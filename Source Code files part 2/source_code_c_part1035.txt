IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    IN va_list * parglist
    )
{
    //
    // get message from system or app msg file.
    //

    DWORD dwReturn = FormatMessage(
                            (dwMsgId >= MSG_FIRST_MESSAGE)
                                    ? FORMAT_MESSAGE_FROM_HMODULE
                                    : FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (0 == dwReturn)   // couldn't find message
    {
        appDebugOut((DEB_IERROR,
                "Formatmessage failed = 0x%08lx\n",
                GetLastError()));

        WCHAR szText[200];
        LoadString(g_hInstance,
                   (dwMsgId >= MSG_FIRST_MESSAGE)
                        ? IDS_APP_MSG_NOT_FOUND
                        : IDS_SYS_MSG_NOT_FOUND,
                   szText,
                   ARRAYLEN(szText));

        wsprintf(pszBuffer,szText,dwMsgId);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   MyFormatMessage
//
//  Synopsis:   Given a resource IDs, load strings from given instance
//              and format the string into a buffer
//
//  History:    11-Aug-93 WilliamW   Created.
//
//--------------------------------------------------------------------------
VOID
MyFormatMessage(
    IN HRESULT   dwMsgId,
    IN PWSTR     pszBuffer,
    IN DWORD     dwBufferSize,
    ...
    )
{
    va_list arglist;

    va_start(arglist, dwBufferSize);
    MyFormatMessageText(dwMsgId, pszBuffer, dwBufferSize, &arglist);
    va_end(arglist);
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  Arguments:
//
//  Returns:
//
//  History:    28-Dec-94   BruceFo   Created
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    if (NULL == psz)
    {
        return NULL;
    }

    PWSTR pszRet = new WCHAR[wcslen(psz) + 1];
    if (NULL == pszRet)
    {
        appDebugOut((DEB_ERROR,"OUT OF MEMORY\n"));
        return NULL;
    }

    wcscpy(pszRet, psz);
    return pszRet;
}



//+---------------------------------------------------------------------------
//
//  Function:   wcsistr
//
//  Synopsis:   Same as wcsstr (find string in string), but case-insensitive
//
//  Arguments:
//
//  Returns:
//
//  History:    2-Feb-95   BruceFo   Created
//
//----------------------------------------------------------------------------

wchar_t*
wcsistr(
    const wchar_t* string1,
    const wchar_t* string2
    )
{
    if ((NULL == string2) || (NULL == string1))
    {
        // do whatever wcsstr would do
        return wcsstr(string1, string2);
    }

    wchar_t* s1dup = NewDup(string1);
    wchar_t* s2dup = NewDup(string2);

    wchar_t* ret = NULL;

    if (NULL != s1dup && NULL != s2dup)
    {
        _wcslwr(s1dup); // lower case everything to make case-insensitive
        _wcslwr(s2dup);
        ret = wcsstr(s1dup, s2dup);
    }

    delete[] s1dup;
    delete[] s2dup;
    return ret;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetResourceString
//
//  Synopsis:   Load a resource string, are return a "new"ed copy
//
//  Arguments:  [dwId] -- a resource string ID
//
//  Returns:    new memory copy of a string
//
//  History:    5-Apr-95    BruceFo Created
//
//----------------------------------------------------------------------------

PWSTR
GetResourceString(
    IN DWORD dwId
    )
{
    WCHAR sz[50];
    if (0 == LoadString(g_hInstance, dwId, sz, ARRAYLEN(sz)))
    {
        return NULL;
    }
    else
    {
        return NewDup(sz);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   IsDfsRoot
//
//  Synopsis:   Determine if the path passed in is a Dfs root, in form only.
//              Namely, does it look like "\\machine-or-domain\share"?
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    18-Apr-96  BruceFo     Created
//
//--------------------------------------------------------------------------
BOOL
IsDfsRoot(
    IN LPWSTR pszRoot
    )
{
    if (NULL != pszRoot
        && pszRoot[0] == L'\\'
        && pszRoot[1] == L'\\'
        && pszRoot[2] != L'\\'	// might be null
        )
    {
        LPWSTR pszTmp = wcschr(pszRoot + 2, L'\\');
        if (pszTmp != NULL)
        {
            if (pszTmp[1] != L'\0'
                && pszTmp[1] != L'\\'
                )
            {
                // ok, we've got "\\xxx\y...."
                // Now make sure it doesn't have a fourth backslash

                pszTmp = wcschr(pszTmp + 2, L'\\');
                if (pszTmp == NULL)
                {
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Function:   IsDfsShare
//
//  Synopsis:   Determine if the given share on the given server is a Dfs
//              share. This actually contacts the machine.
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    18-Apr-96  BruceFo     Created
//
//--------------------------------------------------------------------------
DWORD
IsDfsShare(
    IN LPWSTR pszServer,
    IN LPWSTR pszShare,
    OUT BOOL* pfIsDfs
    )
{
    PSHARE_INFO_1005 pshi1005;
    NET_API_STATUS ret = NetShareGetInfo(pszServer, pszShare, 1005, (LPBYTE*)&pshi1005);
    if (NERR_Success == ret)
    {
        if (pshi1005->shi1005_flags & SHI1005_FLAGS_DFS)
        {
            *pfIsDfs = TRUE;
        }
        else
        {
            appDebugOut((DEB_ITRACE,
                "%ws not a Dfs share\n",
                pszShare));
        }

        NetApiBufferFree(pshi1005);
    }
    else
    {
        // This could be an access denied.

        appDebugOut((DEB_ERROR,
            "NetShareGetInfo(NULL, %ws...) failed, 0x%08lx\n",
            pszShare,
            ret));
    }

    return ret;
}



//+-------------------------------------------------------------------------
//
//  Member:     FindDfsRoot, public
//
//  Synopsis:   Parse a string to find the Dfs root. Returns a pointer to
//
//  History:    22-Apr-96   BruceFo
//
//--------------------------------------------------------------------------

BOOL
FindDfsRoot(
    IN PWSTR pszDfsPath,
    OUT PWSTR pszDfsRoot
    )
{
    PWSTR pszTmp;
    if (NULL != pszDfsPath
        && pszDfsPath[0] == L'\\'
        && pszDfsPath[1] == L'\\'
        && pszDfsPath[2] != L'\\'
        && pszDfsPath[2] != L'\0'
        && (NULL != (pszTmp = wcschr(pszDfsPath + 3, L'\\')))
        && pszTmp[1] != L'\\'
        && pszTmp[1] != L'\0'
        )
    {
        pszTmp = wcschr(pszTmp + 2, L'\\');

        if (NULL != pszTmp)
        {
            // the thing passed in was of the form "\\xxx\yyy\..."
            int len = (int)(pszTmp - pszDfsPath);
            wcsncpy(pszDfsRoot, pszDfsPath, len);
            pszDfsRoot[len] = L'\0';
        }
        else
        {
            // the thing passed in was of the form "\\xxx\yyy"
            wcscpy(pszDfsRoot, pszDfsPath);
        }

        appDebugOut((DEB_IERROR,
            "Dfs root of %ws is %ws\n",
            pszDfsPath, pszDfsRoot));

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

#define MAX_MESSAGE_BUF 8192
#define MAX_ANSI_MESSAGE_BUF (MAX_MESSAGE_BUF * 3)

WCHAR szMsgBuf[MAX_MESSAGE_BUF];
CHAR  szAnsiBuf[MAX_ANSI_MESSAGE_BUF];
VOID
StatusMessage(
    IN HRESULT hr,
    ...
    )
{
    va_list arglist;
    va_start(arglist, hr);
    ULONG written;

    MyFormatMessageText(hr, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);

    va_end(arglist);
}

VOID
ErrorMessage(
    IN HRESULT hr,
    ...
    )
{
    va_list arglist;
    va_start(arglist, hr);
    ULONG written;

    MyFormatMessageText(hr, szMsgBuf, ARRAYLEN(szMsgBuf), &arglist);
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);

    va_end(arglist);
    exit(1);
}

VOID
DfsErrorMessage(
    IN NET_API_STATUS status
    )
{
    ULONG written;

    MyFormatMessage(MSG_ERROR, szMsgBuf, ARRAYLEN(szMsgBuf), status);
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);


	PWSTR pszDll = L"netmsg.dll";

	HINSTANCE hinst = LoadLibrary(pszDll);
	if (NULL == hinst)
	{
    	MyFormatMessage(MSG_NO_MESSAGES, szMsgBuf, ARRAYLEN(szMsgBuf), pszDll);
	}
	else
	{
    	DWORD dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE
								| FORMAT_MESSAGE_IGNORE_INSERTS,
                             hinst,
                             status,
                             LANG_USER_DEFAULT,
                             szMsgBuf,
							 ARRAYLEN(szMsgBuf),
                             NULL);
		FreeLibrary(hinst);

    	if (0 == dwReturn)   // couldn't find message
    	{
			// try system messages
    		dwReturn = FormatMessage(
                             FORMAT_MESSAGE_FROM_SYSTEM
								| FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             status,
                             LANG_USER_DEFAULT,
                             szMsgBuf,
							 ARRAYLEN(szMsgBuf),
                             NULL);
    		if (0 == dwReturn)   // couldn't find message
    		{
    			MyFormatMessage(MSG_ERROR_UNKNOWN, szMsgBuf, ARRAYLEN(szMsgBuf));
    		}
    	}
	}
    written = WideCharToMultiByte(CP_OEMCP, 0,
                szMsgBuf, wcslen(szMsgBuf),
                szAnsiBuf, MAX_ANSI_MESSAGE_BUF,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), szAnsiBuf, written, &written, NULL);

    exit(1);
}

VOID
Usage(
    VOID
    )
{
    ErrorMessage(MSG_USAGE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfscmd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by app.rc
//
#define IDS_APP_MSG_NOT_FOUND           1
#define IDS_SYS_MSG_NOT_FOUND           2
#define IDI_SHARING                     100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfsutil\dfsacl.cxx ===
//-----------------------------------------------------------------------------
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:       dfsacl.c

//  Contents:   Functions to add/remove entries from ACL list(s).
//
//  History:    Nov 6, 1998 JHarper created
//
//-----------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winldap.h>
#include <ntldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <sddl.h>
#include <dfsstr.h>
#include <dfsmrshl.h>
#include <marshal.hxx>
#include <lmdfs.h>
#include <dfspriv.h>
#include <csites.hxx>
#include <dfsm.hxx>
#include <recon.hxx>

#include "dfsacl.hxx"
#include "struct.hxx"

DWORD
ReadDSObjSecDesc(
    PLDAP pLDAP,
    PWSTR pwszObject,
    SECURITY_INFORMATION SeInfo,
    PSECURITY_DESCRIPTOR *ppSD,
    PULONG pcSDSize);

DWORD
DfsGetObjSecurity(
    LDAP *pldap,
    LPWSTR pwszObjectName,
    LPWSTR *pwszStringSD);

DWORD
DfsStampSD(
    PWSTR pwszObject,
    ULONG cSDSize,
    SECURITY_INFORMATION SeInfo,
    PSECURITY_DESCRIPTOR pSD,
    PLDAP pLDAP);

DWORD
DfsAddAce(
    LDAP *pldap,
    LPWSTR wszObjectName,
    LPWSTR wszStringSD,
    LPWSTR wszwszStringSid);

DWORD
DfsRemoveAce(
    LDAP *pldap,
    LPWSTR wszObjectName,
    LPWSTR wszStringSD,
    LPWSTR wszwszStringSid);

BOOL
DfsFindSid(
    LPWSTR DcName,
    LPWSTR Name,
    PSID *Sid);

BOOLEAN
DfsSidInAce(
    LPWSTR wszAce,
    LPWSTR wszStringSid);

#define ACTRL_SD_PROP_NAME  L"nTSecurityDescriptor"

//
// Name of the attribute holding the ACL/ACE list
//

#define ACTRL_SD_PROP_NAME  L"nTSecurityDescriptor"

//
// The sddl description of the ACE we will be adding
//
LPWSTR wszAce = L"(A;;RPWP;;;";

//+---------------------------------------------------------------------------
//
//  Function:   DfsAddMachineAce
//
//  Synopsis:   Adds an ACE representing this machine to the ACL list of the
//              object.
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszDcName]     --  The DC whose DS we are to use.
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [wszRootName]   --  The name of the machine/root we want to add
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
DfsAddMachineAce(
    LDAP *pldap,
    LPWSTR wszDcName,
    LPWSTR wszObjectName,
    LPWSTR wszRootName)
{
    ULONG dwErr = ERROR_SUCCESS;
    PSID Sid;
    BOOL Result;
    ULONG i;
    WCHAR wszNewSD[MAX_PATH];
    LPWSTR wszStringSD = NULL;
    LPWSTR wszStringSid = NULL;
    LPWSTR wszNewRootName = NULL;

    if (fSwDebug != 0)
        MyPrintf(L"DfsAddMachineAce(%ws,%ws)\r\n", wszObjectName, wszRootName);
    //
    // Get Security Descriptor on the FtDfs object
    //
    dwErr = DfsGetObjSecurity(pldap, wszObjectName, &wszStringSD);
    if (dwErr == ERROR_SUCCESS) {
        if (fSwDebug != 0)
            MyPrintf(L"ACL=[%ws]\r\n", wszStringSD);
        wszNewRootName = (LPWSTR)malloc((wcslen(wszRootName) + 2) * sizeof(WCHAR));
        if (wszNewRootName != NULL) {
            wcscpy(wszNewRootName, wszRootName);
            for (i = 0; wszNewRootName[i] != L'\0'; i++) {
                if (wszNewRootName[i] == L'.') {
                    wszNewRootName[i] = L'\0';
                    break;
                }
            }
            wcscat(wszNewRootName, L"$");
            //
            // Get SID representing root machine
            //
            Result = DfsFindSid(wszDcName,wszNewRootName, &Sid);
            if (Result == TRUE) {
                if (fSwDebug != 0)
                    MyPrintf(L"Got SID for %ws\r\n", wszRootName);
                //
                // Convert the machine SID to a string
                //
                Result = ConvertSidToStringSid(Sid, &wszStringSid);
                if (Result == TRUE) {
                    if (fSwDebug != 0)
                        MyPrintf(L"Sid=[%ws]\r\n", wszStringSid);
                    //
                    // Now update the ACL list on the FtDfs object
                    //
                    DfsAddAce(
                            pldap,
                            wszObjectName,
                            wszStringSD,
                            wszStringSid);
                    LocalFree(wszStringSid);
                }
            } else {
                dwErr = ERROR_OBJECT_NOT_FOUND;
            }
            free(wszNewRootName);
        } else {
            dwErr = ERROR_OUTOFMEMORY;
        }
        LocalFree(wszStringSD);
    }
    if (fSwDebug != 0)
        MyPrintf(L"DfsAddMachineAce returning %d\r\n", dwErr);
    return dwErr;

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsRemoveMachineAce
//
//  Synopsis:   Removes an ACE representing this machine from the ACL list of the
//              object.
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszDcName]     --  The DC whose DS we are to use.
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [wszRootName]   --  The name of the machine/root we want to remove
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
DfsRemoveMachineAce(
    LDAP *pldap,
    LPWSTR wszDcName,
    LPWSTR wszObjectName,
    LPWSTR wszRootName)
{
    ULONG dwErr = ERROR_SUCCESS;
    PSID Sid;
    BOOL Result;
    WCHAR wszNewSD[MAX_PATH];
    LPWSTR wszStringSD = NULL;
    LPWSTR wszStringSid = NULL;
    LPWSTR wszNewRootName = NULL;
    ULONG i;

    if (fSwDebug != 0)
        MyPrintf(L"DfsRemoveMachineAce(DC=%ws,DN=\"%ws\",Root=%ws)\r\n",
                    wszDcName,
                    wszObjectName,
                    wszRootName);
    //
    // Get Security Descriptor on the FtDfs object
    //
    dwErr = DfsGetObjSecurity(pldap, wszObjectName, &wszStringSD);
    if (dwErr == ERROR_SUCCESS) {
        if (fSwDebug != 0)
            MyPrintf(L"ACL=[%ws]\r\n", wszStringSD);
        wszNewRootName = (LPWSTR)malloc((wcslen(wszRootName) + 2) * sizeof(WCHAR));
        if (wszNewRootName != NULL) {
            wcscpy(wszNewRootName, wszRootName);
            for (i = 0; wszNewRootName[i] != L'\0'; i++) {
                if (wszNewRootName[i] == L'.') {
                    wszNewRootName[i] = L'\0';
                    break;
                }
            }
            wcscat(wszNewRootName, L"$");
            //
            // Get SID representing root machine
            //
            Result = DfsFindSid(wszDcName,wszNewRootName, &Sid);
            if (Result == TRUE) {
                if (fSwDebug != 0)
                    MyPrintf(L"Got SID for %ws\r\n", wszRootName);
                //
                // Convert the machine SID to a string
                //
                Result = ConvertSidToStringSid(Sid, &wszStringSid);
                if (Result == TRUE) {
                    if (fSwDebug != 0)
                        MyPrintf(L"Sid=[%ws]\r\n", wszStringSid);
                    //
                    // Now update the ACL list on the FtDfs object
                    //
                    DfsRemoveAce(
                            pldap,
                            wszObjectName,
                            wszStringSD,
                            wszStringSid);
                    LocalFree(wszStringSid);
                }
            } else {
                dwErr = ERROR_OBJECT_NOT_FOUND;
            }
            free(wszNewRootName);
        } else {
            dwErr = ERROR_OUTOFMEMORY;
        }
        LocalFree(wszStringSD);
    }
    if (fSwDebug != 0)
        MyPrintf(L"DfsRemoveMachineAce exit %d\r\n", dwErr);
    return dwErr;

}

//+---------------------------------------------------------------------------
//
//  Function:   ReadDSObjSecDesc
//
//  Synopsis:   Reads the security descriptor from the specied object via
//              the open ldap connection
//
//  Arguments:  [pLDAP]         --  The open LDAP connection
//              [pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [SeInfo]        --  Parts of the security descriptor to
//                                      read.
//              [ppSD]          --  Where the security descriptor is
//                                      returned
//              [pcSDSize       -- Size of the security descriptor
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
DWORD
ReadDSObjSecDesc(
    PLDAP pLDAP,
    PWSTR pwszObject,
    SECURITY_INFORMATION SeInfo,
    PSECURITY_DESCRIPTOR *ppSD,
    PULONG pcSDSize)
{
    DWORD dwErr = ERROR_SUCCESS;
    PLDAPMessage pMsg = NULL;
    PWSTR rgAttribs[2];
    BYTE berValue[8];

    LDAPControl SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControl ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    if (fSwDebug != 0)
        MyPrintf(L"ReadDSObjSecDesc(%ws)\r\n", pwszObject);

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);


    rgAttribs[0] = ACTRL_SD_PROP_NAME;
    rgAttribs[1] = NULL;

    dwErr = ldap_search_ext_s(
                    pLDAP,
                    pwszObject,
                    LDAP_SCOPE_BASE,
                    L"(objectClass=*)",
                    rgAttribs,
                    0,
                    (PLDAPControl *)&ServerControls,
                    NULL,
                    NULL,
                    10000,
                    &pMsg);

    dwErr = LdapMapErrorToWin32( dwErr );
    if(dwErr == ERROR_SUCCESS) {

        LDAPMessage *pEntry = NULL;
        PWSTR *ppwszValues = NULL;
        PLDAP_BERVAL *pSize = NULL;

        pEntry = ldap_first_entry(pLDAP, pMsg);
        if(pEntry != NULL) {
            //
            // Now, we'll have to get the values
            //
            ppwszValues = ldap_get_values(pLDAP, pEntry, rgAttribs[0]);
            if(ppwszValues != NULL) {
                pSize = ldap_get_values_len(pLDAP, pMsg, rgAttribs[0]);
                if(pSize != NULL) {
                    //
                    // Allocate the security descriptor to return
                    //
                    *ppSD = (PSECURITY_DESCRIPTOR)malloc((*pSize)->bv_len);
                    if(*ppSD != NULL) {
                        memcpy(*ppSD, (PBYTE)(*pSize)->bv_val, (*pSize)->bv_len);
                        *pcSDSize = (*pSize)->bv_len;
                    } else {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    ldap_value_free_len(pSize);
                } else {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                ldap_value_free(ppwszValues);
            } else {
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
        } else {
            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
        }
        ldap_msgfree(pMsg);

    }
    if (fSwDebug != 0)
        MyPrintf(L"ReadDSObjSecDesc returning %d\r\n", dwErr);
    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsGetObjSecurity
//
//  Synopsis:   Gets the ACL list of an object in sddl stringized form
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [pwszStringSD]  --  Pointer to pointer to SD in string form (sddl)
//
//  Returns:    ERROR_SUCCESS   --  The object is reachable
//
//----------------------------------------------------------------------------
DWORD
DfsGetObjSecurity(
    LDAP *pldap,
    LPWSTR pwszObjectName,
    LPWSTR *pwszStringSD)
{
    DWORD dwErr;
    WCHAR wszObjectName[ MAX_PATH ];
    SECURITY_INFORMATION si;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG cSDSize;

    if (fSwDebug != 0)
        MyPrintf(L"DfsGetObjSecurity(%ws)\r\n",  pwszObjectName);

    si = DACL_SECURITY_INFORMATION;

    dwErr = ReadDSObjSecDesc(
                pldap,
                pwszObjectName,
                si,
                &pSD,
                &cSDSize);

    if (dwErr == ERROR_SUCCESS) {
        if (!ConvertSecurityDescriptorToStringSecurityDescriptor(
                                                            pSD,
                                                            SDDL_REVISION_1,
                                                            DACL_SECURITY_INFORMATION,
                                                            pwszStringSD,
                                                            NULL)
        ) {
            dwErr = GetLastError();
            if (fSwDebug != 0)
                MyPrintf(L"ConvertSecurityDescriptorToStringSecurityDescriptor FAILED %d:\r\n", dwErr);
        }

    }

    return(dwErr);

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsFindSid
//
//  Synopsis:   Gets the SID for a name
//
//              [DcName]  --  The DC to remote to
//              [Name]    --  The Name of the object
//              [Sid]     --  Pointer to pointer to returned SID, which must be freed
//                            using LocalFree
//
//  Returns:    TRUE or FALSE
//
//----------------------------------------------------------------------------
BOOL
DfsFindSid(
    LPWSTR DcName,
    LPWSTR Name,
    PSID *Sid
    )
{
    DWORD SidLength = 0;
    WCHAR DomainName[256];
    DWORD DomainNameLength = 256;
    SID_NAME_USE Use;
    BOOL Result;

    if (fSwDebug != 0)
        MyPrintf(L"DfsFindSid(%ws,%ws)\r\n", DcName,Name);

    Result = LookupAccountName(
                 DcName,
                 Name,
                 (PSID)NULL,
                 &SidLength,
                 DomainName,
                 &DomainNameLength,
                 &Use);

    if ( !Result && (GetLastError() == ERROR_INSUFFICIENT_BUFFER) ) {

        *Sid = LocalAlloc( 0, SidLength );

        Result = LookupAccountName(
                     NULL,
                     Name,
                     *Sid,
                     &SidLength,
                     DomainName,
                     &DomainNameLength,
                     &Use);

    }

    if (fSwDebug != 0)
        MyPrintf(L"DfsFindSid returning %s\r\n", Result == TRUE ? "TRUE" : "FALSE");

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsAddAce
//
//  Synopsis:   Adds a string ACE to a string version of an objects SD
//              object.  This is a string manipulation routine.
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [wszStringSD]   --  String version of SD
//              [wszStringSid]  --  String version of SID to add
//
//  Returns:    ERROR_SUCCESS   --  ACE was added
//
//----------------------------------------------------------------------------
DWORD
DfsAddAce(
    LDAP *pldap,
    LPWSTR wszObjectName,
    LPWSTR wszStringSD,
    LPWSTR wszStringSid)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR wszNewStringSD = NULL;
    SECURITY_INFORMATION si;
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL Result;
    ULONG Size = 0;
    ULONG cSDSize = 0;

    if (fSwDebug != 0)
        MyPrintf(L"DfsAddAce(%ws)\r\n",  wszObjectName);

    Size = wcslen(wszStringSD) * sizeof(WCHAR) +
            wcslen(wszAce) * sizeof(WCHAR) +
                wcslen(wszStringSid) * sizeof(WCHAR) +
                    wcslen(L")") * sizeof(WCHAR) +
                        sizeof(WCHAR);

    wszNewStringSD = (LPWSTR)malloc(Size);

    if (wszNewStringSD != NULL) {
        wcscpy(wszNewStringSD,wszStringSD);
        wcscat(wszNewStringSD,wszAce);
        wcscat(wszNewStringSD,wszStringSid);
        wcscat(wszNewStringSD,L")");
        if (fSwDebug != 0)
            MyPrintf(L"NewSD=[%ws]\r\n", wszNewStringSD);
        Result = ConvertStringSecurityDescriptorToSecurityDescriptor(
                                    wszNewStringSD,
                                    SDDL_REVISION_1,
                                    &pSD,
                                    &cSDSize);
        if (Result == TRUE) {
            si = DACL_SECURITY_INFORMATION;
            dwErr = DfsStampSD(
                        wszObjectName,
                        cSDSize,
                        si,
                        pSD,
                        pldap);
            LocalFree(pSD);
        } else {
            dwErr = GetLastError();
            if (fSwDebug != 0)
                MyPrintf(L"Convert returned %d\r\n", dwErr);
        }
        free(wszNewStringSD);
    } else {
        dwErr = ERROR_OUTOFMEMORY;
    }

    if (fSwDebug != 0)
        MyPrintf(L"DfsAddAce returning %d\r\n", dwErr);
    return(dwErr);

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsRemoveAce
//
//  Synopsis:   Finds and removes a string ACE from the string SD of an
//              object.  This is a string manipulation routine.
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [wszStringSD]   --  String version of SD
//              [wszStringSid]  --  String version of SID to remove
//
//  Returns:    ERROR_SUCCESS  --  ACE was removed or was not present
//
//----------------------------------------------------------------------------
DWORD
DfsRemoveAce(
    LDAP *pldap,
    LPWSTR wszObjectName,
    LPWSTR wszStringSD,
    LPWSTR wszStringSid)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR wszNewStringSD = NULL;
    SECURITY_INFORMATION si;
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL Result;
    ULONG Size = 0;
    ULONG cSDSize = 0;
    BOOLEAN fCopying;
    ULONG s1, s2;

    if (fSwDebug != 0)
        MyPrintf(L"DfsRemoveAce(%ws)\r\n",  wszObjectName);

    Size = wcslen(wszStringSD) * sizeof(WCHAR) + sizeof(WCHAR);

    wszNewStringSD = (LPWSTR)malloc(Size);

    if (wszNewStringSD != NULL) {

        RtlZeroMemory(wszNewStringSD, Size);

        //
        // We have to find the ACEs containing this SID, and remove them.
        //

        fCopying = TRUE;
        for (s1 = s2 = 0; wszStringSD[s1]; s1++) {

            //
            // If this is the start of an ACE that has this SID, stop copying
            //
            if (wszStringSD[s1] == L'(' && DfsSidInAce(&wszStringSD[s1],wszStringSid) == TRUE) {
                fCopying = FALSE;
                continue;
            }

            //
            // If this is the end of SID we are not copying, start copying again
            //
            if (wszStringSD[s1] == L')' && fCopying == FALSE) {
                fCopying = TRUE;
                continue;
            }

            //
            // If we are copying, do so.
            //
            if (fCopying == TRUE)
                wszNewStringSD[s2++] = wszStringSD[s1];
        }

        if (fSwDebug != 0)
            MyPrintf(L"NewSD=[%ws]\r\n", wszNewStringSD);
        Result = ConvertStringSecurityDescriptorToSecurityDescriptor(
                                    wszNewStringSD,
                                    SDDL_REVISION_1,
                                    &pSD,
                                    &cSDSize);
        if (Result == TRUE) {
            si = DACL_SECURITY_INFORMATION;
            dwErr = DfsStampSD(
                        wszObjectName,
                        cSDSize,
                        si,
                        pSD,
                        pldap);
            LocalFree(pSD);
        } else {
            dwErr = GetLastError();
            if (fSwDebug != 0)
                MyPrintf(L"Convert returned %d\r\n", dwErr);
        }
        free(wszNewStringSD);
    } else {
        dwErr = ERROR_OUTOFMEMORY;
    }

    if (fSwDebug != 0)
        MyPrintf(L"DfsRemoveAce returning %d\r\n", dwErr);
    return(dwErr);

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsSidInAce
//
//  Synopsis:   Scans an ACE to see if the string SID is in it.
//
//  Arguments:  [wszAce]         --  ACE to scan
//              [wszStringSid]   --  SID to scan for
//
//  Returns:    TRUE -- SID is in this ACE
//              FALSE -- SID is not in this ACE
//
//----------------------------------------------------------------------------
BOOLEAN
DfsSidInAce(
    LPWSTR wszAce,
    LPWSTR wszStringSid)
{
    ULONG i;
    ULONG SidLen = wcslen(wszStringSid);
    ULONG AceLen;
    WCHAR Oldcp;

    for (AceLen = 0; wszAce[AceLen] && wszAce[AceLen] != L')'; AceLen++)
        /* NOTHING */;

    Oldcp = wszAce[AceLen];
    wszAce[AceLen] = L'\0';
    if (fSwDebug != 0)
        MyPrintf(L"DfsSidInAce(%ws),%ws)\r\n", wszAce, wszStringSid);
    wszAce[AceLen] = Oldcp;

    if (SidLen > AceLen || wszAce[0] != L'(') {
        if (fSwDebug != 0)
            MyPrintf(L"DfsSidInAce returning FALSE(1)\r\n");
        return FALSE;
    }

    for (i = 0; i <= (AceLen - SidLen); i++) {

        if (wszAce[i] == wszStringSid[0] && wcsncmp(&wszAce[i],wszStringSid,SidLen) == 0) {
            if (fSwDebug != 0)
                MyPrintf(L"DfsSidInAce returning TRUE\r\n");
            return TRUE;
        }

    }

    if (fSwDebug != 0)
        MyPrintf(L"DfsSidInAce returning FALSE(2)\r\n");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsStampSD
//
//  Synopsis:   Actually stamps the security descriptor on the object.
//
//  Arguments:  [pwszObject]        --      The object to stamp the SD on
//              [cSDSize]           --      The size of the security descriptor
//              [SeInfo]            --      SecurityInformation about the security
//                                              descriptor
//              [pSD]               --      The SD to stamp
//              [pLDAP]             --      The LDAP connection to use
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
DfsStampSD(
    PWSTR pwszObject,
    ULONG cSDSize,
    SECURITY_INFORMATION SeInfo,
    PSECURITY_DESCRIPTOR pSD,
    PLDAP pLDAP)
{
    DWORD dwErr = ERROR_SUCCESS;
    PLDAPMod rgMods[2];
    PLDAP_BERVAL pBVals[2];
    LDAPMod Mod;
    LDAP_BERVAL BVal;
    BYTE ControlBuffer[ 5 ];

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) &ControlBuffer
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    if (fSwDebug != 0)
        MyPrintf(L"DfsStampSD(%ws,%d)\r\n", pwszObject, cSDSize);

    ASSERT(*(PULONG)pSD > 0xF );

    ControlBuffer[0] = 0x30;
    ControlBuffer[1] = 0x3;
    ControlBuffer[2] = 0x02;    // Denotes an integer;
    ControlBuffer[3] = 0x01;    // Size
    ControlBuffer[4] = (BYTE)((ULONG)SeInfo & 0xF);

    ASSERT(IsValidSecurityDescriptor( pSD ) );

    rgMods[0] = &Mod;
    rgMods[1] = NULL;

    pBVals[0] = &BVal;
    pBVals[1] = NULL;

    BVal.bv_len = cSDSize;
    BVal.bv_val = (PCHAR)pSD;

    Mod.mod_op      = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Mod.mod_type    = ACTRL_SD_PROP_NAME;
    Mod.mod_values  = (PWSTR *)pBVals;

    //
    // Now, we'll do the write...
    //
    dwErr = ldap_modify_ext_s(pLDAP,
                              pwszObject,
                              rgMods,
                              (PLDAPControl *)&ServerControls,
                              NULL);

    dwErr = LdapMapErrorToWin32(dwErr);

    if (fSwDebug != 0)
        MyPrintf(L"DfsStampSD returning %d\r\n", dwErr);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfsutil\fileio.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       infile.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsstr.h>
#include <dfsmrshl.h>
#include <marshal.hxx>
#include <lmdfs.h>
#include <dfspriv.h>
#include <csites.hxx>
#include <dfsm.hxx>
#include <recon.hxx>
#include <rpc.h>
#include "struct.hxx"
#include "ftsup.hxx"
#include "stdsup.hxx"
#include "rootsup.hxx"
#include "misc.hxx"
#include "messages.h"
#include "fileio.hxx"

//
// These are extensions for perf/scalability
//  Undoc'd for now, only apply when scripting
//
FMAKEARG(AddRoot);
FMAKEARG(RemRoot);
FMAKEARG(Share);
FMAKEARG(Server);
FMAKEARG(Link);
FMAKEARG(Site);
FMAKEARG(ShortPrefix);
FMAKEARG(Add);
FMAKEARG(State);
FMAKEARG(Type);
FMAKEARG(Guid);
FMAKEARG(Timeout);
FMAKEARG(Comment)
FMAKEARG(Load);
FMAKEARG(Save);
FMAKEARG(DcName);

FSWITCH(Map);
FSWITCH(UnMap);
FSWITCH(Mod);

LPWSTR pgDfsName = NULL;
LPWSTR pgDcName = NULL;
LPWSTR pgLink = NULL;
LPWSTR pgSite = NULL;
LPWSTR pgShortLink = NULL;
LPWSTR pgTimeout = NULL;
LPWSTR pgState = NULL;
LPWSTR pgType = NULL;
LPWSTR pgGuid = NULL;
LPWSTR pgComment = NULL;
LPWSTR pgAddArg = NULL;
LPWSTR pgDomDfsName = NULL;
LPWSTR pgServerName = NULL;
LPWSTR pgShareName = NULL;

#define UNICODE_COMMENT_CHAR L'/'

//
// Protos
//

DWORD
CmdLoad(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pDfsName,
    LPWSTR pDcName);

DWORD
CmdSave(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pDfsName,
    LPWSTR pDcName);

DWORD
CmdLinkMap(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pLink,
    LPWSTR pShortLink,
    LPWSTR pComment,
    LPWSTR pTimeout,
    LPWSTR pState,
    LPWSTR pType,
    LPWSTR pGUID,
    ULONG LineNum);

DWORD
CmdLink(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pLink,
    ULONG LineNum);

DWORD
CmdLinkMod(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pLink,
    LPWSTR pgShortLink,
    LPWSTR pComment,
    LPWSTR pTimeout,
    LPWSTR pState,
    LPWSTR pType,
    LPWSTR pGUID,
    ULONG LineNum);

DWORD
CmdLinkUnmap(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pLink,
    ULONG LineNum);

DWORD
CmdAdd(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pLink,
    LPWSTR pAltName,
    LPWSTR pState,
    LPWSTR Type,
    ULONG LineNum);

BOOLEAN
CmdProcessInfileArg(
    LPWSTR Arg);

DWORD
DfspBreakName(
    LPWSTR pPath,
    LPWSTR *ppServerName,
    LPWSTR *ppShareName);

DWORD
DfspDomLoad(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pDomName,
    LPWSTR pDfsName,
    LPWSTR pDcName);

DWORD
DfspStdLoad(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServerName,
    LPWSTR pShareName,
    LPWSTR pDcName);

DWORD
DfspDomSave(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pDomName,
    LPWSTR pDfsName,
    LPWSTR pDcName);

DWORD
DfspStdSave(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServerName,
    LPWSTR pShareName);

DWORD
CmdSite(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServer,
    ULONG LineNum);

DWORD
CmdSiteMap(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServer,
    ULONG LineNum);

DWORD
CmdAddSiteToServer(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServer,
    LPWSTR pSite,
    ULONG LineNum);

DWORD
CmdSiteUnmap(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServer,
    ULONG LineNum);

VOID
DfspExportFile(
    HANDLE pHandle,
    PDFS_VOLUME_LIST pDfsVolList);

#define INIT_LINK_COUNT 8
#define INIT_ALT_COUNT 2

//
// The one that gets it all going - use a file
//

DWORD
CmdImport(
    LPWSTR pInfile)
{
    DWORD dwErr = ERROR_SUCCESS;
    DFS_VOLUME_LIST DfsVolList = { 0 };
    PDFS_VOLUME_LIST pDfsVolList = &DfsVolList;
    LONG i;
    FILE *fp;
    WCHAR InBuf[1026];
    LPWSTR *argvw;
    PWCHAR wCp;
    ULONG LineNum = 1;
    int argcw;
    int argx;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdImport(%ws)\r\n", pInfile);

    fp = _wfopen(pInfile, L"r");
    if (fp == NULL) {
        if (fSwDebug == TRUE)
            MyPrintf(L"Can not open %ws for read.\r\n", pInfile);
        dwErr = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    while (fgetws(InBuf, sizeof(InBuf)/sizeof(WCHAR), fp) != NULL) {
        // Remove trailing CR/LF
        for (wCp = InBuf; *wCp != L'\0'; wCp++) {
            if (*wCp == L'\r' || *wCp == L'\n')
                *wCp = L'\0';
        }
        // Strip off comments (indicated by a // )
        for (wCp = InBuf; *wCp != L'\0'; wCp++)
            if (wCp > InBuf && *wCp == UNICODE_COMMENT_CHAR && *(wCp-1) == UNICODE_COMMENT_CHAR) {
                *(wCp-1) = L'\0';
                break;
            }
        // Remove trailing spaces and tabs
        while (wCp != InBuf && (*wCp == L' ' || *wCp == L'\t'))
                *wCp-- = L'\0';
        // Remove leading spaces and tabs
        for (wCp = InBuf; *wCp != L'\0' && (*wCp == L' ' || *wCp == L'\t'); wCp++)
            NOTHING;
        if (fSwDebug == TRUE)
            MyPrintf(L"%d:[%ws]\r\n", LineNum, wCp);
        if (wcslen(wCp) == 0) {
            LineNum++;
            continue;
        }
        argvw = CommandLineToArgvW(wCp, &argcw);
        fArgAddRoot = FALSE;
        fArgRemRoot = FALSE;
        fArgLoad = FALSE;
        fArgLink = FALSE;
        fArgSite = FALSE;
        fArgAdd = FALSE;
        fSwMap = FALSE;
        fSwUnMap = FALSE;
        fSwMod = FALSE;
        pgShortLink = NULL;
        pgTimeout = NULL;
        pgState = NULL;
        pgType = NULL;
        pgGuid = NULL;
        pgComment = NULL;
        pgAddArg = NULL;
        pgDomDfsName = NULL;
        pgServerName = NULL;
        for (argx = 0; argx < argcw; argx++) {
            if (fSwDebug == TRUE)
                MyPrintf(L"%d: [%ws]\r\n", argx, argvw[argx]);
            if (CmdProcessInfileArg(argvw[argx]) != TRUE) {
                dwErr = ERROR_INVALID_PARAMETER;
                MyPrintf(L"Unrecognized parameter in line %d\r\n", LineNum);
            }
        }
        if (fSwDebug == TRUE) {
            MyPrintf(L"DfsName=%ws\r\n", pgDfsName);
            MyPrintf(L"DcName=%ws\r\n", pgDcName);
            MyPrintf(L"Link=%ws\r\n", pgLink);
            MyPrintf(L"ShortLink=%ws\r\n", pgShortLink);
            MyPrintf(L"Site=%ws\r\n", pgSite);
            MyPrintf(L"Timeout=%ws\r\n", pgTimeout);
            MyPrintf(L"State=%ws\r\n", pgState);
            MyPrintf(L"Type=%ws\r\n", pgType);
            MyPrintf(L"Guid=%ws\r\n", pgGuid);
            MyPrintf(L"Comment=%ws\r\n", pgComment);
            MyPrintf(L"AddArg=%ws\r\n", pgAddArg);
        }

        //
        // Do the work
        //
        if (fArgLoad == TRUE) {
            dwErr = CmdLoad(
                        pDfsVolList,
                        pgDfsName,
                        pgDcName);
        } else if (fArgLink == TRUE) {
            if (fSwMap == TRUE) {
                dwErr = CmdLinkMap(
                            pDfsVolList,
                            pgLink,
                            pgShortLink,
                            pgComment,
                            pgTimeout,
                            pgState,
                            pgType,
                            pgGuid,
                            LineNum);
            } else if (fSwMod == TRUE) {
                dwErr = CmdLinkMod(
                            pDfsVolList,
                            pgLink,
                            pgShortLink,
                            pgComment,
                            pgTimeout,
                            pgState,
                            pgType,
                            pgGuid,
                            LineNum);
            } else if (fSwUnMap == TRUE) {
                dwErr = CmdLinkUnmap(
                            pDfsVolList,
                            pgLink,
                            LineNum);
            } else {
                dwErr = CmdLink(
                            pDfsVolList,
                            pgLink,
                            LineNum);
            }
        } else if (fArgSite == TRUE) {
            if (fSwMap == TRUE) {
                dwErr = CmdSiteMap(
                            pDfsVolList,
                            pgSite,
                            LineNum);
            } else if (fSwUnMap == TRUE) {
                dwErr = CmdSiteUnmap(
                            pDfsVolList,
                            pgSite,
                            LineNum);
            } else {
                dwErr = CmdSite(
                            pDfsVolList,
                            pgSite,
                            LineNum);
            }
        } else if (fArgAdd == TRUE) {
            if (pgLink != NULL) {
                dwErr = CmdAdd(
                        pDfsVolList,
                        pgLink,
                        pgAddArg,
                        pgState,
                        pgType,
                        LineNum);
             } else if (pgSite != NULL) {
                dwErr = CmdAddSiteToServer(
                            pDfsVolList,
                            pgSite,
                            pgAddArg,
                            LineNum);
             }
        } else if (fArgSave == TRUE) {
            dwErr = CmdSave(
                        pDfsVolList,
                        pgDfsName,
                        pgDcName);
        } else if (fArgAddRoot == TRUE) {
            dwErr = CmdAddRoot(
                        pgDomDfsName,
                        pgServerName,
                        pgShareName,
                        pgComment);
        } else if (fArgRemRoot == TRUE) {
            dwErr = CmdRemRoot(
                        pgDomDfsName,
                        pgServerName,
                        pgShareName);
        } else {
            MyPrintf(L"Missing command in line %d\r\n", LineNum);
        }

        if(dwErr != ERROR_SUCCESS) {
            MyPrintf(L"Import: Error %d processing line %d.\r\n", dwErr, LineNum);
            goto Cleanup;
        }
        LineNum++;
    }

Cleanup:

    // DfsViewVolList(pDfsVolList, 1);

    if (fSwDebug == TRUE)
       DfsDumpVolList(pDfsVolList);

    //
    // Free our vol list
    //

    DfsFreeVolList(pDfsVolList);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdImport exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdLoad(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pDfsName,
    LPWSTR pDcName)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR pServerName = NULL;
    LPWSTR pShareName = NULL;
    BOOLEAN IsDomainName = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLoad(%ws,%ws)\r\n", pDfsName, pDcName);

    if (pDfsName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    dwErr = DfspParseName(
                pDfsName,
                &pServerName,
                &pShareName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = DfspIsDomainName(
                pServerName,
                pDcName,
                &IsDomainName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (IsDomainName == TRUE) {
        dwErr = DfspDomLoad(
                    pDfsVolList,
                    pServerName,
                    pShareName,
                    pDcName);
    } else {
        dwErr = DfspStdLoad(
                    pDfsVolList,
                    pServerName,
                    pShareName,
                    pDcName);
    }

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // The link list may not be sorted - do so now.
    //

    DfspSortVolList(pDfsVolList);

Cleanup:

    if (pServerName != NULL)
        free(pServerName);
    if (pShareName != NULL)
        free(pShareName);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLoad returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
DfspDomLoad(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pDomName,
    LPWSTR pDfsName,
    LPWSTR pDcName)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDomLoad(%ws,%ws,%ws)\r\n", pDomName, pDfsName, pDcName);

    MyPrintf(L"\\\\%ws\\%ws is a DomDfs\r\n", pDomName, pDfsName);

    dwErr = DfsGetFtVol(
                pDfsVolList,
                pDfsName,
                pDcName,
                pDomName,
                NULL);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (fSwDebug == TRUE)
        DfsDumpVolList(pDfsVolList);

Cleanup:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDomLoad returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
DfspStdLoad(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServerName,
    LPWSTR pShareName,
    LPWSTR pDcName)
{
    ULONG i;
    DWORD dwErr = ERROR_SUCCESS;
    BOOLEAN IsFtRoot = FALSE;
    WCHAR RootShare[MAX_PATH+1];
    WCHAR DomDfsName[MAX_PATH+1];
    LPWSTR pDomDfsName = NULL;
    DWORD cbName = sizeof(DomDfsName);
    DWORD dwType;
    HKEY hKey = NULL;
    HKEY rKey = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdStdLoad(%ws,%ws,%ws)\r\n", pServerName, pShareName, pDcName);

    ErrorMessage(MSG_CONNECTING, pServerName);

    //
    // See if this is a Fault-Tolerant Dfs vs Server-Based Dfs
    //

    dwErr = RegConnectRegistry(
                    pServerName,
                    HKEY_LOCAL_MACHINE,
                    &rKey);

    if (dwErr != ERROR_SUCCESS) {
        ErrorMessage(MSG_CAN_NOT_CONNECT, pServerName);
        goto Cleanup;
    }

    dwErr = RegOpenKey(rKey, VOLUMES_DIR, &hKey);

    if (dwErr == ERROR_SUCCESS) {
        dwErr = RegQueryValueEx(
            hKey,
            FTDFS_VALUE_NAME,
            NULL,
            &dwType,
            (PBYTE) DomDfsName,
            &cbName);

        if (dwErr == ERROR_MORE_DATA)
            dwErr = ERROR_SUCCESS;

        if (dwErr == ERROR_SUCCESS && dwType == REG_SZ)
            IsFtRoot = TRUE;

    } else {
        MyPrintf(L"Not a Dfs root\r\n");
        goto Cleanup;
    }

    dwErr = RegQueryValueEx(
                hKey,
                ROOT_SHARE_VALUE_NAME,
                NULL,
                &dwType,
                (PBYTE) RootShare,
                &cbName);

    if (dwErr == ERROR_MORE_DATA)
        dwErr = ERROR_SUCCESS;

    if (dwErr != ERROR_SUCCESS || dwType != REG_SZ) {
        MyPrintf(L"Registry value \"RootShare\" is missing or corrupt.\r\n");
        goto Cleanup;
    }

    if (IsFtRoot == TRUE) {
        if (fSwDebug == TRUE)
            MyPrintf(L"Registry says is DomDfs (%ws)...\r\n", DomDfsName);
        if (pDomDfsName == NULL) {
            pDomDfsName = DomDfsName;
        } else {
            if (fSwDebug == TRUE)
                MyPrintf(L"You specified to check against %ws\r\n", pDomDfsName);
        }

        dwErr = DfsGetFtVol(
                    pDfsVolList,
                    pDomDfsName,
                    pDcName,
                    NULL,
                    NULL);

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;

        dwErr = GetExitPtInfo(
                    rKey,
                    &pDfsVolList->pRootLocalVol,
                    &pDfsVolList->cRootLocalVol);

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;

    } else {

        if (fSwDebug == TRUE)
            MyPrintf(L"Is StdDfs...\r\n");

        dwErr = DfsGetStdVol(
                    rKey,
                    pDfsVolList);

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;

        dwErr = GetExitPtInfo(
                    rKey,
                    &pDfsVolList->pRootLocalVol,
                    &pDfsVolList->cRootLocalVol);

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;
    }

    if (fSwDebug == TRUE)
        DfsDumpVolList(pDfsVolList);

Cleanup:

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (rKey != NULL)
        RegCloseKey(rKey);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdStdLoad returning %d\r\n", dwErr);

    return dwErr;

}

DWORD
CmdSave(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pDfsName,
    LPWSTR pDcName)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR pServerName = NULL;
    LPWSTR pShareName = NULL;
    BOOLEAN IsDomainName = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSave(%ws,%ws)\r\n", pDfsName, pDcName);

    if (pDfsName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    dwErr = DfspParseName(
                pDfsName,
                &pServerName,
                &pShareName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = DfspIsDomainName(
                pServerName,
                pDcName,
                &IsDomainName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (IsDomainName == TRUE) {
        dwErr = DfspDomSave(
                    pDfsVolList,
                    pServerName,
                    pShareName,
                    pDcName);
    } else {
        dwErr = DfspStdSave(
                    pDfsVolList,
                    pServerName,
                    pShareName);
    }

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

Cleanup:
    if (pServerName != NULL)
        free(pServerName);
    if (pShareName != NULL)
        free(pShareName);
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSave returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
DfspDomSave(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pDomName,
    LPWSTR pDfsName,
    LPWSTR pDcName)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG cbBlob = 0;
    BYTE *pBlob = NULL;
    WCHAR wszDcName[MAX_PATH+1];

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDomSave(%ws,%ws,%ws)\r\n", pDomName, pDfsName, pDcName);

    MyPrintf(L"CmdDomSave(%ws,%ws,%ws)\r\n", pDomName, pDfsName, pDcName);

    MyPrintf(L"\\\\%ws\\%ws is a DomDfs\r\n", pDomName, pDfsName);

    if (pDcName == NULL)
        dwErr = DfspGetPdc(wszDcName, pDomName);
    else
        wcscpy(wszDcName, pDcName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    ErrorMessage(MSG_CONNECTING, wszDcName);

    //
    // Serialize
    //
    dwErr = DfsPutVolList(
                &cbBlob,
                &pBlob,
                pDfsVolList);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Update the DS
    //
    dwErr = DfsPutDsBlob(
                pDfsName,
                DfsConfigContainer,
                wszDcName,
                NULL,
                cbBlob,
                pBlob,
                pDfsVolList->RootServers);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    MyPrintf(L"you need to reinit the dfs service on all roots of %ws\r\n", pDfsName);

    #if 0
    dwErr = NetDfsManagerInitialize(pServerName, 0);
    #endif

Cleanup:
    if (pBlob != NULL)
        free(pBlob);
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDomSave returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
DfspStdSave(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServerName,
    LPWSTR pShareName)
{
    ULONG i;
    DWORD dwErr = ERROR_SUCCESS;
    BOOLEAN IsFtRoot = FALSE;
    WCHAR RootShare[MAX_PATH+1];
    WCHAR DomDfsName[MAX_PATH+1];
    LPWSTR pDomDfsName = NULL;
    DWORD cbName = sizeof(DomDfsName);
    DWORD dwType;
    HKEY hKey = NULL;
    HKEY rKey = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdStdSave(%ws,%ws)\r\n", pServerName, pShareName);

    MyPrintf(L"Writing metadata to %ws\n", pServerName);

    //
    // Verify that this is a Server-based Dfs
    //

    dwErr = RegConnectRegistry(
                    pServerName,
                    HKEY_LOCAL_MACHINE,
                    &rKey);

    if (dwErr != ERROR_SUCCESS) {
        ErrorMessage(MSG_CAN_NOT_CONNECT, pServerName);
        goto Cleanup;
    }

    dwErr = RegOpenKey(rKey, VOLUMES_DIR, &hKey);

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"Not a Dfs root\r\n");
        goto Cleanup;
    }

    dwErr = RegQueryValueEx(
        hKey,
        FTDFS_VALUE_NAME,
        NULL,
        &dwType,
        (PBYTE) DomDfsName,
        &cbName);

    if (dwErr == ERROR_MORE_DATA)
        dwErr = ERROR_SUCCESS;

    if (dwErr == ERROR_SUCCESS && dwType == REG_SZ)
        IsFtRoot = TRUE;

    dwErr = RegQueryValueEx(
                hKey,
                ROOT_SHARE_VALUE_NAME,
                NULL,
                &dwType,
                (PBYTE) RootShare,
                &cbName);

    if (dwErr == ERROR_MORE_DATA)
        dwErr = ERROR_SUCCESS;

    if (dwErr != ERROR_SUCCESS || dwType != REG_SZ) {
        MyPrintf(L"Registry value \"RootShare\" is missing or corrupt.\r\n");
        goto Cleanup;
    }

    if (IsFtRoot == TRUE) {
        if (fSwDebug == TRUE)
            MyPrintf(L"Internal error: Registry says is DomDfs (%ws)...\r\n", DomDfsName);
        dwErr = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    dwErr = DfsSetStdVol(
                rKey,
                pDfsVolList);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    MyPrintf(L"Reinitializing dfs service on %ws\n", pServerName);
    dwErr = NetDfsManagerInitialize(pServerName, 0);

Cleanup:
    if (hKey != NULL)
        RegCloseKey(hKey);
    if (rKey != NULL)
        RegCloseKey(rKey);
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdStdSave returning %d\r\n", dwErr);
    return dwErr;

}

DWORD
CmdLinkMap(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pLink,
    LPWSTR pShortLink,
    LPWSTR pComment,
    LPWSTR pTimeout,
    LPWSTR pState,
    LPWSTR pType,
    LPWSTR pGUID,
    ULONG LineNum)
{
    DWORD dwErr = ERROR_SUCCESS;
    LONG Min;
    LONG Max;
    LONG Res;
    PDFS_VOLUME pVol = NULL;
    PVOID pVoid = NULL;
    LONG Cur = -1;
    LONG i;
    ULONG Size;
    LPWSTR pPrefix = NULL;
    LPWSTR pShortPrefix = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLinkMap(%ws,%ws,%ws,%ws,%ws,%ws,%ws,%d)\r\n",
                    pLink,
                    pShortLink,
                    pComment,
                    pTimeout,
                    pState,
                    pType,
                    pGUID,
                    LineNum);

    //
    // Trim leading \'s
    //

    while (*pLink == UNICODE_PATH_SEP)
        pLink++;

    //
    // If no short prefix is given, use the long prefix
    //

    if (pShortLink == NULL)
        pShortLink = pLink;


    if(pDfsVolList == NULL){
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    if(pDfsVolList->Volumes == NULL){
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    
    //
    // Build full prefix and shortprefix names
    //

    Size = wcslen(pDfsVolList->Volumes[0]->wszPrefix) * sizeof(WCHAR) +
                sizeof(WCHAR) +
                    wcslen(pLink) * sizeof(WCHAR) +
                        sizeof(WCHAR);

    pPrefix = (LPWSTR) malloc(Size);
    if (pPrefix == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    Size = wcslen(pDfsVolList->Volumes[0]->wszShortPrefix) * sizeof(WCHAR) +
                sizeof(WCHAR) +
                    wcslen(pShortLink) * sizeof(WCHAR) +
                        sizeof(WCHAR);

    pShortPrefix = (LPWSTR) malloc(Size);
    if (pShortPrefix == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    wcscpy(pPrefix, pDfsVolList->Volumes[0]->wszPrefix);
    wcscat(pPrefix, UNICODE_PATH_SEP_STR);
    wcscat(pPrefix, pLink);
    wcscpy(pShortPrefix, pDfsVolList->Volumes[0]->wszShortPrefix);
    wcscat(pShortPrefix, UNICODE_PATH_SEP_STR);
    wcscat(pShortPrefix, pShortLink);

    //
    // See if this link is already there.  Binary Search.
    //

    if (pDfsVolList->VolCount > 0) {

        Min = 0;
        Max = pDfsVolList->VolCount-1;
        while (Min <= Max) {
            Cur = (Min + Max) / 2;
            Res = _wcsicmp(pDfsVolList->Volumes[Cur]->wszPrefix, pPrefix);
            if (Res == 0) {
                // we skip it, it is ok.
                //dwErr = ERROR_DUP_NAME;
                MyPrintf(L"MAP line %d: duplicate link %ws (skipped)\r\n", LineNum, pPrefix);
                goto Cleanup;
            } else if (Res < 0) {
                Min = Cur + 1;
            } else {
                Max = Cur - 1;
            }
        }
    }

    //
    // Expand the list if necessary
    //

    if (pDfsVolList->VolCount >= pDfsVolList->AllocatedVolCount) {
        pVoid = realloc(
                    pDfsVolList->Volumes,
                    (pDfsVolList->AllocatedVolCount + INIT_LINK_COUNT) * sizeof(PDFS_VOLUME));
        if (pVoid == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        pDfsVolList->Volumes = (PDFS_VOLUME *) pVoid;
        RtlZeroMemory(
              &pDfsVolList->Volumes[pDfsVolList->AllocatedVolCount],
              INIT_LINK_COUNT * sizeof(PDFS_VOLUME));
        pDfsVolList->AllocatedVolCount += INIT_LINK_COUNT;
        if (fSwDebug == TRUE)
            MyPrintf(L"CmdLinkMap:realloced to %d\r\n", pDfsVolList->AllocatedVolCount);
    }

    if ((pDfsVolList->VolCount % 1000) == 0)
        MyPrintf(L"%d\r\n", pDfsVolList->VolCount);

    if (Cur == -1)
        Cur = 0;
    else if (Res < 0)
        Cur++;

    if (Cur < (LONG)pDfsVolList->VolCount) {
        RtlMoveMemory(
                &pDfsVolList->Volumes[Cur+1],
                &pDfsVolList->Volumes[Cur],
                sizeof(PDFS_VOLUME) * (pDfsVolList->VolCount-(ULONG)Cur));
    }

    //
    // Add the new
    //
    pDfsVolList->Volumes[Cur] = (PDFS_VOLUME) malloc(sizeof(DFS_VOLUME));
    if (pDfsVolList->Volumes[Cur] == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pDfsVolList->Volumes[Cur], sizeof(DFS_VOLUME));
    pVol = pDfsVolList->Volumes[Cur];
    pVol->wszPrefix = pPrefix;
    pPrefix = NULL;
    pVol->wszShortPrefix = pShortPrefix;
    pVol->vFlags |= VFLAGS_MODIFY;
    pShortPrefix = NULL;
    if (pComment != NULL) {
        pVol->wszComment = (PWCHAR)malloc((wcslen(pComment)+1) * sizeof(WCHAR));
        if (pVol->wszComment == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        wcscpy(pVol->wszComment, pComment);
    }
    if (pGUID != NULL && wcslen(pGUID) == (sizeof(GUID) * 2))
        StringToGuid(pGUID, &pVol->idVolume);
    else {
        dwErr = UuidCreate(&pVol->idVolume);
        if(dwErr !=  RPC_S_OK) {
            goto Cleanup;
        }
    }
    pVol->wszObjectName = (PWCHAR)malloc(92);
    if (pVol->wszObjectName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pVol->wszObjectName, 92);
    wcscpy(pVol->wszObjectName, L"\\domainroot\\");
    GuidToStringEx(&pVol->idVolume, &pVol->wszObjectName[12]);
    if (pType != NULL) {
        if (pType[0] == L'0' && (pType[1] == L'x' || pType[1] == L'X'))
            pVol->dwType = AtoHex(pType, &dwErr);
        else 
            pVol->dwType = AtoDec(pType, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"bad value %ws\r\n", pType);
            goto Cleanup;
        }
    } else {
        pVol->dwType = 0x1;
    }
    if (pState != NULL) {
        if (pState[0] == L'0' && (pState[1] == L'x' || pState[1] == L'X'))
            pVol->dwState = AtoHex(pState, &dwErr);
        else 
            pVol->dwState = AtoDec(pState, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"bad value %ws\r\n", pState);
            goto Cleanup;
        }
    } else {
        pVol->dwState = 0x1;
    }
    if (pTimeout != NULL) {
        if (pTimeout[0] == L'0' && (pTimeout[1] == L'x' || pTimeout[1] == L'X'))
            pVol->dwTimeout = AtoHex(pTimeout, &dwErr);
        else 
            pVol->dwTimeout = AtoDec(pTimeout, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"bad value %ws\r\n", pTimeout);
            goto Cleanup;
        }
    } else {
        pVol->dwTimeout = 300;
    }
    pVol->dwVersion = 3;
    pVol->ReplCount = 0;
    pVol->AllocatedReplCount = 0;
    pVol->vFlags |= VFLAGS_MODIFY;
    pDfsVolList->VolCount++;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLinkMap exit %d\r\n", dwErr);

    return dwErr;

Cleanup:

    //
    // We had a problem. Clean up and return the error
    //

    if (pVol != NULL) {
        if (pVol->wszObjectName != NULL)
            free(pVol->wszObjectName);
        if (pVol->wszPrefix != NULL)
            free(pVol->wszPrefix);
        if (pVol->wszShortPrefix != NULL)
            free(pVol->wszShortPrefix);
        if (pVol->wszComment != NULL)
            free(pVol->wszComment);
        RtlZeroMemory(pVol, sizeof(DFS_VOLUME));
    }

    if (pPrefix != NULL)
        free(pPrefix);
    if (pShortPrefix != NULL)
        free(pShortPrefix);

    free(pgLink);
    pgLink = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLinkMap exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdLink(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pLink,
    ULONG LineNum)
{
    DWORD dwErr = ERROR_NOT_FOUND;
    LONG Min;
    LONG Max;
    LONG Res;
    LONG Cur = -1;
    LONG i;
    ULONG Size;
    LPWSTR pPrefix = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLink(%ws,%d)\r\n",
                    pLink,
                    LineNum);

    //
    // Trim leading \'s
    //

    while (*pLink == UNICODE_PATH_SEP)
        pLink++;

    //
    // Build full prefix and shortprefix names
    //

    Size = wcslen(pDfsVolList->Volumes[0]->wszPrefix) * sizeof(WCHAR) +
                sizeof(WCHAR) +
                    wcslen(pLink) * sizeof(WCHAR) +
                        sizeof(WCHAR);

    pPrefix = (LPWSTR) malloc(Size);
    if (pPrefix == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto AllDone;
    }
    wcscpy(pPrefix, pDfsVolList->Volumes[0]->wszPrefix);
    wcscat(pPrefix, UNICODE_PATH_SEP_STR);
    wcscat(pPrefix, pLink);

    //
    // See if this link is there.  Binary Search.
    //

    if (pDfsVolList->VolCount > 0) {

        Min = 0;
        Max = pDfsVolList->VolCount-1;
        while (Min <= Max) {
            Cur = (Min + Max) / 2;
            Res = _wcsicmp(pDfsVolList->Volumes[Cur]->wszPrefix, pPrefix);
            if (Res == 0) {
                dwErr = ERROR_SUCCESS;
                goto AllDone;
            } else if (Res < 0) {
                Min = Cur + 1;
            } else {
                Max = Cur - 1;
            }
        }
    }

    if (dwErr == ERROR_NOT_FOUND) 
        MyPrintf(L"LINK line %d: link %ws not found (skipped)\r\n", LineNum, pLink);

AllDone:

    if (pPrefix != NULL)
        free(pPrefix);

    if (dwErr != ERROR_SUCCESS) {
        free(pgLink);
        pgLink = NULL;
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLink exit %d\r\n", dwErr);

    return dwErr;

}

DWORD
CmdLinkUnmap(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pLink,
    ULONG LineNum)
{
    DWORD dwErr = ERROR_NOT_FOUND;
    LONG Min;
    LONG Max;
    LONG Res;
    PDFS_VOLUME pVol = NULL;
    LONG Cur = 0;
    LONG i;
    ULONG Size;
    PWCHAR wCp;
    BOOLEAN fPrefixAllocated = FALSE;
    LPWSTR pPrefix = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLinkUnmap(%ws,%d)\r\n",
                    pLink,
                    LineNum);

    //
    // Allow two ways to specify a link
    //   relative (no leading \\)
    //   or absolute (leading \\)
    //

    //
    // Trim extra leading \'s
    //

    while (*pLink == UNICODE_PATH_SEP && *(pLink+1) == UNICODE_PATH_SEP)
        pLink++;

    if (*pLink == UNICODE_PATH_SEP) {
        if (*pLink == UNICODE_PATH_SEP && *(pLink+1) == UNICODE_PATH_SEP)
            pLink++;
        pPrefix = pLink;
    } else {
        //
        // Build full prefix name
        //

        Size = wcslen(pDfsVolList->Volumes[0]->wszPrefix) * sizeof(WCHAR) +
                    sizeof(WCHAR) +
                        wcslen(pLink) * sizeof(WCHAR) +
                            sizeof(WCHAR);

        pPrefix = (LPWSTR) malloc(Size);
        if (pPrefix == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        wcscpy(pPrefix, pDfsVolList->Volumes[0]->wszPrefix);
        wcscat(pPrefix, UNICODE_PATH_SEP_STR);
        wcscat(pPrefix, pLink);
        fPrefixAllocated = TRUE;
    }

    //
    // See if this link is there.  Binary Search.
    //

    if (pDfsVolList->VolCount > 0) {

        Min = 0;
        Max = pDfsVolList->VolCount-1;
        while (Min <= Max) {
            Cur = (Min + Max) / 2;
            Res = _wcsicmp(pDfsVolList->Volumes[Cur]->wszPrefix, pPrefix);
            if (Res == 0) {
                dwErr = ERROR_SUCCESS;
                break;
            } else if (Res < 0) {
                Min = Cur + 1;
            } else {
                Max = Cur - 1;
            }
        }
    }

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"UNMAP line %d: link %ws not found (skipped)\r\n", LineNum, pLink);
        goto Cleanup;
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"Found match at %d\r\n", Cur);

    pVol = pDfsVolList->Volumes[Cur];

    if (pDfsVolList->DfsType == STDDFS) {
        pVol->vFlags |= VFLAGS_DELETE;
    } else if (pDfsVolList->DfsType == DOMDFS) {
        DfsFreeVol(pDfsVolList->Volumes[Cur]);
        free(pDfsVolList->Volumes[Cur]);
        RtlMoveMemory(
                &pDfsVolList->Volumes[Cur],
                &pDfsVolList->Volumes[Cur+1],
                sizeof(PDFS_VOLUME) * (pDfsVolList->VolCount-((ULONG)Cur)-1));
        pDfsVolList->VolCount--;
        pDfsVolList->Volumes[pDfsVolList->VolCount] = NULL;
    }

Cleanup:

    if (pPrefix != NULL && fPrefixAllocated == TRUE)
        free(pPrefix);

    if (dwErr != ERROR_SUCCESS) {
        free(pgLink);
        pgLink = NULL;
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLinkUnmap exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdLinkMod(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pLink,
    LPWSTR pShortLink,
    LPWSTR pComment,
    LPWSTR pTimeout,
    LPWSTR pState,
    LPWSTR pType,
    LPWSTR pGUID,
    ULONG LineNum)
{
    DWORD dwErr = ERROR_NOT_FOUND;
    LONG Min;
    LONG Max;
    LONG Res;
    PDFS_VOLUME pVol = NULL;
    LONG Cur = 0;
    LONG i;
    ULONG Size;
    PWCHAR wCp;
    BOOLEAN fPrefixAllocated = FALSE;
    LPWSTR pPrefix = NULL;
    LPWSTR pShortPrefix = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLinkMod(%ws,%ws,%ws,%ws,%ws,%ws,%ws,%d)\r\n",
                    pLink,
                    pShortLink,
                    pComment,
                    pTimeout,
                    pState,
                    pType,
                    pGUID,
                    LineNum);

    //
    // Allow two ways to specify a link
    //   relative (no leading \\)
    //   or absolute (leading \\)
    //

    //
    // Trim extra leading \'s
    //

    while (*pLink == UNICODE_PATH_SEP && *(pLink+1) == UNICODE_PATH_SEP)
        pLink++;

    if (*pLink == UNICODE_PATH_SEP) {
        if (*pLink == UNICODE_PATH_SEP && *(pLink+1) == UNICODE_PATH_SEP)
            pLink++;
        pPrefix = pLink;
    } else {
        //
        // Build full prefix name
        //

        Size = wcslen(pDfsVolList->Volumes[0]->wszPrefix) * sizeof(WCHAR) +
                    sizeof(WCHAR) +
                        wcslen(pLink) * sizeof(WCHAR) +
                            sizeof(WCHAR);

        pPrefix = (LPWSTR) malloc(Size);
        if (pPrefix == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        wcscpy(pPrefix, pDfsVolList->Volumes[0]->wszPrefix);
        wcscat(pPrefix, UNICODE_PATH_SEP_STR);
        wcscat(pPrefix, pLink);
        fPrefixAllocated = TRUE;
    }

    //
    // See if this link is there.  Binary Search.
    //

    if (pDfsVolList->VolCount > 0) {

        Min = 0;
        Max = pDfsVolList->VolCount-1;
        while (Min <= Max) {
            Cur = (Min + Max) / 2;
            Res = _wcsicmp(pDfsVolList->Volumes[Cur]->wszPrefix, pPrefix);
            if (Res == 0) {
                dwErr = ERROR_SUCCESS;
                break;
            } else if (Res < 0) {
                Min = Cur + 1;
            } else {
                Max = Cur - 1;
            }
        }
    }

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"MOD line %d: link %ws not found (skipped)\r\n", LineNum, pLink);
        goto Cleanup;
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"Found match at %d\r\n", Cur);

    pVol = pDfsVolList->Volumes[Cur];

    if (pShortLink != NULL) {
        while (*pShortLink == UNICODE_PATH_SEP)
            pShortLink++;
        Size = wcslen(pDfsVolList->Volumes[0]->wszShortPrefix) * sizeof(WCHAR) +
                    sizeof(WCHAR) +
                        wcslen(pShortLink) * sizeof(WCHAR) +
                            sizeof(WCHAR);
        wCp = (LPWSTR) malloc(Size);
        if (wCp == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        wcscpy(wCp, pDfsVolList->Volumes[0]->wszShortPrefix);
        wcscat(wCp, UNICODE_PATH_SEP_STR);
        wcscat(wCp, pShortLink);
        if (pVol->wszShortPrefix != NULL)
            free(pVol->wszShortPrefix);
        pVol->wszShortPrefix = wCp;
    }
    if (pComment != NULL) {
        wCp = (PWCHAR)malloc((wcslen(pComment)+1) * sizeof(WCHAR));
        if (wCp == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        if (pVol->wszComment != NULL)
            free(pVol->wszComment);
        pVol->wszComment = wCp;
        wcscpy(pVol->wszComment, pComment);
    }
    if (pGUID != NULL && wcslen(pGUID) == (sizeof(GUID) * 2))
        StringToGuid(pGUID, &pVol->idVolume);
    if (pType != NULL) {
        if (pType[0] == L'0' && (pType[1] == L'x' || pType[1] == L'X'))
            pVol->dwType = AtoHex(pType, &dwErr);
        else 
            pVol->dwType = AtoDec(pType, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"bad value %ws\r\n", pType);
            goto Cleanup;
        }
    }
    if (pState != NULL) {
        if (pState[0] == L'0' && (pState[1] == L'x' || pState[1] == L'X'))
            pVol->dwState = AtoHex(pState, &dwErr);
        else 
            pVol->dwState = AtoDec(pState, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"bad value %ws\r\n", pState);
            goto Cleanup;
        }
    }
    if (pTimeout != NULL) {
        if (pTimeout[0] == L'0' && (pTimeout[1] == L'x' || pTimeout[1] == L'X'))
            pVol->dwTimeout = AtoHex(pTimeout, &dwErr);
        else 
            pVol->dwTimeout = AtoDec(pTimeout, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"bad value %ws\r\n", pTimeout);
            goto Cleanup;
        }
    }
    pVol->vFlags |= VFLAGS_MODIFY;

Cleanup:

    if (pPrefix != NULL && fPrefixAllocated == TRUE)
        free(pPrefix);
    if (pShortPrefix != NULL)
        free(pShortPrefix);

    if (dwErr != ERROR_SUCCESS) {
        free(pgLink);
        pgLink = NULL;
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdLinkMod exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdAdd(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pLink,
    LPWSTR pAltName,
    LPWSTR pState,
    LPWSTR pType,
    ULONG LineNum)
{
    DWORD dwErr = ERROR_NOT_FOUND;
    LONG Min;
    LONG Max;
    LONG Res;
    PDFS_VOLUME pVol = NULL;
    DFS_REPLICA_INFO *pReplInfo;
    LONG Cur = 0;
    PVOID pVoid;
    LPWSTR pPrefix = NULL;
    ULONG Size;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdAdd(%ws,%ws,%ws,%ws,%d)\r\n",
                pLink,
                pAltName,
                pState,
                pType,
                LineNum);

    if (pLink == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        MyPrintf(L"ADD line %d: No link specified (skipped)\r\n", LineNum);
        goto Cleanup;
    }

    //
    // Trim leading \'s
    //

    while (*pLink == UNICODE_PATH_SEP)
        pLink++;

    //
    // Build full prefix name
    //

    Size = wcslen(pDfsVolList->Volumes[0]->wszPrefix) * sizeof(WCHAR) +
                sizeof(WCHAR) +
                    wcslen(pLink) * sizeof(WCHAR) +
                        sizeof(WCHAR);

    pPrefix = (LPWSTR) malloc(Size);
    if (pPrefix == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    wcscpy(pPrefix, pDfsVolList->Volumes[0]->wszPrefix);
    wcscat(pPrefix, UNICODE_PATH_SEP_STR);
    wcscat(pPrefix, pLink);

    //
    // See if this link is there.  Binary Search.
    //

    if (pDfsVolList->VolCount > 0) {

        Min = 0;
        Max = pDfsVolList->VolCount-1;
        while (Min <= Max) {
            Cur = (Min + Max) / 2;
            Res = _wcsicmp(pDfsVolList->Volumes[Cur]->wszPrefix, pPrefix);
            if (Res == 0) {
                dwErr = ERROR_SUCCESS;
                break;
            } else if (Res < 0) {
                Min = Cur + 1;
            } else {
                Max = Cur - 1;
            }
        }
    }

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"ADD line %d: link %ws not found (skipped)\r\n", LineNum, pPrefix);
        goto Cleanup;
    }

    pVol = pDfsVolList->Volumes[Cur];

    if (fSwDebug == TRUE)
        MyPrintf(L"Found match at %d\r\n", Cur);

    if (pVol->ReplCount == 0) {
        pVol->ReplicaInfo = (DFS_REPLICA_INFO *) malloc( INIT_ALT_COUNT * sizeof(DFS_REPLICA_INFO));
        if (pVol->ReplicaInfo == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(pVol->ReplicaInfo, INIT_ALT_COUNT * sizeof(DFS_REPLICA_INFO));
        pVol->ReplCount = 0;
        pVol->AllocatedReplCount = INIT_ALT_COUNT;
    }

    if (pVol->ReplCount >= (pVol->AllocatedReplCount-1)) {
        pVoid = realloc(
                    pVol->ReplicaInfo,
                    (pVol->AllocatedReplCount + INIT_ALT_COUNT) * sizeof(DFS_REPLICA_INFO));
        if (pVoid == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        pVol->ReplicaInfo = (DFS_REPLICA_INFO *) pVoid;
        RtlZeroMemory(
            &pVol->ReplicaInfo[pVol->ReplCount],
            INIT_ALT_COUNT * sizeof(DFS_REPLICA_INFO));
        pVol->AllocatedReplCount += INIT_ALT_COUNT;
    }

    pReplInfo = &pVol->ReplicaInfo[pVol->ReplCount];

    dwErr =  DfspBreakName(
                    pAltName,
                    &pReplInfo->pwszServerName,
                    &pReplInfo->pwszShareName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (pState != NULL) {
        if (pState[0] == L'0' && (pState[1] == L'x' || pState[1] == L'X'))
            pReplInfo->ulReplicaState = AtoHex(pState, &dwErr);
        else 
            pReplInfo->ulReplicaState = AtoDec(pState, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"bad value %ws\r\n", pState);
            goto Cleanup;
        }
    } else {
        pReplInfo->ulReplicaState = 0x2;
    }
    if (pType != NULL) {
        if (pType[0] == L'0' && (pType[1] == L'x' || pType[1] == L'X'))
            pReplInfo->ulReplicaType = AtoHex(pType, &dwErr);
        else 
            pReplInfo->ulReplicaType = AtoDec(pType, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"bad value %ws\r\n", pType);
            goto Cleanup;
        }
    } else {
        pReplInfo->ulReplicaType = 0x2;
    }

    pVol->ReplCount++;
    pVol->vFlags |= VFLAGS_MODIFY;

Cleanup:

    if (pPrefix != NULL)
        free(pPrefix);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdAdd exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdSiteMap(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServer,
    ULONG LineNum)
{
    DWORD dwErr = ERROR_SUCCESS;
    PDFSM_SITE_ENTRY pSiteEntry = NULL;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    LONG Res;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSiteMap(%ws)\r\n", pServer);

   //
   // See if this server is already in the site table
   //

    pListHead = &pDfsVolList->SiteList;
    if (pListHead->Flink != NULL) {
        for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
            pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
            Res = _wcsicmp(pSiteEntry->ServerName, pServer);
            if (Res == 0) {
                pSiteEntry = NULL;
                // we skip, it is ok.
                //dwErr = ERROR_DUP_NAME;
                MyPrintf(L"ADDSITE line %d: duplicate site %ws (skipped)\r\n", LineNum, pServer);
                pgSite = NULL;
                goto AllDone;
            }
        }
    }

    //
    // Not a dup - create a new one
    //
    pSiteEntry = (PDFSM_SITE_ENTRY) malloc(sizeof(DFSM_SITE_ENTRY));
    if (pSiteEntry == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto AllDone;
    }

    RtlZeroMemory(pSiteEntry, sizeof(DFSM_SITE_ENTRY));
    dwErr = DupString(&pSiteEntry->ServerName, pServer);
    if (dwErr != ERROR_SUCCESS)
        goto AllDone;

    //
    // Link it in
    //
    InsertHeadList(&pDfsVolList->SiteList, &pSiteEntry->Link);
    pDfsVolList->SiteCount++;
    pDfsVolList->sFlags |= VFLAGS_MODIFY;

    //
    // Indicate that we are done with the pSiteEntry
    //
    pSiteEntry = NULL;

AllDone:

    if (pSiteEntry != NULL) {
        if (pSiteEntry->ServerName != NULL)
            free(pSiteEntry->ServerName);
        free(pSiteEntry);
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSiteMap exit %d\n", dwErr);

    return dwErr;
}

DWORD
CmdSite(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServer,
    ULONG LineNum)
{
    DWORD dwErr = ERROR_NOT_FOUND;
    PDFSM_SITE_ENTRY pSiteEntry = NULL;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    LONG Res;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSite(%ws)\r\n", pServer);

   //
   // See if this server is in the site table
   //

    pListHead = &pDfsVolList->SiteList;
    if (pListHead->Flink != NULL) {
        for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
            pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
            Res = _wcsicmp(pSiteEntry->ServerName, pServer);
            if (Res == 0) {
                dwErr = ERROR_SUCCESS;
                break;
            }
        }
    }

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"SITE line %d: link %ws not found (skipped)\r\n", LineNum, pServer);
        free(pgSite);
        pgSite = NULL;
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSite exit %d\n", dwErr);

    return dwErr;
}

DWORD
CmdAddSiteToServer(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServer,
    LPWSTR pSite,
    ULONG LineNum)
{
    DWORD dwErr = ERROR_NOT_FOUND;
    PDFSM_SITE_ENTRY pSiteEntry = NULL;
    PDFSM_SITE_ENTRY pSiteEntryNew = NULL;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    ULONG cSites;
    ULONG Size;
    LONG Res;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdAddSiteToServer(%ws,%ws)\r\n", pServer, pSite);

    if (pDfsVolList == NULL || pSite == NULL || pServer == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    //
    // See if this server is in the site table
    //
    pListHead = &pDfsVolList->SiteList;
    if (pListHead->Flink != NULL) {
        for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
            pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
            Res = _wcsicmp(pSiteEntry->ServerName, pServer);
            if (Res == 0) {
                dwErr = ERROR_SUCCESS;
                break;
            }
        }
    }
    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"ADD line %d: Server %ws not found (skipped)\r\n", LineNum, pServer);
        free(pgSite);
        pgSite = NULL;
        goto Cleanup;
    }
    //
    // Check if site already in the list
    //
    for (cSites = 0; cSites < pSiteEntry->Info.cSites; cSites++) {
        Res = _wcsicmp(pSiteEntry->Info.Site[cSites].SiteName, pSite);
        if (Res == 0) {
            //we skip, it is okay.
            //dwErr = ERROR_DUP_NAME;
            MyPrintf(L"ADD line %d: Site %ws: duplicate (skipped)\r\n", LineNum, pSite);
            pSiteEntry = NULL;
            goto Cleanup;
        }
    }
    cSites = pSiteEntry->Info.cSites + 1;
    Size = sizeof(DFSM_SITE_ENTRY) + cSites * sizeof(DFS_SITENAME_INFO);
    pSiteEntryNew = (PDFSM_SITE_ENTRY) malloc(Size);
    if (pSiteEntryNew == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pSiteEntryNew, Size);
    RtlMoveMemory(pSiteEntryNew, pSiteEntry, Size - sizeof(DFS_SITENAME_INFO));
    //
    // Add the new site to the end
    //
    pSiteEntryNew->Info.Site[cSites-1].SiteFlags = 0;
    dwErr = DupString(&pSiteEntryNew->Info.Site[cSites-1].SiteName, pSite);
    if (dwErr != ERROR_SUCCESS) {
        pSiteEntry = NULL;
        goto Cleanup;
    }
    pSiteEntryNew->Info.cSites++;
    RemoveEntryList(&pSiteEntry->Link);
    InsertHeadList(&pDfsVolList->SiteList, &pSiteEntryNew->Link);
    pSiteEntryNew = NULL;
Cleanup:
    if (pSiteEntryNew != NULL)
        free(pSiteEntryNew);
    if (pSiteEntry != NULL)
        free(pSiteEntry);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdAddSiteToServer exit %d\n", dwErr);

    return dwErr;
}

DWORD
CmdSiteUnmap(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR pServer,
    ULONG LineNum)
{
    DWORD dwErr = ERROR_NOT_FOUND;
    PDFSM_SITE_ENTRY pSiteEntry = NULL;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    LONG Res;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSiteUnnap(%ws)\r\n", pServer);

   //
   // See if this server is already in the site table
   //

    pListHead = &pDfsVolList->SiteList;
    if (pListHead->Flink != NULL) {
        for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
            pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
            Res = _wcsicmp(pSiteEntry->ServerName, pServer);
            if (Res == 0) {
               RemoveEntryList(&pSiteEntry->Link);
               pDfsVolList->SiteCount--;
               pDfsVolList->sFlags |= VFLAGS_MODIFY;
               dwErr = ERROR_SUCCESS;
               goto AllDone;
            }
        }
    }

    pSiteEntry = NULL;
    MyPrintf(L"UNMAP line %d: server %ws not found (skipped)\r\n", LineNum, pServer);

AllDone:

    if (pSiteEntry != NULL) {
        if (pSiteEntry->ServerName != NULL)
            free(pSiteEntry->ServerName);
        free(pSiteEntry);
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSiteUnmap exit %d\n", dwErr);

    return dwErr;
}

DWORD
DfspBreakName(
    LPWSTR pPath,
    LPWSTR *ppServerName,
    LPWSTR *ppShareName)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR pServerName = NULL;
    LPWSTR pShareName = NULL;
    WCHAR *wCp1 = NULL;
    WCHAR *wCp2 = NULL;
    ULONG Len = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspBreakName(%ws)\r\n", pPath);

    wCp1 = pPath;

    while (*wCp1 == UNICODE_PATH_SEP && *wCp1 != UNICODE_NULL)
        wCp1++;

    if (*wCp1 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    wCp2 = wCp1;
    while (*wCp2 != UNICODE_PATH_SEP && *wCp2 != UNICODE_NULL)
        wCp2++;

    if (*wCp2 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    Len = (ULONG)((wCp2 - wCp1) * sizeof(WCHAR));
    pServerName = (LPWSTR)malloc(Len + sizeof(WCHAR));
    if (pServerName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pServerName,Len+sizeof(WCHAR));
    RtlCopyMemory(pServerName, wCp1, Len);

    wCp1 = wCp2;

    while (*wCp1 == UNICODE_PATH_SEP && *wCp1 != UNICODE_NULL)
        wCp1++;

    if (*wCp1 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    wCp2 = wCp1;
    while (*wCp2 != UNICODE_NULL)
        wCp2++;

    Len = (ULONG)((wCp2 - wCp1) * sizeof(WCHAR));
    pShareName = (LPWSTR)malloc(Len + sizeof(WCHAR));
    if (pShareName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pShareName,Len+sizeof(WCHAR));
    RtlCopyMemory(pShareName, wCp1, Len);

    *ppServerName = pServerName;
    *ppShareName = pShareName;

Cleanup:

    if (dwErr != ERROR_SUCCESS) {
        if (pServerName != NULL)
            free(pServerName);
        if (pShareName != NULL)
            free(pShareName);
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspBreakName returning %d\r\n", dwErr);

    return dwErr;
}

BOOLEAN
CmdProcessInfileArg(LPWSTR Arg)
{
    LONG ArgLen;
    BOOLEAN dwErr = FALSE;
    BOOLEAN FoundAnArg = FALSE;
    BOOLEAN FoundASwitch = FALSE;
    PWCHAR wCp = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessInfileArg(%ws)\r\n", Arg);

    if ( Arg != NULL && wcslen(Arg) > 1) {

        dwErr = TRUE;
        ArgLen = wcslen(Arg);

        if (_wcsnicmp(Arg, ArgLink, ArgLenLink) == 0) {
            FoundAnArg = fArgLink = TRUE;
            if (ArgLen > ArgLenLink) {
                DupString(&pgLink, &Arg[ArgLenLink]);
                DupString(&pgSite, NULL);
            }
        } else if (_wcsnicmp(Arg, ArgSite, ArgLenSite) == 0) {
            FoundAnArg = fArgSite = TRUE;
            if (ArgLen > ArgLenSite) {
                DupString(&pgSite, &Arg[ArgLenSite]);
                DupString(&pgLink, NULL);
            }
        } else if (_wcsnicmp(Arg, ArgShortPrefix, ArgLenShortPrefix) == 0) {
            FoundAnArg = fArgShortPrefix = TRUE;
            if (ArgLen > ArgLenShortPrefix)
                pgShortLink = &Arg[ArgLenShortPrefix];
        } else if (_wcsnicmp(Arg, ArgTimeout, ArgLenTimeout) == 0) {
            FoundAnArg = fArgTimeout = TRUE;
            if (ArgLen > ArgLenTimeout)
                pgTimeout = &Arg[ArgLenTimeout];
        } else if (_wcsnicmp(Arg, ArgType, ArgLenType) == 0) {
            FoundAnArg = fArgType = TRUE;
            if (ArgLen > ArgLenType)
                pgType = &Arg[ArgLenType];
        } else if (_wcsnicmp(Arg, ArgState, ArgLenState) == 0) {
            FoundAnArg = fArgState = TRUE;
            if (ArgLen > ArgLenState)
                pgState = &Arg[ArgLenState];
        } else if (_wcsnicmp(Arg, ArgComment, ArgLenComment) == 0) {
            FoundAnArg = fArgComment = TRUE;
            if (ArgLen > ArgLenComment)
                pgComment = &Arg[ArgLenComment];
        } else if (_wcsnicmp(Arg, ArgAdd, ArgLenAdd) == 0) {
            FoundAnArg = fArgAdd = TRUE;
            if (ArgLen > ArgLenAdd)
                pgAddArg = &Arg[ArgLenAdd];
        } else if (_wcsnicmp(Arg, ArgGuid, ArgLenGuid) == 0) {
            FoundAnArg = fArgGuid = TRUE;
            if (ArgLen > ArgLenGuid)
                pgGuid = &Arg[ArgLenGuid];
        } else if (_wcsnicmp(Arg, ArgDcName, ArgLenDcName) == 0) {
            FoundAnArg = fArgDcName = TRUE;
            if (ArgLen > ArgLenDcName)
                DupString(&pgDcName, &Arg[ArgLenDcName]);
        } else if (_wcsnicmp(Arg, ArgLoad, ArgLenLoad) == 0) {
            FoundAnArg = fArgLoad = TRUE;
            if (ArgLen > ArgLenLoad)
                DupString(&pgDfsName, &Arg[ArgLenLoad]);
        } else if (_wcsnicmp(Arg, ArgSave, ArgLenSave) == 0) {
            FoundAnArg = fArgSave = TRUE;
            if (ArgLen > ArgLenSave)
                DupString(&pgDfsName, &Arg[ArgLenSave]);
        } else if (_wcsnicmp(Arg, ArgAddRoot, ArgLenAddRoot) == 0) {
            FoundAnArg = fArgAddRoot = TRUE;
            if (ArgLen > ArgLenAddRoot)
                pgDomDfsName = &Arg[ArgLenAddRoot];
        } else if (_wcsnicmp(Arg, ArgRemRoot, ArgLenRemRoot) == 0) {
            FoundAnArg = fArgRemRoot = TRUE;
            if (ArgLen > ArgLenRemRoot)
                pgDomDfsName = &Arg[ArgLenRemRoot];
        } else if (_wcsnicmp(Arg, ArgServer, ArgLenServer) == 0) {
            FoundAnArg = fArgServer = TRUE;
            if (ArgLen > ArgLenServer)
                pgServerName = &Arg[ArgLenServer];
        } else if (_wcsnicmp(Arg, ArgShare, ArgLenShare) == 0) {
            FoundAnArg = fArgShare = TRUE;
            if (ArgLen > ArgLenShare)
                pgShareName = &Arg[ArgLenShare];
        }

        if (_wcsicmp(Arg, SwMap) == 0) {
            FoundASwitch = fSwMap = TRUE;
        } else if (_wcsicmp(Arg, SwUnMap) == 0) {
            FoundASwitch = fSwUnMap = TRUE;
        } else if (_wcsicmp(Arg, SwMod) == 0) {
            FoundASwitch = fSwMod = TRUE;
        }

        if (FoundAnArg == FALSE && FoundASwitch == FALSE) {
            ErrorMessage(MSG_UNRECOGNIZED_OPTION, Arg);
            dwErr = FALSE;
            goto AllDone;
        }

    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessInfileArg exit %d\r\n", dwErr);

    return dwErr;
}

int _cdecl
DfspVolCompare(
    const void *p1,
    const void *p2)
{
    PDFS_VOLUME pVol1 = *((PDFS_VOLUME *) p1);
    PDFS_VOLUME pVol2 = *((PDFS_VOLUME *) p2);
    return _wcsicmp(pVol1->wszPrefix, pVol2->wszPrefix);
}

VOID
DfspSortVolList(
    PDFS_VOLUME_LIST pDfsVolList)
{
    ULONG i;
    PDFS_VOLUME *pVols = pDfsVolList->Volumes;

    if (pDfsVolList->VolCount < 2)
        return;

    for (i = 0; i < pDfsVolList->VolCount-1; i++) {
        if (_wcsicmp(pVols[i]->wszPrefix, pVols[i+1]->wszPrefix) > 0) {
            qsort(pVols, pDfsVolList->VolCount, sizeof(PDFS_VOLUME), DfspVolCompare);
            break;
        }
    }
}

DWORD
DupString(
    LPWSTR *wCpp,
    LPWSTR s)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (*wCpp != NULL) {
        free(*wCpp);
        *wCpp = NULL;
    }
    if (s == NULL || wcslen(s) == 0)
        goto Cleanup;
    *wCpp = (LPWSTR)malloc((wcslen(s)+1) * sizeof(WCHAR));
    if (*wCpp == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    wcscpy(*wCpp, s);

Cleanup:
    return dwErr;
}

DWORD
CmdExport(
    LPWSTR pOutfile,
    LPWSTR pDomDfsName,
    LPWSTR pDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent)
{
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DFS_VOLUME_LIST DfsVolList = { 0 };
    PDFS_VOLUME_LIST pDfsVolList = &DfsVolList;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdExport(%ws,%ws,%ws)\r\n", pOutfile, pDomDfsName, pDcName);

    hFile = CreateFile(
                pOutfile,
                GENERIC_WRITE,
                0,
                0,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        dwErr =  GetLastError();
        goto Cleanup;
    }

    dwErr = CmdLoad(
                pDfsVolList,
                pDomDfsName,
                pDcName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if(pDfsVolList != NULL) {
        if (pDfsVolList->RootServers != NULL) {
            // pDomDfSName is \\Dfs\Share, we just want Share
            LPWSTR pDfsName = pDomDfsName;
            for(int i=0; i<3 && pDfsName; pDfsName++){
                if(*pDfsName == UNICODE_PATH_SEP)
                    i++;
            }
            MyFPrintf(hFile, L"// uncomment the addroot lines if\r\n");
            MyFPrintf(hFile, L"// you want the script to create the root\r\n");
            for (ULONG cRoot = 0; pDfsVolList->RootServers[cRoot+1] != NULL; cRoot++) {
                LPWSTR pServer, pShare, pStr;
                // we start with \\server\share, need to split in two.
                
                // grab the share part
                pShare = pDfsVolList->RootServers[cRoot]; 
                for(int i=0; i<3 && pShare; pShare++){
                    if(*pShare == UNICODE_PATH_SEP)
                        i++;
                }

                // for the server we need to copy it...
                pServer = (LPWSTR) malloc(wcslen(pDfsVolList->RootServers[cRoot]) 
                                 * sizeof(WCHAR));
                if(pServer == NULL) {
                    dwErr = ERROR_OUTOFMEMORY;
                    goto Cleanup;
                }
                wcscpy(pServer, pDfsVolList->RootServers[cRoot]);
                pStr = pServer;
                for(int i=0; i<3 && pStr; pStr++){
                    if(*pStr == UNICODE_PATH_SEP)
                        i++;
                }
                *(--pStr) = '\0'; // replace the '\' in server\share with '\0'
              
                MyFPrintf(hFile, L"// ADDROOT:%ws SERVER:%ws SHARE:%ws\r\n",
                          pDfsName,
                          pServer+2,// remove leading "\\"
                          pShare);
                if(pServer)
                    free(pServer);
            }
        }
    }
    
    MyFPrintf(hFile, L"// Load the dfs information\r\n");
    MyFPrintf(hFile, L"LOAD:%ws ", pDomDfsName);
    if (pDcName != NULL)
        MyFPrintf(hFile, L"DCNAME:%ws\r\n", pDcName);
    MyFPrintf(hFile, L"\r\n");
    MyFPrintf(hFile, L"\r\n");

    DfspExportFile(hFile, pDfsVolList);

    MyFPrintf(hFile, L"// Save the dfs information\r\n");
    MyFPrintf(hFile, L"SAVE:\r\n");
    MyFPrintf(hFile, L"\r\n");

Cleanup:

    if (hFile != INVALID_HANDLE_VALUE) {
        FlushFileBuffers(hFile);
        CloseHandle(hFile);
    }

    DfsFreeVolList(pDfsVolList);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdExport exit %d\r\n", dwErr);

     return dwErr;
}

VOID
DfspExportFile(
    HANDLE hHandle,
    PDFS_VOLUME_LIST pDfsVolList)
{
    ULONG cVol;
    ULONG cRepl;
    ULONG cSite;
    ULONG i;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    PDFSM_SITE_ENTRY pSiteEntry;
    WCHAR wszGuid[sizeof(GUID) * sizeof(WCHAR) + sizeof(WCHAR)];

    DfspSortVolList(pDfsVolList);

    MyFPrintf(hHandle, L"// Link Information\r\n");

    for (cVol = 1; cVol < pDfsVolList->VolCount; cVol++) {
        PWCHAR pPrefix = NULL;
        PWCHAR pShortPrefix = NULL;

        for (pPrefix = &pDfsVolList->Volumes[cVol]->wszPrefix[0];
                pPrefix && *pPrefix != UNICODE_PATH_SEP;
                    pPrefix++)
            NOTHING;
        // if we stopped here we would have dfsname\dfsshare\link
        // we want just link.
        if(pPrefix)
            pPrefix++;
        while(pPrefix && *pPrefix != UNICODE_PATH_SEP)
            pPrefix++;
        // do it twice
        if(pPrefix)
            pPrefix++;
        while(pPrefix && *pPrefix != UNICODE_PATH_SEP)
            pPrefix++;
        for (pShortPrefix = &pDfsVolList->Volumes[cVol]->wszShortPrefix[0];
                pShortPrefix && *pShortPrefix != UNICODE_PATH_SEP;
                    pShortPrefix++)
            NOTHING;
        // if we stopped here we would have dfsname\dfsshare\link
        // we want just link.
        if(pShortPrefix)
            pShortPrefix++;
        while(pShortPrefix && *pShortPrefix != UNICODE_PATH_SEP)
            pShortPrefix++;
        // do it twice
        if(pShortPrefix)
            pShortPrefix++;
        while(pShortPrefix && *pShortPrefix != UNICODE_PATH_SEP)
            pShortPrefix++;
        if(pPrefix)
            pPrefix++;
        if(pShortPrefix)
            pShortPrefix++;
        
        MyFPrintf(hHandle, L"LINK:%ws /MAP ", pPrefix);
        if (_wcsicmp(pPrefix, pShortPrefix) != 0)
            MyFPrintf(hHandle, L"SHORTPREFIX:%ws ", pShortPrefix);
        MyFPrintf(
            hHandle,
            L"GUID:%ws ", GuidToStringEx(&pDfsVolList->Volumes[cVol]->idVolume,
            wszGuid));
        if (pDfsVolList->Volumes[cVol]->dwState != 0x1)
            MyFPrintf(hHandle, L"STATE:0x%x ", pDfsVolList->Volumes[cVol]->dwState);
        if (pDfsVolList->Volumes[cVol]->dwType != 0x1)
            MyFPrintf(hHandle, L"TYPE:0x%x ", pDfsVolList->Volumes[cVol]->dwState);
        if (pDfsVolList->Volumes[cVol]->dwTimeout != 300)
            MyFPrintf(hHandle, L"TIMEOUT:%d ", pDfsVolList->Volumes[cVol]->dwTimeout);
        if (
            pDfsVolList->Volumes[cVol]->wszComment != NULL
                &&
            wcslen(pDfsVolList->Volumes[cVol]->wszComment) > 0
        )
            MyFPrintf(hHandle, L"COMMENT:\"%ws\"", pDfsVolList->Volumes[cVol]->wszComment);
        MyFPrintf(hHandle, L"\r\n");

        for (cRepl = 0; cRepl < pDfsVolList->Volumes[cVol]->ReplCount; cRepl++) {
            MyFPrintf(hHandle, L"    ADD:\\\\%ws\\%ws ",
                pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].pwszServerName,
                pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].pwszShareName);
            if (pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].ulReplicaState != 0x2)
                MyFPrintf(
                    hHandle,
                    L"STATE:0x%x ",
                    pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].ulReplicaState);
            if (pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].ulReplicaType != 0x2)
                MyFPrintf(
                    hHandle,
                    L"TYPE:0x%x\r\n",
                    pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].ulReplicaType);
            MyFPrintf(hHandle, L"\r\n");
        }
        MyFPrintf(hHandle, L"\r\n");
    }
    pListHead = &pDfsVolList->SiteList;
    if (pListHead->Flink != NULL) {
        MyFPrintf(hHandle, L"// Site Information\r\n");
        MyFPrintf(hHandle, L"\r\n");
        for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
            pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
            MyFPrintf(hHandle, L"SITE:%ws /MAP \r\n", pSiteEntry->ServerName);
            for (i = 0; i < pSiteEntry->Info.cSites; i++) {
                MyFPrintf(hHandle, L"    ADD:%ws\r\n", pSiteEntry->Info.Site[i].SiteName);
            }
            MyFPrintf(hHandle, L"\r\n");
        }
        MyFPrintf(hHandle, L"\r\n");
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfsutil\flush.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       flush.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsstr.h>
#include <dfsmrshl.h>
#include <marshal.hxx>
#include <lmdfs.h>
#include <dfspriv.h>
#include <dfsm.hxx>
#include <recon.hxx>
#include <rpc.h>

#include "struct.hxx"
#include "ftsup.hxx"
#include "stdsup.hxx"
#include "rootsup.hxx"

WCHAR wszEverything[] = L"*";

DWORD
PktFlush(
    LPWSTR EntryPath)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    if (fSwDebug)
        MyPrintf(L"PktFlush(%ws)\r\n", EntryPath);

    if (EntryPath == NULL)
        EntryPath = wszEverything;

    MyPrintf(L"EntryPath=[%ws]\r\n", EntryPath);

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_PKT_FLUSH_CACHE,
                   EntryPath,
                   wcslen(EntryPath) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        if (fSwDebug)
            MyPrintf(L"NtFsControlFile returned 0x%x\r\n", NtStatus);
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (fSwDebug && dwErr != ERROR_SUCCESS)
        MyPrintf(L"PktFlush exit %d\r\n", dwErr);

    return(dwErr);
}

DWORD
SpcFlush(
    LPWSTR EntryPath)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    if (fSwDebug)
        MyPrintf(L"SpcFlush(%ws)\r\n", EntryPath);

    if (EntryPath == NULL)
        EntryPath = wszEverything;

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

    MyPrintf(L"EntryPath=[%ws]\r\n", EntryPath);

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_PKT_FLUSH_SPC_CACHE,
                   EntryPath,
                   wcslen(EntryPath) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        if (fSwDebug)
            MyPrintf(L"NtFsControlFile returned 0x%x\r\n", NtStatus);
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (fSwDebug && dwErr != ERROR_SUCCESS)
        MyPrintf(L"PktFlush exit %d\r\n", dwErr);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfsutil\dfsutil.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       dfsutil.cxx
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsstr.h>
#include <dfsmrshl.h>
#include <marshal.hxx>
#include <lmdfs.h>
#include <dfspriv.h>
#include <csites.hxx>
#include <dfsm.hxx>
#include <recon.hxx>
#include <fsctrl.h>
#include <rpc.h>

#include "struct.hxx"
#include "ftsup.hxx"
#include "stdsup.hxx"
#include "rootsup.hxx"
#include "flush.hxx"
#include "info.hxx"
#include "misc.hxx"
#include "messages.h"
#include "fileio.hxx"

INIT_FILE_TIME_INFO();
INIT_DFS_ID_PROPS_INFO();
INIT_DFS_REPLICA_INFO_MARSHAL_INFO();
INIT_DFS_SITENAME_INFO_MARSHAL_INFO();
INIT_DFS_SITELIST_INFO_MARSHAL_INFO();
INIT_DFSM_SITE_ENTRY_MARSHAL_INFO();
INIT_LDAP_OBJECT_MARSHAL_INFO();
INIT_LDAP_PKT_MARSHAL_INFO()
INIT_LDAP_DFS_VOLUME_PROPERTIES_MARSHAL_INFO();

//
// Globals
//

WCHAR DfsConfigContainer[] = L"CN=Dfs-Configuration,CN=System";
WCHAR DfsSpecialContainer[] = L"CN=Dfs-SpecialConfig,CN=System";
WCHAR DfsSpecialObject[] = L"SpecialTable";
WCHAR wszDfsRootName[] = L".";
ULONG GTimeout = 300;

WCHAR wszNameBuffer[MAX_PATH+1] = { 0 };
WCHAR wszDcName[MAX_PATH+1] = { 0 };
WCHAR wszDomainName[MAX_PATH+1] = { 0 };

LPWSTR pwszNameBuffer = NULL;
LPWSTR pwszRootName = NULL;
LPWSTR pwszServerName = NULL;
LPWSTR pwszHexValue = NULL;
LPWSTR pwszDcName = NULL;
LPWSTR pwszDomainName = NULL;
LPWSTR pwszEntryToFlush = NULL;
LPWSTR pwszDumpArg = NULL;
LPWSTR pwszImportArg = NULL;
LPWSTR pwszExportArg = NULL;
LPWSTR pwszComment = NULL;
LPWSTR pwszShareName = NULL;

//
// Supplied credentials
//
PSEC_WINNT_AUTH_IDENTITY pAuthIdent = NULL;

WCHAR wszUserDomain[MAX_PATH+1] = { 0 };
LPWSTR pwszUserDomain = NULL;
WCHAR wszUser[MAX_PATH+1] = { 0 };
LPWSTR pwszUser = NULL;
WCHAR wszPassword[MAX_PATH+1] = { 0 };
LPWSTR pwszPassword = NULL;

#define DFSREFERRALLIMIT_VAL L"DfsReferralLimit"
#define NETAPIDFSDEBUG_VALUE L"NetApiDfsDebug"

//
// Arguments (ie '/arg:')
//
MAKEARG(WhatIs);
MAKEARG(View);
MAKEARG(Verify);
MAKEARG(AddRoot);
MAKEARG(RemRoot);
MAKEARG(Comment);
MAKEARG(Server);
MAKEARG(Share);
MAKEARG(Unmap);
MAKEARG(Clean);
MAKEARG(ReInit);
MAKEARG(Verbose);
MAKEARG(EventLog);
MAKEARG(Domain);
MAKEARG(DcName);
MAKEARG(User);
MAKEARG(Password);
MAKEARG(Sfp);
MAKEARG(Dns);
MAKEARG(Value);
MAKEARG(NetApiDfsDebug);
MAKEARG(DfsSvcVerbose);
MAKEARG(LoggingDfs);
MAKEARG(SyncInterval);
MAKEARG(DfsAlt);
MAKEARG(TraceLevel);
MAKEARG(Level);
MAKEARG(SetDc);
MAKEARG(Root);
MAKEARG(Trusts);
MAKEARG(DcList);
MAKEARG(CscOnLine);
MAKEARG(CscOffLine);
MAKEARG(DfsReferralLimit);
MAKEARG(InSite);
MAKEARG(SiteInfo);
MAKEARG(Import);
MAKEARG(Export);

//
// Switches (ie '/arg')
//
SWITCH(Debug);
SWITCH(Help);
SWITCH(HelpHelp);
SWITCH(ScriptHelp);
SWITCH(ReadReg);
SWITCH(Dfs);
SWITCH(All);
SWITCH(StdDfs);
SWITCH(On);
SWITCH(Off);
SWITCH(PktInfo);
SWITCH(MarkStale);
SWITCH(FlushStale);
SWITCH(StopDfs);
SWITCH(StartDfs);
SWITCH(Set);
SWITCH(ReSet);

//
// Either a switch or an arg
//
MAKEARG(PktFlush);
SWITCH(PktFlush);
MAKEARG(SpcFlush);
SWITCH(SpcFlush);
MAKEARG(List);
SWITCH(List);
MAKEARG(SpcInfo);
SWITCH(SpcInfo);

//
// The macro can not make these
//

WCHAR SwQ[] = L"/?";
BOOLEAN fSwQ;
WCHAR SwQQ[] = L"/??";
BOOLEAN fSwQQ;

DWORD
Usage(
    BOOLEAN fHelpHelp);

DWORD
ScriptUsage(VOID);

DWORD
CmdProcessUserCreds(
    VOID);

BOOLEAN
CmdProcessArg(
    LPWSTR Arg);

_cdecl
main(int argc, char *argv[])
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR CommandLine;
    LPWSTR *argvw;
    SEC_WINNT_AUTH_IDENTITY AuthIdent = { 0 };
    int argx;
    int argcw;

    // fSwDebug = TRUE;

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    if ( argvw == NULL ) {
        MyPrintf(L"dfsutil:Can't convert command line to Unicode: %d\r\n", GetLastError() );
        return 1;
    }

    //
    // Get the arguments
    //
    if (argcw <= 1) {
        Usage(FALSE);
        dwErr = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Process arguments
    //

    for (argx = 1; argx < argcw; argx++) {
        if (CmdProcessArg(argvw[argx]) != TRUE) {
            dwErr = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    //
    // Did we get supplied creds?
    //

    if (fArgUser == TRUE || fArgPassword != NULL) {
        dwErr = CmdProcessUserCreds();
        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;
    }

    if (pwszUser != NULL || pwszUserDomain != NULL || pwszPassword != NULL) {
        pAuthIdent = &AuthIdent;
        pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        if (pwszUser != NULL) {
            pAuthIdent->User = (USHORT *)pwszUser;
            pAuthIdent->UserLength = wcslen(pwszUser);
       }
        if (pwszUserDomain != NULL) {
            pAuthIdent->Domain = (USHORT *)pwszUserDomain;
            pAuthIdent->DomainLength = wcslen(pwszUserDomain);
        }
        if (pwszPassword != NULL) {
            pAuthIdent->Password = (USHORT *)pwszPassword;
            pAuthIdent->PasswordLength = wcslen(pwszPassword);
        }
    }

    if (fSwDebug == TRUE) {
        MyPrintf(L"NameBuffer=%ws\r\n", pwszNameBuffer);
        MyPrintf(L"DcName=%ws\r\n", pwszDcName);
        MyPrintf(L"DomainName=%ws\r\n", pwszDomainName);
        MyPrintf(L"EntryToFlush=%ws\r\n", pwszEntryToFlush);
    }

    //
    // Do the work
    //
    if (fSwHelp == TRUE || fSwQ == TRUE) {
        dwErr = Usage(FALSE);
    }  else if (fSwScriptHelp == TRUE) {
        dwErr = ScriptUsage();
    } else if (fSwPktFlush == TRUE || fArgPktFlush == TRUE) {
        dwErr = PktFlush(pwszEntryToFlush);
    } else if (fSwSpcFlush == TRUE || fArgSpcFlush == TRUE) {
        dwErr = SpcFlush(pwszEntryToFlush);
    } else if (fArgImport == TRUE) {
        dwErr = CmdImport(pwszImportArg);
    } else if (fArgExport == TRUE) {
        dwErr = CmdExport(pwszExportArg, pwszNameBuffer, pwszDcName, pAuthIdent);
    } else if (fSwPktInfo == TRUE) {
        dwErr = PktInfo(fSwDfs, pwszHexValue);
    } else if (fSwSpcInfo == TRUE) {
        dwErr = SpcInfo(fSwAll);
    } else if (fArgAddRoot == TRUE) {
        dwErr = CmdAddRoot(
                    pwszNameBuffer,
                    pwszServerName,
                    pwszShareName,
                    pwszComment);
    } else if (fArgRemRoot == TRUE) {
        dwErr = CmdRemRoot(
                    pwszNameBuffer,
                    pwszServerName,
                    pwszShareName);
    } else if (fArgUnmap == TRUE) {
        dwErr = CmdDomUnmap(pwszNameBuffer, pwszRootName, pwszDcName, pAuthIdent);
    } else if (fArgClean == TRUE) {
        dwErr = CmdClean(pwszNameBuffer);
        if (dwErr == ERROR_SUCCESS)
            NetDfsManagerInitialize(pwszNameBuffer, 0);
    } else if (fArgView == TRUE) {
        dwErr = CmdView(pwszNameBuffer, pwszDcName, pAuthIdent, pwszHexValue);
    } else if (fArgReInit == TRUE) {
        dwErr = NetDfsManagerInitialize(pwszNameBuffer, 0);
    } else if (fArgWhatIs == TRUE) {
        dwErr = CmdWhatIs(pwszNameBuffer);
    }
    else if (fArgInSite == TRUE) {
        dwErr = CmdSetOnSite(pwszNameBuffer, pwszDcName, pAuthIdent, fSwSet?1:0);
    } else if (fArgSiteInfo == TRUE) {
        dwErr = CmdSiteInfo(pwszNameBuffer);
    } else if (fSwHelpHelp == TRUE || fSwQQ == TRUE) {
        dwErr = Usage(TRUE);
    } else if (fArgSfp == TRUE) {
        dwErr = CmdSfp(pwszNameBuffer, fSwOn, fSwOff);
    } else if (fArgTrusts == TRUE) {
        dwErr = CmdTrusts(pwszDomainName, pwszDcName, pAuthIdent, fSwAll);
    } else if (fArgNetApiDfsDebug == TRUE) {
        dwErr = CmdRegistry(pwszNameBuffer, REG_KEY_DFSSVC, NETAPIDFSDEBUG_VALUE, pwszHexValue);
    } else if (fArgDfsSvcVerbose == TRUE) {
        dwErr = CmdRegistry(pwszNameBuffer, REG_KEY_DFSSVC, REG_VALUE_VERBOSE, pwszHexValue);
    } else if (fArgDns == TRUE) {
        dwErr = CmdRegistry(pwszNameBuffer, REG_KEY_DFSSVC, REG_VALUE_DFSDNSCONFIG, pwszHexValue);
    } else if (fArgSyncInterval == TRUE) {
        dwErr = CmdRegistry(pwszNameBuffer, REG_KEY_DFSSVC, SYNC_INTERVAL_NAME, pwszHexValue);
    } else if (fArgDfsReferralLimit == TRUE) {
        dwErr = CmdRegistry(pwszNameBuffer, REG_KEY_DFSDRIVER, DFSREFERRALLIMIT_VAL, pwszHexValue);
    } else if (fArgLoggingDfs == TRUE) {
        dwErr = CmdRegistry(pwszNameBuffer, REG_KEY_EVENTLOG, REG_VALUE_EVENTLOG_DFS, pwszHexValue);
    } else if (fArgSetDc == TRUE) {
        dwErr = CmdSetDc(pwszNameBuffer);
    } else if (fSwMarkStale == TRUE) {
        dwErr = CmdDfsFsctlDfs(DFS_SERVER_NAME, FSCTL_DFS_MARK_STALE_PKT_ENTRIES);
    } else if (fSwFlushStale == TRUE) {
        dwErr = CmdDfsFsctlDfs(DFS_SERVER_NAME, FSCTL_DFS_FLUSH_STALE_PKT_ENTRIES);
    } else if (fSwStartDfs == TRUE) {
        dwErr = CmdDfsFsctlDfs(DFS_SERVER_NAME, FSCTL_DFS_START_DFS);
    } else if (fSwStopDfs == TRUE) {
        dwErr = CmdDfsFsctlDfs(DFS_SERVER_NAME, FSCTL_DFS_STOP_DFS);
    } else if (fArgVerbose == TRUE) {
        dwErr = CmdMupFlags(FSCTL_DFS_VERBOSE_FLAGS, pwszHexValue);
    } else if (fArgEventLog == TRUE) {
        dwErr = CmdMupFlags(FSCTL_DFS_EVENTLOG_FLAGS, pwszHexValue);
    } else if (fArgTraceLevel == TRUE) {
        dwErr = CmdMupFlags(FSCTL_DFS_DBG_FLAGS, pwszHexValue);
    } else if (fSwReadReg == TRUE) {
        dwErr = CmdMupReadReg(fSwDfs);
    } else if (fArgCscOnLine == TRUE) {
        dwErr = CmdCscOnLine(pwszNameBuffer);
    } else if (fArgCscOffLine == TRUE) {
        dwErr = CmdCscOffLine(pwszNameBuffer);
    } else if (fArgDfsAlt == TRUE) {
        dwErr = CmdDfsAlt(pwszNameBuffer);
    } else if (fArgDcList == TRUE) {
        dwErr = CmdDcList(pwszDomainName, pwszDcName, pAuthIdent);
    } else if (fSwList == TRUE && fSwStdDfs == TRUE) {
        dwErr = CmdStdList(pwszDomainName);
    } else if (fSwList == TRUE && fSwStdDfs == FALSE) {
        dwErr = CmdDomList(pwszDcName, pwszDomainName, pAuthIdent);
    } else if (fArgVerify == TRUE) {
        dwErr = CmdVerify(pwszNameBuffer, pwszDcName, pAuthIdent, pwszHexValue);
    }
    else {
        dwErr = Usage(FALSE);
//        ErrorMessage(MSG_NOTHING_TO_DO);
    }

Cleanup:

    if (dwErr == STATUS_SUCCESS) {
        ErrorMessage(MSG_SUCCESSFUL);
    } else {
        LPWSTR MessageBuffer;
        DWORD dwBufferLength;

        dwBufferLength = FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwErr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPWSTR) &MessageBuffer,
                            0,
                            NULL);

        ErrorMessage(MSG_ERROR, dwErr);
        if (dwBufferLength > 0) {
            MyPrintf(L"%ws\r\n", MessageBuffer);
            LocalFree(MessageBuffer);
        }
    }

    return dwErr;
}

DWORD
CmdProcessUserCreds(
    VOID)
{
    DWORD dwErr = ERROR_SUCCESS;
    PWCHAR wCp = NULL;

    if (fSwDebug == TRUE) {
        MyPrintf(L"ProcessUserCreds:\r\n");
        MyPrintf(L"    UserName:%ws\r\n", pwszUser);
        MyPrintf(L"    Password:%ws\r\n", pwszPassword);
    }

    //
    // Scan pwszUser for backslash or '@'
    //

    for (wCp = pwszUser; *wCp != L'\0' && *wCp != L'\\' && *wCp != L'@'; wCp++)
        ;

    //
    // If backslash, treat as domain\user
    //
    if (*wCp == L'\\') {
        pwszUserDomain = pwszUser;
        *wCp++ = '\0';
        pwszUser = wCp;
        if (fSwDebug == TRUE)
            MyPrintf(L"User:%ws Domain:%ws Password:%ws\r\n",
                            pwszUser,
                            pwszUserDomain,
                            pwszPassword);
    }

    //
    // If @, treat as user@domain
    //

    if (*wCp == L'@') {
        *wCp++ = '\0';
        pwszUserDomain = wCp;
        if (fSwDebug == TRUE)
            MyPrintf(L"User:%ws Domain:%ws Password:%ws\r\n",
                            pwszUser,
                            pwszUserDomain,
                            pwszPassword);
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessUserCreds exit %d\r\n", dwErr);

    return dwErr;
}

BOOLEAN
CmdProcessArg(LPWSTR Arg)
{
    LONG ArgLen;
    BOOLEAN dwErr = FALSE;
    BOOLEAN FoundAnArg = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessArg(%ws)\r\n", Arg);

    if ( Arg != NULL && wcslen(Arg) > 1) {

        dwErr = TRUE;
        ArgLen = wcslen(Arg);

        if (_wcsnicmp(Arg, ArgView, ArgLenView) == 0) {
            FoundAnArg = fArgView = TRUE;
            if (ArgLen > ArgLenView)
                pwszNameBuffer = &Arg[ArgLenView];
        } else if (_wcsnicmp(Arg, ArgInSite, ArgLenInSite) == 0) {
            FoundAnArg = fArgInSite = TRUE;
            if (ArgLen > ArgLenInSite)
                pwszNameBuffer = &Arg[ArgLenInSite];
        } else if (_wcsnicmp(Arg, ArgSiteInfo, ArgLenSiteInfo) == 0) {
            FoundAnArg = fArgSiteInfo = TRUE;
            if (ArgLen > ArgLenSiteInfo)
                pwszNameBuffer = &Arg[ArgLenSiteInfo];
        } else if (_wcsnicmp(Arg, ArgDcName, ArgLenDcName) == 0) {
            FoundAnArg = fArgDcName = TRUE;
            if (ArgLen > ArgLenDcName)
                pwszDcName = &Arg[ArgLenDcName];
        } else if (_wcsnicmp(Arg, ArgTrusts, ArgLenTrusts) == 0) {
            FoundAnArg = fArgTrusts = TRUE;
            if (ArgLen > ArgLenTrusts)
                pwszDomainName = &Arg[ArgLenTrusts];
        } else if (_wcsnicmp(Arg, ArgImport, ArgLenImport) == 0) {
            FoundAnArg = fArgImport = TRUE;
            if (ArgLen > ArgLenImport)
                pwszImportArg = &Arg[ArgLenImport];
        } else if (_wcsnicmp(Arg, ArgExport, ArgLenExport) == 0) {
            FoundAnArg = fArgExport = TRUE;
            if (ArgLen > ArgLenExport)
                pwszExportArg = &Arg[ArgLenExport];
        } else if (_wcsnicmp(Arg, ArgSetDc, ArgLenSetDc) == 0) {
            FoundAnArg = fArgSetDc = TRUE;
            if (ArgLen > ArgLenSetDc)
                pwszNameBuffer = &Arg[ArgLenSetDc];
        } else if (_wcsnicmp(Arg, ArgRoot, ArgLenRoot) == 0) {
            FoundAnArg = fArgRoot = TRUE;
            if (ArgLen > ArgLenRoot)
                pwszRootName = &Arg[ArgLenRoot];
        } else if (_wcsnicmp(Arg, ArgAddRoot, ArgLenAddRoot) == 0) {
            FoundAnArg = fArgAddRoot = TRUE;
            if (ArgLen > ArgLenAddRoot)
                pwszNameBuffer = &Arg[ArgLenAddRoot];
        } else if (_wcsnicmp(Arg, ArgRemRoot, ArgLenRemRoot) == 0) {
            FoundAnArg = fArgRemRoot = TRUE;
            if (ArgLen > ArgLenRemRoot)
                pwszNameBuffer = &Arg[ArgLenRemRoot];
        } else if (_wcsnicmp(Arg, ArgShare, ArgLenShare) == 0) {
            FoundAnArg = fArgShare = TRUE;
            if (ArgLen > ArgLenShare)
                pwszShareName = &Arg[ArgLenShare];
        } else if (_wcsnicmp(Arg, ArgComment, ArgLenComment) == 0) {
            FoundAnArg = fArgComment = TRUE;
            if (ArgLen > ArgLenComment)
                pwszComment = &Arg[ArgLenComment];
        } else if (_wcsnicmp(Arg, ArgServer, ArgLenServer) == 0) {
            FoundAnArg = fArgServer = TRUE;
            if (ArgLen > ArgLenServer)
                pwszServerName = &Arg[ArgLenServer];
        } else if (_wcsnicmp(Arg, ArgUnmap, ArgLenUnmap) == 0) {
            FoundAnArg = fArgUnmap = TRUE;
            if (ArgLen > ArgLenUnmap)
                pwszNameBuffer = &Arg[ArgLenUnmap];
        } else if (_wcsnicmp(Arg, ArgClean, ArgLenClean) == 0) {
            FoundAnArg = fArgClean = TRUE;
            if (ArgLen > ArgLenClean)
                pwszNameBuffer = &Arg[ArgLenClean];
        } else if (_wcsnicmp(Arg, ArgDomain, ArgLenDomain) == 0) {
            FoundAnArg = fArgDomain = TRUE;
            if (ArgLen > ArgLenDomain)
                pwszDomainName = &Arg[ArgLenDomain];
        } else if (_wcsnicmp(Arg, ArgWhatIs, ArgLenWhatIs) == 0) {
            FoundAnArg = fArgWhatIs = TRUE;
            if (ArgLen > ArgLenWhatIs)
                pwszNameBuffer = &Arg[ArgLenWhatIs];
        } else if (_wcsnicmp(Arg, ArgCscOnLine, ArgLenCscOnLine) == 0) {
            FoundAnArg = fArgCscOnLine = TRUE;
            if (ArgLen > ArgLenCscOnLine)
                pwszNameBuffer = &Arg[ArgLenCscOnLine];
        } else if (_wcsnicmp(Arg, ArgCscOffLine, ArgLenCscOffLine) == 0) {
            FoundAnArg = fArgCscOffLine = TRUE;
            if (ArgLen > ArgLenCscOffLine)
                pwszNameBuffer = &Arg[ArgLenCscOffLine];
        } else if (_wcsnicmp(Arg, ArgDfsAlt, ArgLenDfsAlt) == 0) {
            FoundAnArg = fArgDfsAlt = TRUE;
            if (ArgLen > ArgLenDfsAlt)
                pwszNameBuffer = &Arg[ArgLenDfsAlt];
        } else if (_wcsnicmp(Arg, ArgList, ArgLenList) == 0) {
            FoundAnArg = fArgList = fSwList = TRUE;
            if (ArgLen > ArgLenList)
                pwszDomainName = &Arg[ArgLenList];
        } else if (_wcsnicmp(Arg, ArgDcList, ArgLenDcList) == 0) {
            FoundAnArg = fArgDcList = TRUE;
            if (ArgLen > ArgLenDcList)
                pwszDomainName = &Arg[ArgLenDcList];
        } else if (_wcsnicmp(Arg, ArgSfp, ArgLenSfp) == 0) {
            FoundAnArg = fArgSfp = TRUE;
            if (ArgLen > ArgLenSfp)
                pwszNameBuffer = &Arg[ArgLenSfp];
        } else if (_wcsnicmp(Arg, ArgDns, ArgLenDns) == 0) {
            FoundAnArg = fArgDns = TRUE;
            if (ArgLen > ArgLenDns)
                pwszNameBuffer = &Arg[ArgLenDns];
        } else if (_wcsnicmp(Arg, ArgNetApiDfsDebug, ArgLenNetApiDfsDebug) == 0) {
            FoundAnArg = fArgNetApiDfsDebug = TRUE;
            if (ArgLen > ArgLenNetApiDfsDebug)
                pwszNameBuffer = &Arg[ArgLenNetApiDfsDebug];
        } else if (_wcsnicmp(Arg, ArgDfsSvcVerbose, ArgLenDfsSvcVerbose) == 0) {
            FoundAnArg = fArgDfsSvcVerbose = TRUE;
            if (ArgLen > ArgLenDfsSvcVerbose)
                pwszNameBuffer = &Arg[ArgLenDfsSvcVerbose];
        } else if (_wcsnicmp(Arg, ArgLoggingDfs, ArgLenLoggingDfs) == 0) {
            FoundAnArg = fArgLoggingDfs = TRUE;
            if (ArgLen > ArgLenLoggingDfs)
                pwszNameBuffer = &Arg[ArgLenLoggingDfs];
        } else if (_wcsnicmp(Arg, ArgDfsReferralLimit, ArgLenDfsReferralLimit) == 0) {
            FoundAnArg = fArgDfsReferralLimit = TRUE;
            if (ArgLen > ArgLenDfsReferralLimit)
                pwszNameBuffer = &Arg[ArgLenDfsReferralLimit];
        } else if (_wcsnicmp(Arg, ArgSyncInterval, ArgLenSyncInterval) == 0) {
            FoundAnArg = fArgSyncInterval = TRUE;
            if (ArgLen > ArgLenSyncInterval)
                pwszNameBuffer = &Arg[ArgLenSyncInterval];
        } else if (_wcsnicmp(Arg, ArgVerify, ArgLenVerify) == 0) {
            FoundAnArg = fArgVerify = TRUE;
            if (ArgLen > ArgLenVerify)
                pwszNameBuffer = &Arg[ArgLenVerify];
        } else if (_wcsnicmp(Arg, ArgPktFlush, ArgLenPktFlush) == 0) {
            FoundAnArg = fArgPktFlush = TRUE;
            if (ArgLen > ArgLenPktFlush)
                pwszEntryToFlush = &Arg[ArgLenPktFlush];
        } else if (_wcsnicmp(Arg, ArgSpcFlush, ArgLenSpcFlush) == 0) {
            FoundAnArg = fArgSpcFlush = TRUE;
            if (ArgLen > ArgLenSpcFlush)
                pwszEntryToFlush = &Arg[ArgLenSpcFlush];
        } else if (_wcsnicmp(Arg, ArgReInit, ArgLenReInit) == 0) {
            FoundAnArg = fArgReInit = TRUE;
            if (ArgLen > ArgLenReInit)
                pwszNameBuffer = &Arg[ArgLenReInit];
        } else if (_wcsnicmp(Arg, ArgUser, ArgLenUser) == 0) {
            FoundAnArg = fArgUser = TRUE;
            if (ArgLen > ArgLenUser)
                pwszUser = &Arg[ArgLenUser];
        } else if (_wcsnicmp(Arg, ArgPassword, ArgLenPassword) == 0) {
            FoundAnArg = fArgPassword = TRUE;
            if (ArgLen > ArgLenPassword)
                pwszPassword = &Arg[ArgLenPassword];
        } else if (_wcsnicmp(Arg, ArgVerbose, ArgLenVerbose) == 0) {
            FoundAnArg = fArgVerbose = TRUE;
            if (ArgLen > ArgLenVerbose)
                pwszHexValue = &Arg[ArgLenVerbose];
        } else if (_wcsnicmp(Arg, ArgValue, ArgLenValue) == 0) {
            FoundAnArg = fArgValue = TRUE;
            if (ArgLen > ArgLenValue)
                pwszHexValue = &Arg[ArgLenValue];
        } else if (_wcsnicmp(Arg, ArgTraceLevel, ArgLenTraceLevel) == 0) {
            FoundAnArg = fArgTraceLevel = TRUE;
            if (ArgLen > ArgLenTraceLevel)
                pwszHexValue = &Arg[ArgLenTraceLevel];
        } else if (_wcsnicmp(Arg, ArgLevel, ArgLenLevel) == 0) {
            FoundAnArg = fArgLevel = TRUE;
            if (ArgLen > ArgLenLevel)
                pwszHexValue = &Arg[ArgLenLevel];
        } else if (_wcsnicmp(Arg, ArgEventLog, ArgLenEventLog) == 0) {
            FoundAnArg = fArgEventLog = TRUE;
            if (ArgLen > ArgLenEventLog)
                pwszHexValue = &Arg[ArgLenEventLog];
        }

        // Switches go at the end!!

        if (_wcsicmp(Arg, SwDebug) == 0) {
            FoundAnArg = fSwDebug = TRUE;
        } else if (_wcsicmp(Arg, SwList) == 0) {
            FoundAnArg = fSwList = TRUE;
        } else if (_wcsicmp(Arg, SwReadReg) == 0) {
            FoundAnArg = fSwReadReg = TRUE;
        } else if (_wcsicmp(Arg, SwPktFlush) == 0) {
            FoundAnArg = fSwPktFlush = TRUE;
        } else if (_wcsicmp(Arg, SwSpcFlush) == 0) {
            FoundAnArg = fSwSpcFlush = TRUE;
        } else if (_wcsicmp(Arg, SwPktInfo) == 0) {
            FoundAnArg = fSwPktInfo = TRUE;
        } else if (_wcsicmp(Arg, SwMarkStale) == 0) {
            FoundAnArg = fSwMarkStale = TRUE;
        } else if (_wcsicmp(Arg, SwFlushStale) == 0) {
            FoundAnArg = fSwFlushStale = TRUE;
        } else if (_wcsicmp(Arg, SwStartDfs) == 0) {
            FoundAnArg = fSwStartDfs = TRUE;
        } else if (_wcsicmp(Arg, SwStopDfs) == 0) {
            FoundAnArg = fSwStopDfs = TRUE;
        } else if (_wcsicmp(Arg, SwSpcInfo) == 0) {
            FoundAnArg = fSwSpcInfo = TRUE;
        } else if (_wcsicmp(Arg, SwDfs) == 0) {
            FoundAnArg = fSwDfs = TRUE;
        } else if (_wcsicmp(Arg, SwAll) == 0) {
            FoundAnArg = fSwAll = TRUE;
        } else if (_wcsicmp(Arg, SwOn) == 0) {
            FoundAnArg = fSwOn = TRUE;
        } else if (_wcsicmp(Arg, SwOff) == 0) {
            FoundAnArg = fSwOff = TRUE;
        } else if (_wcsicmp(Arg, SwStdDfs) == 0) {
            FoundAnArg = fSwStdDfs = TRUE;
        } else if (_wcsicmp(Arg, SwHelpHelp) == 0) {
            FoundAnArg = fSwHelpHelp = TRUE;
        } else if (_wcsicmp(Arg, SwScriptHelp) == 0) {
            FoundAnArg = fSwScriptHelp = TRUE;
        } else if (_wcsicmp(Arg, SwHelp) == 0) {
            FoundAnArg = fSwHelp = TRUE;
        } else if (_wcsicmp(Arg, SwQQ) == 0) {
            FoundAnArg = fSwQQ = TRUE;
        } else if (_wcsicmp(Arg, SwQ) == 0) {
            FoundAnArg = fSwQ = TRUE;
        } else if (_wcsicmp(Arg, SwSet) == 0) {
            FoundAnArg = fSwSet = TRUE;
        } else if (_wcsicmp(Arg, SwReSet) == 0) {
            FoundAnArg = fSwReSet = TRUE;
        }

        if (wszNameBuffer[0] == L'\0' && pwszNameBuffer != NULL) {
            wcscpy(wszNameBuffer, L"\\\\");
            wcscat(wszNameBuffer, pwszNameBuffer);
            pwszNameBuffer = wszNameBuffer;
            while (pwszNameBuffer[0] == L'\\' && pwszNameBuffer[1] == L'\\')
                pwszNameBuffer++;
            pwszNameBuffer--;
        }

        if (FoundAnArg == FALSE) {
            ErrorMessage(MSG_UNRECOGNIZED_OPTION, &Arg[1]);
            dwErr = FALSE;
            goto AllDone;
        }

    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessArg exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
Usage(
    BOOLEAN fHelpHelp)
{
#if (MASTER_UTIL == 1)
    ErrorMessage(MSG_USAGE);
    if (fHelpHelp == TRUE)
        ErrorMessage(MSG_USAGE_EX);
#else
    ErrorMessage(MSG_USAGE_LTD);
#endif
    return ERROR_SUCCESS;
}

DWORD
ScriptUsage(VOID)
{
    ErrorMessage(MSG_USAGE_EX_EX);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfsutil\ftsup.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       ftsup.cxx
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsstr.h>
#include <dfsmrshl.h>
#include <marshal.hxx>
#include <lmdfs.h>
#include <dfspriv.h>
#include <csites.hxx>
#include <dfsm.hxx>
#include <recon.hxx>
#include <rpc.h>
#include "struct.hxx"
#include "ftsup.hxx"
#include "rootsup.hxx"
#include "dfsacl.hxx"
#include "misc.hxx"
#include "fileio.hxx"
#include "messages.h"

DWORD
CmdUnmapOneRoot(
    LPWSTR pwszDomDfsName,
    LPWSTR pwszRootName,
    LPWSTR pwszDcName,
    LPWSTR pwszDomainName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent);

DWORD
DfsUpdateSiteReferralInfo(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR wszPrefixMatch,
    ULONG Set);

DWORD
DfsGetFtVol(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR wszFtDfsName,
    LPWSTR pwszDcName,
    LPWSTR pwszDomainName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG cbBlob = 0;
    BYTE *pBlob = NULL;
    WCHAR wszDcName[MAX_PATH+1];

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsGetFtVol(%ws,%ws,%ws)\r\n", wszFtDfsName, pwszDcName, pwszDomainName);

    if (pwszDcName == NULL) {
        dwErr = DfspGetPdc(wszDcName, pwszDomainName);
    } else {
        wcscpy(wszDcName, pwszDcName);
    }

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    ErrorMessage(MSG_CONNECTING, wszDcName);

    //
    // Get blob & root list from Ds
    //
    dwErr = DfsGetDsBlob(
                wszFtDfsName,
                DfsConfigContainer,
                wszDcName,
                pAuthIdent,
                &cbBlob,
                &pBlob,
                &pDfsVolList->RootServers);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Unserialize it
    //
    dwErr =  DfsGetVolList(
                cbBlob,
                pBlob,
                pDfsVolList);

    pDfsVolList->DfsType = DOMDFS;

Cleanup:

    if (pBlob != NULL)
        free(pBlob);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsGetFtVol exit %d\r\n", dwErr);

    return dwErr;

}



//+------------------------------------------------------------------------
//
// Function:    DfsGetDsBlob
//
// Synopsis:    Reads a Dfs BLOB from the DS
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsGetDsBlob(
    LPWSTR wszFtDfsName,
    LPWSTR wszContainerName,
    LPWSTR wszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    ULONG *pcbBlob,
    BYTE **ppBlob,
    LPWSTR **ppRootServers)
{
    DWORD dwErr;
    LDAP *pldap = NULL;
    PLDAPMessage pMsg = NULL;
    PLDAP_BERVAL *rgldapPktBlob = NULL;
    PLDAP_BERVAL pldapPktBlob;
    LDAPMessage *pmsgServers;
    DWORD i;
    WCHAR *wszConfigurationDN = NULL;
    WCHAR wszDfsConfigDN[MAX_PATH+1];
    LPWSTR rgAttrs[5];
    BYTE *pBlob = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsGetDsBlob(%ws,%ws, %ws)\r\n", wszFtDfsName, wszContainerName, wszDcName);

    dwErr = DfspLdapOpen(wszDcName, pAuthIdent, &pldap, wszContainerName, &wszConfigurationDN);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Build the entry name we want to search in
    //

    wcscpy(wszDfsConfigDN,L"CN=");
    wcscat(wszDfsConfigDN,wszFtDfsName);
    wcscat(wszDfsConfigDN,L",");
    wcscat(wszDfsConfigDN,wszConfigurationDN);

    if (fSwDebug == TRUE)
        MyPrintf(L"wszDfsConfigDN=[%ws]\r\n", wszDfsConfigDN);

    rgAttrs[0] = L"pKT";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_s(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr != LDAP_SUCCESS) {
        dwErr = LdapMapErrorToWin32(dwErr);
        goto Cleanup;
    }

    pmsgServers = ldap_first_entry(pldap, pMsg);

    if (pmsgServers == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    rgldapPktBlob = ldap_get_values_len(
                        pldap,
                        pMsg,
                        L"pKT");

    if (rgldapPktBlob == NULL || *rgldapPktBlob == NULL) {
        dwErr = ERROR_INTERNAL_DB_CORRUPTION;
        goto Cleanup;
    }

    pldapPktBlob = rgldapPktBlob[0];

    pBlob = (BYTE *)malloc(pldapPktBlob->bv_len + sizeof(DWORD));

    if (pBlob == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pBlob, pldapPktBlob->bv_len + sizeof(DWORD));

    MyPrintf(L"\r\n");
    MyPrintf(L" ------ Blob is %d bytes...\r\n", pldapPktBlob->bv_len);
    MyPrintf(L"\r\n");

    RtlCopyMemory(pBlob, pldapPktBlob->bv_val, pldapPktBlob->bv_len);

    *ppBlob = pBlob;
    *pcbBlob = pldapPktBlob->bv_len;

    dwErr = NetDfsRootServerEnum(
            pldap,
            wszDfsConfigDN,
            ppRootServers);

Cleanup:

    if (rgldapPktBlob != NULL)
        ldap_value_free_len(rgldapPktBlob);

    if (pMsg != NULL)
        ldap_msgfree(pMsg);

    if (pldap != NULL)
        ldap_unbind(pldap);

    if (wszConfigurationDN != NULL)
        free(wszConfigurationDN);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsGetDsBlob returning %d\r\n", dwErr);

    return (dwErr);

}

//+------------------------------------------------------------------------
//
// Function:    DfsPutDsBlob
//
// Synopsis:    Updates a Dfs BLOB in the DS
//
// History:     12/8/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsPutDsBlob(
    LPWSTR wszFtDfsName,
    LPWSTR wszContainerName,
    LPWSTR wszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    ULONG cbBlob,
    BYTE *pBlob,
    LPWSTR *pRootServers)
{

    DWORD dwErr;
    LDAP *pldap = NULL;
    GUID idNewPkt;
    LDAP_BERVAL ldapVal;
    PLDAP_BERVAL rgldapVals[2];
    LDAPModW ldapMod;
    LDAP_BERVAL ldapIdVal;
    PLDAP_BERVAL rgldapIdVals[2];
    LDAPModW ldapIdMod;
    PLDAPModW rgldapMods[4];
    WCHAR *wszConfigurationDN = NULL;
    LDAPModW ldapModServer;
    WCHAR wszDfsConfigDN[MAX_PATH+1];

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsPutDsBlob(%ws,%ws, %ws)\r\n", wszFtDfsName, wszContainerName, wszDcName);

    dwErr = DfspLdapOpen(wszDcName, pAuthIdent, &pldap, wszContainerName, &wszConfigurationDN);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Build the entry name
    //

    wcscpy(wszDfsConfigDN,L"CN=");
    wcscat(wszDfsConfigDN,wszFtDfsName);
    wcscat(wszDfsConfigDN,L",");
    wcscat(wszDfsConfigDN,wszConfigurationDN);

    if (fSwDebug == TRUE)
        MyPrintf(L"wszDfsConfigDN=[%ws]\r\n", wszDfsConfigDN);

    dwErr = UuidCreate( &idNewPkt );

    if(dwErr != RPC_S_OK) {
        goto Cleanup;
    }


    ldapIdVal.bv_len = sizeof(GUID);
    ldapIdVal.bv_val = (PCHAR) &idNewPkt;
    rgldapIdVals[0] = &ldapIdVal;
    rgldapIdVals[1] = NULL;

    ldapIdMod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    ldapIdMod.mod_type = L"pKTGuid";
    ldapIdMod.mod_vals.modv_bvals = rgldapIdVals;

    ldapVal.bv_len = cbBlob;
    ldapVal.bv_val = (PCHAR) pBlob;
    rgldapVals[0] = &ldapVal;
    rgldapVals[1] = NULL;

    ldapMod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    ldapMod.mod_type = L"pKT";
    ldapMod.mod_vals.modv_bvals = rgldapVals;

    ldapModServer.mod_op = LDAP_MOD_REPLACE;
    ldapModServer.mod_type = L"remoteServerName";
    ldapModServer.mod_vals.modv_strvals = pRootServers;

    rgldapMods[0] = &ldapMod;
    rgldapMods[1] = &ldapIdMod;
    rgldapMods[2] = &ldapModServer;
    rgldapMods[3] = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"Writing BLOB of %d bytes\r\n", cbBlob);

    dwErr = ldap_modify_s(
                    pldap,
                    wszDfsConfigDN,
                    rgldapMods);

    if (fSwDebug == TRUE) {
        MyPrintf(L"ldap_modify_s returned %d(0x%x)\r\n", dwErr, dwErr);
    }

    ldap_unbind(pldap);
    pldap = NULL;

    if (dwErr != LDAP_SUCCESS) {
        dwErr = LdapMapErrorToWin32(dwErr);
    } else {
        dwErr = ERROR_SUCCESS;
    }

Cleanup:

    if (pldap != NULL)
        ldap_unbind( pldap );

    if (wszConfigurationDN != NULL)
        free(wszConfigurationDN);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsPutDsBlob returning %d\r\n", dwErr);

    return (dwErr);

}

//+------------------------------------------------------------------------
//
// Function:    DfsGetVolList
//
// Synopsis:    Unserializes an FtDfs BLOB and creates
//              a volume list representing an FtDfs.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------
DWORD
DfsGetVolList(
    ULONG cbBlob,
    BYTE *pBlob,
    PDFS_VOLUME_LIST pDfsVolList)
{
    DWORD dwErr;
    DWORD cObj;
    DWORD cVol;
    LDAP_PKT LdapPkt;
    MARSHAL_BUFFER marshalBuffer;
    NTSTATUS NtStatus;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsGetVolList()\r\n");

    RtlZeroMemory(&LdapPkt, sizeof(LDAP_PKT));

    if (cbBlob > sizeof(DWORD)) {

        _GetULong(pBlob, pDfsVolList->Version);

        if (fSwDebug == TRUE) {
            MyPrintf(L"Blob Version = %d\r\n", pDfsVolList->Version);
            MyPrintf(L"BLOB is %d bytes:\r\n", cbBlob);
        }

        MarshalBufferInitialize(
            &marshalBuffer,
            cbBlob - sizeof(DWORD),
            pBlob + sizeof(DWORD));

        NtStatus = DfsRtlGet(&marshalBuffer, &MiLdapPkt, &LdapPkt);

        if (!NT_SUCCESS(NtStatus)) {
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        if (fSwDebug == TRUE) {

            MyPrintf(L"  %d objects found\r\n", LdapPkt.cLdapObjects);

            for (cObj = 0; cObj < LdapPkt.cLdapObjects; cObj++) {

                MyPrintf(L"%d:name=%ws size=%d p=0x%p\r\n",
                        cObj,
                        LdapPkt.rgldapObjects[cObj].wszObjectName,
                        LdapPkt.rgldapObjects[cObj].cbObjectData,
                        LdapPkt.rgldapObjects[cObj].pObjectData);

                // DumpBuf(
                //     LdapPkt.rgldapObjects[cObj].pObjectData,
                //     LdapPkt.rgldapObjects[cObj].cbObjectData);
            }

        }

        for (cObj = 0; cObj < LdapPkt.cLdapObjects; cObj++) {

            if (wcscmp(LdapPkt.rgldapObjects[cObj].wszObjectName, L"\\siteroot") != 0) {
                pDfsVolList->VolCount++;
            }

        }

        pDfsVolList->Volumes = (PDFS_VOLUME *) malloc(pDfsVolList->VolCount * sizeof(PDFS_VOLUME));

        if (pDfsVolList->Volumes == NULL) {

            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;

        }

        RtlZeroMemory(pDfsVolList->Volumes, pDfsVolList->VolCount * sizeof(PDFS_VOLUME));

        //
        // Save the true/allocated size so to optimize deletions/additions
        //
        pDfsVolList->AllocatedVolCount = pDfsVolList->VolCount;

        if (fSwDebug == TRUE)
            MyPrintf(L"===============================\r\n");

        for (cVol = cObj = 0; cObj < LdapPkt.cLdapObjects; cObj++) {

            if (wcscmp(LdapPkt.rgldapObjects[cObj].wszObjectName, L"\\siteroot") == 0) {

                dwErr = DfsGetSiteTable(
                            pDfsVolList,
                            &LdapPkt.rgldapObjects[cObj]);

            } else {

                pDfsVolList->Volumes[cVol] = (PDFS_VOLUME) malloc(sizeof(DFS_VOLUME));
                if (pDfsVolList->Volumes[cVol] == NULL) {
                    dwErr = ERROR_OUTOFMEMORY;
                    goto Cleanup;
                }
                RtlZeroMemory(pDfsVolList->Volumes[cVol], sizeof(DFS_VOLUME));
                dwErr = DfsGetVolume(
                            pDfsVolList->Volumes[cVol],
                            &LdapPkt.rgldapObjects[cObj]);

            }

            if (dwErr != ERROR_SUCCESS)
                goto Cleanup;

            cVol++;

        }

    } else if (cbBlob == sizeof(DWORD)) {

        if (fSwDebug == TRUE)
            MyPrintf(L"pKT BLOB is simply one DWORD\r\n");
        dwErr = ERROR_INTERNAL_DB_CORRUPTION;

    } else {

        if (fSwDebug == TRUE)
            MyPrintf(L"pKT BLOB is corrupt!\r\n");
        dwErr = ERROR_INTERNAL_DB_CORRUPTION;

    }

Cleanup:

    FreeLdapPkt(&LdapPkt);

    //
    // Do any recovery needed
    //
    // 447511, do this only if volumes is not null
    if (pDfsVolList->Volumes != NULL) {
       dwErr = DfsRecoverVolList(pDfsVolList);
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsGetVolList returning %d\r\n", dwErr);

    return( dwErr );

}

//+------------------------------------------------------------------------
//
// Function:    DfsGetVolume
//
// Synopsis:    Unserializes the data in a buffer/blob to a volume
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsGetVolume(
    PDFS_VOLUME pVolume,
    PLDAP_OBJECT pLdapObject)
{
    DFS_VOLUME_PROPERTIES VolProps;
    DWORD dwErr = ERROR_SUCCESS;
    MARSHAL_BUFFER marshalBuffer;
    NTSTATUS NtStatus;
    PBYTE pBuffer = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsGetVolume(%ws,%d)\r\n",
                pLdapObject->wszObjectName,
                pLdapObject->cbObjectData);

    RtlZeroMemory(&VolProps, sizeof(DFS_VOLUME_PROPERTIES));

    pVolume->wszObjectName = (WCHAR *) malloc(
                    (wcslen(pLdapObject->wszObjectName)+1) * sizeof(WCHAR));

    if (pVolume->wszObjectName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    wcscpy(
        pVolume->wszObjectName,
        pLdapObject->wszObjectName);

    MarshalBufferInitialize(
        &marshalBuffer,
        pLdapObject->cbObjectData,
        pLdapObject->pObjectData);

    NtStatus = DfsRtlGet(
                    &marshalBuffer,
                    &MiVolumeProperties,
                    &VolProps);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr =  RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    VolProps.dwTimeout = 300;

    if (
        (marshalBuffer.Current < marshalBuffer.Last)
            &&
        (marshalBuffer.Last - marshalBuffer.Current) == sizeof(ULONG)
    ) {

        DfsRtlGetUlong(&marshalBuffer, &VolProps.dwTimeout);

    }

    pVolume->idVolume = VolProps.idVolume;
    pVolume->wszPrefix = VolProps.wszPrefix;
    pVolume->wszShortPrefix = VolProps.wszShortPrefix;
    pVolume->dwType = VolProps.dwType;
    pVolume->dwState = VolProps.dwState;
    pVolume->wszComment = VolProps.wszComment;
    pVolume->dwTimeout = VolProps.dwTimeout;
    pVolume->ftPrefix = VolProps.ftPrefix;
    pVolume->ftState = VolProps.ftState;
    pVolume->ftComment = VolProps.ftComment;
    pVolume->dwVersion = VolProps.dwVersion;
    pVolume->cbRecovery = VolProps.cbRecovery;
    pVolume->pRecovery = VolProps.pRecovery;

    pBuffer = VolProps.pSvc;

    if (fSwDebug == TRUE)
        MyPrintf(L"VolProps.cbSvc = %d\r\n", VolProps.cbSvc);

    dwErr = UnSerializeReplicaList(
                &pVolume->ReplCount,
                &pVolume->AllocatedReplCount,
                &pVolume->ReplicaInfo,
                &pVolume->FtModification,
                &pBuffer);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Get deleted replicas
    //

    if (pBuffer < (pBuffer + VolProps.cbSvc)) {

        dwErr = UnSerializeReplicaList(
                    &pVolume->DelReplCount,
                    &pVolume->AllocatedDelReplCount,
                    &pVolume->DelReplicaInfo,
                    &pVolume->DelFtModification,
                    &pBuffer);

    }

Cleanup:

    if (VolProps.pSvc != NULL)
        MarshalBufferFree(VolProps.pSvc);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsGetVolume returning %d\r\n", dwErr);

    return dwErr;

}

//+------------------------------------------------------------------------
//
// Function:    DfsFreeVolList
//
// Synopsis:    Frees the volume list and associated substructures representing
//              an FtDfs.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

VOID
DfsFreeVolList(
    PDFS_VOLUME_LIST pDfsVolList)
{
    ULONG cVol;
    ULONG cSite;
    ULONG i;
    PLIST_ENTRY pListHead;
    PDFSM_SITE_ENTRY pSiteEntry;

    if (pDfsVolList->VolCount > 0 && pDfsVolList->Volumes) {
        for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {
            DfsFreeVol(pDfsVolList->Volumes[cVol]);
            free(pDfsVolList->Volumes[cVol]);
            pDfsVolList->Volumes[cVol] = NULL;
        }
        pDfsVolList->VolCount = 0;
    }

    if (pDfsVolList->Volumes != NULL) {
        free(pDfsVolList->Volumes);
	pDfsVolList->Volumes = NULL;
    }

    if (pDfsVolList->RootServers != NULL) {
        free(pDfsVolList->RootServers);
	pDfsVolList->RootServers = NULL;
    }

    pListHead = &pDfsVolList->SiteList;

    if (pListHead->Flink != NULL) {
        while (pListHead->Flink != pListHead) {
            pSiteEntry = CONTAINING_RECORD(pListHead->Flink, DFSM_SITE_ENTRY, Link);
            RemoveEntryList(pListHead->Flink);
            for (i = 0; i < pSiteEntry->Info.cSites; i++) {
                if (pSiteEntry->Info.Site[i].SiteName != NULL)
                    MarshalBufferFree(pSiteEntry->Info.Site[i].SiteName);
            }
            if (pSiteEntry->ServerName != NULL)
                MarshalBufferFree(pSiteEntry->ServerName);
            free(pSiteEntry);
        }
    }
}

VOID
DfsFreeRootLocalVol(
    PDFS_ROOTLOCALVOL pRootLocalVol,
    ULONG cRootLocalVol)
{
    ULONG cRoot;
    ULONG cVol;

    if (pRootLocalVol == NULL)
        return;

    for (cRoot = 0; cRoot < cRootLocalVol; cRoot++) {
        if (pRootLocalVol[cRoot].wszObjectName != NULL)
            delete [] pRootLocalVol[cRoot].wszObjectName;
        if (pRootLocalVol[cRoot].wszEntryPath)
            delete [] pRootLocalVol[cRoot].wszEntryPath;
        if (pRootLocalVol[cRoot].wszShortEntryPath)
            delete [] pRootLocalVol[cRoot].wszShortEntryPath;
        if (pRootLocalVol[cRoot].wszShareName)
            delete [] pRootLocalVol[cRoot].wszShareName;
        if (pRootLocalVol[cRoot].wszStorageId)
            delete [] pRootLocalVol[cRoot].wszStorageId;

        for (cVol = 0; cVol < pRootLocalVol[cRoot].cLocalVolCount; cVol++) {
            if (pRootLocalVol[cRoot].pDfsLocalVol[cVol].wszObjectName != NULL)
                delete [] pRootLocalVol[cRoot].pDfsLocalVol[cVol].wszObjectName;
            if (pRootLocalVol[cRoot].pDfsLocalVol[cVol].wszEntryPath != NULL)
                delete pRootLocalVol[cRoot].pDfsLocalVol[cVol].wszEntryPath;
        }
        if (pRootLocalVol[cRoot].pDfsLocalVol)
            delete [] pRootLocalVol[cRoot].pDfsLocalVol;
    }
    delete [] pRootLocalVol;
}

//+------------------------------------------------------------------------
//
// Function:    DfsFreeVol
//
// Synopsis:    Frees the volume and associated substructures representing
//              an FtDfs volume
//
// History:     12/16/98 JHarper Created
//
//-------------------------------------------------------------------------

VOID
DfsFreeVol(
    PDFS_VOLUME pVol)
{
    ULONG cRepl;

    if (pVol->ReplCount > 0 && pVol->ReplicaInfo != NULL) {
        for (cRepl = 0; cRepl < pVol->ReplCount; cRepl++) {
            DfsFreeRepl(&pVol->ReplicaInfo[cRepl]);
        }
    }

    if (pVol->DelReplCount > 0 && pVol->DelReplicaInfo != NULL) {
        for (cRepl = 0; cRepl < pVol->DelReplCount; cRepl++) {
            DfsFreeRepl(&pVol->DelReplicaInfo[cRepl]);
        }
    }

    if (pVol->wszPrefix != NULL)
        MarshalBufferFree(pVol->wszPrefix);
    if (pVol->wszShortPrefix != NULL)
        MarshalBufferFree(pVol->wszShortPrefix);
    if (pVol->wszComment != NULL)
        MarshalBufferFree(pVol->wszComment);
    if (pVol->pRecovery != NULL)
        MarshalBufferFree(pVol->pRecovery);

    if (pVol->ReplicaInfo != NULL)
        free(pVol->ReplicaInfo);
    if (pVol->DelReplicaInfo != NULL)
        free(pVol->DelReplicaInfo);
    if (pVol->FtModification != NULL)
        free(pVol->FtModification);
    if (pVol->DelFtModification != NULL)
        free(pVol->DelFtModification);
    if (pVol->wszObjectName != NULL)
        free(pVol->wszObjectName);

    RtlZeroMemory(pVol, sizeof(DFS_VOLUME));

}

//+------------------------------------------------------------------------
//
// Function:    DfsFreeRepl
//
// Synopsis:    Frees the Replica and associated substructures representing
//              an FtDfs replica
//
// History:     12/16/98 JHarper Created
//
//-------------------------------------------------------------------------

VOID
DfsFreeRepl(
    PDFS_REPLICA_INFO pRepl)
{
    if (pRepl->pwszServerName != NULL)
        MarshalBufferFree(pRepl->pwszServerName);

    if (pRepl->pwszShareName != NULL)
        MarshalBufferFree(pRepl->pwszShareName);

    RtlZeroMemory(pRepl, sizeof(DFS_REPLICA_INFO));
}


//+------------------------------------------------------------------------
//
// Function:    DfsPutVolList
//
// Synopsis:    Serializes the structs representing a Dfs volume and
//              creates a BLOB.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsPutVolList(
    ULONG *pcbBlob,
    BYTE **ppBlob,
    PDFS_VOLUME_LIST pDfsVolList)
{
    ULONG cVol;
    ULONG cRepl;
    ULONG cObj;
    ULONG cBuffer = 0;
    ULONG dwRecovery = 0;
    ULONG cSite;
    DWORD dwErr = ERROR_SUCCESS;
    PBYTE Buffer;
    MARSHAL_BUFFER marshalBuffer;
    NTSTATUS NtStatus;
    DFS_VOLUME_PROPERTIES VolProps;
    LDAP_PKT LdapPkt;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    PDFSM_SITE_ENTRY pSiteEntry;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsPutVolList()\r\n");

    LdapPkt.cLdapObjects = pDfsVolList->VolCount + 1;
    LdapPkt.rgldapObjects = (PLDAP_OBJECT) malloc(LdapPkt.cLdapObjects * sizeof(LDAP_OBJECT));

    if (LdapPkt.rgldapObjects == NULL) {
        dwErr =  ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(LdapPkt.rgldapObjects, LdapPkt.cLdapObjects * sizeof(LDAP_OBJECT));

    //
    // For each volume, serialize the replicas, then the volume
    //

    for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {

        RtlZeroMemory(&VolProps, sizeof(DFS_VOLUME_PROPERTIES));

        LdapPkt.rgldapObjects[cVol].wszObjectName = (WCHAR *) MarshalBufferAllocate(
                (wcslen(pDfsVolList->Volumes[cVol]->wszObjectName)+1) * sizeof(WCHAR));

        if (LdapPkt.rgldapObjects[cVol].wszObjectName == NULL) {
            dwErr =  ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        wcscpy(
            LdapPkt.rgldapObjects[cVol].wszObjectName,
            pDfsVolList->Volumes[cVol]->wszObjectName);

        //
        // Serialize the replicas
        //

        dwErr = SerializeReplicaList(
                    pDfsVolList->Volumes[cVol]->ReplCount,
                    pDfsVolList->Volumes[cVol]->ReplicaInfo,
                    pDfsVolList->Volumes[cVol]->FtModification,
                    pDfsVolList->Volumes[cVol]->DelReplCount,
                    pDfsVolList->Volumes[cVol]->DelReplicaInfo,
                    pDfsVolList->Volumes[cVol]->DelFtModification,
                    &VolProps.cbSvc,
                    &VolProps.pSvc);

        if (dwErr != ERROR_SUCCESS) {
            dwErr =  ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        if (fSwDebug == TRUE)
            MyPrintf(L"   cbSvc = %d\r\n", VolProps.cbSvc);

        VolProps.idVolume = pDfsVolList->Volumes[cVol]->idVolume;
        VolProps.wszPrefix = pDfsVolList->Volumes[cVol]->wszPrefix;
        VolProps.wszShortPrefix = pDfsVolList->Volumes[cVol]->wszShortPrefix;
        VolProps.dwType = pDfsVolList->Volumes[cVol]->dwType;
        VolProps.dwState = pDfsVolList->Volumes[cVol]->dwState;
        VolProps.wszComment = pDfsVolList->Volumes[cVol]->wszComment;
        VolProps.dwTimeout = pDfsVolList->Volumes[cVol]->dwTimeout;
        VolProps.ftPrefix = pDfsVolList->Volumes[cVol]->ftPrefix;
        VolProps.ftState = pDfsVolList->Volumes[cVol]->ftState;
        VolProps.ftComment = pDfsVolList->Volumes[cVol]->ftComment;
        VolProps.dwVersion = pDfsVolList->Volumes[cVol]->dwVersion;

        if (pDfsVolList->Volumes[cVol]->cbRecovery != 0) {
            VolProps.cbRecovery = pDfsVolList->Volumes[cVol]->cbRecovery;
            VolProps.pRecovery = pDfsVolList->Volumes[cVol]->pRecovery;
        } else {
            VolProps.pRecovery = (PBYTE) MarshalBufferAllocate(sizeof(DWORD));
            if (VolProps.pRecovery != NULL) {
                RtlZeroMemory(VolProps.pRecovery, sizeof(DWORD));
                VolProps.cbRecovery = sizeof(DWORD);
            } else {
                VolProps.cbRecovery = 0;
                VolProps.pRecovery = NULL;
            }
        }

        //
        // Now serialize the volume

        cBuffer = 0;
        NtStatus = DfsRtlSize(&MiVolumeProperties, &VolProps, &cBuffer);

        if (!NT_SUCCESS(NtStatus)) {
            MarshalBufferFree(VolProps.pSvc);
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        cBuffer += sizeof(ULONG);

        if (fSwDebug == TRUE)
            MyPrintf(L"VolProps marshaled size = %d\r\n", cBuffer);

        Buffer = (PBYTE) MarshalBufferAllocate(cBuffer);

        if (Buffer == NULL) {
            MarshalBufferFree(VolProps.pSvc);
            dwErr =  ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        LdapPkt.rgldapObjects[cVol].pObjectData = (PCHAR) Buffer;
        LdapPkt.rgldapObjects[cVol].cbObjectData =  cBuffer;

        MarshalBufferInitialize(
            &marshalBuffer,
            cBuffer,
            Buffer);

        NtStatus = DfsRtlPut(&marshalBuffer, &MiVolumeProperties, &VolProps);

        if (!NT_SUCCESS(NtStatus)) {
            MarshalBufferFree(VolProps.pSvc);
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        NtStatus = DfsRtlPutUlong(&marshalBuffer, &VolProps.dwTimeout);

        if (!NT_SUCCESS(NtStatus)) {
            MarshalBufferFree(VolProps.pSvc);
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        MarshalBufferFree(VolProps.pSvc);

    }

    //
    // Serialize the site table
    //

    cBuffer = sizeof(ULONG) + sizeof(GUID);

    //
    // Add the size of all the entries
    //

    pListHead = &pDfsVolList->SiteList;

    if (pListHead->Flink != NULL) {
        for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
            pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
            if (fSwDebug == TRUE)
                MyPrintf(L"pSiteEntry for %ws\r\n", pSiteEntry->ServerName);
            NtStatus = DfsRtlSize(&MiDfsmSiteEntry, pSiteEntry, &cBuffer);
            if (!NT_SUCCESS(NtStatus)) {
                dwErr =  RtlNtStatusToDosError(NtStatus);
                goto Cleanup;
            }
        }
    }

    //
    // Get a buffer big enough
    //

    Buffer = (BYTE *) MarshalBufferAllocate(cBuffer);

    if (Buffer == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    LdapPkt.rgldapObjects[pDfsVolList->VolCount].wszObjectName =
                    (WCHAR *)MarshalBufferAllocate(sizeof(L"\\siteroot"));
    if (LdapPkt.rgldapObjects[pDfsVolList->VolCount].wszObjectName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    wcscpy(LdapPkt.rgldapObjects[pDfsVolList->VolCount].wszObjectName, L"\\siteroot");
    LdapPkt.rgldapObjects[pDfsVolList->VolCount].pObjectData = (PCHAR) Buffer;
    LdapPkt.rgldapObjects[pDfsVolList->VolCount].cbObjectData =  cBuffer;

    MarshalBufferInitialize(
          &marshalBuffer,
          cBuffer,
          Buffer);

    //
    // Put the guid, then the object count in the beginning of the buffer
    //

    DfsRtlPutGuid(&marshalBuffer, &pDfsVolList->SiteGuid);
    DfsRtlPutUlong(&marshalBuffer, &pDfsVolList->SiteCount);

    if (pListHead->Flink != NULL) {
        for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
            pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
            DfsRtlPut(&marshalBuffer,&MiDfsmSiteEntry, pSiteEntry);
            if (!NT_SUCCESS(NtStatus)) {
                dwErr =  RtlNtStatusToDosError(NtStatus);
                goto Cleanup;
            }
        }
    }

    if (fSwDebug == TRUE) {

        MyPrintf(L"After reserialization,  %d objects found\r\n", LdapPkt.cLdapObjects);

        for (cObj = 0; cObj < LdapPkt.cLdapObjects; cObj++) {

            MyPrintf(L"%d:name=%ws size=%d p=0x%p\r\n",
                cObj,
                LdapPkt.rgldapObjects[cObj].wszObjectName,
                LdapPkt.rgldapObjects[cObj].cbObjectData,
                LdapPkt.rgldapObjects[cObj].pObjectData);

            // DumpBuf(
            //     LdapPkt.rgldapObjects[cObj].pObjectData,
            //     LdapPkt.rgldapObjects[cObj].cbObjectData);
        }

    }

    //
    // Finally, serialize all the volumes and the site table into a blob
    //

    cBuffer = 0;
    NtStatus = DfsRtlSize(&MiLdapPkt, &LdapPkt, &cBuffer);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(dwErr);
        goto Cleanup;
    }

    cBuffer += sizeof(DWORD);

    if (fSwDebug == TRUE)
        MyPrintf(L"New ldap size = %d\r\n", cBuffer);

    Buffer = (PBYTE) malloc(cBuffer);

    if (Buffer == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    *((PDWORD) Buffer) = 2;             // Version #
    MarshalBufferInitialize(
        &marshalBuffer,
        cBuffer,
        Buffer + sizeof(DWORD));

    NtStatus = DfsRtlPut(&marshalBuffer, &MiLdapPkt, &LdapPkt);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(dwErr);
        goto Cleanup;
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"Remarshal succeeded cBuffer = %d\r\n", cBuffer);

    *pcbBlob = cBuffer;
    *ppBlob = Buffer;
    Buffer = NULL;

Cleanup:

    FreeLdapPkt(&LdapPkt);

    if (dwErr != ERROR_SUCCESS && Buffer != NULL)
        free(Buffer);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsPutVolList exit %d\r\n", dwErr);

    return dwErr;

}

//+------------------------------------------------------------------------
//
// Function:    FreeLdapPkt
//
// Synopsis:    Frees an LDAP_PKT structure and all substructures.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

VOID
FreeLdapPkt(
    LDAP_PKT *pLdapPkt)
{
    ULONG cObj;

    if (pLdapPkt->rgldapObjects != NULL) {

        for (cObj = 0; cObj < pLdapPkt->cLdapObjects; cObj++) {
            if (pLdapPkt->rgldapObjects[cObj].wszObjectName != NULL)
                MarshalBufferFree(pLdapPkt->rgldapObjects[cObj].wszObjectName);
            if (pLdapPkt->rgldapObjects[cObj].pObjectData != NULL)
                MarshalBufferFree(pLdapPkt->rgldapObjects[cObj].pObjectData);
        }
        MarshalBufferFree(pLdapPkt->rgldapObjects);
    }

}

//+------------------------------------------------------------------------
//
// Function:    SerializeReplicaList
//
// Synopsis:    This method serializes the replica info list and the
//              deleted replica info list into a buffer.
//
// Returns:     [ERROR_SUCCESS] -- If all went well.
//
//              [ERROR_OUTOFMEMORY] - If unable to allocate the target buffer.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------
DWORD
SerializeReplicaList(
    ULONG ReplCount,
    DFS_REPLICA_INFO *pReplicaInfo,
    FILETIME *pFtModification,
    ULONG DelReplCount,
    DFS_REPLICA_INFO *pDelReplicaInfo,
    FILETIME *pDelFtModification,
    ULONG *cBuffer,
    PBYTE *ppBuffer)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG TotalSize;
    ULONG i;
    ULONG *pSize;
    BYTE *Buffer = NULL;
    ULONG *SizeBuffer = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"SerializeReplicaList(%d,%d)\r\n", ReplCount, DelReplCount);

    pSize = SizeBuffer = (PULONG) malloc(sizeof(ULONG) * (ReplCount + DelReplCount));

    if (SizeBuffer == NULL) {

        return ERROR_OUTOFMEMORY;

    }

    //
    // Need all the size values now and later for marshalling stuff.
    // So we collect them here into an array.
    //

    TotalSize = 0;
    pSize = SizeBuffer;

    for (i = 0; i < ReplCount; i++) {

        *pSize = GetReplicaMarshalSize(&pReplicaInfo[i], &pFtModification[i]);
        TotalSize += *pSize;
        pSize++;

    }

    for (i = 0; i < DelReplCount; i++) {

        *pSize = GetReplicaMarshalSize(&pDelReplicaInfo[i], &pDelFtModification[i]);
        TotalSize += *pSize;
        pSize++;

    }

    //
    // Allocate the byte Buffer we need to pass back
    //
    // TotalSize is the size required just to marshal all the replicas and
    // their last-modification-timestamps.
    //
    // In addition, we need:
    //
    //  1 ULONG for storing the count of replicas
    //  ReplCount ULONGs for storing the marshal size of each replica.
    //  1 ULONG for count of deleted replicas
    //  DelReplCount ULONGS for storing the marshal size of each deleted Repl
    //

    //
    // First calc the size of the Buffer.
    //

    TotalSize += sizeof(ULONG) * (1 + ReplCount + 1 + DelReplCount);

    *ppBuffer = Buffer = (PBYTE) malloc(TotalSize);

    if (Buffer == NULL) {
        free(SizeBuffer);
        return ERROR_OUTOFMEMORY;
    }

    //
    // Set the number of entries to follow in the Buffer at the start.
    //

    _PutULong(Buffer, ReplCount);
    Buffer += sizeof(ULONG);

    pSize = SizeBuffer;
    for (i = 0; i < ReplCount; i++) {

        //
        // Marshall each replica Entry into the Buffer.
        // Remember we first need to put the size of the marshalled
        // replica entry to follow, then the FILETIME for the replica,
        // and finally, the marshalled replica entry structure.
        //

        _PutULong(Buffer, *pSize);
        Buffer += sizeof(ULONG);
        dwErr = SerializeReplica(
                    &pReplicaInfo[i],
                    pFtModification ? &pFtModification[i] : NULL,
                    Buffer,
                    *pSize);
        if (dwErr != ERROR_SUCCESS) {
            free(*ppBuffer);
            return dwErr;
        }
        Buffer += *pSize;
        pSize++;

    }

    //
    // Now marshal the deleted Repl list.
    //

    _PutULong(Buffer, DelReplCount);
    Buffer += sizeof(ULONG);

    for (i = 0; i < DelReplCount; i++) {

        _PutULong(Buffer, *pSize);
        Buffer += sizeof(ULONG);
        dwErr = SerializeReplica(
                    &pDelReplicaInfo[i],
                    pDelFtModification ? &pDelFtModification[i] : NULL,
                    Buffer,
                    *pSize);
        if (dwErr != ERROR_SUCCESS) {
            free(*ppBuffer);
            return dwErr;
        }
        Buffer += *pSize;
        pSize++;
    }

    *cBuffer = TotalSize;

    if (fSwDebug == TRUE)
        MyPrintf(L"SerializeReplicaList exit %d\r\n", dwErr);

    return( dwErr );

}

//+------------------------------------------------------------------------
//
// Member:      SerializeReplica
//
// Synopsis:    Serializes a replica info structure
//
// Notes:       The size of the buffer should have been calculated using
//              the function GetReplicaMarshalSize()
//
// History:     13-May-93       SudK    Created.
//              19-Nov-98       Jharper Modified.
//
//-------------------------------------------------------------------------
DWORD
SerializeReplica(
    DFS_REPLICA_INFO *pDfsReplicaInfo,
    FILETIME *pFtModification,
    PBYTE Buffer,
    ULONG Size)
{
    DWORD dwErr;
    MARSHAL_BUFFER MarshalBuffer;
    NTSTATUS NtStatus;
    SYSTEMTIME st;
    FILETIME FtModification;

    if (pFtModification == NULL) {
        GetSystemTime( &st );
        SystemTimeToFileTime( &st, &FtModification );
        pFtModification = &FtModification;
    }
    MarshalBufferInitialize(&MarshalBuffer, Size, Buffer);
    NtStatus = DfsRtlPut(&MarshalBuffer, &MiFileTime, pFtModification);

    if (NT_SUCCESS(NtStatus))
        NtStatus = DfsRtlPut(&MarshalBuffer, &MiDfsReplicaInfo, pDfsReplicaInfo);

    dwErr =  RtlNtStatusToDosError(NtStatus);
    return dwErr;
}

//+----------------------------------------------------------------------
//
// Member:      GetReplicaMarshalSize, public
//
// Synopsis:    Returns the size of a buffer required to marshal this
//              replica.
//
// History:     12-May-93       SudK    Created.
//              19-Nov-98       Jharper Modified.
//
//-----------------------------------------------------------------------

ULONG
GetReplicaMarshalSize(
    DFS_REPLICA_INFO *pDfsReplicaInfo,
    FILETIME *pFtModification)
{
    ULONG Size = 0;
    NTSTATUS NtStatus;
    SYSTEMTIME st;
    FILETIME FtModification;

    if (pFtModification == NULL) {
        GetSystemTime( &st );
        SystemTimeToFileTime( &st, &FtModification );
        pFtModification = &FtModification;
    }
    NtStatus = DfsRtlSize(&MiFileTime, pFtModification, &Size);

    if (NT_SUCCESS(NtStatus))
        NtStatus = DfsRtlSize(&MiDfsReplicaInfo, pDfsReplicaInfo, &Size);

    return(Size);

}

//+------------------------------------------------------------------------
//
// Member:      UnSerializeReplicaList
//
// Synopsis:    Unserializes a buffer into a relica list.
//
// History:     20-Nov-98       Jharper created
//
//-------------------------------------------------------------------------

DWORD
UnSerializeReplicaList(
    ULONG *pReplCount,
    ULONG *pAllocatedReplCount,
    DFS_REPLICA_INFO **ppReplicaInfo,
    FILETIME **ppFtModification,
    BYTE **ppBuffer)
{

    DFS_REPLICA_INFO *pReplicaInfo = NULL;
    FILETIME *pFtModification = NULL;
    ULONG ReplCount;
    BYTE *pBuffer = *ppBuffer;
    ULONG cRepl;
    ULONG Size;
    DWORD dwErr = ERROR_SUCCESS;
    MARSHAL_BUFFER marshalBuffer;
    NTSTATUS NtStatus;

    if (fSwDebug == TRUE)
        MyPrintf(L"UnSerializeReplicaList()\r\n");

    //
    // Get # replicas
    //

    _GetULong(pBuffer, ReplCount);
    pBuffer += sizeof(ULONG);

    pReplicaInfo = (DFS_REPLICA_INFO *) malloc(sizeof(DFS_REPLICA_INFO) * ReplCount);
    pFtModification = (FILETIME *) malloc(sizeof(FILETIME) * ReplCount);
    if(pReplicaInfo == NULL || pFtModification == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Now get each replica
    //

    for (cRepl = 0; cRepl < ReplCount; cRepl++) {

        _GetULong(pBuffer, Size);
        pBuffer += sizeof(ULONG);

        MarshalBufferInitialize(
            &marshalBuffer,
            Size,
            pBuffer);

        NtStatus = DfsRtlGet(
                        &marshalBuffer,
                        &MiFileTime,
                        &pFtModification[cRepl]);

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = DfsRtlGet(
                        &marshalBuffer,
                        &MiDfsReplicaInfo,
                        &pReplicaInfo[cRepl]);

        }

        if (NT_SUCCESS(NtStatus)) {

            pBuffer += Size;

        }

    }

    *ppReplicaInfo = pReplicaInfo;
    *ppFtModification = pFtModification;
    *ppBuffer = pBuffer;
    *pAllocatedReplCount = *pReplCount = ReplCount;

Cleanup:

    if (dwErr != ERROR_SUCCESS) {
        if (pReplicaInfo != NULL)
            free(pReplicaInfo);
        if (pFtModification != NULL)
            free(pFtModification);
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"UnSerializeReplicaList exit %d\r\n", dwErr);

    return dwErr;

}

//+------------------------------------------------------------------------
//
// Function:    DfsGetSiteTable
//
// Synopsis:    Unserializes the buffer passed in into a dfs site table.
//
// Returns:     [ERROR_SUCCESS] -- If all went well.
//
//              [ERROR_OUTOFMEMORY] - If unable to allocate the target buffer.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsGetSiteTable(
    PDFS_VOLUME_LIST pDfsVolList,
    PLDAP_OBJECT pLdapObject)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    ULONG cSite;
    PDFSM_SITE_ENTRY pSiteEntry;
    PDFSM_SITE_ENTRY pTmpSiteEntry;
    MARSHAL_BUFFER marshalBuffer;
    BYTE *pBuffer = NULL;
    ULONG Size;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsGetSiteTable(%d)\r\n", pLdapObject->cbObjectData);

    InitializeListHead(&pDfsVolList->SiteList);

    MarshalBufferInitialize(
      &marshalBuffer,
      pLdapObject->cbObjectData,
      pLdapObject->pObjectData);

    NtStatus = DfsRtlGetGuid(&marshalBuffer, &pDfsVolList->SiteGuid);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr =  RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    NtStatus = DfsRtlGetUlong(&marshalBuffer, &pDfsVolList->SiteCount);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr =  RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    pBuffer = (BYTE *)malloc(pLdapObject->cbObjectData);

    if (pBuffer == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    pTmpSiteEntry = (PDFSM_SITE_ENTRY)pBuffer;

    for (cSite = 0; cSite < pDfsVolList->SiteCount; cSite++) {

        RtlZeroMemory(pBuffer, pLdapObject->cbObjectData);

        NtStatus = DfsRtlGet(
                        &marshalBuffer,
                        &MiDfsmSiteEntry,
                        pBuffer);

        if (!NT_SUCCESS(NtStatus)) {
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        Size = sizeof(DFSM_SITE_ENTRY) + (pTmpSiteEntry->Info.cSites * sizeof(DFS_SITENAME_INFO));

        pSiteEntry = (PDFSM_SITE_ENTRY) malloc(Size);

        if (pSiteEntry == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        RtlCopyMemory(pSiteEntry, pBuffer, Size);
        InsertHeadList(&pDfsVolList->SiteList, &pSiteEntry->Link);

    }

Cleanup:

    if (pBuffer != NULL)
        free(pBuffer);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsGetSiteTable exit dwErr=%d\r\n", dwErr);

    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetNetInfoEx
//
//  Synopsis:   Gets information about the volume.
//
//  Arguments:  [Level] -- Level of Information desired.
//
//              [pDfsVol] - Pointer to DFS_VOLUME to use to fill the info
//
//              [pInfo] -- Pointer to info struct to be filled. Pointer
//                      members will be allocated using MIDL_user_allocate.
//                      The type of this variable is LPDFS_INFO_3, but one
//                      can pass in pointers to lower levels, and only the
//                      fields appropriate for the level will be touched.
//
//              [pcbInfo] -- On successful return, contains the size in
//                      bytes of the returned info. The returned size does
//                      not include the size of the DFS_INFO_3 struct itself.
//
//  Returns:    ERROR_SUCCESS -- Successfully returning info
//
//              ERROR_OUTOFMEMORY -- Out of memory
//
//-----------------------------------------------------------------------------

DWORD
GetNetInfoEx(
    PDFS_VOLUME pDfsVol,
    DWORD Level,
    LPDFS_INFO_3 pInfo,
    LPDWORD pcbInfo)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbInfo = 0;
    DWORD cbItem;
    ULONG i;

    if (fSwDebug == TRUE)
        MyPrintf(L"GetNetInfoEx(%ws,%d)\r\n", pDfsVol->wszPrefix, Level);

    //
    // See if this is a Level 100 or 101. If so, we handle them right away
    // and return

    if (Level == 100) {

        LPDFS_INFO_100  pInfo100 = (LPDFS_INFO_100) pInfo;

        if (pDfsVol->wszComment != NULL) {
            cbItem = (wcslen(pDfsVol->wszComment) + 1) * sizeof(WCHAR);
            pInfo100->Comment = (LPWSTR) MIDL_user_allocate(cbItem);
            if (pInfo100->Comment != NULL) {
                wcscpy(pInfo100->Comment, pDfsVol->wszComment);
                cbInfo += cbItem;
                goto AllDone;
            } else {
                dwErr = ERROR_OUTOFMEMORY;
                goto AllDone;
            }
        } else {
            pInfo100->Comment = (LPWSTR) MIDL_user_allocate(sizeof(WCHAR));
            if (pInfo100->Comment != NULL) {
                pInfo100->Comment[0] = UNICODE_NULL;
                cbInfo += sizeof(WCHAR);
                goto AllDone;
            } else {
                dwErr = ERROR_OUTOFMEMORY;
                goto AllDone;
            }
        }

    }

    if (Level == 101) {

        LPDFS_INFO_101 pInfo101 = (LPDFS_INFO_101) pInfo;

        pInfo->State = pDfsVol->dwState;
        goto AllDone;

    }

    //
    // level 4 isn't just an extension of 3, so handle it seperately
    //

    if (Level == 4) {

        LPDFS_INFO_4 pInfo4 = (LPDFS_INFO_4) pInfo;

        cbItem = sizeof(UNICODE_PATH_SEP) + (wcslen(pDfsVol->wszPrefix) + 1) * sizeof(WCHAR);
        pInfo4->EntryPath = (LPWSTR) MIDL_user_allocate(cbItem);
        if (pInfo4->EntryPath != NULL) {
            pInfo4->EntryPath[0] = UNICODE_PATH_SEP;
            wcscpy(&pInfo4->EntryPath[1], pDfsVol->wszPrefix);
            cbInfo += cbItem;
        } else {
            dwErr = ERROR_OUTOFMEMORY;
            goto AllDone;
        }

        if (pDfsVol->wszComment != NULL) {
            cbItem = (wcslen(pDfsVol->wszComment)+1) * sizeof(WCHAR);
            pInfo4->Comment = (LPWSTR) MIDL_user_allocate(cbItem);
            if (pInfo4->Comment != NULL) {
                wcscpy( pInfo4->Comment, pDfsVol->wszComment );
                cbInfo += cbItem;
            } else {
                dwErr = ERROR_OUTOFMEMORY;
                goto AllDone;
            }
        } else {
            pInfo4->Comment = (LPWSTR) MIDL_user_allocate(sizeof(WCHAR));
            if (pInfo4->Comment != NULL) {
                pInfo4->Comment[0] = UNICODE_NULL;
                cbInfo += sizeof(WCHAR);
            } else {
                dwErr = ERROR_OUTOFMEMORY;
                goto AllDone;
            }
        }

        pInfo4->State = pDfsVol->dwState;
        pInfo4->Timeout = pDfsVol->dwTimeout;
        pInfo4->Guid = pDfsVol->idVolume;
        pInfo4->NumberOfStorages = pDfsVol->ReplCount;
        cbItem = pInfo4->NumberOfStorages * sizeof(DFS_STORAGE_INFO);
        pInfo4->Storage = (LPDFS_STORAGE_INFO) MIDL_user_allocate(cbItem);
        if (pInfo4->Storage != NULL) {
            cbInfo += cbItem;
            for (i = 0; i < pDfsVol->ReplCount; i++) {
                dwErr = GetNetStorageInfo(&pDfsVol->ReplicaInfo[i],&pInfo4->Storage[i],&cbItem);
                cbInfo += cbItem;
            }
            if (dwErr != ERROR_SUCCESS) {
                for (; i > 0; i--) {
                    MIDL_user_free(pInfo4->Storage[i-1].ServerName);
                    MIDL_user_free(pInfo4->Storage[i-1].ShareName);
                }
            }
        } else {
            dwErr = ERROR_OUTOFMEMORY;
        }

        //
        // See if we need to clean up...
        //

        if (dwErr != ERROR_SUCCESS) {
            if (pInfo4->EntryPath != NULL) {
                MIDL_user_free(pInfo4->EntryPath);
            }
            if (pInfo4->Storage != NULL) {
                MIDL_user_free(pInfo4->Storage);
            }
            goto AllDone;
        } else {
            *pcbInfo = cbInfo;
        }
        goto AllDone;

    }

    //
    // Level is 1,2 or 3
    //

    //
    // Fill in the Level 1 stuff
    //

    cbItem = sizeof(UNICODE_PATH_SEP) + (wcslen(pDfsVol->wszPrefix)+1) * sizeof(WCHAR);
    pInfo->EntryPath = (LPWSTR) MIDL_user_allocate(cbItem);
    if (pInfo->EntryPath != NULL) {
        pInfo->EntryPath[0] = UNICODE_PATH_SEP;
        wcscpy(&pInfo->EntryPath[1], pDfsVol->wszPrefix);
        cbInfo += cbItem;
    } else {
        dwErr = ERROR_OUTOFMEMORY;
        goto AllDone;
    }

    //
    // Fill in the Level 2 stuff if needed
    //

    if (Level > 1) {
        pInfo->State = pDfsVol->dwState;
        pInfo->NumberOfStorages = pDfsVol->ReplCount;
        if (pDfsVol->wszComment != NULL) {
            cbItem = (wcslen(pDfsVol->wszComment)+1) * sizeof(WCHAR);
            pInfo->Comment = (LPWSTR) MIDL_user_allocate(cbItem);
            if (pInfo->Comment != NULL) {
                wcscpy( pInfo->Comment, pDfsVol->wszComment );
                cbInfo += cbItem;
            } else {
                dwErr = ERROR_OUTOFMEMORY;
            }
        } else {
            pInfo->Comment = (LPWSTR) MIDL_user_allocate(sizeof(WCHAR));
            if (pInfo->Comment != NULL) {
                pInfo->Comment[0] = UNICODE_NULL;
                cbInfo += sizeof(WCHAR);
            } else {
                dwErr = ERROR_OUTOFMEMORY;
            }
        }
    }

    //
    // Fill in the Level 3 stuff if needed
    //

    if (dwErr == ERROR_SUCCESS && Level > 2) {
        cbItem = pInfo->NumberOfStorages * sizeof(DFS_STORAGE_INFO);
        pInfo->Storage = (LPDFS_STORAGE_INFO) MIDL_user_allocate(cbItem);
        if (pInfo->Storage != NULL) {
            cbInfo += cbItem;
            for (i = 0; i < pDfsVol->ReplCount; i++) {
                dwErr = GetNetStorageInfo(&pDfsVol->ReplicaInfo[i], &pInfo->Storage[i], &cbItem);
                cbInfo += cbItem;
            }
            if (dwErr != ERROR_SUCCESS) {
                for (; i > 0; i--) {
                    MIDL_user_free(pInfo->Storage[i-1].ServerName);
                    MIDL_user_free(pInfo->Storage[i-1].ShareName);
                }
            }
        } else {
            dwErr = ERROR_OUTOFMEMORY;
        }
    }

    //
    // See if we need to clean up...
    //

    if (dwErr != ERROR_SUCCESS) {
        if (Level > 1) {
            if (pInfo->EntryPath != NULL) {
                MIDL_user_free(pInfo->EntryPath);
            }
        }
        if (Level > 2) {
            if (pInfo->Storage != NULL) {
                MIDL_user_free(pInfo->Storage);
            }
        }
    }

AllDone:

    //
    // Finally, we are done
    //

    if (dwErr == ERROR_SUCCESS)
        *pcbInfo = cbInfo;

    if (fSwDebug == TRUE)
        MyPrintf(L"GetNetInfoEx returning %d\r\n", dwErr);

    return(dwErr);

}

DWORD
GetNetStorageInfo(
    PDFS_REPLICA_INFO pRepl,
    LPDFS_STORAGE_INFO pInfo,
    LPDWORD pcbInfo)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR wszShare;
    DWORD cbInfo = 0, cbItem;

    if (fSwDebug == TRUE)
        MyPrintf(L"GetNetStorageInfo(\\\\%ws\\%ws)\r\n",
                    pRepl->pwszServerName,
                    pRepl->pwszShareName);

    pInfo->State = pRepl->ulReplicaState;

    cbItem = (wcslen(pRepl->pwszServerName) + 1) * sizeof(WCHAR);
    pInfo->ServerName = (LPWSTR) MIDL_user_allocate(cbItem);
    if (pInfo->ServerName != NULL) {
        wcscpy(pInfo->ServerName, pRepl->pwszServerName);
        cbInfo += cbItem;
    } else {
        dwErr = ERROR_OUTOFMEMORY;
    }

    if (dwErr == ERROR_SUCCESS) {
        cbItem = (wcslen(pRepl->pwszShareName) + 1) * sizeof(WCHAR);
        pInfo->ShareName = (LPWSTR) MIDL_user_allocate(cbItem);
        if (pInfo->ShareName != NULL) {
            wcscpy( pInfo->ShareName, pRepl->pwszShareName );
            cbInfo += cbItem;
        } else {
            MIDL_user_free( pInfo->ServerName );
            dwErr = ERROR_OUTOFMEMORY;
        }
    }

    if (dwErr == ERROR_SUCCESS)
        *pcbInfo = cbInfo;

    if (fSwDebug == TRUE)
        MyPrintf(L"GetStorageInfo returning %d\r\n", dwErr);

    return( dwErr );

}

//+------------------------------------------------------------------------
//
// Function:    DfsRemoveRootReplica
//
// Synopsis:    Removes a Dfs root replica from the dfs root replica list
//
// History:     12/16/98 JHarper Created
//
//-------------------------------------------------------------------------

DWORD
DfsRemoveRootReplica(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR RootName)
{
    ULONG cVol;
    ULONG cRepl;
    ULONG cRoot;
    DWORD dwErr = ERROR_SUCCESS;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsRemoveRootReplica(%ws)\r\n", RootName);


    for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {

        if (wcscmp(pDfsVolList->Volumes[cVol]->wszObjectName,L"\\domainroot") != 0)
            continue;

ScanReplicas:

        for (cRepl = 0; cRepl < pDfsVolList->Volumes[cVol]->ReplCount; cRepl++) {

            if (
                _wcsicmp(
                    pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].pwszServerName,
                    RootName) == 0
            ) {
                DfsReplDeleteByIndex(pDfsVolList->Volumes[cVol], cRepl);
                goto ScanReplicas;
            }

        }

        break;

    }

    //
    // Remove from RootServers list, if it is there
    //
ScanRoots:
    if (pDfsVolList->RootServers != NULL) {
        ULONG cCount = 0;
        for (cCount = 0; pDfsVolList->RootServers[cCount] != NULL; cCount++)
            NOTHING;
        for (cRoot = 0; cRoot < cCount; cRoot++) {
            if (fSwDebug == TRUE)
                MyPrintf(L" %d: %ws\r\n", cRoot, pDfsVolList->RootServers[cRoot]);
            if (wcslen(pDfsVolList->RootServers[cRoot]) > 2
                    &&
                _wcsnicmp(&pDfsVolList->RootServers[cRoot][2], RootName, wcslen(RootName)) == 0) {
	        LPWSTR VolRoot = &pDfsVolList->RootServers[cRoot][2];
		WCHAR Next = 0;
		if (wcslen(RootName) != wcslen(VolRoot)) {
		  Next = VolRoot[wcslen(RootName)];
		}
		MyPrintf(L"Found match: next is %wc\n", Next);
		
		if (Next == 0 || Next == L'.' || Next == L'\\') {
                   for (; cRoot < (cCount - 1); cRoot++)
                       pDfsVolList->RootServers[cRoot] = pDfsVolList->RootServers[cRoot+1];
                   pDfsVolList->RootServers[cCount-1] = NULL;
                   goto ScanRoots;
		}
            }
        }
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsRemoveRootReplica exit %d\r\n", dwErr);

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsRecoverVolList, public
//
//  Synopsis:   Walks the dfs_volume list, checking the recovery params, and
//              applying any recovery needed.  Also applies the deleted replica
//              list to the volume's replica list.
//
//  Arguments:  [pDfsVolList] -- Pointer to DFS_VOLUME_LIST work on.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsRecoverVolList(
    PDFS_VOLUME_LIST pDfsVolList)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG iVol;
    ULONG iRepl;
    ULONG iDelRepl;
    PDFS_VOLUME pVol;
    ULONG RecoveryState;
    ULONG Operation;
    ULONG OperState;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsRecoverVolList(%d volumes)\r\n", pDfsVolList->VolCount);

ReStart:
    for (iVol = 0; dwErr == ERROR_SUCCESS && iVol < pDfsVolList->VolCount; iVol++) {
        pVol = pDfsVolList->Volumes[iVol];
        if (pVol->cbRecovery >= sizeof(ULONG))  {
            _GetULong(pVol->pRecovery, RecoveryState);
            if (DFS_GET_RECOVERY_STATE(RecoveryState) != DFS_RECOVERY_STATE_NONE) {
                Operation = DFS_GET_RECOVERY_STATE(RecoveryState);
                OperState = DFS_GET_OPER_STAGE(RecoveryState);
                switch (Operation)  {
                case DFS_RECOVERY_STATE_CREATING:
                    if (fSwDebug == TRUE)
                        MyPrintf(L"DFS_RECOVERY_STATE_CREATING\r\n");
                    dwErr = DfsVolDelete(pDfsVolList, iVol);
                    goto ReStart;
                case DFS_RECOVERY_STATE_ADD_SERVICE:
                    if (fSwDebug == TRUE)
                        MyPrintf(L"DFS_RECOVERY_STATE_ADD_SERVICE\r\n");
                    // dwErr = RecoverFromAddService(OperState);
                    ASSERT(L"DFS_RECOVERY_STATE_ADD_SERVICE - WHY?\r\n");
                    break;
                case DFS_RECOVERY_STATE_REMOVE_SERVICE:
                    if (fSwDebug == TRUE)
                        MyPrintf(L"DFS_RECOVERY_STATE_REMOVE_SERVICE\r\n");
                    // dwErr = RecoverFromRemoveService(OperState);
                    ASSERT(L"DFS_RECOVERY_STATE_REMOVE_SERVICE - WHY?\r\n");
                    break;
                case DFS_RECOVERY_STATE_DELETE:
                    if (fSwDebug == TRUE)
                        MyPrintf(L"DFS_RECOVERY_STATE_DELETE\r\n");
                    dwErr = DfsVolDelete(pDfsVolList, iVol);
                    goto ReStart;
                default:
                    if (fSwDebug == TRUE)
                        MyPrintf(L"default\r\n");
                    dwErr = ERROR_INTERNAL_DB_CORRUPTION;
                }
            }
        }
        if (pVol->pRecovery != NULL)
            MarshalBufferFree(pVol->pRecovery);
        pVol->pRecovery = NULL;
        pVol->cbRecovery = 0;
    }

    if (dwErr != ERROR_SUCCESS)
        goto AllDone;

    //
    // Now apply deleted replica list to each volume
    //

    for (iVol = 0; dwErr == ERROR_SUCCESS && iVol < pDfsVolList->VolCount; iVol++) {
        pVol = pDfsVolList->Volumes[iVol];
        for (iDelRepl = 0; dwErr == ERROR_SUCCESS && iDelRepl < pVol->DelReplCount; iDelRepl++) {
#if 0   // XXX This appears to be wrong - don't do it.
            dwErr = DfsReplDeleteByName(
                            pVol,
                            pVol->DelReplicaInfo[iDelRepl].pwszServerName,
                            pVol->DelReplicaInfo[iDelRepl].pwszShareName);
#endif
            DfsFreeRepl(&pVol->DelReplicaInfo[iDelRepl]);
        }
        if (pVol->DelReplicaInfo != NULL) {
            free(pVol->DelReplicaInfo);
            pVol->DelReplicaInfo = NULL;
        }
        if (pVol->DelFtModification != NULL) {
            free(pVol->DelFtModification);
            pVol->DelFtModification = NULL;
        }
        pVol->DelReplCount = 0;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsRecoverVolList returning %d\r\n", dwErr);
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsVolDelete, public
//
//  Synopsis:   Removes a  DFS_VOLUME from DFS_VOLUME_LIST
//
//  Arguments:  [pDfsVolList] -- Pointer to DFS_VOLUME_LIST work on.
//              [iVol] -- Index of volume to delete
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsVolDelete(
    PDFS_VOLUME_LIST pDfsVolList,
    ULONG iVol)
{
    ULONG i;
    DWORD dwErr = ERROR_SUCCESS;

    ASSERT(iVol < pDfsVolList->VolCount);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsVolDelete(%d)\r\n", iVol);

    //
    // Free any memory this Volume is using
    //

    DfsFreeVol(pDfsVolList->Volumes[iVol]);
    free(pDfsVolList->Volumes[iVol]);
    pDfsVolList->Volumes[iVol] = NULL;

    //
    // Since we're shrinking the list, we simply clip out the entry we don't want
    // and adjust the count.
    //
    for (i = iVol+1; i < pDfsVolList->VolCount; i++)
        pDfsVolList->Volumes[i-1] = pDfsVolList->Volumes[i];

    pDfsVolList->VolCount--;
    pDfsVolList->Volumes[pDfsVolList->VolCount] = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsVolDelete returning %d\r\n", dwErr);
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsReplDeleteByIndex, public
//
//  Synopsis:   Removes a  PDFS_REPLICA_INFO from a DFS_VOLUME's replica list
//
//  Arguments:  [pDfsVol] -- Pointer to DFS_VOLUME work on.
//              [iRepl] -- Index of replica to delete
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsReplDeleteByIndex(
    PDFS_VOLUME pVol,
    ULONG iRepl)
{
    ULONG i;
    DWORD dwErr = ERROR_SUCCESS;

    ASSERT(iRepl < pVol->ReplCount);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsReplDeleteByIndex(%d)\r\n", iRepl);

    //
    // Free any memory this replica is using
    //

    DfsFreeRepl(&pVol->ReplicaInfo[iRepl]);

    //
    // Since we're shrinking the list(s), we simply clip out the entry we don't want
    // and adjust the count.
    //
    for (i = iRepl+1; i < pVol->ReplCount; i++) {
        pVol->ReplicaInfo[i-1] = pVol->ReplicaInfo[i];
        pVol->FtModification[i-1] = pVol->FtModification[i];
    }

    pVol->ReplCount--;
    RtlZeroMemory(&pVol->ReplicaInfo[pVol->ReplCount], sizeof(DFS_REPLICA_INFO));


    if (fSwDebug == TRUE)
        MyPrintf(L"DfsReplDeleteByIndex returning %d\r\n", dwErr);
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsReplDeleteByName, public
//
//  Synopsis:   Removes a  PDFS_REPLICA_INFO from a DFS_VOLUME's replica list. Simply
//              looks up the replica by name and then calls DfsReplDeleteByIndex()
//
//  Arguments:  [pDfsVol] -- Pointer to DFS_VOLUME work on.
//              [pwszServername] - Server Name
//              [pwszShareName] - Share Name
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsReplDeleteByName(
    PDFS_VOLUME pVol,
    LPWSTR pwszServerName,
    LPWSTR pwszShareName)
{
    ULONG iRep;
    DWORD dwErr = ERROR_SUCCESS;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsReplDeleteByName(%ws,%ws)\r\n", pwszServerName, pwszShareName);

    if (pwszServerName == NULL || pwszShareName == NULL) {
        dwErr =  ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

ReStart:

    //
    // Scan the volume's replica list, and if there is a match on the
    // passed-in servername and sharename, remove the replica.
    //
    for (iRep = 0; iRep < pVol->ReplCount; iRep++) {
        if (_wcsicmp(pVol->ReplicaInfo[iRep].pwszServerName, pwszServerName) == 0
                &&
            _wcsicmp(pVol->ReplicaInfo[iRep].pwszShareName, pwszShareName) == 0
        ) {
            dwErr = DfsReplDeleteByIndex(pVol, iRep);
            goto ReStart;
        }
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsReplDeleteByName returning %d\r\n", dwErr);
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDelReplDelete, public
//
//  Synopsis:   Removes a  PDFS_REPLICA_INFO from a DFS_VOLUME's deleted replica list
//
//  Arguments:  [pDfsVol] -- Pointer to DFS_VOLUME work on.
//              [iDelRepl] -- Index of Deleted replica to delete
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsDelReplDelete(
    PDFS_VOLUME pVol,
    ULONG iDelRepl)
{
    ULONG i;
    DWORD dwErr = ERROR_SUCCESS;

    ASSERT(iDelRepl < pVol->DelReplCount);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsDelReplDelete(%d)\r\n", iDelRepl);

    //
    // Free any memory this replica is using
    //

    DfsFreeRepl(&pVol->DelReplicaInfo[iDelRepl]);

    //
    // Since we're shrinking the list(s), we simply clip out the entry we don't want
    // and adjust the count.
    //
    for (i = iDelRepl+1; i < pVol->DelReplCount; i++) {
        pVol->DelReplicaInfo[i-1] = pVol->DelReplicaInfo[i];
        pVol->DelFtModification[i-1] = pVol->DelFtModification[i];
    }

    pVol->DelReplCount--;
    RtlZeroMemory(&pVol->DelReplicaInfo[pVol->DelReplCount], sizeof(DFS_REPLICA_INFO));

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsDelReplDelete returning %d\r\n", dwErr);
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspLdapOpen
//
//  Synopsis:   Open ldap storage and returns the object name of the
//                  Dfs-Configuration object.
//
//  Arguments:  DfsEntryPath - wszDcName - Dc name to be used
//              ppldap -- pointer to pointer to ldap obj, filled in on success
//              pwszObjectName -- pointer to LPWSTR for name of dfs-config object
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning list
//
//              [??] - From ldap open/bind, etc.
//
//-----------------------------------------------------------------------------
DWORD
DfspLdapOpen(
    LPWSTR wszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    LDAP **ppldap,
    LPWSTR pwszObjectPrefix,
    LPWSTR *pwszObjectName)
{
    DWORD dwErr;
    DWORD i;
    ULONG Size;

    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    PLDAPMessage pMsg = NULL;
    LDAP *pldap = NULL;
    WCHAR wszConfigurationDN[MAX_PATH+1];
    LPWSTR rgAttrs[5];

    if (fSwDebug)
        MyPrintf(L"DfspLdapOpen(%ws)\r\n", wszDcName);

    if (fSwDebug && pAuthIdent != NULL) {
        MyPrintf(L"User:%ws\r\n", pAuthIdent->User);
        MyPrintf(L"Domain:%ws\r\n", pAuthIdent->Domain);
        MyPrintf(L"Password:%ws\r\n", pAuthIdent->Password);
    }

    if ( ppldap == NULL || pwszObjectName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (*ppldap == NULL && wszDcName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (*ppldap == NULL) {

        pldap = ldap_init(wszDcName, LDAP_PORT);

        if (pldap == NULL) {

            if (fSwDebug == TRUE)
                MyPrintf(L"DfspLdapOpen:ldap_init failed\r\n");
            dwErr = ERROR_INVALID_NAME;
            goto Cleanup;

        }

	dwErr = ldap_set_option(pldap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
	
	if (dwErr != LDAP_SUCCESS) {
	    pldap = NULL;
	    goto Cleanup;
        }

        dwErr = ldap_bind_s(pldap, NULL, (LPWSTR)pAuthIdent, LDAP_AUTH_SSPI);

        if (dwErr != LDAP_SUCCESS) {
            if (fSwDebug == TRUE)
                MyPrintf(L"ldap_bind_s failed with ldap error %d\r\n", dwErr);
            pldap = NULL;
            dwErr = LdapMapErrorToWin32(dwErr);
            goto Cleanup;
        }

    } else {

        pldap = *ppldap;

    }

    //
    // Get attribute "defaultNameContext" containing name of entry we'll be
    // using for our DN
    //

    rgAttrs[0] = L"defaultnamingContext";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_s(
                pldap,
                L"",
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr == LDAP_SUCCESS) {

        PLDAPMessage pEntry = NULL;
        PWCHAR *rgszNamingContexts = NULL;
        DWORD i, cNamingContexts;

        dwErr = ERROR_SUCCESS;

        if ((pEntry = ldap_first_entry(pldap, pMsg)) != NULL &&
                (rgszNamingContexts = ldap_get_values(pldap, pEntry, rgAttrs[0])) != NULL &&
                    (cNamingContexts = ldap_count_values(rgszNamingContexts)) > 0) {

            wcscpy( wszConfigurationDN, *rgszNamingContexts );
        } else {
            dwErr = ERROR_UNEXP_NET_ERR;
        }

        if (rgszNamingContexts != NULL)
            ldap_value_free( rgszNamingContexts );

    } else {

        dwErr = LdapMapErrorToWin32(dwErr);

    }

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"Unable to find Configuration naming context\r\n");
        goto Cleanup;
    }

    //
    // Create string with full object name
    //

    Size = wcslen(pwszObjectPrefix) * sizeof(WCHAR) +
                sizeof(WCHAR) +
                    wcslen(wszConfigurationDN) * sizeof(WCHAR) +
                        sizeof(WCHAR);

    *pwszObjectName = (LPWSTR)malloc(Size);

    if (*pwszObjectName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
     }

    wcscpy(*pwszObjectName,pwszObjectPrefix);
    wcscat(*pwszObjectName,L",");
    wcscat(*pwszObjectName,wszConfigurationDN);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsLdapOpen:object name=[%ws]\r\n", *pwszObjectName);

Cleanup:

    if (pDCInfo != NULL)
        NetApiBufferFree( pDCInfo );

    if (dwErr != ERROR_SUCCESS && *ppldap == NULL) {
        ldap_unbind( pldap );
        pldap = NULL;
    }

    if (pMsg != NULL)
        ldap_msgfree( pMsg );

    if (*ppldap == NULL)
        *ppldap = pldap;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsLdapOpen:returning %d\r\n", dwErr);

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetPdc
//
//  Synopsis:   Gets the PDC
//
//  Arguments:  None
//
//  Returns:    ERROR_SUCCESS or failure
//
//-----------------------------------------------------------------------------
DWORD
DfspGetPdc(
    LPWSTR pwszPdcName,
    LPWSTR pwszDomainName)
{
    DWORD dwErr;
    PDOMAIN_CONTROLLER_INFO pDCInfo;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspGetPdc(%ws)\r\n", pwszDomainName);

    dwErr = DsGetDcName(
                NULL,                            // Computer to remote to
                pwszDomainName,                  // Domain - use local domain
                NULL,                            // Domain Guid
                NULL,                            // Site Guid
                DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY,
                &pDCInfo);

    if (dwErr == ERROR_SUCCESS) {
        wcscpy(pwszPdcName, &pDCInfo->DomainControllerName[2]);
        NetApiBufferFree(pDCInfo);

    }

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspGetPdc() returning %d\r\n", dwErr);

    return dwErr;
}

// ====================================================================
//                MIDL allocate and free
// ====================================================================

PVOID
MIDL_user_allocate(ULONG len)
{
    return malloc(len);
}

VOID
MIDL_user_free(void * ptr)
{
    free(ptr);
}

void
DumpBuf(PCHAR cp, ULONG len)
{
    ULONG i, j, c;

    for (i = 0; i < len; i += 16) {
        MyPrintf(L"%08x  ", i /* +(ULONG)cp */);
        for (j = 0; j < 16; j++) {
            if (j == 8)
                MyPrintf(L" ");
            if (i+j < len) {
                c = cp[i+j] & 0xff;
                MyPrintf(L"%02x ", c);
            } else {
                MyPrintf(L"   ");
            }
        }
        MyPrintf(L"  ");
        for (j = 0; j < 16; j++) {
            if (j == 8)
                MyPrintf(L"|");
            if (i+j < len) {
                c = cp[i+j] & 0xff;
                if (c < ' ' || c > '~')
                    c = '.';
                MyPrintf(L"%c", c);
            } else {
                MyPrintf(L" ");
            }
        }
        MyPrintf(L"\r\n");
    }
}

//+------------------------------------------------------------------------
//
// Function:    DfsDumpVolList
//
// Synopsis:    Prints the volume information represented by the volume
//              list passed in.
//
// Returns:     Usually.
//
//-------------------------------------------------------------------------

VOID
DfsDumpVolList(
    PDFS_VOLUME_LIST pDfsVolList)
{
    ULONG cVol;
    ULONG cRepl;
    ULONG cSite;
    ULONG cRoot;
    ULONG i;
    GUID guid;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    PDFSM_SITE_ENTRY pSiteEntry;
    WCHAR wszGuid[sizeof(GUID) * sizeof(WCHAR) + sizeof(WCHAR)];

    MyPrintf(L"****************************************\r\n");

    MyPrintf(L"Type is %d (%ws)\r\n",
                pDfsVolList->DfsType,
                pDfsVolList->DfsType == DOMUNKNONN ? L"Unknown" :
                    pDfsVolList->DfsType == DOMDFS ? L"DomDfs" :
                        L"StdDfs");

    if (pDfsVolList->RootServers != NULL) {
        MyPrintf(L"remoteServerName:");
        for (cRoot = 0; pDfsVolList->RootServers[cRoot] != NULL; cRoot++)
            MyPrintf(L"[%ws]", pDfsVolList->RootServers[cRoot]);
        MyPrintf(L"\r\n");
    }

    MyPrintf(L"There are %d dfs-links in this Dfs.\r\n", pDfsVolList->VolCount);

    for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {

        MyPrintf(L"------------------------\r\n");
        MyPrintf(L"ID:\r\n");
        MyPrintf(L"    Name=%ws\r\n", pDfsVolList->Volumes[cVol]->wszObjectName);
        MyPrintf(L"    Prefix: %ws\r\n", pDfsVolList->Volumes[cVol]->wszPrefix);
        MyPrintf(L"    ShortPrefix: %ws\r\n", pDfsVolList->Volumes[cVol]->wszShortPrefix);
        MyPrintf(L"    idVolume: %ws\r\n",
                            GuidToStringEx(&pDfsVolList->Volumes[cVol]->idVolume, wszGuid));
        MyPrintf(L"    Comment: %ws\r\n", pDfsVolList->Volumes[cVol]->wszComment);
        MyPrintf(L"    Timeout: %d\r\n", pDfsVolList->Volumes[cVol]->dwTimeout);
        MyPrintf(L"    Type: %x\r\n", pDfsVolList->Volumes[cVol]->dwType);
        MyPrintf(L"    cbRecovery: %d\r\n", pDfsVolList->Volumes[cVol]->cbRecovery);

        MyPrintf(L"Svc:\r\n");
        MyPrintf(L"  ReplCount=%d\r\n", pDfsVolList->Volumes[cVol]->ReplCount);
        MyPrintf(L"  AllocatedReplCount=%d\r\n", pDfsVolList->Volumes[cVol]->AllocatedReplCount);
        for (cRepl = 0; cRepl < pDfsVolList->Volumes[cVol]->ReplCount; cRepl++) {
            MyPrintf(L"    [%d]ReplicaState=0x%x\r\n",
                    cRepl, pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].ulReplicaState);
            MyPrintf(L"    [%d]ReplicaType=0x%x\r\n",
                    cRepl, pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].ulReplicaType);
            MyPrintf(L"    [%d]ServerName=%ws\r\n",
                    cRepl, pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].pwszServerName);
            MyPrintf(L"    [%d]ShareName=%ws\r\n",
                    cRepl, pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].pwszShareName);
        }

        MyPrintf(L"Recovery:\r\n");
        MyPrintf(L"  DelReplCount=%d\r\n", pDfsVolList->Volumes[cVol]->DelReplCount);
        MyPrintf(L"  AllocatedDelReplCount=%d\r\n", pDfsVolList->Volumes[cVol]->AllocatedDelReplCount);
        for (cRepl = 0; cRepl < pDfsVolList->Volumes[cVol]->DelReplCount; cRepl++) {
            MyPrintf(L"    [%d]ReplicaState=0x%x\r\n",
                    cRepl, pDfsVolList->Volumes[cVol]->DelReplicaInfo[cRepl].ulReplicaState);
            MyPrintf(L"    [%d]ReplicaType=0x%x\r\n",
                    cRepl, pDfsVolList->Volumes[cVol]->DelReplicaInfo[cRepl].ulReplicaType);
            MyPrintf(L"    [%d]ServerName=%ws\r\n",
                    cRepl, pDfsVolList->Volumes[cVol]->DelReplicaInfo[cRepl].pwszServerName);
            MyPrintf(L"    [%d]ShareName=%ws\r\n",
                    cRepl, pDfsVolList->Volumes[cVol]->DelReplicaInfo[cRepl].pwszShareName);
        }
        MyPrintf(L"\r\n");
    }

    pListHead = &pDfsVolList->SiteList;

    if (pListHead->Flink != NULL) {
        MyPrintf(L"---------SiteTable-------\r\n");
        guid = pDfsVolList->SiteGuid;

        MyPrintf(L"SiteTableGuid:"
            L"%08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X\r\n",
            guid.Data1, guid.Data2, guid.Data3, (int) guid.Data4[0],
            (int) guid.Data4[1], (int) guid.Data4[2], (int) guid.Data4[3],
            (int) guid.Data4[4], (int) guid.Data4[5],
            (int) guid.Data4[6], (int) guid.Data4[7]);

        for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
            pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
            MyPrintf(L"[%ws-%d sites]\r\n",
                    pSiteEntry->ServerName,
                    pSiteEntry->Info.cSites);
            for (i = 0; i < pSiteEntry->Info.cSites; i++) {
                MyPrintf(L"\t%ws\r\n", pSiteEntry->Info.Site[i].SiteName);
            }
        }
    }
}

VOID
DfsDumpExitPtList(
    PDFS_ROOTLOCALVOL pRootLocalVol,
    ULONG cRootLocalVol)
{
    ULONG cRoot;
    ULONG cVol;

    for (cRoot = 0; cRoot < cRootLocalVol; cRoot++) {
        if (pRootLocalVol[cRoot].wszObjectName == NULL)
            continue;
        MyPrintf(L"LocalVolume ROOT:[%ws]\r\n", pRootLocalVol[cRoot].wszObjectName);
        if (pRootLocalVol[cRoot].wszEntryPath)
            MyPrintf(L"EntryPath:[%ws]\r\n", pRootLocalVol[cRoot].wszEntryPath);
        if (pRootLocalVol[cRoot].wszShortEntryPath)
            MyPrintf(L"ShortEntryPath:[%ws]\r\n", pRootLocalVol[cRoot].wszShortEntryPath);
        if (pRootLocalVol[cRoot].wszShareName)
            MyPrintf(L"ShareName:[%ws]\r\n", pRootLocalVol[cRoot].wszShareName);
        if (pRootLocalVol[cRoot].wszStorageId)
            MyPrintf(L"StorageId:[%ws]\r\n", pRootLocalVol[cRoot].wszStorageId);
        MyPrintf(L"EntryType:0x%x\r\n", pRootLocalVol[cRoot].dwEntryType);
        MyPrintf(L"cLocalVolCount:%d\r\n", pRootLocalVol[cRoot].cLocalVolCount);

        for (cVol = 0; cVol < pRootLocalVol[cRoot].cLocalVolCount; cVol++) {
            if (pRootLocalVol[cRoot].pDfsLocalVol[cVol].wszObjectName != NULL)
                MyPrintf(L"    [%ws]\r\n", pRootLocalVol[cRoot].pDfsLocalVol[cVol].wszObjectName);
            if (pRootLocalVol[cRoot].pDfsLocalVol[cVol].wszEntryPath != NULL)
                MyPrintf(L"        [%ws]\r\n", pRootLocalVol[cRoot].pDfsLocalVol[cVol].wszEntryPath);
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   GuidToStringEx
//
//  Synopsis:   Converts a GUID to a 32 char wchar null terminated string.
//
//  Arguments:  [pGuid] -- Pointer to Guid structure.
//              [pwszGuid] -- wchar buffer into which to put the string
//                         representation of the GUID. Must be atleast
//                         2 * sizeof(GUID) + 1 long.
//
//  Returns:    The string passed in
//
//-----------------------------------------------------------------------------

const WCHAR rgwchHexDigits[] = L"0123456789ABCDEF";

LPWSTR
GuidToStringEx(
    GUID   *pGuid,
    LPWSTR pwszGuid)
{
    PBYTE pbBuffer = (PBYTE) pGuid;
    USHORT i;

    for(i = 0; i < sizeof(GUID); i++) {
        pwszGuid[2 * i] = rgwchHexDigits[(pbBuffer[i] >> 4) & 0xF];
        pwszGuid[2 * i + 1] = rgwchHexDigits[pbBuffer[i] & 0xF];
    }
    pwszGuid[2 * i] = UNICODE_NULL;
    return pwszGuid;
}

//+----------------------------------------------------------------------------
//
//  Function:   StringToGuid
//
//  Synopsis:   Converts a 32 wchar null terminated string to a GUID.
//
//  Arguments:  [pwszGuid] -- the string to convert
//              [pGuid] -- Pointer to destination GUID.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define HEX_DIGIT_TO_INT(d, i)                          \
    ASSERT(((d) >= L'0' && (d) <= L'9') ||              \
           ((d) >= L'A' && (d) <= L'F'));               \
    if ((d) <= L'9') {                                  \
        i = (d) - L'0';                                 \
    } else {                                            \
        i = (d) - L'A' + 10;                            \
    }

VOID
StringToGuid(
    PWSTR pwszGuid,
    GUID *pGuid)
{
    PBYTE pbBuffer = (PBYTE) pGuid;
    USHORT i, n;

    for (i = 0; i < sizeof(GUID); i++) {
        HEX_DIGIT_TO_INT(pwszGuid[2 * i], n);
        pbBuffer[i] = n << 4;
        HEX_DIGIT_TO_INT(pwszGuid[2 * i + 1], n);
        pbBuffer[i] |= n;
    }
}


//+------------------------------------------------------------------------
//
// Function:    DfsViewVolList
//
// Synopsis:    Prints the volume information represented by the volume
//              list passed in, in the 'dfscmd/view /full' format, and
//              also prints the site table.
//
//-------------------------------------------------------------------------

VOID
DfsViewVolList(
    PDFS_VOLUME_LIST pDfsVolList,
    ULONG Level)
{
    ULONG cRoot;
    ULONG cVol;
    ULONG cRepl;
    ULONG cSite;
    ULONG i;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    PDFSM_SITE_ENTRY pSiteEntry;
    WCHAR wszGuid[sizeof(GUID) * sizeof(WCHAR) + sizeof(WCHAR)];

    if (Level <= 1) {

        MyPrintf(L"Type is %ws\r\n",
                    pDfsVolList->DfsType == DOMUNKNONN ? L"Unknown" :
                        pDfsVolList->DfsType == DOMDFS ? L"DomDfs" :
                            L"StdDfs");

        MyPrintf(L"There are %d dfs-links in this Dfs.\r\n", pDfsVolList->VolCount);

        if (Level == 1) {
            MyPrintf(L"Version:%d\r\n", pDfsVolList->Version);

            if (pDfsVolList->RootServers != NULL) {
                MyPrintf(L"remoteServerName:");
                for (cRoot = 0; pDfsVolList->RootServers[cRoot] != NULL; cRoot++)
                    MyPrintf(L"[%ws]", pDfsVolList->RootServers[cRoot]);
                MyPrintf(L"\r\n");
            }
        }

        MyPrintf(L"\r\n");

        for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {
            MyPrintf(L"\\%ws    [%ws]\r\n",
                pDfsVolList->Volumes[cVol]->wszPrefix,
                pDfsVolList->Volumes[cVol]->wszComment);
            if (Level == 1) {
                MyPrintf(L"      GUID: %ws\r\n",
                           GuidToStringEx(&pDfsVolList->Volumes[cVol]->idVolume, wszGuid));
                MyPrintf(L"      ShortPrefix: %ws\r\n", pDfsVolList->Volumes[cVol]->wszShortPrefix);
                MyPrintf(L"      ObjectName: %ws\r\n", pDfsVolList->Volumes[cVol]->wszObjectName);
                MyPrintf(L"      State:0x%x Type:0x%x Version:0x%x\r\n",
                                    pDfsVolList->Volumes[cVol]->dwState,
                                    pDfsVolList->Volumes[cVol]->dwType,
                                    pDfsVolList->Volumes[cVol]->dwVersion);
                                    
            }
            MyPrintf(L"      Timeout is %d seconds\r\n", pDfsVolList->Volumes[cVol]->dwTimeout);
            for (cRepl = 0; cRepl < pDfsVolList->Volumes[cVol]->ReplCount; cRepl++) {
                MyPrintf(L"    \\\\%ws\\%ws\r\n",
                    pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].pwszServerName,
                    pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].pwszShareName);
                if (Level == 1) {
                    ULONG State = pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].ulReplicaState;
                    ULONG Type = pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].ulReplicaType;
                    MyPrintf(L"      State:0x%x %ws Type:0x%x %ws\r\n",
                        State,
                        State & DFS_STORAGE_STATE_OFFLINE ?
                            L"(DFS_STORAGE_STATE_OFFLINE)" :
                                State & DFS_STORAGE_STATE_ONLINE ?
                                    L"(DFS_STORAGE_STATE_ONLINE)" :  L"",
                        Type,
                        Type == DFS_STORAGE_TYPE_DFS ?
                                    L"(DFS_STORAGE_TYPE_DFS)" : L"(DFS_STORAGE_TYPE_NONDFS)");
                }
            }
            MyPrintf(L"\r\n");
        }
        MyPrintf(L"\r\n");

        pListHead = &pDfsVolList->SiteList;
        if (pListHead->Flink != NULL) {
            MyPrintf(L"Site information:\r\n");
            for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
                pSiteEntry = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
                MyPrintf(L"%ws\r\n", pSiteEntry->ServerName);
                for (i = 0; i < pSiteEntry->Info.cSites; i++) {
                    MyPrintf(L"    %ws\r\n", pSiteEntry->Info.Site[i].SiteName);
                }
            }
        }
    }
}

DWORD
CmdDomUnmap(
    LPWSTR pwszDomDfsName,
    LPWSTR pwszRootName,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent)
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wszDfsConfigDN[MAX_PATH+1];
    WCHAR *wszConfigurationDN = NULL;
    LDAP *pldap = NULL;
    LPWSTR pwszDfsName = NULL;
    LPWSTR pwszShareName = NULL;
    LPWSTR pwszDomName = NULL;
    LPWSTR pwszRootServer = NULL;
    LPWSTR pwszRootShare = NULL;
    BOOLEAN IsDomainName = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDomUnmap(%ws,%ws,%ws,0x%p)\r\n", 
                    pwszDomDfsName,
                    pwszRootName,
                    pwszDcName,
                    pAuthIdent);

    if (pwszDomDfsName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    dwErr = DfspParseName(
                pwszDomDfsName,
                &pwszDomName,
                &pwszDfsName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = DfspIsDomainName(
                pwszDomName,
                pwszDcName,
                &IsDomainName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (IsDomainName != TRUE) {
        dwErr = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    if (pwszDcName == NULL) {
        dwErr = DfspGetPdc(wszDcName, pwszDomName);
    } else {
        wcscpy(wszDcName, pwszDcName);
    }

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    ErrorMessage(MSG_CONNECTING, wszDcName);

    //
    // If pwszRootName is not NULL, we delete one root only
    //

    if (pwszRootName != NULL) {
        dwErr = DfspParseName(
                    pwszRootName,
                    &pwszRootServer,
                    &pwszRootShare);

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;

        dwErr = CmdUnmapOneRoot(
                    pwszDfsName,
                    pwszRootServer,
                    wszDcName,
                    pwszDomName,
                    pAuthIdent);
        goto Cleanup;
    }

    //
    // Delete the whole thing...
    //

    dwErr = DfspLdapOpen(wszDcName, pAuthIdent, &pldap, DfsConfigContainer, &wszConfigurationDN);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Build the entry name we want to delete
    //
    wcscpy(wszDfsConfigDN,L"CN=");
    wcscat(wszDfsConfigDN,pwszDfsName);
    wcscat(wszDfsConfigDN,L",");
    wcscat(wszDfsConfigDN,wszConfigurationDN);

    MyPrintf(L"DS object to delete:\"%ws\"\r\n", wszDfsConfigDN);

    dwErr = ldap_delete_s( pldap, wszDfsConfigDN);
    if (dwErr != LDAP_SUCCESS)
        dwErr = LdapMapErrorToWin32(dwErr);

Cleanup:

    if (pldap != NULL)
        ldap_unbind( pldap );

    if (wszConfigurationDN != NULL)
        free(wszConfigurationDN);

    if (pwszDfsName != NULL)
        free(pwszDfsName);

    if (pwszShareName != NULL)
        free(pwszShareName);

    if (pwszDomName != NULL)
        free(pwszDomName);

    if (pwszRootServer != NULL)
        free(pwszRootServer);

    if (pwszRootShare != NULL)
        free(pwszRootShare);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDomUnmap exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdUnmapOneRoot(
    LPWSTR pwszDomDfsName,
    LPWSTR pwszRootName,
    LPWSTR pwszDcName,
    LPWSTR pwszDomainName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent)
{
    DWORD dwErr = ERROR_SUCCESS;
    DFS_VOLUME_LIST DfsVolList = { 0 };
    ULONG cbBlob = 0;
    BYTE *pBlob = NULL;

    if (fSwDebug != 0)
        MyPrintf(L"CmdUnmapOneRoot(%ws,%ws,%ws,%ws)\r\n",
                        pwszDomDfsName,
                        pwszRootName,
                        pwszDcName,
                        pwszDomainName);

    //
    // Get blob from Ds
    //
    dwErr = DfsGetDsBlob(
                pwszDomDfsName,
                DfsConfigContainer,
                pwszDcName,
                pAuthIdent,
                &cbBlob,
                &pBlob,
                &DfsVolList.RootServers);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Unserialize it
    //
    dwErr =  DfsGetVolList(
                cbBlob,
                pBlob,
                &DfsVolList);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Free the blob
    //
    free(pBlob);
    pBlob = NULL;

    if (fSwDebug != 0)
        DfsDumpVolList(&DfsVolList);

    //
    // Remove the root/server/machine
    //
    dwErr = DfsRemoveRootReplica(&DfsVolList, pwszRootName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (fSwDebug != 0)
        DfsDumpVolList(&DfsVolList);

    //
    // Serialize it
    //
    dwErr = DfsPutVolList(
                &cbBlob,
                &pBlob,
                &DfsVolList);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Update the DS
    //
    dwErr = DfsPutDsBlob(
                pwszDomDfsName,
                DfsConfigContainer,
                pwszDcName,
                pAuthIdent,
                cbBlob,
                pBlob,
                DfsVolList.RootServers);

    //
    // Free the volume list we created
    //
    DfsFreeVolList(&DfsVolList);

Cleanup:
    if (pBlob != NULL)
        free(pBlob);

    if (DfsVolList.VolCount > 0 && DfsVolList.Volumes != NULL)
        DfsFreeVolList(&DfsVolList);

    if (fSwDebug != 0)
        MyPrintf(L"CmdUnmapOneRoot returning %d\r\n", dwErr);

    return( dwErr );
}


DWORD
DfsSetFtOnSite(
    LPWSTR pwszDomainName,
    LPWSTR pwszShareName,
    LPWSTR pwszLinkName,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    ULONG Set)
{
    DWORD dwErr = ERROR_SUCCESS;
    DFS_VOLUME_LIST DfsVolList = { 0 };
    ULONG cbBlob = 0;
    BYTE *pBlob = NULL;
    WCHAR wszDcName[MAX_PATH+1];
    if (fSwDebug != 0)
        MyPrintf(L"DfsSetFtOnSite(%ws,%ws,%ws)\r\n",
                        pwszDomainName,
                        pwszShareName,
                        pwszLinkName);

    
    if (pwszDcName == NULL) {
        dwErr = DfspGetPdc(wszDcName, pwszDomainName);
    } else {
        wcscpy(wszDcName, pwszDcName);
    }
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Get blob from Ds
    //
    dwErr = DfsGetDsBlob(
                pwszShareName,
                DfsConfigContainer,
                wszDcName,
                pAuthIdent,
                &cbBlob,
                &pBlob,
                &DfsVolList.RootServers);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Unserialize it
    //
    dwErr =  DfsGetVolList(
                cbBlob,
                pBlob,
                &DfsVolList);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Free the blob
    //
    free(pBlob);
    pBlob = NULL;

    if (fSwDebug != 0)
        DfsDumpVolList(&DfsVolList);

    //
    // Update the site referral info: either set or reset the flag
    //
    dwErr = DfsUpdateSiteReferralInfo(&DfsVolList, pwszLinkName, Set);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (fSwDebug != 0)
        DfsDumpVolList(&DfsVolList);


    //
    // Serialize it
    //
    dwErr = DfsPutVolList(
                &cbBlob,
                &pBlob,
                &DfsVolList);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Update the DS
    //
    dwErr = DfsPutDsBlob(
                pwszShareName,
                DfsConfigContainer,
                wszDcName,
                pAuthIdent,
                cbBlob,
                pBlob,
                DfsVolList.RootServers);

    //
    // Free the volume list we created
    //
    DfsFreeVolList(&DfsVolList);

Cleanup:
    if (pBlob != NULL)
        free(pBlob);

    if (DfsVolList.VolCount > 0 && DfsVolList.Volumes != NULL)
        DfsFreeVolList(&DfsVolList);

    if (fSwDebug != 0)
        MyPrintf(L"CmdUnmapOneRoot returning %d\r\n", dwErr);

    return( dwErr );
}





//+------------------------------------------------------------------------
//
// Function:    DfsUpdateSiteReferralInfo(
//
// Synopsis:    Update the referral site info for the volume
//
//-------------------------------------------------------------------------

DWORD
DfsUpdateSiteReferralInfo(
    PDFS_VOLUME_LIST pDfsVolList,
    LPWSTR wszPrefixMatch,
    ULONG Set)
{
    ULONG cVol;
    ULONG cRepl;
    ULONG cRoot;
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR usePrefix;
    BOOLEAN found = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsUpdateSiteReferralInfo(%ws)\r\n", wszPrefixMatch);


    for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {

      usePrefix = pDfsVolList->Volumes[cVol]->wszPrefix;
      DfspGetLinkName(usePrefix, &usePrefix);
      if (fSwDebug) {
	  MyPrintf(L"Checking for Match (%ws, %ws), keyname (%ws)\n", 
		   usePrefix,
		   pDfsVolList->Volumes[cVol]->wszShortPrefix,
		   wszPrefixMatch);
	}


    if (_wcsicmp(usePrefix, wszPrefixMatch) == 0) {
        if (fSwDebug) {
            MyPrintf(L"Match found prefix (%ws, %ws), keyname (%ws)\n", 
                usePrefix,
                pDfsVolList->Volumes[cVol]->wszShortPrefix,
                wszPrefixMatch);
        }
	found = TRUE;
	if (Set) {
	  if (pDfsVolList->Volumes[cVol]->dwType & PKT_ENTRY_TYPE_INSITE_ONLY) {
	    ErrorMessage(MSG_SITE_INFO_ALREADY_SET, 
			 pDfsVolList->Volumes[cVol]->wszPrefix);
	  }
	  else {
	    ErrorMessage(MSG_SITE_INFO_NOW_SET, 
		     pDfsVolList->Volumes[cVol]->wszPrefix);
	    pDfsVolList->Volumes[cVol]->dwType |= PKT_ENTRY_TYPE_INSITE_ONLY;
	  }
	}
	else {
	  if (pDfsVolList->Volumes[cVol]->dwType & PKT_ENTRY_TYPE_INSITE_ONLY) {
	    ErrorMessage(MSG_SITE_INFO_NOW_SET, 
		   pDfsVolList->Volumes[cVol]->wszPrefix);
	    pDfsVolList->Volumes[cVol]->dwType &= ~PKT_ENTRY_TYPE_INSITE_ONLY;
	  }
	  else {
	    ErrorMessage(MSG_SITE_INFO_ALREADY_SET, 
			 pDfsVolList->Volumes[cVol]->wszPrefix);
	    dwErr = ERROR_REQUEST_ABORTED;
	  }
	}
        break;
      }
    }

    if (!found) {
      ErrorMessage(MSG_LINK_NOT_FOUND, wszPrefixMatch);
      dwErr = ERROR_PATH_NOT_FOUND;
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsUpdateSiteReferralInfo exit %d\r\n", dwErr);

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfscmd\winmain.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:      winmain.cxx
//
//  Contents:  Main DFS Administrator file
//
//  History:   05-May-93 WilliamW    Created
//             11-Jul-95 WayneSc     Bug Fixes
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "cmd.hxx"
#include "myutil.hxx"

//
// Debug flag
//

DECLARE_INFOLEVEL(DfsAdmin)

//////////////////////////////////////////////////////////////////////////////

HINSTANCE g_hInstance;

#define MAX_ARGS 25

//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Synopsis:   main routine for the Sharing app.
//
//  History:    11-May-93 WilliamW   Created.
//              16-Sep-93 DavidMun   Added load & free of ccsvr.dll; move
//                                   InfoLevel init inside #if DBG.
//
//  The command line accepted by this program is described in message
//  MSG_USAGE, in messages.mc. In addition to that, the following options are
//  accepted in debug builds. These must preceed any retail options.
//
//  Debug options:
//      /debug
//          -- dump basic error information
//      /fulldebug
//          -- dump all error and trace information
//
//--------------------------------------------------------------------------

int APIENTRY
WinMain(
    IN HINSTANCE hInst,
    IN HINSTANCE hPrevInstance,
    IN LPSTR lpszCommandLineAnsi,
    IN int cmdShow
    )
{
    HRESULT hr;
    HACCEL  hAccel;
    MSG     msg;
    PWSTR   pszInitialDfs = NULL;
    PWSTR   pszCommandLine = GetCommandLine();  // get the unicode command line
    BOOLEAN fBatch = FALSE;
    BOOLEAN fRestore = FALSE;

    //
    // Store the current instance away.
    //

    g_hInstance = hInst;

#if DBG == 1

    DebugInitialize();

    //
    // Set debug info level
    //

    DfsAdminInfoLevel = DEB_ERROR | DEB_WARN;

    if (NULL != wcsstr(pszCommandLine, L"/debug"))
    {
        DfsAdminInfoLevel =
                  DEB_ERROR
                | DEB_WARN
                | DEB_TRACE
                ;
    }

    if (NULL != wcsstr(pszCommandLine, L"/fulldebug"))
    {
        DfsAdminInfoLevel =
                  DEB_ERROR
                | DEB_WARN
                | DEB_TRACE
                | DEB_IERROR
                | DEB_IWARN
                | DEB_ITRACE
                ;
    }

    // For some reason, the MessageBox call done for ASSRT_POPUP
    // is failing with error 2 (???), and although the assert message gets
    // printed, it doesn't break.

    DebugSetAssertLevel(ASSRT_MESSAGE | ASSRT_BREAK);

#endif

    //
    // Parse the command line. First, break everything out into separate
    // strings (kind of like argv/argc). Note that the program name doesn't
    // appear in pszCommandLine.
    //

    DWORD cArgs = 0;
    DWORD iArg;
    LPWSTR apszArgs[MAX_ARGS];

    LPWSTR pT = pszCommandLine;
    if (NULL != pT)
    {
        for (; cArgs < MAX_ARGS;)
        {
            while (L' ' == *pT || L'\t' == *pT) { pT++; }   // eat whitespace
            if (L'\0' == *pT)
            {
                break;
            }

            // We found a parameter. Find how long it is, allocate a string
            // to store it, and copy it. If the argument begins with a double
            // quote, we continue until we find the next double quote. To allow
            // double-quotes within strings, we allow these two special
            // sequences:
            //              \" => "			backslash escapes quotes
            //              \\ => \         backslash escapes backslash
            //              \x => x         backslash escapes anything!

            // First, determine the string size

            DWORD cchArg = 0;
            BOOL fQuoted = (L'"' == *pT);
            if (fQuoted)
            {
                ++pT;
            }

            // count the # of characters in the string
            LPWSTR pT2 = pT;
            if (fQuoted)
            {
                while (L'"' != *pT2 && L'\0' != *pT2)
                {
                    if (L'\\' == *pT2 && L'"' == *(pT2+1))
                    {
                        pT2 += 2;
                    }
					else
					{
                        pT2 += 1;
					}
                    ++cchArg;
                }
                if (L'\0' == *pT2)
                {
                    // no trailing quotes
                    Usage();
                }
                else
                {
                    // we're on a ", so skip it
                    ++pT2;
                    if (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                    {
                        // garbage after the "
                        Usage();
                    }
                }
            }
            else
            {
                while (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                {
                    ++pT2;
                    ++cchArg;
                }
            }

            // allocate storage for the parameter
            LPWSTR pszNew = new WCHAR[cchArg + 1];
            if (NULL == pszNew)
            {
                ErrorMessage(MSG_OUTOFMEMORY);
            }
            LPWSTR pCopy = pszNew;

            // copy the string
            pT2 = pT;
            if (fQuoted)
            {
                while (L'"' != *pT2 && L'\0' != *pT2)
                {
                    if (L'\\' == *pT2 && L'"' == *(pT2+1))
                    {
                        ++pT2;	// skip the backslash
                    }
                    *pCopy++ = *pT2++;
                }
                if (L'\0' == *pT2)
                {
                    // no trailing quotes
                    appAssert(FALSE);
                }
                else
                {
                    // we're on a ", so skip it
                    ++pT2;
                    if (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                    {
                        // garbage after the "
                        appAssert(FALSE);
                    }
                }
            }
            else
            {
                while (L' ' != *pT2 && L'\t' != *pT2 && L'\0' != *pT2)
                {
                    *pCopy++ = *pT2++;
                }
            }

            *pCopy = L'\0';
            apszArgs[cArgs++] = pszNew;
            pT = pT2;
        }

        if (cArgs >= MAX_ARGS)
        {
            Usage();
        }

        //
        // We've got the arguments parsed out now, so do something with them
        //

        iArg = 1;   // skip the first one, which is the program name

#if DBG == 1
        for (; iArg < cArgs; )
        {
            if (   0 == _wcsicmp(apszArgs[iArg], L"/debug")
                || 0 == _wcsicmp(apszArgs[iArg], L"/fulldebug")
                )
            {
                ++iArg; // skip it
            }
            else
            {
                break;
            }
        }
#endif // DBG == 1

        if (iArg < cArgs)
        {
            if (   0 == _wcsicmp(apszArgs[iArg], L"/help")
                || 0 == _wcsicmp(apszArgs[iArg], L"/h")
                || 0 == _wcsicmp(apszArgs[iArg], L"/?")
                || 0 == _wcsicmp(apszArgs[iArg], L"-help")
                || 0 == _wcsicmp(apszArgs[iArg], L"-h")
                || 0 == _wcsicmp(apszArgs[iArg], L"-?")
                )
            {
                Usage();
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/map"))
            {
                LPWSTR pszComment = NULL;
                if (
                    iArg + 2 > cArgs - 1
                    || iArg + 4 < cArgs - 1)
                {
                    Usage();
                }
                if (iArg + 3 <= cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 3], L"/restore"))
                        fRestore = TRUE;
                    else 
                        pszComment = apszArgs[iArg + 3];
                }
                if (iArg + 4 <= cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 4], L"/restore"))
                        fRestore = TRUE;
                    else if (pszComment != NULL)
                        Usage();
                    else
                        pszComment = apszArgs[iArg + 4];
                }
                CmdMap(apszArgs[iArg + 1], apszArgs[iArg + 2], pszComment, fRestore);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/unmap"))
            {
                if (iArg + 1 != cArgs - 1)
                {
                    Usage();
                }
                CmdUnmap(apszArgs[iArg + 1]);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/add"))
            {
                if (iArg + 2 > cArgs - 1
                    || iArg + 3 < cArgs - 1)
                {
                    Usage();
                }
                if (iArg + 3 <= cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 3], L"/restore"))
                        fRestore = TRUE;
                    else
                        Usage();
                }
                CmdAdd(apszArgs[iArg + 1], apszArgs[iArg + 2], fRestore);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/remove"))
            {
                if (iArg + 2 != cArgs - 1)
                {
                    Usage();
                }
                CmdRemove(apszArgs[iArg + 1], apszArgs[iArg + 2]);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/view"))
            {
                if (   iArg + 1 > cArgs - 1
                    || iArg + 2 < cArgs - 1
                    )
                {
                    Usage();
                }
                DWORD level = 1;
                if (iArg + 2 == cArgs - 1)
                {
                    if (0 == _wcsicmp(apszArgs[iArg + 2], L"/partial"))
                    {
                        level = 2;
                    }
                    else if (0 == _wcsicmp(apszArgs[iArg + 2], L"/full"))
                    {
                        level = 3;
                    }
                    else if (0 == _wcsicmp(apszArgs[iArg + 2], L"/batch"))
                    {
                        fBatch = TRUE;
                        level = 3;
                    }
                    else if (0 == _wcsicmp(apszArgs[iArg + 2], L"/batchrestore"))
                    {
                        fBatch = TRUE;
                        fRestore = TRUE;
                        level = 3;
                    }
                    else
                    {
                        Usage();
                    }
                }
                CmdView(apszArgs[iArg + 1], level, fBatch, fRestore);
            }
#ifdef MOVERENAME
            else if (0 == _wcsicmp(apszArgs[iArg], L"/move"))
            {
                if (iArg + 2 != cArgs - 1)
                {
                    Usage();
                }
                CmdMove(apszArgs[iArg + 1], apszArgs[iArg + 2]);
            }
            else if (0 == _wcsicmp(apszArgs[iArg], L"/rename"))
            {
                if (iArg + 2 != cArgs - 1)
                {
                    Usage();
                }
                CmdRename(apszArgs[iArg + 1], apszArgs[iArg + 2]);
            }
#endif
            else
            {
                Usage();
            }
        }
		else
		{
			Usage();
		}
    }
	else
	{
    	Usage();
	}

	StatusMessage(MSG_SUCCESSFUL);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfsutil\info.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       info.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsstr.h>
#include <dfsmrshl.h>
#include <marshal.hxx>
#include <lmdfs.h>
#include <dfspriv.h>
#include <dfsm.hxx>
#include <recon.hxx>
#include <rpc.h>
#include "struct.hxx"
#include "ftsup.hxx"
#include "stdsup.hxx"
#include "rootsup.hxx"
#include "misc.hxx"


#define OFFSET_TO_POINTER(f,b) \
    ((VOID *)((PCHAR)(f) + (ULONG_PTR)(b)))

CHAR *OutBuf = NULL;
ULONG OutBufSize = 0x1000;
HANDLE DriverHandle = NULL;
CHAR InBuf[0x1000];
CHAR OutBuf2[0x1000];

VOID
GetDCs(
    LPWSTR Name);

DWORD
PktInfo(
    BOOLEAN fSwDfs,
    LPWSTR pwszHexValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type;
    ULONG State;
    ULONG Entry;
    ULONG Service;
    ULONG Level = 0;
    PDFS_GET_PKT_ARG pGetPkt = NULL;

    OutBuf = (PCHAR) malloc(OutBufSize);

    if (OutBuf == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    if (fSwDfs == TRUE) {
        MyPrintf(L"--dfs.sys--\r\n");
        RtlInitUnicodeString(&DfsDriverName, DFS_SERVER_NAME);
    } else {
        MyPrintf(L"--mup.sys--\r\n");
        RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);
    }

    if (pwszHexValue != NULL) {
        Level = AtoHex(pwszHexValue, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"Bad Level %ws\r\n", pwszHexValue);
            goto Cleanup;
        }
    }
            
    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

TryAgain:

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_PKT,
                   NULL,
                   0,
                   OutBuf,
                   OutBufSize);

    if (NtStatus == STATUS_BUFFER_OVERFLOW) {
        OutBufSize =  *((ULONG *)OutBuf);
        free(OutBuf);
        OutBuf = (PCHAR) malloc(OutBufSize);
        if (OutBuf == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        goto TryAgain;
    }


    dwErr = RtlNtStatusToDosError(NtStatus);

    if (!NT_SUCCESS(NtStatus))
        goto Cleanup;

    pGetPkt = (PDFS_GET_PKT_ARG)OutBuf;

    MyPrintf(L"%d entries...\r\n", pGetPkt->EntryCount);

    for (Entry = 0; Entry < pGetPkt->EntryCount; Entry++) {
        pGetPkt->EntryObject[Entry].Prefix = (LPWSTR) OFFSET_TO_POINTER(
                                                        pGetPkt->EntryObject[Entry].Prefix,
                                                        OutBuf);
        pGetPkt->EntryObject[Entry].ShortPrefix = (LPWSTR) OFFSET_TO_POINTER(
                                                        pGetPkt->EntryObject[Entry].ShortPrefix,
                                                        OutBuf);
        pGetPkt->EntryObject[Entry].Address = (PDFS_PKT_ADDRESS_OBJECT *) OFFSET_TO_POINTER(
                                                            pGetPkt->EntryObject[Entry].Address,
                                                            OutBuf);
        for (Service = 0; Service < pGetPkt->EntryObject[Entry].ServiceCount; Service++) {
            pGetPkt->EntryObject[Entry].Address[Service] = (PDFS_PKT_ADDRESS_OBJECT)
                                                OFFSET_TO_POINTER(
                                                    pGetPkt->EntryObject[Entry].Address[Service],
                                                    OutBuf);
        }
    }

    for (Entry = 0; Entry < pGetPkt->EntryCount; Entry++) {
        MyPrintf(L"Entry: %ws\r\n", pGetPkt->EntryObject[Entry].Prefix);
        MyPrintf(L"ShortEntry: %ws\r\n", pGetPkt->EntryObject[Entry].ShortPrefix);
        MyPrintf(L"Expires in %d seconds\r\n", pGetPkt->EntryObject[Entry].ExpireTime);
        MyPrintf(L"UseCount: %d Type:0x%x (",
                    pGetPkt->EntryObject[Entry].UseCount,
                    pGetPkt->EntryObject[Entry].Type);
        Type = pGetPkt->EntryObject[Entry].Type;
        if (Type & PKT_ENTRY_TYPE_OFFLINE)
            MyPrintf(L" OFFLINE");
        if (Type & PKT_ENTRY_TYPE_LOCAL)
            MyPrintf(L" LOCAL");
        if (Type & PKT_ENTRY_TYPE_STALE)
            MyPrintf(L" STALE");
        if (Type & PKT_ENTRY_TYPE_LOCAL_XPOINT)
            MyPrintf(L" LOCAL_XPOINT");
        if (Type & PKT_ENTRY_TYPE_DELETE_PENDING)
            MyPrintf(L" DELETE_PENDING");
        if (Type & PKT_ENTRY_TYPE_PERMANENT)
            MyPrintf(L" PERMANENT");
        if (Type & PKT_ENTRY_TYPE_REFERRAL_SVC)
            MyPrintf(L" REFERRAL_SVC");
        if (Type & PKT_ENTRY_TYPE_SYSVOL)
            MyPrintf(L" SYSVOL");
        if (Type & PKT_ENTRY_TYPE_OUTSIDE_MY_DOM)
            MyPrintf(L" OUTSIDE_MY_DOM");
        if (Type & PKT_ENTRY_TYPE_LEAFONLY)
            MyPrintf(L" LEAFONLY");
        if (Type & PKT_ENTRY_TYPE_NONDFS)
            MyPrintf(L" NONDFS");
        if (Type & PKT_ENTRY_TYPE_MACHINE)
            MyPrintf(L" MACHINE");
        if (Type & PKT_ENTRY_TYPE_DFS)
            MyPrintf(L" DFS");
        if (Type & PKT_ENTRY_TYPE_INSITE_ONLY)
            MyPrintf(L" INSITE");

        MyPrintf(L" )\r\n");

        for (Service = 0; Service < pGetPkt->EntryObject[Entry].ServiceCount; Service++) {
            MyPrintf(L"%4d:[%ws] State:0x%02x ",
                Service,
                pGetPkt->EntryObject[Entry].Address[Service]->ServerShare,
                pGetPkt->EntryObject[Entry].Address[Service]->State);
            State = pGetPkt->EntryObject[Entry].Address[Service]->State;
            //
            // Ugly - used to have State == 0x1 mean 'active'.  Now we return an
            // ULONG with multiple bits set, so 0x1 indicates the old way and
            // more than 1 bit set means the new way.
            //
            if (State == 0x0) {
                MyPrintf(L"\r\n");
            } else if (State == 0x1) {
                MyPrintf(L"( ACTIVE )\r\n");
            } else {
                MyPrintf(L"(");
                if (State & DFS_SERVICE_TYPE_ACTIVE)
                    MyPrintf(L" ACTIVE");
                if (State & DFS_SERVICE_TYPE_OFFLINE)
                    MyPrintf(L" OFFLINE");
                if (Level >= 1) {
                    if (State & DFS_SERVICE_TYPE_MASTER)
                        MyPrintf(L" MASTER");
                    if (State & DFS_SERVICE_TYPE_READONLY)
                        MyPrintf(L" READONLY");
                    if (State & DFS_SERVICE_TYPE_LOCAL)
                        MyPrintf(L" LOCAL");
                    if (State & DFS_SERVICE_TYPE_REFERRAL)
                        MyPrintf(L" REFERRAL");
                    if (State & DFS_SERVICE_TYPE_DOWN_LEVEL)
                        MyPrintf(L" DOWNLEVEL");
                    if (State & DFS_SERVICE_TYPE_COSTLIER)
                        MyPrintf(L" COSTLIER");
                }
                MyPrintf(L" )\r\n");
            }
        }
        MyPrintf(L"\r\n");
    }

Cleanup:

    if (OutBuf != NULL) {
        free(OutBuf); 
        OutBuf = NULL;
    }

    if (DriverHandle != NULL) {
        NTSTATUS st;
        st = NtClose(DriverHandle);
        DriverHandle = NULL;
    }

    return dwErr;
}

DWORD
SpcInfo(
    BOOLEAN fSwAll)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    WCHAR *wCp;

    OutBuf = (PCHAR) malloc(OutBufSize);

    if (OutBuf == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

TryAgain:

    wcscpy((WCHAR *)InBuf, L"*");

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   InBuf,
                   sizeof(InBuf),
                   OutBuf,
                   OutBufSize);

    if (NtStatus == STATUS_BUFFER_OVERFLOW) {
        OutBufSize =  *((ULONG *)OutBuf);
        free(OutBuf);
        OutBuf = (PCHAR)malloc(OutBufSize);
        if (OutBuf == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        goto TryAgain;
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

    if (NtStatus == STATUS_SUCCESS) {
        wCp = (WCHAR *)OutBuf;
        while (*wCp) {
            MyPrintf(L"[%c][%ws]\r\n", *wCp, (wCp+1));
            wCp += wcslen(wCp) + 1;
        }
    }

    wcscpy((WCHAR *)InBuf, L"");

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   InBuf,
                   sizeof(InBuf),
                   OutBuf,
                   OutBufSize);

    if (NtStatus == STATUS_BUFFER_OVERFLOW) {
        OutBufSize =  *((ULONG *)OutBuf);
        OutBuf = (PCHAR)malloc(OutBufSize);
        if (OutBuf == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        goto TryAgain;
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

    if (NtStatus == STATUS_SUCCESS) {
        wCp = (WCHAR *)OutBuf;
        while (*wCp) {
            MyPrintf(L"[%c][%ws]\r\n", *wCp, (wCp+1));
            if (fSwAll == TRUE || *wCp == '+') {
                GetDCs((wCp+1));
            }
            wCp += wcslen(wCp) + 1;
        }
    }

Cleanup:

    if (DriverHandle != NULL) {
        NtClose(DriverHandle);
        DriverHandle = NULL;
    }
    if (OutBuf != NULL) {
        free(OutBuf);
        OutBuf = NULL;
    }
    return dwErr;
}

VOID
GetDCs(
    LPWSTR Name)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR *wCp;

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   Name,
                   (wcslen(Name) + 1) * sizeof(WCHAR),
                   OutBuf2,
                   sizeof(OutBuf2));

    if (NtStatus == STATUS_SUCCESS) {
        wCp = (WCHAR *)OutBuf2;
        while (*wCp) {
            MyPrintf(L"\t[%ws]\r\n", wCp);
            wCp += wcslen(wCp) + 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\inc\helpids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       helpids.h
//
//  Contents:   Context ids for context-sensitive help
//
//  History:    6-May-94 BruceFo    Created from windisk
//
//----------------------------------------------------------------------------

#ifndef __HELPIDS_H__
#define __HELPIDS_H__

//
// NOTE: if you change the numbers in this file, you must notify User Education
// NOTE: so they can change the help file sources
//

//
// All ids in this file start with HC_, as in "Help Context"
//

//
// All menu item ids start with HC_MENU_
//

//
// Storage menu
//

#define HC_MENU_SELECT_DFS              100
#define HC_MENU_OPEN                    101
#define HC_MENU_EXPLORE                 102
#define HC_MENU_ADD                     103
#define HC_MENU_REMOVE                  104
#define HC_MENU_PROPERTIES              105
#define HC_MENU_LOAD                    106
#define HC_MENU_SAVE_AS                 107
#define HC_MENU_EXIT                    108

//
// View menu
//

#define HC_MENU_TOOLBAR                 200
#define HC_MENU_STATUSBAR               201
#define HC_MENU_FILTER                  202
#define HC_MENU_FONT                    203
#define HC_MENU_REFRESH                 204

//
// Help menu
//

#define HC_MENU_HELP                    300
#define HC_MENU_ABOUT                   303

//
// Context menu items: these should duplicate the other menu help
//

#define HC_MENU_CTX_OPEN                HC_MENU_OPEN
#define HC_MENU_CTX_LAUNCH_EXPLORER     HC_MENU_LAUNCH_EXPLORER
#define HC_MENU_CTX_SHARE_A_FOLDER      HC_MENU_SHARE_A_FOLDER
#define HC_MENU_CTX_STOP_SHARING        HC_MENU_STOP_SHARING
#define HC_MENU_CTX_PROPERTIES          HC_MENU_PROPERTIES

//
// The system menu
//

#define HC_MENU_SYSMENU_RESTORE         1000
#define HC_MENU_SYSMENU_MOVE            1001
#define HC_MENU_SYSMENU_SIZE            1002
#define HC_MENU_SYSMENU_MINIMIZE        1003
#define HC_MENU_SYSMENU_MAXIMIZE        1004
#define HC_MENU_SYSMENU_CLOSE           1005
#define HC_MENU_SYSMENU_SWITCHTO        1006

//
// Dialog boxes.  In the form HC_DLG_xxx, where xxx is some reasonably
// descriptive name for the dialog.
//

#define HC_DLG_CUSTOMIZETOOLBAR         2000

//
// Dialog box context-sensitive help
//

// Common
#define HC_OK                           3000
#define HC_CANCEL                       3001

// Filter volumes
#define HC_FV_ALL                       3100
#define HC_FV_NAME                      3101
#define HC_FV_COMMENT                   3102
#define HC_FV_REPLICACOUNT              3104

// Choose Dfs
#define HC_DFSNAME                      3200
#define HC_TREE                         3201

// Add to Dfs dialog
#define HC_ADD_MOUNT_POINT_GROUP        3300
#define HC_ADD_MOUNT_AS                 3301
#define HC_ADD_BROWSE_DFS               3302
#define HC_ADD_UNC                      3303
#define HC_ADD_BROWSE                   3304
#define HC_ADD_COMMENT                  3305

// Volume Property page
#define HC_PROP_MOUNT_POINT_GROUP       3400
#define HC_PROP_MOUNT_AS                3401
#define HC_PROP_UNC                     3402
#define HC_PROP_COMMENT                 3403
#define HC_PROP_ADD                     3406
#define HC_PROP_REMOVE                  3407

// Load Conflict dialog
#define HC_CONFLICT_TEXT				3500
#define HC_OVERRIDE						3501
#define HC_OVERRIDE_ALL					3502
#define HC_IGNORE						3503
#define HC_IGNORE_ALL					3504

//
// Obsolete help ids that haven't been removed yet.
//
#define HC_DFS_PREFIX                   9000
#define HC_EXPLOREDFS                   9000

#endif // __HELPIDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfsutil\rootsup.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       rootsup.cxx
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsstr.h>
#include <lmdfs.h>
#include <dfspriv.h>
#include <dfsm.hxx>
#include <rpc.h>

#include "struct.hxx"
#include "rootsup.hxx"
#include "ftsup.hxx"
#include "misc.hxx"
#include "messages.h"

DWORD
NetDfsRootEnum(
    LPWSTR pwszDcName,
    LPWSTR pwszDomainName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    LPWSTR **List)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS status;
    PWCHAR attrs[2];
    LDAPMessage *pMsg = NULL;
    LDAPMessage *pEntry = NULL;
    WCHAR *pAttr = NULL;
    WCHAR **rpValues = NULL;
    WCHAR **allValues = NULL;
    WCHAR ***rpValuesToFree = NULL;
    INT cValues = 0;
    INT i;
    WCHAR *dfsDn = NULL;
    DWORD len;
    PWCHAR *resultVector = NULL;
    PLDAP pLDAP = NULL;
    LPWSTR pstr;
    ULONG slen;

    if (fSwDebug)
        MyPrintf(L"NetDfsRootEnum(%ws,%ws)\r\n", pwszDcName, pwszDomainName);

    if (List == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pwszDcName == NULL)
        dwErr = DfspGetPdc(wszDcName, pwszDomainName);
    else
        wcscpy(wszDcName, pwszDcName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    ErrorMessage(MSG_CONNECTING, wszDcName);

    dwErr = DfspLdapOpen(wszDcName, pAuthIdent, &pLDAP, DfsConfigContainer, &dfsDn);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    *List = NULL;

    //
    // Now see if we can enumerate the objects below this one.  The names
    //   of these objects will be the different FT dfs's available
    //
    pLDAP->ld_sizelimit = 0;
    pLDAP->ld_timelimit= 0;
    pLDAP->ld_deref = LDAP_DEREF_NEVER;

    attrs[0] = L"CN";
    attrs[1] = NULL;

    dwErr = ldap_search_s(
                        pLDAP,
                        dfsDn,
                        LDAP_SCOPE_ONELEVEL,
                        L"(objectClass=fTDfs)",
                        attrs,
                        0,
                        &pMsg);

    //
    // Make sure the result is reasonable
    //
    if (
        ((cValues = ldap_count_entries(pLDAP, pMsg)) == 0) ||
         (pEntry = ldap_first_entry(pLDAP, pMsg)) == NULL
    ) {
        dwErr = ERROR_PATH_NOT_FOUND;
        goto Cleanup;
    }

    //
    // The search for all FTDfs's returns multiple entries, each with
    // one value for the object's CN. Coalesce these into a single array.
    //

    dwErr = NetApiBufferAllocate(2 * (cValues + 1) * sizeof(PWSTR), (PVOID *)&allValues);

    if (dwErr != ERROR_SUCCESS) {
        goto Cleanup;
    }

    rpValuesToFree = (WCHAR ***) &allValues[cValues + 1];

    for (i = 0; (i < cValues) && (dwErr == ERROR_SUCCESS); i++) {

        rpValues = ldap_get_values(pLDAP, pEntry, attrs[0]);
        rpValuesToFree[i] = rpValues;
        //
        // Sanity check
        //
        if (ldap_count_values(rpValues) == 0 || rpValues[0][0] == L'\0') {
            dwErr = ERROR_PATH_NOT_FOUND;
        } else {
            allValues[i] = rpValues[0];
            pEntry = ldap_next_entry(pLDAP, pEntry);
        }

    }

    if (dwErr != ERROR_SUCCESS) {
        goto Cleanup;
    }

    allValues[i] = NULL;
    rpValuesToFree[i] = NULL;

    //
    // Now we need to allocate the memory to hold this vector and return the results.
    //
    // First see how much space we need
    //

    for (i = len = cValues = 0; allValues[i]; i++) {
        len += sizeof(LPWSTR) + (wcslen(allValues[i]) + 1) * sizeof(WCHAR);
        cValues++;
    }
    len += sizeof(LPWSTR);

    dwErr = NetApiBufferAllocate(len, (PVOID *)&resultVector); 

    if (dwErr != NO_ERROR)
        goto Cleanup;

    RtlZeroMemory(resultVector, len);
    pstr = (LPWSTR)((PCHAR)resultVector + (cValues + 1) * sizeof(LPWSTR));

    len -= (cValues+1) * sizeof(LPWSTR);

    for (i = cValues = 0; allValues[i] && len >= sizeof(WCHAR); i++) {
        resultVector[cValues] = pstr;
        wcscpy(pstr, allValues[i]);
        slen = wcslen(allValues[i]);
        pstr += slen + 1;
        len -= (slen + 1) * sizeof(WCHAR);
        cValues++;
    }

    *List = resultVector;

Cleanup:

    if (rpValuesToFree != NULL) {
        for (i = 0; rpValuesToFree[i] != NULL; i++) {
            ldap_value_free(rpValuesToFree[i]);
        }
    }

    if (allValues != NULL) {
        NetApiBufferFree(allValues);
    }

    if (pMsg != NULL) {
        ldap_msgfree(pMsg);
    }

    if (dfsDn != NULL) {
        free(dfsDn);
    }

    if (pLDAP != NULL) {
        ldap_unbind(pLDAP);
    }

    if (fSwDebug)
        MyPrintf(L"NetDfsRootEnum exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
NetDfsRootServerEnum(
    LDAP *pldap,
    LPWSTR wszDfsConfigDN,
    LPWSTR **ppRootList)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cServers;
    DWORD cRoots;
    DWORD i;
    LPWSTR *pRootList = NULL;
    ULONG Size;
    WCHAR *pWc;

    PLDAPMessage pMsg = NULL;
    LDAPMessage *pmsgServers;

    LPWSTR rgAttrs[5];
    PWCHAR *rgServers = NULL;

    if (fSwDebug)
        MyPrintf(L"DfspCreateRootServerList(%ws)\r\n",
                    wszDfsConfigDN);

    //
    // Search for the FtDfs object
    //

    rgAttrs[0] = L"remoteServerName";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_s(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr != ERROR_SUCCESS) {
        dwErr = LdapMapErrorToWin32(dwErr);
        goto Cleanup;
    }

    pmsgServers = ldap_first_entry(pldap, pMsg);

    if (pmsgServers == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    rgServers = ldap_get_values(
                    pldap,
                    pmsgServers,
                    L"remoteServerName");

    if (rgServers == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    cServers = ldap_count_values(rgServers);

    for (Size = cRoots = i = 0; i < cServers; i++) {
//      if (wcslen(rgServers[i]) < 3 || rgServers[i][0] != UNICODE_PATH_SEP)
//          continue;
        Size += (wcslen(rgServers[i]) + 1) * sizeof(WCHAR);
        cRoots++;
    }

    if (cRoots == 0) {
        *ppRootList = NULL;
        dwErr = ERROR_SUCCESS;
        goto Cleanup;
    }

    Size += sizeof(LPWSTR) * (cRoots + 1);
    pRootList = (LPWSTR *)malloc(Size);

    if (pRootList == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pRootList, Size);
    pWc = (WCHAR *)&pRootList[cRoots+1];
    for (cRoots = i = 0; i < cServers; i++) {
        pRootList[cRoots] = pWc;
        wcscpy(pWc, rgServers[i]);
        pWc += wcslen(rgServers[i]) + 1;
        cRoots++;
    }
    *ppRootList = pRootList;

Cleanup:

    if (rgServers != NULL)
        ldap_value_free(rgServers);

    if (pMsg != NULL)
        ldap_msgfree( pMsg );

    if (fSwDebug) {
        if (dwErr == NO_ERROR && pRootList != NULL) {
            for (i = 0; pRootList[i] != NULL; i++)
                    MyPrintf(L"[%d][%ws]\r\n", i, pRootList[i]);
        }
        MyPrintf(L"DfspCreateRootServerList returning %d\r\n", dwErr);
     }

    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\util\dfsdump\dfsdump.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       DfsDump.c
//
//  Contents:   DFS driver debugging dump.
//
//  Classes:
//
//  Functions:  main
//              Usage
//              DfsReadAndPrintString - Print a string in a dfs structure
//              DumpPkt - Dump PKT, entries and services
//              DumpDevs - Dump device structures
//              DumpFcbs - Dump FCB hash table and all FCBs
//
//  History:    03 Jan 92       Alanw    Created.
//
//--------------------------------------------------------------------------

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tdi.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <lmcons.h>

#include "nodetype.h"
#include "dfsmrshl.h"
#include "dfsfsctl.h"
#include "pkt.h"
#include "dsstruc.h"
#include "fcbsup.h"
#include "dsfsctl.h"
#include "attach.h"
#include "testsup.h"

#define START_OF_NONPAGED_MEM   0x0ff000000


VOID
Usage(
    char*       progname
);

NTSTATUS
DfsReadAndPrintString(
    PUNICODE_STRING     pStr
);

VOID
DfsDump(
    PVOID Ptr
);

VOID
DfsDumpDfsService( PDFS_SERVICE Ptr);

VOID
DfsDumpDSMachine( PDS_MACHINE Ptr);

VOID
DfsDumpDSTransport( PDS_TRANSPORT Ptr);

VOID
DumpPkt( void );

VOID
DumpDevs( void );

VOID
DumpFcbs( void );


#define MemUsage(ptr, size)     {                               \
        if (((ULONG) (ptr))>START_OF_NONPAGED_MEM)      {       \
                NonPagedMem = NonPagedMem + size;               \
        } else {                                                \
                PagedMem = PagedMem + size;                     \
        }                                                       \
    }

#define MemUsageStr(str)        MemUsage((str).Buffer, (str).MaximumLength)



ULONG   NonPagedMem, PagedMem;
DS_DATA DfsData, *pDfsData;
VCB     Vcb;


BOOLEAN Dflag = FALSE;          // dump device objects
BOOLEAN Fflag = FALSE;          // dump FCB hash table and FCBs
BOOLEAN Pflag = FALSE;          // dump PKT and services
BOOLEAN Vflag = FALSE;          // verbose - dump all fields

PWSTR   gpwszServer = NULL;

__cdecl main(argc, argv)
int argc;
char **argv;
{
    FILE_DFS_READ_STRUCT_PARAM  RsParam;
    PLIST_ENTRY                 Link;
    char*                       progname;
    NTSTATUS                    Stat;
    VCB                         *pVcb;
    WCHAR                       wszServer[CNLEN + 1];
    BOOL                        fInvalidArg = FALSE;

    printf("\n");
    progname = argv[0];

//    if (argc >= 3) {
//        Usage(progname);
//        return 3;
//    }

    while (argc > 1 && *argv[1] == '-') {
        char *pszFlags = &argv[1][1];

        while (*pszFlags) {
            switch (*pszFlags++) {
            case 'a':
                Dflag = Fflag = Pflag = TRUE;
                break;

            case 'd':
                Dflag = TRUE;
                break;

            case 'f':
                Fflag = TRUE;
                break;

            case 'p':
                Pflag = TRUE;
                break;

            case 'v':
                Vflag = TRUE;
                break;

            case 's':
                if(*pszFlags != ':' || strlen(pszFlags) > CNLEN ||
                                                      strlen(pszFlags) < 2) {
                    Usage(progname);
                    fInvalidArg = TRUE;
                    break;
                }

                pszFlags++;
                mbstowcs(wszServer,pszFlags, strlen(pszFlags) + 1);
                gpwszServer = wszServer;
                pszFlags += strlen(pszFlags);
                break;

            default:
                Usage(progname);
                fInvalidArg = TRUE;
            }
        }
        argv++;
        argc--;
    }

    if(fInvalidArg)
        return 3;

    if (!Dflag && !Fflag && !Pflag) {
        Pflag = TRUE;
    }

    //
    // Dump out the data structures of the DFS driver.
    //
    RsParam.StructKey = (ULONG)NULL;
    RsParam.TypeCode = DSFS_NTC_DATA_HEADER;
    RsParam.ByteCount = sizeof DfsData;

    Stat = DsfsReadStruct(&RsParam, (PUCHAR)&DfsData);
    if (!NT_SUCCESS(Stat)) {
        printf("%s: DsfsReadStruct for DfsData returned %08x\n", progname, Stat);
        return 3;
    }

    Link = DfsData.VcbQueue.Flink;
    pVcb = CONTAINING_RECORD(Link, VCB, VcbLinks);
    RsParam.StructKey = (ULONG) pVcb;
    RsParam.TypeCode  = DSFS_NTC_VCB;
    RsParam.ByteCount = sizeof Vcb;
    Stat = DsfsReadStruct(&RsParam, (PUCHAR) &Vcb);
    if (!NT_SUCCESS(Stat))  {
        return 3;
    }

    pDfsData = CONTAINING_RECORD((Vcb.VcbLinks.Blink), DS_DATA, VcbQueue);

    MemUsage(pDfsData, RsParam.ByteCount);

    MemUsageStr(DfsData.LogRootDevName);

    if (Vflag)  {

        printf("DfsData @ %08x:\t", pDfsData);
        DfsDump(&DfsData);
        printf("\n");

    } else {

        printf("DfsData @ %08x:\n\n", pDfsData);
    }

    if (Dflag) {
        DumpDevs();
    }

    if (Fflag) {
        DumpFcbs();
    }

    if (Pflag) {
        DumpPkt();
    }


    printf("Total Paged Mem Used: %d\n", PagedMem);
    printf("Total NonPaged Mem Used: %d\n", NonPagedMem);

    return 0;
}




VOID
Usage(
    char*       progname
) {
    printf("Usage: %s [-vdfp] [-s:server]\n", progname);
    printf("   -v\tVerbose\n");
    printf("   -d\tDump device structures\n");
    printf("   -f\tDump FCB structures\n");
    printf("   -p\tDump PKT structures(default)\n");
    printf("   -s:server\tDump the PKT on the indicated Cairo server\n");
    exit (1);
}




NTSTATUS
DfsReadAndPrintString(
    PUNICODE_STRING     pStr
) {
    FILE_DFS_READ_STRUCT_PARAM RsParam;
    UCHAR Buf[500];
    UNICODE_STRING Str;
    NTSTATUS Stat;

    if (pStr->Buffer == NULL) {
        printf("*NULL*");
        return STATUS_SUCCESS;
    }
    if (pStr->Length > sizeof Buf) {
        printf("*StringTooLong*");
        return STATUS_SUCCESS;
    }
    RsParam.StructKey = (ULONG) pStr->Buffer;
    RsParam.TypeCode = 0;
    RsParam.ByteCount = pStr->Length;
    if (! NT_SUCCESS( Stat = DsfsReadStruct(&RsParam, Buf)))
        return Stat;

//    MemUsage(RsParam.StructKey, RsParam.ByteCount);

    Str = *pStr;
    Str.Buffer = (WCHAR *)Buf;
    printf("%wZ", &Str);
    return STATUS_SUCCESS;
}




//+-------------------------------------------------------------------
//
//  Function:   DumpPkt, local
//
//  Synopsis:   This routine will dump the contents of the PKT and
//              all the associated data.
//
//  Arguments:  None
//
//  Returns:    None
//
//  Requires:   DfsData must have previously been loaded into memory.
//
//--------------------------------------------------------------------



VOID
DumpPkt( void )
{
    FILE_DFS_READ_STRUCT_PARAM  RsParam;
    PLIST_ENTRY                 Link, Sentinel = NULL;
    DFS_PKT_ENTRY               PktEntry, *pPktEntry;
    DFS_SERVICE                 Service;
    PDS_TRANSPORT               pTransport;
    DFS_MACHINE_ENTRY           MachEntry;
    PDS_MACHINE                 pMachine;
    NTSTATUS                    Stat;
    ULONG                       i, j, k;
    char*                       pszMsg;

    pTransport = (PDS_TRANSPORT) malloc ( sizeof(DS_TRANSPORT)+512*sizeof(UCHAR) );
    pMachine = (PDS_MACHINE) malloc ( sizeof(DS_MACHINE)+512*sizeof(PVOID) );
    //
    // Now we take care of the Pkt dump.
    //
    if (Vflag)
    {
        printf("Pkt @ %08x:\t", &(pDfsData->Pkt));
        DfsDump(&(DfsData.Pkt));
        printf("\n");
    }
    else
    {
        //
        // In here place whatever needs to be dumped from Pkt.
        //

        printf("Pkt @ %08x:\n", &(pDfsData->Pkt));
        printf("\tDomainPktEntry @ %08x\n", DfsData.Pkt.DomainPktEntry);
        printf("\n");
    }


    //
    // We now work with the Pkt Entries in the Pkt.
    //

    Link = DfsData.Pkt.EntryList.Flink;

    for (i=0; i<DfsData.Pkt.EntryCount; i++)
    {

        pPktEntry = CONTAINING_RECORD(Link, DFS_PKT_ENTRY, Link);
        RsParam.StructKey = (ULONG) pPktEntry;
        RsParam.TypeCode  = DSFS_NTC_PKT_ENTRY;
        RsParam.ByteCount = sizeof(DFS_PKT_ENTRY);

        Stat = DsfsReadStruct(&RsParam, (PUCHAR) &PktEntry);

        if (!NT_SUCCESS(Stat))
        {
           exit(3);
        }

        MemUsage(RsParam.StructKey, RsParam.ByteCount);

        MemUsageStr(PktEntry.Id.Prefix);

        if (Vflag)
        {
            printf("\nPktEntry @ %08x:\t",pPktEntry);
            DfsDump(&PktEntry);
            printf("\n");

        }
        else
        {
            //
            // Place any other fields from PktEntry that need to
            // be dumped out here.
            //

            printf("\tPktEntry @ %08x:\t",pPktEntry);
            printf("EntryId.Prefix: ");
            Stat = DfsReadAndPrintString(&(PktEntry.Id.Prefix));
            printf("\n");
        }

        //
        // We now need to deal with the local service
        // in the Pkt entry.
        //

        if (PktEntry.LocalService)
        {
            RsParam.StructKey = (ULONG) PktEntry.LocalService;
            RsParam.TypeCode  = 0;
            RsParam.ByteCount = sizeof(DFS_SERVICE);

            Stat = DsfsReadStruct(&RsParam, (PUCHAR) &Service);

            if (!NT_SUCCESS(Stat))
            {
                exit(3);
            }

            MemUsage(RsParam.StructKey, RsParam.ByteCount);

            MemUsageStr(Service.Name);
            MemUsageStr(Service.Address);


            if (Vflag)
            {
                printf("\nLOCAL_SERVICE:\n");
                DfsDumpDfsService(&Service);
            }
            else
            {
                printf("\t\tLocalService: ");
                DfsReadAndPrintString((PUNICODE_STRING)&(Service.Address));
                printf("\n");
            }
        }

        //
        // We now need to dump the service list in the EntryInfo
        // structure in the PktEntry above.
        //

        for (j=0; j<PktEntry.Info.ServiceCount; j++)
        {

            RsParam.StructKey = (ULONG) (PktEntry.Info.ServiceList
                                    + j);
            RsParam.TypeCode  = 0;
            RsParam.ByteCount = sizeof(DFS_SERVICE);
            Stat = DsfsReadStruct(&RsParam, (PUCHAR) &Service);

            if (!NT_SUCCESS(Stat))
            {
                    exit(3);
            }

            MemUsage(RsParam.StructKey, RsParam.ByteCount);
            MemUsageStr(Service.Name);
            MemUsageStr(Service.Address);

            if (PktEntry.Info.ServiceList + j == PktEntry.ActiveService)
            {
                pszMsg = " (active)";
            }
            else
            {
                pszMsg = "";
            }
            if (Vflag)
            {
                printf("\nSERVICE# %d%s:\n", j, pszMsg);
                DfsDumpDfsService(&Service);

                //
                // Now we need to dump the MACHINE_ADDR structure as well.
                //
                RsParam.StructKey = (ULONG) (Service.pMachEntry);
                RsParam.TypeCode = 0;
                RsParam.ByteCount = sizeof(DFS_MACHINE_ENTRY);
                Stat = DsfsReadStruct(&RsParam, (PUCHAR) &MachEntry);
                if (!NT_SUCCESS(Stat))
                {
                    printf("Failed to read pDFS_MACHINE_ENTRY address %08lx\n", Stat);
                    exit(3);
                }

                RsParam.StructKey = (ULONG) MachEntry.pMachine;
                RsParam.TypeCode  = 0;
                RsParam.ByteCount = sizeof(DS_MACHINE);
                Stat = DsfsReadStruct(&RsParam, (PUCHAR) pMachine);

                if (!NT_SUCCESS(Stat))
                {
                    exit(3);
                }

                if (pMachine->cTransports != 0)
                {
                    RsParam.StructKey = (ULONG) (((CHAR *) MachEntry.pMachine) + DS_MACHINE_SIZE);
                    RsParam.TypeCode = 0;
                    RsParam.ByteCount = (USHORT) pMachine->cTransports*sizeof(PDS_TRANSPORT);
                    Stat = DsfsReadStruct(&RsParam, (PUCHAR) &pMachine->rpTrans[0]);
                    if (!NT_SUCCESS(Stat))
                    {
                        exit(3);
                    }
                }
                MemUsage(RsParam.StructKey, RsParam.ByteCount);
                DfsDumpDSMachine(pMachine);

                //
                // We really need to read the PrincipalName also but lets skip
                // for now.
                //

                for (k=0; k<pMachine->cTransports; k++)
                {
                    RsParam.StructKey = (ULONG) (pMachine->rpTrans[k]);
                    RsParam.ByteCount = DS_TRANSPORT_SIZE;
                    RsParam.TypeCode = 0;
                    Stat = DsfsReadStruct(&RsParam, (PUCHAR) pTransport);
                    if (!NT_SUCCESS(Stat))
                        exit(3);

                    MemUsage(RsParam.StructKey, RsParam.ByteCount);

                    //
                    // Now we need to read the actual address buffer in.
                    //
                    if (pTransport->taddr.AddressLength != 0)
                    {

                        RsParam.StructKey = (ULONG) (((CHAR *) (pMachine->rpTrans[k])) + DS_TRANSPORT_SIZE);
                        RsParam.ByteCount = pTransport->taddr.AddressLength;
                        RsParam.TypeCode = 0;
                        Stat = DsfsReadStruct(&RsParam, (PUCHAR) &pTransport->taddr.Address[0]);
                        if (!NT_SUCCESS(Stat))
                            exit(3);
                    }
                    DfsDumpDSTransport(pTransport);
                }

            }
            else
            {
                printf("\t\tService#%d%s: ", j, pszMsg);
                DfsReadAndPrintString((PUNICODE_STRING) &(Service.Address));
                printf("\n");
            }
        }
        printf("\n");
        Link = PktEntry.Link.Flink;
    }
    free(pTransport);
    free(pMachine);

}



//+-------------------------------------------------------------------
//
//  Function:   DumpDevs, local
//
//  Synopsis:   This routine will dump the contents of the devices
//              associated with the DFS FSD.
//
//  Arguments:  None
//
//  Returns:    None
//
//  Requires:   DfsData must have previously been loaded into memory.
//
//--------------------------------------------------------------------

VOID
DumpDevs( void )
{
    FILE_DFS_READ_STRUCT_PARAM  RsParam;
    PLIST_ENTRY                 Link, Sentinel = NULL;
    PROVIDER_DEF                Provider;
    DFS_VOLUME_OBJECT           DfsVdo, *pDfsVdo;
    LOGICAL_ROOT_DEVICE_OBJECT  DfsLrdo, *pDfsLrdo;
    NTSTATUS                    Stat;
    ULONG                       i;

    //
    // Now we dump the Provider list.
    //

    if (DfsData.pProvider)
    {

        for (i=0; i<(ULONG)DfsData.cProvider; i++)
        {

            RsParam.StructKey = (ULONG) (DfsData.pProvider+i);
            RsParam.TypeCode  = DSFS_NTC_PROVIDER;
            RsParam.ByteCount = sizeof(PROVIDER_DEF);

            Stat = DsfsReadStruct(&RsParam, (PUCHAR) &Provider);
            if (NT_SUCCESS(Stat))
            {
                break;
            }

            MemUsage(RsParam.StructKey, RsParam.ByteCount);
            MemUsageStr(Provider.DeviceName);

            printf("Provider#%d @ %08x:\t", i, RsParam.StructKey);
            if (Vflag)
            {
                DfsDump(&Provider);
            }
            else
            {
                printf("Device Name: ");
                DfsReadAndPrintString(&(Provider.DeviceName));
            }
            printf("\n");
        }
        printf("\n");
    }

    //
    // Dump the file system device object
    //

    if (Vflag)
    {
        DEVICE_OBJECT Fsdo, *pFsdo;

        pFsdo = DfsData.FileSysDeviceObject;
        RsParam.StructKey = (ULONG) pFsdo;
        RsParam.TypeCode = IO_TYPE_DEVICE;
        RsParam.ByteCount = sizeof Fsdo;

        Stat = DsfsReadStruct(&RsParam, (PUCHAR) &Fsdo);
        if (NT_SUCCESS(Stat))
        {

            MemUsage(RsParam.StructKey, RsParam.ByteCount);

            printf("FileSysDeviceObject @ %08x:\t", pFsdo);
            DfsDump(&Fsdo);
            printf("\n");
        }
    }
    else
        MemUsage(DfsData.FileSysDeviceObject, sizeof (DEVICE_OBJECT));


    //
    // Now we look at the volume device objects
    //

    for (Link = DfsData.AVdoQueue.Flink;
         Link != Sentinel;
         Link = DfsVdo.VdoLinks.Flink) {
        pDfsVdo = CONTAINING_RECORD( Link, DFS_VOLUME_OBJECT, VdoLinks );

        RsParam.StructKey = (ULONG) pDfsVdo;
        RsParam.TypeCode = IO_TYPE_DEVICE;
        RsParam.ByteCount = sizeof DfsVdo;
        if (! NT_SUCCESS( Stat = DsfsReadStruct(&RsParam, (PUCHAR)&DfsVdo)))
            exit(3);

        MemUsage(RsParam.StructKey, RsParam.ByteCount);

        MemUsageStr(DfsVdo.Provider.DeviceName);

        if (Link == DfsData.AVdoQueue.Flink)
            Sentinel = DfsVdo.VdoLinks.Blink;

        if (Vflag) {
            printf("DfsVdo @ %08x:\t", pDfsVdo);
            DfsDump(&DfsVdo);
            printf("\n");
        } else {
            printf("DfsVdo @ %08x:\t", pDfsVdo);
            Stat = DfsReadAndPrintString(&DfsVdo.Provider.DeviceName);
            printf("\n");
        }
    }

    //
    // Now we look at the Vcbs (logical root device object extensions).
    //

    for (Link = DfsData.VcbQueue.Flink;
         Link != Sentinel;
         Link = DfsLrdo.Vcb.VcbLinks.Flink) {
        pDfsLrdo = CONTAINING_RECORD( Link, LOGICAL_ROOT_DEVICE_OBJECT, Vcb.VcbLinks );

        RsParam.StructKey = (ULONG) pDfsLrdo;
        RsParam.TypeCode = IO_TYPE_DEVICE;
        RsParam.ByteCount = sizeof DfsLrdo;
        if (! NT_SUCCESS( Stat = DsfsReadStruct(&RsParam, (PUCHAR)&DfsLrdo)))
            exit(3);

        MemUsage(RsParam.StructKey, RsParam.ByteCount);

        MemUsageStr(DfsLrdo.Vcb.LogicalRoot);
        MemUsageStr(DfsLrdo.Vcb.LogRootPrefix);

        if (Link == DfsData.VcbQueue.Flink)
            Sentinel = DfsLrdo.Vcb.VcbLinks.Blink;

        if (Vflag) {
            printf("DfsLrdo @ %08x:\t", pDfsLrdo);
            DfsDump(&DfsLrdo);
            printf("\n");
        } else {
            printf("DfsLrdo @ %08x:\t", pDfsLrdo);
            Stat = DfsReadAndPrintString(&DfsLrdo.Vcb.LogicalRoot);
            if (! NT_SUCCESS(Stat))
                exit(3);
            printf("\n\tPrefix =\t");
            Stat = DfsReadAndPrintString(&DfsLrdo.Vcb.LogRootPrefix);
            if (! NT_SUCCESS(Stat) )
                exit(3);
            printf("\n");
        }
    }
}



//+-------------------------------------------------------------------
//
//  Function:   DumpFcbs, local
//
//  Synopsis:   This routine will dump the contents of the FCB hash
//              table, and all the associated FCBs.
//
//  Arguments:  None
//
//  Returns:    None
//
//  Requires:   DfsData must have previously been loaded into memory.
//
//--------------------------------------------------------------------



VOID
DumpFcbs( void )
{
    FILE_DFS_READ_STRUCT_PARAM RsParam;
    struct _FCB_HASH{
        FCB_HASH_TABLE  FcbHash;
        LIST_ENTRY      FcbHashBuckets2[127];
    } FcbHashTab, *pFcbHashTab;
    FCB Fcb, *pFcb;
    NTSTATUS Stat;
    ULONG i;

    RsParam.StructKey = (ULONG) (pFcbHashTab =
                        (struct _FCB_HASH *)DfsData.FcbHashTable);
    RsParam.TypeCode = 0;
    RsParam.ByteCount = sizeof (NODE_TYPE_CODE) + sizeof (NODE_BYTE_SIZE);
    if (! NT_SUCCESS( Stat = DsfsReadStruct(&RsParam, (PUCHAR) &FcbHashTab))) {
        printf("Error accessing DfsData.FcbHashTable\n");
        exit(4);
    }

    RsParam.StructKey = (ULONG) DfsData.FcbHashTable;
    RsParam.TypeCode = FcbHashTab.FcbHash.NodeTypeCode;
    RsParam.ByteCount = FcbHashTab.FcbHash.NodeByteSize;
    if (! NT_SUCCESS( Stat = DsfsReadStruct(&RsParam, (PUCHAR) &FcbHashTab))) {
        printf("Error accessing DfsData.FcbHashTable\n");
        exit(4);
    }

    MemUsage(RsParam.StructKey, RsParam.ByteCount);

    if (Vflag) {
        printf("\nFcbHashTable @ %08x:\t", DfsData.FcbHashTable);
        DfsDump(&FcbHashTab);
    } else {
        printf("FcbHashTable @ %08x\n", DfsData.FcbHashTable);
    }

    //
    // Now we look at the FCBs.
    //

    for (i = 0; i <= FcbHashTab.FcbHash.HashMask; i++) {
        PLIST_ENTRY     ListHead, Link, Sentinel = NULL;

        ListHead = &FcbHashTab.FcbHash.HashBuckets[i];
        if (ListHead->Flink == NULL)            // Never initialized
            continue;
        if ((PUCHAR) ListHead->Flink ==
            ((PUCHAR)ListHead - (PUCHAR) &FcbHashTab) + (PUCHAR)pFcbHashTab) {
            printf("    HashBucket[%2d] ==>  <empty>\n", i);
            continue;
        }

        printf("    HashBucket[%2d] ==> ", i);

        for (Link = ListHead->Flink;
             Link != Sentinel;
             Link = Fcb.HashChain.Flink) {
            pFcb = CONTAINING_RECORD( Link, FCB, HashChain );

            RsParam.StructKey = (ULONG) pFcb;
            RsParam.TypeCode = DSFS_NTC_FCB;
            RsParam.ByteCount = sizeof Fcb;
            if (! NT_SUCCESS( Stat = DsfsReadStruct(&RsParam, (PUCHAR)&Fcb))) {
                printf("Error accessing Fcb\n");
                exit(4);
            }

            MemUsage(RsParam.StructKey, RsParam.ByteCount);

            if (Link == ListHead->Flink)
                Sentinel = Fcb.HashChain.Blink;

            if (Vflag) {
                printf("Fcb @ %08x:\t", pFcb);
                DfsDump(&Fcb);
                printf("\n");
            } else {
                printf("%08x ", pFcb);
            }
        }
        printf("\n");
    }

    printf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfsutil\misc.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       misc.cxx
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsstr.h>
#include <dfsmrshl.h>
#include <marshal.hxx>
#include <lmdfs.h>
#include <dfspriv.h>
#include <dfsm.hxx>
#include <recon.hxx>
#include <rpc.h>
#include <fsctrl.h>
#include <ntdsapi.h>
#include <dsrole.h>
#include <ntlsa.h>

#include "struct.hxx"
#include "ftsup.hxx"
#include "stdsup.hxx"
#include "rootsup.hxx"
#include "flush.hxx"
#include "info.hxx"
#include "misc.hxx"
#include "messages.h"


#define MAX_BUF_SIZE	10000

WCHAR MsgBuf[MAX_BUF_SIZE];
CHAR  AnsiBuf[MAX_BUF_SIZE*3];

WCHAR wszRootShare[MAX_PATH+1] = { 0 };
#define WINLOGON_FOLDER L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SFCVALUE L"SFCDisable"
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

DWORD
DfspDomVerify(
    LPWSTR pwszDfsName,
    LPWSTR pwszShareName,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    LPWSTR pwszHexValue);

DWORD
DfspDomView(
    LPWSTR pwszDfsName,
    LPWSTR pwszShareName,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    LPWSTR pwszHexValue);

DWORD
DfspGetLinkName(
    LPWSTR pwszDfsRoot,
    LPWSTR *ppwszLinkName);

DWORD
CmdMupFlags(
    ULONG dwFsctrl,
    LPWSTR pwszHexValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Level = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdMupFlags(0x%x, %ws)\r\n", dwFsctrl, pwszHexValue);

    if (pwszHexValue != NULL) {
        Level = AtoHex(pwszHexValue, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"Bad Level %ws\r\n", pwszHexValue);
            goto Cleanup;
        }
    }

    MyPrintf(L"Setting debug level to 0x%x\r\n", Level);

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   dwFsctrl,
                   &Level,
                   sizeof(ULONG),
                   NULL,
                   0);

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (DriverHandle != NULL)
        NtClose(DriverHandle);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdMupFlags returning %d\r\n", dwErr);
        
    return dwErr;
}

DWORD
CmdMupReadReg(
    BOOLEAN fSwDfs)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Level = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"MupReadReg()\r\n");

    if (fSwDfs == TRUE) {
        MyPrintf(L"--dfs.sys--\r\n");
        RtlInitUnicodeString(&DfsDriverName, DFS_SERVER_NAME);
    } else {
        MyPrintf(L"--mup.sys--\r\n");
        RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);
    }

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }
    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_REREAD_REGISTRY,
                   NULL,
                   0,
                   NULL,
                   0);

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (DriverHandle != NULL)
        NtClose(DriverHandle);

    if (fSwDebug == TRUE)
        MyPrintf(L"MupReadReg exit\r\n");
        
    return dwErr;
}

DWORD
AtoHex(
    LPWSTR pwszHexValue,
    PDWORD pdwErr)
{
    DWORD dwHexValue = 0;

    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoHex(%ws)\r\n", pwszHexValue);

    if (pwszHexValue == NULL) {
        *pdwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    if (pwszHexValue[0] == L'0' && (pwszHexValue[1] == L'x' || pwszHexValue[1] == L'X'))
        pwszHexValue = &pwszHexValue[2];

    swscanf(pwszHexValue, L"%x", &dwHexValue);

 AllDone:

    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoHex returning 0x%x (dwErr=0x%x)\r\n", dwHexValue, *pdwErr);

    return dwHexValue;
}

DWORD
AtoDec(
    LPWSTR pwszDecValue,
    PDWORD pdwErr)
{
    DWORD dwDecValue = 0;

    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoDec(%ws)\r\n", pwszDecValue);

    if (pwszDecValue == NULL) {
        *pdwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    swscanf(pwszDecValue, L"%d", &dwDecValue);

 AllDone:

    // if (fSwDebug == TRUE)
    //     MyPrintf(L"AtoDec returning 0x%x (dwErr=0x%x)\r\n", dwDecValue, *pdwErr);

    return dwDecValue;
}

CHAR ServerName[0x1000];

DWORD
CmdDfsAlt(
    LPWSTR pwszServerName)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsAlt(%ws)\r\n", pwszServerName);

    if (pwszServerName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);
    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );
    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    if (
        (wcslen(pwszServerName) < 5) ||
        *pwszServerName != L'\\' ||
        *(pwszServerName+1) != L'\\'
    ) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    MyPrintf(L"%ws -> ", pwszServerName);

    // Resolve to server name

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SERVER_NAME,
                   pwszServerName,
                   wcslen(pwszServerName) * sizeof(WCHAR),
                   ServerName,
                   sizeof(ServerName)
               );

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
    } else if (NT_SUCCESS(IoStatusBlock.Status) && IoStatusBlock.Information > 0) {
        MyPrintf(L"%ws\r\n", ServerName);
    } else {
        dwErr = RtlNtStatusToDosError(IoStatusBlock.Status);
    }

Cleanup:

    if (DriverHandle == NULL)
        NtClose(DriverHandle);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsAlt exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdSetDc(
    LPWSTR pwszDcName)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSetDc(%ws)\r\n", pwszDcName);

    if (pwszDcName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    pwszDcName += 2;

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                );

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_PKT_SET_DC_NAME,
                   pwszDcName,
                   wcslen(pwszDcName) * sizeof(WCHAR) + sizeof(WCHAR),
                   NULL,
                   0);

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (DriverHandle != NULL)
        NtClose(DriverHandle);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSetDc exit %d\r\n", dwErr);
        
    return dwErr;
}

DWORD
CmdDcList(
    LPWSTR pwszDomainName,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent)
{
    PDS_DOMAIN_CONTROLLER_INFO_1 pDsDomainControllerInfo1 = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    HANDLE hDs = NULL;
    DWORD dwErr;
    DWORD Count;
    ULONG i;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDcList(%ws,%ws)\r\n", pwszDomainName, pwszDcName);

    if (pwszDcName != NULL) {
        dwErr = DsBind(pwszDcName, NULL, &hDs);
    } else if (pwszDomainName != NULL) {
        dwErr = DsBind(NULL, pwszDomainName, &hDs);
    } else {
        dwErr = DsRoleGetPrimaryDomainInformation(
                    NULL,
                    DsRolePrimaryDomainInfoBasic,
                    (PBYTE *)&pPrimaryDomainInfo);

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;
        pwszDomainName = pPrimaryDomainInfo->DomainNameDns;
        dwErr = DsBind(NULL, pwszDomainName, &hDs);
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"Bind returned %d\r\n", dwErr);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = DsGetDomainControllerInfo(
                    hDs,
                    pwszDomainName,
                    1,
                    &Count,
                    (PVOID *)&pDsDomainControllerInfo1);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"DsGetDomainControllerInfo() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    for (i = 0; i < Count; i++) {
        MyPrintf(L"%d:\r\n", i+1);
        MyPrintf(L"\tNetbiosName=%ws\r\n", pDsDomainControllerInfo1[i].NetbiosName);
        MyPrintf(L"\tDnsHostName=%ws\r\n", pDsDomainControllerInfo1[i].DnsHostName);
        MyPrintf(L"\tSiteName=%ws\r\n", pDsDomainControllerInfo1[i].SiteName);
        if (fSwDebug == TRUE) {
            MyPrintf(L"\tComputerObjectName=%ws\r\n", pDsDomainControllerInfo1[i].ComputerObjectName);
            MyPrintf(L"\tServerObjectName=%ws\r\n", pDsDomainControllerInfo1[i].ServerObjectName);
        }
        MyPrintf(L"\tfIsPdc=%d\r\n", pDsDomainControllerInfo1[i].fIsPdc);
        MyPrintf(L"\tfDsEnabled=%d\r\n", pDsDomainControllerInfo1[i].fDsEnabled);
    }

Cleanup:

    if (pDsDomainControllerInfo1 != NULL) {
        DsFreeDomainControllerInfo(
            1,
            Count,
            pDsDomainControllerInfo1);
    }

    if (pPrimaryDomainInfo != NULL)
        DsRoleFreeMemory(pPrimaryDomainInfo);

    if (hDs != NULL)
        DsUnBind(&hDs);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDcList returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdDomList(
    LPWSTR pwszDcName,
    LPWSTR pwszDomainName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR *DomDfsList = NULL;
    ULONG i;

    MyPrintf(L"Getting DomDfs's in %ws\r\n", pwszDomainName);
    dwErr = NetDfsRootEnum(
                pwszDcName,
                pwszDomainName,
                pAuthIdent,
                &DomDfsList);

    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    if (DomDfsList != NULL) {
        for (i = 0; DomDfsList[i]; i++)
            /* NOTHING */;
        MyPrintf(L"Found %d DomDfs's\r\n", i);
        for (i = 0; DomDfsList[i]; i++)
                MyPrintf(L"%ws\r\n", DomDfsList[i]);
        NetApiBufferFree(DomDfsList);
    }

    return dwErr;
}

DWORD
CmdStdList(
    LPWSTR pwszDomainName)
{
    DWORD dwErr = ERROR_SUCCESS;
    PSERVER_INFO_101 pInfo101 = NULL;
    ULONG dwEntriesRead;
    ULONG dwTotalEntries;
    ULONG i;

    MyPrintf(L"Getting Dfs's in %ws\r\n", pwszDomainName);
    dwErr = NetServerEnum(
                NULL,
                101,
                (PUCHAR *)&pInfo101,
                -1,
                &dwEntriesRead,
                &dwTotalEntries,
                SV_TYPE_DFS,
                pwszDomainName,
                NULL);

    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    if (pInfo101 != NULL) {
        MyPrintf(L"Found %d Dfs's\r\n", dwEntriesRead);
        for (i = 0; i < dwEntriesRead; i++) {
            MyPrintf(L"%ws (%d.%d)\r\n",
                        pInfo101[i].sv101_name,
                        pInfo101[i].sv101_version_major,
                        pInfo101[i].sv101_version_minor);
        }
        NetApiBufferFree(pInfo101);
    }
    return dwErr;
}

DWORD
CmdVerify(
    LPWSTR pwszDfsRoot,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    LPWSTR pwszHexValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR pwszDfsName = NULL;
    LPWSTR pwszShareName = NULL;
    BOOLEAN IsDomainName = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdVerify(%ws,%ws)\r\n", pwszDfsRoot, pwszDcName);

    if (pwszDfsRoot == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    dwErr = DfspParseName(
                pwszDfsRoot,
                &pwszDfsName,
                &pwszShareName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = DfspIsDomainName(
                pwszDfsName,
                pwszDcName,
                &IsDomainName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (IsDomainName == TRUE) {
        dwErr = DfspDomVerify(
                    pwszDfsName,
                    pwszShareName,
                    pwszDcName,
                    pAuthIdent,
                    pwszHexValue);
    } else {
        fArgVerify = TRUE;
        dwErr = CmdViewOrVerify(
                    pwszDfsName,
                    pwszDcName,
                    NULL,
                    pAuthIdent,
                    pwszHexValue);
    }

Cleanup:

    if (pwszDfsName != NULL)
        free(pwszDfsName);
    if (pwszShareName != NULL)
        free(pwszShareName);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdVerify returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
DfspDomVerify(
    LPWSTR pwszDfsName,
    LPWSTR pwszShareName,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    LPWSTR pwszHexValue)
{
    ULONG i;
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wszTempName[MAX_PATH+1];
    DFS_VOLUME_LIST DfsVolList = { 0 };
    BOOLEAN IsFtRoot = FALSE;
    WCHAR wszDfsName[MAX_PATH+1];
    DWORD cbName;
    DWORD dwType;
    DWORD Level = 0;
    HKEY hKey = NULL;
    HKEY rKey = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspDomVerify(%ws,%ws,%ws)\r\n", pwszDfsName, pwszShareName, pwszHexValue);

    if (pwszHexValue != NULL) {
        Level = AtoHex(pwszHexValue, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"Bad Level %ws\r\n", pwszHexValue);
            goto Cleanup;
        }
    }

    MyPrintf(L"\\\\%ws\\%ws is a DomDfs\r\n", pwszDfsName, pwszShareName);

    dwErr = DfsGetFtVol(
                &DfsVolList,
                pwszShareName,
                pwszDcName,
                pwszDfsName,
                pAuthIdent);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    for (i = 0; i < DfsVolList.Volumes[0]->ReplCount; i++) {

        wcscpy(wszTempName, L"\\\\");
        wcscat(wszTempName, DfsVolList.Volumes[0]->ReplicaInfo[i].pwszServerName);
        IsFtRoot = FALSE;

        if (rKey != NULL) {
            RegCloseKey(rKey);
            rKey = NULL;
        }
        if (hKey != NULL) {
            RegCloseKey(hKey);
            hKey = NULL;
        }

        MyPrintf(L"Checking root %ws\r\n", wszTempName);

        dwErr = RegConnectRegistry(
                        wszTempName,
                        HKEY_LOCAL_MACHINE,
                        &rKey);

        if (dwErr != ERROR_SUCCESS) {
            ErrorMessage(MSG_CAN_NOT_OPEN_REGISTRY, wszTempName, dwErr);
            continue;
        }

        dwErr = RegOpenKey(rKey, VOLUMES_DIR, &hKey);

        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"Can not open %ws of %ws (error %d)\r\n",
                        VOLUMES_DIR,
                        wszTempName,
                        dwErr);
            continue;
        }

        if (dwErr == ERROR_SUCCESS) {
	    cbName = MAX_PATH;
            dwErr = RegQueryValueEx(
                        hKey,
                        FTDFS_VALUE_NAME,
                        NULL,
                        &dwType,
                        (PBYTE) wszDfsName,
                        &cbName);

            if (dwErr == ERROR_MORE_DATA)
                dwErr = ERROR_SUCCESS;

            if (dwErr == ERROR_SUCCESS && dwType == REG_SZ)
                IsFtRoot = TRUE;
        }

        if (IsFtRoot == FALSE) {
            MyPrintf(L"%ws is not a DomDfs root (%d)\r\n",
                    wszTempName,
                    dwErr);
            continue;
        }

        cbName = MAX_PATH;
        dwErr = RegQueryValueEx(
            hKey,
            ROOT_SHARE_VALUE_NAME,
            NULL,
            &dwType,
            (PBYTE) wszRootShare,
            &cbName);

        if (dwErr == ERROR_MORE_DATA)
            dwErr = ERROR_SUCCESS;

        if (dwErr != ERROR_SUCCESS || dwType != REG_SZ) {
            MyPrintf(L"Registry value \"RootShare\" is missing or corrupt.\r\n");
            continue;
        }

        dwErr = GetExitPtInfo(
                    rKey,
                    &DfsVolList.pRootLocalVol,
                    &DfsVolList.cRootLocalVol);

        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"Could not get registry/exit pt info for %ws\r\n", wszTempName);
            continue;
        }
        if (fArgVerify)
            DfsCheckVolList(&DfsVolList, Level);
        DfsFreeRootLocalVol(
                DfsVolList.pRootLocalVol,
                DfsVolList.cRootLocalVol);
        DfsVolList.pRootLocalVol = NULL;
        DfsVolList.cRootLocalVol = 0;
    }

Cleanup:

    //
    // Free volume info
    //
    DfsFreeVolList(&DfsVolList);

    //
    // Free exit pt info
    //
    DfsFreeRootLocalVol(
            DfsVolList.pRootLocalVol,
            DfsVolList.cRootLocalVol);

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (rKey != NULL)
        RegCloseKey(rKey);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspDomVerify returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdView(
    LPWSTR pwszDfsRoot,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    LPWSTR pwszHexValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR pwszDfsName = NULL;
    LPWSTR pwszShareName = NULL;
    BOOLEAN IsDomainName = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdView(%ws,%ws,%ws)\r\n", pwszDfsRoot, pwszDcName, pwszHexValue);

    if (pwszDfsRoot == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    dwErr = DfspParseName(
                pwszDfsRoot,
                &pwszDfsName,
                &pwszShareName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = DfspIsDomainName(
                pwszDfsName,
                pwszDcName,
                &IsDomainName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (IsDomainName == TRUE) {
        dwErr = DfspDomView(
                    pwszDfsName,
                    pwszShareName,
                    pwszDcName,
                    pAuthIdent,
                    pwszHexValue);
    } else {
        fArgView = TRUE;
        dwErr = CmdViewOrVerify(
                    pwszDfsName,
                    pwszDcName,
                    NULL,
                    pAuthIdent,
                    pwszHexValue);
    }

Cleanup:

    if (pwszDfsName != NULL)
        free(pwszDfsName);
    if (pwszShareName != NULL)
        free(pwszShareName);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdView returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
DfspDomView(
    LPWSTR pwszDfsName,
    LPWSTR pwszShareName,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    LPWSTR pwszHexValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    DFS_VOLUME_LIST DfsVolList = { 0 };
    ULONG Level = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspDomView(%ws,%ws,%ws)\r\n", pwszDfsName, pwszShareName, pwszHexValue);

    if (pwszHexValue != NULL) {
        Level = AtoHex(pwszHexValue, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"Bad Level %ws\r\n", pwszHexValue);
            goto Cleanup;
        }
    }

    MyPrintf(L"\\\\%ws\\%ws is a DomDfs\r\n", pwszDfsName, pwszShareName);

    dwErr = DfsGetFtVol(
                &DfsVolList,
                pwszShareName,
                pwszDcName,
                pwszDfsName,
                pAuthIdent);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (fSwDebug == TRUE)
        DfsDumpVolList(&DfsVolList);

    DfsViewVolList(&DfsVolList, Level);

Cleanup:

    //
    // Free volume info
    //
    DfsFreeVolList(&DfsVolList);

    //
    // Free exit pt info
    //
    DfsFreeRootLocalVol(
            DfsVolList.pRootLocalVol,
            DfsVolList.cRootLocalVol);

    return dwErr;
}

DWORD
CmdWhatIs(
    LPWSTR pwszServerName)
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wszDomDfsName[MAX_PATH+1];
    BOOLEAN IsFtRoot = FALSE;
    DWORD cbName;
    DWORD dwType;
    HKEY hKey = NULL;
    HKEY rKey = NULL;
    ULONG Len;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdWhatIs(%ws)\n", pwszServerName);

    if (pwszServerName != NULL) {
        Len = wcslen(pwszServerName);
        while (pwszServerName[0] == UNICODE_PATH_SEP &&
                pwszServerName[1] == UNICODE_PATH_SEP &&
                    pwszServerName[2] == UNICODE_PATH_SEP &&
                        Len > 3) {
            pwszServerName++;
            Len--;
        }
    }

    //
    // See if this is a Fault-Tolerant Dfs vs Server-Based Dfs
    //

    dwErr = RegConnectRegistry(
                    pwszServerName,
                    HKEY_LOCAL_MACHINE,
                    &rKey);

    if (dwErr != ERROR_SUCCESS) {
        ErrorMessage(MSG_CAN_NOT_CONNECT, pwszServerName);
        goto Cleanup;
    }

    dwErr = RegOpenKey(rKey, VOLUMES_DIR, &hKey);

    if (dwErr == ERROR_SUCCESS) {
        cbName = MAX_PATH;
        dwErr = RegQueryValueEx(
            hKey,
            FTDFS_VALUE_NAME,
            NULL,
            &dwType,
            (PBYTE) wszDomDfsName,
            &cbName);

        if (dwErr == ERROR_MORE_DATA)
            dwErr = ERROR_SUCCESS;

        if (dwErr == ERROR_SUCCESS && dwType == REG_SZ)
            IsFtRoot = TRUE;

    } else {
        MyPrintf(L"Not a Dfs root\r\n");
        goto Cleanup;
    }
    cbName = MAX_PATH;
    dwErr = RegQueryValueEx(
        hKey,
        ROOT_SHARE_VALUE_NAME,
        NULL,
        &dwType,
        (PBYTE) wszRootShare,
        &cbName);

    if (dwErr == ERROR_MORE_DATA)
        dwErr = ERROR_SUCCESS;

    if (dwErr != ERROR_SUCCESS || dwType != REG_SZ) {
        MyPrintf(L"Registry value \"RootShare\" is missing or corrupt.\r\n");
        goto Cleanup;
    }

    if (IsFtRoot == TRUE) {
        MyPrintf(L"Is DomDfs \"%ws\", root share is \"%ws\"\r\n", wszDomDfsName, wszRootShare);
    } else {
        MyPrintf(L"Is StdDfs, root share is \"%ws\"\r\n", wszRootShare);
    }

Cleanup:

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (rKey != NULL)
        RegCloseKey(rKey);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdWhatIs returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdCscOnLine(
    LPWSTR pwszServerName)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    if (fSwDebug)
        MyPrintf(L"CmdCscOnLine(%ws)\r\n", pwszServerName);

    if (pwszServerName == NULL)
        pwszServerName = L"";

    MyPrintf(L"ServerName=[%ws]\r\n", pwszServerName);

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_CSC_SERVER_ONLINE,
                   pwszServerName,
                   wcslen(pwszServerName) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        if (fSwDebug)
            MyPrintf(L"NtFsControlFile returned 0x%x\r\n", NtStatus);
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (fSwDebug && dwErr != ERROR_SUCCESS)
        MyPrintf(L"CmdCscOnLine exit %d\r\n", dwErr);

    return(dwErr);
}

DWORD
CmdCscOffLine(
    LPWSTR pwszServerName)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    if (fSwDebug)
        MyPrintf(L"CmdCscOffLine(%ws)\r\n", pwszServerName);

    if (pwszServerName == NULL)
        pwszServerName = L"";

    MyPrintf(L"ServerName=[%ws]\r\n", pwszServerName);

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_CSC_SERVER_OFFLINE,
                   pwszServerName,
                   wcslen(pwszServerName) * sizeof(WCHAR),
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        if (fSwDebug)
            MyPrintf(L"NtFsControlFile returned 0x%x\r\n", NtStatus);
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (fSwDebug && dwErr != ERROR_SUCCESS)
        MyPrintf(L"CmdCscOffLine exit %d\r\n", dwErr);

    return(dwErr);
}

DWORD
CmdDfsFsctlDfs(
    LPWSTR DriverName,
    DWORD FsctlCmd)
{
    DWORD dwErr = STATUS_SUCCESS;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG Type = 0;

    if (fSwDebug)
        MyPrintf(L"CmdDfsFsctlDfs(0x%x)\r\n", FsctlCmd);

    RtlInitUnicodeString(&DfsDriverName, DriverName);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr = RtlNtStatusToDosError(NtStatus);
        if (fSwDebug)
            MyPrintf(L"NtCreateFile returned 0x%x\r\n", NtStatus);
        goto Cleanup;
    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FsctlCmd,
                   NULL,
                   0,
                   NULL,
                   0);

    NtClose(DriverHandle);

    if (!NT_SUCCESS(NtStatus)) {
        if (fSwDebug)
            MyPrintf(L"NtFsControlFile returned 0x%x\r\n", NtStatus);
    }

    dwErr = RtlNtStatusToDosError(NtStatus);

Cleanup:

    if (fSwDebug && dwErr != ERROR_SUCCESS)
        MyPrintf(L"CmdDfsFsctlDfs exit %d\r\n", dwErr);

    return(dwErr);
}

DWORD
CmdSetOnSite(
    LPWSTR pwszDfsRoot,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    ULONG set)
{

    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR pwszDfsName = NULL;
    LPWSTR pwszShareName = NULL;
    LPWSTR pwszLinkName = NULL;

    WCHAR wszDomDfsName[MAX_PATH+1];
    BOOLEAN IsFtRoot = FALSE;
    DWORD cbName;
    DWORD dwType;
    HKEY hKey = NULL;
    HKEY rKey = NULL;
    BOOLEAN IsDomainName = FALSE;

    dwErr = DfspParseName(pwszDfsRoot, &pwszDfsName, &pwszShareName);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = DfspGetLinkName(pwszDfsRoot, &pwszLinkName);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = DfspIsDomainName(
                pwszDfsName,
                pwszDcName,
                &IsDomainName);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    if (IsDomainName == TRUE) {
      dwErr = DfsSetFtOnSite(pwszDfsName, pwszShareName, pwszLinkName, pwszDcName, pAuthIdent, set);
    } 
    else {
      dwErr = RegConnectRegistry( pwszDfsName, HKEY_LOCAL_MACHINE, &rKey);

      if (dwErr != ERROR_SUCCESS) {
        ErrorMessage(MSG_CAN_NOT_CONNECT, pwszDfsName);
        goto Cleanup;
      }
      dwErr = RegOpenKey(rKey, VOLUMES_DIR, &hKey);

      if (dwErr == ERROR_SUCCESS) {
           cbName = MAX_PATH;
           dwErr = RegQueryValueEx(
                       hKey,
                       FTDFS_VALUE_NAME,
                       NULL,
                       &dwType,
                      (PBYTE) wszDomDfsName,
                      &cbName);

           if (dwErr == ERROR_MORE_DATA)
                 dwErr = ERROR_SUCCESS;

           if (dwErr == ERROR_SUCCESS && dwType == REG_SZ)
                 IsFtRoot = TRUE;

      } else {
           MyPrintf(L"Not a Dfs root\r\n");
           goto Cleanup;
      }

      if (IsFtRoot == TRUE) {
           MyPrintf(L"Not a Std Dfs root\r\n");
           goto Cleanup;
      }

      dwErr = DfsSetOnSite(rKey, pwszLinkName, set);
    }

Cleanup:

    if (pwszDfsName != NULL)
        free(pwszDfsName);
    if (pwszShareName != NULL)
        free(pwszShareName);
    if (pwszLinkName != NULL)
        free(pwszLinkName);

    if (rKey != NULL)
        RegCloseKey(rKey);
    if (hKey != NULL)
        RegCloseKey(hKey);

    return dwErr;
}

DWORD
CmdViewOrVerify(
    LPWSTR pwszServerName,
    LPWSTR pwszDcName,
    LPWSTR pwszDomainName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    LPWSTR pwszHexValue)
{
    ULONG i;
    DWORD dwErr = ERROR_SUCCESS;
    DFS_VOLUME_LIST DfsVolList = { 0 };
    BOOLEAN IsFtRoot = FALSE;
    WCHAR wszDomDfsName[MAX_PATH+1];
    LPWSTR pwszDomDfsName = NULL;
    DWORD cbName;
    DWORD dwType;
    HKEY hKey = NULL;
    HKEY rKey = NULL;
    ULONG Level = 0;

    ErrorMessage(MSG_CONNECTING, pwszServerName);

    if (pwszHexValue != NULL) {
        Level = AtoHex(pwszHexValue, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"Bad Level %ws\r\n", pwszHexValue);
            goto Cleanup;
        }
    }

    //
    // See if this is a Fault-Tolerant Dfs vs Server-Based Dfs
    //

    dwErr = RegConnectRegistry(
                    pwszServerName,
                    HKEY_LOCAL_MACHINE,
                    &rKey);

    if (dwErr != ERROR_SUCCESS) {
        ErrorMessage(MSG_CAN_NOT_CONNECT, pwszServerName);
        goto Cleanup;
    }

    dwErr = RegOpenKey(rKey, VOLUMES_DIR, &hKey);

    if (dwErr == ERROR_SUCCESS) {
        cbName = MAX_PATH;
        dwErr = RegQueryValueEx(
            hKey,
            FTDFS_VALUE_NAME,
            NULL,
            &dwType,
            (PBYTE) wszDomDfsName,
            &cbName);

        if (dwErr == ERROR_MORE_DATA)
            dwErr = ERROR_SUCCESS;

        if (dwErr == ERROR_SUCCESS && dwType == REG_SZ)
            IsFtRoot = TRUE;

    } else {
        MyPrintf(L"Not a Dfs root\r\n");
        goto Cleanup;
    }
        cbName = MAX_PATH;
    dwErr = RegQueryValueEx(
        hKey,
        ROOT_SHARE_VALUE_NAME,
        NULL,
        &dwType,
        (PBYTE) wszRootShare,
        &cbName);

    if (dwErr == ERROR_MORE_DATA)
        dwErr = ERROR_SUCCESS;

    if (dwErr != ERROR_SUCCESS || dwType != REG_SZ) {
        MyPrintf(L"Registry value \"RootShare\" is missing or corrupt.\r\n");
        goto Cleanup;
    }

    if (IsFtRoot == TRUE) {
        if (fSwDebug == TRUE)
            MyPrintf(L"Registry says is DomDfs (%ws)...\r\n", wszDomDfsName);
        if (pwszDomDfsName == NULL) {
            pwszDomDfsName = wszDomDfsName;
        } else {
            if (fSwDebug == TRUE)
                MyPrintf(L"You specified to check against %ws\r\n", pwszDomDfsName);
        }

        dwErr = DfsGetFtVol(
                    &DfsVolList,
                    pwszDomDfsName,
                    pwszDcName,
                    pwszDomainName,
                    pAuthIdent);

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;

        dwErr = GetExitPtInfo(
                    rKey,
                    &DfsVolList.pRootLocalVol,
                    &DfsVolList.cRootLocalVol);

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;

    } else {

        if (fSwDebug == TRUE)
            MyPrintf(L"Is StdDfs...\r\n");

        dwErr = DfsGetStdVol(
                    rKey,
                    &DfsVolList);

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;

        dwErr = GetExitPtInfo(
                    rKey,
                    &DfsVolList.pRootLocalVol,
                    &DfsVolList.cRootLocalVol);

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;
    }

    //
    // Print it all
    //

    if (fSwDebug == TRUE) {
        DfsDumpVolList(&DfsVolList);
        DfsDumpExitPtList(
            DfsVolList.pRootLocalVol,
            DfsVolList.cRootLocalVol);
    }

    if (fArgView == TRUE)
        DfsViewVolList(&DfsVolList, Level);

    //
    // Compare volume info and LocalVolume exitpoint cache
    //

    if (fArgVerify == TRUE)
        DfsCheckVolList(&DfsVolList, Level);

Cleanup:

    //
    // Free volume info
    //
    DfsFreeVolList(&DfsVolList);

    //
    // Free exit pt info
    //
    DfsFreeRootLocalVol(
            DfsVolList.pRootLocalVol,
            DfsVolList.cRootLocalVol);

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (rKey != NULL)
        RegCloseKey(rKey);

    return dwErr;
}

DWORD
CmdSfp(
    LPWSTR pwszServerName,
    BOOLEAN fSwOn, 
    BOOLEAN fSwOff)
{
    DWORD dwErr = ERROR_SUCCESS;
    HKEY rKey = NULL;
    HKEY hKey = NULL;
    ULONG cbSize;
    DWORD dwSFCDisable = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSfp(%ws,ON=%d,OFF=%d)\r\n", 
                    pwszServerName,
                    fSwOn, 
                    fSwOff);

    if (fSwOn == TRUE && fSwOff == TRUE) {
        MyPrintf(L"  ON and OFF at the same time?  Forget it!\r\n");
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    dwErr = RegConnectRegistry(
                    pwszServerName,
                    HKEY_LOCAL_MACHINE,
                    &rKey);

    if (dwErr != ERROR_SUCCESS) {
        ErrorMessage(MSG_CAN_NOT_CONNECT, pwszServerName);
        goto Cleanup;
    }

    dwErr = RegOpenKey(rKey,
                WINLOGON_FOLDER,
                &hKey);

    if (dwErr != ERROR_SUCCESS) {
        ErrorMessage(MSG_CAN_NOT_ACCESS_FOLDER, WINLOGON_FOLDER);
        goto Cleanup;
    }

    if (fSwOn == TRUE || fSwOff == TRUE) {
        dwSFCDisable = fSwOn == TRUE ? 0 : 1;
        dwErr = RegSetValueEx(
                    hKey,
                    L"SFCDisable",
                    NULL,
                    REG_DWORD,
                    (LPBYTE) &dwSFCDisable,
                    sizeof(DWORD));
    }

    cbSize = sizeof(ULONG);

    dwErr = DfsmQueryValue(
                hKey,
                SFCVALUE,
                REG_DWORD,
                sizeof(DWORD),
                (LPBYTE) &dwSFCDisable,
                &cbSize);

    if (dwErr == ERROR_MORE_DATA)
        dwErr = ERROR_SUCCESS;

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"Cannot access the registry value %ws\r\n", SFCVALUE);
        goto Cleanup;
    }

    MyPrintf(L"SFP = 0x%x (%ws)\r\n",
        dwSFCDisable,
        dwSFCDisable == 0 ? L"ON" : L"OFF");

Cleanup:

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (rKey != NULL)
        RegCloseKey(rKey);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSfp returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdRegistry(
    LPWSTR pwszServerName,
    LPWSTR pwszFolderName,
    LPWSTR pwszValueName,
    LPWSTR pwszHexValue)
{
    DWORD dwErr = ERROR_SUCCESS;
    HKEY rKey = NULL;
    HKEY hKey = NULL;
    ULONG cbSize;
    DWORD dwValue = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdRegistry(%ws,%ws)\r\n",
                    pwszServerName,
                    pwszHexValue);

    dwErr = RegConnectRegistry(
                    pwszServerName,
                    HKEY_LOCAL_MACHINE,
                    &rKey);

    if (dwErr != ERROR_SUCCESS) {
        ErrorMessage(MSG_CAN_NOT_CONNECT, pwszServerName);
        goto Cleanup;
    }

    dwErr = RegOpenKey(
                rKey,
                pwszFolderName,
                &hKey);

    if (dwErr != ERROR_SUCCESS) {
        ErrorMessage(MSG_CAN_NOT_ACCESS_FOLDER, pwszFolderName);
        goto Cleanup;
    }

    if (pwszHexValue != NULL) {
        if (pwszHexValue[0] == L'0' && (pwszHexValue[1] == L'x' || pwszHexValue[1] == L'X'))
            dwValue = AtoHex(pwszHexValue, &dwErr);
        else 
            dwValue = AtoDec(pwszHexValue, &dwErr);
        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"bad value %ws\r\n", pwszHexValue);
            goto Cleanup;
        }
        dwErr = RegSetValueEx(
                    hKey,
                    pwszValueName,
                    NULL,
                    REG_DWORD,
                    (LPBYTE) &dwValue,
                    sizeof(DWORD));
    }

    cbSize = sizeof(ULONG);

    dwErr = DfsmQueryValue(
                hKey,
                pwszValueName,
                REG_DWORD,
                sizeof(DWORD),
                (LPBYTE) &dwValue,
                &cbSize);

    if (dwErr == ERROR_MORE_DATA)
        dwErr = ERROR_SUCCESS;

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"Cannot access registry value %ws\r\n", pwszValueName);
        goto Cleanup;
    }

    MyPrintf(L"%ws = 0x%x (%d)\r\n",
        pwszValueName,
        dwValue,
        dwValue);

Cleanup:

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (rKey != NULL)
        RegCloseKey(rKey);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdRegistry returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdTrusts(
    LPWSTR pwszDomainName,
    LPWSTR pwszDcName,
    PSEC_WINNT_AUTH_IDENTITY pAuthIdent,
    BOOLEAN fListAll)
{
    PDS_DOMAIN_TRUSTS pDsDomainTrusts = NULL;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    ULONG DsDomainCount = 0;
    DWORD dwErr = ERROR_SUCCESS;
    ULONG Count = 1;
    ULONG i;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdTrusts(%ws,%ws)\r\n", pwszDomainName, pwszDcName);

    if (pwszDcName == NULL) {
        dwErr = DsGetDcName(
                    NULL,                            // Computer to remote to
                    pwszDomainName,                  // Domain
                    NULL,                            // Domain Guid
                    NULL,                            // Site Guid
                    DS_FORCE_REDISCOVERY,
                    &pDcInfo);
        if (dwErr != ERROR_SUCCESS) {
            if (fSwDebug == TRUE)
                MyPrintf(L"DsGetDcName() returned %d\r\n", dwErr);
            goto Cleanup;
         }
         pwszDcName = &pDcInfo->DomainControllerName[2];
         ErrorMessage(MSG_CONNECTING, pwszDcName);
    }

    dwErr = DsEnumerateDomainTrusts(
                pwszDcName,
                DS_DOMAIN_VALID_FLAGS,
                &pDsDomainTrusts,
                &DsDomainCount);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"DsEnumerateDomainTrusts() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    for (i = 0; i < DsDomainCount; i++) {
        if (pDsDomainTrusts[i].TrustType == TRUST_TYPE_UPLEVEL || fListAll == TRUE) {
            MyPrintf(L"%d:\r\n", Count++);
            MyPrintf(L"    NetbiosDomainName %ws\r\n", pDsDomainTrusts[i].NetbiosDomainName);
            MyPrintf(L"    DnsDomainName %ws\r\n", pDsDomainTrusts[i].DnsDomainName);
            MyPrintf(L"    Flags 0x%x\r\n", pDsDomainTrusts[i].Flags);
            MyPrintf(L"    ParentIndex %d\r\n", pDsDomainTrusts[i].ParentIndex);
            MyPrintf(L"    TrustType 0x%x\r\n", pDsDomainTrusts[i].TrustType);
            MyPrintf(L"    TrustAttributes 0x%x\r\n", pDsDomainTrusts[i].TrustAttributes);
        }
    }

Cleanup:

    if (pDsDomainTrusts != NULL)
        NetApiBufferFree(pDsDomainTrusts);

    if (pDcInfo != NULL)
        NetApiBufferFree(pDcInfo);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdTrusts returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdSiteInfo(
    LPWSTR pwszMachineName)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPDFS_SITELIST_INFO pSiteInfo = NULL;
    ULONG i;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSiteInfo(%ws)\r\n", pwszMachineName);

    if (pwszMachineName == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    dwErr = I_NetDfsManagerReportSiteInfo(
                pwszMachineName,
                &pSiteInfo);

    if (dwErr != ERROR_SUCCESS || pSiteInfo == NULL)
        goto Cleanup;

    MyPrintf(L"%ws:\r\n", &pwszMachineName[2]);
    for (i = 0; i < pSiteInfo->cSites; i++) {
        MyPrintf(L"    %ws\r\n",
                pSiteInfo->Site[i].SiteName);
    }

Cleanup:

    if (pSiteInfo != NULL)
        NetApiBufferFree(pSiteInfo);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSiteInfo returning %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdAddRoot(
    LPWSTR pwszDomDfsName,
    LPWSTR pwszServerName,
    LPWSTR pwszShareName,
    LPWSTR pwszComment)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdAddRoot(%ws,%ws,%ws,%ws)\r\n",
                            pwszDomDfsName,
                            pwszServerName,
                            pwszShareName,
                            pwszComment);

    if (pwszDomDfsName != NULL)
        while (*pwszDomDfsName == UNICODE_PATH_SEP)
            pwszDomDfsName++;

    if (pwszDomDfsName == NULL || wcslen(pwszDomDfsName) == 0) {
        dwErr = NetDfsAddStdRoot(
                    pwszServerName,
                    pwszShareName,
                    pwszComment,
                    0);
    } else {
        dwErr = NetDfsAddFtRoot(
                    pwszServerName,
                    pwszShareName,
                    pwszDomDfsName,
                    pwszComment,
                    0);

    }
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdAddRoot returning %d\r\n", dwErr);
    return dwErr;
}

DWORD
CmdRemRoot(
    LPWSTR pwszDomDfsName,
    LPWSTR pwszServerName,
    LPWSTR pwszShareName)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdRemRoot(%ws,%ws,%ws)\r\n",
                            pwszDomDfsName,
                            pwszServerName,
                            pwszShareName);

    if (pwszDomDfsName != NULL)
        while (*pwszDomDfsName == UNICODE_PATH_SEP)
            pwszDomDfsName++;

    if (pwszDomDfsName == NULL || wcslen(pwszDomDfsName) == 0) {
        dwErr = NetDfsRemoveStdRoot(
                    pwszServerName,
                    pwszShareName,
                    0);
    } else {
        dwErr = NetDfsRemoveFtRoot(
                    pwszServerName,
                    pwszShareName,
                    pwszDomDfsName,
                    0);

    }
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdRemRoot returning %d\r\n", dwErr);
    return dwErr;
}


DWORD
DfspIsDomainName(
    LPWSTR pwszDomainName,
    LPWSTR pwszDcName,
    PBOOLEAN pIsDomainName)
{
    PDS_DOMAIN_TRUSTS pDsDomainTrusts = NULL;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    ULONG DsDomainCount = 0;
    DWORD dwErr = ERROR_SUCCESS;
    ULONG i;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspIsDomainName(%ws,%ws)\r\n", pwszDomainName, pwszDcName);

    if (pwszDcName == NULL) {
        dwErr = DsGetDcName(
                    NULL,                            // Computer to remote to
                    NULL,                            // Domain
                    NULL,                            // Domain Guid
                    NULL,                            // Site Guid
                    DS_FORCE_REDISCOVERY,
                    &pDcInfo);
        if (dwErr != ERROR_SUCCESS) {
            if (fSwDebug == TRUE)
                MyPrintf(L"DsGetDcName() returned %d\r\n", dwErr);
            goto Cleanup;
         }
         pwszDcName = &pDcInfo->DomainControllerName[2];
    }

    dwErr = DsEnumerateDomainTrusts(
                pwszDcName,
                DS_DOMAIN_VALID_FLAGS,
                &pDsDomainTrusts,
                &DsDomainCount);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"DsEnumerateDomainTrusts() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    *pIsDomainName = FALSE;

    for (i = 0; i < DsDomainCount; i++) {
        if (
            (pDsDomainTrusts[i].NetbiosDomainName != NULL && 
            _wcsicmp(pwszDomainName, pDsDomainTrusts[i].NetbiosDomainName) == 0)
                ||
            (pDsDomainTrusts[i].DnsDomainName != NULL &&
            _wcsicmp(pwszDomainName, pDsDomainTrusts[i].DnsDomainName) == 0)
        ) {
            *pIsDomainName = TRUE;
            goto Cleanup;
        }
    }

Cleanup:

    if (pDsDomainTrusts != NULL)
        NetApiBufferFree(pDsDomainTrusts);

    if (pDcInfo != NULL)
        NetApiBufferFree(pDcInfo);

    if (fSwDebug == TRUE)
        MyPrintf(
            L"DfspIsDomainName returning %d (%s)\r\n",
            dwErr, *pIsDomainName == TRUE ? "T" : "F");

    if (dwErr == ERROR_NO_SUCH_DOMAIN)
    {
        *pIsDomainName = FALSE;
        dwErr = ERROR_SUCCESS;
    }

    return dwErr;
}

DWORD
DfspParseName(
    LPWSTR pwszDfsRoot,
    LPWSTR *ppwszDfsName,
    LPWSTR *ppwszShareName)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR pwszDfsName = NULL;
    LPWSTR pwszShareName = NULL;
    WCHAR *wCp1 = NULL;
    WCHAR *wCp2 = NULL;
    ULONG Len = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspParseName(%ws)\r\n", pwszDfsRoot);

    wCp1 = pwszDfsRoot;

    while (*wCp1 == UNICODE_PATH_SEP && *wCp1 != UNICODE_NULL)
        wCp1++;

    if (*wCp1 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    wCp2 = wCp1;
    while (*wCp2 != UNICODE_PATH_SEP && *wCp2 != UNICODE_NULL)
        wCp2++;

    if (*wCp2 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    Len = (ULONG)((wCp2 - wCp1) * sizeof(WCHAR));
    pwszDfsName = (LPWSTR)malloc(Len + sizeof(WCHAR));
    if (pwszDfsName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pwszDfsName,Len+sizeof(WCHAR));
    RtlCopyMemory(pwszDfsName, wCp1, Len);

    wCp1 = wCp2;

    while (*wCp1 == UNICODE_PATH_SEP && *wCp1 != UNICODE_NULL)
        wCp1++;

    if (*wCp1 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    wCp2 = wCp1;
    while (*wCp2 != UNICODE_PATH_SEP && *wCp2 != UNICODE_NULL)
        wCp2++;

    Len = (ULONG)((wCp2 - wCp1) * sizeof(WCHAR));
    pwszShareName = (LPWSTR)malloc(Len + sizeof(WCHAR));
    if (pwszShareName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pwszShareName,Len+sizeof(WCHAR));
    RtlCopyMemory(pwszShareName, wCp1, Len);

    *ppwszDfsName = pwszDfsName;
    *ppwszShareName = pwszShareName;

Cleanup:

    if (dwErr != ERROR_SUCCESS) {
        if (pwszDfsName != NULL)
            free(pwszDfsName);
        if (pwszShareName != NULL)
            free(pwszShareName);
    }

    if (fSwDebug == TRUE)
        MyPrintf(L"DfspParseName returning %d\r\n", dwErr);

    return dwErr;
}


DWORD
DfspGetLinkName(
    LPWSTR pwszDfsRoot,
    LPWSTR *ppwszLinkName)
{
    WCHAR *wCp1 = NULL;
    WCHAR *wCp2 = NULL;
    ULONG Len = 0;
    DWORD dwErr = ERROR_SUCCESS;
 
    wCp1 = pwszDfsRoot;

    while (*wCp1 == UNICODE_PATH_SEP && *wCp1 != UNICODE_NULL)
        wCp1++;
    if (*wCp1 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    while (*wCp1 != UNICODE_PATH_SEP && *wCp1 != UNICODE_NULL)
       wCp1++;

    if (*wCp1 == UNICODE_NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    *ppwszLinkName = ++wCp1;

 Cleanup:
    return dwErr;
}

VOID
MyFormatMessageText(
    HRESULT   dwMsgId,
    PWSTR     pszBuffer,
    DWORD     dwBufferSize,
    va_list   *parglist)
{
    DWORD dwReturn = FormatMessage(
                            (dwMsgId >= MSG_FIRST_MESSAGE)
                                    ? FORMAT_MESSAGE_FROM_HMODULE
                                    : FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (dwReturn == 0)
        MyPrintf(L"Formatmessage failed 0x%x\r\n", GetLastError());
}

VOID
ErrorMessage(
    IN HRESULT hr,
    ...)
{
    ULONG cch;
    va_list arglist;

    va_start(arglist, hr);
    MyFormatMessageText(hr, MsgBuf, ARRAYLEN(MsgBuf), &arglist);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, cch, &cch, NULL);
    va_end(arglist);
}

VOID
MyPrintf(
    PWCHAR format,
    ...)
{
    ULONG cch;
    va_list va;

    va_start(va, format);
    wvsprintf(MsgBuf, format, va);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, cch, &cch, NULL);
    va_end(va);
    return;
}

VOID
MyFPrintf(
    HANDLE hHandle,
    PWCHAR format,
    ...)
{
    ULONG cch;
    va_list va;

    va_start(va, format);
    wvsprintf(MsgBuf, format, va);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(hHandle, AnsiBuf, cch, &cch, NULL);
    va_end(va);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\dfsutil\stdsup.cxx ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 1999, Microsoft Corporation
//
//  File:       stdsup.cxx
//
//--------------------------------------------------------------------------

#define UNICODE

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dfsstr.h>
#include <dfsmrshl.h>
#include <marshal.hxx>
#include <lmdfs.h>
#include <dfspriv.h>
#include <csites.hxx>
#include <dfsm.hxx>
#include <recon.hxx>

#include <rpc.h>

#include "struct.hxx"
#include "rootsup.hxx"
#include "dfsacl.hxx"
#include "misc.hxx"
#include "messages.h"

#include "struct.hxx"
#include "ftsup.hxx"
#include "stdsup.hxx"

DWORD
PutSiteTable(
    HKEY hKey, 
    PDFS_VOLUME_LIST pDfsVolList);

DWORD
DfsRecoverVolList(
    PDFS_VOLUME_LIST pDfsVolList);

DWORD
DfsRegDeleteKeyAndChildren(
    HKEY hkey,
    LPWSTR s);

DWORD
DfsGetStdVol(
    HKEY rKey,
    PDFS_VOLUME_LIST pDfsVolList)
{

    HKEY hKey = NULL;
    DWORD dwErr;
    LPWSTR *pNames = NULL;
    ULONG cKeys = 0;
    ULONG i;
    WCHAR VolumesDir[MAX_PATH+1];

    wcscpy(VolumesDir, VOLUMES_DIR);
    wcscat(VolumesDir, L"domainroot");

    dwErr = RegOpenKey(
                rKey,
                VolumesDir,
                &hKey);

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"Not a StdDfs root!\r\n");
        goto Cleanup;
    }

    dwErr = EnumKeys(
                hKey,
                &cKeys,
                &pNames);

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"No exit points...\r\n");
        goto SiteInfo;
    }

    pDfsVolList->Version = 3;
    pDfsVolList->VolCount = cKeys+1;
    pDfsVolList->Volumes = (PDFS_VOLUME *)malloc((cKeys+1) * sizeof(PDFS_VOLUME));

    if (pDfsVolList->Volumes == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    pDfsVolList->AllocatedVolCount = cKeys + 1;
    RtlZeroMemory(pDfsVolList->Volumes, pDfsVolList->AllocatedVolCount * sizeof(PDFS_VOLUME));

    pDfsVolList->Volumes[0] = (PDFS_VOLUME) malloc(sizeof(DFS_VOLUME));
    if (pDfsVolList->Volumes[0] == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(pDfsVolList->Volumes[0], sizeof(DFS_VOLUME));
    dwErr = GetDfsKey(
                rKey,
                L"domainroot",
                pDfsVolList->Volumes[0]);

    for (i = 0; i < cKeys; i++) {
        wcscpy(VolumesDir, L"domainroot\\");
        wcscat(VolumesDir, pNames[i]);
        pDfsVolList->Volumes[i+1] = (PDFS_VOLUME) malloc(sizeof(DFS_VOLUME));
        if (pDfsVolList->Volumes[i+1] == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
        RtlZeroMemory(pDfsVolList->Volumes[i+1], sizeof(DFS_VOLUME));
        dwErr = GetDfsKey(
                    rKey,
                    VolumesDir,
                    pDfsVolList->Volumes[i+1]);
    }

    //
    // Do any recovery needed
    //

    dwErr = DfsRecoverVolList(pDfsVolList);

    RegCloseKey(hKey);
    hKey = NULL;

    pDfsVolList->DfsType = STDDFS;

SiteInfo:

    //
    // Site information
    //
    wcscpy(VolumesDir, VOLUMES_DIR);
    wcscat(VolumesDir, L"siteroot");

    dwErr = RegOpenKey(
                rKey,
                VolumesDir,
                &hKey);

    if (dwErr != ERROR_SUCCESS) {
        dwErr = ERROR_SUCCESS;
        goto Cleanup;
    }

    dwErr = GetSiteTable(
                    hKey,
                    pDfsVolList);

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"Missing siteroot key (non-fatal error)\r\n");    
        dwErr = ERROR_SUCCESS;
    }


Cleanup:

    FreeNameList(
         pNames,
         cKeys);

    pNames = NULL;

    if (hKey != NULL)
        RegCloseKey(hKey);

    return dwErr;

}

DWORD
GetDfsKey(
    HKEY rKey,
    LPWSTR wszKeyName,
    PDFS_VOLUME pVolume)
{
    DWORD dwErr = 0;
    HKEY hKey = NULL;
    ULONG cRepl;
    WCHAR VolumesDir[MAX_PATH+1];

    wcscpy(VolumesDir, VOLUMES_DIR);
    wcscat(VolumesDir, wszKeyName);

    if (fSwDebug == TRUE)
        MyPrintf(L"GetDfsKey(%ws)\r\n", VolumesDir);

    dwErr = RegOpenKey(
                rKey,
                VolumesDir,
                &hKey);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"RegOpenKey(%ws) returned %d\r\n", VolumesDir, dwErr);
        goto Cleanup;
    }

    //
    // Id (Prefix, Type, state, etc)
    //

    wcscpy(VolumesDir, L"\\");
    wcscat(VolumesDir, wszKeyName);

    GIP_DUPLICATE_STRING(dwErr, VolumesDir, &pVolume->wszObjectName);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"DUP_STRING(%ws) returned %d\r\n", VolumesDir, dwErr);
        goto Cleanup;
    }

    dwErr = GetIdProps(
                hKey,
                &pVolume->dwType,
                &pVolume->dwState,
                &pVolume->wszPrefix,
                &pVolume->wszShortPrefix,
                &pVolume->idVolume,
                &pVolume->wszComment,
                &pVolume->dwTimeout,
                &pVolume->ftPrefix,
                &pVolume->ftState,
                &pVolume->ftComment);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"GetIdProps() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    //
    // Services (replicas)
    //

    dwErr = GetSvcProps(
                hKey,
                pVolume);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"GetSvcProps() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    dwErr = GetVersionProps(
                hKey,
                VERSION_PROPS,
                &pVolume->dwVersion);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"GetVersionProps() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    dwErr = GetRecoveryProps(
                hKey,
                RECOVERY_PROPS,
                &pVolume->cbRecovery,
                &pVolume->pRecovery);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"GetRecoveryProps() returned %d\r\n", dwErr);
        goto Cleanup;
    }

Cleanup:

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (fSwDebug == TRUE)
        MyPrintf(L"GetDfsKey exit %d\r\n", dwErr);

    return( dwErr );

}

DWORD
ReadSiteTable(PBYTE pBuffer, ULONG cbBuffer)
{
    DWORD dwErr;
    ULONG cObjects = 0;
    ULONG cbThisObj;
    ULONG i;
    ULONG j;
    PLIST_ENTRY pListHead, pLink;
    PDFSM_SITE_ENTRY pSiteInfo;
    MARSHAL_BUFFER marshalBuffer;
    GUID guid;
    ULONG Size;

    dwErr = ERROR_SUCCESS;

    if (dwErr == ERROR_SUCCESS && cbBuffer >= sizeof(ULONG)) {

        //
        // Unmarshall all the objects (NET_DFS_SITENAME_INFO's) in the buffer
        //

        MarshalBufferInitialize(
          &marshalBuffer,
          cbBuffer,
          pBuffer);

        DfsRtlGetGuid(&marshalBuffer, &guid);
        DfsRtlGetUlong(&marshalBuffer, &cObjects);

        for (j = 0; j < cObjects; j++) {

            pSiteInfo = (PDFSM_SITE_ENTRY) new BYTE [cbBuffer-sizeof(ULONG)];
            if (pSiteInfo == NULL) {
                dwErr = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            dwErr = DfsRtlGet(&marshalBuffer,&MiDfsmSiteEntry, pSiteInfo);
            Size = (ULONG)((PCHAR)&pSiteInfo->Info.Site[pSiteInfo->Info.cSites] - (PCHAR)pSiteInfo);

        }

    }

Cleanup:

    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetIdProps
//
//  Synopsis:   Retrieves the Id Properties of a Dfs Manager volume object.
//
//  Arguments:
//
//  Returns:    [S_OK] -- Successfully retrieved the properties.
//
//              [DFS_E_VOLUME_OBJECT_CORRUPT] -- The stored properties could
//                      not be parsed properly.
//
//              [DFS_E_INCONSISTENT] -- Another volume object seems to have
//                      the same prefix!
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate memory for properties
//                      or other uses.
//
//              DWORD from DfsmQueryValue
//
//-----------------------------------------------------------------------------

DWORD
GetIdProps(
    HKEY hKey,
    PULONG pdwType,
    PULONG pdwState,
    LPWSTR *ppwszPrefix,
    LPWSTR *ppwszShortPath,
    GUID   *pidVolume,
    LPWSTR  *ppwszComment,
    PULONG pdwTimeout,
    FILETIME *pftPrefix,
    FILETIME *pftState,
    FILETIME *pftComment)
{
    DWORD dwErr;
    NTSTATUS status;
    DWORD dwType;
    DWORD cbBuffer;
    ULONG dwTimeout;
    PBYTE pBuffer = NULL;
    MARSHAL_BUFFER marshalBuffer;
    DFS_ID_PROPS idProps;

    if (fSwDebug == TRUE)
        MyPrintf(L"GetIdProps()\r\n");

    *ppwszPrefix = NULL;
    *ppwszComment = NULL;

    dwErr = GetBlobByValue(
                hKey,
                ID_PROPS,
                &pBuffer,
                &cbBuffer);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    MarshalBufferInitialize(&marshalBuffer, cbBuffer, pBuffer);

    status = DfsRtlGet(&marshalBuffer, &MiDfsIdProps, &idProps);

    if (NT_SUCCESS(status)) {

        GIP_DUPLICATE_PREFIX( dwErr, idProps.wszPrefix, ppwszPrefix );

        if (dwErr == ERROR_SUCCESS) {

            GIP_DUPLICATE_PREFIX(
                dwErr,
                idProps.wszShortPath,
                ppwszShortPath );

        }

        if (dwErr == ERROR_SUCCESS) {

            GIP_DUPLICATE_STRING(
                dwErr,
                idProps.wszComment,
                ppwszComment);

        }
        
        //
        // There are two possible versions of the blob.  One has the timeout
        // after all the other stuff, the other doesn't.
        // So, if there are sizeof(ULONG) bytes left in the blob,
        // assume it is the timeout.  Otherwise this is an old
        // version of the blob, and the timeout isn't here, so we set it to
        // the global value.

        idProps.dwTimeout = GTimeout;

        if (
            (marshalBuffer.Current < marshalBuffer.Last)
                &&
            (marshalBuffer.Last - marshalBuffer.Current) == sizeof(ULONG)
        ) {

            DfsRtlGetUlong(&marshalBuffer, &idProps.dwTimeout);

        }

        if (dwErr == ERROR_SUCCESS) {

            *pdwType = idProps.dwType;
            *pdwState = idProps.dwState;
            *pidVolume = idProps.idVolume;
            *pdwTimeout = idProps.dwTimeout;
            *pftPrefix = idProps.ftEntryPath;
            *pftState = idProps.ftState;
            *pftComment = idProps.ftComment;

        }

        if (dwErr != ERROR_SUCCESS) {

            if (*ppwszPrefix != NULL) {
                delete [] *ppwszPrefix;
                *ppwszPrefix = NULL;
            }

            if (*ppwszShortPath != NULL) {
                delete [] *ppwszShortPath;
                *ppwszShortPath = NULL;
            }

            if (*ppwszComment != NULL) {
                delete [] *ppwszComment;
                *ppwszComment = NULL;
            }

        }

        if (idProps.wszPrefix != NULL)
            MarshalBufferFree(idProps.wszPrefix);

        if (idProps.wszShortPath != NULL)
            MarshalBufferFree(idProps.wszShortPath);

        if (idProps.wszComment != NULL)
            MarshalBufferFree(idProps.wszComment);

    } else {

        if (status == STATUS_INSUFFICIENT_RESOURCES) {

            dwErr = ERROR_OUTOFMEMORY;

        } else {

            dwErr = NERR_DfsInternalCorruption;

        }

    }

Cleanup:

    if (pBuffer != NULL)
        delete [] pBuffer;

    if (fSwDebug == TRUE)
        MyPrintf(L"GetIdProps exit %d\r\n", dwErr);

    return( dwErr );
}

DWORD
DfsSetStdVol(
    HKEY rKey,
    PDFS_VOLUME_LIST pDfsVolList)
{

    HKEY hKey = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwErr2 = ERROR_SUCCESS;
    ULONG i;
    PDFS_VOLUME pVol;
    PWCHAR wCp;
    WCHAR FolderDir[MAX_PATH+1];

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsSetStdVol()\r\n");

    wcscpy(FolderDir, VOLUMES_DIR);
    wcscat(FolderDir, L"domainroot");

    dwErr = RegOpenKey(
                rKey,
                FolderDir,
                &hKey);

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"Not a StdDfs root!\r\n");
        goto Cleanup;
    }

    //
    // Loop through all the dfs links and if the modify bit is set, 
    // create an entry in the registry.  If the delete bit is set,
    // delete the entry.
    //
    // On error we continue, but capture the error which will
    // later be returned.
    //

    for (i = 1; i < pDfsVolList->VolCount; i++) {
        pVol = pDfsVolList->Volumes[i];
        if ((pVol->vFlags & VFLAGS_DELETE) != 0) {
            for (wCp = &pVol->wszObjectName[1]; *wCp != NULL && *wCp != UNICODE_PATH_SEP; wCp++)
                NOTHING;
            wCp++;
            dwErr = RegDeleteKey(hKey, wCp);
        } else if ((pVol->vFlags & VFLAGS_MODIFY) != 0) {
            dwErr = SetDfsKey(hKey, pVol->wszObjectName, pVol);
        } else {
            dwErr = ERROR_SUCCESS;
        }
        if (dwErr != ERROR_SUCCESS)
            dwErr2 = dwErr;
    }

    RegCloseKey(hKey);
    hKey = NULL;

    //
    // Write site table only if it has changed
    //
    if ((pDfsVolList->sFlags & VFLAGS_MODIFY) != 0 || pDfsVolList->SiteCount > 0) {
        wcscpy(FolderDir, VOLUMES_DIR);
        wcscat(FolderDir, L"siteroot");

        dwErr = RegOpenKey(
                    rKey,
                    FolderDir,
                    &hKey);

        if (dwErr != ERROR_SUCCESS) {
            MyPrintf(L"Can not open siteroot\r\n");
            goto Cleanup;
        }
        dwErr2 = PutSiteTable(hKey, pDfsVolList);
    }

Cleanup:

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (fSwDebug == TRUE)
        MyPrintf(L"DfsSetStdVol() exit %d\r\n", dwErr2);

    return dwErr2;

}

DWORD
SetDfsKey(
    HKEY rKey,
    LPWSTR wszKeyName,
    PDFS_VOLUME pVolume)
{
    DWORD dwErr = ERROR_SUCCESS;
    HKEY hKey = NULL;
    PWCHAR wCp;

    if (fSwDebug == TRUE)
        MyPrintf(L"SetDfsKey(%ws)\r\n", wszKeyName);

    for (wCp = &wszKeyName[1]; *wCp != NULL && *wCp != UNICODE_PATH_SEP; wCp++)
        NOTHING;

    if (*wCp != UNICODE_PATH_SEP) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    wCp++;
    dwErr = RegCreateKey(
                rKey,
                wCp,
                &hKey);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"RegCreateKey(%ws) returned %d\r\n", wCp, dwErr);
        goto Cleanup;
    }

    dwErr = SetIdProps(
                hKey,
                pVolume->dwType,
                pVolume->dwState,
                pVolume->wszPrefix,
                pVolume->wszShortPrefix,
                pVolume->idVolume,
                pVolume->wszComment,
                pVolume->dwTimeout,
                pVolume->ftPrefix,
                pVolume->ftState,
                pVolume->ftComment);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"SetIdProps() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    //
    // Services (replicas)
    //

    dwErr = SetSvcProps(
                hKey,
                pVolume);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"SetSvcProps() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    dwErr = SetVersionProps(
                hKey,
                pVolume);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"SetVersionProps() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    dwErr = SetRecoveryProps(
                hKey,
                pVolume);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"SetRecoveryProps() returned %d\r\n", dwErr);
        goto Cleanup;
    }

Cleanup:

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (fSwDebug == TRUE)
        MyPrintf(L"SetDfsKey exit %d\r\n", dwErr);

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   SetIdProps
//
//  Synopsis:   Sets the Id Properties of a Dfs Manager volume object.
//
//  Arguments:
//
//  Returns:    [S_OK] -- Successfully retrieved the properties.
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate memory for properties
//                      or other uses.
//
//-----------------------------------------------------------------------------

DWORD
SetIdProps(
    HKEY hKey,
    ULONG dwType,
    ULONG dwState,
    LPWSTR pwszPrefix,
    LPWSTR pwszShortPath,
    GUID   idVolume,
    LPWSTR  pwszComment,
    ULONG dwTimeout,
    FILETIME ftPrefix,
    FILETIME ftState,
    FILETIME ftComment)
{

    // prefix bug 447510; initialize dwerr
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS status;
    DWORD cbBuffer;
    PBYTE pBuffer = NULL;
    MARSHAL_BUFFER marshalBuffer;
    DFS_ID_PROPS idProps;

    idProps.wszPrefix = wcschr( &pwszPrefix[1], UNICODE_PATH_SEP );
    idProps.wszShortPath = wcschr( &pwszShortPath[1], UNICODE_PATH_SEP );
    idProps.idVolume = idVolume;
    idProps.dwState = dwState;
    idProps.dwType = dwType;
    idProps.wszComment = pwszComment;
    idProps.dwTimeout = dwTimeout;
    idProps.ftEntryPath = ftPrefix;
    idProps.ftState = ftState;
    idProps.ftComment = ftComment;

    cbBuffer = 0;
    status = DfsRtlSize( &MiDfsIdProps, &idProps, &cbBuffer );
    if (NT_SUCCESS(status)) {
        //
        // Add extra bytes for the timeout, which will go at the end
        //
        cbBuffer += sizeof(ULONG);
        pBuffer = new BYTE [cbBuffer];
        if (pBuffer != NULL) {
            MarshalBufferInitialize( &marshalBuffer, cbBuffer, pBuffer);
            status = DfsRtlPut( &marshalBuffer, &MiDfsIdProps, &idProps );
            DfsRtlPutUlong(&marshalBuffer, &dwTimeout);
            if (NT_SUCCESS(status)) {
                dwErr = SetBlobByValue(
                    hKey,
                    ID_PROPS,
                    pBuffer,
                    cbBuffer);
            }
        }
    }

    if (pBuffer != NULL)
        delete [] pBuffer;

    return( dwErr );
}

DWORD
SetSvcProps(
    HKEY hKey,
    PDFS_VOLUME pVol)
{
    DWORD cbBuffer;
    DWORD dwErr = ERROR_SUCCESS;
    PBYTE Buffer = NULL;
    PBYTE pBuf = NULL;
    ULONG *Size = NULL;
    ULONG *pSize = NULL;
    ULONG TotalSize = 0;
    ULONG i;

    if (fSwDebug == TRUE)
        MyPrintf(L"SetSvcProps(%ws)\r\n", pVol->wszObjectName);

    pSize = Size = (PULONG) malloc(sizeof(ULONG) * (pVol->ReplCount + pVol->DelReplCount));
    if (Size == NULL) {
        dwErr =  ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Need all the size values now and later for marshalling stuff.
    // So we collect them here into an array.
    //
    TotalSize = 0;
    for (i = 0; i < pVol->ReplCount; i++) {
        *pSize = GetReplicaMarshalSize(&pVol->ReplicaInfo[i], &pVol->FtModification[i]);
        TotalSize += *pSize;
        pSize++;
    }
    for (i = 0; i < pVol->DelReplCount; i++) {
        *pSize = GetReplicaMarshalSize(&pVol->DelReplicaInfo[i], &pVol->DelFtModification[i]);
        TotalSize += *pSize;
        pSize++;
    }

    //
    // Allocate the byte Buffer we need
    //
    // TotalSize is the size required marshal all the replicas and
    // their last-modification-timestamps.
    //
    // In addition, we need:
    //
    //  1 ULONG for storing the count of replicas
    //  ReplCount ULONGs for storing the marshal size of each replica.
    //

    TotalSize += sizeof(ULONG) * (1 + pVol->ReplCount + 1 + pVol->DelReplCount);
    Buffer = pBuf = (PBYTE) malloc(TotalSize);
    if (Buffer == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Set the number of entries to follow in the Buffer at the start.
    //
    _PutULong(pBuf, pVol->ReplCount);
    pBuf += sizeof(ULONG);
    pSize = Size;
    for (i = 0; i < pVol->ReplCount; i++) {
        //
        // Marshall each replica Entry into the Buffer.
        // Remember we first need to put the size of the marshalled
        // replica entry to follow, then the FILETIME for the replica,
        // and finally, the marshalled replica entry structure.
        //
        _PutULong(pBuf, *pSize);
        pBuf += sizeof(ULONG);
        dwErr = SerializeReplica(
                    &pVol->ReplicaInfo[i],
                    pVol->FtModification ? &pVol->FtModification[i] : NULL,
                    pBuf,
                    *pSize);
        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;
        pBuf += *pSize;
        pSize++;
    }
    //
    // Now the deleted replicas
    //
    _PutULong(pBuf, pVol->DelReplCount);
    pBuf += sizeof(ULONG);
    for (i = 0; i < pVol->DelReplCount; i++) {
        _PutULong(pBuf, *pSize);
        pBuf += sizeof(ULONG);
        dwErr = SerializeReplica(
                    &pVol->DelReplicaInfo[i],
                    pVol->DelFtModification ? &pVol->DelFtModification[i] : NULL,
                    pBuf,
                    *pSize);
        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;
        pBuf += *pSize;
        pSize++;
    }
    dwErr = SetBlobByValue(
                hKey,
                SVC_PROPS,
                Buffer,
                TotalSize);

Cleanup:

    if (Buffer != NULL)
        delete [] Buffer;

    if (Size != NULL)
        delete [] Size;

    if (fSwDebug == TRUE)
        MyPrintf(L"SetSvcProps exit %d\n", dwErr);
    
    return dwErr;
}

DWORD
SetVersionProps(
    HKEY hKey,
    PDFS_VOLUME pVol)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (fSwDebug == TRUE)
        MyPrintf(L"SetVersionProps(%ws)\r\n", pVol->wszObjectName);

    dwErr = RegSetValueEx(
                hKey,
                VERSION_PROPS,
                NULL,
                REG_DWORD,
                (LPBYTE) &pVol->dwVersion,
                sizeof(DWORD));

    if (fSwDebug == TRUE)
        MyPrintf(L"SetVersionProps exit %d\n", dwErr);

    return dwErr;
}

DWORD
SetRecoveryProps(
    HKEY hKey,
    PDFS_VOLUME pVol)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwRecovery = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"SetRecoveryProps(%ws)\r\n", pVol->wszObjectName);

    dwErr = RegSetValueEx(
                hKey,
                RECOVERY_PROPS,
                NULL,
                REG_BINARY,
                (LPBYTE) &dwRecovery,
                sizeof(DWORD));

    if (fSwDebug == TRUE)
        MyPrintf(L"SetRecoveryProps exit %d\n", dwErr);

    return dwErr;
}

DWORD
PutSiteTable(
    HKEY hKey, 
    PDFS_VOLUME_LIST pDfsVolList)
{   
    DWORD dwErr;
    DWORD cbBuffer;
    PBYTE pBuffer = NULL;
    ULONG cObjects;
    ULONG i;
    PLIST_ENTRY pListHead, pLink;
    PDFSM_SITE_ENTRY pSiteInfo;
    MARSHAL_BUFFER marshalBuffer;
    GUID SiteTableGuid = {0};

    if (fSwDebug == TRUE)
        MyPrintf(L"PutSiteTable()\n");

    //
    // Create a new Guid
    //


    dwErr = UuidCreate(&SiteTableGuid);

    if(dwErr != RPC_S_OK){
        // couldn't create a valid uuid
        goto Cleanup;
    }

    //
    // The cObjects count
    //
    cbBuffer = sizeof(ULONG) + sizeof(GUID);

    //
    // Add up the number of entries we need to store, and the total size of all
    // of them.
    //
    cObjects = 0;
    pListHead = &pDfsVolList->SiteList;
    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSiteInfo = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
        DfsRtlSize(&MiDfsmSiteEntry, pSiteInfo, &cbBuffer);
        cObjects++;
    }

    //
    // Get a buffer big enough
    //
    pBuffer = (PBYTE) malloc(cbBuffer);
    if (pBuffer == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Put the guid, then the object count in the beginning of the buffer
    //
    MarshalBufferInitialize(
          &marshalBuffer,
          cbBuffer,
          pBuffer);

    DfsRtlPutGuid(&marshalBuffer, &SiteTableGuid);
    DfsRtlPutUlong(&marshalBuffer, &cObjects);

    //
    // Walk the linked list of objects, marshalling them into the buffer.
    //
    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSiteInfo = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
        DfsRtlPut(&marshalBuffer,&MiDfsmSiteEntry, pSiteInfo);
    }

    //
    // Write the site table binary blob
    //
    dwErr = RegSetValueEx(
                hKey,
                SITE_VALUE_NAME,
                NULL,
                REG_BINARY,
                pBuffer,
                cbBuffer);

Cleanup:
    if (pBuffer)
        free(pBuffer);

    if (fSwDebug == TRUE)
        MyPrintf(L"PutSiteTable exit %d\n", dwErr);

    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsmQueryValue
//
//  Synopsis:   Helper function that calls RegQueryValueEx and verifies that
//              the returned type is equal to the expected type.
//
//  Arguments:  [hkey] -- Handle to key
//              [wszValueName] -- Name of value to read
//              [dwExpectedType] -- Expected type of value
//              [dwExpectedSize] -- Expected size of read in value. If
//                      this is nonzero, this routine will return an error
//                      if the read-in size is not equal to expected size.
//                      If this is 0, no checking is performed.
//              [pBuffer] -- To receive the value data
//              [pcbBuffer] -- On call, size of pBuffer. On successful return,
//                      the size of data read in
//
//  Returns:    [ERROR_SUCCESS] -- Successfully read the value data.
//
//              [DFS_E_VOLUME_OBJECT_CORRUPT] -- If read-in type did not
//                      match dwExpectedType, or if dwExpectedSize was
//                      nonzero and the read-in size did not match it.
//
//              DWORD_FROM_WIN32 of RegQueryValueEx return code.
//
//-----------------------------------------------------------------------------

DWORD
DfsmQueryValue(
    HKEY hkey,
    LPWSTR wszValueName,
    DWORD dwExpectedType,
    DWORD dwExpectedSize,
    PBYTE pBuffer,
    LPDWORD pcbBuffer)
{
    DWORD dwErr;
    DWORD dwType;

    dwErr = RegQueryValueEx(
                hkey,
                wszValueName,
                NULL,
                &dwType,
                pBuffer,
                pcbBuffer);

    if (dwErr == ERROR_SUCCESS) {

        if (dwExpectedType != dwType) {

            dwErr = NERR_DfsInternalCorruption;

        } else if (dwExpectedSize != 0 && dwExpectedSize != *pcbBuffer) {

            dwErr = NERR_DfsInternalCorruption;

        } else {

            dwErr = ERROR_SUCCESS;

        }

    }

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   GetBlobByValue
//
//  Synopsis:   Retrieves a property of type Binary from the value wszProperty
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
GetBlobByValue(
    HKEY hKey,
    LPWSTR wszProperty,
    PBYTE  *ppBuffer,
    PULONG pcbBuffer)
{
    DWORD dwErr;
    DWORD dwUnused;

    dwErr = RegQueryInfoKey(
                hKey,                            // Key
                NULL,                            // Class string
                NULL,                            // Size of class string
                NULL,                            // Reserved
                &dwUnused,                       // # of subkeys
                &dwUnused,                       // max size of subkey name
                &dwUnused,                       // max size of class name
                &dwUnused,                       // # of values
                &dwUnused,                       // max size of value name
                pcbBuffer,                       // max size of value data,
                NULL,                            // security descriptor
                NULL);                           // Last write time

    if (dwErr == ERROR_SUCCESS) {

        *ppBuffer = new BYTE [*pcbBuffer];

        if (*ppBuffer != NULL) {

            dwErr = DfsmQueryValue(
                        hKey,
                        wszProperty,
                        REG_BINARY,
                        0,
                        *ppBuffer,
                        pcbBuffer);

            if (dwErr) {

                delete [] *ppBuffer;
                *ppBuffer = NULL;
                *pcbBuffer = 0;

            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    }

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   SetBlobByValue
//
//  Synopsis:   Saves a property of type Binary for the value wszProperty
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
SetBlobByValue(
    HKEY hKey,
    LPWSTR wszProperty,
    PBYTE  pBuffer,
    ULONG  cbBuffer)
{
    DWORD dwErr;
    DWORD dwUnused;
    DWORD unused;
    dwErr = RegQueryInfoKey(
                hKey,                            // Key
                NULL,                            // Class string
                NULL,                            // Size of class string
                NULL,                            // Reserved
                &dwUnused,                       // # of subkeys
                &dwUnused,                       // max size of subkey name
                &dwUnused,                       // max size of class name
                &dwUnused,                       // # of values
                &dwUnused,                       // max size of value name
                &unused,                         // max size of value data,
                NULL,                            // security descriptor
                NULL);                           // Last write time

    if (dwErr == ERROR_SUCCESS) {
            dwErr = RegSetValueEx(
                        hKey,
                        wszProperty,
                        NULL,
                        REG_BINARY,
                        pBuffer,
                        cbBuffer);
	    
    } else {
      dwErr = ERROR_OUTOFMEMORY;
    }

    return( dwErr );

}

DWORD
GetSvcProps(
    HKEY hKey,
    PDFS_VOLUME pVol)
{
    DWORD cbBuffer;
    DWORD dwErr;
    PBYTE Buffer = NULL;
    PBYTE pBuf = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"GetSvcProps(%ws)\r\n", pVol->wszObjectName);

    dwErr = GetBlobByValue(
                hKey,
                SVC_PROPS,
                &Buffer,
                &cbBuffer);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    pBuf = Buffer;
    dwErr = UnSerializeReplicaList(
                &pVol->ReplCount,
                &pVol->AllocatedReplCount,
                &pVol->ReplicaInfo,
                &pVol->FtModification,
                &pBuf);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Get deleted replicas
    //

    if (pBuf < (pBuf + cbBuffer)) {
        dwErr = UnSerializeReplicaList(
                    &pVol->DelReplCount,
                    &pVol->AllocatedDelReplCount,
                    &pVol->DelReplicaInfo,
                    &pVol->DelFtModification,
                    &pBuf);
    }

Cleanup:

    if (Buffer != NULL)
        delete [] Buffer;

    if (fSwDebug == TRUE)
        MyPrintf(L"GetSvcProps exit %d\n", dwErr);
    
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetVersionProps
//
//  Synopsis:   Retrieves the version property set of a Dfs Manager volume
//              object.
//
//  Returns:    [S_OK] -- If successful.
//
//              DWORD from DfsmQueryValue
//
//-----------------------------------------------------------------------------

DWORD
GetVersionProps(
    HKEY hKey,
    LPWSTR wszProperty,
    PULONG pVersion)
{
    DWORD dwErr;
    DWORD cbSize;

    cbSize = sizeof(ULONG);

    dwErr = DfsmQueryValue(
                hKey,
                wszProperty,
                REG_DWORD,
                sizeof(DWORD),
                (LPBYTE) pVersion,
                &cbSize);

    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetRecoveryProps
//
//  Synopsis:   Retrieves the recovery properties of a Dfs Manager volume
//              object.
//
//  Arguments:  [ppRecovery] -- On successful return, points to a buffer
//                      allocated to hold the recovery property.
//              [pcbRecovery] -- On successful return, size in bytes of
//                      recovery buffer.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
GetRecoveryProps(
    HKEY hKey,
    LPWSTR wszProperty,
    PULONG pcbRecovery,
    PBYTE *ppRecovery)
{
    DWORD dwErr;

    dwErr = GetBlobByValue(
                hKey,
                wszProperty,
                ppRecovery,
                pcbRecovery);

    return dwErr;
}

DWORD
EnumKeys(
    HKEY hKey,
    PULONG pcKeys,
    LPWSTR **ppNames)
{
    //  figure out how many keys are currently stored in this key
    //  and allocate a buffer to hold the return results.

    LPWSTR *pNames = NULL;
    WCHAR   wszClass[MAX_PATH+1];
    ULONG   cbClass = sizeof(wszClass);
    ULONG   cSubKeys, cbMaxSubKeyLen, cbMaxClassLen;
    ULONG   cValues, cbMaxValueIDLen, cbMaxValueLen;
    SECURITY_DESCRIPTOR SecDescriptor;
    FILETIME ft;
    DWORD  dwErr = ERROR_SUCCESS;
    DWORD   dwIndex=0;

    dwErr = RegQueryInfoKey(
                     hKey,
                     wszClass,
                     &cbClass,
                     NULL,
                     &cSubKeys,
                     &cbMaxSubKeyLen,
                     &cbMaxClassLen,
                     &cValues,
                     &cbMaxValueIDLen,
                     &cbMaxValueLen,
                     (DWORD *)&SecDescriptor,
                     &ft);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    pNames = new LPWSTR [cSubKeys];

    if (pNames == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pNames, cSubKeys * sizeof(LPWSTR));

    //  loop enumerating and adding names

    for (dwIndex = 0; dwIndex < cSubKeys && dwErr == ERROR_SUCCESS; dwIndex++) {

        WCHAR   wszKeyName[MAX_PATH];
        ULONG   cbKeyName = sizeof(wszKeyName)/sizeof(WCHAR);
        WCHAR   wszClass[MAX_PATH];
        ULONG   cbClass = sizeof(wszClass)/sizeof(WCHAR);
        FILETIME ft;

        dwErr = RegEnumKeyEx(
                    hKey,           //  handle
                    dwIndex,        //  index
                    wszKeyName,     //  key name
                    &cbKeyName,     //  length of key name
                    NULL,           //  title index
                    wszClass,       //  class
                    &cbClass,       //  length of class
                    &ft);           //  last write time

        if (dwErr == ERROR_SUCCESS) {

            GIP_DUPLICATE_STRING(
                dwErr,
                wszKeyName,
                &pNames[dwIndex]);
           
        }

    };


    //  finished the enumeration, check the results
    if (dwErr == ERROR_NO_MORE_ITEMS || dwErr == ERROR_SUCCESS) {
        *pcKeys = dwIndex;
        *ppNames = pNames;
    } else {
        //  Cleanup and return an error
        while (dwIndex) {
            delete pNames[--dwIndex];
        }
        delete [] pNames;
    }

Cleanup:

    return(dwErr);
}

DWORD
GetSiteTable(
    HKEY hKey,
    PDFS_VOLUME_LIST pDfsVolList)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    ULONG cSite;
    PDFSM_SITE_ENTRY pSiteEntry;
    PDFSM_SITE_ENTRY pTmpSiteEntry;
    MARSHAL_BUFFER marshalBuffer;
    ULONG Size;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    PBYTE pObjectData = NULL;
    ULONG cbObjectData;
    PBYTE pBuffer = NULL;
    ULONG cbBuffer;
    ULONG i;
 
    if (fSwDebug == TRUE)
        MyPrintf(L"GetSiteTable()\r\n");

    dwErr = GetBlobByValue(
                hKey,
                L"SiteTable",
                &pObjectData,
                &cbObjectData);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Unserialize the buffer
    //

    InitializeListHead(&pDfsVolList->SiteList);

    MarshalBufferInitialize(
      &marshalBuffer,
      cbObjectData,
      pObjectData);

    NtStatus = DfsRtlGetGuid(&marshalBuffer, &pDfsVolList->SiteGuid);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr =  RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    NtStatus = DfsRtlGetUlong(&marshalBuffer, &pDfsVolList->SiteCount);

    if (!NT_SUCCESS(NtStatus)) {
        dwErr =  RtlNtStatusToDosError(NtStatus);
        goto Cleanup;
    }

    pBuffer = (BYTE *)malloc(cbObjectData);

    if (pBuffer == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    pTmpSiteEntry = (PDFSM_SITE_ENTRY)pBuffer;

    for (cSite = 0; cSite < pDfsVolList->SiteCount; cSite++) {

        RtlZeroMemory(pBuffer, cbObjectData);

        NtStatus = DfsRtlGet(
                        &marshalBuffer,
                        &MiDfsmSiteEntry,
                        pBuffer);

        if (!NT_SUCCESS(NtStatus)) {
            dwErr =  RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }

        Size = sizeof(DFSM_SITE_ENTRY) + (pTmpSiteEntry->Info.cSites * sizeof(DFS_SITENAME_INFO));

        pSiteEntry = (PDFSM_SITE_ENTRY) malloc(Size);

        if (pSiteEntry == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }

        RtlCopyMemory(pSiteEntry, pBuffer, Size);
        InsertHeadList(&pDfsVolList->SiteList, &pSiteEntry->Link);

    }

Cleanup:

    if (pBuffer != NULL)
        delete [] pBuffer;

    return dwErr;
}

//+------------------------------------------------------------------------
//
// Function:    DfsCheckVolList
//
// Synopsis:    Prints the volume information represented by the volume
//              list passed in.
//
// Returns:     [ERROR_SUCCESS] -- If all went well.
//
// History:     11/19/98 JHarper Created
//
//-------------------------------------------------------------------------

VOID
DfsCheckVolList(
    PDFS_VOLUME_LIST pDfsVolList,
    ULONG Level)
{
    ULONG cVol;
    ULONG cRepl;
    ULONG cExit;
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    PDFSM_SITE_ENTRY pSiteEntry;
    PDFS_ROOTLOCALVOL pRootLocalVol = pDfsVolList->pRootLocalVol;
    BOOLEAN SvcOk = FALSE;
    BOOLEAN IdOk = FALSE;
    BOOLEAN VerOk = FALSE;
    BOOLEAN RecOk = FALSE;
    BOOLEAN Ok1 = FALSE;
    BOOLEAN Ok2 = FALSE;

    MyPrintf(L"(metadata)..\r\n");

    for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {

        IdOk = SvcOk = VerOk = RecOk = TRUE;

        if (
            pDfsVolList->Volumes[cVol]->wszPrefix == NULL
                ||
            pDfsVolList->Volumes[cVol]->wszShortPrefix == NULL
                ||
            pDfsVolList->Volumes[cVol]->dwTimeout <= 0
                ||
            pDfsVolList->Volumes[cVol]->dwState == 0
        ) {
            IdOk = FALSE;
        }

        if (pDfsVolList->Volumes[cVol]->ReplCount == 0)
            SvcOk = FALSE;

        if (pDfsVolList->Volumes[cVol]->dwVersion == 0)
            VerOk = FALSE;

        for (cRepl = 0; cRepl < pDfsVolList->Volumes[cVol]->ReplCount; cRepl++) {

            if (
                pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].pwszServerName == NULL
                    ||
                pDfsVolList->Volumes[cVol]->ReplicaInfo[cRepl].pwszShareName == NULL
            ) {
                SvcOk = FALSE;
            }

        }

        for (cRepl = 0; cRepl < pDfsVolList->Volumes[cVol]->DelReplCount; cRepl++) {

            if (
                pDfsVolList->Volumes[cVol]->DelReplicaInfo[cRepl].pwszServerName == NULL
                    ||
                pDfsVolList->Volumes[cVol]->DelReplicaInfo[cRepl].pwszShareName == NULL
            ) {
                SvcOk = FALSE;
            }

        }

        if (IdOk != TRUE || SvcOk != TRUE) {
            MyPrintf(L"%ws: Bad or Missing values: %ws %ws %ws %ws\r\n",
                    pDfsVolList->Volumes[cVol]->wszObjectName,
                    IdOk == TRUE ? L"" : L"ID",
                    SvcOk == TRUE ? L"" : L"Svc",
                    VerOk == TRUE ? L"" : L"Version",
                    RecOk == TRUE ? L"" : L"Recovery");
        }
    }

    if (Level > 0) {
        //
        // Verify that all the vols have exit points
        //

        MyPrintf(L"(volumes have exit points)..\r\n");

        Ok1 = Ok2 = FALSE;

        for (cVol = 1; cVol < pDfsVolList->VolCount; cVol++) {
            Ok1 = FALSE;
            if (fSwDebug == TRUE) {
                MyPrintf(L"++++ [%ws]\r\n", pDfsVolList->Volumes[cVol]->wszObjectName);
                MyPrintf(L"     %d ExitPts:", pRootLocalVol[0].cLocalVolCount);
            }
            for (cExit = 0; cExit < pRootLocalVol[0].cLocalVolCount; cExit++) {
                if (fSwDebug == TRUE)
                    MyPrintf(L"%d ", cExit);
                if (
                    (pDfsVolList->Volumes[cVol]->wszObjectName != NULL &&
                            pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName != NULL)
                        &&
                    (pDfsVolList->Volumes[cVol]->wszObjectName[12] ==
                            pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName[0])
                        &&
                    wcscmp(
                        &pDfsVolList->Volumes[cVol]->wszObjectName[12],
                        pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName) == 0
                ) {
                    Ok1 = TRUE;
                    break;
                }
            }
            if (fSwDebug == TRUE)
                MyPrintf(L"\r\n", cExit);

            if (Ok1 != TRUE && wcslen(&pDfsVolList->Volumes[cVol]->wszObjectName[12]) > 0) {
                MyPrintf(L"Missing [%ws] in LocalVolumes\r\n",
                            &pDfsVolList->Volumes[cVol]->wszObjectName[12]);
            }
        }

        //
        // Verify that all the exit points have vols
        //

        MyPrintf(L"(exit points have volumes)..\r\n");

        Ok1 = Ok2 = FALSE;

        for (cExit = 0; cExit < pRootLocalVol[0].cLocalVolCount; cExit++) {
            Ok1 = FALSE;
            if (fSwDebug == TRUE) {
                MyPrintf(L"---- [%ws]\r\n", pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName);
                MyPrintf(L"     %d Vols:", pDfsVolList->VolCount);
            }
            for (cVol = 1; cVol < pDfsVolList->VolCount; cVol++) {
                if (fSwDebug == TRUE)
                    MyPrintf(L"%d ", cVol);
                if (
                    (pDfsVolList->Volumes[cVol]->wszObjectName != NULL &&
                            pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName != NULL)
                        &&
                    (pDfsVolList->Volumes[cVol]->wszObjectName[12] ==
                            pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName[0])
                        &&
                    wcscmp(
                        &pDfsVolList->Volumes[cVol]->wszObjectName[12],
                        pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName) == 0
                ) {
                    Ok1 = TRUE;
                    break;
                }
            }
            if (fSwDebug == TRUE)
                MyPrintf(L"\r\n", cVol);

            if (Ok1 != TRUE) {
                MyPrintf(L"Extra ExitPt [%ws] in LocalVolumes\r\n",
                    pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName);
            }
        }
    }

    MyPrintf(L"(exit point internal consistency)...\r\n");

    Ok1 = Ok2 = FALSE;

    for (cVol = 0; cVol < pDfsVolList->VolCount; cVol++) {
        Ok1 = FALSE;
        for (cExit = 0; cExit < pRootLocalVol[0].cLocalVolCount; cExit++) {
            if (
                (pDfsVolList->Volumes[cVol]->wszObjectName != NULL &&
                        pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName != NULL)
                    &&
                (pDfsVolList->Volumes[cVol]->wszObjectName[12] ==
                        pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName[0])
                    &&
                wcscmp(
                    &pDfsVolList->Volumes[cVol]->wszObjectName[12],
                    pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName) == 0
            ) {
                Ok1 = TRUE;
                break;
            }
        }

        if (Ok1 == TRUE && wcslen(&pDfsVolList->Volumes[cVol]->wszObjectName[12]) > 0) {
            PWCHAR wCp1 = &pDfsVolList->Volumes[cVol]->wszPrefix[1];
            PWCHAR wCp2 = &pRootLocalVol[0].pDfsLocalVol[cExit].wszEntryPath[1];
            while (*wCp1 != L'\\')
                wCp1++;
            while (*wCp2 != L'\\')
                wCp2++;
            if (_wcsicmp(wCp1,wCp2) != 0) {
                MyPrintf(L"Mismatch in ExitPt in [%ws]\r\n",
                        pRootLocalVol[0].pDfsLocalVol[cExit].wszObjectName);
                MyPrintf(L"    [%ws] vs [%ws]\r\n",
                        pDfsVolList->Volumes[cVol]->wszPrefix,
                        pRootLocalVol[0].pDfsLocalVol[cExit].wszEntryPath);
            }
        }
    }
}

DWORD
GetExitPtInfo(
    HKEY rKey,
    PDFS_ROOTLOCALVOL *ppRootLocalVol,
    PULONG pcVolCount)
{
    HKEY hKey = NULL;
    HKEY hKeyExPt = NULL;
    LPWSTR *pNames = NULL;
    ULONG dwErr;
    ULONG cKeys;
    ULONG i;
    PDFS_ROOTLOCALVOL pRootLocalVol;
    DWORD cbBuffer;
    DWORD cbSize;
    DWORD dwType;
    WCHAR wszBuffer[MAX_PATH+1];

    if (fSwDebug == TRUE)
        MyPrintf(L"GetExitPtInfo()\r\n");

    dwErr = RegOpenKey(
                rKey,
                REG_KEY_LOCAL_VOLUMES,
                &hKey);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    dwErr = EnumKeys(
                hKey,
                &cKeys,
                &pNames);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    pRootLocalVol = (PDFS_ROOTLOCALVOL)malloc(sizeof(DFS_ROOTLOCALVOL) * cKeys);

    if (pRootLocalVol == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pRootLocalVol, sizeof(DFS_ROOTLOCALVOL) * cKeys);

    for (i = 0; i < cKeys; i++) {

        if (fSwDebug == TRUE)
            MyPrintf(L"RegOpenKey(%ws)\r\n", pNames[i]);

        dwErr = RegOpenKey(
                    hKey,
                    pNames[i],
                    &hKeyExPt);

        if (dwErr != ERROR_SUCCESS)
            continue;

        GIP_DUPLICATE_STRING(dwErr, pNames[i], &pRootLocalVol[i].wszObjectName);

        cbSize = sizeof(ULONG);

        dwErr = DfsmQueryValue(
                    hKeyExPt,
                    REG_VALUE_ENTRY_TYPE,
                    REG_DWORD,
                    sizeof(DWORD),
                    (LPBYTE) &pRootLocalVol[i].dwEntryType,
                    &cbSize);

        cbBuffer = sizeof(wszBuffer);
        dwErr = RegQueryValueEx(
                    hKeyExPt,
                    REG_VALUE_ENTRY_PATH,       // "EntryPath"
                    NULL,
                    &dwType,
                    (LPBYTE) wszBuffer,
                    &cbBuffer);

        if (dwErr == ERROR_MORE_DATA)
            dwErr = ERROR_SUCCESS;

        if (dwErr == ERROR_SUCCESS)
            GIP_DUPLICATE_STRING(dwErr, wszBuffer, &pRootLocalVol[i].wszEntryPath);

        cbBuffer = sizeof(wszBuffer);
        dwErr = RegQueryValueEx(
                    hKeyExPt,
                    REG_VALUE_SHARE_NAME,       // "ShareName"
                    NULL,
                    &dwType,
                    (LPBYTE) wszBuffer,
                    &cbBuffer);

        if (dwErr == ERROR_MORE_DATA)
            dwErr = ERROR_SUCCESS;

        if (dwErr == ERROR_SUCCESS)
            GIP_DUPLICATE_STRING(dwErr, wszBuffer, &pRootLocalVol[i].wszShareName);

        cbBuffer = sizeof(wszBuffer);
        dwErr = RegQueryValueEx(
                    hKeyExPt,
                    REG_VALUE_SHORT_PATH,       // "ShortEntryPath"
                    NULL,
                    &dwType,
                    (LPBYTE) wszBuffer,
                    &cbBuffer);

        if (dwErr == ERROR_SUCCESS)
            GIP_DUPLICATE_STRING(dwErr, wszBuffer, &pRootLocalVol[i].wszShortEntryPath);

        cbBuffer = sizeof(wszBuffer);
        dwErr = RegQueryValueEx(
                    hKeyExPt,
                    REG_VALUE_STORAGE_ID,       // "StorageId"
                    NULL,
                    &dwType,
                    (LPBYTE) wszBuffer,
                    &cbBuffer);

        if (dwErr == ERROR_MORE_DATA)
            dwErr = ERROR_SUCCESS;

        if (dwErr == ERROR_SUCCESS)
            GIP_DUPLICATE_STRING(dwErr, wszBuffer, &pRootLocalVol[i].wszStorageId);

        dwErr = GetExitPts(
                    hKeyExPt,
                    &pRootLocalVol[i]);

        RegCloseKey(hKeyExPt);
    }

    FreeNameList(
        pNames,
        cKeys);

    pNames = NULL;

    *ppRootLocalVol = pRootLocalVol;
    *pcVolCount = cKeys;

Cleanup:

    FreeNameList(
        pNames,
        cKeys);

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (fSwDebug == TRUE)
        MyPrintf(L"GetExitPtInfo returning %d\r\n", dwErr);

    return dwErr;
}

VOID
FreeNameList(
    LPWSTR *pNames,
    ULONG cNames)
{
    ULONG i;

    if (pNames != NULL) {
        for (i = 0; i < cNames; i++) {
            if (pNames[i] != NULL)
                delete [] pNames[i];
        }
        delete [] pNames;
    }
}

DWORD
GetExitPts(
    HKEY hKey,
    PDFS_ROOTLOCALVOL pRootLocalVol)
{
    ULONG cNames = 0;
    LPWSTR *pNames = NULL;
    ULONG cKeys = 0;
    ULONG dwErr = ERROR_SUCCESS;
    ULONG i;
    DWORD dwType = 0;
    DWORD cbBuffer = 0;
    DWORD cbSize = 0;
    HKEY hKeyExPt = NULL;
    WCHAR wszBuffer[MAX_PATH+1];

    dwErr = EnumKeys(
                hKey,
                &cKeys,
                &pNames);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    pRootLocalVol->pDfsLocalVol = (PDFS_LOCALVOLUME)malloc(sizeof(DFS_LOCALVOLUME) * cKeys);

    if (pRootLocalVol->pDfsLocalVol == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(pRootLocalVol->pDfsLocalVol, sizeof(DFS_LOCALVOLUME) * cKeys);
    pRootLocalVol->cLocalVolCount = cKeys;

    for (i = 0; i < cKeys; i++) {

        if (fSwDebug == TRUE)
            MyPrintf(L"   GetExitPts(%ws)\r\n", pNames[i]);

        //
        // Get EntryPath
        //
        dwErr = RegOpenKey(
                    hKey,
                    pNames[i],
                    &hKeyExPt);

        if (dwErr != ERROR_SUCCESS) {
            if (fSwDebug == TRUE)
                MyPrintf(L"RegOpenKey returned %d\r\n", dwErr);
            continue;
        }

        GIP_DUPLICATE_STRING(dwErr, pNames[i], &pRootLocalVol->pDfsLocalVol[i].wszObjectName);

        cbBuffer = sizeof(wszBuffer);
        dwErr = RegQueryValueEx(
                    hKeyExPt,
                    REG_VALUE_ENTRY_PATH,       // "EntryPath"
                    NULL,
                    &dwType,
                    (LPBYTE) wszBuffer,
                    &cbBuffer);

        if (dwErr == ERROR_MORE_DATA)
            dwErr = ERROR_SUCCESS;

        if (dwErr != ERROR_SUCCESS && fSwDebug == TRUE)
            MyPrintf(L"RegQueryValueEx returned %d\r\n", dwErr);

        if (dwErr == ERROR_SUCCESS)
            GIP_DUPLICATE_STRING(dwErr, wszBuffer, &pRootLocalVol->pDfsLocalVol[i].wszEntryPath);

        RegCloseKey(hKeyExPt);
    }

Cleanup:

    FreeNameList(
        pNames,
        cKeys);

    return dwErr;
}

DWORD
DfsSetOnSite(
    HKEY rKey,
    LPWSTR wszKeyName, 
    ULONG set)
{
    HKEY hKey = NULL;
    DWORD dwErr;
    LPWSTR *pNames = NULL;
    ULONG cKeys = 0;
    ULONG i;
    WCHAR VolumesDir[MAX_PATH+1];

    wcscpy(VolumesDir, VOLUMES_DIR);
    wcscat(VolumesDir, L"domainroot");

    dwErr = RegOpenKey(
                rKey,
                VolumesDir,
                &hKey);

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"Not a StdDfs root!\r\n");
        goto Cleanup;
    }

    dwErr = EnumKeys(
                hKey,
                &cKeys,
                &pNames);

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"No exit points...\r\n");
        goto Cleanup;
    }

    dwErr = SetSiteInfoOnKey(
                rKey,
                L"domainroot",
                wszKeyName,
                set);

    for (i = 0; i < cKeys && dwErr != ERROR_SUCCESS && dwErr != ERROR_REQUEST_ABORTED && dwErr != ERROR_PATH_NOT_FOUND; i++) {
        wcscpy(VolumesDir, L"domainroot\\");
        wcscat(VolumesDir, pNames[i]);
        dwErr = SetSiteInfoOnKey(
                    rKey,
                    VolumesDir, wszKeyName, set);
    }

    if (dwErr == ERROR_PATH_NOT_FOUND)
      ErrorMessage(MSG_LINK_NOT_FOUND, wszKeyName);

Cleanup:

    if (pNames != NULL)
        FreeNameList(
             pNames,
             cKeys);

    if (hKey != NULL)
        RegCloseKey(hKey);

    return dwErr;
}

DWORD
SetSiteInfoOnKey(
    HKEY rKey,
    LPWSTR wszKeyName,
    LPWSTR wszPrefixMatch,
    ULONG Set)
{
    DWORD dwErr = 0;
    HKEY hKey = NULL;
    ULONG cRepl;
    WCHAR VolumesDir[MAX_PATH+1];
    DFS_VOLUME Volume;
    PDFS_VOLUME pVolume = &Volume;
    wcscpy(VolumesDir, VOLUMES_DIR);
    wcscat(VolumesDir, wszKeyName);
    LPWSTR usePrefix;

    if (fSwDebug == TRUE)
        MyPrintf(L"SetSiteInfoOnKey(%ws)\r\n", VolumesDir);

    dwErr = RegOpenKey(
                rKey,
                VolumesDir,
                &hKey);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"RegOpenKey(%ws) returned %d\r\n", VolumesDir, dwErr);
        goto Cleanup;
    }

    //
    // Id (Prefix, Type, state, etc)
    //

    dwErr = GetIdProps(
                hKey,
                &pVolume->dwType,
                &pVolume->dwState,
                &pVolume->wszPrefix,
                &pVolume->wszShortPrefix,
                &pVolume->idVolume,
                &pVolume->wszComment,
                &pVolume->dwTimeout,
                &pVolume->ftPrefix,
                &pVolume->ftState,
                &pVolume->ftComment);

    if (dwErr != ERROR_SUCCESS) {
        if (fSwDebug == TRUE)
            MyPrintf(L"GetIdProps() returned %d\r\n", dwErr);
        goto Cleanup;
    }

    usePrefix = pVolume->wszPrefix;

    DfspGetLinkName(usePrefix, &usePrefix);

    if (fSwDebug) {
      MyPrintf(L"prefix (%ws, %ws), keyname (%ws)\r\n", 
	       usePrefix,
	       pVolume->wszShortPrefix,
	       wszPrefixMatch);
    }

    if (_wcsicmp(usePrefix, wszPrefixMatch) == 0) {
        dwErr = ERROR_SUCCESS;
        if (fSwDebug) {
            MyPrintf(L"Match found prefix (%ws, %ws), keyname (%ws)\r\n", 
                usePrefix,
                pVolume->wszShortPrefix,
                wszPrefixMatch);
        }
        if (Set) {
            if (pVolume->dwType & PKT_ENTRY_TYPE_INSITE_ONLY) {
                ErrorMessage(MSG_SITE_INFO_ALREADY_SET, 
                    pVolume->wszPrefix);
                dwErr = ERROR_REQUEST_ABORTED;
            }
            else {
                ErrorMessage(MSG_SITE_INFO_NOW_SET, 
                    pVolume->wszPrefix);
                pVolume->dwType |= PKT_ENTRY_TYPE_INSITE_ONLY;
            }
        }
        else {
            if (pVolume->dwType & PKT_ENTRY_TYPE_INSITE_ONLY) {
                ErrorMessage(MSG_SITE_INFO_NOW_SET, 
                pVolume->wszPrefix);
                pVolume->dwType &= ~PKT_ENTRY_TYPE_INSITE_ONLY;
            }
            else {
                ErrorMessage(MSG_SITE_INFO_ALREADY_SET, 
                pVolume->wszPrefix);
                dwErr = ERROR_REQUEST_ABORTED;
            }
        }
        if (dwErr == ERROR_SUCCESS) {
                dwErr = SetIdProps(
                hKey,
                pVolume->dwType,
                pVolume->dwState,
                pVolume->wszPrefix,
                pVolume->wszShortPrefix,
                pVolume->idVolume,
                pVolume->wszComment,
                pVolume->dwTimeout,
                pVolume->ftPrefix,
                pVolume->ftState,
                pVolume->ftComment);

            if (dwErr != ERROR_SUCCESS) {
                if (fSwDebug == TRUE)
                    MyPrintf(L"SetIdProps() returned %d\r\n", dwErr);
                goto Cleanup;
            }
        }
    }
    else {
        dwErr = ERROR_PATH_NOT_FOUND;
    }

Cleanup:

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (fSwDebug == TRUE)
        MyPrintf(L"SetSiteInfoOnKey exit %d\r\n", dwErr);

    return( dwErr );

}

DWORD
CmdStdUnmap(
    LPWSTR pwszServerName)
{
    DWORD dwErr = ERROR_SUCCESS;
    HKEY rKey = NULL;
    HKEY hKey = NULL;

    if (fSwDebug != 0)
        MyPrintf(L"CmdStdUnmap(%ws)\r\n", pwszServerName);

    dwErr = RegConnectRegistry(
                    pwszServerName,
                    HKEY_LOCAL_MACHINE,
                    &rKey);

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"Can not open registry of %ws (error %d)\r\n", pwszServerName, dwErr);
        goto Cleanup;
    }

    //
    // Remove VOLUMES_DIR and children
    //
    dwErr = DfsRegDeleteKeyAndChildren(rKey, DFSHOST_DIR);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // New remove all local vol information
    //
    dwErr = DfsRegDeleteKeyAndChildren(rKey, REG_KEY_LOCAL_VOLUMES);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

Cleanup:

    RegCreateKey(rKey, REG_KEY_LOCAL_VOLUMES, &hKey);
    RegCreateKey(rKey, DFSHOST_DIR, &hKey);


    if (rKey != NULL)
        RegCloseKey(rKey);

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (fSwDebug != 0)
        MyPrintf(L"CmdStdUnmap exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdClean(
    LPWSTR pwszServerName)
{
    DWORD dwErr = ERROR_SUCCESS;
    HKEY rKey = NULL;
    HKEY hKey = NULL;

    if (fSwDebug != 0)
        MyPrintf(L"CmdClean(%ws)\r\n", pwszServerName);

    dwErr = RegConnectRegistry(
                    pwszServerName,
                    HKEY_LOCAL_MACHINE,
                    &rKey);

    if (dwErr != ERROR_SUCCESS) {
        MyPrintf(L"Can not open registry of %ws (error %d)\r\n", pwszServerName, dwErr);
        goto Cleanup;
    }

    //
    // Remove VOLUMES_DIR and children
    //
    dwErr = DfsRegDeleteKeyAndChildren(rKey, DFSHOST_DIR);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    //
    // New remove all local vol information
    //
    dwErr = DfsRegDeleteKeyAndChildren(rKey, REG_KEY_LOCAL_VOLUMES);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

Cleanup:

    RegCreateKey(rKey, REG_KEY_LOCAL_VOLUMES, &hKey);
    RegCreateKey(rKey, DFSHOST_DIR, &hKey);


    if (rKey != NULL)
        RegCloseKey(rKey);

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (fSwDebug != 0)
        MyPrintf(L"CmdClean exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
DfsDeleteChildKeys(
    HKEY hKey,
    LPWSTR s)
{
    WCHAR *wcp, *wcp1;
    HKEY nKey;
    DWORD dwErr;
    DWORD hErr;

    if (fSwDebug != 0)
        MyPrintf(L"DfsDeleteChildKeys(%ws)\r\n", s);

    for (wcp = s; *wcp; wcp++)
            ;
    hErr = dwErr = RegOpenKey(hKey, s, &nKey);
    while (RegEnumKey(nKey, 0, wcp, 50 * sizeof(WCHAR)) == ERROR_SUCCESS) {
        for (wcp1 = wcp; *wcp1; wcp1++)
            ;
        *wcp1++ = L'\\';
        *wcp1 = L'\0';
        dwErr = DfsDeleteChildKeys(hKey, s);
        if (dwErr == ERROR_SUCCESS) {
            dwErr = RegDeleteKey(hKey, s);
        }
    }
    *wcp = L'\0';
    if (hErr == ERROR_SUCCESS) {
        RegCloseKey(nKey);
    }
    if (fSwDebug != 0)
        MyPrintf(L"DfsDeleteChildKeys exit %d\r\n", dwErr);
    return dwErr;
}

DWORD
DfsRegDeleteKeyAndChildren(
    HKEY hkey,
    LPWSTR s)
{
    DWORD dwErr;
    LONG l;
    LPWSTR wCp;

    if (fSwDebug != 0)
        MyPrintf(L"DfsRegDeleteKeyAndChildren(%ws)\r\n", s);

    wCp = (LPWSTR)malloc(4096);
    if (wCp == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(wCp, s);
    l = wcslen(s);
    if (l > 0 && wCp[l-1] != L'\\') {
        wcscat(wCp, L"\\");
    }
    dwErr = DfsDeleteChildKeys(hkey, wCp);
    if (dwErr == ERROR_SUCCESS) {
        dwErr = RegDeleteKey(hkey, wCp);
    }
    free(wCp);
    if (fSwDebug != 0)
        MyPrintf(L"DfsRegDeleteKeyAndChildren exit %d\r\n", dwErr);
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\util\dfsdump\testsup.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       testsup.c
//
//  Contents:   This file contains functions which are purportedly
//              useful for testing the DsFs driver.
//
//  Functions:  DsfsCleanup -- Cleanup opened files, etc.
//              DsfsDefineLogicalRoot -- Define a logical root to the FSD
//              DsfsDefineProvider -- Define a DFS provider
//              DsfsAddPrefix - Add an entry path to the FSD's prefix table
//              DsfsDelPrefix - Delete a prefix table entry in the FSD
//              DsfsUpdReferralList - update the referral list of a prefix entry
//              DsfsReadStruct - Return dsfs data structures.
//              DfsCreateSymbolicLink - create a symbolic link for logical root
//
//  History:    04 Feb 1992     alanw   Created.
//              30 May 1992     alanw   Added DfsCreateSymbolicLink
//
//  Notes:      These functions are not necessarily multi-thread safe.
//
//--------------------------------------------------------------------------


#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "wchar.h"

#include "dsfsctl.h"
#include "testsup.h"
#include "dfsstr.h"

#define MAX_ENTRY_PATH  80              // max. length of an entry path
#define LOG_ROOT_LENGTH 16              // max. length of a logical root name

#define LMRDR                     L"\\Device\\LanmanRedirector\\"

extern  PWSTR   gpwszServer;
HANDLE  DsfsFile = NULL;
PWSTR   DsfsDeviceName = L"\\Dfs";
PWSTR   DsfsLogicalRootName = L"\\Device\\WinDFS";


//
// from PKT.H
//

#define DFS_SERVICE_TYPE_LOCAL          (0x0004)

//+-------------------------------------------------------------------------
//
//  Function:   DsfsOpenDevice, local
//
//  Synopsis:   Conditionally open the Dsfs file system device object.
//
//  Arguments:  -none-
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if the device was opened
//                      successfully.
//
//--------------------------------------------------------------------------

NTSTATUS
DsfsOpenDevice(
    void
) {
    NTSTATUS Stat;

    OBJECT_ATTRIBUTES ObjAttrs;
    UNICODE_STRING DsfsName;
    IO_STATUS_BLOCK IoStatus;

    if (DsfsFile == NULL) {
        WCHAR   wszServer[sizeof(LMRDR) / sizeof(WCHAR) +
                          16 +      // max NetBIOS machine name length
                          sizeof(ROOT_SHARE_NAME) / sizeof(WCHAR) +
                          1];
        if(gpwszServer != NULL) {
            swprintf(wszServer,
                     L"%ws%ws%ws",
                     LMRDR,
                     gpwszServer,
                     ROOT_SHARE_NAME);
            RtlInitUnicodeString( &DsfsName, wszServer );
        }
        else {
            RtlInitUnicodeString( &DsfsName, DsfsDeviceName );
        }

        InitializeObjectAttributes( &ObjAttrs, &DsfsName,
                                    OBJ_CASE_INSENSITIVE, NULL, NULL);

        Stat = NtCreateFile(
                    &DsfsFile,
                    FILE_READ_DATA | SYNCHRONIZE,
                    &ObjAttrs,
                    &IoStatus,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION |
                        FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

        if ( NT_SUCCESS(Stat) )
            Stat = IoStatus.Status;

        return Stat;
    }
    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------------
//
//  Function:   DsfsDoFsctl, local
//
//  Synopsis:   Issues an NtFsControlFile call to the Dsfs file system
//              driver.  This is a helper routine that just assures that
//              the device is opened, and supplies some conventional
//              parameters.
//
//  Arguments:  [FsControlCode] -- The file system control code to be used
//              [InputBuffer] -- The fsctl input buffer
//              [InputBufferLength]
//              [OutputBuffer] -- The fsctl output buffer
//              [OutputBufferLength]
//
//  Returns:    NTSTATUS - the status of the open or fsctl operation.
//
//--------------------------------------------------------------------------

NTSTATUS
DsfsDoFsctl(
    IN ULONG FsControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
) {
    NTSTATUS Stat;
    IO_STATUS_BLOCK IoStatus;

    Stat = DsfsOpenDevice();
    if (! NT_SUCCESS(Stat))
        return Stat;

    Stat = NtFsControlFile(
        DsfsFile,
        NULL,           // Event,
        NULL,           // ApcRoutine,
        NULL,           // ApcContext,
        &IoStatus,
        FsControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength );

    if ( NT_SUCCESS(Stat) ) {
        Stat = IoStatus.Status;
    }
    return Stat;
}




//+-------------------------------------------------------------------------
//
//  Function:   DsfsCleanup, public
//
//  Synopsis:   DsfsCleanup will release any resources held by the
//              module (the open file handle to the Dsfs device).
//
//  Arguments:  -none-
//
//  Returns:    -none-
//
//--------------------------------------------------------------------------

VOID
DsfsCleanup(
    void
) {
    if (DsfsFile == NULL) {
        (VOID) NtClose(DsfsFile);
        DsfsFile = NULL;
    }
    return;

}



//+-------------------------------------------------------------------------
//
//  Function:   DsfsDefineLogicalRoot, public
//
//  Synopsis:   This routine will issue the Define Logical Root fsctl
//              to the Dsfs file system driver.  If successful, this
//              will create a new DS logical root.
//
//  Effects:    A new DS logical root is created in the DSFS driver.
//              It may also be necessary to create a symbolic link to
//              \DosDevices and inform the Cairo OSM to complete the
//              operation.
//
//  Arguments:  [LogicalRoot] -- the name of the logical root to be
//                      created
//
//  Returns:    NTSTATUS - the status of the operation.
//
//  Notes:      Generally, only one DS logical root will exist (org).
//              Others, such as domain and udomain will be symbolic links
//              to somewhere within org.
//
//--------------------------------------------------------------------------

NTSTATUS
DsfsDefineLogicalRoot(
    IN PWSTR            LogicalRoot
) {
    NTSTATUS Stat;
    WCHAR       Buffer[ LOG_ROOT_LENGTH + MAX_ENTRY_PATH ];
    PFILE_DFS_DEF_ROOT_BUFFER pDlrBuf =
                (PFILE_DFS_DEF_ROOT_BUFFER) &Buffer[0];
    int i;

    for (i=0; i<15; i++) {
        pDlrBuf->LogicalRoot[i] = *LogicalRoot++;
        if (pDlrBuf->LogicalRoot[i] == (WCHAR) ':')
            break;
        if (pDlrBuf->LogicalRoot[i] == UNICODE_NULL)
            break;
    }
    pDlrBuf->LogicalRoot[i] = UNICODE_NULL;

//    if (ARGUMENT_PRESENT(EntryPath)) {
//      for (i=0; i<MAX_ENTRY_PATH; i++) {
//          pDlrBuf->PrefixName[i] = *LogicalRoot++;
//          if (pDlrBuf->PrefixName[i] == (WCHAR) '/')
//              pDlrBuf->PrefixName[i] = (WCHAR) '\\';
//          if (pDlrBuf->PrefixName[i] == UNICODE_NULL)
//              break;
//      }
//      if (i >= MAX_ENTRY_PATH) {
//          return STATUS_BUFFER_TOO_SMALL;
//      }
//    }

    Stat = DsfsDoFsctl(
        FSCTL_DFS_DEFINE_LOGICAL_ROOT,
        (PVOID)pDlrBuf,
        sizeof *pDlrBuf,
        NULL,
        0);
    return Stat;
}


//+-------------------------------------------------------------------------
//
//  Function:   DsfsReadStruct, public
//
//  Synopsis:   A dsfs data structure is returned
//
//  Arguments:  [pRsParam] -- The Fsctl buffer which describes the
//                      data structure to be returned.
//              [pucData] -- Pointer to a buffer where the data will
//                      be returned.
//
//  Returns:    NTSTATUS - the status of the operation.
//
//  Notes:      This call will be effective on a debug build of the
//              dsfs driver only.
//
//--------------------------------------------------------------------------

NTSTATUS
DsfsReadStruct(
    PFILE_DFS_READ_STRUCT_PARAM pRsParam,
    PUCHAR pucData
)
{
    NTSTATUS Stat;

    Stat = DsfsDoFsctl(
        FSCTL_DFS_INTERNAL_READSTRUCT,
        (PVOID)pRsParam,
        sizeof *pRsParam,
        (PVOID)pucData,
        (ULONG)pRsParam->ByteCount);


    return Stat;
}




//+-------------------------------------------------------------------
//
//  Function:   DfsCreateSymbolicLink, public
//
//  Synopsis:   This function creates a symbolic link object for the specified
//              local device name which is linked to the logical root device
//              name that has a form of \Device\WinDFS\logicalrootname
//
//  Arguments:
//              [Local] -- Supplies the local device name.
//              [DestStr] -- Supplies the string which is the link target of
//                      the symbolic link object, if other than the local
//                      name itself.
//
//  Returns:    NTSTATUS - STATUS_Success or reason for failure.
//
//--------------------------------------------------------------------

NTSTATUS
DfsCreateSymbolicLink(
    IN  PWSTR Local,
    IN  PWSTR DestStr OPTIONAL
)
{
    NTSTATUS status;

    HANDLE SymbolicLink;
    UNICODE_STRING LinkStringU;
    UNICODE_STRING DestStringU;
    OBJECT_ATTRIBUTES LinkAttributes;

    WCHAR LocalName[LOG_ROOT_LENGTH + 1];

    WCHAR ExistLinkBuffer[MAXIMUM_FILENAME_LENGTH];
    UNICODE_STRING ExistLink;

    ExistLink.MaximumLength = sizeof( ExistLinkBuffer );
    ExistLink.Buffer = ExistLinkBuffer;
    ExistLink.Length = 0;


    LinkStringU.Buffer = NULL;
    DestStringU.Buffer = NULL;

    wcscpy(LocalName, Local);
    _wcsupr(LocalName);

    //
    // Since the logical root name is like a disk device, we want to
    // make its name refer to the root directory before calling
    // RtlDosNameToNtPathName to convert to NT-style path name.
    //
    wcscat(LocalName, L"\\");

    //
    // We expect this routine to generate an NT-style path name that is unique
    // per logon user using the Logon Id, so we have to be impersonating the
    // user at this point.
    //
    if (! RtlDosPathNameToNtPathName_U(LocalName, &LinkStringU, NULL, NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Remove the trailing slash character in order to create a symbolic
    // link of X: rather than X:/
    //
    LinkStringU.Length -= sizeof(WCHAR);

    if (ARGUMENT_PRESENT(DestStr)) {
        if (! RtlDosPathNameToNtPathName_U(DestStr, &DestStringU, NULL, NULL)) {
            status = STATUS_INVALID_PARAMETER;
            goto FreeStrings;
        }
        RtlFreeUnicodeString(&DestStringU);

        if (! DfsCreateLogicalRootName (DestStr, &DestStringU)) {
            status = STATUS_INVALID_PARAMETER;
            goto FreeStrings;
        }
    } else {
        if (! DfsCreateLogicalRootName (Local, &DestStringU)) {
            status = STATUS_INVALID_PARAMETER;
            goto FreeStrings;
        }
    }

    //
    // About to create a new symbolic link object.
    //
    InitializeObjectAttributes(
        &LinkAttributes,
        &LinkStringU,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );

    //
    // Check to see if there's already an existing symbolic link.
    //

    if ((status = NtOpenSymbolicLinkObject(
                        &SymbolicLink,
                        DELETE | GENERIC_READ,
                        &LinkAttributes
                        )) == STATUS_OBJECT_NAME_NOT_FOUND) {
        //
        // Logical root name has no link target.  Go ahead and
        // create the new one.
        //
        goto CreateLink;
    }
    else if (! NT_SUCCESS(status)) {
        goto FreeStrings;
    }

    //
    // Find out if the device specified is already
    // redirected
    //
    if (! NT_SUCCESS(NtQuerySymbolicLinkObject(
                         SymbolicLink,
                         &ExistLink,
                         NULL
                         ))) {
        goto CloseSymbolicHandle;
    }

    if (RtlPrefixString( (PSTRING) &DsfsLogicalRootName,
                         (PSTRING) &ExistLink,
                         TRUE) == FALSE) {
        //
        // Device is already redirected to something else
        //
        status = STATUS_DEVICE_ALREADY_ATTACHED;
        goto CloseSymbolicHandle;
    }

    //
    // Device is a DFS symbolic link, let's delete it so that we can create
    // a new symbolic link to the DFS logical root.
    //
    if (! NT_SUCCESS(NtMakeTemporaryObject(
                         SymbolicLink
                         ))) {
        status = STATUS_INVALID_PARAMETER;
    }

CloseSymbolicHandle:
    NtClose(SymbolicLink);

    if (! NT_SUCCESS(status)) {
        goto FreeStrings;
    }

CreateLink:
    //
    // Create a symbolic link object to the device we are redirecting only
    // if one does not already exist; or if one existed, it was deleted
    // successfully.
    //
    status = NtCreateSymbolicLinkObject(
                   &SymbolicLink,
                   GENERIC_READ | GENERIC_WRITE,
                   &LinkAttributes,
                   &DestStringU
                   );

    if (NT_SUCCESS(status)) {
        NtClose(SymbolicLink);
    }

FreeStrings:
    if (DestStringU.Buffer != NULL)
        RtlFreeUnicodeString(&DestStringU);

    //
    // Free memory allocated by RtlDosPathNameToNtPathName
    //
    if (LinkStringU.Buffer != NULL)
        RtlFreeUnicodeString(&LinkStringU);

    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateLogicalRootName, private
//
//  Synopsis:   An input logical root style name is converted to be
//              an absolute name referring to the NT DFS logical
//              root device directory.
//
//  Arguments:  [Name] -- The input logical root based path name.
//              [Dest] -- Pointer to a string in which the translated
//                      name will be returned.
//
//  Returns:    BOOLEAN - FALSE if the operation failed.
//
//  Notes:      The buffer for the string is allocated and should be
//              freed by the caller.
//
//--------------------------------------------------------------------------

BOOLEAN
DfsCreateLogicalRootName (
    PWSTR               Name,
    PUNICODE_STRING     Dest
)
{
    PWSTR       Buf = NULL;
    PWSTR       Src;
    int         FoundColon = 0;

    Dest->MaximumLength = (wcslen(Name) + wcslen(DsfsLogicalRootName) + 2 ) * sizeof (WCHAR);
    Buf = RtlAllocateHeap( RtlProcessHeap(), 0, Dest->MaximumLength);
    if (Buf == NULL) {
        return FALSE;
    }

    Dest->Buffer = Buf;

    for (Src = DsfsLogicalRootName; *Buf++ = *Src++; )
        ;
    Buf[-1] = (WCHAR) '\\';

    for (Src = Name; *Buf = *Src++; Buf++)
        if (*Buf == (WCHAR) ':' && !FoundColon) {
            Buf--;
            FoundColon++;
    }
    if (Buf[-1] == (WCHAR) '\\')
        Buf--;

    Dest->Length = (PCHAR)Buf - (PCHAR)Dest->Buffer;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\util\dfsdump\testsup.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       testsup.h
//
//  Contents:   This file defines function prototypes for routines
//              which are useful for testing the DsFs driver.
//
//  Functions:  DsfsCleanup
//              DsfsDefineLogicalRoot, public
//              DsfsDefineProvider, public
//              DsfsReadStruct, public
//              DfsCreateSymbolicLink, public
//              DfsCreateLogicalRootName, public
//
//  Notes:      A selected set of these routines should be moved into
//              a more public place.
//
//  History:    04 Feb 92       alanw   Created.
//
//--------------------------------------------------------------------------


#ifndef _TESTSUP_
#define _TESTSUP_

extern HANDLE   DsfsFile;
extern PWSTR    DsfsDeviceName;
extern PWSTR    DsfsLogicalRootName;

VOID
DsfsCleanup (void);

NTSTATUS
DsfsDefineLogicalRoot(
    IN PWSTR            LogicalRoot
);

NTSTATUS
DsfsDefineProvider(
    IN PWSTR            ProviderName,
    IN USHORT           eProviderId,
    IN USHORT           fProvCapability
);

#ifdef  _DSFSCTL_
NTSTATUS
DsfsReadStruct(
    PFILE_DFS_READ_STRUCT_PARAM pRsParam,
    PUCHAR              pucData
);
#endif  // _DSFSCTL_

NTSTATUS
DfsCreateSymbolicLink(
    IN  PWSTR           Local,
    IN  PWSTR           DestStr
);

BOOLEAN
DfsCreateLogicalRootName (
    PWSTR               Name,
    PUNICODE_STRING     Dest
);

#endif // _TESTSUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\ui\inc\tb.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       tb.h
//
//  Contents:   Message APIs for the toolbar control
//
//  History:    16-Aug-93   BruceFo   Created
//
//----------------------------------------------------------------------------

#ifndef __TB_H__
#define __TB_H__

// void Toolbar_AddBitmap(HWND hwnd, int nButtons, HINSTANCE hBMInst, UINT nBMID);
#define Toolbar_AddBitmap(hwnd, nButtons, hBMInst, nBMID) \
	{ TBADDBITMAP _tbBM; \
	  _tbBM.hInst = hBMInst; \
	  _tbBM.nID   = nBMID; \
	  (int)SendMessage((hwnd),TB_ADDBITMAP,(WPARAM)(nButtons),(LPARAM)&_tbBM); \
	}

// BOOL Toolbar_AddButtons(HWND hwnd, int nButtons, LPTBBUTTON lpButtons);
#define Toolbar_AddButtons(hwnd, nButtons, lpButtons) \
	(BOOL)SendMessage((hwnd),TB_ADDBUTTONS,(WPARAM)(nButtons),(LPARAM)(LPTBBUTTON)(lpButtons))

// int Toolbar_AddString(HWND hwnd, HINSTANCE hInst, UINT idString);
#define Toolbar_AddString(hwnd, hInst, idString) \
	(int)SendMessage((hwnd),TB_ADDSTRING,(WPARAM)(HINSTANCE)(hInst),(LPARAM)(MAKELPARAM((idString),0)))

// void Toolbar_AutoSize(HWND hwnd);
#define Toolbar_AutoSize(hwnd) \
	(void)SendMessage((hwnd),TB_AUTOSIZE,(WPARAM)0,(LPARAM)0)

// int Toolbar_ButtonCount(HWND hwnd);
#define Toolbar_ButtonCount(hwnd) \
	(int)SendMessage((hwnd),TB_BUTTONCOUNT,(WPARAM)0,(LPARAM)0)

// int Toolbar_ButtonStructSize(HWND hwnd, int cb);
#define Toolbar_ButtonStructSize(hwnd, cb) \
	(int)SendMessage((hwnd),TB_BUTTONSTRUCTSIZE,(WPARAM)(cb),(LPARAM)0)

// BOOL Toolbar_CheckButton(HWND hwnd, UINT idButton, BOOL fCheck);
#define Toolbar_CheckButton(hwnd, idButton, fCheck) \
	(BOOL)SendMessage((hwnd),TB_CHECKBUTTON,(WPARAM)(idButton),(LPARAM)MAKELPARAM((fCheck),0))

// int Toolbar_CommandToIndex(HWND hwnd, UINT idButton);
#define Toolbar_CommandToIndex(hwnd, idButton) \
	(int)SendMessage((hwnd),TB_COMMANDTOINDEX,(WPARAM)(idButton),(LPARAM)0)

// void Toolbar_Customize(HWND hwnd);
#define Toolbar_Customize(hwnd) \
	(void)SendMessage((hwnd),TB_CUSTOMIZE,(WPARAM)0,(LPARAM)0)

// BOOL Toolbar_DeleteButton(HWND hwnd, UINT idButton);
#define Toolbar_DeleteButton(hwnd, idButton) \
	(BOOL)SendMessage((hwnd),TB_DELETEBUTTON,(WPARAM)(idButton),(LPARAM)0)

// BOOL Toolbar_EnableButton(HWND hwnd, UINT idButton, BOOL fEnable);
#define Toolbar_EnableButton(hwnd, idButton, fEnable) \
	(BOOL)SendMessage((hwnd),TB_ENABLEBUTTON,(WPARAM)(idButton),(LPARAM)MAKELPARAM((fEnable),0))

// BOOL Toolbar_GetButton(HWND hwnd, UINT iButton, LPTBBUTTON lpButton);
#define Toolbar_GetButton(hwnd, iButton, lpButton) \
	(BOOL)SendMessage((hwnd),TB_GETBUTTON,(WPARAM)(iButton),(LPARAM)(LPTBBUTTON)(lpButton))

// BOOL Toolbar_GetItemRect(HWND hwnd, UINT iButton, LPRECT lpRect);
#define Toolbar_GetItemRect(hwnd, iButton, lpRect) \
	(BOOL)SendMessage((hwnd),TB_GETITEMRECT,(WPARAM)(iButton),(LPARAM)(LPRECT)(lpRect))

// int Toolbar_GetState(HWND hwnd, UINT iButton);
#define Toolbar_GetState(hwnd, iButton, lpRect) \
	(int)SendMessage((hwnd),TB_GETSTATE,(WPARAM)(iButton),(LPARAM)0)

// BOOL Toolbar_HideButton(HWND hwnd, UINT idButton, BOOL fShow);
#define Toolbar_HideButton(hwnd, idButton, fShow) \
	(BOOL)SendMessage((hwnd),TB_HIDEBUTTON,(WPARAM)(idButton),(LPARAM)MAKELPARAM((fShow),0))

// BOOL Toolbar_Indeterminate(HWND hwnd, UINT iButton, BOOL fIndeterminate);
#define Toolbar_Indeterminate(hwnd, iButton, fIndeterminate) \
	(BOOL)SendMessage((hwnd),TB_INDETERMINATE,(WPARAM)(iButton),(LPARAM)MAKELPARAM((fIndeterminate),0))

// BOOL Toolbar_InsertButton(HWND hwnd, UINT iButton, LPTBBUTTON lpButton);
#define Toolbar_InsertButton(hwnd, iButton, lpButton) \
	(BOOL)SendMessage((hwnd),TB_INSERTBUTTON,(WPARAM)(iButton),(LPARAM)(LPTBBUTTON)(lpButton))

// int Toolbar_IsButtonChecked(HWND hwnd, UINT idButton);
#define Toolbar_IsButtonChecked(hwnd, idButton) \
	(int)SendMessage((hwnd),TB_ISBUTTONCHECKED,(WPARAM)(idButton),(LPARAM)0)

// int Toolbar_IsButtonEnabled(HWND hwnd, UINT idButton);
#define Toolbar_IsButtonEnabled(hwnd, idButton) \
	(int)SendMessage((hwnd),TB_ISBUTTONENABLED,(WPARAM)(idButton),(LPARAM)0)

// int Toolbar_IsButtonHidden(HWND hwnd, UINT idButton);
#define Toolbar_IsButtonHidden(hwnd, idButton) \
	(int)SendMessage((hwnd),TB_ISBUTTONHIDDEN,(WPARAM)(idButton),(LPARAM)0)

// int Toolbar_IsButtonIndeterminate(HWND hwnd, UINT idButton);
#define Toolbar_IsButtonIndeterminate(hwnd, idButton) \
	(int)SendMessage((hwnd),TB_ISBUTTONINDETERMINATE,(WPARAM)(idButton),(LPARAM)0)

// int Toolbar_IsButtonPressed(HWND hwnd, UINT idButton);
#define Toolbar_IsButtonPressed(hwnd, idButton) \
	(int)SendMessage((hwnd),TB_ISBUTTONPRESSED,(WPARAM)(idButton),(LPARAM)0)

// BOOL Toolbar_PressButton(HWND hwnd, UINT idButton, BOOL fPress);
#define Toolbar_PressButton(hwnd, idButton, fPress) \
	(BOOL)SendMessage((hwnd),TB_PRESSBUTTON,(WPARAM)(idButton),(LPARAM)MAKELPARAM((fPress),0))

// BOOL Toolbar_SaveRestore(HWND hwnd, BOOL fSave, TBSAVEPARAMS* lpSaveRestore);
#define Toolbar_SaveRestore(hwnd, fSave, lpSaveRestore) \
	(BOOL)SendMessage((hwnd),TB_SAVERESTORE,(WPARAM)(fSave),(LPARAM)(TBSAVEPARAMS*)(lpSaveRestore))

// BOOL Toolbar_SetBitmapSize(HWND hwnd, WORD dxBitmap, WORD dyBitmap);
#define Toolbar_SetBitmapSize(hwnd, dxBitmap, dyBitmap) \
	(BOOL)SendMessage((hwnd),TB_SETBITMAPSIZE,(WPARAM)0,(LPARAM)MAKELPARAM((dxBitmap),(dyBitmap)))

// BOOL Toolbar_SetButtonSize(HWND hwnd, WORD dxButton, WORD dyButton);
#define Toolbar_SetButtonSize(hwnd, dxButton, dyButton) \
	(BOOL)SendMessage((hwnd),TB_SETBUTTONSIZE,(WPARAM)0,(LPARAM)MAKELPARAM((dxButton),(dyButton)))

// BOOL Toolbar_SetState(HWND hwnd, UINT idButton, BOOL fState);
#define Toolbar_SetState(hwnd, idButton, fState) \
	(BOOL)SendMessage((hwnd),TB_SETSTATE,(WPARAM)(idButton),(LPARAM)MAKELPARAM((fState),0))

#endif // __TB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\util\dfsdump\udumpsup.c ===
#include <stdio.h>
#include <ntifs.h>

NTSTATUS
DfsReadAndPrintString(
    PUNICODE_STRING     pStr
);

#define DbgPrint        printf

#define USERMODE                // special handling for DumpString
#include "dumpsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\util\dfskd\dumps.c ===
#define KDEXTMODE

#include <dumpsup.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\util\dfskd\dfskd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    dfskd.c

Abstract:

    Dfs Kernel Debugger extension

Author:

    Milan Shah (milans) 21-Aug-1995

Revision History:

    21-Aug-1995 Milans  Created
    30-Aug-1997 JHarper Updated

--*/

#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "nodetype.h"
#include "dfsmrshl.h"
#include "dfsfsctl.h"
#include "pkt.h"
#include "dfslpc.h"
#include "spcsup.h"
#include "sitesup.h"
#include "ipsup.h"
#include "dfsstruc.h"
#include "fsctrl.h"
#include "attach.h"
#include "fcbsup.h"

#include <kdextlib.h>

#define PRINTF dprintf
#define IPRINTF DoIndent(); dprintf
#define IPRINTSTRINGW DoIndent(); wPrintStringW
   #define NTC_UNDEFINED                   ((NODE_TYPE_CODE)0x0000)

   #define DSFS_NTC_DATA_HEADER            ((NODE_TYPE_CODE)0x0D01)
   #define DSFS_NTC_IRP_CONTEXT            ((NODE_TYPE_CODE)0x0D02)
   #define DSFS_NTC_REFERRAL               ((NODE_TYPE_CODE)0x0D03)
   #define DSFS_NTC_VCB                    ((NODE_TYPE_CODE)0x0D04)
   #define DSFS_NTC_PROVIDER               ((NODE_TYPE_CODE)0x0D05)
   #define DSFS_NTC_FCB_HASH               ((NODE_TYPE_CODE)0x0D06)
   #define DSFS_NTC_FCB                    ((NODE_TYPE_CODE)0x0D07)
   #define DSFS_NTC_DNR_CONTEXT            ((NODE_TYPE_CODE)0x0D08)
   #define DSFS_NTC_PKT                    ((NODE_TYPE_CODE)0x0D09)
   #define DSFS_NTC_PKT_ENTRY              ((NODE_TYPE_CODE)0x0D0A)
   #define DSFS_NTC_PKT_STUB               ((NODE_TYPE_CODE)0x0D0B)
   #define DSFS_NTC_INSTRUM                ((NODE_TYPE_CODE)0x0D0C)
   #define DSFS_NTC_INSTRUM_FREED          ((NODE_TYPE_CODE)0x0D0D)
   #define DSFS_NTC_PWSTR                  ((NODE_TYPE_CODE)0x0D0E)

#define FIELD_NAME_LENGTH 30
#define NewLineForFields(FieldNo) \
        ((((FieldNo) % s_NoOfColumns) == 0) ? NewLine : FieldSeparator)
char *NewLine  = "\n";
char *FieldSeparator = " ";

BOOLEAN wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size);
BOOL wGetString( ULONG_PTR dwAddress, PSZ buf );
BOOL wPrintStringW( IN LPSTR msg OPTIONAL, IN PUNICODE_STRING pStr, IN BOOL nl );
BOOL wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl );
BOOL wPrintLargeInt(LARGE_INTEGER *bigint);

#define MAX_ENTRIES 100

/*
 * Dfs global variables.
 *
 */

#define NO_SYMBOLS_MESSAGE      \
    "Unable to get address of Dfs!DfsData - do you have symbols?\n"

LPSTR ExtensionNames[] = {
    "Dfs debugger extensions",
    0
};

LPSTR Extensions[] = {
    "DfsData - dumps Dfs!DfsData",
    "Pkt - dumps the global Pkt",
    "SpecialTable - dumps the Special table",
    "FtDfsTable - dumps the FtDfs table",
    "SiteTable - dumps the Site table",
    "IpTable - dumps the Ip table",
    "FcbTable - dumps all the Dfs FCBs",
    "VdoList - dumps all the Dfs Volume Objects (attached device objects)",
    "VcbList - dumps all the Vcbs & Dfs Device Objects (net used objects)",
    "Dump - dump a data structure. Type in 'dfskd.dump' for more info",
    "Dumpdfs address -- dumps DfsData, prefix table",
    0
};

ENUM_VALUE_DESCRIPTOR DfsOperationalStateEnum[] = {
    {DFS_STATE_UNINITIALIZED, "Dfs State Uninitialized"},
    {DFS_STATE_INITIALIZED, "Dfs State Initialized"},
    {DFS_STATE_STARTED, "Dfs Started"},
    {DFS_STATE_STOPPING, "Dfs Stopping"},
    {DFS_STATE_STOPPED, "Dfs Stopped"},
    0
};

ENUM_VALUE_DESCRIPTOR DfsMachineStateEnum[] = {
    {DFS_UNKNOWN, "Dfs State Unknown"},
    {DFS_CLIENT, "Dfs Client"},
    {DFS_SERVER, "Dfs Server"},
    {DFS_ROOT_SERVER, "Dfs Root"},
    0
};

ENUM_VALUE_DESCRIPTOR LpcPortStateEnum[] = {
    {LPC_STATE_UNINITIALIZED, "Unitialized"},
    {LPC_STATE_INITIALIZING, "Initializing"},
    {LPC_STATE_INITIALIZED, "Initialized"},
    0
};

ENUM_VALUE_DESCRIPTOR LvStateEnum[] = {
    {LV_UNINITIALIZED,"Local Vols Uninitialized"},
    {LV_INITSCHEDULED,"Local Vols init scheduled"},
    {LV_INITINPROGRESS,"Local Vols init in progress"},
    {LV_INITIALIZED,"Local Vols Initialized"},
    {LV_VALIDATED,"Local Vols Validated with DC"},
    0
};

/*
 * DFS_DATA
 *
 */

FIELD_DESCRIPTOR DfsDataFields[] = {
    FIELD3(FieldTypeShort,DFS_DATA,NodeTypeCode),
    FIELD3(FieldTypeShort,DFS_DATA,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_DATA,AVdoQueue),
    FIELD3(FieldTypePointer,DFS_DATA,DriverObject),
    FIELD3(FieldTypePointer,DFS_DATA,FileSysDeviceObject),
    FIELD3(FieldTypePointer,DFS_DATA,pProvider),
    FIELD3(FieldTypeULong,DFS_DATA,cProvider),
    FIELD3(FieldTypeULong,DFS_DATA,maxProvider),
    FIELD3(FieldTypeStruct,DFS_DATA,Resource),
    FIELD3(FieldTypeUnicodeString,DFS_DATA,PrincipalName),
    FIELD3(FieldTypeUnicodeString,DFS_DATA,NetBIOSName),
    FIELD4(FieldTypeEnum,DFS_DATA,OperationalState,DfsOperationalStateEnum),
    FIELD4(FieldTypeEnum,DFS_DATA,MachineState,DfsMachineStateEnum),
    FIELD3(FieldTypeBoolean,DFS_DATA,IsDC),
    FIELD4(FieldTypeEnum,DFS_DATA,LvState,LvStateEnum),
    FIELD3(FieldTypeStruct,DFS_DATA,Pkt),
    FIELD3(FieldTypePointer,DFS_DATA,FcbHashTable),
    FIELD3(FieldTypePointer,DFS_DATA,SiteHashTable),
    FIELD3(FieldTypePointer,DFS_DATA,IpHashTable),
    FIELD3(FieldTypePointer,DFS_DATA,SpcHashTable),
    FIELD3(FieldTypePointer,DFS_DATA,FtDfsHashTable),
    FIELD3(FieldTypeStruct,DFS_DATA,DfsLpcInfo),
    0
};

/*
 * DFS_PKT
 *
 */

FIELD_DESCRIPTOR DfsPktFields[] = {
    FIELD3(FieldTypeUShort,DFS_PKT,NodeTypeCode),
    FIELD3(FieldTypeUShort,DFS_PKT,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_PKT,Resource),
    FIELD3(FieldTypeStruct,DFS_PKT,UseCountLock),
    FIELD3(FieldTypeULong,DFS_PKT,EntryCount),
    FIELD3(FieldTypeStruct,DFS_PKT,EntryList),
    FIELD3(FieldTypePointer,DFS_PKT,DomainPktEntry),
    FIELD3(FieldTypeStruct,DFS_PKT,LocalVolTable),
    FIELD3(FieldTypeStruct,DFS_PKT,PrefixTable),
    FIELD3(FieldTypeStruct,DFS_PKT,ShortPrefixTable),
    FIELD3(FieldTypeStruct,DFS_PKT,DSMachineTable),
    0
};

/*
 * DFS_PKT_ENTRY
 *
 */

BIT_MASK_DESCRIPTOR PktEntryType[]  = {
    {PKT_ENTRY_TYPE_CAIRO, "Cairo Volume"},
    {PKT_ENTRY_TYPE_MACHINE, "Machine Volume"},
    {PKT_ENTRY_TYPE_NONCAIRO, "Non-Cairo Volume"},
    {PKT_ENTRY_TYPE_OUTSIDE_MY_DOM, "Inter-Domain Volume"},
    {PKT_ENTRY_TYPE_REFERRAL_SVC, "Referral Service (DC)"},
    {PKT_ENTRY_TYPE_PERMANENT, "Permanent Entry"},
    {PKT_ENTRY_TYPE_LOCAL,"Local Volume"},
    {PKT_ENTRY_TYPE_LOCAL_XPOINT,"Local Exit Point"},
    {PKT_ENTRY_TYPE_MACH_SHARE,"Local Machine Share"},
    {PKT_ENTRY_TYPE_OFFLINE,"Offline Volume"},
    0
};

FIELD_DESCRIPTOR DfsPktEntryFields[] = {
    FIELD3(FieldTypeUShort,DFS_PKT_ENTRY,NodeTypeCode),
    FIELD3(FieldTypeUShort,DFS_PKT_ENTRY,NodeByteSize),
    FIELD4(FieldTypeDWordBitMask,DFS_PKT_ENTRY,Type,PktEntryType),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,USN),
    FIELD3(FieldTypeUnicodeString,DFS_PKT_ENTRY,Id.Prefix),
    FIELD3(FieldTypeUnicodeString,DFS_PKT_ENTRY,Id.ShortPrefix),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,Info.Timeout),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,Info.ServiceCount),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,Info.ServiceList),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,UseCount),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,FileOpenCount),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,ActiveService),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,LocalService),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,Superior),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,SubordinateCount),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,SubordinateList),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,SiblingLink),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,ClosestDC),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,ChildList),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,NextLink),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,PrefixTableEntry),
    0
};

/*
 * DFS_SERVICE
 *
 */

BIT_MASK_DESCRIPTOR ServiceType[] = {
    {DFS_SERVICE_TYPE_MASTER, "Master Svc"},
    {DFS_SERVICE_TYPE_READONLY, "Read-Only Svc"},
    {DFS_SERVICE_TYPE_LOCAL, "Local Svc"},
    {DFS_SERVICE_TYPE_REFERRAL, "Referral Svc"},
    {DFS_SERVICE_TYPE_ACTIVE, "Active Svc"},
    {DFS_SERVICE_TYPE_DOWN_LEVEL, "Down-level Svc"},
    {DFS_SERVICE_TYPE_COSTLIER, "Costlier than previous"},
    {DFS_SERVICE_TYPE_OFFLINE, "Svc Offline"},
    0
};

BIT_MASK_DESCRIPTOR ServiceCapability[] = {
    {PROV_DFS_RDR, "Use Dfs Rdr"},
    {PROV_STRIP_PREFIX, "Strip Prefix (downlevel or local) Svc"},
    0
};


FIELD_DESCRIPTOR DfsServiceFields[] = {
    FIELD4(FieldTypeDWordBitMask,DFS_SERVICE,Type,ServiceType),
    FIELD4(FieldTypeDWordBitMask,DFS_SERVICE,Capability,ServiceCapability),
    FIELD3(FieldTypeULong,DFS_SERVICE,Status),
    FIELD3(FieldTypeULong,DFS_SERVICE,ProviderId),
    FIELD3(FieldTypeULong,DFS_SERVICE,Cost),
    FIELD3(FieldTypePointer,DFS_SERVICE,ConnFile),
    FIELD3(FieldTypePointer,DFS_SERVICE,pProvider),
    FIELD3(FieldTypePointer,DFS_SERVICE,pMachEntry),
    FIELD3(FieldTypeUnicodeString,DFS_SERVICE,Name),
    FIELD3(FieldTypeUnicodeString,DFS_SERVICE,Address),
    FIELD3(FieldTypeUnicodeString,DFS_SERVICE,StgId),
    0
};

/*
 * DFS_MACHINE_ENTRY
 *
 */

FIELD_DESCRIPTOR DfsMachineEntryFields[] = {
    FIELD3(FieldTypePointer,DFS_MACHINE_ENTRY,pMachine),
    FIELD3(FieldTypeUnicodeString,DFS_MACHINE_ENTRY,MachineName),
    FIELD3(FieldTypeULong,DFS_MACHINE_ENTRY,UseCount),
    FIELD3(FieldTypeULong,DFS_MACHINE_ENTRY,ConnectionCount),
    0
};

/*
 * DS_MACHINE
 *
 */

FIELD_DESCRIPTOR DsMachineFields[] = {
    FIELD3(FieldTypeGuid,DS_MACHINE,guidSite),
    FIELD3(FieldTypeGuid,DS_MACHINE,guidMachine),
    FIELD3(FieldTypeULong,DS_MACHINE,grfFlags),
    FIELD3(FieldTypePWStr,DS_MACHINE,pwszShareName),
    FIELD3(FieldTypeULong,DS_MACHINE,cPrincipals),
    FIELD3(FieldTypePointer,DS_MACHINE,prgpwszPrincipals),
    FIELD3(FieldTypeULong,DS_MACHINE,cTransports),
    FIELD3(FieldTypeStruct,DS_MACHINE,rpTrans),
    0
};

/*
 * DFS_LPC_INFO
 *
 */

FIELD_DESCRIPTOR LpcInfoFields[] = {
    FIELD3(FieldTypeUnicodeString,DFS_LPC_INFO,LpcPortName),
    FIELD4(FieldTypeEnum,DFS_LPC_INFO,LpcPortState,LpcPortStateEnum),
    FIELD3(FieldTypePointer,DFS_LPC_INFO,LpcPortHandle),
    0
};

/*
 * PROVIDER_DEF
 *
 */

FIELD_DESCRIPTOR ProviderDefFields[] = {
    FIELD3(FieldTypeUShort,PROVIDER_DEF,NodeTypeCode),
    FIELD3(FieldTypeUShort,PROVIDER_DEF,NodeByteSize),
    FIELD3(FieldTypeUShort,PROVIDER_DEF,eProviderId),
    FIELD4(FieldTypeDWordBitMask,PROVIDER_DEF,fProvCapability,ServiceCapability),
    FIELD3(FieldTypeUnicodeString,PROVIDER_DEF,DeviceName),
    FIELD3(FieldTypePointer,PROVIDER_DEF,DeviceObject),
    FIELD3(FieldTypePointer,PROVIDER_DEF,FileObject),
    0
};

/*
 * DFS_VOLUME_OBJECT
 *
 */

FIELD_DESCRIPTOR DfsVolumeObjectFields[] = {
    FIELD3(FieldTypeStruct,DFS_VOLUME_OBJECT,DeviceObject),
    FIELD3(FieldTypeULong,DFS_VOLUME_OBJECT,AttachCount),
    FIELD3(FieldTypeStruct,DFS_VOLUME_OBJECT,VdoLinks),
    FIELD3(FieldTypeStruct,DFS_VOLUME_OBJECT,Provider),
    FIELD3(FieldTypeUnicodeString,DFS_VOLUME_OBJECT,Provider.DeviceName),
    FIELD3(FieldTypePointer,DFS_VOLUME_OBJECT,Provider.DeviceObject),
    FIELD3(FieldTypePointer,DFS_VOLUME_OBJECT,Provider.FileObject),
    0
};

/*
 * DFS_PREFIX_TABLE
 *
 */

FIELD_DESCRIPTOR DfsPrefixTableFields[] = {
    FIELD3(FieldTypeBoolean,DFS_PREFIX_TABLE,CaseSensitive),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE,NamePageList.pFirstPage),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE,NextEntry),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,RootEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[0].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[0].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[1].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[1].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[2].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[2].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[3].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[3].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[4].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[4].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[5].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[5].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[6].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[6].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[7].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[7].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[8].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[8].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[9].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[9].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[10].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[10].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[11].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[11].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[12].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[12].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[13].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[13].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[14].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[14].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[15].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[15].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[16].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[16].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[17].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[17].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[18].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[18].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[19].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[19].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[20].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[20].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[21].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[21].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[22].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[22].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[23].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[23].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[24].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[24].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[25].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[25].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[26].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[26].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[27].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[27].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[28].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[28].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[29].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[29].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[30].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[30].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[31].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[31].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[32].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[32].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[33].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[33].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[34].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[34].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[35].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[35].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[36].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[36].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[37].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[37].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[38].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[38].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[39].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[39].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[40].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[40].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[41].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[41].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[42].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[42].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[43].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[43].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[44].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[44].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[45].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[45].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[46].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[46].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[47].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[47].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[48].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[48].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[49].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[49].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[50].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[50].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[51].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[51].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[52].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[52].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[53].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[53].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[54].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[54].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[55].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[55].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[56].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[56].SentinelEntry),
    0
};

/*
 * DFS_PREFIX_TABLE_ENTRY
 *
 */

FIELD_DESCRIPTOR DfsPrefixTableEntryFields[] = {
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pParentEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pNextEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pPrevEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pFirstChildEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pSiblingEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE_ENTRY,NoOfChildren),
    FIELD3(FieldTypeUnicodeString,DFS_PREFIX_TABLE_ENTRY,PathSegment),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pData),
    0
};

FIELD_DESCRIPTOR DfsLocalVolEntryFields[] = {
    FIELD3(FieldTypeStruct,DFS_LOCAL_VOL_ENTRY,PktEntry),
    FIELD3(FieldTypeUnicodeString,DFS_LOCAL_VOL_ENTRY,LocalPath),
    FIELD3(FieldTypeUnicodeString,DFS_LOCAL_VOL_ENTRY,ShareName),
    FIELD3(FieldTypeStruct,DFS_LOCAL_VOL_ENTRY,PrefixTableEntry),
    0
};


/*
 * DFS_FCB
 *
 */

FIELD_DESCRIPTOR FcbFields[] = {
    FIELD3(FieldTypeUShort, DFS_FCB, NodeTypeCode),
    FIELD3(FieldTypeUShort, DFS_FCB, NodeByteSize),
    FIELD3(FieldTypeUnicodeString, DFS_FCB, FullFileName),
    FIELD3(FieldTypePointer, DFS_FCB, FileObject),
    0
};


STRUCT_DESCRIPTOR Structs[] = {
    STRUCT(DFS_DATA,DfsDataFields),
    STRUCT(DFS_PKT,DfsPktFields),
    STRUCT(DFS_PKT_ENTRY,DfsPktEntryFields),
    STRUCT(DFS_SERVICE,DfsServiceFields),
    STRUCT(DFS_MACHINE_ENTRY,DfsMachineEntryFields),
    STRUCT(DS_MACHINE,DsMachineFields),
    STRUCT(PROVIDER_DEF,ProviderDefFields),
    STRUCT(DFS_VOLUME_OBJECT,DfsVolumeObjectFields),
    STRUCT(DFS_PREFIX_TABLE,DfsPrefixTableFields),
    STRUCT(DFS_PREFIX_TABLE_ENTRY,DfsPrefixTableEntryFields),
    STRUCT(DFS_LOCAL_VOL_ENTRY,DfsLocalVolEntryFields),
    STRUCT(DFS_LPC_INFO,LpcInfoFields),
    STRUCT(DFS_FCB,FcbFields),
    0
};

/*
 * Dfs specific dump routines
 *
 */


VOID
dumplist(
    ULONG_PTR dwListEntryAddress,
    DWORD linkOffset,
    VOID (*dumpRoutine)(ULONG_PTR dwStructAddress)
);

VOID
dumpPktEntry(
    ULONG_PTR dwAddress
);

VOID
PktEntryDump(
    ULONG_PTR dwAddress
);

VOID
dumpFcb(
    ULONG_PTR dwAddress
);

VOID
dumpVcb(
    ULONG_PTR dwAddress
);

VOID
dumpVdo(
    ULONG_PTR dwAddress
);

VOID
dumpSiteInfo(
    ULONG_PTR dwAddress
);

VOID
dumpSpcInfo(
    ULONG_PTR dwAddress
);

VOID
dumpIpInfo(
    ULONG_PTR dwAddress
);

VOID
DumpDfsPrefixTableEntry(
    ULONG_PTR dwAddress,
    VOID (*DispFunc)(ULONG_PTR dwAddress)
);

VOID
DumpUnicodePrefixTable(
    ULONG_PTR dwAddress
);

VOID
DumpUnicodePrefixTableEntry(
    ULONG_PTR dwAddress
);

VOID
DoIndent(
    VOID
);

VOID
MyDumpPktEntry(
    ULONG_PTR dwAddress
);

VOID
MyDumpLocalVolEntry(
    ULONG_PTR dwAddress
);

VOID
MyDumpServices(
    ULONG_PTR dwAddress,
    ULONG ServiceCount
);

/*
 * globals
 */
INT Indent = 0;

/*
 * dfsdata : Routine to dump the global dfs data structure
 *
 */

BOOL
dfsdata(
    ULONG_PTR               dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    dwAddress = (GetExpression)("dfs!DfsData");

    if (dwAddress) {
        DFS_DATA DfsData;

        if (wGetData( dwAddress, &DfsData, sizeof(DfsData) )) {
            PrintStructFields( dwAddress, &DfsData, DfsDataFields);
        } else {
            PRINTF( "Unable to read DfsData @ %08lx\n", dwAddress );
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }

    return( TRUE );

}

/*
 * pkt : Routine to dump the Dfs PKT data structure
 *
 */

BOOL
pkt(
    ULONG_PTR               dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //
    // Figure out the address of the Pkt. This is an offset within
    // dfs!DfsData.
    //

    dwAddress = (GetExpression)("dfs!DfsData");

    if (dwAddress) {
        DFS_PKT pkt;

        dwAddress += FIELD_OFFSET(DFS_DATA, Pkt);

        if (wGetData(dwAddress,&pkt,sizeof(pkt))) {
            PrintStructFields( dwAddress, &pkt, DfsPktFields );
            dwAddress += FIELD_OFFSET(DFS_PKT, EntryList);
            dumplist(
                dwAddress,
                FIELD_OFFSET(DFS_PKT_ENTRY,Link),
                dumpPktEntry);
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }

    return( TRUE );

}

/*
 * dumpPktEntry : Routine suitable as argument for dumplist; used to dump
 *      list of pkt entries.
 *
 */

VOID
dumpPktEntry(
    ULONG_PTR dwAddress
)
{
    DFS_PKT_ENTRY pktEntry;

    if (wGetData(dwAddress, &pktEntry, sizeof(DFS_PKT_ENTRY))) {

        PRINTF( "\n--- Pkt Entry @ %08lx\n", dwAddress);

        wPrintStringW("Prefix : ", &pktEntry.Id.Prefix, TRUE);
        wPrintStringW("ShortPrefix : ", &pktEntry.Id.ShortPrefix, TRUE);

        //
        // Print the local service, if any
        //
        if (pktEntry.LocalService != NULL) {
            DFS_SERVICE Svc;

            PRINTF( "    Local Svc @%08lx : ",pktEntry.LocalService);
            if (wGetData( (ULONG_PTR)pktEntry.LocalService, &Svc, sizeof(Svc))) {
                wPrintStringW("Storage Id = ", &Svc.Address, TRUE);
            } else {
                PRINTF( "Storage Id = ?\n");
            }
        }

        //
        // Now, print the service list
        //
        if (pktEntry.Info.ServiceCount != 0) {
            ULONG i;

            for (i = 0; i < pktEntry.Info.ServiceCount; i++) {
                DFS_SERVICE Svc;
                ULONG_PTR dwServiceAddress;
                if (CheckControlC())
                    return;
                dwServiceAddress =
                    ((ULONG_PTR)pktEntry.Info.ServiceList) +
                        i * sizeof(DFS_SERVICE);
                PRINTF( "    Service %d @%08lx : ",i, dwServiceAddress);
                if (wGetData(dwServiceAddress, &Svc, sizeof(Svc))) {
                    wPrintStringW( "Address =", &Svc.Address, TRUE );
                } else {
                    PRINTF( "Address = ?\n");
                }
            }
        }
    } else {
        PRINTF( "Unable to get Pkt Entry @%08lx\n", dwAddress);
    }

}

VOID
PktEntryDump(ULONG_PTR dwAddress)
{
    DFS_PKT_ENTRY pktEntry;

    if (wGetData(dwAddress, &pktEntry, sizeof(DFS_PKT_ENTRY))) {

        PRINTF( "\n--- Pkt Entry @ %08lx\n", dwAddress);

        wPrintStringW("Prefix : ", &pktEntry.Id.Prefix, TRUE);
        wPrintStringW("ShortPrefix : ", &pktEntry.Id.ShortPrefix, TRUE);

        //
        // Print the local service, if any
        //
        if (pktEntry.LocalService != NULL) {
            DFS_SERVICE Svc;

            PRINTF( "    Local Svc @%08lx : ",pktEntry.LocalService);
            if (wGetData( (ULONG_PTR)pktEntry.LocalService, &Svc, sizeof(Svc))) {
                wPrintStringW("Storage Id = ", &Svc.Address, TRUE);
            } else {
                PRINTF( "Storage Id = ?\n");
            }
        }
    } else {
        PRINTF( "Unable to get Pkt Entry @%08lx\n", dwAddress);
    }

}

/*
 * fcbtable : Routine to dump the dfs fcb hash table
 *
 */

BOOL
fcbtable(
    DWORD                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    DWORD_PTR dwAddress;

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Dfs!DfsData.
    //

    dwAddress = (GetExpression)("Dfs!DfsData");

    if (dwAddress) {
        DFS_DATA DfsData;

        if (wGetData(dwAddress, &DfsData, sizeof(DFS_DATA))) {
            FCB_HASH_TABLE FcbTable;
            dwAddress = (DWORD_PTR) DfsData.FcbHashTable;
            if (wGetData(dwAddress, &FcbTable, sizeof(FCB_HASH_TABLE))) {
                ULONG i, cBuckets;
                DWORD_PTR dwListHeadAddress;
                cBuckets = FcbTable.HashMask + 1;
                dwListHeadAddress =
                    dwAddress + FIELD_OFFSET(FCB_HASH_TABLE, HashBuckets);
                PRINTF(
                    "+++ Fcb Hash Table @ %p (%d Buckets) +++\n",
                    dwAddress, cBuckets);
                for (i = 0; i < cBuckets; i++) {
                    if (CheckControlC())
                        return TRUE;
                    PRINTF( "--- Bucket(%d)\n", i );
                    dumplist(
                        dwListHeadAddress,
                        FIELD_OFFSET(DFS_FCB, HashChain),
                        dumpFcb);
                    dwListHeadAddress += sizeof(LIST_ENTRY);
                }
                PRINTF("--- Fcb Hash Table @ %08lx ---\n", dwAddress);

            } else {
                PRINTF( "Unable to read FcbTable @%08lx\n", dwAddress );
            }
        } else {
            PRINTF( "Unable to read DfsData @%08lx\n", dwAddress);
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}

/*
 * dumpFcb : Routine suitable as argument to dumplist; used to dump list of
 *      Fcbs
 *
 */

VOID
dumpFcb(
    DWORD_PTR dwAddress
)
{
    DFS_FCB fcb;

    if (wGetData( dwAddress, &fcb, sizeof(fcb))) {
        PRINTF("\nFcb @ %08lx\n", dwAddress);
        PrintStructFields( dwAddress, &fcb, FcbFields );
    } else {
        PRINTF("\nUnable to read Fcb @ %08lx\n", dwAddress);
    }
}

/*
 * vdolist : Routine to dump out all the Dfs Volume Device Objects (ie, the
 *      attached device objects)
 *
 */

BOOL
vdolist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //
    // Figure out the address of the Pkt. This is an offset within
    // dfs!DfsData.
    //

    dwAddress = (GetExpression)("dfs!DfsData");

    if (dwAddress) {
        dwAddress += FIELD_OFFSET(DFS_DATA, AVdoQueue);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_VOLUME_OBJECT,VdoLinks),
            dumpVdo);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return(TRUE);

}

BOOL
dumpspecialtable(
    ULONG_PTR dwAddress)
{
    ULONG i;
    SPECIAL_HASH_TABLE HashTable;

    if (wGetData(dwAddress,&HashTable,sizeof(SPECIAL_HASH_TABLE))) {
        ULONG nBuckets = HashTable.HashMask+1;
        PRINTF( "NodeByteCode: 0x%x\n", HashTable.NodeTypeCode);
        PRINTF( "NodeByteSize: 0x%x\n", HashTable.NodeByteSize);
        PRINTF( "Timeout: 0x%x\n", HashTable.SpcTimeout);
        PRINTF( "HashMask: 0x%x\n", HashTable.HashMask);

        if (HashTable.NodeTypeCode != DFS_NTC_SPECIAL_HASH) {
            PRINTF( "NodeTypeCode != DFS_NTC_SPECIAL_HASH\n");
        }
        if ((HashTable.HashMask & (HashTable.HashMask+1)) != 0) {
            PRINTF( "HashMask not a power of 2!\n");
            return (TRUE);
        }
        dwAddress += FIELD_OFFSET(SPECIAL_HASH_TABLE, HashBuckets[0]);
        for (i = 0; i < nBuckets; i++) {
            LIST_ENTRY ListEntry;

            if (wGetData(dwAddress,&ListEntry,sizeof(LIST_ENTRY))) {
                if (ListEntry.Flink) {
                    dumplist(
                        dwAddress,
                        FIELD_OFFSET(DFS_SPECIAL_INFO,HashChain),
                        dumpSpcInfo);
                }
            } else {
                PRINTF("Couldn't get Bucket[%d]\n", i);
                return (TRUE);
            }
            dwAddress += sizeof(LIST_ENTRY);
        }
    }
    return TRUE;
}

/*
 * specialtable : Routine to dump out the special table
 *
 */

BOOL
specialtable(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString)
{
    ULONG i;
    ULONG_PTR dwAddress;

    //
    // Figure out the address of the Pkt. This is an offset within
    // dfs!DfsData.
    //

    dwAddress = (GetExpression)("dfs!DfsData");

    if (dwAddress) {

        dwAddress += FIELD_OFFSET(DFS_DATA, SpcHashTable);
        if (!wGetData(dwAddress,&dwAddress,sizeof(dwAddress))) {
            PRINTF("Couldn't get address of SpcHashTable\n");
            return (TRUE);
        }
        PRINTF("SpcHashTable@0x%x\n", dwAddress);
        return dumpspecialtable(dwAddress);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return(TRUE);
}

/*
 * specialtable : Routine to dump out the special table
 *
 */

BOOL
ftdfstable(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString)
{
    ULONG i;
    ULONG_PTR dwAddress;

    //
    // Figure out the address of the Pkt. This is an offset within
    // dfs!DfsData.
    //

    dwAddress = (GetExpression)("dfs!DfsData");

    if (dwAddress) {

        dwAddress += FIELD_OFFSET(DFS_DATA, FtDfsHashTable);
        if (!wGetData(dwAddress,&dwAddress,sizeof(dwAddress))) {
            PRINTF("Couldn't get address of FtDfsHashTable\n");
            return (TRUE);
        }
        PRINTF("FtDfsHashTable@0x%x\n", dwAddress);
        return dumpspecialtable(dwAddress);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return(TRUE);
}

/*
 * sitetable : Routine to dump out the site table
 *
 */

BOOL
sitetable(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString)
{
    ULONG i;
    ULONG_PTR dwAddress;

    //
    // Figure out the address of the Pkt. This is an offset within
    // dfs!DfsData.
    //

    dwAddress = (GetExpression)("dfs!DfsData");

    if (dwAddress) {
        SITE_HASH_TABLE HashTable;

        dwAddress += FIELD_OFFSET(DFS_DATA, SiteHashTable);
        if (!wGetData(dwAddress,&dwAddress,sizeof(dwAddress))) {
            PRINTF("Couldn't get address of SiteHashTable\n");
            return (TRUE);
        }
        PRINTF("SiteHashTable@0x%x\n", dwAddress);
        if (wGetData(dwAddress,&HashTable,sizeof(SITE_HASH_TABLE))) {
            ULONG nBuckets = HashTable.HashMask+1;
            PRINTF( "NodeByteCode: 0x%x\n", HashTable.NodeTypeCode);
            PRINTF( "NodeByteSize: 0x%x\n", HashTable.NodeByteSize);
            PRINTF( "HashMask: 0x%x\n", HashTable.HashMask);

            if (HashTable.NodeTypeCode != DFS_NTC_SITE_HASH) {
                PRINTF( "NodeTypeCode != DFS_NTC_SITE_HASH\n");
            }
            if ((HashTable.HashMask & (HashTable.HashMask+1)) != 0) {
                PRINTF( "HashMask not a power of 2!\n");
                return (TRUE);
            }
            dwAddress += FIELD_OFFSET(SITE_HASH_TABLE, HashBuckets[0]);
            for (i = 0; i < nBuckets; i++) {
                LIST_ENTRY ListEntry;

                if (CheckControlC())
                    return TRUE;
                if (wGetData(dwAddress,&ListEntry,sizeof(LIST_ENTRY))) {
                    if (ListEntry.Flink) {
                        dumplist(
                            dwAddress,
                            FIELD_OFFSET(DFS_SITE_INFO,HashChain),
                            dumpSiteInfo);
                    }
                } else {
                    PRINTF("Couldn't get Bucket[%d]\n", i);
                    return (TRUE);
                }
                dwAddress += sizeof(LIST_ENTRY);
            }
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return(TRUE);
}


/*
 * iptable : Routine to dump out the ip table
 *
 */

BOOL
iptable(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString)
{
    ULONG i;
    ULONG_PTR dwAddress;

    //
    // Figure out the address of the Pkt. This is an offset within
    // dfs!DfsData.
    //

    dwAddress = (GetExpression)("dfs!DfsData");

    if (dwAddress) {
        IP_HASH_TABLE HashTable;

        dwAddress += FIELD_OFFSET(DFS_DATA, IpHashTable);
        if (!wGetData(dwAddress,&dwAddress,sizeof(dwAddress))) {
            PRINTF("Couldn't get address of IpHashTable\n");
            return (TRUE);
        }
        PRINTF("IpHashTable@0x%x\n", dwAddress);
        if (wGetData(dwAddress,&HashTable,sizeof(IP_HASH_TABLE))) {
            ULONG nBuckets = HashTable.HashMask+1;
            PRINTF( "NodeByteCode: 0x%x\n", HashTable.NodeTypeCode);
            PRINTF( "NodeByteSize: 0x%x\n", HashTable.NodeByteSize);
            PRINTF( "MaxEntries: 0x%x\n", HashTable.MaxEntries);
            PRINTF( "EntryCount: 0x%x\n", HashTable.EntryCount);
            PRINTF( "HashMask: 0x%x\n", HashTable.HashMask);

            if (HashTable.NodeTypeCode != DFS_NTC_IP_HASH) {
                PRINTF( "NodeTypeCode != DFS_NTC_IP_HASH\n");
            }
            if ((HashTable.HashMask & (HashTable.HashMask+1)) != 0) {
                PRINTF( "HashMask not a power of 2!\n");
                return (TRUE);
            }
            dwAddress += FIELD_OFFSET(IP_HASH_TABLE, HashBuckets[0]);
            for (i = 0; i < nBuckets; i++) {
                LIST_ENTRY ListEntry;

                if (CheckControlC())
                    return TRUE;
                if (wGetData(dwAddress,&ListEntry,sizeof(LIST_ENTRY))) {
                    if (ListEntry.Flink) {
                        dumplist(
                            dwAddress,
                            FIELD_OFFSET(DFS_IP_INFO,HashChain),
                            dumpIpInfo);
                    }
                } else {
                    PRINTF("Couldn't get Bucket[%d]\n", i);
                    return (TRUE);
                }
                dwAddress += sizeof(LIST_ENTRY);
            }
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return(TRUE);
}

/*
 * Dumpdfs : recursively dumps a DFS_PREFIX_TABLE
 *
 */

BOOL
dumpdfs(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PDFS_DATA pDfsData;
    PDFS_PKT pPkt;
    ULONG_PTR dwAddress;
    ULONG_PTR dwPrefixTable;

    if( lpArgumentString && *lpArgumentString ) {

        BYTE DataBuffer[sizeof(DFS_DATA)];
        pDfsData = (PDFS_DATA) DataBuffer;

        dwAddress = (GetExpression)( lpArgumentString );

        if (wGetData(dwAddress,pDfsData,sizeof(DFS_DATA))) {

            if (pDfsData->NodeTypeCode != DSFS_NTC_DATA_HEADER) {
               PRINTF( "Bad NodeTypeCode - not a DfsData struct\n");
               return (FALSE);
            }
            PRINTF( "--DFSDATA@0x%x--\n", dwAddress);
            PRINTF( "DfsData->NodeTypeCode: 0x%x\n", pDfsData->NodeTypeCode);
            PRINTF( "DfsData->Pkt@0x%x\n", FIELD_OFFSET(DFS_DATA, Pkt) + dwAddress);
            PRINTF( "DfsData->Pkt.NodeTypeCode: 0x%x\n", pDfsData->Pkt.NodeTypeCode);

            // LocalVolTable
            dwPrefixTable = dwAddress + FIELD_OFFSET(DFS_DATA, Pkt.LocalVolTable.RootEntry);
            DumpDfsPrefixTableEntry(dwPrefixTable, MyDumpLocalVolEntry);

            // PrefixTable
            dwPrefixTable = dwAddress + FIELD_OFFSET(DFS_DATA, Pkt.PrefixTable.RootEntry);
            DumpDfsPrefixTableEntry(dwPrefixTable, MyDumpPktEntry);

            // PrefixTable
            dwPrefixTable = dwAddress + FIELD_OFFSET(DFS_DATA, Pkt.ShortPrefixTable.RootEntry);
            DumpDfsPrefixTableEntry(dwPrefixTable, MyDumpPktEntry);

        } else {
            PRINTF( "Error reading Memory @ %lx\n",dwAddress);
        }
    } else {
                //
        // The command is of the form
        // dumpdfs addr
        //
        // The user didn't give us an address.
        //

        PRINTF(
            "!dfskd.dumpDfsPrefixTable address\n"
        );
    }

    return TRUE;
}

/*
 *  DumpUnicodePrefixTable  : Dump a UNICODE_PREFIX_TABLE
 *
 */
VOID
DumpUnicodePrefixTable(ULONG_PTR dwAddress)
{
    PUNICODE_PREFIX_TABLE pUnicodePrefixTable;
    BYTE DataBuffer[sizeof(UNICODE_PREFIX_TABLE)];

    pUnicodePrefixTable = (PUNICODE_PREFIX_TABLE) DataBuffer;
    if (wGetData(dwAddress,pUnicodePrefixTable,sizeof(UNICODE_PREFIX_TABLE))) {
            IPRINTF(0, "UNICODE_PREFIX_TABLE @ 0x%lx:\n", dwAddress);
            IPRINTF(0, "NodeTypeCode : 0x%x\n", pUnicodePrefixTable->NodeTypeCode);
            IPRINTF(0, "NextPrefixTree : 0x%lx\n", pUnicodePrefixTable->NextPrefixTree);
            IPRINTF(0, "LastNextEntry : 0x%lx\n", pUnicodePrefixTable->LastNextEntry);
            DumpUnicodePrefixTableEntry((ULONG_PTR)pUnicodePrefixTable->NextPrefixTree);
    } else {
        PRINTF( "Error reading Memory @ %lx\n",dwAddress);
    }
}

/*
 *  DumpUnicodePrefixTableEntry  : UNICODE_PREFIX_TABLE_ENTRY
 *
 */
VOID
DumpUnicodePrefixTableEntry(ULONG_PTR dwAddress)
{
    PUNICODE_PREFIX_TABLE_ENTRY pUnicodePrefixTableEntry;
    BYTE DataBuffer[sizeof(UNICODE_PREFIX_TABLE_ENTRY)];

    pUnicodePrefixTableEntry = (PUNICODE_PREFIX_TABLE_ENTRY) DataBuffer;
    if (wGetData(dwAddress,pUnicodePrefixTableEntry,sizeof(UNICODE_PREFIX_TABLE_ENTRY))) {
        // Get and print PathSegment
        if (pUnicodePrefixTableEntry->Prefix->Buffer) {
            IPRINTF( "UNICODE_PREFIX_TABLE_ENTRY @ 0x%lx:\n", dwAddress);
            IPRINTF( "NodeTypeCode : 0x%x\n", pUnicodePrefixTableEntry->NodeTypeCode);
            IPRINTSTRINGW("", pUnicodePrefixTableEntry->Prefix, TRUE);
        }
    } else {
        PRINTF( "Error reading Memory @ %lx\n",dwAddress);
    }
}

/*
 *  DumpDfsPrefixTableEntry : Recursively dump a DFS_PREFIX_TABLE
 *
 *  Prints the DFS_PREFIX_TABLE_ENTRY, then calls itself to print any siblings,
 *  then calls itself to print children.
 *
 */

VOID
DumpDfsPrefixTableEntry(ULONG_PTR dwAddress, VOID (*DumpFunc)(ULONG_PTR dwAddress))
{
    PDFS_PREFIX_TABLE_ENTRY pDfsPrefixTableEntry;
    BYTE DataBuffer[sizeof(DFS_PREFIX_TABLE_ENTRY)];
    BOOLEAN Verbose = 0;


    if (CheckControlC())
        return;
    pDfsPrefixTableEntry = (PDFS_PREFIX_TABLE_ENTRY) DataBuffer;
    if (wGetData(dwAddress,pDfsPrefixTableEntry,sizeof(DFS_PREFIX_TABLE_ENTRY))) {

        IPRINTF( "------DFS_PREFIX_TABLE_ENTRY@0x%x-----------\n", dwAddress);
        IPRINTF( "pParentEntry: 0x%lx\n", pDfsPrefixTableEntry->pParentEntry);
        IPRINTF( "pNextEntry: 0x%lx\n", pDfsPrefixTableEntry->pNextEntry);
        IPRINTF( "pPrevEntry: 0x%lx\n", pDfsPrefixTableEntry->pPrevEntry);
        IPRINTF( "pFirstChildEntry: 0x%lx\n", pDfsPrefixTableEntry->pFirstChildEntry);
        IPRINTF( "pSiblingEntry: 0x%lx\n", pDfsPrefixTableEntry->pSiblingEntry);
        IPRINTF( "NoOfChildren: 0x%lx\n", pDfsPrefixTableEntry->NoOfChildren);
        IPRINTF( "PathSegment: %lx\n", pDfsPrefixTableEntry->PathSegment.Buffer);
        IPRINTF( "pData: 0x%lx\n", pDfsPrefixTableEntry->pData);

        // Get and print PathSegment
        if (pDfsPrefixTableEntry->PathSegment.Buffer) {
            IPRINTSTRINGW("", &pDfsPrefixTableEntry->PathSegment, FALSE);
            IPRINTF( "    --> 0x%x\n", pDfsPrefixTableEntry->pData);
            if (pDfsPrefixTableEntry->pData) {
                ULONG_PTR dwDfsPktEntry;

                dwDfsPktEntry = (ULONG_PTR) pDfsPrefixTableEntry->pData;
                Indent++;
                DumpFunc(dwDfsPktEntry);
                Indent--;
            }
        }

        IPRINTF( "--------------------------------------------\n", dwAddress);

        // recursively dump Siblings
        if (pDfsPrefixTableEntry->pSiblingEntry)
            DumpDfsPrefixTableEntry(
                (ULONG_PTR)pDfsPrefixTableEntry->pSiblingEntry,
                DumpFunc);

        // then children
        Indent++;
        if (pDfsPrefixTableEntry->pFirstChildEntry)
            DumpDfsPrefixTableEntry(
                (ULONG_PTR)pDfsPrefixTableEntry->pFirstChildEntry,
                DumpFunc);
        Indent--;

    } else {
        PRINTF( "Error reading Memory @ %lx\n",dwAddress);
    }
}

VOID
MyDumpPktEntry(ULONG_PTR dwAddress)
{
    PDFS_PKT_ENTRY pDfsPktEntry;
    BYTE DataBuffer[sizeof(DFS_PKT_ENTRY)];

    // dwAddress points to PrefixTableEntry within the DFS_PKT_ENTRY struct
    dwAddress -= FIELD_OFFSET(DFS_PKT_ENTRY, PrefixTableEntry);
    pDfsPktEntry = (PDFS_PKT_ENTRY) DataBuffer;
    if (wGetData(dwAddress,pDfsPktEntry,sizeof(DFS_PKT_ENTRY))) {

        IPRINTF( "---------DFS_PKT_ENTRY@0x%x----\n", dwAddress);
        IPRINTF( "NodeTypeCode: 0x%x\n", pDfsPktEntry->NodeTypeCode);
        IPRINTF( "Type: 0x%x\n", pDfsPktEntry->Type);
        Indent++;
        IPRINTF( "----DFS_PKT_ENTRY_ID@0x%x------\n", dwAddress + FIELD_OFFSET(DFS_PKT_ENTRY, Id));
        IPRINTSTRINGW("Prefix: ", &pDfsPktEntry->Id.Prefix, TRUE);
        IPRINTSTRINGW("ShortPrefix:", &pDfsPktEntry->Id.Prefix, TRUE);
        IPRINTF( "-------------------------------\n");

        IPRINTF( "---DFS_PKT_ENTRY_INFO@0x%x-----\n", dwAddress + FIELD_OFFSET(DFS_PKT_ENTRY, Info));
        IPRINTF( "Timeout\n", pDfsPktEntry->Info.Timeout);
        IPRINTF( "ServiceList (%d services)\n", pDfsPktEntry->Info.ServiceCount);
        Indent++;
        MyDumpServices((ULONG_PTR)pDfsPktEntry->Info.ServiceList, pDfsPktEntry->Info.ServiceCount);
        Indent--;
        IPRINTF( "-------------------------------\n");
        IPRINTF( "ActiveService:\n");
        Indent++;
        MyDumpServices((ULONG_PTR)pDfsPktEntry->ActiveService, 1);
        Indent--;
        IPRINTF( "LocalService:\n");
        Indent++;
        MyDumpServices((ULONG_PTR)pDfsPktEntry->LocalService, 1);
        Indent--;
        IPRINTF( "-------------------------------\n");
        Indent--;
        IPRINTF( "-------------------------------\n");
    }
}

VOID
MyDumpServices(ULONG_PTR dwAddress, ULONG ServiceCount)
{
    PDFS_SERVICE pDfsService;
    BYTE DataBuffer[sizeof(DFS_SERVICE) * 32];
    ULONG i;

    pDfsService = (PDFS_SERVICE) DataBuffer;
    if (wGetData(dwAddress,pDfsService,sizeof(DFS_SERVICE) * ServiceCount)) {

        for (i = 0; i < ServiceCount; i++) {

            if (CheckControlC())
                return;
            IPRINTF( "----DFS_SERVICE@0x%x---\n", dwAddress);
            IPRINTSTRINGW("Service:", &pDfsService[i].Address, TRUE);
            IPRINTF( "-----------------------\n");
            dwAddress += sizeof(DFS_SERVICE);
        }
    }
}

VOID
MyDumpLocalVolEntry(ULONG_PTR dwPrefixTableEntry)
{
    PDFS_LOCAL_VOL_ENTRY pDfsLocalVolEntry;
    BYTE DataBuffer[sizeof(DFS_LOCAL_VOL_ENTRY)];
    ULONG_PTR dwAddress;

    dwAddress = dwPrefixTableEntry - FIELD_OFFSET(DFS_LOCAL_VOL_ENTRY, PrefixTableEntry);
    pDfsLocalVolEntry = (PDFS_LOCAL_VOL_ENTRY) DataBuffer;
    if (wGetData(dwAddress,pDfsLocalVolEntry,sizeof(DFS_LOCAL_VOL_ENTRY))) {
        IPRINTF( "---------DFS_LOCAL_VOL_ENTRY@0x%x-----\n", dwAddress);
        IPRINTSTRINGW("LocalPath:", &pDfsLocalVolEntry->LocalPath, TRUE);
        IPRINTSTRINGW("ShareName:", &pDfsLocalVolEntry->ShareName, TRUE);
        Indent++;
        MyDumpPktEntry(
            (ULONG_PTR) pDfsLocalVolEntry->PktEntry +
                FIELD_OFFSET(DFS_PKT_ENTRY, PrefixTableEntry)
            );
        Indent--;
        IPRINTF( "--------------------------------------\n", dwAddress);
    }
}


/*
 * dumpVdo : Routine suitable as argument to dumplist; used to dump list of
 *      Vdos
 */

void dumpVdo(
    ULONG_PTR dwAddress
)
{
    DFS_VOLUME_OBJECT dfsVdo;

    if (wGetData( dwAddress, &dfsVdo, sizeof(dfsVdo) )) {
        PRINTF( "\nVDO @ %08lx\n", dwAddress);
        PrintStructFields( dwAddress, &dfsVdo, DfsVolumeObjectFields );
    } else {
        PRINTF( "\nUnable to read VDO @%08lx\n", dwAddress);
    }
}

/*
 * dumpSpcInfo : Routine suitable as argument to dumplist; used to dump list of
 *      DFS_SPECIAL_INFO's
 */

void dumpSpcInfo(
    ULONG_PTR dwAddress
)
{
    ULONG_PTR dwName;
    DFS_SPECIAL_INFO dfsSpcInfo;
    LONG i;
    UNICODE_STRING uStr;

    if (wGetData( dwAddress, &dfsSpcInfo, sizeof(dfsSpcInfo) )) {
        PRINTF( "    DFS_SPECIAL_INFO @ %08lx\n", dwAddress);
        PRINTF( "\tExpireTime: 0x%08x:0x%08x\n",
            dfsSpcInfo.ExpireTime.HighPart,
            dfsSpcInfo.ExpireTime.LowPart);
        PRINTF( "\tFlags: 0x%08x\n", dfsSpcInfo.Flags, TRUE);
        PRINTF( "\tTrustDirection: 0x%08x\n", dfsSpcInfo.TrustDirection, TRUE);
        PRINTF( "\tTrustType: 0x%08x\n", dfsSpcInfo.TrustType, TRUE);
        PRINTF( "\tTypeFlags: 0x%08x\n", dfsSpcInfo.TypeFlags, TRUE);
        PRINTF( "\tNameCount: %d\n", dfsSpcInfo.NameCount, TRUE);
        wPrintStringW("\tSpecialName:", &dfsSpcInfo.SpecialName, TRUE);
        dwName = dwAddress + FIELD_OFFSET(DFS_SPECIAL_INFO, Name[0]);
        for (i = 0; i < dfsSpcInfo.NameCount; i++) {
            if (CheckControlC())
                return;
            wGetData(dwName, &uStr, sizeof(UNICODE_STRING));
            wPrintStringW("\t\tName:", &uStr, TRUE);
            dwName += sizeof(UNICODE_STRING);
        }
    } else {
        PRINTF( "Unable to read DFS_SITE_INFO @%08lx\n", dwAddress);
    }
}

/*
 * dumpSiteInfo : Routine suitable as argument to dumplist; used to dump list of
 *      DFS_SITE_INFO's
 */

void dumpSiteInfo(
    ULONG_PTR dwAddress
)
{
    ULONG_PTR dwSiteName;
    DFS_SITE_INFO dfsSiteInfo;
    ULONG i;
    UNICODE_STRING uStr;

    if (wGetData( dwAddress, &dfsSiteInfo, sizeof(dfsSiteInfo) )) {
        PRINTF( "    DFS_SITE_INFO @ %08lx\n", dwAddress);
        wPrintStringW("\tServerName:", &dfsSiteInfo.ServerName, TRUE);
        dwSiteName = dwAddress + FIELD_OFFSET(DFS_SITE_INFO, SiteName[0]);
        for (i = 0; i < dfsSiteInfo.SiteCount; i++) {
            wGetData(dwSiteName, &uStr, sizeof(UNICODE_STRING));
            wPrintStringW("\t\tName:", &uStr, TRUE);
            dwSiteName += sizeof(UNICODE_STRING);
        }
    } else {
        PRINTF( "Unable to read DFS_SITE_INFO @%08lx\n", dwAddress);
    }
}

/*
 * dumpIpInfo : Routine suitable as argument to dumplist; used to dump list of
 *      DFS_IP_INFO's
 */

void dumpIpInfo(
    ULONG_PTR dwAddress
)
{
    DFS_IP_INFO dfsIpInfo;
    ULONG IpAddress;

    if (wGetData( dwAddress, &dfsIpInfo, sizeof(dfsIpInfo) )) {
        IpAddress = *((ULONG *)&dfsIpInfo.IpAddress.IpData);
        PRINTF( "    DFS_IP_INFO @ %08lx\n", dwAddress);
        PRINTF( "\tIpAddress: %d.%d.%d.%d\n",
                IpAddress & 0xff,
                (IpAddress >> 8) & 0xff,
                (IpAddress >> 16) & 0xff,
                (IpAddress >> 24) & 0xff);
        wPrintStringW("\tSiteName: ", &dfsIpInfo.SiteName, TRUE);
    } else {
        PRINTF( "Unable to read DFS_SITE_INFO @%08lx\n", dwAddress);
    }
}

/*
 * dumplist : A general-purpose routine to dump a list of structures
 *
 */

VOID
dumplist(
    ULONG_PTR dwListEntryAddress,
    DWORD linkOffset,
    VOID (*dumpRoutine)(ULONG_PTR dwStructAddress)
)
{
    LIST_ENTRY listHead, listNext;
    ULONG max_list_entry = MAX_ENTRIES;
    //
    // Get the value in the LIST_ENTRY at dwAddress
    //

    PRINTF( "Dumping list @ %08lx\n", dwListEntryAddress );

    if (wGetData(dwListEntryAddress, &listHead, sizeof(LIST_ENTRY))) {

        ULONG_PTR dwNextLink = (ULONG_PTR) listHead.Flink;
        ULONG_PTR dwNextdupLink = (ULONG_PTR) listHead.Flink;
        ULONG loop_count = 0;

        if (dwNextLink == 0) {
            PRINTF( "Uninitialized list!\n" );
        } else if (dwNextLink == dwListEntryAddress) {
            PRINTF( "Empty list!\n" );
        } else {
            while( dwNextLink != dwListEntryAddress) {
                ULONG_PTR dwStructAddress;

                if (CheckControlC())
                        return;

                dwStructAddress = dwNextLink - linkOffset;

                dumpRoutine(dwStructAddress);

                if (wGetData( dwNextLink, &listNext, sizeof(LIST_ENTRY))) {
                    dwNextLink = (ULONG_PTR) listNext.Flink;
                } else {
                    PRINTF( "Unable to get next item @%08lx\n", dwNextLink );
                    break;
                }
		if (++loop_count > max_list_entry) {
		  PRINTF( "Dumped maximum %d entries... aborting\n", loop_count);
		  break;
		}
            }
        }

    } else {

        PRINTF( "Unable to read list head @ %08lx\n", dwListEntryAddress);

    }

}

VOID
DoIndent(VOID)
{
    INT i;

    for (i = 0; i < 2 * Indent; i++)
        PRINTF(" ");
}



VOID
PrintStructFields( ULONG_PTR dwAddress, VOID *ptr, FIELD_DESCRIPTOR *pFieldDescriptors )
{
    int i;
    WCHAR wszBuffer[80];

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            PRINTF( "%-17s...%s ", pFieldDescriptors->Name, pFieldDescriptors->Name+strlen(pFieldDescriptors->Name)-10 );
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        switch( pFieldDescriptors->FieldType ) {
        case FieldTypeByte:
        case FieldTypeChar:
           PRINTF( "%-16d%s",
               *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
               NewLineForFields(i) );
           break;
        case FieldTypeBoolean:
           PRINTF( "%-16s%s",
               *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
               NewLineForFields(i));
           break;
        case FieldTypeBool:
            PRINTF( "%-16s%s",
                *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                NewLineForFields(i));
            break;
        case FieldTypePointer:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULong:
        case FieldTypeLong:
            PRINTF( "%-16d%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeShort:
            PRINTF( "%-16X%s",
                *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShort:
            PRINTF( "%-16X%s",
                *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeGuid:
            PrintGuid( (GUID *)(((char *)ptr) + pFieldDescriptors->Offset) );
            PRINTF( NewLine );
            break;
        case FieldTypePWStr:
            if (wGetString( (ULONG_PTR)(((char *)ptr) + pFieldDescriptors->Offset), (char *)wszBuffer )) {
                PRINTF( "%ws", wszBuffer );
            } else {
                PRINTF( "Unable to get string at %08lx", (ULONG_PTR)(((char *)ptr) + pFieldDescriptors->Offset));
            }
            PRINTF( NewLine );
            break;
        case FieldTypeUnicodeString:
            wPrintStringW( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), 0 );
            PRINTF( NewLine );
            break;
        case FieldTypeAnsiString:
            wPrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), 0 );
            PRINTF( NewLine );
            break;
        case FieldTypeSymbol:
            {
                UCHAR SymbolName[ 200 ];
                ULONG Displacement;
                PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ));

                GetSymbol(sym, SymbolName, (ULONG_PTR *)&Displacement );
                PRINTF( "%-16s%s",
                        SymbolName,
                        NewLineForFields(i) );
            }
            break;
        case FieldTypeEnum:
            {
               ULONG EnumValue;
               ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
               // Get the associated numerical value.

               EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                    != NULL) {
                   //
                   // An auxilary textual description of the value is
                   // available. Display it instead of the numerical value.
                   //

                   LPSTR pEnumName = NULL;

                   while (pEnumValueDescr->EnumName != NULL) {
                       if (EnumValue == pEnumValueDescr->EnumValue) {
                           pEnumName = pEnumValueDescr->EnumName;
                           break;
                       }
                       pEnumValueDescr++;
                   }

                   if (pEnumName != NULL) {
                       PRINTF( "%-16s ", pEnumName );
                   } else {
                       PRINTF( "%-4d (%-10s) ", EnumValue,"Unknown!");
                   }

               } else {
                   //
                   // No auxilary information is associated with the ehumerated type
                   // print the numerical value.
                   //
                   PRINTF( "%-16d",EnumValue);
               }
               PRINTF( NewLineForFields(i) );
            }
            break;

        case FieldTypeByteBitMask:
        case FieldTypeWordBitMask:
        case FieldTypeDWordBitMask:
            {
               BOOL fFirstFlag;
               ULONG BitMaskValue;
               BIT_MASK_DESCRIPTOR *pBitMaskDescr;

               BitMaskValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               PRINTF("%-8x ", BitMaskValue);
               PRINTF( NewLineForFields(i) );

               pBitMaskDescr = pFieldDescriptors->AuxillaryInfo.pBitMaskDescriptor;
               fFirstFlag = TRUE;
               if (BitMaskValue != 0 && pBitMaskDescr != NULL) {
                   while (pBitMaskDescr->BitmaskName != NULL) {
                       if ((BitMaskValue & pBitMaskDescr->BitmaskValue) != 0) {
                           if (fFirstFlag) {
                               fFirstFlag = FALSE;
                               PRINTF("      ( %-s", pBitMaskDescr->BitmaskName);
                           } else {
                               PRINTF( " |\n" );
                               PRINTF("        %-s", pBitMaskDescr->BitmaskName);

                           }
                       }
                       pBitMaskDescr++;
                   }
                   PRINTF(" )");
                   PRINTF( NewLineForFields(i) );
               }
            }
            break;

        case FieldTypeStruct:
            PRINTF( "@%-15X%s",
                (dwAddress + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeLargeInteger:
            wPrintLargeInt( (LARGE_INTEGER *)(((char *)ptr) + pFieldDescriptors->Offset) );
            PRINTF( NewLine );
            break;
        case FieldTypeFileTime:
        default:
            dprintf( "Unrecognized field type %c for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
            break;
        }
    }
}


#define NAME_DELIMITER '@'
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    ULONG               ArgumentLength = strlen(lpArgument);
    BOOLEAN           fAmbiguous = FALSE;


    while ((pStructs->StructName != 0)) {
        ULONG StructLength;
        StructLength = strlen(pStructs->StructName);
        if (StructLength >= ArgumentLength) {
            int Result = _strnicmp(
                            lpArgument,
                            pStructs->StructName,
                            ArgumentLength);

            if (Result == 0) {
                if (StructLength == ArgumentLength) {
                    // Exact match. They must mean this struct!
                    fAmbiguous = FALSE;
                    NameIndex = i;
                    break;
                } else if (NameIndex != INVALID_INDEX) {
                    // We have encountered duplicate matches. Print out the
                    // matching strings and let the user disambiguate.
                   fAmbiguous = TRUE;
                   break;
                } else {
                   NameIndex = i;
                }
            }
        }
        pStructs++;i++;
    }

    if (fAmbiguous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (_strnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(strlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}

#define NAME_DELIMITERS "@"

DECLARE_API( dump )
{
    ULONG_PTR dwAddress;

    //SETCALLBACKS();

    if( args && *args ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = (PSTR)args;
        LPSTR lpArgs = strpbrk(args, NAME_DELIMITERS);
        ULONG Index;

        if (lpArgs) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            for (;*lpName==' ';) { lpName++; } //skip leading blanks

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {
                BYTE DataBuffer[512];

                dwAddress = GetExpression( ++lpArgs );
                if (wGetData(dwAddress,DataBuffer,Structs[Index].StructSize)) {

                    PRINTF(
                        "++++++++++++++++ %s@%lx ++++++++++++++++\n",
                        Structs[Index].StructName,
                        dwAddress);
                    PrintStructFields(
                        dwAddress,
                        &DataBuffer,
                        Structs[Index].FieldDescriptors);
                    PRINTF(
                        "---------------- %s@%lx ----------------\n",
                        Structs[Index].StructName,
                        dwAddress);
                } else {
                    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                }
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
        }
    } else {
        //
        // display the list of structs currently handled.
        //

        DisplayStructs();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\util\dfskd\kdextlib.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.h

Abstract:

    Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created
    21-Aug-1995 Milans  Copied for use in Mup Kernel Extensions

--*/

#ifndef _KDEXTLIB_H_
#define _KDEXTLIB_H_

#include <windef.h>

//
// The help strings printed out
//

extern LPSTR ExtensionNames[];

extern LPSTR Extensions[];

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// The task of generating these descriptors by augmenting the front end, but that will have to
// wait till we play around with these extensions and modify the data structures to meet most
// of the requirements.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.
//
// There are certain conventions that have been adopted to ease the definition of the macros
// as well as facilitate the automation of the generation of these descriptors.
// These are as follows ....
//
// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef struct _BIT_MASK_DESCRIPTOR {
    ULONG   BitmaskValue;
    LPSTR   BitmaskName;
} BIT_MASK_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeLong,
    FieldTypeUShort,
    FieldTypeShort,
    FieldTypeGuid,
    FieldTypePointer,
    FieldTypePWStr,
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeFileTime
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    USHORT           Offset;      // The offset of the field in the structure
    union {
        VOID                   *pDescriptor;     // Generic Auxillary information - used by Field4 macro
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
        BIT_MASK_DESCRIPTOR *pBitMaskDescriptor; // Auxillary information for bitmasks.
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , (USHORT) FIELD_OFFSET(StructureName,FieldName) ,NULL}

#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,(VOID *) AuxInfo}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRITOR_ {
    LPSTR             StructName;
    ULONG             StructSize;
    FIELD_DESCRIPTOR  *FieldDescriptors;
} STRUCT_DESCRIPTOR;

#define STRUCT(StructTypeName,FieldDescriptors) \
        { #StructTypeName,sizeof(StructTypeName),FieldDescriptors}

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

#define    SETCALLBACKS() \
    lpOutputRoutine = lpExtensionApis->lpOutputRoutine; \
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine; \
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine; \
    lpReadMemoryRoutine = lpExtensionApis->lpReadVirtualMemRoutine;


VOID
PrintStructFields(
    ULONG_PTR dwAddress,
    VOID *ptr,
    FIELD_DESCRIPTOR *pFieldDescriptors
);

BOOL
PrintStringW(
    LPSTR msg,
    PUNICODE_STRING puStr,
    BOOL nl
);

BOOLEAN
GetData(
    ULONG_PTR dwAddress,
    PVOID ptr,
    ULONG size
);
BOOL
PrintGuid(
    GUID *pguid);
extern ULONG s_NoOfColumns;


#endif // _KDEXTLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\util\dfskd\wdbgxlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    wdbgxlib.c

Abstract:

    This module realizes most of the routines needed for the rdbss/smbmini debugger extension.

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created
    11-Nov-1995         Changed to newer windbg apis

--*/


#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>




WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

BOOL
wPrintStringW( IN LPSTR msg OPTIONAL, IN PUNICODE_STRING pStr, IN BOOL nl )
{
    UNICODE_STRING NewStr;

    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    NewStr.Buffer = (WCHAR *)LocalAlloc( LPTR, pStr->Length + 1 );
    NewStr.Length = pStr->Length;
    NewStr.MaximumLength = pStr->Length+1;
    if( NewStr.Buffer == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               NewStr.Buffer,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        dprintf("%wZ%s", &NewStr, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)NewStr.Buffer);

    return BytesRead;
}



/*
 * Fetches the data at the given address
 */
BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size)
{
    BOOL b;
    ULONG BytesRead;

    b = ReadMemory( dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        dprintf( "Unable to read %u bytes at %X, for %s\n", size, dwAddress);
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
wGetString( ULONG_PTR dwAddress, PSZ buf )
{
    for(;;) {
        if( !wGetData( dwAddress,buf, 1) ){
            //dprintf("readfailure at %08lx\n",dwAddress);
            return FALSE;
        }

        //dprintf ("stringing %08lx %08lx %c\n", dwAddress, buf,
        //                                     ((*buf==0)?'.':*buf) );

        if ( *buf == '\0' ) { break; }

        dwAddress++;
        buf++;

    };

    return TRUE;
}

#if 0
/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
wGetData_srv( IN LPVOID ptr, IN ULONG_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    while( size > 0 ) {

        count = min( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN ULONG_PTR dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !wGetData_srv( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (ULONG_PTR)ListEntry.Flink == dwListHeadAddr || (ULONG_PTR)ListEntry.Flink == 0 )
            break;

        if( !wGetData_srv( &ListEntry, (ULONG_PTR)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (ULONG_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}
#endif

/*
 * Print out a single HEX character
 */
VOID
wPrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
wPrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        wPrintHexChar( *buf++ );
        dprintf( " " );
    }
}

#if 0
/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !wGetData_srv( buf, dwAddress, sizeof( *buf ), "UNICODE Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}
#endif

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}


VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}


ULONG FieldOffsetOfContextListEntryInRxC();
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2);
DECLARE_API( dump );



HANDLE DumpFile;
CHAR wwDumpFormat[] = "-%06d:  %s\n";
VOID DumpRoutine(
    ULONG EntryNumber,
    PSZ   OriginalStringToPrint
    )
{
    UCHAR Buffer[200];
    UCHAR StringToPrint[160];
    PUCHAR p,q,r; LONG i;
    ULONG n,l3,l2,l1,l0; UCHAR Numbuf[32];
    ULONG ReturnedSize;

    //dprintf("before %d\n",EntryNumber);
    for (p=OriginalStringToPrint,q=StringToPrint,i=160;;) {
        PSZ format=NULL;

        if (*p==0) break;

        if (*p==0x4) {
            format = "%lx";
        } else if (*p==0x5) {
            format = "%ld";
        } else if (*p < ' ') {
            p++;i--;continue;
        }

        if (format!=NULL) {
            LONG Length;
            //translate the number
            p++;
            l0=*p++;
            l1=(*p++)<<8;
            l2=(*p++)<<16;
            l3=(*p++)<<24;
            n = l0 + l1 + l2 + l3;
            //dprintf("yaya %d %08lx %08lx %08lx %08lx %08lx\n",n,n,l0,l1,l2,l3);
            Length = sprintf(Numbuf,format,n);
            if (Length <= i) {
                for (r=Numbuf;*r;) { *q++ = *r++; }
                i -= Length;
            } else {
                i = 0;
            }
            if (i>0) continue;
        }
        if (i<=0) break;
        *q++ = *p++; i--;
    }
    *q = 0;

    //dprintf("after %d\n",EntryNumber);
    if (DumpFile == INVALID_HANDLE_VALUE) {
        dprintf(wwDumpFormat,EntryNumber,StringToPrint);
        return;
    }
    sprintf(Buffer,wwDumpFormat,EntryNumber,StringToPrint);
    WriteFile(DumpFile,Buffer,strlen(Buffer),&ReturnedSize,NULL);
    //should i check??
    return;
}




PCWSTR   ExtensionLib   = NULL;
HANDLE   hExtensionMod  = NULL;
ULONG    DebugeeArchitecture = 0;

PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture);


DECLARE_API( dump );

DECLARE_API( flags )
{
    ULONG i,mask,newline,value;

    if( args && *args ) {
        sscanf(args,"%lx",&value);
        dprintf("Flags for %08lx\n",value);
    } else {
        dprintf("error in flags: no value presented\n");
        return;
    }

    for (i=newline=0,mask=1;i<32;i++,mask<<=1) {
        if (value&mask) {
            dprintf("    %02d 0x%08lx%c",i,mask,(newline==0)?' ':'\n');
            newline ^= 1;
        }
    }
    if (newline) {
        dprintf("\n");
    }
}

VOID dprintfsprintfbuffer(BYTE *Buffer)
{
    dprintf("%s\n",Buffer);
}

BOOL
wPrintLargeInt(
    LARGE_INTEGER *bigint)
{
    dprintf( "%08x:%08x", bigint->HighPart, bigint->LowPart);
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\efs\create.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   create.c

Abstract:

   This module will handle the IRP_MJ_CREATE (and all associated support
   routines) requests.

Author:

    Robert Gu (robertg) 29-Oct-1996
Environment:

   Kernel Mode Only

Revision History:

--*/

#include "efs.h"
#include "efsrtl.h"
#include "efsext.h"


#ifdef ALLOC_PRAGMA
//
// cannot make this code paged because of calls to
// virtual memory functions.
//
//#pragma alloc_text(PAGE, EFSFilePostCreate)
//#pragma alloc_text(PAGE, EFSPostCreate)
//
#endif


NTSTATUS
EFSFilePostCreate(
    IN PDEVICE_OBJECT VolDo,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN NTSTATUS Status,
    IN OUT PVOID *PCreateContext
    )
{
    PEFS_CONTEXT    pEfsContext;
    KIRQL savedIrql;
    NTSTATUS EfsStatus = STATUS_SUCCESS;


    PAGED_CODE();

    if (!PCreateContext) {
        return Status;
    }

    pEfsContext = *PCreateContext;

    if (( NT_SUCCESS( Status ) && (Status != STATUS_PENDING) && (Status != STATUS_REPARSE))
        && pEfsContext){

        if ( NO_FURTHER_PROCESSING != pEfsContext->Status ){

            PIO_STACK_LOCATION irpSp;

            irpSp = IoGetCurrentIrpStackLocation( Irp );


#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){

        DbgPrint( " EFSFILTER: Begin post create. \n" );

    }
#endif

            if ((pEfsContext->EfsStreamData) &&
                   (EFS_STREAM_TRANSITION == ((PEFS_STREAM)(pEfsContext->EfsStreamData))->Status)) {

                PSID    SystemSid;
                SID_IDENTIFIER_AUTHORITY    IdentifierAuthority = SECURITY_NT_AUTHORITY;

                //
                // $EFS indicates transition state.
                // Only the system can open it
                //

                SystemSid = ExAllocatePoolWithTag(
                                        PagedPool,
                                        RtlLengthRequiredSid(1),
                                        'msfE'
                                        );

                if ( SystemSid ){

                    EfsStatus = RtlInitializeSid( SystemSid, &IdentifierAuthority, (UCHAR) 1 );

                    if ( NT_SUCCESS(EfsStatus) ){

                        PACCESS_TOKEN accessToken = NULL;
                        PTOKEN_USER UserId = NULL;

                        *(RtlSubAuthoritySid(SystemSid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;

                        //
                        // We got the system SID. Now try to get the caller's SID.
                        //

                        accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken;
                        if(!accessToken) {
                            accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
                        }
                        if ( accessToken ){

                            //
                            // Get User ID
                            //

                            EfsStatus = SeQueryInformationToken(
                                accessToken,
                                TokenUser,
                                &UserId
                            );

                            if ( NT_SUCCESS(EfsStatus) ){

                                //
                                // Got the user SID
                                //

                                if ( !RtlEqualSid ( SystemSid, UserId->User.Sid) ) {

                                    EfsStatus = STATUS_ACCESS_DENIED;

                                }
                            }

                            ExFreePool( UserId );

                        } else {
                            //
                            // Cannot get the user token
                            //

                            EfsStatus = STATUS_ACCESS_DENIED;

                        }

                    }

                    ExFreePool( SystemSid );

                } else {

                    EfsStatus = STATUS_INSUFFICIENT_RESOURCES;

                }

            } else {
                //
                // $EFS in normal status
                // Set Key Blob and/or write $EFS
                //
                // Legacy problem, The fourth parameter of EfsPostCreate (OpenType)
                // was used to indicate a recovery open. The design was changed. Now
                // this parameter is not used. It is not worth to take out the parameter
                // now. This will need to change several modules, EFS.SYS, KSECDD.SYS
                // SEcur32.lib and LSASRV.DLL. We might just leave it as reserved for future use.
                // To speed up a little bit, pass in 0.
                //

                EfsStatus = EFSPostCreate(
                                VolDo,
                                Irp,
                                pEfsContext,
                                0
                                );

            }
        }

    }

    if (pEfsContext){

        //
        // Release memory if necessary
        //

        *PCreateContext = NULL;
        if ( pEfsContext->EfsStreamData ) {

            ExFreePool(pEfsContext->EfsStreamData);
            pEfsContext->EfsStreamData = NULL;

        }

        ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEfsContext );
    }

    if (!NT_SUCCESS(EfsStatus)) {
        return EfsStatus;
    }

    return Status; // If EFS operation succeeded, just return the original status code.

}



NTSTATUS
EFSPostCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PEFS_CONTEXT EfsContext,
    IN ULONG OpenType
    )

/*++

Routine Description:

    This function calls the EFS server to get FEK, $EFS, set Key Blob and or write $EFS.

    We could not use user's space to talk to LSA so we need to attach to LSA to allocate

    memory in LSA space. We could cause APC dead lock if we call LSA while attached to LSA.

    We need to detach before calling LSA and reattach to get data back from LSA.

Arguments:

    DeviceObject - Pointer to the target device object.

    Irp - Pointer to the I/O Request Packet that represents the operation.

    EfsContext - A context block associated with the file object.

    OpenType - File create(open) option

    IrpContext - NTFS internal data

    FileHdl - NTFS internal data

    AttributeHandle - NTFS internal data


--*/
{
    PEFS_KEY fek = NULL;
    PEFS_DATA_STREAM_HEADER efsStream = NULL;
    PVOID currentEfsStream = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PVOID bufferBase = NULL;
    ULONG currentEfsStreamLength = 0;
    ULONG bufferLength;
    SIZE_T regionSize = 0;
    PACCESS_TOKEN accessToken = NULL;
    PTOKEN_USER UserId = NULL;
    GUID *EfsId = NULL;
    HANDLE  CrntProcess = NULL;
    BOOLEAN ProcessAttached = FALSE;
    BOOLEAN ProcessNeedAttach = FALSE;
    SECURITY_IMPERSONATION_LEVEL  ImpersonationLevel = SecurityImpersonation;
    KAPC_STATE  ApcState;
/*
    PIO_SECURITY_CONTEXT sContext;
    sContext = irpSp->Parameters.Create.SecurityContext;
    DbgPrint( "\n PostCreate: Desired Access %x\n", sContext->DesiredAccess );
    DbgPrint( "\n PostCreate: Orginal Desired Access %x\n", sContext->AccessState->OriginalDesiredAccess );
    DbgPrint( "\n PostCreate: PrevGrant Access %x\n", sContext->AccessState->PreviouslyGrantedAccess );
    DbgPrint( "\n PostCreate: Remaining Desired Access %x\n", sContext->AccessState->RemainingDesiredAccess );
*/
    //
    //  Check if we can use the cache to verify the open
    //

    if ( !(EfsContext->Status & NO_OPEN_CACHE_CHECK) ){

        if ( irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken ){
            accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken;
            ImpersonationLevel = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ImpersonationLevel;
        } else {
            accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
        }

        if ( accessToken ){

            //
            // Get User ID
            //

            status = SeQueryInformationToken(
                accessToken,
                TokenUser,
                &UserId
            );

            if ( NT_SUCCESS(status) ){

                if ( EfsFindInCache(
                        &((( PEFS_DATA_STREAM_HEADER ) EfsContext->EfsStreamData)->EfsId),
                        UserId
                        )) {

                    ExFreePool( UserId );
#if DBG
    if ( (EFSTRACEALL ) & EFSDebug ){
        DbgPrint( " EFS:Open with cache. \n" );
    }
#endif
                    return ( STATUS_SUCCESS );
                }
            }

            //
            //  UserId will be freed later
            //

        }

        //
        //  Check cache failure should not block the normal operations
        //

        status = STATUS_SUCCESS;
    }

    //
    // Clear the cache bit
    //

    EfsContext->Status &= ~NO_OPEN_CACHE_CHECK;

    //
    // Check if it is ACCESS_ATTRIBUTE ONLY
    //

    if ( !( irpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess &
            ( FILE_APPEND_DATA | FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE )) &&
          ( EfsContext->Status & TURN_ON_ENCRYPTION_BIT ) &&
          ( !(EfsContext->Status & (NEW_FILE_EFS_REQUIRED | NEW_DIR_EFS_REQUIRED)))){

        //
        //  A new stream is to be created without data access required. We might not
        //  have the keys to decrypt the $EFS. We just need to turn on the bit here.
        //  Changed the real action required.
        //  Free the memory not required by this action.
        //
#if DBG
    if ( (EFSTRACEALL ) & EFSDebug ){
        DbgPrint( " EFS:Open accessing attr only. \n" );
    }
#endif

        if (EfsContext->EfsStreamData){
            ExFreePool(EfsContext->EfsStreamData);
            EfsContext->EfsStreamData = NULL;
        }
        EfsContext->Status = TURN_ON_ENCRYPTION_BIT | TURN_ON_BIT_ONLY ;

    } else if ( !(EfsContext->Status & TURN_ON_BIT_ONLY) ) {

        if (accessToken == NULL){
            if ( irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken ){
                accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken;
                ImpersonationLevel = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ImpersonationLevel;
            } else {
                accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
            }

            //
            // Get User ID
            //

            status = SeQueryInformationToken(
                accessToken,
                TokenUser,
                &UserId
                );

            if (!NT_SUCCESS(status)) {

               //
               // Do not refresh the cache
               //

               UserId = NULL;
               status = STATUS_SUCCESS;
            }

        }

        //
        // Allocate virtual memory.
        // Move the $EFS to virtual memory, LPC requires this.
        //

        if ( PsGetCurrentProcess() != EfsData.LsaProcess ){

            ProcessNeedAttach = TRUE;

            status = ObReferenceObjectByPointer(
                        EfsData.LsaProcess,
                        0,
                        NULL,
                        KernelMode);

            if ( NT_SUCCESS(status) ) {
                KeStackAttachProcess (
                    EfsData.LsaProcess,
                    &ApcState
                    );
                ProcessAttached = TRUE;
            }

        }

        CrntProcess = NtCurrentProcess();

        if ( NT_SUCCESS(status) ) {
            if (EfsContext->EfsStreamData){
                regionSize = currentEfsStreamLength = * (ULONG*)(EfsContext->EfsStreamData);

                status = ZwAllocateVirtualMemory(
                            CrntProcess,
                            (PVOID *) &currentEfsStream,
                            0,
                            &regionSize,
                            MEM_COMMIT,
                            PAGE_READWRITE
                            );
            }
        }
    }

    if ( NT_SUCCESS(status) ){

        BOOLEAN OldCopyOnOpen;
        BOOLEAN OldEffectiveOnly;
        SECURITY_IMPERSONATION_LEVEL OldImpersonationLevel;
        PACCESS_TOKEN OldClientToken;


        OldClientToken = PsReferenceImpersonationToken(
                            PsGetCurrentThread(),
                            &OldCopyOnOpen,
                            &OldEffectiveOnly,
                            &OldImpersonationLevel
                            );

        if ( EfsContext->Status  != (TURN_ON_ENCRYPTION_BIT | TURN_ON_BIT_ONLY)  &&
                ( NULL != currentEfsStream) ){

            RtlCopyMemory(
                    currentEfsStream,
                    EfsContext->EfsStreamData,
                    currentEfsStreamLength
                    );

            //
            // Free the memory first to increase chance of getting new memory
            //

            ExFreePool(EfsContext->EfsStreamData);
            EfsContext->EfsStreamData = NULL;
        }

        //
        // Detach process before calling user mode
        //

        if (ProcessAttached){
            KeUnstackDetachProcess(&ApcState);
            ProcessAttached = FALSE;
        }

        switch ( EfsContext->Status & ACTION_REQUIRED){
            case VERIFY_USER_REQUIRED:

                PsImpersonateClient(
                    PsGetCurrentThread(),
                    accessToken,
                    TRUE,
                    TRUE,
                    ImpersonationLevel
                    );

                //
                // Call service to verify the user
                //

                status = EfsDecryptFek(
                    &fek,
                    (PEFS_DATA_STREAM_HEADER) currentEfsStream,
                    currentEfsStreamLength,
                    OpenType,
                    &efsStream,
                    &bufferBase,
                    &bufferLength
                    );

                if ( OldClientToken ) {
                    PsImpersonateClient(
                        PsGetCurrentThread(),
                        OldClientToken,
                        OldCopyOnOpen,
                        OldEffectiveOnly,
                        OldImpersonationLevel
                        );
                    PsDereferenceImpersonationToken(OldClientToken);
                } else {
                    PsRevertToSelf( );
                }

                break;

            case NEW_FILE_EFS_REQUIRED:
                //
                // Call service to get new FEK, $EFS
                //

                if (EfsContext->Flags & SYSTEM_IS_READONLY) {
                    ASSERT(FALSE);
                    status = STATUS_MEDIA_WRITE_PROTECTED;
                    if ( OldClientToken ) {
                        PsDereferenceImpersonationToken(OldClientToken);
                    }
                    break;
                }

                PsImpersonateClient(
                    PsGetCurrentThread(),
                    accessToken,
                    TRUE,
                    TRUE,
                    ImpersonationLevel
                    );

               status = EfsGenerateKey(
                              &fek,
                              &efsStream,
                              (PEFS_DATA_STREAM_HEADER) currentEfsStream,
                              currentEfsStreamLength,
                              &bufferBase,
                              &bufferLength
                              );

               if ( OldClientToken ) {
                   PsImpersonateClient(
                       PsGetCurrentThread(),
                       OldClientToken,
                       OldCopyOnOpen,
                       OldEffectiveOnly,
                       OldImpersonationLevel
                       );
                   PsDereferenceImpersonationToken(OldClientToken);
                } else {
                    PsRevertToSelf( );
                }
                break;

            case NEW_DIR_EFS_REQUIRED:
                //
                // Call service to get new $EFS
                //

                if (EfsContext->Flags & SYSTEM_IS_READONLY) {
                    ASSERT(FALSE);
                    status = STATUS_MEDIA_WRITE_PROTECTED;
                    if ( OldClientToken ) {
                        PsDereferenceImpersonationToken(OldClientToken);
                    }
                    break;
                }

                PsImpersonateClient(
                    PsGetCurrentThread(),
                    accessToken,
                    TRUE,
                    TRUE,
                    ImpersonationLevel
                    );

                status = GenerateDirEfs(
                              (PEFS_DATA_STREAM_HEADER) currentEfsStream,
                              currentEfsStreamLength,
                              &efsStream,
                              &bufferBase,
                              &bufferLength
                              );

                if ( OldClientToken ) {
                    PsImpersonateClient(
                        PsGetCurrentThread(),
                        OldClientToken,
                        OldCopyOnOpen,
                        OldEffectiveOnly,
                        OldImpersonationLevel
                        );
                    PsDereferenceImpersonationToken(OldClientToken);
                } else {
                    PsRevertToSelf( );
                }
                break;

            case TURN_ON_BIT_ONLY:
                //
                // Fall through intended
                //

            default:

                if ( OldClientToken ) {
                    PsDereferenceImpersonationToken(OldClientToken);
                }

                break;
        }


        if ( ProcessNeedAttach ){

            KeStackAttachProcess (
                EfsData.LsaProcess,
                &ApcState
                );
            ProcessAttached = TRUE;

        }

        if (fek && (fek->Algorithm == CALG_3DES) && !EfsData.FipsFunctionTable.Fips3Des3Key ) {

            //
            // User requested 3des but fips is not available, quit.
            //


            if (bufferBase){
    
                SIZE_T bufferSize;
    
                bufferSize = bufferLength;
                ZwFreeVirtualMemory(
                    CrntProcess,
                    &bufferBase,
                    &bufferSize,
                    MEM_RELEASE
                    );
    
            }
            status = STATUS_ACCESS_DENIED;
        }

        if ( NT_SUCCESS(status) ){

            KEVENT event;
            IO_STATUS_BLOCK ioStatus;
            PIRP fsCtlIrp;
            PIO_STACK_LOCATION fsCtlIrpSp;
            ULONG inputDataLength;
            ULONG actionType;
            ULONG usingCurrentEfs;
            ULONG FsCode;
            PULONG pUlong;

            //
            // We got our FEK, $EFS. Set it with a FSCTL
            // Prepare the input data buffer first
            //

            switch ( EfsContext->Status & ACTION_REQUIRED ){
                case VERIFY_USER_REQUIRED:

                    EfsId =  ExAllocatePoolWithTag(
                                PagedPool,
                                sizeof (GUID),
                                'msfE'
                                );

                    if ( EfsId ){
                        RtlCopyMemory(
                            EfsId,
                            &(((PEFS_DATA_STREAM_HEADER) currentEfsStream)->EfsId),
                            sizeof( GUID ) );
                    }

                    //
                    // Free memory first
                    //
                    ZwFreeVirtualMemory(
                        CrntProcess,
                        &currentEfsStream,
                        &regionSize,
                        MEM_RELEASE
                        );

                    //
                    // Prepare input data buffer
                    //

                    inputDataLength = EFS_FSCTL_HEADER_LENGTH + 2 * EFS_KEY_SIZE( fek );

                    actionType = SET_EFS_KEYBLOB;

                    if ( efsStream && !(EfsContext->Flags & SYSTEM_IS_READONLY)){
                        //
                        // $EFS updated
                        //

                        inputDataLength += *(ULONG *)efsStream;
                        actionType |= WRITE_EFS_ATTRIBUTE;
                    }

                    currentEfsStream = ExAllocatePoolWithTag(
                                PagedPool,
                                inputDataLength,
                                'msfE'
                                );

                    //
                    // Deal with out of memory here
                    //
                    if ( NULL == currentEfsStream ){

                        //
                        // Out of memory
                        //

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;

                    }

                    pUlong = (ULONG *) currentEfsStream;
                    *pUlong = ((PFSCTL_INPUT)currentEfsStream)->CipherSubCode
                                = actionType;

                    ((PFSCTL_INPUT)currentEfsStream)->EfsFsCode = EFS_SET_ATTRIBUTE;

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH,
                        fek,
                        EFS_KEY_SIZE( fek )
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + EFS_KEY_SIZE( fek ),
                        fek,
                        EFS_KEY_SIZE( fek )
                        );

                    if ( efsStream && !(EfsContext->Flags & SYSTEM_IS_READONLY)){

                        RtlCopyMemory(
                            ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                                + 2 * EFS_KEY_SIZE( fek ),
                            efsStream,
                            *(ULONG *)efsStream
                            );

                    }

                    //
                    // Encrypt our Input data
                    //
                    EfsEncryptKeyFsData(
                        currentEfsStream,
                        inputDataLength,
                        sizeof(ULONG),
                        EFS_FSCTL_HEADER_LENGTH + EFS_KEY_SIZE( fek ),
                        EFS_KEY_SIZE( fek )
                        );

                    break;
                case NEW_FILE_EFS_REQUIRED:

                    EfsId =  ExAllocatePoolWithTag(
                                PagedPool,
                                sizeof (GUID),
                                'msfE'
                                );

                    if ( EfsId ){
                        RtlCopyMemory(
                            EfsId,
                            &(efsStream->EfsId),
                            sizeof( GUID ) );
                    }

                    //
                    // Free memory first
                    //

                    if ( currentEfsStream ){
                        ZwFreeVirtualMemory(
                            CrntProcess,
                            &currentEfsStream,
                            &regionSize,
                            MEM_RELEASE
                            );
                    }

                    //
                    // Prepare input data buffer
                    //

                    inputDataLength = EFS_FSCTL_HEADER_LENGTH
                                      + 2 * EFS_KEY_SIZE( fek )
                                      + *(ULONG *)efsStream;

                    currentEfsStream = ExAllocatePoolWithTag(
                                PagedPool,
                                inputDataLength,
                                'msfE'
                                );

                    //
                    // Deal with out of memory here
                    //
                    if ( NULL == currentEfsStream ){

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;

                    }

                    pUlong = (ULONG *) currentEfsStream;
                    *pUlong = ((PFSCTL_INPUT)currentEfsStream)->CipherSubCode
                                            = WRITE_EFS_ATTRIBUTE | SET_EFS_KEYBLOB;

                    ((PFSCTL_INPUT)currentEfsStream)->EfsFsCode = EFS_SET_ATTRIBUTE;

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH,
                        fek,
                        EFS_KEY_SIZE( fek )
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + EFS_KEY_SIZE( fek ),
                        fek,
                        EFS_KEY_SIZE( fek )
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + 2 *  EFS_KEY_SIZE( fek ) ,
                        efsStream,
                        *(ULONG *)efsStream
                        );

                    //
                    // Encrypt our Input data
                    //
                    EfsEncryptKeyFsData(
                        currentEfsStream,
                        inputDataLength,
                        sizeof(ULONG),
                        EFS_FSCTL_HEADER_LENGTH + EFS_KEY_SIZE( fek ),
                        EFS_KEY_SIZE( fek )
                        );

                    break;
                case NEW_DIR_EFS_REQUIRED:
                    //
                    // Prepare input data buffer
                    //

                    inputDataLength = EFS_FSCTL_HEADER_LENGTH
                                      + 2 * ( sizeof( EFS_KEY ) + DES_KEYSIZE );

                    if ( NULL == efsStream ){

                        //
                        // New directory will inherit the parent $EFS
                        //

                        usingCurrentEfs = TRUE;
                        inputDataLength += currentEfsStreamLength;
                        efsStream = currentEfsStream;

                    } else {

                        //
                        // New $EFS generated. Not in ver 1.0
                        //

                        usingCurrentEfs = FALSE;
                        inputDataLength += *(ULONG *)efsStream;

                        //
                        // Free memory first
                        //

                        if (currentEfsStream){
                            ZwFreeVirtualMemory(
                                CrntProcess,
                                &currentEfsStream,
                                &regionSize,
                                MEM_RELEASE
                                );
                        }

                    }

                    currentEfsStream = ExAllocatePoolWithTag(
                                PagedPool,
                                inputDataLength,
                                'msfE'
                                );

                    //
                    // Deal with out of memory here
                    //
                    if ( NULL == currentEfsStream ){

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;

                    }

                    pUlong = (ULONG *) currentEfsStream;
                    *pUlong = ((PFSCTL_INPUT)currentEfsStream)->CipherSubCode
                                = WRITE_EFS_ATTRIBUTE;

                    ((PFSCTL_INPUT)currentEfsStream)->EfsFsCode = EFS_SET_ATTRIBUTE;

                    //
                    // Make up an false FEK with session key
                    //

                    ((PEFS_KEY)&(((PFSCTL_INPUT)currentEfsStream)->EfsFsData[0]))->KeyLength
                            = DES_KEYSIZE;

                    ((PEFS_KEY)&(((PFSCTL_INPUT)currentEfsStream)->EfsFsData[0]))->Algorithm
                            = CALG_DES;

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH + sizeof ( EFS_KEY ),
                        &(EfsData.SessionKey),
                        DES_KEYSIZE
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + DES_KEYSIZE + sizeof ( EFS_KEY ) ,
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH,
                        DES_KEYSIZE + sizeof ( EFS_KEY )
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + 2 * ( sizeof ( EFS_KEY ) + DES_KEYSIZE) ,
                        efsStream,
                        *(ULONG *)efsStream
                        );

                    if ( usingCurrentEfs && efsStream ) {

                        //
                        // Free memory
                        //

                        ZwFreeVirtualMemory(
                            CrntProcess,
                            &efsStream,
                            &regionSize,
                            MEM_RELEASE
                            );

                    }

                    //
                    // Encrypt our Input data
                    //
                    EfsEncryptKeyFsData(
                        currentEfsStream,
                        inputDataLength,
                        sizeof(ULONG),
                        EFS_FSCTL_HEADER_LENGTH + DES_KEYSIZE + sizeof ( EFS_KEY ),
                        DES_KEYSIZE + sizeof ( EFS_KEY )
                        );

                    break;

                case TURN_ON_BIT_ONLY:

                    //
                    // Prepare input data buffer
                    //

                    inputDataLength = EFS_FSCTL_HEADER_LENGTH
                                      + 2 * ( sizeof( EFS_KEY ) + DES_KEYSIZE );

                    currentEfsStream = ExAllocatePoolWithTag(
                                PagedPool,
                                inputDataLength,
                                'msfE'
                                );

                    //
                    // Deal with out of memory here
                    //
                    if ( NULL == currentEfsStream ){

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;

                    }

                    ((PFSCTL_INPUT)currentEfsStream)->CipherSubCode = 0;
                    ((PFSCTL_INPUT)currentEfsStream)->EfsFsCode = EFS_SET_ATTRIBUTE;

                    //
                    // Make up an false FEK with session key
                    //

                    ((PEFS_KEY)&(((PFSCTL_INPUT)currentEfsStream)->EfsFsData[0]))->KeyLength
                            = DES_KEYSIZE;

                    ((PEFS_KEY)&(((PFSCTL_INPUT)currentEfsStream)->EfsFsData[0]))->Algorithm
                            = CALG_DES;

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH + sizeof ( EFS_KEY ),
                        &(EfsData.SessionKey),
                        DES_KEYSIZE
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + DES_KEYSIZE + sizeof ( EFS_KEY ) ,
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH,
                        DES_KEYSIZE + sizeof ( EFS_KEY )
                        );

                    //
                    // Encrypt our Input data
                    //
                    EfsEncryptKeyFsData(
                        currentEfsStream,
                        inputDataLength,
                        sizeof(ULONG),
                        EFS_FSCTL_HEADER_LENGTH + DES_KEYSIZE + sizeof ( EFS_KEY ),
                        DES_KEYSIZE + sizeof ( EFS_KEY )
                        );

                default:
                    break;
            }

            //
            // Free the memory from the EFS server
            //

            if (bufferBase){

                SIZE_T bufferSize;

                bufferSize = bufferLength;
                ZwFreeVirtualMemory(
                    CrntProcess,
                    &bufferBase,
                    &bufferSize,
                    MEM_RELEASE
                    );

            }

            if (ProcessAttached){
                KeUnstackDetachProcess(&ApcState);
                ObDereferenceObject(EfsData.LsaProcess);
                ProcessAttached = FALSE;
            }

            if ( NT_SUCCESS(status) ){


                //
                // Prepare a FSCTL IRP
                //
                KeInitializeEvent( &event, SynchronizationEvent, FALSE);

                if ( EfsContext->Status & TURN_ON_ENCRYPTION_BIT ) {
                    FsCode = FSCTL_SET_ENCRYPTION;
                    *(ULONG *) currentEfsStream = EFS_ENCRYPT_STREAM;
                } else {
                    FsCode = FSCTL_ENCRYPTION_FSCTL_IO;
                }

                fsCtlIrp = IoBuildDeviceIoControlRequest( FsCode,
                                                     DeviceObject,
                                                     currentEfsStream,
                                                     inputDataLength,
                                                     NULL,
                                                     0,
                                                     FALSE,
                                                     &event,
                                                     &ioStatus
                                                     );
                if ( fsCtlIrp ) {

                    fsCtlIrpSp = IoGetNextIrpStackLocation( fsCtlIrp );
                    fsCtlIrpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
                    fsCtlIrpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
                    fsCtlIrpSp->FileObject = irpSp->FileObject;

                    status = IoCallDriver( DeviceObject, fsCtlIrp);
                    if (status == STATUS_PENDING) {

                        status = KeWaitForSingleObject( &event,
                                               Executive,
                                               KernelMode,
                                               FALSE,
                                               (PLARGE_INTEGER) NULL );
                        status = ioStatus.Status;
                    }

                    if ( !NT_SUCCESS(status) ){
                        //
                        // Write EFS and set Key Blob failed. Failed the create
                        //

                        status = STATUS_ACCESS_DENIED;

                    } else {

                        //
                        //  Refresh the cache
                        //

                        if ( EfsId ){
                            if ( !accessToken ){

                                if ( irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken ){
                                    accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken;
                                } else {
                                    accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
                                }

                                if ( accessToken ){

                                    //
                                    // Get User ID
                                    //

                                    status = SeQueryInformationToken(
                                                accessToken,
                                                TokenUser,
                                                &UserId
                                    );
                                }
                            }

                            if (UserId && NT_SUCCESS(status)){

                                status = EfsRefreshCache(
                                            EfsId,
                                            UserId
                                            );

                                if (NT_SUCCESS(status)){

                                    //
                                    // Cache set successfully.
                                    // UserId should not be deleted in this routine.
                                    //

                                    UserId = NULL;
                                }
                            }

                            //
                            //  Cache should not affect the normal operations
                            //

                            status = STATUS_SUCCESS;
                        }
                    }
                } else {
                    //
                    // Failed allocate IRP
                    //

                   status = STATUS_INSUFFICIENT_RESOURCES;

                }

                ExFreePool( currentEfsStream );

            } else {

                //
                // Failed allocating memory for currentEfsStream
                // Use the status returned.
                //

            }
        } else {
            //
            // Failed on calling EFS server.
            // Because of the down level support, we cannot return the new error status code.
            //

            status = STATUS_ACCESS_DENIED;

            ZwFreeVirtualMemory(
                CrntProcess,
                &currentEfsStream,
                &regionSize,
                MEM_RELEASE
                );

            if (ProcessAttached){
                KeUnstackDetachProcess(&ApcState);
                ObDereferenceObject(EfsData.LsaProcess);
                ProcessAttached = FALSE;
            }

        }

    } else {
        //
        // Allocate virtual memory failed. Use the status returned.
        //

        if (ProcessAttached){
            KeUnstackDetachProcess(&ApcState);
            ObDereferenceObject(EfsData.LsaProcess);
            ProcessAttached = FALSE;
        }

    }

    if ( UserId ){

        ExFreePool( UserId );

    }

    if ( EfsId ){

        ExFreePool( EfsId );

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\util\dfskd\kdextlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>

BOOL
kdextAtoi(
    LPSTR lpArg,
    int *pRet
);

int
kdextStrlen(
    LPSTR lpsz
);

int
kdextStrnicmp(
    LPSTR lpsz1,
    LPSTR lpsz2,
    int cLen
);

#define    PRINTF    dprintf


PWINDBG_OUTPUT_ROUTINE                lpOutputRoutine;
PWINDBG_GET_EXPRESSION32              lpGetExpressionRoutine;
PWINDBG_GET_SYMBOL32                  lpGetSymbolRoutine;
PWINDBG_READ_PROCESS_MEMORY_ROUTINE   lpReadMemoryRoutine;

#define    NL      1
#define    NONL    0

#define DEFAULT_UNICODE_DATA_LENGTH 512
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 512
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

//
// No. of columns used to display struct fields;
//

ULONG s_MaxNoOfColumns = 3;
ULONG s_NoOfColumns = 1;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size)
{
    BOOL b;
    ULONG BytesRead;

    b = (lpReadMemoryRoutine)(dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
GetStringW( DWORD dwAddress, LPWSTR buf )
{
    do {
        if( !GetData( dwAddress,buf, sizeof(WCHAR)) )
            return FALSE;

        dwAddress += sizeof(WCHAR);
        buf++;

    } while( *buf != '\0' );

    return TRUE;
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&7 ], "0123456789abcdef"[ c&7 ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    BOOLEAN        b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = GetData((ULONG_PTR)puStr->Buffer, UnicodeString.Buffer, (ULONG) UnicodeString.Length);

    if (b)    {
        PRINTF("%wZ%s", &UnicodeString, nl ? "\n" : "" );
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR)pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}

/*
 * Displays a GUID
 */

BOOL
PrintGuid(
    GUID *pguid)
{
    ULONG i;

    PRINTF( "%08x-%04x-%04x", pguid->Data1, pguid->Data2, pguid->Data3 );
    for (i = 0; i < 8; i++) {
        PRINTF("%02x",pguid->Data4[i]);
    }
    return( TRUE );
}

/*
 * Displays a LARGE_INTEGER
 */

BOOL
PrintLargeInt(
    LARGE_INTEGER *bigint)
{
    PRINTF( "%08x:%08x", bigint->HighPart, bigint->LowPart);
    return( TRUE );
}

/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */



LPSTR LibCommands[] = {
    "help -- This command ",
    "version -- Version of extension ",
    "dump <Struct Type Name>@<address expr> ",
    "columns <d> -- controls the number of columns in the display ",
    0
};

BOOL
help(
    DWORD                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    int i;


    PRINTF("\n");

    for( i=0; ExtensionNames[i]; i++ )
        PRINTF( "%s\n", ExtensionNames[i] );

    for( i=0; LibCommands[i]; i++ )
        PRINTF( "   %s\n", LibCommands[i] );

    for( i=0; Extensions[i]; i++) {
        PRINTF( "   %s\n", Extensions[i] );
    }

    return TRUE;
}

BOOL
columns(
    DWORD                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG NoOfColumns;
    int   i;


    if (kdextAtoi(lpArgumentString, &i) && i > 0) {

        NoOfColumns = (ULONG) i;

        if (NoOfColumns > s_MaxNoOfColumns) {
            PRINTF( "No. Of Columns exceeds maximum(%ld) -- directive Ignored\n", s_MaxNoOfColumns );
        } else {
            s_NoOfColumns = NoOfColumns;
        }

    } else {

        PRINTF( "Bad argument to command (%s)", lpArgumentString );

    }

    return TRUE;
}

BOOL
version
(
    DWORD                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
#if    VER_DEBUG
    char *kind = "checked";
#else
    char *kind = "free";
#endif


    PRINTF( "Mup debugger extension dll for %s build %u\n", kind, VER_PRODUCTBUILD );

    return TRUE;
}


/*
 * KD Extensions should not link with the C-Runtime library routines. So,
 * we implement a few of the needed ones here.
 */

BOOL
kdextAtoi(
    LPSTR lpArg,
    int *pRet
)
{
    int n, cbArg, val = 0;
    BOOL fNegative = FALSE;

    cbArg = kdextStrlen( lpArg );

    if (cbArg > 0) {
        for (n = 0; lpArg[n] == ' '; n++) {
            ;
        }
        if (lpArg[n] == '-') {
            n++;
            fNegative = TRUE;
        }
        for (; lpArg[n] >= '0' && lpArg[n] <= '9'; n++) {
            val *= 10;
            val += (int) (lpArg[n] - '0');
        }
        if (lpArg[n] == 0) {
            *pRet = (fNegative ? -val : val);
            return( TRUE );
        } else {
            return( FALSE );
        }
    } else {
        return( FALSE );
    }

}

int
kdextStrlen(
    LPSTR lpsz
)
{
    int c;

    if (lpsz == NULL) {
        c = 0;
    } else {
        for (c = 0; lpsz[c] != 0; c++) {
            ;
        }
    }

    return( c );
}


#define UPCASE_CHAR(c)  \
    ( (((c) >= 'a') && ((c) <= 'z')) ? ((c) - 'a' + 'A') : (c) )

int
kdextStrnicmp(
    LPSTR lpsz1,
    LPSTR lpsz2,
    int cLen
)
{
    int nDif, i;

    for (i = nDif = 0; nDif == 0 && i < cLen; i++) {
        nDif = UPCASE_CHAR(lpsz1[i]) - UPCASE_CHAR(lpsz2[i]);
    }

    return( nDif );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\efs\control.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   control.c

Abstract:

   This module contains the code to handle the IRP MajorFunctions of
   IRP_MJ_DEVICE_CONTROL and IRP_MJ_FILE_SYSTEM_CONTROL. The code will
   be responsible for correctly setting these IRP's with any necessary
   information and passing them along. Any other support routine which are
   directly releated (such as completion routines) to these operations can
   be found in this module.

Author:

    Robert Gu (robertg) 29-Oct-1996

Environment:

    Kernel mode


Revision History:


--*/

#include "efs.h"
#include "efsrtl.h"
#include "efsext.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, EFSFsControl)
#endif


NTSTATUS
EFSFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PIO_STACK_LOCATION nextIrpSp;
    PDEVICE_OBJECT deviceObject;
    PKEVENT finishEvent;

    PAGED_CODE();

    if ( (irpSp->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                    (irpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_SET_COMPRESSION) &&
                    ( (irpSp->Parameters.FileSystemControl.InputBufferLength >= sizeof (USHORT)) && 
                      (*(PUSHORT)(Irp->AssociatedIrp.SystemBuffer) != 0 /*COMPRESSION_FORMAT_NONE*/)
                    )
                  ){
        //
        // Compression on encrypted file is not allowed.
        // Check if the file is encrypted or not
        //
        ULONG inputDataLength;
        UCHAR *inputDataBuffer, *outputDataBuffer;
        ULONG outputDataLength;
        KEVENT event;
        IO_STATUS_BLOCK ioStatus;
        PIRP fsCtlIrp;
        PIO_STACK_LOCATION fsCtlIrpSp;

        inputDataLength = FIELD_OFFSET(FSCTL_INPUT, EfsFsData[0]) +
                          FIELD_OFFSET(GENERAL_FS_DATA, EfsData[0]);

        inputDataBuffer = ExAllocatePoolWithTag(
                    PagedPool,
                    inputDataLength,
                    'msfE'
                    );

        //
        // The size of output data buffer is not important. We don't
        // care the content. We just need to know the $EFS exists.
        //

        outputDataLength = 1024;
        outputDataBuffer = ExAllocatePoolWithTag(
                    PagedPool,
                    outputDataLength,
                    'msfE'
                    );

        if ( ( NULL == inputDataBuffer ) || ( NULL == outputDataBuffer ) ){

            //
            // Out of memory
            //

            if ( inputDataBuffer ){

                ExFreePool( inputDataBuffer );

            }
            if ( outputDataBuffer ){

                ExFreePool( outputDataBuffer );

            }

            return STATUS_INSUFFICIENT_RESOURCES;
        }


        ((PFSCTL_INPUT)inputDataBuffer)->EfsFsCode = EFS_GET_ATTRIBUTE;

        RtlCopyMemory(
            &(((PFSCTL_INPUT)inputDataBuffer)->EfsFsData[0]),
            &(EfsData.SessionKey),
            DES_KEYSIZE
            );

        RtlCopyMemory(
            &(((PFSCTL_INPUT)inputDataBuffer)->EfsFsData[0]) + DES_KEYSIZE + 2 * sizeof( ULONG ),
            &(((PFSCTL_INPUT)inputDataBuffer)->EfsFsData[0]),
            DES_KEYSIZE + 2 * sizeof( ULONG )
            );

        //
        // Encrypt our Input data
        //
        EfsEncryptKeyFsData(
            inputDataBuffer,
            inputDataLength,
            sizeof(ULONG),
            EFS_FSCTL_HEADER_LENGTH + DES_KEYSIZE + 2 * sizeof( ULONG ),
            DES_KEYSIZE + 2 * sizeof( ULONG )
            );

        //
        // Prepare a FSCTL IRP
        //
        KeInitializeEvent( &event, SynchronizationEvent, FALSE);

        fsCtlIrp = IoBuildDeviceIoControlRequest( FSCTL_ENCRYPTION_FSCTL_IO,
                                             DeviceObject,
                                             inputDataBuffer,
                                             inputDataLength,
                                             outputDataBuffer,
                                             outputDataLength,
                                             FALSE,
                                             &event,
                                             &ioStatus
                                             );
        if ( fsCtlIrp ) {

            fsCtlIrpSp = IoGetNextIrpStackLocation( fsCtlIrp );
            fsCtlIrpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
            fsCtlIrpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
            fsCtlIrpSp->FileObject = irpSp->FileObject;

            status = IoCallDriver( DeviceObject, fsCtlIrp);
            if (status == STATUS_PENDING) {

                status = KeWaitForSingleObject( &event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       (PLARGE_INTEGER) NULL );
                status = ioStatus.Status;
            }

            ExFreePool( inputDataBuffer );
            ExFreePool( outputDataBuffer );

            if ( NT_SUCCESS(status) || ( STATUS_BUFFER_TOO_SMALL == status) ){
                //
                // $EFS exist, encrypted file. Deny compression
                //

                return STATUS_INVALID_DEVICE_REQUEST;
            }

        } else {
            //
            // Failed allocate IRP
            //

            ExFreePool( inputDataBuffer );
            ExFreePool( outputDataBuffer );

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Compression allowed. Simply pass this file system control request through.
        //

        status = STATUS_SUCCESS;

    } else {

        //
        // Simply pass this file system control request through.
        //

        status = STATUS_SUCCESS;

    }

    //
    // Any special processing has been completed, so simply pass the request
    // along to the next driver.
    //

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\efs\efsext.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

   This module contains the common extern header information for the EFS
   file system filter driver.

Author:

   Robert Gu (robertg)  29-Oct-1996

Enviroment:

   Kernel Mode Only

Revision History:

--*/
#ifndef EFSEXT_H
#define EFSEXT_H

#include "efs.h"

//Global externals
extern EFS_DATA EfsData;

#if DBG

extern ULONG EFSDebug;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\efs\efs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   efs.c

Abstract:

    This module contains the code that implements the EFS
    file system filter driver.

Author:

    Robert Gu (robertg) 29-Oct-1996

Environment:

    Kernel mode


Revision History:


--*/

#include "efs.h"
#include "efsrtl.h"


#define BUFFER_SIZE 1024
#define BUFFER_REG_VAL L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NTFS\\EFS\\Parameters"
#define MAX_ALLOC_BUFFER L"MaximumBlob"
#define EFS_KERNEL_CACHE_PERIOD L"EFSKCACHEPERIOD"

//
// Global storage for this file system filter driver.
//
EFS_DATA EfsData;
WORK_QUEUE_ITEM EfsShutdownCleanupWorkItem;

//
// $EFS stream name
//
WCHAR   AttrName[5] = L"$EFS";

#if DBG

ULONG EFSDebug = 0;

#endif

ENCRYPTION_CALL_BACK EFSCallBackTable = {
    ENCRYPTION_CURRENT_INTERFACE_VERSION,
    ENCRYPTION_ALL_STREAMS,
    EfsOpenFile,
    NULL,
    EFSFilePostCreate,
    EfsFileControl,
    EfsFileControl,
    EFSFsControl,
    EfsRead,
    EfsWrite,
    EfsFreeContext
    };

VOID
EfspShutdownCleanup(
    IN PVOID Parameter
    );

//
// Assign text sections for each routine.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, EfspShutdownCleanup)
#pragma alloc_text(PAGE, EfsInitialization)
#pragma alloc_text(PAGE, EfsGetSessionKey)
#pragma alloc_text(PAGE, GetKeyBlobLength)
#pragma alloc_text(PAGE, GetKeyBlobBuffer)
#pragma alloc_text(PAGE, SetKeyTable)
#pragma alloc_text(PAGE, EfsInitFips)
#endif


VOID
EfspShutdownCleanup(
    IN PVOID Parameter
    )
{
    PEPROCESS LsaProcess;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(Parameter);
    
    if (EfsData.LsaProcess) {
        LsaProcess = EfsData.LsaProcess;
        EfsData.LsaProcess = NULL;
        ObDereferenceObject(LsaProcess);
    }
}


NTSTATUS
EfsInitialization(
    void
    )

/*++

Routine Description:

    This is the initialization routine for the general purpose file system
    filter driver.  This routine creates the device object that represents this
    driver in the system and registers it for watching all file systems that
    register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING nameString;
    PDEVICE_EXTENSION deviceExtension;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    HANDLE threadHdl;
    ULONG i;
    OBJECT_ATTRIBUTES objAttr;
    UNICODE_STRING efsInitEventName;
    UNICODE_STRING efsBufValue;
    ULONG  resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION pPartialValue = NULL;
    HANDLE efsKey;
    EFS_INIT_DATAEXG InitDataFromSrv;

    PAGED_CODE();

    //
    // Mark our global data record
    //

    EfsData.AllocMaxBuffer = FALSE;
    EfsData.FipsFileObject = NULL;
    EfsData.FipsFunctionTable.Fips3Des = NULL;
    EfsData.FipsFunctionTable.Fips3Des3Key = NULL;
    EfsData.EfsDriverCacheLength = DefaultTimeExpirePeriod;

    RtlInitUnicodeString( &efsBufValue, BUFFER_REG_VAL );

    InitializeObjectAttributes(
        &objAttr,
        &efsBufValue,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = ZwOpenKey(
        &efsKey,
        KEY_READ,
        &objAttr);

    if (NT_SUCCESS(status)) {

        pPartialValue = (PKEY_VALUE_PARTIAL_INFORMATION)ExAllocatePool(NonPagedPool, BUFFER_SIZE);
        if (pPartialValue) {
            RtlInitUnicodeString(&efsBufValue, MAX_ALLOC_BUFFER);
        
            status = ZwQueryValueKey(
                        efsKey,
                        &efsBufValue,
                        KeyValuePartialInformation,
                        (PVOID)pPartialValue,
                        BUFFER_SIZE,
                        &resultLength
                        );
        
            if (NT_SUCCESS(status)) {
                ASSERT(pPartialValue->Type == REG_DWORD);
                if (*((PLONG)&(pPartialValue->Data))){
                    EfsData.AllocMaxBuffer = TRUE;
                }
            }

            RtlInitUnicodeString(&efsBufValue, EFS_KERNEL_CACHE_PERIOD);
        
            status = ZwQueryValueKey(
                        efsKey,
                        &efsBufValue,
                        KeyValuePartialInformation,
                        (PVOID)pPartialValue,
                        BUFFER_SIZE,
                        &resultLength
                        );
        
            if (NT_SUCCESS(status)) {
                ASSERT(pPartialValue->Type == REG_DWORD);
                if (((*((DWORD *)&(pPartialValue->Data))) >= MINCACHEPERIOD) && 
                    ((*((DWORD *)&(pPartialValue->Data))) <= MAXCACHEPERIOD)){
                    EfsData.EfsDriverCacheLength = *((DWORD *)&(pPartialValue->Data));
                    EfsData.EfsDriverCacheLength *= 10000000;
                }
            }
            ExFreePool(pPartialValue);
        }
        ZwClose(efsKey);
    }
    
    EfsData.NodeTypeCode = EFS_NTC_DATA_HEADER;
    EfsData.NodeByteSize = sizeof( EFS_DATA );
    EfsData.EfsInitialized = FALSE;
    EfsData.InitEventHandle = NULL;
    EfsData.LsaProcess = NULL;

    //
    // Initialize global data structures.
    //

    ExInitializeWorkItem( &EfsShutdownCleanupWorkItem,
                          &EfspShutdownCleanup,
                          NULL );
    status = PoQueueShutdownWorkItem( &EfsShutdownCleanupWorkItem );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    InitializeListHead( &(EfsData.EfsOpenCacheList) );
    InitializeListHead( &(EfsData.EfsKeyLookAsideList) );
    ExInitializeFastMutex( &(EfsData.EfsKeyBlobMemSrcMutex) );
    ExInitializeFastMutex( &(EfsData.EfsOpenCacheMutex) );

    //
    // Initialize the event lookaside list
    //

    ExInitializeNPagedLookasideList(&(EfsData.EfsEventPool),
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(KEVENT),
                                    'levE',
                                    EFS_EVENTDEPTH
                                    );

    //
    // Try to allocate at least one event in the list. This one will be used for
    // sure later.
    //

    {
        PVOID pTryEvent;

        pTryEvent = ExAllocateFromNPagedLookasideList(&(EfsData.EfsEventPool));
        if ( NULL == pTryEvent ){
            //
            // Free previously allocated memory
            //

            ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
            return STATUS_NO_MEMORY;
        }
        ExFreeToNPagedLookasideList(&(EfsData.EfsEventPool), pTryEvent);
    }

    //
    // Initialize the context lookaside list
    //

    ExInitializeNPagedLookasideList(&(EfsData.EfsContextPool),
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(EFS_CONTEXT),
                                    'nocE',
                                    EFS_CONTEXTDEPTH
                                    );

    //
    //  Initialize the cache lookaside list
    //

    ExInitializePagedLookasideList(&(EfsData.EfsOpenCachePool),
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(OPEN_CACHE),
                                    'hcoE',
                                    EFS_CACHEDEPTH
                                    );

    ExInitializePagedLookasideList(&(EfsData.EfsMemSourceItem),
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(KEY_BLOB_RAMPOOL),
                                    'msfE',
                                    EFS_ALGDEPTH
                                    );

    ExInitializeNPagedLookasideList(&(EfsData.EfsLookAside),
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(NPAGED_LOOKASIDE_LIST),
                                    'msfE',
                                    EFS_ALGDEPTH
                                    );

    status = NtOfsRegisterCallBacks( Encryption, &EFSCallBackTable );
    if (!NT_SUCCESS(status)) {

        //
        // Register callback failed
        //

        ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
        ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
        ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
        ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
        ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));
        return status;
    }

    RtlInitUnicodeString(&(EfsData.EfsName), &AttrName[0]);

    //
    //  Create an event
    //

    RtlInitUnicodeString( &efsInitEventName, L"\\EFSInitEvent" );

    InitializeObjectAttributes(
        &objAttr,
        &efsInitEventName,
        0,
        NULL,
        NULL
        );

    //
    // Try to create an event. If the event was not created, the EFS
    // server is not loaded yet. We will create a thread waiting for
    // EFS server to be loaded. If the event was already created, we
    // will just go ahead and get the session key from the EFS server.
    //

    status = ZwCreateEvent(
                 &(EfsData.InitEventHandle),
                 EVENT_MODIFY_STATE,
                 &objAttr,
                 NotificationEvent,
                 FALSE
                 );

    if (!NT_SUCCESS(status)) {

        if ( STATUS_OBJECT_NAME_COLLISION == status ){

            //
            // EFS server has been loaded. This is the normal case.
            // Call server to get the session key.
            //

            status = GenerateSessionKey(
                         &InitDataFromSrv
                         );


            if (NT_SUCCESS( status )) {

                //
                //  Set session key
                //

                RtlCopyMemory( &(EfsData.SessionKey[0]), InitDataFromSrv.Key, DES_KEYSIZE );
                deskey( (DESTable*)&(EfsData.SessionDesTable[0]),
                        &(EfsData.SessionKey[0]));

                status = PsLookupProcessByProcessId(
                                    InitDataFromSrv.LsaProcessID,
                                    &(EfsData.LsaProcess)
                                    );

                if (NT_SUCCESS( status )) {
                    EfsData.EfsInitialized = TRUE;
                    if ( PsGetCurrentProcess() != EfsData.LsaProcess ){

                        KAPC_STATE  ApcState;

                        KeStackAttachProcess (
                            EfsData.LsaProcess,
                            &ApcState
                            );
                        InitSecurityInterface();
                        KeUnstackDetachProcess(&ApcState);
                    } else {
                        InitSecurityInterface();
                    }
                    EfsInitFips();
                } else {
#if DBG

                    if ( (EFSTRACEALL | EFSTRACELIGHT) & EFSDebug ){

                        DbgPrint("PsLookupProcessByProcessId failed, status = %x\n",status);

                    }

#endif
                    //
                    // Failed to get the process pointer
                    //

                    ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
                    ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
                    ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
                    ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
                    ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));

                }

            } else {

#if DBG

                if ( (EFSTRACEALL | EFSTRACELIGHT) & EFSDebug ){

                    DbgPrint("GenerateSessionKey failed, status = %x\n",status);

                }

#endif
                //
                // Failed to get the session key
                //

                ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
                ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
                ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
                ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
                ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));

            }


        } else {

            //
            // Unexpected error occured. EFS cannot be loaded
            //

#if DBG

            if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
                DbgPrint("EFSFILTER: Efs init event creation failed.%x\n", status);
            }

#endif
            ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
            ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
            ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
            ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
            ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));

        }

    } else {

        //
        // The server is not ready yet.
        // Create a thread and wait for the server in that thread
        //

        status = PsCreateSystemThread(
                                &threadHdl,
                                GENERIC_ALL,
                                NULL,
                                NULL,
                                NULL,
                                EfsGetSessionKey,
                                NULL
                                );

        if ( NT_SUCCESS( status ) ){

            ZwClose( threadHdl );

        } else {

            ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
            ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
            ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
            ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
            ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));

        }
    }

    return status;
}

VOID
EfsUninitialization(
    VOID
    )
{
    PLIST_ENTRY              pLink;
    PKEY_BLOB_RAMPOOL        pTmpItem;
    PNPAGED_LOOKASIDE_LIST   MemSrcList;

    while (!IsListEmpty (&EfsData.EfsKeyLookAsideList)) {
        pLink = RemoveHeadList (&EfsData.EfsKeyLookAsideList);
        pTmpItem = CONTAINING_RECORD(pLink, KEY_BLOB_RAMPOOL, MemSourceChain);
        MemSrcList = pTmpItem->MemSourceList;

        ExDeleteNPagedLookasideList(MemSrcList);
        ExFreeToNPagedLookasideList(&(EfsData.EfsLookAside), MemSrcList );
        ExFreeToPagedLookasideList(&(EfsData.EfsMemSourceItem), pTmpItem );
    }
    ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
    ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
    ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
    ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
    ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));
    if (EfsData.FipsFileObject) {
        ObDereferenceObject(EfsData.FipsFileObject);
        EfsData.FipsFileObject = NULL;
    }
}

VOID
EfsGetSessionKey(
    IN PVOID StartContext
    )

/*++

Routine Description:

    This routine is invoked in DriverEntry. It runs in a seperate thread.

    The purpose of this routine is to wait for the EFS server. And Get the session key.

Arguments:

    StartContext - Start context of the thread.

Return Value:

    None.

--*/

{

    SECURITY_DESCRIPTOR efsInitEventSecurityDescriptor;
    NTSTATUS status;
    EFS_INIT_DATAEXG InitDataFromSrv;

#if DBG

    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( "EFSFILTER: Thread started. %x\n", EfsData.NodeTypeCode );
    }

#endif

#if 0
    //
    // Prepare to create an event for synchronizing with the Efs.
    // First, build the Security Descriptor for the Init Event Object
    //

    status = RtlCreateSecurityDescriptor(
                 &efsInitEventSecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );

    if (!NT_SUCCESS(status)) {

#if DBG
        DbgPrint(("EFSFILTER:  Creating Efs Init Event Desc failed 0x%lx\n",
                  status));
#endif

        return ;
    }

    //
    // Allocate a temporary buffer from the paged pool.  It is a fatal
    // system error if the allocation fails since security cannot be
    // enabled.
    //

    aclSize = sizeof(ACL) +
              sizeof(ACCESS_ALLOWED_ACE) +
              RtlLengthSid(SeLocalSystemSid);

    efsInitEventSecurityDescriptor.Dacl =
        ExAllocatePoolWithTag(PagedPool, aclSize, 'cAeS');

    if (efsInitEventSecurityDescriptor.Dacl == NULL) {

#if DBG
        DbgPrint(("EFSFILTER:  Insufficient resources to initialize\n"));
#endif
        return;
    }

    //
    // Now create the Discretionary ACL within the Security Descriptor
    //

    status = RtlCreateAcl(
                 efsInitEventSecurityDescriptor.Dacl,
                 aclSize,
                 ACL_REVISION2
                 );

    if (!NT_SUCCESS(status)) {

#if DBG
        DbgPrint(("EFSFILTER:  Creating Efs Init Event Dacl failed 0x%lx\n",
                  status));
#endif

        return;
    }

    //
    // Now add an ACE giving GENERIC_ALL access to the User ID
    //

    status = RtlAddAccessAllowedAce(
                 efsInitEventSecurityDescriptor.Dacl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 SeLocalSystemSid
                 );

    if (!NT_SUCCESS(status)) {

#if DBG
        DbgPrint(("EFSFILTER:  Adding Efs Init Event ACE failed 0x%lx\n",
                  status));
#endif

        return;
    }

#endif // #if 0


    status = ZwWaitForSingleObject (
                            EfsData.InitEventHandle,
                            FALSE,
                            (PLARGE_INTEGER)NULL
                            );

    ZwClose( EfsData.InitEventHandle );

    //
    //  Call server to get the session key
    //


    status = GenerateSessionKey(
                 &InitDataFromSrv
                 );


    if (!NT_SUCCESS( status )) {

#if DBG

        if ( (EFSTRACEALL | EFSTRACELIGHT) & EFSDebug ){

            DbgPrint("GenerateSessionKey failed, status = %x\n",status);

        }

#endif

         return;
    }

    //
    //  Set session key
    //

    RtlCopyMemory( &(EfsData.SessionKey[0]), InitDataFromSrv.Key, DES_KEYSIZE );
    deskey( (DESTable*)&(EfsData.SessionDesTable[0]),
            &(EfsData.SessionKey[0]));

    status = PsLookupProcessByProcessId(
                        InitDataFromSrv.LsaProcessID,
                        &(EfsData.LsaProcess)
                        );

    if (NT_SUCCESS( status )) {

        EfsData.EfsInitialized = TRUE;
        if ( PsGetCurrentProcess() != EfsData.LsaProcess ){
            KAPC_STATE  ApcState;

            //KeAttachProcess(EfsData.LsaProcess);
            KeStackAttachProcess (
                EfsData.LsaProcess,
                &ApcState
                );
            InitSecurityInterface();
            //KeDetachProcess();
            KeUnstackDetachProcess(&ApcState);
        } else {
            InitSecurityInterface();
        }

        EfsInitFips();

    } else {

#if DBG

        if ( (EFSTRACEALL | EFSTRACELIGHT) & EFSDebug ){

            DbgPrint("PsLookupProcessByProcessId failed, status = %x\n",status);

        }

#endif

    }

    return;
}

ULONG GetKeyBlobLength(
    ULONG AlgID
    )
{
    if (EfsData.AllocMaxBuffer) {
        return AES_KEY_BLOB_LENGTH_256;
    }
    switch (AlgID){
        case CALG_DESX:
            return DESX_KEY_BLOB_LENGTH;
        case CALG_3DES:
            return DES3_KEY_BLOB_LENGTH;
        case CALG_AES_256:
            return AES_KEY_BLOB_LENGTH_256;
        case CALG_DES:
        default:
            return DES_KEY_BLOB_LENGTH;
    }
    return 0;
}

PKEY_BLOB
GetKeyBlobBuffer(
    ULONG AlgID
    )
{

    PNPAGED_LOOKASIDE_LIST   MemSrcList = NULL;
    PKEY_BLOB_RAMPOOL   KeyBlobPoolListItem = NULL;
    PKEY_BLOB_RAMPOOL   pTmpItem = NULL;
    ULONG KeyBlobLength;
    PLIST_ENTRY pLink = NULL;
    PKEY_BLOB NewKeyBlob;

    KeyBlobLength = GetKeyBlobLength(AlgID);

    if (!KeyBlobLength){
        ASSERT(KeyBlobLength);
        return NULL;
    }

    ExAcquireFastMutex( &(EfsData.EfsKeyBlobMemSrcMutex));
    for (pLink = EfsData.EfsKeyLookAsideList.Flink; pLink != &(EfsData.EfsKeyLookAsideList); pLink = pLink->Flink) {
        pTmpItem = CONTAINING_RECORD(pLink, KEY_BLOB_RAMPOOL, MemSourceChain);
        if (pTmpItem->AlgorithmID == AlgID) {

            //
            // The lookaside list already exists
            //

            MemSrcList = pTmpItem->MemSourceList;
            break;
        }
    }
    ExReleaseFastMutex(  &(EfsData.EfsKeyBlobMemSrcMutex) );

    if ( MemSrcList == NULL ) {

        //
        // No lookaside for this type of key. Go and create one item.
        //

        MemSrcList = (PNPAGED_LOOKASIDE_LIST)ExAllocateFromNPagedLookasideList(&(EfsData.EfsLookAside));
        KeyBlobPoolListItem = (PKEY_BLOB_RAMPOOL) ExAllocateFromPagedLookasideList(&(EfsData.EfsMemSourceItem));
        if ( (NULL == MemSrcList) || (NULL == KeyBlobPoolListItem) ){
            if (MemSrcList) {
                ExFreeToNPagedLookasideList(&(EfsData.EfsLookAside), MemSrcList );
            }
            if (KeyBlobPoolListItem){
                ExFreeToPagedLookasideList(&(EfsData.EfsMemSourceItem), KeyBlobPoolListItem );
            }
            return NULL;
        }

        RtlZeroMemory( KeyBlobPoolListItem, sizeof( KEY_BLOB_RAMPOOL ) );
        KeyBlobPoolListItem->MemSourceList = MemSrcList;
        KeyBlobPoolListItem->AlgorithmID = AlgID;

        ExInitializeNPagedLookasideList(
                MemSrcList,
                NULL,
                NULL,
                0,
                KeyBlobLength,
                'msfE',
                EFS_KEYDEPTH
                );

        ExAcquireFastMutex( &(EfsData.EfsKeyBlobMemSrcMutex));
        InsertHeadList( &(EfsData.EfsKeyLookAsideList), &(KeyBlobPoolListItem->MemSourceChain));
        ExReleaseFastMutex(  &(EfsData.EfsKeyBlobMemSrcMutex) );
    }

    //
    // Allocate the Key Blob
    //

    NewKeyBlob = (PKEY_BLOB)ExAllocateFromNPagedLookasideList(MemSrcList);

    if (NewKeyBlob){
        NewKeyBlob->AlgorithmID = AlgID;
        NewKeyBlob->KeyLength = KeyBlobLength;
        NewKeyBlob->MemSource = MemSrcList;
    }
    return NewKeyBlob;

}

BOOLEAN
SetKeyTable(
    PKEY_BLOB   KeyBlob,
    PEFS_KEY    EfsKey
    )
{

    char DesXTmpKey[DESX_KEYSIZE];

    switch ( EfsKey->Algorithm ){
        case CALG_3DES:
            if (EfsData.AllocMaxBuffer) {
                RtlZeroMemory( &(KeyBlob->Key[0]) + DES3_TABLESIZE, KeyBlob->KeyLength - DES3_KEY_BLOB_LENGTH);
            }
            if (EfsData.FipsFunctionTable.Fips3Des3Key) {
                EfsData.FipsFunctionTable.Fips3Des3Key(
                    (DES3TABLE*) &(KeyBlob->Key[0]), 
                    ((char *)EfsKey) + sizeof ( EFS_KEY )
                    );
            } else {
                return FALSE;
            }
            //tripledes3key(
            //    (DES3TABLE*) &(KeyBlob->Key[0]), 
            //    ((char *)EfsKey) + sizeof ( EFS_KEY )
            //    );
            break;
        case CALG_DESX:
            //
            // Flush the non used area.
            //

            if (EfsData.AllocMaxBuffer) {
                RtlZeroMemory( &(KeyBlob->Key[0]) + DESX_TABLESIZE, KeyBlob->KeyLength - DESX_KEY_BLOB_LENGTH);
            }
            desexpand128to192(
                ((char *)EfsKey) + sizeof ( EFS_KEY ),
                DesXTmpKey
                );

            desxkey(
                (DESXTable*) &(KeyBlob->Key[0]),
                DesXTmpKey
                );
            break;

        case CALG_AES_256:
            aeskey(
                (AESTable*) &(KeyBlob->Key[0]),
                ((char *)EfsKey) + sizeof ( EFS_KEY ),
                AES_ROUNDS_256
                );
            break;

        case CALG_DES:
        default:
            if (EfsData.AllocMaxBuffer) {
                RtlZeroMemory( &(KeyBlob->Key[0]) + DES_TABLESIZE, KeyBlob->KeyLength - DES_KEY_BLOB_LENGTH);
            }
            deskey(
                (DESTable*) &(KeyBlob->Key[0]),
                ((char *)EfsKey) + sizeof ( EFS_KEY )
                );
            break;
    }
    return TRUE;
}


BOOLEAN
EfsInitFips(VOID)
/*++

Routine Description:

	Initialize the FIPS library table.

Arguments:

Return Value:

    TRUE/FALSE.

--*/
{
    UNICODE_STRING  deviceName;
    NTSTATUS        status;
    PDEVICE_OBJECT  pDeviceObject;
    // PFILE_OBJECT    pFileObject = NULL;
    PIRP            pIrp;
    IO_STATUS_BLOCK IoStatusBlock;

    PAGED_CODE();

    RtlInitUnicodeString(&deviceName, FIPS_DEVICE_NAME);

    //
    // Get the file and device objects for FIPS.
    //

    status = IoGetDeviceObjectPointer(  &deviceName,
                                        FILE_ALL_ACCESS,
                                        &EfsData.FipsFileObject,
                                        &pDeviceObject);

    if (status != STATUS_SUCCESS) {
        return  FALSE;
    }
    
    //
    // Build the request to send to FIPS to get library table.
    //
    pIrp = IoBuildDeviceIoControlRequest(   IOCTL_FIPS_GET_FUNCTION_TABLE,
                                            pDeviceObject,
                                            NULL,
                                            0,
                                            &EfsData.FipsFunctionTable,
                                            sizeof(FIPS_FUNCTION_TABLE),
                                            FALSE,
                                            NULL,
                                            &IoStatusBlock
                                            );
    
    if (pIrp == NULL) {
#if DBG
        DbgPrint("EfsInitFips: IoBuildDeviceIoControlRequest IOCTL_FIPS_GET_FUNCTION_TABLE failed.\n");
#endif
        ObDereferenceObject(EfsData.FipsFileObject);
        EfsData.FipsFileObject = NULL;
        return  FALSE;
    }
    
    status = IoCallDriver(pDeviceObject, pIrp);
    
    if (status != STATUS_SUCCESS) {
        ObDereferenceObject(EfsData.FipsFileObject);
        EfsData.FipsFileObject = NULL;
#if DBG
        DbgPrint("EfsInitFips: IoCallDriver failed, status = %x\n",status);
#endif
        return  FALSE;
    }
    
    return  TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\efs\efsrtl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

   This module contains the common header information for the EFS

   DLL.

Author:

   Robert Gu (robertg)  08-Dec-1996

Enviroment:

   Kernel Mode Only

Revision History:

--*/
#ifndef EFSRTL_H
#define EFSRTL_H

#include "efs.h"
#include "efsext.h"

#define EFS_IV 0x169119629891ad13
#define EFS_AES_IVL 0x5816657be9161312
#define EFS_AES_IVH 0x1989adbe44918961


//#define ENCRYPT 0
//#define DECRYPT 1
#define CHUNK_SIZE  512
#define EFS_MAX_LENGTH  256*1024

//
// Status of EFS context.
//
// Processing Status
//


#define NO_FURTHER_PROCESSING   0x00000000
#define NEW_FILE_EFS_REQUIRED     0x00000001
#define NEW_DIR_EFS_REQUIRED      0x00000002
#define VERIFY_USER_REQUIRED       0x00000004
#define TURN_ON_BIT_ONLY               0x00000008
#define NO_OPEN_CACHE_CHECK       0x40000000
#define TURN_ON_ENCRYPTION_BIT   0x80000000
#define ACTION_REQUIRED         0x0fffffff

//
//
//

#define SYSTEM_IS_READONLY     0x00000001

//
// Error Status
//

#define CREATE_EFS_FAIL         0x00000100
#define OPEN_EFS_FAIL           0x00000200
#define WRITE_EFS_FAIL          0x00000400
#define OUT_OF_MEMORY           0x00000800
#define EFS_FORMAT_ERROR        0x00001000
#define NTOFS_EXCEPTION         0x00002000

//
// Information Status
//

#define EFS_READ_SUCCESSFUL     0x00010000

//
// Stream Create Status
//

#define STRING_NEW_OR_EXIST_MASK  0x000f0000
#define FILE_DIR_TYPE             0x0000000f

#define FILE_NEW                0x00000001
#define FILE_EXISTING           0x00000002
#define DIRECTORY_NEW           0x00000004
#define DIRECTORY_EXISTING      0x00000008
#define STREAM_NEW              0x00010000
#define STREAM_EXISTING         0x00020000

//
// Encryption flag
//

#define FILE_ENCRYPTED          0x00000002
#define STREAM_ENCRYPTED        0x00000001


//
// The EFS FSCTL Input data buffer.
//

typedef struct _FSCTL_INPUT {

    ULONG   PlainSubCode;
    ULONG   EfsFsCode;
    ULONG   CipherSubCode;
    UCHAR   EfsFsData[1];

} FSCTL_INPUT, *PFSCTL_INPUT;

typedef struct _GENERAL_FS_DATA {

    UCHAR   Sk1[DES_KEYSIZE];
    ULONG   Hdl1;
    ULONG   Hdl2;
    UCHAR   Sk2[DES_KEYSIZE];
    ULONG   Hdl3;
    ULONG   Hdl4;
    UCHAR   EfsData[1];

} GENERAL_FS_DATA, *PGENERAL_FS_DATA;

typedef struct _EFS_STREAM {

    ULONG   Length;
    ULONG   Status;
    UCHAR   Private[1];

} EFS_STREAM, *PEFS_STREAM;

//
// Function prototypes
//

typedef VOID ( * EfsEncFunc)(
        IN PUCHAR   InBuffer,
        OUT PUCHAR  OutBuffer,
        IN PUCHAR   IV,
        IN PKEY_BLOB   KeyBlob,
        IN LONG     Length
        );

typedef VOID ( * EfsDecFunc)(
        IN OUT PUCHAR   Buffer,
        IN PUCHAR   IV,
        IN PKEY_BLOB   KeyBlob,
        IN LONG     Length
        );

VOID
EFSDesEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSDesDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSDesXEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSDesXDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSDes3Enc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSDes3Dec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSAesEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSAesDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EfsEncryptKeyFsData(
    IN PVOID DataBuffer,
    IN ULONG DataLength,
    IN ULONG DataEncOffset,
    IN ULONG RefdataEncOffset,
    IN ULONG RefdataEncLength
    );

NTSTATUS
EfsOpenFile(
    IN OBJECT_HANDLE FileHdl,
    IN OBJECT_HANDLE ParentDir OPTIONAL,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG FileDirFlag,
    IN ULONG SystemState,
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT VolDo,
    IN PVOID PfileKeyContext,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength,
    IN OUT PVOID *PCreateContext,
    IN OUT PBOOLEAN Reserved
    );

NTSTATUS
EfsFileControl(
    IN PVOID PInputBuffer,
    IN ULONG InputDataLength,
    OUT PVOID POutputBuffer OPTIONAL,
    IN OUT PULONG OutputBufferLength,
    IN ULONG EncryptionFlag,
    IN ULONG AccessFlag,
    IN ULONG SystemState,
    IN ULONG FsControlCode,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT VolDo,
    IN ATTRIBUTE_HANDLE Stream,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength
    );

NTSTATUS
EfsRead(
    IN OUT PUCHAR Buffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PVOID Context
    );

NTSTATUS
EfsWrite(
    IN PUCHAR InBuffer, //Do we need in and out buffer?
    OUT PUCHAR OutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PUCHAR Context
    );

VOID
EfsFreeContext(
    IN OUT PVOID *PContext
    );

NTSTATUS
EfsMountVolumn(
    IN PDEVICE_OBJECT VolDo,
    IN PDEVICE_OBJECT RealDevice
    );

VOID
EfsDismountVolumn(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
EfsReadEfsData(
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    OUT PVOID   *EfsStreamData,
    OUT PULONG   PEfsStreamLength,
    OUT PULONG Information
    );

BOOLEAN
EfsVerifyGeneralFsData(
    IN PUCHAR DataOffset,
    IN ULONG InputDataLength
    );

BOOLEAN
EfsVerifyKeyFsData(
    IN PUCHAR DataOffset,
    IN ULONG InputDataLength
    );

NTSTATUS
EfsDeleteEfsData(
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
EfsSetEncrypt(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context,
        IN OUT PULONG PContextLength
        );

NTSTATUS
EfsEncryptStream(
    IN PUCHAR InputData,
    IN ULONG InputDataLength,
    IN ULONG EncryptionFlag,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID *Context,
    IN OUT PULONG PContextLength
    );

NTSTATUS
EfsEncryptFile(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context
        );

NTSTATUS
EfsDecryptStream(
    IN PUCHAR InputData,
    IN ULONG InputDataLength,
    IN ULONG EncryptionFlag,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID *Context,
    IN OUT PULONG PContextLength
    );

NTSTATUS
EfsDecryptFile(
    IN PUCHAR InputData,
    IN ULONG InputDataLength,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
EfsEncryptDir(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        );

NTSTATUS
EfsModifyEfsState(
        IN ULONG FunctionCode,
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        );

ULONG
GetEfsStreamOffset(
        IN PUCHAR InputData
        );

NTSTATUS
SetEfsData(
    PUCHAR InputData,
    IN ULONG InputDataLength,
    IN ULONG SystemState,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength
    );

BOOLEAN
EfsFindInCache(
    IN GUID   *EfsId,
    IN PTOKEN_USER    UserId
    );

NTSTATUS
EfsRefreshCache(
    IN GUID   *EfsId,
    IN PTOKEN_USER    UserId
    );

BOOLEAN
SkipCheckStream(
    IN PIO_STACK_LOCATION IrpSp,
    IN PVOID efsStreamData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\efs\efsrtl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   efsrtl.c

Abstract:

    This module contains the code that implements the EFS
    call back routines.

Author:

    Robert Gu (robertg) 08-Dec-1996

Environment:

    Kernel mode


Revision History:


--*/

#include "efsrtl.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, EfsEncryptKeyFsData)
#pragma alloc_text(PAGE, EfsOpenFile)
#pragma alloc_text(PAGE, EfsFileControl)
#pragma alloc_text(PAGE, EfsRead)
#pragma alloc_text(PAGE, EfsWrite)
#pragma alloc_text(PAGE, EfsFreeContext)
#pragma alloc_text(PAGE, EfsMountVolumn)
#pragma alloc_text(PAGE, EfsDismountVolumn)
#pragma alloc_text(PAGE, EfsDismountVolumn)
#endif


VOID
EfsEncryptKeyFsData(
    IN PVOID DataBuffer,
    IN ULONG DataLength,
    IN ULONG DataEncOffset,
    IN ULONG RefdataEncOffset,
    IN ULONG RefdataEncLength
    )
/*++

Routine Description:

    This is called by EFS driver to prepare a FSCTL input data buffer.
    The result data will be in the format of
    SUB-CODE plain text, [FSCTL_CODE, SUB-CODE, refdata, [refdata]sk, $EFS]sk

Arguments:

    DataBuffer  -- Point to a buffer holding the FSCTL input data.

    DataLength  -- Input data length.

    DataEncOffset -- The offset of the first byte to be encrypted.

    RefdataEncOffset -- The offset of the first reference byte to be encrypted.
                        Second round encryption.

    RefdataEncLength -- The length of the refdata.

Return Value:

    No.

--*/
{

    LONG bytesToBeEnc;
    PUCHAR pWorkData;
    ULONG encryptionRound;

    PAGED_CODE();

    //
    // Data to be encrypted must be in the blocks of DES_BLOCKLEN
    //

    ASSERT( ((DataLength - DataEncOffset) % DES_BLOCKLEN) == 0 );
    ASSERT( (RefdataEncLength % DES_BLOCKLEN) == 0 );

    //
    // Encrypt the reference data first. Reference data is the data we used to
    // verify the caller. The data can be in the form FEK or sessionKey or
    // sessionKey plus some changeable data
    //

    pWorkData = ((PUCHAR)DataBuffer) + RefdataEncOffset;
    bytesToBeEnc = (LONG) RefdataEncLength;
    encryptionRound = 1;

    do {

        while ( bytesToBeEnc > 0 ) {

            //
            // Encrypt data with DES
            //

            des( pWorkData,
                 pWorkData,
                 &(EfsData.SessionDesTable[0]),
                 ENCRYPT
               );

            pWorkData += DES_BLOCKLEN;
            bytesToBeEnc -= DES_BLOCKLEN;

        }

        //
        // Then encrypt the whole data except the header bytes.
        //

        pWorkData = ((PUCHAR)DataBuffer) + DataEncOffset;
        bytesToBeEnc = (LONG) (DataLength - DataEncOffset);
        encryptionRound++;

    } while ( encryptionRound < 3 );

    return;

}

NTSTATUS
EfsOpenFile(
    IN OBJECT_HANDLE FileHdl,
    IN OBJECT_HANDLE ParentDir OPTIONAL,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG FileDirFlag,
    IN ULONG SystemState,
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT VolDo,
    IN PVOID PfileKeyContext,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength,
    IN OUT PVOID *PCreateContext,
    IN OUT PBOOLEAN Reserved
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system when
    an encrypted file is opened or a new file under encrypted directory is
    created.

Arguments:

    FileHdl  -- An object handle of the file

    ParentDir - An object handle of the parent. Can be null for create file in
                root directory. It will be used by EFS only a new file is created.

    IrpSp -- Irp Stack Location pointer.

    FileDirFlag  -- Indicating the status of the parent of the stream, may have four values,
                    FILE_NEW, FILE_EXISTING, DIRECTORY_NEW and DIRECTORY_EXISTING and the
                    status of the stream itself.

    IrpContext - Used in NtOfsCreateAttributeEx().

    VolDo - A pointer to the volumn device object.

    PContext - Not used by EFS.

    PContextLength - Not used by EFS.

Return Value:

    Result of the operation.
    File system should fail the CREATE IRP if fail code returned.

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PEFS_CONTEXT    pEFSContext;
    ULONG   efsLength;
    PVOID   efsStreamData;
    ULONG   information;
    IN PFILE_OBJECT fileObject = IrpSp->FileObject;
/*
    PIO_SECURITY_CONTEXT sContext;
    sContext = IrpSp->Parameters.Create.SecurityContext;
    DbgPrint( "\n Create: Desired Access %x\n", sContext->DesiredAccess );
    DbgPrint( "\n Create: Original Desired Access %x\n", sContext->AccessState->OriginalDesiredAccess );
    DbgPrint( "\n Create: PrevGrant Access %x\n", sContext->AccessState->PreviouslyGrantedAccess );
    DbgPrint( "\n Create: Remaining Desired Access %x\n", sContext->AccessState->RemainingDesiredAccess );
*/
    PAGED_CODE();

    //
    // If read/write data is not required, we will always succeed the call.
    // Treadted as plain text file. No encryption/decryption will be involved.
    //

    CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsOpenFile() in.\n");
#if DBG

    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( "\n EFSFILTER: ******  EFS RTL CREATE ****** \n" );
        DbgPrint( "EFSFILTER: FileDir %x\n", FileDirFlag );
        DbgPrint( "EFSFILTER: Access %x\n", IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess );
    }
#endif

    if ( FALSE == EfsData.EfsInitialized ){

        //
        // Not initialized yet.
        //

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( (IrpSp->Parameters.Create.FileAttributes & FILE_ATTRIBUTE_SYSTEM) &&
         ( FileDirFlag & (FILE_NEW | DIRECTORY_NEW) )){

        //
        // Do not encrypt SYSTEM File if creating new file
        //

        return STATUS_SUCCESS;
    }

    if ( (IrpSp->Parameters.Create.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
         ((FileDirFlag & EXISTING_FILE_ENCRYPTED) == 0) &&
         ((FileDirFlag & (FILE_NEW | DIRECTORY_NEW) ) == 0)){

        //
        // Do not encrypt a stream if the file is not encrypted
        //

        return STATUS_SUCCESS;
    }

    if ( (FileDirFlag & (FILE_EXISTING | DIRECTORY_EXISTING)) &&
         !( FileDirFlag & STREAM_NEW ) &&
         !( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess &
           ( FILE_APPEND_DATA | FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE ))
       ) {

        return STATUS_SUCCESS;

    }

    //
    // Allocate the EFS context block
    //

    *PCreateContext =  (PEFS_CONTEXT)ExAllocateFromNPagedLookasideList(&(EfsData.EfsContextPool));
    if ( NULL == *PCreateContext){
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    pEFSContext = (PEFS_CONTEXT)*PCreateContext;

    //
    // Set initial status value and initialize the event
    //

    RtlZeroMemory( pEFSContext, sizeof( EFS_CONTEXT ) );
    pEFSContext->Status = NO_FURTHER_PROCESSING;
    pEFSContext->Flags = SystemState;
    KeInitializeEvent(&( pEFSContext->FinishEvent ), SynchronizationEvent, FALSE);

    switch (FileDirFlag & FILE_DIR_TYPE) {

        case FILE_EXISTING:

            //
            // An existing file. Either a new stream created or
            // an existing stream opened
            // The user must be verified.
            // Trying to open $EFS on the file.
            //
#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( " EFSFILTER: ******  File Existed ****** \n" );
    }
#endif
            try{

                ntStatus = EfsReadEfsData(
                                    FileHdl,
                                    IrpContext,
                                    &efsStreamData,
                                    &efsLength,
                                    &information
                                    );
            } finally {
                if (AbnormalTermination()) {
                    ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEFSContext );
                    *PCreateContext = NULL;
                }
            }

            if ( EFS_READ_SUCCESSFUL == information ){

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){

        DbgPrint( " EFSFILTER: ******  $EFS Existed ****** \n" );

    }
#endif

                //
                // Check if multi-stream.
                //

                if ( PfileKeyContext && SkipCheckStream(IrpSp, efsStreamData)) {

                    //
                    // Skip calling the user mode code
                    //

                    ExFreePool(efsStreamData);
                    efsStreamData = NULL;

                    if ( NULL == *PContext ) {
                        *PContext = GetKeyBlobBuffer(((PKEY_BLOB)PfileKeyContext)->AlgorithmID);
                        if (*PContext) {

                            *PContextLength = ((PKEY_BLOB) *PContext)->KeyLength;
                            RtlCopyMemory( *PContext, PfileKeyContext, ((PKEY_BLOB)PfileKeyContext)->KeyLength );

                        } else {

                            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                            ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEFSContext );
                            *PCreateContext = NULL;

                        }
                    }

                    if (*PContext) {
                        if ( FileDirFlag & STREAM_NEW ){

                            //
                            // New stream, we need to turn on the bit
                            //

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
      DbgPrint("Cache New Named String\n");
    }
#endif
                            pEFSContext->Status = TURN_ON_ENCRYPTION_BIT | TURN_ON_BIT_ONLY | NO_OPEN_CACHE_CHECK;

                        } else {

                            //
                            // Open existing stream, no further actions required.
                            //
#if DBG
    if ( EFSTRACEALL & EFSDebug ){
      DbgPrint("Cache Existing Named String\n");
    }
#endif
                            ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEFSContext );
                            *PCreateContext = NULL;
                            ntStatus = STATUS_SUCCESS;
                        }
                    }

                } else {

                    //
                    // Set the pointers in context block
                    //
                    pEFSContext->EfsStreamData = efsStreamData;
                    pEFSContext->Status = VERIFY_USER_REQUIRED;

                    if ( NULL == *PContext ) {

                        //
                        //  Do not check open cache. We need the key blob.
                        //

                        pEFSContext->Status |= NO_OPEN_CACHE_CHECK;
                    }

                    if ( FileDirFlag & STREAM_NEW ) {
#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( " EFSFILTER: ****** File Existed & Stream New ****** \n" );
    }
#endif
                        pEFSContext->Status |= TURN_ON_ENCRYPTION_BIT;
                    }
                }

            }

            //
            // If EFS_READ_SUCCESSFUL != information
            // ntStatus might still be STATUS_SUCCESS which means it is not
            // encrypted by EFS and we succeeded call.
            // Should we fail the call?
            //

            break;

        case FILE_NEW:

            //
            // A new file created
            // New FEK, DDF, DRF needed
            // Trying to open $EFS on the parent directory
            //

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( " EFSFILTER: ******  File New ****** \n" );
    }
#endif
            try {
                ntStatus = EfsReadEfsData(
                                    ParentDir,
                                    IrpContext,
                                    &efsStreamData,
                                    &efsLength,
                                    &information
                                    );
            } finally {
                if (AbnormalTermination()) {
                    ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEFSContext );
                    *PCreateContext = NULL;
                }
            }

            if ( EFS_READ_SUCCESSFUL == information ){

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){

        DbgPrint( " EFSFILTER: ****** Parent $EFS Existed ****** \n" );

    }
#endif
                //
                // Set the pointers in context block
                //
                pEFSContext->EfsStreamData = efsStreamData;
                pEFSContext->Status = NEW_FILE_EFS_REQUIRED |
                                      TURN_ON_ENCRYPTION_BIT |
                                      NO_OPEN_CACHE_CHECK;

            } else if ( OPEN_EFS_FAIL == information ) {
                pEFSContext->EfsStreamData = NULL;
                pEFSContext->Status = NEW_FILE_EFS_REQUIRED |
                                      TURN_ON_ENCRYPTION_BIT |
                                      NO_OPEN_CACHE_CHECK;
                ntStatus =  STATUS_SUCCESS;
            }

            //
            // If EFS_READ_SUCCESSFUL != information
            // ntStatus might still be STATUS_SUCCESS which means it is not
            // encrypted by EFS and we succeeded call.
            // Should we fail the call?
            //

            break;

        case DIRECTORY_NEW:

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( " EFSFILTER: ****** Directory New ****** \n" );
    }
#endif
            //
            // A new directory created
            // New Public keys needed
            // Trying to open $EFS on the parent directory
            //

            try {

                ntStatus = EfsReadEfsData(
                                    ParentDir,
                                    IrpContext,
                                    &efsStreamData,
                                    &efsLength,
                                    &information
                                    );

            } finally {
                if (AbnormalTermination()) {
                    ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEFSContext );
                    *PCreateContext = NULL;
                }
            }

            if ( EFS_READ_SUCCESSFUL == information ){

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( " EFSFILTER: ****** Parent $EFS Existed ****** \n" );
    }
#endif

                //
                // Set the pointers in context block
                //
                pEFSContext->EfsStreamData = efsStreamData;
                pEFSContext->Status = NEW_DIR_EFS_REQUIRED |
                                      TURN_ON_ENCRYPTION_BIT |
                                      NO_OPEN_CACHE_CHECK;

            } else if ( OPEN_EFS_FAIL == information ) {
                pEFSContext->EfsStreamData = NULL;
                pEFSContext->Status = NEW_DIR_EFS_REQUIRED |
                                      TURN_ON_ENCRYPTION_BIT |
                                      NO_OPEN_CACHE_CHECK;
                ntStatus =  STATUS_SUCCESS;
            }


            //
            // If EFS_READ_SUCCESSFUL != information
            // ntStatus might still be STATUS_SUCCESS which means it is not
            // encrypted by EFS and we succeeded call.
            // Should we fail the call?
            //

            break;

        case DIRECTORY_EXISTING:

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( " EFSFILTER: ****** Directory Existed ****** \n" );
    }
#endif
            //
            // An existing directory. Either a new stream created or
            // an existing stream opened
            // We do not encrypt data stream for Directory. Ignore this.
            //

        default:

            break;

    }

    CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsOpenFile() Out.\n");
    return ntStatus;
}

NTSTATUS
EfsFileControl(
    IN PVOID PInputBuffer,
    IN ULONG InputDataLength,
    OUT PVOID POutputBuffer OPTIONAL,
    IN OUT PULONG POutputBufferLength,
    IN ULONG EncryptionFlag,
    IN ULONG AccessFlag,
    IN ULONG SystemState,
    IN ULONG FsControlCode,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT VolDo,
    IN ATTRIBUTE_HANDLE StreamHdl,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system to
    support EFS's FSCTL APIs

Arguments:

    PInputBuffer - Pointer to the input data buffer. The first 4 bytes are
                  for information to Ntfs or some other drivers only. The EFS related
                  data are encrypted in the following bytes. The first 4 encrypted
                  bytes are subfunction code in the form of EFS_XXX. General package
                  looks like this,
                  Subcode plain text, EFS subfunction code, EFS subcode cipher text, FSCTL specific data.

    InputDataLength - The length of the input data buffer.

    POutputBuffer - Pointer to the output data buffer.

    POutputBufferLength - The length of the output data.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    AccessFlag - Indicating the desired access when the stream is opened.

    FsControlCode - Indicating what FSCTL was originally called.

    FileHdl - Used to access the $EFS.

    IrpContext - Irp context used to call NtOfsCreateAttributeEx().

    VolDo - A pointer to the volumn device object.

    StreamHdl - Stream to be worked on.

    PContext - BLOB(key) for READ or WRITE later.

    PContextLength - The length of the context.

Return Value:

    STATUS_SUCCESS for successful operation.

--*/
{

    ULONG functionCode;
    ULONG bytesSame;
    ULONG efsLength;
    ULONG workOffset;
    ULONG information;
    PUCHAR pCmdContext = NULL;
    PVOID efsStreamData = NULL;
    NTSTATUS ntStatus;
    ATTRIBUTE_HANDLE  attribute;
    BOOLEAN verifyInput;

    PAGED_CODE();

    CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFileControl() in.\n");
#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( "\n EFSFILTER: ******  EFS RTL FSCTL ****** \n" );
    }
#endif

    if ( (NULL == PInputBuffer) || ( FALSE == EfsData.EfsInitialized )){
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Input data is encrypted by DES with sessionKey.
    // As long as we do not change the algorithm for the input data
    // We need guarantee the data length is in multiple of DES block size.
    // The first four bytes is always in plain text intended to hold the data
    // the NTFS is interested in.
    // The general format of input data is,
    // Sub-code plain text, [FsCode, Sub-code cipher text, [FsData]]sk
    //

    if ((InputDataLength < sizeof(FSCTL_INPUT)) || ((( InputDataLength - sizeof( ULONG )) % DES_BLOCKLEN ) != 0)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    pCmdContext = ExAllocatePoolWithTag(
                                PagedPool,
                                InputDataLength,
                                'csfE'
                                );

    if ( NULL == pCmdContext ){

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Decrypt FSCTL input buffer. No CBC is used.
    //

    try {
        RtlCopyMemory( pCmdContext, PInputBuffer, InputDataLength );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        ntStatus = GetExceptionCode();
        ExFreePool( pCmdContext );
        if (FsRtlIsNtstatusExpected( ntStatus)) {
            return ntStatus;
        } else {
            return STATUS_INVALID_USER_BUFFER;
        }
    }

    workOffset = sizeof( ULONG );
    while ( workOffset < InputDataLength ){

        des( pCmdContext + workOffset,
             pCmdContext + workOffset,
             &(EfsData.SessionDesTable[0]),
             DECRYPT
           );

        workOffset += DES_BLOCKLEN;
    }

    functionCode = ((PFSCTL_INPUT)pCmdContext)->EfsFsCode;

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( "\n EFSFILTER: EFS RTL FSCTL=%x \n", functionCode);
    }
#endif

    //
    // Check the codes match for set encrypt and decrypt to guard the integrity
    // of the encryption status. The NTFS is going to set/clear the bits. We really
    // want to make sure the FSCTL is issued by the right module.
    //

    if ( FSCTL_SET_ENCRYPTION == FsControlCode){
        if (SystemState & SYSTEM_IS_READONLY) {
            ExFreePool( pCmdContext );
            return STATUS_MEDIA_WRITE_PROTECTED;
        }
        if ( EFS_SET_ENCRYPT == functionCode ){
            if ( ((PFSCTL_INPUT)pCmdContext)->PlainSubCode !=
                 (((PFSCTL_INPUT)pCmdContext)->CipherSubCode & ~EFS_FSCTL_ON_DIR ) ){

                ExFreePool( pCmdContext );
                return STATUS_INVALID_DEVICE_REQUEST;

            }
        } else if ( (EFS_SET_ATTRIBUTE != functionCode) &&
                    (EFS_OVERWRITE_ATTRIBUTE != functionCode) ){

             ExFreePool( pCmdContext );
             return STATUS_INVALID_DEVICE_REQUEST;

        }
     }

    switch ( functionCode ){

        case EFS_SET_ATTRIBUTE:

            //
            // Write $EFS and/or set key Blob
            // subCode is a bit mask for the combination of write $EFS and set blob
            // [FsData] = FEK, [FEK]sk, [$EFS]
            //     FEK == sessionKey when set key Blob is not required
            //
            // We cannot check access rights here. This call will be made if the
            // user creates a new file and without any access requirement. We
            // still want to setup FEK inside this call.
            //

            if ( !EfsVerifyKeyFsData(
                        &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]),
                        InputDataLength) ){

                //
                // Input data format error
                //

                ExFreePool( pCmdContext );
                return STATUS_INVALID_PARAMETER;

            }

            try {
                ntStatus = SetEfsData(
                            pCmdContext,
                            InputDataLength,
                            SystemState,
                            FileHdl,
                            IrpContext,
                            PContext,
                            PContextLength
                            );
            } finally {

                ExFreePool( pCmdContext );

            }
            CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFileControl() Out 1.\n");
            return ntStatus;

        case EFS_SET_ENCRYPT:

            if ( !( AccessFlag & ( READ_DATA_ACCESS | WRITE_DATA_ACCESS ))){

                //
                // Check access flag
                //
                ExFreePool( pCmdContext );
                return STATUS_ACCESS_DENIED;

            }

            try {
                ntStatus = EfsSetEncrypt(
                                pCmdContext,
                                InputDataLength,
                                EncryptionFlag,
                                FileHdl,
                                IrpContext,
                                PContext,
                                PContextLength
                                );
            } finally {
                ExFreePool( pCmdContext );
            }

            CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFileControl() Out 2.\n");
            return ntStatus;

        case EFS_GET_ATTRIBUTE:

            //
            // Provide read access to $EFS for EFS service
            // Verify the input data format first.
            //

            try {
                if ( (NULL == POutputBuffer) ||
                      (*POutputBufferLength < sizeof(ULONG)) ||
                     !EfsVerifyGeneralFsData(
                            &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]),
                            InputDataLength)){

                    ExFreePool( pCmdContext );
                    return STATUS_INVALID_PARAMETER;

                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                ntStatus = GetExceptionCode();
                ExFreePool( pCmdContext );
                if (FsRtlIsNtstatusExpected( ntStatus)) {
                    return ntStatus;
                } else {
                    return STATUS_INVALID_USER_BUFFER;
                }
            }

            if ( !(EncryptionFlag &  STREAM_ENCRYPTED) ){
                ExFreePool( pCmdContext );
                return STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            // Try to read an existing $EFS
            //

            try {
                ntStatus = EfsReadEfsData(
                                    FileHdl,
                                    IrpContext,
                                    &efsStreamData,
                                    &efsLength,
                                    &information
                                    );
            } finally {

                ExFreePool( pCmdContext );
                pCmdContext = NULL;

            }

            if ( EFS_READ_SUCCESSFUL == information ){

                //
                // Everything is OK. We do not check user ID here,
                // we suppose that has been checked by the service.
                //

                try {
                    ntStatus = STATUS_SUCCESS;
                    if ( efsLength > *POutputBufferLength ) {

                        * (ULONG *) POutputBuffer = efsLength;
                        *POutputBufferLength = sizeof(ULONG);
                        ExFreePool( efsStreamData );
                        return STATUS_BUFFER_TOO_SMALL;

                    }

                    RtlCopyMemory(POutputBuffer, efsStreamData, efsLength);
                    *POutputBufferLength = efsLength;
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    ntStatus = GetExceptionCode();
                    if (!FsRtlIsNtstatusExpected( ntStatus)) {
                        ntStatus = STATUS_INVALID_USER_BUFFER;
                    }
                }

                ExFreePool( efsStreamData );
                return ntStatus;

            } else if ( ( OPEN_EFS_FAIL == information ) ||
                            ( EFS_FORMAT_ERROR == information ) ) {

                //
                // EFS does not exist or not encrypted by the EFS ?
                //

                ntStatus =  STATUS_INVALID_DEVICE_REQUEST;

            }


            //
            // Other error while opening $EFS
            //

            return ntStatus;

        case EFS_DEL_ATTRIBUTE:

            if (SystemState & SYSTEM_IS_READONLY) {
                ExFreePool( pCmdContext );
                return STATUS_MEDIA_WRITE_PROTECTED;
            }
            if ( !( AccessFlag & WRITE_DATA_ACCESS )){

                //
                // Check access flag
                //

                ExFreePool( pCmdContext );
                return STATUS_ACCESS_DENIED;

            }

            //
            // Delete $EFS after all the stream has been decrypted.
            //

            if ( EncryptionFlag ){

                //
                // Stream has not been decrypted
                //

                ExFreePool( pCmdContext );
                return STATUS_INVALID_DEVICE_REQUEST;

            }

            //
            // [FsData] = SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
            // Verify the FsData format.
            //

            if ( !EfsVerifyGeneralFsData(
                        &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]),
                        InputDataLength) ){

                //
                // Input data format error
                //

                ExFreePool( pCmdContext );
                return STATUS_INVALID_PARAMETER;

            }

            //
            // Delete the $EFS stream
            //

            try {
                ntStatus = EfsDeleteEfsData( FileHdl, IrpContext );
            } finally {
                ExFreePool( pCmdContext );
            }

            return ntStatus;

        case EFS_ENCRYPT_DONE:

            //
            // Change the transition state of $EFS to normal state
            // Fall through intended.
            //
#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( "\n EFSFILTER: Encryption Done %x\n", functionCode );
    }
#endif

        case EFS_DECRYPT_BEGIN:

            if (SystemState & SYSTEM_IS_READONLY) {
                ExFreePool( pCmdContext );
                return STATUS_MEDIA_WRITE_PROTECTED;
            }
            if ( !( AccessFlag & WRITE_DATA_ACCESS )){

                //
                // Check access flag
                //

                ExFreePool( pCmdContext );
                return STATUS_ACCESS_DENIED;

            }

            //
            // Mark the transition state of $EFS
            //

            try {
                ntStatus = EfsModifyEfsState(
                                functionCode,
                                pCmdContext,
                                InputDataLength,
                                FileHdl,
                                IrpContext
                                );
            } finally {

                ExFreePool( pCmdContext );

            }

            return ntStatus;

        case EFS_OVERWRITE_ATTRIBUTE:

            if ( !( AccessFlag &
                   ( WRITE_DATA_ACCESS |
                     RESTORE_ACCESS ))){

                //
                // Check access flag
                //
                ExFreePool( pCmdContext );
                return STATUS_ACCESS_DENIED;

            }

            //
            // Mostly used in import
            // Overwrite $EFS and/or set key Blob
            // subCode is a bit mask for the combination of write $EFS and set blob
            //

            if ( ((PFSCTL_INPUT)pCmdContext)->CipherSubCode & SET_EFS_KEYBLOB ){

                verifyInput = EfsVerifyKeyFsData(
                                            &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]),
                                            InputDataLength
                                            );

            } else {

                verifyInput = EfsVerifyGeneralFsData(
                                            &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]),
                                            InputDataLength
                                            );

            }

            if ( !verifyInput ){

                //
                // Input data format error
                //

                ExFreePool( pCmdContext );
                return STATUS_INVALID_PARAMETER;

            }

            try {
                ntStatus = SetEfsData(
                            pCmdContext,
                            InputDataLength,
                            SystemState,
                            FileHdl,
                            IrpContext,
                            PContext,
                            PContextLength
                            );
            } finally {

                ExFreePool( pCmdContext );

            }
            CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFileControl() Out 3.\n");
            return ntStatus;

        default:
//            ASSERT (FALSE);
            ExFreePool( pCmdContext );
            return STATUS_INVALID_DEVICE_REQUEST;
    }
    CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFileControl() Out 4.\n");
}


NTSTATUS
EfsRead(
    IN OUT PUCHAR InOutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PVOID Context
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system and
    decrypt the data in the buffer provided by the file system.

Arguments:

    InOutBuffer - Pointer to the data block to be decrypted.

    Offset - Pointer to the offset of the block in the file. Relative to the
             beginning of the file.

    BufferSize - Length of the data block.

    Context - Information needed to decrypt the file. Passed to the file
              system on EfsOpenFile()

Return Value:

    This routine will not cause error. Unless the memory passed in is not
    valid. In that case, memory flush will occur.

--*/
{
    ULONGLONG chainBlockIV[2];
    PUCHAR pWorkBuffer = InOutBuffer;
    EfsDecFunc  pDecryptFunc;


    PAGED_CODE();

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( "\n EFSFILTER: READ Bytes = %x, Offset = %x\n", BufferSize,  Offset->QuadPart);
    }
#endif

    //
    // Data length should be in multiple of the chunk (512 Bytes)
    // Data offset (relative to the begining of the stream) should
    // Start at chunk boundary
    //

    CheckValidKeyBlock(Context,"Please contact RobertG if you see this. EfsRead() in.\n");
    ASSERT (BufferSize % CHUNK_SIZE == 0);
    ASSERT (Offset->QuadPart % CHUNK_SIZE == 0);


    switch (((PKEY_BLOB)Context)->AlgorithmID){

        case CALG_3DES:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pDecryptFunc = EFSDes3Dec;
            break;
        case CALG_DESX:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pDecryptFunc = EFSDesXDec;
            break;
        case CALG_AES_256:
            chainBlockIV[0] = Offset->QuadPart + EFS_AES_IVL;
            chainBlockIV[1] = Offset->QuadPart + EFS_AES_IVH;
            pDecryptFunc = EFSAesDec;
            break;
        case CALG_DES:
        default:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pDecryptFunc = EFSDesDec;
            break;
    }

    while ( BufferSize > 0 ){

        pDecryptFunc(pWorkBuffer,
                  (PUCHAR) &chainBlockIV[0],
                  (PKEY_BLOB) Context,
                  CHUNK_SIZE
                  );

        pWorkBuffer += CHUNK_SIZE;
        chainBlockIV[0] += CHUNK_SIZE;
        if (((PKEY_BLOB)Context)->AlgorithmID == CALG_AES_256) {
            chainBlockIV[1] += CHUNK_SIZE;
        }
        BufferSize -= CHUNK_SIZE;
    }

    CheckValidKeyBlock(Context,"Please contact RobertG if you see this. EfsRead() out.\n");
    return ( STATUS_SUCCESS );
}


NTSTATUS
EfsWrite(
    IN PUCHAR InBuffer,
    OUT PUCHAR OutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PUCHAR Context
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system and
    encrypt the data in the buffer provided by the file system.

    Note: The input data buffer can only be touched once.

Arguments:

    InBuffer - Pointer to the data block to be encrypted.

    OutBuffer - Pointer to the data buffer to hold the encrypted data.

    Offset - Pointer to the offset of the block in the file. Relative to the
             beginning of the file.

    BufferSize - Length of the data block.

    Context - Information needed to decrypt the file. Passed to the file
              system on EfsOpenFile()

Return Value:

    This routine will not cause error. Unless the memory passed in is not
    valid. In that case, memory flush will occur.

--*/
{
    ULONGLONG chainBlockIV[2];
    PUCHAR pWorkInBuffer = InBuffer;
    PUCHAR pWorkOutBuffer = OutBuffer;
    EfsEncFunc  pEncryptFunc;


    PAGED_CODE();

    //
    // Data length should be in multiple of the chunk (512 Bytes)
    // Data offset (relative to the begining of the stream) should
    // Start at chunk boundary
    //

    CheckValidKeyBlock(Context,"Please contact RobertG if you see this. EfsWrite() in.\n");
    ASSERT (BufferSize % CHUNK_SIZE == 0);
    ASSERT (Offset->QuadPart % CHUNK_SIZE == 0);

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( "\n EFSFILTER: WRITE Bytes = %x, Offset = %x\n", BufferSize,  Offset->QuadPart);
    }
#endif

    switch (((PKEY_BLOB)Context)->AlgorithmID){
        case CALG_3DES:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pEncryptFunc = EFSDes3Enc;
            break;
        case CALG_DESX:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pEncryptFunc = EFSDesXEnc;
            break;
        case CALG_AES_256:
            chainBlockIV[0] = Offset->QuadPart + EFS_AES_IVL;
            chainBlockIV[1] = Offset->QuadPart + EFS_AES_IVH;
            pEncryptFunc = EFSAesEnc;
            break;
        case CALG_DES:
        default:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pEncryptFunc = EFSDesEnc;
            break;
    }

    while ( BufferSize > 0 ){
        pEncryptFunc(pWorkInBuffer,
                  pWorkOutBuffer,
                  (PUCHAR) &chainBlockIV,
                  (PKEY_BLOB)Context,
                  CHUNK_SIZE
                  );

        pWorkInBuffer += CHUNK_SIZE;
        pWorkOutBuffer += CHUNK_SIZE;
        chainBlockIV[0] += CHUNK_SIZE;
        if (((PKEY_BLOB)Context)->AlgorithmID == CALG_AES_256) {
            chainBlockIV[1] += CHUNK_SIZE;
        }
        BufferSize -= CHUNK_SIZE;
    }
    CheckValidKeyBlock(Context,"Please contact RobertG if you see this. EfsWrite() out.\n");
    return STATUS_SUCCESS;
}

VOID
EfsFreeContext(
    IN OUT PVOID *PContext
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system to
    free the context block.

Arguments:

    PContext - Context block to be freed.

Return Value:

    This routine will not cause error. Unless the memory passed in is not
    valid.

--*/
{
    PAGED_CODE();

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( " EFSFILTER: ******  Free Key ****** \n" );
    }
#endif

    CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFreeContext() in.\n");
    if (*PContext){
        FreeMemoryBlock(PContext);
    }

}

NTSTATUS
EfsMountVolumn(
    IN PDEVICE_OBJECT VolDo,
    IN PDEVICE_OBJECT RealDevice
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system
    when a volumn needs to be attached

Arguments:

    VolDo - Volume device object
    RealDevice - Volume real device object

Return Value:

    The status of operation.

--*/
{
    PDEVICE_OBJECT fsfDeviceObject;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( "\n *****EFSFILTER:  RTL mount.***** \n" );
    }
#endif

    return STATUS_SUCCESS;

}

VOID
EfsDismountVolumn(
    IN PDEVICE_OBJECT VolDo
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system
    when a volumn is dismounted

Arguments:

    VolDo - volumn's device object.

Return Value:

    No return value.

--*/
{
    PAGED_CODE();

#if DBG

    if ( EFSTRACEALL & EFSDebug ){

        DbgPrint( "EFSFILTER:  Dismount callback. \n" );

    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\efs\encrypt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   encrypt.c

Abstract:

   This module will support data encryption and decryption

Author:

    Robert Gu (robertg) 08-Dec-1996
Environment:

   Kernel Mode Only

Revision History:

--*/


#include "efsrtl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, EFSDesEnc)
#pragma alloc_text(PAGE, EFSDesDec)
#pragma alloc_text(PAGE, EFSDesXEnc)
#pragma alloc_text(PAGE, EFSDesXDec)
#pragma alloc_text(PAGE, EFSDes3Enc)
#pragma alloc_text(PAGE, EFSDes3Dec)
#pragma alloc_text(PAGE, EFSAesEnc)
#pragma alloc_text(PAGE, EFSAesDec)
#endif


VOID
EFSDesEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DES CBC encryption. The DES is implemented by LIB
    function des().

Arguments:

    InBuffer - Pointer to the data buffer (encryption in place)
    IV - Initial chaining vector (DES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DES_BLOCKLEN = 0)

Note:

    Input buffer can only be touched once. This the requirement by the Ntfs & CC.

--*/
{
    ULONGLONG chainBlock;
    ULONGLONG tmpData;
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % DES_BLOCKLEN == 0);

    chainBlock = *(ULONGLONG *)IV;
    KeyTable = &(KeyBlob->Key[0]);
    while (Length > 0){

        //
        //  Block chaining
        //
        tmpData = *(ULONGLONG *)InBuffer;
        tmpData ^= chainBlock;

        //
        //  Call DES LIB to encrypt the DES_BLOCKLEN bytes
        //  We are using DECRYPT/ENCRYPT for real ENCRYPT/DECRYPT. This is for the backward
        //  compatiblity. The old definitions were reversed.
        //

        des( OutBuffer, (PUCHAR) &tmpData,  KeyTable, DECRYPT );
        chainBlock = *(ULONGLONG *)OutBuffer;
        Length -= DES_BLOCKLEN;
        InBuffer += DES_BLOCKLEN;
        OutBuffer += DES_BLOCKLEN;
    }
}

VOID
EFSDesDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DES CBC decryption. The DES is implemented by LIB
    function des().

Arguments:

    Buffer - Pointer to the data buffer (decryption in place)
    IV - Initial chaining vector (DES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DES_BLOCKLEN = 0)

--*/
{
    ULONGLONG chainBlock;
    PUCHAR  pBuffer;
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % DES_BLOCKLEN == 0);

    pBuffer = Buffer + Length - DES_BLOCKLEN;
    KeyTable = &(KeyBlob->Key[0]);

    while (pBuffer > Buffer){

        //
        //  Call DES LIB to decrypt the DES_BLOCKLEN bytes
        //  We are using DECRYPT/ENCRYPT for real ENCRYPT/DECRYPT. This is for the backward
        //  compatiblity. The old definitions were reversed.
        //

        des( pBuffer, pBuffer, KeyTable, ENCRYPT );

        //
        //  Undo the block chaining
        //

        chainBlock = *(ULONGLONG *)( pBuffer - DES_BLOCKLEN );
        *(ULONGLONG *)pBuffer ^= chainBlock;

        pBuffer -= DES_BLOCKLEN;
    }

    //
    // Now decrypt the first block
    //
    des( pBuffer, pBuffer, KeyTable, ENCRYPT );

    chainBlock = *(ULONGLONG *)IV;
    *(ULONGLONG *)pBuffer ^= chainBlock;
}

VOID
EFSDesXEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DESX CBC encryption. The DESX is implemented by
    LIBRARY function desx().

Arguments:

    InBuffer - Pointer to the data buffer (encryption in place)
    IV - Initial chaining vector (DESX_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DESX_BLOCKLEN = 0)

Note:

    Input buffer can only be touched once. This the requirement by the Ntfs & CC.

--*/
{
    ULONGLONG chainBlock;
    ULONGLONG tmpData;
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % DESX_BLOCKLEN == 0);

    chainBlock = *(ULONGLONG *)IV;
    KeyTable = &(KeyBlob->Key[0]);
    while (Length > 0){

        //
        //  Block chaining
        //
        tmpData = *(ULONGLONG *)InBuffer;
        tmpData ^= chainBlock;

        //
        //  Call LIB to encrypt the DESX_BLOCKLEN bytes
        //  We are using DECRYPT/ENCRYPT for real ENCRYPT/DECRYPT. This is for the backward
        //  compatiblity. The old definitions were reversed.
        //

        desx( OutBuffer, (PUCHAR) &tmpData,  KeyTable, DECRYPT );
        chainBlock = *(ULONGLONG *)OutBuffer;
        Length -= DESX_BLOCKLEN;
        InBuffer += DESX_BLOCKLEN;
        OutBuffer += DESX_BLOCKLEN;
    }
}

VOID
EFSDesXDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DESX CBC decryption. The DESX is implemented by
    LIBRARY function desx().

Arguments:

    Buffer - Pointer to the data buffer (decryption in place)
    IV - Initial chaining vector (DESX_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DESX_BLOCKLEN = 0)

--*/
{
    ULONGLONG chainBlock;
    PUCHAR  pBuffer;
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % DESX_BLOCKLEN == 0);

    pBuffer = Buffer + Length - DESX_BLOCKLEN;
    KeyTable = &(KeyBlob->Key[0]);

    while (pBuffer > Buffer){

        //
        //  Call LIB to decrypt the DESX_BLOCKLEN bytes
        //  We are using DECRYPT/ENCRYPT for real ENCRYPT/DECRYPT. This is for the backward
        //  compatiblity. The old definitions were reversed.
        //

        desx( pBuffer, pBuffer, KeyTable, ENCRYPT );

        //
        //  Undo the block chaining
        //

        chainBlock = *(ULONGLONG *)( pBuffer - DESX_BLOCKLEN );
        *(ULONGLONG *)pBuffer ^= chainBlock;

        pBuffer -= DESX_BLOCKLEN;
    }

    //
    // Now decrypt the first block
    //
    desx( pBuffer, pBuffer, KeyTable, ENCRYPT );

    chainBlock = *(ULONGLONG *)IV;
    *(ULONGLONG *)pBuffer ^= chainBlock;
}

VOID
EFSDes3Enc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DES3 CBC encryption. The DES3 is implemented by 
    LIBRARY function tripledes().

Arguments:

    InBuffer - Pointer to the data buffer (encryption in place)
    IV - Initial chaining vector (DES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DES_BLOCKLEN = 0)

Note:

    Input buffer can only be touched once. This the requirement by the Ntfs & CC.

--*/
{
    ULONGLONG chainBlock = *(ULONGLONG *)IV;
    ULONGLONG tmpData;
    PUCHAR   KeyTable;
   
    ASSERT (Length % DES_BLOCKLEN == 0);

    EfsData.FipsFunctionTable.FipsBlockCBC(        
        FIPS_CBC_3DES, 
        OutBuffer, 
        InBuffer,
        Length,
        &(KeyBlob->Key[0]), 
        ENCRYPT, 
        (PUCHAR) &chainBlock 
        );
}

VOID
EFSDes3Dec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DES3 CBC decryption. The DES3 is implemented by 
    LIBRARY function tripledes().

Arguments:

    Buffer - Pointer to the data buffer (decryption in place)
    IV - Initial chaining vector (DES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DES_BLOCKLEN = 0)

--*/
{
    ULONGLONG ChainIV = *(ULONGLONG *)IV;
   
    ASSERT (Length % DESX_BLOCKLEN == 0);


    EfsData.FipsFunctionTable.FipsBlockCBC( 
        FIPS_CBC_3DES, 
        Buffer, 
        Buffer, 
        Length, 
        &(KeyBlob->Key[0]), 
        DECRYPT, 
        (PUCHAR) &ChainIV 
        );

}


VOID
EFSAesEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements AES CBC encryption. The AES is implemented by
    LIBRARY function aes().

Arguments:

    InBuffer - Pointer to the data buffer (encryption in place)
    IV - Initial chaining vector (AES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % AES_BLOCKLEN = 0)

Note:

    Input buffer can only be touched once. This the requirement by the Ntfs & CC.

--*/
{
    ULONGLONG chainBlock[2];
    ULONGLONG tmpData[2];
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % AES_BLOCKLEN == 0);

    chainBlock[0] = *(ULONGLONG *)IV;
    chainBlock[1] = *(ULONGLONG *)(IV+sizeof(ULONGLONG));
    KeyTable = &(KeyBlob->Key[0]);
    
    while (Length > 0){

        //
        //  Block chaining
        //
        tmpData[0] = *(ULONGLONG *)InBuffer;
        tmpData[1] = *(ULONGLONG *)(InBuffer+sizeof(ULONGLONG));
        tmpData[0] ^= chainBlock[0];
        tmpData[1] ^= chainBlock[1];

        aes256( OutBuffer, (PUCHAR) &tmpData[0],  KeyTable, ENCRYPT );

        chainBlock[0] = *(ULONGLONG *)OutBuffer;
        chainBlock[1] = *(ULONGLONG *)(OutBuffer+sizeof(ULONGLONG));
        Length -= AES_BLOCKLEN;
        InBuffer += AES_BLOCKLEN;
        OutBuffer += AES_BLOCKLEN;
    }
}

VOID
EFSAesDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DESX CBC decryption. The DESX is implemented by
    LIBRARY function desx().

Arguments:

    Buffer - Pointer to the data buffer (decryption in place)
    IV - Initial chaining vector (AES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % AES_BLOCKLEN = 0)

--*/
{
    ULONGLONG chainBlock[2];
    PUCHAR  pBuffer;
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % AES_BLOCKLEN == 0);

    pBuffer = Buffer + Length - AES_BLOCKLEN;
    KeyTable = &(KeyBlob->Key[0]);

    while (pBuffer > Buffer){

        aes256( pBuffer, pBuffer, KeyTable, DECRYPT );


        //
        //  Undo the block chaining
        //

        chainBlock[0] = *(ULONGLONG *)( pBuffer - AES_BLOCKLEN );
        chainBlock[1] = *(ULONGLONG *)(pBuffer - sizeof(ULONGLONG));
        *(ULONGLONG *)pBuffer ^= chainBlock[0];
        *(ULONGLONG *)(pBuffer+sizeof(ULONGLONG)) ^= chainBlock[1];
        pBuffer -= AES_BLOCKLEN;
    }

    //
    // Now decrypt the first block
    //
    aes256( pBuffer, pBuffer, KeyTable, DECRYPT );

    *(ULONGLONG *)pBuffer ^= *(ULONGLONG *)IV;
    *(ULONGLONG *)(pBuffer+sizeof(ULONGLONG)) ^= *(ULONGLONG *)(IV+sizeof(ULONGLONG));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\efs\efs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

   This module contains the common header information for the EFS
   file system filter driver.

Author:

   Robert Gu (robertg)  29-Oct-1996

Enviroment:

   Kernel Mode Only

Revision History:

--*/
#ifndef EFS_H
#define EFS_H

#include "ntifs.h"

//
// BYTE is required by des.h
// PBYTE is required by des3.h
//
typedef unsigned char  BYTE;
typedef unsigned long  DWORD;
typedef unsigned char  *PBYTE; 

#include "fipsapi.h"
//#include "des.h"
//#include "tripldes.h"
#include "aes.h"
#include "ntfsexp.h"
#include "efsstruc.h"

#if DBG

#define EFSTRACEALL     0x00000001
#define EFSTRACELIGHT   0x00000002
#define EFSTRACEMED     0x00000004
#define EFSSTOPALL      0x00000010
#define EFSSTOPLIGHT    0x00000020
#define EFSSTOPMED      0x00000040

#endif // DBG

#ifndef CALG_DES
//
// Definition from sdk\inc\wincrypt.h
// Including wincrypt.h causes too much work.
//
#define ALG_CLASS_DATA_ENCRYPT          (3 << 13)
#define ALG_TYPE_BLOCK                  (3 << 9)
#define ALG_SID_DES                     1
#define ALG_SID_3DES                    3
#define ALG_SID_DESX                    4
#define ALG_SID_AES_256                 16
#define ALG_SID_AES                     17
#define CALG_DES                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DES)
#define CALG_DESX               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DESX)
#define CALG_3DES               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES)
#define CALG_AES_256            (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_256)
#define CALG_AES                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES)

#endif


//
// Define the device extension structure for this driver's extensions.
//

#define EFSFILTER_DEVICE_TYPE   0x1309

#define EFS_EVENTDEPTH     3
#define EFS_CONTEXTDEPTH   5
#define EFS_KEYDEPTH       30
#define EFS_ALGDEPTH       3

//
// Define the constants used in Open Cache
//

#define DefaultTimeExpirePeriod    5 * 10000000  // 5 seconds
#define MINCACHEPERIOD             2
#define MAXCACHEPERIOD             30
#define EFS_CACHEDEPTH  5

#define EFS_STREAM_NORMAL 0
#define EFS_STREAM_TRANSITION 1
#define EFS_STRNAME_LENGTH  6
#define EFS_FSCTL_HEADER_LENGTH 3 * sizeof( ULONG )

//
// Define test MACRO
//


#define CheckValidKeyBlock(PContext, Msg)

/*
#define CheckValidKeyBlock(PContext, Msg)    {                            \
    if (PContext) {                                                       \
       if (((PKEY_BLOB) PContext)->KeyLength != DESX_KEY_BLOB_LENGTH){    \
          DbgPrint(Msg);                                                  \
       }                                                                  \
       ASSERT(((PKEY_BLOB) PContext)->KeyLength == DESX_KEY_BLOB_LENGTH); \
    }                                                                     \
}
*/


#define FreeMemoryBlock(PContext) {                      \
    ExFreeToNPagedLookasideList(((PKEY_BLOB)(*PContext))->MemSource, *PContext);   \
    *PContext = NULL;                                    \
}

/*
#define FreeMemoryBlock(PContext) {                      \
    PNPAGED_LOOKASIDE_LIST MemSource;                    \
    MemSource = ((PKEY_BLOB)(*PContext))->MemSource;     \
    RtlFillMemory(*PContext, DESX_KEY_BLOB_LENGTH, 0x45);\
    ExFreeToNPagedLookasideList(MemSource, *PContext);   \
    *PContext = NULL;                                    \
}
*/


typedef CSHORT NODE_TYPE_CODE, *PNODE_TYPE_CODE;
typedef CSHORT NODE_BYTE_SIZE, *PNODE_BYTE_SIZE;

#define NTC_UNDEFINED                  ((NODE_TYPE_CODE)0x0000)
#define EFS_NTC_DATA_HEADER            ((NODE_TYPE_CODE)0x0E04)


#define DES_KEY_BLOB_LENGTH  (2 * sizeof(ULONG) + sizeof(PNPAGED_LOOKASIDE_LIST)  + DES_TABLESIZE)
#define DESX_KEY_BLOB_LENGTH  (2 * sizeof(ULONG) + sizeof(PNPAGED_LOOKASIDE_LIST) + DESX_TABLESIZE)
#define DES3_KEY_BLOB_LENGTH  (2 * sizeof(ULONG) + sizeof(PNPAGED_LOOKASIDE_LIST) + DES3_TABLESIZE)
#define AES_KEY_BLOB_LENGTH_256   (2 * sizeof(ULONG) + sizeof(PNPAGED_LOOKASIDE_LIST) + AES_TABLESIZE_256)

//
// EFS device object extension
//

typedef struct _DEVICE_EXTENSION {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT FileSystemDeviceObject;
    PDEVICE_OBJECT RealDeviceObject;
    BOOLEAN Attached;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// EFS context block. Attached to CREATE Irp
//

typedef struct _EFS_CONTEXT {

    //
    // Status information
    //

    ULONG   Status;
    ULONG   Flags;

    PVOID   EfsStreamData;

    KEVENT  FinishEvent;



} EFS_CONTEXT, *PEFS_CONTEXT;

//
// The keyBlob.
//

typedef struct _KEY_BLOB {

    ULONG   KeyLength;

    //
    // Indicate what kind of encryption used
    //

    ULONG   AlgorithmID;

    //
    // Where the memory comes from
    //

    PNPAGED_LOOKASIDE_LIST MemSource;
    UCHAR   Key[1];

} KEY_BLOB, *PKEY_BLOB;

typedef struct _KEY_BLOB_RAMPOOL {

    ULONG   AlgorithmID;
    PNPAGED_LOOKASIDE_LIST MemSourceList;
    LIST_ENTRY MemSourceChain;

}  KEY_BLOB_RAMPOOL, *PKEY_BLOB_RAMPOOL;

//
//   EFS Open Cache Node
//

typedef struct _OPEN_CACHE {

    GUID    EfsId;
    PTOKEN_USER    UserId;
    LARGE_INTEGER TimeStamp;
    LIST_ENTRY CacheChain;

}  OPEN_CACHE, *POPEN_CACHE;

//
//  The EFS_DATA keeps global data in the EFS file system in-memory
//  This structure must be allocated from non-paged pool.
//
typedef struct _EFS_DATA {

    //
    //  The type and size of this record (must be EFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;
    DWORD          EfsDriverCacheLength;  // Cache valid length 2 - 30 seconds       

    //
    // A Lookaside List for event object
    // The event object are used in synchronization.
    //
    NPAGED_LOOKASIDE_LIST EfsEventPool;

    //
    // A Lookaside List for EFS context
    // The EFS context is used in Create Irp.
    //
    NPAGED_LOOKASIDE_LIST EfsContextPool;


    //
    //  A lookaside list for open operation cache
    //
    PAGED_LOOKASIDE_LIST EfsOpenCachePool;

    LIST_ENTRY EfsOpenCacheList;
    FAST_MUTEX EfsOpenCacheMutex;

    //
    // Lookaside Lists for key blob
    //

    LIST_ENTRY EfsKeyLookAsideList;
    FAST_MUTEX EfsKeyBlobMemSrcMutex;
    PAGED_LOOKASIDE_LIST EfsMemSourceItem;
    NPAGED_LOOKASIDE_LIST EfsLookAside;

    //
    // Session key.
    // Used to decrypt the FSCTL input buffer.
    //
    UCHAR  SessionKey[DES_KEYSIZE];
    UCHAR  SessionDesTable[DES_TABLESIZE];
    PRKPROCESS LsaProcess;

    //
    // Flag indicate EFS is ready
    //
    BOOLEAN EfsInitialized;
    BOOLEAN AllocMaxBuffer;
    HANDLE  InitEventHandle;

    //PDEVICE_OBJECT      FipsDeviceObject;
    PFILE_OBJECT        FipsFileObject;
    FIPS_FUNCTION_TABLE FipsFunctionTable;

    //
    // Efs special attribute name
    //
    UNICODE_STRING EfsName;

} EFS_DATA, *PEFS_DATA;

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(F,SF) (    \
//    (BOOLEAN)(((F) & (SF)) != 0) \
//)
//#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) { \
//    (Flags) |= (SingleFlag);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) { \
//    (Flags) &= ~(SingleFlag);         \
//}
//#endif

//
// Function prototypes
//

//
// Define driver entry routine.
//

NTSTATUS
EfsInitialization(
    void
    );

NTSTATUS
EFSCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

DWORD
GetKeyBlobLength(
    ULONG AlgID
    );

PKEY_BLOB
GetKeyBlobBuffer(
    ULONG AlgID
    );

BOOLEAN
SetKeyTable(
    PKEY_BLOB   KeyBlob,
    PEFS_KEY    EfsKey
    );

NTSTATUS
EFSFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
EFSPostCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PEFS_CONTEXT EfsContext,
    IN ULONG OpenType
    );

NTSTATUS
EFSFilePostCreate(
    IN PDEVICE_OBJECT VolDo,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN NTSTATUS Status,
    IN OUT PVOID *PCreateContext
    );

VOID
EfsGetSessionKey(
    IN PVOID StartContext
    );

BOOLEAN
EfsInitFips(
    VOID
    );

//
// private PS kernel funtions (this should REALLY be including ntos.h or ps.h)
//

NTKERNELAPI
VOID
PsRevertToSelf(
    VOID
    );

NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
    IN HANDLE ProcessId,
    OUT PEPROCESS *Process
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\efs\efsrtlsp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   efsrtlsp.c

Abstract:

   This module will provide EFS RTL support routines.

Author:

    Robert Gu (robertg) 20-Dec-1996
Environment:

   Kernel Mode Only

Revision History:

--*/

#include "efsrtl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, EfsReadEfsData)
#pragma alloc_text(PAGE, EfsVerifyGeneralFsData)
#pragma alloc_text(PAGE, EfsVerifyKeyFsData)
#pragma alloc_text(PAGE, EfsDeleteEfsData)
#pragma alloc_text(PAGE, EfsSetEncrypt)
#pragma alloc_text(PAGE, EfsEncryptStream)
#pragma alloc_text(PAGE, EfsEncryptFile)
#pragma alloc_text(PAGE, EfsDecryptStream)
#pragma alloc_text(PAGE, EfsDecryptFile)
#pragma alloc_text(PAGE, EfsEncryptDir)
#pragma alloc_text(PAGE, EfsModifyEfsState)
#pragma alloc_text(PAGE, GetEfsStreamOffset)
#pragma alloc_text(PAGE, SetEfsData)
#pragma alloc_text(PAGE, EfsFindInCache)
#pragma alloc_text(PAGE, EfsRefreshCache)
#pragma alloc_text(PAGE, SkipCheckStream)
#endif


NTSTATUS
EfsReadEfsData(
       IN OBJECT_HANDLE FileHdl,
       IN PIRP_CONTEXT IrpContext,
       OUT PVOID   *EfsStreamData,
       OUT PULONG   PEfsStreamLength,
       OUT PULONG Information
       )
/*++

Routine Description:

    This is an internal support routine. The purpose is to reduce the code size.
    It is used to read $EFS data and set the context block.

Arguments:

    FileHdl  -- An object handle to access the attached $EFS

    IrpContext -- Used in NtOfsCreateAttributeEx().

    EfsStreamData -- Point to $EFS data read.

    Information -- Return the processing information

Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{
    NTSTATUS ntStatus;
    ATTRIBUTE_HANDLE  attribute = NULL;
    LONGLONG attriOffset;
    ULONG   efsLength;
    PVOID   efsMapBuffer = NULL;
    MAP_HANDLE efsMapHandle;

    PAGED_CODE();

    if (EfsStreamData) {
        *EfsStreamData = NULL;
    }

    try {

        ntStatus = NtOfsCreateAttributeEx(
                             IrpContext,
                             FileHdl,
                             EfsData.EfsName,
                             $LOGGED_UTILITY_STREAM,
                             OPEN_EXISTING,
                             TRUE,
                             &attribute
                             );

        if (NT_SUCCESS(ntStatus)){

                LONGLONG  attrLength;

                NtOfsInitializeMapHandle(&efsMapHandle);

                //
                // Prepare to map and read the $EFS data
                //

                attrLength = NtOfsQueryLength ( attribute );

                if (attrLength <= sizeof ( EFS_DATA_STREAM_HEADER ) ){

                    //
                    // Not our $EFS
                    //

                    NtOfsCloseAttribute(IrpContext, attribute);
                    *Information = EFS_FORMAT_ERROR;
                    ntStatus = STATUS_SUCCESS;

                    leave;

                }

                if ( attrLength > EFS_MAX_LENGTH) {

                    //
                    // EFS stream too long ( > 256K )
                    // We might support that in the future
                    // In that case, we need multiple map window
                    //

                    NtOfsCloseAttribute(IrpContext, attribute);
                    *Information = EFS_FORMAT_ERROR;
                    ntStatus = STATUS_SUCCESS;

                    leave;
                }

                attriOffset = 0;
                *PEfsStreamLength = efsLength = (ULONG) attrLength;

                NtOfsMapAttribute(
                        IrpContext,
                        attribute,
                        attriOffset,
                        efsLength,
                        &efsMapBuffer,
                        &efsMapHandle
                        );

                //
                // Double check the EFS
                //

                if ( efsLength != *(ULONG *)efsMapBuffer){

                    //
                    // Not our $EFS
                    //

                    NtOfsReleaseMap(IrpContext, &efsMapHandle);
                    NtOfsCloseAttribute(IrpContext, attribute);
                    *Information = EFS_FORMAT_ERROR;
                    ntStatus = STATUS_SUCCESS;

                    leave;
                }

                //
                // Allocate memory for $EFS
                //

                if ( EfsStreamData ){

                    //
                    // $EFS must be read
                    //

                    *EfsStreamData = ExAllocatePoolWithTag(
                                        PagedPool,
                                        efsLength,
                                        'msfE'
                                        );

                    if ( NULL == *EfsStreamData ){

                        NtOfsReleaseMap(IrpContext, &efsMapHandle);
                        NtOfsCloseAttribute(IrpContext, attribute);
                        *Information = OUT_OF_MEMORY;
                        ntStatus =  STATUS_INSUFFICIENT_RESOURCES;

                        leave;

                    }

                    RtlCopyMemory(*EfsStreamData, efsMapBuffer, efsLength);

                }

                NtOfsReleaseMap(IrpContext, &efsMapHandle);
                NtOfsCloseAttribute(IrpContext, attribute);

                *Information = EFS_READ_SUCCESSFUL;
                ntStatus = STATUS_SUCCESS;

        } else {

            //
            // Open failed. Not encrypted by EFS.
            //

            *Information = OPEN_EFS_FAIL;
            ntStatus = STATUS_SUCCESS;

        }
    } finally {

        if (AbnormalTermination()) {

            //
            //  Get the exception status
            //
    
            *Information = NTOFS_EXCEPTION;
    
            if (*EfsStreamData) {
                ExFreePool(*EfsStreamData);
                *EfsStreamData = NULL;
            }
            if (efsMapBuffer) {
                NtOfsReleaseMap(IrpContext, &efsMapHandle);
            }
            if (attribute) {
                NtOfsCloseAttribute(IrpContext, attribute);
            }
        }


    }

    return ntStatus;

}

BOOLEAN
EfsVerifyGeneralFsData(
    IN PUCHAR DataOffset,
    IN ULONG InputDataLength
    )
/*++

Routine Description:

    This is an internal support routine. The purpose is to verify the general
    FSCTL input data to see if it is sent by EFS component or not.

    General EFS data format is like the following,

    SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk

Arguments:

    DataOffset  -- Point to a buffer holding the FSCTL general data part.

    InputDataLength -- The length of the FSCTL input puffer

Return Value:

    TRUE if verified.

--*/
{

    ULONG bytesSame;
    ULONG minLength;

    PAGED_CODE();

    minLength = 4 * DES_BLOCKLEN + 3 * sizeof(ULONG);
    if (InputDataLength < minLength){
        return FALSE;
    }

    //
    // Decrypt the encrypted data part.
    //

    des( DataOffset + 2 * DES_BLOCKLEN,
         DataOffset + 2 * DES_BLOCKLEN,
         &(EfsData.SessionDesTable[0]),
         DECRYPT
       );

    des( DataOffset + 3 * DES_BLOCKLEN,
         DataOffset + 3 * DES_BLOCKLEN,
         &(EfsData.SessionDesTable[0]),
         DECRYPT
       );

    bytesSame = (ULONG)RtlCompareMemory(
                     DataOffset,
                     DataOffset + 2 * DES_BLOCKLEN,
                     2 * DES_BLOCKLEN
                    );

    if (( 2 * DES_BLOCKLEN ) != bytesSame ){

            //
            // Input data format error
            //

            return FALSE;

    }

    bytesSame = (ULONG)RtlCompareMemory(
                     DataOffset,
                     &(EfsData.SessionKey[0]),
                     DES_KEYSIZE
                    );

    if ( DES_KEYSIZE != bytesSame ){

        //
        // Input data is not set by EFS component.
        // The session key does not match.
        //

        return FALSE;

    }

    return TRUE;

}

BOOLEAN
EfsVerifyKeyFsData(
    IN PUCHAR DataOffset,
    IN ULONG InputDataLength
    )
/*++

Routine Description:

    This is an internal support routine. The purpose is to verify the
    FSCTL input data with FEK encrypted to see if it is sent by EFS
    component or not.

    Key EFS data format is like the following,

    FEK, [FEK]sk, [$EFS]

Arguments:

    DataOffset  -- Point to a buffer holding the FSCTL general data part.

    InputDataLength -- The length of the FSCTL input puffer

Return Value:

    TRUE if verified.

--*/
{

    ULONG bytesSame;
    LONG encLength;
    PUCHAR encBuffer;

    PAGED_CODE();

    encLength = EFS_KEY_SIZE( ((PEFS_KEY)DataOffset) );

    if  ( (InputDataLength < (2 * encLength + 3 * sizeof(ULONG))) ||
          (0 != ( encLength % DES_BLOCKLEN )) ||
          ( encLength <= 0 )){
        return FALSE;
    }

    //
    // Decrypt the encrypted data part.
    //

    encBuffer = DataOffset + encLength;

    while ( encLength > 0 ){

        des( encBuffer,
             encBuffer,
             &(EfsData.SessionDesTable[0]),
             DECRYPT 
           );

        encBuffer += DES_BLOCKLEN;
        encLength -= DES_BLOCKLEN;

    }

    //
    //  Compare the two parts.
    //

    encLength = EFS_KEY_SIZE( ((PEFS_KEY)DataOffset) );
    bytesSame = (ULONG)RtlCompareMemory(
                     DataOffset,
                     DataOffset + encLength,
                     encLength
                    );

    if ( ((ULONG) encLength) != bytesSame ){

            //
            // Input data format error
            //

            return FALSE;

    }

    return TRUE;

}

NTSTATUS
EfsDeleteEfsData(
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        )
/*++

Routine Description:

    This is an internal support routine. It deletes $EFS.

Arguments:

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{

    ATTRIBUTE_HANDLE  attribute = NULL;
    NTSTATUS ntStatus;

    PAGED_CODE();

    //
    // Delete the $EFS stream
    //

    try {
        ntStatus = NtOfsCreateAttributeEx(
                             IrpContext,
                             FileHdl,
                             EfsData.EfsName,
                             $LOGGED_UTILITY_STREAM,
                             OPEN_EXISTING,
                             TRUE,
                             &attribute
                             );

        if (NT_SUCCESS(ntStatus)){

            NtOfsDeleteAttribute( IrpContext, FileHdl, attribute );

        }
    } finally {

        if (attribute) {

            //
            // According to BrianAn, we shouldn't get exception below.
            //

            NtOfsCloseAttribute(IrpContext, attribute);
        }
    }

    return ntStatus;
}



NTSTATUS
EfsSetEncrypt(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context,
        IN OUT PULONG PContextLength
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT.

Arguments:

    InputData -- Input data buffer of FSCTL.

    InputDataLength -- The length of input data.

    EncryptionFlag -- Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context -- Blob(key) for READ or WRITE later.

    PContextLength -- Length og the key Blob

Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{

    PAGED_CODE();

    switch ( ((PFSCTL_INPUT)InputData)->CipherSubCode ){

        case EFS_ENCRYPT_STREAM:

            return EfsEncryptStream(
                            InputData,
                            InputDataLength,
                            EncryptionFlag,
                            FileHdl,
                            IrpContext,
                            Context,
                            PContextLength
                            );

        case EFS_ENCRYPT_FILE:

             return EfsEncryptFile(
                            InputData,
                            InputDataLength,
                            EncryptionFlag,
                            FileHdl,
                            IrpContext,
                            Context
                            );

        case EFS_DECRYPT_STREAM:

            return EfsDecryptStream(
                    InputData,
                    InputDataLength,
                    EncryptionFlag,
                    FileHdl,
                    IrpContext,
                    Context,
                    PContextLength
                    );

        case EFS_DECRYPT_FILE:
        case EFS_DECRYPT_DIRFILE:

            return EfsDecryptFile(
                    InputData,
                    InputDataLength,
                    FileHdl,
                    IrpContext
                    );

        case EFS_ENCRYPT_DIRSTR:

             return EfsEncryptDir(
                            InputData,
                            InputDataLength,
                            EncryptionFlag,
                            FileHdl,
                            IrpContext
                            );

            break;

        case EFS_DECRYPT_DIRSTR:

            //
            // EFS ignore this case.\
            //
            break;

        default:
            break;

    }
    return STATUS_SUCCESS;
}

NTSTATUS
EfsEncryptStream(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context,
        IN OUT PULONG PContextLength
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT for encrypting a stream. It verifies the caller
    and set the key Blob for the stream.

Arguments:

    InputData -- Input data buffer of FSCTL.

    InputDataLength -- The length of input data.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context -- Blob(key) for READ or WRITE later.

    PContextLength -- Length of the key Blob


Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{

    ULONG efsLength;
    ULONG information;
    PVOID efsStreamData = NULL;
    PVOID efsKeyBlob = NULL;
    PEFS_KEY    efsKey = NULL;
    NTSTATUS ntStatus;
    ULONG bytesSame;

    PAGED_CODE();

    if ( EncryptionFlag & STREAM_ENCRYPTED ) {

        //
        // Stream already encrypted
        //

        return STATUS_SUCCESS;
    }

    if ( *Context ){

        //
        // The key Blob is already set without the bit set first.
        // Not set by EFS
        //

        return STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // [FsData] = FEK, [FEK]sk, $EFS
    //

    if ( !EfsVerifyKeyFsData(
            &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
            InputDataLength) ){

        //
        // Input data format error
        //

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Try to read an existing $EFS
    //

    ntStatus = EfsReadEfsData(
                        FileHdl,
                        IrpContext,
                        &efsStreamData,
                        &efsLength,
                        &information
                        );

    if ( EFS_READ_SUCCESSFUL == information ){

        BOOLEAN continueProcess = TRUE;
        ULONG efsOffset;

        efsOffset = GetEfsStreamOffset( InputData );

        if ( 0 == (EncryptionFlag & FILE_ENCRYPTED) ){
            //
            // File is not encrypted, but $EFS exist. Invalid status.
            // May caused by a crash during the SET_ENCRYPT file call.
            //

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            continueProcess = FALSE;

        } else if ( efsLength != ( InputDataLength - efsOffset )) {
            //
            // $EFS stream length does not match
            //

            ntStatus = STATUS_INVALID_PARAMETER;
            continueProcess = FALSE;

        }

        if ( !continueProcess ) {

            ExFreePool( efsStreamData );
            return ntStatus;

        }

        //
        // Got the $EFS. Now double check the match of the $EFS stream.
        // EFS use the same $EFS for all the stream within a file.
        // Skip comparing the length and status fields.
        //

        bytesSame = (ULONG)RtlCompareMemory(
                        (PUCHAR)efsStreamData + 2 * sizeof(ULONG),
                        InputData + efsOffset + 2 * sizeof(ULONG),
                        efsLength - 2 * sizeof(ULONG)
                        );

        ExFreePool( efsStreamData );

        if ( bytesSame != efsLength - 2 * sizeof(ULONG) ){

            //
            // The EFS are not the same length
            //

            return STATUS_INVALID_PARAMETER;

        }

        efsKey = (PEFS_KEY)&(((PFSCTL_INPUT)InputData)->EfsFsData[0]);
        efsKeyBlob = GetKeyBlobBuffer(efsKey->Algorithm);
        if ( NULL == efsKeyBlob ){
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        if (!SetKeyTable( efsKeyBlob, efsKey )){

            ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);

            //
            // We might be able to return a better error code if needed.
            // This is not in the CreateFile() path.
            //

            return STATUS_ACCESS_DENIED;
        }

        *Context = efsKeyBlob;
        *PContextLength = ((PKEY_BLOB)efsKeyBlob)->KeyLength;
        return STATUS_SUCCESS;

    }

    //
    // Try to encrypt a stream but the $EFS is not there.
    // EFS server will always call encrypt on a file first.
    //

    return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
EfsEncryptFile(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT for encrypting a file. It does not deal with
    the stream, it only writes the initial $EFS and put the file in
    a transition status so that no one else can open the file.

Arguments:

    InputData -- Input data buffer of FSCTL.

    InputDataLength -- The length of input data.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context - BLOB(key) for READ or WRITE later.


Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{

    ULONG efsLength;
    ULONG information;
    ULONG efsOffset;
    PVOID efsStreamData = NULL;
    PVOID efsKeyBlob = NULL;
    NTSTATUS ntStatus;
    ATTRIBUTE_HANDLE  attribute = NULL;

    PAGED_CODE();

    if ( EncryptionFlag & FILE_ENCRYPTED ){

        //
        // File encrypted.
        //

        return STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // [FsData] = FEK, [FEK]sk, $EFS
    //

    if ( !EfsVerifyKeyFsData(
            &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
            InputDataLength) ){

        //
        // Input data format error
        //

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Allocate memory for $EFS
    // Create the $EFS, if there is one, overwrite it.
    //

    efsOffset = GetEfsStreamOffset( InputData );
    efsLength = InputDataLength - efsOffset;

    try {

        ntStatus = NtOfsCreateAttributeEx(
                         IrpContext,
                         FileHdl,
                         EfsData.EfsName,
                         $LOGGED_UTILITY_STREAM,
                         CREATE_NEW,
                         TRUE,
                         &attribute
                         );

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){

        DbgPrint( "\n EFSFILTER: Create Attr. Status %x\n", ntStatus );

    }
#endif

        if (NT_SUCCESS(ntStatus)){

            LONGLONG    attriOffset = 0;
            LONGLONG    attriLength = (LONGLONG) efsLength;

            NtOfsSetLength(
                    IrpContext,
                    attribute,
                    attriLength
                    );

            //
            // Write the $EFS with transition status
            //

            *(PULONG)(InputData + efsOffset + sizeof(ULONG)) =
                    EFS_STREAM_TRANSITION;

            NtOfsPutData(
                    IrpContext,
                    attribute,
                    attriOffset,
                    efsLength,
                    InputData + efsOffset
                    );


            NtOfsFlushAttribute (IrpContext, attribute, FALSE);

        }
    } finally {

        if (attribute) {

            NtOfsCloseAttribute(IrpContext, attribute);

        }
    }

    return ntStatus;
}

NTSTATUS
EfsDecryptStream(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context,
        IN OUT PULONG PContextLength
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT for decrypting a stream. It sets the key Blob to NULL.

Arguments:

    InputData -- Input data buffer of FSCTL.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context -- Blob(key) for READ or WRITE later.

    PContextLength -- Length of the key Blob.

Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/

{
    ULONG efsLength;
    ULONG information;
    NTSTATUS ntStatus;

    PAGED_CODE();

    if ( 0 == (EncryptionFlag & STREAM_ENCRYPTED) ) {

        //
        // Stream already decrypted
        //

        return STATUS_SUCCESS;
    }

    if ( 0 == (EncryptionFlag & FILE_ENCRYPTED)){

        //
        // File decrypted but the stream is still encrypted.
        //

        return STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // [FsData] = SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
    // Verify the FsData format.
    //

    if (!EfsVerifyGeneralFsData(
                &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
                InputDataLength)){

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Try to read an existing $EFS
    //

    ntStatus = EfsReadEfsData(
                        FileHdl,
                        IrpContext,
                        NULL,
                        &efsLength,
                        &information
                        );

    if ( EFS_READ_SUCCESSFUL == information ){

        //
        // Everything is OK. We do not check user ID here,
        // we suppose that has been checked during the Open path.
        // Clear the key Blob. The caller should flushed this
        // stream before the FSCTL is issued.
        //

        if ( *Context ){
            CheckValidKeyBlock(*Context,"Please contact RobertG if you see this line, efsrtlsp.c.\n");
            FreeMemoryBlock(Context);
            *PContextLength = 0;
        }

        return STATUS_SUCCESS;

    } else if ( ( OPEN_EFS_FAIL == information ) ||
                ( EFS_FORMAT_ERROR == information ) ) {

        //
        // EFS does not exist or not encrypted by the EFS ?
        //

        ntStatus =  STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // Other error while opening $EFS
    //

    return ntStatus;
}

NTSTATUS
EfsDecryptFile(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT for decrypting a file. It deletes the $EFS. NTFS
    will clear the bit if STATUS_SUCCESS returned.

Arguments:

    InputData -- Input data buffer of FSCTL.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context - BLOB(key) for READ or WRITE later.


Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/

{
    ULONG efsLength;
    ULONG information;
    NTSTATUS ntStatus;

    PAGED_CODE();

    //
    // It is possible to have following situations,
    // File bit set but no $EFS. Crash inside this call last time.
    // File bit not set, $EFS exist. Crash inside EFS_ENCRYPT_FILE.
    //

    //
    // [FsData] = SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
    // Verify the FsData format.
    //

    if (!EfsVerifyGeneralFsData(
            &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
            InputDataLength)){

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Try to read an existing $EFS
    //

    ntStatus = EfsReadEfsData(
                        FileHdl,
                        IrpContext,
                        NULL,
                        &efsLength,
                        &information
                        );

    if ( EFS_READ_SUCCESSFUL == information ){

        //
        // Everything is OK.
        //

        return ( EfsDeleteEfsData( FileHdl, IrpContext ) );

    } else if ( OPEN_EFS_FAIL == information ){

        //
        // Bit set, no $EFS. OK, NTFS will clear the bit.
        //

        return STATUS_SUCCESS;

    }

    return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
EfsEncryptDir(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT for encrypting a directory. It writes initial $EFS.

Arguments:

    InputData -- Input data buffer of FSCTL.

    InputDataLength -- The length of input data.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context - BLOB(key) for READ or WRITE later.


Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{

    ULONG efsLength;
    ULONG information;
    ULONG efsStreamOffset;
    PVOID efsStreamData = NULL;
    PVOID efsKeyBlob = NULL;
    NTSTATUS ntStatus;
    ATTRIBUTE_HANDLE  attribute = NULL;

    PAGED_CODE();

    if ( EncryptionFlag & STREAM_ENCRYPTED ){

        //
        // Dir string already encrypted.
        //

        return STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // [FsData] = SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
    // Verify the FsData format.
    //

    if (!EfsVerifyGeneralFsData(
            &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
            InputDataLength)){

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Allocate memory for $EFS
    // Create the $EFS, if there is one, overwrite it.
    //

    efsStreamOffset = FIELD_OFFSET( FSCTL_INPUT, EfsFsData[0] )
                      + FIELD_OFFSET( GENERAL_FS_DATA, EfsData[0]);

    efsLength = InputDataLength - efsStreamOffset;

    try {

        ntStatus = NtOfsCreateAttributeEx(
                         IrpContext,
                         FileHdl,
                         EfsData.EfsName,
                         $LOGGED_UTILITY_STREAM,
                         CREATE_NEW,
                         TRUE,
                         &attribute
                         );

        if (NT_SUCCESS(ntStatus)){

            LONGLONG    attriOffset = 0;
            LONGLONG    attriLength = (LONGLONG) efsLength;

            NtOfsSetLength(
                    IrpContext,
                    attribute,
                    attriLength
                    );

            //
            // Write the $EFS
            //

            NtOfsPutData(
                    IrpContext,
                    attribute,
                    attriOffset,
                    efsLength,
                    InputData + efsStreamOffset
                    );


            NtOfsFlushAttribute (IrpContext, attribute, FALSE);

        }
    } finally {

        if (attribute) {
            NtOfsCloseAttribute(IrpContext, attribute);
        }
    }

    return ntStatus;
}

NTSTATUS
EfsModifyEfsState(
        IN ULONG FunctionCode,
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        )
/*++

Routine Description:

    This is an internal support routine. It modifies the state field of $EFS.

Arguments:

    FunctionCode -- EFS private code for FSCTL

    InputData -- Input data buffer of FSCTL.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{
    NTSTATUS ntStatus;
    ATTRIBUTE_HANDLE  attribute = NULL;

    PAGED_CODE();

    //
    // [FsData] = SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
    // Verify the FsData format.
    //

    if (!EfsVerifyGeneralFsData(
            &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
            InputDataLength)){

        return STATUS_INVALID_PARAMETER;

    }

    try {

        ntStatus = NtOfsCreateAttributeEx(
                         IrpContext,
                         FileHdl,
                         EfsData.EfsName,
                         $LOGGED_UTILITY_STREAM,
                         OPEN_EXISTING,
                         TRUE,
                         &attribute
                         );

        if (NT_SUCCESS(ntStatus)){

            ULONG   efsStatus = EFS_STREAM_NORMAL;

            if ( EFS_DECRYPT_BEGIN == FunctionCode ){

                 efsStatus = EFS_STREAM_TRANSITION;

            }

            //
            // Modify the status
            //

            NtOfsPutData(
                    IrpContext,
                    attribute,
                    (LONGLONG) &((( EFS_STREAM * ) 0)->Status),
                    sizeof( efsStatus ),
                    &efsStatus
                    );

            NtOfsFlushAttribute (IrpContext, attribute, FALSE);

        }
    } finally {

        if (attribute) {
            NtOfsCloseAttribute(IrpContext, attribute);
        }
    }

    return ntStatus;
}

ULONG
GetEfsStreamOffset(
        IN PUCHAR InputData
        )
/*++

Routine Description:

    This is an internal support routine. It calculates the offset of $EFS.

Arguments:

    InputData -- Input data buffer of FSCTL.
                 The format is always PSC, EfsCode, CSC, FEK, FEK, $EFS

Return Value:

    The offset of $EFS in InputData.

--*/
{

    ULONG efsOffset;

    efsOffset = FIELD_OFFSET( FSCTL_INPUT, EfsFsData[0]);
    efsOffset += 2 * EFS_KEY_SIZE( ((PEFS_KEY)(InputData + efsOffset)) );
    return efsOffset;

}

NTSTATUS
SetEfsData(
    PUCHAR InputData,
    IN ULONG InputDataLength,
    IN ULONG SystemState,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength
    )
/*++

Routine Description:

    This is an internal support routine. It sets the $EFS to the file.

Arguments:

    InputData -- Input data buffer of FSCTL.

    InputDataLength -- Input data length.

    FileHdl -- Used to access the $EFS.

    IrpContext -- Used to access the $EFS.

    PContext -- BLOB(key) for READ or WRITE later.

    PContextLength - The length of the context.

Return Value:

    STATUS_SUCCESS or NT error

--*/
{

    ULONG bytesSame;
    ULONG efsLength;
    PVOID efsStreamData = NULL;
    PVOID efsKeyBlob = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ATTRIBUTE_HANDLE  attribute = NULL;
    PEFS_KEY    efsKey;
    PNPAGED_LOOKASIDE_LIST tmpMemSrc;

    PAGED_CODE();

    if ( ((PFSCTL_INPUT)InputData)->CipherSubCode & SET_EFS_KEYBLOB ){

        //
        // Set the key blob is required
        //

        efsKey = (PEFS_KEY) &(((PFSCTL_INPUT)InputData)->EfsFsData[0]);
        efsKeyBlob = GetKeyBlobBuffer(efsKey->Algorithm);
        if ( NULL == efsKeyBlob ){

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        if (!SetKeyTable(
                efsKeyBlob,
                (PEFS_KEY) &(((PFSCTL_INPUT)InputData)->EfsFsData[0])
                )){

            ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);
            return STATUS_ACCESS_DENIED;
        }

        if ( (((PFSCTL_INPUT)InputData)->EfsFsCode == EFS_SET_ATTRIBUTE ) &&
             *PContext ){

            bytesSame = (ULONG)RtlCompareMemory(
                             efsKeyBlob,
                             *PContext,
                             ((PKEY_BLOB)efsKeyBlob)->KeyLength
                            );

            ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);
            efsKeyBlob = NULL;

            if ( bytesSame != ((PKEY_BLOB)(*PContext))->KeyLength ) {

                //
                // The new key blob is not the same one as in the memory
                //

                return STATUS_INVALID_PARAMETER;

            }

        }

        //
        // Defer the setting of key blob until the $EFS is written
        // successfully.
        //

    }

    if ( ((PFSCTL_INPUT)InputData)->CipherSubCode & WRITE_EFS_ATTRIBUTE ){

        //
        // Write $EFS is required. Either create or overwrite the EFS
        //
        ULONG efsOffset;

        if (SystemState & SYSTEM_IS_READONLY) {
            if ( efsKeyBlob ){

                ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);

            }
            return STATUS_MEDIA_WRITE_PROTECTED;
        }

        if ( (((PFSCTL_INPUT)InputData)->EfsFsCode == EFS_SET_ATTRIBUTE ) ||
             (((PFSCTL_INPUT)InputData)->CipherSubCode & SET_EFS_KEYBLOB) ){

            efsOffset = GetEfsStreamOffset( InputData );

        } else {

            efsOffset = COMMON_FSCTL_HEADER_SIZE;

        }

        efsLength = InputDataLength - efsOffset;

        try {

            ntStatus = NtOfsCreateAttributeEx(
                             IrpContext,
                             FileHdl,
                             EfsData.EfsName,
                             $LOGGED_UTILITY_STREAM,
                             CREATE_OR_OPEN,
                             TRUE,
                             &attribute
                             );

            if (NT_SUCCESS(ntStatus)){

                LONGLONG    attriOffset = 0;
                LONGLONG    attriLength = (LONGLONG) efsLength;

                NtOfsSetLength(
                        IrpContext,
                        attribute,
                        attriLength
                        );

                NtOfsPutData(
                        IrpContext,
                        attribute,
                        attriOffset,
                        efsLength,
                        InputData + efsOffset
                        );


                NtOfsFlushAttribute (IrpContext, attribute, FALSE);

            } else {

                //
                // Create or Open $EFS fail
                //

                if ( efsKeyBlob ){

                    ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);
                    efsKeyBlob = NULL;

                }

                leave;

            }
        } finally {

            if (AbnormalTermination()) {

                if ( efsKeyBlob ){
    
                    ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);
                    efsKeyBlob = NULL;
    
                }

            }

            if (attribute) {

                NtOfsCloseAttribute(IrpContext, attribute);

            }
        }

    }

    if ( efsKeyBlob && (((PFSCTL_INPUT)InputData)->CipherSubCode & SET_EFS_KEYBLOB) ){

        if ( (((PFSCTL_INPUT)InputData)->EfsFsCode == EFS_SET_ATTRIBUTE ) &&
             ( *PContext == NULL ) ){

            //
            // Set the key blob
            //

            *PContext = efsKeyBlob;
            *PContextLength = ((PKEY_BLOB) efsKeyBlob)->KeyLength;

        } else if ( ((PFSCTL_INPUT)InputData)->EfsFsCode == EFS_OVERWRITE_ATTRIBUTE ) {

            //
            // Overwrite the key blob for legal import user
            //

            if ( *PContext == NULL){

                //
                //  The file was not encrypted
                //

                *PContext = efsKeyBlob;
                *PContextLength = ((PKEY_BLOB) efsKeyBlob)->KeyLength;

            } else {

                if ( ((PKEY_BLOB) efsKeyBlob)->KeyLength <= *PContextLength ){

                    tmpMemSrc = ((PKEY_BLOB)(*PContext))->MemSource;
                    RtlCopyMemory( *PContext, efsKeyBlob, ((PKEY_BLOB) efsKeyBlob)->KeyLength );
                    ((PKEY_BLOB)(*PContext))->MemSource = tmpMemSrc;

                    //
                    // Keep the original buffer length
                    //
                    if (((PKEY_BLOB) efsKeyBlob)->KeyLength < *PContextLength) {
                        ((PKEY_BLOB)(*PContext))->KeyLength = *PContextLength;
                        RtlZeroMemory((UCHAR *)(*PContext) + ((PKEY_BLOB) efsKeyBlob)->KeyLength,
                                      *PContextLength - ((PKEY_BLOB) efsKeyBlob)->KeyLength); 
                    }

                    
                }  else{

                    //
                    // We could not swap the key blob because the old blob might be in use. Deleting
                    // the old blob could bug check the system.
                    // This could be avoid if MaximumBlob is defined nonzero in the registry.
                    //

                    ntStatus = STATUS_EFS_ALG_BLOB_TOO_BIG;
                }

                ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);

            }
       }

    }

    return ntStatus;
}

BOOLEAN
EfsFindInCache(
    IN GUID   *EfsId,
    IN PTOKEN_USER    UserId
    )
/*++

Routine Description:

    This routine will try to find the information in open cache.

Arguments:

    EfsId - $EFS ID.
    UserId - User ID

Return Value:

    TRUE, if match found in the cache and the time is not expired. ( 5 second )

--*/
{
    PLIST_ENTRY pListHead, pLink;
    POPEN_CACHE pOpenCache;
    LARGE_INTEGER crntTime;
    PSID    UserSid;

    PAGED_CODE();

    UserSid = UserId->User.Sid;
    KeQuerySystemTime( &crntTime );

    ExAcquireFastMutex( &(EfsData.EfsOpenCacheMutex) );

    if ( EfsData.EfsOpenCacheList.Flink == &(EfsData.EfsOpenCacheList) ) {

        //
        // list empty
        //

        ExReleaseFastMutex(  &(EfsData.EfsOpenCacheMutex)  );
        return FALSE;
    }
    for (pLink = EfsData.EfsOpenCacheList.Flink; pLink != &(EfsData.EfsOpenCacheList); pLink = pLink->Flink) {
        pOpenCache = CONTAINING_RECORD(pLink, OPEN_CACHE, CacheChain);

        ASSERT( pLink );
        ASSERT( pLink->Flink );

        if ( !memcmp( &(pOpenCache->EfsId), EfsId, sizeof(GUID)) &&
            (crntTime.QuadPart - pOpenCache->TimeStamp.QuadPart <= EfsData.EfsDriverCacheLength )  &&
            RtlEqualSid ( UserSid, pOpenCache->UserId->User.Sid)
             ) {

            ExReleaseFastMutex(  &(EfsData.EfsOpenCacheMutex)  );
            return TRUE;
        }

    }
    ExReleaseFastMutex(  &(EfsData.EfsOpenCacheMutex)  );

    return FALSE;
}

NTSTATUS
EfsRefreshCache(
    IN GUID   *EfsId,
    IN PTOKEN_USER    UserId
    )
/*++

Routine Description:

    This routine will set the latest open information in open cache. It will
    delete the the obsolete info. Cache is refreshed.

Arguments:

    EfsId - $EFS ID.
    UserId - User ID

Return Value:

    STATUS_SUCCESS if succeed.

--*/
{
    PLIST_ENTRY pListHead, pLink;
    POPEN_CACHE pOpenCache, pTmpCache;
    LARGE_INTEGER crntTime;

    KeQuerySystemTime( &crntTime );

    pOpenCache =   (POPEN_CACHE)ExAllocateFromPagedLookasideList(&(EfsData.EfsOpenCachePool));
    if ( NULL == pOpenCache){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Init the node
    //

    RtlZeroMemory( pOpenCache, sizeof( OPEN_CACHE ) );
    RtlCopyMemory(  &(pOpenCache->EfsId), EfsId, sizeof( GUID ) );
    pOpenCache->UserId = UserId;
    pOpenCache->TimeStamp.QuadPart =  crntTime.QuadPart;

    ExAcquireFastMutex( &(EfsData.EfsOpenCacheMutex) );

    if ( EfsData.EfsOpenCacheList.Flink == &(EfsData.EfsOpenCacheList) ) {

        //
        // list empty
        //

        InsertHeadList(&( EfsData.EfsOpenCacheList ), &( pOpenCache->CacheChain ));

    } else {

        //
        // Search for expired one
        //

        pLink = EfsData.EfsOpenCacheList.Flink;
        while ( pLink != &(EfsData.EfsOpenCacheList) ){

            pTmpCache = CONTAINING_RECORD(pLink, OPEN_CACHE, CacheChain);

            ASSERT( pLink );
            ASSERT( pLink->Flink );

            pLink = pLink->Flink;
            if ( ( (crntTime.QuadPart - pTmpCache->TimeStamp.QuadPart) > EfsData.EfsDriverCacheLength ) ||
                !memcmp( &(pTmpCache->EfsId), EfsId, sizeof(GUID))
               ){

                //
                // Expired node. Delete it.
                //

                RemoveEntryList(&( pTmpCache->CacheChain ));
                ExFreePool( pTmpCache->UserId );
                ExFreeToPagedLookasideList(&(EfsData.EfsOpenCachePool), pTmpCache );

            }
        }

        InsertHeadList(&( EfsData.EfsOpenCacheList ), &( pOpenCache->CacheChain ));
    }

    ExReleaseFastMutex(  &(EfsData.EfsOpenCacheMutex)  );
    return STATUS_SUCCESS;
}

BOOLEAN
SkipCheckStream(
    IN PIO_STACK_LOCATION IrpSp,
    IN PVOID efsStreamData
    )
/*++

Routine Description:

    This routine will check if the related default data stream has just been opened
    or not.

Arguments:

    EfsId - $EFS ID.
    UserId - User ID

Return Value:

    TRUE if succeed.

--*/
{
    BOOLEAN     bRet = TRUE;
    PACCESS_TOKEN accessToken;
    NTSTATUS status;
    PTOKEN_USER UserId;

    PAGED_CODE();

    if ( IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken ){
        accessToken = IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken;
    } else {
        accessToken = IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
    }

    if (accessToken) {

        //
        // Get User ID
        //

        status = SeQueryInformationToken(
                    accessToken,
                    TokenUser,
                    &UserId
                    );

        if ( NT_SUCCESS(status) ){

            if ( EfsFindInCache(
                    &((( PEFS_DATA_STREAM_HEADER ) efsStreamData)->EfsId),
                    UserId
                    )) {

                bRet = TRUE;

            } else {

                bRet = FALSE;

            }

            ExFreePool( UserId );
        }
    } else {
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\cleanup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Fat called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_CLEANUP)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  The following little routine exists solely because it need a spin lock.
//

VOID
FatAutoUnlock (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonCleanup)
#pragma alloc_text(PAGE, FatFsdCleanup)
#endif


NTSTATUS
FatFsdCleanup (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of closing down a handle to a
    file object.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file being Cleanup exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if ( FatDeviceIsFatFsdo( VolumeDeviceObject))  {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    DebugTrace(+1, Dbg, "FatFsdCleanup\n", 0);

    //
    //  Call the common Cleanup routine, with blocking allowed.
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, TRUE );

        Status = FatCommonCleanup( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdCleanup -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonCleanup (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleanup of a file/directory called by both
    the fsd and fsp threads.

    Cleanup is invoked whenever the last handle to a file object is closed.
    This is different than the Close operation which is invoked when the last
    reference to a file object is deleted.

    The function of cleanup is to essentially "cleanup" the file/directory
    after a user is done with it.  The Fcb/Dcb remains around (because MM
    still has the file object referenced) but is now available for another
    user to open (i.e., as far as the user is concerned the is now closed).

    See close for a more complete description of what close does.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN SendUnlockNotification = FALSE;

    PSHARE_ACCESS ShareAccess;

    PLARGE_INTEGER TruncateSize = NULL;
    LARGE_INTEGER LocalTruncateSize;

    BOOLEAN AcquiredVcb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;
    
    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonCleanup\n", 0);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "->FileObject  = %08lx\n", IrpSp->FileObject);

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

    //
    //  Special case the unopened file object.  This will occur only when
    //  we are initializing Vcb and IoCreateStreamFileObject is being
    //  called.
    //

    if (TypeOfOpen == UnopenedFileObject) {

        DebugTrace(0, Dbg, "Unopened File Object\n", 0);

        FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        DebugTrace(-1, Dbg, "FatCommonCleanup -> STATUS_SUCCESS\n", 0);
        return STATUS_SUCCESS;
    }

    //
    //  If this is not our first time through (for whatever reason)
    //  only see if we have to flush the file.
    //

    if (FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE )) {

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH) &&
            FlagOn(FileObject->Flags, FO_FILE_MODIFIED) &&
            !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED) &&
            (TypeOfOpen == UserFileOpen)) {

            //
            //  Flush the file.
            //

            Status = FatFlushFile( IrpContext, Fcb, Flush );

            if (!NT_SUCCESS(Status)) {

                FatNormalizeAndRaiseStatus( IrpContext, Status );
            }
        }

        FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        DebugTrace(-1, Dbg, "FatCommonCleanup -> STATUS_SUCCESS\n", 0);
        return STATUS_SUCCESS;
    }

    //
    //  If we call change the allocation or call CcUninitialize,
    //  we have to take the Fcb exclusive
    //

    if ((TypeOfOpen == UserFileOpen) || (TypeOfOpen == UserDirectoryOpen)) {

        ASSERT( Fcb != NULL );
    
        (VOID)FatAcquireExclusiveFcb( IrpContext, Fcb );

        AcquiredFcb = TRUE;

        //
        //  Do a check here if this was a DELETE_ON_CLOSE FileObject, and
        //  set the Fcb flag appropriately.
        //

        if (FlagOn(Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE)) {

            ASSERT( NodeType(Fcb) != FAT_NTC_ROOT_DCB );

            SetFlag(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE);

            //
            //  Report this to the dir notify package for a directory.
            //

            if (TypeOfOpen == UserDirectoryOpen) {

                FsRtlNotifyFullChangeDirectory( Vcb->NotifySync,
                                                &Vcb->DirNotifyList,
                                                FileObject->FsContext,
                                                NULL,
                                                FALSE,
                                                FALSE,
                                                0,
                                                NULL,
                                                NULL,
                                                NULL );
            }
        }

        //
        //  Now if we may delete the file, drop the Fcb and acquire the Vcb
        //  first.  Note that while we own the Fcb exclusive, a file cannot
        //  become DELETE_ON_CLOSE and cannot be opened via CommonCreate.
        //

        if ((Fcb->UncleanCount == 1) &&
            FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE) &&
            (Fcb->FcbCondition != FcbBad) &&
            !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

            FatReleaseFcb( IrpContext, Fcb );
            AcquiredFcb = FALSE;

            (VOID)FatAcquireExclusiveVcb( IrpContext, Vcb );
            AcquiredVcb = TRUE;

            (VOID)FatAcquireExclusiveFcb( IrpContext, Fcb );
            AcquiredFcb = TRUE;
        }
    }

    //
    //  For user DASD cleanups, grab the Vcb exclusive.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        (VOID)FatAcquireExclusiveVcb( IrpContext, Vcb );
        AcquiredVcb = TRUE;
    }

    //
    //  Complete any Notify Irps on this file handle.
    //

    if (TypeOfOpen == UserDirectoryOpen) {

        FsRtlNotifyCleanup( Vcb->NotifySync,
                            &Vcb->DirNotifyList,
                            Ccb );
    }

    //
    //  Determine the Fcb state, Good or Bad, for better or for worse.
    //
    //  We can only read the volume file if VcbCondition is good.
    //

    if ( Fcb != NULL) {

        //
        //  Stop any raises from FatVerifyFcb, unless it is REAL bad.
        //

        try {

            try {

                FatVerifyFcb( IrpContext, Fcb );

            } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

                  FatResetExceptionState( IrpContext );
            }

        } finally {

            if ( AbnormalTermination() ) {

                //
                //  We will be raising out of here.
                //

                if (AcquiredFcb) { FatReleaseFcb( IrpContext, Fcb ); }
                if (AcquiredVcb) { FatReleaseVcb( IrpContext, Vcb ); }
            }
        }
    }

    try {

        //
        //  Case on the type of open that we are trying to cleanup.
        //  For all cases we need to set the share access to point to the
        //  share access variable (if there is one). After the switch
        //  we then remove the share access and complete the Irp.
        //  In the case of UserFileOpen we actually have a lot more work
        //  to do and we have the FsdLockControl complete the Irp for us.
        //

        switch (TypeOfOpen) {

        case DirectoryFile:
        case VirtualVolumeFile:

            DebugTrace(0, Dbg, "Cleanup VirtualVolumeFile/DirectoryFile\n", 0);

            ShareAccess = NULL;

            break;

        case UserVolumeOpen:

            DebugTrace(0, Dbg, "Cleanup UserVolumeOpen\n", 0);

            if (FlagOn( Ccb->Flags, CCB_FLAG_COMPLETE_DISMOUNT )) {

                FatCheckForDismount( IrpContext, Vcb, TRUE );
            
            //
            //  If this handle had write access, and actually wrote something,
            //  flush the device buffers, and then set the verify bit now
            //  just to be safe (in case there is no dismount).
            //

            } else if (FileObject->WriteAccess &&
                       FlagOn(FileObject->Flags, FO_FILE_MODIFIED)) {

                (VOID)FatHijackIrpAndFlushDevice( IrpContext,
                                                  Irp,
                                                  Vcb->TargetDeviceObject );

                SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);
            }

            //
            //  If the volume is locked by this file object then release
            //  the volume and send notification.
            //

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED) &&
                (Vcb->FileObjectWithVcbLocked == FileObject)) {

                FatAutoUnlock( IrpContext, Vcb );
                SendUnlockNotification = TRUE;
            }

            ShareAccess = &Vcb->ShareAccess;

            break;

        case EaFile:

            DebugTrace(0, Dbg, "Cleanup EaFileObject\n", 0);

            ShareAccess = NULL;

            break;

        case UserDirectoryOpen:

            DebugTrace(0, Dbg, "Cleanup UserDirectoryOpen\n", 0);

            ShareAccess = &Fcb->ShareAccess;

            //
            //  Determine here if we should try do delayed close.
            //

            if ((Fcb->UncleanCount == 1) &&
                (Fcb->OpenCount == 1) &&
                (Fcb->Specific.Dcb.DirectoryFileOpenCount == 0) &&
                !FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE) &&
                Fcb->FcbCondition == FcbGood) {

                //
                //  Delay our close.
                //

                SetFlag( Fcb->FcbState, FCB_STATE_DELAY_CLOSE );
            }

            FatUpdateDirentFromFcb( IrpContext, FileObject, Fcb, Ccb );

            //
            //  If the directory has a unclean count of 1 then we know
            //  that this is the last handle for the file object.  If
            //  we are supposed to delete it, do so.
            //

            if ((Fcb->UncleanCount == 1) &&
                (NodeType(Fcb) == FAT_NTC_DCB) &&
                (FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE)) &&
                (Fcb->FcbCondition != FcbBad) &&
                !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

                if (!FatIsDirectoryEmpty(IrpContext, Fcb)) {

                    //
                    //  If there are files in the directory at this point,
                    //  forget that we were trying to delete it.
                    //

                    ClearFlag( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );

                } else {

                    //
                    //  Even if something goes wrong, we cannot turn back!
                    //
        
                    try {
        
                        DELETE_CONTEXT DeleteContext;
        
                        //
                        //  Before truncating file allocation remember this
                        //  info for FatDeleteDirent.
                        //
        
                        DeleteContext.FileSize = Fcb->Header.FileSize.LowPart;
                        DeleteContext.FirstClusterOfFile = Fcb->FirstClusterOfFile;
        
                        //
                        //  Synchronize here with paging IO
                        //
        
                        (VOID)ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource,
                                                          TRUE );
        
                        Fcb->Header.FileSize.LowPart = 0;
        
                        ExReleaseResourceLite( Fcb->Header.PagingIoResource );
        
                        if (Vcb->VcbCondition == VcbGood) {
        
                            //
                            //  Truncate the file allocation down to zero
                            //
        
                            DebugTrace(0, Dbg, "Delete File allocation\n", 0);
        
                            FatTruncateFileAllocation( IrpContext, Fcb, 0 );

                            if (Fcb->Header.AllocationSize.LowPart == 0) {
        
                                //
                                //  Tunnel and remove the dirent for the directory
                                //
            
                                DebugTrace(0, Dbg, "Delete the directory dirent\n", 0);
            
                                FatTunnelFcbOrDcb( Fcb, NULL );
    
                                FatDeleteDirent( IrpContext, Fcb, &DeleteContext, TRUE );
            
                                //
                                //  Report that we have removed an entry.
                                //
        
                                FatNotifyReportChange( IrpContext,
                                                       Vcb,
                                                       Fcb,
                                                       FILE_NOTIFY_CHANGE_DIR_NAME,
                                                       FILE_ACTION_REMOVED );
                            }
                        }

                    } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {
    
                          FatResetExceptionState( IrpContext );
                    }

                    //
                    //  Remove the entry from the name table.
                    //  This will ensure that
                    //  we will not collide with the Dcb if the user wants
                    //  to recreate the same file over again before we
                    //  get a close irp.
                    //
    
                    FatRemoveNames( IrpContext, Fcb );
                }
            }

            //
            //  Decrement the unclean count.
            //

            ASSERT( Fcb->UncleanCount != 0 );
            Fcb->UncleanCount -= 1;

            break;

        case UserFileOpen:

            DebugTrace(0, Dbg, "Cleanup UserFileOpen\n", 0);

            ShareAccess = &Fcb->ShareAccess;

            //
            //  Determine here if we should do a delayed close.
            //

            if ((FileObject->SectionObjectPointer->DataSectionObject == NULL) &&
                (FileObject->SectionObjectPointer->ImageSectionObject == NULL) &&
                (Fcb->UncleanCount == 1) &&
                (Fcb->OpenCount == 1) &&
                !FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE) &&
                Fcb->FcbCondition == FcbGood) {

                //
                //  Delay our close.
                //

                SetFlag( Fcb->FcbState, FCB_STATE_DELAY_CLOSE );
            }

            //
            //  Unlock all outstanding file locks.
            //

            (VOID) FsRtlFastUnlockAll( &Fcb->Specific.Fcb.FileLock,
                                       FileObject,
                                       IoGetRequestorProcess( Irp ),
                                       NULL );

            //
            //  We can proceed with on-disk updates only if the volume is mounted.
            //  Remember that we toss all sections in the failed-verify and dismount
            //  cases.
            //
            
            if (Vcb->VcbCondition == VcbGood) {
                
                if (Fcb->FcbCondition != FcbBad) {
                    
                    FatUpdateDirentFromFcb( IrpContext, FileObject, Fcb, Ccb );
                }
    
                //
                //  If the file has a unclean count of 1 then we know
                //  that this is the last handle for the file object.
                //
    
                if ( (Fcb->UncleanCount == 1) && (Fcb->FcbCondition != FcbBad) ) {
    
                    DELETE_CONTEXT DeleteContext;
    
                    //
                    //  Check if we should be deleting the file.  The
                    //  delete operation really deletes the file but
                    //  keeps the Fcb around for close to do away with.
                    //
    
                    if (FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE) &&
                        !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {
    
                        //
                        //  Before truncating file allocation remember this
                        //  info for FatDeleteDirent.
                        //
    
                        DeleteContext.FileSize = Fcb->Header.FileSize.LowPart;
                        DeleteContext.FirstClusterOfFile = Fcb->FirstClusterOfFile;
    
                        DebugTrace(0, Dbg, "Delete File allocation\n", 0);
    
                        //
                        //  Synchronize here with paging IO
                        //
    
                        (VOID)ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource,
                                                          TRUE );
    
                        Fcb->Header.FileSize.LowPart = 0;
                        Fcb->Header.ValidDataLength.LowPart = 0;
                        Fcb->ValidDataToDisk = 0;
    
                        ExReleaseResourceLite( Fcb->Header.PagingIoResource );
    
                        try {
    
                            FatSetFileSizeInDirent( IrpContext, Fcb, NULL );
    
                        } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                                  EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {
    
                              FatResetExceptionState( IrpContext );
                        }
    
                        Fcb->FcbState |= FCB_STATE_TRUNCATE_ON_CLOSE;
    
                    } else {
    
                        //
                        //  We must zero between ValidDataLength and FileSize
                        //
    
                        if (!FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE) &&
                            (Fcb->Header.ValidDataLength.LowPart < Fcb->Header.FileSize.LowPart)) {
    
                            ULONG ValidDataLength;
    
                            ValidDataLength = Fcb->Header.ValidDataLength.LowPart;
    
                            if (ValidDataLength < Fcb->ValidDataToDisk) {
                                ValidDataLength = Fcb->ValidDataToDisk;
                            }
    
                            //
                            //  Recheck, VDD can be >= FS
                            //
                            
                            if (ValidDataLength < Fcb->Header.FileSize.LowPart) {
                                
                                try {

                                    (VOID)FatZeroData( IrpContext,
                                                       Vcb,
                                                       FileObject,
                                                       ValidDataLength,
                                                       Fcb->Header.FileSize.LowPart -
                                                       ValidDataLength );

                                    //
                                    //  Since we just zeroed this, we can now bump
                                    //  up VDL in the Fcb.
                                    //

                                    Fcb->ValidDataToDisk =
                                    Fcb->Header.ValidDataLength.LowPart =
                                    Fcb->Header.FileSize.LowPart;

                                    //
                                    //  We inform Cc of the motion so that the cache map is updated.
                                    //  This prevents optimized zero-page faults in case the cache
                                    //  structures are re-used for another handle before they are torn
                                    //  down by our soon-to-occur uninitialize. If they were, a noncached
                                    //  producer could write into the region we just zeroed and Cc would
                                    //  be none the wiser, then our async cached reader comes in and takes
                                    //  the optimized path, and we get bad (zero) data.
                                    //
                                    //  If this was memory mapped, we don't have to (can't) tell Cc, it'll
                                    //  figure it out when a cached handle is opened.
                                    //

                                    if (CcIsFileCached( FileObject )) {
                                        CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );
                                    }

                                } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                                          EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

                                      FatResetExceptionState( IrpContext );
                                }
                            }
                        }
                    }
    
                    //
                    //  See if we are supposed to truncate the file on the last
                    //  close.  If we cannot wait we'll ship this off to the fsp
                    //
    
                    try {
    
                        if (FlagOn(Fcb->FcbState, FCB_STATE_TRUNCATE_ON_CLOSE)) {
    
                            DebugTrace(0, Dbg, "truncate file allocation\n", 0);
    
                            if (Vcb->VcbCondition == VcbGood) {
    
                                FatTruncateFileAllocation( IrpContext,
                                                           Fcb,
                                                           Fcb->Header.FileSize.LowPart );
                            }
    
                            //
                            //  We also have to get rid of the Cache Map because
                            //  this is the only way we have of trashing the
                            //  truncated pages.
                            //
    
                            LocalTruncateSize = Fcb->Header.FileSize;
                            TruncateSize = &LocalTruncateSize;
    
                            //
                            //  Mark the Fcb as having now been truncated, just incase
                            //  we have to reship this off to the fsp.
                            //
    
                            Fcb->FcbState &= ~FCB_STATE_TRUNCATE_ON_CLOSE;
                        }
    
                        //
                        //  Now check again if we are to delete the file and if
                        //  so then we remove the file from the disk.
                        //
    
                        if (FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE) &&
                            Fcb->Header.AllocationSize.LowPart == 0) {
    
                            DebugTrace(0, Dbg, "Delete File\n", 0);
    
                            //
                            //  Now tunnel and delete the dirent
                            //
    
                            FatTunnelFcbOrDcb( Fcb, Ccb );
    
                            FatDeleteDirent( IrpContext, Fcb, &DeleteContext, TRUE );
    
                            //
                            //  Report that we have removed an entry.
                            //
    
                            FatNotifyReportChange( IrpContext,
                                                   Vcb,
                                                   Fcb,
                                                   FILE_NOTIFY_CHANGE_FILE_NAME,
                                                   FILE_ACTION_REMOVED );
                        }
    
                    } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {
    
                          FatResetExceptionState( IrpContext );
                    }
    
                    if (FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE)) {
    
                        //
                        //  Remove the entry from the splay table. This will
                        //  ensure that we will not collide with the Fcb if the
                        //  user wants to recreate the same file over again
                        //  before we get a close irp.
                        //
                        //  Note that we remove the name even if we couldn't
                        //  truncate the allocation and remove the dirent above.
                        //
    
                        FatRemoveNames( IrpContext, Fcb );
                    }
                }
            }
            
            //
            //  We've just finished everything associated with an unclean
            //  fcb so now decrement the unclean count before releasing
            //  the resource.
            //

            ASSERT( Fcb->UncleanCount != 0 );
            Fcb->UncleanCount -= 1;
            if (!FlagOn( FileObject->Flags, FO_CACHE_SUPPORTED )) {
                ASSERT( Fcb->NonCachedUncleanCount != 0 );
                Fcb->NonCachedUncleanCount -= 1;
            }

            //
            //  If this was the last cached open, and there are open
            //  non-cached handles, attempt a flush and purge operation
            //  to avoid cache coherency overhead from these non-cached
            //  handles later.  We ignore any I/O errors from the flush.
            //

            if (FlagOn( FileObject->Flags, FO_CACHE_SUPPORTED ) &&
                (Fcb->NonCachedUncleanCount != 0) &&
                (Fcb->NonCachedUncleanCount == Fcb->UncleanCount) &&
                (Fcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL)) {

                CcFlushCache( &Fcb->NonPaged->SectionObjectPointers, NULL, 0, NULL );
            
                //
                //  Grab and release PagingIo to serialize ourselves with the lazy writer.
                //  This will work to ensure that all IO has completed on the cached
                //  data and we will succesfully tear away the cache section.
                //
                
                ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource, TRUE);
                ExReleaseResourceLite( Fcb->Header.PagingIoResource );

                CcPurgeCacheSection( &Fcb->NonPaged->SectionObjectPointers,
                                     NULL,
                                     0,
                                     FALSE );
            }

            //
            //  If the file is invalid, hint to the cache that we should throw everything out.
            //
            
            if ( Fcb->FcbCondition == FcbBad ) {

                TruncateSize = &FatLargeZero;
            }

            //
            //  Cleanup the cache map
            //

            CcUninitializeCacheMap( FileObject, TruncateSize, NULL );

            break;

        default:

            FatBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        //  We must clean up the share access at this time, since we may not
        //  get a Close call for awhile if the file was mapped through this
        //  File Object.
        //

        if (ShareAccess != NULL) {

            DebugTrace(0, Dbg, "Cleanup the Share access\n", 0);
            IoRemoveShareAccess( FileObject, ShareAccess );
        }

        if (TypeOfOpen == UserFileOpen) {

            //
            //  Coordinate the cleanup operation with the oplock state.
            //  Cleanup operations can always cleanup immediately.
            //

            FsRtlCheckOplock( &Fcb->Specific.Fcb.Oplock,
                              Irp,
                              IrpContext,
                              NULL,
                              NULL );

            Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );
        }

        //
        //  First set the FO_CLEANUP_COMPLETE flag.
        //

        SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

        Status = STATUS_SUCCESS;

        //
        //  Now unpin any repinned Bcbs.
        //

        FatUnpinRepinnedBcbs( IrpContext );

        //
        //  If this was deferred flush media, flush the volume.
        //  We used to do this in lieu of write through for all removable
        //  media.
        //

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH) &&
            !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED))  {

            //
            //  Flush the file.
            //

            if ((TypeOfOpen == UserFileOpen) && 
                FlagOn(FileObject->Flags, FO_FILE_MODIFIED)) {

                Status = FatFlushFile( IrpContext, Fcb, Flush );
            }

            //
            //  If that worked ok,  then see if we should flush the FAT as well.
            //

            if (NT_SUCCESS(Status) && Fcb && !FatIsFat12( Vcb) && 
                FlagOn( Fcb->FcbState, FCB_STATE_FLUSH_FAT)) {

                Status = FatFlushFat( IrpContext, Vcb);
            }

            if (!NT_SUCCESS(Status)) {

                FatNormalizeAndRaiseStatus( IrpContext, Status );
            }
        }

    } finally {

        DebugUnwind( FatCommonCleanup );

        if (AcquiredFcb) { FatReleaseFcb( IrpContext, Fcb ); }
        if (AcquiredVcb) { FatReleaseVcb( IrpContext, Vcb ); }

        if (SendUnlockNotification) {
            
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
        }

        //
        //  If this is a normal termination then complete the request
        //

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatCommonCleanup -> %08lx\n", Status);
    }

    return Status;
}

VOID
FatAutoUnlock (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )
{
    KIRQL SavedIrql;

    //
    //  Unlock the volume.
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED );

    Vcb->VcbState &= ~VCB_STATE_FLAG_LOCKED;
    Vcb->FileObjectWithVcbLocked = NULL;

    IoReleaseVpbSpinLock( SavedIrql );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\acchksup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    AcChkSup.c

Abstract:

    This module implements the FAT access checking routine

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    12-Jun-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  Our debug trace level
//

#define Dbg                              (DEBUG_TRACE_ACCHKSUP)

NTSTATUS
FatCreateRestrictEveryoneToken(
    IN PACCESS_TOKEN Token,
    OUT PACCESS_TOKEN *RestrictedToken
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCheckFileAccess)
#pragma alloc_text(PAGE, FatCreateRestrictEveryoneToken)
#pragma alloc_text(PAGE, FatExplicitDeviceAccessGranted)
#endif


BOOLEAN
FatCheckFileAccess (
    PIRP_CONTEXT IrpContext,
    IN UCHAR DirentAttributes,
    IN PACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine checks if a desired access is allowed to a file represented
    by the specified DirentAttriubutes.

Arguments:

    DirentAttributes - Supplies the Dirent attributes to check access for

    DesiredAccess - Supplies the desired access mask that we are checking for

Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise

--*/

{
    BOOLEAN Result;

    DebugTrace(+1, Dbg, "FatCheckFileAccess\n", 0);
    DebugTrace( 0, Dbg, "DirentAttributes = %8lx\n", DirentAttributes);
    DebugTrace( 0, Dbg, "DesiredAccess    = %8lx\n", *DesiredAccess);

    //
    //  This procedures is programmed like a string of filters each
    //  filter checks to see if some access is allowed,  if it is not allowed
    //  the filter return FALSE to the user without further checks otherwise
    //  it moves on to the next filter.  The filter check is to check for
    //  desired access flags that are not allowed for a particular dirent
    //

    Result = TRUE;

    try {

        //
        //  Check for Volume ID or Device Dirents, these are not allowed user
        //  access at all
        //

        if (FlagOn(DirentAttributes, FAT_DIRENT_ATTR_VOLUME_ID) ||
            FlagOn(DirentAttributes, FAT_DIRENT_ATTR_DEVICE)) {

            DebugTrace(0, Dbg, "Cannot access volume id or device\n", 0);

            try_return( Result = FALSE );
        }

        //
        //  Check the desired access for the object - we only blackball that
        //  we do not understand.  The model of filesystems using ACLs is that
        //  they do not type the ACL to the object the ACL is on.  Permissions
        //  are not checked for consistency vs. the object type - dir/file.
        //

        if (FlagOn(*DesiredAccess, ~(DELETE |
                                     READ_CONTROL |
                                     WRITE_OWNER |
                                     WRITE_DAC |
                                     SYNCHRONIZE |
                                     ACCESS_SYSTEM_SECURITY |
                                     FILE_WRITE_DATA |
                                     FILE_READ_EA |
                                     FILE_WRITE_EA |
                                     FILE_READ_ATTRIBUTES |
                                     FILE_WRITE_ATTRIBUTES |
                                     FILE_LIST_DIRECTORY |
                                     FILE_TRAVERSE |
                                     FILE_DELETE_CHILD |
                                     FILE_APPEND_DATA))) {

            DebugTrace(0, Dbg, "Cannot open object\n", 0);

            try_return( Result = FALSE );
        }

        //
        //  Check for a read-only Dirent
        //

        if (FlagOn(DirentAttributes, FAT_DIRENT_ATTR_READ_ONLY)) {

            //
            //  Check the desired access for a read-only dirent, we blackball
            //  WRITE, FILE_APPEND_DATA, FILE_ADD_FILE,
            //  FILE_ADD_SUBDIRECTORY, and FILE_DELETE_CHILD
            //

            if (FlagOn(*DesiredAccess, ~(DELETE |
                                         READ_CONTROL |
                                         WRITE_OWNER |
                                         WRITE_DAC |
                                         SYNCHRONIZE |
                                         ACCESS_SYSTEM_SECURITY |
                                         FILE_READ_DATA |
                                         FILE_READ_EA |
                                         FILE_WRITE_EA |
                                         FILE_READ_ATTRIBUTES |
                                         FILE_WRITE_ATTRIBUTES |
                                         FILE_EXECUTE |
                                         FILE_LIST_DIRECTORY |
                                         FILE_TRAVERSE))) {

                DebugTrace(0, Dbg, "Cannot open readonly\n", 0);

                try_return( Result = FALSE );
            }
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatCheckFileAccess );

        DebugTrace(-1, Dbg, "FatCheckFileAccess -> %08lx\n", Result);
    }

    UNREFERENCED_PARAMETER( IrpContext );

    return Result;
}


NTSTATUS
FatExplicitDeviceAccessGranted (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE ProcessorMode
    )

/*++

Routine Description:

    This function asks whether the SID described in the input access state has
    been granted any explicit access to the given device object.  It does this
    by acquiring a token stripped of its ability to acquire access via the
    Everyone SID and re-doing the access check.

Arguments:

    DeviceObject - the device whose ACL will be checked
    
    AccessState - the access state describing the security context to be checked
    
    ProcessorMode - the mode this check should occur against

Return Value:

    NTSTATUS - Indicating whether explicit access was granted.

--*/

{
    NTSTATUS Status;
    BOOLEAN Result;

    PACCESS_TOKEN OriginalAccessToken;
    PACCESS_TOKEN RestrictedAccessToken;
    
    PACCESS_TOKEN *EffectiveToken;
    
    PRIVILEGE_SET PrivilegeSet;

    ACCESS_MASK GrantedAccess;

    //
    //  If the access state indicates that specific access other
    //  than traverse was acquired, either Everyone does have such
    //  access or explicit access was granted.  In both cases, we're
    //  happy to let this proceed.
    //

    if (AccessState->PreviouslyGrantedAccess & (SPECIFIC_RIGHTS_ALL ^
                                                FILE_TRAVERSE)) {

        return STATUS_SUCCESS;
    }

    //
    //  If the manage volume privilege is held, this also permits access.
    //

    PrivilegeSet.PrivilegeCount = 1;
    PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid( SE_MANAGE_VOLUME_PRIVILEGE );
    PrivilegeSet.Privilege[0].Attributes = 0;

    if (SePrivilegeCheck( &PrivilegeSet,
                          &AccessState->SubjectSecurityContext,
                          ProcessorMode )) {

        return STATUS_SUCCESS;
    }

    //
    //  Capture the subject context as a prelude to everything below.
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );
    
    //
    //  Convert the token in the subject context into one which does not
    //  acquire access through the Everyone SID.
    //
    //  The logic for deciding which token is effective comes from
    //  SeQuerySubjectContextToken; since there is no natural way
    //  of getting a pointer to it, do it by hand.
    //
    
    if (ARGUMENT_PRESENT( AccessState->SubjectSecurityContext.ClientToken )) {
        EffectiveToken = &AccessState->SubjectSecurityContext.ClientToken;
    } else {
        EffectiveToken = &AccessState->SubjectSecurityContext.PrimaryToken;
    }

    OriginalAccessToken = *EffectiveToken;
    Status = FatCreateRestrictEveryoneToken( OriginalAccessToken, &RestrictedAccessToken );

    if (!NT_SUCCESS(Status)) {
        
        SeReleaseSubjectContext( &AccessState->SubjectSecurityContext );
        return Status;
    }

    //
    //  Now see if the resulting context has access to the device through
    //  its explicitly granted access.  We swap in our restricted token
    //  for this check as the effective client token.
    //

    *EffectiveToken = RestrictedAccessToken;

    Result = SeAccessCheck( DeviceObject->SecurityDescriptor,
                            &AccessState->SubjectSecurityContext,
                            FALSE,
                            AccessState->OriginalDesiredAccess,
                            0,
                            NULL,
                            IoGetFileObjectGenericMapping(),
                            ProcessorMode,
                            &GrantedAccess,
                            &Status );
    
    *EffectiveToken = OriginalAccessToken;
    
    //
    //  Cleanup and return.
    //

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
    ObDereferenceObject( RestrictedAccessToken );

    return Status;
}


NTSTATUS
FatCreateRestrictEveryoneToken (
    IN PACCESS_TOKEN Token,
    OUT PACCESS_TOKEN *RestrictedToken
    )

/*++

Routine Description:

    This function takes a token as the input and returns a new restricted token
    from which Everyone sid has been disabled.  The resulting token may be used
    to find out if access is available to a user-sid by explicit means.

Arguments:

    Token - Input token from which Everyone sid needs to be deactivated.

    RestrictedToken - Receives the the new restricted token.
        This must be released using ObDereferenceObject(*RestrictedToken);

Return Value:

    NTSTATUS - Returned by SeFilterToken.

--*/

{
    //
    // Array of sids to disable.
    //

    TOKEN_GROUPS SidsToDisable;

    NTSTATUS Status = STATUS_SUCCESS;

    //
    //  Restricted token will contain the original sids with one change:
    //  If Everyone sid is present in the token, it will be marked for DenyOnly.
    //

    *RestrictedToken = NULL;

    //
    //  Put Everyone sid in the array of sids to disable. This will mark it
    //  for SE_GROUP_USE_FOR_DENY_ONLY and it'll only be applicable for Deny aces.
    //

    SidsToDisable.GroupCount = 1;
    SidsToDisable.Groups[0].Attributes = 0;
    SidsToDisable.Groups[0].Sid = SeExports->SeWorldSid;

    Status = SeFilterToken(
                 Token,            // Token that needs to be restricted.
                 0,                // No flags
                 &SidsToDisable,   // Disable everyone sid
                 NULL,             // Do not create any restricted sids
                 NULL,             // Do not delete any privileges
                 RestrictedToken   // Restricted token
                 );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\allocsup.c ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    AllocSup.c

Abstract:

    This module implements the Allocation support routines for Fat.

// @@BEGIN_DDKSPLIT

Author:

    DavidGoebel     [DavidGoe]      31-Oct-90

Revision History:

    DavidGoebel     [DavidGoe]      31-Oct-90

        Add unwinding support.  Some steps had to be reordered, and whether
        operations cpuld fail carefully considered.  In particular, attention
        was paid to to the order of Mcb operations (see note below).



             #####     ##    #    #   ####   ######  #####
             #    #   #  #   ##   #  #    #  #       #    #
             #    #  #    #  # #  #  #       #####   #    #
             #    #  ######  #  # #  #  ###  #       #####
             #    #  #    #  #   ##  #    #  #       #   #
             #####   #    #  #    #   ####   ######  #    #
             ______________________________________________


            ++++++++++++++++++++++++++++++++++++++++++++++++++|
            |                                                 |
            | The unwinding aspects of this module depend on  |
            | operational details of the Mcb package.  Do not |
            | attempt to modify unwind procedures without     |
            | thoughoughly understanding the innerworkings of |
            | the Mcb package.                                |
            |                                                 |
            ++++++++++++++++++++++++++++++++++++++++++++++++++|


         #    #    ##    #####   #    #     #    #    #   ####
         #    #   #  #   #    #  ##   #     #    ##   #  #    #
         #    #  #    #  #    #  # #  #     #    # #  #  #
         # ## #  ######  #####   #  # #     #    #  # #  #  ###
         ##  ##  #    #  #   #   #   ##     #    #   ##  #    #
         #    #  #    #  #    #  #    #     #    #    #   ####
         ______________________________________________________
         
         
         There is also a suspect convention in use due to the way FAT32 was
         put into the allocator. We've got four distinct kinds of numbers
         you can see being used:
         
         - true volume cluster numbers, ranging from 2 to N
         - zero-based volume cluster numbers, ranging from 0 to N-2
         - window-relative "true" cluster numbers, ranging from 2 to 10001,
            the window size. this is because the hints/allocation within a window
            looks like unwindowed FAT12/16.
         - window-relative zero-based cluster numbers, ranging from 0 to ffff
         
         Make very sure you realize what kind of number you are looking at. This
         is where a bad +/-2 can come back to haunt you for years.

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_ALLOCSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_ALLOCSUP)

#define FatMin(a, b)    ((a) < (b) ? (a) : (b))

//
//  This strucure is used by FatLookupFatEntry to remember a pinned page
//  of fat.
//

typedef struct _FAT_ENUMERATION_CONTEXT {

    VBO VboOfPinnedPage;
    PBCB Bcb;
    PVOID PinnedPage;

} FAT_ENUMERATION_CONTEXT, *PFAT_ENUMERATION_CONTEXT;

//
//  Local support routine prototypes
//

VOID
FatLookupFatEntry(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FatIndex,
    IN OUT PULONG FatEntry,
    IN OUT PFAT_ENUMERATION_CONTEXT Context
    );

VOID
FatSetFatRun(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartingFatIndex,
    IN ULONG ClusterCount,
    IN BOOLEAN ChainTogether
    );

UCHAR
FatLogOf(
    IN ULONG Value
    );

//
//  Note that the KdPrint below will ONLY fire when the assert does. Leave it
//  alone.
//

#if DBG
#define ASSERT_CURRENT_WINDOW_GOOD(VCB) {                                               \
    ULONG FreeClusterBitMapClear;                                                       \
    ASSERT( (VCB)->FreeClusterBitMap.Buffer != NULL );                                  \
    FreeClusterBitMapClear = RtlNumberOfClearBits(&(VCB)->FreeClusterBitMap);           \
    if ((VCB)->CurrentWindow->ClustersFree != FreeClusterBitMapClear) {                 \
        KdPrint(("FAT: ClustersFree %x h != FreeClusterBitMapClear %x h\n",             \
                 (VCB)->CurrentWindow->ClustersFree,                                    \
                 FreeClusterBitMapClear));                                              \
    }                                                                                   \
    ASSERT( (VCB)->CurrentWindow->ClustersFree == FreeClusterBitMapClear );             \
}
#else
#define ASSERT_CURRENT_WINDOW_GOOD(VCB)
#endif

//
//  The following macros provide a convenient way of hiding the details
//  of bitmap allocation schemes.
//


//
//  VOID
//  FatLockFreeClusterBitMap (
//      IN PVCB Vcb
//      );
//

#define FatLockFreeClusterBitMap(VCB) {                         \
    ASSERT(KeAreApcsDisabled());                                \
    ExAcquireFastMutexUnsafe( &(VCB)->FreeClusterBitMapMutex ); \
    ASSERT_CURRENT_WINDOW_GOOD(VCB)                             \
}

//
//  VOID
//  FatUnlockFreeClusterBitMap (
//      IN PVCB Vcb
//      );
//

#define FatUnlockFreeClusterBitMap(VCB) {                       \
    ASSERT_CURRENT_WINDOW_GOOD(VCB)                             \
    ASSERT(KeAreApcsDisabled());                                \
    ExReleaseFastMutexUnsafe( &(VCB)->FreeClusterBitMapMutex ); \
}

//
//  BOOLEAN
//  FatIsClusterFree (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG FatIndex
//      );
//

#define FatIsClusterFree(IRPCONTEXT,VCB,FAT_INDEX)                            \
    (RtlCheckBit(&(VCB)->FreeClusterBitMap,(FAT_INDEX)-2) == 0)

//
//  VOID
//  FatFreeClusters  (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG FatIndex,
//      IN ULONG ClusterCount
//      );
//

#define FatFreeClusters(IRPCONTEXT,VCB,FAT_INDEX,CLUSTER_COUNT) {             \
    if ((CLUSTER_COUNT) == 1) {                                               \
        FatSetFatEntry((IRPCONTEXT),(VCB),(FAT_INDEX),FAT_CLUSTER_AVAILABLE); \
    } else {                                                                  \
        FatSetFatRun((IRPCONTEXT),(VCB),(FAT_INDEX),(CLUSTER_COUNT),FALSE);   \
    }                                                                         \
}

//
//  VOID
//  FatAllocateClusters  (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG FatIndex,
//      IN ULONG ClusterCount
//      );
//

#define FatAllocateClusters(IRPCONTEXT,VCB,FAT_INDEX,CLUSTER_COUNT) {      \
    if ((CLUSTER_COUNT) == 1) {                                            \
        FatSetFatEntry((IRPCONTEXT),(VCB),(FAT_INDEX),FAT_CLUSTER_LAST);   \
    } else {                                                               \
        FatSetFatRun((IRPCONTEXT),(VCB),(FAT_INDEX),(CLUSTER_COUNT),TRUE); \
    }                                                                      \
}

//
//  VOID
//  FatUnreserveClusters  (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG FatIndex,
//      IN ULONG ClusterCount
//      );
//

#define FatUnreserveClusters(IRPCONTEXT,VCB,FAT_INDEX,CLUSTER_COUNT) {                      \
    ASSERT( (FAT_INDEX) + (CLUSTER_COUNT) - 2 <= (VCB)->FreeClusterBitMap.SizeOfBitMap );   \
    ASSERT( (FAT_INDEX) >= 2);                                                              \
    RtlClearBits(&(VCB)->FreeClusterBitMap,(FAT_INDEX)-2,(CLUSTER_COUNT));                  \
    if ((FAT_INDEX) < (VCB)->ClusterHint) {                                                 \
        (VCB)->ClusterHint = (FAT_INDEX);                                                   \
    }                                                                                       \
}

//
//  VOID
//  FatReserveClusters  (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG FatIndex,
//      IN ULONG ClusterCount
//      );
//
//  Handle wrapping the hint back to the front.
//

#define FatReserveClusters(IRPCONTEXT,VCB,FAT_INDEX,CLUSTER_COUNT) {                        \
    ULONG _AfterRun = (FAT_INDEX) + (CLUSTER_COUNT);                                        \
    ASSERT( (FAT_INDEX) + (CLUSTER_COUNT) - 2 <= (VCB)->FreeClusterBitMap.SizeOfBitMap );   \
    ASSERT( (FAT_INDEX) >= 2);                                                              \
    RtlSetBits(&(VCB)->FreeClusterBitMap,(FAT_INDEX)-2,(CLUSTER_COUNT));                    \
                                                                                            \
    if (_AfterRun - 2 >= (VCB)->FreeClusterBitMap.SizeOfBitMap) {                           \
        _AfterRun = 2;                                                                      \
    }                                                                                       \
    if (RtlCheckBit(&(VCB)->FreeClusterBitMap, _AfterRun - 2))  {                                   \
        (VCB)->ClusterHint = RtlFindClearBits( &(VCB)->FreeClusterBitMap, 1, _AfterRun - 2) + 2;    \
        if (1 == (VCB)->ClusterHint)  {                                                             \
            (VCB)->ClusterHint = 2;                                                         \
        }                                                                                   \
    }                                                                                       \
    else {                                                                                  \
        (VCB)->ClusterHint = _AfterRun;                                                     \
    }                                                                                       \
}

//
//  ULONG
//  FatFindFreeClusterRun (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG ClusterCount,
//      IN ULONG AlternateClusterHint
//      );
//
//  Do a special check if only one cluster is desired.
//

#define FatFindFreeClusterRun(IRPCONTEXT,VCB,CLUSTER_COUNT,CLUSTER_HINT) ( \
    (CLUSTER_COUNT == 1) &&                                                \
    FatIsClusterFree((IRPCONTEXT), (VCB), (CLUSTER_HINT)) ?                \
        (CLUSTER_HINT) :                                                   \
        RtlFindClearBits( &(VCB)->FreeClusterBitMap,                       \
                          (CLUSTER_COUNT),                                 \
                          (CLUSTER_HINT) - 2) + 2                          \
)

//
//  FAT32: Define the maximum size of the FreeClusterBitMap to be the
//  maximum size of a FAT16 FAT.  If there are more clusters on the
//  volume than can be represented by this many bytes of bitmap, the
//  FAT will be split into "buckets", each of which does fit.
//
//  Note this count is in clusters/bits of bitmap.
//

#define MAX_CLUSTER_BITMAP_SIZE         (1 << 16)

//
//  Calculate the window a given cluster number is in.
//

#define FatWindowOfCluster(C)           (((C) - 2) / MAX_CLUSTER_BITMAP_SIZE)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatAddFileAllocation)
#pragma alloc_text(PAGE, FatAllocateDiskSpace)
#pragma alloc_text(PAGE, FatDeallocateDiskSpace)
#pragma alloc_text(PAGE, FatExamineFatEntries)
#pragma alloc_text(PAGE, FatInterpretClusterType)
#pragma alloc_text(PAGE, FatLogOf)
#pragma alloc_text(PAGE, FatLookupFatEntry)
#pragma alloc_text(PAGE, FatLookupFileAllocation)
#pragma alloc_text(PAGE, FatLookupFileAllocationSize)
#pragma alloc_text(PAGE, FatMergeAllocation)
#pragma alloc_text(PAGE, FatSetFatEntry)
#pragma alloc_text(PAGE, FatSetFatRun)
#pragma alloc_text(PAGE, FatSetupAllocationSupport)
#pragma alloc_text(PAGE, FatSplitAllocation)
#pragma alloc_text(PAGE, FatTearDownAllocationSupport)
#pragma alloc_text(PAGE, FatTruncateFileAllocation)
#endif


INLINE
ULONG
FatSelectBestWindow( 
    IN PVCB Vcb
    )
/*++

Routine Description:

    Choose a window to allocate clusters from.   Order of preference is:

    1.  First window with >50% free clusters
    2.  First empty window
    3.  Window with greatest number of free clusters.
        
Arguments:

    Vcb - Supplies the Vcb for the volume

Return Value:

    'Best window' number (index into Vcb->Windows[])

--*/
{
    ULONG i, Fave = 0;
    ULONG MaxFree = 0;
    ULONG FirstEmpty = -1;
    ULONG ClustersPerWindow = MAX_CLUSTER_BITMAP_SIZE;

    ASSERT( 1 != Vcb->NumberOfWindows);
    
    for (i = 0; i < Vcb->NumberOfWindows; i++) {

        if (Vcb->Windows[i].ClustersFree == ClustersPerWindow)  {
        
            if (-1 == FirstEmpty)  {
            
                //
                //  Keep note of the first empty window on the disc
                //
                
                FirstEmpty = i;
            }
        }
        else if (Vcb->Windows[i].ClustersFree > MaxFree)  {

            //
            //  This window has the most free clusters,  so far
            //
            
            MaxFree = Vcb->Windows[i].ClustersFree;
            Fave = i;

            //
            //  If this window has >50% free clusters,  then we will take it,
            //  so don't bother considering more windows.
            //
            
            if (MaxFree >= (ClustersPerWindow >> 1))  {
            
                break;
            }
        }
    }

    //
    //  If there were no windows with 50% or more freespace,  then select the
    //  first empty window on the disc,  if any - otherwise we'll just go with
    //  the one with the most free clusters.
    //
    
    if ((MaxFree < (ClustersPerWindow >> 1)) && (-1 != FirstEmpty))  {

        Fave = FirstEmpty;
    }

    return Fave;
}


VOID
FatSetupAllocationSupport (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine fills in the Allocation Support structure in the Vcb.
    Most entries are computed using fat.h macros supplied with data from
    the Bios Parameter Block.  The free cluster count, however, requires
    going to the Fat and actually counting free sectors.  At the same time
    the free cluster bit map is initalized.

Arguments:

    Vcb - Supplies the Vcb to fill in.

--*/

{
    ULONG BitMapSize;
    PVOID BitMapBuffer;
    ULONG BitIndex;

    PBCB Bcb;

    ULONG Page;
    ULONG Offset;
    ULONG FatIndexBitSize;
    ULONG ClustersDescribableByFat;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatSetupAllocationSupport\n", 0);
    DebugTrace( 0, Dbg, "  Vcb = %8lx\n", Vcb);

    //
    //  Compute a number of fields for Vcb.AllocationSupport
    //

    Vcb->AllocationSupport.RootDirectoryLbo = FatRootDirectoryLbo( &Vcb->Bpb );
    Vcb->AllocationSupport.RootDirectorySize = FatRootDirectorySize( &Vcb->Bpb );

    Vcb->AllocationSupport.FileAreaLbo = FatFileAreaLbo( &Vcb->Bpb );

    Vcb->AllocationSupport.NumberOfClusters = FatNumberOfClusters( &Vcb->Bpb );

    Vcb->AllocationSupport.FatIndexBitSize = FatIndexBitSize( &Vcb->Bpb );

    Vcb->AllocationSupport.LogOfBytesPerSector = FatLogOf(Vcb->Bpb.BytesPerSector);
    Vcb->AllocationSupport.LogOfBytesPerCluster = FatLogOf(FatBytesPerCluster( &Vcb->Bpb ));
    Vcb->AllocationSupport.NumberOfFreeClusters = 0;

    //
    //  Deal with a bug in DOS 5 format, if the Fat is not big enough to
    //  describe all the clusters on the disk, reduce this number.  We expect
    //  that fat32 volumes will not have this problem.
    //
    //  Turns out this was not a good assumption.  We have to do this always now.
    //

    ClustersDescribableByFat = ( ((FatIsFat32(Vcb)? Vcb->Bpb.LargeSectorsPerFat :
                                                    Vcb->Bpb.SectorsPerFat) *
                                  Vcb->Bpb.BytesPerSector * 8)
                                 / FatIndexBitSize(&Vcb->Bpb) ) - 2;

    if (Vcb->AllocationSupport.NumberOfClusters > ClustersDescribableByFat) {

        Vcb->AllocationSupport.NumberOfClusters = ClustersDescribableByFat;
    }

    //
    //  Extend the virtual volume file to include the Fat
    //

    {
        CC_FILE_SIZES FileSizes;

        FileSizes.AllocationSize.QuadPart =
        FileSizes.FileSize.QuadPart = (FatReservedBytes( &Vcb->Bpb ) +
                                       FatBytesPerFat( &Vcb->Bpb ));
        FileSizes.ValidDataLength = FatMaxLarge;

        if ( Vcb->VirtualVolumeFile->PrivateCacheMap == NULL ) {

            CcInitializeCacheMap( Vcb->VirtualVolumeFile,
                                  &FileSizes,
                                  TRUE,
                                  &FatData.CacheManagerNoOpCallbacks,
                                  Vcb );

        } else {

            CcSetFileSizes( Vcb->VirtualVolumeFile, &FileSizes );
        }
    }

    try {

        if (FatIsFat32(Vcb) &&
            Vcb->AllocationSupport.NumberOfClusters > MAX_CLUSTER_BITMAP_SIZE) {

            Vcb->NumberOfWindows = (Vcb->AllocationSupport.NumberOfClusters +
                                    MAX_CLUSTER_BITMAP_SIZE - 1) /
                                   MAX_CLUSTER_BITMAP_SIZE;

            BitMapSize = MAX_CLUSTER_BITMAP_SIZE;

        } else {

            Vcb->NumberOfWindows = 1;
            BitMapSize = Vcb->AllocationSupport.NumberOfClusters;
        }

        Vcb->Windows = FsRtlAllocatePoolWithTag( PagedPool,
                                                 Vcb->NumberOfWindows * sizeof(FAT_WINDOW),
                                                 TAG_FAT_WINDOW );

        RtlInitializeBitMap( &Vcb->FreeClusterBitMap,
                             NULL,
                             0 );

        //
        //  Chose a FAT window to begin operation in.
        //

        if (Vcb->NumberOfWindows > 1) {

            //
            //  Read the fat and count up free clusters.  We bias by the two reserved
            //  entries in the FAT.
            //

            FatExamineFatEntries( IrpContext, Vcb,
                                  2,
                                  Vcb->AllocationSupport.NumberOfClusters + 2 - 1,
                                  TRUE,
                                  NULL,
                                  NULL);


            //
            //  Pick a window to begin allocating from
            //

            Vcb->CurrentWindow = &Vcb->Windows[ FatSelectBestWindow( Vcb)];

        } else {

            Vcb->CurrentWindow = &Vcb->Windows[0];

            //
            //  Carefully bias ourselves by the two reserved entries in the FAT.
            //

            Vcb->CurrentWindow->FirstCluster = 2;
            Vcb->CurrentWindow->LastCluster = Vcb->AllocationSupport.NumberOfClusters + 2 - 1;
        }

        //
        //  Now transition to the FAT window we have chosen.
        //

        FatExamineFatEntries( IrpContext, Vcb,
                              0,
                              0,
                              FALSE,
                              Vcb->CurrentWindow,
                              NULL);

        //
        //  Now set the ClusterHint to the first free bit in our favorite
        //  window (except the ClusterHint is off by two).
        //

        Vcb->ClusterHint =
            (BitIndex = RtlFindClearBits( &Vcb->FreeClusterBitMap, 1, 0 )) != -1 ?
                BitIndex + 2 : 2;

    } finally {

        DebugUnwind( FatSetupAllocationSupport );

        //
        //  If we hit an exception, back out.
        //

        if (AbnormalTermination()) {

            FatTearDownAllocationSupport( IrpContext, Vcb );
        }
    }

    return;
}


VOID
FatTearDownAllocationSupport (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine prepares the volume for closing.  Specifically, we must
    release the free fat bit map buffer, and uninitialize the dirty fat
    Mcb.

Arguments:

    Vcb - Supplies the Vcb to fill in.

Return Value:

    VOID

--*/

{
    DebugTrace(+1, Dbg, "FatTearDownAllocationSupport\n", 0);
    DebugTrace( 0, Dbg, "  Vcb = %8lx\n", Vcb);

    PAGED_CODE();

    //
    //  If there are FAT buckets, free them.
    //

    if ( Vcb->Windows != NULL ) {

        ExFreePool( Vcb->Windows );
        Vcb->Windows = NULL;
    }

    //
    //  Free the memory associated with the free cluster bitmap.
    //

    if ( Vcb->FreeClusterBitMap.Buffer != NULL ) {

        ExFreePool( Vcb->FreeClusterBitMap.Buffer );

        //
        //  NULL this field as an flag.
        //

        Vcb->FreeClusterBitMap.Buffer = NULL;
    }

    //
    //  And remove all the runs in the dirty fat Mcb
    //

    FatRemoveMcbEntry( Vcb, &Vcb->DirtyFatMcb, 0, 0xFFFFFFFF );

    DebugTrace(-1, Dbg, "FatTearDownAllocationSupport -> (VOID)\n", 0);

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}


VOID
FatLookupFileAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount,
    OUT PBOOLEAN Allocated,
    OUT PBOOLEAN EndOnMax,
    OUT PULONG Index
    )

/*++

Routine Description:

    This routine looks up the existing mapping of VBO to LBO for a
    file/directory.  The information it queries is either stored in the
    mcb field of the fcb/dcb or it is stored on in the fat table and
    needs to be retrieved and decoded, and updated in the mcb.

Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being queried

    Vbo - Supplies the VBO whose LBO we want returned

    Lbo - Receives the LBO corresponding to the input Vbo if one exists

    ByteCount - Receives the number of bytes within the run the run
                that correpond between the input vbo and output lbo.

    Allocated - Receives TRUE if the Vbo does have a corresponding Lbo
                and FALSE otherwise.

    EndOnMax - Receives TRUE if the run ends in the maximal FAT cluster,
                which results in a fractional bytecount.

    Index - Receives the Index of the run

--*/

{
    VBO CurrentVbo;
    LBO CurrentLbo;
    LBO PriorLbo;

    VBO FirstVboOfCurrentRun;
    LBO FirstLboOfCurrentRun;

    BOOLEAN LastCluster;
    ULONG Runs;

    PVCB Vcb;
    FAT_ENTRY FatEntry;
    ULONG BytesPerCluster;
    ULARGE_INTEGER BytesOnVolume;

    FAT_ENUMERATION_CONTEXT Context;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatLookupFileAllocation\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  = %8lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  Vbo       = %8lx\n", Vbo);
    DebugTrace( 0, Dbg, "  Lbo       = %8lx\n", Lbo);
    DebugTrace( 0, Dbg, "  ByteCount = %8lx\n", ByteCount);
    DebugTrace( 0, Dbg, "  Allocated = %8lx\n", Allocated);

    Context.Bcb = NULL;

    Vcb = FcbOrDcb->Vcb;

    *EndOnMax = FALSE;

    //
    //  Check the trivial case that the mapping is already in our
    //  Mcb.
    //

    if ( FatLookupMcbEntry(Vcb, &FcbOrDcb->Mcb, Vbo, Lbo, ByteCount, Index) ) {

        *Allocated = TRUE;

        ASSERT( ByteCount != 0);

        //
        //  Detect the overflow case, trim and claim the condition.
        //

        if (Vbo + *ByteCount == 0) {

            *EndOnMax = TRUE;
        }

        DebugTrace( 0, Dbg, "Found run in Mcb.\n", 0);
        DebugTrace(-1, Dbg, "FatLookupFileAllocation -> (VOID)\n", 0);
        return;
    }

    //
    //  Initialize the Vcb, the cluster size, LastCluster, and
    //  FirstLboOfCurrentRun (to be used as an indication of the first
    //  iteration through the following while loop).
    //

    BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    BytesOnVolume.QuadPart = UInt32x32To64( Vcb->AllocationSupport.NumberOfClusters, BytesPerCluster );

    LastCluster = FALSE;
    FirstLboOfCurrentRun = 0;

    //
    //  Discard the case that the request extends beyond the end of
    //  allocation.  Note that if the allocation size if not known
    //  AllocationSize is set to 0xffffffff.
    //

    if ( Vbo >= FcbOrDcb->Header.AllocationSize.LowPart ) {

        *Allocated = FALSE;

        DebugTrace( 0, Dbg, "Vbo beyond end of file.\n", 0);
        DebugTrace(-1, Dbg, "FatLookupFileAllocation -> (VOID)\n", 0);
        return;
    }

    //
    //  The Vbo is beyond the last Mcb entry.  So we adjust Current Vbo/Lbo
    //  and FatEntry to describe the beginning of the last entry in the Mcb.
    //  This is used as initialization for the following loop.
    //
    //  If the Mcb was empty, we start at the beginning of the file with
    //  CurrentVbo set to 0 to indicate a new run.
    //

    if (FatLookupLastMcbEntry( Vcb, &FcbOrDcb->Mcb, &CurrentVbo, &CurrentLbo, &Runs )) {

        DebugTrace( 0, Dbg, "Current Mcb size = %8lx.\n", CurrentVbo + 1);

        CurrentVbo -= (BytesPerCluster - 1);
        CurrentLbo -= (BytesPerCluster - 1);

        //
        //  Convert an index to a count.
        //

        Runs += 1;

    } else {

        DebugTrace( 0, Dbg, "Mcb empty.\n", 0);

        //
        //  Check for an FcbOrDcb that has no allocation
        //

        if (FcbOrDcb->FirstClusterOfFile == 0) {

            *Allocated = FALSE;

            DebugTrace( 0, Dbg, "File has no allocation.\n", 0);
            DebugTrace(-1, Dbg, "FatLookupFileAllocation -> (VOID)\n", 0);
            return;

        } else {

            CurrentVbo = 0;
            CurrentLbo = FatGetLboFromIndex( Vcb, FcbOrDcb->FirstClusterOfFile );
            FirstVboOfCurrentRun = CurrentVbo;
            FirstLboOfCurrentRun = CurrentLbo;

            Runs = 0;

            DebugTrace( 0, Dbg, "First Lbo of file = %8lx\n", CurrentLbo);
        }
    }

    //
    //  Now we know that we are looking up a valid Vbo, but it is
    //  not in the Mcb, which is a monotonically increasing list of
    //  Vbo's.  Thus we have to go to the Fat, and update
    //  the Mcb as we go.  We use a try-finally to unpin the page
    //  of fat hanging around.  Also we mark *Allocated = FALSE, so that
    //  the caller wont try to use the data if we hit an exception.
    //

    *Allocated = FALSE;

    try {

        FatEntry = (FAT_ENTRY)FatGetIndexFromLbo( Vcb, CurrentLbo );

        //
        //  ASSERT that CurrentVbo and CurrentLbo are now cluster alligned.
        //  The assumption here, is that only whole clusters of Vbos and Lbos
        //  are mapped in the Mcb.
        //

        ASSERT( ((CurrentLbo - Vcb->AllocationSupport.FileAreaLbo)
                                                    % BytesPerCluster == 0) &&
                (CurrentVbo % BytesPerCluster == 0) );

        //
        //  Starting from the first Vbo after the last Mcb entry, scan through
        //  the Fat looking for our Vbo. We continue through the Fat until we
        //  hit a noncontiguity beyond the desired Vbo, or the last cluster.
        //

        while ( !LastCluster ) {

            //
            //  Get the next fat entry, and update our Current variables.
            //

            FatLookupFatEntry( IrpContext, Vcb, FatEntry, &FatEntry, &Context );

            PriorLbo = CurrentLbo;
            CurrentLbo = FatGetLboFromIndex( Vcb, FatEntry );
            CurrentVbo += BytesPerCluster;

            switch ( FatInterpretClusterType( Vcb, FatEntry )) {

            //
            //  Check for a break in the Fat allocation chain.
            //

            case FatClusterAvailable:
            case FatClusterReserved:
            case FatClusterBad:

                DebugTrace( 0, Dbg, "Break in allocation chain, entry = %d\n", FatEntry);
                DebugTrace(-1, Dbg, "FatLookupFileAllocation -> Fat Corrupt.  Raise Status.\n", 0);

                FatPopUpFileCorrupt( IrpContext, FcbOrDcb );
                FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                break;

            //
            //  If this is the last cluster, we must update the Mcb and
            //  exit the loop.
            //

            case FatClusterLast:

                //
                //  Assert we know where the current run started.  If the
                //  Mcb was empty when we were called, thenFirstLboOfCurrentRun
                //  was set to the start of the file.  If the Mcb contained an
                //  entry, then FirstLboOfCurrentRun was set on the first
                //  iteration through the loop.  Thus if FirstLboOfCurrentRun
                //  is 0, then there was an Mcb entry and we are on our first
                //  iteration, meaing that the last cluster in the Mcb was
                //  really the last allocated cluster, but we checked Vbo
                //  against AllocationSize, and found it OK, thus AllocationSize
                //  must be too large.
                //
                //  Note that, when we finally arrive here, CurrentVbo is actually
                //  the first Vbo beyond the file allocation and CurrentLbo is
                //  meaningless.
                //

                DebugTrace( 0, Dbg, "Read last cluster of file.\n", 0);

                //
                //  Detect the case of the maximal file.  Note that this really isn't
                //  a proper Vbo - those are zero-based, and this is a one-based number.
                //  The maximal file, of 2^32 - 1 bytes, has a maximum byte offset of
                //  2^32 - 2.
                //
                //  Just so we don't get confused here.
                //

                if (CurrentVbo == 0) {

                    *EndOnMax = TRUE;
                    CurrentVbo -= 1;
                }

                LastCluster = TRUE;

                if (FirstLboOfCurrentRun != 0 ) {

                    DebugTrace( 0, Dbg, "Adding a run to the Mcb.\n", 0);
                    DebugTrace( 0, Dbg, "  Vbo    = %08lx.\n", FirstVboOfCurrentRun);
                    DebugTrace( 0, Dbg, "  Lbo    = %08lx.\n", FirstLboOfCurrentRun);
                    DebugTrace( 0, Dbg, "  Length = %08lx.\n", CurrentVbo - FirstVboOfCurrentRun);

                    (VOID)FatAddMcbEntry( Vcb,
                                          &FcbOrDcb->Mcb,
                                          FirstVboOfCurrentRun,
                                          FirstLboOfCurrentRun,
                                          CurrentVbo - FirstVboOfCurrentRun );

                    Runs += 1;
                }

                //
                //  Being at the end of allocation, make sure we have found
                //  the Vbo.  If we haven't, seeing as we checked VBO
                //  against AllocationSize, the real disk allocation is less
                //  than that of AllocationSize.  This comes about when the
                //  real allocation is not yet known, and AllocaitonSize
                //  contains MAXULONG.
                //
                //  KLUDGE! - If we were called by FatLookupFileAllocationSize
                //  Vbo is set to MAXULONG - 1, and AllocationSize to the lookup
                //  hint. Thus we merrily go along looking for a match that isn't
                //  there, but in the meantime building an Mcb.  If this is
                //  the case, fill in AllocationSize and return.
                //

                if ( Vbo == MAXULONG - 1 ) {

                    *Allocated = FALSE;
                    FcbOrDcb->Header.AllocationSize.QuadPart = CurrentVbo;

                    DebugTrace( 0, Dbg, "New file allocation size = %08lx.\n", CurrentVbo);
                    try_return ( NOTHING );
                }

                //
                //  We will lie ever so slightly if we really terminated on the
                //  maximal byte of a file.  It is really allocated.
                //

                if (Vbo >= CurrentVbo && !*EndOnMax) {

                    *Allocated = FALSE;
                    try_return ( NOTHING );
                }

                break;

            //
            //  This is a continuation in the chain.  If the run has a
            //  discontiguity at this point, update the Mcb, and if we are beyond
            //  the desired Vbo, this is the end of the run, so set LastCluster
            //  and exit the loop.
            //

            case FatClusterNext:

                //
                //  This is the loop check.  The Vbo must not be bigger than the size of
                //  the volume, and the Vbo must not have a) wrapped and b) not been at the
                //  very last cluster in the chain, for the case of the maximal file.
                //

                if ( CurrentVbo == 0 ||
                     (BytesOnVolume.HighPart == 0 && CurrentVbo > BytesOnVolume.LowPart)) {

                    FatPopUpFileCorrupt( IrpContext, FcbOrDcb );
                    FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                }

                if ( PriorLbo + BytesPerCluster != CurrentLbo ) {

                    //
                    //  Note that on the first time through the loop
                    //  (FirstLboOfCurrentRun == 0), we don't add the
                    //  run to the Mcb since it curresponds to the last
                    //  run already stored in the Mcb.
                    //

                    if ( FirstLboOfCurrentRun != 0 ) {

                        DebugTrace( 0, Dbg, "Adding a run to the Mcb.\n", 0);
                        DebugTrace( 0, Dbg, "  Vbo    = %08lx.\n", FirstVboOfCurrentRun);
                        DebugTrace( 0, Dbg, "  Lbo    = %08lx.\n", FirstLboOfCurrentRun);
                        DebugTrace( 0, Dbg, "  Length = %08lx.\n", CurrentVbo - FirstVboOfCurrentRun);

                        FatAddMcbEntry( Vcb,
                                        &FcbOrDcb->Mcb,
                                        FirstVboOfCurrentRun,
                                        FirstLboOfCurrentRun,
                                        CurrentVbo - FirstVboOfCurrentRun );

                        Runs += 1;
                    }

                    //
                    //  Since we are at a run boundry, with CurrentLbo and
                    //  CurrentVbo being the first cluster of the next run,
                    //  we see if the run we just added encompases the desired
                    //  Vbo, and if so exit.  Otherwise we set up two new
                    //  First*boOfCurrentRun, and continue.
                    //

                    if (CurrentVbo > Vbo) {

                        LastCluster = TRUE;

                    } else {

                        FirstVboOfCurrentRun = CurrentVbo;
                        FirstLboOfCurrentRun = CurrentLbo;
                    }
                }
                break;

            default:

                DebugTrace(0, Dbg, "Illegal Cluster Type.\n", FatEntry);

                FatBugCheck( 0, 0, 0 );

                break;

            } // switch()
        } // while()

        //
        //  Load up the return parameters.
        //
        //  On exit from the loop, Vbo still contains the desired Vbo, and
        //  CurrentVbo is the first byte after the run that contained the
        //  desired Vbo.
        //

        *Allocated = TRUE;

        *Lbo = FirstLboOfCurrentRun + (Vbo - FirstVboOfCurrentRun);

        *ByteCount = CurrentVbo - Vbo;

        if (ARGUMENT_PRESENT(Index)) {

            //
            //  Note that Runs only needs to be accurate with respect to where we
            //  ended.  Since partial-lookup cases will occur without exclusive
            //  synchronization, the Mcb itself may be much bigger by now.
            //

            *Index = Runs - 1;
        }

    try_exit: NOTHING;

    } finally {

        DebugUnwind( FatLookupFileAllocation );

        //
        //  We are done reading the Fat, so unpin the last page of fat
        //  that is hanging around
        //

        FatUnpinBcb( IrpContext, Context.Bcb );

        DebugTrace(-1, Dbg, "FatLookupFileAllocation -> (VOID)\n", 0);
    }

    return;
}


VOID
FatAddFileAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN ULONG DesiredAllocationSize
    )

/*++

Routine Description:

    This routine adds additional allocation to the specified file/directory.
    Additional allocation is added by appending clusters to the file/directory.

    If the file already has a sufficient allocation then this procedure
    is effectively a noop.

Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being modified.
               This parameter must not specify the root dcb.

    FileObject - If supplied inform the cache manager of the change.

    DesiredAllocationSize - Supplies the minimum size, in bytes, that we want
                            allocated to the file/directory.

--*/

{
    PVCB Vcb;
    LARGE_MCB NewMcb;
    PLARGE_MCB McbToCleanup = NULL;
    PDIRENT Dirent = NULL;
    ULONG NewAllocation;
    PBCB Bcb = NULL;
    BOOLEAN UnwindWeAllocatedDiskSpace = FALSE;
    BOOLEAN UnwindAllocationSizeSet = FALSE;
    BOOLEAN UnwindCacheManagerInformed = FALSE;
    BOOLEAN UnwindWeInitializedMcb = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatAddFileAllocation\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  =             %8lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  DesiredAllocationSize = %8lx\n", DesiredAllocationSize);

    //
    //  If we haven't yet set the correct AllocationSize, do so.
    //

    if (FcbOrDcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT)  {

        FatLookupFileAllocationSize( IrpContext, FcbOrDcb );
    }

    //
    //  Check for the benign case that the desired allocation is already
    //  within the allocation size.
    //

    if (DesiredAllocationSize <= FcbOrDcb->Header.AllocationSize.LowPart) {

        DebugTrace(0, Dbg, "Desired size within current allocation.\n", 0);

        DebugTrace(-1, Dbg, "FatAddFileAllocation -> (VOID)\n", 0);
        return;
    }

    DebugTrace( 0, Dbg, "InitialAllocation = %08lx.\n", FcbOrDcb->Header.AllocationSize.LowPart);

    //
    //  Get a chunk of disk space that will fullfill our needs.  If there
    //  was no initial allocation, start from the hint in the Vcb, otherwise
    //  try to allocate from the cluster after the initial allocation.
    //
    //  If there was no initial allocation to the file, we can just use the
    //  Mcb in the FcbOrDcb, otherwise we have to use a new one, and merge
    //  it to the one in the FcbOrDcb.
    //

    Vcb = FcbOrDcb->Vcb;

    try {

        if (FcbOrDcb->Header.AllocationSize.LowPart == 0) {

            LBO FirstLboOfFile;

            ASSERT( FcbOrDcb->FcbCondition == FcbGood );
            
            FatGetDirentFromFcbOrDcb( IrpContext,
                                      FcbOrDcb,
                                      &Dirent,
                                      &Bcb );

            ASSERT( Bcb != NULL );

            //
            //  Set this dirty right now since this call can fail.
            //

            FatSetDirtyBcb( IrpContext, Bcb, Vcb, TRUE );


            FatAllocateDiskSpace( IrpContext,
                                  Vcb,
                                  0,
                                  &DesiredAllocationSize,
                                  FALSE,
                                  &FcbOrDcb->Mcb );

            UnwindWeAllocatedDiskSpace = TRUE;
            McbToCleanup = &FcbOrDcb->Mcb;

            //
            //  We have to update the dirent and FcbOrDcb copies of
            //  FirstClusterOfFile since before it was 0
            //

            FatLookupMcbEntry( FcbOrDcb->Vcb,
                               &FcbOrDcb->Mcb,
                               0,
                               &FirstLboOfFile,
                               (PULONG)NULL,
                               NULL );

            DebugTrace( 0, Dbg, "First Lbo of file will be %08lx.\n", FirstLboOfFile );

            FcbOrDcb->FirstClusterOfFile = FatGetIndexFromLbo( Vcb, FirstLboOfFile );

            Dirent->FirstClusterOfFile = (USHORT)FcbOrDcb->FirstClusterOfFile;

            if ( FatIsFat32(Vcb) ) {

                Dirent->FirstClusterOfFileHi = (USHORT)(FcbOrDcb->FirstClusterOfFile >> 16);
            }

            //
            //   Note the size of the allocation we need to tell the cache manager about.
            //

            NewAllocation = DesiredAllocationSize;

        } else {

            LBO LastAllocatedLbo;
            VBO DontCare;

            //
            //  Get the first cluster following the current allocation.  It is possible
            //  the Mcb is empty (or short, etc.) so we need to be slightly careful
            //  about making sure we don't lie with the hint.
            //

            (void)FatLookupLastMcbEntry( FcbOrDcb->Vcb, &FcbOrDcb->Mcb, &DontCare, &LastAllocatedLbo, NULL );

            //
            //  Try to get some disk space starting from there.
            //

            NewAllocation = DesiredAllocationSize - FcbOrDcb->Header.AllocationSize.LowPart;

            FsRtlInitializeLargeMcb( &NewMcb, PagedPool );
            UnwindWeInitializedMcb = TRUE;
            McbToCleanup = &NewMcb;

            FatAllocateDiskSpace( IrpContext,
                                  Vcb,
                                  (LastAllocatedLbo != ~0  ?
                                   FatGetIndexFromLbo(Vcb,LastAllocatedLbo + 1) :
                                   0),
                                  &NewAllocation,
                                  FALSE,
                                  &NewMcb );

            UnwindWeAllocatedDiskSpace = TRUE;
        }

        //
        //  Now that we increased the allocation of the file, mark it in the
        //  FcbOrDcb.  Carefully prepare to handle an inability to grow the cache
        //  structures.
        //

        FcbOrDcb->Header.AllocationSize.LowPart += NewAllocation;

        //
        //  Handle the maximal file case, where we may have just wrapped.  Note
        //  that this must be the precise boundary case wrap, i.e. by one byte,
        //  so that the new allocation is actually one byte "less" as far as we're
        //  concerned.  This is important for the extension case.
        //

        if (FcbOrDcb->Header.AllocationSize.LowPart == 0) {

            NewAllocation -= 1;
            FcbOrDcb->Header.AllocationSize.LowPart = 0xffffffff;
        }

        UnwindAllocationSizeSet = TRUE;

        //
        //  Inform the cache manager to increase the section size
        //

        if ( ARGUMENT_PRESENT(FileObject) && CcIsFileCached(FileObject) ) {

            CcSetFileSizes( FileObject,
                            (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize );
            UnwindCacheManagerInformed = TRUE;
        }

        //
        //  In the extension case, we have held off actually gluing the new
        //  allocation onto the file.  This simplifies exception cleanup since
        //  if it was already added and the section grow failed, we'd have to
        //  do extra work to unglue it.  This way, we can assume that if we
        //  raise the only thing we need to do is deallocate the disk space.
        //
        //  Merge the allocation now.
        //

        if (FcbOrDcb->Header.AllocationSize.LowPart != NewAllocation) {

            //
            //  Tack the new Mcb onto the end of the FcbOrDcb one.
            //

            FatMergeAllocation( IrpContext,
                                Vcb,
                                &FcbOrDcb->Mcb,
                                &NewMcb );
        }

    } finally {

        DebugUnwind( FatAddFileAllocation );

        //
        //  Give FlushFileBuffer a clue here.
        //

        SetFlag(FcbOrDcb->FcbState, FCB_STATE_FLUSH_FAT);

        //
        //  If we were dogged trying to complete this operation, we need to go
        //  back various things out.
        //

        if (AbnormalTermination()) {

            //
            //  Pull off the allocation size we tried to add to this object if
            //  we failed to grow cache structures or Mcb structures.
            //

            if (UnwindAllocationSizeSet) {

                FcbOrDcb->Header.AllocationSize.LowPart -= NewAllocation;
            }

            if (UnwindCacheManagerInformed) {

                CcSetFileSizes( FileObject,
                                (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize );
            }

            //
            //  In the case of initial allocation, we used the Fcb's Mcb and have
            //  to clean that up as well as the FAT chain references.
            //

            if (FcbOrDcb->Header.AllocationSize.LowPart == 0) {

                if (Dirent != NULL) {

                    FcbOrDcb->FirstClusterOfFile = 0;
                    Dirent->FirstClusterOfFile = 0;

                    if ( FatIsFat32(Vcb) ) {

                        Dirent->FirstClusterOfFileHi = 0;
                    }
                }
            }

            //
            //  ... and drop the dirent Bcb if we got it.  Do it now
            //  so we can afford to take the exception if we have to.
            //

            FatUnpinBcb( IrpContext, Bcb );

            try {

                //
                //  Note this can re-raise.
                //

                if ( UnwindWeAllocatedDiskSpace ) {

                    FatDeallocateDiskSpace( IrpContext, Vcb, McbToCleanup );
                }

            } finally {

                //
                //  We always want to clean up the non-initial allocation temporary Mcb,
                //  otherwise we have the Fcb's Mcb and we just truncate it away.
                //

                if (UnwindWeInitializedMcb == TRUE) {

                    //
                    //  Note that we already know a raise is in progress.  No danger
                    //  of encountering the normal case code below and doing this again.
                    //

                    FsRtlUninitializeLargeMcb( McbToCleanup );

                } else {

                    if (McbToCleanup) {

                        FsRtlTruncateLargeMcb( McbToCleanup, 0 );
                    }
                }
            }
        }

        DebugTrace(-1, Dbg, "FatAddFileAllocation -> (VOID)\n", 0);
    }

    //
    //  Non-exceptional cleanup we always want to do.  In handling the re-raise possibilities
    //  during exceptions we had to make sure these two steps always happened there beforehand.
    //  So now we handle the usual case.
    //

    FatUnpinBcb( IrpContext, Bcb );

    if (UnwindWeInitializedMcb == TRUE) {

        FsRtlUninitializeLargeMcb( &NewMcb );
    }
}


VOID
FatTruncateFileAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN ULONG DesiredAllocationSize
    )

/*++

Routine Description:

    This routine truncates the allocation to the specified file/directory.

    If the file is already smaller than the indicated size then this procedure
    is effectively a noop.


Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being modified
               This parameter must not specify the root dcb.

    DesiredAllocationSize - Supplies the maximum size, in bytes, that we want
                            allocated to the file/directory.  It is rounded
                            up to the nearest cluster.

Return Value:

    VOID - TRUE if the operation completed and FALSE if it had to
        block but could not.

--*/

{
    PVCB Vcb;
    PBCB Bcb = NULL;
    LARGE_MCB RemainingMcb;
    ULONG BytesPerCluster;
    PDIRENT Dirent = NULL;
    BOOLEAN UpdatedDirent = FALSE;

    ULONG UnwindInitialAllocationSize;
    ULONG UnwindInitialFirstClusterOfFile;
    BOOLEAN UnwindWeAllocatedMcb = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatTruncateFileAllocation\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  =             %8lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  DesiredAllocationSize = %8lx\n", DesiredAllocationSize);

    //
    //  If the Fcb isn't in good condition, we have no business whacking around on
    //  the disk after "its" clusters.
    //
    //  Inspired by a Prefix complaint.
    //
    
    ASSERT( FcbOrDcb->FcbCondition == FcbGood );

    //
    //  If we haven't yet set the correct AllocationSize, do so.
    //

    if (FcbOrDcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT)  {

        FatLookupFileAllocationSize( IrpContext, FcbOrDcb );
    }

    //
    //  Round up the Desired Allocation Size to the next cluster size
    //

    Vcb = FcbOrDcb->Vcb;

    BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    //
    //  Note if the desired allocation is zero, to distinguish this from
    //  the wrap case below.
    //

    if (DesiredAllocationSize != 0) {

        DesiredAllocationSize = (DesiredAllocationSize + (BytesPerCluster - 1)) &
                                ~(BytesPerCluster - 1);
        //
        //  Check for the benign case that the file is already smaller than
        //  the desired truncation.  Note that if it wraps, then a) it was
        //  specifying an offset in the maximally allocatable cluster and
        //  b) we're not asking to extend the file, either.  So stop.
        //

        if (DesiredAllocationSize == 0 ||
            DesiredAllocationSize >= FcbOrDcb->Header.AllocationSize.LowPart) {

            DebugTrace(0, Dbg, "Desired size within current allocation.\n", 0);

            DebugTrace(-1, Dbg, "FatTruncateFileAllocation -> (VOID)\n", 0);
            return;
        }

    }

    UnwindInitialAllocationSize = FcbOrDcb->Header.AllocationSize.LowPart;
    UnwindInitialFirstClusterOfFile = FcbOrDcb->FirstClusterOfFile;

    //
    //  Update the FcbOrDcb allocation size.  If it is now zero, we have the
    //  additional task of modifying the FcbOrDcb and Dirent copies of
    //  FirstClusterInFile.
    //
    //  Note that we must pin the dirent before actually deallocating the
    //  disk space since, in unwind, it would not be possible to reallocate
    //  deallocated disk space as someone else may have reallocated it and
    //  may cause an exception when you try to get some more disk space.
    //  Thus FatDeallocateDiskSpace must be the final dangerous operation.
    //

    try {

        FcbOrDcb->Header.AllocationSize.QuadPart = DesiredAllocationSize;

        //
        //  Special case 0
        //

        if (DesiredAllocationSize == 0) {

            //
            //  We have to update the dirent and FcbOrDcb copies of
            //  FirstClusterOfFile since before it was 0
            //

            ASSERT( FcbOrDcb->FcbCondition == FcbGood );
            
            FatGetDirentFromFcbOrDcb( IrpContext, FcbOrDcb, &Dirent, &Bcb );

            ASSERT( Dirent && Bcb );

            Dirent->FirstClusterOfFile = 0;

            if (FatIsFat32(Vcb)) {

                Dirent->FirstClusterOfFileHi = 0;
            }

            FcbOrDcb->FirstClusterOfFile = 0;

            FatSetDirtyBcb( IrpContext, Bcb, Vcb, TRUE );
            UpdatedDirent = TRUE;

            FatDeallocateDiskSpace( IrpContext, Vcb, &FcbOrDcb->Mcb );

            FatRemoveMcbEntry( FcbOrDcb->Vcb, &FcbOrDcb->Mcb, 0, 0xFFFFFFFF );

        } else {

            //
            //  Split the existing allocation into two parts, one we will keep, and
            //  one we will deallocate.
            //

            FsRtlInitializeLargeMcb( &RemainingMcb, PagedPool );
            UnwindWeAllocatedMcb = TRUE;

            FatSplitAllocation( IrpContext,
                                Vcb,
                                &FcbOrDcb->Mcb,
                                DesiredAllocationSize,
                                &RemainingMcb );

            FatDeallocateDiskSpace( IrpContext, Vcb, &RemainingMcb );

            FsRtlUninitializeLargeMcb( &RemainingMcb );
        }

    } finally {

        DebugUnwind( FatTruncateFileAllocation );

        //
        //  Is this really the right backout strategy?  It would be nice if we could
        //  pretend the truncate worked if we knew that the file had gotten into
        //  a consistent state.  Leaving dangled clusters is probably quite preferable.
        //

        if ( AbnormalTermination() ) {

            FcbOrDcb->Header.AllocationSize.LowPart = UnwindInitialAllocationSize;

            if ( (DesiredAllocationSize == 0) && (Dirent != NULL)) {

                if (UpdatedDirent)  {

                    //
                    //  If the dirent has been updated ok and marked dirty,  then we
                    //  failed in deallocatediscspace,  and don't know what state
                    //  the on disc fat chain is in.  So we throw away the mcb,
                    //  and potentially loose a few clusters until the next
                    //  chkdsk.  The operation has succeeded,  but the exception
                    //  will still propogate.  5.1
                    //

                    FatRemoveMcbEntry( Vcb, &FcbOrDcb->Mcb, 0, 0xFFFFFFFF );
                    FcbOrDcb->Header.AllocationSize.QuadPart = 0;
                }
                else  {

                    Dirent->FirstClusterOfFile = (USHORT)UnwindInitialFirstClusterOfFile;

                    if ( FatIsFat32(Vcb) ) {

                        Dirent->FirstClusterOfFileHi =
                                (USHORT)(UnwindInitialFirstClusterOfFile >> 16);
                    }

                    FcbOrDcb->FirstClusterOfFile = UnwindInitialFirstClusterOfFile;
                }
            }

            if ( UnwindWeAllocatedMcb ) {

                FsRtlUninitializeLargeMcb( &RemainingMcb );
            }

            //
            //  Note that in the non zero truncation case,  we will also
            //  leak clusters.  However, apart from this, the in memory and on disc
            //  structures will agree.
        }

        FatUnpinBcb( IrpContext, Bcb );

        //
        //  Give FlushFileBuffer a clue here.
        //

        SetFlag(FcbOrDcb->FcbState, FCB_STATE_FLUSH_FAT);

        DebugTrace(-1, Dbg, "FatTruncateFileAllocation -> (VOID)\n", 0);
    }
}


VOID
FatLookupFileAllocationSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb
    )

/*++

Routine Description:

    This routine retrieves the current file allocatio size for the
    specified file/directory.

Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being modified

--*/

{
    LBO Lbo;
    ULONG ByteCount;
    BOOLEAN DontCare;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatLookupAllocationSize\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  =      %8lx\n", FcbOrDcb);

    //
    //  We call FatLookupFileAllocation with Vbo of 0xffffffff - 1.
    //

    FatLookupFileAllocation( IrpContext,
                             FcbOrDcb,
                             MAXULONG - 1,
                             &Lbo,
                             &ByteCount,
                             &DontCare,
                             &DontCare,
                             NULL );

    //
    //  FileSize was set at Fcb creation time from the contents of the directory entry,
    //  and we are only now looking up the real length of the allocation chain.  If it
    //  cannot be contained, this is trash.  Probably more where that came from.
    //

    if (FcbOrDcb->Header.FileSize.LowPart > FcbOrDcb->Header.AllocationSize.LowPart) {

        FatPopUpFileCorrupt( IrpContext, FcbOrDcb );
        FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    DebugTrace(-1, Dbg, "FatLookupFileAllocationSize -> (VOID)\n", 0);
    return;
}


VOID
FatAllocateDiskSpace (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG AbsoluteClusterHint,
    IN PULONG ByteCount,
    IN BOOLEAN ExactMatchRequired,
    OUT PLARGE_MCB Mcb
    )

/*++

Routine Description:

    This procedure allocates additional disk space and builds an mcb
    representing the newly allocated space.  If the space cannot be
    allocated then this procedure raises an appropriate status.

    Searching starts from the hint index in the Vcb unless an alternative
    non-zero hint is given in AlternateClusterHint.  If we are using the
    hint field in the Vcb, it is set to the cluster following our allocation
    when we are done.

    Disk space can only be allocated in cluster units so this procedure
    will round up any byte count to the next cluster boundary.

    Pictorially what is done is the following (where ! denotes the end of
    the fat chain (i.e., FAT_CLUSTER_LAST)):


        Mcb (empty)

    becomes

        Mcb |--a--|--b--|--c--!

                            ^
        ByteCount ----------+

Arguments:

    Vcb - Supplies the VCB being modified

    AbsoluteClusterHint  - Supplies an alternate hint index to start the
                           search from.  If this is zero we use, and update,
                           the Vcb hint field.

    ByteCount - Supplies the number of bytes that we are requesting, and
                receives the number of bytes that we got.

    ExactMatchRequired - Caller should set this to TRUE if only the precise run requested
                 is acceptable.

    Mcb - Receives the MCB describing the newly allocated disk space.  The
          caller passes in an initialized Mcb that is filled in by this procedure.

 Return Value:

    TRUE  - Allocated ok
    FALSE - Failed to allocate exactly as requested (=> ExactMatchRequired was TRUE)

--*/

{
    UCHAR LogOfBytesPerCluster;
    ULONG BytesPerCluster;
    ULONG StartingCluster;
    ULONG ClusterCount;
    ULONG WindowRelativeHint;
#if DBG
    ULONG i;
    ULONG PreviousClear;
#endif

    PFAT_WINDOW Window;
    BOOLEAN Wait;
    BOOLEAN Result = TRUE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatAllocateDiskSpace\n", 0);
    DebugTrace( 0, Dbg, "  Vcb        = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  *ByteCount = %8lx\n", *ByteCount);
    DebugTrace( 0, Dbg, "  Mcb        = %8lx\n", Mcb);
    DebugTrace( 0, Dbg, "  Hint       = %8lx\n", AbsoluteClusterHint);

    ASSERT((AbsoluteClusterHint <= Vcb->AllocationSupport.NumberOfClusters + 2) && (1 != AbsoluteClusterHint));

    //
    //  Make sure byte count is not zero
    //

    if (*ByteCount == 0) {

        DebugTrace(0, Dbg, "Nothing to allocate.\n", 0);

        DebugTrace(-1, Dbg, "FatAllocateDiskSpace -> (VOID)\n", 0);
        return;
    }

    //
    //  Compute the cluster count based on the byte count, rounding up
    //  to the next cluster if there is any remainder.  Note that the
    //  pathalogical case BytesCount == 0 has been eliminated above.
    //

    LogOfBytesPerCluster = Vcb->AllocationSupport.LogOfBytesPerCluster;
    BytesPerCluster = 1 << LogOfBytesPerCluster;

    *ByteCount = (*ByteCount + (BytesPerCluster - 1))
                            & ~(BytesPerCluster - 1);

    //
    //  If ByteCount is NOW zero, then we were asked for the maximal
    //  filesize (or at least for bytes in the last allocatable sector).
    //

    if (*ByteCount == 0) {

        *ByteCount = 0xffffffff;
        ClusterCount =  1 << (32 - LogOfBytesPerCluster);

    } else {

        ClusterCount = (*ByteCount >> LogOfBytesPerCluster);
    }

    //
    //  Make sure there are enough free clusters to start with, and
    //  take them now so that nobody else takes them from us.  
    //

    ExAcquireResourceSharedLite(&Vcb->ChangeBitMapResource, TRUE);
    FatLockFreeClusterBitMap( Vcb );

    if (ClusterCount <= Vcb->AllocationSupport.NumberOfFreeClusters) {

        Vcb->AllocationSupport.NumberOfFreeClusters -= ClusterCount;

    } else {

        FatUnlockFreeClusterBitMap( Vcb );
        ExReleaseResourceLite(&Vcb->ChangeBitMapResource);

        DebugTrace(0, Dbg, "Disk Full.  Raise Status.\n", 0);
        FatRaiseStatus( IrpContext, STATUS_DISK_FULL );
    }

    //
    //  Did the caller supply a hint?
    //

    if ((0 != AbsoluteClusterHint) && (AbsoluteClusterHint < (Vcb->AllocationSupport.NumberOfClusters + 2)))  {

        if (Vcb->NumberOfWindows > 1)  {

            //
            //  If we're being called upon to allocate clusters outside the
            //  current window (which happens only via MoveFile), it's a problem.
            //  We address this by changing the current window to be the one which
            //  contains the alternate cluster hint.  Note that if the user's
            //  request would cross a window boundary, he doesn't really get what
            //  he wanted.
            //

            if (AbsoluteClusterHint < Vcb->CurrentWindow->FirstCluster ||
                AbsoluteClusterHint > Vcb->CurrentWindow->LastCluster) {

                ULONG BucketNum = FatWindowOfCluster( AbsoluteClusterHint );

                ASSERT( BucketNum < Vcb->NumberOfWindows);

                //
                //  Drop our shared lock on the ChangeBitMapResource,  and pick it up again
                //  exclusive in preparation for making the window swap.
                //
                
                FatUnlockFreeClusterBitMap(Vcb);    
                ExReleaseResourceLite(&Vcb->ChangeBitMapResource);
                ExAcquireResourceExclusiveLite(&Vcb->ChangeBitMapResource, TRUE);
                FatLockFreeClusterBitMap(Vcb);

                Window = &Vcb->Windows[BucketNum];

                //
                //  Again,  test the current window against the one we want - some other
                //  thread could have sneaked in behind our backs and kindly set it to the one 
                //  we need,  when we dropped and reacquired the ChangeBitMapResource above.
                //
                
                if (Window != Vcb->CurrentWindow)  {
                
                    try {

                        Wait = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
                        SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);

                        //
                        //  Change to the new window (update Vcb->CurrentWindow) and scan it
                        //  to build up a freespace bitmap etc.
                        //
                        
                        FatExamineFatEntries( IrpContext, Vcb,
                                              0,
                                              0,
                                              FALSE,
                                              Window,
                                              NULL);

                    } finally {

                        if (!Wait) {

                            ClearFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
                        }

                        if (AbnormalTermination()) {

                            //
                            //  We will have raised as a result of failing to pick up the
                            //  chunk of the FAT for this window move.  Release our resources
                            //  and return the cluster count to the volume.
                            //

                            Vcb->AllocationSupport.NumberOfFreeClusters += ClusterCount;

                            FatUnlockFreeClusterBitMap( Vcb );
                            ExReleaseResourceLite(&Vcb->ChangeBitMapResource);
                        }
                    }
                }
            }

            //
            //  Make the hint cluster number relative to the base of the current window...
            //
            //  Currentwindow->Firstcluster is baised by +2 already,  so we will lose the
            //  bias already in AbsoluteClusterHint.  Put it back....
            //

            WindowRelativeHint = AbsoluteClusterHint - Vcb->CurrentWindow->FirstCluster + 2;
        }
        else {

            //
            //  Only one 'window',  ie fat16/12.  No modification necessary.
            //

            WindowRelativeHint = AbsoluteClusterHint;
        }
    }
    else {

        //
        //  Either no hint supplied,  or it was out of range,  so grab one from the Vcb
        //
        //  NOTE: Clusterhint in the Vcb is not guaranteed to be set (may be -1)
        //
    
        WindowRelativeHint = Vcb->ClusterHint;
        AbsoluteClusterHint = 0;

        //
        //  Vcb hint may not have been initialized yet.  Force to valid cluster.
        //

        if (-1 == WindowRelativeHint)  {

            WindowRelativeHint = 2;
        }
    }

    ASSERT((WindowRelativeHint >= 2) && (WindowRelativeHint < Vcb->FreeClusterBitMap.SizeOfBitMap + 2));

    //
    //  Keep track of the window we're allocating from, so we can clean
    //  up correctly if the current window changes after we unlock the
    //  bitmap.
    //

    Window = Vcb->CurrentWindow;

    //
    //  Try to find a run of free clusters large enough for us.
    //

    StartingCluster = FatFindFreeClusterRun( IrpContext,
                                             Vcb,
                                             ClusterCount,
                                             WindowRelativeHint );
    //
    //  If the above call was successful, we can just update the fat
    //  and Mcb and exit.  Otherwise we have to look for smaller free
    //  runs.
    //
    //  This test is a bit funky. Note that the error return from
    //  RtlFindClearBits is -1, and adding two to that is 1.
    //

    if ((StartingCluster != 1) &&
        ((0 == AbsoluteClusterHint) || (StartingCluster == WindowRelativeHint))
    )  {

#if DBG
        PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif // DBG

        //
        //  Take the clusters we found, and unlock the bit map.
        //

        FatReserveClusters(IrpContext, Vcb, StartingCluster, ClusterCount);

        Window->ClustersFree -= ClusterCount;

        StartingCluster += Window->FirstCluster;
        StartingCluster -= 2;

        ASSERT( PreviousClear - ClusterCount == Window->ClustersFree );

        FatUnlockFreeClusterBitMap( Vcb );

        //
        //  Note that this call will never fail since there is always
        //  room for one entry in an empty Mcb.
        //

        FatAddMcbEntry( Vcb, Mcb,
                        0,
                        FatGetLboFromIndex( Vcb, StartingCluster ),
                        *ByteCount);
        try {

            //
            //  Update the fat.
            //

            FatAllocateClusters(IrpContext, Vcb,
                                StartingCluster,
                                ClusterCount);

        } finally {

            DebugUnwind( FatAllocateDiskSpace );

            //
            //  If the allocate clusters failed, remove the run from the Mcb,
            //  unreserve the clusters, and reset the free cluster count.
            //

            if (AbnormalTermination()) {

                FatRemoveMcbEntry( Vcb, Mcb, 0, *ByteCount );

                FatLockFreeClusterBitMap( Vcb );

                //  Only clear bits if the bitmap window is the same.

                if (Window == Vcb->CurrentWindow) {

                    //  Both values (startingcluster and window->firstcluster) are
                    //  already biased by 2,  so will cancel,  so we need to add in the 2 again.

                    FatUnreserveClusters( IrpContext, Vcb,
                                          StartingCluster - Window->FirstCluster + 2,
                                          ClusterCount );
                }

                Window->ClustersFree += ClusterCount;
                Vcb->AllocationSupport.NumberOfFreeClusters += ClusterCount;

                FatUnlockFreeClusterBitMap( Vcb );
            }

            ExReleaseResourceLite(&Vcb->ChangeBitMapResource);
        }

    } else {

        //
        //  Note that Index is a zero-based window-relative number.  When appropriate
        //  it'll get converted into a true cluster number and put in Cluster, which
        //  will be a volume relative true cluster number.
        //
        
        ULONG Index;
        ULONG Cluster;
        ULONG CurrentVbo;
        ULONG PriorLastCluster;
        ULONG BytesFound;

        ULONG ClustersFound = 0;
        ULONG ClustersRemaining;

        BOOLEAN LockedBitMap = FALSE;
        BOOLEAN SelectNextContigWindow = FALSE;

        //
        //  Drop our shared lock on the ChangeBitMapResource,  and pick it up again
        //  exclusive in preparation for making a window swap.
        //
        
        FatUnlockFreeClusterBitMap(Vcb);
        ExReleaseResourceLite(&Vcb->ChangeBitMapResource);
        ExAcquireResourceExclusiveLite(&Vcb->ChangeBitMapResource, TRUE);
        FatLockFreeClusterBitMap(Vcb);
        LockedBitMap = TRUE;

        try {

            if ( ExactMatchRequired && (1 == Vcb->NumberOfWindows))  {

                //
                //  Give up right now,  there are no more windows to search!  RtlFindClearBits
                //  searchs the whole bitmap,  so we would have found any contiguous run
                //  large enough.
                //

                try_leave( Result = FALSE);
            }

            //
            //  While the request is still incomplete, look for the largest
            //  run of free clusters, mark them taken, allocate the run in
            //  the Mcb and Fat, and if this isn't the first time through
            //  the loop link it to prior run on the fat.  The Mcb will
            //  coalesce automatically.
            //

            ClustersRemaining = ClusterCount;
            CurrentVbo = 0;
            PriorLastCluster = 0;

            while (ClustersRemaining != 0) {

                //
                //  If we just entered the loop, the bit map is already locked
                //

                if ( !LockedBitMap ) {

                    FatLockFreeClusterBitMap( Vcb );
                    LockedBitMap = TRUE;
                }

                //
                //  Find the largest run of free clusters.  If the run is
                //  bigger than we need, only use what we need.  Note that
                //  this will then be the last while() iteration.
                //

                // 12/3/95 - David Goebel: need to bias bitmap by 2 bits for the defrag
                // hooks and the below macro became impossible to do without in-line
                // procedures.
                //
                // ClustersFound = FatLongestFreeClusterRun( IrpContext, Vcb, &Index );

                ClustersFound = 0;

                if (!SelectNextContigWindow)  {

                    if ( 0 != WindowRelativeHint)  {

                        ULONG Desired = Vcb->FreeClusterBitMap.SizeOfBitMap - (WindowRelativeHint - 2);

                        //
                        //  We will try to allocate contiguously.  Try from the current hint the to
                        //  end of current window.  Don't try for more than we actually need.
                        //

                        if (Desired > ClustersRemaining)  {

                            Desired = ClustersRemaining;
                        }

                        if (RtlAreBitsClear(  &Vcb->FreeClusterBitMap,
                                              WindowRelativeHint - 2,
                                              Desired))
                        {
                            //
                            //  Clusters from hint->...windowend are free.  Take them.
                            //

                            Index = WindowRelativeHint - 2;
                            ClustersFound = Desired;

                            if (FatIsFat32(Vcb))  {

                                //
                                //  We're now up against the end of the current window,  so indicate that we
                                //  want the next window in the sequence next time around.  (If we're not up
                                //  against the end of the window,  then we got what we needed and won't be
                                //  coming around again anyway).
                                //

                                SelectNextContigWindow = TRUE;
                                WindowRelativeHint = 2;
                            }
                            else {

                                //
                                //  FAT 12/16 - we've run up against the end of the volume.  Clear the
                                //  hint,  since we now have no idea where to look.
                                //

                                WindowRelativeHint = 0;
                            }
#if DBG
                            PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif // DBG
                        }
                        else  {

                            if (ExactMatchRequired)  {

                                //
                                //  If our caller required an exact match,  then we're hosed.  Bail out now.
                                //

                                try_leave( Result = FALSE);
                            }

                            //
                            //  Hint failed,  drop back to pot luck
                            //

                            WindowRelativeHint = 0;
                        }
                    }

                    if ((0 == WindowRelativeHint) && (0 == ClustersFound)) {

                        if (ClustersRemaining <= Vcb->CurrentWindow->ClustersFree)  {
                        
                            //
                            //  The remaining allocation could be satisfied entirely from this 
                            //  window.  We will ask only for what we need,  to try and avoid
                            //  unnecessarily fragmenting large runs of space by always using 
                            //  (part of) the largest run we can find.  This call will return the
                            //  first run large enough.
                            //

                            Index = RtlFindClearBits( &Vcb->FreeClusterBitMap,  ClustersRemaining,  0);

                            if (-1 != Index)  {
                            
                                ClustersFound = ClustersRemaining;
                            }
                        }

                        if (0 == ClustersFound)  {
                            
                            //
                            //  Still nothing,  so just take the largest free run we can find.
                            //
                            
                            ClustersFound = RtlFindLongestRunClear( &Vcb->FreeClusterBitMap, &Index );
                            
                        }
#if DBG
                        PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif // DBG
                        if (ClustersFound >= ClustersRemaining) {

                            ClustersFound = ClustersRemaining;
                        }
                        else {

                            //
                            //  If we just ran up to the end of a window,  set up a hint that
                            //  we'd like the next consecutive window after this one. (FAT32 only)
                            //

                            if ( ((Index + ClustersFound) == Vcb->FreeClusterBitMap.SizeOfBitMap) &&
                                 FatIsFat32( Vcb)
                               )  {

                                SelectNextContigWindow = TRUE;
                                WindowRelativeHint = 2;
                            }
                        }
                    }
                }

                if (ClustersFound == 0) {

                    ULONG FaveWindow = 0;
                    BOOLEAN SelectedWindow;

                    //
                    //  If we found no free clusters on a single-window FAT,
                    //  there was a bad problem with the free cluster count.
                    //

                    if (1 == Vcb->NumberOfWindows) {

                        FatBugCheck( 0, 5, 0 );
                    }

                    //
                    //  Switch to a new bucket.  Possibly the next one if we're
                    //  currently on a roll (allocating contiguously)
                    //

                    SelectedWindow = FALSE;

                    if ( SelectNextContigWindow)  {

                        ULONG NextWindow;

                        NextWindow = (((ULONG)((PUCHAR)Vcb->CurrentWindow - (PUCHAR)Vcb->Windows)) / sizeof( FAT_WINDOW)) + 1;

                        if ((NextWindow < Vcb->NumberOfWindows) &&
                            ( Vcb->Windows[ NextWindow].ClustersFree > 0)
                           )  {

                            FaveWindow = NextWindow;
                            SelectedWindow = TRUE;                            
                        }
                        else  {

                            if (ExactMatchRequired)  {

                                //
                                //  Some dope tried to allocate a run past the end of the volume...
                                //

                                try_leave( Result = FALSE);
                            }

                            //
                            //  Give up on the contiguous allocation attempts
                            //

                            WindowRelativeHint = 0;
                        }

                        SelectNextContigWindow = FALSE;
                    }

                    if (!SelectedWindow)  {

                        //
                        //  Select a new window to begin allocating from
                        //
                        
                        FaveWindow = FatSelectBestWindow( Vcb);
                    }

                    //
                    //  By now we'd better have found a window with some free clusters
                    //

                    if (0 == Vcb->Windows[ FaveWindow].ClustersFree) {

                        FatBugCheck( 0, 5, 1 );
                    }

                    Wait = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
                    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);

                    FatExamineFatEntries( IrpContext, Vcb,
                                          0,
                                          0,
                                          FALSE,
                                          &Vcb->Windows[FaveWindow],
                                          NULL);

                    if (!Wait) {

                        ClearFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
                    }

                    //
                    //  Now we'll just go around the loop again, having switched windows,
                    //  and allocate....
                    //
#if DBG
                    PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif //DBG
                }       // if (clustersfound == 0)
                else  {

                    //
                    //  Take the clusters we found, convert our index to a cluster number
                    //  and unlock the bit map.
                    //

                    Window = Vcb->CurrentWindow;

                    FatReserveClusters( IrpContext, Vcb, (Index + 2), ClustersFound );

                    Cluster = Index + Window->FirstCluster;
                    
                    Window->ClustersFree -= ClustersFound;
                    ASSERT( PreviousClear - ClustersFound == Window->ClustersFree );

                    FatUnlockFreeClusterBitMap( Vcb );
                    LockedBitMap = FALSE;

                    //
                    //  Add the newly alloced run to the Mcb.
                    //

                    BytesFound = ClustersFound << LogOfBytesPerCluster;

                    FatAddMcbEntry( Vcb, Mcb,
                                    CurrentVbo,
                                    FatGetLboFromIndex( Vcb, Cluster ),
                                    BytesFound );

                    //
                    //  Connect the last allocated run with this one, and allocate
                    //  this run on the Fat.
                    //

                    if (PriorLastCluster != 0) {

                        FatSetFatEntry( IrpContext,
                                        Vcb,
                                        PriorLastCluster,
                                        (FAT_ENTRY)Cluster );
                    }

                    //
                    //  Update the fat
                    //

                    FatAllocateClusters( IrpContext, Vcb, Cluster, ClustersFound );

                    //
                    //  Prepare for the next iteration.
                    //

                    CurrentVbo += BytesFound;
                    ClustersRemaining -= ClustersFound;
                    PriorLastCluster = Cluster + ClustersFound - 1;
                }
            }  // while (clustersremaining)

        } finally {

            DebugUnwind( FatAllocateDiskSpace );

            ExReleaseResourceLite(&Vcb->ChangeBitMapResource);

            //
            //  Is there any unwinding to do?
            //

            if ( AbnormalTermination() || (FALSE == Result)) {

                //
                //  Flag to the caller that they're getting nothing
                //

                *ByteCount = 0;

                //
                //  There are three places we could have taken this exception:
                //  when switching the window (FatExamineFatEntries), adding
                //  a found run to the Mcb (FatAddMcbEntry), or when writing
                //  the changes to the FAT (FatSetFatEntry).  In the first case
                //  we don't have anything to unwind before deallocation, and
                //  can detect this by seeing if we have the ClusterBitmap
                //  mutex out.

                if (!LockedBitMap) {

                    FatLockFreeClusterBitMap( Vcb );

                    //
                    //  In these cases, we have the possiblity that the FAT
                    //  window is still in place and we need to clear the bits.
                    //  If the Mcb entry isn't there (we raised trying to add
                    //  it), the effect of trying to remove it is a noop.
                    //

                    if (Window == Vcb->CurrentWindow) {

                        //
                        //  Cluster reservation works on cluster 2 based window-relative
                        //  numbers, so we must convert.  The subtraction will lose the
                        //  cluster 2 base, so bias the result.
                        //

                        FatUnreserveClusters( IrpContext, Vcb,
                                              (Cluster - Window->FirstCluster) + 2,
                                              ClustersFound );
                    }

                    //
                    //  Note that FatDeallocateDiskSpace will take care of adjusting
                    //  to account for the entries in the Mcb.  All we have to account
                    //  for is the last run that didn't make it.
                    //

                    Window->ClustersFree += ClustersFound;
                    Vcb->AllocationSupport.NumberOfFreeClusters += ClustersFound;

                    FatUnlockFreeClusterBitMap( Vcb );

                    FatRemoveMcbEntry( Vcb, Mcb, CurrentVbo, BytesFound );

                } else {

                    //
                    //  Just drop the mutex now - we didn't manage to do anything
                    //  that needs to be backed out.
                    //

                    FatUnlockFreeClusterBitMap( Vcb );
                }

                try {

                    //
                    //  Now we have tidied up, we are ready to just send the Mcb
                    //  off to deallocate disk space
                    //

                    FatDeallocateDiskSpace( IrpContext, Vcb, Mcb );

                } finally {

                    //
                    //  Now finally (really), remove all the entries from the mcb
                    //

                    FatRemoveMcbEntry( Vcb, Mcb, 0, 0xFFFFFFFF );
                }
            }

            DebugTrace(-1, Dbg, "FatAllocateDiskSpace -> (VOID)\n", 0);

        } // finally
    }

    return;
}


VOID
FatDeallocateDiskSpace (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb
    )

/*++

Routine Description:

    This procedure deallocates the disk space denoted by an input
    mcb.  Note that the input MCB does not need to necessarily describe
    a chain that ends with a FAT_CLUSTER_LAST entry.

    Pictorially what is done is the following

        Fat |--a--|--b--|--c--|
        Mcb |--a--|--b--|--c--|

    becomes

        Fat |--0--|--0--|--0--|
        Mcb |--a--|--b--|--c--|

Arguments:

    Vcb - Supplies the VCB being modified

    Mcb - Supplies the MCB describing the disk space to deallocate.  Note
          that Mcb is unchanged by this procedure.


Return Value:

    None.

--*/

{
    LBO Lbo;
    VBO Vbo;

    ULONG RunsInMcb;
    ULONG ByteCount;
    ULONG ClusterCount;
    ULONG ClusterIndex;
    ULONG McbIndex;

    UCHAR LogOfBytesPerCluster;

    PFAT_WINDOW Window;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatDeallocateDiskSpace\n", 0);
    DebugTrace( 0, Dbg, "  Vcb = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Mcb = %8lx\n", Mcb);

    LogOfBytesPerCluster = Vcb->AllocationSupport.LogOfBytesPerCluster;

    RunsInMcb = FsRtlNumberOfRunsInLargeMcb( Mcb );

    if ( RunsInMcb == 0 ) {

        DebugTrace(-1, Dbg, "FatDeallocateDiskSpace -> (VOID)\n", 0);
        return;
    }

    try {

        //
        //  Run though the Mcb, freeing all the runs in the fat.
        //
        //  We do this in two steps (first update the fat, then the bitmap
        //  (which can't fail)) to prevent other people from taking clusters
        //  that we need to re-allocate in the event of unwind.
        //

        ExAcquireResourceSharedLite(&Vcb->ChangeBitMapResource, TRUE);

        RunsInMcb = FsRtlNumberOfRunsInLargeMcb( Mcb );

        for ( McbIndex = 0; McbIndex < RunsInMcb; McbIndex++ ) {

            FatGetNextMcbEntry( Vcb, Mcb, McbIndex, &Vbo, &Lbo, &ByteCount );

            //
            //  Assert that Fat files have no holes.
            //

            ASSERT( Lbo != 0 );

            //
            //  Write FAT_CLUSTER_AVAILABLE to each cluster in the run.
            //

            ClusterCount = ByteCount >> LogOfBytesPerCluster;
            ClusterIndex = FatGetIndexFromLbo( Vcb, Lbo );

            FatFreeClusters( IrpContext, Vcb, ClusterIndex, ClusterCount );
        }

        //
        //  From now on, nothing can go wrong .... (as in raise)
        //

        FatLockFreeClusterBitMap( Vcb );

        for ( McbIndex = 0; McbIndex < RunsInMcb; McbIndex++ ) {

            ULONG ClusterEnd;
            ULONG MyStart, MyLength, count;
#if DBG
            ULONG PreviousClear, i;
#endif

            FatGetNextMcbEntry( Vcb, Mcb, McbIndex, &Vbo, &Lbo, &ByteCount );

            //
            //  Mark the bits clear in the FreeClusterBitMap.
            //

            ClusterCount = ByteCount >> LogOfBytesPerCluster;
            ClusterIndex = FatGetIndexFromLbo( Vcb, Lbo );

            Window = Vcb->CurrentWindow;

            //
            //  If we've divided the bitmap, elide bitmap manipulation for
            //  runs that are outside the current bucket.
            //

            ClusterEnd = ClusterIndex + ClusterCount - 1;

            if (!(ClusterIndex > Window->LastCluster ||
                  ClusterEnd  < Window->FirstCluster)) {

                //
                //  The run being freed overlaps the current bucket, so we'll
                //  have to clear some bits.
                //

                if (ClusterIndex < Window->FirstCluster &&
                    ClusterEnd > Window->LastCluster) {

                    MyStart = Window->FirstCluster;
                    MyLength = Window->LastCluster - Window->FirstCluster + 1;

                } else if (ClusterIndex < Window->FirstCluster) {

                    MyStart = Window->FirstCluster;
                    MyLength = ClusterEnd - Window->FirstCluster + 1;

                } else {

                    //
                    //  The range being freed starts in the bucket, and may possibly
                    //  extend beyond the bucket.
                    //

                    MyStart = ClusterIndex;

                    if (ClusterEnd <= Window->LastCluster) {

                        MyLength = ClusterCount;

                    } else {

                        MyLength = Window->LastCluster - ClusterIndex + 1;
                    }
                }

                if (MyLength == 0) {

                    continue;
                }

#if DBG
                PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );


                //
                //  Verify that the Bits are all really set.
                //

                ASSERT( MyStart + MyLength - Window->FirstCluster <= Vcb->FreeClusterBitMap.SizeOfBitMap );

                for (i = 0; i < MyLength; i++) {

                    ASSERT( RtlCheckBit(&Vcb->FreeClusterBitMap,
                            MyStart - Window->FirstCluster + i) == 1 );
                }
#endif // DBG

                FatUnreserveClusters( IrpContext, Vcb,
                                      MyStart - Window->FirstCluster + 2,
                                      MyLength );
            }

            //
            //  Adjust the ClustersFree count for each bitmap window, even the ones
            //  that are not the current window.
            //

            if (FatIsFat32(Vcb)) {

                Window = &Vcb->Windows[FatWindowOfCluster( ClusterIndex )];

            } else {

                Window = &Vcb->Windows[0];
            }

            MyStart = ClusterIndex;

            for (MyLength = ClusterCount; MyLength > 0; MyLength -= count) {

                count = FatMin(Window->LastCluster - MyStart + 1, MyLength);
                Window->ClustersFree += count;

                //
                //  If this was not the last window this allocation spanned,
                //  advance to the next.
                //

                if (MyLength != count) {

                    Window++;
                    MyStart = Window->FirstCluster;
                }
            }

            //
            //  Deallocation is now complete.  Adjust the free cluster count.
            //

            Vcb->AllocationSupport.NumberOfFreeClusters += ClusterCount;
        }

#if DBG
        if (Vcb->CurrentWindow->ClustersFree !=
               RtlNumberOfClearBits(&Vcb->FreeClusterBitMap)) {

            DbgPrint("%x vs %x\n",  Vcb->CurrentWindow->ClustersFree,
                RtlNumberOfClearBits(&Vcb->FreeClusterBitMap));

            DbgPrint("%x for %x\n", ClusterIndex, ClusterCount);
        }
#endif

        FatUnlockFreeClusterBitMap( Vcb );


    } finally {

        DebugUnwind( FatDeallocateDiskSpace );

        //
        //  Is there any unwinding to do?
        //

        ExReleaseResourceLite(&Vcb->ChangeBitMapResource);

        if ( AbnormalTermination() ) {

            LBO Lbo;
            VBO Vbo;

            ULONG Index;
            ULONG Clusters;
            ULONG FatIndex;
            ULONG PriorLastIndex;

            //
            //  For each entry we already deallocated, reallocate it,
            //  chaining together as nessecary.  Note that we continue
            //  up to and including the last "for" iteration even though
            //  the SetFatRun could not have been successful.  This
            //  allows us a convienent way to re-link the final successful
            //  SetFatRun.
            //
            //  It is possible that the reason we got here will prevent us
            //  from succeeding in this operation.
            //

            PriorLastIndex = 0;

            for (Index = 0; Index <= McbIndex; Index++) {

                FatGetNextMcbEntry(Vcb, Mcb, Index, &Vbo, &Lbo, &ByteCount);

                FatIndex = FatGetIndexFromLbo( Vcb, Lbo );
                Clusters = ByteCount >> LogOfBytesPerCluster;

                //
                //  We must always restore the prior iteration's last
                //  entry, pointing it to the first cluster of this run.
                //

                if (PriorLastIndex != 0) {

                    FatSetFatEntry( IrpContext,
                                    Vcb,
                                    PriorLastIndex,
                                    (FAT_ENTRY)FatIndex );
                }

                //
                //  If this is not the last entry (the one that failed)
                //  then reallocate the disk space on the fat.
                //

                if ( Index < McbIndex ) {

                    FatAllocateClusters(IrpContext, Vcb, FatIndex, Clusters);

                    PriorLastIndex = FatIndex + Clusters - 1;
                }
            }
        }

        DebugTrace(-1, Dbg, "FatDeallocateDiskSpace -> (VOID)\n", 0);
    }

    return;
}


VOID
FatSplitAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PLARGE_MCB Mcb,
    IN VBO SplitAtVbo,
    OUT PLARGE_MCB RemainingMcb
    )

/*++

Routine Description:

    This procedure takes a single mcb and splits its allocation into
    two separate allocation units.  The separation must only be done
    on cluster boundaries, otherwise we bugcheck.

    On the disk this actually works by inserting a FAT_CLUSTER_LAST into
    the last index of the first part being split out.

    Pictorially what is done is the following (where ! denotes the end of
    the fat chain (i.e., FAT_CLUSTER_LAST)):


        Mcb          |--a--|--b--|--c--|--d--|--e--|--f--|

                                        ^
        SplitAtVbo ---------------------+

        RemainingMcb (empty)

    becomes

        Mcb          |--a--|--b--|--c--!


        RemainingMcb |--d--|--e--|--f--|

Arguments:

    Vcb - Supplies the VCB being modified

    Mcb - Supplies the MCB describing the allocation being split into
          two parts.  Upon return this Mcb now contains the first chain.

    SplitAtVbo - Supplies the VBO of the first byte for the second chain
                 that we creating.

    RemainingMcb - Receives the MCB describing the second chain of allocated
                   disk space.  The caller passes in an initialized Mcb that
                   is filled in by this procedure STARTING AT VBO 0.

Return Value:

    VOID - TRUE if the operation completed and FALSE if it had to
               block but could not.

--*/

{
    VBO SourceVbo;
    VBO TargetVbo;
    VBO DontCare;

    LBO Lbo;

    ULONG ByteCount;
    ULONG BytesPerCluster;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatSplitAllocation\n", 0);
    DebugTrace( 0, Dbg, "  Vcb          = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Mcb          = %8lx\n", Mcb);
    DebugTrace( 0, Dbg, "  SplitAtVbo   = %8lx\n", SplitAtVbo);
    DebugTrace( 0, Dbg, "  RemainingMcb = %8lx\n", RemainingMcb);

    BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    //
    //  Assert that the split point is cluster alligned
    //

    ASSERT( (SplitAtVbo & (BytesPerCluster - 1)) == 0 );

    //
    //  We should never be handed an empty source MCB and asked to split
    //  at a non zero point.
    //

    ASSERT( !((0 != SplitAtVbo) && (0 == FsRtlNumberOfRunsInLargeMcb( Mcb))));

    //
    //  Assert we were given an empty target Mcb.
    //

    //
    //  This assert is commented out to avoid hitting in the Ea error
    //  path.  In that case we will be using the same Mcb's to split the
    //  allocation that we used to merge them.  The target Mcb will contain
    //  the runs that the split will attempt to insert.
    //
    //
    //  ASSERT( FsRtlNumberOfRunsInMcb( RemainingMcb ) == 0 );
    //

    try {

        //
        //  Move the runs after SplitAtVbo from the souce to the target
        //

        SourceVbo = SplitAtVbo;
        TargetVbo = 0;

        while (FatLookupMcbEntry(Vcb, Mcb, SourceVbo, &Lbo, &ByteCount, NULL)) {

            FatAddMcbEntry( Vcb, RemainingMcb, TargetVbo, Lbo, ByteCount );

            FatRemoveMcbEntry( Vcb, Mcb, SourceVbo, ByteCount );

            TargetVbo += ByteCount;
            SourceVbo += ByteCount;

            //
            //  If SourceVbo overflows, we were actually snipping off the end
            //  of the maximal file ... and are now done.
            //

            if (SourceVbo == 0) {

                break;
            }
        }

        //
        //  Mark the last pre-split cluster as a FAT_LAST_CLUSTER
        //

        if ( SplitAtVbo != 0 ) {

            FatLookupLastMcbEntry( Vcb, Mcb, &DontCare, &Lbo, NULL );

            FatSetFatEntry( IrpContext,
                            Vcb,
                            FatGetIndexFromLbo( Vcb, Lbo ),
                            FAT_CLUSTER_LAST );
        }

    } finally {

        DebugUnwind( FatSplitAllocation );

        //
        //  If we got an exception, we must glue back together the Mcbs
        //

        if ( AbnormalTermination() ) {

            TargetVbo = SplitAtVbo;
            SourceVbo = 0;

            while (FatLookupMcbEntry(Vcb, RemainingMcb, SourceVbo, &Lbo, &ByteCount, NULL)) {

                FatAddMcbEntry( Vcb, Mcb, TargetVbo, Lbo, ByteCount );

                FatRemoveMcbEntry( Vcb, RemainingMcb, SourceVbo, ByteCount );

                TargetVbo += ByteCount;
                SourceVbo += ByteCount;
            }
        }

        DebugTrace(-1, Dbg, "FatSplitAllocation -> (VOID)\n", 0);
    }

    return;
}


VOID
FatMergeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PLARGE_MCB Mcb,
    IN PLARGE_MCB SecondMcb
    )

/*++

Routine Description:

    This routine takes two separate allocations described by two MCBs and
    joins them together into one allocation.

    Pictorially what is done is the following (where ! denotes the end of
    the fat chain (i.e., FAT_CLUSTER_LAST)):


        Mcb       |--a--|--b--|--c--!

        SecondMcb |--d--|--e--|--f--|

    becomes

        Mcb       |--a--|--b--|--c--|--d--|--e--|--f--|

        SecondMcb |--d--|--e--|--f--|


Arguments:

    Vcb - Supplies the VCB being modified

    Mcb - Supplies the MCB of the first allocation that is being modified.
          Upon return this Mcb will also describe the newly enlarged
          allocation

    SecondMcb - Supplies the ZERO VBO BASED MCB of the second allocation
                that is being appended to the first allocation.  This
                procedure leaves SecondMcb unchanged.

Return Value:

    VOID - TRUE if the operation completed and FALSE if it had to
        block but could not.

--*/

{
    VBO SpliceVbo;
    LBO SpliceLbo;

    VBO SourceVbo;
    VBO TargetVbo;

    LBO Lbo;

    ULONG ByteCount;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatMergeAllocation\n", 0);
    DebugTrace( 0, Dbg, "  Vcb       = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Mcb       = %8lx\n", Mcb);
    DebugTrace( 0, Dbg, "  SecondMcb = %8lx\n", SecondMcb);

    try {

        //
        //  Append the runs from SecondMcb to Mcb
        //

        (void)FatLookupLastMcbEntry( Vcb, Mcb, &SpliceVbo, &SpliceLbo, NULL );

        SourceVbo = 0;
        TargetVbo = SpliceVbo + 1;

        while (FatLookupMcbEntry(Vcb, SecondMcb, SourceVbo, &Lbo, &ByteCount, NULL)) {

            FatAddMcbEntry( Vcb, Mcb, TargetVbo, Lbo, ByteCount );

            SourceVbo += ByteCount;
            TargetVbo += ByteCount;
        }

        //
        //  Link the last pre-merge cluster to the first cluster of SecondMcb
        //

        FatLookupMcbEntry( Vcb, SecondMcb, 0, &Lbo, (PULONG)NULL, NULL );

        FatSetFatEntry( IrpContext,
                        Vcb,
                        FatGetIndexFromLbo( Vcb, SpliceLbo ),
                        (FAT_ENTRY)FatGetIndexFromLbo( Vcb, Lbo ) );

    } finally {

        DebugUnwind( FatMergeAllocation );

        //
        //  If we got an exception, we must remove the runs added to Mcb
        //

        if ( AbnormalTermination() ) {

            ULONG CutLength;

            if ((CutLength = TargetVbo - (SpliceVbo + 1)) != 0) {

                FatRemoveMcbEntry( Vcb, Mcb, SpliceVbo + 1, CutLength);
            }
        }

        DebugTrace(-1, Dbg, "FatMergeAllocation -> (VOID)\n", 0);
    }

    return;
}


//
//  Internal support routine
//

CLUSTER_TYPE
FatInterpretClusterType (
    IN PVCB Vcb,
    IN FAT_ENTRY Entry
    )

/*++

Routine Description:

    This procedure tells the caller how to interpret the input fat table
    entry.  It will indicate if the fat cluster is available, resereved,
    bad, the last one, or the another fat index.  This procedure can deal
    with both 12 and 16 bit fat.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16 bit info

    Entry - Supplies the fat entry to examine

Return Value:

    CLUSTER_TYPE - Is the type of the input Fat entry

--*/

{
    DebugTrace(+1, Dbg, "InterpretClusterType\n", 0);
    DebugTrace( 0, Dbg, "  Vcb   = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Entry = %8lx\n", Entry);

    PAGED_CODE();

    switch(Vcb->AllocationSupport.FatIndexBitSize ) {
    case 32:
        Entry &= FAT32_ENTRY_MASK;
        break;

    case 12:
        ASSERT( Entry <= 0xfff );
        if (Entry >= 0x0ff0) {
            Entry |= 0x0FFFF000;
        }
        break;

    default:
    case 16:
        ASSERT( Entry <= 0xffff );
        if (Entry >= 0x0fff0) {
            Entry |= 0x0FFF0000;
        }
        break;
    }

    if (Entry == FAT_CLUSTER_AVAILABLE) {

        DebugTrace(-1, Dbg, "FatInterpretClusterType -> FatClusterAvailable\n", 0);

        return FatClusterAvailable;

    } else if (Entry < FAT_CLUSTER_RESERVED) {

        DebugTrace(-1, Dbg, "FatInterpretClusterType -> FatClusterNext\n", 0);

        return FatClusterNext;

    } else if (Entry < FAT_CLUSTER_BAD) {

        DebugTrace(-1, Dbg, "FatInterpretClusterType -> FatClusterReserved\n", 0);

        return FatClusterReserved;

    } else if (Entry == FAT_CLUSTER_BAD) {

        DebugTrace(-1, Dbg, "FatInterpretClusterType -> FatClusterBad\n", 0);

        return FatClusterBad;

    } else {

        DebugTrace(-1, Dbg, "FatInterpretClusterType -> FatClusterLast\n", 0);

        return FatClusterLast;
    }
}


//
//  Internal support routine
//

VOID
FatLookupFatEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FatIndex,
    IN OUT PULONG FatEntry,
    IN OUT PFAT_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine takes an index into the fat and gives back the value
    in the Fat at this index.  At any given time, for a 16 bit fat, this
    routine allows only one page per volume of the fat to be pinned in
    memory.  For a 12 bit bit fat, the entire fat (max 6k) is pinned.  This
    extra layer of caching makes the vast majority of requests very
    fast.  The context for this caching stored in a structure in the Vcb.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16 bit info,
          fat access context, etc.

    FatIndex - Supplies the fat index to examine.

    FatEntry - Receives the fat entry pointed to by FatIndex.  Note that
               it must point to non-paged pool.

    Context - This structure keeps track of a page of pinned fat between calls.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatLookupFatEntry\n", 0);
    DebugTrace( 0, Dbg, "  Vcb      = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  FatIndex = %4x\n", FatIndex);
    DebugTrace( 0, Dbg, "  FatEntry = %8lx\n", FatEntry);

    //
    //  Make sure they gave us a valid fat index.
    //

    FatVerifyIndexIsValid(IrpContext, Vcb, FatIndex);

    //
    //  Case on 12 or 16 bit fats.
    //
    //  In the 12 bit case (mostly floppies) we always have the whole fat
    //  (max 6k bytes) pinned during allocation operations.  This is possibly
    //  a wee bit slower, but saves headaches over fat entries with 8 bits
    //  on one page, and 4 bits on the next.
    //
    //  The 16 bit case always keeps the last used page pinned until all
    //  operations are done and it is unpinned.
    //

    //
    //  DEAL WITH 12 BIT CASE
    //

    if (Vcb->AllocationSupport.FatIndexBitSize == 12) {

        //
        //  Check to see if the fat is already pinned, otherwise pin it.
        //

        if (Context->Bcb == NULL) {

            FatReadVolumeFile( IrpContext,
                               Vcb,
                               FatReservedBytes( &Vcb->Bpb ),
                               FatBytesPerFat( &Vcb->Bpb ),
                               &Context->Bcb,
                               &Context->PinnedPage );
        }

        //
        //  Load the return value.
        //


        FatLookup12BitEntry( Context->PinnedPage, FatIndex, FatEntry );

    } else if (Vcb->AllocationSupport.FatIndexBitSize == 32) {

        //
        //  DEAL WITH 32 BIT CASE
        //

        ULONG PageEntryOffset;
        ULONG OffsetIntoVolumeFile;

        //
        //  Initialize two local variables that help us.
        //
        OffsetIntoVolumeFile = FatReservedBytes(&Vcb->Bpb) + FatIndex * sizeof(FAT_ENTRY);
        PageEntryOffset = (OffsetIntoVolumeFile % PAGE_SIZE) / sizeof(FAT_ENTRY);

        //
        //  Check to see if we need to read in a new page of fat
        //

        if ((Context->Bcb == NULL) ||
            (OffsetIntoVolumeFile / PAGE_SIZE != Context->VboOfPinnedPage / PAGE_SIZE)) {

            //
            //  The entry wasn't in the pinned page, so must we unpin the current
            //  page (if any) and read in a new page.
            //

            FatUnpinBcb( IrpContext, Context->Bcb );

            FatReadVolumeFile( IrpContext,
                               Vcb,
                               OffsetIntoVolumeFile & ~(PAGE_SIZE - 1),
                               PAGE_SIZE,
                               &Context->Bcb,
                               &Context->PinnedPage );

            Context->VboOfPinnedPage = OffsetIntoVolumeFile & ~(PAGE_SIZE - 1);
        }

        //
        //  Grab the fat entry from the pinned page, and return
        //

        *FatEntry = ((PULONG)(Context->PinnedPage))[PageEntryOffset] & FAT32_ENTRY_MASK;

    } else {

        //
        //  DEAL WITH 16 BIT CASE
        //

        ULONG PageEntryOffset;
        ULONG OffsetIntoVolumeFile;

        //
        //  Initialize two local variables that help us.
        //

        OffsetIntoVolumeFile = FatReservedBytes(&Vcb->Bpb) + FatIndex * sizeof(USHORT);
        PageEntryOffset = (OffsetIntoVolumeFile % PAGE_SIZE) / sizeof(USHORT);

        //
        //  Check to see if we need to read in a new page of fat
        //

        if ((Context->Bcb == NULL) ||
            (OffsetIntoVolumeFile / PAGE_SIZE != Context->VboOfPinnedPage / PAGE_SIZE)) {

            //
            //  The entry wasn't in the pinned page, so must we unpin the current
            //  page (if any) and read in a new page.
            //

            FatUnpinBcb( IrpContext, Context->Bcb );

            FatReadVolumeFile( IrpContext,
                               Vcb,
                               OffsetIntoVolumeFile & ~(PAGE_SIZE - 1),
                               PAGE_SIZE,
                               &Context->Bcb,
                               &Context->PinnedPage );

            Context->VboOfPinnedPage = OffsetIntoVolumeFile & ~(PAGE_SIZE - 1);
        }

        //
        //  Grab the fat entry from the pinned page, and return
        //

        *FatEntry = ((PUSHORT)(Context->PinnedPage))[PageEntryOffset];
    }

    DebugTrace(-1, Dbg, "FatLookupFatEntry -> (VOID)\n", 0);
    return;
}


VOID
FatSetFatEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FatIndex,
    IN FAT_ENTRY FatEntry
    )

/*++

Routine Description:

    This routine takes an index into the fat and puts a value in the Fat
    at this index.  The routine special cases 12, 16 and 32 bit fats.  In
    all cases we go to the cache manager for a piece of the fat.

    We have a special form of this call for setting the DOS-style dirty bit.
    Unlike the dirty bit in the boot sector, we do not go to special effort
    to make sure that this hits the disk synchronously - if the system goes
    down in the window between the dirty bit being set in the boot sector
    and the FAT index zero dirty bit being lazy written, then life is tough.

    The only possible scenario is that Win9x may see what it thinks is a clean
    volume that really isn't (hopefully Memphis will pay attention to our dirty
    bit as well). The dirty bit will get out quickly, and if heavy activity is
    occurring, then the dirty bit should actually be there virtually all of the
    time since the act of cleaning the volume is the "rare" occurance.

    There are synchronization concerns that would crop up if we tried to make
    this synchronous. This thread may already own the Bcb shared for the first
    sector of the FAT (so we can't get it exclusive for a writethrough). This
    would require some more serious replumbing to work around than I want to
    consider at this time.

    We can and do, however, synchronously set the bit clean.

    At this point the reader should understand why the NT dirty bit is where it is.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16/32 bit info, etc.

    FatIndex - Supplies the destination fat index.

    FatEntry - Supplies the source fat entry.

--*/

{
    LBO Lbo;
    PBCB Bcb = NULL;
    ULONG SectorSize;
    ULONG OffsetIntoVolumeFile;
    ULONG WasWait = TRUE;
    BOOLEAN RegularOperation = TRUE;
    BOOLEAN CleaningOperation = FALSE;
    BOOLEAN ReleaseMutex = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatSetFatEntry\n", 0);
    DebugTrace( 0, Dbg, "  Vcb      = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  FatIndex = %4x\n", FatIndex);
    DebugTrace( 0, Dbg, "  FatEntry = %4x\n", FatEntry);

    //
    //  Make sure they gave us a valid fat index if this isn't the special
    //  clean-bit modifying call.
    //

    if (FatIndex == FAT_DIRTY_BIT_INDEX) {

        //
        //  We are setting the clean bit state.  Of course, we could
        //  have corruption that would cause us to try to fiddle the
        //  reserved index - we guard against this by having the
        //  special entry values use the reserved high 4 bits that
        //  we know that we'll never try to set.
        //

        //
        //  We don't want to repin the FAT pages involved here.  Just
        //  let the lazy writer hit them when it can.
        //

        RegularOperation = FALSE;

        switch (FatEntry) {
            case FAT_CLEAN_VOLUME:
                FatEntry = FAT_CLEAN_ENTRY;
                CleaningOperation = TRUE;
                break;

            case FAT_DIRTY_VOLUME:
                switch (Vcb->AllocationSupport.FatIndexBitSize) {
                    case 12:
                        FatEntry = FAT12_DIRTY_ENTRY;
                        break;

                    case 32:
                        FatEntry = FAT32_DIRTY_ENTRY;
                        break;

                    default:
                        FatEntry = FAT16_DIRTY_ENTRY;
                        break;
                }
                break;

            default:
                FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                break;
        }

        //
        //  Disable dirtying semantics for the duration of this operation.  Force this
        //  operation to wait for the duration.
        //

        WasWait = FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT | IRP_CONTEXT_FLAG_DISABLE_DIRTY );

    } else {

        ASSERT( !(FatEntry & ~FAT32_ENTRY_MASK) );
        FatVerifyIndexIsValid(IrpContext, Vcb, FatIndex);
    }

    //
    //  Set Sector Size
    //

    SectorSize = 1 << Vcb->AllocationSupport.LogOfBytesPerSector;

    //
    //  Case on 12 or 16 bit fats.
    //
    //  In the 12 bit case (mostly floppies) we always have the whole fat
    //  (max 6k bytes) pinned during allocation operations.  This is possibly
    //  a wee bit slower, but saves headaches over fat entries with 8 bits
    //  on one page, and 4 bits on the next.
    //
    //  In the 16 bit case we only read the page that we need to set the fat
    //  entry.
    //

    //
    //  DEAL WITH 12 BIT CASE
    //

    try {

        if (Vcb->AllocationSupport.FatIndexBitSize == 12) {

            PVOID PinnedFat;

            //
            //  Make sure we have a valid entry
            //

            FatEntry &= 0xfff;

            //
            //  We read in the entire fat.  Note that using prepare write marks
            //  the bcb pre-dirty, so we don't have to do it explicitly.
            //

            OffsetIntoVolumeFile = FatReservedBytes( &Vcb->Bpb ) + FatIndex * 3 / 2;

            FatPrepareWriteVolumeFile( IrpContext,
                                       Vcb,
                                       FatReservedBytes( &Vcb->Bpb ),
                                       FatBytesPerFat( &Vcb->Bpb ),
                                       &Bcb,
                                       &PinnedFat,
                                       RegularOperation,
                                       FALSE );

            //
            //  Mark the sector(s) dirty in the DirtyFatMcb.  This call is
            //  complicated somewhat for the 12 bit case since a single
            //  entry write can span two sectors (and pages).
            //
            //  Get the Lbo for the sector where the entry starts, and add it to
            //  the dirty fat Mcb.
            //

            Lbo = OffsetIntoVolumeFile & ~(SectorSize - 1);

            FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize);

            //
            //  If the entry started on the last byte of the sector, it continues
            //  to the next sector, so mark the next sector dirty as well.
            //
            //  Note that this entry will simply coalese with the last entry,
            //  so this operation cannot fail.  Also if we get this far, we have
            //  made it, so no unwinding will be needed.
            //

            if ( (OffsetIntoVolumeFile & (SectorSize - 1)) == (SectorSize - 1) ) {

                Lbo += SectorSize;

                FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize );
            }

            //
            //  Store the entry into the fat; we need a little synchonization
            //  here and can't use a spinlock since the bytes might not be
            //  resident.
            //

            FatLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;

            FatSet12BitEntry( PinnedFat, FatIndex, FatEntry );

            FatUnlockFreeClusterBitMap( Vcb );
            ReleaseMutex = FALSE;

        } else if (Vcb->AllocationSupport.FatIndexBitSize == 32) {

            //
            //  DEAL WITH 32 BIT CASE
            //

            PULONG PinnedFatEntry32;

            //
            //  Read in a new page of fat
            //

            OffsetIntoVolumeFile = FatReservedBytes( &Vcb->Bpb ) +
                                   FatIndex * sizeof( FAT_ENTRY );

            FatPrepareWriteVolumeFile( IrpContext,
                                       Vcb,
                                       OffsetIntoVolumeFile,
                                       sizeof(FAT_ENTRY),
                                       &Bcb,
                                       (PVOID *)&PinnedFatEntry32,
                                       RegularOperation,
                                       FALSE );
            //
            //  Mark the sector dirty in the DirtyFatMcb
            //

            Lbo = OffsetIntoVolumeFile & ~(SectorSize - 1);

            FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize);

            //
            //  Store the FatEntry to the pinned page.
            //
            //  Preserve the reserved bits in FAT32 entries in the file heap.
            //

#ifdef ALPHA
            FatLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;
#endif // ALPHA

            if (FatIndex != FAT_DIRTY_BIT_INDEX) {

                *PinnedFatEntry32 = ((*PinnedFatEntry32 & ~FAT32_ENTRY_MASK) | FatEntry);

            } else {

                *PinnedFatEntry32 = FatEntry;
            }

#ifdef ALPHA
            FatUnlockFreeClusterBitMap( Vcb );
            ReleaseMutex = FALSE;
#endif // ALPHA

        } else {

            //
            //  DEAL WITH 16 BIT CASE
            //

            PUSHORT PinnedFatEntry;

            //
            //  Read in a new page of fat
            //

            OffsetIntoVolumeFile = FatReservedBytes( &Vcb->Bpb ) +
                                   FatIndex * sizeof(USHORT);

            FatPrepareWriteVolumeFile( IrpContext,
                                       Vcb,
                                       OffsetIntoVolumeFile,
                                       sizeof(USHORT),
                                       &Bcb,
                                       (PVOID *)&PinnedFatEntry,
                                       RegularOperation,
                                       FALSE );
            //
            //  Mark the sector dirty in the DirtyFatMcb
            //

            Lbo = OffsetIntoVolumeFile & ~(SectorSize - 1);

            FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize);

            //
            //  Store the FatEntry to the pinned page.
            //
            //  We need extra synchronization here for broken architectures
            //  like the ALPHA that don't support atomic 16 bit writes.
            //

#ifdef ALPHA
            FatLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;
#endif // ALPHA

            *PinnedFatEntry = (USHORT)FatEntry;

#ifdef ALPHA
            FatUnlockFreeClusterBitMap( Vcb );
            ReleaseMutex = FALSE;
#endif // ALPHA
        }

    } finally {

        DebugUnwind( FatSetFatEntry );

        //
        //  Re-enable volume dirtying in case this was a dirty bit operation.
        //

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_DIRTY );

        //
        //  Make this operation asynchronous again if needed.
        //

        if (!WasWait) {

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
        }

        //
        //  If we still somehow have the Mutex, release it.
        //

        if (ReleaseMutex) {

            ASSERT( AbnormalTermination() );

            FatUnlockFreeClusterBitMap( Vcb );
        }

        //
        //  Unpin the Bcb.  For cleaning operations, we make this write-through.
        //

        if (CleaningOperation && Bcb) {

            IO_STATUS_BLOCK IgnoreStatus;

            CcRepinBcb( Bcb );
            CcUnpinData( Bcb );
            DbgDoit( IrpContext->PinCount -= 1 );
            CcUnpinRepinnedBcb( Bcb, TRUE, &IgnoreStatus );

        } else {

            FatUnpinBcb(IrpContext, Bcb);
        }

        DebugTrace(-1, Dbg, "FatSetFatEntry -> (VOID)\n", 0);
    }

    return;
}


//
//  Internal support routine
//

VOID
FatSetFatRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartingFatIndex,
    IN ULONG ClusterCount,
    IN BOOLEAN ChainTogether
    )

/*++

Routine Description:

    This routine sets a continuous run of clusters in the fat.  If ChainTogether
    is TRUE, then the clusters are linked together as in normal Fat fasion,
    with the last cluster receiving FAT_CLUSTER_LAST.  If ChainTogether is
    FALSE, all the entries are set to FAT_CLUSTER_AVAILABLE, effectively
    freeing all the clusters in the run.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16 bit info, etc.

    StartingFatIndex - Supplies the destination fat index.

    ClusterCount - Supplies the number of contiguous clusters to work on.

    ChainTogether - Tells us whether to fill the entries with links, or
                    FAT_CLUSTER_AVAILABLE


Return Value:

    VOID

--*/

{
#define MAXCOUNTCLUS 0x10000
#define COUNTSAVEDBCBS ((MAXCOUNTCLUS * sizeof(FAT_ENTRY) / PAGE_SIZE) + 2)
    PBCB SavedBcbs[COUNTSAVEDBCBS][2];

    ULONG SectorSize;
    ULONG Cluster;

    LBO StartSectorLbo;
    LBO FinalSectorLbo;
    LBO Lbo;

    PVOID PinnedFat;

    ULONG StartingPage;

    BOOLEAN ReleaseMutex = FALSE;

    ULONG SavedStartingFatIndex = StartingFatIndex;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatSetFatRun\n", 0);
    DebugTrace( 0, Dbg, "  Vcb              = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  StartingFatIndex = %8x\n", StartingFatIndex);
    DebugTrace( 0, Dbg, "  ClusterCount     = %8lx\n", ClusterCount);
    DebugTrace( 0, Dbg, "  ChainTogether    = %s\n", ChainTogether ? "TRUE":"FALSE");

    //
    //  Make sure they gave us a valid fat run.
    //

    FatVerifyIndexIsValid(IrpContext, Vcb, StartingFatIndex);
    FatVerifyIndexIsValid(IrpContext, Vcb, StartingFatIndex + ClusterCount - 1);

    //
    //  Check special case
    //

    if (ClusterCount == 0) {

        DebugTrace(-1, Dbg, "FatSetFatRun -> (VOID)\n", 0);
        return;
    }

    //
    //  Set Sector Size
    //

    SectorSize = 1 << Vcb->AllocationSupport.LogOfBytesPerSector;

    //
    //  Case on 12 or 16 bit fats.
    //
    //  In the 12 bit case (mostly floppies) we always have the whole fat
    //  (max 6k bytes) pinned during allocation operations.  This is possibly
    //  a wee bit slower, but saves headaches over fat entries with 8 bits
    //  on one page, and 4 bits on the next.
    //
    //  In the 16 bit case we only read one page at a time, as needed.
    //

    //
    //  DEAL WITH 12 BIT CASE
    //

    try {

        if (Vcb->AllocationSupport.FatIndexBitSize == 12) {

            StartingPage = 0;

            //
            //  We read in the entire fat.  Note that using prepare write marks
            //  the bcb pre-dirty, so we don't have to do it explicitly.
            //

            RtlZeroMemory( &SavedBcbs[0], 2 * sizeof(PBCB) * 2);

            FatPrepareWriteVolumeFile( IrpContext,
                                       Vcb,
                                       FatReservedBytes( &Vcb->Bpb ),
                                       FatBytesPerFat( &Vcb->Bpb ),
                                       &SavedBcbs[0][0],
                                       &PinnedFat,
                                       TRUE,
                                       FALSE );

            //
            //  Mark the affected sectors dirty.  Note that FinalSectorLbo is
            //  the Lbo of the END of the entry (Thus * 3 + 2).  This makes sure
            //  we catch the case of a dirty fat entry straddling a sector boundry.
            //
            //  Note that if the first AddMcbEntry succeeds, all following ones
            //  will simply coalese, and thus also succeed.
            //

            StartSectorLbo = (FatReservedBytes( &Vcb->Bpb ) + StartingFatIndex * 3 / 2)
                             & ~(SectorSize - 1);

            FinalSectorLbo = (FatReservedBytes( &Vcb->Bpb ) + ((StartingFatIndex +
                             ClusterCount) * 3 + 2) / 2) & ~(SectorSize - 1);

            for (Lbo = StartSectorLbo; Lbo <= FinalSectorLbo; Lbo += SectorSize) {

                FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize );
            }

            //
            //  Store the entries into the fat; we need a little
            //  synchonization here and can't use a spinlock since the bytes
            //  might not be resident.
            //

            FatLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;

            for (Cluster = StartingFatIndex;
                 Cluster < StartingFatIndex + ClusterCount - 1;
                 Cluster++) {

                FatSet12BitEntry( PinnedFat,
                                  Cluster,
                                  ChainTogether ? Cluster + 1 : FAT_CLUSTER_AVAILABLE );
            }

            //
            //  Save the last entry
            //

            FatSet12BitEntry( PinnedFat,
                              Cluster,
                              ChainTogether ?
                              FAT_CLUSTER_LAST & 0xfff : FAT_CLUSTER_AVAILABLE );

            FatUnlockFreeClusterBitMap( Vcb );
            ReleaseMutex = FALSE;

        } else if (Vcb->AllocationSupport.FatIndexBitSize == 32) {

            //
            //  DEAL WITH 32 BIT CASE
            //

            for (;;) {

                VBO StartOffsetInVolume;
                VBO FinalOffsetInVolume;

                ULONG Page;
                ULONG FinalCluster;
                PULONG FatEntry;
                ULONG ClusterCountThisRun;

                StartOffsetInVolume = FatReservedBytes(&Vcb->Bpb) +
                                            StartingFatIndex * sizeof(FAT_ENTRY);

                if (ClusterCount > MAXCOUNTCLUS) {
                    ClusterCountThisRun = MAXCOUNTCLUS;
                } else {
                    ClusterCountThisRun = ClusterCount;
                }

                FinalOffsetInVolume = StartOffsetInVolume +
                                            (ClusterCountThisRun -  1) * sizeof(FAT_ENTRY);

                StartingPage = StartOffsetInVolume / PAGE_SIZE;

                {
                    ULONG NumberOfPages;
                    ULONG Offset;

                    NumberOfPages = (FinalOffsetInVolume / PAGE_SIZE) -
                                    (StartOffsetInVolume / PAGE_SIZE) + 1;

                    RtlZeroMemory( &SavedBcbs[0][0], (NumberOfPages + 1) * sizeof(PBCB) * 2 );

                    for ( Page = 0, Offset = StartOffsetInVolume & ~(PAGE_SIZE - 1);
                          Page < NumberOfPages;
                          Page++, Offset += PAGE_SIZE ) {

                        FatPrepareWriteVolumeFile( IrpContext,
                                                   Vcb,
                                                   Offset,
                                                   PAGE_SIZE,
                                                   &SavedBcbs[Page][0],
                                                   (PVOID *)&SavedBcbs[Page][1],
                                                   TRUE,
                                                   FALSE );

                        if (Page == 0) {

                            FatEntry = (PULONG)((PUCHAR)SavedBcbs[0][1] +
                                                (StartOffsetInVolume % PAGE_SIZE));
                        }
                    }
                }

                //
                //  Mark the run dirty
                //

                StartSectorLbo = StartOffsetInVolume & ~(SectorSize - 1);
                FinalSectorLbo = FinalOffsetInVolume & ~(SectorSize - 1);

                for (Lbo = StartSectorLbo; Lbo <= FinalSectorLbo; Lbo += SectorSize) {

                    FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO)Lbo, Lbo, SectorSize );
                }

                //
                //  Store the entries
                //
                //  We need extra synchronization here for broken architectures
                //  like the ALPHA that don't support atomic 16 bit writes.
                //

#ifdef ALPHA
                FatLockFreeClusterBitMap( Vcb );
                ReleaseMutex = TRUE;
#endif // ALPHA

                FinalCluster = StartingFatIndex + ClusterCountThisRun - 1;
                Page = 0;

                for (Cluster = StartingFatIndex;
                     Cluster <= FinalCluster;
                     Cluster++, FatEntry++) {

                    //
                    //  If we just crossed a page boundry (as opposed to starting
                    //  on one), update our idea of FatEntry.

                    if ( (((ULONG_PTR)FatEntry & (PAGE_SIZE-1)) == 0) &&
                         (Cluster != StartingFatIndex) ) {

                        Page += 1;
                        FatEntry = (PULONG)SavedBcbs[Page][1];
                    }

                    *FatEntry = ChainTogether ? (FAT_ENTRY)(Cluster + 1) :
                                                FAT_CLUSTER_AVAILABLE;
                }

                //
                //  Fix up the last entry if we were chaining together
                //

                if ((ClusterCount <= MAXCOUNTCLUS) &&
                    ChainTogether ) {

                    *(FatEntry-1) = FAT_CLUSTER_LAST;
                }

#ifdef ALPHA
                FatUnlockFreeClusterBitMap( Vcb );
                ReleaseMutex = FALSE;
#endif // ALPHA

                {
                    ULONG i = 0;
                    //
                    //  Unpin the Bcbs
                    //

                    while ( SavedBcbs[i][0] != NULL ) {

                        FatUnpinBcb( IrpContext, SavedBcbs[i][0] );
                        SavedBcbs[i][0] = NULL;

                        i += 1;
                    }
                }

                if (ClusterCount <= MAXCOUNTCLUS) {

                    break;

                } else {

                    StartingFatIndex += MAXCOUNTCLUS;
                    ClusterCount -= MAXCOUNTCLUS;
                }
            }

        } else {

            //
            //  DEAL WITH 16 BIT CASE
            //

            VBO StartOffsetInVolume;
            VBO FinalOffsetInVolume;

            ULONG Page;
            ULONG FinalCluster;
            PUSHORT FatEntry;

            StartOffsetInVolume = FatReservedBytes(&Vcb->Bpb) +
                                        StartingFatIndex * sizeof(USHORT);

            FinalOffsetInVolume = StartOffsetInVolume +
                                        (ClusterCount - 1) * sizeof(USHORT);

            StartingPage = StartOffsetInVolume / PAGE_SIZE;

            //
            //  Read in one page of fat at a time.  We cannot read in the
            //  all of the fat we need because of cache manager limitations.
            //
            //  SavedBcb was initialized to be able to hold the largest
            //  possible number of pages in a fat plus and extra one to
            //  accomadate the boot sector, plus one more to make sure there
            //  is enough room for the RtlZeroMemory below that needs the mark
            //  the first Bcb after all the ones we will use as an end marker.
            //

            {
                ULONG NumberOfPages;
                ULONG Offset;

                NumberOfPages = (FinalOffsetInVolume / PAGE_SIZE) -
                                (StartOffsetInVolume / PAGE_SIZE) + 1;

                RtlZeroMemory( &SavedBcbs[0][0], (NumberOfPages + 1) * sizeof(PBCB) * 2 );

                for ( Page = 0, Offset = StartOffsetInVolume & ~(PAGE_SIZE - 1);
                      Page < NumberOfPages;
                      Page++, Offset += PAGE_SIZE ) {

                    FatPrepareWriteVolumeFile( IrpContext,
                                               Vcb,
                                               Offset,
                                               PAGE_SIZE,
                                               &SavedBcbs[Page][0],
                                               (PVOID *)&SavedBcbs[Page][1],
                                               TRUE,
                                               FALSE );

                    if (Page == 0) {

                        FatEntry = (PUSHORT)((PUCHAR)SavedBcbs[0][1] +
                                            (StartOffsetInVolume % PAGE_SIZE));
                    }
                }
            }

            //
            //  Mark the run dirty
            //

            StartSectorLbo = StartOffsetInVolume & ~(SectorSize - 1);
            FinalSectorLbo = FinalOffsetInVolume & ~(SectorSize - 1);

            for (Lbo = StartSectorLbo; Lbo <= FinalSectorLbo; Lbo += SectorSize) {

                FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize );
            }

            //
            //  Store the entries
            //
            //  We need extra synchronization here for broken architectures
            //  like the ALPHA that don't support atomic 16 bit writes.
            //

#ifdef ALPHA
            FatLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;
#endif // ALPHA

            FinalCluster = StartingFatIndex + ClusterCount - 1;
            Page = 0;

            for (Cluster = StartingFatIndex;
                 Cluster <= FinalCluster;
                 Cluster++, FatEntry++) {

                //
                //  If we just crossed a page boundry (as opposed to starting
                //  on one), update our idea of FatEntry.

                if ( (((ULONG_PTR)FatEntry & (PAGE_SIZE-1)) == 0) &&
                     (Cluster != StartingFatIndex) ) {

                    Page += 1;
                    FatEntry = (PUSHORT)SavedBcbs[Page][1];
                }

                *FatEntry = (USHORT) (ChainTogether ? (FAT_ENTRY)(Cluster + 1) :
                                                      FAT_CLUSTER_AVAILABLE);
            }

            //
            //  Fix up the last entry if we were chaining together
            //

            if ( ChainTogether ) {

                *(FatEntry-1) = (USHORT)FAT_CLUSTER_LAST;
            }
#ifdef ALPHA
            FatUnlockFreeClusterBitMap( Vcb );
            ReleaseMutex = FALSE;
#endif // ALPHA
        }

    } finally {

        ULONG i = 0;

        DebugUnwind( FatSetFatRun );

        //
        //  If we still somehow have the Mutex, release it.
        //

        if (ReleaseMutex) {

            ASSERT( AbnormalTermination() );

            FatUnlockFreeClusterBitMap( Vcb );
        }

        //
        //  Unpin the Bcbs
        //

        while ( SavedBcbs[i][0] != NULL ) {

            FatUnpinBcb( IrpContext, SavedBcbs[i][0] );

            i += 1;
        }

        //
        //  At this point nothing in this finally clause should have raised.
        //  So, now comes the unsafe (sigh) stuff.
        //

        if ( AbnormalTermination() &&
            (Vcb->AllocationSupport.FatIndexBitSize == 32) ) {

            //
            //  Fat32 unwind
            //
            //  This case is more complex because the FAT12 and FAT16 cases
            //  pin all the needed FAT pages (128K max), after which it
            //  can't fail, before changing any FAT entries.  In the Fat32
            //  case, it may not be practical to pin all the needed FAT
            //  pages, because that could span many megabytes.  So Fat32
            //  attacks in chunks, and if a failure occurs once the first
            //  chunk has been updated, we have to back out the updates.
            //
            //  The unwind consists of walking back over each FAT entry we
            //  have changed, setting it back to the previous value.  Note
            //  that the previous value with either be FAT_CLUSTER_AVAILABLE
            //  (if ChainTogether==TRUE) or a simple link to the successor
            //  (if ChainTogether==FALSE).
            //
            //  We concede that any one of these calls could fail too; our
            //  objective is to make this case no more likely than the case
            //  for a file consisting of multiple disjoint runs.
            //

            while ( StartingFatIndex > SavedStartingFatIndex ) {

                StartingFatIndex--;

                FatSetFatEntry( IrpContext, Vcb, StartingFatIndex,
                    ChainTogether ?
                        StartingFatIndex + 1 : FAT_CLUSTER_AVAILABLE );
            }
        }

        DebugTrace(-1, Dbg, "FatSetFatRun -> (VOID)\n", 0);
    }

    return;
}


//
//  Internal support routine
//

UCHAR
FatLogOf (
    IN ULONG Value
    )

/*++

Routine Description:

    This routine just computes the base 2 log of an integer.  It is only used
    on objects that are know to be powers of two.

Arguments:

    Value - The value to take the base 2 log of.

Return Value:

    UCHAR - The base 2 log of Value.

--*/

{
    UCHAR Log = 0;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "LogOf\n", 0);
    DebugTrace( 0, Dbg, "  Value = %8lx\n", Value);

    //
    //  Knock bits off until we we get a one at position 0
    //

    while ( (Value & 0xfffffffe) != 0 ) {

        Log++;
        Value >>= 1;
    }

    //
    //  If there was more than one bit set, the file system messed up,
    //  Bug Check.
    //

    if (Value != 0x1) {

        DebugTrace( 0, Dbg, "Received non power of 2.\n", 0);

        FatBugCheck( Value, Log, 0 );
    }

    DebugTrace(-1, Dbg, "LogOf -> %8lx\n", Log);

    return Log;
}


VOID
FatExamineFatEntries(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartIndex OPTIONAL,
    IN ULONG EndIndex OPTIONAL,
    IN BOOLEAN SetupWindows,
    IN PFAT_WINDOW SwitchToWindow OPTIONAL,
    IN PULONG BitMapBuffer OPTIONAL
    )
/*++

Routine Description:

    This routine handles scanning a segment of the FAT into in-memory structures.

    There are three fundamental cases, with variations depending on the FAT type:

    1) During volume setup, FatSetupAllocations

        1a) for FAT12/16, read the FAT into our free clusterbitmap
        1b) for FAT32, perform the initial scan for window free cluster counts

    2) Switching FAT32 windows on the fly during system operation

    3) Reading arbitrary segments of the FAT for the purposes of the GetVolumeBitmap
        call (only for FAT32)

    There really is too much going on in here. At some point this should be
    substantially rewritten.

Arguments:

    Vcb - Supplies the volume involved

    StartIndex - Supplies the starting cluster, ignored if SwitchToWindow supplied

    EndIndex - Supplies the ending cluster, ignored if SwitchToWindow supplied

    SetupWindows - Indicates if we are doing the initial FAT32 scan

    SwitchToWindow - Supplies the FAT window we are examining and will switch to

    BitMapBuffer - Supplies a specific bitmap to fill in, if not supplied we fill
        in the volume free cluster bitmap if !SetupWindows

Return Value:

    None.  Lots of side effects.

--*/
{
    ULONG FatIndexBitSize;
    ULONG Page;
    ULONG Offset;
    ULONG FatIndex;
    FAT_ENTRY FatEntry = FAT_CLUSTER_AVAILABLE;
    FAT_ENTRY FirstFatEntry = FAT_CLUSTER_AVAILABLE;
    PUSHORT FatBuffer;
    PVOID pv;
    PBCB Bcb;
    ULONG EntriesPerWindow;
    ULONG BitIndex;

    ULONG ClustersThisRun;
    ULONG StartIndexOfThisRun;

    PULONG FreeClusterCount = NULL;

    PFAT_WINDOW CurrentWindow = NULL;

    PVOID NewBitMapBuffer = NULL;
    PRTL_BITMAP BitMap = NULL;
    RTL_BITMAP PrivateBitMap;

    enum RunType {
        FreeClusters,
        AllocatedClusters,
        UnknownClusters
    } CurrentRun;

    PAGED_CODE();

    //
    //  Now assert correct usage.
    //

    FatIndexBitSize = Vcb->AllocationSupport.FatIndexBitSize;

    ASSERT( !(SetupWindows && (SwitchToWindow || BitMapBuffer)));
    ASSERT( !(SetupWindows && FatIndexBitSize != 32));

    if (Vcb->NumberOfWindows > 1) {

        //
        //  FAT32: Calculate the number of FAT entries covered by a window.  This is
        //  equal to the number of bits in the freespace bitmap,  the size of which 
        //  is hardcoded.
        //
        
        EntriesPerWindow = MAX_CLUSTER_BITMAP_SIZE;
        
    } else {
    
        EntriesPerWindow = Vcb->AllocationSupport.NumberOfClusters;
    }

    //
    //  We will also fill in the cumulative count of free clusters for
    //  the entire volume.  If this is not appropriate, NULL it out
    //  shortly.
    //

    FreeClusterCount = &Vcb->AllocationSupport.NumberOfFreeClusters;

    if (SetupWindows) {

        ASSERT(BitMapBuffer == NULL);

        //
        //  In this case we're just supposed to scan the fat and set up
        //  the information regarding where the buckets fall and how many
        //  free clusters are in each.
        //
        //  It is fine to monkey with the real windows, we must be able
        //  to do this to activate the volume.
        //

        BitMap = NULL;

        CurrentWindow = &Vcb->Windows[0];
        CurrentWindow->FirstCluster = StartIndex;
        CurrentWindow->ClustersFree = 0;

        //
        //  We always wish to calculate total free clusters when
        //  setting up the FAT windows.
        //

    } else if (BitMapBuffer == NULL) {

        //
        //  We will be filling in the free cluster bitmap for the volume.
        //  Careful, we can raise out of here and be hopelessly hosed if
        //  we built this up in the main bitmap/window itself.
        //
        //  For simplicity's sake, we'll do the swap for everyone. FAT32
        //  provokes the need since we can't tolerate partial results
        //  when switching windows.
        //

        ASSERT( SwitchToWindow );

        CurrentWindow = SwitchToWindow;
        StartIndex = CurrentWindow->FirstCluster;
        EndIndex = CurrentWindow->LastCluster;

        BitMap = &PrivateBitMap;
        NewBitMapBuffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                    (EntriesPerWindow + 7) / 8,
                                                    TAG_FAT_BITMAP );

        RtlInitializeBitMap( &PrivateBitMap,
                             NewBitMapBuffer,
                             EndIndex - StartIndex + 1);

        if (FatIndexBitSize == 32) {

            //
            //  We do not wish count total clusters here.
            //

            FreeClusterCount = NULL;

        }

    } else {

        BitMap = &PrivateBitMap;
        RtlInitializeBitMap(&PrivateBitMap,
                            BitMapBuffer,
                            EndIndex - StartIndex + 1);

        //
        //  We do not count total clusters here.
        //

        FreeClusterCount = NULL;
    }

    //
    //  Now, our start index better be in the file heap.
    //

    ASSERT( StartIndex >= 2 );

    //
    //  Pick up the initial chunk of the FAT and first entry.
    //

    if (FatIndexBitSize == 12) {

        //
        //  We read in the entire fat in the 12 bit case.
        //

        FatReadVolumeFile( IrpContext,
                           Vcb,
                           FatReservedBytes( &Vcb->Bpb ),
                           FatBytesPerFat( &Vcb->Bpb ),
                           &Bcb,
                           (PVOID *)&FatBuffer );

        FatLookup12BitEntry(FatBuffer, 0, &FirstFatEntry);

    } else {

        //
        //  Read in one page of fat at a time.  We cannot read in the
        //  all of the fat we need because of cache manager limitations.
        //

        ULONG BytesPerEntry = FatIndexBitSize >> 3;
        ULONG EntriesPerPage = PAGE_SIZE / BytesPerEntry;

        Page = (FatReservedBytes(&Vcb->Bpb) + StartIndex * BytesPerEntry) / PAGE_SIZE;

        Offset = Page * PAGE_SIZE;

        FatReadVolumeFile( IrpContext,
                           Vcb,
                           Offset,
                           PAGE_SIZE,
                           &Bcb,
                           &pv);

        if (FatIndexBitSize == 32) {


            FatBuffer = (PUSHORT)((PUCHAR)pv +
                        (FatReservedBytes(&Vcb->Bpb) + StartIndex * BytesPerEntry) %
                             PAGE_SIZE);

            FirstFatEntry = *((PULONG)FatBuffer);
            FirstFatEntry = FirstFatEntry & FAT32_ENTRY_MASK;

        } else {

            FatBuffer = (PUSHORT)((PUCHAR)pv +
                        FatReservedBytes(&Vcb->Bpb) % PAGE_SIZE) + 2;

            FirstFatEntry = *FatBuffer;
        }

    }

    CurrentRun = (FirstFatEntry == FAT_CLUSTER_AVAILABLE) ?
                 FreeClusters : AllocatedClusters;

    StartIndexOfThisRun = StartIndex;

    try {

        for (FatIndex = StartIndex; FatIndex <= EndIndex; FatIndex++) {


            if (FatIndexBitSize == 12) {

                FatLookup12BitEntry(FatBuffer, FatIndex, &FatEntry);

            } else {

                //
                //  If we are setting up the FAT32 windows and have stepped into a new
                //  bucket, finalize this one and move forward.
                //

                if (SetupWindows &&
                    FatIndex > StartIndex &&
                    (FatIndex - 2) % EntriesPerWindow == 0) {

                    CurrentWindow->LastCluster = FatIndex - 1;

                    if (CurrentRun == FreeClusters) {

                        //
                        //  We must be counting clusters in order to modify the
                        //  contents of the window.
                        //

                        ASSERT( FreeClusterCount );


                        ClustersThisRun = FatIndex - StartIndexOfThisRun;
                        CurrentWindow->ClustersFree += ClustersThisRun;

                        if (FreeClusterCount) {
                            *FreeClusterCount += ClustersThisRun;
                        }

                    } else {

                        ASSERT(CurrentRun == AllocatedClusters);

                        ClustersThisRun = FatIndex - StartIndexOfThisRun;
                    }

                    StartIndexOfThisRun = FatIndex;
                    CurrentRun = UnknownClusters;

                    CurrentWindow++;
                    CurrentWindow->ClustersFree = 0;
                    CurrentWindow->FirstCluster = FatIndex;
                }

                //
                //  If we just stepped onto a new page, grab a new pointer.
                //

                if (((ULONG_PTR)FatBuffer & (PAGE_SIZE - 1)) == 0) {

                    FatUnpinBcb( IrpContext, Bcb );

                    Page++;
                    Offset += PAGE_SIZE;

                    FatReadVolumeFile( IrpContext,
                                       Vcb,
                                       Offset,
                                       PAGE_SIZE,
                                       &Bcb,
                                       &pv );

                    FatBuffer = (PUSHORT)pv;
                }

                if (FatIndexBitSize == 32) {

                    FatEntry = *((PULONG)FatBuffer)++;
                    FatEntry = FatEntry & FAT32_ENTRY_MASK;

                } else {

                    FatEntry = *FatBuffer;
                    FatBuffer += 1;
                }
            }

            if (CurrentRun == UnknownClusters) {

                CurrentRun = (FatEntry == FAT_CLUSTER_AVAILABLE) ?
                              FreeClusters : AllocatedClusters;
            }

            //
            //  Are we switching from a free run to an allocated run?
            //

            if (CurrentRun == FreeClusters &&
                FatEntry != FAT_CLUSTER_AVAILABLE) {

                ClustersThisRun = FatIndex - StartIndexOfThisRun;

                if (FreeClusterCount) {

                    *FreeClusterCount += ClustersThisRun;
                    CurrentWindow->ClustersFree += ClustersThisRun;
                }

                if (BitMap) {

                    RtlClearBits( BitMap,
                                  StartIndexOfThisRun - StartIndex,
                                  ClustersThisRun );
                }

                CurrentRun = AllocatedClusters;
                StartIndexOfThisRun = FatIndex;
            }

            //
            //  Are we switching from an allocated run to a free run?
            //

            if (CurrentRun == AllocatedClusters &&
                FatEntry == FAT_CLUSTER_AVAILABLE) {

                ClustersThisRun = FatIndex - StartIndexOfThisRun;

                if (BitMap) {

                    RtlSetBits( BitMap,
                                StartIndexOfThisRun - StartIndex,
                                ClustersThisRun );
                }

                CurrentRun = FreeClusters;
                StartIndexOfThisRun = FatIndex;
            }
        }

        //
        //  Now we have to record the final run we encountered
        //

        ClustersThisRun = FatIndex - StartIndexOfThisRun;

        if (CurrentRun == FreeClusters) {

            if (FreeClusterCount) {

                *FreeClusterCount += ClustersThisRun;
                CurrentWindow->ClustersFree += ClustersThisRun;
            }

            if (BitMap) {

                RtlClearBits( BitMap,
                              StartIndexOfThisRun - StartIndex,
                              ClustersThisRun );
            }

        } else {

            if (BitMap) {

                RtlSetBits( BitMap,
                            StartIndexOfThisRun - StartIndex,
                            ClustersThisRun );
            }
        }

        //
        //  And finish the last window if we are in setup.
        //

        if (SetupWindows) {

            CurrentWindow->LastCluster = FatIndex - 1;
        }

        //
        //  Now switch the active window if required.  We've succesfully gotten everything
        //  nailed down.
        //
        //  If we were tracking the free cluster count, this means we should update the
        //  window.  This is the case of FAT12/16 initialization.
        //

        if (SwitchToWindow) {

            if (Vcb->FreeClusterBitMap.Buffer) {

                ExFreePool( Vcb->FreeClusterBitMap.Buffer );
            }

            RtlInitializeBitMap( &Vcb->FreeClusterBitMap,
                                 NewBitMapBuffer,
                                 EndIndex - StartIndex + 1 );

            NewBitMapBuffer = NULL;

            Vcb->CurrentWindow = SwitchToWindow;
            Vcb->ClusterHint = -1;

            if (FreeClusterCount) {

                ASSERT( !SetupWindows );
                ASSERT( FatIndexBitSize != 32 );

                Vcb->CurrentWindow->ClustersFree = *FreeClusterCount;
            }
        }

        //
        //  Make sure plausible things occured ...
        //

        if (!SetupWindows && BitMapBuffer == NULL) {

            ASSERT_CURRENT_WINDOW_GOOD( Vcb );
        }

        ASSERT(Vcb->AllocationSupport.NumberOfFreeClusters <= Vcb->AllocationSupport.NumberOfClusters);

    } finally {

        //
        //  Unpin the last bcb and drop the temporary bitmap buffer if it exists.
        //

        FatUnpinBcb( IrpContext, Bcb);

        if (NewBitMapBuffer) {

            ExFreePool( NewBitMapBuffer );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\devctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DevCtrl.c

Abstract:

    This module implements the File System Device Control routines for Fat
    called by the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVCTRL)

//
//  Local procedure prototypes
//

NTSTATUS
FatDeviceControlCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonDeviceControl)
#pragma alloc_text(PAGE, FatFsdDeviceControl)
#endif


NTSTATUS
FatFsdDeviceControl (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Device control operations

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdDeviceControl\n", 0);

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ));

        Status = FatCommonDeviceControl( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdDeviceControl -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonDeviceControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing Device control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

    InFsp - Indicates if this is the fsp thread or someother thread

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    KEVENT WaitEvent;
    PVOID CompletionContext = NULL;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonDeviceControl\n", 0);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "MinorFunction = %08lx\n", IrpSp->MinorFunction);

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb ) != UserVolumeOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatCommonDeviceControl -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  A few IOCTLs actually require some intervention on our part
    //

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES:

        //
        //  This is sent by the Volume Snapshot driver (Lovelace).
        //  We flush the volume, and hold all file resources
        //  to make sure that nothing more gets dirty. Then we wait
        //  for the IRP to complete or cancel.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
        FatAcquireExclusiveVolume( IrpContext, Vcb );

        FatFlushAndCleanVolume( IrpContext,
                                Irp,
                                Vcb,
                                FlushWithoutPurge );

        KeInitializeEvent( &WaitEvent, NotificationEvent, FALSE );
        CompletionContext = &WaitEvent;

        //
        //  Get the next stack location, and copy over the stack location
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );

        //
        //  Set up the completion routine
        //

        IoSetCompletionRoutine( Irp,
                                FatDeviceControlCompletionRoutine,
                                CompletionContext,
                                TRUE,
                                TRUE,
                                TRUE );
        break;

    default:

        //
        //  FAT doesn't need to see this on the way back, so skip ourselves.
        //

        IoSkipCurrentIrpStackLocation( Irp );
        break;
    }

    //
    //  Send the request.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING && CompletionContext) {

        KeWaitForSingleObject( &WaitEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }

    //
    //  If we had a context, the IRP remains for us and we will complete it.
    //  Handle it appropriately.
    //

    if (CompletionContext) {

        //
        //  Release all the resources that we held because of a
        //  VOLSNAP_FLUSH_AND_HOLD. 
        //

        ASSERT( IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_VOLSNAP_FLUSH_AND_HOLD_WRITES );

        FatReleaseVolume( IrpContext, Vcb );

        //
        //  If we had no context, the IRP will complete asynchronously.
        //

    } else {

        Irp = NULL;
    }

    FatCompleteRequest( IrpContext, Irp, Status );

    DebugTrace(-1, Dbg, "FatCommonDeviceControl -> %08lx\n", Status);

    return Status;
}


//
//  Local support routine
//

NTSTATUS
FatDeviceControlCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    PKEVENT Event = (PKEVENT) Contxt;
    
    //
    //  If there is an event, this is a synch request. Signal and
    //  let I/O know this isn't done yet.
    //

    if (Event) {

        KeSetEvent( Event, 0, FALSE );
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\cachesup.c ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    cache.c

Abstract:

    This module implements the cache management routines for the Fat
    FSD and FSP, by calling the Common Cache Manager.

// @@BEGIN_DDKSPLIT

Author:

    Tom Miller      [TomM]      26-Jan-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_CACHESUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CACHESUP)

#if DBG

BOOLEAN
FatIsCurrentOperationSynchedForDcbTeardown (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    );

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCloseEaFile)
#pragma alloc_text(PAGE, FatCompleteMdl)
#pragma alloc_text(PAGE, FatOpenDirectoryFile)
#pragma alloc_text(PAGE, FatOpenEaFile)
#pragma alloc_text(PAGE, FatPinMappedData)
#pragma alloc_text(PAGE, FatPrepareWriteDirectoryFile)
#pragma alloc_text(PAGE, FatPrepareWriteVolumeFile)
#pragma alloc_text(PAGE, FatReadDirectoryFile)
#pragma alloc_text(PAGE, FatReadVolumeFile)
#pragma alloc_text(PAGE, FatRepinBcb)
#pragma alloc_text(PAGE, FatSyncUninitializeCacheMap)
#pragma alloc_text(PAGE, FatUnpinRepinnedBcbs)
#pragma alloc_text(PAGE, FatZeroData)
#if DBG
#pragma alloc_text(PAGE, FatIsCurrentOperationSynchedForDcbTeardown)
#endif
#endif


VOID
FatReadVolumeFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine is called when the specified range of sectors is to be
    read into the cache.  In fat, the volume file only contains the boot
    sector, reserved sectors, and the "fat(s)."  Thus the volume file is
    of fixed size and only extends up to (but not not including) the root
    directory entry, and will never move or change size.

    The fat volume file is also peculiar in that, since it starts at the
    logical beginning of the disk, Vbo == Lbo.

Arguments:

    Vcb - Pointer to the VCB for the volume

    StartingVbo - The virtual offset of the first desired byte

    ByteCount - Number of bytes desired

    Bcb - Returns a pointer to the BCB which is valid until unpinned

    Buffer - Returns a pointer to the sectors, which is valid until unpinned

--*/

{
    LARGE_INTEGER Vbo;

    PAGED_CODE();

    //
    //  Check to see that all references are within the Bios Parameter Block
    //  or the fat(s).  A special case is made when StartingVbo == 0 at
    //  mounting time since we do not know how big the fat is.
    //

    ASSERT( ((StartingVbo == 0) || ((StartingVbo + ByteCount) <= (ULONG)
            (FatRootDirectoryLbo( &Vcb->Bpb ) + PAGE_SIZE))));

    DebugTrace(+1, Dbg, "FatReadVolumeFile\n", 0);
    DebugTrace( 0, Dbg, "Vcb         = %08lx\n", Vcb);
    DebugTrace( 0, Dbg, "StartingVbo = %08lx\n", StartingVbo);
    DebugTrace( 0, Dbg, "ByteCount   = %08lx\n", ByteCount);

    //
    //  Call the Cache manager to attempt the transfer.
    //

    Vbo.QuadPart = StartingVbo;

    if (!CcMapData( Vcb->VirtualVolumeFile,
                    &Vbo,
                    ByteCount,
                    BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                    Bcb,
                    Buffer )) {

        ASSERT( !FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

        //
        // Could not read the data without waiting (cache miss).
        //

        FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    DbgDoit( IrpContext->PinCount += 1 )

    DebugTrace(-1, Dbg, "FatReadVolumeFile -> VOID, *BCB = %08lx\n", *Bcb);

    return;
}


VOID
FatPrepareWriteVolumeFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    IN BOOLEAN Reversible,
    IN BOOLEAN Zero
    )

/*++

Routine Description:

    This routine first looks to see if the specified range of sectors,
    is already in the cache.  If so, it increments the BCB PinCount,
    sets the BCB dirty, and returns with the location of the sectors.

    If the sectors are not in the cache and Wait is TRUE, it finds a
    free BCB (potentially causing a flush), and clears out the entire
    buffer.  Once this is done, it increments the BCB PinCount, sets the
    BCB dirty, and returns with the location of the sectors.

    If the sectors are not in the cache and Wait is FALSE, this routine
    raises STATUS_CANT_WAIT.

Arguments:

    Vcb - Pointer to the VCB for the volume

    StartingVbo - The virtual offset of the first byte to be written

    ByteCount - Number of bytes to be written

    Bcb - Returns a pointer to the BCB which is valid until unpinned

    Buffer - Returns a pointer to the sectors, which is valid until unpinned

    Reversible - Supplies TRUE if the specified range of modification should
        be repinned so that the operation can be reversed in a controlled
        fashion if errors are encountered.
    
    Zero - Supplies TRUE if the specified range of bytes should be zeroed

--*/

{
    LARGE_INTEGER Vbo;

    PAGED_CODE();
    
    //
    //  Check to see that all references are within the Bios Parameter Block
    //  or the fat(s).
    //

    ASSERT( ((StartingVbo + ByteCount) <= (ULONG)
            (FatRootDirectoryLbo( &Vcb->Bpb ))));

    DebugTrace(+1, Dbg, "FatPrepareWriteVolumeFile\n", 0);
    DebugTrace( 0, Dbg, "Vcb         = %08lx\n", Vcb);
    DebugTrace( 0, Dbg, "StartingVbo = %08lx\n", (ULONG)StartingVbo);
    DebugTrace( 0, Dbg, "ByteCount   = %08lx\n", ByteCount);
    DebugTrace( 0, Dbg, "Zero        = %08lx\n", Zero);

    //
    //  Call the Cache manager to attempt the transfer.
    //

    Vbo.QuadPart = StartingVbo;

    if (!CcPinRead( Vcb->VirtualVolumeFile,
                    &Vbo,
                    ByteCount,
                    BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                    Bcb,
                    Buffer )) {

        ASSERT( !FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

        //
        // Could not read the data without waiting (cache miss).
        //

        FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    //
    //  This keeps the data pinned until we complete the request
    //  and writes the dirty bit through to the disk.
    //

    DbgDoit( IrpContext->PinCount += 1 )

    try {

        if (Zero) {
            
            RtlZeroMemory( *Buffer, ByteCount );
        }

        FatSetDirtyBcb( IrpContext, *Bcb, Vcb, Reversible );

    } finally {

        if (AbnormalTermination()) {

            FatUnpinBcb(IrpContext, *Bcb);
        }
    }

    DebugTrace(-1, Dbg, "FatPrepareWriteVolumeFile -> VOID, *Bcb = %08lx\n", *Bcb);

    return;
}


VOID
FatReadDirectoryFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    IN BOOLEAN Pin,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    This routine is called when the specified range of sectors is to be
    read into the cache.  If the desired range falls beyond the current
    cache mapping, the fat will be searched, and if the desired range can
    be satisfied, the cache mapping will be extended and the MCB updated
    accordingly.

Arguments:

    Dcb - Pointer to the DCB for the directory

    StartingVbo - The virtual offset of the first desired byte

    ByteCount - Number of bytes desired

    Pin - Tells us if we should pin instead of just mapping.

    Bcb - Returns a pointer to the BCB which is valid until unpinned

    Buffer - Returns a pointer to the sectors, which is valid until unpinned

    Status - Returns the status of the operation.

--*/

{
    LARGE_INTEGER Vbo;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatReadDirectoryFile\n", 0);
    DebugTrace( 0, Dbg, "Dcb         = %08lx\n", Dcb);
    DebugTrace( 0, Dbg, "StartingVbo = %08lx\n", StartingVbo);
    DebugTrace( 0, Dbg, "ByteCount   = %08lx\n", ByteCount);

    //
    //  Check for the zero case
    //

    if (ByteCount == 0) {

        DebugTrace(0, Dbg, "Nothing to read\n", 0);

        *Bcb = NULL;
        *Buffer = NULL;
        *Status = STATUS_SUCCESS;

        DebugTrace(-1, Dbg, "FatReadDirectoryFile -> VOID\n", 0);
        return;
    }

    //
    //  If we need to create a directory file and initialize the
    //  cachemap, do so.
    //

    FatOpenDirectoryFile( IrpContext, Dcb );

    //
    //  Now if the transfer is beyond the allocation size return EOF.
    //

    if (StartingVbo >= Dcb->Header.AllocationSize.LowPart) {

        DebugTrace(0, Dbg, "End of file read for directory\n", 0);

        *Bcb = NULL;
        *Buffer = NULL;
        *Status = STATUS_END_OF_FILE;

        DebugTrace(-1, Dbg, "FatReadDirectoryFile -> VOID\n", 0);
        return;
    }

    //
    // If the caller is trying to read past the EOF, truncate the
    // read.
    //

    ByteCount = (Dcb->Header.AllocationSize.LowPart - StartingVbo < ByteCount) ?
                 Dcb->Header.AllocationSize.LowPart - StartingVbo : ByteCount;

    ASSERT( ByteCount != 0 );

    //
    //  Call the Cache manager to attempt the transfer.
    //

    Vbo.QuadPart = StartingVbo;

    if (Pin ?

        !CcPinRead( Dcb->Specific.Dcb.DirectoryFile,
                    &Vbo,
                    ByteCount,
                    BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                    Bcb,
                    Buffer )
        :

        !CcMapData( Dcb->Specific.Dcb.DirectoryFile,
                    &Vbo,
                    ByteCount,
                    BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                    Bcb,
                    Buffer ) ) {

        //
        // Could not read the data without waiting (cache miss).
        //

        *Bcb = NULL;
        *Buffer = NULL;
        FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    DbgDoit( IrpContext->PinCount += 1 )

    *Status = STATUS_SUCCESS;

    DebugTrace(-1, Dbg, "FatReadDirectoryFile -> VOID, *BCB = %08lx\n", *Bcb);

    return;
}


VOID
FatPrepareWriteDirectoryFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    IN BOOLEAN Zero,
    IN BOOLEAN Reversible,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    This routine first looks to see if the specified range of sectors
    is already in the cache.  If so, it increments the BCB PinCount,
    sets the BCB dirty, and returns TRUE with the location of the sectors.

    The IrpContext->Flags .. Wait == TRUE/FALSE actions of this routine are identical to
    FatPrepareWriteVolumeFile() above.

Arguments:

    Dcb - Pointer to the DCB for the directory

    StartingVbo - The virtual offset of the first byte to be written

    ByteCount - Number of bytes to be written

    Bcb - Returns a pointer to the BCB which is valid until unpinned

    Buffer - Returns a pointer to the sectors, which is valid until unpinned

    Zero - Supplies TRUE if the specified range of bytes should be zeroed
    
    Reversible - Supplies TRUE if the specified range of modification should
        be repinned so that the operation can be reversed in a controlled
        fashion if errors are encountered.
    
    Status - Returns the status of the operation.

--*/

{
    LARGE_INTEGER Vbo;
    ULONG InitialAllocation;
    BOOLEAN UnwindWeAllocatedDiskSpace = FALSE;
    ULONG ClusterSize;

    PVOID LocalBuffer;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatPrepareWriteDirectoryFile\n", 0);
    DebugTrace( 0, Dbg, "Dcb         = %08lx\n", Dcb);
    DebugTrace( 0, Dbg, "StartingVbo = %08lx\n", (ULONG)StartingVbo);
    DebugTrace( 0, Dbg, "ByteCount   = %08lx\n", ByteCount);
    DebugTrace( 0, Dbg, "Zero        = %08lx\n", Zero);

    *Bcb = NULL;
    *Buffer = NULL;

    //
    //  If we need to create a directory file and initialize the
    //  cachemap, do so.
    //

    FatOpenDirectoryFile( IrpContext, Dcb );

    //
    //  If the transfer is beyond the allocation size we need to
    //  extend the directory's allocation.  The call to
    //  AddFileAllocation will raise a condition if
    //  it runs out of disk space.  Note that the root directory
    //  cannot be extended.
    //

    Vbo.QuadPart = StartingVbo;

    try {

        if (StartingVbo + ByteCount > Dcb->Header.AllocationSize.LowPart) {

            if (NodeType(Dcb) == FAT_NTC_ROOT_DCB &&
                !FatIsFat32(Dcb->Vcb)) {

                FatRaiseStatus( IrpContext, STATUS_DISK_FULL );
            }

            DebugTrace(0, Dbg, "Try extending normal directory\n", 0);

            InitialAllocation = Dcb->Header.AllocationSize.LowPart;

            FatAddFileAllocation( IrpContext,
                                  Dcb,
                                  Dcb->Specific.Dcb.DirectoryFile,
                                  StartingVbo + ByteCount );

            UnwindWeAllocatedDiskSpace = TRUE;

            //
            //  Inform the cache manager of the new allocation
            //

            Dcb->Header.FileSize.LowPart =
                Dcb->Header.AllocationSize.LowPart;

            CcSetFileSizes( Dcb->Specific.Dcb.DirectoryFile,
                            (PCC_FILE_SIZES)&Dcb->Header.AllocationSize );

            //
            //  Set up the Bitmap buffer if it is not big enough already
            //

            FatCheckFreeDirentBitmap( IrpContext, Dcb );

            //
            //  The newly allocated clusters should be zeroed starting at
            //  the previous allocation size
            //

            Zero = TRUE;
            Vbo.QuadPart = InitialAllocation;
            ByteCount = Dcb->Header.AllocationSize.LowPart - InitialAllocation;
        }

        //
        // Call the Cache Manager to attempt the transfer, going one cluster
        // at a time to avoid pinning across a page boundary.
        //

        ClusterSize =
            1 << Dcb->Vcb->AllocationSupport.LogOfBytesPerCluster;

        while (ByteCount > 0) {

            ULONG BytesToPin;

            *Bcb = NULL;

            if (ByteCount > ClusterSize) {
                BytesToPin = ClusterSize;
            } else {
                BytesToPin = ByteCount;
            }

            ASSERT( (Vbo.QuadPart / ClusterSize) ==
                    (Vbo.QuadPart + BytesToPin - 1)/ClusterSize );

            if (!CcPinRead( Dcb->Specific.Dcb.DirectoryFile,
                            &Vbo,
                            BytesToPin,
                            BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                            Bcb,
                            &LocalBuffer )) {
    
                //
                // Could not read the data without waiting (cache miss).
                //

                FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            //
            //  Update our caller with the beginning of their request.
            //
            
            if (*Buffer == NULL) {

                *Buffer = LocalBuffer;
            }

            DbgDoit( IrpContext->PinCount += 1 )

            if (Zero) {
                
                //
                //  We set this guy dirty right now so that we can raise CANT_WAIT when
                //  it needs to be done.  It'd be beautiful if we could noop the read IO
                //  since we know we don't care about it.
                //
                
                RtlZeroMemory( LocalBuffer, BytesToPin );
                CcSetDirtyPinnedData( *Bcb, NULL );
            }

            ByteCount -= BytesToPin;
            Vbo.QuadPart += BytesToPin;


            if (ByteCount > 0) {

                FatUnpinBcb( IrpContext, *Bcb );
            }
        }

        //
        //  This lets us get the data pinned until we complete the request
        //  and writes the dirty bit through to the disk.
        //

        FatSetDirtyBcb( IrpContext, *Bcb, Dcb->Vcb, Reversible );

        *Status = STATUS_SUCCESS;

    } finally {

        DebugUnwind( FatPrepareWriteDirectoryFile );

        if (AbnormalTermination()) {

            //
            //  These steps are carefully arranged - FatTruncateFileAllocation can raise.
            //  Make sure we unpin the buffer.  If FTFA raises, the effect should be benign.
            //
            
            FatUnpinBcb(IrpContext, *Bcb);
            
            if (UnwindWeAllocatedDiskSpace == TRUE) {

                //
                //  Inform the cache manager of the change.
                //

                FatTruncateFileAllocation( IrpContext, Dcb, InitialAllocation );

                Dcb->Header.FileSize.LowPart =
                    Dcb->Header.AllocationSize.LowPart;

                CcSetFileSizes( Dcb->Specific.Dcb.DirectoryFile,
                                (PCC_FILE_SIZES)&Dcb->Header.AllocationSize );
            }
        }

        DebugTrace(-1, Dbg, "FatPrepareWriteDirectoryFile -> (VOID), *Bcb = %08lx\n", *Bcb);
    }

    return;
}


#if DBG
BOOLEAN FatDisableParentCheck = 0;

BOOLEAN
FatIsCurrentOperationSynchedForDcbTeardown (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    )
{
    PIRP Irp = IrpContext->OriginatingIrp;
    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation( Irp ) ;
    PFILE_OBJECT FileObject = Stack->FileObject;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PFILE_OBJECT ToCheck[3];
    ULONG Index = 0;

    PAGED_CODE();
    
    //
    //  While mounting, we're OK without having to own anything.
    //
    
    if (Stack->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
        Stack->MinorFunction == IRP_MN_MOUNT_VOLUME) {

        return TRUE;
    }
    
    //
    //  With the Vcb held, the close path is blocked out.
    //
    
    if (ExIsResourceAcquiredSharedLite( &Dcb->Vcb->Resource ) ||
        ExIsResourceAcquiredExclusiveLite( &Dcb->Vcb->Resource )) {

        return TRUE;
    }
    
    //
    //  Accept this assertion at face value.  It comes from GetDirentForFcbOrDcb,
    //  and is reliable.
    //
    
    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_PARENT_BY_CHILD )) {

        return TRUE;
    }

    //
    //  Determine which fileobjects are around on this operation.
    //

    if (Stack->MajorFunction == IRP_MJ_SET_INFORMATION &&
        Stack->Parameters.SetFile.FileObject) {

        ToCheck[Index++] = Stack->Parameters.SetFile.FileObject;
    }

    if (Stack->FileObject) {
        
        ToCheck[Index++] = Stack->FileObject;
    }

    ToCheck[Index] = NULL;
    
    //
    //  If the fileobjects we have are for this dcb or a child of it, we are
    //  also guaranteed that this dcb isn't going anywhere (even without
    //  the Vcb).
    //
    
    for (Index = 0; ToCheck[Index] != NULL; Index++) {
    
        (VOID) FatDecodeFileObject( ToCheck[Index], &Vcb, &Fcb, &Ccb );

        while ( Fcb ) {
    
            if (Fcb == Dcb) {
    
                return TRUE;
            }
    
            Fcb = Fcb->ParentDcb;
        }
    }

    return FatDisableParentCheck;
}
#endif // DBG

VOID
FatOpenDirectoryFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    )

/*++

Routine Description:

    This routine opens a new directory file if one is not already open.

Arguments:

    Dcb - Pointer to the DCB for the directory

Return Value:

    None.

--*/

{
    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatOpenDirectoryFile\n", 0);
    DebugTrace( 0, Dbg, "Dcb = %08lx\n", Dcb);

    //
    //  If we don't have some hold on this Dcb (there are several ways), there is nothing
    //  to prevent child files from closing and tearing this branch of the tree down in the
    //  midst of our slapping this reference onto it.
    //
    //  I really wish we had a proper Fcb synchronization model (like CDFS/UDFS/NTFS).
    //
    
    ASSERT( FatIsCurrentOperationSynchedForDcbTeardown( IrpContext, Dcb ));

    //
    //  If we haven't yet set the correct AllocationSize, do so.
    //

    if (Dcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

        FatLookupFileAllocationSize( IrpContext, Dcb );

        Dcb->Header.FileSize.LowPart =
        Dcb->Header.AllocationSize.LowPart;
    }

    //
    //  Setup the Bitmap buffer if it is not big enough already
    //

    FatCheckFreeDirentBitmap( IrpContext, Dcb );

    //
    //  Check if we need to create a directory file.
    //
    //  We first do a spot check and then synchronize and check again.
    //

    if (Dcb->Specific.Dcb.DirectoryFile == NULL) {

        PFILE_OBJECT DirectoryFileObject = NULL;

        FatAcquireDirectoryFileMutex( Dcb->Vcb );

        try {

            if (Dcb->Specific.Dcb.DirectoryFile == NULL) {

                PDEVICE_OBJECT RealDevice;

                //
                //  Create the special file object for the directory file, and set
                //  up its pointers back to the Dcb and the section object pointer.
                //  Note that setting the DirectoryFile pointer in the Dcb has
                //  to be the last thing done.
                //
                //  Preallocate a close context since we have no Ccb for this object.
                //

                RealDevice = Dcb->Vcb->CurrentDevice;

                DirectoryFileObject = IoCreateStreamFileObject( NULL, RealDevice );
                FatPreallocateCloseContext();

                FatSetFileObject( DirectoryFileObject,
                                  DirectoryFile,
                                  Dcb,
                                  NULL );

                DirectoryFileObject->SectionObjectPointer = &Dcb->NonPaged->SectionObjectPointers;

                DirectoryFileObject->ReadAccess = TRUE;
                DirectoryFileObject->WriteAccess = TRUE;
                DirectoryFileObject->DeleteAccess = TRUE;

                InterlockedIncrement( &Dcb->Specific.Dcb.DirectoryFileOpenCount );

                Dcb->Specific.Dcb.DirectoryFile = DirectoryFileObject;
                
                //
                //  Indicate we're happy with the fileobject now.
                //

                DirectoryFileObject = NULL;
            }

        } finally {

            FatReleaseDirectoryFileMutex( Dcb->Vcb );

            //
            //  Rip the object up if we couldn't get the close context.
            //
            
            if (DirectoryFileObject) {
                
                ObDereferenceObject( DirectoryFileObject );
            }
        }
    }

    //
    //  Finally check if we need to initialize the Cache Map for the
    //  directory file.  The size of the section we are going to map
    //  the current allocation size for the directory.  Note that the
    //  cache manager will provide syncronization for us.
    //

    if ( Dcb->Specific.Dcb.DirectoryFile->PrivateCacheMap == NULL ) {

        Dcb->Header.ValidDataLength = FatMaxLarge;
        Dcb->ValidDataToDisk = MAXULONG;

        CcInitializeCacheMap( Dcb->Specific.Dcb.DirectoryFile,
                              (PCC_FILE_SIZES)&Dcb->Header.AllocationSize,
                              TRUE,
                              &FatData.CacheManagerNoOpCallbacks,
                              Dcb );
    }

    DebugTrace(-1, Dbg, "FatOpenDirectoryFile -> VOID\n", 0);

    return;
}


PFILE_OBJECT
FatOpenEaFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB EaFcb
    )

/*++

Routine Description:

    This routine opens the Ea file.

Arguments:

    EaFcb - Pointer to the Fcb for the Ea file.

Return Value:

    Pointer to the new file object.

--*/

{
    PFILE_OBJECT EaFileObject = NULL;
    PDEVICE_OBJECT RealDevice;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatOpenEaFile\n", 0);
    DebugTrace( 0, Dbg, "EaFcb = %08lx\n", EaFcb);

    //
    //  Create the special file object for the ea file, and set
    //  up its pointers back to the Fcb and the section object pointer
    //

    RealDevice = EaFcb->Vcb->CurrentDevice;

    EaFileObject = IoCreateStreamFileObject( NULL, RealDevice );

    try {

        FatPreallocateCloseContext();

        FatSetFileObject( EaFileObject,
                          EaFile,
                          EaFcb,
                          NULL );

        EaFileObject->SectionObjectPointer = &EaFcb->NonPaged->SectionObjectPointers;

        EaFileObject->ReadAccess = TRUE;
        EaFileObject->WriteAccess = TRUE;

        //
        //  Finally check if we need to initialize the Cache Map for the
        //  ea file.  The size of the section we are going to map
        //  the current allocation size for the Fcb.
        //

        EaFcb->Header.ValidDataLength = FatMaxLarge;

        CcInitializeCacheMap( EaFileObject,
                              (PCC_FILE_SIZES)&EaFcb->Header.AllocationSize,
                              TRUE,
                              &FatData.CacheManagerCallbacks,
                              EaFcb );

        CcSetAdditionalCacheAttributes( EaFileObject, TRUE, TRUE );
    
    } finally {

        //
        //  Drop the fileobject if we're raising.  Two cases: couldn't get
        //  the close context, and it is still an UnopenedFileObject, or
        //  we lost trying to build the cache map - in which case we're
        //  OK for the close context if we have to.
        //
        
        if (AbnormalTermination()) {
            
            ObDereferenceObject( EaFileObject );
        }
    }

    DebugTrace(-1, Dbg, "FatOpenEaFile -> %08lx\n", EaFileObject);

    UNREFERENCED_PARAMETER( IrpContext );

    return EaFileObject;
}


VOID
FatCloseEaFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN FlushFirst
    )

/*++

Routine Description:

    This routine shuts down the ea file.  Usually this is required when the volume
    begins to leave the system: after verify, dismount, deletion, pnp.
    
Arguments:

    Vcb - the volume to close the ea file on
    
    FlushFirst - whether the file should be flushed
    
Return Value:

    None. As a side effect, the EA fileobject in the Vcb is cleared.
    
    Caller must have the Vcb exclusive.
    
--*/

{
    PFILE_OBJECT EaFileObject = Vcb->VirtualEaFile;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatCloseEaFile\n", 0);
    DebugTrace( 0, Dbg, "Vcb = %08lx\n", Vcb);

    ASSERT( FatVcbAcquiredExclusive(IrpContext, Vcb) );

    if (EaFileObject != NULL) {

        EaFileObject = Vcb->VirtualEaFile;

        if (FlushFirst) {

            CcFlushCache( Vcb->VirtualEaFile->SectionObjectPointer, NULL, 0, NULL );
        }

        Vcb->VirtualEaFile = NULL;

        //
        //  Empty the Mcb for the Ea file.
        //

        FatRemoveMcbEntry( Vcb, &Vcb->EaFcb->Mcb, 0, 0xFFFFFFFF );

        //
        //  Set the file object type to unopened file object
        //  and dereference it.
        //

        FatSetFileObject( EaFileObject,
                          UnopenedFileObject,
                          NULL,
                          NULL );

        FatSyncUninitializeCacheMap( IrpContext, EaFileObject );

        ObDereferenceObject( EaFileObject );
    }
    
    DebugTrace(-1, Dbg, "FatCloseEaFile -> %08lx\n", EaFileObject);
}


VOID
FatSetDirtyBcb (
    IN PIRP_CONTEXT IrpContext,
    IN PBCB Bcb,
    IN PVCB Vcb OPTIONAL,
    IN BOOLEAN Reversible
    )

/*++

Routine Description:

    This routine saves a reference to the bcb in the irp context and
    sets the bcb dirty.  This will have the affect of keeping the page in
    memory until we complete the request

    In addition, a DPC is set to fire in 5 seconds (or if one is pending,
    pushed back 5 seconds) to mark the volume clean.

Arguments:

    Bcb - Supplies the Bcb being set dirty
    
    Vcb - Supplies the volume being marked dirty
    
    Reversible - Supplies TRUE if the specified range of bcb should be repinned
        so that the changes can be reversed in a controlled fashion if errors
        are encountered.
    
Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FatSetDirtyBcb\n", 0 );
    DebugTrace( 0, Dbg, "IrpContext = %08lx\n", IrpContext );
    DebugTrace( 0, Dbg, "Bcb        = %08lx\n", Bcb );
    DebugTrace( 0, Dbg, "Vcb        = %08lx\n", Vcb );

    //
    //  Repin the bcb as required
    //

    if (Reversible) {
    
        FatRepinBcb( IrpContext, Bcb );
    }

    //
    //  Set the bcb dirty
    //

    CcSetDirtyPinnedData( Bcb, NULL );

    //
    //  If volume dirtying isn't disabled for this operation (for
    //  instance, when we're changing the dirty state), set the
    //  volume dirty if we were given a Vcb that we want to perform
    //  clean volume processing on, and return.
    //
    //  As a historical note, we used to key off of the old floppy
    //  (now deferred flush) bit to disable dirtying behavior.  Since
    //  hotpluggable media can still be yanked while operations are
    //  in flight, recognize that its really the case that FAT12
    //  doesn't have the dirty bit.
    //

    if ( !FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_DIRTY) &&
         ARGUMENT_PRESENT(Vcb) &&
         !FatIsFat12(Vcb)) {

        KIRQL SavedIrql;

        BOOLEAN SetTimer;

        LARGE_INTEGER TimeSincePreviousCall;
        LARGE_INTEGER CurrentTime;

        //
        //  "Borrow" the irp context spinlock.
        //

        KeQuerySystemTime( &CurrentTime );

        KeAcquireSpinLock( &FatData.GeneralSpinLock, &SavedIrql );

        TimeSincePreviousCall.QuadPart =
                CurrentTime.QuadPart - Vcb->LastFatMarkVolumeDirtyCall.QuadPart;

        //
        //  If more than one second has elapsed since the prior call
        //  to here, bump the timer up again and see if we need to
        //  physically mark the volume dirty.
        //

        if ( (TimeSincePreviousCall.HighPart != 0) ||
             (TimeSincePreviousCall.LowPart > (1000 * 1000 * 10)) ) {

            SetTimer = TRUE;

        } else {

            SetTimer = FALSE;
        }

        KeReleaseSpinLock( &FatData.GeneralSpinLock, SavedIrql );

        if ( SetTimer ) {

            LARGE_INTEGER CleanVolumeTimer;

            //
            //  We use a shorter volume clean timer for hot plug volumes.
            //
            
            CleanVolumeTimer.QuadPart = FlagOn( Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH)
                                        ? (LONG)-1500*1000*10
                                        : (LONG)-8*1000*1000*10;

            (VOID)KeCancelTimer( &Vcb->CleanVolumeTimer );
            (VOID)KeRemoveQueueDpc( &Vcb->CleanVolumeDpc );

            //
            //  We have now synchronized with anybody clearing the dirty
            //  flag, so we can now see if we really have to actually write
            //  out the physical bit.
            //

            if ( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY) ) {

                //
                //  We want to really mark the volume dirty now.
                //

                if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY)) {

                    FatMarkVolume( IrpContext, Vcb, VolumeDirty );
                }

                SetFlag( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY );

                //
                //  Lock the volume if it is removable.
                //

                if (FlagOn( Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA)) {

                    FatToggleMediaEjectDisable( IrpContext, Vcb, TRUE );
                }
            }

            KeAcquireSpinLock( &FatData.GeneralSpinLock, &SavedIrql );

            KeQuerySystemTime( &Vcb->LastFatMarkVolumeDirtyCall );

            KeReleaseSpinLock( &FatData.GeneralSpinLock, SavedIrql );

            KeSetTimer( &Vcb->CleanVolumeTimer,
                        CleanVolumeTimer,
                        &Vcb->CleanVolumeDpc );
        }
    }

    DebugTrace(-1, Dbg, "FatSetDirtyBcb -> VOID\n", 0 );
}


VOID
FatRepinBcb (
    IN PIRP_CONTEXT IrpContext,
    IN PBCB Bcb
    )

/*++

Routine Description:

    This routine saves a reference to the bcb in the irp context. This will
    have the affect of keeping the page in memory until we complete the
    request

Arguments:

    Bcb - Supplies the Bcb being referenced

Return Value:

    None.

--*/

{
    PREPINNED_BCBS Repinned;
    ULONG i;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatRepinBcb\n", 0 );
    DebugTrace( 0, Dbg, "IrpContext = %08lx\n", IrpContext );
    DebugTrace( 0, Dbg, "Bcb        = %08lx\n", Bcb );

    //
    //  The algorithm is to search the list of repinned records until
    //  we either find a match for the bcb or we find a null slot.
    //

    Repinned = &IrpContext->Repinned;

    while (TRUE) {

        //
        //  For every entry in the repinned record check if the bcb's
        //  match or if the entry is null.  If the bcb's match then
        //  we've done because we've already repinned this bcb, if
        //  the entry is null then we know, because it's densely packed,
        //  that the bcb is not in the list so add it to the repinned
        //  record and repin it.
        //

        for (i = 0; i < REPINNED_BCBS_ARRAY_SIZE; i += 1) {

            if (Repinned->Bcb[i] == Bcb) {

                DebugTrace(-1, Dbg, "FatRepinBcb -> VOID\n", 0 );
                return;
            }

            if (Repinned->Bcb[i] == NULL) {

                Repinned->Bcb[i] = Bcb;
                CcRepinBcb( Bcb );

                DebugTrace(-1, Dbg, "FatRepinBcb -> VOID\n", 0 );
                return;
            }
        }

        //
        //  We finished checking one repinned record so now locate the next
        //  repinned record,  If there isn't one then allocate and zero out
        //  a new one.
        //

        if (Repinned->Next == NULL) {

            Repinned->Next = FsRtlAllocatePoolWithTag( PagedPool,
                                                       sizeof(REPINNED_BCBS),
                                                       TAG_REPINNED_BCB );

            RtlZeroMemory( Repinned->Next, sizeof(REPINNED_BCBS) );
        }

        Repinned = Repinned->Next;
    }
}


VOID
FatUnpinRepinnedBcbs (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine frees all of the repinned bcbs, stored in an IRP context.

Arguments:

Return Value:

    None.

--*/

{
    IO_STATUS_BLOCK RaiseIosb;
    PREPINNED_BCBS Repinned;
    BOOLEAN WriteThroughToDisk;
    PFILE_OBJECT FileObject = NULL;
    BOOLEAN ForceVerify = FALSE;
    ULONG i;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatUnpinRepinnedBcbs\n", 0 );
    DebugTrace( 0, Dbg, "IrpContext = %08lx\n", IrpContext );

    //
    //  The algorithm for this procedure is to scan the entire list of
    //  repinned records unpinning any repinned bcbs.  We start off
    //  with the first record in the irp context, and while there is a
    //  record to scan we do the following loop.
    //

    Repinned = &IrpContext->Repinned;
    RaiseIosb.Status = STATUS_SUCCESS;

    //
    //  If the request is write through or the media is deferred flush,
    //  unpin the bcb's write through.
    //

    WriteThroughToDisk = (BOOLEAN) (!FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_WRITE_THROUGH) &&
                                    IrpContext->Vcb != NULL &&
                                    (FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH) ||
                                     FlagOn(IrpContext->Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH)));

    while (Repinned != NULL) {

        //
        //  For every non-null entry in the repinned record unpin the
        //  repinned entry.
        //
        //  If the this is removable media (therefore all requests write-
        //  through) and the write fails, purge the cache so that we throw
        //  away the modifications as we will be returning an error to the
        //  user.
        //

        for (i = 0; i < REPINNED_BCBS_ARRAY_SIZE; i += 1) {

            if (Repinned->Bcb[i] != NULL) {

                IO_STATUS_BLOCK Iosb;

                if (WriteThroughToDisk && 
                    FlagOn(IrpContext->Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH)) {

                    FileObject = CcGetFileObjectFromBcb( Repinned->Bcb[i] );
                }

                CcUnpinRepinnedBcb( Repinned->Bcb[i],
                                    WriteThroughToDisk,
                                    &Iosb );

                if ( !NT_SUCCESS(Iosb.Status) ) {

                    if (RaiseIosb.Status == STATUS_SUCCESS) {

                        RaiseIosb = Iosb;
                    }

                    //
                    //  If this was a writethrough device, purge the cache,
                    //  except for Irp major codes that either don't handle
                    //  the error paths correctly or are simple victims like
                    //  cleanup.c.
                    //

                    if (FileObject &&
                        (IrpContext->MajorFunction != IRP_MJ_CLEANUP) &&
                        (IrpContext->MajorFunction != IRP_MJ_FLUSH_BUFFERS) &&
                        (IrpContext->MajorFunction != IRP_MJ_SET_INFORMATION)) {

                        //
                        //  The call to CcPurgeCacheSection() below will
                        //  purge the entire file from memory.  It will also
                        //  block until all the file's BCB's are pinned.
                        //
                        //  We end up in a deadlock situation of there
                        //  are any other pinned BCB's in this IRP context
                        //  so the first thing we do is search the list
                        //  for BCB's pinned in the same file and unpin
                        //  them.
                        //
                        //  We are probably not going to lose data because
                        //  it's safe to assume that all flushes will
                        //  fail after the first one fails.
                        //

                        ULONG j;

                        for (j = i + 1; j < REPINNED_BCBS_ARRAY_SIZE; j++) {

                            if (Repinned->Bcb[j] != NULL) {
                                
                                if (CcGetFileObjectFromBcb( Repinned->Bcb[j] ) == FileObject) {

                                    CcUnpinRepinnedBcb( Repinned->Bcb[j],
                                                        FALSE,
                                                        &Iosb );
                    
                                    Repinned->Bcb[j] = NULL;
                                }
                            }
                        }
                        
                        CcPurgeCacheSection( FileObject->SectionObjectPointer,
                                             NULL,
                                             0,
                                             FALSE );

                        //
                        //  Force a verify operation here since who knows
                        //  what state things are in.
                        //

                        ForceVerify = TRUE;
                    }
                }

                Repinned->Bcb[i] = NULL;

            }
        }

        //
        //  Now find the next repinned record in the list, and possibly
        //  delete the one we've just processed.
        //

        if (Repinned != &IrpContext->Repinned) {

            PREPINNED_BCBS Saved;

            Saved = Repinned->Next;
            ExFreePool( Repinned );
            Repinned = Saved;

        } else {

            Repinned = Repinned->Next;
            IrpContext->Repinned.Next = NULL;
        }
    }

    //
    //  Now if we weren't completely successful in the our unpin
    //  then raise the iosb we got
    //

    if (!NT_SUCCESS(RaiseIosb.Status)) {

        if (ForceVerify && FileObject) {

            SetFlag(FileObject->DeviceObject->Flags, DO_VERIFY_VOLUME);

            IoSetHardErrorOrVerifyDevice( IrpContext->OriginatingIrp,
                                          FileObject->DeviceObject );
        }

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_RAISE )) {
            
            IrpContext->OriginatingIrp->IoStatus = RaiseIosb;
            FatNormalizeAndRaiseStatus( IrpContext, RaiseIosb.Status );
        }
    }

    DebugTrace(-1, Dbg, "FatUnpinRepinnedBcbs -> VOID\n", 0 );

    return;
}


FINISHED
FatZeroData (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ULONG StartingZero,
    IN ULONG ByteCount
    )

/*++

    **** Temporary function - Remove when CcZeroData is capable of handling
    non sector aligned requests.

--*/
{
    LARGE_INTEGER ZeroStart = {0,0};
    LARGE_INTEGER BeyondZeroEnd = {0,0};

    ULONG SectorSize;

    BOOLEAN Finished;

    PAGED_CODE();
    
    SectorSize = (ULONG)Vcb->Bpb.BytesPerSector;

    ZeroStart.LowPart = (StartingZero + (SectorSize - 1)) & ~(SectorSize - 1);

    //
    //  Detect overflow if we were asked to zero in the last sector of the file,
    //  which must be "zeroed" already (or we're in trouble).
    //
    
    if (StartingZero != 0 && ZeroStart.LowPart == 0) {
        
        return TRUE;
    }

    //
    //  Note that BeyondZeroEnd can take the value 4gb.
    //
    
    BeyondZeroEnd.QuadPart = ((ULONGLONG) StartingZero + ByteCount + (SectorSize - 1))
                             & (~((LONGLONG) SectorSize - 1));

    //
    //  If we were called to just zero part of a sector we are in trouble.
    //
    
    if ( ZeroStart.QuadPart == BeyondZeroEnd.QuadPart ) {

        return TRUE;
    }

    Finished = CcZeroData( FileObject,
                           &ZeroStart,
                           &BeyondZeroEnd,
                           BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

    return Finished;
}


NTSTATUS
FatCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the function of completing Mdl read and write
    requests.  It should be called only from FatFsdRead and FatFsdWrite.

Arguments:

    Irp - Supplies the originating Irp.

Return Value:

    NTSTATUS - Will always be STATUS_PENDING or STATUS_SUCCESS.

--*/

{
    PFILE_OBJECT FileObject;
    PIO_STACK_LOCATION IrpSp;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatCompleteMdl\n", 0 );
    DebugTrace( 0, Dbg, "IrpContext = %08lx\n", IrpContext );
    DebugTrace( 0, Dbg, "Irp        = %08lx\n", Irp );

    //
    // Do completion processing.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    switch( IrpContext->MajorFunction ) {

    case IRP_MJ_READ:

        CcMdlReadComplete( FileObject, Irp->MdlAddress );
        break;

    case IRP_MJ_WRITE:

        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        ASSERT( FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT ));

        CcMdlWriteComplete( FileObject, &IrpSp->Parameters.Write.ByteOffset, Irp->MdlAddress );

        Irp->IoStatus.Status = STATUS_SUCCESS;

        break;

    default:

        DebugTrace( DEBUG_TRACE_ERROR, 0, "Illegal Mdl Complete.\n", 0);
        FatBugCheck( IrpContext->MajorFunction, 0, 0 );
    }

    //
    // Mdl is now deallocated.
    //

    Irp->MdlAddress = NULL;

    //
    // Complete the request and exit right away.
    //

    FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    DebugTrace(-1, Dbg, "FatCompleteMdl -> STATUS_SUCCESS\n", 0 );

    return STATUS_SUCCESS;
}

VOID
FatSyncUninitializeCacheMap (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    The routine performs a CcUnitializeCacheMap to LargeZero synchronously.  That
    is it waits on the Cc event.  This call is useful when we want to be certain
    when a close will actually some in.

Return Value:

    None.

--*/

{
    CACHE_UNINITIALIZE_EVENT UninitializeCompleteEvent;
    NTSTATUS WaitStatus;

    PAGED_CODE();
    
    KeInitializeEvent( &UninitializeCompleteEvent.Event,
                       SynchronizationEvent,
                       FALSE);

    CcUninitializeCacheMap( FileObject,
                            &FatLargeZero,
                            &UninitializeCompleteEvent );

    //
    //  Now wait for the cache manager to finish purging the file.
    //  This will garentee that Mm gets the purge before we
    //  delete the Vcb.
    //

    WaitStatus = KeWaitForSingleObject( &UninitializeCompleteEvent.Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

    ASSERT(WaitStatus == STATUS_SUCCESS);
}

VOID
FatPinMappedData (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine pins data that was previously mapped before setting it dirty.

Arguments:

    Dcb - Pointer to the DCB for the directory

    StartingVbo - The virtual offset of the first desired byte

    ByteCount - Number of bytes desired

    Bcb - Returns a pointer to the BCB which is valid until unpinned

--*/

{
    LARGE_INTEGER Vbo;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatPinMappedData\n", 0);
    DebugTrace( 0, Dbg, "Dcb         = %08lx\n", Dcb);
    DebugTrace( 0, Dbg, "StartingVbo = %08lx\n", StartingVbo);
    DebugTrace( 0, Dbg, "ByteCount   = %08lx\n", ByteCount);

    //
    //  Call the Cache manager to perform the operation.
    //

    Vbo.QuadPart = StartingVbo;

    if (!CcPinMappedData( Dcb->Specific.Dcb.DirectoryFile,
                          &Vbo,
                          ByteCount,
                          BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                          Bcb )) {

        //
        // Could not pin the data without waiting (cache miss).
        //

        FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    DebugTrace(-1, Dbg, "FatReadDirectoryFile -> VOID, *BCB = %08lx\n", *Bcb);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\create.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Fat called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_CREATE)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)


//
//  Macros for incrementing performance counters.
//

#define CollectCreateHitStatistics(VCB) {                                                \
    PFILE_SYSTEM_STATISTICS Stats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()];   \
    Stats->Fat.CreateHits += 1;                                                          \
}

#define CollectCreateStatistics(VCB,STATUS) {                                            \
    PFILE_SYSTEM_STATISTICS Stats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()];   \
    if ((STATUS) == STATUS_SUCCESS) {                                                    \
        Stats->Fat.SuccessfulCreates += 1;                                               \
    } else {                                                                             \
        Stats->Fat.FailedCreates += 1;                                                   \
    }                                                                                    \
}

LUID FatSecurityPrivilege = { SE_SECURITY_PRIVILEGE, 0 };

//
//  local procedure prototypes
//

IO_STATUS_BLOCK
FatOpenVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition
    );

IO_STATUS_BLOCK
FatOpenRootDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition
    );

IO_STATUS_BLOCK
FatOpenExistingDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB Dcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose
    );

IO_STATUS_BLOCK
FatOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN ULONG CreateDisposition,
    IN BOOLEAN DeleteOnClose,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN FileNameOpenedDos,
    OUT PBOOLEAN OplockPostIrp
    );

IO_STATUS_BLOCK
FatOpenTargetDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PDCB Dcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN BOOLEAN DoesNameExist
    );

IO_STATUS_BLOCK
FatOpenExistingDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN PDIRENT Dirent,
    IN ULONG LfnByteOffset,
    IN ULONG DirentByteOffset,
    IN PUNICODE_STRING Lfn,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose
    );

IO_STATUS_BLOCK
FatOpenExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN PDIRENT Dirent,
    IN ULONG LfnByteOffset,
    IN ULONG DirentByteOffset,
    IN PUNICODE_STRING Lfn,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN ULONG CreateDisposition,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose,
    IN BOOLEAN FileNameOpenedDos
    );

IO_STATUS_BLOCK
FatCreateNewDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN POEM_STRING OemName,
    IN PUNICODE_STRING UnicodeName,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose
    );

IO_STATUS_BLOCK
FatCreateNewFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN POEM_STRING OemName,
    IN PUNICODE_STRING UnicodeName,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN PUNICODE_STRING LfnBuffer,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose,
    IN BOOLEAN TemporaryFile
    );

IO_STATUS_BLOCK
FatSupersedeOrOverwriteFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN ULONG CreateDisposition,
    IN BOOLEAN NoEaKnowledge
    );

NTSTATUS
FatCheckSystemSecurityAccess(
    PIRP_CONTEXT IrpContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCheckSystemSecurityAccess)
#pragma alloc_text(PAGE, FatCommonCreate)
#pragma alloc_text(PAGE, FatCreateNewDirectory)
#pragma alloc_text(PAGE, FatCreateNewFile)
#pragma alloc_text(PAGE, FatFsdCreate)
#pragma alloc_text(PAGE, FatOpenExistingDcb)
#pragma alloc_text(PAGE, FatOpenExistingDirectory)
#pragma alloc_text(PAGE, FatOpenExistingFcb)
#pragma alloc_text(PAGE, FatOpenExistingFile)
#pragma alloc_text(PAGE, FatOpenRootDcb)
#pragma alloc_text(PAGE, FatOpenTargetDirectory)
#pragma alloc_text(PAGE, FatOpenVolume)
#pragma alloc_text(PAGE, FatSupersedeOrOverwriteFile)
#pragma alloc_text(PAGE, FatSetFullNameInFcb)
#endif


NTSTATUS
FatFsdCreate (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateFile and NtOpenFile
    API calls.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file/directory exists that we are trying to open/create

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if ( FatDeviceIsFatFsdo( VolumeDeviceObject))  {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    TimerStart(Dbg);

    DebugTrace(+1, Dbg, "FatFsdCreate\n", 0);

    //
    //  Call the common create routine, with block allowed if the operation
    //  is synchronous.
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, TRUE );

        Status = FatCommonCreate( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdCreate -> %08lx\n", Status );

    TimerStop(Dbg,"FatFsdCreate");

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}



NTSTATUS
FatCommonCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file called by
    both the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    PFILE_OBJECT RelatedFileObject;
    UNICODE_STRING FileName;
    ULONG AllocationSize;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    PACCESS_MASK DesiredAccess;
    ULONG Options;
    UCHAR FileAttributes;
    USHORT ShareAccess;
    ULONG EaLength;

    BOOLEAN CreateDirectory;
    BOOLEAN SequentialOnly;
    BOOLEAN NoIntermediateBuffering;
    BOOLEAN OpenDirectory;
    BOOLEAN IsPagingFile;
    BOOLEAN OpenTargetDirectory;
    BOOLEAN DirectoryFile;
    BOOLEAN NonDirectoryFile;
    BOOLEAN NoEaKnowledge;
    BOOLEAN DeleteOnClose;
    BOOLEAN TemporaryFile;
    BOOLEAN FileNameOpenedDos = FALSE;

    ULONG CreateDisposition;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;
    PDCB ParentDcb;
    PDCB FinalDcb = NULL;

    UNICODE_STRING FinalName;
    UNICODE_STRING RemainingPart;
    UNICODE_STRING NextRemainingPart;
    UNICODE_STRING UpcasedFinalName;
    WCHAR UpcasedBuffer[ FAT_CREATE_INITIAL_NAME_BUF_SIZE];

    OEM_STRING OemFinalName;
    UCHAR OemBuffer[ FAT_CREATE_INITIAL_NAME_BUF_SIZE*2];

    BOOLEAN FreeOemBuffer;
    BOOLEAN FreeUpcasedBuffer;

    PDIRENT Dirent;
    PBCB DirentBcb = NULL;
    ULONG LfnByteOffset;
    ULONG DirentByteOffset;

    BOOLEAN PostIrp = FALSE;
    BOOLEAN OplockPostIrp = FALSE;
    BOOLEAN TrailingBackslash;
    BOOLEAN FirstLoop = TRUE;

    CCB LocalCcb;
    UNICODE_STRING Lfn;
    WCHAR LfnBuffer[ FAT_CREATE_INITIAL_NAME_BUF_SIZE];

    //
    //  Get the current IRP stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonCreate\n", 0 );
    DebugTrace( 0, Dbg, "Irp                       = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "->Flags                   = %08lx\n", Irp->Flags );
    DebugTrace( 0, Dbg, "->FileObject              = %08lx\n", IrpSp->FileObject );
    DebugTrace( 0, Dbg, " ->RelatedFileObject      = %08lx\n", IrpSp->FileObject->RelatedFileObject );
    DebugTrace( 0, Dbg, " ->FileName               = %Z\n",    &IrpSp->FileObject->FileName );
    DebugTrace( 0, Dbg, "->AllocationSize.LowPart  = %08lx\n", Irp->Overlay.AllocationSize.LowPart );
    DebugTrace( 0, Dbg, "->AllocationSize.HighPart = %08lx\n", Irp->Overlay.AllocationSize.HighPart );
    DebugTrace( 0, Dbg, "->SystemBuffer            = %08lx\n", Irp->AssociatedIrp.SystemBuffer );
    DebugTrace( 0, Dbg, "->DesiredAccess           = %08lx\n", IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
    DebugTrace( 0, Dbg, "->Options                 = %08lx\n", IrpSp->Parameters.Create.Options );
    DebugTrace( 0, Dbg, "->FileAttributes          = %04x\n",  IrpSp->Parameters.Create.FileAttributes );
    DebugTrace( 0, Dbg, "->ShareAccess             = %04x\n",  IrpSp->Parameters.Create.ShareAccess );
    DebugTrace( 0, Dbg, "->EaLength                = %08lx\n", IrpSp->Parameters.Create.EaLength );

    //
    //  This is here because the Win32 layer can't avoid sending me double
    //  beginning backslashes.
    //

    if ((IrpSp->FileObject->FileName.Length > sizeof(WCHAR)) &&
        (IrpSp->FileObject->FileName.Buffer[1] == L'\\') &&
        (IrpSp->FileObject->FileName.Buffer[0] == L'\\')) {

        IrpSp->FileObject->FileName.Length -= sizeof(WCHAR);

        RtlMoveMemory( &IrpSp->FileObject->FileName.Buffer[0],
                       &IrpSp->FileObject->FileName.Buffer[1],
                       IrpSp->FileObject->FileName.Length );

        //
        //  If there are still two beginning backslashes, the name is bogus.
        //

        if ((IrpSp->FileObject->FileName.Length > sizeof(WCHAR)) &&
            (IrpSp->FileObject->FileName.Buffer[1] == L'\\') &&
            (IrpSp->FileObject->FileName.Buffer[0] == L'\\')) {

            FatCompleteRequest( IrpContext, Irp, STATUS_OBJECT_NAME_INVALID );

            DebugTrace(-1, Dbg, "FatCommonCreate -> STATUS_OBJECT_NAME_INVALID\n", 0);
            return STATUS_OBJECT_NAME_INVALID;
        }
    }

    //
    //  Reference our input parameters to make things easier
    //

    ASSERT( IrpSp->Parameters.Create.SecurityContext != NULL );
    
    FileObject        = IrpSp->FileObject;
    FileName          = FileObject->FileName;
    RelatedFileObject = FileObject->RelatedFileObject;
    AllocationSize    = Irp->Overlay.AllocationSize.LowPart;
    EaBuffer          = Irp->AssociatedIrp.SystemBuffer;
    DesiredAccess     = &IrpSp->Parameters.Create.SecurityContext->DesiredAccess;
    Options           = IrpSp->Parameters.Create.Options;
    FileAttributes    = (UCHAR)(IrpSp->Parameters.Create.FileAttributes & ~FILE_ATTRIBUTE_NORMAL);
    ShareAccess       = IrpSp->Parameters.Create.ShareAccess;
    EaLength          = IrpSp->Parameters.Create.EaLength;


    //
    //  Set up the file object's Vpb pointer in case anything happens.
    //  This will allow us to get a reasonable pop-up.
    //

    if ( RelatedFileObject != NULL ) {
        FileObject->Vpb = RelatedFileObject->Vpb;
    }

    //
    //  Force setting the archive bit in the attributes byte to follow OS/2,
    //  & DOS semantics.  Also mask out any extraneous bits, note that
    //  we can't use the ATTRIBUTE_VALID_FLAGS constant because that has
    //  the control and normal flags set.
    //
    //  Delay setting ARCHIVE in case this is a directory: DavidGoe 2/16/95
    //

    FileAttributes   &= (FILE_ATTRIBUTE_READONLY |
                         FILE_ATTRIBUTE_HIDDEN   |
                         FILE_ATTRIBUTE_SYSTEM   |
                         FILE_ATTRIBUTE_ARCHIVE );

    //
    //  Locate the volume device object and Vcb that we are trying to access
    //

    Vcb = &((PVOLUME_DEVICE_OBJECT)IrpSp->DeviceObject)->Vcb;

    //
    //  Decipher Option flags and values
    //

    //
    //  If this is an open by fileid operation, just fail it explicitly.  FAT's
    //  source of fileids is not reversible for open operations.
    //

    if (BooleanFlagOn( Options, FILE_OPEN_BY_FILE_ID )) {

        FatCompleteRequest( IrpContext, Irp, STATUS_NOT_IMPLEMENTED );
        return STATUS_NOT_IMPLEMENTED;
    }

    DirectoryFile           = BooleanFlagOn( Options, FILE_DIRECTORY_FILE );
    NonDirectoryFile        = BooleanFlagOn( Options, FILE_NON_DIRECTORY_FILE );
    SequentialOnly          = BooleanFlagOn( Options, FILE_SEQUENTIAL_ONLY );
    NoIntermediateBuffering = BooleanFlagOn( Options, FILE_NO_INTERMEDIATE_BUFFERING );
    NoEaKnowledge           = BooleanFlagOn( Options, FILE_NO_EA_KNOWLEDGE );
    DeleteOnClose           = BooleanFlagOn( Options, FILE_DELETE_ON_CLOSE );

    TemporaryFile = BooleanFlagOn( IrpSp->Parameters.Create.FileAttributes,
                                   FILE_ATTRIBUTE_TEMPORARY );

    CreateDisposition = (Options >> 24) & 0x000000ff;

    IsPagingFile = BooleanFlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE );
    OpenTargetDirectory = BooleanFlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY );

    CreateDirectory = (BOOLEAN)(DirectoryFile &&
                                ((CreateDisposition == FILE_CREATE) ||
                                 (CreateDisposition == FILE_OPEN_IF)));

    OpenDirectory   = (BOOLEAN)(DirectoryFile &&
                                ((CreateDisposition == FILE_OPEN) ||
                                 (CreateDisposition == FILE_OPEN_IF)));
    
    
    //
    //  Make sure the input large integer is valid and that the dir/nondir
    //  indicates a storage type we understand.
    //

    if (Irp->Overlay.AllocationSize.HighPart != 0 ||
        (DirectoryFile && NonDirectoryFile)) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatCommonCreate -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the vcb, and enqueue the Irp if
    //  we didn't get it.
    //

    if (!FatAcquireExclusiveVcb( IrpContext, Vcb )) {

        DebugTrace(0, Dbg, "Cannot acquire Vcb\n", 0);

        Iosb.Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatCommonCreate -> %08lx\n", Iosb.Status );
        return Iosb.Status;
    }

    //
    //  Initialize the DirentBcb to null
    //

    DirentBcb = NULL;

    //
    //  Initialize our temp strings with their stack buffers.
    //

    OemFinalName.Length = 0;
    OemFinalName.MaximumLength = sizeof( OemBuffer);
    OemFinalName.Buffer = OemBuffer;

    UpcasedFinalName.Length = 0;
    UpcasedFinalName.MaximumLength = sizeof( UpcasedBuffer);
    UpcasedFinalName.Buffer = UpcasedBuffer;

    Lfn.Length = 0;
    Lfn.MaximumLength = sizeof( LfnBuffer);
    Lfn.Buffer = LfnBuffer;

    try {

        //
        //  Make sure the vcb is in a usable condition.  This will raise
        //  and error condition if the volume is unusable
        //

        FatVerifyVcb( IrpContext, Vcb );

        //
        //  If the Vcb is locked then we cannot open another file
        //

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED)) {

            DebugTrace(0, Dbg, "Volume is locked\n", 0);

            Status = STATUS_ACCESS_DENIED;
            if (Vcb->VcbCondition != VcbGood) {

                Status = STATUS_VOLUME_DISMOUNTED;
            }
            try_return( Iosb.Status = Status );
        }

        //
        //  Don't allow the DELETE_ON_CLOSE option if the volume is
        //  write-protected.
        //

        if (DeleteOnClose && FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

            //
            //  Set the real device for the pop-up info, and set the verify
            //  bit in the device object, so that we will force a verify
            //  in case the user put the correct media back in.
            //

            IoSetHardErrorOrVerifyDevice( IrpContext->OriginatingIrp,
                                          Vcb->Vpb->RealDevice );

            SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);

            FatRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED );
        }

        //
        //  If this is a fat32 volume, EA's are not supported.
        //

        if (EaBuffer != NULL &&
            FatIsFat32(Vcb)) {

            try_return( Iosb.Status = STATUS_EAS_NOT_SUPPORTED );
        }

        //
        //  Check if we are opening the volume and not a file/directory.
        //  We are opening the volume if the name is empty and there
        //  isn't a related file object.  If there is a related file object
        //  then it is the Vcb itself.
        //

        if (FileName.Length == 0) {
             
            PVCB DecodeVcb;
            
            if (RelatedFileObject == NULL ||
                FatDecodeFileObject( RelatedFileObject,
                                     &DecodeVcb,
                                     &Fcb,
                                     &Ccb ) == UserVolumeOpen) {

                ASSERT( RelatedFileObject == NULL || Vcb == DecodeVcb );
                
                //
                //  Check if we were to open a directory
                //
        
                if (DirectoryFile) {
        
                    DebugTrace(0, Dbg, "Cannot open volume as a directory\n", 0);
        
                    try_return( Iosb.Status = STATUS_NOT_A_DIRECTORY );
                }
        
                //
                //  Can't open the TargetDirectory of the DASD volume.
                //
        
                if (OpenTargetDirectory) {
        
                    try_return( Iosb.Status = STATUS_INVALID_PARAMETER );
                }
        
                DebugTrace(0, Dbg, "Opening the volume, Vcb = %08lx\n", Vcb);
        
                CollectCreateHitStatistics(Vcb);
        
                Iosb = FatOpenVolume( IrpContext,
                                      FileObject,
                                      Vcb,
                                      DesiredAccess,
                                      ShareAccess,
                                      CreateDisposition );
        
                Irp->IoStatus.Information = Iosb.Information;
                try_return( Iosb.Status );
            }
        }

        //
        //  If there is a related file object then this is a relative open.
        //  The related file object is the directory to start our search at.
        //  Return an error if it is not a directory.
        //

        if (RelatedFileObject != NULL) {

            PVCB RelatedVcb;
            PDCB RelatedDcb;
            PCCB RelatedCcb;
            TYPE_OF_OPEN TypeOfOpen;

            TypeOfOpen = FatDecodeFileObject( RelatedFileObject,
                                              &RelatedVcb,
                                              &RelatedDcb,
                                              &RelatedCcb );

            if (TypeOfOpen != UserFileOpen &&
                TypeOfOpen != UserDirectoryOpen) {

                DebugTrace(0, Dbg, "Invalid related file object\n", 0);

                try_return( Iosb.Status = STATUS_OBJECT_PATH_NOT_FOUND );
            }

            //
            //  A relative open must be via a relative path.
            //

            if (FileName.Length != 0 &&
                FileName.Buffer[0] == L'\\') {

                try_return( Iosb.Status = STATUS_OBJECT_NAME_INVALID );
            }

            //
            //  Set up the file object's Vpb pointer in case anything happens.
            //

            ASSERT( Vcb == RelatedVcb );

            FileObject->Vpb = RelatedFileObject->Vpb;

            ParentDcb = RelatedDcb;

        } else {

            //
            //  This is not a relative open, so check if we're
            //  opening the root dcb
            //
            
            if ((FileName.Length == sizeof(WCHAR)) &&
                (FileName.Buffer[0] == L'\\')) {

                //
                //  Check if we were not supposed to open a directory
                //

                if (NonDirectoryFile) {

                    DebugTrace(0, Dbg, "Cannot open root directory as a file\n", 0);

                    try_return( Iosb.Status = STATUS_FILE_IS_A_DIRECTORY );
                }

                //
                //  Can't open the TargetDirectory of the root directory.
                //

                if (OpenTargetDirectory) {

                    try_return( Iosb.Status = STATUS_INVALID_PARAMETER );
                }

                //
                //  Not allowed to delete root directory.
                //

                if (DeleteOnClose) {

                    try_return( Iosb.Status = STATUS_CANNOT_DELETE );
                }

                DebugTrace(0, Dbg, "Opening root dcb\n", 0);

                CollectCreateHitStatistics(Vcb);

                Iosb = FatOpenRootDcb( IrpContext,
                                       FileObject,
                                       Vcb,
                                       DesiredAccess,
                                       ShareAccess,
                                       CreateDisposition );

                Irp->IoStatus.Information = Iosb.Information;
                try_return( Iosb.Status );
            }

            //
            //  Nope, we will be opening relative to the root directory.
            //
            
            ParentDcb = Vcb->RootDcb;
        }

        //
        //  FatCommonCreate(): trailing backslash check
        //


        if ((FileName.Length != 0) &&
            (FileName.Buffer[FileName.Length/sizeof(WCHAR)-1] == L'\\')) {

            FileName.Length -= sizeof(WCHAR);
            TrailingBackslash = TRUE;

        } else {

            TrailingBackslash = FALSE;
        }

        //
        //  Check for max path.  We might want to tighten this down to DOS MAX_PATH
        //  for maximal interchange with non-NT platforms, but for now defer to the
        //  possibility of something depending on it.
        //

        if (ParentDcb->FullFileName.Buffer == NULL) {
            
            FatSetFullFileNameInFcb( IrpContext, ParentDcb );
        }

        if ((USHORT) (ParentDcb->FullFileName.Length + sizeof(WCHAR) + FileName.Length) <= FileName.Length) {

            try_return( Iosb.Status = STATUS_OBJECT_NAME_INVALID );
        }

        //
        //  We loop here until we land on an Fcb that is in a good
        //  condition.  This way we can reopen files that have stale handles
        //  to files of the same name but are now different.
        //

        while ( TRUE ) {

            Fcb = ParentDcb;
            RemainingPart = FileName;

            //
            //  Now walk down the Dcb tree looking for the longest prefix.
            //  This one exit condition in the while() is to handle a
            //  special case condition (relative NULL name open), the main
            //  exit conditions are at the bottom of the loop.
            //

            while (RemainingPart.Length != 0) {

                PFCB NextFcb;

                FsRtlDissectName( RemainingPart,
                                  &FinalName,
                                  &NextRemainingPart );

                //
                //  If RemainingPart starts with a backslash the name is
                //  invalid.
                //  Check for no more than 255 characters in FinalName
                //

                if (((NextRemainingPart.Length != 0) && (NextRemainingPart.Buffer[0] == L'\\')) ||
                    (FinalName.Length > 255*sizeof(WCHAR))) {

                    try_return( Iosb.Status = STATUS_OBJECT_NAME_INVALID );
                }

                //
                //  Now, try to convert this one component into Oem and search
                //  the splay tree.  If it works then that's great, otherwise
                //  we have to try with the UNICODE name instead.
                //

                FatEnsureStringBufferEnough( &OemFinalName, 
                                             FinalName.Length);

                Status = RtlUpcaseUnicodeStringToCountedOemString( &OemFinalName, &FinalName, FALSE );

                if (NT_SUCCESS(Status)) {

                    NextFcb = FatFindFcb( IrpContext,
                                          &Fcb->Specific.Dcb.RootOemNode,
                                          (PSTRING)&OemFinalName,
                                          &FileNameOpenedDos );

                } else {

                    NextFcb = NULL;
                    OemFinalName.Length = 0;

                    if (Status != STATUS_UNMAPPABLE_CHARACTER) {

                        try_return( Iosb.Status = Status );
                    }
                }

                //
                //  If we didn't find anything searching the Oem space, we
                //  have to try the Unicode space.  To save cycles in the
                //  common case that this tree is empty, we do a quick check
                //  here.
                //

                if ((NextFcb == NULL) && Fcb->Specific.Dcb.RootUnicodeNode) {

                    //
                    // First downcase, then upcase the string, because this
                    // is what happens when putting names into the tree (see
                    // strucsup.c, FatConstructNamesInFcb()).
                    //

                    FatEnsureStringBufferEnough( &UpcasedFinalName, 
                                                 FinalName.Length);

                    Status = RtlDowncaseUnicodeString(&UpcasedFinalName, &FinalName, FALSE );
                    ASSERT( NT_SUCCESS( Status ));

                    Status = RtlUpcaseUnicodeString( &UpcasedFinalName, &UpcasedFinalName, FALSE );
                    ASSERT( NT_SUCCESS( Status ));

                    NextFcb = FatFindFcb( IrpContext,
                                          &Fcb->Specific.Dcb.RootUnicodeNode,
                                          (PSTRING)&UpcasedFinalName,
                                          &FileNameOpenedDos );
                }

                //
                //  If we got back an Fcb then we consumed the FinalName
                //  legitimately, so the remaining name is now RemainingPart.
                //

                if (NextFcb != NULL) {
                    Fcb = NextFcb;
                    RemainingPart = NextRemainingPart;
                }

                if ((NextFcb == NULL) ||
                    (NodeType(NextFcb) == FAT_NTC_FCB) ||
                    (NextRemainingPart.Length == 0)) {

                    break;
                }
            }

            //
            //  Remaining name cannot start with a backslash
            //

            if (RemainingPart.Length && (RemainingPart.Buffer[0] == L'\\')) {

                RemainingPart.Length -= sizeof(WCHAR);
                RemainingPart.Buffer += 1;
            }

            //
            //  Now verify that everybody up to the longest found prefix is valid.
            //

            try {

                FatVerifyFcb( IrpContext, Fcb );

            } except( (GetExceptionCode() == STATUS_FILE_INVALID) ?
                      EXCEPTION_EXECUTE_HANDLER :
                      EXCEPTION_CONTINUE_SEARCH ) {

                  FatResetExceptionState( IrpContext );
            }

            if ( Fcb->FcbCondition == FcbGood ) {

                //
                //  If we are trying to open a paging file and have happened
                //  upon the DelayedCloseFcb, make it go away, and try again.
                //

                if (IsPagingFile && FirstLoop &&
                    (NodeType(Fcb) == FAT_NTC_FCB) &&
                    (!IsListEmpty( &FatData.AsyncCloseList ) ||
                     !IsListEmpty( &FatData.DelayedCloseList ))) {

                    FatFspClose(Vcb);

                    FirstLoop = FALSE;

                    continue;

                } else {

                    break;
                }

            } else {

                FatRemoveNames( IrpContext, Fcb );
            }
        }

        ASSERT( Fcb->FcbCondition == FcbGood );

        //
        //  If there is already an Fcb for a paging file open and
        //  it was not already opened as a paging file, we cannot
        //  continue as it is too difficult to move a live Fcb to
        //  non-paged pool.
        //

        if (IsPagingFile) {
             
            if (NodeType(Fcb) == FAT_NTC_FCB &&
                !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                try_return( Iosb.Status = STATUS_SHARING_VIOLATION );
            }
        
        //
        //  Check for a system file.
        //

        } else if (FlagOn( Fcb->FcbState, FCB_STATE_SYSTEM_FILE )) {

            try_return( Iosb.Status = STATUS_ACCESS_DENIED );
        }

        //
        //  If the longest prefix is pending delete (either the file or
        //  some higher level directory), we cannot continue.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE )) {

            try_return( Iosb.Status = STATUS_DELETE_PENDING );
        }

        //
        //  Now that we've found the longest matching prefix we'll
        //  check if there isn't any remaining part because that means
        //  we've located an existing fcb/dcb to open and we can do the open
        //  without going to the disk
        //

        if (RemainingPart.Length == 0) {

            //
            //  First check if the user wanted to open the target directory
            //  and if so then call the subroutine to finish the open.
            //

            if (OpenTargetDirectory) {

                CollectCreateHitStatistics(Vcb);

                Iosb = FatOpenTargetDirectory( IrpContext,
                                               FileObject,
                                               Fcb->ParentDcb,
                                               DesiredAccess,
                                               ShareAccess,
                                               TRUE );
                Irp->IoStatus.Information = Iosb.Information;
                try_return( Iosb.Status );
            }

            //
            //  We can open an existing fcb/dcb, now we only need to case
            //  on which type to open.
            //

            if (NodeType(Fcb) == FAT_NTC_DCB || NodeType(Fcb) == FAT_NTC_ROOT_DCB) {

                //
                //  This is a directory we're opening up so check if
                //  we were not to open a directory
                //

                if (NonDirectoryFile) {

                    DebugTrace(0, Dbg, "Cannot open directory as a file\n", 0);

                    try_return( Iosb.Status = STATUS_FILE_IS_A_DIRECTORY );
                }

                DebugTrace(0, Dbg, "Open existing dcb, Dcb = %08lx\n", Fcb);

                CollectCreateHitStatistics(Vcb);

                Iosb = FatOpenExistingDcb( IrpContext,
                                           FileObject,
                                           Vcb,
                                           (PDCB)Fcb,
                                           DesiredAccess,
                                           ShareAccess,
                                           CreateDisposition,
                                           NoEaKnowledge,
                                           DeleteOnClose );

                Irp->IoStatus.Information = Iosb.Information;
                try_return( Iosb.Status );
            }

            //
            //  Check if we're trying to open an existing Fcb and that
            //  the user didn't want to open a directory.  Note that this
            //  call might actually come back with status_pending because
            //  the user wanted to supersede or overwrite the file and we
            //  cannot block.  If it is pending then we do not complete the
            //  request, and we fall through the bottom to the code that
            //  dispatches the request to the fsp.
            //

            if (NodeType(Fcb) == FAT_NTC_FCB) {

                //
                //  Check if we were only to open a directory
                //

                if (OpenDirectory) {

                    DebugTrace(0, Dbg, "Cannot open file as directory\n", 0);

                    try_return( Iosb.Status = STATUS_NOT_A_DIRECTORY );
                }

                DebugTrace(0, Dbg, "Open existing fcb, Fcb = %08lx\n", Fcb);

                if ( TrailingBackslash ) {
                    try_return( Iosb.Status = STATUS_OBJECT_NAME_INVALID );
                }

                CollectCreateHitStatistics(Vcb);

                Iosb = FatOpenExistingFcb( IrpContext,
                                           FileObject,
                                           Vcb,
                                           Fcb,
                                           DesiredAccess,
                                           ShareAccess,
                                           AllocationSize,
                                           EaBuffer,
                                           EaLength,
                                           FileAttributes,
                                           CreateDisposition,
                                           NoEaKnowledge,
                                           DeleteOnClose,
                                           FileNameOpenedDos,
                                           &OplockPostIrp );

                if (Iosb.Status != STATUS_PENDING) {

                    //
                    //  Check if we need to set the cache support flag in
                    //  the file object
                    //

                    if (NT_SUCCESS( Iosb.Status) && !NoIntermediateBuffering) {

                        FileObject->Flags |= FO_CACHE_SUPPORTED;
                    }

                    Irp->IoStatus.Information = Iosb.Information;

                } else {

                    DebugTrace(0, Dbg, "Enqueue Irp to FSP\n", 0);

                    PostIrp = TRUE;
                }

                try_return( Iosb.Status );
            }

            //
            //  Not and Fcb or a Dcb so we bug check
            //

            FatBugCheck( NodeType(Fcb), (ULONG_PTR) Fcb, 0 );
        }

        //
        //  There is more in the name to parse than we have in existing
        //  fcbs/dcbs.  So now make sure that fcb we got for the largest
        //  matching prefix is really a dcb otherwise we can't go any
        //  further
        //

        if ((NodeType(Fcb) != FAT_NTC_DCB) && (NodeType(Fcb) != FAT_NTC_ROOT_DCB)) {

            DebugTrace(0, Dbg, "Cannot open file as subdirectory, Fcb = %08lx\n", Fcb);

            try_return( Iosb.Status = STATUS_OBJECT_PATH_NOT_FOUND );
        }

        //
        //  Otherwise we continue on processing the Irp and allowing ourselves
        //  to block for I/O as necessary.  Find/create additional dcb's for
        //  the one we're trying to open.  We loop until either remaining part
        //  is empty or we get a bad filename.  When we exit FinalName is
        //  the last name in the string we're after, and ParentDcb is the
        //  parent directory that will contain the opened/created
        //  file/directory.
        //
        //  Make sure the rest of the name is valid in at least the LFN
        //  character set (which just happens to be that of HPFS).
        //
        //  If we are not in ChicagoMode, use FAT symantics.
        //

        ParentDcb = Fcb;
        FirstLoop = TRUE;

        while (TRUE) {

            //
            //  We do one little optimization here on the first itterration of
            //  the loop since we know that we have already tried to convert
            //  FinalOemName from the original UNICODE.
            //

            if (FirstLoop) {

                FirstLoop = FALSE;
                RemainingPart = NextRemainingPart;
                Status = OemFinalName.Length ? STATUS_SUCCESS : STATUS_UNMAPPABLE_CHARACTER;

            } else {

                //
                //  Dissect the remaining part.
                //

                DebugTrace(0, Dbg, "Dissecting the name %Z\n", &RemainingPart);

                FsRtlDissectName( RemainingPart,
                                  &FinalName,
                                  &RemainingPart );

                //
                //  If RemainingPart starts with a backslash the name is
                //  invalid.
                //  Check for no more than 255 characters in FinalName
                //

                if (((RemainingPart.Length != 0) && (RemainingPart.Buffer[0] == L'\\')) ||
                    (FinalName.Length > 255*sizeof(WCHAR))) {

                    try_return( Iosb.Status = STATUS_OBJECT_NAME_INVALID );
                }

                //
                //  Now, try to convert this one component into Oem.  If it works
                //  then that's great, otherwise we have to try with the UNICODE
                //  name instead.
                //

                FatEnsureStringBufferEnough( &OemFinalName, 
                                             FinalName.Length);

                Status = RtlUpcaseUnicodeStringToCountedOemString( &OemFinalName, &FinalName, FALSE );
            }

            if (NT_SUCCESS(Status)) {

                //
                //  We'll start by trying to locate the dirent for the name.  Note
                //  that we already know that there isn't an Fcb/Dcb for the file
                //  otherwise we would have found it when we did our prefix lookup.
                //

                if (FatIsNameShortOemValid( IrpContext, OemFinalName, FALSE, FALSE, FALSE )) {

                    FatStringTo8dot3( IrpContext,
                                      OemFinalName,
                                      &LocalCcb.OemQueryTemplate.Constant );

                    LocalCcb.Flags = 0;

                } else {

                    LocalCcb.Flags = CCB_FLAG_SKIP_SHORT_NAME_COMPARE;
                }

            } else {

                LocalCcb.Flags = CCB_FLAG_SKIP_SHORT_NAME_COMPARE;

                if (Status != STATUS_UNMAPPABLE_CHARACTER) {

                    try_return( Iosb.Status = Status );
                }
            }

            //
            //  Now we know a lot about the final name, so do legal name
            //  checking here.
            //

            if (FatData.ChicagoMode) {

                if (!FatIsNameLongUnicodeValid( IrpContext, &FinalName, FALSE, FALSE, FALSE )) {

                    try_return( Iosb.Status = STATUS_OBJECT_NAME_INVALID );
                }

            } else {

                if (FlagOn(LocalCcb.Flags, CCB_FLAG_SKIP_SHORT_NAME_COMPARE)) {

                    try_return( Iosb.Status = STATUS_OBJECT_NAME_INVALID );
                }
            }

            DebugTrace(0, Dbg, "FinalName is %Z\n", &FinalName);
            DebugTrace(0, Dbg, "RemainingPart is %Z\n", &RemainingPart);

            FatEnsureStringBufferEnough( &UpcasedFinalName, 
                                         FinalName.Length);
            
            if (!NT_SUCCESS(Status = RtlUpcaseUnicodeString( &UpcasedFinalName, &FinalName, FALSE))) {

                try_return( Iosb.Status = Status );
            }

            LocalCcb.UnicodeQueryTemplate =  UpcasedFinalName;
            LocalCcb.ContainsWildCards = FALSE;

            Lfn.Length = 0;

            FatLocateDirent( IrpContext,
                             ParentDcb,
                             &LocalCcb,
                             0,
                             &Dirent,
                             &DirentBcb,
                             &DirentByteOffset,
                             &FileNameOpenedDos,
                             &Lfn);
            //
            //  Remember we read this Dcb for error recovery.
            //

            FinalDcb = ParentDcb;

            //
            //  If the remaining part is now empty then this is the last name
            //  in the string and the one we want to open
            //

            if (RemainingPart.Length == 0) { break; }

            //
            //  We didn't find a dirent, bail.
            //

            if (Dirent == NULL) {

                Iosb.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                try_return( Iosb.Status );
            }

            //
            //  We now have a dirent, make sure it is a directory
            //

            if (!FlagOn( Dirent->Attributes, FAT_DIRENT_ATTR_DIRECTORY )) {

                Iosb.Status = STATUS_OBJECT_PATH_NOT_FOUND;
                try_return( Iosb.Status );
            }

            //
            //  Compute the LfnByteOffset.
            //

            LfnByteOffset = DirentByteOffset -
                            FAT_LFN_DIRENTS_NEEDED(&Lfn) * sizeof(LFN_DIRENT);

            //
            //  Create a dcb for the new directory
            //

            ParentDcb = FatCreateDcb( IrpContext,
                                      Vcb,
                                      ParentDcb,
                                      LfnByteOffset,
                                      DirentByteOffset,
                                      Dirent,
                                      &Lfn );

            //
            //  Remember we created this Dcb for error recovery.
            //

            FinalDcb = ParentDcb;

            FatSetFullNameInFcb( IrpContext, ParentDcb, &FinalName );
        }

        //
        //  First check if the user wanted to open the target directory
        //  and if so then call the subroutine to finish the open.
        //

        if (OpenTargetDirectory) {

            Iosb = FatOpenTargetDirectory( IrpContext,
                                           FileObject,
                                           ParentDcb,
                                           DesiredAccess,
                                           ShareAccess,
                                           Dirent ? TRUE : FALSE);

            Irp->IoStatus.Information = Iosb.Information;
            try_return( Iosb.Status );
        }

        if (Dirent != NULL) {

            //
            //  Compute the LfnByteOffset.
            //

            LfnByteOffset = DirentByteOffset -
                            FAT_LFN_DIRENTS_NEEDED(&Lfn) * sizeof(LFN_DIRENT);

            //
            //  We were able to locate an existing dirent entry, so now
            //  see if it is a directory that we're trying to open.
            //

            if (FlagOn( Dirent->Attributes, FAT_DIRENT_ATTR_DIRECTORY )) {

                //
                //  Make sure its okay to open a directory
                //

                if (NonDirectoryFile) {

                    DebugTrace(0, Dbg, "Cannot open directory as a file\n", 0);

                    try_return( Iosb.Status = STATUS_FILE_IS_A_DIRECTORY );
                }

                DebugTrace(0, Dbg, "Open existing directory\n", 0);

                Iosb = FatOpenExistingDirectory( IrpContext,
                                                 FileObject,
                                                 Vcb,
                                                 ParentDcb,
                                                 Dirent,
                                                 LfnByteOffset,
                                                 DirentByteOffset,
                                                 &Lfn,
                                                 DesiredAccess,
                                                 ShareAccess,
                                                 CreateDisposition,
                                                 NoEaKnowledge,
                                                 DeleteOnClose );
                Irp->IoStatus.Information = Iosb.Information;
                try_return( Iosb.Status );
            }

            //
            //  Otherwise we're trying to open and existing file, and we
            //  need to check if the user only wanted to open a directory.
            //

            if (OpenDirectory) {

                DebugTrace(0, Dbg, "Cannot open file as directory\n", 0);

                try_return( Iosb.Status = STATUS_NOT_A_DIRECTORY );
            }

            DebugTrace(0, Dbg, "Open existing file\n", 0);

            if ( TrailingBackslash ) {
               try_return( Iosb.Status = STATUS_OBJECT_NAME_INVALID );
            }

            Iosb = FatOpenExistingFile( IrpContext,
                                        FileObject,
                                        Vcb,
                                        ParentDcb,
                                        Dirent,
                                        LfnByteOffset,
                                        DirentByteOffset,
                                        &Lfn,
                                        DesiredAccess,
                                        ShareAccess,
                                        AllocationSize,
                                        EaBuffer,
                                        EaLength,
                                        FileAttributes,
                                        CreateDisposition,
                                        IsPagingFile,
                                        NoEaKnowledge,
                                        DeleteOnClose,
                                        FileNameOpenedDos );

            //
            //  Check if we need to set the cache support flag in
            //  the file object
            //

            if (NT_SUCCESS(Iosb.Status) && !NoIntermediateBuffering) {

                FileObject->Flags |= FO_CACHE_SUPPORTED;
            }

            Irp->IoStatus.Information = Iosb.Information;
            try_return( Iosb.Status );
        }

        //
        //  We can't locate a dirent so this is a new file.
        //

        //
        //  Now check to see if we wanted to only open an existing file.
        //  And then case on whether we wanted to create a file or a directory.
        //

        if ((CreateDisposition == FILE_OPEN) ||
            (CreateDisposition == FILE_OVERWRITE)) {

            DebugTrace( 0, Dbg, "Cannot open nonexisting file\n", 0);

            try_return( Iosb.Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        //
        //  Skip a few cycles later if we know now that the Oem name is not
        //  valid 8.3.
        //

        if (FlagOn(LocalCcb.Flags, CCB_FLAG_SKIP_SHORT_NAME_COMPARE)) {

            OemFinalName.Length = 0;
        }

        //
        //  Determine the granted access for this operation now.
        //

        if (!NT_SUCCESS( Iosb.Status = FatCheckSystemSecurityAccess( IrpContext ))) {

            try_return( Iosb );
        }

        if (CreateDirectory) {

            DebugTrace(0, Dbg, "Create new directory\n", 0);

            //
            //  If this media is write protected, don't even try the create.
            //

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

                //
                //  Set the real device for the pop-up info, and set the verify
                //  bit in the device object, so that we will force a verify
                //  in case the user put the correct media back in.
                //


                IoSetHardErrorOrVerifyDevice( IrpContext->OriginatingIrp,
                                              Vcb->Vpb->RealDevice );

                SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);

                FatRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED );
            }

            //
            //  Don't allow people to create directories with the
            //  temporary bit set.
            //

            if (TemporaryFile) {

                try_return( Iosb.Status = STATUS_INVALID_PARAMETER );
            }

            Iosb = FatCreateNewDirectory( IrpContext,
                                          FileObject,
                                          Vcb,
                                          ParentDcb,
                                          &OemFinalName,
                                          &FinalName,
                                          DesiredAccess,
                                          ShareAccess,
                                          EaBuffer,
                                          EaLength,
                                          FileAttributes,
                                          NoEaKnowledge,
                                          DeleteOnClose );

            Irp->IoStatus.Information = Iosb.Information;
            try_return( Iosb.Status );
        }

        DebugTrace(0, Dbg, "Create new file\n", 0);

        if ( TrailingBackslash ) {
           
            try_return( Iosb.Status = STATUS_OBJECT_NAME_INVALID );
        }

        //
        //  If this media is write protected, don't even try the create.
        //

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

            //
            //  Set the real device for the pop-up info, and set the verify
            //  bit in the device object, so that we will force a verify
            //  in case the user put the correct media back in.
            //


            IoSetHardErrorOrVerifyDevice( IrpContext->OriginatingIrp,
                                          Vcb->Vpb->RealDevice );

            SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);

            FatRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED );
        }

        Iosb = FatCreateNewFile( IrpContext,
                                 FileObject,
                                 Vcb,
                                 ParentDcb,
                                 &OemFinalName,
                                 &FinalName,
                                 DesiredAccess,
                                 ShareAccess,
                                 AllocationSize,
                                 EaBuffer,
                                 EaLength,
                                 FileAttributes,
                                 &Lfn,
                                 IsPagingFile,
                                 NoEaKnowledge,
                                 DeleteOnClose,
                                 TemporaryFile );

        //
        //  Check if we need to set the cache support flag in
        //  the file object
        //

        if (NT_SUCCESS(Iosb.Status) && !NoIntermediateBuffering) {

            FileObject->Flags |= FO_CACHE_SUPPORTED;
        }

        Irp->IoStatus.Information = Iosb.Information;

    try_exit: NOTHING;

        //
        //  This is a Beta Fix.  Do this at a better place later.
        //

        if (NT_SUCCESS(Iosb.Status) && !OpenTargetDirectory) {

            PFCB Fcb;

            //
            //  If there is an Fcb/Dcb, set the long file name.
            //

            Fcb = FileObject->FsContext;

            if (Fcb &&
                ((NodeType(Fcb) == FAT_NTC_FCB) ||
                 (NodeType(Fcb) == FAT_NTC_DCB)) &&
                (Fcb->FullFileName.Buffer == NULL)) {

                FatSetFullNameInFcb( IrpContext, Fcb, &FinalName );
            }
        }

    } finally {

        DebugUnwind( FatCommonCreate );

        //
        //  There used to be a test here - the ASSERT replaces it.  We will
        //  never have begun enumerating directories if we post the IRP for
        //  oplock reasons.
        //
        
        ASSERT( !OplockPostIrp || DirentBcb == NULL );

        FatUnpinBcb( IrpContext, DirentBcb );

        //
        //  If we are in an error path, check for any created subdir Dcbs that
        //  have to be unwound.  Don't whack the root directory.
        //
        //  Note this will leave a branch of Dcbs dangling if the directory file
        //  had not been built on the leaf (case: opening path which has an 
        //  element containing an invalid character name).
        //

        if ((AbnormalTermination() || !NT_SUCCESS(Iosb.Status)) &&
            (FinalDcb != NULL) &&
            (NodeType(FinalDcb) == FAT_NTC_DCB) &&
            IsListEmpty(&FinalDcb->Specific.Dcb.ParentDcbQueue) &&
            (FinalDcb->OpenCount == 0) &&
            (FinalDcb->Specific.Dcb.DirectoryFile != NULL)) {

            PFILE_OBJECT DirectoryFileObject;
            ULONG SavedFlags;

            //
            //  Before doing the uninitialize, we have to unpin anything
            //  that has been repinned, but disable writethrough first.  We
            //  disable raise from unpin-repin since we're already failing.
            //

            SavedFlags = IrpContext->Flags;

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_RAISE |
                                        IRP_CONTEXT_FLAG_DISABLE_WRITE_THROUGH );

            FatUnpinRepinnedBcbs( IrpContext );

            DirectoryFileObject = FinalDcb->Specific.Dcb.DirectoryFile;

            FinalDcb->Specific.Dcb.DirectoryFile = NULL;

            CcUninitializeCacheMap( DirectoryFileObject, NULL, NULL );

            ObDereferenceObject( DirectoryFileObject );

            IrpContext->Flags = SavedFlags;
        }

        if (AbnormalTermination()) {

            FatReleaseVcb( IrpContext, Vcb );
        }

        //
        //  Free up any string buffers we allocated
        //

        FatFreeStringBuffer( &OemFinalName);

        FatFreeStringBuffer( &UpcasedFinalName);

        FatFreeStringBuffer( &Lfn);
    }

    //
    //  The following code is only executed if we are exiting the
    //  procedure through a normal termination.  We complete the request
    //  and if for any reason that bombs out then we need to unreference
    //  and possibly delete the fcb and ccb.
    //

    try {

        if (PostIrp) {

            //
            //  If the Irp hasn't already been posted, do it now.
            //

            if (!OplockPostIrp) {

                Iosb.Status = FatFsdPostRequest( IrpContext, Irp );
            }

        } else {

            FatUnpinRepinnedBcbs( IrpContext );
        }

    } finally {

        DebugUnwind( FatCommonCreate-in-FatCompleteRequest );

        if (AbnormalTermination()) {

            PVCB Vcb;
            PFCB Fcb;
            PCCB Ccb;

            //
            //  Unwind all of our counts.  Note that if a write failed, then
            //  the volume has been marked for verify, and all volume
            //  structures will be cleaned up automatically.
            //

            (VOID) FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

            Fcb->UncleanCount -= 1;
            Fcb->OpenCount -= 1;
            Vcb->OpenFileCount -= 1;
            
            if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount -= 1; }

            //
            //  If we leafed out on a new Fcb we should get rid of it at this point.
            //
            //  Since the object isn't being opened, we have to do all of the teardown
            //  here.  Our close path will not occur for this fileobject. Note this
            //  will leave a branch of Dcbs dangling since we do it by hand and don't
            //  chase to the root.
            //

            if (Fcb->OpenCount == 0 &&
                (NodeType( Fcb ) == FAT_NTC_FCB ||
                 IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue))) {

                ASSERT( NodeType( Fcb ) != FAT_NTC_ROOT_DCB );

                if ( (NodeType( Fcb ) == FAT_NTC_DCB) &&
                     (Fcb->Specific.Dcb.DirectoryFile != NULL) ) {

                    FatSyncUninitializeCacheMap( IrpContext,
                                                 Fcb->Specific.Dcb.DirectoryFile );

                    InterlockedDecrement( &Fcb->Specific.Dcb.DirectoryFileOpenCount );
                    FatSetFileObject( Fcb->Specific.Dcb.DirectoryFile,
                                      UnopenedFileObject,
                                      NULL,
                                      NULL );

                    ObDereferenceObject( Fcb->Specific.Dcb.DirectoryFile );
                    Fcb->Specific.Dcb.DirectoryFile = NULL;
                }

                FatDeleteFcb( IrpContext, Fcb );
            }

            FatDeleteCcb( IrpContext, Ccb );

            FatReleaseVcb( IrpContext, Vcb );

        } else {

            FatReleaseVcb( IrpContext, Vcb );

            if ( !PostIrp ) {

                //
                //  If this request is successful and the file was opened
                //  for FILE_EXECUTE access, then set the FileObject bit.
                //

                ASSERT( IrpSp->Parameters.Create.SecurityContext != NULL );
                if (FlagOn( *DesiredAccess, FILE_EXECUTE )) {

                    SetFlag( FileObject->Flags, FO_FILE_FAST_IO_READ );
                }

                //
                //  Lock volume in drive if we opened a paging file, allocating a
                //  reserve MDL to guarantee paging file operations can always
                //  go forward.
                //

                if (IsPagingFile && NT_SUCCESS(Iosb.Status)) {

                    if (!FatReserveMdl) {

                        PMDL ReserveMdl = IoAllocateMdl( NULL,
                                                         FAT_RESERVE_MDL_SIZE * PAGE_SIZE,
                                                         TRUE,
                                                         FALSE,
                                                         NULL );
                        
                        //
                        //  Stash the MDL, and if it turned out there was already one there
                        //  just free what we got.
                        //
                        
                        InterlockedCompareExchangePointer( &FatReserveMdl, ReserveMdl, NULL );

                        if (FatReserveMdl != ReserveMdl) {

                            IoFreeMdl( ReserveMdl );
                        }
                    }

                    SetFlag(Vcb->VcbState, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE);

                    if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA)) {
                        
                        FatToggleMediaEjectDisable( IrpContext, Vcb, TRUE );
                    }
                }

                //
                //  Complete the request.
                //

                FatCompleteRequest( IrpContext, Irp, Iosb.Status );
            }
        }

        DebugTrace(-1, Dbg, "FatCommonCreate -> %08lx\n", Iosb.Status);
    }

    CollectCreateStatistics(Vcb, Iosb.Status);

    return Iosb.Status;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
FatOpenVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition
    )

/*++

Routine Description:

    This routine opens the specified volume for DASD access

Arguments:

    FileObject - Supplies the File object

    Vcb - Supplies the Vcb denoting the volume being opened

    DesiredAccess - Supplies the desired access of the caller

    ShareAccess - Supplies the share access of the caller

    CreateDisposition - Supplies the create disposition for this operation

Return Value:

    IO_STATUS_BLOCK - Returns the completion status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    
    IO_STATUS_BLOCK Iosb = {0,0};

    BOOLEAN CleanedVolume = FALSE;
    
    //
    //  The following variables are for abnormal termination
    //

    BOOLEAN UnwindShareAccess = FALSE;
    PCCB UnwindCcb = NULL;
    BOOLEAN UnwindCounts = FALSE;
    BOOLEAN UnwindVolumeLock = FALSE;

    DebugTrace(+1, Dbg, "FatOpenVolume...\n", 0);

    try {

        //
        //  Check for proper desired access and rights
        //

        if ((CreateDisposition != FILE_OPEN) &&
            (CreateDisposition != FILE_OPEN_IF)) {

            try_return( Iosb.Status = STATUS_ACCESS_DENIED );
        }

        //
        //  If the user does not want to share write or delete then we will try
        //  and take out a lock on the volume.
        //

        if (!FlagOn(ShareAccess, FILE_SHARE_WRITE) &&
            !FlagOn(ShareAccess, FILE_SHARE_DELETE)) {

            //
            //  Do a quick check here for handles on exclusive open.
            //

            if (!FlagOn(ShareAccess, FILE_SHARE_READ) &&
                !FatIsHandleCountZero( IrpContext, Vcb )) {

                try_return( Iosb.Status = STATUS_SHARING_VIOLATION );
            }

            //
            //  Force Mm to get rid of its referenced file objects.
            //

            FatFlushFat( IrpContext, Vcb );

            FatPurgeReferencedFileObjects( IrpContext, Vcb->RootDcb, Flush );

            //
            //  If the user also does not want to share read then we check
            //  if anyone is already using the volume, and if so then we
            //  deny the access.  If the user wants to share read then
            //  we allow the current opens to stay provided they are only
            //  readonly opens and deny further opens.
            //

            if (!FlagOn(ShareAccess, FILE_SHARE_READ)) {

                if (Vcb->OpenFileCount != 0) {

                    try_return( Iosb.Status = STATUS_SHARING_VIOLATION );
                }

            } else {

                if (Vcb->ReadOnlyCount != Vcb->OpenFileCount) {

                    try_return( Iosb.Status = STATUS_SHARING_VIOLATION );
                }
            }
            
            //
            //  Lock the volume
            //

            Vcb->VcbState |= VCB_STATE_FLAG_LOCKED;
            Vcb->FileObjectWithVcbLocked = FileObject;
            UnwindVolumeLock = TRUE;

            //
            //  Clean the volume
            //
            
            CleanedVolume = TRUE;
        
        }  else if (FlagOn( *DesiredAccess, FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA )) {

            //
            //  Flush the volume and let ourselves push the clean bit out if everything
            //  worked.
            //

            if (NT_SUCCESS( FatFlushVolume( IrpContext, Vcb, Flush ))) {
                
                CleanedVolume = TRUE;
            }
        }

        //
        //  Clean the volume if we believe it safe and reasonable.
        //
    
        if (CleanedVolume &&
            FlagOn( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY ) &&
            !FlagOn( Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY ) &&
            !CcIsThereDirtyData(Vcb->Vpb)) {
    
            //
            //  Cancel any pending clean volumes.
            //

            (VOID)KeCancelTimer( &Vcb->CleanVolumeTimer );
            (VOID)KeRemoveQueueDpc( &Vcb->CleanVolumeDpc );

            FatMarkVolume( IrpContext, Vcb, VolumeClean );
            ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY );

            //
            //  Unlock the volume if it is removable.
            //

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) &&
                !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE)) {

                FatToggleMediaEjectDisable( IrpContext, Vcb, FALSE );
            }
        }

        //
        //  If the volume is already opened by someone then we need to check
        //  the share access
        //

        if (Vcb->DirectAccessOpenCount > 0) {

            if (!NT_SUCCESS(Iosb.Status = IoCheckShareAccess( *DesiredAccess,
                                                              ShareAccess,
                                                              FileObject,
                                                              &Vcb->ShareAccess,
                                                              TRUE ))) {

                try_return( Iosb.Status );
            }

        } else {

            IoSetShareAccess( *DesiredAccess,
                              ShareAccess,
                              FileObject,
                              &Vcb->ShareAccess );
        }

        UnwindShareAccess = TRUE;

        //
        //  Set up the context and section object pointers, and update
        //  our reference counts
        //

        FatSetFileObject( FileObject,
                          UserVolumeOpen,
                          Vcb,
                          UnwindCcb = FatCreateCcb( IrpContext ));

        FileObject->SectionObjectPointer = &Vcb->SectionObjectPointers;

        Vcb->DirectAccessOpenCount += 1;
        Vcb->OpenFileCount += 1;
        if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount += 1; }
        UnwindCounts = TRUE;
        FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;

        //
        //  At this point the open will succeed, so check if the user is getting explicit access
        //  to the device.  If not, we will note this so we can deny modifying FSCTL to it.
        //

        IrpSp = IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp );
        Status = FatExplicitDeviceAccessGranted( IrpContext,
                                                 Vcb->Vpb->RealDevice,
                                                 IrpSp->Parameters.Create.SecurityContext->AccessState,
                                                 (KPROCESSOR_MODE)( FlagOn( IrpSp->Flags, SL_FORCE_ACCESS_CHECK ) ?
                                                                    UserMode :
                                                                    IrpContext->OriginatingIrp->RequestorMode ));

        if (NT_SUCCESS( Status )) {

            SetFlag( UnwindCcb->Flags, CCB_FLAG_MANAGE_VOLUME_ACCESS );
        }

        //
        //  And set our status to success
        //

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = FILE_OPENED;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatOpenVolume );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination() || !NT_SUCCESS(Iosb.Status)) {

            if (UnwindCounts) {
                Vcb->DirectAccessOpenCount -= 1;
                Vcb->OpenFileCount -= 1;
                if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount -= 1; }
            }
            if (UnwindCcb != NULL) { FatDeleteCcb( IrpContext, UnwindCcb ); }
            if (UnwindShareAccess) { IoRemoveShareAccess( FileObject, &Vcb->ShareAccess ); }
            if (UnwindVolumeLock) { Vcb->VcbState &= ~VCB_STATE_FLAG_LOCKED; }
        }

        DebugTrace(-1, Dbg, "FatOpenVolume -> Iosb.Status = %08lx\n", Iosb.Status);
    }

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
FatOpenRootDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition
    )

/*++

Routine Description:

    This routine opens the root dcb for the volume

Arguments:

    FileObject - Supplies the File object

    Vcb - Supplies the Vcb denoting the volume whose dcb is being opened.

    DesiredAccess - Supplies the desired access of the caller

    ShareAccess - Supplies the share access of the caller

    CreateDisposition - Supplies the create disposition for this operation

Return Value:

    IO_STATUS_BLOCK - Returns the completion status for the operation

Arguments:

--*/

{
    PDCB RootDcb;
    IO_STATUS_BLOCK Iosb;

    //
    //  The following variables are for abnormal termination
    //

    BOOLEAN UnwindShareAccess = FALSE;
    PCCB UnwindCcb = NULL;
    BOOLEAN UnwindCounts = FALSE;
    BOOLEAN RootDcbAcquired = FALSE;

    DebugTrace(+1, Dbg, "FatOpenRootDcb...\n", 0);

    //
    //  Locate the root dcb
    //

    RootDcb = Vcb->RootDcb;

    //
    //  Get the Dcb exlcusive.  This is important as cleanup does not
    //  acquire the Vcb.
    //

    (VOID)FatAcquireExclusiveFcb( IrpContext, RootDcb );
    RootDcbAcquired = TRUE;

    try {

        //
        //  Check the create disposition and desired access
        //

        if ((CreateDisposition != FILE_OPEN) &&
            (CreateDisposition != FILE_OPEN_IF)) {

            Iosb.Status = STATUS_ACCESS_DENIED;
            try_return( Iosb );
        }

        if (!FatCheckFileAccess( IrpContext,
                                 RootDcb->DirentFatFlags,
                                 DesiredAccess)) {

            Iosb.Status = STATUS_ACCESS_DENIED;
            try_return( Iosb );
        }

        //
        //  If the Root dcb is already opened by someone then we need
        //  to check the share access
        //

        if (RootDcb->OpenCount > 0) {

            if (!NT_SUCCESS(Iosb.Status = IoCheckShareAccess( *DesiredAccess,
                                                              ShareAccess,
                                                              FileObject,
                                                              &RootDcb->ShareAccess,
                                                              TRUE ))) {

                try_return( Iosb );
            }

        } else {

            IoSetShareAccess( *DesiredAccess,
                              ShareAccess,
                              FileObject,
                              &RootDcb->ShareAccess );
        }

        UnwindShareAccess = TRUE;

        //
        //  Setup the context and section object pointers, and update
        //  our reference counts
        //

        FatSetFileObject( FileObject,
                          UserDirectoryOpen,
                          RootDcb,
                          UnwindCcb = FatCreateCcb( IrpContext ));

        RootDcb->UncleanCount += 1;
        RootDcb->OpenCount += 1;
        Vcb->OpenFileCount += 1;
        if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount += 1; }
        UnwindCounts = TRUE;

        //
        //  And set our status to success
        //

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = FILE_OPENED;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatOpenRootDcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            if (UnwindCounts) {
                RootDcb->UncleanCount -= 1;
                RootDcb->OpenCount -= 1;
                Vcb->OpenFileCount -= 1;
                if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount -= 1; }
            }
            if (UnwindCcb != NULL) { FatDeleteCcb( IrpContext, UnwindCcb ); }
            if (UnwindShareAccess) { IoRemoveShareAccess( FileObject, &RootDcb->ShareAccess ); }
        }

        if (RootDcbAcquired) {

            FatReleaseFcb( IrpContext, RootDcb );
        }

        DebugTrace(-1, Dbg, "FatOpenRootDcb -> Iosb.Status = %08lx\n", Iosb.Status);
    }

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
FatOpenExistingDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB Dcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose
    )

/*++

Routine Description:

    This routine opens the specified existing dcb

Arguments:

    FileObject - Supplies the File object

    Vcb - Supplies the Vcb denoting the volume containing the dcb

    Dcb - Supplies the already existing dcb

    DesiredAccess - Supplies the desired access of the caller

    ShareAccess - Supplies the share access of the caller

    CreateDisposition - Supplies the create disposition for this operation

    NoEaKnowledge - This opener doesn't understand Ea's and we fail this
        open if the file has NeedEa's.

    DeleteOnClose - The caller wants the file gone when the handle is closed

Return Value:

    IO_STATUS_BLOCK - Returns the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;
    PBCB DirentBcb = NULL;
    PDIRENT Dirent;

    //
    //  The following variables are for abnormal termination
    //

    BOOLEAN UnwindShareAccess = FALSE;
    PCCB UnwindCcb = NULL;
    BOOLEAN DcbAcquired = FALSE;

    DebugTrace(+1, Dbg, "FatOpenExistingDcb...\n", 0);

    //
    //  Get the Dcb exlcusive.  This is important as cleanup does not
    //  acquire the Vcb.
    //

    (VOID)FatAcquireExclusiveFcb( IrpContext, Dcb );
    DcbAcquired = TRUE;

    try {

        //
        //  Before spending any noticeable effort, see if we have the odd case
        //  of someone trying to delete-on-close the root dcb.  This will only
        //  happen if we're hit with a null-filename relative open via the root.
        //

        if (NodeType(Dcb) == FAT_NTC_ROOT_DCB && DeleteOnClose) {

            Iosb.Status = STATUS_CANNOT_DELETE;
            try_return( Iosb );
        }

        //
        //  If the caller has no Ea knowledge, we immediately check for
        //  Need Ea's on the file.  We don't need to check for ea's on the
        //  root directory, because it never has any.  Fat32 doesn't have
        //  any, either.
        //

        if (NoEaKnowledge && NodeType(Dcb) != FAT_NTC_ROOT_DCB &&
            !FatIsFat32(Vcb)) {

            ULONG NeedEaCount;

            //
            //  Get the dirent for the file and then check that the need
            //  ea count is 0.
            //

            FatGetDirentFromFcbOrDcb( IrpContext,
                                      Dcb,
                                      &Dirent,
                                      &DirentBcb );

            ASSERT( Dirent && DirentBcb );

            FatGetNeedEaCount( IrpContext,
                               Vcb,
                               Dirent,
                               &NeedEaCount );

            FatUnpinBcb( IrpContext, DirentBcb );

            if (NeedEaCount != 0) {

                Iosb.Status = STATUS_ACCESS_DENIED;
                try_return( Iosb );
            }
        }

        //
        //  Check the create disposition and desired access
        //

        if ((CreateDisposition != FILE_OPEN) &&
            (CreateDisposition != FILE_OPEN_IF)) {

            Iosb.Status = STATUS_OBJECT_NAME_COLLISION;
            try_return( Iosb );
        }

        if (!FatCheckFileAccess( IrpContext,
                                 Dcb->DirentFatFlags,
                                 DesiredAccess)) {

            Iosb.Status = STATUS_ACCESS_DENIED;
            try_return( Iosb );
        }

        //
        //  If the dcb is already opened by someone then we need
        //  to check the share access
        //

        if (Dcb->OpenCount > 0) {

            if (!NT_SUCCESS(Iosb.Status = IoCheckShareAccess( *DesiredAccess,
                                                              ShareAccess,
                                                              FileObject,
                                                              &Dcb->ShareAccess,
                                                              TRUE ))) {

                try_return( Iosb );
            }

        } else {

            IoSetShareAccess( *DesiredAccess,
                              ShareAccess,
                              FileObject,
                              &Dcb->ShareAccess );
        }

        UnwindShareAccess = TRUE;

        //
        //  Setup the context and section object pointers, and update
        //  our reference counts
        //

        FatSetFileObject( FileObject,
                          UserDirectoryOpen,
                          Dcb,
                          UnwindCcb = FatCreateCcb( IrpContext ));

        Dcb->UncleanCount += 1;
        Dcb->OpenCount += 1;
        Vcb->OpenFileCount += 1;
        if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount += 1; }

        //
        //  Mark the delete on close bit if the caller asked for that.
        //

        {
            PCCB Ccb = (PCCB)FileObject->FsContext2;


            if (DeleteOnClose) {

                SetFlag( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
            }

        }

        //
        //  In case this was set, clear it now.
        //

        ClearFlag(Dcb->FcbState, FCB_STATE_DELAY_CLOSE);

        //
        //  And set our status to success
        //

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = FILE_OPENED;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatOpenExistingDcb );

        //
        //  Unpin the Dirent Bcb if pinned.
        //

        FatUnpinBcb( IrpContext, DirentBcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            if (UnwindCcb != NULL) { FatDeleteCcb( IrpContext, UnwindCcb ); }
            if (UnwindShareAccess) { IoRemoveShareAccess( FileObject, &Dcb->ShareAccess ); }
        }

        if (DcbAcquired) {

            FatReleaseFcb( IrpContext, Dcb );
        }

        DebugTrace(-1, Dbg, "FatOpenExistingDcb -> Iosb.Status = %08lx\n", Iosb.Status);
    }

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
FatOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN ULONG CreateDisposition,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose,
    IN BOOLEAN FileNameOpenedDos,
    OUT PBOOLEAN OplockPostIrp
    )

/*++

Routine Description:

    This routine opens the specified existing fcb

Arguments:

    FileObject - Supplies the File object

    Vcb - Supplies the Vcb denoting the volume containing the Fcb

    Fcb - Supplies the already existing fcb

    DesiredAccess - Supplies the desired access of the caller

    ShareAccess - Supplies the share access of the caller

    AllocationSize - Supplies the initial allocation if the file is being
        superseded or overwritten

    EaBuffer - Supplies the Ea set if the file is being superseded or
        overwritten

    EaLength - Supplies the size, in byte, of the EaBuffer

    FileAttributes - Supplies file attributes to use if the file is being
        superseded or overwritten

    CreateDisposition - Supplies the create disposition for this operation

    NoEaKnowledge - This opener doesn't understand Ea's and we fail this
        open if the file has NeedEa's.

    DeleteOnClose - The caller wants the file gone when the handle is closed

    FileNameOpenedDos - The caller hit the short side of the name pair finding
        this file

    OplockPostIrp - Address to store boolean indicating if the Irp needs to
        be posted to the Fsp.

Return Value:

    IO_STATUS_BLOCK - Returns the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    PBCB DirentBcb = NULL;
    PDIRENT Dirent;

    ACCESS_MASK AddedAccess = 0;

    //
    //  The following variables are for abnormal termination
    //

    BOOLEAN UnwindShareAccess = FALSE;
    PCCB UnwindCcb = NULL;
    BOOLEAN DecrementFcbOpenCount = FALSE;
    BOOLEAN FcbAcquired = FALSE;

    DebugTrace(+1, Dbg, "FatOpenExistingFcb...\n", 0);

    //
    //  Get the Fcb exlcusive.  This is important as cleanup does not
    //  acquire the Vcb.

    //

    (VOID)FatAcquireExclusiveFcb( IrpContext, Fcb );
    FcbAcquired = TRUE;

    try {

        *OplockPostIrp = FALSE;

        //
        //  Take special action if there is a current batch oplock or
        //  batch oplock break in process on the Fcb.
        //

        if (FsRtlCurrentBatchOplock( &Fcb->Specific.Fcb.Oplock )) {

            //
            //  We remember if a batch oplock break is underway for the
            //  case where the sharing check fails.
            //

            Iosb.Information = FILE_OPBATCH_BREAK_UNDERWAY;

            Iosb.Status = FsRtlCheckOplock( &Fcb->Specific.Fcb.Oplock,
                                            IrpContext->OriginatingIrp,
                                            IrpContext,
                                            FatOplockComplete,
                                            FatPrePostIrp );

            if (Iosb.Status != STATUS_SUCCESS
                && Iosb.Status != STATUS_OPLOCK_BREAK_IN_PROGRESS) {

                *OplockPostIrp = TRUE;
                try_return( NOTHING );
            }
        }

        //
        //  Check if the user wanted to create the file, also special case
        //  the supersede and overwrite options.  Those add additional,
        //  possibly only implied, desired accesses to the caller, which
        //  we must be careful to pull back off if the caller did not actually
        //  request them.
        //
        //  In other words, check against the implied access, but do not modify
        //  share access as a result.
        //

        if (CreateDisposition == FILE_CREATE) {

            Iosb.Status = STATUS_OBJECT_NAME_COLLISION;
            try_return( Iosb );

        } else if (CreateDisposition == FILE_SUPERSEDE) {

            SetFlag( AddedAccess,
                     DELETE & ~(*DesiredAccess) );

            *DesiredAccess |= DELETE;

        } else if ((CreateDisposition == FILE_OVERWRITE) ||
                   (CreateDisposition == FILE_OVERWRITE_IF)) {

            SetFlag( AddedAccess,
                     (FILE_WRITE_DATA | FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES) & ~(*DesiredAccess) );
            
            *DesiredAccess |= FILE_WRITE_DATA | FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES;
        }

        //
        //  Check the desired access
        //

        if (!FatCheckFileAccess( IrpContext,
                                 Fcb->DirentFatFlags,
                                 DesiredAccess )) {

            Iosb.Status = STATUS_ACCESS_DENIED;
            try_return( Iosb );
        }

        //
        //  Check for trying to delete a read only file.
        //

        if (DeleteOnClose &&
            FlagOn( Fcb->DirentFatFlags, FAT_DIRENT_ATTR_READ_ONLY )) {

            Iosb.Status = STATUS_CANNOT_DELETE;
            try_return( Iosb );
        }

        //
        //  If we are asked to do an overwrite or supersede operation then
        //  deny access for files where the file attributes for system and
        //  hidden do not match
        //
        
        if ((CreateDisposition == FILE_SUPERSEDE) ||
            (CreateDisposition == FILE_OVERWRITE) ||
            (CreateDisposition == FILE_OVERWRITE_IF)) {

            BOOLEAN Hidden;
            BOOLEAN System;

            Hidden = BooleanFlagOn(Fcb->DirentFatFlags, FAT_DIRENT_ATTR_HIDDEN );
            System = BooleanFlagOn(Fcb->DirentFatFlags, FAT_DIRENT_ATTR_SYSTEM );

            if ((Hidden && !FlagOn(FileAttributes, FILE_ATTRIBUTE_HIDDEN)) ||
                (System && !FlagOn(FileAttributes, FILE_ATTRIBUTE_SYSTEM))) {

                DebugTrace(0, Dbg, "The hidden and/or system bits do not match\n", 0);


                Iosb.Status = STATUS_ACCESS_DENIED;
                try_return( Iosb );
            }

            //
            //  If this media is write protected, don't even try the create.
            //

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

                //
                //  Set the real device for the pop-up info, and set the verify
                //  bit in the device object, so that we will force a verify
                //  in case the user put the correct media back in.
                //

                IoSetHardErrorOrVerifyDevice( IrpContext->OriginatingIrp,
                                              Vcb->Vpb->RealDevice );

                SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);

                FatRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED );
            }
        }

        //
        //  Check if the Fcb has the proper share access
        //

        if (!NT_SUCCESS(Iosb.Status = IoCheckShareAccess( *DesiredAccess,
                                                          ShareAccess,
                                                          FileObject,
                                                          &Fcb->ShareAccess,
                                                          FALSE ))) {

            try_return( Iosb );
        }

        //
        //  Now check that we can continue based on the oplock state of the
        //  file.
        //
        //  It is important that we modified the DesiredAccess in place so
        //  that the Oplock check proceeds against any added access we had
        //  to give the caller.
        //

        Iosb.Status = FsRtlCheckOplock( &Fcb->Specific.Fcb.Oplock,
                                        IrpContext->OriginatingIrp,
                                        IrpContext,
                                        FatOplockComplete,
                                        FatPrePostIrp );

        if (Iosb.Status != STATUS_SUCCESS
            && Iosb.Status != STATUS_OPLOCK_BREAK_IN_PROGRESS) {

            *OplockPostIrp = TRUE;
            try_return( NOTHING );
        }

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );

        //
        //  If the user wants write access access to the file make sure there
        //  is not a process mapping this file as an image.  Any attempt to
        //  delete the file will be stopped in fileinfo.c
        //
        //  If the user wants to delete on close, we must check at this
        //  point though.
        //

        if (FlagOn(*DesiredAccess, FILE_WRITE_DATA) || DeleteOnClose) {

            Fcb->OpenCount += 1;
            DecrementFcbOpenCount = TRUE;

            if (!MmFlushImageSection( &Fcb->NonPaged->SectionObjectPointers,
                                      MmFlushForWrite )) {

                Iosb.Status = DeleteOnClose ? STATUS_CANNOT_DELETE :
                                              STATUS_SHARING_VIOLATION;
                try_return( Iosb );
            }
        }

        //
        //  If this is a non-cached open on a non-paging file, and there
        //  are no open cached handles, but there is a still a data
        //  section, attempt a flush and purge operation to avoid cache
        //  coherency overhead later.  We ignore any I/O errors from
        //  the flush.
        //
        //  We set the CREATE_IN_PROGRESS flag to prevent the Fcb from
        //  going away out from underneath us.
        //

        if (FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
            (Fcb->UncleanCount == Fcb->NonCachedUncleanCount) &&
            (Fcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL) &&
            !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

            SetFlag(Fcb->Vcb->VcbState, VCB_STATE_FLAG_CREATE_IN_PROGRESS);

            CcFlushCache( &Fcb->NonPaged->SectionObjectPointers, NULL, 0, NULL );

            //
            //  Grab and release PagingIo to serialize ourselves with the lazy writer.
            //  This will work to ensure that all IO has completed on the cached
            //  data and we will succesfully tear away the cache section.
            //

            ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource, TRUE);
            ExReleaseResourceLite( Fcb->Header.PagingIoResource );

            CcPurgeCacheSection( &Fcb->NonPaged->SectionObjectPointers,
                                 NULL,
                                 0,
                                 FALSE );

            ClearFlag(Fcb->Vcb->VcbState, VCB_STATE_FLAG_CREATE_IN_PROGRESS);
        }

        //
        //  Check if the user only wanted to open the file
        //

        if ((CreateDisposition == FILE_OPEN) ||
            (CreateDisposition == FILE_OPEN_IF)) {

            DebugTrace(0, Dbg, "Doing open operation\n", 0);

            //
            //  If the caller has no Ea knowledge, we immediately check for
            //  Need Ea's on the file.
            //

            if (NoEaKnowledge && !FatIsFat32(Vcb)) {

                ULONG NeedEaCount;

                //
                //  Get the dirent for the file and then check that the need
                //  ea count is 0.
                //

                FatGetDirentFromFcbOrDcb( IrpContext,
                                          Fcb,
                                          &Dirent,
                                          &DirentBcb );

                FatGetNeedEaCount( IrpContext,
                                   Vcb,
                                   Dirent,
                                   &NeedEaCount );

                FatUnpinBcb( IrpContext, DirentBcb );

                if (NeedEaCount != 0) {

                    Iosb.Status = STATUS_ACCESS_DENIED;
                    try_return( Iosb );
                }
            }

            //
            //  Everything checks out okay, so setup the context and
            //  section object pointers.
            //

            FatSetFileObject( FileObject,
                              UserFileOpen,
                              Fcb,
                              UnwindCcb = FatCreateCcb( IrpContext ));

            FileObject->SectionObjectPointer = &Fcb->NonPaged->SectionObjectPointers;

            //
            //  Fill in the information field, the status field is already
            //  set.
            //

            Iosb.Information = FILE_OPENED;

            try_return( Iosb );
        }

        //
        //  Check if we are to supersede/overwrite the file, we can wait for
        //  any I/O at this point
        //

        if ((CreateDisposition == FILE_SUPERSEDE) ||
            (CreateDisposition == FILE_OVERWRITE) ||
            (CreateDisposition == FILE_OVERWRITE_IF)) {

            NTSTATUS OldStatus;

            DebugTrace(0, Dbg, "Doing supersede/overwrite operation\n", 0);

            //
            //  Determine the granted access for this operation now.
            //

            if (!NT_SUCCESS( Iosb.Status = FatCheckSystemSecurityAccess( IrpContext ))) {

                try_return( Iosb );
            }

            //
            //  And overwrite the file.  We remember the previous status
            //  code because it may contain information about
            //  the oplock status.
            //

            OldStatus = Iosb.Status;

            Iosb = FatSupersedeOrOverwriteFile( IrpContext,
                                                FileObject,
                                                Fcb,
                                                AllocationSize,
                                                EaBuffer,
                                                EaLength,
                                                FileAttributes,
                                                CreateDisposition,
                                                NoEaKnowledge );

            if (Iosb.Status == STATUS_SUCCESS) {

                Iosb.Status = OldStatus;
            }

            try_return( Iosb );
        }

        //
        //  If we ever get here then the I/O system gave us some bad input
        //

        FatBugCheck( CreateDisposition, 0, 0 );

    try_exit: NOTHING;

        //
        //  Update the share access and counts if successful
        //

        if ((Iosb.Status != STATUS_PENDING) && NT_SUCCESS(Iosb.Status)) {

            //
            //  Now, we may have added some access bits above to indicate the access
            //  this caller would conflict with (as opposed to what they get) in order
            //  to perform the overwrite/supersede.  We need to make a call to that will
            //  recalculate the bits in the fileobject to reflect the real access they
            //  will get.
            //

            if (AddedAccess) {

                NTSTATUS Status;
            
                ClearFlag( *DesiredAccess, AddedAccess );
                Status = IoCheckShareAccess( *DesiredAccess,
                                             ShareAccess,
                                             FileObject,
                                             &Fcb->ShareAccess,
                                             TRUE );

                //
                //  It must be the case that we are really asking for less access, so
                //  any conflict must have been detected before this point.
                //

                ASSERT( Status == STATUS_SUCCESS );

            } else {
            
                IoUpdateShareAccess( FileObject, &Fcb->ShareAccess );
            }

            UnwindShareAccess = TRUE;

            //
            //  In case this was set, clear it now.
            //

            ClearFlag(Fcb->FcbState, FCB_STATE_DELAY_CLOSE);

            Fcb->UncleanCount += 1;
            Fcb->OpenCount += 1;
            if (FlagOn(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING)) {
                Fcb->NonCachedUncleanCount += 1;
            }
            Vcb->OpenFileCount += 1;
            if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount += 1; }

            {
                PCCB Ccb;
                Ccb = (PCCB)FileObject->FsContext2;

                //
                //  Mark the DeleteOnClose bit if the operation was successful.
                //

                if ( DeleteOnClose ) {

                    SetFlag( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
                }

                //
                //  Mark the OpenedByShortName bit if the operation was successful.
                //

                if ( FileNameOpenedDos ) {

                    SetFlag( Ccb->Flags, CCB_FLAG_OPENED_BY_SHORTNAME );
                }
            }
        }

    } finally {

        DebugUnwind( FatOpenExistingFcb );

        //
        //  Unpin the Dirent Bcb if pinned.
        //

        FatUnpinBcb( IrpContext, DirentBcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            if (UnwindCcb != NULL) { FatDeleteCcb( IrpContext, UnwindCcb ); }
            if (UnwindShareAccess) { IoRemoveShareAccess( FileObject, &Fcb->ShareAccess ); }
        }

        if (DecrementFcbOpenCount) {

            Fcb->OpenCount -= 1;
            if (Fcb->OpenCount == 0) { FatDeleteFcb( IrpContext, Fcb ); }
        }

        if (FcbAcquired) {

            FatReleaseFcb( IrpContext, Fcb );
        }

        DebugTrace(-1, Dbg, "FatOpenExistingFcb -> Iosb.Status = %08lx\n", Iosb.Status);
    }

    return Iosb;
}

//
//  Internal support routine
//

IO_STATUS_BLOCK
FatOpenTargetDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PDCB Dcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN BOOLEAN DoesNameExist
    )

/*++

Routine Description:

    This routine opens the target directory and replaces the name in the
    file object with the remaining name.

Arguments:

    FileObject - Supplies the File object

    Dcb - Supplies an already existing dcb that we are going to open

    DesiredAccess - Supplies the desired access of the caller

    ShareAccess - Supplies the share access of the caller

    DoesNameExist - Indicates if the file name already exists in the
        target directory.


Return Value:

    IO_STATUS_BLOCK - Returns the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    //
    //  The following variables are for abnormal termination
    //

    BOOLEAN UnwindShareAccess = FALSE;
    PCCB UnwindCcb = NULL;
    BOOLEAN DcbAcquired = FALSE;

    DebugTrace(+1, Dbg, "FatOpenTargetDirectory...\n", 0);

    //
    //  Get the Dcb exlcusive.  This is important as cleanup does not
    //  acquire the Vcb.
    //

    (VOID)FatAcquireExclusiveFcb( IrpContext, Dcb );
    DcbAcquired = TRUE;

    try {

        ULONG i;

        //
        //  If the Dcb is already opened by someone then we need
        //  to check the share access
        //

        if (Dcb->OpenCount > 0) {

            if (!NT_SUCCESS(Iosb.Status = IoCheckShareAccess( *DesiredAccess,
                                                              ShareAccess,
                                                              FileObject,
                                                              &Dcb->ShareAccess,
                                                              TRUE ))) {

                try_return( Iosb );
            }

        } else {

            IoSetShareAccess( *DesiredAccess,
                              ShareAccess,
                              FileObject,
                              &Dcb->ShareAccess );
        }

        UnwindShareAccess = TRUE;

        //
        //  Setup the context and section object pointers, and update
        //  our reference counts
        //

        FatSetFileObject( FileObject,
                          UserDirectoryOpen,
                          Dcb,
                          UnwindCcb = FatCreateCcb( IrpContext ));

        Dcb->UncleanCount += 1;
        Dcb->OpenCount += 1;
        Dcb->Vcb->OpenFileCount += 1;
        if (IsFileObjectReadOnly(FileObject)) { Dcb->Vcb->ReadOnlyCount += 1; }

        //
        //  Update the name in the file object, by definition the remaining
        //  part must be shorter than the original file name so we'll just
        //  overwrite the file name.
        //

        i = FileObject->FileName.Length/sizeof(WCHAR) - 1;

        //
        //  Get rid of a trailing backslash
        //

        if (FileObject->FileName.Buffer[i] == L'\\') {

            ASSERT(i != 0);

            FileObject->FileName.Length -= sizeof(WCHAR);
            i -= 1;
        }

        //
        //  Find the first non-backslash character.  i will be its index.
        //

        while (TRUE) {

            if (FileObject->FileName.Buffer[i] == L'\\') {

                i += 1;
                break;
            }

            if (i == 0) {
                break;
            }

            i--;
        }

        if (i) {

            FileObject->FileName.Length -= (USHORT)(i * sizeof(WCHAR));

            RtlCopyMemory( &FileObject->FileName.Buffer[0],
                           &FileObject->FileName.Buffer[i],
                           FileObject->FileName.Length );
        }

        //
        //  And set our status to success
        //

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = (DoesNameExist ? FILE_EXISTS : FILE_DOES_NOT_EXIST);

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatOpenTargetDirectory );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            if (UnwindCcb != NULL) { FatDeleteCcb( IrpContext, UnwindCcb ); }
            if (UnwindShareAccess) { IoRemoveShareAccess( FileObject, &Dcb->ShareAccess ); }
        }

        if (DcbAcquired) {

            FatReleaseFcb( IrpContext, Dcb );
        }

        DebugTrace(-1, Dbg, "FatOpenTargetDirectory -> Iosb.Status = %08lx\n", Iosb.Status);
    }

    return Iosb;
}



//
//  Internal support routine
//

IO_STATUS_BLOCK
FatOpenExistingDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN PDIRENT Dirent,
    IN ULONG LfnByteOffset,
    IN ULONG DirentByteOffset,
    IN PUNICODE_STRING Lfn,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose
    )

/*++

Routine Description:

    This routine opens the specified directory.  The directory has not
    previously been opened.

Arguments:

    FileObject - Supplies the File object

    Vcb - Supplies the Vcb denoting the volume containing the dcb

    ParentDcb - Supplies the parent directory containing the subdirectory
        to be opened

    DirectoryName - Supplies the file name of the directory being opened.

    Dirent - Supplies the dirent for the directory being opened

    LfnByteOffset - Tells where the Lfn begins.  If there is no Lfn
        this field is the same as DirentByteOffset.

    DirentByteOffset - Supplies the Vbo of the dirent within its parent
        directory

    Lfn - May supply a long name for the file.

    DesiredAccess - Supplies the desired access of the caller

    ShareAccess - Supplies the share access of the caller

    CreateDisposition - Supplies the create disposition for this operation

    NoEaKnowledge - This opener doesn't understand Ea's and we fail this
        open if the file has NeedEa's.

    DeleteOnClose - The caller wants the file gone when the handle is closed

Return Value:

    IO_STATUS_BLOCK - Returns the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;
    PDCB Dcb;

    //
    //  The following variables are for abnormal termination
    //

    PDCB UnwindDcb = NULL;
    PCCB UnwindCcb = NULL;

    DebugTrace(+1, Dbg, "FatOpenExistingDirectory...\n", 0);

    try {

        //
        //  If the caller has no Ea knowledge, we immediately check for
        //  Need Ea's on the file.
        //

        if (NoEaKnowledge && !FatIsFat32(Vcb)) {

            ULONG NeedEaCount;

            FatGetNeedEaCount( IrpContext,
                               Vcb,
                               Dirent,
                               &NeedEaCount );

            if (NeedEaCount != 0) {

                Iosb.Status = STATUS_ACCESS_DENIED;
                try_return( Iosb );
            }
        }

        //
        //  Check the create disposition and desired access
        //

        if ((CreateDisposition != FILE_OPEN) &&
            (CreateDisposition != FILE_OPEN_IF)) {

            Iosb.Status = STATUS_OBJECT_NAME_COLLISION;
            try_return( Iosb );
        }

        if (!FatCheckFileAccess( IrpContext,
                                 Dirent->Attributes,
                                 DesiredAccess)) {

            Iosb.Status = STATUS_ACCESS_DENIED;
            try_return( Iosb );
        }

        //
        //  Create a new dcb for the directory
        //

        Dcb = UnwindDcb = FatCreateDcb( IrpContext,
                                        Vcb,
                                        ParentDcb,
                                        LfnByteOffset,
                                        DirentByteOffset,
                                        Dirent,
                                        Lfn );

        //
        //  Setup our share access
        //

        IoSetShareAccess( *DesiredAccess,
                          ShareAccess,
                          FileObject,
                          &Dcb->ShareAccess );

        //
        //  Setup the context and section object pointers, and update
        //  our reference counts
        //

        FatSetFileObject( FileObject,
                          UserDirectoryOpen,
                          Dcb,
                          UnwindCcb = FatCreateCcb( IrpContext ));

        Dcb->UncleanCount += 1;
        Dcb->OpenCount += 1;
        Vcb->OpenFileCount += 1;
        if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount += 1; }

        //
        //  And set our status to success
        //

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = FILE_OPENED;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatOpenExistingDirectory );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            if (UnwindDcb != NULL) { FatDeleteFcb( IrpContext, UnwindDcb ); }
            if (UnwindCcb != NULL) { FatDeleteCcb( IrpContext, UnwindCcb ); }
        }

        DebugTrace(-1, Dbg, "FatOpenExistingDirectory -> Iosb.Status = %08lx\n", Iosb.Status);
    }

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
FatOpenExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN PDIRENT Dirent,
    IN ULONG LfnByteOffset,
    IN ULONG DirentByteOffset,
    IN PUNICODE_STRING Lfn,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN ULONG CreateDisposition,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose,
    IN BOOLEAN FileNameOpenedDos
    )

/*++

Routine Description:

    This routine opens the specified file.  The file has not previously
    been opened.

Arguments:

    FileObject - Supplies the File object

    Vcb - Supplies the Vcb denoting the volume containing the file

    ParentFcb - Supplies the parent directory containing the file to be
        opened

    Dirent - Supplies the dirent for the file being opened

    LfnByteOffset - Tells where the Lfn begins.  If there is no Lfn
        this field is the same as DirentByteOffset.

    DirentByteOffset - Supplies the Vbo of the dirent within its parent
        directory

    Lfn - May supply a long name for the file.

    DesiredAccess - Supplies the desired access of the caller

    ShareAccess - Supplies the share access of the caller

    AllocationSize - Supplies the initial allocation if the file is being
        superseded, overwritten, or created.

    EaBuffer - Supplies the Ea set if the file is being superseded,
        overwritten, or created.

    EaLength - Supplies the size, in byte, of the EaBuffer

    FileAttributes - Supplies file attributes to use if the file is being
        superseded, overwritten, or created

    CreateDisposition - Supplies the create disposition for this operation

    IsPagingFile - Indicates if this is the paging file being opened.

    NoEaKnowledge - This opener doesn't understand Ea's and we fail this
        open if the file has NeedEa's.

    DeleteOnClose - The caller wants the file gone when the handle is closed

    FileNameOpenedDos - The caller opened this file by hitting the 8.3 side
        of the Lfn/8.3 pair

Return Value:

    IO_STATUS_BLOCK - Returns the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;
    PFCB Fcb;

    ACCESS_MASK AddedAccess = 0;

    //
    //  The following variables are for abnormal termination
    //

    PFCB UnwindFcb = NULL;
    PCCB UnwindCcb = NULL;

    DebugTrace(+1, Dbg, "FatOpenExistingFile...\n", 0);

    try {

        //
        //  Check if the user wanted to create the file or if access is
        //  denied
        //

        if (CreateDisposition == FILE_CREATE) {
            Iosb.Status = STATUS_OBJECT_NAME_COLLISION;
            try_return( Iosb );

        } else if ((CreateDisposition == FILE_SUPERSEDE) && !IsPagingFile) {

            SetFlag( AddedAccess,
                     DELETE & ~(*DesiredAccess) );
            
            *DesiredAccess |= DELETE;

        } else if (((CreateDisposition == FILE_OVERWRITE) ||
                    (CreateDisposition == FILE_OVERWRITE_IF)) && !IsPagingFile) {

            SetFlag( AddedAccess,
                     (FILE_WRITE_DATA | FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES) & ~(*DesiredAccess) );
            
            *DesiredAccess |= FILE_WRITE_DATA | FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES;
        }

        if (!FatCheckFileAccess( IrpContext,
                                 Dirent->Attributes,
                                 DesiredAccess)) {

            Iosb.Status = STATUS_ACCESS_DENIED;
            try_return( Iosb );
        }

        //
        //  Check for trying to delete a read only file.
        //

        if (DeleteOnClose &&
            FlagOn( Dirent->Attributes, FAT_DIRENT_ATTR_READ_ONLY )) {

            Iosb.Status = STATUS_CANNOT_DELETE;
            try_return( Iosb );
        }

        //
        //  IF we are asked to do an overwrite or supersede operation then
        //  deny access for files where the file attributes for system and
        //  hidden do not match
        //

        if ((CreateDisposition == FILE_SUPERSEDE) ||
            (CreateDisposition == FILE_OVERWRITE) ||
            (CreateDisposition == FILE_OVERWRITE_IF)) {

            BOOLEAN Hidden;
            BOOLEAN System;

            Hidden = BooleanFlagOn(Dirent->Attributes, FAT_DIRENT_ATTR_HIDDEN );
            System = BooleanFlagOn(Dirent->Attributes, FAT_DIRENT_ATTR_SYSTEM );

            if ((Hidden && !FlagOn(FileAttributes, FILE_ATTRIBUTE_HIDDEN)) ||
                (System && !FlagOn(FileAttributes, FILE_ATTRIBUTE_SYSTEM))) {

                DebugTrace(0, Dbg, "The hidden and/or system bits do not match\n", 0);

                if ( !IsPagingFile ) {

                    Iosb.Status = STATUS_ACCESS_DENIED;
                    try_return( Iosb );
                }
            }

            //
            //  If this media is write protected, don't even try the create.
            //

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

                //
                //  Set the real device for the pop-up info, and set the verify
                //  bit in the device object, so that we will force a verify
                //  in case the user put the correct media back in.
                //


                IoSetHardErrorOrVerifyDevice( IrpContext->OriginatingIrp,
                                              Vcb->Vpb->RealDevice );

                SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);

                FatRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED );
            }
        }

        //
        //  Create a new Fcb for the file, and set the file size in
        //  the fcb.
        //

        Fcb = UnwindFcb = FatCreateFcb( IrpContext,
                                        Vcb,
                                        ParentDcb,
                                        LfnByteOffset,
                                        DirentByteOffset,
                                        Dirent,
                                        Lfn,
                                        IsPagingFile,
                                        FALSE );

        //
        //  If this is a paging file, lookup the allocation size so that
        //  the Mcb is always valid
        //

        if (IsPagingFile) {

            FatLookupFileAllocationSize( IrpContext, Fcb );
        }

        //
        //  Now case on whether we are to simply open, supersede, or
        //  overwrite the file.
        //

        switch (CreateDisposition) {

        case FILE_OPEN:
        case FILE_OPEN_IF:

            DebugTrace(0, Dbg, "Doing only an open operation\n", 0);

            //
            //  If the caller has no Ea knowledge, we immediately check for
            //  Need Ea's on the file.
            //

            if (NoEaKnowledge && !FatIsFat32(Vcb)) {

                ULONG NeedEaCount;

                FatGetNeedEaCount( IrpContext,
                                   Vcb,
                                   Dirent,
                                   &NeedEaCount );

                if (NeedEaCount != 0) {

                    FatRaiseStatus( IrpContext, STATUS_ACCESS_DENIED );
                }
            }

            //
            //  Setup the context and section object pointers.
            //

            FatSetFileObject( FileObject,
                              UserFileOpen,
                              Fcb,
                              UnwindCcb = FatCreateCcb( IrpContext ));

            FileObject->SectionObjectPointer = &Fcb->NonPaged->SectionObjectPointers;

            Iosb.Status = STATUS_SUCCESS;
            Iosb.Information = FILE_OPENED;
            break;

        case FILE_SUPERSEDE:
        case FILE_OVERWRITE:
        case FILE_OVERWRITE_IF:

            DebugTrace(0, Dbg, "Doing supersede/overwrite operation\n", 0);

            //
            //  Determine the granted access for this operation now.
            //

            if (!NT_SUCCESS( Iosb.Status = FatCheckSystemSecurityAccess( IrpContext ))) {

                try_return( Iosb );
            }

            Iosb = FatSupersedeOrOverwriteFile( IrpContext,
                                                FileObject,
                                                Fcb,
                                                AllocationSize,
                                                EaBuffer,
                                                EaLength,
                                                FileAttributes,
                                                CreateDisposition,
                                                NoEaKnowledge );
            break;

        default:

            DebugTrace(0, Dbg, "Illegal Create Disposition\n", 0);

            FatBugCheck( CreateDisposition, 0, 0 );
            break;
        }

    try_exit: NOTHING;

        //
        //  Setup our share access and counts if things were successful.
        //

        if ((Iosb.Status != STATUS_PENDING) && NT_SUCCESS(Iosb.Status)) {

            //
            //  Remove any virtual access the caller needed to check against, but will
            //  not really receive.  Overwrite/supersede is a bit of a special case.
            //
            
            ClearFlag( *DesiredAccess, AddedAccess );
            
            IoSetShareAccess( *DesiredAccess,
                              ShareAccess,
                              FileObject,
                              &Fcb->ShareAccess );

            Fcb->UncleanCount += 1;
            Fcb->OpenCount += 1;
            if (FlagOn(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING)) {
                Fcb->NonCachedUncleanCount += 1;
            }
            Vcb->OpenFileCount += 1;
            if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount += 1; }
        }

        {
            PCCB Ccb;
            Ccb = (PCCB)FileObject->FsContext2;

            if ( NT_SUCCESS(Iosb.Status) ) {

                //
                //  Mark the DeleteOnClose bit if the operation was successful.
                //

                if ( DeleteOnClose ) {

                    SetFlag( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
                }

                //
                //  Mark the OpenedByShortName bit if the operation was successful.
                //

                if ( FileNameOpenedDos ) {

                    SetFlag( Ccb->Flags, CCB_FLAG_OPENED_BY_SHORTNAME );
                }
            }
        }


    } finally {

        DebugUnwind( FatOpenExistingFile );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            if (UnwindFcb != NULL) { FatDeleteFcb( IrpContext, UnwindFcb ); }
            if (UnwindCcb != NULL) { FatDeleteCcb( IrpContext, UnwindCcb ); }
        }

        DebugTrace(-1, Dbg, "FatOpenExistingFile -> Iosb.Status = %08lx\n", Iosb.Status);
    }

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
FatCreateNewDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN POEM_STRING OemName,
    IN PUNICODE_STRING UnicodeName,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose
    )

/*++

Routine Description:

    This routine creates a new directory.  The directory has already been
    verified not to exist yet.

Arguments:

    FileObject - Supplies the file object for the newly created directory

    Vcb - Supplies the Vcb denote the volume to contain the new directory

    ParentDcb - Supplies the parent directory containg the newly created
        directory

    OemName - Supplies the Oem name for the newly created directory.  It may
        or maynot be 8.3 complient, but will be upcased.

    UnicodeName - Supplies the Unicode name for the newly created directory.
        It may or maynot be 8.3 complient.  This name contains the original
        case information.

    DesiredAccess - Supplies the desired access of the caller

    ShareAccess - Supplies the shared access of the caller

    EaBuffer - Supplies the Ea set for the newly created directory

    EaLength - Supplies the length, in bytes, of EaBuffer

    FileAttributes - Supplies the file attributes for the newly created
        directory.

    NoEaKnowledge - This opener doesn't understand Ea's and we fail this
        open if the file has NeedEa's.

    DeleteOnClose - The caller wants the file gone when the handle is closed

Return Value:

    IO_STATUS_BLOCK - Returns the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    PDCB Dcb = NULL;
    PCCB Ccb = NULL;

    PDIRENT Dirent = NULL;
    PBCB DirentBcb = NULL;
    ULONG DirentsNeeded;
    ULONG DirentByteOffset;

    PDIRENT ShortDirent;
    ULONG ShortDirentByteOffset;

    USHORT EaHandle;

    BOOLEAN AllLowerComponent;
    BOOLEAN AllLowerExtension;
    BOOLEAN CreateLfn;

    ULONG BytesInFirstPage;
    ULONG DirentsInFirstPage;
    PDIRENT FirstPageDirent;

    PBCB SecondPageBcb = NULL;
    ULONG SecondPageOffset;
    PDIRENT SecondPageDirent;

    BOOLEAN DirentFromPool = FALSE;

    OEM_STRING ShortName;
    UCHAR ShortNameBuffer[12];

    ULONG LocalAbnormalTermination = FALSE;

    DebugTrace(+1, Dbg, "FatCreateNewDirectory...\n", 0);

    ShortName.Length = 0;
    ShortName.MaximumLength = 12;
    ShortName.Buffer = &ShortNameBuffer[0];

    EaHandle = 0;

    //
    //  We fail this operation if the caller doesn't understand Ea's.
    //

    if (NoEaKnowledge
        && EaLength > 0) {

        Iosb.Status = STATUS_ACCESS_DENIED;

        DebugTrace(-1, Dbg, "FatCreateNewDirectory -> Iosb.Status = %08lx\n", Iosb.Status);
        return Iosb;
    }

    //
    //  DeleteOnClose and ReadOnly are not compatible.
    //

    if (DeleteOnClose && FlagOn(FileAttributes, FAT_DIRENT_ATTR_READ_ONLY)) {

        Iosb.Status = STATUS_CANNOT_DELETE;
        return Iosb;
    }

    //  Now get the names that we will be using.
    //

    FatSelectNames( IrpContext,
                    ParentDcb,
                    OemName,
                    UnicodeName,
                    &ShortName,
                    NULL,
                    &AllLowerComponent,
                    &AllLowerExtension,
                    &CreateLfn );

    //
    //  If we are not in Chicago mode, ignore the magic bits.
    //

    if (!FatData.ChicagoMode) {

        AllLowerComponent = FALSE;
        AllLowerExtension = FALSE;
        CreateLfn = FALSE;
    }

    //
    //  Create/allocate a new dirent
    //

    DirentsNeeded = CreateLfn ? FAT_LFN_DIRENTS_NEEDED(UnicodeName) + 1 : 1;

    DirentByteOffset = FatCreateNewDirent( IrpContext,
                                           ParentDcb,
                                           DirentsNeeded );
    try {

        FatPrepareWriteDirectoryFile( IrpContext,
                                      ParentDcb,
                                      DirentByteOffset,
                                      sizeof(DIRENT),
                                      &DirentBcb,
                                      &Dirent,
                                      FALSE,
                                      TRUE,
                                      &Iosb.Status );

        ASSERT( NT_SUCCESS( Iosb.Status ) && DirentBcb && Dirent );

        //
        //  Deal with the special case of an LFN + Dirent structure crossing
        //  a page boundry.
        //

        if ((DirentByteOffset / PAGE_SIZE) !=
            ((DirentByteOffset + (DirentsNeeded - 1) * sizeof(DIRENT)) / PAGE_SIZE)) {

            SecondPageBcb;
            SecondPageOffset;
            SecondPageDirent;

            SecondPageOffset = (DirentByteOffset & ~(PAGE_SIZE - 1)) + PAGE_SIZE;

            BytesInFirstPage = SecondPageOffset - DirentByteOffset;

            DirentsInFirstPage = BytesInFirstPage / sizeof(DIRENT);

            FatPrepareWriteDirectoryFile( IrpContext,
                                          ParentDcb,
                                          SecondPageOffset,
                                          sizeof(DIRENT),
                                          &SecondPageBcb,
                                          &SecondPageDirent,
                                          FALSE,
                                          TRUE,
                                          &Iosb.Status );

            ASSERT( NT_SUCCESS( Iosb.Status ) && SecondPageBcb && SecondPageDirent );

            FirstPageDirent = Dirent;

            Dirent = FsRtlAllocatePoolWithTag( PagedPool,
                                               DirentsNeeded * sizeof(DIRENT),
                                               TAG_DIRENT );

            DirentFromPool = TRUE;
        }

        //
        //  Bump up Dirent and DirentByteOffset
        //

        ShortDirent = Dirent + DirentsNeeded - 1;
        ShortDirentByteOffset = DirentByteOffset +
                                (DirentsNeeded - 1) * sizeof(DIRENT);

        ASSERT( NT_SUCCESS( Iosb.Status ));


        //
        //  Fill in the fields of the dirent.
        //

        FatConstructDirent( IrpContext,
                            ShortDirent,
                            &ShortName,
                            AllLowerComponent,
                            AllLowerExtension,
                            CreateLfn ? UnicodeName : NULL,
                            (UCHAR)(FileAttributes | FAT_DIRENT_ATTR_DIRECTORY),
                            TRUE,
                            NULL );

        //
        //  If the dirent crossed pages, we have to do some real gross stuff.
        //

        if (DirentFromPool) {

            RtlCopyMemory( FirstPageDirent, Dirent, BytesInFirstPage );

            RtlCopyMemory( SecondPageDirent,
                           Dirent + DirentsInFirstPage,
                           DirentsNeeded*sizeof(DIRENT) - BytesInFirstPage );

            ShortDirent = SecondPageDirent + (DirentsNeeded - DirentsInFirstPage) - 1;
        }

        //
        //  Create a new dcb for the directory.
        //

        Dcb = FatCreateDcb( IrpContext,
                            Vcb,
                            ParentDcb,
                            DirentByteOffset,
                            ShortDirentByteOffset,
                            ShortDirent,
                            CreateLfn ? UnicodeName : NULL );

        //
        //  Tentatively add the new Ea's,
        //

        if (EaLength > 0) {

            //
            //  This returns false if we are trying to create a file
            //  with Need Ea's and don't understand EA's.
            //

            FatCreateEa( IrpContext,
                         Dcb->Vcb,
                         (PUCHAR) EaBuffer,
                         EaLength,
                         &Dcb->ShortName.Name.Oem,
                         &EaHandle );
        }


        if (!FatIsFat32(Dcb->Vcb)) {

            ShortDirent->ExtendedAttributes = EaHandle;
        }

        //
        //  After this point we cannot just simply mark the dirent deleted,
        //  we have to deal with the directory file object.
        //

        //
        //  Make the dirent into a directory.  Note that even if this call
        //  raises because of disk space, the diectory file object has been
        //  created.
        //

        FatInitializeDirectoryDirent( IrpContext, Dcb, ShortDirent );

        //
        //  Setup the context and section object pointers, and update
        //  our reference counts.  Note that this call cannot fail.
        //

        FatSetFileObject( FileObject,
                          UserDirectoryOpen,
                          Dcb,
                          Ccb = FatCreateCcb( IrpContext ) );

        //
        //  Initialize the LongFileName if it has not already been set, so that 
        //  FatNotify below won't have to.  If there are filesystem filters 
        //  attached to FAT, the LongFileName could have gotten set if the 
        //  filter queried for name information on this file object while 
        //  watching the IO needed in FatInitializeDirectoryDirent.
        //

        if (Dcb->FullFileName.Buffer == NULL) {
            
            FatSetFullNameInFcb( IrpContext, Dcb, UnicodeName );
        }

        //
        //  We call the notify package to report that the
        //  we added a file.
        //

        FatNotifyReportChange( IrpContext,
                               Vcb,
                               Dcb,
                               FILE_NOTIFY_CHANGE_DIR_NAME,
                               FILE_ACTION_ADDED );

        //
        //  Setup our share access
        //

        IoSetShareAccess( *DesiredAccess,
                          ShareAccess,
                          FileObject,
                          &Dcb->ShareAccess );

        //
        //  From this point on, nothing can raise.
        //

        Dcb->UncleanCount += 1;
        Dcb->OpenCount += 1;
        Vcb->OpenFileCount += 1;
        if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount += 1; }

        if (DeleteOnClose) {

            SetFlag( Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
        }

        //
        //  And set our return status
        //

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = FILE_CREATED;

    } finally {

        DebugUnwind( FatCreateNewDirectory );

        LocalAbnormalTermination = AbnormalTermination();
        
        //
        //  If this is an abnormal termination then undo our work
        //

        if (LocalAbnormalTermination) {

            //
            //  We always have to delete the Ccb if we created one.
            //

            if ( Ccb != NULL ) {

                FatDeleteCcb( IrpContext, Ccb );
            }
            
            if ( Dcb == NULL) {

                ASSERT( (ParentDcb->Specific.Dcb.UnusedDirentVbo == 0xffffffff) ||
                        RtlAreBitsSet( &ParentDcb->Specific.Dcb.FreeDirentBitmap,
                                       DirentByteOffset / sizeof(DIRENT),
                                       DirentsNeeded ) );

                RtlClearBits( &ParentDcb->Specific.Dcb.FreeDirentBitmap,
                              DirentByteOffset / sizeof(DIRENT),
                              DirentsNeeded );

                //
                //  Mark the dirents deleted.  The codes is complex because of
                //  dealing with an LFN than crosses a page boundry.
                //

                if (Dirent != NULL) {

                    ULONG i;

                    //
                    //  We failed before creating a directory file object.
                    //  We can just mark the dirent deleted and exit.
                    //

                    for (i = 0; i < DirentsNeeded; i++) {

                        if (DirentFromPool == FALSE) {

                            //
                            //  Simple case.
                            //

                            Dirent[i].FileName[0] = FAT_DIRENT_DELETED;

                        } else {

                            //
                            //  If the second CcPreparePinWrite failed, we have
                            //  to stop early.
                            //

                            if ((SecondPageBcb == NULL) &&
                                (i == DirentsInFirstPage)) {

                                break;
                            }

                            //
                            //  Now conditionally update either page.
                            //

                            if (i < DirentsInFirstPage) {

                                FirstPageDirent[i].FileName[0] = FAT_DIRENT_DELETED;

                            } else {

                                SecondPageDirent[i - DirentsInFirstPage].FileName[0] = FAT_DIRENT_DELETED;
                            }
                        }
                    }
                }
            }
        }

        //
        //  Just drop the Bcbs we have in the parent right now so if this
        //  was abnormal termination and we take the path to rip apart
        //  the partially created child, when we sync-uninit we won't cause
        //  a lazy writer processing the parent to block on us. This would
        //  consume one of the lazy writers, one of which must be running free
        //  in order for us to come back from the sync-uninit.
        //
        //  Neat, huh?
        //
        //  Granted, the delete dirent below will be marginally less efficient
        //  since the Bcb may be reclaimed by the time it executes. Life is
        //  tough.
        //

        FatUnpinBcb( IrpContext, DirentBcb );
        FatUnpinBcb( IrpContext, SecondPageBcb );

        if (DirentFromPool) {

            ExFreePool( Dirent );
        }

        if (LocalAbnormalTermination) {
            
            if (Dcb != NULL) {

                //
                //  We have created the Dcb.  If an error occurred while
                //  creating the Ea's, there will be no directory file
                //  object.
                //

                PFILE_OBJECT DirectoryFileObject;

                DirectoryFileObject = Dcb->Specific.Dcb.DirectoryFile;

                //
                //  Knock down all of the repinned data so we can begin to destroy
                //  this failed child.  We don't care about any raising here - we're
                //  already got a fire going.
                //
                //  Note that if we failed to do this, the repinned initial pieces
                //  of the child would cause the sync-uninit to block forever.
                //
                //  A previous spin on this fix had us not make the ./.. creation
                //  "reversible" (bad term) and thus avoid having the Bcb still
                //  outstanding.  This wound up causing very bad things to happen
                //  on DMF floppies when we tried to do a similar yank-down in the
                //  create path - we want the purge it does to make sure we never
                //  try to write the bytes out ... it is just a lot cleaner to
                //  unpinrepin.  I'll leave the reversible logic in place if it ever
                //  proves useful.
                //

                //
                //  There is a possibility that this may be a generally good idea
                //  for "live" finally clauses - set in ExceptionFilter, clear in
                //  ProcessException. Think about this.
                //
                
                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_RAISE );
                FatUnpinRepinnedBcbs( IrpContext );
                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_RAISE );
                
                if (DirectoryFileObject != NULL) {

                    FatSyncUninitializeCacheMap( IrpContext,
                                                 DirectoryFileObject );
                }

                try {
                    
                    //
                    //  Now zap the allocation backing it.  Do it after removing the cachemap so that
                    //  pending writes don't get perplexed looking at free FAT entries.
                    //

                    FatTruncateFileAllocation( IrpContext, Dcb, 0);
                    
                } finally {

                    try {
                        
                        //
                        //  Remove the directory entry we made in the parent Dcb.
                        //

                        FatDeleteDirent( IrpContext, Dcb, NULL, TRUE );
                        
                    } finally {
                        
                        //
                        //  Finaly, dereference the directory file object. This will
                        //  cause a close Irp to be processed, blowing away the Fcb.
                        //

                        if (DirectoryFileObject != NULL) {

                            //
                            //  The following was a fix for the PDK only, but after five
                            //  years it is the real one. By making this an unopened stream
                            //  file we won't try to clean up our parent.
                            //

                            InterlockedDecrement( &Dcb->Specific.Dcb.DirectoryFileOpenCount );
                            Dcb->Specific.Dcb.DirectoryFile = NULL;
                            FatSetFileObject( DirectoryFileObject,
                                              UnopenedFileObject,
                                              NULL,
                                              NULL );

                            ObDereferenceObject( DirectoryFileObject );
                        }

                        //
                        //  This was also a PDK fix.  If the stream file exists, this would
                        //  be done during the dereference file object operation.  Otherwise
                        //  we have to remove the Dcb and check if we should remove the parent.
                        //  For now we will just leave the parent lying around.
                        //

                        FatDeleteFcb( IrpContext, Dcb );
                    }
                }
            }

        }

        DebugTrace(-1, Dbg, "FatCreateNewDirectory -> Iosb.Status = %08lx\n", Iosb.Status);
    }

    UNREFERENCED_PARAMETER( EaBuffer );
    UNREFERENCED_PARAMETER( EaLength );

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
FatCreateNewFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN POEM_STRING OemName,
    IN PUNICODE_STRING UnicodeName,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN PUNICODE_STRING LfnBuffer,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose,
    IN BOOLEAN TemporaryFile
    )

/*++

Routine Description:

    This routine creates a new file.  The file has already been verified
    not to exist yet.

Arguments:

    FileObject - Supplies the file object for the newly created file

    Vcb - Supplies the Vcb denote the volume to contain the new file

    ParentDcb - Supplies the parent directory containg the newly created
        File

    OemName - Supplies the Oem name for the newly created file.  It may
        or maynot be 8.3 complient, but will be upcased.

    UnicodeName - Supplies the Unicode name for the newly created file.
        It may or maynot be 8.3 complient.  This name contains the original
        case information.

    DesiredAccess - Supplies the desired access of the caller

    ShareAccess - Supplies the shared access of the caller

    AllocationSize - Supplies the initial allocation size for the file

    EaBuffer - Supplies the Ea set for the newly created file

    EaLength - Supplies the length, in bytes, of EaBuffer

    FileAttributes - Supplies the file attributes for the newly created
        file

    LfnBuffer - A MAX_LFN sized buffer for directory searching

    IsPagingFile - Indicates if this is the paging file being created

    NoEaKnowledge - This opener doesn't understand Ea's and we fail this
        open if the file has NeedEa's.

    DeleteOnClose - The caller wants the file gone when the handle is closed

    TemporaryFile - Signals the lazywriter to not write dirty data unless
        absolutely has to.


Return Value:

    IO_STATUS_BLOCK - Returns the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    PFCB Fcb;

    PDIRENT Dirent = NULL;
    PBCB DirentBcb = NULL;
    ULONG DirentsNeeded;
    ULONG DirentByteOffset;

    PDIRENT ShortDirent;
    ULONG ShortDirentByteOffset;

    USHORT EaHandle;

    BOOLEAN AllLowerComponent;
    BOOLEAN AllLowerExtension;
    BOOLEAN CreateLfn;

    ULONG BytesInFirstPage;
    ULONG DirentsInFirstPage;
    PDIRENT FirstPageDirent;

    PBCB SecondPageBcb = NULL;
    ULONG SecondPageOffset;
    PDIRENT SecondPageDirent;

    BOOLEAN DirentFromPool = FALSE;

    OEM_STRING ShortName;
    UCHAR ShortNameBuffer[12];

    UNICODE_STRING UniTunneledShortName;
    WCHAR UniTunneledShortNameBuffer[12];
    UNICODE_STRING UniTunneledLongName;
    WCHAR UniTunneledLongNameBuffer[26];
    LARGE_INTEGER TunneledCreationTime;
    ULONG TunneledDataSize;
    BOOLEAN HaveTunneledInformation;
    BOOLEAN UsingTunneledLfn = FALSE;

    PUNICODE_STRING RealUnicodeName;

    //
    //  The following variables are for abnormal termination
    //

    PDIRENT UnwindDirent = NULL;
    PFCB UnwindFcb = NULL;
    BOOLEAN UnwindAllocation = FALSE;
    PCCB UnwindCcb = NULL;

    ULONG LocalAbnormalTermination = FALSE;

    DebugTrace(+1, Dbg, "FatCreateNewFile...\n", 0);

    ShortName.Length = 0;
    ShortName.MaximumLength = sizeof(ShortNameBuffer);
    ShortName.Buffer = &ShortNameBuffer[0];

    UniTunneledShortName.Length = 0;
    UniTunneledShortName.MaximumLength = sizeof(UniTunneledShortNameBuffer);
    UniTunneledShortName.Buffer = &UniTunneledShortNameBuffer[0];

    UniTunneledLongName.Length = 0;
    UniTunneledLongName.MaximumLength = sizeof(UniTunneledLongNameBuffer);
    UniTunneledLongName.Buffer = &UniTunneledLongNameBuffer[0];

    EaHandle = 0;

    //
    //  We fail this operation if the caller doesn't understand Ea's.
    //

    if (NoEaKnowledge
        && EaLength > 0) {

        Iosb.Status = STATUS_ACCESS_DENIED;

        DebugTrace(-1, Dbg, "FatCreateNewFile -> Iosb.Status = %08lx\n", Iosb.Status);
        return Iosb;
    }

    //
    //  DeleteOnClose and ReadOnly are not compatible.
    //

    if (DeleteOnClose && FlagOn(FileAttributes, FAT_DIRENT_ATTR_READ_ONLY)) {

        Iosb.Status = STATUS_CANNOT_DELETE;
        return Iosb;
    }

    //
    //  Look in the tunnel cache for names and timestamps to restore
    //

    TunneledDataSize = sizeof(LARGE_INTEGER);
    HaveTunneledInformation = FsRtlFindInTunnelCache( &Vcb->Tunnel,
                                                      FatDirectoryKey(ParentDcb),
                                                      UnicodeName,
                                                      &UniTunneledShortName,
                                                      &UniTunneledLongName,
                                                      &TunneledDataSize,
                                                      &TunneledCreationTime );
    ASSERT(TunneledDataSize == sizeof(LARGE_INTEGER));

    //
    //  Now get the names that we will be using.
    //

    FatSelectNames( IrpContext,
                    ParentDcb,
                    OemName,
                    UnicodeName,
                    &ShortName,
                    (HaveTunneledInformation? &UniTunneledShortName : NULL),
                    &AllLowerComponent,
                    &AllLowerExtension,
                    &CreateLfn );

    //
    //  If we are not in Chicago mode, ignore the magic bits.
    //

    RealUnicodeName = UnicodeName;

    if (!FatData.ChicagoMode) {

        AllLowerComponent = FALSE;
        AllLowerExtension = FALSE;
        CreateLfn = FALSE;

    } else {

        //
        //  If the Unicode name was legal for a short name and we got
        //  a tunneling hit which had a long name associated which is
        //  avaliable for use, use it.
        //

        if (!CreateLfn &&
            UniTunneledLongName.Length &&
            !FatLfnDirentExists(IrpContext, ParentDcb, &UniTunneledLongName, LfnBuffer)) {

            UsingTunneledLfn = TRUE;
            CreateLfn = TRUE;

            RealUnicodeName = &UniTunneledLongName;

            //
            //  Short names are always upcase if an LFN exists
            //

            AllLowerComponent = FALSE;
            AllLowerExtension = FALSE;
        }
    }

    //
    //  Create/allocate a new dirent
    //

    DirentsNeeded = CreateLfn ? FAT_LFN_DIRENTS_NEEDED(RealUnicodeName) + 1 : 1;

    DirentByteOffset = FatCreateNewDirent( IrpContext,
                                           ParentDcb,
                                           DirentsNeeded );

    try {

        FatPrepareWriteDirectoryFile( IrpContext,
                                      ParentDcb,
                                      DirentByteOffset,
                                      sizeof(DIRENT),
                                      &DirentBcb,
                                      &Dirent,
                                      FALSE,
                                      TRUE,
                                      &Iosb.Status );

        ASSERT( NT_SUCCESS( Iosb.Status ) );

        UnwindDirent = Dirent;

        //
        //  Deal with the special case of an LFN + Dirent structure crossing
        //  a page boundry.
        //

        if ((DirentByteOffset / PAGE_SIZE) !=
            ((DirentByteOffset + (DirentsNeeded - 1) * sizeof(DIRENT)) / PAGE_SIZE)) {

            SecondPageBcb;
            SecondPageOffset;
            SecondPageDirent;

            SecondPageOffset = (DirentByteOffset & ~(PAGE_SIZE - 1)) + PAGE_SIZE;

            BytesInFirstPage = SecondPageOffset - DirentByteOffset;

            DirentsInFirstPage = BytesInFirstPage / sizeof(DIRENT);

            FatPrepareWriteDirectoryFile( IrpContext,
                                          ParentDcb,
                                          SecondPageOffset,
                                          sizeof(DIRENT),
                                          &SecondPageBcb,
                                          &SecondPageDirent,
                                          FALSE,
                                          TRUE,
                                          &Iosb.Status );

            ASSERT( NT_SUCCESS( Iosb.Status ) );

            FirstPageDirent = Dirent;

            Dirent = FsRtlAllocatePoolWithTag( PagedPool,
                                               DirentsNeeded * sizeof(DIRENT),
                                               TAG_DIRENT );

            DirentFromPool = TRUE;
        }

        //
        //  Bump up Dirent and DirentByteOffset
        //

        ShortDirent = Dirent + DirentsNeeded - 1;
        ShortDirentByteOffset = DirentByteOffset +
                                (DirentsNeeded - 1) * sizeof(DIRENT);

        ASSERT( NT_SUCCESS( Iosb.Status ));


        //
        //  Fill in the fields of the dirent.
        //

        FatConstructDirent( IrpContext,
                            ShortDirent,
                            &ShortName,
                            AllLowerComponent,
                            AllLowerExtension,
                            CreateLfn ? RealUnicodeName : NULL,
                            (UCHAR)(FileAttributes | FILE_ATTRIBUTE_ARCHIVE),
                            TRUE,
                            (HaveTunneledInformation ? &TunneledCreationTime : NULL) );

        //
        //  If the dirent crossed pages, we have to do some real gross stuff.
        //

        if (DirentFromPool) {

            RtlCopyMemory( FirstPageDirent, Dirent, BytesInFirstPage );

            RtlCopyMemory( SecondPageDirent,
                           Dirent + DirentsInFirstPage,
                           DirentsNeeded*sizeof(DIRENT) - BytesInFirstPage );

            ShortDirent = SecondPageDirent + (DirentsNeeded - DirentsInFirstPage) - 1;
        }

        //
        //  Create a new Fcb for the file.  Once the Fcb is created we
        //  will not need to unwind dirent because delete dirent will
        //  now do the work.
        //

        Fcb = UnwindFcb = FatCreateFcb( IrpContext,
                                        Vcb,
                                        ParentDcb,
                                        DirentByteOffset,
                                        ShortDirentByteOffset,
                                        ShortDirent,
                                        CreateLfn ? RealUnicodeName : NULL,
                                        IsPagingFile,
                                        FALSE );
        UnwindDirent = NULL;

        //
        //  If this is a temporary file, note it in the FcbState
        //

        if (TemporaryFile) {

            SetFlag( Fcb->FcbState, FCB_STATE_TEMPORARY );
        }

        //
        //  Add some initial file allocation
        //

        FatAddFileAllocation( IrpContext, Fcb, FileObject, AllocationSize );
        UnwindAllocation = TRUE;

        Fcb->FcbState |= FCB_STATE_TRUNCATE_ON_CLOSE;

        //
        //  Tentatively add the new Ea's
        //

        if ( EaLength > 0 ) {

            FatCreateEa( IrpContext,
                         Fcb->Vcb,
                         (PUCHAR) EaBuffer,
                         EaLength,
                         &Fcb->ShortName.Name.Oem,
                         &EaHandle );
        }


        if (!FatIsFat32(Fcb->Vcb)) {

            ShortDirent->ExtendedAttributes = EaHandle;
        }

        //
        //  Initialize the LongFileName right now so that FatNotify
        //  below won't have to.
        //

        FatSetFullNameInFcb( IrpContext, Fcb, RealUnicodeName );

        //
        //  Setup the context and section object pointers, and update
        //  our reference counts
        //

        FatSetFileObject( FileObject,
                          UserFileOpen,
                          Fcb,
                          UnwindCcb = FatCreateCcb( IrpContext ));

        FileObject->SectionObjectPointer = &Fcb->NonPaged->SectionObjectPointers;

        //
        //  We call the notify package to report that the
        //  we added a file.
        //

        FatNotifyReportChange( IrpContext,
                               Vcb,
                               Fcb,
                               FILE_NOTIFY_CHANGE_FILE_NAME,
                               FILE_ACTION_ADDED );

        //
        //  Setup our share access
        //

        IoSetShareAccess( *DesiredAccess,
                          ShareAccess,
                          FileObject,
                          &Fcb->ShareAccess );

        Fcb->UncleanCount += 1;
        Fcb->OpenCount += 1;
        if (FlagOn(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING)) {
            Fcb->NonCachedUncleanCount += 1;
        }
        Vcb->OpenFileCount += 1;
        if (IsFileObjectReadOnly(FileObject)) { Vcb->ReadOnlyCount += 1; }

        //
        //  And set our return status
        //

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = FILE_CREATED;

        if ( NT_SUCCESS(Iosb.Status) ) {

            //
            //  Mark the DeleteOnClose bit if the operation was successful.
            //

            if ( DeleteOnClose ) {

                SetFlag( UnwindCcb->Flags, CCB_FLAG_DELETE_ON_CLOSE );
            }

            //
            //  Mark the OpenedByShortName bit if the operation was successful.
            //  If we created an Lfn, we have some sort of generated short name
            //  and thus don't consider ourselves to have opened it - though we
            //  may have had a case mix Lfn "Foo.bar" and generated "FOO.BAR"
            //
            //  Unless, of course, we wanted to create a short name and hit an
            //  associated Lfn in the tunnel cache
            //

            if ( !CreateLfn && !UsingTunneledLfn ) {

                SetFlag( UnwindCcb->Flags, CCB_FLAG_OPENED_BY_SHORTNAME );
            }
        }

    } finally {

        DebugUnwind( FatCreateNewFile );

        if (UniTunneledLongName.Buffer != UniTunneledLongNameBuffer) {

            //
            //  Tunneling package grew the buffer from pool
            //

            ExFreePool( UniTunneledLongName.Buffer );
        }

        //
        //  If this is an abnormal termination then undo our work.
        //
        //  The extra exception handling here is so nasty.  We've got
        //  two places here where an exception can be thrown again.
        //

        LocalAbnormalTermination = AbnormalTermination();

        if (LocalAbnormalTermination) {

            if (UnwindFcb == NULL) {

                ASSERT( (ParentDcb->Specific.Dcb.UnusedDirentVbo == 0xffffffff) ||
                        RtlAreBitsSet( &ParentDcb->Specific.Dcb.FreeDirentBitmap,
                                       DirentByteOffset / sizeof(DIRENT),
                                       DirentsNeeded ) );

                RtlClearBits( &ParentDcb->Specific.Dcb.FreeDirentBitmap,
                              DirentByteOffset / sizeof(DIRENT),
                              DirentsNeeded );
            }

            //
            //  Mark the dirents deleted.  The code is complex because of
            //  dealing with an LFN than crosses a page boundry.
            //

            if (UnwindDirent != NULL) {

                ULONG i;

                for (i = 0; i < DirentsNeeded; i++) {

                    if (DirentFromPool == FALSE) {

                        //
                        //  Simple case.
                        //

                        Dirent[i].FileName[0] = FAT_DIRENT_DELETED;

                    } else {

                        //
                        //  If the second CcPreparePinWrite failed, we have
                        //  to stop early.
                        //

                        if ((SecondPageBcb == NULL) &&
                            (i == DirentsInFirstPage)) {

                            break;
                        }

                        //
                        //  Now conditionally update either page.
                        //

                        if (i < DirentsInFirstPage) {

                            FirstPageDirent[i].FileName[0] = FAT_DIRENT_DELETED;

                        } else {

                            SecondPageDirent[i - DirentsInFirstPage].FileName[0] = FAT_DIRENT_DELETED;
                        }
                    }
                }
            }
        }

        //
        //  We must handle exceptions in the following fragments and plow on with the
        //  unwind of this create operation.  This is basically inverted from the
        //  previous state of the code.  Since AbnormalTermination() changes when we
        //  enter a new enclosure, we cached the original state ...
        //

        try {

            if (LocalAbnormalTermination) {
                if (UnwindAllocation) {
                    FatTruncateFileAllocation( IrpContext, Fcb, 0 );
                }
            }

        } finally {

            try {

                if (LocalAbnormalTermination) {
                    if (UnwindFcb != NULL) { 
                        FatDeleteDirent( IrpContext, UnwindFcb, NULL, TRUE );
                    }
                }

            } finally {

                if (LocalAbnormalTermination) {
                    if (UnwindFcb != NULL) { FatDeleteFcb( IrpContext, UnwindFcb ); }
                    if (UnwindCcb != NULL) { FatDeleteCcb( IrpContext, UnwindCcb ); }
                }

                //
                //  This is the normal cleanup code.
                //
                
                FatUnpinBcb( IrpContext, DirentBcb );
                FatUnpinBcb( IrpContext, SecondPageBcb );

                if (DirentFromPool) {
                    
                    ExFreePool( Dirent );
                }

            }
        }
        
        DebugTrace(-1, Dbg, "FatCreateNewFile -> Iosb.Status = %08lx\n", Iosb.Status);
    }

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
FatSupersedeOrOverwriteFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN ULONG CreateDisposition,
    IN BOOLEAN NoEaKnowledge
    )

/*++

Routine Description:

    This routine performs a file supersede or overwrite operation.

Arguments:

    FileObject - Supplies a pointer to the file object

    Fcb - Supplies a pointer to the Fcb

    AllocationSize - Supplies an initial allocation size

    EaBuffer - Supplies the Ea set for the superseded/overwritten file

    EaLength - Supplies the length, in bytes, of EaBuffer

    FileAttributes - Supplies the supersede/overwrite file attributes

    CreateDisposition - Supplies the create disposition for the file
        It must be either supersede, overwrite, or overwrite if.

    NoEaKnowledge - This opener doesn't understand Ea's and we fail this
        open if the file has NeedEa's.

Return Value:

    IO_STATUS_BLOCK - Returns the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    PDIRENT Dirent;
    PBCB DirentBcb;

    USHORT EaHandle = 0;
    BOOLEAN EaChange = FALSE;
    BOOLEAN ReleasePaging = FALSE;

    PCCB Ccb;

    ULONG NotifyFilter;

    //
    //  The following variables are for abnormal termination
    //

    PCCB UnwindCcb = NULL;
    USHORT UnwindEa = 0;

    DebugTrace(+1, Dbg, "FatSupersedeOrOverwriteFile...\n", 0);

    DirentBcb = NULL;

    //
    //  We fail this operation if the caller doesn't understand Ea's.
    //

    if (NoEaKnowledge
        && EaLength > 0) {

        Iosb.Status = STATUS_ACCESS_DENIED;

        DebugTrace(-1, Dbg, "FatSupersedeOrOverwriteFile -> Iosb.Status = %08lx\n", Iosb.Status);
        return Iosb;
    }

    try {

        //
        //  Before we actually truncate, check to see if the purge
        //  is going to fail.
        //

        if (!MmCanFileBeTruncated( &Fcb->NonPaged->SectionObjectPointers,
                                   &FatLargeZero )) {

            try_return( Iosb.Status = STATUS_USER_MAPPED_FILE );
        }

        //
        //  Setup the context and section object pointers, and update
        //  our reference counts
        //

        FatSetFileObject( FileObject,
                          UserFileOpen,
                          Fcb,
                          Ccb = UnwindCcb = FatCreateCcb( IrpContext ));

        FileObject->SectionObjectPointer = &Fcb->NonPaged->SectionObjectPointers;

        //
        //  Since this is an supersede/overwrite, purge the section so
        //  that mappers will see zeros.  We set the CREATE_IN_PROGRESS flag
        //  to prevent the Fcb from going away out from underneath us.
        //

        SetFlag(Fcb->Vcb->VcbState, VCB_STATE_FLAG_CREATE_IN_PROGRESS);

        CcPurgeCacheSection( &Fcb->NonPaged->SectionObjectPointers, NULL, 0, FALSE );

        //
        //  Tentatively add the new Ea's
        //

        if (EaLength > 0) {

            FatCreateEa( IrpContext,
                         Fcb->Vcb,
                         (PUCHAR) EaBuffer,
                         EaLength,
                         &Fcb->ShortName.Name.Oem,
                         &EaHandle );

            UnwindEa = EaHandle;
            EaChange = TRUE;
        }

        //
        //  Now set the new allocation size, we do that by first
        //  zeroing out the current file size.  Then we truncate and
        //  allocate up to the new allocation size
        //

        (VOID)ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource,
                                          TRUE );
        ReleasePaging = TRUE;

        Fcb->Header.FileSize.LowPart = 0;
        Fcb->Header.ValidDataLength.LowPart = 0;
        Fcb->ValidDataToDisk = 0;

        //
        //  Tell the cache manager the size went to zero
        //  This call is unconditional, because MM always wants to know.
        //

        CcSetFileSizes( FileObject,
                        (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );

        FatTruncateFileAllocation( IrpContext, Fcb, AllocationSize );
        
        ExReleaseResourceLite( Fcb->Header.PagingIoResource );
        ReleasePaging = FALSE;
        
        FatAddFileAllocation( IrpContext, Fcb, FileObject, AllocationSize );

        Fcb->FcbState |= FCB_STATE_TRUNCATE_ON_CLOSE;

        //
        //  Modify the attributes and time of the file, by first reading
        //  in the dirent for the file and then updating its attributes
        //  and time fields.  Note that for supersede we replace the file
        //  attributes as opposed to adding to them.
        //

        FatGetDirentFromFcbOrDcb( IrpContext,
                                  Fcb,
                                  &Dirent,
                                  &DirentBcb );

        //
        //  We must get the dirent since this Fcb is in good condition, verified as
        //  we crawled down the prefix tree.  Prefix (no relation) isn't noticing
        //  this guarantee, so I'll help.
        //

        ASSERT( Dirent && DirentBcb );

        //
        //  Update the appropriate dirent fields, and the fcb fields
        //

        Dirent->FileSize = 0;

        FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;

        if (CreateDisposition == FILE_SUPERSEDE) {

            Dirent->Attributes = FileAttributes;

        } else {

            Dirent->Attributes |= FileAttributes;
        }

        Fcb->DirentFatFlags = Dirent->Attributes;

        KeQuerySystemTime( &Fcb->LastWriteTime );

        (VOID)FatNtTimeToFatTime( IrpContext,
                                  &Fcb->LastWriteTime,
                                  TRUE,
                                  &Dirent->LastWriteTime,
                                  NULL );

        if (FatData.ChicagoMode) {

            Dirent->LastAccessDate = Dirent->LastWriteTime.Date;
        }

        NotifyFilter = FILE_NOTIFY_CHANGE_LAST_WRITE
                       | FILE_NOTIFY_CHANGE_ATTRIBUTES
                       | FILE_NOTIFY_CHANGE_SIZE;

        //
        //  And now delete the previous Ea set if there was one.
        //

        if (!FatIsFat32(Fcb->Vcb) && Dirent->ExtendedAttributes != 0) {

            //
            //  ****    SDK fix, we won't fail this if there is
            //          an error in the Ea's, we'll just leave
            //          the orphaned Ea's in the file.
            //

            EaChange = TRUE;

            try {

                FatDeleteEa( IrpContext,
                             Fcb->Vcb,
                             Dirent->ExtendedAttributes,
                             &Fcb->ShortName.Name.Oem );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                  FatResetExceptionState( IrpContext );
            }
        }

        //
        //  Update the extended attributes handle in the dirent.
        //

        if (EaChange) {

            ASSERT(!FatIsFat32(Fcb->Vcb));

            Dirent->ExtendedAttributes = EaHandle;

            NotifyFilter |= FILE_NOTIFY_CHANGE_EA;
        }

        //
        //  Now update the dirent to the new ea handle and set the bcb dirty
        //  Once we do this we can no longer back out the Ea
        //

        FatSetDirtyBcb( IrpContext, DirentBcb, Fcb->Vcb, TRUE );
        UnwindEa = 0;

        //
        //  Indicate that the Eas for this file have changed.
        //

        Ccb->EaModificationCount += Fcb->EaModificationCount;

        //
        //  Check to see if we need to notify outstanding Irps for full
        //  changes only (i.e., we haven't added, deleted, or renamed the file).
        //

        FatNotifyReportChange( IrpContext,
                               Fcb->Vcb,
                               Fcb,
                               NotifyFilter,
                               FILE_ACTION_MODIFIED );

        //
        //  And set our status to success
        //

        Iosb.Status = STATUS_SUCCESS;

        if (CreateDisposition == FILE_SUPERSEDE) {

            Iosb.Information = FILE_SUPERSEDED;

        } else {

            Iosb.Information = FILE_OVERWRITTEN;
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatSupersedeOfOverwriteFile );

        if (ReleasePaging)  {  ExReleaseResourceLite( Fcb->Header.PagingIoResource );  }
        
        //
        //  If this is an abnormal termination then undo our work.
        //

        if (AbnormalTermination()) {

            if (UnwindEa != 0) { FatDeleteEa( IrpContext, Fcb->Vcb, UnwindEa, &Fcb->ShortName.Name.Oem ); }
            if (UnwindCcb != NULL) { FatDeleteCcb( IrpContext, UnwindCcb ); }
        }

        FatUnpinBcb( IrpContext, DirentBcb );

        ClearFlag(Fcb->Vcb->VcbState, VCB_STATE_FLAG_CREATE_IN_PROGRESS);

        DebugTrace(-1, Dbg, "FatSupersedeOrOverwriteFile -> Iosb.Status = %08lx\n", Iosb.Status);
    }

    return Iosb;
}

VOID
FatSetFullNameInFcb(
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING FinalName
    )

/*++

Routine Description:

    This routine attempts a quick form of the full FatSetFullFileNameInFcb
    operation.

    NOTE: this routine is probably not worth the code duplication involved,
    and is not equipped to handle the cases where the parent doesn't have
    the full name set up.

Arguments:

    Fcb - Supplies a pointer to the Fcb

    FinalName - Supplies the last component of the path to this Fcb's dirent

Return Value:

    None.  May silently fail.

--*/

{
    ASSERT( Fcb->FullFileName.Buffer == NULL );

    //
    //  Prefer the ExactCaseLongName of the file for this operation, if set.  In
    //  this way we avoid building the fullname with a short filename.  Several
    //  operations assume this - the FinalNameLength in particular is the Lfn
    //  (if existant) length, and we use this to crack the fullname in paths
    //  such as the FsRtlNotify caller.
    //
    //  If the caller specified a particular name and it is short, it is the
    //  case that the long name was set up.
    //

    if (Fcb->ExactCaseLongName.Buffer) {

        ASSERT( Fcb->ExactCaseLongName.Length != 0 );
        FinalName = &Fcb->ExactCaseLongName;
    }

    //
    //  Special case the root.
    //

    if (NodeType(Fcb->ParentDcb) == FAT_NTC_ROOT_DCB) {

        Fcb->FullFileName.Length =
        Fcb->FullFileName.MaximumLength = sizeof(WCHAR) + FinalName->Length;

        Fcb->FullFileName.Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                             Fcb->FullFileName.Length,
                                                             TAG_FILENAME_BUFFER );

        Fcb->FullFileName.Buffer[0] = L'\\';

        RtlCopyMemory( &Fcb->FullFileName.Buffer[1],
                       &FinalName->Buffer[0],
                       FinalName->Length );

    } else {

        PUNICODE_STRING Prefix;

        Prefix = &Fcb->ParentDcb->FullFileName;

        //
        //  It is possible our parent's full filename is not set.  Simply fail
        //  this attempt.
        //

        if (Prefix->Buffer == NULL) {

            return;
        }

        Fcb->FullFileName.Length = 
        Fcb->FullFileName.MaximumLength = Prefix->Length + sizeof(WCHAR) + FinalName->Length;

        Fcb->FullFileName.Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                             Fcb->FullFileName.Length,
                                                             TAG_FILENAME_BUFFER );

        RtlCopyMemory( &Fcb->FullFileName.Buffer[0],
                       &Prefix->Buffer[0],
                       Prefix->Length );

        Fcb->FullFileName.Buffer[Prefix->Length / sizeof(WCHAR)] = L'\\';

        RtlCopyMemory( &Fcb->FullFileName.Buffer[(Prefix->Length / sizeof(WCHAR)) + 1],
                       &FinalName->Buffer[0],
                       FinalName->Length );

    }
}


NTSTATUS
FatCheckSystemSecurityAccess(
    PIRP_CONTEXT IrpContext
    )
{
    PACCESS_STATE AccessState;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp );

    //
    //  We check if the caller wants ACCESS_SYSTEM_SECURITY access on this
    //  object and fail the request if he does.
    //

    ASSERT( IrpSp->Parameters.Create.SecurityContext != NULL );
    AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;

    //
    //  Check if the remaining privilege includes ACCESS_SYSTEM_SECURITY.
    //

    if (FlagOn( AccessState->RemainingDesiredAccess, ACCESS_SYSTEM_SECURITY )) {

        if (!SeSinglePrivilegeCheck( FatSecurityPrivilege,
                                     UserMode )) {

            return STATUS_ACCESS_DENIED;
        }

        //
        //  Move this privilege from the Remaining access to Granted access.
        //

        ClearFlag( AccessState->RemainingDesiredAccess, ACCESS_SYSTEM_SECURITY );
        SetFlag( AccessState->PreviouslyGrantedAccess, ACCESS_SYSTEM_SECURITY );
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\close.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Fat called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_CLOSE)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

ULONG FatMaxDelayedCloseCount;


#define FatAcquireCloseMutex() {                        \
    ASSERT(KeAreApcsDisabled());                        \
    ExAcquireFastMutexUnsafe( &FatCloseQueueMutex );    \
}

#define FatReleaseCloseMutex() {                        \
    ASSERT(KeAreApcsDisabled());                        \
    ExReleaseFastMutexUnsafe( &FatCloseQueueMutex );    \
}

//
//  Local procedure prototypes
//

VOID
FatQueueClose (
    IN PCLOSE_CONTEXT CloseContext,
    IN BOOLEAN DelayClose
    );

PCLOSE_CONTEXT
FatRemoveClose (
    PVCB Vcb OPTIONAL,
    PVCB LastVcbHint OPTIONAL
    );

VOID
FatCloseWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatFsdClose)
#pragma alloc_text(PAGE, FatFspClose)
#pragma alloc_text(PAGE, FatCommonClose)
#pragma alloc_text(PAGE, FatCloseWorker)
#endif


NTSTATUS
FatFsdClose (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Close.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;
    TYPE_OF_OPEN TypeOfOpen;

    BOOLEAN TopLevel;

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if (FatDeviceIsFatFsdo( VolumeDeviceObject))  {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    DebugTrace(+1, Dbg, "FatFsdClose\n", 0);

    //
    //  Call the common Close routine
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    //
    //  Get a pointer to the current stack location and the file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;

    //
    //  Decode the file object and set the read-only bit in the Ccb.
    //

    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

    if (Ccb && IsFileObjectReadOnly(FileObject)) {

        SetFlag( Ccb->Flags, CCB_FLAG_READ_ONLY );
    }

    try {

        PCLOSE_CONTEXT CloseContext;

        //
        //  If we are top level, WAIT can be TRUE, otherwise make it FALSE
        //  to avoid deadlocks, unless this is a top
        //  level request not originating from the system process.
        //

        BOOLEAN Wait = TopLevel && (PsGetCurrentProcess() != FatData.OurProcess);

        //
        //  Call the common Close routine if we are not delaying this close.
        //

        if ((((TypeOfOpen == UserFileOpen) ||
              (TypeOfOpen == UserDirectoryOpen)) &&
             FlagOn(Fcb->FcbState, FCB_STATE_DELAY_CLOSE) &&
             !FatData.ShutdownStarted) ||
            (FatCommonClose(Vcb, Fcb, Ccb, TypeOfOpen, Wait, NULL) == STATUS_PENDING)) {

            //
            //  Metadata streams have had close contexts preallocated.
            //

            if (TypeOfOpen == VirtualVolumeFile ||
                TypeOfOpen == DirectoryFile ||
                TypeOfOpen == EaFile) {

                CloseContext = FatAllocateCloseContext();
                ASSERT( CloseContext != NULL );
                CloseContext->Free = TRUE;

            } else {

                //
                //  Free up any query template strings before using the close context fields,
                //  which overlap (union)
                //

                FatDeallocateCcbStrings( Ccb);

                CloseContext = &Ccb->CloseContext;
                CloseContext->Free = FALSE;
                
                SetFlag( Ccb->Flags, CCB_FLAG_CLOSE_CONTEXT );
            }

            //
            //  If the status is pending, then let's get the information we
            //  need into the close context we already have bagged, complete
            //  the request, and post it.  It is important we allocate nothing
            //  in the close path.
            //

            CloseContext->Vcb = Vcb;
            CloseContext->Fcb = Fcb;
            CloseContext->TypeOfOpen = TypeOfOpen;

            //
            //  Send it off, either to an ExWorkerThread or to the async
            //  close list.
            //

            FatQueueClose( CloseContext,
                           (BOOLEAN)(Fcb && FlagOn(Fcb->FcbState, FCB_STATE_DELAY_CLOSE)));
        } else {
            
            //
            //  The close proceeded synchronously, so for the metadata objects we
            //  can now drop the close context we preallocated.
            //
            
            if (TypeOfOpen == VirtualVolumeFile ||
                TypeOfOpen == DirectoryFile ||
                TypeOfOpen == EaFile) {

                CloseContext = FatAllocateCloseContext();
                ASSERT( CloseContext != NULL );

                ExFreePool( CloseContext );
            }

        }

        FatCompleteRequest( FatNull, Irp, Status );

    } except(FatExceptionFilter( NULL, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with the 
        //  error status that we get back from the execption code.
        //

        Status = FatProcessException( NULL, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdClose -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}

VOID
FatCloseWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is a shim between the IO worker package and FatFspClose.

Arguments:

    DeviceObject - Registration device object, unused
    Context - Context value, unused

Return Value:

    None.

--*/
{
    FsRtlEnterFileSystem();
    
    FatFspClose (Context);
    
    FsRtlExitFileSystem();
}


VOID
FatFspClose (
    IN PVCB Vcb OPTIONAL
    )

/*++

Routine Description:

    This routine implements the FSP part of Close.

Arguments:

    Vcb - If present, tells us to only close file objects opened on the
        specified volume.

Return Value:

    None.

--*/

{
    PCLOSE_CONTEXT CloseContext;
    PVCB CurrentVcb = NULL;
    PVCB LastVcb = NULL;
    BOOLEAN FreeContext;

    ULONG LoopsWithVcbHeld;
    
    DebugTrace(+1, Dbg, "FatFspClose\n", 0);

    //
    //  Set the top level IRP for the true FSP operation.
    //
    
    if (!ARGUMENT_PRESENT( Vcb )) {
        
        IoSetTopLevelIrp( (PIRP)FSRTL_FSP_TOP_LEVEL_IRP );
    }
    
    while (CloseContext = FatRemoveClose(Vcb, LastVcb)) {

        //
        //  If we are in the FSP (i.e. Vcb == NULL), then try to keep ahead of
        //  creates by doing several closes with one acquisition of the Vcb.
        //
        //  Note that we cannot be holding the Vcb on entry to FatCommonClose
        //  if this is last close as we will try to acquire FatData, and
        //  worse the volume (and therefore the Vcb) may go away.
        //

        if (!ARGUMENT_PRESENT(Vcb)) {
             
            if (!FatData.ShutdownStarted) {

                if (CloseContext->Vcb != CurrentVcb) {

                    LoopsWithVcbHeld = 0;

                    //
                    //  Release a previously held Vcb, if any.
                    //

                    if (CurrentVcb != NULL) {

                        ExReleaseResourceLite( &CurrentVcb->Resource);
                    }

                    //
                    //  Get the new Vcb.
                    //

                    CurrentVcb = CloseContext->Vcb;
                    (VOID)ExAcquireResourceExclusiveLite( &CurrentVcb->Resource, TRUE );

                } else {

                    //
                    //  Share the resource occasionally if we seem to be finding a lot
                    //  of closes for a single volume.
                    //

                    if (++LoopsWithVcbHeld >= 20) {

                        if (ExGetSharedWaiterCount( &CurrentVcb->Resource ) +
                            ExGetExclusiveWaiterCount( &CurrentVcb->Resource )) {

                            ExReleaseResourceLite( &CurrentVcb->Resource);
                            (VOID)ExAcquireResourceExclusiveLite( &CurrentVcb->Resource, TRUE );
                        }

                        LoopsWithVcbHeld = 0;
                    }
                }

                //
                //  Now check the Open count.  We may be about to delete this volume!
                //
                //  The test below must be <= 1 because there could still be outstanding
                //  stream references on this VCB that are not counted in the OpenFileCount.
                //  For example if there are no open files OpenFileCount could be zero and we would
                //  not release the resource here.  The call to FatCommonClose() below may cause
                //  the VCB to be torn down and we will try to release memory we don't
                //  own later.
                //

                if (CurrentVcb->OpenFileCount <= 1) {

                    ExReleaseResourceLite( &CurrentVcb->Resource);
                    CurrentVcb = NULL;
                }
            //
            //  If shutdown has started while processing our list, drop the
            //  current Vcb resource.
            //

            } else if (CurrentVcb != NULL) {

                ExReleaseResourceLite( &CurrentVcb->Resource);
                CurrentVcb = NULL;
            }
        }

        LastVcb = CurrentVcb;

        //
        //  Call the common Close routine.  Protected in a try {} except {}
        //

        try {

            //
            //  The close context either is in the CCB, automatically freed,
            //  or was from pool for a metadata fileobject, CCB is NULL, and
            //  we'll need to free it.
            //

            FreeContext = CloseContext->Free;

            (VOID)FatCommonClose( CloseContext->Vcb,
                                  CloseContext->Fcb,
                                  (FreeContext ? NULL :
                                                 CONTAINING_RECORD( CloseContext, CCB, CloseContext)),
                                  CloseContext->TypeOfOpen,
                                  TRUE,
                                  NULL );

        } except(FatExceptionFilter( NULL, GetExceptionInformation() )) {

            //
            //  Ignore anything we expect.
            //

              NOTHING;
        }

        //
        //  Drop the context if it came from pool.
        //
        
        if (FreeContext) {

            ExFreePool( CloseContext );
        }
    }

    //
    //  Release a previously held Vcb, if any.
    //

    if (CurrentVcb != NULL) {

        ExReleaseResourceLite( &CurrentVcb->Resource);
    }

    //
    //  Clean up the top level IRP hint if we owned it.
    //
    
    if (!ARGUMENT_PRESENT( Vcb )) {
        
        IoSetTopLevelIrp( NULL );
    }
    
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFspClose -> NULL\n", 0);

    return;
}


VOID
FatQueueClose (
    IN PCLOSE_CONTEXT CloseContext,
    IN BOOLEAN DelayClose
    )

/*++

Routine Description:

    Enqueue a deferred close to one of the two delayed close queues.

Arguments:

    CloseContext - a close context to enqueue for the delayed close thread.
    
    DelayClose - whether this should go on the delayed close queue (unreferenced
        objects).

Return Value:

    None.

--*/

{
    BOOLEAN StartWorker = FALSE;

    FatAcquireCloseMutex();

    if (DelayClose) {

        InsertTailList( &FatData.DelayedCloseList,
                        &CloseContext->GlobalLinks );
        InsertTailList( &CloseContext->Vcb->DelayedCloseList,
                        &CloseContext->VcbLinks );

        FatData.DelayedCloseCount += 1;

        if ((FatData.DelayedCloseCount > FatMaxDelayedCloseCount) &&
            !FatData.AsyncCloseActive) {

            FatData.AsyncCloseActive = TRUE;
            StartWorker = TRUE;
        }

    } else {

        InsertTailList( &FatData.AsyncCloseList,
                        &CloseContext->GlobalLinks );
        InsertTailList( &CloseContext->Vcb->AsyncCloseList,
                        &CloseContext->VcbLinks );

        FatData.AsyncCloseCount += 1;

        if (!FatData.AsyncCloseActive) {

            FatData.AsyncCloseActive = TRUE;
            StartWorker = TRUE;
        }
    }

    FatReleaseCloseMutex();

    if (StartWorker) {

        IoQueueWorkItem( FatData.FatCloseItem, FatCloseWorker, CriticalWorkQueue, NULL );
    }
}


PCLOSE_CONTEXT
FatRemoveClose (
    PVCB Vcb OPTIONAL,
    PVCB LastVcbHint OPTIONAL
    )

/*++

Routine Description:

    Dequeue a deferred close from one of the two delayed close queues.

Arguments:

    Vcb - if specified, only returns close for this volume.
    
    LastVcbHint - if specified and other starvation avoidance is required by
        the system condition, will attempt to return closes for this volume.

Return Value:

    A close to perform.

--*/

{
    PLIST_ENTRY Entry;
    PCLOSE_CONTEXT CloseContext;
    BOOLEAN WorkerThread;

    FatAcquireCloseMutex();

    //
    //  Remember if this is the worker thread, so we can pull down the active
    //  flag should we run everything out.
    //
    
    WorkerThread = (Vcb == NULL);

    //
    //  If the queues are above the limits by a significant amount, we have
    //  to try hard to pull them down.  To do this, we will aggresively try
    //  to find closes for the last volume the caller looked at.  This will
    //  make sure we fully utilize the acquisition of the volume, which can
    //  be a hugely expensive resource to get (create/close/cleanup use it
    //  exclusively).
    //
    //  Only do this in the delayed close thread.  We will know this is the
    //  case by seeing a NULL mandatory Vcb.
    //

    if (Vcb == NULL && LastVcbHint != NULL) {

        //
        //  Flip over to aggressive at twice the legal limit, and flip it
        //  off at the legal limit.
        //
        
        if (!FatData.HighAsync && FatData.AsyncCloseCount > FatMaxDelayedCloseCount*2) {

            FatData.HighAsync = TRUE;
        
        } else if (FatData.HighAsync && FatData.AsyncCloseCount < FatMaxDelayedCloseCount) {

            FatData.HighAsync = FALSE;
        }
            
        if (!FatData.HighDelayed && FatData.DelayedCloseCount > FatMaxDelayedCloseCount*2) {

            FatData.HighDelayed = TRUE;
        
        } else if (FatData.HighDelayed && FatData.DelayedCloseCount < FatMaxDelayedCloseCount) {

            FatData.HighDelayed = FALSE;
        }

        if (FatData.HighAsync || FatData.HighDelayed) {

            Vcb = LastVcbHint;
        }
    }
        
    //
    //  Do the case when we don't care about which Vcb the close is on.
    //  This is the case when we are in an ExWorkerThread and aren't
    //  under pressure.
    //

    if (Vcb == NULL) {

        AnyClose:

        //
        //  First check the list of async closes.
        //

        if (!IsListEmpty( &FatData.AsyncCloseList )) {

            Entry = RemoveHeadList( &FatData.AsyncCloseList );
            FatData.AsyncCloseCount -= 1;

            CloseContext = CONTAINING_RECORD( Entry,
                                              CLOSE_CONTEXT,
                                              GlobalLinks );

            RemoveEntryList( &CloseContext->VcbLinks );

        //
        //  Do any delayed closes over half the limit, unless shutdown has
        //  started (then kill them all).
        //

        } else if (!IsListEmpty( &FatData.DelayedCloseList ) &&
                   (FatData.DelayedCloseCount > FatMaxDelayedCloseCount/2 ||
                    FatData.ShutdownStarted)) {

            Entry = RemoveHeadList( &FatData.DelayedCloseList );
            FatData.DelayedCloseCount -= 1;

            CloseContext = CONTAINING_RECORD( Entry,
                                              CLOSE_CONTEXT,
                                              GlobalLinks );

            RemoveEntryList( &CloseContext->VcbLinks );

        //
        //  There are no more closes to perform; show that we are done.
        //

        } else {

            CloseContext = NULL;

            if (WorkerThread) {
                
                FatData.AsyncCloseActive = FALSE;
            }
        }

    //
    //  We're running down a specific volume.
    //
    
    } else {


        //
        //  First check the list of async closes.
        //

        if (!IsListEmpty( &Vcb->AsyncCloseList )) {

            Entry = RemoveHeadList( &Vcb->AsyncCloseList );
            FatData.AsyncCloseCount -= 1;

            CloseContext = CONTAINING_RECORD( Entry,
                                              CLOSE_CONTEXT,
                                              VcbLinks );

            RemoveEntryList( &CloseContext->GlobalLinks );

        //
        //  Do any delayed closes.
        //

        } else if (!IsListEmpty( &Vcb->DelayedCloseList )) {

            Entry = RemoveHeadList( &Vcb->DelayedCloseList );
            FatData.DelayedCloseCount -= 1;

            CloseContext = CONTAINING_RECORD( Entry,
                                              CLOSE_CONTEXT,
                                              VcbLinks );
        
            RemoveEntryList( &CloseContext->GlobalLinks );
        
        //
        //  If we were trying to run down the queues but didn't find anything for this
        //  volume, flip over to accept anything and try again.
        //

        } else if (LastVcbHint) {

            goto AnyClose;
        
        //
        //  There are no more closes to perform; show that we are done.
        //

        } else {

            CloseContext = NULL;
        }
    }

    FatReleaseCloseMutex();

    return CloseContext;
}


NTSTATUS
FatCommonClose (
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN Wait,
    IN PVOLUME_DEVICE_OBJECT *VolDo OPTIONAL
    )

/*++

Routine Description:

    This is the common routine for closing a file/directory called by both
    the fsd and fsp threads.

    Close is invoked whenever the last reference to a file object is deleted.
    Cleanup is invoked when the last handle to a file object is closed, and
    is called before close.

    The function of close is to completely tear down and remove the fcb/dcb/ccb
    structures associated with the file object.

Arguments:

    Fcb - Supplies the file to process.

    Wait - If this is TRUE we are allowed to block for the Vcb, if FALSE
        then we must try to acquire the Vcb anyway.

    VolDo - This is really gross.  If we are really in the Fsp, and a volume
        goes away.  We need some way to NULL out the VolDo variable in
        FspDispatch().

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PDCB ParentDcb;
    BOOLEAN RecursiveClose;
    IRP_CONTEXT IrpContext;

    DebugTrace(+1, Dbg, "FatCommonClose...\n", 0);

    //
    //  Special case the unopened file object
    //

    if (TypeOfOpen == UnopenedFileObject) {

        DebugTrace(0, Dbg, "Close unopened file object\n", 0);

        Status = STATUS_SUCCESS;

        DebugTrace(-1, Dbg, "FatCommonClose -> %08lx\n", Status);
        return Status;
    }

    //
    //  Set up our stack IrpContext.
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );

    if (Wait) {

        SetFlag( IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT );
    }

    //
    //  Acquire exclusive access to the Vcb and enqueue the irp if we didn't
    //  get access.
    //

    if (!ExAcquireResourceExclusiveLite( &Vcb->Resource, Wait )) {

        return STATUS_PENDING;
    }

    //
    //  The following test makes sure that we don't blow away an Fcb if we
    //  are trying to do a Supersede/Overwrite open above us.  This test
    //  does not apply for the EA file.
    //

    if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_CREATE_IN_PROGRESS) &&
        Vcb->EaFcb != Fcb) {

        ExReleaseResourceLite( &Vcb->Resource );

        return STATUS_PENDING;
    }

    //
    //  Setting the following flag prevents recursive closes of directory file
    //  objects, which are handled in a special case loop.
    //

    if ( FlagOn(Vcb->VcbState, VCB_STATE_FLAG_CLOSE_IN_PROGRESS) ) {

        RecursiveClose = TRUE;

    } else {

        SetFlag(Vcb->VcbState, VCB_STATE_FLAG_CLOSE_IN_PROGRESS);

        RecursiveClose = FALSE;
    }

    //
    //  Synchronize here with other closes regarding volume deletion.  Note
    //  that the Vcb->OpenFileCount can be safely incremented here without
    //  FatData synchronization for the following reasons:
    //
    //  This counter only becomes relevant when (holding a spinlock):
    //
    //      A: The Vcb->OpenFileCount is zero, and
    //      B: The Vpb->Refcount is the residual (2/3 for close/verify)
    //
    //  For A to be true, there can be no more pending closes at this point
    //  in the close code.  For B to be true, in close, there cannot be
    //  a create in process, and thus no verify in process.
    //
    //  Also we only increment the count if this is a top level close.
    //

    if ( !RecursiveClose ) {

        Vcb->OpenFileCount += 1;
    }

    try {

        //
        //  Case on the type of open that we are trying to close.
        //

        switch (TypeOfOpen) {

        case VirtualVolumeFile:

            DebugTrace(0, Dbg, "Close VirtualVolumeFile\n", 0);

            try_return( Status = STATUS_SUCCESS );
            break;

        case UserVolumeOpen:

            DebugTrace(0, Dbg, "Close UserVolumeOpen\n", 0);

            Vcb->DirectAccessOpenCount -= 1;
            Vcb->OpenFileCount -= 1;
            if (FlagOn(Ccb->Flags, CCB_FLAG_READ_ONLY)) { Vcb->ReadOnlyCount -= 1; }

            FatDeleteCcb( &IrpContext, Ccb );

            try_return( Status = STATUS_SUCCESS );
            break;

        case EaFile:

            DebugTrace(0, Dbg, "Close EaFile\n", 0);

            try_return( Status = STATUS_SUCCESS );
            break;

        case DirectoryFile:

            DebugTrace(0, Dbg, "Close DirectoryFile\n", 0);

            InterlockedDecrement( &Fcb->Specific.Dcb.DirectoryFileOpenCount );

            //
            //  If this is a recursive close, just return here.
            //

            if ( RecursiveClose ) {

                try_return( Status = STATUS_SUCCESS );

            } else {

                break;
            }

        case UserDirectoryOpen:
        case UserFileOpen:

            DebugTrace(0, Dbg, "Close UserFileOpen/UserDirectoryOpen\n", 0);

            //
            //  Uninitialize the cache map if we no longer need to use it
            //

            if ((NodeType(Fcb) == FAT_NTC_DCB) &&
                IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue) &&
                (Fcb->OpenCount == 1) &&
                (Fcb->Specific.Dcb.DirectoryFile != NULL)) {

                PFILE_OBJECT DirectoryFileObject = Fcb->Specific.Dcb.DirectoryFile;

                DebugTrace(0, Dbg, "Uninitialize the stream file object\n", 0);

                CcUninitializeCacheMap( DirectoryFileObject, NULL, NULL );

                //
                //  Dereference the directory file.  This may cause a close
                //  Irp to be processed, so we need to do this before we destory
                //  the Fcb.
                //

                Fcb->Specific.Dcb.DirectoryFile = NULL;
                ObDereferenceObject( DirectoryFileObject );
            }

            Fcb->OpenCount -= 1;
            Vcb->OpenFileCount -= 1;
            if (FlagOn(Ccb->Flags, CCB_FLAG_READ_ONLY)) { Vcb->ReadOnlyCount -= 1; }

            FatDeleteCcb( &IrpContext, Ccb );

            break;

        default:

            FatBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        //  At this point we've cleaned up any on-disk structure that needs
        //  to be done, and we can now update the in-memory structures.
        //  Now if this is an unreferenced FCB or if it is
        //  an unreferenced DCB (not the root) then we can remove
        //  the fcb and set our ParentDcb to non null.
        //

        if (((NodeType(Fcb) == FAT_NTC_FCB) &&
             (Fcb->OpenCount == 0))

                ||

             ((NodeType(Fcb) == FAT_NTC_DCB) &&
              (IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue)) &&
              (Fcb->OpenCount == 0) &&
              (Fcb->Specific.Dcb.DirectoryFileOpenCount == 0))) {

            ParentDcb = Fcb->ParentDcb;

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB );

            FatDeleteFcb( &IrpContext, Fcb );

            //
            //  Uninitialize our parent's cache map if we no longer need
            //  to use it.
            //

            while ((NodeType(ParentDcb) == FAT_NTC_DCB) &&
                   IsListEmpty(&ParentDcb->Specific.Dcb.ParentDcbQueue) &&
                   (ParentDcb->OpenCount == 0) &&
                   (ParentDcb->Specific.Dcb.DirectoryFile != NULL)) {

                PFILE_OBJECT DirectoryFileObject;

                DirectoryFileObject = ParentDcb->Specific.Dcb.DirectoryFile;

                DebugTrace(0, Dbg, "Uninitialize our parent Stream Cache Map\n", 0);

                CcUninitializeCacheMap( DirectoryFileObject, NULL, NULL );

                ParentDcb->Specific.Dcb.DirectoryFile = NULL;

                ObDereferenceObject( DirectoryFileObject );

                //
                //  Now, if the ObDereferenceObject() caused the final close
                //  to come in, then blow away the Fcb and continue up,
                //  otherwise wait for Mm to to dereference its file objects
                //  and stop here..
                //

                if ( ParentDcb->Specific.Dcb.DirectoryFileOpenCount == 0) {

                    PDCB CurrentDcb;

                    CurrentDcb = ParentDcb;
                    ParentDcb = CurrentDcb->ParentDcb;

                    SetFlag( Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB );

                    FatDeleteFcb( &IrpContext, CurrentDcb );

                } else {

                    break;
                }
            }
        }

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatCommonClose );

        if ( !RecursiveClose ) {

            ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_CLOSE_IN_PROGRESS );
        }

        //
        //  Check if we should delete the volume.  Unfortunately, to correctly
        //  synchronize with verify, we can only unsafely check our own
        //  transition.  This results in a little bit of extra overhead in the
        //  1 -> 0 OpenFileCount transition.
        //
        //  2 is the residual Vpb->RefCount on a volume to be freed.
        //

        //
        //  Here is the deal with releasing the Vcb.  We must be holding the
        //  Vcb when decrementing the Vcb->OpenFileCount.  If we don't this
        //  could cause the decrement to mal-function on an MP system.  But we
        //  want to be holding the Global resource exclusive when decrement
        //  the count so that nobody else will try to dismount the volume.
        //  However, because of locking rules, the Global resource must be
        //  acquired first, which is why we do what we do below.
        //

        if ( !RecursiveClose ) {

            if ( Vcb->OpenFileCount == 1 ) {

                PVPB Vpb = Vcb->Vpb;

                SetFlag( IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT );

                FatReleaseVcb( &IrpContext, Vcb );

                (VOID)FatAcquireExclusiveGlobal( &IrpContext );
                (VOID)FatAcquireExclusiveVcb( &IrpContext, Vcb );

                Vcb->OpenFileCount -= 1;

                FatReleaseVcb( &IrpContext, Vcb );

                //
                //  We can now "safely" check OpenFileCount and VcbCondition.
                //  If they are OK, we will proceed to checking the
                //  Vpb Ref Count in FatCheckForDismount.
                //

                if ( (Vcb->OpenFileCount == 0) &&
                     ((Vcb->VcbCondition == VcbNotMounted) ||
                      (Vcb->VcbCondition == VcbBad) ||
                      FlagOn( Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN )) &&
                     FatCheckForDismount( &IrpContext, Vcb, FALSE ) ) {


                    //
                    //  If this is not the Vpb "attached" to the device, free it.
                    //

                    if ((Vpb->RealDevice->Vpb != Vpb) &&
                        !FlagOn( Vpb->Flags, VPB_PERSISTENT)) {

                        ExFreePool( Vpb );
                    }

                    if (ARGUMENT_PRESENT(VolDo)) {

                        *VolDo = NULL;
                    }
                }

                FatReleaseGlobal( &IrpContext );

            } else {

                Vcb->OpenFileCount -= 1;

                FatReleaseVcb( &IrpContext, Vcb );
            }

        } else {

            FatReleaseVcb( &IrpContext, Vcb );
        }

        DebugTrace(-1, Dbg, "FatCommonClose -> %08lx\n", Status);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\deviosup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DevIoSup.c

Abstract:

    This module implements the low lever disk read/write support for Fat.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    22-Jan-1990

Revision History:

    David Goebel    [DavidGoe]  05-Oct-1990

        Major changes for the new FAT


    Tom Miller      [TomM]      22-Apr-1990

        Added User Buffer Locking and Mapping routines
        Modified behavior of async I/O routines to use completion routines

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_DEVIOSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVIOSUP)

#define CollectDiskIoStats(VCB,FUNCTION,IS_USER_IO,COUNT) {                                    \
    PFILESYSTEM_STATISTICS Stats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()].Common;   \
    if (IS_USER_IO) {                                                                          \
        if ((FUNCTION) == IRP_MJ_WRITE) {                                                      \
            Stats->UserDiskWrites += (COUNT);                                                  \
        } else {                                                                               \
            Stats->UserDiskReads += (COUNT);                                                   \
        }                                                                                      \
    } else {                                                                                   \
        if ((FUNCTION) == IRP_MJ_WRITE) {                                                      \
            Stats->MetaDataDiskWrites += (COUNT);                                              \
        } else {                                                                               \
            Stats->MetaDataDiskReads += (COUNT);                                               \
        }                                                                                      \
    }                                                                                          \
}

//
// Completion Routine declarations
//

NTSTATUS
FatMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
FatMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
FatSpecialSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
FatSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
FatSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
FatPagingFileCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MasterIrp
    );

NTSTATUS
FatPagingFileCompletionRoutineCatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

VOID
FatSingleNonAlignedSync (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PUCHAR Buffer,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    );

//
//  The following macro decides whether to send a request directly to
//  the device driver, or to other routines.  It was meant to
//  replace IoCallDriver as transparently as possible.  It must only be
//  called with a read or write Irp.
//
//  NTSTATUS
//  FatLowLevelReadWrite (
//      PIRP_CONTEXT IrpContext,
//      PDEVICE_OBJECT DeviceObject,
//      PIRP Irp,
//      PVCB Vcb
//      );
//

#define FatLowLevelReadWrite(IRPCONTEXT,DO,IRP,VCB) ( \
    IoCallDriver((DO),(IRP))                          \
)

//
//  The following macro handles completion-time zeroing of buffers.
//

#define FatDoCompletionZero( I, C )                                     \
    if ((C)->ZeroMdl) {                                                 \
        ASSERT( (C)->ZeroMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |     \
                                          MDL_SOURCE_IS_NONPAGED_POOL));\
        if (NT_SUCCESS((I)->IoStatus.Status)) {                         \
            RtlZeroMemory( (C)->ZeroMdl->MappedSystemVa,                \
                           (C)->ZeroMdl->ByteCount );                   \
        }                                                               \
        IoFreeMdl((C)->ZeroMdl);                                        \
        (C)->ZeroMdl = NULL;                                            \
    }
    
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatMultipleAsync)
#pragma alloc_text(PAGE, FatSingleAsync)
#pragma alloc_text(PAGE, FatSingleNonAlignedSync)
#pragma alloc_text(PAGE, FatWaitSync)
#pragma alloc_text(PAGE, FatLockUserBuffer)
#pragma alloc_text(PAGE, FatBufferUserBuffer)
#pragma alloc_text(PAGE, FatMapUserBuffer)
#pragma alloc_text(PAGE, FatNonCachedIo)
#pragma alloc_text(PAGE, FatSingleNonAlignedSync)
#pragma alloc_text(PAGE, FatNonCachedNonAlignedRead)
#endif

typedef struct FAT_PAGING_FILE_CONTEXT {
    KEVENT Event;
    PMDL RestoreMdl;
} FAT_PAGING_FILE_CONTEXT, *PFAT_PAGING_FILE_CONTEXT;


VOID
FatPagingFileIo (
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    This routine nevers blocks, and should only be used with the paging
    file since no completion processing is performed.

Arguments:

    Irp - Supplies the requesting Irp.

    Fcb - Supplies the file to act on.

Return Value:

    None.

--*/

{
    //
    // Declare some local variables for enumeration through the
    // runs of the file.
    //

    VBO Vbo;
    ULONG ByteCount;

    PMDL Mdl;
    LBO NextLbo;
    VBO NextVbo;
    ULONG NextByteCount;
    ULONG RemainingByteCount;
    BOOLEAN MustSucceed;

    ULONG FirstIndex;
    ULONG CurrentIndex;
    ULONG LastIndex;

    LBO LastLbo;
    ULONG LastByteCount;

    BOOLEAN MdlIsReserve = FALSE;
    BOOLEAN IrpIsMaster = FALSE;
    FAT_PAGING_FILE_CONTEXT Context;
    LONG IrpCount;

    PIRP AssocIrp;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    ULONG BufferOffset;
    PDEVICE_OBJECT DeviceObject;

    DebugTrace(+1, Dbg, "FatPagingFileIo\n", 0);
    DebugTrace( 0, Dbg, "Irp = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "Fcb = %08lx\n", Fcb );

    ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ));

    //
    //  Initialize some locals.
    //

    BufferOffset = 0;
    DeviceObject = Fcb->Vcb->TargetDeviceObject;
    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    Vbo = IrpSp->Parameters.Read.ByteOffset.LowPart;
    ByteCount = IrpSp->Parameters.Read.Length;

    MustSucceed = FatLookupMcbEntry( Fcb->Vcb, &Fcb->Mcb,
                                     Vbo,
                                     &NextLbo,
                                     &NextByteCount,
                                     &FirstIndex);

    //
    //  If this run isn't present, something is very wrong.
    //

    if (!MustSucceed) {

        FatBugCheck( Vbo, ByteCount, 0 );
    }

    //
    // See if the write covers a single valid run, and if so pass
    // it on.
    //

    if ( NextByteCount >= ByteCount ) {

        DebugTrace( 0, Dbg, "Passing Irp on to Disk Driver\n", 0 );

        //
        //  Setup the next IRP stack location for the disk driver beneath us.
        //

        NextIrpSp = IoGetNextIrpStackLocation( Irp );

        NextIrpSp->MajorFunction = IrpSp->MajorFunction;
        NextIrpSp->Parameters.Read.Length = ByteCount;
        NextIrpSp->Parameters.Read.ByteOffset.QuadPart = NextLbo;

        //
        //  Since this is Paging file IO, we'll just ignore the verify bit.
        //

        SetFlag( NextIrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );

        //
        //  Set up the completion routine address in our stack frame.
        //  This is only invoked on error or cancel, and just copies
        //  the error Status into master irp's iosb.
        //
        //  If the error implies a media problem, it also enqueues a
        //  worker item to write out the dirty bit so that the next
        //  time we run we will do a autochk /r
        //

        IoSetCompletionRoutine( Irp,
                                &FatPagingFileCompletionRoutine,
                                Irp,
                                FALSE,
                                TRUE,
                                TRUE );

        //
        //  Issue the read/write request
        //
        //  If IoCallDriver returns an error, it has completed the Irp
        //  and the error will be dealt with as a normal IO error.
        //

        (VOID)IoCallDriver( DeviceObject, Irp );

        DebugTrace(-1, Dbg, "FatPagingFileIo -> VOID\n", 0);
        return;
    }

    //
    //  Find out how may runs there are.
    //

    MustSucceed = FatLookupMcbEntry( Fcb->Vcb, &Fcb->Mcb,
                                     Vbo + ByteCount - 1,
                                     &LastLbo,
                                     &LastByteCount,
                                     &LastIndex);

    //
    //  If this run isn't present, something is very wrong.
    //

    if (!MustSucceed) {

        FatBugCheck( Vbo + ByteCount - 1, 1, 0 );
    }

    CurrentIndex = FirstIndex;

    //
    //  Now set up the Irp->IoStatus.  It will be modified by the
    //  multi-completion routine in case of error or verify required.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = ByteCount;

    //
    //  Loop while there are still byte writes to satisfy.  The way we'll work this
    //  is to hope for the best - one associated IRP per run, which will let us be
    //  completely async after launching all the IO.
    //
    //  IrpCount will indicate the remaining number of associated Irps to launch.
    //
    //  All we have to do is make sure IrpCount doesn't hit zero before we're building
    //  the very last Irp.  If it is positive when we're done, it means we have to
    //  wait for the rest of the associated Irps to come back before we complete the
    //  master by hand.
    //
    //  This will keep the master from completing early.
    //

    Irp->AssociatedIrp.IrpCount = IrpCount = LastIndex - FirstIndex + 1;

    while (CurrentIndex <= LastIndex) {

        //
        //  Reset this for unwinding purposes
        //

        AssocIrp = NULL;

        //
        //  If next run is larger than we need, "ya get what ya need".
        //

        if (NextByteCount > ByteCount) {
            NextByteCount = ByteCount;
        }

        RemainingByteCount = 0;

        //
        // Allocate and build a partial Mdl for the request.
        //

        Mdl = IoAllocateMdl( (PCHAR)Irp->UserBuffer + BufferOffset,
                             NextByteCount,
                             FALSE,
                             FALSE,
                             AssocIrp );

        if (Mdl == NULL) {

            //
            //  Pick up the reserve MDL
            //

            KeWaitForSingleObject( &FatReserveEvent, Executive, KernelMode, FALSE, NULL );

            Mdl = FatReserveMdl;
            MdlIsReserve = TRUE;

            //
            //  Trim to fit the size of the reserve MDL.
            //

            if (NextByteCount > FAT_RESERVE_MDL_SIZE * PAGE_SIZE) {

                RemainingByteCount = NextByteCount - FAT_RESERVE_MDL_SIZE * PAGE_SIZE;
                NextByteCount = FAT_RESERVE_MDL_SIZE * PAGE_SIZE;
            }
        }

        IoBuildPartialMdl( Irp->MdlAddress,
                           Mdl,
                           (PCHAR)Irp->UserBuffer + BufferOffset,
                           NextByteCount );

        //
        //  Now that we have properly bounded this piece of the transfer, it is
        //  time to read/write it.  We can simplify life slightly by always
        //  re-using the master IRP for cases where we use the reserve MDL,
        //  since we'll always be synchronous for those and can use a single
        //  completion context on our local stack.
        //
        //  We also must prevent ourselves from issuing an associated IRP that would
        //  complete the master UNLESS this is the very last IRP we'll issue.
        //
        //  This logic looks a bit nasty, but is hopefully straightforward.
        //

        if (!MdlIsReserve &&
            (IrpCount != 1 ||
             (CurrentIndex == LastIndex &&
              RemainingByteCount == 0))) {

            AssocIrp = IoMakeAssociatedIrp( Irp, (CCHAR)(DeviceObject->StackSize + 1) );
        }
        
        if (AssocIrp == NULL) {

            AssocIrp = Irp;
            IrpIsMaster = TRUE;

            //
            //  We need to drain the associated Irps so we can reliably figure out if
            //  the master Irp is showing a failed status, in which case we bail out
            //  immediately - as opposed to putting the value in the status field in
            //  jeopardy due to our re-use of the master Irp.
            //

            while (Irp->AssociatedIrp.IrpCount != IrpCount) {

                KeDelayExecutionThread (KernelMode, FALSE, &Fat30Milliseconds);
            }

            //
            //  Note that since we failed to launch this associated Irp, that the completion
            //  code at the bottom will take care of completing the master Irp.
            //
            
            if (!NT_SUCCESS(Irp->IoStatus.Status)) {

                ASSERT( IrpCount );
                break;
            }

        } else {
                        
            //
            //  Indicate we used an associated Irp.
            //

            IrpCount -= 1;
        }
        
        //
        //  With an associated IRP, we must take over the first stack location so
        //  we can have one to put the completion routine on.  When re-using the
        //  master IRP, its already there.
        //
        
        if (!IrpIsMaster) {
            
            //
            //  Get the first IRP stack location in the associated Irp
            //

            IoSetNextIrpStackLocation( AssocIrp );
            NextIrpSp = IoGetCurrentIrpStackLocation( AssocIrp );

            //
            //  Setup the Stack location to describe our read.
            //

            NextIrpSp->MajorFunction = IrpSp->MajorFunction;
            NextIrpSp->Parameters.Read.Length = NextByteCount;
            NextIrpSp->Parameters.Read.ByteOffset.QuadPart = Vbo;

            //
            //  We also need the VolumeDeviceObject in the Irp stack in case
            //  we take the failure path.
            //

            NextIrpSp->DeviceObject = IrpSp->DeviceObject;
            
        } else {

            //
            //  Save the MDL in the IRP and prepare the stack
            //  context for the completion routine.
            //

            KeInitializeEvent( &Context.Event, SynchronizationEvent, FALSE );
            Context.RestoreMdl = Irp->MdlAddress;
        }

        //
        //  And drop our Mdl into the Irp.
        //

        AssocIrp->MdlAddress = Mdl;

        //
        //  Set up the completion routine address in our stack frame.
        //  For true associated IRPs, this is only invoked on error or
        //  cancel, and just copies the error Status into master irp's
        //  iosb.
        //
        //  If the error implies a media problem, it also enqueues a
        //  worker item to write out the dirty bit so that the next
        //  time we run we will do a autochk /r
        //

        if (IrpIsMaster) {
            
            IoSetCompletionRoutine( AssocIrp,
                                    FatPagingFileCompletionRoutineCatch,
                                    &Context,
                                    TRUE,
                                    TRUE,
                                    TRUE );

        } else {
            
            IoSetCompletionRoutine( AssocIrp,
                                    FatPagingFileCompletionRoutine,
                                    Irp,
                                    FALSE,
                                    TRUE,
                                    TRUE );
        }

        //
        //  Setup the next IRP stack location for the disk driver beneath us.
        //

        NextIrpSp = IoGetNextIrpStackLocation( AssocIrp );

        //
        //  Since this is paging file IO, we'll just ignore the verify bit.
        //

        SetFlag( NextIrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );

        //
        //  Setup the Stack location to do a read from the disk driver.
        //

        NextIrpSp->MajorFunction = IrpSp->MajorFunction;
        NextIrpSp->Parameters.Read.Length = NextByteCount;
        NextIrpSp->Parameters.Read.ByteOffset.QuadPart = NextLbo;

        (VOID)IoCallDriver( DeviceObject, AssocIrp );

        //
        //  Wait for the Irp in the catch case and drop the flags.
        //

        if (IrpIsMaster) {
            
            KeWaitForSingleObject( &Context.Event, Executive, KernelMode, FALSE, NULL );
            IrpIsMaster = MdlIsReserve = FALSE;

            //
            //  If the Irp is showing a failed status, there is no point in continuing.
            //  In doing so, we get to avoid squirreling away the failed status in case
            //  we were to re-use the master irp again.
            //
            //  Note that since we re-used the master, we must not have issued the "last"
            //  associated Irp, and thus the completion code at the bottom will take care
            //  of that for us.
            //
            
            if (!NT_SUCCESS(Irp->IoStatus.Status)) {

                ASSERT( IrpCount );
                break;
            }
        }

        //
        //  Now adjust everything for the next pass through the loop.
        //

        Vbo += NextByteCount;
        BufferOffset += NextByteCount;
        ByteCount -= NextByteCount;

        //
        //  Try to lookup the next run, if we are not done and we got
        //  all the way through the current run.
        //

        if (RemainingByteCount) {

            //
            //  Advance the Lbo/Vbo if we have more to do in the current run.
            //
            
            NextLbo += NextByteCount;
            NextVbo += NextByteCount;

            NextByteCount = RemainingByteCount;
        
        } else {
        
            CurrentIndex += 1;

            if ( CurrentIndex <= LastIndex ) {

                ASSERT( ByteCount != 0 );

                FatGetNextMcbEntry( Fcb->Vcb, &Fcb->Mcb,
                                    CurrentIndex,
                                    &NextVbo,
                                    &NextLbo,
                                    &NextByteCount );

                ASSERT( NextVbo == Vbo );
            }
        }
    } // while ( CurrentIndex <= LastIndex )

    //
    //  If we didn't get enough associated Irps going to make this asynchronous, we
    //  twiddle our thumbs and wait for those we did launch to complete.
    //
    
    if (IrpCount) {

        while (Irp->AssociatedIrp.IrpCount != IrpCount) {
            
            KeDelayExecutionThread (KernelMode, FALSE, &Fat30Milliseconds);
        }

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
    }

    DebugTrace(-1, Dbg, "FatPagingFileIo -> VOID\n", 0);
    return;
}


NTSTATUS
FatNonCachedIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB FcbOrDcb,
    IN ULONG StartingVbo,
    IN ULONG ByteCount,
    IN ULONG UserByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    The choice of a single run is made if possible, otherwise multiple runs
    are executed.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    FcbOrDcb - Supplies the file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.
    
    UserByteCount - The last byte the user can see, rest to be zeroed.

Return Value:

    None.

--*/

{
    //
    // Declare some local variables for enumeration through the
    // runs of the file, and an array to store parameters for
    // parallel I/Os
    //

    BOOLEAN Wait;

    LBO NextLbo;
    VBO NextVbo;
    ULONG NextByteCount;
    BOOLEAN NextIsAllocated;

    LBO LastLbo;
    ULONG LastByteCount;
    BOOLEAN LastIsAllocated;

    BOOLEAN EndOnMax;

    ULONG FirstIndex;
    ULONG CurrentIndex;
    ULONG LastIndex;

    ULONG NextRun;
    ULONG BufferOffset;
    ULONG OriginalByteCount;

    IO_RUN StackIoRuns[FAT_MAX_IO_RUNS_ON_STACK];
    PIO_RUN IoRuns;

    DebugTrace(+1, Dbg, "FatNonCachedIo\n", 0);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "MajorFunction = %08lx\n", IrpContext->MajorFunction );
    DebugTrace( 0, Dbg, "FcbOrDcb      = %08lx\n", FcbOrDcb );
    DebugTrace( 0, Dbg, "StartingVbo   = %08lx\n", StartingVbo );
    DebugTrace( 0, Dbg, "ByteCount     = %08lx\n", ByteCount );

    if (!FlagOn(Irp->Flags, IRP_PAGING_IO)) {

        PFILE_SYSTEM_STATISTICS Stats =
            &FcbOrDcb->Vcb->Statistics[KeGetCurrentProcessorNumber()];

        if (IrpContext->MajorFunction == IRP_MJ_READ) {
            Stats->Fat.NonCachedReads += 1;
            Stats->Fat.NonCachedReadBytes += ByteCount;
        } else {
            Stats->Fat.NonCachedWrites += 1;
            Stats->Fat.NonCachedWriteBytes += ByteCount;
        }
    }

    //
    //  Initialize some locals.
    //

    NextRun = 0;
    BufferOffset = 0;
    OriginalByteCount = ByteCount;

    Wait = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);

    //
    // For nonbuffered I/O, we need the buffer locked in all
    // cases.
    //
    // This call may raise.  If this call succeeds and a subsequent
    // condition is raised, the buffers are unlocked automatically
    // by the I/O system when the request is completed, via the
    // Irp->MdlAddress field.
    //

    FatLockUserBuffer( IrpContext,
                       Irp,
                       (IrpContext->MajorFunction == IRP_MJ_READ) ?
                       IoWriteAccess : IoReadAccess,
                       ByteCount );

    //
    //  Setup the required zeroing for read requests.
    //

    if (UserByteCount != ByteCount) {

        PMDL Mdl;

        ASSERT( ByteCount > UserByteCount );

        Mdl = IoAllocateMdl( (PUCHAR) Irp->UserBuffer + UserByteCount,
                             ByteCount - UserByteCount,
                             FALSE,
                             FALSE,
                             NULL );

        if (Mdl == NULL) {

            FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        IoBuildPartialMdl( Irp->MdlAddress,
                           Mdl,
                           (PUCHAR) Irp->UserBuffer + UserByteCount,
                           ByteCount - UserByteCount );

        IrpContext->FatIoContext->ZeroMdl = Mdl;

        //
        //  Map the MDL now so we can't fail at IO completion time.  Note
        //  that this will be only a single page.
        //

        if (MmGetSystemAddressForMdlSafe( Mdl, NormalPagePriority ) == NULL) {

            FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }
    }

#if 0 // The corruption was happening on the SCSI bus. (DavidGoe 1/11/93)

    //
    //  If we are writing a directory, add a spot check here that
    //  what we are writing is really a directory.
    //

    if ( !FlagOn(FcbOrDcb->Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) &&
         (NodeType(FcbOrDcb) != FAT_NTC_FCB) &&
         (IrpContext->MajorFunction == IRP_MJ_WRITE) ) {

        PDIRENT Dirent;

        Dirent = FatMapUserBuffer( IrpContext, Irp );

        //
        //  For the first page of a non-root directory, make sure that
        //  . and .. are present.
        //

        if ( (StartingVbo == 0) &&
             (NodeType(FcbOrDcb) != FAT_NTC_ROOT_DCB) ) {

            if ( (!RtlEqualMemory( (PUCHAR)Dirent++,
                                   ".          ",
                                   11 )) ||
                 (!RtlEqualMemory( (PUCHAR)Dirent,
                                   "..         ",
                                   11 )) ) {

                FatBugCheck( 0, 0, 0 );
            }

        } else {

            //
            //  Check that all the reserved bit in the second dirent are
            //  zero.  (The first one contains our dirty bit in the root dir)
            //

            PULONG Zeros;

            Dirent++;

            Zeros = (PULONG)&Dirent->Reserved[0];

            if ( (Dirent->FileName[0] != 0xE5) &&
                 ((*Zeros != 0) || (*(Zeros+1) != 0)) ) {

                FatBugCheck( 0, 0, 0 );
            }
        }
    }
#endif //0

    //
    //  Try to lookup the first run.  If there is just a single run,
    //  we may just be able to pass it on.
    //

    FatLookupFileAllocation( IrpContext,
                             FcbOrDcb,
                             StartingVbo,
                             &NextLbo,
                             &NextByteCount,
                             &NextIsAllocated,
                             &EndOnMax,
                             &FirstIndex );

    //
    //  We just added the allocation, thus there must be at least
    //  one entry in the mcb corresponding to our write, ie.
    //  NextIsAllocated must be true.  If not, the pre-existing file
    //  must have an allocation error.
    //

    if ( !NextIsAllocated ) {

        FatPopUpFileCorrupt( IrpContext, FcbOrDcb );

        FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    ASSERT( NextByteCount != 0 );

    //
    //  If the request was not aligned correctly, read in the first
    //  part first.
    //


    //
    //  See if the write covers a single valid run, and if so pass
    //  it on.  We must bias this by the byte that is lost at the
    //  end of the maximal file.
    //

    if ( NextByteCount >= ByteCount - (EndOnMax ? 1 : 0)) {

        if (FlagOn(Irp->Flags, IRP_PAGING_IO)) {
            CollectDiskIoStats(FcbOrDcb->Vcb, IrpContext->MajorFunction,
                               FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_USER_IO), 1);
        } else {

            PFILE_SYSTEM_STATISTICS Stats =
                &FcbOrDcb->Vcb->Statistics[KeGetCurrentProcessorNumber()];

            if (IrpContext->MajorFunction == IRP_MJ_READ) {
                Stats->Fat.NonCachedDiskReads += 1;
            } else {
                Stats->Fat.NonCachedDiskWrites += 1;
            }
        }

        DebugTrace( 0, Dbg, "Passing 1 Irp on to Disk Driver\n", 0 );

        FatSingleAsync( IrpContext,
                        FcbOrDcb->Vcb,
                        NextLbo,
                        ByteCount,
                        Irp );

    } else {

        //
        //  If there we can't wait, and there are more runs than we can handle,
        //  we will have to post this request.
        //

        FatLookupFileAllocation( IrpContext,
                                 FcbOrDcb,
                                 StartingVbo + ByteCount - 1,
                                 &LastLbo,
                                 &LastByteCount,
                                 &LastIsAllocated,
                                 &EndOnMax,
                                 &LastIndex );

        //
        // Since we already added the allocation for the whole
        // write, assert that we find runs until ByteCount == 0
        // Otherwise this file is corrupt.
        //

        if ( !LastIsAllocated ) {

            FatPopUpFileCorrupt( IrpContext, FcbOrDcb );

            FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        if (LastIndex - FirstIndex + 1 > FAT_MAX_IO_RUNS_ON_STACK) {

            IoRuns = FsRtlAllocatePoolWithTag( PagedPool,
                                               (LastIndex - FirstIndex + 1) * sizeof(IO_RUN),
                                               TAG_IO_RUNS );

        } else {

            IoRuns = StackIoRuns;
        }

        ASSERT( LastIndex != FirstIndex );

        CurrentIndex = FirstIndex;

        //
        // Loop while there are still byte writes to satisfy.
        //

        while (CurrentIndex <= LastIndex) {


            ASSERT( NextByteCount != 0);
            ASSERT( ByteCount != 0);

            //
            // If next run is larger than we need, "ya get what you need".
            //

            if (NextByteCount > ByteCount) {
                NextByteCount = ByteCount;
            }

            //
            // Now that we have properly bounded this piece of the
            // transfer, it is time to write it.
            //
            // We remember each piece of a parallel run by saving the
            // essential information in the IoRuns array.  The tranfers
            // are started up in parallel below.
            //

            IoRuns[NextRun].Vbo = StartingVbo;
            IoRuns[NextRun].Lbo = NextLbo;
            IoRuns[NextRun].Offset = BufferOffset;
            IoRuns[NextRun].ByteCount = NextByteCount;
            NextRun += 1;

            //
            // Now adjust everything for the next pass through the loop.
            //

            StartingVbo += NextByteCount;
            BufferOffset += NextByteCount;
            ByteCount -= NextByteCount;

            //
            // Try to lookup the next run (if we are not done).
            //

            CurrentIndex += 1;

            if ( CurrentIndex <= LastIndex ) {

                ASSERT( ByteCount != 0 );

                FatGetNextMcbEntry( FcbOrDcb->Vcb, &FcbOrDcb->Mcb,
                                    CurrentIndex,
                                    &NextVbo,
                                    &NextLbo,
                                    &NextByteCount );

                ASSERT( NextVbo == StartingVbo );
            }

        } // while ( CurrentIndex <= LastIndex )

        //
        //  Now set up the Irp->IoStatus.  It will be modified by the
        //  multi-completion routine in case of error or verify required.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = OriginalByteCount;

        if (FlagOn(Irp->Flags, IRP_PAGING_IO)) {
            CollectDiskIoStats(FcbOrDcb->Vcb, IrpContext->MajorFunction,
                               FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_USER_IO), NextRun);
        }

        //
        //  OK, now do the I/O.
        //

        try {

            DebugTrace( 0, Dbg, "Passing Multiple Irps on to Disk Driver\n", 0 );

            FatMultipleAsync( IrpContext,
                              FcbOrDcb->Vcb,
                              Irp,
                              NextRun,
                              IoRuns );

        } finally {

            if (IoRuns != StackIoRuns) {

                ExFreePool( IoRuns );
            }
        }
    }

    if (!Wait) {

        DebugTrace(-1, Dbg, "FatNonCachedIo -> STATUS_PENDING\n", 0);
        return STATUS_PENDING;
    }

    FatWaitSync( IrpContext );

    DebugTrace(-1, Dbg, "FatNonCachedIo -> 0x%08lx\n", Irp->IoStatus.Status);
    return Irp->IoStatus.Status;
}


VOID
FatNonCachedNonAlignedRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB FcbOrDcb,
    IN ULONG StartingVbo,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached disk io described in its parameters.
    This routine differs from the above in that the range does not have to be
    sector aligned.  This accomplished with the use of intermediate buffers.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Irp - Supplies the requesting Irp.

    FcbOrDcb - Supplies the file to act on.

    StartingVbo - The starting point for the operation.

    ByteCount - The lengh of the operation.

Return Value:

    None.

--*/

{
    //
    // Declare some local variables for enumeration through the
    // runs of the file, and an array to store parameters for
    // parallel I/Os
    //

    LBO NextLbo;
    ULONG NextByteCount;
    BOOLEAN NextIsAllocated;

    ULONG SectorSize;
    ULONG BytesToCopy;
    ULONG OriginalByteCount;
    ULONG OriginalStartingVbo;

    BOOLEAN EndOnMax;

    PUCHAR UserBuffer;
    PUCHAR DiskBuffer = NULL;

    PMDL Mdl;
    PMDL SavedMdl;
    PVOID SavedUserBuffer;

    DebugTrace(+1, Dbg, "FatNonCachedNonAlignedRead\n", 0);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "MajorFunction = %08lx\n", IrpContext->MajorFunction );
    DebugTrace( 0, Dbg, "FcbOrDcb      = %08lx\n", FcbOrDcb );
    DebugTrace( 0, Dbg, "StartingVbo   = %08lx\n", StartingVbo );
    DebugTrace( 0, Dbg, "ByteCount     = %08lx\n", ByteCount );

    //
    //  Initialize some locals.
    //

    OriginalByteCount = ByteCount;
    OriginalStartingVbo = StartingVbo;
    SectorSize = FcbOrDcb->Vcb->Bpb.BytesPerSector;

    ASSERT( FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

    //
    // For nonbuffered I/O, we need the buffer locked in all
    // cases.
    //
    // This call may raise.  If this call succeeds and a subsequent
    // condition is raised, the buffers are unlocked automatically
    // by the I/O system when the request is completed, via the
    // Irp->MdlAddress field.
    //

    FatLockUserBuffer( IrpContext,
                       Irp,
                       IoWriteAccess,
                       ByteCount );

    UserBuffer = FatMapUserBuffer( IrpContext, Irp );

    //
    //  Allocate the local buffer
    //

    DiskBuffer = FsRtlAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                           (ULONG) ROUND_TO_PAGES( SectorSize ),
                                           TAG_IO_BUFFER );

    //
    //  We use a try block here to ensure the buffer is freed, and to
    //  fill in the correct byte count in the Iosb.Information field.
    //

    try {

        //
        //  If the beginning of the request was not aligned correctly, read in
        //  the first part first.
        //

        if ( StartingVbo & (SectorSize - 1) ) {

            VBO Hole;

            //
            // Try to lookup the first run.
            //

            FatLookupFileAllocation( IrpContext,
                                     FcbOrDcb,
                                     StartingVbo,
                                     &NextLbo,
                                     &NextByteCount,
                                     &NextIsAllocated,
                                     &EndOnMax,
                                     NULL );

            //
            // We just added the allocation, thus there must be at least
            // one entry in the mcb corresponding to our write, ie.
            // NextIsAllocated must be true.  If not, the pre-existing file
            // must have an allocation error.
            //

            if ( !NextIsAllocated ) {

                FatPopUpFileCorrupt( IrpContext, FcbOrDcb );

                FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            FatSingleNonAlignedSync( IrpContext,
                                     FcbOrDcb->Vcb,
                                     DiskBuffer,
                                     NextLbo & ~((LONG)SectorSize - 1),
                                     SectorSize,
                                     Irp );

            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                try_return( NOTHING );
            }

            //
            //  Now copy the part of the first sector that we want to the user
            //  buffer.
            //

            Hole = StartingVbo & (SectorSize - 1);

            BytesToCopy = ByteCount >= SectorSize - Hole ?
                                       SectorSize - Hole : ByteCount;

            RtlCopyMemory( UserBuffer, DiskBuffer + Hole, BytesToCopy );

            StartingVbo += BytesToCopy;
            ByteCount -= BytesToCopy;

            if ( ByteCount == 0 ) {

                try_return( NOTHING );
            }
        }

        ASSERT( (StartingVbo & (SectorSize - 1)) == 0 );

        //
        //  If there is a tail part that is not sector aligned, read it.
        //

        if ( ByteCount & (SectorSize - 1) ) {

            VBO LastSectorVbo;

            LastSectorVbo = StartingVbo + (ByteCount & ~(SectorSize - 1));

            //
            // Try to lookup the last part of the requested range.
            //

            FatLookupFileAllocation( IrpContext,
                                     FcbOrDcb,
                                     LastSectorVbo,
                                     &NextLbo,
                                     &NextByteCount,
                                     &NextIsAllocated,
                                     &EndOnMax,
                                     NULL );

            //
            // We just added the allocation, thus there must be at least
            // one entry in the mcb corresponding to our write, ie.
            // NextIsAllocated must be true.  If not, the pre-existing file
            // must have an allocation error.
            //

            if ( !NextIsAllocated ) {

                FatPopUpFileCorrupt( IrpContext, FcbOrDcb );

                FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            FatSingleNonAlignedSync( IrpContext,
                                     FcbOrDcb->Vcb,
                                     DiskBuffer,
                                     NextLbo,
                                     SectorSize,
                                     Irp );

            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                try_return( NOTHING );
            }

            //
            //  Now copy over the part of this last sector that we need.
            //

            BytesToCopy = ByteCount & (SectorSize - 1);

            UserBuffer += LastSectorVbo - OriginalStartingVbo;

            RtlCopyMemory( UserBuffer, DiskBuffer, BytesToCopy );

            ByteCount -= BytesToCopy;

            if ( ByteCount == 0 ) {

                try_return( NOTHING );
            }
        }

        ASSERT( ((StartingVbo | ByteCount) & (SectorSize - 1)) == 0 );

        //
        //  Now build a Mdl describing the sector aligned balance of the transfer,
        //  and put it in the Irp, and read that part.
        //

        SavedMdl = Irp->MdlAddress;
        Irp->MdlAddress = NULL;

        SavedUserBuffer = Irp->UserBuffer;

        Irp->UserBuffer = (PUCHAR)MmGetMdlVirtualAddress( SavedMdl ) +
                          (StartingVbo - OriginalStartingVbo);

        Mdl = IoAllocateMdl( Irp->UserBuffer,
                             ByteCount,
                             FALSE,
                             FALSE,
                             Irp );

        if (Mdl == NULL) {

            Irp->MdlAddress = SavedMdl;
            Irp->UserBuffer = SavedUserBuffer;
            FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        IoBuildPartialMdl( SavedMdl,
                           Mdl,
                           Irp->UserBuffer,
                           ByteCount );

        //
        //  Try to read in the pages.
        //

        try {

            FatNonCachedIo( IrpContext,
                            Irp,
                            FcbOrDcb,
                            StartingVbo,
                            ByteCount,
                            ByteCount );

        } finally {

            IoFreeMdl( Irp->MdlAddress );

            Irp->MdlAddress = SavedMdl;
            Irp->UserBuffer = SavedUserBuffer;
        }

    try_exit: NOTHING;

    } finally {

        ExFreePool( DiskBuffer );

        if ( !AbnormalTermination() && NT_SUCCESS(Irp->IoStatus.Status) ) {

            Irp->IoStatus.Information = OriginalByteCount;

            //
            //  We now flush the user's buffer to memory.
            //

            KeFlushIoBuffers( Irp->MdlAddress, TRUE, FALSE );
        }
    }

    DebugTrace(-1, Dbg, "FatNonCachedNonAlignedRead -> VOID\n", 0);
    return;
}


VOID
FatMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PIRP MasterIrp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns
    )

/*++

Routine Description:

    This routine first does the initial setup required of a Master IRP that is
    going to be completed using associated IRPs.  This routine should not
    be used if only one async request is needed, instead the single read/write
    async routines should be called.

    A context parameter is initialized, to serve as a communications area
    between here and the common completion routine.  This initialization
    includes allocation of a spinlock.  The spinlock is deallocated in the
    FatWaitSync routine, so it is essential that the caller insure that
    this routine is always called under all circumstances following a call
    to this routine.

    Next this routine reads or writes one or more contiguous sectors from
    a device asynchronously, and is used if there are multiple reads for a
    master IRP.  A completion routine is used to synchronize with the
    completion of all of the I/O requests started by calls to this routine.

    Also, prior to calling this routine the caller must initialize the
    IoStatus field in the Context, with the correct success status and byte
    count which are expected if all of the parallel transfers complete
    successfully.  After return this status will be unchanged if all requests
    were, in fact, successful.  However, if one or more errors occur, the
    IoStatus will be modified to reflect the error status and byte count
    from the first run (by Vbo) which encountered an error.  I/O status
    from all subsequent runs will not be indicated.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Vcb - Supplies the device to be read

    MasterIrp - Supplies the master Irp.

    MulitpleIrpCount - Supplies the number of multiple async requests
        that will be issued against the master irp.

    IoRuns - Supplies an array containing the Vbo, Lbo, BufferOffset, and
        ByteCount for all the runs to executed in parallel.

Return Value:

    None.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PMDL Mdl;
    BOOLEAN Wait;
    PFAT_IO_CONTEXT Context;

    ULONG UnwindRunCount = 0;

    BOOLEAN ExceptionExpected = TRUE;

    BOOLEAN CalledByFatVerifyVolume = FALSE;

    DebugTrace(+1, Dbg, "FatMultipleAsync\n", 0);
    DebugTrace( 0, Dbg, "MajorFunction    = %08lx\n", IrpContext->MajorFunction );
    DebugTrace( 0, Dbg, "Vcb              = %08lx\n", Vcb );
    DebugTrace( 0, Dbg, "MasterIrp        = %08lx\n", MasterIrp );
    DebugTrace( 0, Dbg, "MultipleIrpCount = %08lx\n", MultipleIrpCount );
    DebugTrace( 0, Dbg, "IoRuns           = %08lx\n", IoRuns );

    //
    //  If this I/O originating during FatVerifyVolume, bypass the
    //  verify logic.
    //

    if ( Vcb->VerifyThread == KeGetCurrentThread() ) {

        CalledByFatVerifyVolume = TRUE;
    }

    //
    //  Set up things according to whether this is truely async.
    //

    Wait = BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    Context = IrpContext->FatIoContext;

    //
    //  Finish initializing Context, for use in Read/Write Multiple Asynch.
    //

    Context->MasterIrp = MasterIrp;

    try {

        //
        //  Itterate through the runs, doing everything that can fail
        //

        for ( UnwindRunCount = 0;
              UnwindRunCount < MultipleIrpCount;
              UnwindRunCount++ ) {

            //
            //  Create an associated IRP, making sure there is one stack entry for
            //  us, as well.
            //

            IoRuns[UnwindRunCount].SavedIrp = 0;

            Irp = IoMakeAssociatedIrp( MasterIrp,
                                       (CCHAR)(Vcb->TargetDeviceObject->StackSize + 1) );

            if (Irp == NULL) {

                FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
            }

            IoRuns[UnwindRunCount].SavedIrp = Irp;

            //
            // Allocate and build a partial Mdl for the request.
            //

            Mdl = IoAllocateMdl( (PCHAR)MasterIrp->UserBuffer +
                                 IoRuns[UnwindRunCount].Offset,
                                 IoRuns[UnwindRunCount].ByteCount,
                                 FALSE,
                                 FALSE,
                                 Irp );

            if (Mdl == NULL) {

                FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            //  Sanity Check
            //

            ASSERT( Mdl == Irp->MdlAddress );

            IoBuildPartialMdl( MasterIrp->MdlAddress,
                               Mdl,
                               (PCHAR)MasterIrp->UserBuffer +
                               IoRuns[UnwindRunCount].Offset,
                               IoRuns[UnwindRunCount].ByteCount );

            //
            //  Get the first IRP stack location in the associated Irp
            //

            IoSetNextIrpStackLocation( Irp );
            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Setup the Stack location to describe our read.
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].ByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].Vbo;

            //
            // Set up the completion routine address in our stack frame.
            //

            IoSetCompletionRoutine( Irp,
                                    Wait ?
                                    &FatMultiSyncCompletionRoutine :
                                    &FatMultiAsyncCompletionRoutine,
                                    Context,
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Setup the next IRP stack location in the associated Irp for the disk
            //  driver beneath us.
            //

            IrpSp = IoGetNextIrpStackLocation( Irp );

            //
            //  Setup the Stack location to do a read from the disk driver.
            //

            IrpSp->MajorFunction = IrpContext->MajorFunction;
            IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].ByteCount;
            IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].Lbo;

            //
            //  If this Irp is the result of a WriteThough operation,
            //  tell the device to write it through.
            //

            if (FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH)) {

                SetFlag( IrpSp->Flags, SL_WRITE_THROUGH );
            }

            //
            //  If this I/O originating during FatVerifyVolume, bypass the
            //  verify logic.
            //

            if ( CalledByFatVerifyVolume ) {

                SetFlag( IrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );
            }
        }

        //
        //  Now we no longer expect an exception.  If the driver raises, we
        //  must bugcheck, because we do not know how to recover from that
        //  case.
        //

        ExceptionExpected = FALSE;

        //
        //  We only need to set the associated IRP count in the master irp to
        //  make it a master IRP.  But we set the count to one more than our
        //  caller requested, because we do not want the I/O system to complete
        //  the I/O.  We also set our own count.
        //

        Context->IrpCount = MultipleIrpCount;
        MasterIrp->AssociatedIrp.IrpCount = MultipleIrpCount;

        if (Wait) {

            MasterIrp->AssociatedIrp.IrpCount += 1;
        }

        //
        //  Now that all the dangerous work is done, issue the read requests
        //

        for (UnwindRunCount = 0;
             UnwindRunCount < MultipleIrpCount;
             UnwindRunCount++) {

            Irp = IoRuns[UnwindRunCount].SavedIrp;

            DebugDoit( FatIoCallDriverCount += 1);

            //
            //  If IoCallDriver returns an error, it has completed the Irp
            //  and the error will be caught by our completion routines
            //  and dealt with as a normal IO error.
            //

            (VOID)FatLowLevelReadWrite( IrpContext,
                                        Vcb->TargetDeviceObject,
                                        Irp,
                                        Vcb );
        }

    } finally {

        ULONG i;

        DebugUnwind( FatMultipleAsync );

        //
        //  Only allocating the spinlock, making the associated Irps
        //  and allocating the Mdls can fail.
        //

        if ( AbnormalTermination() ) {

            //
            //  If the driver raised, we are hosed.  He is not supposed to raise,
            //  and it is impossible for us to figure out how to clean up.
            //

            if (!ExceptionExpected) {
                ASSERT( ExceptionExpected );
                FatBugCheck( 0, 0, 0 );
            }

            //
            //  Unwind
            //

            for (i = 0; i <= UnwindRunCount; i++) {

                if ( (Irp = IoRuns[i].SavedIrp) != NULL ) {

                    if ( Irp->MdlAddress != NULL ) {

                        IoFreeMdl( Irp->MdlAddress );
                    }

                    IoFreeIrp( Irp );
                }
            }
        }

        //
        //  And return to our caller
        //

        DebugTrace(-1, Dbg, "FatMultipleAsync -> VOID\n", 0);
    }

    return;
}


VOID
FatSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine reads or writes one or more contiguous sectors from a device
    asynchronously, and is used if there is only one read necessary to
    complete the IRP.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Vcb - Supplies the device to read

    Lbo - Supplies the starting Logical Byte Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

    Irp - Supplies the master Irp to associated with the async
          request.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    DebugTrace(+1, Dbg, "FatSingleAsync\n", 0);
    DebugTrace( 0, Dbg, "MajorFunction = %08lx\n", IrpContext->MajorFunction );
    DebugTrace( 0, Dbg, "Vcb           = %08lx\n", Vcb );
    DebugTrace( 0, Dbg, "Lbo           = %08lx\n", Lbo);
    DebugTrace( 0, Dbg, "ByteCount     = %08lx\n", ByteCount);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp );

    //
    // Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( Irp,
                            FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) ?
                            &FatSingleSyncCompletionRoutine :
                            &FatSingleAsyncCompletionRoutine,
                            IrpContext->FatIoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = IrpContext->MajorFunction;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = Lbo;

    //
    //  If this Irp is the result of a WriteThough operation,
    //  tell the device to write it through.
    //

    if (FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH)) {

        SetFlag( IrpSp->Flags, SL_WRITE_THROUGH );
    }

    //
    //  If this I/O originating during FatVerifyVolume, bypass the
    //  verify logic.
    //

    if ( Vcb->VerifyThread == KeGetCurrentThread() ) {

        SetFlag( IrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    }

    //
    //  Issue the read request
    //

    DebugDoit( FatIoCallDriverCount += 1);

    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    (VOID)FatLowLevelReadWrite( IrpContext,
                                Vcb->TargetDeviceObject,
                                Irp,
                                Vcb );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatSingleAsync -> VOID\n", 0);

    return;
}


VOID
FatSingleNonAlignedSync (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PUCHAR Buffer,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine reads or writes one or more contiguous sectors from a device
    Synchronously, and does so to a buffer that must come from non paged
    pool.  It saves a pointer to the Irp's original Mdl, and creates a new
    one describing the given buffer.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

Arguments:

    IrpContext->MajorFunction - Supplies either IRP_MJ_READ or IRP_MJ_WRITE.

    Vcb - Supplies the device to read

    Buffer - Supplies a buffer from non-paged pool.

    Lbo - Supplies the starting Logical Byte Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

    Irp - Supplies the master Irp to associated with the async
          request.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PMDL Mdl;
    PMDL SavedMdl;

    DebugTrace(+1, Dbg, "FatSingleNonAlignedAsync\n", 0);
    DebugTrace( 0, Dbg, "MajorFunction = %08lx\n", IrpContext->MajorFunction );
    DebugTrace( 0, Dbg, "Vcb           = %08lx\n", Vcb );
    DebugTrace( 0, Dbg, "Buffer        = %08lx\n", Buffer );
    DebugTrace( 0, Dbg, "Lbo           = %08lx\n", Lbo);
    DebugTrace( 0, Dbg, "ByteCount     = %08lx\n", ByteCount);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp );

    //
    //  Create a new Mdl describing the buffer, saving the current one in the
    //  Irp
    //

    SavedMdl = Irp->MdlAddress;

    Irp->MdlAddress = 0;

    Mdl = IoAllocateMdl( Buffer,
                         ByteCount,
                         FALSE,
                         FALSE,
                         Irp );

    if (Mdl == NULL) {

        Irp->MdlAddress = SavedMdl;

        FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Lock the new Mdl in memory.
    //

    try {

        MmProbeAndLockPages( Mdl, KernelMode, IoWriteAccess );

    } finally {

        if ( AbnormalTermination() ) {

            IoFreeMdl( Mdl );
            Irp->MdlAddress = SavedMdl;
        }
    }

    //
    // Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( Irp,
                            &FatSingleSyncCompletionRoutine,
                            IrpContext->FatIoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = IrpContext->MajorFunction;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = Lbo;

    //
    //  If this I/O originating during FatVerifyVolume, bypass the
    //  verify logic.
    //

    if ( Vcb->VerifyThread == KeGetCurrentThread() ) {

        SetFlag( IrpSp->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    }

    //
    //  Issue the read request
    //

    DebugDoit( FatIoCallDriverCount += 1);

    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    try {

        (VOID)FatLowLevelReadWrite( IrpContext,
                                    Vcb->TargetDeviceObject,
                                    Irp,
                                    Vcb );

        FatWaitSync( IrpContext );

    } finally {

        MmUnlockPages( Mdl );
        IoFreeMdl( Mdl );
        Irp->MdlAddress = SavedMdl;
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatSingleNonAlignedSync -> VOID\n", 0);

    return;
}


VOID
FatWaitSync (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine waits for one or more previously started I/O requests
    from the above routines, by simply waiting on the event.

Arguments:

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "FatWaitSync, Context = %08lx\n", IrpContext->FatIoContext );

    KeWaitForSingleObject( &IrpContext->FatIoContext->Wait.SyncEvent,
                           Executive, KernelMode, FALSE, NULL );

    KeClearEvent( &IrpContext->FatIoContext->Wait.SyncEvent );

    DebugTrace(-1, Dbg, "FatWaitSync -> VOID\n", 0 );
}


//
// Internal Support Routine
//

NTSTATUS
FatMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    FatRead/WriteMultipleAsynch.  It must synchronize its operation for
    multiprocessor environments with itself on all other processors, via
    a spin lock found via the Context parameter.

    The completion routine has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        (essentially by Vbo), and if so it must correctly reduce the
        byte count and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    Contxt - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{

    PFAT_IO_CONTEXT Context = Contxt;
    PIRP MasterIrp = Context->MasterIrp;

    DebugTrace(+1, Dbg, "FatMultiSyncCompletionRoutine, Context = %08lx\n", Context );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    MasterIrp = Context->MasterIrp;

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        ASSERT( NT_SUCCESS( FatAssertNotStatus ) || Irp->IoStatus.Status != FatAssertNotStatus );

#ifdef SYSCACHE_COMPILE
        DbgPrint( "FAT SYSCACHE: MultiSync (IRP %08x for Master %08x) -> %08x\n", Irp, MasterIrp, Irp->IoStatus );
#endif

        MasterIrp->IoStatus = Irp->IoStatus;
    }

    ASSERT( !(NT_SUCCESS( Irp->IoStatus.Status ) && Irp->IoStatus.Information == 0 ));

    //
    //  We must do this here since IoCompleteRequest won't get a chance
    //  on this associated Irp.
    //

    IoFreeMdl( Irp->MdlAddress );
    IoFreeIrp( Irp );

    if (InterlockedDecrement(&Context->IrpCount) == 0) {

        FatDoCompletionZero( MasterIrp, Context );
        KeSetEvent( &Context->Wait.SyncEvent, 0, FALSE );
    }

    DebugTrace(-1, Dbg, "FatMultiSyncCompletionRoutine -> SUCCESS\n", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//
// Internal Support Routine
//

NTSTATUS
FatMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    FatRead/WriteMultipleAsynch.  It must synchronize its operation for
    multiprocessor environments with itself on all other processors, via
    a spin lock found via the Context parameter.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        (essentially by Vbo), and if so it must correctly reduce the
        byte count and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    Contxt - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{

    PFAT_IO_CONTEXT Context = Contxt;
    PIRP MasterIrp = Context->MasterIrp;

    DebugTrace(+1, Dbg, "FatMultiAsyncCompletionRoutine, Context = %08lx\n", Context );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    MasterIrp = Context->MasterIrp;

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        ASSERT( NT_SUCCESS( FatAssertNotStatus ) || Irp->IoStatus.Status != FatAssertNotStatus );

#ifdef SYSCACHE_COMPILE
        DbgPrint( "FAT SYSCACHE: MultiAsync (IRP %08x for Master %08x) -> %08x\n", Irp, MasterIrp, Irp->IoStatus );
#endif

        MasterIrp->IoStatus = Irp->IoStatus;
    
    }

    ASSERT( !(NT_SUCCESS( Irp->IoStatus.Status ) && Irp->IoStatus.Information == 0 ));
    
    if (InterlockedDecrement(&Context->IrpCount) == 0) {

        FatDoCompletionZero( MasterIrp, Context );

        if (NT_SUCCESS(MasterIrp->IoStatus.Status)) {

            MasterIrp->IoStatus.Information =
                Context->Wait.Async.RequestedByteCount;

            ASSERT(MasterIrp->IoStatus.Information != 0);

            //
            //  Now if this wasn't PagingIo, set either the read or write bit.
            //

            if (!FlagOn(MasterIrp->Flags, IRP_PAGING_IO)) {

                SetFlag( Context->Wait.Async.FileObject->Flags,
                         IoGetCurrentIrpStackLocation(MasterIrp)->MajorFunction == IRP_MJ_READ ?
                         FO_FILE_FAST_IO_READ : FO_FILE_MODIFIED );
            }
        }

        //
        //  If this was a special async write, decrement the count.  Set the
        //  event if this was the final outstanding I/O for the file.  We will
        //  also want to queue an APC to deal with any error conditionions.
        //

        if ((Context->Wait.Async.NonPagedFcb) &&
            (ExInterlockedAddUlong( &Context->Wait.Async.NonPagedFcb->OutstandingAsyncWrites,
                                    0xffffffff,
                                    &FatData.GeneralSpinLock ) == 1)) {

            KeSetEvent( Context->Wait.Async.NonPagedFcb->OutstandingAsyncEvent, 0, FALSE );
        }

        //
        //  Now release the resources.
        //

        if (Context->Wait.Async.Resource != NULL) {

            ExReleaseResourceForThreadLite( Context->Wait.Async.Resource,
                                        Context->Wait.Async.ResourceThreadId );
        }

        if (Context->Wait.Async.Resource2 != NULL) {

            ExReleaseResourceForThreadLite( Context->Wait.Async.Resource2,
                                        Context->Wait.Async.ResourceThreadId );
        }

        //
        //  Mark the master Irp pending
        //

        IoMarkIrpPending( MasterIrp );

        //
        //  and finally, free the context record.
        //

        ExFreePool( Context );
    }

    DebugTrace(-1, Dbg, "FatMultiAsyncCompletionRoutine -> SUCCESS\n", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return STATUS_SUCCESS;
}


NTSTATUS
FatPagingFileErrorHandler (
    IN PIRP Irp,
    IN PKEVENT Event OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to guarantee that the media is marked dirty
    with the surface test bit if a paging file IO fails.
    
    The work done here has several basic problems
    
        1) when paging file writes start failing, this is a good sign
           that the rest of the system is about to fall down around us
           
        2) it has no forward progress guarantee
        
    With Whistler, it is actually quite intentional that we're rejiggering
    the paging file write path to make forward progress at all times.  This
    means that the cases where it *does* fail, we're truly seeing media errors
    and this is probably going to mean the paging file is going to stop working
    very soon.
    
    It'd be nice to make this guarantee progress.  It would need
    
        1) a guaranteed worker thread which can only be used by items which
           will make forward progress (i.e., not block out this one)
           
        2) the virtual volume file's pages containing the boot sector and
           1st FAT entry would have to be pinned resident and have a guaranteed
           mapping address
           
        3) mark volume would have to have a stashed irp/mdl and roll the write
           irp, or use a generalized mechanism to guarantee issue of the irp
           
        4) the lower stack would have to guarantee progress
        
    Of these, 1 and 4 may actually exist shortly.
        
Arguments:

    Irp - Pointer to the associated Irp which is being failed.

    Event - Pointer to optional event to be signalled instead of completing
        the IRP

Return Value:

    Returns STATUS_MORE_PROCESSING_REQUIRED if we managed to queue off the workitem,
    STATUS_SUCCESS otherwise.

--*/

{
    NTSTATUS Status;

    //
    //  If this was a media error, we want to chkdsk /r the next time we boot.
    //

    if (FsRtlIsTotalDeviceFailure(Irp->IoStatus.Status)) {

        Status = STATUS_SUCCESS;

    } else {

        PCLEAN_AND_DIRTY_VOLUME_PACKET Packet;

        //
        //  We are going to try to mark the volume needing recover.
        //  If we can't get pool, oh well....
        //

        Packet = ExAllocatePool(NonPagedPool, sizeof(CLEAN_AND_DIRTY_VOLUME_PACKET));

        if ( Packet ) {

            Packet->Vcb = &((PVOLUME_DEVICE_OBJECT)IoGetCurrentIrpStackLocation(Irp)->DeviceObject)->Vcb;
            Packet->Irp = Irp;
            Packet->Event = Event;

            ExInitializeWorkItem( &Packet->Item,
                                  &FatFspMarkVolumeDirtyWithRecover,
                                  Packet );

            ExQueueWorkItem( &Packet->Item, CriticalWorkQueue );

            Status = STATUS_MORE_PROCESSING_REQUIRED;

        } else {

            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}


//
// Internal Support Routine
//

NTSTATUS
FatPagingFileCompletionRoutineCatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    FatPagingFileIo that reuse the master irp (that we have to catch
    on the way back).  It is always invoked.

    The completion routine has has the following responsibility:

        If the error implies a media problem, it enqueues a
        worker item to write out the dirty bit so that the next
        time we run we will do a autochk /r.  This is not forward
        progress guaranteed at the moment.
        
        Clean up the Mdl used for this partial request.
        
    Note that if the Irp is failing, the error code is already where
    we want it.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    MasterIrp - Pointer to the master Irp.

Return Value:

    Always returns STATUS_MORE_PROCESSING_REQUIRED.

--*/

{
    PFAT_PAGING_FILE_CONTEXT Context = (PFAT_PAGING_FILE_CONTEXT) Contxt;

    DebugTrace(+1, Dbg, "FatPagingFileCompletionRoutineCatch, Context = %08lx\n", Context );
    
    //
    //  Cleanup the existing Mdl, perhaps by returning the reserve.
    //

    if (Irp->MdlAddress == FatReserveMdl) {

        MmPrepareMdlForReuse( Irp->MdlAddress );
        KeSetEvent( &FatReserveEvent, 0, FALSE );
    
    } else {

        IoFreeMdl( Irp->MdlAddress );
    }

    //
    //  Restore the original Mdl.
    //

    Irp->MdlAddress = Context->RestoreMdl;

    DebugTrace(-1, Dbg, "FatPagingFileCompletionRoutine => (done)\n", 0 );

    //
    //  If the IRP is succeeding or the failure handler did not post off the
    //  completion, we're done and should set the event to let the master
    //  know the IRP is his again.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status ) ||
        FatPagingFileErrorHandler( Irp, &Context->Event ) == STATUS_SUCCESS) {

        KeSetEvent( &Context->Event, 0, FALSE );
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
    
}


//
// Internal Support Routine
//

NTSTATUS
FatPagingFileCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MasterIrp
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    FatPagingFileIo.  It should only be invoked on error or cancel.

    The completion routine has has the following responsibility:

        Since the individual request was completed with an error,
        this completion routine must stuff it into the master irp.

        If the error implies a media problem, it also enqueues a
        worker item to write out the dirty bit so that the next
        time we run we will do a autochk /r

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
          Irp will no longer be accessible after this routine returns.)

    MasterIrp - Pointer to the master Irp.

Return Value:

    Always returns STATUS_SUCCESS.

--*/

{
    NTSTATUS Status;

    DebugTrace(+1, Dbg, "FatPagingFileCompletionRoutine, MasterIrp = %08lx\n", MasterIrp );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    ASSERT( !NT_SUCCESS( Irp->IoStatus.Status ));

    //
    //  If we were invoked with an assoicated Irp, copy the error over.
    //

    if (Irp != MasterIrp) {

        ((PIRP)MasterIrp)->IoStatus = Irp->IoStatus;
    }

    DebugTrace(-1, Dbg, "FatPagingFileCompletionRoutine => (done)\n", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return FatPagingFileErrorHandler( Irp, NULL );
}


//
// Internal Support Routine
//

NTSTATUS
FatSpecialSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for a special set of sub irps
    that have to work at APC level.

    The completion routine has has the following responsibilities:

        It sets the event passed as the context to signal that the
        request is done.

    By doing this, the caller will be released before final APC
    completion with knowledge that the IRP is finished.  Final
    completion will occur at an indeterminate time after this
    occurs, and by using this completion routine the caller expects
    to not have any output or status returned.  A junk user Iosb
    should be used to capture the status without forcing Io to take
    an exception on NULL.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
    be accessible after this routine returns.)

    Contxt - The context parameter which was specified in the call to
             FatRead/WriteSingleAsynch.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    PKEVENT Event = (PKEVENT)Contxt;

    DebugTrace(+1, Dbg, "FatSpecialSyncCompletionRoutine, Context = %08lx\n", Contxt );

    KeSetEvent( Event, 0, FALSE );

    DebugTrace(-1, Dbg, "FatSpecialSyncCompletionRoutine -> STATUS_SUCCESS\n", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return STATUS_SUCCESS;
}


//
// Internal Support Routine
//

NTSTATUS
FatSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    FatRead/WriteSingleAsynch.

    The completion routine has has the following responsibilities:

        Copy the I/O status from the Irp to the Context, since the Irp
        will no longer be accessible.

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
    be accessible after this routine returns.)

    Contxt - The context parameter which was specified in the call to
             FatRead/WriteSingleAsynch.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    PFAT_IO_CONTEXT Context = Contxt;

    DebugTrace(+1, Dbg, "FatSingleSyncCompletionRoutine, Context = %08lx\n", Context );

    FatDoCompletionZero( Irp, Context );

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        ASSERT( NT_SUCCESS( FatAssertNotStatus ) || Irp->IoStatus.Status != FatAssertNotStatus );
    }

    ASSERT( !(NT_SUCCESS( Irp->IoStatus.Status ) && Irp->IoStatus.Information == 0 ));

    KeSetEvent( &Context->Wait.SyncEvent, 0, FALSE );

    DebugTrace(-1, Dbg, "FatSingleSyncCompletionRoutine -> STATUS_MORE_PROCESSING_REQUIRED\n", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//
// Internal Support Routine
//

NTSTATUS
FatSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

/*++

Routine Description:

    This is the completion routine for all reads and writes started via
    FatRead/WriteSingleAsynch.

    The completion routine has has the following responsibilities:

        Copy the I/O status from the Irp to the Context, since the Irp
        will no longer be accessible.

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
    be accessible after this routine returns.)

    Contxt - The context parameter which was specified in the call to
             FatRead/WriteSingleAsynch.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    PFAT_IO_CONTEXT Context = Contxt;

    DebugTrace(+1, Dbg, "FatSingleAsyncCompletionRoutine, Context = %08lx\n", Context );

    //
    //  Fill in the information field correctedly if this worked.
    //

    FatDoCompletionZero( Irp, Context );

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        ASSERT( Irp->IoStatus.Information != 0 );
        Irp->IoStatus.Information = Context->Wait.Async.RequestedByteCount;
        ASSERT( Irp->IoStatus.Information != 0 );

        //
        //  Now if this wasn't PagingIo, set either the read or write bit.
        //

        if (!FlagOn(Irp->Flags, IRP_PAGING_IO)) {

            SetFlag( Context->Wait.Async.FileObject->Flags,
                     IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_READ ?
                     FO_FILE_FAST_IO_READ : FO_FILE_MODIFIED );
        }

    } else {

        ASSERT( NT_SUCCESS( FatAssertNotStatus ) || Irp->IoStatus.Status != FatAssertNotStatus );
    
#ifdef SYSCACHE_COMPILE
        DbgPrint( "FAT SYSCACHE: SingleAsync (IRP %08x) -> %08x\n", Irp, Irp->IoStatus );
#endif

    }

    //
    //  If this was a special async write, decrement the count.  Set the
    //  event if this was the final outstanding I/O for the file.  We will
    //  also want to queue an APC to deal with any error conditionions.
    //

    if ((Context->Wait.Async.NonPagedFcb) &&
        (ExInterlockedAddUlong( &Context->Wait.Async.NonPagedFcb->OutstandingAsyncWrites,
                                0xffffffff,
                                &FatData.GeneralSpinLock ) == 1)) {

        KeSetEvent( Context->Wait.Async.NonPagedFcb->OutstandingAsyncEvent, 0, FALSE );
    }

    //
    //  Now release the resources
    //

    if (Context->Wait.Async.Resource != NULL) {

        ExReleaseResourceForThreadLite( Context->Wait.Async.Resource,
                                    Context->Wait.Async.ResourceThreadId );
    }
    
    if (Context->Wait.Async.Resource2 != NULL) {

        ExReleaseResourceForThreadLite( Context->Wait.Async.Resource2,
                                    Context->Wait.Async.ResourceThreadId );
    }

    //
    //  Mark the Irp pending
    //

    IoMarkIrpPending( Irp );

    //
    //  and finally, free the context record.
    //

    ExFreePool( Context );

    DebugTrace(-1, Dbg, "FatSingleAsyncCompletionRoutine -> STATUS_MORE_PROCESSING_REQUIRED\n", 0 );

    UNREFERENCED_PARAMETER( DeviceObject );

    return STATUS_SUCCESS;
}


VOID
FatLockUserBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine locks the specified buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

    Note that this is the *input/output* buffer.

Arguments:

    Irp - Pointer to the Irp for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    BufferLength - Length of user buffer.

Return Value:

    None

--*/

{
    PMDL Mdl = NULL;

    if (Irp->MdlAddress == NULL) {

        //
        // Allocate the Mdl, and Raise if we fail.
        //

        Mdl = IoAllocateMdl( Irp->UserBuffer, BufferLength, FALSE, FALSE, Irp );

        if (Mdl == NULL) {

            FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        // Now probe the buffer described by the Irp.  If we get an exception,
        // deallocate the Mdl and return the appropriate "expected" status.
        //

        try {

            MmProbeAndLockPages( Mdl,
                                 Irp->RequestorMode,
                                 Operation );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            NTSTATUS Status;

            Status = GetExceptionCode();

            IoFreeMdl( Mdl );
            Irp->MdlAddress = NULL;

            FatRaiseStatus( IrpContext,
                            FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER );
        }
    }

    UNREFERENCED_PARAMETER( IrpContext );
}


PVOID
FatMapUserBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine conditionally maps the user buffer for the current I/O
    request in the specified mode.  If the buffer is already mapped, it
    just returns its address.
    
    Note that this is the *input/output* buffer.

Arguments:

    Irp - Pointer to the Irp for the request.

Return Value:

    Mapped address

--*/

{
    UNREFERENCED_PARAMETER( IrpContext );

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        return Irp->UserBuffer;
    
    } else {

        PVOID Address = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

        if (Address == NULL) {

            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        return Address;
    }
}


PVOID
FatBufferUserBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PIRP Irp,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine conditionally buffers the user buffer for the current I/O
    request.  If the buffer is already buffered, it just returns its address.
    
    Note that this is the *input* buffer.

Arguments:

    Irp - Pointer to the Irp for the request.

    BufferLength - Length of user buffer.
    
Return Value:

    Buffered address.

--*/

{
    PUCHAR UserBuffer;
    
    UNREFERENCED_PARAMETER( IrpContext );

    //
    //  Handle the no buffer case.
    //
    
    if (BufferLength == 0) {

        return NULL;
    }
    
    //
    //  If there is no system buffer we must have been supplied an Mdl
    //  describing the users input buffer, which we will now snapshot.
    //

    if (Irp->AssociatedIrp.SystemBuffer == NULL) {

        UserBuffer = FatMapUserBuffer( IrpContext, Irp );

        Irp->AssociatedIrp.SystemBuffer = FsRtlAllocatePoolWithQuotaTag( NonPagedPool,
                                                                         BufferLength,
                                                                         TAG_IO_USER_BUFFER );

        //
        // Set the flags so that the completion code knows to deallocate the
        // buffer.
        //

        Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);

        try {

            RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer,
                           UserBuffer,
                           BufferLength );

        } except (EXCEPTION_EXECUTE_HANDLER) {
              
              NTSTATUS Status;
  
              Status = GetExceptionCode();
              FatRaiseStatus( IrpContext,
                              FsRtlIsNtstatusExpected(Status) ? Status : STATUS_INVALID_USER_BUFFER );
        }
    }
        
    return Irp->AssociatedIrp.SystemBuffer;
}


NTSTATUS
FatToggleMediaEjectDisable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN PreventRemoval
    )

/*++

Routine Description:

    The routine either enables or disables the eject button on removable
    media.

Arguments:

    Vcb - Descibes the volume to operate on

    PreventRemoval - TRUE if we should disable the media eject button.  FALSE
        if we want to enable it.

Return Value:

    Status of the operation.

--*/

{
    PIRP Irp;
    KEVENT Event;
    KIRQL SavedIrql;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    PREVENT_MEDIA_REMOVAL Prevent;

    //
    //  If PreventRemoval is the same as VCB_STATE_FLAG_REMOVAL_PREVENTED,
    //  no-op this call, otherwise toggle the state of the flag.
    //

    KeAcquireSpinLock( &FatData.GeneralSpinLock, &SavedIrql );

    if ((PreventRemoval ^
         BooleanFlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVAL_PREVENTED)) == 0) {

        KeReleaseSpinLock( &FatData.GeneralSpinLock, SavedIrql );

        return STATUS_SUCCESS;

    } else {

        Vcb->VcbState ^= VCB_STATE_FLAG_REMOVAL_PREVENTED;

        KeReleaseSpinLock( &FatData.GeneralSpinLock, SavedIrql );
    }

    Prevent.PreventMediaRemoval = PreventRemoval;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  We build this IRP using a junk Iosb that will receive the final
    //  completion status since we won't be around for it.
    //

    Irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_MEDIA_REMOVAL,
                                         Vcb->TargetDeviceObject,
                                         &Prevent,
                                         sizeof(PREVENT_MEDIA_REMOVAL),
                                         NULL,
                                         0,
                                         FALSE,
                                         NULL,
                                         &Iosb );

    if ( Irp != NULL ) {

        //
        //  Use our special completion routine which will remove the requirement that
        //  the caller must be below APC level.  All it tells us is that the Irp got
        //  back, but will not tell us if it was succesful or not.  We don't care,
        //  and there is of course no fallback if the attempt to prevent removal
        //  doesn't work for some mysterious reason.
        //
        //  Normally, all IO is done at passive level. However, MM needs to be able
        //  to issue IO with fast mutexes locked down, which raises us to APC.  The
        //  overlying IRP is set up to complete in yet another magical fashion even
        //  though APCs are disabled, and any IRPage we do in these cases has to do
        //  the same.  Marking media dirty (and toggling eject state) is one.
        //

        IoSetCompletionRoutine( Irp,
                                FatSpecialSyncCompletionRoutine,
                                &Event,
                                TRUE,
                                TRUE,
                                TRUE );

        Status = IoCallDriver( Vcb->TargetDeviceObject, Irp );

        if (Status == STATUS_PENDING) {
            
            (VOID) KeWaitForSingleObject( &Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL );

            Status = Iosb.Status;
        }

        return Status;
    }

    return STATUS_INSUFFICIENT_RESOURCES;
}


NTSTATUS
FatPerformDevIoCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT Device,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN BOOLEAN OverrideVerify,
    OUT PIO_STATUS_BLOCK Iosb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to perform DevIoCtrl functions internally within
    the filesystem.  We take the status from the driver and return it to our
    caller.

Arguments:

    IoControlCode - Code to send to driver.

    Device - This is the device to send the request to.

    OutPutBuffer - Pointer to output buffer.

    OutputBufferLength - Length of output buffer above.

    InternalDeviceIoControl - Indicates if this is an internal or external
        Io control code.

    OverrideVerify - Indicates if we should tell the driver not to return
        STATUS_VERIFY_REQUIRED for mount and verify.

    Iosb - If specified, we return the results of the operation here.

Return Value:

    NTSTATUS - Status returned by next lower driver.

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK LocalIosb;
    PIO_STATUS_BLOCK IosbToUse = &LocalIosb;

    PAGED_CODE();

    //
    //  Check if the user gave us an Iosb.
    //

    if (ARGUMENT_PRESENT( Iosb )) {

        IosbToUse = Iosb;
    }

    IosbToUse->Status = 0;
    IosbToUse->Information = 0;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( IoControlCode,
                                         Device,
                                         NULL,
                                         0,
                                         OutputBuffer,
                                         OutputBufferLength,
                                         InternalDeviceIoControl,
                                         &Event,
                                         IosbToUse );

    if (Irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (OverrideVerify) {

        SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    }

    Status = IoCallDriver( Device, Irp );

    //
    //  We check for device not ready by first checking Status
    //  and then if status pending was returned, the Iosb status
    //  value.
    //

    if (Status == STATUS_PENDING) {

        (VOID) KeWaitForSingleObject( &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER)NULL );

        Status = IosbToUse->Status;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\dumpsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DumpSup.c

Abstract:

    This module implements a collection of data structure dump routines
    for debugging the Fat file system

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    18-Jan-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

#ifdef FASTFATDBG

VOID FatDump(IN PVOID Ptr);

VOID FatDumpDataHeader();
VOID FatDumpVcb(IN PVCB Ptr);
VOID FatDumpFcb(IN PFCB Ptr);
VOID FatDumpCcb(IN PCCB Ptr);

ULONG FatDumpCurrentColumn;

#define DumpNewLine() {       \
    DbgPrint("\n");            \
    FatDumpCurrentColumn = 1; \
}

#define DumpLabel(Label,Width) {                                          \
    ULONG i, LastPeriod=0;                                                \
    CHAR _Str[20];                                                        \
    for(i=0;i<2;i++) { _Str[i] = UCHAR_SP;}                               \
    for(i=0;i<strlen(#Label);i++) {if (#Label[i] == '.') LastPeriod = i;} \
    strncpy(&_Str[2],&#Label[LastPeriod],Width);                          \
    for(i=strlen(_Str);i<Width;i++) {_Str[i] = UCHAR_SP;}                 \
    _Str[Width] = '\0';                                                   \
    DbgPrint("%s", _Str);                                                  \
}

#define DumpField(Field) {                                         \
    if ((FatDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    FatDumpCurrentColumn += 18 + 9 + 9;                            \
    DumpLabel(Field,18);                                           \
    DbgPrint(":%8lx", Ptr->Field);                                  \
    DbgPrint("         ");                                          \
}

#define DumpListEntry(Links) {                                     \
    if ((FatDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    FatDumpCurrentColumn += 18 + 9 + 9;                            \
    DumpLabel(Links,18);                                           \
    DbgPrint(":%8lx", Ptr->Links.Flink);                            \
    DbgPrint(":%8lx", Ptr->Links.Blink);                            \
}

#define DumpName(Field,Width) {                                    \
    ULONG i;                                                       \
    CHAR _String[256];                                             \
    if ((FatDumpCurrentColumn + 18 + Width) > 80) {DumpNewLine();} \
    FatDumpCurrentColumn += 18 + Width;                            \
    DumpLabel(Field,18);                                           \
    for(i=0;i<Width;i++) {_String[i] = Ptr->Field[i];}             \
    _String[Width] = '\0';                                         \
    DbgPrint("%s", _String);                                        \
}

#define TestForNull(Name) {                                 \
    if (Ptr == NULL) {                                      \
        DbgPrint("%s - Cannot dump a NULL pointer\n", Name); \
        return;                                             \
    }                                                       \
}


VOID
FatDump (
    IN PVOID Ptr
    )

/*++

Routine Description:

    This routine determines the type of internal record reference by ptr and
    calls the appropriate dump routine.

Arguments:

    Ptr - Supplies the pointer to the record to be dumped

Return Value:

    None

--*/

{
    TestForNull("FatDump");

    switch (NodeType(Ptr)) {

    case FAT_NTC_DATA_HEADER:

        FatDumpDataHeader();
        break;

    case FAT_NTC_VCB:

        FatDumpVcb(Ptr);
        break;

    case FAT_NTC_FCB:
    case FAT_NTC_DCB:
    case FAT_NTC_ROOT_DCB:

        FatDumpFcb(Ptr);
        break;

    case FAT_NTC_CCB:

        FatDumpCcb(Ptr);
        break;

    default :

        DbgPrint("FatDump - Unknown Node type code %8lx\n", *((PNODE_TYPE_CODE)(Ptr)));
        break;
    }

    return;
}


VOID
FatDumpDataHeader (
    )

/*++

Routine Description:

    Dump the top data structures and all Device structures

Arguments:

    None

Return Value:

    None

--*/

{
    PFAT_DATA Ptr;
    PLIST_ENTRY Links;

    Ptr = &FatData;

    TestForNull("FatDumpDataHeader");

    DumpNewLine();
    DbgPrint("FatData@ %lx", (Ptr));
    DumpNewLine();

    DumpField           (NodeTypeCode);
    DumpField           (NodeByteSize);
    DumpListEntry       (VcbQueue);
    DumpField           (DriverObject);
    DumpField           (OurProcess);
    DumpNewLine();

    for (Links = Ptr->VcbQueue.Flink;
         Links != &Ptr->VcbQueue;
         Links = Links->Flink) {

        FatDumpVcb(CONTAINING_RECORD(Links, VCB, VcbLinks));
    }

    return;
}


VOID
FatDumpVcb (
    IN PVCB Ptr
    )

/*++

Routine Description:

    Dump an Device structure, its Fcb queue amd direct access queue.

Arguments:

    Ptr - Supplies the Device record to be dumped

Return Value:

    None

--*/

{
    TestForNull("FatDumpVcb");

    DumpNewLine();
    DbgPrint("Vcb@ %lx", (Ptr));
    DumpNewLine();

    DumpField           (VolumeFileHeader.NodeTypeCode);
    DumpField           (VolumeFileHeader.NodeByteSize);
    DumpListEntry       (VcbLinks);
    DumpField           (TargetDeviceObject);
    DumpField           (Vpb);
    DumpField           (VcbState);
    DumpField           (VcbCondition);
    DumpField           (RootDcb);
    DumpField           (DirectAccessOpenCount);
    DumpField           (OpenFileCount);
    DumpField           (ReadOnlyCount);
    DumpField           (AllocationSupport);
    DumpField           (AllocationSupport.RootDirectoryLbo);
    DumpField           (AllocationSupport.RootDirectorySize);
    DumpField           (AllocationSupport.FileAreaLbo);
    DumpField           (AllocationSupport.NumberOfClusters);
    DumpField           (AllocationSupport.NumberOfFreeClusters);
    DumpField           (AllocationSupport.FatIndexBitSize);
    DumpField           (AllocationSupport.LogOfBytesPerSector);
    DumpField           (AllocationSupport.LogOfBytesPerCluster);
    DumpField           (DirtyFatMcb);
    DumpField           (FreeClusterBitMap);
    DumpField           (VirtualVolumeFile);
    DumpField           (SectionObjectPointers.DataSectionObject);
    DumpField           (SectionObjectPointers.SharedCacheMap);
    DumpField           (SectionObjectPointers.ImageSectionObject);
    DumpField           (ClusterHint);
    DumpNewLine();

    FatDumpFcb(Ptr->RootDcb);

    return;
}


VOID
FatDumpFcb (
    IN PFCB Ptr
    )

/*++

Routine Description:

    Dump an Fcb structure, its various queues

Arguments:

    Ptr - Supplies the Fcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;

    TestForNull("FatDumpFcb");

    DumpNewLine();
    if      (NodeType(&Ptr->Header) == FAT_NTC_FCB)      {DbgPrint("Fcb@ %lx", (Ptr));}
    else if (NodeType(&Ptr->Header) == FAT_NTC_DCB)      {DbgPrint("Dcb@ %lx", (Ptr));}
    else if (NodeType(&Ptr->Header) == FAT_NTC_ROOT_DCB) {DbgPrint("RootDcb@ %lx", (Ptr));}
    else {DbgPrint("NonFcb NodeType @ %lx", (Ptr));}
    DumpNewLine();

    DumpField           (Header.NodeTypeCode);
    DumpField           (Header.NodeByteSize);
    DumpListEntry       (ParentDcbLinks);
    DumpField           (ParentDcb);
    DumpField           (Vcb);
    DumpField           (FcbState);
    DumpField           (FcbCondition);
    DumpField           (UncleanCount);
    DumpField           (OpenCount);
    DumpField           (DirentOffsetWithinDirectory);
    DumpField           (DirentFatFlags);
    DumpField           (FullFileName.Length);
    DumpField           (FullFileName.Buffer);
    DumpName            (FullFileName.Buffer, 32);
    DumpField           (ShortName.Name.Oem.Length);
    DumpField           (ShortName.Name.Oem.Buffer);
    DumpField           (NonPaged);
    DumpField           (Header.AllocationSize.LowPart);
    DumpField           (NonPaged->SectionObjectPointers.DataSectionObject);
    DumpField           (NonPaged->SectionObjectPointers.SharedCacheMap);
    DumpField           (NonPaged->SectionObjectPointers.ImageSectionObject);

    if ((Ptr->Header.NodeTypeCode == FAT_NTC_DCB) ||
        (Ptr->Header.NodeTypeCode == FAT_NTC_ROOT_DCB)) {

        DumpListEntry   (Specific.Dcb.ParentDcbQueue);
        DumpField       (Specific.Dcb.DirectoryFileOpenCount);
        DumpField       (Specific.Dcb.DirectoryFile);

    } else if (Ptr->Header.NodeTypeCode == FAT_NTC_FCB) {

        DumpField       (Header.FileSize.LowPart);

    } else {

        DumpNewLine();
        DbgPrint("Illegal Node type code");

    }
    DumpNewLine();

    if ((Ptr->Header.NodeTypeCode == FAT_NTC_DCB) ||
        (Ptr->Header.NodeTypeCode == FAT_NTC_ROOT_DCB)) {

        for (Links = Ptr->Specific.Dcb.ParentDcbQueue.Flink;
             Links != &Ptr->Specific.Dcb.ParentDcbQueue;
             Links = Links->Flink) {

            FatDumpFcb(CONTAINING_RECORD(Links, FCB, ParentDcbLinks));
        }
    }

    return;
}


VOID
FatDumpCcb (
    IN PCCB Ptr
    )

/*++

Routine Description:

    Dump a Ccb structure

Arguments:

    Ptr - Supplies the Ccb record to be dumped

Return Value:

    None

--*/

{
    TestForNull("FatDumpCcb");

    DumpNewLine();
    DbgPrint("Ccb@ %lx", (Ptr));
    DumpNewLine();

    DumpField           (NodeTypeCode);
    DumpField           (NodeByteSize);
    DumpField           (UnicodeQueryTemplate.Length);
    DumpName            (UnicodeQueryTemplate.Buffer, 32);
    DumpField           (OffsetToStartSearchFrom);
    DumpNewLine();

    return;
}

#endif // FASTFATDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\dirsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DirSup.c

Abstract:

    This module implements the dirent support routines for Fat.

// @@BEGIN_DDKSPLIT

Author:

    DavidGoebel     [DavidGoe]      08-Nov-90

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_DIRSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIRSUP)

//
//  The following three macro all assume the input dirent has been zeroed.
//

//
//  VOID
//  FatConstructDot (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDCB Directory,
//      IN PDIRENT ParentDirent,
//      IN OUT PDIRENT Dirent
//      );
//
//  The following macro is called to initalize the "." dirent.
//
//  Always setting FirstClusterOfFileHi is OK because it will be zero
//  unless we're working on a FAT 32 disk.
//

#define FatConstructDot(IRPCONTEXT,DCB,PARENT,DIRENT) {                  \
                                                                         \
    RtlCopyMemory( (PUCHAR)(DIRENT), ".          ", 11 );                \
    (DIRENT)->Attributes = FAT_DIRENT_ATTR_DIRECTORY;                    \
    (DIRENT)->LastWriteTime = (PARENT)->LastWriteTime;                   \
    if (FatData.ChicagoMode) {                                           \
        (DIRENT)->CreationTime = (PARENT)->CreationTime;                 \
        (DIRENT)->CreationMSec = (PARENT)->CreationMSec;                 \
        (DIRENT)->LastAccessDate = (PARENT)->LastAccessDate;             \
    }                                                                    \
    (DIRENT)->FirstClusterOfFile =                                       \
            (USHORT)(DCB)->FirstClusterOfFile;                           \
    (DIRENT)->FirstClusterOfFileHi =                                     \
            (USHORT)((DCB)->FirstClusterOfFile/0x10000);                 \
}

//
//  VOID
//  FatConstructDotDot (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDCB Directory,
//      IN PDIRENT ParentDirent,
//      IN OUT PDIRENT Dirent
//      );
//
//  The following macro is called to initalize the ".." dirent.
//
//  Always setting FirstClusterOfFileHi is OK because it will be zero
//  unless we're working on a FAT 32 disk.
//

#define FatConstructDotDot(IRPCONTEXT,DCB,PARENT,DIRENT) {   \
                                                             \
    RtlCopyMemory( (PUCHAR)(DIRENT), "..         ", 11 );    \
    (DIRENT)->Attributes = FAT_DIRENT_ATTR_DIRECTORY;        \
    (DIRENT)->LastWriteTime = (PARENT)->LastWriteTime;       \
    if (FatData.ChicagoMode) {                               \
        (DIRENT)->CreationTime = (PARENT)->CreationTime;     \
        (DIRENT)->CreationMSec = (PARENT)->CreationMSec;     \
        (DIRENT)->LastAccessDate = (PARENT)->LastAccessDate; \
    }                                                        \
    if (NodeType((DCB)->ParentDcb) == FAT_NTC_ROOT_DCB) {    \
        (DIRENT)->FirstClusterOfFile = 0;                    \
        (DIRENT)->FirstClusterOfFileHi = 0;                  \
    } else {                                                 \
        (DIRENT)->FirstClusterOfFile = (USHORT)              \
            ((DCB)->ParentDcb->FirstClusterOfFile);          \
        (DIRENT)->FirstClusterOfFileHi = (USHORT)            \
            ((DCB)->ParentDcb->FirstClusterOfFile/0x10000);  \
    }                                                        \
}

//
//  VOID
//  FatConstructEndDirent (
//      IN PIRP_CONTEXT IrpContext,
//      IN OUT PDIRENT Dirent
//      );
//
//  The following macro created the end dirent.  Note that since the
//  dirent was zeroed, the first byte of the name already contains 0x0,
//  so there is nothing to do.
//

#define FatConstructEndDirent(IRPCONTEXT,DIRENT) NOTHING

//
//  VOID
//  FatReadDirent (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDCB Dcb,
//      IN VBO Vbo,
//      OUT PBCB *Bcb,
//      OUT PVOID *Dirent,
//      OUT PNTSTATUS Status
//      );
//

//
//  This macro reads in a page of dirents when we step onto a new page,
//  or this is the first iteration of a loop and Bcb is NULL.
//

#define FatReadDirent(IRPCONTEXT,DCB,VBO,BCB,DIRENT,STATUS)       \
if ((VBO) >= (DCB)->Header.AllocationSize.LowPart) {              \
    *(STATUS) = STATUS_END_OF_FILE;                               \
    FatUnpinBcb( (IRPCONTEXT), *(BCB) );                          \
} else if ( ((VBO) % PAGE_SIZE == 0) || (*(BCB) == NULL) ) {      \
    FatUnpinBcb( (IRPCONTEXT), *(BCB) );                          \
    FatReadDirectoryFile( (IRPCONTEXT),                           \
                          (DCB),                                  \
                          (VBO) & ~(PAGE_SIZE - 1),               \
                          PAGE_SIZE,                              \
                          FALSE,                                  \
                          (BCB),                                  \
                          (PVOID *)(DIRENT),                      \
                          (STATUS) );                             \
    *(DIRENT) = (PVOID)((PUCHAR)*(DIRENT) + ((VBO) % PAGE_SIZE)); \
}

//
//  Internal support routines
//

UCHAR
FatComputeLfnChecksum (
    PDIRENT Dirent
    );

VOID
FatRescanDirectory (
    PIRP_CONTEXT IrpContext,
    PDCB Dcb
    );

ULONG
FatDefragDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN ULONG DirentsNeeded
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatComputeLfnChecksum)
#pragma alloc_text(PAGE, FatConstructDirent)
#pragma alloc_text(PAGE, FatConstructLabelDirent)
#pragma alloc_text(PAGE, FatCreateNewDirent)
#pragma alloc_text(PAGE, FatDefragDirectory)
#pragma alloc_text(PAGE, FatDeleteDirent)
#pragma alloc_text(PAGE, FatGetDirentFromFcbOrDcb)
#pragma alloc_text(PAGE, FatInitializeDirectoryDirent)
#pragma alloc_text(PAGE, FatIsDirectoryEmpty)
#pragma alloc_text(PAGE, FatLfnDirentExists)
#pragma alloc_text(PAGE, FatLocateDirent)
#pragma alloc_text(PAGE, FatLocateSimpleOemDirent)
#pragma alloc_text(PAGE, FatLocateVolumeLabel)
#pragma alloc_text(PAGE, FatRescanDirectory)
#pragma alloc_text(PAGE, FatSetFileSizeInDirent)
#pragma alloc_text(PAGE, FatTunnelFcbOrDcb)
#pragma alloc_text(PAGE, FatUpdateDirentFromFcb)
#endif


ULONG
FatCreateNewDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB ParentDirectory,
    IN ULONG DirentsNeeded
    )

/*++

Routine Description:

    This routine allocates on the disk a new dirent inside of the
    parent directory.  If a new dirent cannot be allocated (i.e.,
    because the disk is full or the root directory is full) then
    it raises the appropriate status.  The dirent itself is
    neither initialized nor pinned by this procedure.
    
Arguments:

    ParentDirectory - Supplies the DCB for the directory in which
        to create the new dirent

    DirentsNeeded - This is the number of continginous dirents required

Return Value:

    ByteOffset - Returns the VBO within the Parent directory where
        the dirent has been allocated

--*/

{
    VBO UnusedVbo;
    VBO DeletedHint;
    ULONG ByteOffset;

    PBCB Bcb = NULL;
    PDIRENT Dirent;
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatCreateNewDirent\n", 0);

    DebugTrace( 0, Dbg, "  ParentDirectory = %08lx\n", ParentDirectory);

    //
    //  If UnusedDirentVbo is within our current file allocation then we
    //  don't have to search through the directory at all; we know just
    //  where to put it.
    //
    //  If UnusedDirentVbo is beyond the current file allocation then
    //  there are no more unused dirents in the current allocation, though
    //  upon adding another cluster of allocation UnusedDirentVbo
    //  will point to an unused dirent.  Haveing found no unused dirents
    //  we use the DeletedDirentHint to try and find a deleted dirent in
    //  the current allocation.  In this also runs off the end of the file,
    //  we finally have to break down and allocate another sector.  Note
    //  that simply writing beyond the current allocation will automatically
    //  do just this.
    //
    //  We also must deal with the special case where UnusedDirentVbo and
    //  DeletedDirentHint have yet to be initialized.  In this case we must
    //  first walk through the directory looking for the first deleted entry
    //  first unused dirent.  After this point we continue as before.
    //  This virgin state is denoted by the special value of 0xffffffff.
    //

    UnusedVbo = ParentDirectory->Specific.Dcb.UnusedDirentVbo;
    DeletedHint = ParentDirectory->Specific.Dcb.DeletedDirentHint;

    //
    //  Check for our first call to this routine with this Dcb.  If so
    //  we have to correctly set the two hints in the Dcb.
    //

    if (UnusedVbo == 0xffffffff) {

        FatRescanDirectory( IrpContext, ParentDirectory );

        UnusedVbo = ParentDirectory->Specific.Dcb.UnusedDirentVbo;
        DeletedHint = ParentDirectory->Specific.Dcb.DeletedDirentHint;
    }

    //
    //  Now we know that UnusedDirentVbo and DeletedDirentHint are correctly
    //  set so we check if there is already an unused dirent in the the
    //  current allocation.  This is the easy case.
    //

    DebugTrace( 0, Dbg, "  UnusedVbo   = %08lx\n", UnusedVbo);
    DebugTrace( 0, Dbg, "  DeletedHint = %08lx\n", DeletedHint);

    if ( UnusedVbo + (DirentsNeeded * sizeof(DIRENT)) <=
         ParentDirectory->Header.AllocationSize.LowPart ) {

        //
        //  Get this unused dirent for the caller.  We have a
        //  sporting chance that we won't have to wait.
        //

        DebugTrace( 0, Dbg, "There is a never used entry.\n", 0);

        ByteOffset = UnusedVbo;

        UnusedVbo += DirentsNeeded * sizeof(DIRENT);

    } else {

        //
        //  Life is tough.  We have to march from the DeletedDirentHint
        //  looking for a deleted dirent.  If we get to EOF without finding
        //  one, we will have to allocate a new cluster.
        //

        ByteOffset =
            RtlFindClearBits( &ParentDirectory->Specific.Dcb.FreeDirentBitmap,
                              DirentsNeeded,
                              DeletedHint / sizeof(DIRENT) );

        //
        //  Do a quick check for a root directory allocation that failed
        //  simply because of fragmentation.  Also, only attempt to defrag
        //  if the length is less that 0x40000.  This is to avoid
        //  complications arising from crossing a MM view boundary (256kb).
        //  By default on DOS the root directory is only 0x2000 long.
        //
        //  Don't try to defrag fat32 root dirs.
        //

        if (!FatIsFat32(ParentDirectory->Vcb) &&
            (ByteOffset == -1) &&
            (NodeType(ParentDirectory) == FAT_NTC_ROOT_DCB) &&
            (ParentDirectory->Header.AllocationSize.LowPart <= 0x40000)) {

            ByteOffset = FatDefragDirectory( IrpContext, ParentDirectory, DirentsNeeded );
        }

        if (ByteOffset != -1) {

            //
            //  If we consuemed deleted dirents at Deleted Hint, update.
            //  We also may have consumed some un-used dirents as well,
            //  so be sure to check for that as well.
            //

            ByteOffset *= sizeof(DIRENT);

            if (ByteOffset == DeletedHint) {

                DeletedHint += DirentsNeeded * sizeof(DIRENT);
            }

            if (ByteOffset + DirentsNeeded * sizeof(DIRENT) > UnusedVbo) {

                UnusedVbo = ByteOffset + DirentsNeeded * sizeof(DIRENT);
            }

        } else {

            //
            //  We are going to have to allocate another cluster.  Do
            //  so, update both the UnusedVbo and the DeletedHint and bail.
            //

            DebugTrace( 0, Dbg, "We have to allocate another cluster.\n", 0);

            //
            //  A reason why we might fail, unrelated to physical reasons,
            //  is that we constrain to 64k directory entries to match the
            //  restriction on Win95.  There are fundamental reasons to do
            //  this since searching a FAT directory is a linear operation
            //  and to allow FAT32 to toss us over the cliff is not permissable.
            //

            if (ParentDirectory->Header.AllocationSize.LowPart >= (64 * 1024 * sizeof(DIRENT)) ||
                
                //
                //  Make sure we are not trying to expand the root directory on non
                //  FAT32.  FAT16 and FAT12 have fixed size allocations.
                //

                (!FatIsFat32(ParentDirectory->Vcb) &&
                 NodeType(ParentDirectory) == FAT_NTC_ROOT_DCB)) {
                    
                DebugTrace(0, Dbg, "Full root directory or too big on FAT32.  Raise Status.\n", 0);

                FatRaiseStatus( IrpContext, STATUS_CANNOT_MAKE );
            }

            //
            //  Take the last dirent(s) in this cluster.  We will allocate
            //  more clusters below.
            //

            ByteOffset = UnusedVbo;
            UnusedVbo += DirentsNeeded * sizeof(DIRENT);

            //
            //  Touch the directory file to cause space for the new dirents
            //  to be allocated.
            //

            Bcb = NULL;

            try {

                ULONG ClusterSize;
                PVOID Buffer;

                ClusterSize =
                    1 << ParentDirectory->Vcb->AllocationSupport.LogOfBytesPerCluster;

                FatPrepareWriteDirectoryFile( IrpContext,
                                              ParentDirectory,
                                              UnusedVbo,
                                              1,
                                              &Bcb,
                                              &Buffer,
                                              FALSE,
                                              TRUE,
                                              &Status );

            } finally {

                FatUnpinBcb( IrpContext, Bcb );
            }
        }
    }

    //
    //  If we are only requesting a single dirent, and we did not get the
    //  first dirent in a directory, then check that the preceding dirent
    //  is not an orphaned LFN.  If it is, then mark it deleted.  Thus
    //  reducing the possibility of an accidental pairing.
    //
    //  Only do this when we are in Chicago Mode.
    //

    Bcb = NULL;

    if (FatData.ChicagoMode &&
        (DirentsNeeded == 1) &&
        (ByteOffset > (NodeType(ParentDirectory) == FAT_NTC_ROOT_DCB ?
                       0 : 2 * sizeof(DIRENT)))) {
        try {

            FatReadDirent( IrpContext,
                           ParentDirectory,
                           ByteOffset - sizeof(DIRENT),
                           &Bcb,
                           &Dirent,
                           &Status );

            if ((Status != STATUS_SUCCESS) ||
                (Dirent->FileName[0] == FAT_DIRENT_NEVER_USED)) {

                FatPopUpFileCorrupt( IrpContext, ParentDirectory );

                FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            if ((Dirent->Attributes == FAT_DIRENT_ATTR_LFN) &&
                (Dirent->FileName[0] != FAT_DIRENT_DELETED)) {

                //
                //  Pin it, mark it, and set it dirty.
                //

                FatPinMappedData( IrpContext,
                                  ParentDirectory,
                                  ByteOffset - sizeof(DIRENT),
                                  sizeof(DIRENT),
                                  &Bcb );

                Dirent->FileName[0] = FAT_DIRENT_DELETED;

                FatSetDirtyBcb( IrpContext, Bcb, ParentDirectory->Vcb, TRUE );

                ASSERT( RtlAreBitsSet( &ParentDirectory->Specific.Dcb.FreeDirentBitmap,
                                       (ByteOffset - sizeof(DIRENT))/ sizeof(DIRENT),
                                       DirentsNeeded ) );

                RtlClearBits( &ParentDirectory->Specific.Dcb.FreeDirentBitmap,
                              (ByteOffset - sizeof(DIRENT))/ sizeof(DIRENT),
                              DirentsNeeded );

            }

        } finally {

            FatUnpinBcb( IrpContext, Bcb );
        }
    }

    //
    //  Assert that the dirents are in fact unused
    //

    try {

        ULONG i;

        Bcb = NULL;

        for (i = 0; i < DirentsNeeded; i++) {

            FatReadDirent( IrpContext,
                           ParentDirectory,
                           ByteOffset + i*sizeof(DIRENT),
                           &Bcb,
                           &Dirent,
                           &Status );

            if ((Status != STATUS_SUCCESS) ||
                ((Dirent->FileName[0] != FAT_DIRENT_NEVER_USED) &&
                 (Dirent->FileName[0] != FAT_DIRENT_DELETED))) {

                FatPopUpFileCorrupt( IrpContext, ParentDirectory );
                FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }
        }

    } finally {

        FatUnpinBcb( IrpContext, Bcb );
    }

    //
    //  Set the Bits in the bitmap and move the Unused Dirent Vbo.
    //

    ASSERT( RtlAreBitsClear( &ParentDirectory->Specific.Dcb.FreeDirentBitmap,
                             ByteOffset / sizeof(DIRENT),
                             DirentsNeeded ) );

    RtlSetBits( &ParentDirectory->Specific.Dcb.FreeDirentBitmap,
                ByteOffset / sizeof(DIRENT),
                DirentsNeeded );

    //
    //  Save the newly computed values in the Parent Directory Fcb
    //

    ParentDirectory->Specific.Dcb.UnusedDirentVbo = UnusedVbo;
    ParentDirectory->Specific.Dcb.DeletedDirentHint = DeletedHint;

    DebugTrace(-1, Dbg, "FatCreateNewDirent -> (VOID)\n", 0);

    return ByteOffset;
}


VOID
FatInitializeDirectoryDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN PDIRENT ParentDirent
    )

/*++

Routine Description:

    This routine converts a dirent into a directory on the disk.  It does this
    setting the directory flag in the dirent, and by allocating the necessary
    space for the "." and ".." dirents and initializing them.

    If a new dirent cannot be allocated (i.e., because the disk is full) then
    it raises the appropriate status.

Arguments:

    Dcb - Supplies the Dcb denoting the file that is to be made into a
        directory.  This must be input a completely empty file with
        an allocation size of zero.

    ParentDirent - Provides the parent Dirent for a time-stamp model.

Return Value:

    None.

--*/

{
    PBCB Bcb;
    PVOID Buffer;
    NTSTATUS DontCare;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatInitializeDirectoryDirent\n", 0);

    DebugTrace( 0, Dbg, "  Dcb = %08lx\n", Dcb);

    //
    //  Assert that we are not attempting this on the root directory.
    //

    ASSERT( NodeType(Dcb) != FAT_NTC_ROOT_DCB );

    //
    //  Assert that this is only attempted on newly created directories.
    //

    ASSERT( Dcb->Header.AllocationSize.LowPart == 0 );

    //
    //  Prepare the directory file for writing.  Note that we can use a single
    //  Bcb for these two entries because we know they are the first two in
    //  the directory, and thus together do not span a page boundry.  Also
    //  note that we prepare write 2 entries: one for "." and one for "..".
    //  The end of directory marker is automatically set since the whole
    //  directory is initially zero (DIRENT_NEVER_USED).
    //

    FatPrepareWriteDirectoryFile( IrpContext,
                                  Dcb,
                                  0,
                                  2 * sizeof(DIRENT),
                                  &Bcb,
                                  &Buffer,
                                  FALSE,
                                  TRUE,
                                  &DontCare );

    ASSERT( NT_SUCCESS( DontCare ));

    //
    //  Add the . and .. entries
    //

    try {

        FatConstructDot( IrpContext, Dcb, ParentDirent, (PDIRENT)Buffer + 0);

        FatConstructDotDot( IrpContext, Dcb, ParentDirent, (PDIRENT)Buffer + 1);

    //
    //  Unpin the buffer and return to the caller.
    //

    } finally {

        FatUnpinBcb( IrpContext, Bcb );
    }

    DebugTrace(-1, Dbg, "FatInitializeDirectoryDirent -> (VOID)\n", 0);
    return;
}


VOID
FatTunnelFcbOrDcb (
    IN PFCB FcbOrDcb,
    IN PCCB Ccb OPTIONAL
    )
/*++

Routine Description:

    This routine handles tunneling of an Fcb or Dcb associated with
    an object whose name is disappearing from a directory.

Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb whose name will be going away

    Ccb - Supplies the Ccb for the Fcb (not reqired for a Dcb) so
        that we know which name the Fcb was opened by

Return Value:

    None.

--*/
{
    UNICODE_STRING ShortNameWithCase;
    UNICODE_STRING DownCaseSeg;
    WCHAR ShortNameBuffer[8+1+3];
    NTSTATUS Status;
    USHORT i;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatTunnelFcbOrDcb\n", 0);

    if (NodeType(FcbOrDcb) == FAT_NTC_DCB) {

        //
        //  Directory deletion. Flush all entries from this directory in
        //  the cache for this volume
        //

        FsRtlDeleteKeyFromTunnelCache( &FcbOrDcb->Vcb->Tunnel,
                                       FatDirectoryKey(FcbOrDcb) );

    } else {

        //
        //  Was a file, so throw it into the tunnel cache
        //

        //
        //  Get the short name into UNICODE
        //

        ShortNameWithCase.Length = 0;
        ShortNameWithCase.MaximumLength = sizeof(ShortNameBuffer);
        ShortNameWithCase.Buffer = ShortNameBuffer;

        Status = RtlOemStringToCountedUnicodeString( &ShortNameWithCase,
                                                     &FcbOrDcb->ShortName.Name.Oem,
                                                     FALSE);

        ASSERT(ShortNameWithCase.Length != 0);

        ASSERT(NT_SUCCESS(Status));

        if (FlagOn(FcbOrDcb->FcbState, FCB_STATE_8_LOWER_CASE | FCB_STATE_3_LOWER_CASE)) {

            //
            //  Have to repair the case of the short name
            //

            for (i = 0; i < (ShortNameWithCase.Length/sizeof(WCHAR)) &&
                        ShortNameWithCase.Buffer[i] != L'.'; i++);

            //
            //  Now pointing at the '.', or otherwise the end of name component
            //

            if (FlagOn(FcbOrDcb->FcbState, FCB_STATE_8_LOWER_CASE)) {

                DownCaseSeg.Buffer = ShortNameWithCase.Buffer;
                DownCaseSeg.MaximumLength = DownCaseSeg.Length = i*sizeof(WCHAR);

                RtlDowncaseUnicodeString(&DownCaseSeg, &DownCaseSeg, FALSE);
            }

            i++;

            //
            //  Now pointing at first wchar of the extension.
            //

            if (FlagOn(FcbOrDcb->FcbState, FCB_STATE_3_LOWER_CASE)) {

                //
                //  It is not neccesarily the case that we can rely on the flag
                //  indicating that we really have an extension.
                //

                if ((i*sizeof(WCHAR)) < ShortNameWithCase.Length) {
                    DownCaseSeg.Buffer = &ShortNameWithCase.Buffer[i];
                    DownCaseSeg.MaximumLength = DownCaseSeg.Length = ShortNameWithCase.Length - i*sizeof(WCHAR);
    
                    RtlDowncaseUnicodeString(&DownCaseSeg, &DownCaseSeg, FALSE);
                }
            }
        }

        //
        //  ... and add it in
        //

        FsRtlAddToTunnelCache( &FcbOrDcb->Vcb->Tunnel,
                               FatDirectoryKey(FcbOrDcb->ParentDcb),
                               &ShortNameWithCase,
                               &FcbOrDcb->ExactCaseLongName,
                               BooleanFlagOn(Ccb->Flags, CCB_FLAG_OPENED_BY_SHORTNAME),
                               sizeof(LARGE_INTEGER),
                               &FcbOrDcb->CreationTime );
    }

    DebugTrace(-1, Dbg, "FatTunnelFcbOrDcb -> (VOID)\n", 0);

    return;
}


VOID
FatDeleteDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN PDELETE_CONTEXT DeleteContext OPTIONAL,
    IN BOOLEAN DeleteEa
    )

/*++

Routine Description:

    This routine Deletes on the disk the indicated dirent.  It does
    this by marking the dirent as deleted.

Arguments:

    FcbOrDcb - Supplies the FCB/DCB for the file/directory being
        deleted.  For a file the file size and allocation must be zero.
        (Zero allocation is implied by a zero cluster index).
        For a directory the allocation must be zero.

    DeleteContext - This variable, if speicified, may be used to preserve
        the file size and first cluster of file information in the dirent
        fot the benefit of unerase utilities.

    DeleteEa - Tells us whether to delete the EA and whether to check
        for no allocation/  Mainly TRUE.  FALSE passed in from rename.

Return Value:

    None.

--*/

{
    PBCB Bcb = NULL;
    PDIRENT Dirent;
    NTSTATUS DontCare;
    ULONG Offset;
    ULONG DirentsToDelete;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatDeleteDirent\n", 0);

    DebugTrace( 0, Dbg, "  FcbOrDcb = %08lx\n", FcbOrDcb);

    //
    //  We must be holding the vcb exclusive here to deal with the locate dirent
    //  cases where it cannot be holding the parent simply.  This is actually
    //  a true statement from olden daze, lets just wire in our assertion.
    //
    //  Among other reasons, it'd be darn unfortunate if this raced with the
    //  rename path.
    //
    
    ASSERT( ExIsResourceAcquiredExclusiveLite( &FcbOrDcb->Vcb->Resource ));

    //
    //  Assert that we are not attempting this on the root directory.
    //

    ASSERT( NodeType(FcbOrDcb) != FAT_NTC_ROOT_DCB );

    //
    //  Make sure all requests have zero allocation/file size
    //

    if (DeleteEa &&
        ((FcbOrDcb->Header.AllocationSize.LowPart != 0) ||
         ((NodeType(FcbOrDcb) == FAT_NTC_FCB) &&
          (FcbOrDcb->Header.FileSize.LowPart != 0)))) {

        DebugTrace( 0, Dbg, "Called with non zero allocation/file size.\n", 0);
        FatBugCheck( 0, 0, 0 );
    }

    //
    //  Now, mark the dirents deleted, unpin the Bcb, and return to the caller.
    //  Assert that there isn't any allocation associated with this dirent.
    //
    //  Note that this loop will end with Dirent pointing to the short name.
    //

    try {

        //
        //  We must acquire our parent exclusive to synchronize with enumerators
        //  who do not hold the vcb (ex: dirctrl).
        //
        //  This relies on our bottom up lockorder.
        //
    
        ExAcquireResourceExclusiveLite( FcbOrDcb->ParentDcb->Header.Resource, TRUE );
    
        for ( Offset = FcbOrDcb->LfnOffsetWithinDirectory;
              Offset <= FcbOrDcb->DirentOffsetWithinDirectory;
              Offset += sizeof(DIRENT), Dirent += 1 ) {

            //
            //  If we stepped onto a new page, or this is the first iteration,
            //  unpin the old page, and pin the new one.
            //

            if ((Offset == FcbOrDcb->LfnOffsetWithinDirectory) ||
                ((Offset & (PAGE_SIZE - 1)) == 0)) {

                FatUnpinBcb( IrpContext, Bcb );

                FatPrepareWriteDirectoryFile( IrpContext,
                                              FcbOrDcb->ParentDcb,
                                              Offset,
                                              sizeof(DIRENT),
                                              &Bcb,
                                              (PVOID *)&Dirent,
                                              FALSE,
                                              TRUE,
                                              &DontCare );
            }

            ASSERT( (Dirent->FirstClusterOfFile == 0) || !DeleteEa );
            Dirent->FileName[0] = FAT_DIRENT_DELETED;
        }

        //
        //  Back Dirent off by one to point back to the short dirent.
        //

        Dirent -= 1;

        //
        //  If there are extended attributes for this dirent, we will attempt
        //  to remove them.  We ignore any errors in removing Eas.
        //

        if (!FatIsFat32(FcbOrDcb->Vcb) &&
            DeleteEa && (Dirent->ExtendedAttributes != 0)) {

            try {

                FatDeleteEa( IrpContext,
                             FcbOrDcb->Vcb,
                             Dirent->ExtendedAttributes,
                             &FcbOrDcb->ShortName.Name.Oem );

            } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

                //
                //  We catch all exceptions that Fat catches, but don't do
                //  anything with them.
                //
            }
        }

        //
        //  Now clear the bits in the free dirent mask.
        //

        DirentsToDelete = (FcbOrDcb->DirentOffsetWithinDirectory -
                           FcbOrDcb->LfnOffsetWithinDirectory) / sizeof(DIRENT) + 1;


        ASSERT( (FcbOrDcb->ParentDcb->Specific.Dcb.UnusedDirentVbo == 0xffffffff) ||
                RtlAreBitsSet( &FcbOrDcb->ParentDcb->Specific.Dcb.FreeDirentBitmap,
                               FcbOrDcb->LfnOffsetWithinDirectory / sizeof(DIRENT),
                               DirentsToDelete ) );

        RtlClearBits( &FcbOrDcb->ParentDcb->Specific.Dcb.FreeDirentBitmap,
                      FcbOrDcb->LfnOffsetWithinDirectory / sizeof(DIRENT),
                      DirentsToDelete );

        //
        //  Now, if the caller specified a DeleteContext, use it.
        //

        if ( ARGUMENT_PRESENT( DeleteContext ) ) {

            Dirent->FileSize = DeleteContext->FileSize;
            Dirent->FirstClusterOfFile = (USHORT)DeleteContext->FirstClusterOfFile;
        }

        //
        //  If this newly deleted dirent is before the DeletedDirentHint, change
        //  the DeletedDirentHint to point here.
        //

        if (FcbOrDcb->DirentOffsetWithinDirectory <
                            FcbOrDcb->ParentDcb->Specific.Dcb.DeletedDirentHint) {

            FcbOrDcb->ParentDcb->Specific.Dcb.DeletedDirentHint =
                                            FcbOrDcb->LfnOffsetWithinDirectory;
        }

    } finally {

        FatUnpinBcb( IrpContext, Bcb );
        
        //
        //  Release our parent.
        //
    
        ExReleaseResourceLite( FcbOrDcb->ParentDcb->Header.Resource );
    }

    DebugTrace(-1, Dbg, "FatDeleteDirent -> (VOID)\n", 0);
    return;
}

BOOLEAN
FatLfnDirentExists (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN PUNICODE_STRING Lfn,
    IN PUNICODE_STRING LfnTmp
    )
/*++

Routine Description:

    This routine looks for a given Lfn in a directory

Arguments:

    Dcb - The directory to search

    Lfn - The Lfn to look for

    Lfn - Temporary buffer to use to search for Lfn with (if < MAX_LFN then this 
        function may cause it to be allocated from pool if not large enough.

Retrn Value:

    BOOLEAN TRUE if it exists, FALSE if not

--*/
{
    CCB Ccb;
    PDIRENT Dirent;
    PBCB DirentBcb = NULL;
    VBO DirentByteOffset;
    BOOLEAN Result = FALSE;

    PAGED_CODE();

    //
    //  Pay performance penalty by forcing the compares to be case insensitive as
    //  opposed to grabbing more pool for a monocased copy of the Lfn. This is slight.
    //

    Ccb.UnicodeQueryTemplate =  *Lfn;
    Ccb.ContainsWildCards = FALSE;
    Ccb.Flags = CCB_FLAG_SKIP_SHORT_NAME_COMPARE | CCB_FLAG_QUERY_TEMPLATE_MIXED;

    try {
        
        FatLocateDirent( IrpContext,
                         Dcb,
                         &Ccb,
                         0,
                         &Dirent,
                         &DirentBcb,
                         &DirentByteOffset,
                         NULL,
                         LfnTmp);
        
    } finally {

        if (DirentBcb) {

            Result = TRUE;
        }
        
        FatUnpinBcb(IrpContext, DirentBcb);
    }

    return Result;
}

VOID
FatLocateDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB ParentDirectory,
    IN PCCB Ccb,
    IN VBO OffsetToStartSearchFrom,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb,
    OUT PVBO ByteOffset,
    OUT PBOOLEAN FileNameDos OPTIONAL,
    IN OUT PUNICODE_STRING LongFileName OPTIONAL
    )

/*++

Routine Description:

    This routine locates on the disk an undeleted dirent matching a given name.

Arguments:

    ParentDirectory - Supplies the DCB for the directory to search

    Ccb - Contains a context control block with all matching information.

    OffsetToStartSearchFrom - Supplies the VBO within the parent directory
        from which to start looking for another real dirent.

    Dirent - Receives a pointer to the located dirent if one was found
        or NULL otherwise.

    Bcb - Receives the Bcb for the located dirent if one was found or
        NULL otherwise.

    ByteOffset - Receives the VBO within the Parent directory for
        the located dirent if one was found, or 0 otherwise.

    FileNameDos - Receives TRUE if the element of the dirent we hit on
        was the short (non LFN) side

    LongFileName - If specified, this parameter returns the long file name
        associated with the returned dirent.  Note that it is the caller's
        responsibility to provide the buffer (and set MaximumLength
        accordingly) for this unicode string.  The Length field is reset
        to 0 by this routine on invocation.  If the supplied buffer is not
        large enough,  a new one will be allocated from pool.

Return Value:

    None.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    OEM_STRING Name;
    UCHAR NameBuffer[12];

    UNICODE_STRING UpcasedLfn;

    WCHAR LocalLfnBuffer[32];

    BOOLEAN LfnInProgress = FALSE;
    UCHAR LfnChecksum;
    ULONG LfnSize;
    ULONG LfnIndex;
    UCHAR Ordinal;
    VBO LfnByteOffset;

    TimerStart(Dbg);

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatLocateDirent\n", 0);

    DebugTrace( 0, Dbg, "  ParentDirectory         = %08lx\n", ParentDirectory);
    DebugTrace( 0, Dbg, "  OffsetToStartSearchFrom = %08lx\n", OffsetToStartSearchFrom);
    DebugTrace( 0, Dbg, "  Dirent                  = %08lx\n", Dirent);
    DebugTrace( 0, Dbg, "  Bcb                     = %08lx\n", Bcb);
    DebugTrace( 0, Dbg, "  ByteOffset              = %08lx\n", ByteOffset);

    //
    //  We must have acquired the parent or the vcb to synchronize with deletion.  This
    //  is important since we can't survive racing a thread marking a series of lfn
    //  dirents deleted - we'd get a bogus ordinal, and otherwise get really messed up.
    //  
    //  This routine cannot do the acquire since it would be out-of-order with respect
    //  to the Bcb resources on iterative calls.  Our order has Bcbs as the inferior resource.
    //
    //  Deletion always grabs the parent (safely - this used to not be possible until the
    //  multiple fcb lockorder was fixed to be bottom up!).  Deletion always occurs with
    //  the vcb held exclusive as well, and this will cover the cases where we can't easily
    //  hold the parent here, see above.
    //

    ASSERT( ExIsResourceAcquiredSharedLite( ParentDirectory->Header.Resource ) ||
            ExIsResourceAcquiredExclusiveLite( ParentDirectory->Header.Resource ) ||
            ExIsResourceAcquiredSharedLite( &ParentDirectory->Vcb->Resource ) ||
            ExIsResourceAcquiredExclusiveLite( &ParentDirectory->Vcb->Resource ));
    
    //
    //  The algorithm here is pretty simple.  We just walk through the
    //  parent directory until we:
    //
    //      A)  Find a matching entry.
    //      B)  Can't Wait
    //      C)  Hit the End of Directory
    //      D)  Hit Eof
    //
    //  In the first case we found it, in the latter three cases we did not.
    //

    //
    //  Set up the strings that receives file names from our search
    //

    Name.MaximumLength = 12;
    Name.Buffer = NameBuffer;

    UpcasedLfn.Length = 0;
    UpcasedLfn.MaximumLength = sizeof( LocalLfnBuffer);
    UpcasedLfn.Buffer = LocalLfnBuffer;

    //
    //  If we were given a non-NULL Bcb, compute the new Dirent address
    //  from the prior one, or unpin the Bcb if the new Dirent is not pinned.
    //

    if (*Bcb != NULL) {

        if ((OffsetToStartSearchFrom / PAGE_SIZE) == (*ByteOffset / PAGE_SIZE)) {

            *Dirent += (OffsetToStartSearchFrom - *ByteOffset) / sizeof(DIRENT);

        } else {

            FatUnpinBcb( IrpContext, *Bcb );
        }
    }

    //
    //  Init the Lfn if we were given one.
    //

    if (ARGUMENT_PRESENT(LongFileName)) {

        LongFileName->Length = 0;
    }

    //
    //  Init the FileNameDos flag
    //

    if (FileNameDos) {

        *FileNameDos = FALSE;
    }

    //
    //  Round up OffsetToStartSearchFrom to the nearest Dirent, and store
    //  in ByteOffset.  Note that this wipes out the prior value.
    //

    *ByteOffset = (OffsetToStartSearchFrom +  (sizeof(DIRENT) - 1))
                                           & ~(sizeof(DIRENT) - 1);

    try {

        while ( TRUE ) {

            BOOLEAN FoundValidLfn;

            //
            //  Try to read in the dirent
            //

            FatReadDirent( IrpContext,
                           ParentDirectory,
                           *ByteOffset,
                           Bcb,
                           Dirent,
                           &Status );

            //
            //  If End Directory dirent or EOF, set all out parameters to
            //  indicate entry not found and, like, bail.
            //
            //  Note that the order of evaluation here is important since we
            //  cannot check the first character of the dirent until after we
            //  know we are not beyond EOF
            //

            if ((Status == STATUS_END_OF_FILE) ||
                ((*Dirent)->FileName[0] == FAT_DIRENT_NEVER_USED)) {

                DebugTrace( 0, Dbg, "End of directory: entry not found.\n", 0);

                //
                //  If there is a Bcb, unpin it and set it to null
                //

                FatUnpinBcb( IrpContext, *Bcb );

                *Dirent = NULL;
                *ByteOffset = 0;
                break;
            }

            //
            //  If the entry is marked deleted, skip.  If there was an Lfn in
            //  progress we throw it out at this point.
            //
            
            if ((*Dirent)->FileName[0] == FAT_DIRENT_DELETED) {

                LfnInProgress = FALSE;
                goto GetNextDirent;
            }

            //
            //  If we have wandered onto an LFN entry, try to interpret it.
            //

            if (FatData.ChicagoMode &&
                ARGUMENT_PRESENT(LongFileName) &&
                ((*Dirent)->Attributes == FAT_DIRENT_ATTR_LFN)) {

                PLFN_DIRENT Lfn;

                Lfn = (PLFN_DIRENT)*Dirent;

                if (LfnInProgress) {

                    //
                    //  Check for a proper continuation of the Lfn in progress.
                    //

                    if ((Lfn->Ordinal & FAT_LAST_LONG_ENTRY) ||
                        (Lfn->Ordinal == 0) ||
                        (Lfn->Ordinal != Ordinal - 1) ||
                        (Lfn->Checksum != LfnChecksum) ||
                        (Lfn->MustBeZero != 0)) {

                        //
                        //  The Lfn is not proper, stop constructing it.
                        //

                        LfnInProgress = FALSE;

                    } else {

                        ASSERT( ((LfnIndex % 13) == 0) && LfnIndex );

                        LfnIndex -= 13;

                        RtlCopyMemory( &LongFileName->Buffer[LfnIndex+0],
                                       &Lfn->Name1[0],
                                       5*sizeof(WCHAR) );

                        RtlCopyMemory( &LongFileName->Buffer[LfnIndex+5],
                                       &Lfn->Name2[0],
                                       6 * sizeof(WCHAR) );

                        RtlCopyMemory( &LongFileName->Buffer[LfnIndex+11],
                                       &Lfn->Name3[0],
                                       2 * sizeof(WCHAR) );

                        Ordinal = Lfn->Ordinal;
                        LfnByteOffset = *ByteOffset;
                    }
                }

                //
                //  Now check (maybe again) if we should analyze this entry
                //  for a possible last entry.
                //

                if ((!LfnInProgress) &&
                    (Lfn->Ordinal & FAT_LAST_LONG_ENTRY) &&
                    ((Lfn->Ordinal & ~FAT_LAST_LONG_ENTRY) <= MAX_LFN_DIRENTS) &&
                    (Lfn->MustBeZero == 0)) {

                    BOOLEAN CheckTail = FALSE;

                    Ordinal = Lfn->Ordinal & ~FAT_LAST_LONG_ENTRY;

                    //
                    //  We're usually permissive (following the lead of Win9x) when we find
                    //  malformation of the LFN dirent pile.  I'm not sure this is a good idea,
                    //  so I'm going to trigger corruption on this particularly ugly one.  Perhaps
                    //  we should come back and redo the original code here with this in mind in the
                    //  future.
                    //

                    if (Ordinal == 0) {

                        //
                        //  First LFN in the pile was zero marked as the last. This is never
                        //  possible since oridinals are 1-based.
                        //

                        FatPopUpFileCorrupt( IrpContext, ParentDirectory );
                        FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                    }

                    LfnIndex = (Ordinal - 1) * 13;

                    FatEnsureStringBufferEnough( LongFileName, 
                                                 (USHORT)((LfnIndex + 13) << 1));

                    RtlCopyMemory( &LongFileName->Buffer[LfnIndex+0],
                                   &Lfn->Name1[0],
                                   5*sizeof(WCHAR));

                    RtlCopyMemory( &LongFileName->Buffer[LfnIndex+5],
                                   &Lfn->Name2[0],
                                   6 * sizeof(WCHAR) );

                    RtlCopyMemory( &LongFileName->Buffer[LfnIndex+11],
                                   &Lfn->Name3[0],
                                   2 * sizeof(WCHAR) );

                    //
                    //  Now compute the Lfn size and make sure that the tail
                    //  bytes are correct.
                    //

                    while (LfnIndex != (ULONG)Ordinal * 13) {

                        if (!CheckTail) {

                            if (LongFileName->Buffer[LfnIndex] == 0x0000) {

                                LfnSize = LfnIndex;
                                CheckTail = TRUE;
                            }

                        } else {

                            if (LongFileName->Buffer[LfnIndex] != 0xffff) {

                                break;
                            }
                        }

                        LfnIndex += 1;
                    }

                    //
                    //  If we exited this loop prematurely, the LFN is not valid.
                    //

                    if (LfnIndex == (ULONG)Ordinal * 13) {

                        //
                        //  If we didn't find the NULL terminator, then the size
                        //  is LfnIndex.
                        //

                        if (!CheckTail) {

                            LfnSize = LfnIndex;
                        }

                        LfnIndex -= 13;
                        LfnInProgress = TRUE;
                        LfnChecksum = Lfn->Checksum;
                        LfnByteOffset = *ByteOffset;
                    }
                }

                //
                //  Move on to the next dirent.
                //

                goto GetNextDirent;
            }

            //
            //  If this is the volume label, skip.  Note that we never arrive here
            //  while building the LFN.  If we did, we weren't asked to find LFNs
            //  and that is another good reason to skip this LFN fragment.
            //

            if (FlagOn((*Dirent)->Attributes, FAT_DIRENT_ATTR_VOLUME_ID)) {

                //
                //  If we actually were asked to hand back volume labels,
                //  do it.
                //
                
                if (FlagOn(Ccb->Flags, CCB_FLAG_MATCH_VOLUME_ID)) {

                    break;
                }

                goto GetNextDirent;
            }

            //
            //  We may have just stepped off a valid Lfn run.  Check to see if
            //  it is indeed valid for the following dirent.
            //

            if (LfnInProgress &&
                (*ByteOffset == LfnByteOffset + sizeof(DIRENT)) &&
                (LfnIndex == 0) &&
                (FatComputeLfnChecksum(*Dirent) == LfnChecksum)) {

                ASSERT( Ordinal == 1);

                FoundValidLfn = TRUE;
                LongFileName->Length = (USHORT)(LfnSize * sizeof(WCHAR));

            } else {

                FoundValidLfn = FALSE;
            }

            //
            //  If we are supposed to match all entries, then match this entry.
            //

            if (FlagOn(Ccb->Flags, CCB_FLAG_MATCH_ALL)) {

                break;
            }

            //
            //  Check against the short name given if one was.
            //

            if (!FlagOn( Ccb->Flags, CCB_FLAG_SKIP_SHORT_NAME_COMPARE )) {

                if (Ccb->ContainsWildCards) {

                    //
                    //  If we get one, note that all out parameters are already set.
                    //

                    (VOID)Fat8dot3ToString( IrpContext, (*Dirent), FALSE, &Name );

                    //
                    //  For fat we special case the ".." dirent because we want it to
                    //  match ????????.??? and to do that we change ".." to "." before
                    //  calling the Fsrtl routine.  But only do this if the expression
                    //  is greater than one character long.
                    //

                    if ((Name.Length == 2) &&
                        (Name.Buffer[0] == '.') &&
                        (Name.Buffer[1] == '.') &&
                        (Ccb->OemQueryTemplate.Wild.Length > 1)) {

                        Name.Length = 1;
                    }

                    if (FatIsNameInExpression( IrpContext,
                                               Ccb->OemQueryTemplate.Wild,
                                               Name)) {

                        DebugTrace( 0, Dbg, "Entry found: Name = \"%Z\"\n", &Name);
                        DebugTrace( 0, Dbg, "             VBO  = %08lx\n", *ByteOffset);

                        if (FileNameDos) {

                            *FileNameDos = TRUE;
                        }

                        break;
                    }

                } else {

                    //
                    //  Do the quickest 8.3 equivalency check possible
                    //

                    if (!FlagOn((*Dirent)->Attributes, FAT_DIRENT_ATTR_VOLUME_ID) &&
                        (*(PULONG)&(Ccb->OemQueryTemplate.Constant[0]) == *(PULONG)&((*Dirent)->FileName[0])) &&
                        (*(PULONG)&(Ccb->OemQueryTemplate.Constant[4]) == *(PULONG)&((*Dirent)->FileName[4])) &&
                        (*(PUSHORT)&(Ccb->OemQueryTemplate.Constant[8]) == *(PUSHORT)&((*Dirent)->FileName[8])) &&
                        (*(PUCHAR)&(Ccb->OemQueryTemplate.Constant[10]) == *(PUCHAR)&((*Dirent)->FileName[10]))) {

                        DebugTrace( 0, Dbg, "Entry found.\n", 0);

                        if (FileNameDos) {

                            *FileNameDos = TRUE;
                        }

                        break;
                    }
                }
            }

            //
            //  No matches were found with the short name.  If an LFN exists,
            //  use it for the search.
            //

            if (FoundValidLfn) {

                //
                //  First do a quick check here for different sized constant
                //  name and expression before upcasing.
                //

                if (!Ccb->ContainsWildCards &&
                    Ccb->UnicodeQueryTemplate.Length != (USHORT)(LfnSize * sizeof(WCHAR))) {

                    //
                    //  Move on to the next dirent.
                    //

                    FoundValidLfn = FALSE;
                    LongFileName->Length = 0;

                    goto GetNextDirent;
                }

                //
                //  We need to upcase the name we found.
                //  We need a buffer.  Try to avoid doing an allocation.
                //

                FatEnsureStringBufferEnough( &UpcasedLfn, 
                                             LongFileName->Length);

                Status = RtlUpcaseUnicodeString( &UpcasedLfn,
                                                 LongFileName,
                                                 FALSE );

                if (!NT_SUCCESS(Status)) {

                    FatNormalizeAndRaiseStatus( IrpContext, Status );
                }

                //
                //  Do the compare
                //

                if (Ccb->ContainsWildCards) {

                    if (FsRtlIsNameInExpression( &Ccb->UnicodeQueryTemplate,
                                                 &UpcasedLfn,
                                                 TRUE,
                                                 NULL )) {

                        break;
                    }

                } else {

                    if (FsRtlAreNamesEqual( &Ccb->UnicodeQueryTemplate,
                                            &UpcasedLfn,
                                            BooleanFlagOn( Ccb->Flags, CCB_FLAG_QUERY_TEMPLATE_MIXED ),
                                            NULL )) {

                        break;
                    }
                }
            }

            //
            //  This long name was not a match.  Zero out the Length field.
            //

            if (FoundValidLfn) {

                FoundValidLfn = FALSE;
                LongFileName->Length = 0;
            }

GetNextDirent:

            //
            //  Move on to the next dirent.
            //

            *ByteOffset += sizeof(DIRENT);
            *Dirent += 1;
        }

    } finally {

        FatFreeStringBuffer( &UpcasedLfn);
    }

    DebugTrace(-1, Dbg, "FatLocateDirent -> (VOID)\n", 0);

    TimerStop(Dbg,"FatLocateDirent");

    return;
}


VOID
FatLocateSimpleOemDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB ParentDirectory,
    IN POEM_STRING FileName,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb,
    OUT PVBO ByteOffset
    )

/*++

Routine Description:

    This routine locates on the disk an undelted simple Oem dirent.  By simple
    I mean that FileName cannot contain any extended characters, and we do
    not search LFNs or return them.

Arguments:

    ParentDirectory - Supplies the DCB for the directory in which
        to search

    FileName - Supplies the filename to search for.  The name may contain
        wild cards

    OffsetToStartSearchFrom - Supplies the VBO within the parent directory
        from which to start looking for another real dirent.

    Dirent - Receives a pointer to the located dirent if one was found
        or NULL otherwise.

    Bcb - Receives the Bcb for the located dirent if one was found or
        NULL otherwise.

    ByteOffset - Receives the VBO within the Parent directory for
        the located dirent if one was found, or 0 otherwise.

Return Value:

    None.

--*/

{
    CCB LocalCcb;

    PAGED_CODE();

    //
    //  Note, this routine is called rarely, so performance is not critical.
    //  Just fill in a Ccb structure on my stack with the values that are
    //  required.
    //

    FatStringTo8dot3( IrpContext,
                      *FileName,
                      &LocalCcb.OemQueryTemplate.Constant );
    LocalCcb.ContainsWildCards = FALSE;
    LocalCcb.Flags = 0;

    FatLocateDirent( IrpContext,
                     ParentDirectory,
                     &LocalCcb,
                     0,
                     Dirent,
                     Bcb,
                     ByteOffset,
                     NULL,
                     NULL);

    return;
}


VOID
FatLocateVolumeLabel (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb,
    OUT PVBO ByteOffset
    )

/*++

Routine Description:

    This routine locates on the disk a dirent representing the volume
    label.  It does this by searching the root directory for a special
    volume label dirent.

Arguments:

    Vcb - Supplies the VCB for the volume to search

    Dirent - Receives a pointer to the located dirent if one was found
        or NULL otherwise.

    Bcb - Receives the Bcb for the located dirent if one was found or
        NULL otherwise.

    ByteOffset - Receives the VBO within the Parent directory for
        the located dirent if one was found, or 0 otherwise.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatLocateVolumeLabel\n", 0);

    DebugTrace( 0, Dbg, "  Vcb        = %08lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Dirent     = %08lx\n", Dirent);
    DebugTrace( 0, Dbg, "  Bcb        = %08lx\n", Bcb);
    DebugTrace( 0, Dbg, "  ByteOffset = %08lx\n", ByteOffset);

    //
    //  The algorithm here is really simple.  We just walk through the
    //  root directory until we:
    //
    //      A)  Find the non-deleted volume label
    //      B)  Can't Wait
    //      C)  Hit the End of Directory
    //      D)  Hit Eof
    //
    //  In the first case we found it, in the latter three cases we did not.
    //

    *Bcb = NULL;
    *ByteOffset = 0;

    while ( TRUE ) {

        //
        //  Try to read in the dirent
        //

        FatReadDirent( IrpContext,
                       Vcb->RootDcb,
                       *ByteOffset,
                       Bcb,
                       Dirent,
                       &Status );

        //
        //  If End Directory dirent or EOF, set all out parameters to
        //  indicate volume label not found and, like, bail.
        //
        //  Note that the order of evaluation here is important since we cannot
        //  check the first character of the dirent until after we know we
        //  are not beyond EOF
        //

        if ((Status == STATUS_END_OF_FILE) ||
            ((*Dirent)->FileName[0] == FAT_DIRENT_NEVER_USED)) {

            DebugTrace( 0, Dbg, "Volume label not found.\n", 0);

            //
            //  If there is a Bcb, unpin it and set it to null
            //

            FatUnpinBcb( IrpContext, *Bcb );

            *Dirent = NULL;
            *ByteOffset = 0;
            break;
        }

        //
        //  If the entry is the non-deleted volume label break from the loop.
        //
        //  Note that all out parameters are already correctly set.
        //

        if ((((*Dirent)->Attributes & ~FAT_DIRENT_ATTR_ARCHIVE) == FAT_DIRENT_ATTR_VOLUME_ID) &&
            ((*Dirent)->FileName[0] != FAT_DIRENT_DELETED)) {

            DebugTrace( 0, Dbg, "Volume label found at VBO = %08lx\n", *ByteOffset);

            //
            //  We may set this dirty, so pin it.
            //

            FatPinMappedData( IrpContext,
                              Vcb->RootDcb,
                              *ByteOffset,
                              sizeof(DIRENT),
                              Bcb );

            break;
        }

        //
        //  Move on to the next dirent.
        //

        *ByteOffset += sizeof(DIRENT);
        *Dirent += 1;
    }


    DebugTrace(-1, Dbg, "FatLocateVolumeLabel -> (VOID)\n", 0);

    return;
}


VOID
FatGetDirentFromFcbOrDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine reads locates on the disk the dirent denoted by the
    specified Fcb/Dcb.

Arguments:

    FcbOrDcb - Supplies the FCB/DCB for the file/directory whose dirent
        we are trying to read in.  This must not be the root dcb.

    Dirent - Receives a pointer to the dirent

    Bcb - Receives the Bcb for the dirent

Return Value:

    None.

--*/

{
    NTSTATUS DontCare;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatGetDirentFromFcbOrDcb\n", 0);

    DebugTrace( 0, Dbg, "  FcbOrDcb = %08lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  Dirent   = %08lx\n", Dirent);
    DebugTrace( 0, Dbg, "  Bcb      = %08lx\n", Bcb);

    //
    //  Assert that we are not attempting this on the root directory.
    //

    ASSERT( NodeType(FcbOrDcb) != FAT_NTC_ROOT_DCB );

    //
    //  We know the offset of the dirent within the directory file,
    //  so we just read it (with pinning).
    //

    FatReadDirectoryFile( IrpContext,
                          FcbOrDcb->ParentDcb,
                          FcbOrDcb->DirentOffsetWithinDirectory,
                          sizeof(DIRENT),
                          TRUE,
                          Bcb,
                          (PVOID *)Dirent,
                          &DontCare );

    //
    //  Previous call can fail.  We used to assert success, but we use this
    //  as part of volume verification (DetermineAndMarkFcbCondition) after
    //  media has been removed.  Clearly the directory could shrink and we
    //  would try to read beyond filesize.
    //
    //  The caller will note this via NULL pointers for Bcb/Buffer.  Note that
    //  both asserts below are OK since this should never happen fixed media.
    //
    //  This was a Prefix catch.
    //

    ASSERT( FlagOn( FcbOrDcb->Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) ||
            NT_SUCCESS( DontCare ));

    //
    //  Note also that the only way this could fail is if the Fcb was being
    //  verified.  This can't happen if the Fcb is in good condition.
    //
    //  Also a Prefix catch.
    //

    ASSERT( NT_SUCCESS( DontCare ) || FcbOrDcb->FcbCondition == FcbNeedsToBeVerified );

    DebugTrace(-1, Dbg, "FatGetDirentFromFcbOrDcb -> (VOID)\n", 0);
    return;
}


BOOLEAN
FatIsDirectoryEmpty (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    )

/*++

Routine Description:

    This routine indicates to the caller if the specified directory
    is empty.  (i.e., it is not the root dcb and it only contains
    the "." and ".." entries, or deleted files).

Arguments:

    Dcb - Supplies the DCB for the directory being queried.

Return Value:

    BOOLEAN - Returns TRUE if the directory is empty and
        FALSE if the directory and is not empty.

--*/

{
    PBCB Bcb;
    ULONG ByteOffset;
    PDIRENT Dirent;

    BOOLEAN IsDirectoryEmpty;

    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatIsDirectoryEmpty\n", 0);

    DebugTrace( 0, Dbg, "  Dcb              = %08lx\n", Dcb);
    DebugTrace( 0, Dbg, "  IsDirectoryEmpty = %08lx\n", IsDirectoryEmpty);

    //
    //  Check to see if the first entry is an and of directory marker.
    //  For the root directory we check at Vbo = 0, for normal directories
    //  we check after the "." and ".." entries.
    //

    ByteOffset = (NodeType(Dcb) == FAT_NTC_ROOT_DCB) ? 0 : 2*sizeof(DIRENT);

    //
    //  We just march through the directory looking for anything other
    //  than deleted files, LFNs, an EOF, or end of directory marker.
    //

    Bcb = NULL;

    try {

        while ( TRUE ) {

            //
            //  Try to read in the dirent
            //

            FatReadDirent( IrpContext,
                           Dcb,
                           ByteOffset,
                           &Bcb,
                           &Dirent,
                           &Status );

            //
            //  If End Directory dirent or EOF, set IsDirectoryEmpty to TRUE and,
            //  like, bail.
            //
            //  Note that the order of evaluation here is important since we cannot
            //  check the first character of the dirent until after we know we
            //  are not beyond EOF
            //

            if ((Status == STATUS_END_OF_FILE) ||
                (Dirent->FileName[0] == FAT_DIRENT_NEVER_USED)) {

                DebugTrace( 0, Dbg, "Empty.  Last exempt entry at VBO = %08lx\n", ByteOffset);

                IsDirectoryEmpty = TRUE;
                break;
            }

            //
            //  If this dirent is NOT deleted or an LFN set IsDirectoryEmpty to
            //  FALSE and, like, bail.
            //

            if ((Dirent->FileName[0] != FAT_DIRENT_DELETED) &&
                (Dirent->Attributes != FAT_DIRENT_ATTR_LFN)) {

                DebugTrace( 0, Dbg, "Not Empty.  First entry at VBO = %08lx\n", ByteOffset);

                IsDirectoryEmpty = FALSE;
                break;
            }

            //
            //  Move on to the next dirent.
            //

            ByteOffset += sizeof(DIRENT);
            Dirent += 1;
        }

    } finally {

        FatUnpinBcb( IrpContext, Bcb );
    }

    DebugTrace(-1, Dbg, "FatIsDirectoryEmpty -> %ld\n", IsDirectoryEmpty);

    return IsDirectoryEmpty;
}


VOID
FatConstructDirent (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDIRENT Dirent,
    IN POEM_STRING FileName,
    IN BOOLEAN ComponentReallyLowercase,
    IN BOOLEAN ExtensionReallyLowercase,
    IN PUNICODE_STRING Lfn OPTIONAL,
    IN UCHAR Attributes,
    IN BOOLEAN ZeroAndSetTimeFields,
    IN PLARGE_INTEGER SetCreationTime OPTIONAL
    )

/*++

Routine Description:

    This routine modifies the fields of a dirent.

Arguments:

    Dirent - Supplies the dirent being modified.

    FileName - Supplies the name to store in the Dirent.  This
        name must not contain wildcards.

    ComponentReallyLowercase - This boolean indicates that the User Specified
        compoent name was really all a-z and < 0x80 characters.  We set the
        magic bit in this case.

    ExtensionReallyLowercase - Same as above, but for the extension.

    Lfn - May supply a long file name.

    Attributes - Supplies the attributes to store in the dirent

    ZeroAndSetTimeFields - Tells whether or not to initially zero the dirent
        and update the time fields.

    SetCreationTime - If specified, contains a timestamp to use as the creation
        time of this dirent

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatConstructDirent\n", 0);

    DebugTrace( 0, Dbg, "  Dirent             = %08lx\n", Dirent);
    DebugTrace( 0, Dbg, "  FileName           = %Z\n", FileName);
    DebugTrace( 0, Dbg, "  Attributes         = %08lx\n", Attributes);

    if (ZeroAndSetTimeFields) {

        RtlZeroMemory( Dirent, sizeof(DIRENT) );
    }

    //
    //  We just merrily go and fill up the dirent with the fields given.
    //

    FatStringTo8dot3( IrpContext, *FileName, (PFAT8DOT3)&Dirent->FileName[0] );

    if (ZeroAndSetTimeFields || SetCreationTime) {

        LARGE_INTEGER Time, SaveTime;

        KeQuerySystemTime( &Time );

        if (FatData.ChicagoMode) {

            if (!SetCreationTime || !FatNtTimeToFatTime( IrpContext,
                                                         SetCreationTime,
                                                         FALSE,
                                                         &Dirent->CreationTime,
                                                         &Dirent->CreationMSec )) {
        
                //
                //  No tunneled time or the tunneled time was bogus. Since we aren't
                //  responsible for initializing the to-be-created Fcb with creation
                //  time, we can't do the usual thing and let NtTimeToFatTime perform
                //  rounding on the timestamp - this would mess up converting to the
                //  LastWriteTime below.
                //

                SaveTime = Time;

                if (!FatNtTimeToFatTime( IrpContext,
                                         &SaveTime,
                                         FALSE,
                                         &Dirent->CreationTime,
                                         &Dirent->CreationMSec )) {

                    //
                    //  Failed again. Wow.
                    //

                    RtlZeroMemory( &Dirent->CreationTime, sizeof(FAT_TIME_STAMP));
                    Dirent->CreationMSec = 0;
                }
            }
        }

        if (ZeroAndSetTimeFields) {

            //
            //  We only touch the other timestamps if we are initializing the dirent
            //

            if (!FatNtTimeToFatTime( IrpContext,
                                     &Time,
                                     TRUE,
                                     &Dirent->LastWriteTime,
                                     NULL )) {

                DebugTrace( 0, Dbg, "Current time invalid.\n", 0);

                RtlZeroMemory( &Dirent->LastWriteTime, sizeof(FAT_TIME_STAMP) );
            }

            if (FatData.ChicagoMode) {

                Dirent->LastAccessDate = Dirent->LastWriteTime.Date;
            }
        }
    }

    //
    //  Copy the attributes
    //

    Dirent->Attributes = Attributes;

    //
    //  Set the magic bit here, to tell dirctrl.c that this name is really
    //  lowercase.
    //

    Dirent->NtByte = 0;

    if (ComponentReallyLowercase) {

        SetFlag( Dirent->NtByte, FAT_DIRENT_NT_BYTE_8_LOWER_CASE );
    }

    if (ExtensionReallyLowercase) {

        SetFlag( Dirent->NtByte, FAT_DIRENT_NT_BYTE_3_LOWER_CASE );
    }

    //
    //  See if we have to create an Lfn entry
    //

    if (ARGUMENT_PRESENT(Lfn)) {

        UCHAR DirentChecksum;
        UCHAR DirentsInLfn;
        UCHAR LfnOrdinal;
        PWCHAR LfnBuffer;
        PLFN_DIRENT LfnDirent;

        ASSERT( FatData.ChicagoMode );

        DirentChecksum = FatComputeLfnChecksum( Dirent );

        LfnOrdinal =
        DirentsInLfn = FAT_LFN_DIRENTS_NEEDED(Lfn);

        LfnBuffer = &Lfn->Buffer[(DirentsInLfn - 1) * 13];

        ASSERT( DirentsInLfn <= MAX_LFN_DIRENTS );

        for (LfnDirent = (PLFN_DIRENT)Dirent - DirentsInLfn;
             LfnDirent < (PLFN_DIRENT)Dirent;
             LfnDirent += 1, LfnOrdinal -= 1, LfnBuffer -= 13) {

            WCHAR FinalLfnBuffer[13];
            PWCHAR Buffer;

            //
            //  We need to special case the "final" dirent.
            //

            if (LfnOrdinal == DirentsInLfn) {

                ULONG i;
                ULONG RemainderChars;

                RemainderChars = (Lfn->Length / sizeof(WCHAR)) % 13;

                LfnDirent->Ordinal = LfnOrdinal | FAT_LAST_LONG_ENTRY;

                if (RemainderChars != 0) {

                    RtlCopyMemory( &FinalLfnBuffer,
                                   LfnBuffer,
                                   RemainderChars * sizeof(WCHAR) );

                    for (i = RemainderChars; i < 13; i++) {

                        //
                        //  Figure out which character to use.
                        //

                        if (i == RemainderChars) {

                            FinalLfnBuffer[i] = 0x0000;

                        } else {

                            FinalLfnBuffer[i] = 0xffff;
                        }
                    }

                    Buffer = FinalLfnBuffer;

                } else {

                    Buffer = LfnBuffer;
                }

            } else {

                LfnDirent->Ordinal = LfnOrdinal;

                Buffer = LfnBuffer;
            }

            //
            //  Now fill in the name.
            //

            RtlCopyMemory( &LfnDirent->Name1[0],
                           &Buffer[0],
                           5 * sizeof(WCHAR) );

            RtlCopyMemory( &LfnDirent->Name2[0],
                           &Buffer[5],
                           6 * sizeof(WCHAR) );

            RtlCopyMemory( &LfnDirent->Name3[0],
                           &Buffer[11],
                           2 * sizeof(WCHAR) );

            //
            //  And the other fields
            //

            LfnDirent->Attributes = FAT_DIRENT_ATTR_LFN;

            LfnDirent->Type = 0;

            LfnDirent->Checksum = DirentChecksum;

            LfnDirent->MustBeZero = 0;
        }
    }

    DebugTrace(-1, Dbg, "FatConstructDirent -> (VOID)\n", 0);
    return;
}


VOID
FatConstructLabelDirent (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDIRENT Dirent,
    IN POEM_STRING Label
    )

/*++

Routine Description:

    This routine modifies the fields of a dirent to be used for a label.

Arguments:

    Dirent - Supplies the dirent being modified.

    Label - Supplies the name to store in the Dirent.  This
            name must not contain wildcards.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatConstructLabelDirent\n", 0);

    DebugTrace( 0, Dbg, "  Dirent             = %08lx\n", Dirent);
    DebugTrace( 0, Dbg, "  Label              = %Z\n", Label);

    RtlZeroMemory( Dirent, sizeof(DIRENT) );

    //
    //  We just merrily go and fill up the dirent with the fields given.
    //

    RtlCopyMemory( Dirent->FileName, Label->Buffer, Label->Length );

    //
    // Pad the label with spaces, not nulls.
    //

    RtlFillMemory( &Dirent->FileName[Label->Length], 11 - Label->Length, ' ');

    Dirent->LastWriteTime = FatGetCurrentFatTime( IrpContext );

    Dirent->Attributes = FAT_DIRENT_ATTR_VOLUME_ID;
    Dirent->ExtendedAttributes = 0;
    Dirent->FileSize = 0;

    DebugTrace(-1, Dbg, "FatConstructLabelDirent -> (VOID)\n", 0);
    return;
}


VOID
FatSetFileSizeInDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PULONG AlternativeFileSize OPTIONAL
    )

/*++

Routine Description:

    This routine saves the file size in an fcb into its dirent.

Arguments:

    Fcb - Supplies the Fcb being referenced

    AlternativeFileSize - If non-null we use the ULONG it points to as
        the new file size.  Otherwise we use the one in the Fcb.

Return Value:

    None.

--*/

{
    PDIRENT Dirent;
    PBCB DirentBcb;

    PAGED_CODE();

    ASSERT( Fcb->FcbCondition == FcbGood );

    FatGetDirentFromFcbOrDcb( IrpContext,
                              Fcb,
                              &Dirent,
                              &DirentBcb );

    ASSERT( Dirent && DirentBcb );

    try {

        Dirent->FileSize = ARGUMENT_PRESENT( AlternativeFileSize ) ?
                           *AlternativeFileSize : Fcb->Header.FileSize.LowPart;

        FatSetDirtyBcb( IrpContext, DirentBcb, Fcb->Vcb, TRUE );

    } finally {

        FatUnpinBcb( IrpContext, DirentBcb );
    }
}


VOID
FatUpdateDirentFromFcb (
   IN PIRP_CONTEXT IrpContext,
   IN PFILE_OBJECT FileObject,
   IN PFCB FcbOrDcb,
   IN PCCB Ccb
   )

/*++

Routine Description:

    This routine modifies an objects directory entry based on the hints
    that have been built up over previous operations on a handle.  Notify
    change filters are built and fired as a result of these updates.

Arguments:

    FileObject - Fileobject representing the handle involved
    
    FcbOrDcb - File/Dir involved
    
    Ccb - User context involved

Return Value:

    None.

--*/

{
    BOOLEAN SetArchiveBit;

    BOOLEAN UpdateFileSize;
    BOOLEAN UpdateLastWriteTime;
    BOOLEAN UpdateLastAccessTime;

    PDIRENT Dirent;
    PBCB DirentBcb = NULL;
    ULONG NotifyFilter = 0;
    FAT_TIME_STAMP CurrentFatTime;

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER CurrentDay;
    LARGE_INTEGER LastAccessDay;

    PAGED_CODE();

    //
    //  Nothing to do if the fcb is bad, volume is readonly or we got the
    //  root dir.
    //
    
    if (FcbOrDcb->FcbCondition != FcbGood ||
        NodeType(FcbOrDcb) == FAT_NTC_ROOT_DCB ||
        FlagOn(FcbOrDcb->Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

        return;
    }

    //
    //  Check if we should be changing the time or file size and set
    //  the archive bit on the file.
    //

    KeQuerySystemTime( &CurrentTime );

    //
    //  Note that we HAVE to use BooleanFlagOn() here because
    //  FO_FILE_SIZE_CHANGED > 0x80 (i.e., not in the first byte).
    //

    SetArchiveBit = BooleanFlagOn(FileObject->Flags, FO_FILE_MODIFIED);

    UpdateLastWriteTime = FlagOn(FileObject->Flags, FO_FILE_MODIFIED) &&
                          !FlagOn(Ccb->Flags, CCB_FLAG_USER_SET_LAST_WRITE);

    UpdateFileSize = NodeType(FcbOrDcb) == FAT_NTC_FCB &&
                     BooleanFlagOn(FileObject->Flags, FO_FILE_SIZE_CHANGED);

    //
    //  Do one further check here of access time.  Only update it if
    //  the current version is at least one day old.  We know that
    //  the current FcbOrDcb->LastAccessTime corresponds to 12 midnight local
    //  time, so just see if the current time is on the same day.
    //

    if (FatData.ChicagoMode &&
        (UpdateLastWriteTime ||
         FlagOn(FileObject->Flags, FO_FILE_FAST_IO_READ)) &&
        !FlagOn(Ccb->Flags, CCB_FLAG_USER_SET_LAST_ACCESS)) {

        ExSystemTimeToLocalTime( &FcbOrDcb->LastAccessTime, &LastAccessDay );
        ExSystemTimeToLocalTime( &CurrentTime, &CurrentDay );

        LastAccessDay.QuadPart /= FatOneDay.QuadPart;
        CurrentDay.QuadPart /= FatOneDay.QuadPart;

        if (LastAccessDay.LowPart != CurrentDay.LowPart) {

            UpdateLastAccessTime = TRUE;

        } else {

            UpdateLastAccessTime = FALSE;
        }

    } else {

        UpdateLastAccessTime = FALSE;
    }

    if (SetArchiveBit ||
        UpdateFileSize ||
        UpdateLastWriteTime ||
        UpdateLastAccessTime) {

        DebugTrace(0, Dbg, "Update Time and/or file size on File/Dir\n", 0);

        try {

            try {

                //
                //  Get the dirent
                //

                FatGetDirentFromFcbOrDcb( IrpContext,
                                          FcbOrDcb,
                                          &Dirent,
                                          &DirentBcb );

                ASSERT( Dirent && DirentBcb );

                if (UpdateLastWriteTime || UpdateLastAccessTime) {

                    (VOID)FatNtTimeToFatTime( IrpContext,
                                              &CurrentTime,
                                              TRUE,
                                              &CurrentFatTime,
                                              NULL );
                }

                if (SetArchiveBit) {

                    Dirent->Attributes |= FILE_ATTRIBUTE_ARCHIVE;
                    FcbOrDcb->DirentFatFlags |= FILE_ATTRIBUTE_ARCHIVE;
                    
                    NotifyFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES;
                }

                if (UpdateLastWriteTime) {

                    //
                    //  Update its time of last write
                    //

                    FcbOrDcb->LastWriteTime = CurrentTime;
                    Dirent->LastWriteTime = CurrentFatTime;

                    //
                    //  We call the notify package to report that the
                    //  last modification time has changed.
                    //

                    NotifyFilter |= FILE_NOTIFY_CHANGE_LAST_WRITE;
                }

                if (UpdateLastAccessTime) {

                    //
                    //  Now we have to truncate the local time down
                    //  to the current day, then convert back to UTC.
                    //

                    FcbOrDcb->LastAccessTime.QuadPart =
                        CurrentDay.QuadPart * FatOneDay.QuadPart;

                    ExLocalTimeToSystemTime( &FcbOrDcb->LastAccessTime,
                                             &FcbOrDcb->LastAccessTime );

                    Dirent->LastAccessDate = CurrentFatTime.Date;

                    //
                    //  We call the notify package to report that the
                    //  last access time has changed.
                    //

                    NotifyFilter |= FILE_NOTIFY_CHANGE_LAST_ACCESS;
                }

                if (UpdateFileSize) {

                    //
                    //  Perhaps we were called to make certain that the
                    //  filesize on disc was updated - don't bother updating
                    //  and firing the filter if nothing changed.
                    //

                    ASSERT( NodeType(FcbOrDcb) == FAT_NTC_FCB );
                    
                    if (Dirent->FileSize != FcbOrDcb->Header.FileSize.LowPart) {
                    
                        //
                        //  Update the dirent file size
                        //
                        
                        Dirent->FileSize = FcbOrDcb->Header.FileSize.LowPart;

                        //
                        //  We call the notify package to report that the
                        //  size has changed.
                        //

                        NotifyFilter |= FILE_NOTIFY_CHANGE_SIZE;
                    }
                }

                FatNotifyReportChange( IrpContext,
                                       FcbOrDcb->Vcb,
                                       FcbOrDcb,
                                       NotifyFilter,
                                       FILE_ACTION_MODIFIED );

                //
                //  If all we did was update last access time,
                //  don't mark the volume dirty.
                //

                FatSetDirtyBcb( IrpContext,
                                DirentBcb,
                                NotifyFilter == FILE_NOTIFY_CHANGE_LAST_ACCESS ?
                                NULL : FcbOrDcb->Vcb,
                                TRUE );

            } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

                  FatResetExceptionState( IrpContext );
            }

        } finally {

            FatUnpinBcb( IrpContext, DirentBcb );
        }
    }
}


//
//  Internal support routine
//

UCHAR
FatComputeLfnChecksum (
    PDIRENT Dirent
    )

/*++

Routine Description:

    This routine computes the Chicago long file name checksum.

Arguments:

    Dirent - Specifies the dirent that we are to compute a checksum for.

Return Value:

    The checksum.

--*/

{
    ULONG i;
    UCHAR Checksum;

    PAGED_CODE();

    Checksum = Dirent->FileName[0];

    for (i=1; i < 11; i++) {

        Checksum = ((Checksum & 1) ? 0x80 : 0) +
                    (Checksum >> 1) +
                    Dirent->FileName[i];
    }

    return Checksum;
}



#if 0 // It turns out Win95 is still creating short names without a ~

//
//  Internal support routine
//

BOOLEAN
FatIsLfnPairValid (
    PWCHAR Lfn,
    ULONG LfnSize,
    PDIRENT Dirent
    )

/*++

Routine Description:

    This routine does a few more checks to make sure that a LFN/short
    name pairing is legitimate.  Basically this is the test:

        Pairing is valid if:

        DIRENT has a ~ character ||
        (LFN is 8.3 compliant &&
         (LFN has extended character(s) ? TRUE :
          LFN upcases to DIRENT))

    When checking for the presence of a tilda character in the short
    name, note that we purposely do a single byte search instead of
    converting the name to UNICODE and looking there for the tilda.
    This protects us from accidently missing the tilda if the
    preceding byte is a lead byte in the current Oem code page,
    but wasn't in the Oem code page that created the file.

    Also note that if the LFN is longer than 12 characters, then the
    second clause of the OR must be false.

Arguments:

    Lfn - Points to a buffer of UNICODE chars.

    LfnSize - This is the size of the LFN in characters.

    Dirent - Specifies the dirent we are to consider.

Return Value:

    TRUE if the Lfn/DIRENT form a legitimate pair, FALSE otherwise.

--*/

{
    ULONG i;
    BOOLEAN ExtendedChars;
    ULONG DirentBuffer[3];
    PUCHAR DirentName;
    ULONG DirentIndex;
    BOOLEAN DotEncountered;

    //
    //  First, look for a tilda
    //

    for (i=0; i<11; i++) {
        if (Dirent->FileName[i] == '~') {
            return TRUE;
        }
    }

    //
    //  No tilda.  If the LFN is longer than 12 characters, then it can
    //  neither upcase to the DIRENT nor be 8.3 complient.
    //

    if (LfnSize > 12) {
        return FALSE;
    }

    //
    //  Now see if the name is 8.3, and build an upcased DIRENT as well.
    //

    DirentBuffer[0] = 0x20202020;
    DirentBuffer[1] = 0x20202020;
    DirentBuffer[2] = 0x20202020;

    DirentName = (PUCHAR)DirentBuffer;

    ExtendedChars = FALSE;
    DirentIndex = 0;
    DotEncountered = FALSE;

    for (i=0; i < LfnSize; i++) {

        //
        //  Do dot transition work
        //

        if (Lfn[i] == L'.') {
            if (DotEncountered ||
                (i > 8) ||
                ((LfnSize - i) > 4) ||
                (i && Lfn[i-1] == L' ')) {
                return FALSE;
            }
            DotEncountered = TRUE;
            DirentIndex = 8;
            continue;
        }

        //
        //  The character must be legal in order to be 8.3
        //

        if ((Lfn[i] < 0x80) &&
            !FsRtlIsAnsiCharacterLegalFat((UCHAR)Lfn[i], FALSE)) {
            return FALSE;
        }

        //
        //  If the name contains no extended chars, continue building DIRENT
        //

        if (!ExtendedChars) {
            if (Lfn[i] > 0x7f) {
                ExtendedChars = TRUE;
            } else {
                DirentName[DirentIndex++] = (UCHAR) (
                Lfn[i] < 'a' ? Lfn[i] : Lfn[i] <= 'z' ? Lfn[i] - ('a' - 'A') : Lfn[i]);
            }
        }
    }

    //
    //  If the LFN ended in a space, or there was no dot and the name
    //  has more than 8 characters, then it is not 8.3 compliant.
    //

    if ((Lfn[LfnSize - 1] == L' ') ||
        (!DotEncountered && (LfnSize > 8))) {
        return FALSE;
    }

    //
    //  OK, now if we got this far then the LFN is 8dot3.  If there are
    //  no extended characters, then we can also check to make sure that
    //  the LFN is only a case varient of the DIRENT.
    //

    if (!ExtendedChars &&
        !RtlEqualMemory(Dirent->FileName, DirentName, 11)) {

        return FALSE;
    }

    //
    //  We have now verified this pairing the very best we can without
    //  knowledge of the code page that the file was created under.
    //

    return TRUE;
}
#endif //0

//
//  Internal support routine
//

VOID
FatRescanDirectory (
    PIRP_CONTEXT IrpContext,
    PDCB Dcb
    )

/*++

Routine Description:

    This routine rescans the given directory, finding the first unused
    dirent, first deleted dirent, and setting the free dirent bitmap
    appropriately.

Arguments:

    Dcb - Supplies the directory to rescan.

Return Value:

    None.

--*/

{
    PBCB Bcb = NULL;
    PDIRENT Dirent;
    NTSTATUS Status;

    ULONG UnusedVbo;
    ULONG DeletedHint;
    ULONG DirentIndex;
    ULONG DirentsThisRun;
    ULONG StartIndexOfThisRun;

    enum RunType {
        InitialRun,
        FreeDirents,
        AllocatedDirents,
    } CurrentRun;

    PAGED_CODE();

    DebugTrace( 0, Dbg, "We must scan the whole directory.\n", 0);

    UnusedVbo = 0;
    DeletedHint = 0xffffffff;

    //
    //  To start with, we have to find out if the first dirent is free.
    //

    CurrentRun = InitialRun;
    DirentIndex =
    StartIndexOfThisRun = 0;

    try {

        while ( TRUE ) {

            BOOLEAN DirentDeleted;

            //
            //  Read a dirent
            //

            FatReadDirent( IrpContext,
                           Dcb,
                           UnusedVbo,
                           &Bcb,
                           &Dirent,
                           &Status );

            //
            //  If EOF, or we found a NEVER_USED entry, we exit the loop
            //

            if ( (Status == STATUS_END_OF_FILE ) ||
                 (Dirent->FileName[0] == FAT_DIRENT_NEVER_USED)) {

                break;
            }

            //
            //  If the dirent is DELETED, and it is the first one we found, set
            //  it in the deleted hint.
            //

            if (Dirent->FileName[0] == FAT_DIRENT_DELETED) {

                DirentDeleted = TRUE;

                if (DeletedHint == 0xffffffff) {

                    DeletedHint = UnusedVbo;
                }

            } else {

                DirentDeleted = FALSE;
            }

            //
            //  Check for the first time through the loop, and determine
            //  the current run type.
            //

            if (CurrentRun == InitialRun) {

                CurrentRun = DirentDeleted ?
                             FreeDirents : AllocatedDirents;

            } else {

                //
                //  Are we switching from a free run to an allocated run?
                //

                if ((CurrentRun == FreeDirents) && !DirentDeleted) {

                    DirentsThisRun = DirentIndex - StartIndexOfThisRun;

                    RtlClearBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                                  StartIndexOfThisRun,
                                  DirentsThisRun );

                    CurrentRun = AllocatedDirents;
                    StartIndexOfThisRun = DirentIndex;
                }

                //
                //  Are we switching from an allocated run to a free run?
                //

                if ((CurrentRun == AllocatedDirents) && DirentDeleted) {

                    DirentsThisRun = DirentIndex - StartIndexOfThisRun;

                    RtlSetBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                                StartIndexOfThisRun,
                                DirentsThisRun );

                    CurrentRun = FreeDirents;
                    StartIndexOfThisRun = DirentIndex;
                }
            }

            //
            //  Move on to the next dirent.
            //

            UnusedVbo += sizeof(DIRENT);
            Dirent += 1;
            DirentIndex += 1;
        }

        //
        //  Now we have to record the final run we encoutered
        //

        DirentsThisRun = DirentIndex - StartIndexOfThisRun;

        if ((CurrentRun == FreeDirents) || (CurrentRun == InitialRun)) {

            RtlClearBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                          StartIndexOfThisRun,
                          DirentsThisRun );

        } else {

            RtlSetBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                        StartIndexOfThisRun,
                        DirentsThisRun );
        }

        //
        //  Now if there we bailed prematurely out of the loop because
        //  we hit an unused entry, set all the rest as free.
        //

        if (UnusedVbo < Dcb->Header.AllocationSize.LowPart) {

            StartIndexOfThisRun = UnusedVbo / sizeof(DIRENT);

            DirentsThisRun = (Dcb->Header.AllocationSize.LowPart -
                              UnusedVbo) / sizeof(DIRENT);

            RtlClearBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                          StartIndexOfThisRun,
                          DirentsThisRun);
        }

    } finally {

        FatUnpinBcb( IrpContext, Bcb );
    }

    //
    //  If there weren't any DELETED entries, set the index to our current
    //  position.
    //

    if (DeletedHint == 0xffffffff) { DeletedHint = UnusedVbo; }

    Dcb->Specific.Dcb.UnusedDirentVbo = UnusedVbo;
    Dcb->Specific.Dcb.DeletedDirentHint = DeletedHint;

    return;
}


//
//  Internal support routine
//

ULONG
FatDefragDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN ULONG DirentsNeeded
    )

/*++

Routine Description:

    This routine determines if the requested number of dirents can be found
    in the directory, looking for deleted dirents and orphaned LFNs.  If the
    request can be satisifed, orphaned LFNs are marked as deleted, and deleted
    dirents are all grouped together at the end of the directory.

    Note that this routine is currently used only on the root directory, but
    it is completely general and could be used on any directory.

Arguments:

    Dcb - Supplies the directory to defrag.

Return Value:

    The Index of the first dirent available for use, or -1 if the
    request cannot be satisfied.

--*/

{
    ULONG SavedIrpContextFlag;
    PLIST_ENTRY Links;
    ULONG ReturnValue;
    PFCB Fcb;

    PBCB Bcb = NULL;
    PDIRENT Dirent = NULL;
    UNICODE_STRING Lfn = {0,0,NULL};

    LARGE_MCB Mcb;
    BOOLEAN McbInitialized = FALSE;
    BOOLEAN InvalidateFcbs = FALSE;

    PUCHAR Directory;
    PUCHAR UnusedDirents;
    PUCHAR UnusedDirentBuffer = NULL;
    PUCHAR UsedDirents;
    PUCHAR UsedDirentBuffer = NULL;

    PBCB *Bcbs = NULL;
    ULONG Page;
    ULONG PagesPinned;

    ULONG DcbSize;
    ULONG TotalBytesAllocated = 0;

    PAGED_CODE();

    //
    //  We assume we own the Vcb.
    //

    ASSERT( FatVcbAcquiredExclusive(IrpContext, Dcb->Vcb) );

    //
    //  We will only attempt this on directories less than 0x40000 bytes
    //  long (by default on DOS the root directory is only 0x2000 long).
    //  This is to avoid a cache manager complication.
    //

    DcbSize = Dcb->Header.AllocationSize.LowPart;

    if (DcbSize > 0x40000) {

        return (ULONG)-1;
    }

    //
    //  Force wait to TRUE
    //

    SavedIrpContextFlag = IrpContext->Flags;

    SetFlag( IrpContext->Flags,
             IRP_CONTEXT_FLAG_WAIT | IRP_CONTEXT_FLAG_WRITE_THROUGH );

    //
    //  Now acquire all open Fcbs in the Dcb exclusive.
    //

    for (Links = Dcb->Specific.Dcb.ParentDcbQueue.Flink;
         Links != &Dcb->Specific.Dcb.ParentDcbQueue;
         Links = Links->Flink) {

        Fcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

        (VOID)ExAcquireResourceExclusiveLite( Fcb->Header.Resource, TRUE );
    }

    try {

        CCB Ccb;
        ULONG QueryOffset = 0;
        ULONG FoundOffset = 0;
        ULONGLONG BytesUsed = 0;

        NTSTATUS DontCare;
        ULONG Run;
        ULONG TotalRuns;
        BOOLEAN Result;
        PUCHAR Char;

        //
        //  We are going to build a new bitmap that will show all orphaned
        //  LFNs as well as deleted dirents as available.
        //
        //  Initialize our local CCB that will match all files and even
        //  a label if it is here.
        //

        RtlZeroMemory( &Ccb, sizeof(CCB) );
        Ccb.Flags = CCB_FLAG_MATCH_ALL | CCB_FLAG_MATCH_VOLUME_ID;

        //
        //  Init the Long File Name string.
        //

        Lfn.MaximumLength = 260 * sizeof(WCHAR);
        Lfn.Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                               260*sizeof(WCHAR),
                                               TAG_FILENAME_BUFFER );

        //
        //  Initalize the Mcb.  We use this structure to keep track of runs
        //  of free and allocated dirents.  Runs are identity allocations, and
        //  holes are free dirents.
        //

        FsRtlInitializeLargeMcb( &Mcb, PagedPool );

        McbInitialized = TRUE;

        do {
            
            FatLocateDirent( IrpContext,
                             Dcb,
                             &Ccb,
                             QueryOffset,
                             &Dirent,
                             &Bcb,
                             &FoundOffset,
                             NULL,
                             &Lfn);

            if (Dirent != NULL) {

                ULONG LfnByteOffset;

                //
                //  Compute the LfnByteOffset.
                //

                LfnByteOffset = FoundOffset -
                                FAT_LFN_DIRENTS_NEEDED(&Lfn) * sizeof(LFN_DIRENT);

                BytesUsed = FoundOffset - LfnByteOffset + sizeof(DIRENT);

                //
                //  Set a run to represent all the dirents used for this
                //  file in the Dcb dir.
                //

                Result = FsRtlAddLargeMcbEntry( &Mcb,
                                                LfnByteOffset,
                                                LfnByteOffset,
                                                BytesUsed );

                ASSERT( Result );

                //
                //  Move on to the next dirent.
                //

                TotalBytesAllocated += (ULONG) BytesUsed;
                QueryOffset = FoundOffset + sizeof(DIRENT);
            }

        } while ((Dirent != NULL) && (QueryOffset < DcbSize));

        if (Bcb != NULL) {

            FatUnpinBcb( IrpContext, Bcb );
        }

        //
        //  If we need more dirents than are available, bail.
        //

        if (DirentsNeeded > (DcbSize - TotalBytesAllocated)/sizeof(DIRENT)) {

            try_return(ReturnValue = (ULONG)-1);
        }

        //
        //  Now we are going to copy all the used and un-used parts of the
        //  directory to separate pool.
        //
        //  Allocate these buffers and pin the entire directory.
        //

        UnusedDirents =
        UnusedDirentBuffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                       DcbSize - TotalBytesAllocated,
                                                       TAG_DIRENT );

        UsedDirents =
        UsedDirentBuffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                     TotalBytesAllocated,
                                                     TAG_DIRENT );

        PagesPinned = (DcbSize + (PAGE_SIZE - 1 )) / PAGE_SIZE;

        Bcbs = FsRtlAllocatePoolWithTag( PagedPool,
                                         PagesPinned * sizeof(PBCB),
                                         TAG_BCB );

        RtlZeroMemory( Bcbs, PagesPinned * sizeof(PBCB) );

        for (Page = 0; Page < PagesPinned; Page += 1) {

            ULONG PinSize;

            //
            //  Don't try to pin beyond the Dcb size.
            //

            if ((Page + 1) * PAGE_SIZE > DcbSize) {

                PinSize = DcbSize - (Page * PAGE_SIZE);

            } else {

                PinSize = PAGE_SIZE;
            }

            FatPrepareWriteDirectoryFile( IrpContext,
                                          Dcb,
                                          Page * PAGE_SIZE,
                                          PinSize,
                                          &Bcbs[Page],
                                          &Dirent,
                                          FALSE,
                                          TRUE,
                                          &DontCare );

            if (Page == 0) {
                Directory = (PUCHAR)Dirent;
            }
        }

        TotalRuns = FsRtlNumberOfRunsInLargeMcb( &Mcb );

        for (Run = 0; Run < TotalRuns; Run++) {

            LBO Vbo;
            LBO Lbo;

            Result = FsRtlGetNextLargeMcbEntry( &Mcb,
                                                Run,
                                                &Vbo,
                                                &Lbo,
                                                &BytesUsed );

            ASSERT(Result);

            //
            //  Copy each run to their specific pool.
            //

            if (Lbo != -1) {

                RtlCopyMemory( UsedDirents,
                               Directory + Vbo,
                               (ULONG) BytesUsed );

                UsedDirents += BytesUsed;

            } else {

                RtlCopyMemory( UnusedDirents,
                               Directory + Vbo,
                               (ULONG) BytesUsed );

                UnusedDirents += BytesUsed;
            }
        }

        //
        //  Marking all the un-used dirents as "deleted".  This will reclaim
        //  storage used by orphaned LFNs.
        //

        for (Char = UnusedDirentBuffer; Char < UnusedDirents; Char += sizeof(DIRENT)) {

            *Char = FAT_DIRENT_DELETED;
        }

        //
        //  Now, for the permanent step.  Copy the two pool buffer back to the
        //  real Dcb directory, and flush the Dcb directory
        //

        ASSERT( TotalBytesAllocated == (ULONG)(UsedDirents - UsedDirentBuffer) );

        RtlCopyMemory( Directory, UsedDirentBuffer, TotalBytesAllocated );

        RtlCopyMemory( Directory + TotalBytesAllocated,
                       UnusedDirentBuffer,
                       UnusedDirents - UnusedDirentBuffer );

        //
        //  We need to unpin here so that the UnpinRepinned won't deadlock.
        //

        if (Bcbs) {
            for (Page = 0; Page < PagesPinned; Page += 1) {
                FatUnpinBcb( IrpContext, Bcbs[Page] );
            }
            ExFreePool(Bcbs);
            Bcbs = NULL;
        }

        //
        //  Now make the free dirent bitmap reflect the new state of the Dcb
        //  directory.
        //

        RtlSetBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                    0,
                    TotalBytesAllocated / sizeof(DIRENT) );

        RtlClearBits( &Dcb->Specific.Dcb.FreeDirentBitmap,
                      TotalBytesAllocated / sizeof(DIRENT),
                      (DcbSize - TotalBytesAllocated) / sizeof(DIRENT) );

        ReturnValue = TotalBytesAllocated / sizeof(DIRENT);

        //
        //  Flush the directory to disk.  If we raise, we will need to invalidate
        //  all of the children.  Sorry, guys, but I can't figure out where you are
        //  now - if this failed I probably can't read the media either.  And we
        //  probably purged the cache to boot.
        //

        try {
            
            FatUnpinRepinnedBcbs( IrpContext );

        } except(FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

              InvalidateFcbs = TRUE;
        }

        //
        //  OK, now nothing can go wrong.  We have two more things to do.
        //  First, we have to fix up all the dirent offsets in any open Fcbs.
        //  If we cannot now find the Fcb, the file is marked invalid.  Also,
        //  we skip deleted files.
        //

        for (Links = Dcb->Specific.Dcb.ParentDcbQueue.Flink;
             Links != &Dcb->Specific.Dcb.ParentDcbQueue;
             Links = Links->Flink) {

            PBCB TmpBcb = NULL;
            ULONG TmpOffset;
            PDIRENT TmpDirent = NULL;
            ULONG PreviousLfnSpread;

            Fcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

            if (IsFileDeleted( IrpContext, Fcb )) {

                continue;
            }

            //
            //  If we aren't already giving up, safely try to pick up the dirent
            //  to update the Fcb.  If this raises, we have to give up and blow
            //  evenyone else away too.
            //
            
            if (!InvalidateFcbs) {
                
                try {
                    
                    FatLocateSimpleOemDirent( IrpContext,
                                              Dcb,
                                              &Fcb->ShortName.Name.Oem,
                                              &TmpDirent,
                                              &TmpBcb,
                                              &TmpOffset );
                
                } except(FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                         EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

                      InvalidateFcbs = TRUE;
                }
            }

            if (TmpBcb == NULL || InvalidateFcbs) {

                FatUnpinBcb( IrpContext, TmpBcb );
                FatMarkFcbCondition( IrpContext, Fcb, FcbBad, TRUE );

            } else {

                FatUnpinBcb( IrpContext, TmpBcb );

                PreviousLfnSpread = Fcb->DirentOffsetWithinDirectory -
                                    Fcb->LfnOffsetWithinDirectory;

                Fcb->DirentOffsetWithinDirectory = TmpOffset;
                Fcb->LfnOffsetWithinDirectory = TmpOffset - PreviousLfnSpread;
            }
        }

    try_exit: NOTHING;
    } finally {

        //
        //  Free all our resources and stuff.
        //

        if (McbInitialized) {
            FsRtlUninitializeLargeMcb( &Mcb );
        }

        if (Lfn.Buffer) {
            ExFreePool( Lfn.Buffer );
        }

        if (UnusedDirentBuffer) {
            ExFreePool( UnusedDirentBuffer );
        }

        if (UsedDirentBuffer) {
            ExFreePool( UsedDirentBuffer );
        }

        if (Bcbs) {
            for (Page = 0; Page < PagesPinned; Page += 1) {
                FatUnpinBcb( IrpContext, Bcbs[Page] );
            }
            ExFreePool(Bcbs);
        }

        FatUnpinBcb( IrpContext, Bcb );

        for (Links = Dcb->Specific.Dcb.ParentDcbQueue.Flink;
             Links != &Dcb->Specific.Dcb.ParentDcbQueue;
             Links = Links->Flink) {

            Fcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

            ExReleaseResourceLite( Fcb->Header.Resource );
        }

        IrpContext->Flags = SavedIrpContextFlag;
    }

    //
    //  Now return the offset of the first free dirent to the caller.
    //

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fatdata.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FatData.c

Abstract:

    This module declares the global data used by the Fat file system.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_FATDATA)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)

#ifdef ALLOC_PRAGMA

#if DBG
#pragma alloc_text(PAGE, FatBugCheckExceptionFilter)
#endif

#pragma alloc_text(PAGE, FatCompleteRequest_Real)
#pragma alloc_text(PAGE, FatFastIoCheckIfPossible)
#pragma alloc_text(PAGE, FatFastQueryBasicInfo)
#pragma alloc_text(PAGE, FatFastQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, FatFastQueryStdInfo)
#pragma alloc_text(PAGE, FatIsIrpTopLevel)
#pragma alloc_text(PAGE, FatPopUpFileCorrupt)
#pragma alloc_text(PAGE, FatProcessException)
#endif


//
//  The global fsd data record, and zero large integer
//

FAT_DATA FatData;

PDEVICE_OBJECT FatDiskFileSystemDeviceObject;
PDEVICE_OBJECT FatCdromFileSystemDeviceObject;

LARGE_INTEGER FatLargeZero = {0,0};
LARGE_INTEGER FatMaxLarge = {MAXULONG,MAXLONG};

LARGE_INTEGER Fat30Milliseconds = {(ULONG)(-30 * 1000 * 10), -1};
LARGE_INTEGER Fat100Milliseconds = {(ULONG)(-30 * 1000 * 10), -1};
LARGE_INTEGER FatOneDay = {0x2a69c000, 0xc9};
LARGE_INTEGER FatJanOne1980 = {0xe1d58000,0x01a8e79f};
LARGE_INTEGER FatDecThirtyOne1979 = {0xb76bc000,0x01a8e6d6};

FAT_TIME_STAMP FatTimeJanOne1980 = {{0,0,0},{1,1,0}};

LARGE_INTEGER FatMagic10000    = {0xe219652c, 0xd1b71758};
LARGE_INTEGER FatMagic86400000 = {0xfa67b90e, 0xc6d750eb};

FAST_IO_DISPATCH FatFastIoDispatch;

//
//  Our lookaside lists.
//

NPAGED_LOOKASIDE_LIST FatIrpContextLookasideList;
NPAGED_LOOKASIDE_LIST FatNonPagedFcbLookasideList;
NPAGED_LOOKASIDE_LIST FatEResourceLookasideList;

SLIST_HEADER FatCloseContextSList;

//
//  Synchronization for the close queue
//

FAST_MUTEX FatCloseQueueMutex;

//
//  Reserve MDL for paging file operations.
//

PMDL FatReserveMdl = NULL;
KEVENT FatReserveEvent;

#ifdef FASTFATDBG

LONG FatDebugTraceLevel = 0x00000009;
LONG FatDebugTraceIndent = 0;

ULONG FatFsdEntryCount = 0;
ULONG FatFspEntryCount = 0;
ULONG FatIoCallDriverCount = 0;

LONG FatPerformanceTimerLevel = 0x00000000;

ULONG FatTotalTicks[32] = { 0 };

//
//  I need this because C can't support conditional compilation within
//  a macro.
//

PVOID FatNull = NULL;

#endif // FASTFATDBG

#if DBG

NTSTATUS FatAssertNotStatus = STATUS_SUCCESS;
BOOLEAN FatTestRaisedStatus = FALSE;

#endif


#if DBG
ULONG
FatBugCheckExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    An exception filter which acts as an assert that the exception should
    never occur.
    
    This is only valid on debug builds, we don't want the overhead on retail.

Arguments:

    ExceptionPointers - The result of GetExceptionInformation() in the context
        of the exception.

Return Value:

    Bugchecks.

--*/

{
    FatBugCheck( (ULONG_PTR)ExceptionPointer->ExceptionRecord,
                 (ULONG_PTR)ExceptionPointer->ContextRecord,
                 (ULONG_PTR)ExceptionPointer->ExceptionRecord->ExceptionAddress );

    return EXCEPTION_EXECUTE_HANDLER;
}
#endif


ULONG
FatExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide if we should or should not handle
    an exception status that is being raised.  It inserts the status
    into the IrpContext and either indicates that we should handle
    the exception or bug check the system.

Arguments:

    ExceptionPointers - The result of GetExceptionInformation() in the context
        of the exception.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode;

    ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;
    DebugTrace(0, DEBUG_TRACE_UNWIND, "FatExceptionFilter %X\n", ExceptionCode);
    DebugDump("FatExceptionFilter\n", Dbg, NULL );

    //
    // If the exception is STATUS_IN_PAGE_ERROR, get the I/O error code
    // from the exception record.
    //

    if (ExceptionCode == STATUS_IN_PAGE_ERROR) {
        if (ExceptionPointer->ExceptionRecord->NumberParameters >= 3) {
            ExceptionCode = (NTSTATUS)ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
        }
    }

    //
    //  If there is not an irp context, we must have had insufficient resources.
    //

    if ( !ARGUMENT_PRESENT( IrpContext ) ) {

        if (!FsRtlIsNtstatusExpected( ExceptionCode )) {

            FatBugCheck( (ULONG_PTR)ExceptionPointer->ExceptionRecord,
                         (ULONG_PTR)ExceptionPointer->ContextRecord,
                         (ULONG_PTR)ExceptionPointer->ExceptionRecord->ExceptionAddress );
        }

        return EXCEPTION_EXECUTE_HANDLER;
    }

    //
    //  For the purposes of processing this exception, let's mark this
    //  request as being able to wait and disable  write through if we
    //  aren't posting it.
    //

    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);

    if ( (ExceptionCode != STATUS_CANT_WAIT) &&
         (ExceptionCode != STATUS_VERIFY_REQUIRED) ) {

        SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_WRITE_THROUGH);
    }

    if ( IrpContext->ExceptionStatus == 0 ) {

        if (FsRtlIsNtstatusExpected( ExceptionCode )) {

            IrpContext->ExceptionStatus = ExceptionCode;

            return EXCEPTION_EXECUTE_HANDLER;

        } else {

            FatBugCheck( (ULONG_PTR)ExceptionPointer->ExceptionRecord,
                         (ULONG_PTR)ExceptionPointer->ContextRecord,
                         (ULONG_PTR)ExceptionPointer->ExceptionRecord->ExceptionAddress );
        }

    } else {

        //
        //  We raised this code explicitly ourselves, so it had better be
        //  expected.
        //

        ASSERT( IrpContext->ExceptionStatus == ExceptionCode );
        ASSERT( FsRtlIsNtstatusExpected( ExceptionCode ) );
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

NTSTATUS
FatProcessException (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine process an exception.  It either completes the request
    with the saved exception status or it sends it off to IoRaiseHardError()

Arguments:

    Irp - Supplies the Irp being processed

    ExceptionCode - Supplies the normalized exception status being handled

Return Value:

    NTSTATUS - Returns the results of either posting the Irp or the
        saved completion status.

--*/

{
    PVCB Vcb;
    PIO_STACK_LOCATION IrpSp;
    FAT_VOLUME_STATE TransitionState = VolumeDirty;
    ULONG SavedFlags;

    DebugTrace(0, Dbg, "FatProcessException\n", 0);

    //
    //  If there is not an irp context, we must have had insufficient resources.
    //

    if ( !ARGUMENT_PRESENT( IrpContext ) ) {

        FatCompleteRequest( FatNull, Irp, ExceptionCode );

        return ExceptionCode;
    }

    //
    //  Get the real exception status from IrpContext->ExceptionStatus, and
    //  reset it.
    //

    ExceptionCode = IrpContext->ExceptionStatus;
    FatResetExceptionState( IrpContext );

    //
    //  If we are going to post the request, we may have to lock down the
    //  user's buffer, so do it here in a try except so that we failed the
    //  request if the LockPages fails.
    //
    //  Also unpin any repinned Bcbs, protected by the try {} except {} filter.
    //

    try {

        SavedFlags = IrpContext->Flags;

        //
        //  Make sure we don't try to write through Bcbs
        //

        SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_WRITE_THROUGH);

        FatUnpinRepinnedBcbs( IrpContext );

        IrpContext->Flags = SavedFlags;

        //
        //  If we will have to post the request, do it here.  Note
        //  that the last thing FatPrePostIrp() does is mark the Irp pending,
        //  so it is critical that we actually return PENDING.  Nothing
        //  from this point to return can fail, so we are OK.
        //
        //  We cannot do a verify operations at APC level because we
        //  have to wait for Io operations to complete.
        //

        if (!FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_RECURSIVE_CALL) &&
            (((ExceptionCode == STATUS_VERIFY_REQUIRED) && (KeGetCurrentIrql() >= APC_LEVEL)) ||
             (ExceptionCode == STATUS_CANT_WAIT))) {

            ExceptionCode = FatFsdPostRequest( IrpContext, Irp );
        }

    } except( FatExceptionFilter( IrpContext, GetExceptionInformation() ) ) {

        ExceptionCode = IrpContext->ExceptionStatus;
        IrpContext->ExceptionStatus = 0;

        IrpContext->Flags = SavedFlags;
    }

    //
    //  If we posted the request, just return here.
    //

    if (ExceptionCode == STATUS_PENDING) {

        return ExceptionCode;
    }

    Irp->IoStatus.Status = ExceptionCode;

    //
    //  If this request is not a "top-level" irp, just complete it.
    //

    if (FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_RECURSIVE_CALL)) {

        //
        //  If there is a cache operation above us, commute verify
        //  to a lock conflict.  This will cause retries so that
        //  we have a chance of getting through without needing
        //  to return an unaesthetic error for the operation.
        //

        if (IoGetTopLevelIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP &&
            ExceptionCode == STATUS_VERIFY_REQUIRED) {

            ExceptionCode = STATUS_FILE_LOCK_CONFLICT;
        }
        
        FatCompleteRequest( IrpContext, Irp, ExceptionCode );

        return ExceptionCode;
    }

    if (IoIsErrorUserInduced(ExceptionCode)) {

        //
        //  Check for the various error conditions that can be caused by,
        //  and possibly resolved by the user.
        //

        if (ExceptionCode == STATUS_VERIFY_REQUIRED) {

            PDEVICE_OBJECT Device;

            DebugTrace(0, Dbg, "Perform Verify Operation\n", 0);

            //
            //  Now we are at the top level file system entry point.
            //
            //  Grab the device to verify from the thread local storage
            //  and stick it in the information field for transportation
            //  to the fsp.  We also clear the field at this time.
            //

            Device = IoGetDeviceToVerify( Irp->Tail.Overlay.Thread );
            IoSetDeviceToVerify( Irp->Tail.Overlay.Thread, NULL );

            if ( Device == NULL ) {

                Device = IoGetDeviceToVerify( PsGetCurrentThread() );
                IoSetDeviceToVerify( PsGetCurrentThread(), NULL );

                ASSERT( Device != NULL );
            }

            //
            //  Let's not BugCheck just because the driver messed up.
            //

            if (Device == NULL) {

                ExceptionCode = STATUS_DRIVER_INTERNAL_ERROR;

                FatCompleteRequest( IrpContext, Irp, ExceptionCode );

                return ExceptionCode;
            }

            //
            //  FatPerformVerify() will do the right thing with the Irp.

            return FatPerformVerify( IrpContext, Irp, Device );
        }

        //
        //  The other user induced conditions generate an error unless
        //  they have been disabled for this request.
        //

        if (FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS)) {

            FatCompleteRequest( IrpContext, Irp, ExceptionCode );

            return ExceptionCode;

        } else {

            //
            //  Generate a pop-up
            //

            PDEVICE_OBJECT RealDevice;
            PVPB Vpb;
            PETHREAD Thread;

            if (IoGetCurrentIrpStackLocation(Irp)->FileObject != NULL) {

                Vpb = IoGetCurrentIrpStackLocation(Irp)->FileObject->Vpb;

            } else {

                Vpb = NULL;
            }

            //
            //  The device to verify is either in my thread local storage
            //  or that of the thread that owns the Irp.
            //

            Thread = Irp->Tail.Overlay.Thread;
            RealDevice = IoGetDeviceToVerify( Thread );

            if ( RealDevice == NULL ) {

                Thread = PsGetCurrentThread();
                RealDevice = IoGetDeviceToVerify( Thread );

                ASSERT( RealDevice != NULL );
            }

            //
            //  Let's not BugCheck just because the driver messed up.
            //

            if (RealDevice == NULL) {

                FatCompleteRequest( IrpContext, Irp, ExceptionCode );

                return ExceptionCode;
            }

            //
            //  This routine actually causes the pop-up.  It usually
            //  does this by queuing an APC to the callers thread,
            //  but in some cases it will complete the request immediately,
            //  so it is very important to IoMarkIrpPending() first.
            //

            IoMarkIrpPending( Irp );
            IoRaiseHardError( Irp, Vpb, RealDevice );

            //
            //  We will be handing control back to the caller here, so
            //  reset the saved device object.
            //

            IoSetDeviceToVerify( Thread, NULL );

            //
            //  The Irp will be completed by Io or resubmitted.  In either
            //  case we must clean up the IrpContext here.
            //

            FatDeleteIrpContext( IrpContext );
            return STATUS_PENDING;
        }
    }

    //
    //  This is just a run of the mill error.  If is a STATUS that we
    //  raised ourselves, and the information would be use for the
    //  user, raise an informational pop-up.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    Vcb = IrpContext->Vcb;

    //
    //  Now, if the Vcb is unknown to us this means that the error was raised
    //  in the process of a mount and before we even had a chance to build
    //  a full Vcb - and was really handled there.
    //

    if (Vcb != NULL) {

        if ( !FatDeviceIsFatFsdo( IrpSp->DeviceObject) &&
             !NT_SUCCESS(ExceptionCode) &&
             !FsRtlIsTotalDeviceFailure(ExceptionCode) ) {

            TransitionState = VolumeDirtyWithSurfaceTest;
        }

        //
        //  If this was a STATUS_FILE_CORRUPT or similar error indicating some
        //  nastiness out on the media, then mark the volume permanently dirty.
        //

        if (!FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS) &&
            ( TransitionState == VolumeDirtyWithSurfaceTest ||
              (ExceptionCode == STATUS_FILE_CORRUPT_ERROR) ||
              (ExceptionCode == STATUS_DISK_CORRUPT_ERROR) ||
              (ExceptionCode == STATUS_EA_CORRUPT_ERROR) ||
              (ExceptionCode == STATUS_INVALID_EA_NAME) ||
              (ExceptionCode == STATUS_EA_LIST_INCONSISTENT) ||
              (ExceptionCode == STATUS_NO_EAS_ON_FILE) )) {

            ASSERT( NodeType(Vcb) == FAT_NTC_VCB );

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY );

            //
            //  Do the "dirty" work, ignoring any error.
            //

            try {

                FatMarkVolume( IrpContext, Vcb, TransitionState );

            } except( FatExceptionFilter( IrpContext, GetExceptionInformation() ) ) {

                NOTHING;
            }
        }
    }

    FatCompleteRequest( IrpContext, Irp, ExceptionCode );

    return ExceptionCode;
}


VOID
FatCompleteRequest_Real (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine completes a Irp

Arguments:

    Irp - Supplies the Irp being processed

    Status - Supplies the status to complete the Irp with

Return Value:

    None.

--*/

{
    //
    //  If we have an Irp Context then unpin all of the repinned bcbs
    //  we might have collected.
    //

    if (IrpContext != NULL) {

        ASSERT( IrpContext->Repinned.Bcb[0] == NULL );

        FatUnpinRepinnedBcbs( IrpContext );
    }

    //
    //  Delete the Irp context before completing the IRP so if
    //  we run into some of the asserts, we can still backtrack
    //  through the IRP.
    //

    if (IrpContext != NULL) {

        FatDeleteIrpContext( IrpContext );
    }

    //
    //  If we have an Irp then complete the irp.
    //

    if (Irp != NULL) {

        //
        //  We got an error, so zero out the information field before
        //  completing the request if this was an input operation.
        //  Otherwise IopCompleteRequest will try to copy to the user's buffer.
        //

        if ( NT_ERROR(Status) &&
             FlagOn(Irp->Flags, IRP_INPUT_OPERATION) ) {

            Irp->IoStatus.Information = 0;
        }

        Irp->IoStatus.Status = Status;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
    }

    return;
}

BOOLEAN
FatIsIrpTopLevel (
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine detects if an Irp is the Top level requestor, ie. if it os OK
    to do a verify or pop-up now.  If TRUE is returned, then no file system
    resources are held above us.

Arguments:

    Irp - Supplies the Irp being processed

    Status - Supplies the status to complete the Irp with

Return Value:

    None.

--*/

{
    if ( IoGetTopLevelIrp() == NULL ) {

        IoSetTopLevelIrp( Irp );

        return TRUE;

    } else {

        return FALSE;
    }
}


BOOLEAN
FatFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine checks if fast i/o is possible for a read/write operation

Arguments:

    FileObject - Supplies the file object used in the query

    FileOffset - Supplies the starting byte offset for the read/write operation

    Length - Supplies the length, in bytes, of the read/write operation

    Wait - Indicates if we can wait

    LockKey - Supplies the lock key

    CheckForReadOperation - Indicates if this is a check for a read or write
        operation

    IoStatus - Receives the status of the operation if our return value is
        FastIoReturnError

Return Value:

    BOOLEAN - TRUE if fast I/O is possible and FALSE if the caller needs
        to take the long route.

--*/

{
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    LARGE_INTEGER LargeLength;

    //
    //  Decode the file object to get our fcb, the only one we want
    //  to deal with is a UserFileOpen
    //

    if (FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb ) != UserFileOpen) {

        return FALSE;
    }

    LargeLength.QuadPart = Length;

    //
    //  Based on whether this is a read or write operation we call
    //  fsrtl check for read/write
    //

    if (CheckForReadOperation) {

        if (FsRtlFastCheckLockForRead( &Fcb->Specific.Fcb.FileLock,
                                       FileOffset,
                                       &LargeLength,
                                       LockKey,
                                       FileObject,
                                       PsGetCurrentProcess() )) {

            return TRUE;
        }

    } else {

        //
        //  Also check for a write-protected volume here.
        //

        if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED) &&
            FsRtlFastCheckLockForWrite( &Fcb->Specific.Fcb.FileLock,
                                        FileOffset,
                                        &LargeLength,
                                        LockKey,
                                        FileObject,
                                        PsGetCurrentProcess() )) {

            return TRUE;
        }
    }

    return FALSE;
}


BOOLEAN
FatFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for basic file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN FcbAcquired = FALSE;

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = FAT_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);

    if (Wait) {

        SetFlag(IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT);

    } else {

        ClearFlag(IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT);
    }

    //
    //  Determine the type of open for the input file object and only accept
    //  the user file or directory open
    //

    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        return Results;
    }

    FsRtlEnterFileSystem();

    //
    //  Get access to the Fcb but only if it is not the paging file
    //

    if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

        if (!ExAcquireResourceSharedLite( Fcb->Header.Resource, Wait )) {

            FsRtlExitFileSystem();
            return Results;
        }

        FcbAcquired = TRUE;
    }

    try {

        //
        //  If the Fcb is not in a good state, return FALSE.
        //

        if (Fcb->FcbCondition != FcbGood) {

            try_return( Results );
        }

        Buffer->FileAttributes = 0;

        //
        //  If the fcb is not the root dcb then we will fill in the
        //  buffer otherwise it is all setup for us.
        //

        if (NodeType(Fcb) != FAT_NTC_ROOT_DCB) {

            //
            //  Extract the data and fill in the non zero fields of the output
            //  buffer
            //

            Buffer->LastWriteTime = Fcb->LastWriteTime;
            Buffer->CreationTime = Fcb->CreationTime;
            Buffer->LastAccessTime = Fcb->LastAccessTime;

            //
            //  Zero out the field we don't support.
            //

            Buffer->ChangeTime.QuadPart = 0;
            Buffer->FileAttributes = Fcb->DirentFatFlags;

        } else {

            Buffer->LastWriteTime.QuadPart = 0;
            Buffer->CreationTime.QuadPart = 0;
            Buffer->LastAccessTime.QuadPart = 0;
            Buffer->ChangeTime.QuadPart = 0;

            Buffer->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        }

        //
        //  If the temporary flag is set, then set it in the buffer.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_TEMPORARY )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
        }

        //
        //  If no attributes were set, set the normal bit.
        //

        if (Buffer->FileAttributes == 0) {

            Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = sizeof(FILE_BASIC_INFORMATION);

        Results = TRUE;

    try_exit: NOTHING;
    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Header.Resource ); }

        FsRtlExitFileSystem();
    }

    //
    //  And return to our caller
    //

    return Results;
}


BOOLEAN
FatFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for standard file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN FcbAcquired = FALSE;

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = FAT_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);

    if (Wait) {

        SetFlag(IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT);

    } else {

        ClearFlag(IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT);
    }

    //
    //  Determine the type of open for the input file object and only accept
    //  the user file or directory open
    //

    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        return Results;
    }

    //
    //  Get access to the Fcb but only if it is not the paging file
    //

    FsRtlEnterFileSystem();

    if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

        if (!ExAcquireResourceSharedLite( Fcb->Header.Resource, Wait )) {

            FsRtlExitFileSystem();
            return Results;
        }

        FcbAcquired = TRUE;
    }

    try {

        //
        //  If the Fcb is not in a good state, return FALSE.
        //

        if (Fcb->FcbCondition != FcbGood) {

            try_return( Results );
        }

        Buffer->NumberOfLinks = 1;
        Buffer->DeletePending = BooleanFlagOn( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );

        //
        //  Case on whether this is a file or a directory, and extract
        //  the information and fill in the fcb/dcb specific parts
        //  of the output buffer.
        //

        if (NodeType(Fcb) == FAT_NTC_FCB) {

            //
            //  If we don't alread know the allocation size, we cannot look
            //  it up in the fast path.
            //

            if (Fcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

                try_return( Results );
            }

            Buffer->AllocationSize = Fcb->Header.AllocationSize;
            Buffer->EndOfFile = Fcb->Header.FileSize;

            Buffer->Directory = FALSE;

        } else {

            Buffer->AllocationSize = FatLargeZero;
            Buffer->EndOfFile = FatLargeZero;

            Buffer->Directory = TRUE;
        }

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = sizeof(FILE_STANDARD_INFORMATION);

        Results = TRUE;

    try_exit: NOTHING;
    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Header.Resource ); }

        FsRtlExitFileSystem();
    }

    //
    //  And return to our caller
    //

    return Results;
}

BOOLEAN
FatFastQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for network open information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    IRP_CONTEXT IrpContext;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN FcbAcquired = FALSE;

    //
    //  Prepare the dummy irp context
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );
    IrpContext.NodeTypeCode = FAT_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof(IRP_CONTEXT);

    if (Wait) {

        SetFlag(IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT);

    } else {

        ClearFlag(IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT);
    }

    //
    //  Determine the type of open for the input file object and only accept
    //  the user file or directory open
    //

    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        return Results;
    }

    FsRtlEnterFileSystem();

    //
    //  Get access to the Fcb but only if it is not the paging file
    //

    if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

        if (!ExAcquireResourceSharedLite( Fcb->Header.Resource, Wait )) {

            FsRtlExitFileSystem();
            return Results;
        }

        FcbAcquired = TRUE;
    }

    try {

        //
        //  If the Fcb is not in a good state, return FALSE.
        //

        if (Fcb->FcbCondition != FcbGood) {

            try_return( Results );
        }

        //
        //  Extract the data and fill in the non zero fields of the output
        //  buffer
        //

        //
        //  Default the field we don't support to a reasonable value.
        //

        ExLocalTimeToSystemTime( &FatJanOne1980,
                                 &Buffer->ChangeTime );

        if (Fcb->Header.NodeTypeCode == FAT_NTC_ROOT_DCB) {

            //
            //  Reuse the default for the root dir.
            //

            Buffer->CreationTime =
            Buffer->LastAccessTime =
            Buffer->LastWriteTime = Buffer->ChangeTime;

        } else {

            Buffer->LastWriteTime = Fcb->LastWriteTime;
            Buffer->CreationTime = Fcb->CreationTime;
            Buffer->LastAccessTime = Fcb->LastAccessTime;
        }

        Buffer->FileAttributes = Fcb->DirentFatFlags;

        //
        //  If the temporary flag is set, then set it in the buffer.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_TEMPORARY )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
        }

        //
        //  If no attributes were set, set the normal bit.
        //

        if (Buffer->FileAttributes == 0) {

            Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        if (NodeType(Fcb) == FAT_NTC_FCB) {

            //
            //  If we don't already know the allocation size, we cannot
            //  lock it up in the fast path.
            //

            if (Fcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

                try_return( Results );
            }

            Buffer->AllocationSize = Fcb->Header.AllocationSize;
            Buffer->EndOfFile = Fcb->Header.FileSize;

        } else {

            Buffer->AllocationSize = FatLargeZero;
            Buffer->EndOfFile = FatLargeZero;
        }

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = sizeof(FILE_NETWORK_OPEN_INFORMATION);

        Results = TRUE;

    try_exit: NOTHING;
    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Header.Resource ); }

        FsRtlExitFileSystem();
    }

    //
    //  And return to our caller
    //

    return Results;
}

VOID
FatPopUpFileCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    The Following routine makes an informational popup that the file
    is corrupt.

Arguments:

    Fcb - The file that is corrupt.

Return Value:

    None.

--*/

{
    PKTHREAD Thread;

    //
    //  Disable the popup on the root directory.  It is important not
    //  to generate them on objects which are part of the mount process.
    //

    if (NodeType(Fcb) == FAT_NTC_ROOT_DCB) {

        return;
    }

    //
    //  Got to grab the full filename now.
    //

    if (Fcb->FullFileName.Buffer == NULL) {

        FatSetFullFileNameInFcb( IrpContext, Fcb );
    }

    //
    //  We never want to block a system thread waiting for the user to
    //  press OK.
    //

    if (IoIsSystemThread(IrpContext->OriginatingIrp->Tail.Overlay.Thread)) {

       Thread = NULL;

    } else {

       Thread = IrpContext->OriginatingIrp->Tail.Overlay.Thread;
    }

    IoRaiseInformationalHardError( STATUS_FILE_CORRUPT_ERROR,
                                   &Fcb->FullFileName,
                                   Thread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\dirctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DirCtrl.c

Abstract:

    This module implements the File Directory Control routines for Fat called
    by the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_DIRCTRL)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIRCTRL)

WCHAR Fat8QMdot3QM[12] = { DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM,
                           L'.', DOS_QM, DOS_QM, DOS_QM};

//
//  Local procedure prototypes
//

NTSTATUS
FatQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
FatGetDirTimes(
    PIRP_CONTEXT IrpContext,
    PDIRENT Dirent,
    PFILE_DIRECTORY_INFORMATION DirInfo
    );

NTSTATUS
FatNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonDirectoryControl)
#pragma alloc_text(PAGE, FatFsdDirectoryControl)
#pragma alloc_text(PAGE, FatNotifyChangeDirectory)
#pragma alloc_text(PAGE, FatQueryDirectory)
#pragma alloc_text(PAGE, FatGetDirTimes)

#endif


NTSTATUS
FatFsdDirectoryControl (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of directory control

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdDirectoryControl\n", 0);

    //
    //  Call the common directory Control routine, with blocking allowed if
    //  synchronous
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        Status = FatCommonDirectoryControl( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdDirectoryControl -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonDirectoryControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing directory control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonDirectoryControl\n", 0);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "MinorFunction = %08lx\n", IrpSp->MinorFunction );

    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch ( IrpSp->MinorFunction ) {

    case IRP_MN_QUERY_DIRECTORY:

        Status = FatQueryDirectory( IrpContext, Irp );
        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

        Status = FatNotifyChangeDirectory( IrpContext, Irp );
        break;

    default:

        DebugTrace(0, Dbg, "Invalid Directory Control Minor Function %08lx\n", IrpSp->MinorFunction);

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    DebugTrace(-1, Dbg, "FatCommonDirectoryControl -> %08lx\n", Status);

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the query directory operation.  It is responsible
    for either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PDCB Dcb;
    PCCB Ccb;
    PBCB Bcb;

    ULONG i;
    PUCHAR Buffer;
    CLONG UserBufferLength;

    PUNICODE_STRING UniArgFileName;
    WCHAR LongFileNameBuffer[ FAT_CREATE_INITIAL_NAME_BUF_SIZE];
    UNICODE_STRING LongFileName;
    FILE_INFORMATION_CLASS FileInformationClass;
    ULONG FileIndex;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN IndexSpecified;

    BOOLEAN InitialQuery;
    VBO CurrentVbo;
    BOOLEAN UpdateCcb;
    PDIRENT Dirent;
    UCHAR Fat8Dot3Buffer[12];
    OEM_STRING Fat8Dot3String;
    ULONG DiskAllocSize;

    ULONG NextEntry;
    ULONG LastEntry;

    PFILE_DIRECTORY_INFORMATION DirInfo;
    PFILE_FULL_DIR_INFORMATION FullDirInfo;
    PFILE_BOTH_DIR_INFORMATION BothDirInfo;
    PFILE_ID_FULL_DIR_INFORMATION IdFullDirInfo;
    PFILE_ID_BOTH_DIR_INFORMATION IdBothDirInfo;
    PFILE_NAMES_INFORMATION NamesInfo;

    //
    //  Get the current Stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Display the input values.
    //
    DebugTrace(+1, Dbg, "FatQueryDirectory...\n", 0);
    DebugTrace( 0, Dbg, " Wait                   = %08lx\n", FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT));
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", IrpSp->Parameters.QueryDirectory.Length);
    DebugTrace( 0, Dbg, " ->FileName             = %08lx\n", IrpSp->Parameters.QueryDirectory.FileName);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", IrpSp->Parameters.QueryDirectory.FileInformationClass);
    DebugTrace( 0, Dbg, " ->FileIndex            = %08lx\n", IrpSp->Parameters.QueryDirectory.FileIndex);
    DebugTrace( 0, Dbg, " ->UserBuffer           = %08lx\n", Irp->AssociatedIrp.SystemBuffer);
    DebugTrace( 0, Dbg, " ->RestartScan          = %08lx\n", FlagOn( IrpSp->Flags, SL_RESTART_SCAN ));
    DebugTrace( 0, Dbg, " ->ReturnSingleEntry    = %08lx\n", FlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY ));
    DebugTrace( 0, Dbg, " ->IndexSpecified       = %08lx\n", FlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED ));

    //
    //  Reference our input parameters to make things easier
    //

    UserBufferLength = IrpSp->Parameters.QueryDirectory.Length;

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;
    FileIndex = IrpSp->Parameters.QueryDirectory.FileIndex;

    UniArgFileName = (PUNICODE_STRING) IrpSp->Parameters.QueryDirectory.FileName;

    RestartScan       = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);
    ReturnSingleEntry = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);
    IndexSpecified    = BooleanFlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED);

    //
    //  Check on the type of open.  We return invalid parameter for all
    //  but UserDirectoryOpens.  Also check that the filename is a valid
    //  UNICODE string.
    //
    
    if (FatDecodeFileObject( IrpSp->FileObject,
                             &Vcb,
                             &Dcb,
                             &Ccb) != UserDirectoryOpen ||
        (UniArgFileName &&
         UniArgFileName->Length % sizeof(WCHAR))) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace(-1, Dbg, "FatQueryDirectory -> STATUS_INVALID_PARAMETER\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Initialize the local variables.
    //

    Bcb = NULL;
    UpdateCcb = TRUE;
    Dirent = NULL;

    Fat8Dot3String.MaximumLength = 12;
    Fat8Dot3String.Buffer = Fat8Dot3Buffer;

    LongFileName.Length = 0;
    LongFileName.MaximumLength = sizeof( LongFileNameBuffer);
    LongFileName.Buffer = LongFileNameBuffer;

    InitialQuery = (BOOLEAN)((Ccb->UnicodeQueryTemplate.Buffer == NULL) &&
                             !FlagOn(Ccb->Flags, CCB_FLAG_MATCH_ALL));
    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    DiskAllocSize = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    //
    //  If this is the initial query, then grab exclusive access in
    //  order to update the search string in the Ccb.  We may
    //  discover that we are not the initial query once we grab the Fcb
    //  and downgrade our status.
    //

    if (InitialQuery) {

        if (!FatAcquireExclusiveFcb( IrpContext, Dcb )) {

            DebugTrace(0, Dbg, "FatQueryDirectory -> Enqueue to Fsp\n", 0);
            Status = FatFsdPostRequest( IrpContext, Irp );
            DebugTrace(-1, Dbg, "FatQueryDirectory -> %08lx\n", Status);

            return Status;
        }

        if (Ccb->UnicodeQueryTemplate.Buffer != NULL) {

            InitialQuery = FALSE;

            FatConvertToSharedFcb( IrpContext, Dcb );
        }

    } else {

        if (!FatAcquireSharedFcb( IrpContext, Dcb )) {

            DebugTrace(0, Dbg, "FatQueryDirectory -> Enqueue to Fsp\n", 0);
            Status = FatFsdPostRequest( IrpContext, Irp );
            DebugTrace(-1, Dbg, "FatQueryDirectory -> %08lx\n", Status);

            return Status;

        }
    }

    try {

        ULONG BaseLength;
        ULONG BytesConverted;

        //
        // If we are in the Fsp now because we had to wait earlier,
        // we must map the user buffer, otherwise we can use the
        // user's buffer directly.
        //

        Buffer = FatMapUserBuffer( IrpContext, Irp );

        //
        //  Make sure the Dcb is still good.
        //

        FatVerifyFcb( IrpContext, Dcb );

        //
        //  Determine where to start the scan.  Highest priority is given
        //  to the file index.  Lower priority is the restart flag.  If
        //  neither of these is specified, then the Vbo offset field in the
        //  Ccb is used.
        //

        if (IndexSpecified) {

            CurrentVbo = FileIndex + sizeof( DIRENT );

        } else if (RestartScan) {

            CurrentVbo = 0;

        } else {

            CurrentVbo = Ccb->OffsetToStartSearchFrom;

        }

        //
        //  If this is the first try then allocate a buffer for the file
        //  name.
        //

        if (InitialQuery) {

            //
            //  If either:
            //
            //  - No name was specified
            //  - An empty name was specified
            //  - We received a '*'
            //  - The user specified the DOS equivolent of ????????.???
            //
            //  then match all names.
            //

            if ((UniArgFileName == NULL) ||
                (UniArgFileName->Length == 0) ||
                (UniArgFileName->Buffer == NULL) ||
                ((UniArgFileName->Length == sizeof(WCHAR)) &&
                 (UniArgFileName->Buffer[0] == L'*')) ||
                ((UniArgFileName->Length == 12*sizeof(WCHAR)) &&
                 (RtlEqualMemory( UniArgFileName->Buffer,
                                  Fat8QMdot3QM,
                                  12*sizeof(WCHAR) )))) {

                Ccb->ContainsWildCards = TRUE;

                SetFlag( Ccb->Flags, CCB_FLAG_MATCH_ALL );

            } else {

                BOOLEAN ExtendedName = FALSE;
                OEM_STRING LocalBestFit;

                //
                //  First and formost, see if the name has wild cards.
                //

                Ccb->ContainsWildCards =
                    FsRtlDoesNameContainWildCards( UniArgFileName );

                //
                //  Now check to see if the name contains any extended
                //  characters
                //

                for (i=0; i < UniArgFileName->Length / sizeof(WCHAR); i++) {

                    if (UniArgFileName->Buffer[i] >= 0x80) {

                        ExtendedName = TRUE;
                        break;
                    }
                }

                //
                //  OK, now do the conversions we need.
                //

                if (ExtendedName) {

                    Status = RtlUpcaseUnicodeString( &Ccb->UnicodeQueryTemplate,
                                                     UniArgFileName,
                                                     TRUE );

                    if (!NT_SUCCESS(Status)) {

                        try_return( Status );
                    }

                    SetFlag( Ccb->Flags, CCB_FLAG_FREE_UNICODE );

                    //
                    //  Upcase the name and convert it to the Oem code page.
                    //

                    Status = RtlUpcaseUnicodeStringToCountedOemString( &LocalBestFit,
                                                                       UniArgFileName,
                                                                       TRUE );

                    //
                    //  If this conversion failed for any reason other than
                    //  an unmappable character fail the request.
                    //

                    if (!NT_SUCCESS(Status)) {

                        if (Status == STATUS_UNMAPPABLE_CHARACTER) {

                            SetFlag( Ccb->Flags, CCB_FLAG_SKIP_SHORT_NAME_COMPARE );

                        } else {

                            try_return( Status );
                        }

                    } else {

                        SetFlag( Ccb->Flags, CCB_FLAG_FREE_OEM_BEST_FIT );
                    }

                } else {

                    PVOID Buffers;

                    //
                    //  This case is optimized because I know I only have to
                    //  worry about a-z.
                    //

                    Buffers = FsRtlAllocatePoolWithTag( PagedPool,
                                                        UniArgFileName->Length +
                                                        UniArgFileName->Length / sizeof(WCHAR),
                                                        TAG_FILENAME_BUFFER );

                    Ccb->UnicodeQueryTemplate.Buffer = Buffers;
                    Ccb->UnicodeQueryTemplate.Length = UniArgFileName->Length;
                    Ccb->UnicodeQueryTemplate.MaximumLength = UniArgFileName->Length;

                    LocalBestFit.Buffer = (PUCHAR)Buffers + UniArgFileName->Length;
                    LocalBestFit.Length = UniArgFileName->Length / sizeof(WCHAR);
                    LocalBestFit.MaximumLength = LocalBestFit.Length;

                    SetFlag( Ccb->Flags, CCB_FLAG_FREE_UNICODE );

                    for (i=0; i < UniArgFileName->Length / sizeof(WCHAR); i++) {

                        WCHAR c = UniArgFileName->Buffer[i];

                        LocalBestFit.Buffer[i] = (UCHAR)
                        (Ccb->UnicodeQueryTemplate.Buffer[i] =
                             (c < 'a' ? c : c <= 'z' ? c - ('a' - 'A') : c));
                    }
                }

                //
                //  At this point we now have the upcased unicode name,
                //  and the two Oem names if they could be represented in
                //  this code page.
                //
                //  Now determine if the Oem names are legal for what we
                //  going to try and do.  Mark them as not usable is they
                //  are not legal.  Note that we can optimize extended names
                //  since they are actually both the same string.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_SKIP_SHORT_NAME_COMPARE ) &&
                    !FatIsNameShortOemValid( IrpContext,
                                             LocalBestFit,
                                             Ccb->ContainsWildCards,
                                             FALSE,
                                             FALSE )) {

                    if (ExtendedName) {

                        RtlFreeOemString( &LocalBestFit );
                        ClearFlag( Ccb->Flags, CCB_FLAG_FREE_OEM_BEST_FIT );
                    }

                    SetFlag( Ccb->Flags, CCB_FLAG_SKIP_SHORT_NAME_COMPARE );
                }

                //
                //  OK, now both locals oem strings correctly reflect their
                //  usability.  Now we want to load up the Ccb structure.
                //
                //  Now we will branch on two paths of wheather the name
                //  is wild or not.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_SKIP_SHORT_NAME_COMPARE )) {

                    if (Ccb->ContainsWildCards) {

                        Ccb->OemQueryTemplate.Wild = LocalBestFit;

                    } else {

                        FatStringTo8dot3( IrpContext,
                                          LocalBestFit,
                                          &Ccb->OemQueryTemplate.Constant );

                        if (FlagOn(Ccb->Flags, CCB_FLAG_FREE_OEM_BEST_FIT)) {

                            RtlFreeOemString( &LocalBestFit );
                            ClearFlag( Ccb->Flags, CCB_FLAG_FREE_OEM_BEST_FIT );
                        }
                    }
                }
            }

            //
            //  We convert to shared access.
            //

            FatConvertToSharedFcb( IrpContext, Dcb );
        }

        LastEntry = 0;
        NextEntry = 0;

        switch (FileInformationClass) {

        case FileDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                       FileName[0] );
            break;

        case FileFullDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                       FileName[0] );
            break;

        case FileIdFullDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION,
                                       FileName[0] );
            break;

        case FileNamesInformation:

            BaseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                       FileName[0] );
            break;

        case FileBothDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                       FileName[0] );
            break;

        case FileIdBothDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION,
                                       FileName[0] );
            break;

        default:

            try_return( Status = STATUS_INVALID_INFO_CLASS );
        }

        //
        //  At this point we are about to enter our query loop.  We have
        //  determined the index into the directory file to begin the
        //  search.  LastEntry and NextEntry are used to index into the user
        //  buffer.  LastEntry is the last entry we've added, NextEntry is
        //  current one we're working on.  If NextEntry is non-zero, then
        //  at least one entry was added.
        //

        while ( TRUE ) {

            VBO NextVbo;
            ULONG FileNameLength;
            ULONG BytesRemainingInBuffer;


            DebugTrace(0, Dbg, "FatQueryDirectory -> Top of loop\n", 0);

            //
            //  If the user had requested only a single match and we have
            //  returned that, then we stop at this point.
            //

            if (ReturnSingleEntry && NextEntry != 0) {

                try_return( Status );
            }

            //
            //  We call FatLocateDirent to lock down the next matching dirent.
            //

            FatLocateDirent( IrpContext,
                             Dcb,
                             Ccb,
                             CurrentVbo,
                             &Dirent,
                             &Bcb,
                             &NextVbo,
                             NULL,
                             &LongFileName);

            //
            //  If we didn't receive a dirent, then we are at the end of the
            //  directory.  If we have returned any files, we exit with
            //  success, otherwise we return STATUS_NO_MORE_FILES.
            //

            if (!Dirent) {

                DebugTrace(0, Dbg, "FatQueryDirectory -> No dirent\n", 0);

                if (NextEntry == 0) {

                    UpdateCcb = FALSE;

                    if (InitialQuery) {

                        Status = STATUS_NO_SUCH_FILE;

                    } else {

                        Status = STATUS_NO_MORE_FILES;
                    }
                }

                try_return( Status );
            }

            //
            //  Protect access to the user buffer with an exception handler.
            //  Since (at our request) IO doesn't buffer these requests, we have
            //  to guard against a user messing with the page protection and other
            //  such trickery.
            //
            
            try {
                
                if (LongFileName.Length == 0) {

                    //
                    //  Now we have an entry to return to our caller.  We'll convert
                    //  the name from the form in the dirent to a <name>.<ext> form.
                    //  We'll case on the type of information requested and fill up
                    //  the user buffer if everything fits.
                    //

                    Fat8dot3ToString( IrpContext, Dirent, TRUE, &Fat8Dot3String );
    
                    //
                    //  Determine the UNICODE length of the file name.
                    //
    
                    FileNameLength = RtlOemStringToCountedUnicodeSize(&Fat8Dot3String);

                    //
                    //  Here are the rules concerning filling up the buffer:
                    //
                    //  1.  The Io system garentees that there will always be
                    //      enough room for at least one base record.
                    //
                    //  2.  If the full first record (including file name) cannot
                    //      fit, as much of the name as possible is copied and
                    //      STATUS_BUFFER_OVERFLOW is returned.
                    //
                    //  3.  If a subsequent record cannot completely fit into the
                    //      buffer, none of it (as in 0 bytes) is copied, and
                    //      STATUS_SUCCESS is returned.  A subsequent query will
                    //      pick up with this record.
                    //
    
                    BytesRemainingInBuffer = UserBufferLength - NextEntry;
    
                    if ( (NextEntry != 0) &&
                         ( (BaseLength + FileNameLength > BytesRemainingInBuffer) ||
                           (UserBufferLength < NextEntry) ) ) {
    
                        DebugTrace(0, Dbg, "Next entry won't fit\n", 0);
    
                        try_return( Status = STATUS_SUCCESS );
                    }
    
                    ASSERT( BytesRemainingInBuffer >= BaseLength );

                    //
                    //  Zero the base part of the structure.
                    //

                    RtlZeroMemory( &Buffer[NextEntry], BaseLength );

                    switch ( FileInformationClass ) {
    
                    //
                    //  Now fill the base parts of the strucure that are applicable.
                    //
    
                    case FileBothDirectoryInformation:
                    case FileFullDirectoryInformation:
                    case FileIdBothDirectoryInformation:
                    case FileIdFullDirectoryInformation:

                        DebugTrace(0, Dbg, "FatQueryDirectory -> Getting file full directory information\n", 0);
    
                        //
                        //  Get the Ea file length.
                        //
    
                        FullDirInfo = (PFILE_FULL_DIR_INFORMATION)&Buffer[NextEntry];
    
                        //
                        //  If the EAs are corrupt, ignore the error.  We don't want
                        //  to abort the directory query.
                        //
    
                        try {
    
                            FatGetEaLength( IrpContext,
                                            Vcb,
                                            Dirent,
                                            &FullDirInfo->EaSize );
    
                        } except(EXCEPTION_EXECUTE_HANDLER) {
    
                              FatResetExceptionState( IrpContext );
                              FullDirInfo->EaSize = 0;
                        }
                        
                    case FileDirectoryInformation:
    
                        DirInfo = (PFILE_DIRECTORY_INFORMATION)&Buffer[NextEntry];
    
                        FatGetDirTimes( IrpContext, Dirent, DirInfo );
    
                        DirInfo->EndOfFile.QuadPart = Dirent->FileSize;
    
                        if (!FlagOn( Dirent->Attributes, FAT_DIRENT_ATTR_DIRECTORY )) {
    
                            DirInfo->AllocationSize.QuadPart =
                               (((Dirent->FileSize + DiskAllocSize - 1) / DiskAllocSize) *
                                DiskAllocSize );
                        }
    
                        DirInfo->FileAttributes = Dirent->Attributes != 0 ?
                                                  Dirent->Attributes :
                                                  FILE_ATTRIBUTE_NORMAL;
    
                        DirInfo->FileIndex = NextVbo;
    
                        DirInfo->FileNameLength = FileNameLength;
    
                        DebugTrace(0, Dbg, "FatQueryDirectory -> Name = \"%Z\"\n", &Fat8Dot3String);
    
                        break;
    
                    case FileNamesInformation:
    
                        DebugTrace(0, Dbg, "FatQueryDirectory -> Getting file names information\n", 0);
    
                        NamesInfo = (PFILE_NAMES_INFORMATION)&Buffer[NextEntry];
    
                        NamesInfo->FileIndex = NextVbo;
    
                        NamesInfo->FileNameLength = FileNameLength;
    
                        DebugTrace(0, Dbg, "FatQueryDirectory -> Name = \"%Z\"\n", &Fat8Dot3String );
    
                        break;
    
                    default:
    
                        FatBugCheck( FileInformationClass, 0, 0 );
                    }

                    BytesConverted = 0;
    
                    Status = RtlOemToUnicodeN( (PWCH)&Buffer[NextEntry + BaseLength],
                                               BytesRemainingInBuffer - BaseLength,
                                               &BytesConverted,
                                               Fat8Dot3String.Buffer,
                                               Fat8Dot3String.Length );
                    
                    //
                    //  Check for the case that a single entry doesn't fit.
                    //  This should only get this far on the first entry
                    //
    
                    if (BytesConverted < FileNameLength) {
    
                        ASSERT( NextEntry == 0 );
                        Status = STATUS_BUFFER_OVERFLOW;
                    }
    
                    //
                    //  Set up the previous next entry offset
                    //
    
                    *((PULONG)(&Buffer[LastEntry])) = NextEntry - LastEntry;
    
                    //
                    //  And indicate how much of the user buffer we have currently
                    //  used up.  We must compute this value before we long align
                    //  ourselves for the next entry
                    //
    
                    Irp->IoStatus.Information = QuadAlign( Irp->IoStatus.Information ) +
                                                BaseLength + BytesConverted;
    
                    //
                    //  If something happened with the conversion, bail here.
                    //
    
                    if ( !NT_SUCCESS( Status ) ) {
    
                        try_return( NOTHING );
                    }

                } else {

                    ULONG ShortNameLength;
    
                    FileNameLength = LongFileName.Length;
    
                    //
                    //  Here are the rules concerning filling up the buffer:
                    //
                    //  1.  The Io system garentees that there will always be
                    //      enough room for at least one base record.
                    //
                    //  2.  If the full first record (including file name) cannot
                    //      fit, as much of the name as possible is copied and
                    //      STATUS_BUFFER_OVERFLOW is returned.
                    //
                    //  3.  If a subsequent record cannot completely fit into the
                    //      buffer, none of it (as in 0 bytes) is copied, and
                    //      STATUS_SUCCESS is returned.  A subsequent query will
                    //      pick up with this record.
                    //
    
                    BytesRemainingInBuffer = UserBufferLength - NextEntry;
    
                    if ( (NextEntry != 0) &&
                         ( (BaseLength + FileNameLength > BytesRemainingInBuffer) ||
                           (UserBufferLength < NextEntry) ) ) {
    
                        DebugTrace(0, Dbg, "Next entry won't fit\n", 0);
    
                        try_return( Status = STATUS_SUCCESS );
                    }
    
                    ASSERT( BytesRemainingInBuffer >= BaseLength );
    
                    //
                    //  Zero the base part of the structure.
                    //

                    RtlZeroMemory( &Buffer[NextEntry], BaseLength );

                    switch ( FileInformationClass ) {
    
                    //
                    //  Now fill the base parts of the strucure that are applicable.
                    //
    
                    case FileBothDirectoryInformation:
                    case FileIdBothDirectoryInformation:
    
                        BothDirInfo = (PFILE_BOTH_DIR_INFORMATION)&Buffer[NextEntry];
    
                        //
                        //  Now we have an entry to return to our caller.  We'll convert
                        //  the name from the form in the dirent to a <name>.<ext> form.
                        //  We'll case on the type of information requested and fill up
                        //  the user buffer if everything fits.
                        //
    
                        Fat8dot3ToString( IrpContext, Dirent, FALSE, &Fat8Dot3String );
    
                        ASSERT( Fat8Dot3String.Length <= 12 );
    
                        Status = RtlOemToUnicodeN( &BothDirInfo->ShortName[0],
                                                   12*sizeof(WCHAR),
                                                   &ShortNameLength,
                                                   Fat8Dot3String.Buffer,
                                                   Fat8Dot3String.Length );
    
                        ASSERT( Status != STATUS_BUFFER_OVERFLOW );
                        ASSERT( BothDirInfo->ShortNameLength <= 12*sizeof(WCHAR) );
    
                        //
                        //  Copy the length into the dirinfo structure.  Note
                        //  that the LHS below is a USHORT, so it can not
                        //  be specificed as the OUT parameter above.
                        //
    
                        BothDirInfo->ShortNameLength = (UCHAR)ShortNameLength;
    
                        //
                        //  If something happened with the conversion, bail here.
                        //
    
                        if ( !NT_SUCCESS( Status ) ) {
    
                            try_return( NOTHING );
                        }
    
                    case FileFullDirectoryInformation:
                    case FileIdFullDirectoryInformation:
    
                        DebugTrace(0, Dbg, "FatQueryDirectory -> Getting file full directory information\n", 0);
    
                        //
                        //  Get the Ea file length.
                        //
    
                        FullDirInfo = (PFILE_FULL_DIR_INFORMATION)&Buffer[NextEntry];
    
                        //
                        //  If the EAs are corrupt, ignore the error.  We don't want
                        //  to abort the directory query.
                        //
    
                        try {
    
                            FatGetEaLength( IrpContext,
                                            Vcb,
                                            Dirent,
                                            &FullDirInfo->EaSize );
    
                        } except(EXCEPTION_EXECUTE_HANDLER) {
    
                              FatResetExceptionState( IrpContext );
                              FullDirInfo->EaSize = 0;
                        }
    
                    case FileDirectoryInformation:
    
                        DirInfo = (PFILE_DIRECTORY_INFORMATION)&Buffer[NextEntry];
    
                        FatGetDirTimes( IrpContext, Dirent, DirInfo );
    
                        DirInfo->EndOfFile.QuadPart = Dirent->FileSize;
    
                        if (!FlagOn( Dirent->Attributes, FAT_DIRENT_ATTR_DIRECTORY )) {
    
                            DirInfo->AllocationSize.QuadPart = (
                                                            (( Dirent->FileSize
                                                               + DiskAllocSize - 1 )
                                                             / DiskAllocSize )
                                                            * DiskAllocSize );
                        }
    
                        DirInfo->FileAttributes = Dirent->Attributes != 0 ?
                                                  Dirent->Attributes :
                                                  FILE_ATTRIBUTE_NORMAL;
    
                        DirInfo->FileIndex = NextVbo;
    
                        DirInfo->FileNameLength = FileNameLength;
    
                        DebugTrace(0, Dbg, "FatQueryDirectory -> Name = \"%Z\"\n", &Fat8Dot3String);
    
                        break;
    
                    case FileNamesInformation:
    
                        DebugTrace(0, Dbg, "FatQueryDirectory -> Getting file names information\n", 0);
    
                        NamesInfo = (PFILE_NAMES_INFORMATION)&Buffer[NextEntry];
    
                        NamesInfo->FileIndex = NextVbo;
    
                        NamesInfo->FileNameLength = FileNameLength;
    
                        DebugTrace(0, Dbg, "FatQueryDirectory -> Name = \"%Z\"\n", &Fat8Dot3String );
    
                        break;
    
                    default:
    
                        FatBugCheck( FileInformationClass, 0, 0 );
                    }

                    BytesConverted = BytesRemainingInBuffer - BaseLength >= FileNameLength ?
                                     FileNameLength :
                                     BytesRemainingInBuffer - BaseLength;
    
                    RtlCopyMemory( &Buffer[NextEntry + BaseLength],
                                   &LongFileName.Buffer[0],
                                   BytesConverted );
    
                    //
                    //  Set up the previous next entry offset
                    //
    
                    *((PULONG)(&Buffer[LastEntry])) = NextEntry - LastEntry;

                    //
                    //  And indicate how much of the user buffer we have currently
                    //  used up.  We must compute this value before we long align
                    //  ourselves for the next entry
                    //
    
                    Irp->IoStatus.Information += BaseLength + BytesConverted;

                    //
                    //  Check for the case that a single entry doesn't fit.
                    //  This should only get this far on the first entry.
                    //

                    if (BytesConverted < FileNameLength) {

                        ASSERT( NextEntry == 0 );

                        try_return( Status = STATUS_BUFFER_OVERFLOW );
                    }
                }

                //
                //  Finish up by filling in the FileId
                //

                switch ( FileInformationClass ) {

                case FileIdBothDirectoryInformation:

                    IdBothDirInfo = (PFILE_ID_BOTH_DIR_INFORMATION)&Buffer[NextEntry];
                    IdBothDirInfo->FileId.QuadPart = FatGenerateFileIdFromDirentAndOffset( Dcb, Dirent, NextVbo );
                    break;

                case FileIdFullDirectoryInformation:

                    IdFullDirInfo = (PFILE_ID_FULL_DIR_INFORMATION)&Buffer[NextEntry];
                    IdFullDirInfo->FileId.QuadPart = FatGenerateFileIdFromDirentAndOffset( Dcb, Dirent, NextVbo );
                    break;

                default:
                    break;
                }
            
            }  except (EXCEPTION_EXECUTE_HANDLER) {

                  //
                  //  We had a problem filling in the user's buffer, so stop and
                  //  fail this request.  This is the only reason any exception
                  //  would have occured at this level.
                  //
                  
                  Irp->IoStatus.Information = 0;
                  UpdateCcb = FALSE;
                  try_return( Status = GetExceptionCode());
            }

            //
            //  Set ourselves up for the next iteration
            //

            LastEntry = NextEntry;
            NextEntry += (ULONG)QuadAlign(BaseLength + BytesConverted);

            CurrentVbo = NextVbo + sizeof( DIRENT );
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatQueryDirectory );

        FatReleaseFcb( IrpContext, Dcb );

        //
        //  Unpin data in cache if still held.
        //

        FatUnpinBcb( IrpContext, Bcb );

        //
        //  Free any dynamically allocated string buffer
        //

        FatFreeStringBuffer( &LongFileName);

        //
        //  Perform any cleanup.  If this is the first query, then store
        //  the filename in the Ccb if successful.  Also update the
        //  VBO index for the next search.  This is done by transferring
        //  from shared access to exclusive access and copying the
        //  data from the local copies.
        //

        if (!AbnormalTermination()) {

            if (UpdateCcb) {

                //
                //  Store the most recent VBO to use as a starting point for
                //  the next search.
                //

                Ccb->OffsetToStartSearchFrom = CurrentVbo;
            }

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatQueryDirectory -> %08lx\n", Status);

    }

    return Status;
}


//
//  Local Support Routine
//

VOID
FatGetDirTimes(
    PIRP_CONTEXT IrpContext,
    PDIRENT Dirent,
    PFILE_DIRECTORY_INFORMATION DirInfo
    )

/*++

Routine Description:

    This routine pulls the date/time information from a dirent and fills
    in the DirInfo structure.

Arguments:

    Dirent - Supplies the dirent
    DirInfo - Supplies the target structure

Return Value:

    VOID

--*/


{
    //
    //  Start with the Last Write Time.
    //

    DirInfo->LastWriteTime =
        FatFatTimeToNtTime( IrpContext,
                            Dirent->LastWriteTime,
                            0 );

    //
    //  These fields are only non-zero when in Chicago mode.
    //

    if (FatData.ChicagoMode) {

        //
        //  Do a quick check here for Creation and LastAccess
        //  times that are the same as the LastWriteTime.
        //

        if (*((UNALIGNED LONG *)&Dirent->CreationTime) ==
            *((UNALIGNED LONG *)&Dirent->LastWriteTime)) {

            DirInfo->CreationTime.QuadPart =

                DirInfo->LastWriteTime.QuadPart +
                Dirent->CreationMSec * 10 * 1000 * 10;

        } else {

            //
            //  Only do the really hard work if this field is non-zero.
            //

            if (((PUSHORT)Dirent)[8] != 0) {

                DirInfo->CreationTime =
                    FatFatTimeToNtTime( IrpContext,
                                        Dirent->CreationTime,
                                        Dirent->CreationMSec );

            } else {

                ExLocalTimeToSystemTime( &FatJanOne1980,
                                         &DirInfo->CreationTime );
            }
        }

        //
        //  Do a quick check for LastAccessDate.
        //

        if (*((PUSHORT)&Dirent->LastAccessDate) ==
            *((PUSHORT)&Dirent->LastWriteTime.Date)) {

            PFAT_TIME WriteTime;

            WriteTime = &Dirent->LastWriteTime.Time;

            DirInfo->LastAccessTime.QuadPart =
                DirInfo->LastWriteTime.QuadPart -
                UInt32x32To64(((WriteTime->DoubleSeconds * 2) +
                               (WriteTime->Minute * 60) +
                               (WriteTime->Hour * 60 * 60)),
                              1000 * 1000 * 10);

        } else {

            //
            //  Only do the really hard work if this field is non-zero.
            //

            if (((PUSHORT)Dirent)[9] != 0) {

                DirInfo->LastAccessTime =
                    FatFatDateToNtTime( IrpContext,
                                        Dirent->LastAccessDate );

            } else {

                ExLocalTimeToSystemTime( &FatJanOne1980,
                                         &DirInfo->LastAccessTime );
            }
        }
    }
}


//
//  Local Support Routine
//

NTSTATUS
FatNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the notify change directory operation.  It is
    responsible for either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PVCB Vcb;
    PDCB Dcb;
    PCCB Ccb;
    ULONG CompletionFilter;
    BOOLEAN WatchTree;

    BOOLEAN CompleteRequest;

    //
    //  Get the current Stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatNotifyChangeDirectory...\n", 0);
    DebugTrace( 0, Dbg, " Wait               = %08lx\n", FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT));
    DebugTrace( 0, Dbg, " Irp                = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->CompletionFilter = %08lx\n", IrpSp->Parameters.NotifyDirectory.CompletionFilter);

    //
    //  Always set the wait flag in the Irp context for the original request.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    //
    //  Assume we don't complete request.
    //

    CompleteRequest = FALSE;

    //
    //  Check on the type of open.  We return invalid parameter for all
    //  but UserDirectoryOpens.
    //

    if (FatDecodeFileObject( IrpSp->FileObject,
                             &Vcb,
                             &Dcb,
                             &Ccb ) != UserDirectoryOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace(-1, Dbg, "FatQueryDirectory -> STATUS_INVALID_PARAMETER\n", 0);

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Reference our input parameter to make things easier
    //

    CompletionFilter = IrpSp->Parameters.NotifyDirectory.CompletionFilter;
    WatchTree = BooleanFlagOn( IrpSp->Flags, SL_WATCH_TREE );

    //
    //  Try to acquire exclusive access to the Dcb and enqueue the Irp to the
    //  Fsp if we didn't get access
    //

    if (!FatAcquireExclusiveFcb( IrpContext, Dcb )) {

        DebugTrace(0, Dbg, "FatNotifyChangeDirectory -> Cannot Acquire Fcb\n", 0);

        Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatNotifyChangeDirectory -> %08lx\n", Status);
        return Status;
    }

    try {

        //
        //  Make sure the Fcb is still good
        //

        FatVerifyFcb( IrpContext, Dcb );

        //
        //  We need the full name.
        //

        FatSetFullFileNameInFcb( IrpContext, Dcb );

        //
        //  If the file is marked as DELETE_PENDING then complete this
        //  request immediately.
        //

        if (FlagOn( Dcb->FcbState, FCB_STATE_DELETE_ON_CLOSE )) {

            FatRaiseStatus( IrpContext, STATUS_DELETE_PENDING );
        }

        //
        //  Call the Fsrtl package to process the request.
        //

        FsRtlNotifyFullChangeDirectory( Vcb->NotifySync,
                                        &Vcb->DirNotifyList,
                                        Ccb,
                                        (PSTRING)&Dcb->FullFileName,
                                        WatchTree,
                                        FALSE,
                                        CompletionFilter,
                                        Irp,
                                        NULL,
                                        NULL );

        Status = STATUS_PENDING;

        CompleteRequest = TRUE;

    } finally {

        DebugUnwind( FatNotifyChangeDirectory );

        FatReleaseFcb( IrpContext, Dcb );

        //
        //  If the dir notify package is holding the Irp, we discard the
        //  the IrpContext.
        //

        if (CompleteRequest) {

            FatCompleteRequest( IrpContext, FatNull, 0 );
        }

        DebugTrace(-1, Dbg, "FatNotifyChangeDirectory -> %08lx\n", Status);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\ea.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Ea.c

Abstract:

    This module implements the EA routines for Fat called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    12-Apr-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

//
//  Local procedure prototypes
//

IO_STATUS_BLOCK
FatQueryEaUserEaList (
    IN PIRP_CONTEXT IrpContext,
    OUT PCCB Ccb,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    OUT PUCHAR UserBuffer,
    IN ULONG  UserBufferLength,
    IN PUCHAR UserEaList,
    IN ULONG  UserEaListLength,
    IN BOOLEAN ReturnSingleEntry
    );

IO_STATUS_BLOCK
FatQueryEaIndexSpecified (
    IN PIRP_CONTEXT IrpContext,
    OUT PCCB Ccb,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    OUT PUCHAR UserBuffer,
    IN ULONG  UserBufferLength,
    IN ULONG  UserEaIndex,
    IN BOOLEAN ReturnSingleEntry
    );

IO_STATUS_BLOCK
FatQueryEaSimpleScan (
    IN PIRP_CONTEXT IrpContext,
    OUT PCCB Ccb,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    OUT PUCHAR UserBuffer,
    IN ULONG  UserBufferLength,
    IN BOOLEAN ReturnSingleEntry,
    ULONG StartOffset
    );

BOOLEAN
FatIsDuplicateEaName (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_GET_EA_INFORMATION GetEa,
    IN PUCHAR UserBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonQueryEa)
#pragma alloc_text(PAGE, FatCommonSetEa)
#pragma alloc_text(PAGE, FatFsdQueryEa)
#pragma alloc_text(PAGE, FatFsdSetEa)
#pragma alloc_text(PAGE, FatIsDuplicateEaName)
#pragma alloc_text(PAGE, FatQueryEaIndexSpecified)
#pragma alloc_text(PAGE, FatQueryEaSimpleScan)
#pragma alloc_text(PAGE, FatQueryEaUserEaList)
#endif


NTSTATUS
FatFsdQueryEa (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the Fsd part of the NtQueryEa API
    call.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the file
        being queried exists.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The FSD status for the Irp.

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdQueryEa\n", 0);

    //
    //  Call the common query routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        Status = FatCommonQueryEa( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdQueryEa -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatFsdSetEa (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtSetEa API
    call.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the file
        being set exists.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The FSD status for the Irp.

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdSetEa\n", 0);

    //
    //  Call the common set routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        Status = FatCommonSetEa( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdSetEa -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonQueryEa (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying File ea called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    NTSTATUS Status;

    PUCHAR  Buffer;
    ULONG   UserBufferLength;

    PUCHAR  UserEaList;
    ULONG   UserEaListLength;
    ULONG   UserEaIndex;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN IndexSpecified;

    PVCB Vcb;
    PCCB Ccb;

    PFCB Fcb;
    PDIRENT Dirent;
    PBCB Bcb;

    PDIRENT EaDirent;
    PBCB EaBcb;
    BOOLEAN LockedEaFcb;

    PEA_SET_HEADER EaSetHeader;
    EA_RANGE EaSetRange;

    USHORT ExtendedAttributes;

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonQueryEa...\n", 0);
    DebugTrace( 0, Dbg, " Wait                = %08lx\n", FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT));
    DebugTrace( 0, Dbg, " Irp                 = %08lx\n", Irp );
    DebugTrace( 0, Dbg, " ->SystemBuffer      = %08lx\n", Irp->AssociatedIrp.SystemBuffer );
    DebugTrace( 0, Dbg, " ->Length            = %08lx\n", IrpSp->Parameters.QueryEa.Length );
    DebugTrace( 0, Dbg, " ->EaList            = %08lx\n", IrpSp->Parameters.QueryEa.EaList );
    DebugTrace( 0, Dbg, " ->EaListLength      = %08lx\n", IrpSp->Parameters.QueryEa.EaListLength );
    DebugTrace( 0, Dbg, " ->EaIndex           = %08lx\n", IrpSp->Parameters.QueryEa.EaIndex );
    DebugTrace( 0, Dbg, " ->RestartScan       = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN));
    DebugTrace( 0, Dbg, " ->ReturnSingleEntry = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY));
    DebugTrace( 0, Dbg, " ->IndexSpecified    = %08lx\n", FlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    //  Check that the file object is associated with either a user file
    //  or directory open.  We don't allow Ea operations on the root
    //  directory.
    //

    {
        TYPE_OF_OPEN OpenType;

        if (((OpenType = FatDecodeFileObject( IrpSp->FileObject,
                                             &Vcb,
                                             &Fcb,
                                             &Ccb )) != UserFileOpen
             && OpenType != UserDirectoryOpen) ||

            (NodeType( Fcb )) == FAT_NTC_ROOT_DCB) {

            FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

            DebugTrace(-1, Dbg,
                       "FatCommonQueryEa -> %08lx\n",
                       STATUS_INVALID_PARAMETER);

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Fat32 does not support ea's.
    //

    if (FatIsFat32(Vcb)) {

        FatCompleteRequest( IrpContext, Irp, STATUS_EAS_NOT_SUPPORTED );
        DebugTrace(-1, Dbg,
                   "FatCommonQueryEa -> %08lx\n",
                   STATUS_EAS_NOT_SUPPORTED);
        return STATUS_EAS_NOT_SUPPORTED;
    }

    //
    //  Acquire shared access to the Fcb and enqueue the Irp if we didn't
    //  get access.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        DebugTrace(0, Dbg, "FatCommonQueryEa:  Thread can't wait\n", 0);

        Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatCommonQueryEa -> %08lx\n", Status );

        return Status;
    }

    FatAcquireSharedFcb( IrpContext, Fcb );

    //
    //  Reference our input parameters to make things easier
    //

    UserBufferLength  = IrpSp->Parameters.QueryEa.Length;
    UserEaList        = IrpSp->Parameters.QueryEa.EaList;
    UserEaListLength  = IrpSp->Parameters.QueryEa.EaListLength;
    UserEaIndex       = IrpSp->Parameters.QueryEa.EaIndex;
    RestartScan       = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);
    ReturnSingleEntry = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);
    IndexSpecified    = BooleanFlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED);

    //
    //  Initialize our local values.
    //

    LockedEaFcb = FALSE;
    Bcb = NULL;
    EaBcb = NULL;

    Status = STATUS_SUCCESS;

    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    try {

        PPACKED_EA FirstPackedEa;
        ULONG PackedEasLength;

        Buffer = FatMapUserBuffer( IrpContext, Irp );

        //
        //  We verify that the Fcb is still valid.
        //

        FatVerifyFcb( IrpContext, Fcb );

        //
        //  We need to get the dirent for the Fcb to recover the Ea handle.
        //

        FatGetDirentFromFcbOrDcb( IrpContext, Fcb, &Dirent, &Bcb );

        //
        //  Verify that the Ea file is in a consistant state.  If the
        //  Ea modification count in the Fcb doesn't match that in
        //  the CCB, then the Ea file has been changed from under
        //  us.  If we are not starting the search from the beginning
        //  of the Ea set, we return an error.
        //

        if (UserEaList == NULL
            && Ccb->OffsetOfNextEaToReturn != 0
            && !IndexSpecified
            && !RestartScan
            && Fcb->EaModificationCount != Ccb->EaModificationCount) {

            DebugTrace(0, Dbg,
                      "FatCommonQueryEa:  Ea file in unknown state\n", 0);

            Status = STATUS_EA_CORRUPT_ERROR;

            try_return( Status );
        }

        //
        //  Show that the Ea's for this file are consistant for this
        //  file handle.
        //

        Ccb->EaModificationCount = Fcb->EaModificationCount;

        //
        //  If the handle value is 0, then the file has no Eas.  We dummy up
        //  an ea list to use below.
        //

        ExtendedAttributes = Dirent->ExtendedAttributes;

        FatUnpinBcb( IrpContext, Bcb );

        if (ExtendedAttributes == 0) {

            DebugTrace(0, Dbg,
                      "FatCommonQueryEa:  Zero handle, no Ea's for this file\n", 0);

            FirstPackedEa = (PPACKED_EA) NULL;

            PackedEasLength = 0;

        } else {

            //
            //  We need to get the Ea file for this volume.  If the
            //  operation doesn't complete due to blocking, then queue the
            //  Irp to the Fsp.
            //

            FatGetEaFile( IrpContext,
                          Vcb,
                          &EaDirent,
                          &EaBcb,
                          FALSE,
                          FALSE );

            LockedEaFcb = TRUE;

            //
            //  If the above operation completed and the Ea file did not exist,
            //  the disk has been corrupted.  There is an existing Ea handle
            //  without any Ea data.
            //

            if (Vcb->VirtualEaFile == NULL) {

                DebugTrace(0, Dbg,
                          "FatCommonQueryEa:  No Ea file found when expected\n", 0);

                Status = STATUS_NO_EAS_ON_FILE;

                try_return( Status );
            }

            //
            //  We need to try to get the Ea set for the desired file.  If
            //  blocking is necessary then we'll post the request to the Fsp.
            //

            FatReadEaSet( IrpContext,
                          Vcb,
                          ExtendedAttributes,
                          &Fcb->ShortName.Name.Oem,
                          TRUE,
                          &EaSetRange );

            EaSetHeader = (PEA_SET_HEADER) EaSetRange.Data;

            //
            //  Find the start and length of the Eas.
            //

            FirstPackedEa = (PPACKED_EA) EaSetHeader->PackedEas;

            PackedEasLength = GetcbList( EaSetHeader ) - 4;
        }

        //
        //  Protect our access to the user buffer since IO dosn't do this
        //  for us in this path unless we had specified that our driver
        //  requires buffering for these large requests.  We don't, so ...
        //

        try {

            //
            //  Let's clear the output buffer.
            //

            RtlZeroMemory( Buffer, UserBufferLength );

            //
            //  We now satisfy the user's request depending on whether he
            //  specified an Ea name list, an Ea index or restarting the
            //  search.
            //

            //
            //  The user has supplied a list of Ea names.
            //

            if (UserEaList != NULL) {

                Irp->IoStatus = FatQueryEaUserEaList( IrpContext,
                                                      Ccb,
                                                      FirstPackedEa,
                                                      PackedEasLength,
                                                      Buffer,
                                                      UserBufferLength,
                                                      UserEaList,
                                                      UserEaListLength,
                                                      ReturnSingleEntry );

            //
            //  The user supplied an index into the Ea list.
            //

            } else if (IndexSpecified) {

                Irp->IoStatus = FatQueryEaIndexSpecified( IrpContext,
                                                          Ccb,
                                                          FirstPackedEa,
                                                          PackedEasLength,
                                                          Buffer,
                                                          UserBufferLength,
                                                          UserEaIndex,
                                                          ReturnSingleEntry );

            //
            //  Else perform a simple scan, taking into account the restart
            //  flag and the position of the next Ea stored in the Ccb.
            //

            } else {

                Irp->IoStatus = FatQueryEaSimpleScan( IrpContext,
                                                      Ccb,
                                                      FirstPackedEa,
                                                      PackedEasLength,
                                                      Buffer,
                                                      UserBufferLength,
                                                      ReturnSingleEntry,
                                                      RestartScan
                                                      ? 0
                                                      : Ccb->OffsetOfNextEaToReturn );
            }

        }  except (!FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

               //
               //  We must have had a problem filling in the user's buffer, so fail.
               //

               Irp->IoStatus.Status = GetExceptionCode();
               Irp->IoStatus.Information = 0;
        }

        Status = Irp->IoStatus.Status;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatCommonQueryEa );

        //
        //  Release the Fcb for the file object, and the Ea Fcb if
        //  successfully locked.
        //

        FatReleaseFcb( IrpContext, Fcb );

        if (LockedEaFcb) {

            FatReleaseFcb( IrpContext, Vcb->EaFcb );
        }

        //
        //  Unpin the dirents for the Fcb, EaFcb and EaSetFcb if necessary.
        //

        FatUnpinBcb( IrpContext, Bcb );
        FatUnpinBcb( IrpContext, EaBcb );

        FatUnpinEaRange( IrpContext, &EaSetRange );

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatCommonQueryEa -> %08lx\n", Status);
    }

    return Status;
}


NTSTATUS
FatCommonSetEa (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the common Set Ea File Api called by the
    the Fsd and Fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The appropriate status for the Irp

--*/

{
    PIO_STACK_LOCATION IrpSp;

    NTSTATUS Status;

    USHORT ExtendedAttributes;

    PUCHAR Buffer;
    ULONG UserBufferLength;

    PVCB Vcb;
    PCCB Ccb;

    PFCB Fcb;
    PDIRENT Dirent;
    PBCB Bcb = NULL;

    PDIRENT EaDirent = NULL;
    PBCB EaBcb = NULL;

    PEA_SET_HEADER EaSetHeader = NULL;

    PEA_SET_HEADER PrevEaSetHeader;
    PEA_SET_HEADER NewEaSetHeader;
    EA_RANGE EaSetRange;

    BOOLEAN AcquiredVcb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;
    BOOLEAN AcquiredParentDcb = FALSE;
    BOOLEAN AcquiredRootDcb = FALSE;
    BOOLEAN AcquiredEaFcb = FALSE;

    //
    //  The following booleans are used in the unwind process.
    //

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonSetEa...\n", 0);
    DebugTrace( 0, Dbg, " Wait                = %08lx\n", FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT));
    DebugTrace( 0, Dbg, " Irp                 = %08lx\n", Irp );
    DebugTrace( 0, Dbg, " ->SystemBuffer      = %08lx\n", Irp->AssociatedIrp.SystemBuffer );
    DebugTrace( 0, Dbg, " ->Length            = %08lx\n", IrpSp->Parameters.SetEa.Length );

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    //  Check that the file object is associated with either a user file
    //  or directory open.
    //

    {
        TYPE_OF_OPEN OpenType;

        if (((OpenType = FatDecodeFileObject( IrpSp->FileObject,
                                             &Vcb,
                                             &Fcb,
                                             &Ccb )) != UserFileOpen
             && OpenType != UserDirectoryOpen) ||

            (NodeType( Fcb )) == FAT_NTC_ROOT_DCB) {

            FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

            DebugTrace(-1, Dbg,
                       "FatCommonSetEa -> %08lx\n",
                       STATUS_INVALID_PARAMETER);

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Fat32 does not support ea's.
    //

    if (FatIsFat32(Vcb)) {

        FatCompleteRequest( IrpContext, Irp, STATUS_EAS_NOT_SUPPORTED );
        DebugTrace(-1, Dbg,
                   "FatCommonSetEa -> %08lx\n",
                   STATUS_EAS_NOT_SUPPORTED);
        return STATUS_EAS_NOT_SUPPORTED;
    }

    //
    //  Reference our input parameters to make things easier
    //

    UserBufferLength  = IrpSp->Parameters.SetEa.Length;

    //
    //  Since we ask for no outside help (direct or buffered IO), it
    //  is our responsibility to insulate ourselves from the
    //  deviousness of the user above.  Now, buffer and validate the
    //  contents.
    //

    Buffer = FatBufferUserBuffer( IrpContext, Irp, UserBufferLength );

    //
    //  Check the validity of the buffer with the new eas.  We really
    //  need to do this always since we don't know, if it was already
    //  buffered, that we buffered and checked it or some overlying
    //  filter buffered without checking.
    //

    Status = IoCheckEaBufferValidity( (PFILE_FULL_EA_INFORMATION) Buffer,
                                      UserBufferLength,
                                      (PULONG)&Irp->IoStatus.Information );

    if (!NT_SUCCESS( Status )) {

        FatCompleteRequest( IrpContext, Irp, Status );
        DebugTrace(-1, Dbg,
                   "FatCommonSetEa -> %08lx\n",
                   Status);
        return Status;
    }

    //
    //  Acquire exclusive access to the Fcb.  If this is a write-through operation
    //  we will need to pick up the other possible streams that can be modified in
    //  this operation so that the locking order is preserved - the root directory
    //  (dirent addition if EA database doesn't already exist) and the parent
    //  directory (addition of the EA handle to the object's dirent).
    //
    //  We are primarily synchronizing with directory enumeration here.
    //
    //  If we cannot wait need to send things off to the fsp.
    //

    if (!FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT)) {

        DebugTrace(0, Dbg, "FatCommonSetEa:  Set Ea must be waitable\n", 0);

        Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatCommonSetEa -> %08lx\n", Status );

        return Status;
    }

    //
    //  Set this handle as having modified the file
    //

    IrpSp->FileObject->Flags |= FO_FILE_MODIFIED;

    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    try {

        ULONG PackedEasLength;
        BOOLEAN PreviousEas;
        ULONG AllocationLength;
        ULONG BytesPerCluster;
        USHORT EaHandle;

        PFILE_FULL_EA_INFORMATION FullEa;

        //
        //  Now go pick up everything
        //
        
        FatAcquireSharedVcb( IrpContext, Fcb->Vcb );
        AcquiredVcb = TRUE;
        FatAcquireExclusiveFcb( IrpContext, Fcb );
        AcquiredFcb = TRUE;

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH)) {

            if (Fcb->ParentDcb) {

                FatAcquireExclusiveFcb( IrpContext, Fcb->ParentDcb );
                AcquiredParentDcb = TRUE;
            }

            FatAcquireExclusiveFcb( IrpContext, Fcb->Vcb->RootDcb );
            AcquiredRootDcb = TRUE;
        }

        //
        //  We verify that the Fcb is still valid.
        //

        FatVerifyFcb( IrpContext, Fcb );

        //
        //  We need to get the dirent for the Fcb to recover the Ea handle.
        //

        FatGetDirentFromFcbOrDcb( IrpContext, Fcb, &Dirent, &Bcb );

        DebugTrace(0, Dbg, "FatCommonSetEa:  Dirent Address -> %08lx\n",
                   Dirent );
        DebugTrace(0, Dbg, "FatCommonSetEa:  Dirent Bcb -> %08lx\n",
                   Bcb);

        //
        //  If the handle value is 0, then the file has no Eas.  In that
        //  case we allocate memory to hold the Eas to be added.  If there
        //  are existing Eas for the file, then we must read from the
        //  file and copy the Eas.
        //

        ExtendedAttributes = Dirent->ExtendedAttributes;

        FatUnpinBcb( IrpContext, Bcb );

        if (ExtendedAttributes == 0) {

            PreviousEas = FALSE;

            DebugTrace(0, Dbg,
                      "FatCommonSetEa:  File has no current Eas\n", 0 );

        } else {

            PreviousEas = TRUE;

            DebugTrace(0, Dbg, "FatCommonSetEa:  File has previous Eas\n", 0 );

            FatGetEaFile( IrpContext,
                          Vcb,
                          &EaDirent,
                          &EaBcb,
                          FALSE,
                          TRUE );

            AcquiredEaFcb = TRUE;

            //
            //  If we didn't get the file then there is an error on
            //  the disk.
            //

            if (Vcb->VirtualEaFile == NULL) {

                Status = STATUS_NO_EAS_ON_FILE;
                try_return( Status );
            }
        }

        DebugTrace(0, Dbg, "FatCommonSetEa:  EaBcb -> %08lx\n", EaBcb);

        DebugTrace(0, Dbg, "FatCommonSetEa:  EaDirent -> %08lx\n", EaDirent);

        //
        //  If the file has existing ea's, we need to read them to
        //  determine the size of the buffer allocation.
        //

        if (PreviousEas) {

            //
            //  We need to try to get the Ea set for the desired file.
            //

            FatReadEaSet( IrpContext,
                          Vcb,
                          ExtendedAttributes,
                          &Fcb->ShortName.Name.Oem,
                          TRUE,
                          &EaSetRange );

            PrevEaSetHeader = (PEA_SET_HEADER) EaSetRange.Data;

            //
            //  We now must allocate pool memory for our copy of the
            //  EaSetHeader and then copy the Ea data into it.  At that
            //  time we can unpin the EaSet.
            //

            PackedEasLength = GetcbList( PrevEaSetHeader ) - 4;

        //
        //  Else we will create a dummy EaSetHeader.
        //

        } else {

            PackedEasLength = 0;
        }

        BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

        AllocationLength = (PackedEasLength
                            + SIZE_OF_EA_SET_HEADER
                            + BytesPerCluster - 1)
                           & ~(BytesPerCluster - 1);

        EaSetHeader = FsRtlAllocatePoolWithTag( PagedPool,
                                                AllocationLength,
                                                TAG_EA_SET_HEADER );

        //
        //  Copy the existing Eas over to pool memory.
        //

        if (PreviousEas) {

            RtlCopyMemory( EaSetHeader, PrevEaSetHeader, AllocationLength );

            FatUnpinEaRange( IrpContext, &EaSetRange );

        } else {

            RtlZeroMemory( EaSetHeader, AllocationLength );

            RtlCopyMemory( EaSetHeader->OwnerFileName,
                           Fcb->ShortName.Name.Oem.Buffer,
                           Fcb->ShortName.Name.Oem.Length );
        }


        AllocationLength -= SIZE_OF_EA_SET_HEADER;

        DebugTrace(0, Dbg, "FatCommonSetEa:  Initial Ea set -> %08lx\n",
                   EaSetHeader);

        //
        //  At this point we have either read in the current eas for the file
        //  or we have initialized a new empty buffer for the eas.  Now for
        //  each full ea in the input user buffer we do the specified operation
        //  on the ea
        //

        for (FullEa = (PFILE_FULL_EA_INFORMATION) Buffer;
             FullEa < (PFILE_FULL_EA_INFORMATION) &Buffer[UserBufferLength];
             FullEa = (PFILE_FULL_EA_INFORMATION) (FullEa->NextEntryOffset == 0 ?
                                  &Buffer[UserBufferLength] :
                                  (PUCHAR) FullEa + FullEa->NextEntryOffset)) {

            OEM_STRING EaName;
            ULONG Offset;

            EaName.MaximumLength = EaName.Length = FullEa->EaNameLength;
            EaName.Buffer = &FullEa->EaName[0];

            DebugTrace(0, Dbg, "FatCommonSetEa:  Next Ea name -> %Z\n",
                       &EaName);

            //
            //  Make sure the ea name is valid
            //

            if (!FatIsEaNameValid( IrpContext,EaName )) {

                Irp->IoStatus.Information = (PUCHAR)FullEa - Buffer;
                Status = STATUS_INVALID_EA_NAME;
                try_return( Status );
            }

            //
            //  Check that no invalid ea flags are set.
            //

            //
            //  TEMPCODE  We are returning STATUS_INVALID_EA_NAME
            //  until a more appropriate error code exists.
            //

            if (FullEa->Flags != 0
                && FullEa->Flags != FILE_NEED_EA) {

                Irp->IoStatus.Information = (PUCHAR)FullEa - (PUCHAR)Buffer;
                try_return( Status = STATUS_INVALID_EA_NAME );
            }

            //
            //  See if we can locate the ea name in the ea set
            //

            if (FatLocateEaByName( IrpContext,
                                   (PPACKED_EA) EaSetHeader->PackedEas,
                                   PackedEasLength,
                                   &EaName,
                                   &Offset )) {

                DebugTrace(0, Dbg, "FatCommonSetEa:  Found Ea name\n", 0);

                //
                //  We found the ea name so now delete the current entry,
                //  and if the new ea value length is not zero then we
                //  replace if with the new ea
                //

                FatDeletePackedEa( IrpContext,
                                   EaSetHeader,
                                   &PackedEasLength,
                                   Offset );
            }

            if (FullEa->EaValueLength != 0) {

                FatAppendPackedEa( IrpContext,
                                   &EaSetHeader,
                                   &PackedEasLength,
                                   &AllocationLength,
                                   FullEa,
                                   BytesPerCluster );
            }
        }

        //
        //  If there are any ea's not removed, we
        //  call 'AddEaSet' to insert them into the Fat chain.
        //

        if (PackedEasLength != 0) {

            LARGE_INTEGER EaOffset;

            EaOffset.HighPart = 0;

            //
            //  If the packed eas length (plus 4 bytes) is greater
            //  than the maximum allowed ea size, we return an error.
            //

            if (PackedEasLength + 4 > MAXIMUM_EA_SIZE) {

                DebugTrace( 0, Dbg, "Ea length is greater than maximum\n", 0 );

                try_return( Status = STATUS_EA_TOO_LARGE );
            }

            //
            //  We need to now read the ea file if we haven't already.
            //

            if (EaDirent == NULL) {

                FatGetEaFile( IrpContext,
                              Vcb,
                              &EaDirent,
                              &EaBcb,
                              TRUE,
                              TRUE );

                AcquiredEaFcb = TRUE;
            }

            FatGetDirentFromFcbOrDcb( IrpContext, Fcb, &Dirent, &Bcb );

            RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

            FatAddEaSet( IrpContext,
                         Vcb,
                         PackedEasLength + SIZE_OF_EA_SET_HEADER,
                         EaBcb,
                         EaDirent,
                         &EaHandle,
                         &EaSetRange );

            NewEaSetHeader = (PEA_SET_HEADER) EaSetRange.Data;

            DebugTrace(0, Dbg, "FatCommonSetEa:  Adding an ea set\n", 0);

            //
            //  Store the length of the new Ea's into the EaSetHeader.
            //  This is the PackedEasLength + 4.
            //

            PackedEasLength += 4;

            CopyU4char( EaSetHeader->cbList, &PackedEasLength );

            //
            //  Copy all but the first four bytes of EaSetHeader into
            //  NewEaSetHeader.  The signature and index fields have
            //  already been filled in.
            //

            RtlCopyMemory( &NewEaSetHeader->NeedEaCount,
                           &EaSetHeader->NeedEaCount,
                           PackedEasLength + SIZE_OF_EA_SET_HEADER - 8 );

            FatMarkEaRangeDirty( IrpContext, Vcb->VirtualEaFile, &EaSetRange );
            FatUnpinEaRange( IrpContext, &EaSetRange );

            CcFlushCache( Vcb->VirtualEaFile->SectionObjectPointer, NULL, 0, NULL );

        } else {

            FatGetDirentFromFcbOrDcb( IrpContext, Fcb, &Dirent, &Bcb );

            EaHandle = 0;
        }

        //
        //  Now we do a wholesale replacement of the ea for the file
        //

        if (PreviousEas) {

            FatDeleteEaSet( IrpContext,
                            Vcb,
                            EaBcb,
                            EaDirent,
                            ExtendedAttributes,
                            &Fcb->ShortName.Name.Oem );

            CcFlushCache( Vcb->VirtualEaFile->SectionObjectPointer, NULL, 0, NULL );
        }

        if (PackedEasLength != 0 ) {

            Fcb->EaModificationCount++;
        }

        //
        //  Mark the dirent with the new ea's
        //

        Dirent->ExtendedAttributes = EaHandle;

        FatSetDirtyBcb( IrpContext, Bcb, Vcb, TRUE );

        //
        //  We call the notify package to report that the ea's were
        //  modified.
        //

        FatNotifyReportChange( IrpContext,
                               Vcb,
                               Fcb,
                               FILE_NOTIFY_CHANGE_EA,
                               FILE_ACTION_MODIFIED );

        Irp->IoStatus.Information = 0;
        Status = STATUS_SUCCESS;

    try_exit: NOTHING;

        //
        //  Unpin the dirents for the Fcb and EaFcb if necessary.
        //

        FatUnpinBcb( IrpContext, Bcb );
        FatUnpinBcb( IrpContext, EaBcb );

        FatUnpinRepinnedBcbs( IrpContext );

    } finally {

        DebugUnwind( FatCommonSetEa );

        //
        //  If this is an abnormal termination, we need to clean up
        //  any locked resources.
        //

        if (AbnormalTermination()) {

            //
            //  Unpin the dirents for the Fcb, EaFcb and EaSetFcb if necessary.
            //

            FatUnpinBcb( IrpContext, Bcb );
            FatUnpinBcb( IrpContext, EaBcb );

            FatUnpinEaRange( IrpContext, &EaSetRange );
        }

        //
        //  Release the Fcbs/Vcb acquired.
        //

        if (AcquiredEaFcb) {
            FatReleaseFcb( IrpContext, Vcb->EaFcb );
        }

        if (AcquiredFcb) {
            FatReleaseFcb( IrpContext, Fcb );
        }

        if (AcquiredParentDcb) {
            FatReleaseFcb( IrpContext, Fcb->ParentDcb );
        }

        if (AcquiredRootDcb) {
            FatReleaseFcb( IrpContext, Fcb->Vcb->RootDcb );
        }

        if (AcquiredVcb) {
            FatReleaseVcb( IrpContext, Fcb->Vcb );
        }

        //
        //  Deallocate our Ea buffer.
        //

        if (EaSetHeader != NULL) {

            ExFreePool( EaSetHeader );
        }

        //
        //  Complete the irp.
        //

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatCommonSetEa -> %08lx\n", Status);
    }

    //
    //  And return to our caller
    //

    return Status;
}



//
//  Local Support Routine
//

IO_STATUS_BLOCK
FatQueryEaUserEaList (
    IN PIRP_CONTEXT IrpContext,
    OUT PCCB Ccb,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    OUT PUCHAR UserBuffer,
    IN ULONG  UserBufferLength,
    IN PUCHAR UserEaList,
    IN ULONG  UserEaListLength,
    IN BOOLEAN ReturnSingleEntry
    )

/*++

Routine Description:

    This routine is the work routine for querying EAs given an ea index

Arguments:

    Ccb - Supplies the Ccb for the query

    FirstPackedEa - Supplies the first ea for the file being queried

    PackedEasLength - Supplies the length of the ea data

    UserBuffer - Supplies the buffer to receive the full eas

    UserBufferLength - Supplies the length, in bytes, of the user buffer

    UserEaList - Supplies the user specified ea name list

    UserEaListLength - Supplies the length, in bytes, of the user ea list

    ReturnSingleEntry - Indicates if we are to return a single entry or not

Return Value:

    IO_STATUS_BLOCK - Receives the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    ULONG Offset;
    ULONG RemainingUserBufferLength;

    PPACKED_EA PackedEa;
    ULONG PackedEaSize;

    PFILE_FULL_EA_INFORMATION LastFullEa;
    ULONG LastFullEaSize;
    PFILE_FULL_EA_INFORMATION NextFullEa;

    PFILE_GET_EA_INFORMATION GetEa;

    BOOLEAN Overflow;

    DebugTrace(+1, Dbg, "FatQueryEaUserEaList...\n", 0);

    LastFullEa = NULL;
    NextFullEa = (PFILE_FULL_EA_INFORMATION) UserBuffer;
    RemainingUserBufferLength = UserBufferLength;

    Overflow = FALSE;

    for (GetEa = (PFILE_GET_EA_INFORMATION) &UserEaList[0];
         GetEa < (PFILE_GET_EA_INFORMATION) ((PUCHAR) UserEaList
                                             + UserEaListLength);
         GetEa = (GetEa->NextEntryOffset == 0
                  ? (PFILE_GET_EA_INFORMATION) MAXUINT_PTR
                  : (PFILE_GET_EA_INFORMATION) ((PUCHAR) GetEa
                                                + GetEa->NextEntryOffset))) {

        OEM_STRING Str;
        OEM_STRING OutputEaName;

        DebugTrace(0, Dbg, "Top of loop, GetEa = %08lx\n", GetEa);
        DebugTrace(0, Dbg, "LastFullEa = %08lx\n", LastFullEa);
        DebugTrace(0, Dbg, "NextFullEa = %08lx\n", NextFullEa);
        DebugTrace(0, Dbg, "RemainingUserBufferLength = %08lx\n", RemainingUserBufferLength);

        //
        //  Make a string reference to the GetEa and see if we can
        //  locate the ea by name
        //

        Str.MaximumLength = Str.Length = GetEa->EaNameLength;
        Str.Buffer = &GetEa->EaName[0];

        //
        //  Check for a valid name.
        //

        if (!FatIsEaNameValid( IrpContext, Str )) {

            DebugTrace(-1, Dbg,
                       "FatQueryEaUserEaList:  Invalid Ea Name -> %Z\n",
                       &Str);

            Iosb.Information = (PUCHAR)GetEa - UserEaList;
            Iosb.Status = STATUS_INVALID_EA_NAME;
            return Iosb;
        }

        //
        //  If this is a duplicate name, we skip to the next.
        //

        if (FatIsDuplicateEaName( IrpContext, GetEa, UserEaList )) {

            DebugTrace(0, Dbg, "FatQueryEaUserEaList:  Duplicate name\n", 0);
            continue;
        }

        if (!FatLocateEaByName( IrpContext,
                                FirstPackedEa,
                                PackedEasLength,
                                &Str,
                                &Offset )) {

            Offset = 0xffffffff;

            DebugTrace(0, Dbg, "Need to dummy up an ea\n", 0);

            //
            //  We were not able to locate the name therefore we must
            //  dummy up a entry for the query.  The needed Ea size is
            //  the size of the name + 4 (next entry offset) + 1 (flags)
            //  + 1 (name length) + 2 (value length) + the name length +
            //  1 (null byte).
            //

            if ((ULONG)(4+1+1+2+GetEa->EaNameLength+1)
                > RemainingUserBufferLength) {

                Overflow = TRUE;
                break;
            }

            //
            //  Everything is going to work fine, so copy over the name,
            //  set the name length and zero out the rest of the ea.
            //

            NextFullEa->NextEntryOffset = 0;
            NextFullEa->Flags = 0;
            NextFullEa->EaNameLength = GetEa->EaNameLength;
            NextFullEa->EaValueLength = 0;
            RtlCopyMemory( &NextFullEa->EaName[0],
                           &GetEa->EaName[0],
                           GetEa->EaNameLength );

            //
            //  Upcase the name in the buffer.
            //

            OutputEaName.MaximumLength = OutputEaName.Length = Str.Length;
            OutputEaName.Buffer = NextFullEa->EaName;

            FatUpcaseEaName( IrpContext, &OutputEaName, &OutputEaName );

            NextFullEa->EaName[GetEa->EaNameLength] = 0;

        } else {

            DebugTrace(0, Dbg, "Located the ea, Offset = %08lx\n", Offset);

            //
            //  We were able to locate the packed ea
            //  Reference the packed ea
            //

            PackedEa = (PPACKED_EA) ((PUCHAR) FirstPackedEa + Offset);
            SizeOfPackedEa( PackedEa, &PackedEaSize );

            DebugTrace(0, Dbg, "PackedEaSize = %08lx\n", PackedEaSize);

            //
            //  We know that the packed ea is 4 bytes smaller than its
            //  equivalent full ea so we need to check the remaining
            //  user buffer length against the computed full ea size.
            //

            if (PackedEaSize + 4 > RemainingUserBufferLength) {

                Overflow = TRUE;
                break;
            }

            //
            //  Everything is going to work fine, so copy over the packed
            //  ea to the full ea and zero out the next entry offset field.
            //

            RtlCopyMemory( &NextFullEa->Flags,
                           &PackedEa->Flags,
                           PackedEaSize );

            NextFullEa->NextEntryOffset = 0;
        }

        //
        //  At this point we've copied a new full ea into the next full ea
        //  location.  So now go back and set the set full eas entry offset
        //  field to be the difference between out two pointers.
        //

        if (LastFullEa != NULL) {

            LastFullEa->NextEntryOffset = (ULONG)((PUCHAR) NextFullEa
                                          - (PUCHAR) LastFullEa);
        }

        //
        //  Set the last full ea to the next full ea, compute
        //  where the next full should be, and decrement the remaining user
        //  buffer length appropriately
        //

        LastFullEa = NextFullEa;
        LastFullEaSize = LongAlign( SizeOfFullEa( LastFullEa ));
        RemainingUserBufferLength -= LastFullEaSize;
        NextFullEa = (PFILE_FULL_EA_INFORMATION) ((PUCHAR) NextFullEa
                                                  + LastFullEaSize);

        //
        //  Remember the offset of the next ea in case we're asked to
        //  resume the iteration
        //

        Ccb->OffsetOfNextEaToReturn = FatLocateNextEa( IrpContext,
                                                       FirstPackedEa,
                                                       PackedEasLength,
                                                       Offset );

        //
        //  If we were to return a single entry then break out of our loop
        //  now
        //

        if (ReturnSingleEntry) {

            break;
        }
    }

    //
    //  Now we've iterated all that can and we've exited the preceding loop
    //  with either all, some or no information stored in the return buffer.
    //  We can decide if we got everything to fit by checking the local
    //  Overflow variable
    //

    if (Overflow) {

        Iosb.Information = 0;
        Iosb.Status = STATUS_BUFFER_OVERFLOW;

    } else {

        //
        //  Otherwise we've been successful in returing at least one
        //  ea so we'll compute the number of bytes used to store the
        //  full ea information.  The number of bytes used is the difference
        //  between the LastFullEa and the start of the buffer, and the
        //  non-aligned size of the last full ea.
        //

        Iosb.Information = ((PUCHAR) LastFullEa - UserBuffer)
                            + SizeOfFullEa(LastFullEa);

        Iosb.Status = STATUS_SUCCESS;
    }

    DebugTrace(-1, Dbg, "FatQueryEaUserEaList -> Iosb.Status = %08lx\n",
               Iosb.Status);

    return Iosb;
}


//
//  Local Support Routine
//

IO_STATUS_BLOCK
FatQueryEaIndexSpecified (
    IN PIRP_CONTEXT IrpContext,
    OUT PCCB Ccb,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    OUT PUCHAR UserBuffer,
    IN ULONG  UserBufferLength,
    IN ULONG  UserEaIndex,
    IN BOOLEAN ReturnSingleEntry
    )

/*++

Routine Description:

    This routine is the work routine for querying EAs given an ea index

Arguments:

    Ccb - Supplies the Ccb for the query

    FirstPackedEa - Supplies the first ea for the file being queried

    PackedEasLength - Supplies the length of the ea data

    UserBuffer - Supplies the buffer to receive the full eas

    UserBufferLength - Supplies the length, in bytes, of the user buffer

    UserEaIndex - Supplies the index of the first ea to return.

    RestartScan - Indicates if the first item to return is at the
                  beginning of the packed ea list or if we should resume our
                  previous iteration

Return Value:

    IO_STATUS_BLOCK - Receives the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    ULONG i;
    ULONG Offset;

    DebugTrace(+1, Dbg, "FatQueryEaIndexSpecified...\n", 0);

    //
    //  Zero out the information field of the iosb
    //

    Iosb.Information = 0;

    //
    //  If the index value is zero or there are no Eas on the file, then
    //  the specified index can't be returned.
    //

    if (UserEaIndex == 0
        || PackedEasLength == 0) {

        DebugTrace( -1, Dbg, "FatQueryEaIndexSpecified: Non-existant entry\n", 0 );

        Iosb.Status = STATUS_NONEXISTENT_EA_ENTRY;

        return Iosb;
    }

    //
    //  Iterate the eas until we find the index we're after.
    //

    for (i = 1, Offset = 0;
         (i < UserEaIndex) && (Offset < PackedEasLength);
         i += 1, Offset = FatLocateNextEa( IrpContext,
                                           FirstPackedEa,
                                           PackedEasLength, Offset )) {

        NOTHING;
    }

    //
    //  Make sure the offset we're given to the ea is a real offset otherwise
    //  the ea doesn't exist
    //

    if (Offset >= PackedEasLength) {

        //
        //  If we just passed the last Ea, we will return STATUS_NO_MORE_EAS.
        //  This is for the caller who may be enumerating the Eas.
        //

        if (i == UserEaIndex) {

            Iosb.Status = STATUS_NO_MORE_EAS;

        //
        //  Otherwise we report that this is a bad ea index.
        //

        } else {

            Iosb.Status = STATUS_NONEXISTENT_EA_ENTRY;
        }

        DebugTrace(-1, Dbg, "FatQueryEaIndexSpecified -> %08lx\n", Iosb.Status);
        return Iosb;
    }

    //
    //  We now have the offset of the first Ea to return to the user.
    //  We simply call our EaSimpleScan routine to do the actual work.
    //

    Iosb = FatQueryEaSimpleScan( IrpContext,
                                 Ccb,
                                 FirstPackedEa,
                                 PackedEasLength,
                                 UserBuffer,
                                 UserBufferLength,
                                 ReturnSingleEntry,
                                 Offset );

    DebugTrace(-1, Dbg, "FatQueryEaIndexSpecified -> %08lx\n", Iosb.Status);

    return Iosb;

}


//
//  Local Support Routine
//

IO_STATUS_BLOCK
FatQueryEaSimpleScan (
    IN PIRP_CONTEXT IrpContext,
    OUT PCCB Ccb,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    OUT PUCHAR UserBuffer,
    IN ULONG  UserBufferLength,
    IN BOOLEAN ReturnSingleEntry,
    ULONG StartOffset
    )

/*++

Routine Description:

    This routine is the work routine for querying EAs from the beginning of
    the ea list.

Arguments:

    Ccb - Supplies the Ccb for the query

    FirstPackedEa - Supplies the first ea for the file being queried

    PackedEasLength - Supplies the length of the ea data

    UserBuffer - Supplies the buffer to receive the full eas

    UserBufferLength - Supplies the length, in bytes, of the user buffer

    ReturnSingleEntry - Indicates if we are to return a single entry or not

    StartOffset - Indicates the offset within the Ea data to return the
                  first block of data.

Return Value:

    IO_STATUS_BLOCK - Receives the completion status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    ULONG RemainingUserBufferLength;

    PPACKED_EA PackedEa;
    ULONG PackedEaSize;

    PFILE_FULL_EA_INFORMATION LastFullEa;
    ULONG LastFullEaSize;
    PFILE_FULL_EA_INFORMATION NextFullEa;
    BOOLEAN BufferOverflow = FALSE;


    DebugTrace(+1, Dbg, "FatQueryEaSimpleScan...\n", 0);

    //
    //  Zero out the information field in the Iosb
    //

    Iosb.Information = 0;

    LastFullEa = NULL;
    NextFullEa = (PFILE_FULL_EA_INFORMATION) UserBuffer;
    RemainingUserBufferLength = UserBufferLength;

    while (StartOffset < PackedEasLength) {

        DebugTrace(0, Dbg, "Top of loop, Offset = %08lx\n", StartOffset);
        DebugTrace(0, Dbg, "LastFullEa = %08lx\n", LastFullEa);
        DebugTrace(0, Dbg, "NextFullEa = %08lx\n", NextFullEa);
        DebugTrace(0, Dbg, "RemainingUserBufferLength = %08lx\n", RemainingUserBufferLength);

        //
        //  Reference the packed ea of interest.
        //

        PackedEa = (PPACKED_EA) ((PUCHAR) FirstPackedEa + StartOffset);

        SizeOfPackedEa( PackedEa, &PackedEaSize );

        DebugTrace(0, Dbg, "PackedEaSize = %08lx\n", PackedEaSize);

        //
        //  We know that the packed ea is 4 bytes smaller than its
        //  equivalent full ea so we need to check the remaining
        //  user buffer length against the computed full ea size.
        //

        if (PackedEaSize + 4 > RemainingUserBufferLength) {

            BufferOverflow = TRUE;
            break;
        }

        //
        //  Everything is going to work fine, so copy over the packed
        //  ea to the full ea and zero out the next entry offset field.
        //  Then go back and set the last full eas entry offset field
        //  to be the difference between the two pointers.
        //

        RtlCopyMemory( &NextFullEa->Flags, &PackedEa->Flags, PackedEaSize );
        NextFullEa->NextEntryOffset = 0;

        if (LastFullEa != NULL) {

            LastFullEa->NextEntryOffset = (ULONG)((PUCHAR) NextFullEa
                                          - (PUCHAR) LastFullEa);
        }

        //
        //  Set the last full ea to the next full ea, compute
        //  where the next full should be, and decrement the remaining user
        //  buffer length appropriately
        //

        LastFullEa = NextFullEa;
        LastFullEaSize = LongAlign( SizeOfFullEa( LastFullEa ));
        RemainingUserBufferLength -= LastFullEaSize;
        NextFullEa = (PFILE_FULL_EA_INFORMATION) ((PUCHAR) NextFullEa
                                                  + LastFullEaSize);

        //
        //  Remember the offset of the next ea in case we're asked to
        //  resume the teration
        //

        StartOffset = FatLocateNextEa( IrpContext,
                                       FirstPackedEa,
                                       PackedEasLength,
                                       StartOffset );

        Ccb->OffsetOfNextEaToReturn = StartOffset;

        //
        //  If we were to return a single entry then break out of our loop
        //  now
        //

        if (ReturnSingleEntry) {

            break;
        }
    }

    //
    //  Now we've iterated all that can and we've exited the preceding loop
    //  with either some or no information stored in the return buffer.
    //  We can decide which it is by checking if the last full ea is null
    //

    if (LastFullEa == NULL) {

        Iosb.Information = 0;

        //
        //  We were not able to return a single ea entry, now we need to find
        //  out if it is because we didn't have an entry to return or the
        //  buffer is too small.  If the Offset variable is less than
        //  PackedEaList->UsedSize then the user buffer is too small
        //

        if (PackedEasLength == 0) {

            Iosb.Status = STATUS_NO_EAS_ON_FILE;

        } else if (StartOffset >= PackedEasLength) {

            Iosb.Status = STATUS_NO_MORE_EAS;

        } else {

            Iosb.Status = STATUS_BUFFER_TOO_SMALL;
        }

    } else {

        //
        //  Otherwise we've been successful in returing at least one
        //  ea so we'll compute the number of bytes used to store the
        //  full ea information.  The number of bytes used is the difference
        //  between the LastFullEa and the start of the buffer, and the
        //  non-aligned size of the last full ea.
        //

        Iosb.Information = ((PUCHAR) LastFullEa - UserBuffer)
                            + SizeOfFullEa( LastFullEa );

        //
        //  If there are more to return, report the buffer was too small.
        //  Otherwise return STATUS_SUCCESS.
        //

        if (BufferOverflow) {

            Iosb.Status = STATUS_BUFFER_OVERFLOW;

        } else {

            Iosb.Status = STATUS_SUCCESS;
        }
    }

    DebugTrace(-1, Dbg, "FatQueryEaSimpleScan -> Iosb.Status = %08lx\n",
               Iosb.Status);

    return Iosb;

}


//
//  Local Support Routine
//

BOOLEAN
FatIsDuplicateEaName (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_GET_EA_INFORMATION GetEa,
    IN PUCHAR UserBuffer
    )

/*++

Routine Description:

    This routine walks through a list of ea names to find a duplicate name.
    'GetEa' is an actual position in the list.  We are only interested in
    previous matching ea names, as the ea information for that ea name
    would have been returned with the previous instance.

Arguments:

    GetEa - Supplies the Ea name structure for the ea name to match.

    UserBuffer - Supplies a pointer to the user buffer with the list
                 of ea names to search for.

Return Value:

    BOOLEAN - TRUE if a previous match is found, FALSE otherwise.

--*/

{
    PFILE_GET_EA_INFORMATION ThisGetEa;

    BOOLEAN DuplicateFound;
    OEM_STRING EaString;

    DebugTrace(+1, Dbg, "FatIsDuplicateEaName...\n", 0);

    EaString.MaximumLength = EaString.Length = GetEa->EaNameLength;
    EaString.Buffer = &GetEa->EaName[0];

    FatUpcaseEaName( IrpContext, &EaString, &EaString );

    DuplicateFound = FALSE;

    for (ThisGetEa = (PFILE_GET_EA_INFORMATION) &UserBuffer[0];
         ThisGetEa < GetEa
         && ThisGetEa->NextEntryOffset != 0;
         ThisGetEa = (PFILE_GET_EA_INFORMATION) ((PUCHAR) ThisGetEa
                                                 + ThisGetEa->NextEntryOffset)) {

        OEM_STRING Str;

        DebugTrace(0, Dbg, "Top of loop, ThisGetEa = %08lx\n", ThisGetEa);

        //
        //  Make a string reference to the GetEa and see if we can
        //  locate the ea by name
        //

        Str.MaximumLength = Str.Length = ThisGetEa->EaNameLength;
        Str.Buffer = &ThisGetEa->EaName[0];

        DebugTrace(0, Dbg, "FatIsDuplicateEaName:  Next Name -> %Z\n", &Str);

        if ( FatAreNamesEqual(IrpContext, Str, EaString) ) {

            DebugTrace(0, Dbg, "FatIsDuplicateEaName:  Duplicate found\n", 0);
            DuplicateFound = TRUE;
            break;
        }
    }

    DebugTrace(-1, Dbg, "FatIsDuplicateEaName:  Exit -> %04x\n", DuplicateFound);

    return DuplicateFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fatdata.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FatData.c

Abstract:

    This module declares the global data used by the Fat file system.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _FATDATA_
#define _FATDATA_

//
//  The global fsd data record, and a global zero large integer
//

extern FAT_DATA FatData;

extern IO_STATUS_BLOCK FatGarbageIosb;

extern NPAGED_LOOKASIDE_LIST FatIrpContextLookasideList;
extern NPAGED_LOOKASIDE_LIST FatNonPagedFcbLookasideList;
extern NPAGED_LOOKASIDE_LIST FatEResourceLookasideList;

extern PAGED_LOOKASIDE_LIST FatFcbLookasideList;
extern PAGED_LOOKASIDE_LIST FatCcbLookasideList;

extern SLIST_HEADER FatCloseContextSList;
extern FAST_MUTEX FatCloseQueueMutex;

extern PDEVICE_OBJECT FatDiskFileSystemDeviceObject;
extern PDEVICE_OBJECT FatCdromFileSystemDeviceObject;

extern LARGE_INTEGER FatLargeZero;
extern LARGE_INTEGER FatMaxLarge;
extern LARGE_INTEGER Fat30Milliseconds;
extern LARGE_INTEGER Fat100Milliseconds;
extern LARGE_INTEGER FatOneSecond;
extern LARGE_INTEGER FatOneDay;
extern LARGE_INTEGER FatJanOne1980;
extern LARGE_INTEGER FatDecThirtyOne1979;

extern FAT_TIME_STAMP FatTimeJanOne1980;

extern LARGE_INTEGER FatMagic10000;
#define FAT_SHIFT10000 13

extern LARGE_INTEGER FatMagic86400000;
#define FAT_SHIFT86400000 26

#define FatConvert100nsToMilliseconds(LARGE_INTEGER) (                      \
    RtlExtendedMagicDivide( (LARGE_INTEGER), FatMagic10000, FAT_SHIFT10000 )\
    )

#define FatConvertMillisecondsToDays(LARGE_INTEGER) (                       \
    RtlExtendedMagicDivide( (LARGE_INTEGER), FatMagic86400000, FAT_SHIFT86400000 ) \
    )

#define FatConvertDaysToMilliseconds(DAYS) (                                \
    Int32x32To64( (DAYS), 86400000 )                                        \
    )

//
//  Reserve MDL for paging file io forward progress.
//

#define FAT_RESERVE_MDL_SIZE    16

extern PMDL FatReserveMdl;
extern KEVENT FatReserveEvent;

//
//  The global structure used to contain our fast I/O callbacks
//

extern FAST_IO_DISPATCH FatFastIoDispatch;

//
// Read ahead amount used for normal data files
//

#define READ_AHEAD_GRANULARITY           (0x10000)

//
//  Define maximum number of parallel Reads or Writes that will be generated
//  per one request.
//

#define FAT_MAX_IO_RUNS_ON_STACK        ((ULONG) 5)

//
//  Define the maximum number of delayed closes.
//

#define FAT_MAX_DELAYED_CLOSES          ((ULONG)16)

extern ULONG FatMaxDelayedCloseCount;

//
// Define constant for time rounding.
//

#define TenMSec (10*1000*10)
#define TwoSeconds (2*1000*1000*10)
#define AlmostTenMSec (TenMSec - 1)
#define AlmostTwoSeconds (TwoSeconds - 1)

// too big #define HighPartPerDay (24*60*60*1000*1000*10 >> 32)

#define HighPartPerDay (52734375 >> 18)

//
//  The global Fat debug level variable, its values are:
//
//      0x00000000      Always gets printed (used when about to bug check)
//
//      0x00000001      Error conditions
//      0x00000002      Debug hooks
//      0x00000004      Catch exceptions before completing Irp
//      0x00000008
//
//      0x00000010
//      0x00000020
//      0x00000040
//      0x00000080
//
//      0x00000100
//      0x00000200
//      0x00000400
//      0x00000800
//
//      0x00001000
//      0x00002000
//      0x00004000
//      0x00008000
//
//      0x00010000
//      0x00020000
//      0x00040000
//      0x00080000
//
//      0x00100000
//      0x00200000
//      0x00400000
//      0x00800000
//
//      0x01000000
//      0x02000000
//      0x04000000
//      0x08000000
//
//      0x10000000
//      0x20000000
//      0x40000000
//      0x80000000
//

#ifdef FASTFATDBG

#define DEBUG_TRACE_ERROR                (0x00000001)
#define DEBUG_TRACE_DEBUG_HOOKS          (0x00000002)
#define DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00000004)
#define DEBUG_TRACE_UNWIND               (0x00000008)
#define DEBUG_TRACE_CLEANUP              (0x00000010)
#define DEBUG_TRACE_CLOSE                (0x00000020)
#define DEBUG_TRACE_CREATE               (0x00000040)
#define DEBUG_TRACE_DIRCTRL              (0x00000080)
#define DEBUG_TRACE_EA                   (0x00000100)
#define DEBUG_TRACE_FILEINFO             (0x00000200)
#define DEBUG_TRACE_FSCTRL               (0x00000400)
#define DEBUG_TRACE_LOCKCTRL             (0x00000800)
#define DEBUG_TRACE_READ                 (0x00001000)
#define DEBUG_TRACE_VOLINFO              (0x00002000)
#define DEBUG_TRACE_WRITE                (0x00004000)
#define DEBUG_TRACE_FLUSH                (0x00008000)
#define DEBUG_TRACE_DEVCTRL              (0x00010000)
#define DEBUG_TRACE_SHUTDOWN             (0x00020000)
#define DEBUG_TRACE_FATDATA              (0x00040000)
#define DEBUG_TRACE_PNP                  (0x00080000)
#define DEBUG_TRACE_ACCHKSUP             (0x00100000)
#define DEBUG_TRACE_ALLOCSUP             (0x00200000)
#define DEBUG_TRACE_DIRSUP               (0x00400000)
#define DEBUG_TRACE_FILOBSUP             (0x00800000)
#define DEBUG_TRACE_NAMESUP              (0x01000000)
#define DEBUG_TRACE_VERFYSUP             (0x02000000)
#define DEBUG_TRACE_CACHESUP             (0x04000000)
#define DEBUG_TRACE_SPLAYSUP             (0x08000000)
#define DEBUG_TRACE_DEVIOSUP             (0x10000000)
#define DEBUG_TRACE_STRUCSUP             (0x20000000)
#define DEBUG_TRACE_FSP_DISPATCHER       (0x40000000)
#define DEBUG_TRACE_FSP_DUMP             (0x80000000)

extern LONG FatDebugTraceLevel;
extern LONG FatDebugTraceIndent;

#define DebugTrace(INDENT,LEVEL,X,Y) {                      \
    LONG _i;                                                \
    if (((LEVEL) == 0) || (FatDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                   \
        DbgPrint("%08lx:",_i);                              \
        if ((INDENT) < 0) {                                 \
            FatDebugTraceIndent += (INDENT);                \
        }                                                   \
        if (FatDebugTraceIndent < 0) {                      \
            FatDebugTraceIndent = 0;                        \
        }                                                   \
        for (_i = 0; _i < FatDebugTraceIndent; _i += 1) {   \
            DbgPrint(" ");                                  \
        }                                                   \
        DbgPrint(X,Y);                                      \
        if ((INDENT) > 0) {                                 \
            FatDebugTraceIndent += (INDENT);                \
        }                                                   \
    }                                                       \
}

#define DebugDump(STR,LEVEL,PTR) {                          \
    ULONG _i;                                               \
    VOID FatDump(IN PVOID Ptr);                             \
    if (((LEVEL) == 0) || (FatDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                   \
        DbgPrint("%08lx:",_i);                              \
        DbgPrint(STR);                                      \
        if (PTR != NULL) {FatDump(PTR);}                    \
        DbgBreakPoint();                                    \
    }                                                       \
}

#define DebugUnwind(X) {                                                      \
    if (AbnormalTermination()) {                                             \
        DebugTrace(0, DEBUG_TRACE_UNWIND, #X ", Abnormal termination.\n", 0); \
    }                                                                         \
}

//
//  The following variables are used to keep track of the total amount
//  of requests processed by the file system, and the number of requests
//  that end up being processed by the Fsp thread.  The first variable
//  is incremented whenever an Irp context is created (which is always
//  at the start of an Fsd entry point) and the second is incremented
//  by read request.
//

extern ULONG FatFsdEntryCount;
extern ULONG FatFspEntryCount;
extern ULONG FatIoCallDriverCount;
extern ULONG FatTotalTicks[];

#define DebugDoit(X)                     {X;}

extern LONG FatPerformanceTimerLevel;

#define TimerStart(LEVEL) {                     \
    LARGE_INTEGER TStart, TEnd;                 \
    LARGE_INTEGER TElapsed;                     \
    TStart = KeQueryPerformanceCounter( NULL ); \

#define TimerStop(LEVEL,s)                                    \
    TEnd = KeQueryPerformanceCounter( NULL );                 \
    TElapsed.QuadPart = TEnd.QuadPart - TStart.QuadPart;      \
    FatTotalTicks[FatLogOf(LEVEL)] += TElapsed.LowPart;       \
    if (FlagOn( FatPerformanceTimerLevel, (LEVEL))) {         \
        DbgPrint("Time of %s %ld\n", (s), TElapsed.LowPart ); \
    }                                                         \
}

//
//  I need this because C can't support conditional compilation within
//  a macro.
//

extern PVOID FatNull;

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}
#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}
#define DebugUnwind(X)                   {NOTHING;}
#define DebugDoit(X)                     {NOTHING;}

#define TimerStart(LEVEL)
#define TimerStop(LEVEL,s)

#define FatNull NULL

#endif // FASTFATDBG

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just fastfat dbg users
//

#if DBG

#define DbgDoit(X)                       {X;}

#else

#define DbgDoit(X)                       {NOTHING;}

#endif // DBG

#if DBG

extern NTSTATUS FatAssertNotStatus;
extern BOOLEAN FatTestRaisedStatus;

#endif

#endif // _FATDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\easup.c ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    EaSup.c

Abstract:

    This module implements the cluster operations on the EA file for Fat.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]       07-Nov-1990

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatAddEaSet)
#pragma alloc_text(PAGE, FatAppendPackedEa)
#pragma alloc_text(PAGE, FatCreateEa)
#pragma alloc_text(PAGE, FatDeleteEa)
#pragma alloc_text(PAGE, FatDeleteEaSet)
#pragma alloc_text(PAGE, FatDeletePackedEa)
#pragma alloc_text(PAGE, FatGetEaFile)
#pragma alloc_text(PAGE, FatGetEaLength)
#pragma alloc_text(PAGE, FatGetNeedEaCount)
#pragma alloc_text(PAGE, FatIsEaNameValid)
#pragma alloc_text(PAGE, FatLocateEaByName)
#pragma alloc_text(PAGE, FatLocateNextEa)
#pragma alloc_text(PAGE, FatReadEaSet)
#pragma alloc_text(PAGE, FatPinEaRange)
#pragma alloc_text(PAGE, FatMarkEaRangeDirty)
#pragma alloc_text(PAGE, FatUnpinEaRange)
#endif

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))

//
//  Any access to the Ea file must recognize when a section boundary is being
//  crossed.
//

#define EA_SECTION_SIZE             (0x00040000)


VOID
FatGetEaLength (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDIRENT Dirent,
    OUT PULONG EaLength
    )

/*++

Routine Description:

    This routine looks up the Ea length for the Eas of the file.  This
    length is the  length of the packed eas, including the 4 bytes which
    contain the Ea length.

    This routine pins down the Ea set for the desired file and copies
    this field from the Ea set header.

Arguments:

    Vcb - Vcb for the volume containing the Eas.

    Dirent - Supplies a pointer to the dirent for the file in question.

    EaLength - Supplies the address to store the length of the Eas.

Return Value:

    None

--*/

{
    PBCB EaBcb;
    BOOLEAN LockedEaFcb;
    EA_RANGE EaSetRange;

    DebugTrace(+1, Dbg, "FatGetEaLength ...\n", 0);

    //
    //  If this is Fat32 volume, or if the handle is 0 then the Ea length is 0.
    //

    if (FatIsFat32( Vcb ) ||
        Dirent->ExtendedAttributes == 0) {

        *EaLength = 0;
        DebugTrace(-1, Dbg, "FatGetEaLength -> %08lx\n", TRUE);
        return;
    }

    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    //
    //  Use a try to facilitate cleanup.
    //

    try {

        PDIRENT EaDirent;
        OEM_STRING ThisFilename;
        UCHAR Buffer[12];
        PEA_SET_HEADER EaSetHeader;

        //
        //  Initial the local values.
        //

        EaBcb = NULL;
        LockedEaFcb = FALSE;

        //
        //  Try to get the Ea file object.  Return FALSE on failure.
        //

        FatGetEaFile( IrpContext,
                      Vcb,
                      &EaDirent,
                      &EaBcb,
                      FALSE,
                      FALSE );

        LockedEaFcb = TRUE;

        //
        //  If we didn't get the file because it doesn't exist, then the
        //  disk is corrupted.
        //

        if (Vcb->VirtualEaFile == NULL) {

            DebugTrace(0, Dbg, "FatGetEaLength:  Ea file doesn't exist\n", 0);
            FatRaiseStatus( IrpContext, STATUS_NO_EAS_ON_FILE );
        }

        //
        //  Try to pin down the Ea set header for the index in the
        //  dirent.  If the operation doesn't complete, return FALSE
        //  from this routine.
        //

        ThisFilename.Buffer = Buffer;
        Fat8dot3ToString( IrpContext, Dirent, FALSE, &ThisFilename );

        FatReadEaSet( IrpContext,
                      Vcb,
                      Dirent->ExtendedAttributes,
                      &ThisFilename,
                      FALSE,
                      &EaSetRange );

        EaSetHeader = (PEA_SET_HEADER) EaSetRange.Data;

        //
        //  We now have the Ea set header for this file.  We simply copy
        //  the Ea length field.
        //

        CopyUchar4( EaLength, EaSetHeader->cbList );
        DebugTrace(0, Dbg, "FatGetEaLength:  Length of Ea is -> %08lx\n",
                   *EaLength);

    } finally {

        DebugUnwind( FatGetEaLength );

        //
        //  Unpin the EaDirent and the EaSetHeader if pinned.
        //

        FatUnpinBcb( IrpContext, EaBcb );

        FatUnpinEaRange( IrpContext, &EaSetRange );

        //
        //  Release the Fcb for the Ea file if locked.
        //

        if (LockedEaFcb) {

            FatReleaseFcb( IrpContext, Vcb->EaFcb );
        }

        DebugTrace(-1, Dbg, "FatGetEaLength:  Ea length -> %08lx\n", *EaLength);
    }

    return;
}


VOID
FatGetNeedEaCount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDIRENT Dirent,
    OUT PULONG NeedEaCount
    )

/*++

Routine Description:

    This routine looks up the Need Ea count for the file.  The value is the
    in the ea header for the file.

Arguments:

    Vcb - Vcb for the volume containing the Eas.

    Dirent - Supplies a pointer to the dirent for the file in question.

    NeedEaCount - Supplies the address to store the Need Ea count.

Return Value:

    None

--*/

{
    PBCB EaBcb;
    BOOLEAN LockedEaFcb;
    EA_RANGE EaSetRange;

    DebugTrace(+1, Dbg, "FatGetNeedEaCount ...\n", 0);

    //
    //  If the handle is 0 then the Need Ea count is 0.
    //

    if (Dirent->ExtendedAttributes == 0) {

        *NeedEaCount = 0;
        DebugTrace(-1, Dbg, "FatGetNeedEaCount -> %08lx\n", TRUE);
        return;
    }

    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    //
    //  Use a try to facilitate cleanup.
    //

    try {

        PDIRENT EaDirent;
        OEM_STRING ThisFilename;
        UCHAR Buffer[12];
        PEA_SET_HEADER EaSetHeader;

        //
        //  Initial the local values.
        //

        EaBcb = NULL;
        LockedEaFcb = FALSE;

        //
        //  Try to get the Ea file object.  Return FALSE on failure.
        //

        FatGetEaFile( IrpContext,
                      Vcb,
                      &EaDirent,
                      &EaBcb,
                      FALSE,
                      FALSE );

        LockedEaFcb = TRUE;

        //
        //  If we didn't get the file because it doesn't exist, then the
        //  disk is corrupted.
        //

        if (Vcb->VirtualEaFile == NULL) {

            DebugTrace(0, Dbg, "FatGetNeedEaCount:  Ea file doesn't exist\n", 0);
            FatRaiseStatus( IrpContext, STATUS_NO_EAS_ON_FILE );
        }

        //
        //  Try to pin down the Ea set header for the index in the
        //  dirent.  If the operation doesn't complete, return FALSE
        //  from this routine.
        //

        ThisFilename.Buffer = Buffer;
        Fat8dot3ToString( IrpContext, Dirent, FALSE, &ThisFilename );

        FatReadEaSet( IrpContext,
                      Vcb,
                      Dirent->ExtendedAttributes,
                      &ThisFilename,
                      FALSE,
                      &EaSetRange );

        EaSetHeader = (PEA_SET_HEADER) EaSetRange.Data;

        //
        //  We now have the Ea set header for this file.  We simply copy
        //  the Need Ea field.
        //

        *NeedEaCount = EaSetHeader->NeedEaCount;

    } finally {

        DebugUnwind( FatGetNeedEaCount );

        //
        //  Unpin the EaDirent and the EaSetHeader if pinned.
        //

        FatUnpinBcb( IrpContext, EaBcb );

        FatUnpinEaRange( IrpContext, &EaSetRange );

        //
        //  Release the Fcb for the Ea file if locked.
        //

        if (LockedEaFcb) {

            FatReleaseFcb( IrpContext, Vcb->EaFcb );
        }

        DebugTrace(-1, Dbg, "FatGetNeedEaCount:  NeedEaCount -> %08lx\n", *NeedEaCount);
    }

    return;
}


VOID
FatCreateEa (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PUCHAR Buffer,
    IN ULONG Length,
    IN POEM_STRING FileName,
    OUT PUSHORT EaHandle
    )

/*++

Routine Description:

    This routine adds an entire ea set to the Ea file.  The owning file
    is specified in 'FileName'.  This is used to replace the Ea set attached
    to an existing file during a supersede operation.

    NOTE: This routine may block, it should not be called unless the
    thread is waitable.

Arguments:

    Vcb - Supplies the Vcb for the volume.

    Buffer - Buffer with the Ea list to add.

    Length - Length of the buffer.

    FileName - The Ea's will be attached to this file.

    EaHandle - The new ea handle will be assigned to this address.

Return Value:

    None

--*/

{
    PBCB EaBcb;
    BOOLEAN LockedEaFcb;

    PEA_SET_HEADER EaSetHeader;
    EA_RANGE EaSetRange;

    DebugTrace(+1, Dbg, "FatCreateEa...\n", 0);

    EaBcb = NULL;
    LockedEaFcb = FALSE;

    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    //
    //  Use 'try' to facilitate cleanup.
    //

    try {

        PDIRENT EaDirent;

        ULONG PackedEasLength;
        ULONG AllocationLength;
        ULONG BytesPerCluster;

        PFILE_FULL_EA_INFORMATION FullEa;

        //
        //  We will allocate a buffer and copy the Ea list from the user's
        //  buffer to a FAT packed Ea list.  Initial allocation is one
        //  cluster, our starting offset into the packed Ea list is 0.
        //

        PackedEasLength = 0;

        BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

        AllocationLength = (PackedEasLength
                            + SIZE_OF_EA_SET_HEADER
                            + BytesPerCluster - 1)
                           & ~(BytesPerCluster - 1);

        //
        //  Allocate the memory and store the file name into it.
        //

        EaSetHeader = FsRtlAllocatePoolWithTag( PagedPool,
                                                AllocationLength,
                                                TAG_EA_SET_HEADER );

        RtlZeroMemory( EaSetHeader, AllocationLength );

        RtlCopyMemory( EaSetHeader->OwnerFileName,
                       FileName->Buffer,
                       FileName->Length );

        AllocationLength -= SIZE_OF_EA_SET_HEADER;

        //
        //  Loop through the user's Ea list.  Catch any error for invalid
        //  name or non-existent Ea value.
        //

        for ( FullEa = (PFILE_FULL_EA_INFORMATION) Buffer;
              FullEa < (PFILE_FULL_EA_INFORMATION) &Buffer[Length];
              FullEa = (PFILE_FULL_EA_INFORMATION) (FullEa->NextEntryOffset == 0 ?
                                   &Buffer[Length] :
                                   (PUCHAR) FullEa + FullEa->NextEntryOffset)) {

            OEM_STRING EaName;
            ULONG EaOffset;

            EaName.Length = FullEa->EaNameLength;
            EaName.Buffer = &FullEa->EaName[0];

            //
            //  Make sure the ea name is valid
            //

            if (!FatIsEaNameValid( IrpContext, EaName )) {

                DebugTrace(0, Dbg,
                           "FatCreateEa:  Invalid Ea Name -> %Z\n",
                           EaName);

                IrpContext->OriginatingIrp->IoStatus.Information = (PUCHAR)FullEa - Buffer;
                IrpContext->OriginatingIrp->IoStatus.Status = STATUS_INVALID_EA_NAME;
                FatRaiseStatus( IrpContext, STATUS_INVALID_EA_NAME );
            }

            //
            //  Check that no invalid ea flags are set.
            //

            //
            //  TEMPCODE  We are returning STATUS_INVALID_EA_NAME
            //  until a more appropriate error code exists.
            //

            if (FullEa->Flags != 0
                && FullEa->Flags != FILE_NEED_EA) {

                IrpContext->OriginatingIrp->IoStatus.Information = (PUCHAR)FullEa - Buffer;
                IrpContext->OriginatingIrp->IoStatus.Status = STATUS_INVALID_EA_NAME;
                FatRaiseStatus( IrpContext, STATUS_INVALID_EA_NAME );
            }

            //
            //  If this is a duplicate name then delete the current ea
            //  value.
            //

            if (FatLocateEaByName( IrpContext,
                                   (PPACKED_EA) EaSetHeader->PackedEas,
                                   PackedEasLength,
                                   &EaName,
                                   &EaOffset )) {

                DebugTrace(0, Dbg, "FatCreateEa:  Duplicate name found\n", 0);

                FatDeletePackedEa( IrpContext,
                                   EaSetHeader,
                                   &PackedEasLength,
                                   EaOffset );
            }

            //
            //  We ignore this value if the eavalue length is zero.
            //

            if (FullEa->EaValueLength == 0) {

                DebugTrace(0, Dbg,
                           "FatCreateEa:  Empty ea\n",
                           0);

                continue;
            }

            FatAppendPackedEa( IrpContext,
                               &EaSetHeader,
                               &PackedEasLength,
                               &AllocationLength,
                               FullEa,
                               BytesPerCluster );
        }

        //
        //  If the resulting length isn't zero, then allocate a FAT cluster
        //  to store the data.
        //

        if (PackedEasLength != 0) {

            PEA_SET_HEADER NewEaSetHeader;

            //
            //  If the packed eas length (plus 4 bytes) is greater
            //  than the maximum allowed ea size, we return an error.
            //

            if (PackedEasLength + 4 > MAXIMUM_EA_SIZE) {

                DebugTrace( 0, Dbg, "Ea length is greater than maximum\n", 0 );

                FatRaiseStatus( IrpContext, STATUS_EA_TOO_LARGE );
            }

            //
            //  Get the Ea file.
            //

            FatGetEaFile( IrpContext,
                          Vcb,
                          &EaDirent,
                          &EaBcb,
                          TRUE,
                          TRUE );

            LockedEaFcb = TRUE;

            FatAddEaSet( IrpContext,
                         Vcb,
                         PackedEasLength + SIZE_OF_EA_SET_HEADER,
                         EaBcb,
                         EaDirent,
                         EaHandle,
                         &EaSetRange );

            NewEaSetHeader = (PEA_SET_HEADER) EaSetRange.Data;

            //
            //  Store the length of the new Ea's into the NewEaSetHeader.
            //  This is the PackedEasLength + 4.
            //

            PackedEasLength += 4;

            CopyU4char( EaSetHeader->cbList, &PackedEasLength );

            //
            //  Copy all but the first four bytes of EaSetHeader into
            //  the new ea.  The signature and index fields have
            //  already been filled in.
            //

            RtlCopyMemory( &NewEaSetHeader->NeedEaCount,
                           &EaSetHeader->NeedEaCount,
                           PackedEasLength + SIZE_OF_EA_SET_HEADER - 8 );

            FatMarkEaRangeDirty( IrpContext, Vcb->VirtualEaFile, &EaSetRange );
            FatUnpinEaRange( IrpContext, &EaSetRange );

            CcFlushCache( Vcb->VirtualEaFile->SectionObjectPointer, NULL, 0, NULL );

        //
        //  There was no data added to the Ea file.  Return a handle
        //  of 0.
        //

        } else {

            *EaHandle = 0;
        }

    } finally {

        DebugUnwind( FatCreateEa );

        //
        //  Deallocate the EaSetHeader if present.
        //

        if (EaSetHeader) {

            ExFreePool( EaSetHeader );
        }

        //
        //  Release the EaFcb if held.
        //

        if (LockedEaFcb) {

            FatReleaseFcb( IrpContext, Vcb->EaFcb );
        }

        //
        //  Unpin the dirents for the EaFcb and EaSetFcb if necessary.
        //

        FatUnpinBcb( IrpContext, EaBcb );
        FatUnpinEaRange( IrpContext, &EaSetRange );

        DebugTrace(-1, Dbg, "FatCreateEa -> Exit\n", 0);
    }

    return;
}

VOID
FatDeleteEa (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN USHORT EaHandle,
    IN POEM_STRING FileName
    )

/*++

Routine Description:

    This routine is called to remove an entire ea set.  Most of the work
    is done in the call to 'FatDeleteEaSet'.  This routine opens the
    Ea file and then calls the support routine.

    NOTE: This routine may block, it should not be called unless the
    thread is waitable.

Arguments:

    Vcb - Vcb for the volume

    EaHandle - The handle for the Ea's to remove.  This handle will be
               verified during this operation.

    FileName - The name of the file whose Ea's are being removed.  This
               name is compared against the Ea owner's name in the Ea set.

Return Value:

    None.

--*/

{
    PBCB EaBcb;
    BOOLEAN LockedEaFcb;

    DebugTrace(+1, Dbg, "FatDeleteEa...\n", 0);

    //
    //  Initialize local values.
    //

    EaBcb = NULL;
    LockedEaFcb = FALSE;

    //
    //  Use a try statement to facilitate cleanup.
    //

    try {

        PDIRENT EaDirent;

        //
        //  Get the Ea stream file.  If the file doesn't exist on the disk
        //  then the disk has been corrupted.
        //

        FatGetEaFile( IrpContext,
                      Vcb,
                      &EaDirent,
                      &EaBcb,
                      FALSE,
                      TRUE );

        LockedEaFcb = TRUE;

        //
        //  If we didn't get the Ea file, then the disk is corrupt.
        //

        if ( EaBcb == NULL ) {


            DebugTrace(0, Dbg,
                       "FatDeleteEa:  No Ea file exists\n",
                       0);

            FatRaiseStatus( IrpContext, STATUS_NO_EAS_ON_FILE );
        }

        //
        //  We now have everything we need to delete the ea set.  Call the
        //  support routine to do this.
        //

        FatDeleteEaSet( IrpContext,
                        Vcb,
                        EaBcb,
                        EaDirent,
                        EaHandle,
                        FileName );

        CcFlushCache( Vcb->VirtualEaFile->SectionObjectPointer, NULL, 0, NULL );

    } finally {

        DebugUnwind( FatDeleteEa );

        //
        //  Release the EaFcb if held.
        //

        if (LockedEaFcb) {

            FatReleaseFcb( IrpContext, Vcb->EaFcb );
        }

        //
        //  Unpin the dirent for the Ea file if pinned.
        //

        FatUnpinBcb( IrpContext, EaBcb );

        DebugTrace(-1, Dbg, "FatDeleteEa -> Exit\n", 0);
    }

    return;
}


VOID
FatGetEaFile (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    OUT PDIRENT *EaDirent,
    OUT PBCB *EaBcb,
    IN BOOLEAN CreateFile,
    IN BOOLEAN ExclusiveFcb
    )

/*++

Routine Description:

    This routine is used to completely initialize the Vcb and
    the Ea file for the Vcb.

    If the Vcb doesn't have the Ea file object, then we first try to
    lookup the Ea data file in the root directory and if that fails
    we try to create the file.  The 'CreateFile' flag is used to check
    whether it is necessary to create the Ea file.

    This routine will lock down the Fcb for exclusive or shared access before
    performing any operations.  If the operation does not complete due
    to blocking, exclusive or shared access will be given up before returning.

    If we are creating the Ea file and marking sections of it dirty,
    we can't use the repin feature through the cache map.  In that case
    we use a local IrpContext and then unpin all of the Bcb's before
    continuing.

    Note: If this routine will be creating the Ea file, we are guaranteed
    to be waitable.

Arguments:

    Vcb - Vcb for the volume

    EaDirent - Location to store the address of the pinned dirent for the
               Ea file.

    EaBcb - Location to store the address of the Bcb for the pinned dirent.

    CreateFile - Boolean indicating whether we should create the Ea file
                 on the disk.

    ExclusiveFcb - Indicates whether shared or exclusive access is desired
                   for the EaFcb.

Return Value:

    None.

--*/

{
    PFILE_OBJECT EaStreamFile = NULL;
    EA_RANGE EaFileRange;

    BOOLEAN UnwindLockedEaFcb = FALSE;
    BOOLEAN UnwindLockedRootDcb = FALSE;
    BOOLEAN UnwindAllocatedDiskSpace = FALSE;
    BOOLEAN UnwindEaDirentCreated = FALSE;
    BOOLEAN UnwindUpdatedSizes = FALSE;

    DebugTrace(+1, Dbg, "FatGetEaFile ...\n", 0);

    RtlZeroMemory( &EaFileRange, sizeof( EA_RANGE ));

    //
    //  Use a try to facilitate cleanup
    //

    try {

        OEM_STRING EaFileName;
        LARGE_INTEGER SectionSize;

        //
        //  Check if the Vcb already has the file object.  If it doesn't, then
        //  we need to search the root directory for the Ea data file.
        //

        if (Vcb->VirtualEaFile == NULL) {

            //
            //  Always lock the Ea file exclusively if we have to create the file.
            //

            if ( !FatAcquireExclusiveFcb( IrpContext, Vcb->EaFcb )) {

                DebugTrace(0, Dbg, "FatGetEaFile:  Can't grab exclusive\n", 0);
                FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            UnwindLockedEaFcb = TRUE;

        //
        //  Otherwise we acquire the Fcb as the caller requested.
        //

        } else {

            if ((ExclusiveFcb && !FatAcquireExclusiveFcb( IrpContext, Vcb->EaFcb ))
                || (!ExclusiveFcb && !FatAcquireSharedFcb( IrpContext, Vcb->EaFcb))) {

                DebugTrace(0, Dbg, "FatGetEaFile:  Can't grab EaFcb\n", 0);

                FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            UnwindLockedEaFcb = TRUE;

            //
            //  If the file now does not exist we need to release the Fcb and
            //  reacquire exclusive if we acquired shared.
            //

            if ((Vcb->VirtualEaFile == NULL) && !ExclusiveFcb) {

                FatReleaseFcb( IrpContext, Vcb->EaFcb );
                UnwindLockedEaFcb = FALSE;

                if (!FatAcquireExclusiveFcb( IrpContext, Vcb->EaFcb )) {

                    DebugTrace(0, Dbg, "FatGetEaFile:  Can't grab EaFcb\n", 0);

                    FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
                }

                UnwindLockedEaFcb = TRUE;
            }
        }

        //
        //  If the file object is now there we only need to get the
        //  dirent for the Ea file.
        //

        if (Vcb->VirtualEaFile != NULL) {

            FatVerifyFcb( IrpContext, Vcb->EaFcb );

            FatGetDirentFromFcbOrDcb( IrpContext,
                                      Vcb->EaFcb,
                                      EaDirent,
                                      EaBcb );

            try_return( NOTHING );

        } else {

            VBO ByteOffset;

            //
            //  Always mark the ea fcb as good.
            //

            Vcb->EaFcb->FcbCondition = FcbGood;

            //
            //  We try to lookup the dirent for the Ea Fcb.
            //

            EaFileName.Buffer = "EA DATA. SF";
            EaFileName.Length = 11;
            EaFileName.MaximumLength = 12;

            //
            //  Now pick up the root directory to be synchronized with
            //  deletion/creation of entries.  If we may create the file,
            //  get it exclusive right now.
            //
            //  Again, note how we are relying on bottom-up lockorder. We
            //  already got the EaFcb.
            //

            if (CreateFile) {
                ExAcquireResourceExclusiveLite( Vcb->RootDcb->Header.Resource, TRUE );
            } else {
                ExAcquireResourceSharedLite( Vcb->RootDcb->Header.Resource, TRUE );
            }
            UnwindLockedRootDcb = TRUE;

            FatLocateSimpleOemDirent( IrpContext,
                                      Vcb->EaFcb->ParentDcb,
                                      &EaFileName,
                                      EaDirent,
                                      EaBcb,
                                      &ByteOffset );

            //
            //  If the file exists, we need to create the virtual file
            //  object for it.
            //

            if (*EaDirent != NULL) {

                //
                //  Since we may be modifying the dirent, pin the data now.
                //

                FatPinMappedData( IrpContext,
                                  Vcb->EaFcb->ParentDcb,
                                  ByteOffset,
                                  sizeof(DIRENT),
                                  EaBcb );

                //
                //  Update the Fcb with information on the file size
                //  and disk location.  Also increment the open/unclean
                //  counts in the EaFcb and the open count in the
                //  Vcb.
                //

                Vcb->EaFcb->FirstClusterOfFile = (*EaDirent)->FirstClusterOfFile;
                Vcb->EaFcb->DirentOffsetWithinDirectory = ByteOffset;

                //
                //  Find the allocation size.  The purpose here is
                //  really to completely fill in the Mcb for the
                //  file.
                //

                Vcb->EaFcb->Header.AllocationSize.QuadPart = FCB_LOOKUP_ALLOCATIONSIZE_HINT;

                FatLookupFileAllocationSize( IrpContext, Vcb->EaFcb );

                //
                //  Start by computing the section size for the cache
                //  manager.
                //

                SectionSize.QuadPart = (*EaDirent)->FileSize;
                Vcb->EaFcb->Header.AllocationSize = SectionSize;
                Vcb->EaFcb->Header.FileSize = SectionSize;

                //
                //  Create and initialize the file object for the
                //  Ea virtual file.
                //

                EaStreamFile = FatOpenEaFile( IrpContext, Vcb->EaFcb );

                Vcb->VirtualEaFile = EaStreamFile;

            //
            //  Else there was no dirent.  If we were instructed to
            //  create the file object, we will try to create the dirent,
            //  allocate disk space, initialize the Ea file header and
            //  return this information to the user.
            //

            } else if (CreateFile) {

                ULONG BytesPerCluster;
                ULONG OffsetTableSize;
                ULONG AllocationSize;
                PEA_FILE_HEADER FileHeader;
                USHORT AllocatedClusters;
                PUSHORT CurrentIndex;
                ULONG Index;
                NTSTATUS Status;

                DebugTrace(0, Dbg, "FatGetEaFile:  Creating local IrpContext\n", 0);

                BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

                AllocationSize = (((ULONG) sizeof( EA_FILE_HEADER ) << 1) + BytesPerCluster - 1)
                                 & ~(BytesPerCluster - 1);

                AllocatedClusters = (USHORT) (AllocationSize
                                    >> Vcb->AllocationSupport.LogOfBytesPerCluster);

                OffsetTableSize = AllocationSize - sizeof( EA_FILE_HEADER );

                //
                //  Allocate disk space, the space allocated is 1024 bytes
                //  rounded up to the nearest cluster size.
                //

                FatAllocateDiskSpace( IrpContext,
                                      Vcb,
                                      0,
                                      &AllocationSize,
                                      FALSE,
                                      &Vcb->EaFcb->Mcb );

                UnwindAllocatedDiskSpace = TRUE;

                //
                //  Allocate and initialize a dirent in the root directory
                //  to describe this new file.
                //

                Vcb->EaFcb->DirentOffsetWithinDirectory =
                    FatCreateNewDirent( IrpContext,
                                        Vcb->EaFcb->ParentDcb,
                                        1 );

                FatPrepareWriteDirectoryFile( IrpContext,
                                              Vcb->EaFcb->ParentDcb,
                                              Vcb->EaFcb->DirentOffsetWithinDirectory,
                                              sizeof(DIRENT),
                                              EaBcb,
                                              EaDirent,
                                              FALSE,
                                              TRUE,
                                              &Status );

                ASSERT( NT_SUCCESS( Status ));

                UnwindEaDirentCreated = TRUE;

                FatConstructDirent( IrpContext,
                                    *EaDirent,
                                    &EaFileName,
                                    FALSE,
                                    FALSE,
                                    NULL,
                                    FAT_DIRENT_ATTR_READ_ONLY
                                    | FAT_DIRENT_ATTR_HIDDEN
                                    | FAT_DIRENT_ATTR_SYSTEM
                                    | FAT_DIRENT_ATTR_ARCHIVE,
                                    TRUE,
                                    NULL );

                (*EaDirent)->FileSize = AllocationSize;

                //
                //  Initialize the Fcb for this file and initialize the
                //  cache map as well.
                //

                //
                //  Start by computing the section size for the cache
                //  manager.
                //

                SectionSize.QuadPart = (*EaDirent)->FileSize;
                Vcb->EaFcb->Header.AllocationSize = SectionSize;
                Vcb->EaFcb->Header.FileSize = SectionSize;
                UnwindUpdatedSizes = TRUE;

                //
                //  Create and initialize the file object for the
                //  Ea virtual file.
                //

                EaStreamFile = FatOpenEaFile( IrpContext, Vcb->EaFcb );

                //
                //  Update the Fcb with information on the file size
                //  and disk location.  Also increment the open/unclean
                //  counts in the EaFcb and the open count in the
                //  Vcb.
                //

                {
                    LBO FirstLboOfFile;

                    FatLookupMcbEntry( Vcb, &Vcb->EaFcb->Mcb,
                                       0,
                                       &FirstLboOfFile,
                                       NULL,
                                       NULL );

                    //
                    //  The discerning reader will note that this doesn't take
                    //  FAT32 into account, which is of course intentional.
                    //
                    
                    (*EaDirent)->FirstClusterOfFile =
                        (USHORT) FatGetIndexFromLbo( Vcb, FirstLboOfFile );
                }

                Vcb->EaFcb->FirstClusterOfFile = (*EaDirent)->FirstClusterOfFile;

                //
                //  Initialize the Ea file header and mark the Bcb as dirty.
                //

                FatPinEaRange( IrpContext,
                               EaStreamFile,
                               Vcb->EaFcb,
                               &EaFileRange,
                               0,
                               AllocationSize,
                               STATUS_DATA_ERROR );

                FileHeader = (PEA_FILE_HEADER) EaFileRange.Data;

                RtlZeroMemory( FileHeader, AllocationSize );
                FileHeader->Signature = EA_FILE_SIGNATURE;

                for (Index = MAX_EA_BASE_INDEX, CurrentIndex = FileHeader->EaBaseTable;
                     Index;
                     Index--, CurrentIndex++) {

                    *CurrentIndex = AllocatedClusters;
                }

                //
                //  Initialize the offset table with the offset set to
                //  after the just allocated clusters.
                //

                for (Index = OffsetTableSize >> 1,
                        CurrentIndex = (PUSHORT) ((PUCHAR) FileHeader + sizeof( EA_FILE_HEADER ));
                     Index;
                     Index--, CurrentIndex++) {

                    *CurrentIndex = UNUSED_EA_HANDLE;
                }

                //
                //  Unpin the file header and offset table.
                //

                FatMarkEaRangeDirty( IrpContext, EaStreamFile, &EaFileRange );
                FatUnpinEaRange( IrpContext, &EaFileRange );

                CcFlushCache( EaStreamFile->SectionObjectPointer, NULL, 0, NULL );

                //
                //  Return the Ea file object to the user.
                //

                Vcb->VirtualEaFile = EaStreamFile;
            }
        }
    try_exit:  NOTHING;
    } finally {

        DebugUnwind( FatGetEaFile );

        //
        //  If this is abnormal termination and disk space has been
        //  allocated.  We deallocate it now.
        //

        if (AbnormalTermination()) {

            //
            //  Deallocate the Ea file
            //

            if (UnwindAllocatedDiskSpace) {

                FatDeallocateDiskSpace( IrpContext,
                                        Vcb,
                                        &Vcb->EaFcb->Mcb );
            }

            //
            //  Delete the dirent for the Ea file, if created.
            //

            if (UnwindEaDirentCreated) {

                if (UnwindUpdatedSizes) {

                    Vcb->EaFcb->Header.AllocationSize.QuadPart = 0;
                    Vcb->EaFcb->Header.FileSize.QuadPart = 0;
                }

                FatUnpinBcb( IrpContext, *EaBcb );
                FatDeleteDirent( IrpContext, Vcb->EaFcb, NULL, TRUE );
            }

            //
            //  Release the EA Fcb if held
            //

            if (UnwindLockedEaFcb) {

                FatReleaseFcb( IrpContext, Vcb->EaFcb );
            }
            
            //
            //  Dereference the Ea stream file if created.
            //

            if (EaStreamFile != NULL) {

                ObDereferenceObject( EaStreamFile );
            }
        }

        //
        //  Always release the root Dcb (our caller releases the EA Fcb if we
        //  do not raise).
        //
        
        if (UnwindLockedRootDcb) {

            FatReleaseFcb( IrpContext, Vcb->RootDcb );
        }

        //
        //  If the Ea file header is locked down.  We unpin it now.
        //

        FatUnpinEaRange( IrpContext, &EaFileRange );

        DebugTrace(-1, Dbg, "FatGetEaFile:  Exit\n", 0);
    }

    return;
}


VOID
FatReadEaSet (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN USHORT EaHandle,
    IN POEM_STRING FileName,
    IN BOOLEAN ReturnEntireSet,
    OUT PEA_RANGE EaSetRange
    )

/*++

Routine Description:

    This routine pins the Ea set for the given ea handle within the
    Ea stream file.  The EaHandle, after first comparing against valid
    index values, is used to compute the cluster offset for this
    this Ea set.  The Ea set is then verified as belonging to this
    index and lying within the Ea data file.

    The caller of this function will have verified that the Ea file
    exists and that the Vcb field points to an initialized cache file.
    The caller will already have gained exclusive access to the
    EaFcb.

Arguments:

    Vcb - Supplies the Vcb for the volume.

    EaHandle - Supplies the handle for the Ea's to read.

    FileName - Name of the file whose Ea's are being read.

    ReturnEntireSet - Indicates if the caller needs the entire set
        as opposed to just the header.

    EaSetRange - Pointer to the EaRange structure which will describe the Ea
        on return.

Return Value:

    None

--*/

{
    ULONG BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    ULONG EaOffsetVbo;
    EA_RANGE EaOffsetRange;
    USHORT EaOffsetCluster;

    EA_RANGE EaHeaderRange;
    PEA_FILE_HEADER EaHeader;

    ULONG EaSetVbo;
    PEA_SET_HEADER EaSet;

    ULONG CbList;

    DebugTrace(+1, Dbg, "FatReadEaSet\n", 0);
    DebugTrace( 0, Dbg, "  Vcb      = %8lx\n", Vcb);

    //
    //  Verify that the Ea index has a legal value.  Raise status
    //  STATUS_NONEXISTENT_EA_ENTRY if illegal.
    //

    if (EaHandle < MIN_EA_HANDLE
        || EaHandle > MAX_EA_HANDLE) {

        DebugTrace(-1, Dbg, "FatReadEaSet: Illegal handle value\n", 0);
        FatRaiseStatus( IrpContext, STATUS_NONEXISTENT_EA_ENTRY );
    }

    //
    //  Verify that the virtual Ea file is large enough for us to read
    //  the EaOffet table for this index.
    //

    EaOffsetVbo = sizeof( EA_FILE_HEADER ) + ((EaHandle >> 7) << 8);

    //
    //  Zero the Ea range structures.
    //

    RtlZeroMemory( &EaHeaderRange, sizeof( EA_RANGE ));
    RtlZeroMemory( &EaOffsetRange, sizeof( EA_RANGE ));

    //
    //  Use a try statement to clean up on exit.
    //

    try {

        //
        //  Pin down the EA file header.
        //

        FatPinEaRange( IrpContext,
                       Vcb->VirtualEaFile,
                       Vcb->EaFcb,
                       &EaHeaderRange,
                       0,
                       sizeof( EA_FILE_HEADER ),
                       STATUS_NONEXISTENT_EA_ENTRY );

        EaHeader = (PEA_FILE_HEADER) EaHeaderRange.Data;

        //
        //  Pin down the Ea offset table for the particular index.
        //

        FatPinEaRange( IrpContext,
                       Vcb->VirtualEaFile,
                       Vcb->EaFcb,
                       &EaOffsetRange,
                       EaOffsetVbo,
                       sizeof( EA_OFF_TABLE ),
                       STATUS_NONEXISTENT_EA_ENTRY );

        //
        //  Check if the specifific handle is currently being used.
        //

        EaOffsetCluster = *((PUSHORT) EaOffsetRange.Data
                            + (EaHandle & (MAX_EA_OFFSET_INDEX - 1)));

        if (EaOffsetCluster == UNUSED_EA_HANDLE) {

            DebugTrace(0, Dbg, "FatReadEaSet: Ea handle is unused\n", 0);
            FatRaiseStatus( IrpContext, STATUS_NONEXISTENT_EA_ENTRY );
        }

        //
        //  Compute the file offset for the Ea data.
        //

        EaSetVbo = (EaHeader->EaBaseTable[EaHandle >> 7] + EaOffsetCluster)
                   << Vcb->AllocationSupport.LogOfBytesPerCluster;

        //
        //  Unpin the file header and offset table.
        //

        FatUnpinEaRange( IrpContext, &EaHeaderRange );
        FatUnpinEaRange( IrpContext, &EaOffsetRange );

        //
        //  Pin the ea set.
        //

        FatPinEaRange( IrpContext,
                       Vcb->VirtualEaFile,
                       Vcb->EaFcb,
                       EaSetRange,
                       EaSetVbo,
                       BytesPerCluster,
                       STATUS_DATA_ERROR );

        //
        //  Verify that the Ea set is valid and belongs to this index.
        //  Raise STATUS_DATA_ERROR if there is a data conflict.
        //

        EaSet = (PEA_SET_HEADER) EaSetRange->Data;

        if (EaSet->Signature != EA_SET_SIGNATURE
            || EaSet->OwnEaHandle != EaHandle ) {

            DebugTrace(0, Dbg, "FatReadEaSet: Ea set header is corrupt\n", 0);
            FatRaiseStatus( IrpContext, STATUS_DATA_ERROR );
        }

        //
        //  At this point we have pinned a single cluster of Ea data.  If
        //  this represents the entire Ea data for the Ea index, we are
        //  done.  Otherwise we need to check on the entire size of
        //  of the Ea set header and whether it is contained in the allocated
        //  size of the Ea virtual file.  At that point we can unpin
        //  the partial Ea set header and repin the entire header.
        //

        CbList = GetcbList( EaSet );

        if (ReturnEntireSet
            && CbList > BytesPerCluster ) {

            //
            //  Round up to the cluster size.
            //

            CbList = (CbList + EA_CBLIST_OFFSET + BytesPerCluster - 1)
                     & ~(BytesPerCluster - 1);

            FatUnpinEaRange( IrpContext, EaSetRange );

            RtlZeroMemory( EaSetRange, sizeof( EA_RANGE ));

            FatPinEaRange( IrpContext,
                           Vcb->VirtualEaFile,
                           Vcb->EaFcb,
                           EaSetRange,
                           EaSetVbo,
                           CbList,
                           STATUS_DATA_ERROR );
        }

    } finally {

        DebugUnwind( FatReadEaSet );

        //
        //  Unpin the Ea base and offset tables if locked down.
        //

        FatUnpinEaRange( IrpContext, &EaHeaderRange );
        FatUnpinEaRange( IrpContext, &EaOffsetRange );

        DebugTrace(-1, Dbg, "FatReadEaSet:  Exit\n", 0);
    }

    return;
}


VOID
FatDeleteEaSet (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PBCB EaBcb,
    OUT PDIRENT EaDirent,
    IN USHORT EaHandle,
    IN POEM_STRING FileName
    )

/*++

Routine Description:

    This routines clips the Ea set for a particular index out of the
    Ea file for a volume.  The index is verified as belonging to a valid
    handle.  The clusters are removed and the Ea stream file along with
    the Ea base and offset files are updated.

    The caller of this function will have verified that the Ea file
    exists and that the Vcb field points to an initialized cache file.
    The caller will already have gained exclusive access to the
    EaFcb.

Arguments:

    Vcb - Supplies the Vcb for the volume.

    VirtualEeFile - Pointer to the file object for the virtual Ea file.

    EaFcb - Supplies the pointer to the Fcb for the Ea file.

    EaBcb - Supplies a pointer to the Bcb for the Ea dirent.

    EaDirent - Supplies a pointer to the dirent for the Ea file.

    EaHandle - Supplies the handle for the Ea's to read.

    FileName - Name of the file whose Ea's are being read.

Return Value:

    None.

--*/

{
    ULONG BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;
    ULONG CbList;
    LARGE_INTEGER FileOffset;

    LARGE_MCB DataMcb;
    BOOLEAN UnwindInitializeDataMcb = FALSE;
    BOOLEAN UnwindSplitData = FALSE;

    LARGE_MCB TailMcb;
    BOOLEAN UnwindInitializeTailMcb = FALSE;
    BOOLEAN UnwindSplitTail = FALSE;
    BOOLEAN UnwindMergeTail = FALSE;

    BOOLEAN UnwindModifiedEaHeader = FALSE;
    BOOLEAN UnwindCacheValues = FALSE;
    ULONG UnwindPrevFileSize = 0;

    ULONG EaOffsetVbo;
    USHORT EaOffsetIndex;
    EA_RANGE EaOffsetRange;
    USHORT EaOffsetCluster;

    PFILE_OBJECT VirtualEaFile = Vcb->VirtualEaFile;
    PFCB EaFcb = Vcb->EaFcb;

    EA_RANGE EaHeaderRange;
    PEA_FILE_HEADER EaHeader;
    USHORT EaHeaderBaseIndex;

    ULONG EaSetVbo;
    ULONG EaSetLength;
    EA_RANGE EaSetRange;
    PEA_SET_HEADER EaSet;
    USHORT EaSetClusterCount;

    //
    //  Verify that the Ea index has a legal value.  Raise status
    //  STATUS_INVALID_HANDLE if illegal.
    //

    if (EaHandle < MIN_EA_HANDLE
        || EaHandle > MAX_EA_HANDLE) {

        DebugTrace(-1, Dbg, "FatDeleteEaSet: Illegal handle value\n", 0);
        FatRaiseStatus( IrpContext, STATUS_NONEXISTENT_EA_ENTRY );
    }

    //
    //  Verify that the virtual Ea file is large enough for us to read
    //  the EaOffet table for this index.
    //

    EaOffsetVbo = sizeof( EA_FILE_HEADER ) + ((EaHandle >> 7) << 8);

    //
    //  Zero the Ea range structures.
    //

    RtlZeroMemory( &EaHeaderRange, sizeof( EA_RANGE ));
    RtlZeroMemory( &EaOffsetRange, sizeof( EA_RANGE ));
    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    //
    //  Use a try to facilitate cleanup.
    //

    try {

        //
        //  Pin down the EA file header.
        //

        FatPinEaRange( IrpContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaHeaderRange,
                       0,
                       sizeof( EA_FILE_HEADER ),
                       STATUS_NONEXISTENT_EA_ENTRY );

        EaHeader = (PEA_FILE_HEADER) EaHeaderRange.Data;

        //
        //  Pin down the Ea offset table for the particular index.
        //

        FatPinEaRange( IrpContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaOffsetRange,
                       EaOffsetVbo,
                       sizeof( EA_OFF_TABLE ),
                       STATUS_NONEXISTENT_EA_ENTRY );

        //
        //  Check if the specifific handle is currently being used.
        //

        EaOffsetIndex = EaHandle & (MAX_EA_OFFSET_INDEX - 1);
        EaOffsetCluster = *((PUSHORT) EaOffsetRange.Data + EaOffsetIndex);

        if (EaOffsetCluster == UNUSED_EA_HANDLE) {

            DebugTrace(0, Dbg, "FatReadEaSet: Ea handle is unused\n", 0);
            FatRaiseStatus( IrpContext, STATUS_NONEXISTENT_EA_ENTRY );
        }

        //
        //  Compute the file offset for the Ea data.
        //

        EaHeaderBaseIndex = EaHandle >> 7;
        EaSetVbo = (EaHeader->EaBaseTable[EaHeaderBaseIndex] + EaOffsetCluster)
                   << Vcb->AllocationSupport.LogOfBytesPerCluster;

        //
        //  Unpin the file header and offset table.
        //

        FatUnpinEaRange( IrpContext, &EaHeaderRange );
        FatUnpinEaRange( IrpContext, &EaOffsetRange );

        //
        //  Try to pin the requested Ea set.
        //

        FatPinEaRange( IrpContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaSetRange,
                       EaSetVbo,
                       BytesPerCluster,
                       STATUS_DATA_ERROR );

        EaSet = (PEA_SET_HEADER) EaSetRange.Data;

        if (EaSet->Signature != EA_SET_SIGNATURE
            || EaSet->OwnEaHandle != EaHandle ) {

            DebugTrace(0, Dbg, "FatReadEaSet: Ea set header is corrupt\n", 0);
            FatRaiseStatus( IrpContext, STATUS_DATA_ERROR );
        }

        //
        //  At this point we have pinned a single cluster of Ea data.  If
        //  this represents the entire Ea data for the Ea index, we know
        //  the number of clusters to remove.  Otherwise we need to check
        //  on the entire size of the Ea set header and whether it is
        //  contained in the allocated size of the Ea virtual file.  At
        //  that point we unpin the partial Ea set header and remember the
        //  starting cluster offset and number of clusters in both cluster
        //  and Vbo formats.
        //
        //  At that point the following variables have the described
        //  values.
        //
        //      EaSetVbo - Vbo to start splice at.
        //      EaSetLength - Number of bytes to splice.
        //      EaSetClusterCount - Number of clusters to splice.
        //

        CbList = GetcbList( EaSet );

        EaSetClusterCount = (USHORT) ((CbList + EA_CBLIST_OFFSET + BytesPerCluster - 1)
                                      >> Vcb->AllocationSupport.LogOfBytesPerCluster);

        EaSetLength = EaSetClusterCount << Vcb->AllocationSupport.LogOfBytesPerCluster;

        if (EaSetLength > BytesPerCluster) {

            if (EaFcb->Header.FileSize.LowPart - EaSetVbo < EaSetLength) {

                DebugTrace(0, Dbg, "FatDeleteEaSet: Full Ea set not contained in file\n", 0);

                FatRaiseStatus( IrpContext, STATUS_DATA_ERROR );
            }
        }

        FatUnpinEaRange( IrpContext, &EaSetRange );

        //
        //  Update the cache manager for this file.  This is done by
        //  truncating to the point where the data was spliced and
        //  reinitializing with the modified size of the file.
        //
        //  NOTE: Even if the all the EA's are removed the Ea file will
        //  always exist and the header area will never shrink.
        //

        FileOffset.LowPart = EaSetVbo;
        FileOffset.HighPart = 0;

        //
        //  Round the cache map down to a system page boundary.
        //

        FileOffset.LowPart &= ~(PAGE_SIZE - 1);

        //
        //  Make sure all the data gets out to the disk.
        //

        {
            IO_STATUS_BLOCK Iosb;
            ULONG PurgeCount = 5;

            while (--PurgeCount) {

                Iosb.Status = STATUS_SUCCESS;

                CcFlushCache( VirtualEaFile->SectionObjectPointer,
                              NULL,
                              0,
                              &Iosb );

                ASSERT( Iosb.Status == STATUS_SUCCESS );

                //
                //  We do not have to worry about a lazy writer firing in parallel
                //  with our CcFlushCache since we have the EaFcb exclusive.  Thus
                //  we know all data is out.
                //

                //
                //  We throw the unwanted pages out of the cache and then
                //  truncate the Ea File for the new size.
                //

                if (CcPurgeCacheSection( VirtualEaFile->SectionObjectPointer,
                                         &FileOffset,
                                         0,
                                         FALSE )) {

                    break;
                }
            }

            if (!PurgeCount) {

                FatRaiseStatus( IrpContext, STATUS_UNABLE_TO_DELETE_SECTION );
            }
        }

        FileOffset.LowPart = EaFcb->Header.FileSize.LowPart - EaSetLength;

        //
        //  Perform the splice operation on the FAT chain.  This is done
        //  by splitting the target clusters out and merging the remaining
        //  clusters around them.  We can ignore the return value from
        //  the merge and splice functions because we are guaranteed
        //  to be able to block.
        //

        {
            FsRtlInitializeLargeMcb( &DataMcb, PagedPool );

            UnwindInitializeDataMcb = TRUE;

            FatSplitAllocation( IrpContext,
                                Vcb,
                                &EaFcb->Mcb,
                                EaSetVbo,
                                &DataMcb );

            UnwindSplitData = TRUE;

            if (EaSetLength + EaSetVbo != EaFcb->Header.FileSize.LowPart) {

                FsRtlInitializeLargeMcb( &TailMcb, PagedPool );

                UnwindInitializeTailMcb = TRUE;

                FatSplitAllocation( IrpContext,
                                    Vcb,
                                    &DataMcb,
                                    EaSetLength,
                                    &TailMcb );

                UnwindSplitTail = TRUE;

                FatMergeAllocation( IrpContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    &TailMcb );

                UnwindMergeTail = TRUE;
            }
        }

        //
        //  Update the Fcb for the Ea file
        //

        UnwindPrevFileSize = EaFcb->Header.FileSize.LowPart;

        (VOID)ExAcquireResourceExclusiveLite( EaFcb->Header.PagingIoResource,
                                          TRUE );

        EaFcb->Header.FileSize.LowPart = EaFcb->Header.FileSize.LowPart - EaSetLength;
        EaFcb->Header.AllocationSize = EaFcb->Header.FileSize;


        CcSetFileSizes( VirtualEaFile,
                        (PCC_FILE_SIZES)&EaFcb->Header.AllocationSize );

        ExReleaseResourceLite( EaFcb->Header.PagingIoResource );

        UnwindCacheValues = TRUE;

        EaDirent->FileSize = EaFcb->Header.FileSize.LowPart;

        FatSetDirtyBcb( IrpContext, EaBcb, Vcb, TRUE );

        //
        //  Update the Ea base and offset tables.  For the Ea base table,
        //  all subsequent index values must be decremented by the number
        //  of clusters removed.
        //
        //  For the entries in the relevant Ea offset table, all entries
        //  after this index must also be decreased by the number of
        //  clusters removed.
        //

        //
        //  Pin down the EA file header.
        //

        RtlZeroMemory( &EaHeaderRange,
                       sizeof( EA_RANGE ));

        FatPinEaRange( IrpContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaHeaderRange,
                       0,
                       sizeof( EA_FILE_HEADER ),
                       STATUS_NONEXISTENT_EA_ENTRY );

        EaHeader = (PEA_FILE_HEADER) EaHeaderRange.Data;

        //
        //  Pin down the Ea offset table for the particular index.
        //

        RtlZeroMemory( &EaOffsetRange,
                       sizeof( EA_RANGE ));

        FatPinEaRange( IrpContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaOffsetRange,
                       EaOffsetVbo,
                       sizeof( EA_OFF_TABLE ),
                       STATUS_NONEXISTENT_EA_ENTRY );

        {
            ULONG Count;
            PUSHORT NextEaIndex;

            Count = MAX_EA_BASE_INDEX - EaHeaderBaseIndex - 1;

            NextEaIndex = &EaHeader->EaBaseTable[EaHeaderBaseIndex + 1];

            while (Count--) {

                *(NextEaIndex++) -= EaSetClusterCount;
            }

            FatMarkEaRangeDirty( IrpContext, VirtualEaFile, &EaHeaderRange );

            Count = MAX_EA_OFFSET_INDEX - EaOffsetIndex - 1;
            NextEaIndex = (PUSHORT) EaOffsetRange.Data + EaOffsetIndex;

            *(NextEaIndex++) = UNUSED_EA_HANDLE;

            while (Count--) {

                if (*NextEaIndex != UNUSED_EA_HANDLE) {

                    *NextEaIndex -= EaSetClusterCount;
                }

                NextEaIndex++;
            }

            FatMarkEaRangeDirty( IrpContext, VirtualEaFile, &EaOffsetRange );
        }

        UnwindModifiedEaHeader = TRUE;

        //
        //  Deallocate the ea set removed
        //

        FatDeallocateDiskSpace( IrpContext,
                                Vcb,
                                &DataMcb );

    } finally {

        DebugUnwind( FatDeleteEaSet );

        //
        //  Restore file if abnormal termination.
        //
        //  If we have modified the ea file header we ignore this
        //  error.  Otherwise we walk through the state variables.
        //

        if (AbnormalTermination()
            && !UnwindModifiedEaHeader) {

            //
            //  If we modified the Ea dirent or Fcb, recover the previous
            //  values.
            //

            if (UnwindPrevFileSize) {
            
                EaFcb->Header.FileSize.LowPart = UnwindPrevFileSize;
                EaFcb->Header.AllocationSize.LowPart = UnwindPrevFileSize;
                EaDirent->FileSize = UnwindPrevFileSize;

                if (UnwindCacheValues) {

                    CcSetFileSizes( VirtualEaFile,
                                    (PCC_FILE_SIZES)&EaFcb->Header.AllocationSize );
                }
            }
            
            //
            //  If we merged the tail with the
            //  ea file header.  We split it out
            //  again.
            //

            if (UnwindMergeTail) {

                FatSplitAllocation( IrpContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    EaSetVbo,
                                    &TailMcb );
            }

            //
            //  If we split the tail off we merge the tail back
            //  with the ea data to remove.
            //

            if (UnwindSplitTail) {

                FatMergeAllocation( IrpContext,
                                    Vcb,
                                    &DataMcb,
                                    &TailMcb );
            }

            //
            //  If the ea set has been split out, we merge that
            //  cluster string back in the file.  Otherwise we
            //  simply uninitialize the local Mcb.
            //

            if (UnwindSplitData) {

                FatMergeAllocation( IrpContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    &DataMcb );
            }
        }

        //
        //  Unpin any Bcb's still active.
        //

        FatUnpinEaRange( IrpContext, &EaHeaderRange );
        FatUnpinEaRange( IrpContext, &EaOffsetRange );
        FatUnpinEaRange( IrpContext, &EaSetRange );

        //
        //  Uninitialize any initialized Mcbs
        //

        if (UnwindInitializeDataMcb) {

            FsRtlUninitializeLargeMcb( &DataMcb );
        }

        if (UnwindInitializeTailMcb) {

            FsRtlUninitializeLargeMcb( &TailMcb );
        }

        DebugTrace(-1, Dbg, "FatDeleteEaSet -> Exit\n", 0);
    }

    return;
}


VOID
FatAddEaSet (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG EaSetLength,
    IN PBCB EaBcb,
    OUT PDIRENT EaDirent,
    OUT PUSHORT EaHandle,
    OUT PEA_RANGE EaSetRange
    )

/*++

Routine Description:

    This routine will add the necessary clusters to support a new
    Ea set of the given size.  This is done by splicing a chain of
    clusters into the existing Ea file.  An Ea index is assigned to
    this new chain and the Ea base and offset tables are updated to
    include this new handle.  This routine also pins the added
    clusters and returns their address and a Bcb.

    The caller of this function will have verified that the Ea file
    exists and that the Vcb field points to an initialized cache file.
    The caller will already have gained exclusive access to the
    EaFcb.

Arguments:

    Vcb - Supplies the Vcb to fill in.

    EaSetLength - The number of bytes needed to contain the Ea set.  This
        routine will round this up the next cluster size.

    EaBcb - Supplies a pointer to the Bcb for the Ea dirent.

    EaDirent - Supplies a pointer to the dirent for the Ea file.

    EaHandle - Supplies the address to store the ea index generated here.

    EaSetRange - This is the structure that describes new range in the Ea file.

Return Value:

    None.

--*/

{
    ULONG BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    EA_RANGE EaHeaderRange;
    USHORT EaHeaderIndex;
    PEA_FILE_HEADER EaHeader;

    EA_RANGE EaOffsetRange;
    ULONG EaNewOffsetVbo;
    USHORT EaOffsetIndex;
    ULONG EaOffsetTableSize;
    PUSHORT EaOffsetTable;

    ULONG EaSetClusterOffset;
    ULONG EaSetVbo;
    USHORT EaSetClusterCount;
    PEA_SET_HEADER EaSet;

    PFILE_OBJECT VirtualEaFile = Vcb->VirtualEaFile;
    PFCB EaFcb = Vcb->EaFcb;

    LARGE_MCB EaSetMcb;
    BOOLEAN UnwindInitializedEaSetMcb = FALSE;
    BOOLEAN UnwindAllocatedNewAllocation = FALSE;
    BOOLEAN UnwindMergedNewEaSet = FALSE;

    LARGE_MCB EaOffsetMcb;
    BOOLEAN UnwindInitializedOffsetMcb = FALSE;
    BOOLEAN UnwindSplitNewAllocation = FALSE;
    BOOLEAN UnwindMergedNewOffset = FALSE;

    LARGE_MCB EaTailMcb;
    BOOLEAN UnwindInitializedTailMcb = FALSE;
    BOOLEAN UnwindSplitTail = FALSE;
    BOOLEAN UnwindMergedTail = FALSE;

    LARGE_MCB EaInitialEaMcb;
    BOOLEAN UnwindInitializedInitialEaMcb = FALSE;
    BOOLEAN UnwindSplitInitialEa = FALSE;
    BOOLEAN UnwindMergedInitialEa = FALSE;

    USHORT NewEaIndex;
    PUSHORT NextEaOffset;

    ULONG NewAllocation;
    LARGE_INTEGER FileOffset;
    ULONG Count;

    ULONG UnwindPrevFileSize = 0;
    BOOLEAN UnwindCacheValues = FALSE;

    BOOLEAN TailExists = FALSE;
    BOOLEAN AddedOffsetTableCluster = FALSE;
    BOOLEAN UnwindPurgeCacheMap = FALSE;

    DebugTrace(+1, Dbg, "FatAddEaSet\n", 0);
    DebugTrace( 0, Dbg, "  Vcb         = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  EaSetLength = %ul\n", EaSetLength );

    //
    //  Zero the Ea range structures.
    //

    RtlZeroMemory( &EaHeaderRange, sizeof( EA_RANGE ));
    RtlZeroMemory( &EaOffsetRange, sizeof( EA_RANGE ));

    //
    //  Use a try statement to facilitate cleanup.
    //

    try {

        //
        //  Pin down the file header.
        //

        FatPinEaRange( IrpContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaHeaderRange,
                       0,
                       sizeof( EA_FILE_HEADER ),
                       STATUS_DATA_ERROR );

        EaHeader = (PEA_FILE_HEADER) EaHeaderRange.Data;

        //
        //  Compute the size of the offset table.
        //

        EaNewOffsetVbo = EaHeader->EaBaseTable[0] << Vcb->AllocationSupport.LogOfBytesPerCluster;
        EaOffsetTableSize = EaNewOffsetVbo - sizeof( EA_FILE_HEADER );

        //
        //  Pin down the entire offset table.
        //

        FatPinEaRange( IrpContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaOffsetRange,
                       sizeof( EA_FILE_HEADER ),
                       EaOffsetTableSize,
                       STATUS_DATA_ERROR );

        //
        //  We now look for a valid handle out of the existing offset table.
        //  We start at the last entry and walk backwards.  We stop at the
        //  first unused handle which is preceded by a used handle (or handle
        //  1).
        //
        //  As we walk backwards, we need to remember the file offset of the
        //  cluster which will follow the clusters we add.  We initially
        //  remember the end of the file.  If the end of the offset table
        //  consists of a string of used handles, we remember the offset of
        //  the handle prior to the transition from used to unused handles.
        //

        EaSetClusterOffset = EaFcb->Header.FileSize.LowPart
                             >> Vcb->AllocationSupport.LogOfBytesPerCluster;

        NewEaIndex = (USHORT) ((EaOffsetTableSize >> 1) - 1);

        NextEaOffset = (PUSHORT) EaOffsetRange.Data + NewEaIndex;

        //
        //  Walk through the used handles at the end of the offset table.
        //

        if (*NextEaOffset != UNUSED_EA_HANDLE) {

            while (NewEaIndex != 0) {

                if (*(NextEaOffset - 1) == UNUSED_EA_HANDLE) {

                    //
                    //  If the handle is 1, we take no action.  Otherwise
                    //  we save the cluster offset of the current handle
                    //  knowing we will use a previous handle and insert
                    //  a chain of clusters.
                    //

                    if (NewEaIndex != 1) {

                        EaSetClusterOffset = *NextEaOffset
                                             + EaHeader->EaBaseTable[NewEaIndex >> 7];

                        TailExists = TRUE;
                    }

                    NewEaIndex--;
                    NextEaOffset--;

                    break;
                }

                NewEaIndex--;
                NextEaOffset--;
            }
        }

        //
        //  Walk through looking for the first unused handle in a string
        //  of unused handles.
        //

        while (NewEaIndex) {

            if (*(NextEaOffset - 1) != UNUSED_EA_HANDLE) {

                break;
            }

            NextEaOffset--;
            NewEaIndex--;
        }

        //
        //  If the handle is zero, we do a special test to see if handle 1
        //  is available.  Otherwise we will use the first handle of a new
        //  cluster.  A non-zero handle now indicates that a handle was found
        //  in an existing offset table cluster.
        //

        if (NewEaIndex == 0) {

            if (*(NextEaOffset + 1) == UNUSED_EA_HANDLE) {

                NewEaIndex = 1;

            } else {

                NewEaIndex = (USHORT) EaOffsetTableSize >> 1;
                AddedOffsetTableCluster = TRUE;
            }
        }

        //
        //  If the Ea index is outside the legal range then raise an
        //  exception.
        //

        if (NewEaIndex > MAX_EA_HANDLE) {

            DebugTrace(-1, Dbg,
                       "FatAddEaSet: Illegal handle value for new handle\n", 0);

            FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  Compute the base and offset indexes.
        //

        EaHeaderIndex = NewEaIndex >> 7;
        EaOffsetIndex = NewEaIndex & (MAX_EA_OFFSET_INDEX - 1);

        //
        //  Compute the byte offset of the new ea data in the file.
        //

        EaSetVbo = EaSetClusterOffset << Vcb->AllocationSupport.LogOfBytesPerCluster;

        //
        //  Allocate all the required disk space together to insure this
        //  operation is atomic.  We don't want to allocate one block
        //  of disk space and then fail on a second allocation.
        //

        EaSetLength = (EaSetLength + BytesPerCluster - 1)
                      & ~(BytesPerCluster - 1);

        NewAllocation = EaSetLength
                        + (AddedOffsetTableCluster ? BytesPerCluster : 0);

        //
        //  Verify that adding these clusters will not grow the Ea file
        //  beyond its legal value.  The maximum number of clusters is
        //  2^16 since the Ea sets are referenced by a 16 bit cluster
        //  offset value.
        //

        if ((ULONG) ((0x0000FFFF << Vcb->AllocationSupport.LogOfBytesPerCluster)
                     - EaFcb->Header.FileSize.LowPart)
            < NewAllocation) {

            DebugTrace(-1, Dbg,
                       "FatAddEaSet: New Ea file size is too large\n", 0);

            FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        FsRtlInitializeLargeMcb( &EaSetMcb, PagedPool );

        UnwindInitializedEaSetMcb = TRUE;

        FatAllocateDiskSpace( IrpContext,
                              Vcb,
                              0,
                              &NewAllocation,
                              FALSE,
                              &EaSetMcb );

        UnwindAllocatedNewAllocation = TRUE;

        EaSetClusterCount = (USHORT) (EaSetLength >> Vcb->AllocationSupport.LogOfBytesPerCluster);

        if (AddedOffsetTableCluster) {

            FsRtlInitializeLargeMcb( &EaOffsetMcb, PagedPool );

            UnwindInitializedOffsetMcb = TRUE;

            FatSplitAllocation( IrpContext,
                                Vcb,
                                &EaSetMcb,
                                EaSetLength,
                                &EaOffsetMcb );

            UnwindSplitNewAllocation = TRUE;
        }

        FatUnpinEaRange( IrpContext, &EaHeaderRange );
        FatUnpinEaRange( IrpContext, &EaOffsetRange );

        if (AddedOffsetTableCluster) {

            FileOffset.LowPart = EaNewOffsetVbo;

        } else {

            FileOffset.LowPart = EaSetVbo;
        }

        FileOffset.HighPart = 0;

        //
        //  Round the cache map down to a system page boundary.
        //

        FileOffset.LowPart &= ~(PAGE_SIZE - 1);

        {
            IO_STATUS_BLOCK Iosb;
            ULONG PurgeCount = 5;

            while (--PurgeCount) {

                Iosb.Status = STATUS_SUCCESS;

                CcFlushCache( VirtualEaFile->SectionObjectPointer,
                              NULL,
                              0,
                              &Iosb );

                ASSERT( Iosb.Status == STATUS_SUCCESS );

                //
                //  We do not have to worry about a lazy writer firing in parallel
                //  with our CcFlushCache since we have the EaFcb exclusive.  Thus
                //  we know all data is out.
                //

                //
                //  We throw the unwanted pages out of the cache and then
                //  truncate the Ea File for the new size.
                //
                //

                if (CcPurgeCacheSection( VirtualEaFile->SectionObjectPointer,
                                         &FileOffset,
                                         0,
                                         FALSE )) {

                    break;
                }
            }

            if (!PurgeCount) {

                FatRaiseStatus( IrpContext, STATUS_UNABLE_TO_DELETE_SECTION );
            }
        }

        UnwindPurgeCacheMap = TRUE;

        FileOffset.LowPart = EaFcb->Header.FileSize.LowPart + NewAllocation;

        //
        //  If there is a tail to the file, then we initialize an Mcb
        //  for the file section and split the tail from the file.
        //

        if (TailExists) {

            FsRtlInitializeLargeMcb( &EaTailMcb, PagedPool );

            UnwindInitializedTailMcb = TRUE;

            FatSplitAllocation( IrpContext,
                                Vcb,
                                &EaFcb->Mcb,
                                EaSetVbo,
                                &EaTailMcb );

            UnwindSplitTail = TRUE;
        }

        //
        //  If there is an initial section of ea data, we initialize an
        //  Mcb for that section.
        //

        if (AddedOffsetTableCluster
            && EaSetVbo != EaNewOffsetVbo) {

            FsRtlInitializeLargeMcb( &EaInitialEaMcb, PagedPool );

            UnwindInitializedInitialEaMcb = TRUE;

            FatSplitAllocation( IrpContext,
                                Vcb,
                                &EaFcb->Mcb,
                                EaNewOffsetVbo,
                                &EaInitialEaMcb );

            UnwindSplitInitialEa = TRUE;
        }

        //
        //  We have now split the new file allocation into the new
        //  ea set and possibly a new offset table.
        //
        //  We have also split the existing file data into a file
        //  header, an initial section of ea data and the tail of the
        //  file.  These last 2 may not exist.
        //
        //  Each section is described by an Mcb.
        //

        //
        //  Merge the new offset information if it exists.
        //

        if (AddedOffsetTableCluster) {

            FatMergeAllocation( IrpContext,
                                Vcb,
                                &EaFcb->Mcb,
                                &EaOffsetMcb );

            FsRtlUninitializeLargeMcb( &EaOffsetMcb );
            FsRtlInitializeLargeMcb( &EaOffsetMcb, PagedPool );

            UnwindMergedNewOffset = TRUE;
        }

        //
        //  Merge the existing initial ea data if it exists.
        //

        if (UnwindInitializedInitialEaMcb) {

            FatMergeAllocation( IrpContext,
                                Vcb,
                                &EaFcb->Mcb,
                                &EaInitialEaMcb );

            FsRtlUninitializeLargeMcb( &EaInitialEaMcb );
            FsRtlInitializeLargeMcb( &EaInitialEaMcb, PagedPool );

            UnwindMergedInitialEa = TRUE;
        }

        //
        //  We modify the offset of the new ea set by one cluster if
        //  we added one to the offset table.
        //

        if (AddedOffsetTableCluster) {

            EaSetClusterOffset += 1;
            EaSetVbo += BytesPerCluster;
        }

        //
        //  Merge the new ea set.
        //

        FatMergeAllocation( IrpContext,
                            Vcb,
                            &EaFcb->Mcb,
                            &EaSetMcb );

        FsRtlUninitializeLargeMcb( &EaSetMcb );
        FsRtlInitializeLargeMcb( &EaSetMcb, PagedPool );

        UnwindMergedNewEaSet = TRUE;

        //
        //  Merge the tail if it exists.
        //

        if (UnwindInitializedTailMcb) {

            FatMergeAllocation( IrpContext,
                                Vcb,
                                &EaFcb->Mcb,
                                &EaTailMcb );

            FsRtlUninitializeLargeMcb( &EaTailMcb );
            FsRtlInitializeLargeMcb( &EaTailMcb, PagedPool );

            UnwindMergedTail = TRUE;
        }

        //
        //  If we added a new cluster for the offset table, we need to
        //  lock the entire cluster down and initialize all the handles to
        //  the unused state except the first one.
        //

        //
        //  Update the Fcb information.
        //

        UnwindPrevFileSize = EaFcb->Header.FileSize.LowPart;

        EaFcb->Header.FileSize.LowPart += NewAllocation;
        EaFcb->Header.AllocationSize = EaFcb->Header.FileSize;
        EaDirent->FileSize = EaFcb->Header.FileSize.LowPart;

        FatSetDirtyBcb( IrpContext, EaBcb, Vcb, TRUE );

        //
        //  Let Mm and Cc know the new file sizes.
        //

        CcSetFileSizes( VirtualEaFile,
                        (PCC_FILE_SIZES)&EaFcb->Header.AllocationSize );

        UnwindCacheValues = TRUE;

        //
        //  Pin down the file header.
        //

        RtlZeroMemory( &EaHeaderRange, sizeof( EA_RANGE ));

        FatPinEaRange( IrpContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaHeaderRange,
                       0,
                       sizeof( EA_FILE_HEADER ),
                       STATUS_DATA_ERROR );

        EaHeader = (PEA_FILE_HEADER) EaHeaderRange.Data;

        //
        //  Pin down the entire offset table.
        //


        RtlZeroMemory( &EaOffsetRange, sizeof( EA_RANGE ));

        FatPinEaRange( IrpContext,
                       VirtualEaFile,
                       EaFcb,
                       &EaOffsetRange,
                       sizeof( EA_FILE_HEADER ) + ((NewEaIndex >> 7) << 8),
                       sizeof( EA_OFF_TABLE ),
                       STATUS_DATA_ERROR );

        EaOffsetTable = (PUSHORT) EaOffsetRange.Data;

        //
        //  Pin the Ea set header for the added clusters and initialize
        //  the fields of interest.  These are the signature field, the
        //  owning handle field, the need Ea field and the cbList field.
        //  Also mark the data as dirty.
        //

        //
        //  Pin the ea set.
        //

        FatPinEaRange( IrpContext,
                       VirtualEaFile,
                       EaFcb,
                       EaSetRange,
                       EaSetVbo,
                       EaSetLength,
                       STATUS_DATA_ERROR );

        EaSet = (PEA_SET_HEADER) EaSetRange->Data;

        EaSet->Signature = EA_SET_SIGNATURE;
        EaSet->OwnEaHandle = NewEaIndex;

        FatMarkEaRangeDirty( IrpContext, VirtualEaFile, EaSetRange );

        //
        //  Update the Ea base and offset tables.  For the Ea base table,
        //  all subsequent index values must be incremented by the number
        //  of clusters added.
        //
        //  For the entries in the relevant Ea offset table, all entries
        //  after this index must also be increased by the number of
        //  clusters added.
        //
        //  If we added another cluster to the offset table, then we increment
        //  all the base table values by 1.
        //

        Count = MAX_EA_BASE_INDEX - EaHeaderIndex - 1;

        NextEaOffset = &EaHeader->EaBaseTable[EaHeaderIndex + 1];

        while (Count--) {

            *(NextEaOffset++) += EaSetClusterCount;
        }

        if (AddedOffsetTableCluster) {

            Count = MAX_EA_BASE_INDEX;

            NextEaOffset = &EaHeader->EaBaseTable[0];

            while (Count--) {

                *(NextEaOffset++) += 1;
            }
        }

        FatMarkEaRangeDirty( IrpContext, VirtualEaFile, &EaHeaderRange );

        //
        //  If we added an offset table cluster, we need to initialize
        //  the handles to unused.
        //

        if (AddedOffsetTableCluster) {

            Count = (BytesPerCluster >> 1) - 1;
            NextEaOffset = EaOffsetTable;

            *NextEaOffset++ = 0;

            while (Count--) {

                *NextEaOffset++ = UNUSED_EA_HANDLE;
            }
        }

        //
        //  We need to compute the offset of the added Ea set clusters
        //  from their base.
        //

        NextEaOffset = EaOffsetTable + EaOffsetIndex;

        *NextEaOffset++ = (USHORT) (EaSetClusterOffset
                                    - EaHeader->EaBaseTable[EaHeaderIndex]);

        Count = MAX_EA_OFFSET_INDEX - EaOffsetIndex - 1;

        while (Count--) {

            if (*NextEaOffset != UNUSED_EA_HANDLE) {

                *NextEaOffset += EaSetClusterCount;
            }

            NextEaOffset++;
        }

        FatMarkEaRangeDirty( IrpContext, VirtualEaFile, &EaOffsetRange );

        //
        //  Update the callers parameters.
        //

        *EaHandle = NewEaIndex;

        DebugTrace(0, Dbg, "FatAddEaSet: Return values\n", 0);

        DebugTrace(0, Dbg, "FatAddEaSet: New Handle -> %x\n",
                   *EaHandle);

    } finally {

        DebugUnwind( FatAddEaSet );

        //
        //  Handle cleanup for abnormal termination only if we allocated
        //  disk space for the new ea set.
        //

        if (AbnormalTermination() && UnwindAllocatedNewAllocation) {

            //
            //  If we modified the Ea dirent or Fcb, recover the previous
            //  values.  Even though we are decreasing FileSize here, we
            //  don't need to synchronize to synchronize with paging Io
            //  because there was no dirty data generated in the new allocation.
            //

            if (UnwindPrevFileSize) {
            
                EaFcb->Header.FileSize.LowPart = UnwindPrevFileSize;
                EaFcb->Header.AllocationSize.LowPart = UnwindPrevFileSize;
                EaDirent->FileSize = UnwindPrevFileSize;

                if (UnwindCacheValues) {

                    CcSetFileSizes( VirtualEaFile,
                                    (PCC_FILE_SIZES)&EaFcb->Header.AllocationSize );
                }
            }
            
            //
            //  If we merged the tail then split it off.
            //

            if (UnwindMergedTail) {

                VBO NewTailPosition;

                NewTailPosition = EaSetVbo + EaSetLength;

                FatSplitAllocation( IrpContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    NewTailPosition,
                                    &EaTailMcb );
            }

            //
            //  If we merged the new ea data then split it out.
            //

            if (UnwindMergedNewEaSet) {

                FatSplitAllocation( IrpContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    EaSetVbo,
                                    &EaSetMcb );
            }

            //
            //  If we merged the initial ea data then split it out.
            //

            if (UnwindMergedInitialEa) {

                FatSplitAllocation( IrpContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    EaNewOffsetVbo + BytesPerCluster,
                                    &EaInitialEaMcb );
            }

            //
            //  If we added a new offset cluster, then split it out.
            //

            if (UnwindMergedNewOffset) {

                FatSplitAllocation( IrpContext,
                                    Vcb,
                                    &EaFcb->Mcb,
                                    EaNewOffsetVbo,
                                    &EaOffsetMcb );
            }

            //
            //  If there is an initial ea section prior to the new section, merge
            //  it with the rest of the file.
            //

            if (UnwindSplitInitialEa) {

                FatMergeAllocation( IrpContext, Vcb, &EaFcb->Mcb, &EaInitialEaMcb );
            }

            //
            //  If there is a file tail split off, merge it with the
            //  rest of the file.
            //

            if (UnwindSplitTail) {

                FatMergeAllocation( IrpContext, Vcb, &EaFcb->Mcb, &EaTailMcb );
            }

            //
            //  If we modified the cache initialization for the ea file,
            //  then throw away the ea file object.
            //

            if (UnwindPurgeCacheMap) {

                Vcb->VirtualEaFile = NULL;
                ObDereferenceObject( VirtualEaFile );
            }

            //
            //  If we split the allocation, then deallocate the block for
            //  the new offset information.
            //

            if (UnwindSplitNewAllocation) {

                FatDeallocateDiskSpace( IrpContext, Vcb, &EaOffsetMcb );
            }

            //
            //  Deallocate the disk space.
            //

            FatDeallocateDiskSpace( IrpContext, Vcb, &EaSetMcb );
        }

        //
        //  Unpin the Ea ranges.
        //

        FatUnpinEaRange( IrpContext, &EaHeaderRange );
        FatUnpinEaRange( IrpContext, &EaOffsetRange );

        //
        //  Uninitialize any local Mcbs
        //

        if (UnwindInitializedEaSetMcb) {

            FsRtlUninitializeLargeMcb( &EaSetMcb );
        }

        if (UnwindInitializedOffsetMcb) {

            FsRtlUninitializeLargeMcb( &EaOffsetMcb );
        }

        if (UnwindInitializedTailMcb) {

            FsRtlUninitializeLargeMcb( &EaTailMcb );
        }

        if (UnwindInitializedInitialEaMcb) {

            FsRtlUninitializeLargeMcb( &EaInitialEaMcb );
        }

        DebugTrace(-1, Dbg, "FatAddEaSet ->  Exit\n", 0);
    }

    return;
}


VOID
FatAppendPackedEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_SET_HEADER *EaSetHeader,
    IN OUT PULONG PackedEasLength,
    IN OUT PULONG AllocationLength,
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN ULONG BytesPerCluster
    )

/*++

Routine Description:

    This routine appends a new packed ea onto an existing packed ea list,
    it also will allocate/dealloate pool as necessary to hold the ea list.

Arguments:

    EaSetHeader - Supplies the address to store the pointer to pool memory
                  which contains the Ea list for a file.

    PackedEasLength - Supplies the length of the actual Ea data.  The
                      new Ea data will be appended at this point.

    AllocationLength - Supplies the allocated length available for Ea
                       data.

    FullEa - Supplies a pointer to the new full ea that is to be appended
             (in packed form) to the packed ea list.

    BytesPerCluster - Number of bytes per cluster on this volume.

    NOTE: The EaSetHeader refers to the entire block of Ea data for a
          file.  This includes the Ea's and their values as well as the
          header information.  The PackedEasLength and AllocationLength
          parameters refer to the name/value pairs only.

Return Value:

    None.

--*/

{
    ULONG PackedEaSize;
    PPACKED_EA ThisPackedEa;
    OEM_STRING EaName;

    DebugTrace(+1, Dbg, "FatAppendPackedEa...\n", 0);

    //
    //  As a quick check see if the computed packed ea size plus the
    //  current packed ea list size will overflow the buffer.  Full Ea and
    //  packed Ea only differ by 4 in their size
    //

    PackedEaSize = SizeOfFullEa( FullEa ) - 4;

    if ( PackedEaSize + *PackedEasLength > *AllocationLength ) {

        //
        //  We will overflow our current work buffer so allocate a larger
        //  one and copy over the current buffer
        //

        PVOID Temp;
        ULONG NewAllocationSize;
        ULONG OldAllocationSize;

        DebugTrace(0, Dbg, "Allocate a new ea list buffer\n", 0);

        //
        //  Compute a new size and allocate space.  Always increase the
        //  allocation in cluster increments.
        //

        NewAllocationSize = (SIZE_OF_EA_SET_HEADER
                             + PackedEaSize
                             + *PackedEasLength
                             + BytesPerCluster - 1)
                            & ~(BytesPerCluster - 1);

        Temp = FsRtlAllocatePoolWithTag( PagedPool,
                                         NewAllocationSize,
                                         TAG_EA_SET_HEADER );

        //
        //  Move over the existing ea list, and deallocate the old one
        //

        RtlCopyMemory( Temp,
                       *EaSetHeader,
                       OldAllocationSize = *AllocationLength
                                           + SIZE_OF_EA_SET_HEADER );

        ExFreePool( *EaSetHeader );

        //
        //  Set up so we will use the new packed ea list
        //

        *EaSetHeader = Temp;

        //
        //  Zero out the added memory.
        //

        RtlZeroMemory( &(*EaSetHeader)->PackedEas[*AllocationLength],
                       NewAllocationSize - OldAllocationSize );

        *AllocationLength = NewAllocationSize - SIZE_OF_EA_SET_HEADER;
    }

    //
    //  Determine if we need to increment our need ea changes count
    //

    if ( FlagOn(FullEa->Flags, FILE_NEED_EA )) {

        //
        //  The NeedEaCount field is long aligned so we will write
        //  directly to it.
        //

        (*EaSetHeader)->NeedEaCount++;
    }

    //
    //  Now copy over the ea, full ea's and packed ea are identical except
    //  that full ea also have a next ea offset that we skip over
    //
    //  Before:
    //             UsedSize                     Allocated
    //                |                             |
    //                V                             V
    //      +xxxxxxxx+-----------------------------+
    //
    //  After:
    //                              UsedSize    Allocated
    //                                 |            |
    //                                 V            V
    //      +xxxxxxxx+yyyyyyyyyyyyyyyy+------------+
    //

    ThisPackedEa = (PPACKED_EA) (RtlOffsetToPointer( (*EaSetHeader)->PackedEas,
                                                     *PackedEasLength ));

    RtlCopyMemory( ThisPackedEa,
                   (PUCHAR) FullEa + 4,
                   PackedEaSize );

    //
    //  Now convert the name to uppercase.
    //

    EaName.MaximumLength = EaName.Length = FullEa->EaNameLength;
    EaName.Buffer = ThisPackedEa->EaName;

    FatUpcaseEaName( IrpContext, &EaName, &EaName );

    //
    //  Increment the used size in the packed ea list structure
    //

    *PackedEasLength += PackedEaSize;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatAppendPackedEa -> VOID\n", 0);

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}


VOID
FatDeletePackedEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_SET_HEADER EaSetHeader,
    IN OUT PULONG PackedEasLength,
    IN ULONG Offset
    )

/*++

Routine Description:

    This routine deletes an individual packed ea from the supplied
    packed ea list.

Arguments:

    EaSetHeader - Supplies the address to store the pointer to pool memory
                  which contains the Ea list for a file.

    PackedEasLength - Supplies the length of the actual Ea data.  The
                      new Ea data will be appended at this point.

    Offset - Supplies the offset to the individual ea in the list to delete

    NOTE: The EaSetHeader refers to the entire block of Ea data for a
          file.  This includes the Ea's and their values as well as the
          header information.  The PackedEasLength parameter refer to the
          name/value pairs only.

Return Value:

    None.

--*/

{
    PPACKED_EA PackedEa;
    ULONG PackedEaSize;

    DebugTrace(+1, Dbg, "FatDeletePackedEa, Offset = %08lx\n", Offset);

    //
    //  Get a reference to the packed ea and figure out its size
    //

    PackedEa = (PPACKED_EA) (&EaSetHeader->PackedEas[Offset]);

    SizeOfPackedEa( PackedEa, &PackedEaSize );

    //
    //  Determine if we need to decrement our need ea changes count
    //

    if (FlagOn(PackedEa->Flags, EA_NEED_EA_FLAG)) {

        EaSetHeader->NeedEaCount--;
    }

    //
    //  Shrink the ea list over the deleted ea.  The amount to copy is the
    //  total size of the ea list minus the offset to the end of the ea
    //  we're deleting.
    //
    //  Before:
    //              Offset    Offset+PackedEaSize      UsedSize    Allocated
    //                |                |                  |            |
    //                V                V                  V            V
    //      +xxxxxxxx+yyyyyyyyyyyyyyyy+zzzzzzzzzzzzzzzzzz+------------+
    //
    //  After
    //              Offset            UsedSize                     Allocated
    //                |                  |                             |
    //                V                  V                             V
    //      +xxxxxxxx+zzzzzzzzzzzzzzzzzz+-----------------------------+
    //

    RtlCopyMemory( PackedEa,
                   (PUCHAR) PackedEa + PackedEaSize,
                   *PackedEasLength - (Offset + PackedEaSize) );

    //
    //  And zero out the remaing part of the ea list, to make things
    //  nice and more robust
    //

    RtlZeroMemory( &EaSetHeader->PackedEas[*PackedEasLength - PackedEaSize],
                   PackedEaSize );

    //
    //  Decrement the used size by the amount we just removed
    //

    *PackedEasLength -= PackedEaSize;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatDeletePackedEa -> VOID\n", 0);

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}


ULONG
FatLocateNextEa (
    IN PIRP_CONTEXT IrpContext,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    IN ULONG PreviousOffset
    )

/*++

Routine Description:

    This routine locates the offset for the next individual packed ea
    inside of a packed ea list, given the offset to a previous Ea.
    Instead of returing boolean to indicate if we've found the next one
    we let the return offset be so large that it overuns the used size
    of the packed ea list, and that way it's an easy construct to use
    in a for loop.

Arguments:

    FirstPackedEa - Supplies a pointer to the packed ea list structure

    PackedEasLength - Supplies the length of the packed ea list

    PreviousOffset - Supplies the offset to a individual packed ea in the
        list

Return Value:

    ULONG - The offset to the next ea in the list or 0xffffffff of one
        does not exist.

--*/

{
    PPACKED_EA PackedEa;
    ULONG PackedEaSize;
    ULONG Offset;

    DebugTrace(+1, Dbg, "FatLocateNextEa, PreviousOffset = %08lx\n",
               PreviousOffset);

    //
    //  Make sure the previous offset is within the used size range
    //

    if ( PreviousOffset >= PackedEasLength ) {

        DebugTrace(-1, Dbg, "FatLocateNextEa -> 0xffffffff\n", 0);
        return 0xffffffff;
    }

    //
    //  Get a reference to the previous packed ea, and compute its size
    //

    PackedEa = (PPACKED_EA) ((PUCHAR) FirstPackedEa + PreviousOffset );
    SizeOfPackedEa( PackedEa, &PackedEaSize );

    //
    //  Compute to the next ea
    //

    Offset = PreviousOffset + PackedEaSize;

    //
    //  Now, if the new offset is beyond the ea size then we know
    //  that there isn't one so, we return an offset of 0xffffffff.
    //  otherwise we'll leave the new offset alone.
    //

    if ( Offset >= PackedEasLength ) {

        Offset = 0xffffffff;
    }

    DebugTrace(-1, Dbg, "FatLocateNextEa -> %08lx\n", Offset);

    UNREFERENCED_PARAMETER( IrpContext );

    return Offset;
}


BOOLEAN
FatLocateEaByName (
    IN PIRP_CONTEXT IrpContext,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    IN POEM_STRING EaName,
    OUT PULONG Offset
    )

/*++

Routine Description:

    This routine locates the offset for the next individual packed ea
    inside of a packed ea list, given the name of the ea to locate

Arguments:

    FirstPackedEa - Supplies a pointer to the packed ea list structure

    PackedEasLength - Supplies the length of the packed ea list

    EaName - Supplies the name of the ea search for

    Offset - Receives the offset to the located individual ea in the list
        if one exists.

Return Value:

    BOOLEAN - TRUE if the named packed ea exists in the list and FALSE
        otherwise.

--*/

{
    PPACKED_EA PackedEa;
    OEM_STRING Name;

    DebugTrace(+1, Dbg, "FatLocateEaByName, EaName = %Z\n", EaName);

    //
    //  For each packed ea in the list check its name against the
    //  ea name we're searching for
    //

    for ( *Offset = 0;
          *Offset < PackedEasLength;
          *Offset = FatLocateNextEa( IrpContext,
                                     FirstPackedEa,
                                     PackedEasLength,
                                     *Offset )) {

        //
        //  Reference the packed ea and get a string to its name
        //

        PackedEa = (PPACKED_EA) ((PUCHAR) FirstPackedEa + *Offset);

        Name.Buffer = &PackedEa->EaName[0];
        Name.Length = PackedEa->EaNameLength;
        Name.MaximumLength = PackedEa->EaNameLength;

        //
        //  Compare the two strings, if they are equal then we've
        //  found the caller's ea
        //

        if ( RtlCompareString( EaName, &Name, TRUE ) == 0 ) {

            DebugTrace(-1, Dbg, "FatLocateEaByName -> TRUE, *Offset = %08lx\n", *Offset);
            return TRUE;
        }
    }

    //
    //  We've exhausted the ea list without finding a match so return false
    //

    DebugTrace(-1, Dbg, "FatLocateEaByName -> FALSE\n", 0);
    return FALSE;
}


BOOLEAN
FatIsEaNameValid (
    IN PIRP_CONTEXT IrpContext,
    IN OEM_STRING Name
    )

/*++

Routine Description:

    This routine simple returns whether the specified file names conforms
    to the file system specific rules for legal Ea names.

    For Ea names, the following rules apply:

    A. An Ea name may not contain any of the following characters:

       0x0000 - 0x001F  \ / : * ? " < > | , + = [ ] ;

Arguments:

    Name - Supllies the name to check.

Return Value:

    BOOLEAN - TRUE if the name is legal, FALSE otherwise.

--*/

{
    ULONG Index;

    UCHAR Char;

    //
    //  Empty names are not valid.
    //

    if ( Name.Length == 0 ) { return FALSE; }

    //
    //  At this point we should only have a single name, which can't have
    //  more than 254 characters
    //

    if ( Name.Length > 254 ) { return FALSE; }

    for ( Index = 0; Index < (ULONG)Name.Length; Index += 1 ) {

        Char = Name.Buffer[ Index ];

        //
        //  Skip over and Dbcs chacters
        //

        if ( FsRtlIsLeadDbcsCharacter( Char ) ) {

            ASSERT( Index != (ULONG)(Name.Length - 1) );

            Index += 1;

            continue;
        }

        //
        //  Make sure this character is legal, and if a wild card, that
        //  wild cards are permissible.
        //

        if ( !FsRtlIsAnsiCharacterLegalFat(Char, FALSE) ) {

            return FALSE;
        }
    }

    return TRUE;
}


VOID
FatPinEaRange (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT VirtualEaFile,
    IN PFCB EaFcb,
    IN OUT PEA_RANGE EaRange,
    IN ULONG StartingVbo,
    IN ULONG Length,
    IN NTSTATUS ErrorStatus
    )

/*++

Routine Description:

    This routine is called to pin a range within the Ea file.  It will follow all the
    rules required by the cache manager so that we don't have overlapping pin operations.
    If the range being pinned spans a section then the desired data will be copied into
    an auxilary buffer.  FatMarkEaRangeDirty will know whether to copy the data back
    into the cache or whether to simply mark the pinned data dirty.

Arguments:

    VirtualEaFile - This is the stream file for the Ea file.

    EaFcb - This is the Fcb for the Ea file.

    EaRange - This is the Ea range structure for this request.

    StartingVbo - This is the starting offset in the Ea file to read from.

    Length - This is the length of the read.

    ErrorStatus - This is the error status to use if we are reading outside
        of the file.

Return Value:

    None.

--*/

{
    LARGE_INTEGER LargeVbo;
    ULONG ByteCount;
    PBCB *NextBcb;
    PVOID Buffer;
    PCHAR DestinationBuffer;
    BOOLEAN FirstPage = TRUE;

    //
    //  Verify that the entire read is contained within the Ea file.
    //

    if (Length == 0
        || StartingVbo >= EaFcb->Header.AllocationSize.LowPart
        || (EaFcb->Header.AllocationSize.LowPart - StartingVbo) < Length) {

        FatRaiseStatus( IrpContext, ErrorStatus );
    }

    //
    //  If the read will span a section, the system addresses may not be contiguous.
    //  Allocate a separate buffer in this case.
    //

    if (((StartingVbo & (EA_SECTION_SIZE - 1)) + Length) > EA_SECTION_SIZE) {

        EaRange->Data = FsRtlAllocatePoolWithTag( PagedPool,
                                                  Length,
                                                  TAG_EA_DATA );
        EaRange->AuxilaryBuffer = TRUE;

        DestinationBuffer = EaRange->Data;
    
    } else {

        //
        //  PREfix correctly notes that if we don't decide here to have an aux buffer
        //  and the flag is up in the EaRange, we'll party on random memory since
        //  DestinationBuffer won't be set; however, this will never happen due to
        //  initialization of ea ranges and the cleanup in UnpinEaRange.
        //

        ASSERT( EaRange->AuxilaryBuffer == FALSE );
    }


    //
    //  If the read will require more pages than our structure will hold then
    //  allocate an auxilary buffer.  We have to figure the number of pages
    //  being requested so we have to include the page offset of the first page of
    //  the request.
    //

    EaRange->BcbChainLength = (USHORT) (((StartingVbo & (PAGE_SIZE - 1)) + Length + PAGE_SIZE - 1) / PAGE_SIZE);

    if (EaRange->BcbChainLength > EA_BCB_ARRAY_SIZE) {

        EaRange->BcbChain = FsRtlAllocatePoolWithTag( PagedPool,
                                                      sizeof( PBCB ) * EaRange->BcbChainLength,
                                                      TAG_BCB );

        RtlZeroMemory( EaRange->BcbChain, sizeof( PBCB ) * EaRange->BcbChainLength );

    } else {

        EaRange->BcbChain = (PBCB *) &EaRange->BcbArray;
    }

    //
    //  Store the byte range data in the Ea Range structure.
    //

    EaRange->StartingVbo = StartingVbo;
    EaRange->Length = Length;

    //
    //  Compute the initial pin length.
    //

    ByteCount = PAGE_SIZE - (StartingVbo & (PAGE_SIZE - 1));

    //
    //  For each page in the range; pin the page and update the Bcb count, copy to
    //  the auxiliary buffer.
    //

    NextBcb = EaRange->BcbChain;

    while (Length != 0) {

        //
        //  Pin the page and remember the data start.
        //

        LargeVbo.QuadPart = StartingVbo;

        if (ByteCount > Length) {

            ByteCount = Length;
        }

        if (!CcPinRead( VirtualEaFile,
                        &LargeVbo,
                        ByteCount,
                        BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                        NextBcb,
                        &Buffer )) {

            //
            // Could not read the data without waiting (cache miss).
            //

            FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
        }

        //
        //  Increment the Bcb pointer and copy to the auxilary buffer if necessary.
        //

        NextBcb += 1;

        if (EaRange->AuxilaryBuffer == TRUE) {

            RtlCopyMemory( DestinationBuffer,
                           Buffer,
                           ByteCount );

            DestinationBuffer = (PCHAR) Add2Ptr( DestinationBuffer, ByteCount );
        }

        StartingVbo += ByteCount;
        Length -= ByteCount;

        //
        //  If this is the first page then update the Ea Range structure.
        //

        if (FirstPage) {

            FirstPage = FALSE;
            ByteCount = PAGE_SIZE;

            if (EaRange->AuxilaryBuffer == FALSE) {

                EaRange->Data = Buffer;
            }
        }
    }

    return;
}


VOID
FatMarkEaRangeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT EaFileObject,
    IN OUT PEA_RANGE EaRange
    )

/*++

Routine Description:

    This routine is called to mark a range of the Ea file as dirty.  If the modified
    data is sitting in an auxilary buffer then we will copy it back into the cache.
    In any case we will go through the list of Bcb's and mark them dirty.

Arguments:

    EaFileObject - This is the file object for the Ea file.

    EaRange - This is the Ea range structure for this request.

Return Value:

    None.

--*/

{
    PBCB *NextBcb;
    ULONG BcbCount;

    //
    //  If there is an auxilary buffer we need to copy the data back into the cache.
    //

    if (EaRange->AuxilaryBuffer == TRUE) {

        LARGE_INTEGER LargeVbo;

        LargeVbo.QuadPart = EaRange->StartingVbo;

        CcCopyWrite( EaFileObject,
                     &LargeVbo,
                     EaRange->Length,
                     TRUE,
                     EaRange->Data );
    }

    //
    //  Now walk through the Bcb chain and mark everything dirty.
    //

    BcbCount = EaRange->BcbChainLength;
    NextBcb = EaRange->BcbChain;

    while (BcbCount--) {

        if (*NextBcb != NULL) {

            CcSetDirtyPinnedData( *NextBcb, NULL );
        }

        NextBcb += 1;
    }

    return;
}


VOID
FatUnpinEaRange (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_RANGE EaRange
    )

/*++

Routine Description:

    This routine is called to unpin a range in the Ea file.  Any structures allocated
    will be deallocated here.

Arguments:

    EaRange - This is the Ea range structure for this request.

Return Value:

    None.

--*/

{
    PBCB *NextBcb;
    ULONG BcbCount;

    //
    //  If we allocated a auxilary buffer, deallocate it here.
    //

    if (EaRange->AuxilaryBuffer == TRUE) {

        ExFreePool( EaRange->Data );
        EaRange->AuxilaryBuffer = FALSE;
    }

    //
    //  Walk through the Bcb chain and unpin the data.
    //

    if (EaRange->BcbChain != NULL) {

        BcbCount = EaRange->BcbChainLength;
        NextBcb = EaRange->BcbChain;

        while (BcbCount--) {

            if (*NextBcb != NULL) {

                CcUnpinData( *NextBcb );
                *NextBcb = NULL;
            }

            NextBcb += 1;
        }

        //
        //  If we allocated a Bcb chain, deallocate it here.
        //

        if (EaRange->BcbChain != &EaRange->BcbArray[0]) {

            ExFreePool( EaRange->BcbChain );
        }

        EaRange->BcbChain = NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fat.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Fat.h

Abstract:

    This module defines the on-disk structure of the Fat file system.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _FAT_
#define _FAT_

//
//  The following nomenclature is used to describe the Fat on-disk
//  structure:
//
//      LBN - is the number of a sector relative to the start of the disk.
//
//      VBN - is the number of a sector relative to the start of a file,
//          directory, or allocation.
//
//      LBO - is a byte offset relative to the start of the disk.
//
//      VBO - is a byte offset relative to the start of a file, directory
//          or allocation.
//

typedef LONGLONG LBO;    /* for Fat32, LBO is >32 bits */

typedef LBO *PLBO;

typedef ULONG32 VBO;
typedef VBO *PVBO;


//
//  The boot sector is the first physical sector (LBN == 0) on the volume.
//  Part of the sector contains a BIOS Parameter Block.  The BIOS in the
//  sector is packed (i.e., unaligned) so we'll supply a unpacking macro
//  to translate a packed BIOS into its unpacked equivalent.  The unpacked
//  BIOS structure is already defined in ntioapi.h so we only need to define
//  the packed BIOS.
//

//
//  Define the Packed and Unpacked BIOS Parameter Block
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {
    UCHAR  BytesPerSector[2];                       // offset = 0x000  0
    UCHAR  SectorsPerCluster[1];                    // offset = 0x002  2
    UCHAR  ReservedSectors[2];                      // offset = 0x003  3
    UCHAR  Fats[1];                                 // offset = 0x005  5
    UCHAR  RootEntries[2];                          // offset = 0x006  6
    UCHAR  Sectors[2];                              // offset = 0x008  8
    UCHAR  Media[1];                                // offset = 0x00A 10
    UCHAR  SectorsPerFat[2];                        // offset = 0x00B 11
    UCHAR  SectorsPerTrack[2];                      // offset = 0x00D 13
    UCHAR  Heads[2];                                // offset = 0x00F 15
    UCHAR  HiddenSectors[4];                        // offset = 0x011 17
    UCHAR  LargeSectors[4];                         // offset = 0x015 21
} PACKED_BIOS_PARAMETER_BLOCK;                      // sizeof = 0x019 25
typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct _PACKED_BIOS_PARAMETER_BLOCK_EX {
    UCHAR  BytesPerSector[2];                       // offset = 0x000  0
    UCHAR  SectorsPerCluster[1];                    // offset = 0x002  2
    UCHAR  ReservedSectors[2];                      // offset = 0x003  3
    UCHAR  Fats[1];                                 // offset = 0x005  5
    UCHAR  RootEntries[2];                          // offset = 0x006  6
    UCHAR  Sectors[2];                              // offset = 0x008  8
    UCHAR  Media[1];                                // offset = 0x00A 10
    UCHAR  SectorsPerFat[2];                        // offset = 0x00B 11
    UCHAR  SectorsPerTrack[2];                      // offset = 0x00D 13
    UCHAR  Heads[2];                                // offset = 0x00F 15
    UCHAR  HiddenSectors[4];                        // offset = 0x011 17
    UCHAR  LargeSectors[4];                         // offset = 0x015 21
    UCHAR  LargeSectorsPerFat[4];                   // offset = 0x019 25
    UCHAR  ExtendedFlags[2];                        // offset = 0x01D 29
    UCHAR  FsVersion[2];                            // offset = 0x01F 31
    UCHAR  RootDirFirstCluster[4];                  // offset = 0x021 33
    UCHAR  FsInfoSector[2];                         // offset = 0x025 37
    UCHAR  BackupBootSector[2];                     // offset = 0x027 39
    UCHAR  Reserved[12];                            // offset = 0x029 41
} PACKED_BIOS_PARAMETER_BLOCK_EX;                   // sizeof = 0x035 53

typedef PACKED_BIOS_PARAMETER_BLOCK_EX *PPACKED_BIOS_PARAMETER_BLOCK_EX;

//
//  The IsBpbFat32 macro is defined to work with both packed and unpacked
//  BPB structures.  Since we are only checking for zero, the byte order
//  does not matter.
//

#define IsBpbFat32(bpb) (*(USHORT *)(&(bpb)->SectorsPerFat) == 0)

typedef struct BIOS_PARAMETER_BLOCK {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG32  HiddenSectors;
    ULONG32  LargeSectors;
    ULONG32  LargeSectorsPerFat;
    union {
        USHORT ExtendedFlags;
        struct {
            ULONG ActiveFat:4;
            ULONG Reserved0:3;
            ULONG MirrorDisabled:1;
            ULONG Reserved1:8;
        };
    };
    USHORT FsVersion;
    ULONG32 RootDirFirstCluster;
    USHORT FsInfoSector;
    USHORT BackupBootSector;
} BIOS_PARAMETER_BLOCK, *PBIOS_PARAMETER_BLOCK;

//
//  This macro takes a Packed BIOS and fills in its Unpacked equivalent
//

#define FatUnpackBios(Bios,Pbios) {                                         \
    CopyUchar2(&(Bios)->BytesPerSector,    &(Pbios)->BytesPerSector[0]   ); \
    CopyUchar1(&(Bios)->SectorsPerCluster, &(Pbios)->SectorsPerCluster[0]); \
    CopyUchar2(&(Bios)->ReservedSectors,   &(Pbios)->ReservedSectors[0]  ); \
    CopyUchar1(&(Bios)->Fats,              &(Pbios)->Fats[0]             ); \
    CopyUchar2(&(Bios)->RootEntries,       &(Pbios)->RootEntries[0]      ); \
    CopyUchar2(&(Bios)->Sectors,           &(Pbios)->Sectors[0]          ); \
    CopyUchar1(&(Bios)->Media,             &(Pbios)->Media[0]            ); \
    CopyUchar2(&(Bios)->SectorsPerFat,     &(Pbios)->SectorsPerFat[0]    ); \
    CopyUchar2(&(Bios)->SectorsPerTrack,   &(Pbios)->SectorsPerTrack[0]  ); \
    CopyUchar2(&(Bios)->Heads,             &(Pbios)->Heads[0]            ); \
    CopyUchar4(&(Bios)->HiddenSectors,     &(Pbios)->HiddenSectors[0]    ); \
    CopyUchar4(&(Bios)->LargeSectors,      &(Pbios)->LargeSectors[0]     ); \
    CopyUchar4(&(Bios)->LargeSectorsPerFat,&((PPACKED_BIOS_PARAMETER_BLOCK_EX)Pbios)->LargeSectorsPerFat[0]  ); \
    CopyUchar2(&(Bios)->ExtendedFlags,     &((PPACKED_BIOS_PARAMETER_BLOCK_EX)Pbios)->ExtendedFlags[0]       ); \
    CopyUchar2(&(Bios)->FsVersion,         &((PPACKED_BIOS_PARAMETER_BLOCK_EX)Pbios)->FsVersion[0]           ); \
    CopyUchar4(&(Bios)->RootDirFirstCluster,                                \
                                           &((PPACKED_BIOS_PARAMETER_BLOCK_EX)Pbios)->RootDirFirstCluster[0] ); \
    CopyUchar2(&(Bios)->FsInfoSector,      &((PPACKED_BIOS_PARAMETER_BLOCK_EX)Pbios)->FsInfoSector[0]        ); \
    CopyUchar2(&(Bios)->BackupBootSector,  &((PPACKED_BIOS_PARAMETER_BLOCK_EX)Pbios)->BackupBootSector[0]    ); \
}

//
//  Define the boot sector
//

typedef struct _PACKED_BOOT_SECTOR {
    UCHAR Jump[3];                                  // offset = 0x000   0
    UCHAR Oem[8];                                   // offset = 0x003   3
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;          // offset = 0x00B  11
    UCHAR PhysicalDriveNumber;                      // offset = 0x024  36
    UCHAR CurrentHead;                              // offset = 0x025  37
    UCHAR Signature;                                // offset = 0x026  38
    UCHAR Id[4];                                    // offset = 0x027  39
    UCHAR VolumeLabel[11];                          // offset = 0x02B  43
    UCHAR SystemId[8];                              // offset = 0x036  54
} PACKED_BOOT_SECTOR;                               // sizeof = 0x03E  62

typedef PACKED_BOOT_SECTOR *PPACKED_BOOT_SECTOR;

typedef struct _PACKED_BOOT_SECTOR_EX {
    UCHAR Jump[3];                                  // offset = 0x000   0
    UCHAR Oem[8];                                   // offset = 0x003   3
    PACKED_BIOS_PARAMETER_BLOCK_EX PackedBpb;       // offset = 0x00B  11
    UCHAR PhysicalDriveNumber;                      // offset = 0x040  64
    UCHAR CurrentHead;                              // offset = 0x041  65
    UCHAR Signature;                                // offset = 0x042  66
    UCHAR Id[4];                                    // offset = 0x043  67
    UCHAR VolumeLabel[11];                          // offset = 0x047  71
    UCHAR SystemId[8];                              // offset = 0x058  88
} PACKED_BOOT_SECTOR_EX;                            // sizeof = 0x060  96

typedef PACKED_BOOT_SECTOR_EX *PPACKED_BOOT_SECTOR_EX;

//
//  Define the FAT32 FsInfo sector.
//

typedef struct _FSINFO_SECTOR {
    ULONG SectorBeginSignature;                     // offset = 0x000   0
    UCHAR ExtraBootCode[480];                       // offset = 0x004   4
    ULONG FsInfoSignature;                          // offset = 0x1e4 484
    ULONG FreeClusterCount;                         // offset = 0x1e8 488
    ULONG NextFreeCluster;                          // offset = 0x1ec 492
    UCHAR Reserved[12];                             // offset = 0x1f0 496
    ULONG SectorEndSignature;                       // offset = 0x1fc 508
} FSINFO_SECTOR, *PFSINFO_SECTOR;

#define FSINFO_SECTOR_BEGIN_SIGNATURE   0x41615252
#define FSINFO_SECTOR_END_SIGNATURE     0xAA550000

#define FSINFO_SIGNATURE                0x61417272

//
//  We use the CurrentHead field for our dirty partition info.
//

#define FAT_BOOT_SECTOR_DIRTY            0x01
#define FAT_BOOT_SECTOR_TEST_SURFACE     0x02

//
//  Define a Fat Entry type.
//
//  This type is used when representing a fat table entry.  It also used
//  to be used when dealing with a fat table index and a count of entries,
//  but the ensuing type casting nightmare sealed this fate.  These other
//  two types are represented as ULONGs.
//

typedef ULONG32 FAT_ENTRY;

#define FAT32_ENTRY_MASK 0x0FFFFFFFUL

//
//  We use these special index values to set the dirty info for
//  DOS/Win9x compatibility.
//

#define FAT_CLEAN_VOLUME        (~FAT32_ENTRY_MASK | 0)
#define FAT_DIRTY_VOLUME        (~FAT32_ENTRY_MASK | 1)

#define FAT_DIRTY_BIT_INDEX     1

//
//  Physically, the entry is fully set if clean, and the high
//  bit knocked out if it is dirty (i.e., it is really a clean
//  bit).  This means it is different per-FAT size.
//

#define FAT_CLEAN_ENTRY         (~0)

#define FAT12_DIRTY_ENTRY       0x7ff
#define FAT16_DIRTY_ENTRY       0x7fff
#define FAT32_DIRTY_ENTRY       0x7fffffff

//
//  The following constants the are the valid Fat index values.
//

#define FAT_CLUSTER_AVAILABLE            (FAT_ENTRY)0x00000000
#define FAT_CLUSTER_RESERVED             (FAT_ENTRY)0x0ffffff0
#define FAT_CLUSTER_BAD                  (FAT_ENTRY)0x0ffffff7
#define FAT_CLUSTER_LAST                 (FAT_ENTRY)0x0fffffff

//
//  Fat files have the following time/date structures.  Note that the
//  following structure is a 32 bits long but USHORT aligned.
//

typedef struct _FAT_TIME {

    USHORT DoubleSeconds : 5;
    USHORT Minute        : 6;
    USHORT Hour          : 5;

} FAT_TIME;
typedef FAT_TIME *PFAT_TIME;

typedef struct _FAT_DATE {

    USHORT Day           : 5;
    USHORT Month         : 4;
    USHORT Year          : 7; // Relative to 1980

} FAT_DATE;
typedef FAT_DATE *PFAT_DATE;

typedef struct _FAT_TIME_STAMP {

    FAT_TIME Time;
    FAT_DATE Date;

} FAT_TIME_STAMP;
typedef FAT_TIME_STAMP *PFAT_TIME_STAMP;

//
//  Fat files have 8 character file names and 3 character extensions
//

typedef UCHAR FAT8DOT3[11];
typedef FAT8DOT3 *PFAT8DOT3;


//
//  The directory entry record exists for every file/directory on the
//  disk except for the root directory.
//

typedef struct _PACKED_DIRENT {
    FAT8DOT3       FileName;                         //  offset =  0
    UCHAR          Attributes;                       //  offset = 11
    UCHAR          NtByte;                           //  offset = 12
    UCHAR          CreationMSec;                     //  offset = 13
    FAT_TIME_STAMP CreationTime;                     //  offset = 14
    FAT_DATE       LastAccessDate;                   //  offset = 18
    union {
        USHORT     ExtendedAttributes;               //  offset = 20
        USHORT     FirstClusterOfFileHi;             //  offset = 20
    };
    FAT_TIME_STAMP LastWriteTime;                    //  offset = 22
    USHORT         FirstClusterOfFile;               //  offset = 26
    ULONG32        FileSize;                         //  offset = 28
} PACKED_DIRENT;                                     //  sizeof = 32
typedef PACKED_DIRENT *PPACKED_DIRENT;

//
//  A packed dirent is already quadword aligned so simply declare a dirent as a
//  packed dirent
//

typedef PACKED_DIRENT DIRENT;
typedef DIRENT *PDIRENT;

//
//  The first byte of a dirent describes the dirent.  There is also a routine
//  to help in deciding how to interpret the dirent.
//

#define FAT_DIRENT_NEVER_USED            0x00
#define FAT_DIRENT_REALLY_0E5            0x05
#define FAT_DIRENT_DIRECTORY_ALIAS       0x2e
#define FAT_DIRENT_DELETED               0xe5

//
//  Define the NtByte bits.
//

#define FAT_DIRENT_NT_BYTE_8_LOWER_CASE  0x08
#define FAT_DIRENT_NT_BYTE_3_LOWER_CASE  0x10

//
//  Define the various dirent attributes
//

#define FAT_DIRENT_ATTR_READ_ONLY        0x01
#define FAT_DIRENT_ATTR_HIDDEN           0x02
#define FAT_DIRENT_ATTR_SYSTEM           0x04
#define FAT_DIRENT_ATTR_VOLUME_ID        0x08
#define FAT_DIRENT_ATTR_DIRECTORY        0x10
#define FAT_DIRENT_ATTR_ARCHIVE          0x20
#define FAT_DIRENT_ATTR_DEVICE           0x40
#define FAT_DIRENT_ATTR_LFN              (FAT_DIRENT_ATTR_READ_ONLY | \
                                          FAT_DIRENT_ATTR_HIDDEN |    \
                                          FAT_DIRENT_ATTR_SYSTEM |    \
                                          FAT_DIRENT_ATTR_VOLUME_ID)


//
//  These macros convert a number of fields in the Bpb to bytes from sectors
//
//      ULONG
//      FatBytesPerCluster (
//          IN PBIOS_PARAMETER_BLOCK Bios
//      );
//
//      ULONG
//      FatBytesPerFat (
//          IN PBIOS_PARAMETER_BLOCK Bios
//      );
//
//      ULONG
//      FatReservedBytes (
//          IN PBIOS_PARAMETER_BLOCK Bios
//      );
//

#define FatBytesPerCluster(B) ((ULONG)((B)->BytesPerSector * (B)->SectorsPerCluster))

#define FatBytesPerFat(B) (IsBpbFat32(B)?                           \
    ((ULONG)((B)->BytesPerSector * (B)->LargeSectorsPerFat)) :      \
    ((ULONG)((B)->BytesPerSector * (B)->SectorsPerFat)))

#define FatReservedBytes(B) ((ULONG)((B)->BytesPerSector * (B)->ReservedSectors))

//
//  This macro returns the size of the root directory dirent area in bytes
//  For Fat32, the root directory is variable in length.  This macro returns
//  0 because it is also used to determine the location of cluster 2.
//
//      ULONG
//      FatRootDirectorySize (
//          IN PBIOS_PARAMETER_BLOCK Bios
//          );
//

#define FatRootDirectorySize(B) ((ULONG)((B)->RootEntries * sizeof(DIRENT)))


//
//  This macro returns the first Lbo (zero based) of the root directory on
//  the device.  This area is after the reserved and fats.
//
//  For Fat32, the root directory is moveable.  This macro returns the LBO
//  for cluster 2 because it is used to determine the location of cluster 2.
//  FatRootDirectoryLbo32() returns the actual LBO of the beginning of the
//  actual root directory.
//
//      LBO
//      FatRootDirectoryLbo (
//          IN PBIOS_PARAMETER_BLOCK Bios
//          );
//

#define FatRootDirectoryLbo(B) (FatReservedBytes(B) + ((B)->Fats * FatBytesPerFat(B)))
#define FatRootDirectoryLbo32(B) (FatFileAreaLbo(B)+((B)->RootDirFirstCluster-2)*FatBytesPerCluster(B))

//
//  This macro returns the first Lbo (zero based) of the file area on the
//  the device.  This area is after the reserved, fats, and root directory.
//
//      LBO
//      FatFirstFileAreaLbo (
//          IN PBIOS_PARAMTER_BLOCK Bios
//          );
//

#define FatFileAreaLbo(B) (FatRootDirectoryLbo(B) + FatRootDirectorySize(B))

//
//  This macro returns the number of clusters on the disk.  This value is
//  computed by taking the total sectors on the disk subtracting up to the
//  first file area sector and then dividing by the sectors per cluster count.
//  Note that I don't use any of the above macros since far too much
//  superfluous sector/byte conversion would take place.
//
//      ULONG
//      FatNumberOfClusters (
//          IN PBIOS_PARAMETER_BLOCK Bios
//          );
//

//
// for prior to MS-DOS Version 3.2
//
// After DOS 4.0, at least one of these, Sectors or LargeSectors, will be zero.
// but DOS version 3.2 case, both of these value might contains some value,
// because, before 3.2, we don't have Large Sector entry, some disk might have
// unexpected value in the field, we will use LargeSectors if Sectors eqaul to zero.
//

#define FatNumberOfClusters(B) (                                         \
                                                                         \
  IsBpbFat32(B) ?                                                        \
                                                                         \
    ((((B)->Sectors ? (B)->Sectors : (B)->LargeSectors)                  \
                                                                         \
        -   ((B)->ReservedSectors +                                      \
             (B)->Fats * (B)->LargeSectorsPerFat ))                      \
                                                                         \
                                    /                                    \
                                                                         \
                        (B)->SectorsPerCluster)                          \
  :                                                                      \
    ((((B)->Sectors ? (B)->Sectors : (B)->LargeSectors)                  \
                                                                         \
        -   ((B)->ReservedSectors +                                      \
             (B)->Fats * (B)->SectorsPerFat +                            \
             (B)->RootEntries * sizeof(DIRENT) / (B)->BytesPerSector ) ) \
                                                                         \
                                    /                                    \
                                                                         \
                        (B)->SectorsPerCluster)                          \
)

//
//  This macro returns the fat table bit size (i.e., 12 or 16 bits)
//
//      ULONG
//      FatIndexBitSize (
//          IN PBIOS_PARAMETER_BLOCK Bios
//          );
//

#define FatIndexBitSize(B)  \
    ((UCHAR)(IsBpbFat32(B) ? 32 : (FatNumberOfClusters(B) < 4087 ? 12 : 16)))

//
//  This macro raises STATUS_FILE_CORRUPT and marks the Fcb bad if an
//  index value is not within the proper range.
//  Note that the first two index values are invalid (0, 1), so we must
//  add two from the top end to make sure the everything is within range
//
//      VOID
//      FatVerifyIndexIsValid (
//          IN PIRP_CONTEXT IrpContext,
//          IN PVCB Vcb,
//          IN ULONG Index
//          );
//

#define FatVerifyIndexIsValid(IC,V,I) {                                       \
    if (((I) < 2) || ((I) > ((V)->AllocationSupport.NumberOfClusters + 1))) { \
        FatRaiseStatus(IC,STATUS_FILE_CORRUPT_ERROR);                         \
    }                                                                         \
}

//
//  These two macros are used to translate between Logical Byte Offsets,
//  and fat entry indexes.  Note the use of variables stored in the Vcb.
//  These two macros are used at a higher level than the other macros
//  above.
//
//  Note, these indexes are true cluster numbers.
//
//  LBO
//  GetLboFromFatIndex (
//      IN FAT_ENTRY Fat_Index,
//      IN PVCB Vcb
//      );
//
//  FAT_ENTRY
//  GetFatIndexFromLbo (
//      IN LBO Lbo,
//      IN PVCB Vcb
//      );
//

#define FatGetLboFromIndex(VCB,FAT_INDEX) (                                       \
    ( (LBO)                                                                       \
        (VCB)->AllocationSupport.FileAreaLbo +                                    \
        (((LBO)((FAT_INDEX) - 2)) << (VCB)->AllocationSupport.LogOfBytesPerCluster) \
    )                                                                             \
)

#define FatGetIndexFromLbo(VCB,LBO) (                      \
    (ULONG) (                                              \
        (((LBO) - (VCB)->AllocationSupport.FileAreaLbo) >> \
        (VCB)->AllocationSupport.LogOfBytesPerCluster) + 2 \
    )                                                      \
)

//
//  The following macro does the shifting and such to lookup an entry
//
//  VOID
//  FatLookup12BitEntry(
//      IN PVOID Fat,
//      IN FAT_ENTRY Index,
//      OUT PFAT_ENTRY Entry
//      );
//

#define FatLookup12BitEntry(FAT,INDEX,ENTRY) {                              \
                                                                            \
    CopyUchar2((PUCHAR)(ENTRY), (PUCHAR)(FAT) + (INDEX) * 3 / 2);           \
                                                                            \
    *ENTRY = (FAT_ENTRY)(0xfff & (((INDEX) & 1) ? (*(ENTRY) >> 4) :         \
                                                   *(ENTRY)));              \
}

//
//  The following macro does the tmp shifting and such to store an entry
//
//  VOID
//  FatSet12BitEntry(
//      IN PVOID Fat,
//      IN FAT_ENTRY Index,
//      IN FAT_ENTRY Entry
//      );
//

#define FatSet12BitEntry(FAT,INDEX,ENTRY) {                            \
                                                                       \
    FAT_ENTRY TmpFatEntry;                                             \
                                                                       \
    CopyUchar2((PUCHAR)&TmpFatEntry, (PUCHAR)(FAT) + (INDEX) * 3 / 2); \
                                                                       \
    TmpFatEntry = (FAT_ENTRY)                                          \
                (((INDEX) & 1) ? ((ENTRY) << 4) | (TmpFatEntry & 0xf)  \
                               : (ENTRY) | (TmpFatEntry & 0xf000));    \
                                                                       \
    *((UNALIGNED UCHAR2 *)((PUCHAR)(FAT) + (INDEX) * 3 / 2)) = *((UNALIGNED UCHAR2 *)(&TmpFatEntry)); \
}

//
//  The following macro compares two FAT_TIME_STAMPs
//

#define FatAreTimesEqual(TIME1,TIME2) (                     \
    RtlEqualMemory((TIME1),(TIME2), sizeof(FAT_TIME_STAMP)) \
)


#define EA_FILE_SIGNATURE                (0x4445) // "ED"
#define EA_SET_SIGNATURE                 (0x4145) // "EA"

//
//  If the volume contains any ea data then there is one EA file called
//  "EA DATA. SF" located in the root directory as Hidden, System and
//  ReadOnly.
//

typedef struct _EA_FILE_HEADER {
    USHORT Signature;           // offset = 0
    USHORT FormatType;          // offset = 2
    USHORT LogType;             // offset = 4
    USHORT Cluster1;            // offset = 6
    USHORT NewCValue1;          // offset = 8
    USHORT Cluster2;            // offset = 10
    USHORT NewCValue2;          // offset = 12
    USHORT Cluster3;            // offset = 14
    USHORT NewCValue3;          // offset = 16
    USHORT Handle;              // offset = 18
    USHORT NewHOffset;          // offset = 20
    UCHAR  Reserved[10];        // offset = 22
    USHORT EaBaseTable[240];    // offset = 32
} EA_FILE_HEADER;               // sizeof = 512

typedef EA_FILE_HEADER *PEA_FILE_HEADER;

typedef USHORT EA_OFF_TABLE[128];

typedef EA_OFF_TABLE *PEA_OFF_TABLE;

//
//  Every file with an extended attribute contains in its dirent an index
//  into the EaMapTable.  The map table contains an offset within the ea
//  file (cluster aligned) of the ea data for the file.  The individual
//  ea data for each file is prefaced with an Ea Data Header.
//

typedef struct _EA_SET_HEADER {
    USHORT Signature;           // offset = 0
    USHORT OwnEaHandle;         // offset = 2
    ULONG32  NeedEaCount;         // offset = 4
    UCHAR  OwnerFileName[14];   // offset = 8
    UCHAR  Reserved[4];         // offset = 22
    UCHAR  cbList[4];           // offset = 26
    UCHAR  PackedEas[1];        // offset = 30
} EA_SET_HEADER;                // sizeof = 30
typedef EA_SET_HEADER *PEA_SET_HEADER;

#define SIZE_OF_EA_SET_HEADER       30

#define MAXIMUM_EA_SIZE             0x0000ffff

#define GetcbList(EASET) (((EASET)->cbList[0] <<  0) + \
                          ((EASET)->cbList[1] <<  8) + \
                          ((EASET)->cbList[2] << 16) + \
                          ((EASET)->cbList[3] << 24))

#define SetcbList(EASET,CB) {                \
    (EASET)->cbList[0] = (CB >>  0) & 0x0ff; \
    (EASET)->cbList[1] = (CB >>  8) & 0x0ff; \
    (EASET)->cbList[2] = (CB >> 16) & 0x0ff; \
    (EASET)->cbList[3] = (CB >> 24) & 0x0ff; \
}

//
//  Every individual ea in an ea set is declared the following packed ea
//

typedef struct _PACKED_EA {
    UCHAR Flags;
    UCHAR EaNameLength;
    UCHAR EaValueLength[2];
    CHAR  EaName[1];
} PACKED_EA;
typedef PACKED_EA *PPACKED_EA;

//
//  The following two macros are used to get and set the ea value length
//  field of a packed ea
//
//      VOID
//      GetEaValueLength (
//          IN PPACKED_EA Ea,
//          OUT PUSHORT ValueLength
//          );
//
//      VOID
//      SetEaValueLength (
//          IN PPACKED_EA Ea,
//          IN USHORT ValueLength
//          );
//

#define GetEaValueLength(EA,LEN) {               \
    *(LEN) = 0;                                  \
    CopyUchar2( (LEN), (EA)->EaValueLength );    \
}

#define SetEaValueLength(EA,LEN) {               \
    CopyUchar2( &((EA)->EaValueLength), (LEN) ); \
}

//
//  The following macro is used to get the size of a packed ea
//
//      VOID
//      SizeOfPackedEa (
//          IN PPACKED_EA Ea,
//          OUT PUSHORT EaSize
//          );
//

#define SizeOfPackedEa(EA,SIZE) {          \
    ULONG _NL,_DL; _NL = 0; _DL = 0;       \
    CopyUchar1(&_NL, &(EA)->EaNameLength); \
    GetEaValueLength(EA, &_DL);            \
    *(SIZE) = 1 + 1 + 2 + _NL + 1 + _DL;   \
}

#define EA_NEED_EA_FLAG                 0x80
#define MIN_EA_HANDLE                   1
#define MAX_EA_HANDLE                   30719
#define UNUSED_EA_HANDLE                0xffff
#define EA_CBLIST_OFFSET                0x1a
#define MAX_EA_BASE_INDEX               240
#define MAX_EA_OFFSET_INDEX             128


#endif // _FAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fatinit.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FatInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for Fat

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
FatUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
FatGetCompatibilityModeValue(
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG Value
    );

BOOLEAN
FatIsFujitsuFMR (
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, FatGetCompatibilityModeValue)
#pragma alloc_text(INIT, FatIsFujitsuFMR)
//#pragma alloc_text(PAGE, FatUnload)
#endif

#define COMPATIBILITY_MODE_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem"
#define COMPATIBILITY_MODE_VALUE_NAME L"Win31FileSystem"
#define CODE_PAGE_INVARIANCE_VALUE_NAME L"FatDisableCodePageInvariance"

#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + \
                        sizeof(ULONG)) + 64)

#define REGISTRY_HARDWARE_DESCRIPTION_W \
        L"\\Registry\\Machine\\Hardware\\DESCRIPTION\\System"

#define REGISTRY_MACHINE_IDENTIFIER_W   L"Identifier"

#define FUJITSU_FMR_NAME_W  L"FUJITSU FMR-"


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Fat file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    USHORT MaxDepth;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;

    UNICODE_STRING ValueName;
    ULONG Value;

    //
    // Create the device object for disks.  To avoid problems with filters who
    // know this name, we must keep it.
    //

    RtlInitUnicodeString( &UnicodeString, L"\\Fat" );
    Status = IoCreateDevice( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &FatDiskFileSystemDeviceObject );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    //
    // Create the device object for "cdroms".
    //

    RtlInitUnicodeString( &UnicodeString, L"\\FatCdrom" );
    Status = IoCreateDevice( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                             0,
                             FALSE,
                             &FatCdromFileSystemDeviceObject );

    if (!NT_SUCCESS( Status )) {
        IoDeleteDevice( FatDiskFileSystemDeviceObject);
        return Status;
    }


    DriverObject->DriverUnload = FatUnload;

#ifdef _PNP_POWER_
    //
    // This driver doesn't talk directly to a device, and (at the moment)
    // isn't otherwise concerned about power management.
    //

    FatDiskFileSystemDeviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
    FatCdromFileSystemDeviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif

    //
    //  Note that because of the way data caching is done, we set neither
    //  the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
    //  data is not in the cache, or the request is not buffered, we may,
    //  set up for Direct I/O by hand.
    //

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                   = (PDRIVER_DISPATCH)FatFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                    = (PDRIVER_DISPATCH)FatFsdClose;
    DriverObject->MajorFunction[IRP_MJ_READ]                     = (PDRIVER_DISPATCH)FatFsdRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE]                    = (PDRIVER_DISPATCH)FatFsdWrite;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]        = (PDRIVER_DISPATCH)FatFsdQueryInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]          = (PDRIVER_DISPATCH)FatFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_QUERY_EA]                 = (PDRIVER_DISPATCH)FatFsdQueryEa;
    DriverObject->MajorFunction[IRP_MJ_SET_EA]                   = (PDRIVER_DISPATCH)FatFsdSetEa;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]            = (PDRIVER_DISPATCH)FatFsdFlushBuffers;
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] = (PDRIVER_DISPATCH)FatFsdQueryVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_VOLUME_INFORMATION]   = (PDRIVER_DISPATCH)FatFsdSetVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                  = (PDRIVER_DISPATCH)FatFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL]        = (PDRIVER_DISPATCH)FatFsdDirectoryControl;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]      = (PDRIVER_DISPATCH)FatFsdFileSystemControl;
    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL]             = (PDRIVER_DISPATCH)FatFsdLockControl;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]           = (PDRIVER_DISPATCH)FatFsdDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]                 = (PDRIVER_DISPATCH)FatFsdShutdown;
    DriverObject->MajorFunction[IRP_MJ_PNP]                      = (PDRIVER_DISPATCH)FatFsdPnp;

    DriverObject->FastIoDispatch = &FatFastIoDispatch;

    RtlZeroMemory(&FatFastIoDispatch, sizeof(FatFastIoDispatch));

    FatFastIoDispatch.SizeOfFastIoDispatch =    sizeof(FAST_IO_DISPATCH);
    FatFastIoDispatch.FastIoCheckIfPossible =   FatFastIoCheckIfPossible;  //  CheckForFastIo
    FatFastIoDispatch.FastIoRead =              FsRtlCopyRead;             //  Read
    FatFastIoDispatch.FastIoWrite =             FsRtlCopyWrite;            //  Write
    FatFastIoDispatch.FastIoQueryBasicInfo =    FatFastQueryBasicInfo;     //  QueryBasicInfo
    FatFastIoDispatch.FastIoQueryStandardInfo = FatFastQueryStdInfo;       //  QueryStandardInfo
    FatFastIoDispatch.FastIoLock =              FatFastLock;               //  Lock
    FatFastIoDispatch.FastIoUnlockSingle =      FatFastUnlockSingle;       //  UnlockSingle
    FatFastIoDispatch.FastIoUnlockAll =         FatFastUnlockAll;          //  UnlockAll
    FatFastIoDispatch.FastIoUnlockAllByKey =    FatFastUnlockAllByKey;     //  UnlockAllByKey
    FatFastIoDispatch.FastIoQueryNetworkOpenInfo = FatFastQueryNetworkOpenInfo;
    FatFastIoDispatch.AcquireForCcFlush =       FatAcquireForCcFlush;
    FatFastIoDispatch.ReleaseForCcFlush =       FatReleaseForCcFlush;
    
    //
    //  Initialize the global data structures
    //

    //
    //  The FatData record
    //

    RtlZeroMemory( &FatData, sizeof(FAT_DATA));

    FatData.NodeTypeCode = FAT_NTC_DATA_HEADER;
    FatData.NodeByteSize = sizeof(FAT_DATA);

    InitializeListHead(&FatData.VcbQueue);

    FatData.DriverObject = DriverObject;
    FatData.DiskFileSystemDeviceObject = FatDiskFileSystemDeviceObject;
    FatData.CdromFileSystemDeviceObject = FatCdromFileSystemDeviceObject;

    //
    //  This list head keeps track of closes yet to be done.
    //

    InitializeListHead( &FatData.AsyncCloseList );
    InitializeListHead( &FatData.DelayedCloseList );

    FatData.FatCloseItem = IoAllocateWorkItem( FatDiskFileSystemDeviceObject);

    if (FatData.FatCloseItem == NULL) {
        IoDeleteDevice (FatDiskFileSystemDeviceObject);
        IoDeleteDevice (FatCdromFileSystemDeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Now initialize our general purpose spinlock (gag) and figure out how
    //  deep and wide we want our delayed lists (along with fooling ourselves
    //  about the lookaside depths).
    //

    KeInitializeSpinLock( &FatData.GeneralSpinLock );

    switch ( MmQuerySystemSize() ) {

    case MmSmallSystem:

        MaxDepth = 4;
        FatMaxDelayedCloseCount = FAT_MAX_DELAYED_CLOSES;
        break;

    case MmMediumSystem:

        MaxDepth = 8;
        FatMaxDelayedCloseCount = 4 * FAT_MAX_DELAYED_CLOSES;
        break;

    case MmLargeSystem:

        MaxDepth = 16;
        FatMaxDelayedCloseCount = 16 * FAT_MAX_DELAYED_CLOSES;
        break;
    }


    //
    //  Initialize the cache manager callback routines
    //

    FatData.CacheManagerCallbacks.AcquireForLazyWrite  = &FatAcquireFcbForLazyWrite;
    FatData.CacheManagerCallbacks.ReleaseFromLazyWrite = &FatReleaseFcbFromLazyWrite;
    FatData.CacheManagerCallbacks.AcquireForReadAhead  = &FatAcquireFcbForReadAhead;
    FatData.CacheManagerCallbacks.ReleaseFromReadAhead = &FatReleaseFcbFromReadAhead;

    FatData.CacheManagerNoOpCallbacks.AcquireForLazyWrite  = &FatNoOpAcquire;
    FatData.CacheManagerNoOpCallbacks.ReleaseFromLazyWrite = &FatNoOpRelease;
    FatData.CacheManagerNoOpCallbacks.AcquireForReadAhead  = &FatNoOpAcquire;
    FatData.CacheManagerNoOpCallbacks.ReleaseFromReadAhead = &FatNoOpRelease;

    //
    //  Set up global pointer to our process.
    //

    FatData.OurProcess = PsGetCurrentProcess();

    //
    //  Read the registry to determine if we are in ChicagoMode.
    //

    ValueName.Buffer = COMPATIBILITY_MODE_VALUE_NAME;
    ValueName.Length = sizeof(COMPATIBILITY_MODE_VALUE_NAME) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(COMPATIBILITY_MODE_VALUE_NAME);

    Status = FatGetCompatibilityModeValue( &ValueName, &Value );

    if (NT_SUCCESS(Status) && FlagOn(Value, 1)) {

        FatData.ChicagoMode = FALSE;

    } else {

        FatData.ChicagoMode = TRUE;
    }

    //
    //  Read the registry to determine if we are going to generate LFNs
    //  for valid 8.3 names with extended characters.
    //

    ValueName.Buffer = CODE_PAGE_INVARIANCE_VALUE_NAME;
    ValueName.Length = sizeof(CODE_PAGE_INVARIANCE_VALUE_NAME) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(CODE_PAGE_INVARIANCE_VALUE_NAME);

    Status = FatGetCompatibilityModeValue( &ValueName, &Value );

    if (NT_SUCCESS(Status) && FlagOn(Value, 1)) {

        FatData.CodePageInvariant = FALSE;

    } else {

        FatData.CodePageInvariant = TRUE;
    }

    //
    //  Initialize our global resource and fire up the lookaside lists.
    //

    ExInitializeResourceLite( &FatData.Resource );

    ExInitializeNPagedLookasideList( &FatIrpContextLookasideList,
                                     NULL,
                                     NULL,
                                     POOL_RAISE_IF_ALLOCATION_FAILURE,
                                     sizeof(IRP_CONTEXT),
                                     TAG_IRP_CONTEXT,
                                     MaxDepth );

    ExInitializeNPagedLookasideList( &FatNonPagedFcbLookasideList,
                                     NULL,
                                     NULL,
                                     POOL_RAISE_IF_ALLOCATION_FAILURE,
                                     sizeof(NON_PAGED_FCB),
                                     TAG_FCB_NONPAGED,
                                     MaxDepth );

    ExInitializeNPagedLookasideList( &FatEResourceLookasideList,
                                     NULL,
                                     NULL,
                                     POOL_RAISE_IF_ALLOCATION_FAILURE,
                                     sizeof(ERESOURCE),
                                     TAG_ERESOURCE,
                                     MaxDepth );

    ExInitializeSListHead( &FatCloseContextSList );
    ExInitializeFastMutex( &FatCloseQueueMutex );
    KeInitializeEvent( &FatReserveEvent, SynchronizationEvent, TRUE );

    //
    //  Register the file system with the I/O system
    //

    IoRegisterFileSystem(FatDiskFileSystemDeviceObject);
    ObReferenceObject (FatDiskFileSystemDeviceObject);
    IoRegisterFileSystem(FatCdromFileSystemDeviceObject);
    ObReferenceObject (FatCdromFileSystemDeviceObject);

    //
    //  Find out if we are running an a FujitsuFMR machine.
    //

    FatData.FujitsuFMR = FatIsFujitsuFMR();

    //
    //  And return to our caller
    //

    return( STATUS_SUCCESS );
}


VOID
FatUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the unload routine for the filesystem

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None

--*/

{
    ExDeleteNPagedLookasideList (&FatEResourceLookasideList);
    ExDeleteNPagedLookasideList (&FatNonPagedFcbLookasideList);
    ExDeleteNPagedLookasideList (&FatIrpContextLookasideList);
    ExDeleteResourceLite( &FatData.Resource );
    IoFreeWorkItem (FatData.FatCloseItem);
    ObDereferenceObject( FatDiskFileSystemDeviceObject);
    ObDereferenceObject( FatCdromFileSystemDeviceObject);
}


//
//  Local Support routine
//

NTSTATUS
FatGetCompatibilityModeValue (
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG Value
    )

/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the Chicago compatibilitymode information and get the
    value.

Arguments:

    ValueName - the unicode name for the registry value located in the registry.
    Value   - a pointer to the ULONG for the result.

Return Value:

    NTSTATUS

    If STATUS_SUCCESSFUL is returned, the location *Value will be
    updated with the DWORD value from the registry.  If any failing
    status is returned, this value is untouched.

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    UCHAR Buffer[KEY_WORK_AREA];
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;

    KeyName.Buffer = COMPATIBILITY_MODE_KEY_NAME;
    KeyName.Length = sizeof(COMPATIBILITY_MODE_KEY_NAME) - sizeof(WCHAR);
    KeyName.MaximumLength = sizeof(COMPATIBILITY_MODE_KEY_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Handle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    RequestLength = KEY_WORK_AREA;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

    while (1) {

        Status = ZwQueryValueKey(Handle,
                                 ValueName,
                                 KeyValueFullInformation,
                                 KeyValueInformation,
                                 RequestLength,
                                 &ResultLength);

        ASSERT( Status != STATUS_BUFFER_OVERFLOW );

        if (Status == STATUS_BUFFER_OVERFLOW) {

            //
            // Try to get a buffer big enough.
            //

            if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

                ExFreePool(KeyValueInformation);
            }

            RequestLength += 256;

            KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                  ExAllocatePoolWithTag(PagedPool,
                                                        RequestLength,
                                                        ' taF');

            if (!KeyValueInformation) {
                return STATUS_NO_MEMORY;
            }

        } else {

            break;
        }
    }

    ZwClose(Handle);

    if (NT_SUCCESS(Status)) {

        if (KeyValueInformation->DataLength != 0) {

            PULONG DataPtr;

            //
            // Return contents to the caller.
            //

            DataPtr = (PULONG)
              ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
            *Value = *DataPtr;

        } else {

            //
            // Treat as if no value was found
            //

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

        ExFreePool(KeyValueInformation);
    }

    return Status;
}

//
//  Local Support routine
//

BOOLEAN
FatIsFujitsuFMR (
    )

/*++

Routine Description:

    This routine tells if is we running on a FujitsuFMR machine.

Arguments:


Return Value:

    BOOLEAN - TRUE is we are and FALSE otherwise

--*/

{
    ULONG Value;
    BOOLEAN Result;
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    UCHAR Buffer[KEY_WORK_AREA];
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;

    //
    // Set default as PC/AT
    //

    KeyName.Buffer = REGISTRY_HARDWARE_DESCRIPTION_W;
    KeyName.Length = sizeof(REGISTRY_HARDWARE_DESCRIPTION_W) - sizeof(WCHAR);
    KeyName.MaximumLength = sizeof(REGISTRY_HARDWARE_DESCRIPTION_W);

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Handle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        return FALSE;
    }

    ValueName.Buffer = REGISTRY_MACHINE_IDENTIFIER_W;
    ValueName.Length = sizeof(REGISTRY_MACHINE_IDENTIFIER_W) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(REGISTRY_MACHINE_IDENTIFIER_W);

    RequestLength = KEY_WORK_AREA;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

    while (1) {

        Status = ZwQueryValueKey(Handle,
                                 &ValueName,
                                 KeyValueFullInformation,
                                 KeyValueInformation,
                                 RequestLength,
                                 &ResultLength);

        // ASSERT( Status != STATUS_BUFFER_OVERFLOW );

        if (Status == STATUS_BUFFER_OVERFLOW) {

            //
            // Try to get a buffer big enough.
            //

            if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

                ExFreePool(KeyValueInformation);
            }

            RequestLength += 256;

            KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                  ExAllocatePool(PagedPool, RequestLength);

            if (!KeyValueInformation) {
                return FALSE;
            }

        } else {

            break;
        }
    }

    ZwClose(Handle);

    if (NT_SUCCESS(Status) &&
        (KeyValueInformation->DataLength >= sizeof(FUJITSU_FMR_NAME_W)) &&
        (RtlCompareMemory((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset,
                          FUJITSU_FMR_NAME_W,
                          sizeof(FUJITSU_FMR_NAME_W) - sizeof(WCHAR)) ==
         sizeof(FUJITSU_FMR_NAME_W) - sizeof(WCHAR))) {

        Result = TRUE;

    } else {

        Result = FALSE;
    }

    if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

        ExFreePool(KeyValueInformation);
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fileinfo.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the File Information routines for Fat called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    22-Oct-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_FILEINFO)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

VOID
FatQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PLONG Length
    );

VOID
FatQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PLONG Length
    );

VOID
FatQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PLONG Length
    );

VOID
FatQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PLONG Length
    );

VOID
FatQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PLONG Length
    );

VOID
FatQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PLONG Length
    );

VOID
FatQueryShortNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PLONG Length
    );

VOID
FatQueryNetworkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PLONG Length
    );

NTSTATUS
FatSetBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PCCB Ccb
    );

NTSTATUS
FatSetDispositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb
    );

NTSTATUS
FatSetRenameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN PCCB Ccb
    );

NTSTATUS
FatSetPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
FatSetAllocationInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
FatSetEndOfFileInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PFCB Fcb
    );

VOID
FatDeleteFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB TargetDcb,
    IN ULONG LfnOffset,
    IN ULONG DirentOffset,
    IN PDIRENT Dirent,
    IN PUNICODE_STRING Lfn
    );

VOID
FatRenameEAs (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN USHORT ExtendedAttributes,
    IN POEM_STRING OldOemName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonQueryInformation)
#pragma alloc_text(PAGE, FatCommonSetInformation)
#pragma alloc_text(PAGE, FatFsdQueryInformation)
#pragma alloc_text(PAGE, FatFsdSetInformation)
#pragma alloc_text(PAGE, FatQueryBasicInfo)
#pragma alloc_text(PAGE, FatQueryEaInfo)
#pragma alloc_text(PAGE, FatQueryInternalInfo)
#pragma alloc_text(PAGE, FatQueryNameInfo)
#pragma alloc_text(PAGE, FatQueryNetworkInfo)
#pragma alloc_text(PAGE, FatQueryShortNameInfo)
#pragma alloc_text(PAGE, FatQueryPositionInfo)
#pragma alloc_text(PAGE, FatQueryStandardInfo)
#pragma alloc_text(PAGE, FatSetAllocationInfo)
#pragma alloc_text(PAGE, FatSetBasicInfo)
#pragma alloc_text(PAGE, FatSetDispositionInfo)
#pragma alloc_text(PAGE, FatSetEndOfFileInfo)
#pragma alloc_text(PAGE, FatSetPositionInfo)
#pragma alloc_text(PAGE, FatSetRenameInfo)
#pragma alloc_text(PAGE, FatDeleteFile)
#pragma alloc_text(PAGE, FatRenameEAs)
#endif


NTSTATUS
FatFsdQueryInformation (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the Fsd part of the NtQueryInformationFile API
    call.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the file
        being queried exists.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The FSD status for the Irp.

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdQueryInformation\n", 0);

    //
    //  Call the common query routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        Status = FatCommonQueryInformation( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdQueryInformation -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatFsdSetInformation (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtSetInformationFile API
    call.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the file
        being set exists.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The FSD status for the Irp.

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdSetInformation\n", 0);

    //
    //  Call the common set routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        Status = FatCommonSetInformation( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdSetInformation -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonQueryInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying file information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;

    LONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID Buffer;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN FcbAcquired;

    PFILE_ALL_INFORMATION AllInfo;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;

    DebugTrace(+1, Dbg, "FatCommonQueryInformation...\n", 0);
    DebugTrace( 0, Dbg, "Irp                    = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "->Length               = %08lx\n", IrpSp->Parameters.QueryFile.Length);
    DebugTrace( 0, Dbg, "->FileInformationClass = %08lx\n", IrpSp->Parameters.QueryFile.FileInformationClass);
    DebugTrace( 0, Dbg, "->Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    Length = (LONG)IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object
    //

    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

    FcbAcquired = FALSE;
    Status = STATUS_SUCCESS;

    try {

        //
        //  Case on the type of open we're dealing with
        //

        switch (TypeOfOpen) {

        case UserVolumeOpen:

            //
            //  We cannot query the user volume open.
            //

            Status = STATUS_INVALID_PARAMETER;
            break;

        case UserFileOpen:

        case UserDirectoryOpen:

        case DirectoryFile:

            //
            //  Acquire shared access to the fcb, except for a paging file
            //  in order to avoid deadlocks with Mm.
            //

            if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                if (!FatAcquireSharedFcb( IrpContext, Fcb )) {

                    DebugTrace(0, Dbg, "Cannot acquire Fcb\n", 0);
                    
                    Status = FatFsdPostRequest( IrpContext, Irp );
                    IrpContext = NULL;
                    Irp = NULL;

                    try_return( Status );
                }

                FcbAcquired = TRUE;
            }

            //
            //  Make sure the Fcb is in a usable condition.  This
            //  will raise an error condition if the fcb is unusable
            //

            FatVerifyFcb( IrpContext, Fcb );

            //
            //  Based on the information class we'll do different
            //  actions.  Each of hte procedures that we're calling fills
            //  up the output buffer, if possible.  They will raise the
            //  status STATUS_BUFFER_OVERFLOW for an insufficient buffer.
            //  This is considered a somewhat unusual case and is handled
            //  more cleanly with the exception mechanism rather than
            //  testing a return status value for each call.
            //

            switch (FileInformationClass) {

            case FileAllInformation:

                //
                //  For the all information class we'll typecast a local
                //  pointer to the output buffer and then call the
                //  individual routines to fill in the buffer.
                //

                AllInfo = Buffer;
                Length -= (sizeof(FILE_ACCESS_INFORMATION)
                           + sizeof(FILE_MODE_INFORMATION)
                           + sizeof(FILE_ALIGNMENT_INFORMATION));

                FatQueryBasicInfo( IrpContext, Fcb, FileObject, &AllInfo->BasicInformation, &Length );
                FatQueryStandardInfo( IrpContext, Fcb, &AllInfo->StandardInformation, &Length );
                FatQueryInternalInfo( IrpContext, Fcb, &AllInfo->InternalInformation, &Length );
                FatQueryEaInfo( IrpContext, Fcb, &AllInfo->EaInformation, &Length );
                FatQueryPositionInfo( IrpContext, FileObject, &AllInfo->PositionInformation, &Length );
                FatQueryNameInfo( IrpContext, Fcb, Ccb, &AllInfo->NameInformation, &Length );

                break;

            case FileBasicInformation:

                FatQueryBasicInfo( IrpContext, Fcb, FileObject, Buffer, &Length );
                break;

            case FileStandardInformation:

                FatQueryStandardInfo( IrpContext, Fcb, Buffer, &Length );
                break;

            case FileInternalInformation:

                FatQueryInternalInfo( IrpContext, Fcb, Buffer, &Length );
                break;

            case FileEaInformation:

                FatQueryEaInfo( IrpContext, Fcb, Buffer, &Length );
                break;

            case FilePositionInformation:

                FatQueryPositionInfo( IrpContext, FileObject, Buffer, &Length );
                break;

            case FileNameInformation:

                FatQueryNameInfo( IrpContext, Fcb, Ccb, Buffer, &Length );
                break;

            case FileAlternateNameInformation:

                FatQueryShortNameInfo( IrpContext, Fcb, Buffer, &Length );
                break;

            case FileNetworkOpenInformation:

                FatQueryNetworkInfo( IrpContext, Fcb, FileObject, Buffer, &Length );
                break;

            default:

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            break;
 
        default:

            KdPrintEx((DPFLTR_FASTFAT_ID,
                       DPFLTR_INFO_LEVEL,
                       "FATQueryFile, Illegal TypeOfOpen = %08lx\n",
                       TypeOfOpen));

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  If we overflowed the buffer, set the length to 0 and change the
        //  status to STATUS_BUFFER_OVERFLOW.
        //

        if ( Length < 0 ) {

            Status = STATUS_BUFFER_OVERFLOW;

            Length = 0;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //  and then complete the request
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryFile.Length - Length;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatCommonQueryInformation );

        if (FcbAcquired) { FatReleaseFcb( IrpContext, Fcb ); }

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatCommonQueryInformation -> %08lx\n", Status);
    }

    return Status;
}


NTSTATUS
FatCommonSetInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for setting file information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    FILE_INFORMATION_CLASS FileInformationClass;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN FcbAcquired = FALSE;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonSetInformation...\n", 0);
    DebugTrace( 0, Dbg, "Irp                    = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "->Length               = %08lx\n", IrpSp->Parameters.SetFile.Length);
    DebugTrace( 0, Dbg, "->FileInformationClass = %08lx\n", IrpSp->Parameters.SetFile.FileInformationClass);
    DebugTrace( 0, Dbg, "->FileObject           = %08lx\n", IrpSp->Parameters.SetFile.FileObject);
    DebugTrace( 0, Dbg, "->ReplaceIfExists      = %08lx\n", IrpSp->Parameters.SetFile.ReplaceIfExists);
    DebugTrace( 0, Dbg, "->Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;
    FileObject = IrpSp->FileObject;

    //
    //  Decode the file object
    //

    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

    try {

        //
        //  Case on the type of open we're dealing with
        //

        switch (TypeOfOpen) {

        case UserVolumeOpen:

            //
            //  We cannot query the user volume open.
            //

            try_return( Status = STATUS_INVALID_PARAMETER );
            break;

        case UserFileOpen:

            if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                ((FileInformationClass == FileEndOfFileInformation) ||
                 (FileInformationClass == FileAllocationInformation))) {

                //
                //  We check whether we can proceed
                //  based on the state of the file oplocks.
                //

                Status = FsRtlCheckOplock( &Fcb->Specific.Fcb.Oplock,
                                           Irp,
                                           IrpContext,
                                           NULL,
                                           NULL );

                if (Status != STATUS_SUCCESS) {

                    try_return( Status );
                }

                //
                //  Set the flag indicating if Fast I/O is possible
                //

                Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );
            }
            break;

        case UserDirectoryOpen:

            break;

        default:

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  We can only do a set on a nonroot dcb, so we do the test
        //  and then fall through to the user file open code.
        //

        if (NodeType(Fcb) == FAT_NTC_ROOT_DCB) {

            if (FileInformationClass == FileDispositionInformation) {

                try_return( Status = STATUS_CANNOT_DELETE );
            }

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  In the following two cases, we cannot have creates occuring
        //  while we are here, so acquire the volume exclusive.
        //

        if ((FileInformationClass == FileDispositionInformation) ||
            (FileInformationClass == FileRenameInformation)) {

            if (!FatAcquireExclusiveVcb( IrpContext, Vcb )) {

                DebugTrace(0, Dbg, "Cannot acquire Vcb\n", 0);

                Status = FatFsdPostRequest( IrpContext, Irp );
                Irp = NULL;
                IrpContext = NULL;

                try_return( Status );
            }

            VcbAcquired = TRUE;
        }

        //
        //  We need to look here to check whether the oplock state
        //  will allow us to continue.  We may have to loop to prevent
        //  an oplock being granted between the time we check the oplock
        //  and obtain the Fcb.
        //

        //
        //  Acquire exclusive access to the Fcb,  We use exclusive
        //  because it is probable that one of the subroutines
        //  that we call will need to monkey with file allocation,
        //  create/delete extra fcbs.  So we're willing to pay the
        //  cost of exclusive Fcb access.
        //
        //  Note that we do not acquire the resource for paging file
        //  operations in order to avoid deadlock with Mm.
        //

        if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

            if (!FatAcquireExclusiveFcb( IrpContext, Fcb )) {

                DebugTrace(0, Dbg, "Cannot acquire Fcb\n", 0);

                Status = FatFsdPostRequest( IrpContext, Irp );
                Irp = NULL;
                IrpContext = NULL;

                try_return( Status );
            }

            FcbAcquired = TRUE;
        }

        Status = STATUS_SUCCESS;

        //
        //  Make sure the Fcb is in a usable condition.  This
        //  will raise an error condition if the fcb is unusable
        //

        FatVerifyFcb( IrpContext, Fcb );

        //
        //  Based on the information class we'll do different
        //  actions.  Each of the procedures that we're calling will either
        //  complete the request of send the request off to the fsp
        //  to do the work.
        //

        switch (FileInformationClass) {

        case FileBasicInformation:

            Status = FatSetBasicInfo( IrpContext, Irp, Fcb, Ccb );
            break;

        case FileDispositionInformation:

            //
            //  If this is on deferred flush media, we have to be able to wait.
            //

            if ( FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH) &&
                 !FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) ) {

                Status = FatFsdPostRequest( IrpContext, Irp );
                Irp = NULL;
                IrpContext = NULL;

            } else {

                Status = FatSetDispositionInfo( IrpContext, Irp, FileObject, Fcb );
            }

            break;

        case FileRenameInformation:

            //
            //  We proceed with this operation only if we can wait
            //

            if (!FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT)) {

                Status = FatFsdPostRequest( IrpContext, Irp );
                Irp = NULL;
                IrpContext = NULL;

            } else {

                Status = FatSetRenameInfo( IrpContext, Irp, Vcb, Fcb, Ccb );

                //
                //  If STATUS_PENDING is returned it means the oplock
                //  package has the Irp.  Don't complete the request here.
                //

                if (Status == STATUS_PENDING) {
                    Irp = NULL;
                    IrpContext = NULL;
                }
            }

            break;

        case FilePositionInformation:

            Status = FatSetPositionInfo( IrpContext, Irp, FileObject );
            break;

        case FileLinkInformation:

            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case FileAllocationInformation:

            Status = FatSetAllocationInfo( IrpContext, Irp, Fcb, FileObject );
            break;

        case FileEndOfFileInformation:

            Status = FatSetEndOfFileInfo( IrpContext, Irp, FileObject, Vcb, Fcb );
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        if ( IrpContext != NULL ) {

            FatUnpinRepinnedBcbs( IrpContext );
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatCommonSetInformation );

        if (FcbAcquired) { FatReleaseFcb( IrpContext, Fcb ); }
        if (VcbAcquired) { FatReleaseVcb( IrpContext, Vcb ); }

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatCommonSetInformation -> %08lx\n", Status);
    }

    return Status;
}


//
//  Internal Support Routine
//

VOID
FatQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PLONG Length
    )

/*++
 Description:

    This routine performs the query basic information function for fat.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    FileObject - Supplies the flag bit that indicates the file was modified.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "FatQueryBasicInfo...\n", 0);

    //
    //  Zero out the output buffer, and set it to indicate that
    //  the query is a normal file.  Later we might overwrite the
    //  attribute.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_BASIC_INFORMATION) );

    //
    //  Extract the data and fill in the non zero fields of the output
    //  buffer
    //

    if (Fcb->Header.NodeTypeCode == FAT_NTC_ROOT_DCB) {

        //
        //  We have to munge a lie on the fly.  Every time we have to
        //  use 1/1/80 we need to convert to GMT since the TZ may have
        //  changed on us.
        //

        ExLocalTimeToSystemTime( &FatJanOne1980,
                                 &Buffer->LastWriteTime );
        Buffer->CreationTime = Buffer->LastAccessTime = Buffer->LastWriteTime;

    } else {

        Buffer->LastWriteTime = Fcb->LastWriteTime;
        Buffer->CreationTime = Fcb->CreationTime;
        Buffer->LastAccessTime = Fcb->LastAccessTime;
    }

    Buffer->FileAttributes = Fcb->DirentFatFlags;

    //
    //  If the temporary flag is set, then set it in the buffer.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_TEMPORARY )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
    }

    //
    //  If no attributes were set, set the normal bit.
    //

    if (Buffer->FileAttributes == 0) {

        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_BASIC_INFORMATION );

    DebugTrace( 0, Dbg, "*Length = %08lx\n", *Length);

    DebugTrace(-1, Dbg, "FatQueryBasicInfo -> VOID\n", 0);

    return;
}


//
//  Internal Support Routine
//

VOID
FatQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PLONG Length
    )

/*++

Routine Description:

    This routine performs the query standard information function for fat.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "FatQueryStandardInfo...\n", 0);

    //
    //  Zero out the output buffer, and fill in the number of links
    //  and the delete pending flag.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_STANDARD_INFORMATION) );

    Buffer->NumberOfLinks = 1;
    Buffer->DeletePending = BooleanFlagOn( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );

    //
    //  Case on whether this is a file or a directory, and extract
    //  the information and fill in the fcb/dcb specific parts
    //  of the output buffer
    //

    if (NodeType(Fcb) == FAT_NTC_FCB) {

        if (Fcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

            FatLookupFileAllocationSize( IrpContext, Fcb );
        }

        Buffer->AllocationSize = Fcb->Header.AllocationSize;
        Buffer->EndOfFile = Fcb->Header.FileSize;

        Buffer->Directory = FALSE;

    } else {

        Buffer->Directory = TRUE;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_STANDARD_INFORMATION );

    DebugTrace( 0, Dbg, "*Length = %08lx\n", *Length);

    DebugTrace(-1, Dbg, "FatQueryStandardInfo -> VOID\n", 0);

    return;
}


//
//  Internal Support Routine
//

VOID
FatQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PLONG Length
    )

/*++

Routine Description:

    This routine performs the query internal information function for fat.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "FatQueryInternalInfo...\n", 0);

    try {

        Buffer->IndexNumber.QuadPart = FatGenerateFileIdFromFcb( Fcb );

        //
        //  Update the length and status output variables
        //

        *Length -= sizeof( FILE_INTERNAL_INFORMATION );

    } finally {

        DebugUnwind( FatQueryInternalInfo );

        DebugTrace( 0, Dbg, "*Length = %08lx\n", *Length);

        DebugTrace(-1, Dbg, "FatQueryInternalInfo -> VOID\n", 0);
    }

    return;
}


//
//  Internal Support Routine
//

VOID
FatQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PLONG Length
    )

/*++

Routine Description:

    This routine performs the query Ea information function for fat.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PBCB Bcb;

    DebugTrace(+1, Dbg, "FatQueryEaInfo...\n", 0);

    Bcb = NULL;

    try {

        //
        //  Zero out the output buffer
        //

        RtlZeroMemory( Buffer, sizeof(FILE_EA_INFORMATION) );

        //
        //  The Root dcb does not have any EAs so don't look for any.  Fat32
        //  doesn't have any, either.
        //

        if ( NodeType( Fcb ) != FAT_NTC_ROOT_DCB &&
             !FatIsFat32( Fcb->Vcb )) {

            PDIRENT Dirent;

            //
            //  Try to get the dirent for this file.
            //

            FatGetDirentFromFcbOrDcb( IrpContext,
                                      Fcb,
                                      &Dirent,
                                      &Bcb );
            
            if (Dirent != NULL) {
                
                //
                //  Get a the size needed to store the full eas for the file.
                //

                FatGetEaLength( IrpContext,
                                Fcb->Vcb,
                                Dirent,
                                &Buffer->EaSize );
            }
        }

        //
        //  Update the length and status output variables
        //

        *Length -= sizeof( FILE_EA_INFORMATION );

    } finally {

        DebugUnwind( FatQueryEaInfo );

        //
        //  Unpin the dirent if pinned.
        //

        FatUnpinBcb( IrpContext, Bcb );

        DebugTrace( 0, Dbg, "*Length = %08lx\n", *Length);

        DebugTrace(-1, Dbg, "FatQueryEaInfo -> VOID\n", 0);
    }

    return;
}


//
//  Internal Support Routine
//

VOID
FatQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PLONG Length
    )

/*++

Routine Description:

    This routine performs the query position information function for fat.

Arguments:

    FileObject - Supplies the File object being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "FatQueryPositionInfo...\n", 0);

    //
    //  Get the current position found in the file object.
    //

    Buffer->CurrentByteOffset = FileObject->CurrentByteOffset;

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_POSITION_INFORMATION );

    DebugTrace( 0, Dbg, "*Length = %08lx\n", *Length);

    DebugTrace(-1, Dbg, "FatQueryPositionInfo -> VOID\n", 0);

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}


//
//  Internal Support Routine
//

VOID
FatQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PLONG Length
    )

/*++

Routine Description:

    This routine performs the query name information function for fat.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Ccb - Supplies the Ccb for the context of the user open

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    ULONG BytesToCopy;
    LONG TrimLength;
    BOOLEAN Overflow = FALSE;

    DebugTrace(+1, Dbg, "FatQueryNameInfo...\n", 0);

    //
    //  Convert the name to UNICODE
    //

    *Length -= FIELD_OFFSET(FILE_NAME_INFORMATION, FileName[0]);

    //
    //  Use the full filename to build the path up.  If we wanted to be
    //  slick in the future, we'd just build the path directly into the
    //  return buffer and avoid constructing the full filename, but since
    //  the full filename winds up being required so often lets not
    //  over optimize this case yet.
    //
    
    if (Fcb->FullFileName.Buffer == NULL) {

        FatSetFullFileNameInFcb( IrpContext, Fcb );
    }

    //
    //  Here is where it gets a smidge tricky.  FinalNameLength is the length
    //  of the LFN element if it exists, and since the long name is always used
    //  to build FullFileName, we have two cases:
    //
    //  1) short name: use FinalNameLength to tear off the path from FullFileName
    //      and append the UNICODE converted short name.
    //  2) long name: just use FullFileName
    //
    //  We bias to the name the user thinks they opened by.  This winds
    //  up fixing some oddball tunneling cases where intermediate filters
    //  translate operations like delete into renames - this lets them
    //  do the operation in the context of the name the user was using.
    //
    //  It also matches what NTFS does, and so we have the definition of
    //  correct behavior.
    //

    //
    //
    //  Assume there is no long name and we are just going to use 
    //  FullFileName.
    //

    TrimLength = 0;

    //
    //  If a LongName exists and the original open was by the short name
    //  then set TrimLength to point to the place where the short name goes.
    //
    //
    //  Note: The Ccb can be NULL.  The lazy writer calls to get the name of
    //  a DirectoryOpen FILE_OBJECT that it wants to display in the lost
    //  delayed write popup.  Handle this case by just using the FileFullName.
    //

    if (Fcb->LongName.Unicode.Name.Unicode.Buffer != NULL) {

        if ((Ccb != NULL) && FlagOn(Ccb->Flags, CCB_FLAG_OPENED_BY_SHORTNAME)) {

            TrimLength = Fcb->FinalNameLength;

        }

    }

    if (*Length < Fcb->FullFileName.Length - TrimLength) {

        BytesToCopy = *Length;
        Overflow = TRUE;

    } else {

        BytesToCopy = Fcb->FullFileName.Length - TrimLength;
        *Length -= BytesToCopy;
    }

    RtlCopyMemory( &Buffer->FileName[0],
                   Fcb->FullFileName.Buffer,
                   BytesToCopy );

    //
    //  Note that this is just the amount of name we've copied so far.  It'll
    //  either be all of it (long) or the path element including the \ (short).
    //
    
    Buffer->FileNameLength = Fcb->FullFileName.Length - TrimLength;
    
    //
    //  If we trimmed off the name element, this is the short name case.  Pick
    //  up the UNICODE conversion and append it.
    //
    
    if (TrimLength != 0) {

        UNICODE_STRING ShortName;
        WCHAR ShortNameBuffer[12];
        NTSTATUS Status;

        //
        //  Convert the short name to UNICODE and figure out how much
        //  of it can fit.  Again, we always bump the returned length
        //  to indicate how much is available even if we can't return it.
        //

        ShortName.Length = 0;
        ShortName.MaximumLength = sizeof(ShortNameBuffer);
        ShortName.Buffer = ShortNameBuffer;

        Status = RtlOemStringToCountedUnicodeString( &ShortName,
                                                     &Fcb->ShortName.Name.Oem,
                                                     FALSE );

        ASSERT( Status == STATUS_SUCCESS );
        
        if (!Overflow) {
            
            if (*Length < ShortName.Length) {

                BytesToCopy = *Length;
                Overflow = TRUE;
            
            } else {

                BytesToCopy = ShortName.Length;
                *Length -= BytesToCopy;
            }

            RtlCopyMemory( (PUCHAR)&Buffer->FileName[0] + Buffer->FileNameLength,
                           ShortName.Buffer,
                           BytesToCopy );
        }

        Buffer->FileNameLength += ShortName.Length;
    }

    if (Overflow) {
        
        *Length = -1;
    }
    
    //
    //  Return to caller
    //

    DebugTrace( 0, Dbg, "*Length = %08lx\n", *Length);

    DebugTrace(-1, Dbg, "FatQueryNameInfo -> VOID\n", 0);

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}


//
//  Internal Support Routine
//

VOID
FatQueryShortNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PLONG Length
    )

/*++

Routine Description:

    This routine queries the short name of the file.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    NTSTATUS Status;

    ULONG BytesToCopy;
    WCHAR ShortNameBuffer[12];
    UNICODE_STRING ShortName;

    DebugTrace(+1, Dbg, "FatQueryNameInfo...\n", 0);

    //
    //  Convert the name to UNICODE
    //

    ShortName.Length = 0;
    ShortName.MaximumLength = sizeof(ShortNameBuffer);
    ShortName.Buffer = ShortNameBuffer;

    *Length -= FIELD_OFFSET(FILE_NAME_INFORMATION, FileName[0]);

    Status = RtlOemStringToCountedUnicodeString( &ShortName,
                                                 &Fcb->ShortName.Name.Oem,
                                                 FALSE );

    ASSERT( Status == STATUS_SUCCESS );

    //
    //  If we overflow, set *Length to -1 as a flag.
    //

    if (*Length < ShortName.Length) {

        BytesToCopy = *Length;
        *Length = -1;

    } else {

        BytesToCopy = ShortName.Length;
        *Length -= ShortName.Length;
    }

    RtlCopyMemory( &Buffer->FileName[0],
                   &ShortName.Buffer[0],
                   BytesToCopy );

    Buffer->FileNameLength = ShortName.Length;

    //
    //  Return to caller
    //

    DebugTrace( 0, Dbg, "*Length = %08lx\n", *Length);

    DebugTrace(-1, Dbg, "FatQueryNameInfo -> VOID\n", 0);

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}


//
//  Internal Support Routine
//

VOID
FatQueryNetworkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PLONG Length
    )

/*++
 Description:

    This routine performs the query network open information function for fat.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    FileObject - Supplies the flag bit that indicates the file was modified.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "FatQueryNetworkInfo...\n", 0);

    //
    //  Zero out the output buffer, and set it to indicate that
    //  the query is a normal file.  Later we might overwrite the
    //  attribute.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_NETWORK_OPEN_INFORMATION) );

    //
    //  Extract the data and fill in the non zero fields of the output
    //  buffer
    //

    if (Fcb->Header.NodeTypeCode == FAT_NTC_ROOT_DCB) {

        //
        //  We have to munge a lie on the fly.  Every time we have to
        //  use 1/1/80 we need to convert to GMT since the TZ may have
        //  changed on us.
        //

        ExLocalTimeToSystemTime( &FatJanOne1980,
                                 &Buffer->LastWriteTime );
        Buffer->CreationTime = Buffer->LastAccessTime = Buffer->LastWriteTime;

    } else {

        Buffer->LastWriteTime.QuadPart = Fcb->LastWriteTime.QuadPart;
        Buffer->CreationTime.QuadPart = Fcb->CreationTime.QuadPart;
        Buffer->LastAccessTime.QuadPart = Fcb->LastAccessTime.QuadPart;
    }

    Buffer->FileAttributes = Fcb->DirentFatFlags;

    //
    //  If the temporary flag is set, then set it in the buffer.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_TEMPORARY )) {

        SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
    }

    //
    //  If no attributes were set, set the normal bit.
    //

    if (Buffer->FileAttributes == 0) {

        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;
    }
    //
    //  Case on whether this is a file or a directory, and extract
    //  the information and fill in the fcb/dcb specific parts
    //  of the output buffer
    //

    if (NodeType(Fcb) == FAT_NTC_FCB) {

        if (Fcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

            FatLookupFileAllocationSize( IrpContext, Fcb );
        }

        Buffer->AllocationSize.QuadPart = Fcb->Header.AllocationSize.QuadPart;
        Buffer->EndOfFile.QuadPart = Fcb->Header.FileSize.QuadPart;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_NETWORK_OPEN_INFORMATION );

    DebugTrace( 0, Dbg, "*Length = %08lx\n", *Length);

    DebugTrace(-1, Dbg, "FatQueryNetworkInfo -> VOID\n", 0);

    return;
}


//
//  Internal Support routine
//

NTSTATUS
FatSetBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set basic information for fat.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    Irp - Supplies the irp being processed

    Fcb - Supplies the Fcb or Dcb being processed, already known not to
        be the root dcb

    Ccb - Supplies the flag bit that control updating the last modify
        time on cleanup.

Return Value:

    NTSTATUS - The result of this operation if it completes without
               an exception.

--*/

{
    NTSTATUS Status;

    PFILE_BASIC_INFORMATION Buffer;

    PDIRENT Dirent;
    PBCB DirentBcb;

    FAT_TIME_STAMP CreationTime;
    UCHAR CreationMSec;
    FAT_TIME_STAMP LastWriteTime;
    FAT_TIME_STAMP LastAccessTime;
    FAT_DATE LastAccessDate;
    UCHAR Attributes;

    BOOLEAN ModifyCreation = FALSE;
    BOOLEAN ModifyLastWrite = FALSE;
    BOOLEAN ModifyLastAccess = FALSE;

    LARGE_INTEGER LargeCreationTime;
    LARGE_INTEGER LargeLastWriteTime;
    LARGE_INTEGER LargeLastAccessTime;


    ULONG NotifyFilter = 0;

    DebugTrace(+1, Dbg, "FatSetBasicInfo...\n", 0);

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  If the user is specifying -1 for a field, that means
    //  we should leave that field unchanged, even if we might
    //  have otherwise set it ourselves.  We'll set the Ccb flag
    //  saying that the user set the field so that we
    //  don't do our default updating.
    //
    //  We set the field to 0 then so we know not to actually
    //  set the field to the user-specified (and in this case,
    //  illegal) value.
    //

    if (Buffer->LastWriteTime.QuadPart == -1) {

        SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_WRITE );
        Buffer->LastWriteTime.QuadPart = 0;
    }

    if (Buffer->LastAccessTime.QuadPart == -1) {

        SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_ACCESS );
        Buffer->LastAccessTime.QuadPart = 0;
    }

    if (Buffer->CreationTime.QuadPart == -1) {

        SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_CREATION );
        Buffer->CreationTime.QuadPart = 0;
    }

    DirentBcb = NULL;

    Status = STATUS_SUCCESS;

    try {

        LARGE_INTEGER FatLocalDecThirtyOne1979;
        LARGE_INTEGER FatLocalJanOne1980;

        ExLocalTimeToSystemTime( &FatDecThirtyOne1979,
                                 &FatLocalDecThirtyOne1979 );

        ExLocalTimeToSystemTime( &FatJanOne1980,
                                 &FatLocalJanOne1980 );

        //
        //  Get a pointer to the dirent
        //

        ASSERT( Fcb->FcbCondition == FcbGood );
        
        FatGetDirentFromFcbOrDcb( IrpContext,
                                  Fcb,
                                  &Dirent,
                                  &DirentBcb );

        ASSERT( Dirent && DirentBcb );

        //
        //  Check if the user specified a non-zero creation time
        //

        if (FatData.ChicagoMode && (Buffer->CreationTime.QuadPart != 0)) {

            LargeCreationTime = Buffer->CreationTime;

            //
            //  Convert the Nt time to a Fat time
            //

            if ( !FatNtTimeToFatTime( IrpContext,
                                      &LargeCreationTime,
                                      FALSE,
                                      &CreationTime,
                                      &CreationMSec )) {

                //
                //  Special case the value 12/31/79 and treat this as 1/1/80.
                //  This '79 value can happen because of time zone issues.
                //

                if ((LargeCreationTime.QuadPart >= FatLocalDecThirtyOne1979.QuadPart) &&
                    (LargeCreationTime.QuadPart < FatLocalJanOne1980.QuadPart)) {

                    CreationTime = FatTimeJanOne1980;
                    LargeCreationTime = FatLocalJanOne1980;

                } else {

                    DebugTrace(0, Dbg, "Invalid CreationTime\n", 0);
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                //
                //  Don't worry about CreationMSec
                //

                CreationMSec = 0;
            }

            ModifyCreation = TRUE;
        }

        //
        //  Check if the user specified a non-zero last access time
        //

        if (FatData.ChicagoMode && (Buffer->LastAccessTime.QuadPart != 0)) {

            LargeLastAccessTime = Buffer->LastAccessTime;

            //
            //  Convert the Nt time to a Fat time
            //

            if ( !FatNtTimeToFatTime( IrpContext,
                                      &LargeLastAccessTime,
                                      TRUE,
                                      &LastAccessTime,
                                      NULL )) {

                //
                //  Special case the value 12/31/79 and treat this as 1/1/80.
                //  This '79 value can happen because of time zone issues.
                //

                if ((LargeLastAccessTime.QuadPart >= FatLocalDecThirtyOne1979.QuadPart) &&
                    (LargeLastAccessTime.QuadPart < FatLocalJanOne1980.QuadPart)) {

                    LastAccessTime = FatTimeJanOne1980;
                    LargeLastAccessTime = FatLocalJanOne1980;

                } else {

                    DebugTrace(0, Dbg, "Invalid LastAccessTime\n", 0);
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }
            }

            LastAccessDate = LastAccessTime.Date;
            ModifyLastAccess = TRUE;
        }

        //
        //  Check if the user specified a non-zero last write time
        //

        if (Buffer->LastWriteTime.QuadPart != 0) {

            //
            //  First do a quick check here if the this time is the same
            //  time as LastAccessTime.
            //

            if (ModifyLastAccess &&
                (Buffer->LastWriteTime.QuadPart == Buffer->LastAccessTime.QuadPart)) {

                ModifyLastWrite = TRUE;
                LastWriteTime = LastAccessTime;
                LargeLastWriteTime = LargeLastAccessTime;

            } else {

                LargeLastWriteTime = Buffer->LastWriteTime;

                //
                //  Convert the Nt time to a Fat time
                //

                if ( !FatNtTimeToFatTime( IrpContext,
                                          &LargeLastWriteTime,
                                          TRUE,
                                          &LastWriteTime,
                                          NULL )) {


                    //
                    //  Special case the value 12/31/79 and treat this as 1/1/80.
                    //  This '79 value can happen because of time zone issues.
                    //

                    if ((LargeLastWriteTime.QuadPart >= FatLocalDecThirtyOne1979.QuadPart) &&
                        (LargeLastWriteTime.QuadPart < FatLocalJanOne1980.QuadPart)) {

                        LastWriteTime = FatTimeJanOne1980;
                        LargeLastWriteTime = FatLocalJanOne1980;

                    } else {

                        DebugTrace(0, Dbg, "Invalid LastWriteTime\n", 0);
                        try_return( Status = STATUS_INVALID_PARAMETER );
                    }
                }

                ModifyLastWrite = TRUE;
            }
        }


        //
        //  Check if the user specified a non zero file attributes byte
        //

        if (Buffer->FileAttributes != 0) {

            //
            //  Only permit the attributes that FAT understands.  The rest are silently
            //  dropped on the floor.
            //

            Attributes = (UCHAR)(Buffer->FileAttributes & (FILE_ATTRIBUTE_READONLY |
                                                           FILE_ATTRIBUTE_HIDDEN |
                                                           FILE_ATTRIBUTE_SYSTEM |
                                                           FILE_ATTRIBUTE_DIRECTORY |
                                                           FILE_ATTRIBUTE_ARCHIVE));

            //
            //  Make sure that for a file the directory bit is not set
            //  and that for a directory the bit is set.
            //

            if (NodeType(Fcb) == FAT_NTC_FCB) {

                if (FlagOn(Buffer->FileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

                    DebugTrace(0, Dbg, "Attempt to set dir attribute on file\n", 0);
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

            } else {

                Attributes |= FAT_DIRENT_ATTR_DIRECTORY;
            }

            //
            //  Mark the FcbState temporary flag correctly.
            //

            if (FlagOn(Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY)) {

                //
                //  Don't allow the temporary bit to be set on directories.
                //

                if (NodeType(Fcb) == FAT_NTC_DCB) {

                    DebugTrace(0, Dbg, "No temporary directories\n", 0);
                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                SetFlag( Fcb->FcbState, FCB_STATE_TEMPORARY );

                SetFlag( IoGetCurrentIrpStackLocation(Irp)->FileObject->Flags,
                         FO_TEMPORARY_FILE );

            } else {

                ClearFlag( Fcb->FcbState, FCB_STATE_TEMPORARY );

                ClearFlag( IoGetCurrentIrpStackLocation(Irp)->FileObject->Flags,
                           FO_TEMPORARY_FILE );
            }

            //
            //  Set the new attributes byte, and mark the bcb dirty
            //

            Fcb->DirentFatFlags = Attributes;

            Dirent->Attributes = Attributes;

            NotifyFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES;
        }

        if ( ModifyCreation ) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            Fcb->CreationTime = LargeCreationTime;
            Dirent->CreationTime = CreationTime;
            Dirent->CreationMSec = CreationMSec;


            NotifyFilter |= FILE_NOTIFY_CHANGE_CREATION;
            //
            //  Now we have to round the time in the Fcb up to the
            //  nearest tem msec.
            //

            Fcb->CreationTime.QuadPart =

                ((Fcb->CreationTime.QuadPart + AlmostTenMSec) /
                 TenMSec) * TenMSec;

            //
            //  Now because the user just set the creation time we
            //  better not set the creation time on close
            //

            SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_CREATION );
        }

        if ( ModifyLastAccess ) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            Fcb->LastAccessTime = LargeLastAccessTime;
            Dirent->LastAccessDate = LastAccessDate;

            NotifyFilter |= FILE_NOTIFY_CHANGE_LAST_ACCESS;

            //
            //  Now we have to truncate the time in the Fcb down to the
            //  current day.  This has to be in LocalTime though, so first
            //  convert to local, trunacate, then set back to GMT.
            //

            ExSystemTimeToLocalTime( &Fcb->LastAccessTime,
                                     &Fcb->LastAccessTime );

            Fcb->LastAccessTime.QuadPart =

                (Fcb->LastAccessTime.QuadPart /
                 FatOneDay.QuadPart) * FatOneDay.QuadPart;

            ExLocalTimeToSystemTime( &Fcb->LastAccessTime,
                                     &Fcb->LastAccessTime );

            //
            //  Now because the user just set the last access time we
            //  better not set the last access time on close
            //

            SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_ACCESS );
        }

        if ( ModifyLastWrite ) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            Fcb->LastWriteTime = LargeLastWriteTime;
            Dirent->LastWriteTime = LastWriteTime;

            NotifyFilter |= FILE_NOTIFY_CHANGE_LAST_WRITE;

            //
            //  Now we have to round the time in the Fcb up to the
            //  nearest two seconds.
            //

            Fcb->LastWriteTime.QuadPart =

                ((Fcb->LastWriteTime.QuadPart + AlmostTwoSeconds) /
                 TwoSeconds) * TwoSeconds;

            //
            //  Now because the user just set the last write time we
            //  better not set the last write time on close
            //

            SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_WRITE );
        }

        //
        //  If we modified any of the values, we report this to the notify
        //  package.
        //
        //  We also take this opportunity to set the current file size and
        //  first cluster in the Dirent in order to support a server hack.
        //

        if (NotifyFilter != 0) {

            if (NodeType(Fcb) == FAT_NTC_FCB) {

                Dirent->FileSize = Fcb->Header.FileSize.LowPart;

                Dirent->FirstClusterOfFile = (USHORT)Fcb->FirstClusterOfFile;

                if (FatIsFat32(Fcb->Vcb)) {

                    Dirent->FirstClusterOfFileHi =
                            (USHORT)(Fcb->FirstClusterOfFile >> 16);
                }
            }

            FatNotifyReportChange( IrpContext,
                                   Fcb->Vcb,
                                   Fcb,
                                   NotifyFilter,
                                   FILE_ACTION_MODIFIED );

            FatSetDirtyBcb( IrpContext, DirentBcb, Fcb->Vcb, TRUE );
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatSetBasicInfo );

        FatUnpinBcb( IrpContext, DirentBcb );

        DebugTrace(-1, Dbg, "FatSetBasicInfo -> %08lx\n", Status);
    }

    return Status;
}

//
//  Internal Support Routine
//

NTSTATUS
FatSetDispositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine performs the set disposition information for fat.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    Irp - Supplies the irp being processed

    FileObject - Supplies the file object being processed

    Fcb - Supplies the Fcb or Dcb being processed, already known not to
        be the root dcb

Return Value:

    NTSTATUS - The result of this operation if it completes without
               an exception.

--*/

{
    PFILE_DISPOSITION_INFORMATION Buffer;
    PBCB Bcb;
    PDIRENT Dirent;

    DebugTrace(+1, Dbg, "FatSetDispositionInfo...\n", 0);

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Check if the user wants to delete the file or not delete
    //  the file
    //

    if (Buffer->DeleteFile) {

        //
        //  Check if the file is marked read only
        //

        if (FlagOn(Fcb->DirentFatFlags, FAT_DIRENT_ATTR_READ_ONLY)) {

            DebugTrace(-1, Dbg, "Cannot delete readonly file\n", 0);

            return STATUS_CANNOT_DELETE;
        }

        //
        //  Make sure there is no process mapping this file as an image.
        //

        if (!MmFlushImageSection( &Fcb->NonPaged->SectionObjectPointers,
                                  MmFlushForDelete )) {

            DebugTrace(-1, Dbg, "Cannot delete user mapped image\n", 0);

            return STATUS_CANNOT_DELETE;
        }

        //
        //  Check if this is a dcb and if so then only allow
        //  the request if the directory is empty.
        //

        if (NodeType(Fcb) == FAT_NTC_ROOT_DCB) {

            DebugTrace(-1, Dbg, "Cannot delete root Directory\n", 0);

            return STATUS_CANNOT_DELETE;
        }

        if (NodeType(Fcb) == FAT_NTC_DCB) {

            DebugTrace(-1, Dbg, "User wants to delete a directory\n", 0);

            //
            //  Check if the directory is empty
            //

            if ( !FatIsDirectoryEmpty(IrpContext, Fcb) ) {

                DebugTrace(-1, Dbg, "Directory is not empty\n", 0);

                return STATUS_DIRECTORY_NOT_EMPTY;
            }
        }

        //
        //  If this is a floppy, touch the volume so to verify that it
        //  is not write protected.
        //

        if ( FlagOn(Fcb->Vcb->Vpb->RealDevice->Characteristics, FILE_FLOPPY_DISKETTE)) {

            PVCB Vcb;
            PBCB Bcb = NULL;
            UCHAR *Buffer;
            UCHAR TmpChar;
            ULONG BytesToMap;

            IO_STATUS_BLOCK Iosb;

            Vcb = Fcb->Vcb;

            BytesToMap = Vcb->AllocationSupport.FatIndexBitSize == 12 ?
                         FatReservedBytes(&Vcb->Bpb) +
                         FatBytesPerFat(&Vcb->Bpb):PAGE_SIZE;

            FatReadVolumeFile( IrpContext,
                               Vcb,
                               0,
                               BytesToMap,
                               &Bcb,
                               (PVOID *)&Buffer );

            try {

                if (!CcPinMappedData( Vcb->VirtualVolumeFile,
                                      &FatLargeZero,
                                      BytesToMap,
                                      BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                                      &Bcb )) {

                    //
                    // Could not pin the data without waiting (cache miss).
                    //

                    FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
                }

                //
                //  Make Mm, myself, and Cc think the byte is dirty, and then
                //  force a writethrough.
                //

                Buffer += FatReservedBytes(&Vcb->Bpb);

                TmpChar = Buffer[0];
                Buffer[0] = TmpChar;

                FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb,
                                FatReservedBytes( &Vcb->Bpb ),
                                FatReservedBytes( &Vcb->Bpb ),
                                Vcb->Bpb.BytesPerSector );

            } finally {

                if (AbnormalTermination() && (Bcb != NULL)) {

                    FatUnpinBcb( IrpContext, Bcb );
                }
            }

            CcRepinBcb( Bcb );
            CcSetDirtyPinnedData( Bcb, NULL );
            CcUnpinData( Bcb );
            DbgDoit( ASSERT( IrpContext->PinCount ));
            DbgDoit( IrpContext->PinCount -= 1 );
            CcUnpinRepinnedBcb( Bcb, TRUE, &Iosb );

            //
            //  If this was not successful, raise the status.
            //

            if ( !NT_SUCCESS(Iosb.Status) ) {

                FatNormalizeAndRaiseStatus( IrpContext, Iosb.Status );
            }

        } else {

            //
            //  Just set a Bcb dirty here.  The above code was only there to
            //  detect a write protected floppy, while the below code works
            //  for any write protected media and only takes a hit when the
            //  volume in clean.
            //

            FatGetDirentFromFcbOrDcb( IrpContext,
                                      Fcb,
                                      &Dirent,
                                      &Bcb );

            //
            //  This has to work for the usual reasons (we verified the Fcb within
            //  volume synch).
            //
            
            ASSERT( Bcb != NULL );

            try {

                FatSetDirtyBcb( IrpContext, Bcb, Fcb->Vcb, TRUE );

            } finally {

                FatUnpinBcb( IrpContext, Bcb );
            }
        }

        //
        //  At this point either we have a file or an empty directory
        //  so we know the delete can proceed.
        //

        SetFlag( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );
        FileObject->DeletePending = TRUE;

        //
        //  If this is a directory then report this delete pending to
        //  the dir notify package.
        //

        if (NodeType(Fcb) == FAT_NTC_DCB) {

            FsRtlNotifyFullChangeDirectory( Fcb->Vcb->NotifySync,
                                            &Fcb->Vcb->DirNotifyList,
                                            FileObject->FsContext,
                                            NULL,
                                            FALSE,
                                            FALSE,
                                            0,
                                            NULL,
                                            NULL,
                                            NULL );
        }
    } else {

        //
        //  The user doesn't want to delete the file so clear
        //  the delete on close bit
        //

        DebugTrace(0, Dbg, "User want to not delete file\n", 0);

        ClearFlag( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );
        FileObject->DeletePending = FALSE;
    }

    DebugTrace(-1, Dbg, "FatSetDispositionInfo -> STATUS_SUCCESS\n", 0);

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
FatSetRenameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the set name information for fat.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    Irp - Supplies the irp being processed

    Vcb - Supplies the Vcb being processed

    Fcb - Supplies the Fcb or Dcb being processed, already known not to
        be the root dcb

    Ccb - Supplies the Ccb corresponding to the handle opening the source
        file

Return Value:

    NTSTATUS - The result of this operation if it completes without
               an exception.

--*/

{
    BOOLEAN AllLowerComponent;
    BOOLEAN AllLowerExtension;
    BOOLEAN CaseOnlyRename;
    BOOLEAN ContinueWithRename;
    BOOLEAN CreateLfn;
    BOOLEAN DeleteSourceDirent;
    BOOLEAN DeleteTarget;
    BOOLEAN NewDirentFromPool;
    BOOLEAN RenamedAcrossDirectories;
    BOOLEAN ReplaceIfExists;

    CCB LocalCcb;
    PCCB SourceCcb;

    DIRENT SourceDirent;

    NTSTATUS Status;

    OEM_STRING OldOemName;
    OEM_STRING NewOemName;
    UCHAR OemNameBuffer[24*2];

    PBCB DotDotBcb;
    PBCB NewDirentBcb;
    PBCB OldDirentBcb;
    PBCB SecondPageBcb;
    PBCB TargetDirentBcb;

    PDCB TargetDcb;
    PDCB OldParentDcb;

    PDIRENT DotDotDirent;
    PDIRENT FirstPageDirent;
    PDIRENT NewDirent;
    PDIRENT OldDirent;
    PDIRENT SecondPageDirent;
    PDIRENT ShortDirent;
    PDIRENT TargetDirent;

    PFCB TempFcb;

    PFILE_OBJECT TargetFileObject;
    PFILE_OBJECT FileObject;

    PIO_STACK_LOCATION IrpSp;

    PLIST_ENTRY Links;

    ULONG BytesInFirstPage;
    ULONG DirentsInFirstPage;
    ULONG DirentsRequired;
    ULONG NewOffset;
    ULONG NotifyAction;
    ULONG SecondPageOffset;
    ULONG ShortDirentOffset;
    ULONG TargetDirentOffset;
    ULONG TargetLfnOffset;

    UNICODE_STRING NewName;
    UNICODE_STRING NewUpcasedName;
    UNICODE_STRING OldName;
    UNICODE_STRING OldUpcasedName;
    UNICODE_STRING TargetLfn;

    PWCHAR UnicodeBuffer;

    UNICODE_STRING UniTunneledShortName;
    WCHAR UniTunneledShortNameBuffer[12];
    UNICODE_STRING UniTunneledLongName;
    WCHAR UniTunneledLongNameBuffer[26];
    LARGE_INTEGER TunneledCreationTime;
    ULONG TunneledDataSize;
    BOOLEAN HaveTunneledInformation;
    BOOLEAN UsingTunneledLfn = FALSE;

    BOOLEAN InvalidateFcbOnRaise = FALSE;

    DebugTrace(+1, Dbg, "FatSetRenameInfo...\n", 0);

    //
    //  P H A S E  0: Initialize some variables.
    //

    CaseOnlyRename = FALSE;
    ContinueWithRename = FALSE;
    DeleteSourceDirent = FALSE;
    DeleteTarget = FALSE;
    NewDirentFromPool = FALSE;
    RenamedAcrossDirectories = FALSE;

    DotDotBcb = NULL;
    NewDirentBcb = NULL;
    OldDirentBcb = NULL;
    SecondPageBcb = NULL;
    TargetDirentBcb = NULL;

    NewOemName.Length = 0;
    NewOemName.MaximumLength = 24;
    NewOemName.Buffer = &OemNameBuffer[0];

    OldOemName.Length = 0;
    OldOemName.MaximumLength = 24;
    OldOemName.Buffer = &OemNameBuffer[24];

    UnicodeBuffer = FsRtlAllocatePoolWithTag( PagedPool,
                                              4 * MAX_LFN_CHARACTERS * sizeof(WCHAR),
                                              TAG_FILENAME_BUFFER );

    NewUpcasedName.Length = 0;
    NewUpcasedName.MaximumLength = MAX_LFN_CHARACTERS * sizeof(WCHAR);
    NewUpcasedName.Buffer = &UnicodeBuffer[0];

    OldName.Length = 0;
    OldName.MaximumLength = MAX_LFN_CHARACTERS * sizeof(WCHAR);
    OldName.Buffer = &UnicodeBuffer[MAX_LFN_CHARACTERS];

    OldUpcasedName.Length = 0;
    OldUpcasedName.MaximumLength = MAX_LFN_CHARACTERS * sizeof(WCHAR);
    OldUpcasedName.Buffer = &UnicodeBuffer[MAX_LFN_CHARACTERS * 2];

    TargetLfn.Length = 0;
    TargetLfn.MaximumLength = MAX_LFN_CHARACTERS * sizeof(WCHAR);
    TargetLfn.Buffer = &UnicodeBuffer[MAX_LFN_CHARACTERS * 3];

    UniTunneledShortName.Length = 0;
    UniTunneledShortName.MaximumLength = sizeof(UniTunneledShortNameBuffer);
    UniTunneledShortName.Buffer = &UniTunneledShortNameBuffer[0];

    UniTunneledLongName.Length = 0;
    UniTunneledLongName.MaximumLength = sizeof(UniTunneledLongNameBuffer);
    UniTunneledLongName.Buffer = &UniTunneledLongNameBuffer[0];

    //
    //  Remember the name in case we have to modify the name
    //  value in the ea.
    //

    RtlCopyMemory( OldOemName.Buffer,
                   Fcb->ShortName.Name.Oem.Buffer,
                   OldOemName.Length );

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract information from the Irp to make our life easier
    //

    FileObject = IrpSp->FileObject;
    SourceCcb = FileObject->FsContext2;
    TargetFileObject = IrpSp->Parameters.SetFile.FileObject;
    ReplaceIfExists = IrpSp->Parameters.SetFile.ReplaceIfExists;

    RtlZeroMemory( &LocalCcb, sizeof(CCB) );

    //
    //  P H A S E  1:
    //
    //  Test if rename is legal.  Only small side-effects are not undone.
    //

    try {

        //
        //  Can't rename the root directory
        //

        if ( NodeType(Fcb) == FAT_NTC_ROOT_DCB ) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  Check that we were not given a dcb with open handles beneath
        //  it.  If there are only UncleanCount == 0 Fcbs beneath us, then
        //  remove them from the prefix table, and they will just close
        //  and go away naturally.
        //

        if (NodeType(Fcb) == FAT_NTC_DCB) {

            PFCB BatchOplockFcb;
            ULONG BatchOplockCount;

            //
            //  Loop until there are no batch oplocks in the subtree below
            //  this directory.
            //

            while (TRUE) {

                BatchOplockFcb = NULL;
                BatchOplockCount = 0;

                //
                //  First look for any UncleanCount != 0 Fcbs, and fail if we
                //  find any.
                //

                for ( TempFcb = FatGetNextFcbBottomUp(IrpContext, NULL, Fcb);
                      TempFcb != Fcb;
                      TempFcb = FatGetNextFcbBottomUp(IrpContext, TempFcb, Fcb) ) {

                     if ( TempFcb->UncleanCount != 0 ) {

                         //
                         // If there is a batch oplock on this file then
                         // increment our count and remember the Fcb if
                         // this is the first.
                         //

                         if ( (NodeType(TempFcb) == FAT_NTC_FCB) &&
                              FsRtlCurrentBatchOplock( &TempFcb->Specific.Fcb.Oplock ) ) {

                             BatchOplockCount += 1;
                             if ( BatchOplockFcb == NULL ) {

                                 BatchOplockFcb = TempFcb;
                             }

                         } else {

                            try_return( Status = STATUS_ACCESS_DENIED );
                         }
                     }
                }

                //
                //  If this is not the first pass for rename and the number
                //  of batch oplocks has not decreased then give up.
                //

                if ( BatchOplockFcb != NULL ) {

                    if ( (Irp->IoStatus.Information != 0) &&
                         (BatchOplockCount >= Irp->IoStatus.Information) ) {

                        try_return( Status = STATUS_ACCESS_DENIED );
                    }

                    //
                    //  Try to break this batch oplock.
                    //

                    Irp->IoStatus.Information = BatchOplockCount;
                    Status = FsRtlCheckOplock( &BatchOplockFcb->Specific.Fcb.Oplock,
                                               Irp,
                                               IrpContext,
                                               FatOplockComplete,
                                               NULL );

                    //
                    //  If the oplock was already broken then look for more
                    //  batch oplocks.
                    //

                    if (Status == STATUS_SUCCESS) {

                        continue;
                    }

                    //
                    //  Otherwise the oplock package will post or complete the
                    //  request.
                    //

                    try_return( Status = STATUS_PENDING );
                }

                break;
            }

            //
            //  Now try to get as many of these file object, and thus Fcbs
            //  to go away as possible, flushing first, of course.
            //

            FatPurgeReferencedFileObjects( IrpContext, Fcb, TRUE );

            //
            //  OK, so there are no UncleanCount != 0, Fcbs.  Infact, there
            //  shouldn't really be any Fcbs left at all, except obstinate
            //  ones from user mapped sections ....oh well, he shouldn't have
            //  closed his handle if he wanted the file to stick around.  So
            //  remove any Fcbs beneath us from the splay table and mark them
            //  DELETE_ON_CLOSE so that any future operations will fail.
            //

            for ( TempFcb = FatGetNextFcbBottomUp(IrpContext, NULL, Fcb);
                  TempFcb != Fcb;
                  TempFcb = FatGetNextFcbBottomUp(IrpContext, TempFcb, Fcb) ) {

                FatRemoveNames( IrpContext, TempFcb );

                SetFlag( TempFcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );
            }
        }

        //
        //  Check if this is a simple rename or a fully-qualified rename
        //  In both cases we need to figure out what the TargetDcb, and
        //  NewName are.
        //

        if (TargetFileObject == NULL) {

            //
            //  In the case of a simple rename the target dcb is the
            //  same as the source file's parent dcb, and the new file name
            //  is taken from the system buffer
            //

            PFILE_RENAME_INFORMATION Buffer;

            Buffer = Irp->AssociatedIrp.SystemBuffer;

            TargetDcb = Fcb->ParentDcb;

            NewName.Length = (USHORT) Buffer->FileNameLength;
            NewName.Buffer = (PWSTR) &Buffer->FileName;

            //
            //  Make sure the name is of legal length.
            //

            if (NewName.Length >= 255*sizeof(WCHAR)) {

                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

        } else {

            //
            //  For a fully-qualified rename the target dcb is taken from
            //  the target file object, which must be on the same vcb as
            //  the source.
            //

            PVCB TargetVcb;
            PCCB TargetCcb;

            if ((FatDecodeFileObject( TargetFileObject,
                                      &TargetVcb,
                                      &TargetDcb,
                                      &TargetCcb ) != UserDirectoryOpen) ||
                (TargetVcb != Vcb)) {

                try_return( Status = STATUS_INVALID_PARAMETER );
            }

            //
            //  This name is by definition legal.
            //

            NewName = *((PUNICODE_STRING)&TargetFileObject->FileName);
        }

        //
        //  We will need an upcased version of the unicode name and the
        //  old name as well.
        //

        Status = RtlUpcaseUnicodeString( &NewUpcasedName, &NewName, FALSE );

        if (!NT_SUCCESS(Status)) {

            try_return( Status );
        }

        FatGetUnicodeNameFromFcb( IrpContext, Fcb, &OldName );

        Status = RtlUpcaseUnicodeString( &OldUpcasedName, &OldName, FALSE );

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        //
        //  Check if the current name and new name are equal, and the
        //  DCBs are equal.  If they are then our work is already done.
        //

        if (TargetDcb == Fcb->ParentDcb) {

            //
            //  OK, now if we found something then check if it was an exact
            //  match or just a case match.  If it was an exact match, then
            //  we can bail here.
            //

            if (FsRtlAreNamesEqual( &NewName,
                                    &OldName,
                                    FALSE,
                                    NULL )) {

                 try_return( Status = STATUS_SUCCESS );
            }

            //
            //  Check now for a case only rename.
            //


            if (FsRtlAreNamesEqual( &NewUpcasedName,
                                    &OldUpcasedName,
                                    FALSE,
                                    NULL )) {

                 CaseOnlyRename = TRUE;
            }

        } else {

            RenamedAcrossDirectories = TRUE;
        }

        //
        //  Upcase the name and convert it to the Oem code page.
        //
        //  If the new UNICODE name is already more than 12 characters,
        //  then we know the Oem name will not be valid
        //

        if (NewName.Length <= 12*sizeof(WCHAR)) {

            FatUnicodeToUpcaseOem( IrpContext, &NewOemName, &NewName );

            //
            //  If the name is not valid 8.3, zero the length.
            //

            if (FatSpaceInName( IrpContext, &NewName ) ||
                !FatIsNameShortOemValid( IrpContext, NewOemName, FALSE, FALSE, FALSE)) {

                NewOemName.Length = 0;
            }

        } else {

            NewOemName.Length = 0;
        }

        //
        //  Look in the tunnel cache for names and timestamps to restore
        //

        TunneledDataSize = sizeof(LARGE_INTEGER);
        HaveTunneledInformation = FsRtlFindInTunnelCache( &Vcb->Tunnel,
                                                          FatDirectoryKey(TargetDcb),
                                                          &NewName,
                                                          &UniTunneledShortName,
                                                          &UniTunneledLongName,
                                                          &TunneledDataSize,
                                                          &TunneledCreationTime );
        ASSERT(TunneledDataSize == sizeof(LARGE_INTEGER));

        //
        //  Now we need to determine how many dirents this new name will
        //  require.
        //

        if ((NewOemName.Length == 0) ||
            (FatEvaluateNameCase( IrpContext,
                                  &NewName,
                                  &AllLowerComponent,
                                  &AllLowerExtension,
                                  &CreateLfn ),
             CreateLfn)) {

            DirentsRequired = FAT_LFN_DIRENTS_NEEDED(&NewName) + 1;

        } else {

            //
            //  The user-given name is a short name, but we might still have
            //  a tunneled long name we want to use. See if we can.
            //

            if (UniTunneledLongName.Length && 
                !FatLfnDirentExists(IrpContext, TargetDcb, &UniTunneledLongName, &TargetLfn)) {

                UsingTunneledLfn = CreateLfn = TRUE;
                DirentsRequired = FAT_LFN_DIRENTS_NEEDED(&UniTunneledLongName) + 1;

            } else {

                //
                //  This really is a simple dirent.  Note that the two AllLower BOOLEANs
                //  are correctly set now.
                //

                DirentsRequired = 1;
            }
        }

        //
        //  Do some extra checks here if we are not in Chicago mode.
        //

        if (!FatData.ChicagoMode) {

            //
            //  If the name was not 8.3 valid, fail the rename.
            //

            if (NewOemName.Length == 0) {

                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            //
            //  Don't use the magic bits.
            //

            AllLowerComponent = FALSE;
            AllLowerExtension = FALSE;
            CreateLfn = FALSE;
            UsingTunneledLfn = FALSE;
        }

        if (!CaseOnlyRename) {

            //
            //  Check if the new name already exists, wait is known to be
            //  true.
            //

            if (NewOemName.Length != 0) {

                FatStringTo8dot3( IrpContext,
                                  NewOemName,
                                  &LocalCcb.OemQueryTemplate.Constant );

            } else {

                SetFlag( LocalCcb.Flags, CCB_FLAG_SKIP_SHORT_NAME_COMPARE );
            }

            LocalCcb.UnicodeQueryTemplate = NewUpcasedName;
            LocalCcb.ContainsWildCards = FALSE;

            FatLocateDirent( IrpContext,
                             TargetDcb,
                             &LocalCcb,
                             0,
                             &TargetDirent,
                             &TargetDirentBcb,
                             &TargetDirentOffset,
                             NULL,
                             &TargetLfn);

            if (TargetDirent != NULL) {

                //
                //  The name already exists, check if the user wants
                //  to overwrite the name, and has access to do the overwrite
                //  We cannot overwrite a directory.
                //

                if ((!ReplaceIfExists) ||
                    (FlagOn(TargetDirent->Attributes, FAT_DIRENT_ATTR_DIRECTORY)) ||
                    (FlagOn(TargetDirent->Attributes, FAT_DIRENT_ATTR_READ_ONLY))) {

                    try_return( Status = STATUS_OBJECT_NAME_COLLISION );
                }

                //
                //  Check that the file has no open user handles, if it does
                //  then we will deny access.  We do the check by searching
                //  down the list of fcbs opened under our parent Dcb, and making
                //  sure none of the maching Fcbs have a non-zero unclean count or
                //  outstanding image sections.
                //

                for (Links = TargetDcb->Specific.Dcb.ParentDcbQueue.Flink;
                     Links != &TargetDcb->Specific.Dcb.ParentDcbQueue; ) {

                    TempFcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

                    //
                    //  Advance now.  The image section flush may cause the final
                    //  close, which will recursively happen underneath of us here.
                    //  It would be unfortunate if we looked through free memory.
                    //

                    Links = Links->Flink;

                    if ((TempFcb->DirentOffsetWithinDirectory == TargetDirentOffset) &&
                        ((TempFcb->UncleanCount != 0) ||
                         !MmFlushImageSection( &TempFcb->NonPaged->SectionObjectPointers,
                                               MmFlushForDelete))) {

                        //
                        //  If there are batch oplocks on this file then break the
                        //  oplocks before failing the rename.
                        //

                        Status = STATUS_ACCESS_DENIED;

                        if ((NodeType(TempFcb) == FAT_NTC_FCB) &&
                            FsRtlCurrentBatchOplock( &TempFcb->Specific.Fcb.Oplock )) {

                            //
                            //  Do all of our cleanup now since the IrpContext
                            //  could go away when this request is posted.
                            //

                            FatUnpinBcb( IrpContext, TargetDirentBcb );

                            Status = FsRtlCheckOplock( &TempFcb->Specific.Fcb.Oplock,
                                                       Irp,
                                                       IrpContext,
                                                       FatOplockComplete,
                                                       NULL );

                            if (Status != STATUS_PENDING) {

                                Status = STATUS_ACCESS_DENIED;
                            }
                        }

                        try_return( NOTHING );
                    }
                }

                //
                //  OK, this target is toast.  Remember the Lfn offset.
                //

                TargetLfnOffset = TargetDirentOffset -
                                  FAT_LFN_DIRENTS_NEEDED(&TargetLfn) *
                                  sizeof(DIRENT);

                DeleteTarget = TRUE;
            }
        }

        //
        //  If we will need more dirents than we have, allocate them now.
        //

        if ((TargetDcb != Fcb->ParentDcb) ||
            (DirentsRequired !=
             (Fcb->DirentOffsetWithinDirectory -
              Fcb->LfnOffsetWithinDirectory) / sizeof(DIRENT) + 1)) {

            //
            //  Get some new allocation
            //

            NewOffset = FatCreateNewDirent( IrpContext,
                                            TargetDcb,
                                            DirentsRequired );

            DeleteSourceDirent = TRUE;

        } else {

            NewOffset = Fcb->LfnOffsetWithinDirectory;
        }

        ContinueWithRename = TRUE;

    try_exit: NOTHING;

    } finally {

        if (!ContinueWithRename) {

            //
            //  Undo everything from above.
            //

            ExFreePool( UnicodeBuffer );
            FatUnpinBcb( IrpContext, TargetDirentBcb );
        }
    }

    //
    //  Now, if we are already done, return here.
    //

    if (!ContinueWithRename) {

        return Status;
    }

    //
    //  P H A S E  2: Actually perform the rename.
    //

    try {

        //
        //  Report the fact that we are going to remove this entry.
        //  If we renamed within the same directory and the new name for the
        //  file did not previously exist, we report this as a rename old
        //  name.  Otherwise this is a removed file.
        //

        if (!RenamedAcrossDirectories && !DeleteTarget) {

            NotifyAction = FILE_ACTION_RENAMED_OLD_NAME;

        } else {

            NotifyAction = FILE_ACTION_REMOVED;
        }

        FatNotifyReportChange( IrpContext,
                               Vcb,
                               Fcb,
                               ((NodeType( Fcb ) == FAT_NTC_FCB)
                                ? FILE_NOTIFY_CHANGE_FILE_NAME
                                : FILE_NOTIFY_CHANGE_DIR_NAME ),
                               NotifyAction );

        //
        //  Capture a copy of the source dirent.
        //

        FatGetDirentFromFcbOrDcb( IrpContext, Fcb, &OldDirent, &OldDirentBcb );
        SourceDirent = *OldDirent;

        try {

            //
            //  Tunnel the source Fcb - the names are disappearing regardless of
            //  whether the dirent allocation physically changed
            //

            FatTunnelFcbOrDcb( Fcb, SourceCcb );

            //
            //  From here until very nearly the end of the operation, if we raise there
            //  is no reasonable way to suppose we'd be able to undo the damage.  Not
            //  being a transactional filesystem, FAT is at the mercy of a lot of things
            //  (as the astute reader has no doubt realized by now).
            //

            InvalidateFcbOnRaise = TRUE;

            //
            //  Delete our current dirent(s) if we got a new one.
            //

            if (DeleteSourceDirent) {

                FatDeleteDirent( IrpContext, Fcb, NULL, FALSE );
            }

            //
            //  Delete a target conflict if we were meant to.
            //

            if (DeleteTarget) {

                FatDeleteFile( IrpContext,
                               TargetDcb,
                               TargetLfnOffset,
                               TargetDirentOffset,
                               TargetDirent,
                               &TargetLfn );
            }

            //
            //  We need to evaluate any short names required.  If there were any
            //  conflicts in existing short names, they would have been deleted above.
            //
            //  It isn't neccesary to worry about the UsingTunneledLfn case. Since we
            //  actually already know whether CreateLfn will be set either NewName is
            //  an Lfn and !UsingTunneledLfn is implied or NewName is a short name and
            //  we can handle that externally.
            //

            FatSelectNames( IrpContext,
                            TargetDcb,
                            &NewOemName,
                            &NewName,
                            &NewOemName,
                            (HaveTunneledInformation ? &UniTunneledShortName : NULL),
                            &AllLowerComponent,
                            &AllLowerExtension,
                            &CreateLfn );

            if (!CreateLfn && UsingTunneledLfn) {

                CreateLfn = TRUE;
                NewName = UniTunneledLongName;

                //
                //  Short names are always upcase if an LFN exists
                //

                AllLowerComponent = FALSE;
                AllLowerExtension = FALSE;
            }

            //
            //  OK, now setup the new dirent(s) for the new name.
            //

            FatPrepareWriteDirectoryFile( IrpContext,
                                          TargetDcb,
                                          NewOffset,
                                          sizeof(DIRENT),
                                          &NewDirentBcb,
                                          &NewDirent,
                                          FALSE,
                                          TRUE,
                                          &Status );

            ASSERT( NT_SUCCESS( Status ) );

            //
            //  Deal with the special case of an LFN + Dirent structure crossing
            //  a page boundry.
            //

            if ((NewOffset / PAGE_SIZE) !=
                ((NewOffset + (DirentsRequired - 1) * sizeof(DIRENT)) / PAGE_SIZE)) {

                SecondPageOffset = (NewOffset & ~(PAGE_SIZE - 1)) + PAGE_SIZE;

                BytesInFirstPage = SecondPageOffset - NewOffset;

                DirentsInFirstPage = BytesInFirstPage / sizeof(DIRENT);

                FatPrepareWriteDirectoryFile( IrpContext,
                                              TargetDcb,
                                              SecondPageOffset,
                                              sizeof(DIRENT),
                                              &SecondPageBcb,
                                              &SecondPageDirent,
                                              FALSE,
                                              TRUE,
                                              &Status );

                ASSERT( NT_SUCCESS( Status ) );

                FirstPageDirent = NewDirent;

                NewDirent = FsRtlAllocatePoolWithTag( PagedPool,
                                                      DirentsRequired * sizeof(DIRENT),
                                                      TAG_DIRENT );

                NewDirentFromPool = TRUE;
            }

            //
            //  Bump up Dirent and DirentOffset
            //

            ShortDirent = NewDirent + DirentsRequired - 1;
            ShortDirentOffset = NewOffset + (DirentsRequired - 1) * sizeof(DIRENT);

            //
            //  Fill in the fields of the dirent.
            //

            *ShortDirent = SourceDirent;

            FatConstructDirent( IrpContext,
                                ShortDirent,
                                &NewOemName,
                                AllLowerComponent,
                                AllLowerExtension,
                                CreateLfn ? &NewName : NULL,
                                SourceDirent.Attributes,
                                FALSE,
                                (HaveTunneledInformation ? &TunneledCreationTime : NULL) );

            if (HaveTunneledInformation) {

                //
                //  Need to go in and fix the timestamps in the FCB. Note that we can't use
                //  the TunneledCreationTime since the conversions may have failed.
                //

                Fcb->CreationTime = FatFatTimeToNtTime(IrpContext, ShortDirent->CreationTime, ShortDirent->CreationMSec);
                Fcb->LastWriteTime = FatFatTimeToNtTime(IrpContext, ShortDirent->LastWriteTime, 0);
                Fcb->LastAccessTime = FatFatDateToNtTime(IrpContext, ShortDirent->LastAccessDate);
            }

            //
            //  If the dirent crossed pages, split the contents of the
            //  temporary pool between the two pages.
            //

            if (NewDirentFromPool) {

                RtlCopyMemory( FirstPageDirent, NewDirent, BytesInFirstPage );

                RtlCopyMemory( SecondPageDirent,
                               NewDirent + DirentsInFirstPage,
                               DirentsRequired*sizeof(DIRENT) - BytesInFirstPage );

                ShortDirent = SecondPageDirent +
                              (DirentsRequired - DirentsInFirstPage) - 1;
            }

        } finally {

            //
            //  Remove the entry from the splay table, and then remove the
            //  full file name and exact case lfn. It is important that we
            //  always remove the name from the prefix table regardless of
            //  other errors.
            //

            FatRemoveNames( IrpContext, Fcb );

            if (Fcb->FullFileName.Buffer != NULL) {

                ExFreePool( Fcb->FullFileName.Buffer );
                Fcb->FullFileName.Buffer = NULL;
            }

            if (Fcb->ExactCaseLongName.Buffer) {

                ExFreePool( Fcb->ExactCaseLongName.Buffer );
                Fcb->ExactCaseLongName.Buffer = NULL;
            }
        }

        //
        //  Now we need to update the location of the file's directory
        //  offset and move the fcb from its current parent dcb to
        //  the target dcb.
        //

        Fcb->LfnOffsetWithinDirectory = NewOffset;
        Fcb->DirentOffsetWithinDirectory = ShortDirentOffset;

        RemoveEntryList( &Fcb->ParentDcbLinks );

        //
        //  There is a deep reason we put files on the tail, others on the head,
        //  which is to allow us to easily enumerate all child directories before
        //  child files. This is important to let us maintain whole-volume lockorder
        //  via BottomUp enumeration.
        //

        if (NodeType(Fcb) == FAT_NTC_FCB) {

            InsertTailList( &TargetDcb->Specific.Dcb.ParentDcbQueue,
                            &Fcb->ParentDcbLinks );

        } else {

            InsertHeadList( &TargetDcb->Specific.Dcb.ParentDcbQueue,
                            &Fcb->ParentDcbLinks );
        }

        OldParentDcb = Fcb->ParentDcb;
        Fcb->ParentDcb = TargetDcb;

        //
        //  If we renamed across directories, some cleanup is now in order.
        //

        if (RenamedAcrossDirectories) {

            //
            //  See if we need to uninitialize the cachemap for the source directory.
            //  Do this now in case we get unlucky and raise trying to finalize the
            //  operation.
            //

            if (IsListEmpty(&OldParentDcb->Specific.Dcb.ParentDcbQueue) &&
                (OldParentDcb->OpenCount == 0) &&
                (OldParentDcb->Specific.Dcb.DirectoryFile != NULL)) {

                PFILE_OBJECT DirectoryFileObject;

                ASSERT( NodeType(OldParentDcb) == FAT_NTC_DCB );

                DirectoryFileObject = OldParentDcb->Specific.Dcb.DirectoryFile;

                DebugTrace(0, Dbg, "Uninitialize our parent Stream Cache Map\n", 0);

                CcUninitializeCacheMap( DirectoryFileObject, NULL, NULL );

                OldParentDcb->Specific.Dcb.DirectoryFile = NULL;

                ObDereferenceObject( DirectoryFileObject );
            }

            //
            //  If we move a directory across directories, we have to change
            //  the cluster number in its .. entry
            //

            if (NodeType(Fcb) == FAT_NTC_DCB) {

                FatPrepareWriteDirectoryFile( IrpContext,
                                              Fcb,
                                              sizeof(DIRENT),
                                              sizeof(DIRENT),
                                              &DotDotBcb,
                                              &DotDotDirent,
                                              FALSE,
                                              TRUE,
                                              &Status );

                ASSERT( NT_SUCCESS( Status ) );

                DotDotDirent->FirstClusterOfFile = (USHORT)
                    ( NodeType(TargetDcb) == FAT_NTC_ROOT_DCB ?
                      0 : TargetDcb->FirstClusterOfFile);

                if (FatIsFat32( Vcb )) {

                    DotDotDirent->FirstClusterOfFileHi = (USHORT)
                    ( NodeType( TargetDcb ) == FAT_NTC_ROOT_DCB ?
                      0 : (TargetDcb->FirstClusterOfFile >> 16));
                }
            }
        }

        //
        //  Now we need to setup the splay table and the name within
        //  the fcb.  Free the old short name at this point.
        //

        ExFreePool( Fcb->ShortName.Name.Oem.Buffer );
        Fcb->ShortName.Name.Oem.Buffer = NULL;

        FatConstructNamesInFcb( IrpContext,
                                Fcb,
                                ShortDirent,
                                CreateLfn ? &NewName : NULL );

        FatSetFullNameInFcb( IrpContext, Fcb, &NewName );

        //
        //  The rest of the actions taken are not related to correctness of
        //  the in-memory structures, so we shouldn't toast the Fcb if we
        //  raise from here to the end.
        //

        InvalidateFcbOnRaise = FALSE;

        //
        //  If a file, set the file as modified so that the archive bit
        //  is set.  We prevent this from adjusting the write time by
        //  indicating the user flag in the ccb.
        //

        if (Fcb->Header.NodeTypeCode == FAT_NTC_FCB) {

            SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
            SetFlag( Ccb->Flags, CCB_FLAG_USER_SET_LAST_WRITE );
        }

        //
        //  We have three cases to report.
        //
        //      1.  If we overwrote an existing file, we report this as
        //          a modified file.
        //
        //      2.  If we renamed to a new directory, then we added a file.
        //
        //      3.  If we renamed in the same directory, then we report the
        //          the renamednewname.
        //

        if (DeleteTarget) {

            FatNotifyReportChange( IrpContext,
                                   Vcb,
                                   Fcb,
                                   FILE_NOTIFY_CHANGE_ATTRIBUTES
                                   | FILE_NOTIFY_CHANGE_SIZE
                                   | FILE_NOTIFY_CHANGE_LAST_WRITE
                                   | FILE_NOTIFY_CHANGE_LAST_ACCESS
                                   | FILE_NOTIFY_CHANGE_CREATION
                                   | FILE_NOTIFY_CHANGE_EA,
                                   FILE_ACTION_MODIFIED );

        } else if (RenamedAcrossDirectories) {

            FatNotifyReportChange( IrpContext,
                                   Vcb,
                                   Fcb,
                                   ((NodeType( Fcb ) == FAT_NTC_FCB)
                                    ? FILE_NOTIFY_CHANGE_FILE_NAME
                                    : FILE_NOTIFY_CHANGE_DIR_NAME ),
                                   FILE_ACTION_ADDED );

        } else {

            FatNotifyReportChange( IrpContext,
                                   Vcb,
                                   Fcb,
                                   ((NodeType( Fcb ) == FAT_NTC_FCB)
                                    ? FILE_NOTIFY_CHANGE_FILE_NAME
                                    : FILE_NOTIFY_CHANGE_DIR_NAME ),
                                   FILE_ACTION_RENAMED_NEW_NAME );
        }

        //
        //  We need to update the file name in the dirent.  This value
        //  is never used elsewhere, so we don't concern ourselves
        //  with any error we may encounter.  We let chkdsk fix the
        //  disk at some later time.
        //

        if (!FatIsFat32(Vcb) &&
            ShortDirent->ExtendedAttributes != 0) {

            FatRenameEAs( IrpContext,
                          Fcb,
                          ShortDirent->ExtendedAttributes,
                          &OldOemName );
        }

        //
        //  Set our final status
        //

        Status = STATUS_SUCCESS;

    } finally {

        DebugUnwind( FatSetRenameInfo );

        ExFreePool( UnicodeBuffer );

        if (UniTunneledLongName.Buffer != UniTunneledLongNameBuffer) {

            //
            //  Free pool if the buffer was grown on tunneling lookup
            //

            ExFreePool(UniTunneledLongName.Buffer);
        }

        FatUnpinBcb( IrpContext, OldDirentBcb );
        FatUnpinBcb( IrpContext, TargetDirentBcb );
        FatUnpinBcb( IrpContext, NewDirentBcb );
        FatUnpinBcb( IrpContext, SecondPageBcb );
        FatUnpinBcb( IrpContext, DotDotBcb );


        //
        //  If this was an abnormal termination, then we are in trouble.
        //  Should the operation have been in a sensitive state there is
        //  nothing we can do but invalidate the Fcb.
        //

        if (AbnormalTermination() && InvalidateFcbOnRaise) {

            Fcb->FcbCondition = FcbBad;
        }

        DebugTrace(-1, Dbg, "FatSetRenameInfo -> %08lx\n", Status);
    }

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
FatSetPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine performs the set position information for fat.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    Irp - Supplies the irp being processed

    FileObject - Supplies the file object being processed

Return Value:

    NTSTATUS - The result of this operation if it completes without
               an exception.

--*/

{
    PFILE_POSITION_INFORMATION Buffer;

    DebugTrace(+1, Dbg, "FatSetPositionInfo...\n", 0);

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Check if the file does not use intermediate buffering.  If it
    //  does not use intermediate buffering then the new position we're
    //  supplied must be aligned properly for the device
    //

    if (FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {

        PDEVICE_OBJECT DeviceObject;

        DeviceObject = IoGetCurrentIrpStackLocation( Irp )->DeviceObject;

        if ((Buffer->CurrentByteOffset.LowPart & DeviceObject->AlignmentRequirement) != 0) {

            DebugTrace(0, Dbg, "Cannot set position due to aligment conflict\n", 0);
            DebugTrace(-1, Dbg, "FatSetPositionInfo -> %08lx\n", STATUS_INVALID_PARAMETER);

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  The input parameter is fine so set the current byte offset and
    //  complete the request
    //

    DebugTrace(0, Dbg, "Set the new position to %08lx\n", Buffer->CurrentByteOffset);

    FileObject->CurrentByteOffset = Buffer->CurrentByteOffset;

    DebugTrace(-1, Dbg, "FatSetPositionInfo -> %08lx\n", STATUS_SUCCESS);

    UNREFERENCED_PARAMETER( IrpContext );

    return STATUS_SUCCESS;
}


//
//  Internal Support Routine
//

NTSTATUS
FatSetAllocationInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine performs the set Allocation information for fat.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    Irp - Supplies the irp being processed

    Fcb - Supplies the Fcb or Dcb being processed, already known not to
        be the root dcb

    FileObject - Supplies the FileObject being processed, already known not to
        be the root dcb

Return Value:

    NTSTATUS - The result of this operation if it completes without
               an exception.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_ALLOCATION_INFORMATION Buffer;
    ULONG NewAllocationSize;

    BOOLEAN FileSizeTruncated = FALSE;
    BOOLEAN CacheMapInitialized = FALSE;
    BOOLEAN ResourceAcquired = FALSE;
    ULONG OriginalFileSize;
    ULONG OriginalValidDataLength;
    ULONG OriginalValidDataToDisk;

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    NewAllocationSize = Buffer->AllocationSize.LowPart;

    DebugTrace(+1, Dbg, "FatSetAllocationInfo.. to %08lx\n", NewAllocationSize);

    //
    //  Allocation is only allowed on a file and not a directory
    //

    if (NodeType(Fcb) == FAT_NTC_DCB) {

        DebugTrace(-1, Dbg, "Cannot change allocation of a directory\n", 0);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Check that the new file allocation is legal
    //

    if (!FatIsIoRangeValid( Fcb->Vcb, Buffer->AllocationSize, 0 )) {

        DebugTrace(-1, Dbg, "Illegal allocation size\n", 0);

        return STATUS_DISK_FULL;
    }

    //
    //  If we haven't yet looked up the correct AllocationSize, do so.
    //

    if (Fcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

        FatLookupFileAllocationSize( IrpContext, Fcb );
    }

    //
    //  This is kinda gross, but if the file is not cached, but there is
    //  a data section, we have to cache the file to avoid a bunch of
    //  extra work.
    //

    if ((FileObject->SectionObjectPointer->DataSectionObject != NULL) &&
        (FileObject->SectionObjectPointer->SharedCacheMap == NULL) &&
        !FlagOn(Irp->Flags, IRP_PAGING_IO)) {

        ASSERT( !FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE ) );

        //
        //  Now initialize the cache map.
        //

        CcInitializeCacheMap( FileObject,
                              (PCC_FILE_SIZES)&Fcb->Header.AllocationSize,
                              FALSE,
                              &FatData.CacheManagerCallbacks,
                              Fcb );

        CacheMapInitialized = TRUE;
    }

    //
    //  Now mark the fact that the file needs to be truncated on close
    //

    Fcb->FcbState |= FCB_STATE_TRUNCATE_ON_CLOSE;

    //
    //  Now mark that the time on the dirent needs to be updated on close.
    //

    SetFlag( FileObject->Flags, FO_FILE_MODIFIED );

    try {

        //
        //  Increase or decrease the allocation size.
        //

        if (NewAllocationSize > Fcb->Header.AllocationSize.LowPart) {

            FatAddFileAllocation( IrpContext, Fcb, FileObject, NewAllocationSize);

        } else {

            //
            //  Check here if we will be decreasing file size and synchonize with
            //  paging IO.
            //

            if ( Fcb->Header.FileSize.LowPart > NewAllocationSize ) {

                //
                //  Before we actually truncate, check to see if the purge
                //  is going to fail.
                //

                if (!MmCanFileBeTruncated( FileObject->SectionObjectPointer,
                                           &Buffer->AllocationSize )) {

                    try_return( Status = STATUS_USER_MAPPED_FILE );
                }

                FileSizeTruncated = TRUE;

                OriginalFileSize = Fcb->Header.FileSize.LowPart;
                OriginalValidDataLength = Fcb->Header.ValidDataLength.LowPart;
                OriginalValidDataToDisk = Fcb->ValidDataToDisk;

                (VOID)ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource, TRUE );
                ResourceAcquired = TRUE;

                Fcb->Header.FileSize.LowPart = NewAllocationSize;

                //
                //  If we reduced the file size to less than the ValidDataLength,
                //  adjust the VDL.  Likewise ValidDataToDisk.
                //

                if (Fcb->Header.ValidDataLength.LowPart > Fcb->Header.FileSize.LowPart) {

                    Fcb->Header.ValidDataLength.LowPart = Fcb->Header.FileSize.LowPart;
                }
                if (Fcb->ValidDataToDisk > Fcb->Header.FileSize.LowPart) {

                    Fcb->ValidDataToDisk = Fcb->Header.FileSize.LowPart;
                }

            }

            //
            //  Now that File Size is down, actually do the truncate.
            //

            FatTruncateFileAllocation( IrpContext, Fcb, NewAllocationSize);

            //
            //  Now check if we needed to decrease the file size accordingly.
            //

            if ( FileSizeTruncated ) {

                //
                //  Tell the cache manager we reduced the file size.
                //  The call is unconditional, because MM always wants to know.
                //

#if DBG
                try {
#endif
                
                    CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );

#if DBG
                } except(FatBugCheckExceptionFilter( GetExceptionInformation() )) {

                      NOTHING;
                }
#endif

                ASSERT( FileObject->DeleteAccess || FileObject->WriteAccess );

                //
                //  There is no going back from this. If we run into problems updating
                //  the dirent we will have to live with the consequences. Not sending
                //  the notifies is likewise pretty benign compared to failing the entire
                //  operation and trying to back out everything, which could fail for the
                //  same reasons.
                //
                //  If you want a transacted filesystem, use NTFS ...
                //

                FileSizeTruncated = FALSE;

                FatSetFileSizeInDirent( IrpContext, Fcb, NULL );

                //
                //  Report that we just reduced the file size.
                //

                FatNotifyReportChange( IrpContext,
                                       Fcb->Vcb,
                                       Fcb,
                                       FILE_NOTIFY_CHANGE_SIZE,
                                       FILE_ACTION_MODIFIED );
            }
        }

    try_exit: NOTHING;

    } finally {

        if ( AbnormalTermination() && FileSizeTruncated ) {

            Fcb->Header.FileSize.LowPart = OriginalFileSize;
            Fcb->Header.ValidDataLength.LowPart = OriginalValidDataLength;
            Fcb->ValidDataToDisk = OriginalValidDataToDisk;

            //
            //  Make sure Cc knows the right filesize.
            //

            if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {

                *CcGetFileSizePointer(FileObject) = Fcb->Header.FileSize;
            }

            ASSERT( Fcb->Header.FileSize.LowPart <= Fcb->Header.AllocationSize.LowPart );
        }

        if (CacheMapInitialized) {

            CcUninitializeCacheMap( FileObject, NULL, NULL );
        }

        if (ResourceAcquired) {

            ExReleaseResourceLite( Fcb->Header.PagingIoResource );

        }
        
    }

    DebugTrace(-1, Dbg, "FatSetAllocationInfo -> %08lx\n", STATUS_SUCCESS);

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
FatSetEndOfFileInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine performs the set End of File information for fat.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    Irp - Supplies the irp being processed

    FileObject - Supplies the file object being processed

    Vcb - Supplies the Vcb being processed

    Fcb - Supplies the Fcb or Dcb being processed, already known not to
        be the root dcb

Return Value:

    NTSTATUS - The result of this operation if it completes without
               an exception.

--*/

{
    NTSTATUS Status;

    PFILE_END_OF_FILE_INFORMATION Buffer;

    ULONG NewFileSize;
    ULONG InitialFileSize;
    ULONG InitialValidDataLength;
    ULONG InitialValidDataToDisk;

    BOOLEAN CacheMapInitialized = FALSE;
    BOOLEAN UnwindFileSizes = FALSE;
    BOOLEAN ResourceAcquired = FALSE;

    DebugTrace(+1, Dbg, "FatSetEndOfFileInfo...\n", 0);

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    try {

        //
        //  File Size changes are only allowed on a file and not a directory
        //

        if (NodeType(Fcb) != FAT_NTC_FCB) {

            DebugTrace(0, Dbg, "Cannot change size of a directory\n", 0);

            try_return( Status = STATUS_INVALID_DEVICE_REQUEST );
        }

        //
        //  Check that the new file size is legal
        //

        if (!FatIsIoRangeValid( Fcb->Vcb, Buffer->EndOfFile, 0 )) {

            DebugTrace(0, Dbg, "Illegal allocation size\n", 0);

            try_return( Status = STATUS_DISK_FULL );
        }

        NewFileSize = Buffer->EndOfFile.LowPart;

        //
        //  If we haven't yet looked up the correct AllocationSize, do so.
        //

        if (Fcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

            FatLookupFileAllocationSize( IrpContext, Fcb );
        }

        //
        //  This is kinda gross, but if the file is not cached, but there is
        //  a data section, we have to cache the file to avoid a bunch of
        //  extra work.
        //

        if ((FileObject->SectionObjectPointer->DataSectionObject != NULL) &&
            (FileObject->SectionObjectPointer->SharedCacheMap == NULL) &&
            !FlagOn(Irp->Flags, IRP_PAGING_IO)) {

            if (FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE ))  {

                //
                //  This IRP has raced (and lost) with a close (=>cleanup)
                //  on the same fileobject.  We don't want to reinitialise the
                //  cachemap here now because we'll leak it (unless we do so &
                //  then tear it down again here,  which is too much of a change at
                //  this stage).   So we'll just say the file is closed - which
                //  is arguably the right thing to do anyway,  since a caller
                //  racing operations in this way is broken.  The only stumbling
                //  block is possibly filters - do they operate on cleaned
                //  up fileobjects?
                //

                FatRaiseStatus( IrpContext, STATUS_FILE_CLOSED);
            }

            //
            //  Now initialize the cache map.
            //

            CcInitializeCacheMap( FileObject,
                                  (PCC_FILE_SIZES)&Fcb->Header.AllocationSize,
                                  FALSE,
                                  &FatData.CacheManagerCallbacks,
                                  Fcb );

            CacheMapInitialized = TRUE;
        }

        //
        //  Do a special case here for the lazy write of file sizes.
        //

        if (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.AdvanceOnly) {

            //
            //  Only attempt this if the file hasn't been "deleted on close" and
            //  this is a good FCB.
            //

            if (!IsFileDeleted( IrpContext, Fcb ) && (Fcb->FcbCondition == FcbGood)) {

                PDIRENT Dirent;
                PBCB DirentBcb;

                //
                //  Never have the dirent filesize larger than the fcb filesize
                //

                if (NewFileSize >= Fcb->Header.FileSize.LowPart) {

                    NewFileSize = Fcb->Header.FileSize.LowPart;
                }

                //
                //  Make sure we don't set anything higher than the alloc size.
                //

                ASSERT( NewFileSize <= Fcb->Header.AllocationSize.LowPart );

                //
                //  Only advance the file size, never reduce it with this call
                //

                FatGetDirentFromFcbOrDcb( IrpContext,
                                          Fcb,
                                          &Dirent,
                                          &DirentBcb );

                ASSERT( Dirent && DirentBcb );

                try {

                    if ( NewFileSize > Dirent->FileSize ) {

                        Dirent->FileSize = NewFileSize;

                        FatSetDirtyBcb( IrpContext, DirentBcb, Fcb->Vcb, TRUE );

                        //
                        //  Report that we just changed the file size.
                        //

                        FatNotifyReportChange( IrpContext,
                                               Vcb,
                                               Fcb,
                                               FILE_NOTIFY_CHANGE_SIZE,
                                               FILE_ACTION_MODIFIED );
                    }

                } finally {

                    FatUnpinBcb( IrpContext, DirentBcb );
                }

            } else {

                DebugTrace(0, Dbg, "Cannot set size on deleted file.\n", 0);
            }

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  Check if the new file size is greater than the current
        //  allocation size.  If it is then we need to increase the
        //  allocation size.
        //

        if ( NewFileSize > Fcb->Header.AllocationSize.LowPart ) {

            //
            //  Change the file allocation
            //

            FatAddFileAllocation( IrpContext, Fcb, FileObject, NewFileSize );
        }

        //
        //  At this point we have enough allocation for the file.
        //  So check if we are really changing the file size
        //

        if (Fcb->Header.FileSize.LowPart != NewFileSize) {

            if ( NewFileSize < Fcb->Header.FileSize.LowPart ) {

                //
                //  Before we actually truncate, check to see if the purge
                //  is going to fail.
                //

                if (!MmCanFileBeTruncated( FileObject->SectionObjectPointer,
                                           &Buffer->EndOfFile )) {

                    try_return( Status = STATUS_USER_MAPPED_FILE );
                }

                //
                //  This call is unconditional, because MM always wants to know.
                //  Also serialize here with paging io since we are truncating
                //  the file size.
                //

                ResourceAcquired =
                    ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource, TRUE );
            }

            //
            //  Set the new file size
            //

            InitialFileSize = Fcb->Header.FileSize.LowPart;
            InitialValidDataLength = Fcb->Header.ValidDataLength.LowPart;
            InitialValidDataToDisk = Fcb->ValidDataToDisk;
            UnwindFileSizes = TRUE;

            Fcb->Header.FileSize.LowPart = NewFileSize;

            //
            //  If we reduced the file size to less than the ValidDataLength,
            //  adjust the VDL.  Likewise ValidDataToDisk.
            //

            if (Fcb->Header.ValidDataLength.LowPart > NewFileSize) {

                Fcb->Header.ValidDataLength.LowPart = NewFileSize;
            }

            if (Fcb->ValidDataToDisk > NewFileSize) {

                Fcb->ValidDataToDisk = NewFileSize;
            }

            DebugTrace(0, Dbg, "New file size is 0x%08lx.\n", NewFileSize);

            //
            //  We must now update the cache mapping (benign if not cached).
            //

            CcSetFileSizes( FileObject,
                            (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );

            FatSetFileSizeInDirent( IrpContext, Fcb, NULL );

            //
            //  Report that we just changed the file size.
            //

            FatNotifyReportChange( IrpContext,
                                   Vcb,
                                   Fcb,
                                   FILE_NOTIFY_CHANGE_SIZE,
                                   FILE_ACTION_MODIFIED );

            //
            //  Mark the fact that the file will need to checked for
            //  truncation on cleanup.
            //

            SetFlag( Fcb->FcbState, FCB_STATE_TRUNCATE_ON_CLOSE );
        }

        //
        //  Set this handle as having modified the file
        //

        FileObject->Flags |= FO_FILE_MODIFIED;

        //
        //  Set our return status to success
        //

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;

        FatUnpinRepinnedBcbs( IrpContext );

    } finally {

        DebugUnwind( FatSetEndOfFileInfo );

        if (AbnormalTermination() && UnwindFileSizes) {

            Fcb->Header.FileSize.LowPart = InitialFileSize;
            Fcb->Header.ValidDataLength.LowPart = InitialValidDataLength;
            Fcb->ValidDataToDisk = InitialValidDataToDisk;

            if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {

                *CcGetFileSizePointer(FileObject) = Fcb->Header.FileSize;
            }
        }

        if (CacheMapInitialized) {

            CcUninitializeCacheMap( FileObject, NULL, NULL );
        }

        if ( ResourceAcquired ) {

            ExReleaseResourceLite( Fcb->Header.PagingIoResource );
        }

        DebugTrace(-1, Dbg, "FatSetEndOfFileInfo -> %08lx\n", Status);
    }

    return Status;
}


//
//  Internal Support Routine
//

VOID
FatDeleteFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB TargetDcb,
    IN ULONG LfnOffset,
    IN ULONG DirentOffset,
    IN PDIRENT Dirent,
    IN PUNICODE_STRING Lfn
    )
{
    PFCB Fcb;
    PLIST_ENTRY Links;

    //
    //  We can do the replace by removing the other Fcb(s) from
    //  the prefix table.
    //

    for (Links = TargetDcb->Specific.Dcb.ParentDcbQueue.Flink;
         Links != &TargetDcb->Specific.Dcb.ParentDcbQueue;
         Links = Links->Flink) {

        Fcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

        if (FlagOn(Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE) &&
            (Fcb->DirentOffsetWithinDirectory == DirentOffset)) {

            ASSERT( NodeType(Fcb) == FAT_NTC_FCB );
            ASSERT( Fcb->LfnOffsetWithinDirectory == LfnOffset );

            if ( Fcb->UncleanCount != 0 ) {

                FatBugCheck(0,0,0);

            } else {

                PERESOURCE Resource;

                //
                //  Make this fcb "appear" deleted, synchronizing with
                //  paging IO.
                //

                FatRemoveNames( IrpContext, Fcb );

                Resource = Fcb->Header.PagingIoResource;

                (VOID)ExAcquireResourceExclusiveLite( Resource, TRUE );

                SetFlag(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE);

                Fcb->ValidDataToDisk = 0;
                Fcb->Header.FileSize.QuadPart =
                Fcb->Header.ValidDataLength.QuadPart = 0;

                Fcb->FirstClusterOfFile = 0;

                ExReleaseResourceLite( Resource );
            }
        }
    }

    //
    //  The file is not currently opened so we can delete the file
    //  that is being overwritten.  To do the operation we dummy
    //  up an fcb, truncate allocation, delete the fcb, and delete
    //  the dirent.
    //

    Fcb = FatCreateFcb( IrpContext,
                        TargetDcb->Vcb,
                        TargetDcb,
                        LfnOffset,
                        DirentOffset,
                        Dirent,
                        Lfn,
                        FALSE,
                        FALSE );

    Fcb->Header.FileSize.LowPart = 0;

    try {

        FatTruncateFileAllocation( IrpContext, Fcb, 0 );

        FatDeleteDirent( IrpContext, Fcb, NULL, TRUE );

    } finally {

        FatDeleteFcb( IrpContext, Fcb );
    }
}

//
//  Internal Support Routine
//

VOID
FatRenameEAs (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN USHORT ExtendedAttributes,
    IN POEM_STRING OldOemName
    )
{
    BOOLEAN LockedEaFcb = FALSE;

    PBCB EaBcb = NULL;
    PDIRENT EaDirent;
    EA_RANGE EaSetRange;
    PEA_SET_HEADER EaSetHeader;

    PVCB Vcb;

    RtlZeroMemory( &EaSetRange, sizeof( EA_RANGE ));

    Vcb = Fcb->Vcb;

    try {

        //
        //  Use a try-except to catch any errors.
        //

        try {


            //
            //  Try to get the Ea file object.  Return FALSE on failure.
            //

            FatGetEaFile( IrpContext,
                          Vcb,
                          &EaDirent,
                          &EaBcb,
                          FALSE,
                          FALSE );

            LockedEaFcb = TRUE;

            //
            //  If we didn't get the file because it doesn't exist, then the
            //  disk is corrupted.  We do nothing here.
            //

            if (Vcb->VirtualEaFile != NULL) {

                //
                //  Try to pin down the Ea set header for the index in the
                //  dirent.  If the operation doesn't complete, return FALSE
                //  from this routine.
                //

                FatReadEaSet( IrpContext,
                              Vcb,
                              ExtendedAttributes,
                              OldOemName,
                              FALSE,
                              &EaSetRange );

                EaSetHeader = (PEA_SET_HEADER) EaSetRange.Data;

                //
                //  We now have the Ea set header for this file.  We simply
                //  overwrite the owning file name.
                //

                RtlZeroMemory( EaSetHeader->OwnerFileName, 14 );

                RtlCopyMemory( EaSetHeader->OwnerFileName,
                               Fcb->ShortName.Name.Oem.Buffer,
                               Fcb->ShortName.Name.Oem.Length );

                FatMarkEaRangeDirty( IrpContext, Vcb->VirtualEaFile, &EaSetRange );
                FatUnpinEaRange( IrpContext, &EaSetRange );

                CcFlushCache( Vcb->VirtualEaFile->SectionObjectPointer, NULL, 0, NULL );
            }

        } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We catch all exceptions that Fat catches, but don't do
            //  anything with them.
            //
        }

    } finally {

        //
        //  Unpin the EaDirent and the EaSetHeader if pinned.
        //

        FatUnpinBcb( IrpContext, EaBcb );
        FatUnpinEaRange( IrpContext, &EaSetRange );

        //
        //  Release the Fcb for the Ea file if locked.
        //

        if (LockedEaFcb) {

            FatReleaseFcb( IrpContext, Vcb->EaFcb );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\filobsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FilObSup.c

Abstract:

    This module implements the Fat File object support routines.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_FILOBSUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatForceCacheMiss)
#pragma alloc_text(PAGE, FatPurgeReferencedFileObjects)
#pragma alloc_text(PAGE, FatSetFileObject)
#pragma alloc_text(PAGE, FatDecodeFileObject)
#endif


VOID
FatSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PVOID VcbOrFcbOrDcb,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object

Arguments:

    FileObject - Supplies a pointer to the file object being modified, and
        can optionally be null.

    TypeOfOpen - Supplies the type of open denoted by the file object.
        This is only used by this procedure for sanity checking.

    VcbOrFcbOrDcb - Supplies a pointer to either a vcb, fcb, or dcb

    Ccb - Optionally supplies a pointer to a ccb

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FatSetFileObject, FileObject = %08lx\n", FileObject );

    ASSERT((Ccb == NULL) || (NodeType(Ccb) == FAT_NTC_CCB));

    ASSERT(((TypeOfOpen == UnopenedFileObject))

                ||

           ((TypeOfOpen == UserFileOpen) &&
            (NodeType(VcbOrFcbOrDcb) == FAT_NTC_FCB) &&
            (Ccb != NULL))

                ||

           ((TypeOfOpen == EaFile) &&
            (NodeType(VcbOrFcbOrDcb) == FAT_NTC_FCB) &&
            (Ccb == NULL))

                ||

           ((TypeOfOpen == UserDirectoryOpen) &&
            ((NodeType(VcbOrFcbOrDcb) == FAT_NTC_DCB) || (NodeType(VcbOrFcbOrDcb) == FAT_NTC_ROOT_DCB)) &&
            (Ccb != NULL))

                ||

           ((TypeOfOpen == UserVolumeOpen) &&
            (NodeType(VcbOrFcbOrDcb) == FAT_NTC_VCB) &&
            (Ccb != NULL))

                ||

           ((TypeOfOpen == VirtualVolumeFile) &&
            (NodeType(VcbOrFcbOrDcb) == FAT_NTC_VCB) &&
            (Ccb == NULL))

                ||

           ((TypeOfOpen == DirectoryFile) &&
            ((NodeType(VcbOrFcbOrDcb) == FAT_NTC_DCB) || (NodeType(VcbOrFcbOrDcb) == FAT_NTC_ROOT_DCB)) &&
            (Ccb == NULL)));

    //
    //  If we were given an Fcb, Dcb, or Vcb, we have some processing to do.
    //

    ASSERT((Ccb == NULL) || (NodeType(Ccb) == FAT_NTC_CCB));

    if ( VcbOrFcbOrDcb != NULL ) {

        //
        //  Set the Vpb field in the file object, and if we were given an
        //  Fcb or Dcb move the field over to point to the nonpaged Fcb/Dcb
        //

        if (NodeType(VcbOrFcbOrDcb) == FAT_NTC_VCB) {

            FileObject->Vpb = ((PVCB)VcbOrFcbOrDcb)->Vpb;

        } else {

            FileObject->Vpb = ((PFCB)VcbOrFcbOrDcb)->Vcb->Vpb;

            //
            //  If this is a temporary file, note it in the FcbState
            //

            if (FlagOn(((PFCB)VcbOrFcbOrDcb)->FcbState, FCB_STATE_TEMPORARY)) {

                SetFlag(FileObject->Flags, FO_TEMPORARY_FILE);
            }
        }
    }

    ASSERT((Ccb == NULL) || (NodeType(Ccb) == FAT_NTC_CCB));

    //
    //  Now set the fscontext fields of the file object
    //

    if (ARGUMENT_PRESENT( FileObject )) {

        FileObject->FsContext  = VcbOrFcbOrDcb;
        FileObject->FsContext2 = Ccb;
    }

    ASSERT((Ccb == NULL) || (NodeType(Ccb) == FAT_NTC_CCB));

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatSetFileObject -> VOID\n", 0);

    return;
}


TYPE_OF_OPEN
FatDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVCB *Vcb,
    OUT PFCB *FcbOrDcb,
    OUT PCCB *Ccb
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by the Fat file system and figures out what really is opened.

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    Vcb - Receives a pointer to the Vcb for the file object.

    FcbOrDcb - Receives a pointer to the Fcb/Dcb for the file object, if
        one exists.

    Ccb - Receives a pointer to the Ccb for the file object, if one exists.

Return Value:

    TYPE_OF_OPEN - returns the type of file denoted by the input file object.

        UserFileOpen - The FO represents a user's opened data file.
            Ccb, FcbOrDcb, and Vcb are set.  FcbOrDcb points to an Fcb.

        UserDirectoryOpen - The FO represents a user's opened directory.
            Ccb, FcbOrDcb, and Vcb are set.  FcbOrDcb points to a Dcb/RootDcb

        UserVolumeOpen - The FO represents a user's opened volume.
            Ccb and Vcb are set. FcbOrDcb is null.

        VirtualVolumeFile - The FO represents the special virtual volume file.
            Vcb is set, and Ccb and FcbOrDcb are null.

        DirectoryFile - The FO represents a special directory file.
            Vcb and FcbOrDcb are set. Ccb is null.  FcbOrDcb points to a
            Dcb/RootDcb.

        EaFile - The FO represents an Ea Io stream file.
            FcbOrDcb, and Vcb are set.  FcbOrDcb points to an Fcb, and Ccb is
            null.

--*/

{
    TYPE_OF_OPEN TypeOfOpen;
    PVOID FsContext;
    PVOID FsContext2;

    DebugTrace(+1, Dbg, "FatDecodeFileObject, FileObject = %08lx\n", FileObject);

    //
    //  Reference the fs context fields of the file object, and zero out
    //  the out pointer parameters.
    //

    FsContext = FileObject->FsContext;
    FsContext2 = FileObject->FsContext2;

    //
    //  Special case the situation where FsContext is null
    //

    if (FsContext == NULL) {

        *Ccb = NULL;
        *FcbOrDcb = NULL;
        *Vcb = NULL;

        TypeOfOpen = UnopenedFileObject;

    } else {

        //
        //  Now we can case on the node type code of the fscontext pointer
        //  and set the appropriate out pointers
        //

        switch (NodeType(FsContext)) {

        case FAT_NTC_VCB:

            *Ccb = FsContext2;
            *FcbOrDcb = NULL;
            *Vcb = FsContext;

            TypeOfOpen = ( *Ccb == NULL ? VirtualVolumeFile : UserVolumeOpen );

            break;

        case FAT_NTC_ROOT_DCB:
        case FAT_NTC_DCB:

            *Ccb = FsContext2;
            *FcbOrDcb = FsContext;
            *Vcb = (*FcbOrDcb)->Vcb;

            TypeOfOpen = ( *Ccb == NULL ? DirectoryFile : UserDirectoryOpen );

            DebugTrace(0, Dbg, "Referencing directory: %Z\n", &(*FcbOrDcb)->FullFileName);

            break;

        case FAT_NTC_FCB:

            *Ccb = FsContext2;
            *FcbOrDcb = FsContext;
            *Vcb = (*FcbOrDcb)->Vcb;

            TypeOfOpen = ( *Ccb == NULL ? EaFile : UserFileOpen );

            DebugTrace(0, Dbg, "Referencing file: %Z\n", &(*FcbOrDcb)->FullFileName);

            break;

        default:

            FatBugCheck( NodeType(FsContext), 0, 0 );
        }
    }

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "FatDecodeFileObject -> %08lx\n", TypeOfOpen);

    return TypeOfOpen;
}

VOID
FatPurgeReferencedFileObjects (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN FAT_FLUSH_TYPE FlushType
    )

/*++

Routine Description:

    This routine non-recursively walks from the given FcbOrDcb and trys
    to force Cc or Mm to close any sections it may be holding on to.

Arguments:

    Fcb - Supplies a pointer to either an fcb or a dcb

    FlushType - Specifies the kind of flushing to perform
    
Return Value:

    None.

--*/

{
    PFCB OriginalFcb = Fcb;
    PFCB NextFcb;

    DebugTrace(+1, Dbg, "FatPurgeReferencedFileObjects, Fcb = %08lx\n", Fcb );

    ASSERT( FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

    //
    //  First, if we have a delayed close, force it closed.
    //

    FatFspClose(Fcb->Vcb);

    //
    //  Walk the directory tree forcing sections closed.
    //
    //  Note that it very important to get the next node to visit before
    //  acting on the current node.  This is because acting on a node may
    //  make it, and an arbitrary number of direct ancestors, vanish.
    //  Since we never visit ancestors in our top-down enumeration scheme, we
    //  can safely continue the enumeration even when the tree is vanishing
    //  beneath us.  This is way cool.
    //

    while ( Fcb != NULL ) {

        NextFcb = FatGetNextFcbTopDown(IrpContext, Fcb, OriginalFcb);

        //
        //  Check for the EA file fcb
        //

        if ( !FlagOn(Fcb->DirentFatFlags, FAT_DIRENT_ATTR_VOLUME_ID) ) {

            FatForceCacheMiss( IrpContext, Fcb, FlushType );
        }

        Fcb = NextFcb;
    }

    DebugTrace(-1, Dbg, "FatPurgeReferencedFileObjects (VOID)\n", 0 );

    return;
}


VOID
FatForceCacheMiss (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN FAT_FLUSH_TYPE FlushType
    )

/*++

Routine Description:

    The following routine asks either Cc or Mm to get rid of any cached
    pages on a file.  Note that this will fail if a user has mapped a file.

    If there is a shared cache map, purge the cache section.  Otherwise
    we have to go and ask Mm to blow away the section.

    NOTE: This caller MUST own the Vcb exclusive.

Arguments:

    Fcb - Supplies a pointer to an fcb

    FlushType - Specifies the kind of flushing to perform
    
Return Value:

    None.

--*/

{
    PVCB Vcb;
    BOOLEAN ChildrenAcquired = FALSE;

    //
    //  If we can't wait, bail.
    //

    ASSERT( FatVcbAcquiredExclusive( IrpContext, Fcb->Vcb ) ||
            FlagOn( Fcb->Vcb->VcbState, VCB_STATE_FLAG_LOCKED ) );

    if (!FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT)) {

        FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    //
    //  If we are purging a directory file object, we must acquire all the
    //  FCBs exclusive so that the parent directory is not being pinned.
    //  Careful, we can collide with something acquiring up the tree like
    //  an unpin repinned flush (FsRtlAcquireFileForCcFlush ...) of a parent
    //  dir on extending writethrough of a child file (oops).  So get things
    //  going up the tree, not down.
    //

    if ((NodeType(Fcb) != FAT_NTC_FCB) &&
        !IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue)) {

        PLIST_ENTRY Links;
        PFCB TempFcb;

        ChildrenAcquired = TRUE;

        for (Links = Fcb->Specific.Dcb.ParentDcbQueue.Flink;
             Links != &Fcb->Specific.Dcb.ParentDcbQueue;
             Links = Links->Flink) {

            TempFcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

            (VOID)FatAcquireExclusiveFcb( IrpContext, TempFcb );
        }
    }

    (VOID)FatAcquireExclusiveFcb( IrpContext, Fcb );

    //
    //  We use this flag to indicate to a close beneath us that
    //  the Fcb resource should be freed before deleting the Fcb.
    //

    Vcb = Fcb->Vcb;

    SetFlag( Fcb->FcbState, FCB_STATE_FORCE_MISS_IN_PROGRESS );

    ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB );

    try {

        BOOLEAN DataSectionExists;
        BOOLEAN ImageSectionExists;

        PSECTION_OBJECT_POINTERS Section;

        if ( FlushType ) {

            (VOID)FatFlushFile( IrpContext, Fcb, FlushType );
        }

        //
        //  The Flush may have made the Fcb go away
        //

        if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB)) {

            Section = &Fcb->NonPaged->SectionObjectPointers;

            DataSectionExists = (BOOLEAN)(Section->DataSectionObject != NULL);
            ImageSectionExists = (BOOLEAN)(Section->ImageSectionObject != NULL);

            //
            //  Note, it is critical to do the Image section first as the
            //  purge of the data section may cause the image section to go
            //  away, but the opposite is not true.
            //

            if (ImageSectionExists) {

                (VOID)MmFlushImageSection( Section, MmFlushForWrite );
            }

            if (DataSectionExists) {

                CcPurgeCacheSection( Section, NULL, 0, FALSE );
            }
        }

    } finally {

        //
        //  If we purging a directory file object, release all the Fcb
        //  resources that we acquired above.  The Dcb cannot have vanished
        //  if there were Fcbs underneath it, and the Fcbs couldn't have gone
        //  away since I own the Vcb.
        //

        if (ChildrenAcquired) {

            PLIST_ENTRY Links;
            PFCB TempFcb;

            for (Links = Fcb->Specific.Dcb.ParentDcbQueue.Flink;
                 Links != &Fcb->Specific.Dcb.ParentDcbQueue;
                 Links = Links->Flink) {

                TempFcb = CONTAINING_RECORD( Links, FCB, ParentDcbLinks );

                FatReleaseFcb( IrpContext, TempFcb );
            }
        }

        //
        //  Since we have the Vcb exclusive we know that if any closes
        //  come in it is because the CcPurgeCacheSection caused the
        //  Fcb to go away.  Also in close, the Fcb was released
        //  before being freed.
        //

        if ( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB) ) {

            ClearFlag( Fcb->FcbState, FCB_STATE_FORCE_MISS_IN_PROGRESS );

            FatReleaseFcb( (IRPCONTEXT), Fcb );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fatstruc.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FatStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Fat file system.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _FATSTRUC_
#define _FATSTRUC_

typedef PVOID PBCB;     //**** Bcb's are now part of the cache module


//
//  The FAT_DATA record is the top record in the Fat file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _FAT_DATA {

    //
    //  The type and size of this record (must be FAT_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;


    PVOID LazyWriteThread;


    //
    //  A queue of all the devices that are mounted by the file system.
    //

    LIST_ENTRY VcbQueue;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  A pointer to the filesystem device objects we created.
    //

    PVOID DiskFileSystemDeviceObject;
    PVOID CdromFileSystemDeviceObject;

    //
    //  A resource variable to control access to the global Fat data record
    //

    ERESOURCE Resource;

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

    //
    //  The following tells us if we should use Chicago extensions.
    //

    BOOLEAN ChicagoMode:1;

    //
    //  The following field tells us if we are running on a Fujitsu
    //  FMR Series. These machines supports extra formats on the
    //  FAT file system.
    //

    BOOLEAN FujitsuFMR:1;

    //
    //  Inidicates that FspClose is currently processing closes.
    //

    BOOLEAN AsyncCloseActive:1;

    //
    //  The following BOOLEAN says shutdown has started on FAT.  It
    //  instructs FspClose to not keep the Vcb resources anymore.
    //

    BOOLEAN ShutdownStarted:1;

    //
    //  The following flag tells us if we are going to generate LFNs
    //  for valid 8.3 names with extended characters.
    //

    BOOLEAN CodePageInvariant:1;

    //
    //  The following flags tell us if we are in an aggresive push to lower
    //  the size of the deferred close queues.
    //

    BOOLEAN HighAsync:1;
    BOOLEAN HighDelayed:1;

    //
    //  The following list entry is used for performing closes that can't
    //  be done in the context of the original caller.
    //

    ULONG AsyncCloseCount;
    LIST_ENTRY AsyncCloseList;

    //
    //  The following two fields record if we are delaying a close.
    //

    ULONG DelayedCloseCount;
    LIST_ENTRY DelayedCloseList;

    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    PIO_WORKITEM FatCloseItem;

    //
    //  This spinlock protects several rapid-fire operations. NOTE: this is
    //  pretty horrible style.
    //

    KSPIN_LOCK GeneralSpinLock;

    //
    //  Cache manager call back structures, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerNoOpCallbacks;

} FAT_DATA;
typedef FAT_DATA *PFAT_DATA;

//
// An array of these structures will keep

typedef struct _FAT_WINDOW {
    
    ULONG FirstCluster;       // The first cluster in this window.
    ULONG LastCluster;        // The last cluster in this window.
    ULONG ClustersFree;       // The number of clusters free in this window.

} FAT_WINDOW;
typedef FAT_WINDOW *PFAT_WINDOW;


//
//  The Vcb (Volume control Block) record corresponds to every volume mounted
//  by the file system.  They are ordered in a queue off of FatData.VcbQueue.
//  This structure must be allocated from non-paged pool
//

typedef enum _VCB_CONDITION {
    VcbGood = 1,
    VcbNotMounted,
    VcbBad
} VCB_CONDITION;

typedef struct _VCB {

    //
    //  This is a common head for the FAT volume file
    //

    FSRTL_ADVANCED_FCB_HEADER VolumeFileHeader;

    //
    //  The links for the device queue off of FatData.VcbQueue
    //

    LIST_ENTRY VcbLinks;

    //
    //  A pointer the device object passed in by the I/O system on a mount
    //  This is the target device object that the file system talks to when it
    //  needs to do any I/O (e.g., the disk stripper device object).
    //
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  A pointer to the VPB for the volume passed in by the I/O system on
    //  a mount.
    //

    PVPB Vpb;

    //
    //  The internal state of the device.  This is a collection of fsd device
    //  state flags.
    //

    ULONG VcbState;
    VCB_CONDITION VcbCondition;

    //
    //  A pointer to the root DCB for this volume
    //

    struct _FCB *RootDcb;

    //
    //  If the FAT has so many entries that the free cluster bitmap would
    //  be too large, we split the FAT into buckets, and only one bucket's
    //  worth of bits are kept in the bitmap.
    //

    ULONG NumberOfWindows;
    PFAT_WINDOW Windows;
    PFAT_WINDOW CurrentWindow;

    //
    //  A count of the number of file objects that have opened the volume
    //  for direct access, and their share access state.
    //

    CLONG DirectAccessOpenCount;
    SHARE_ACCESS ShareAccess;

    //
    //  A count of the number of file objects that have any file/directory
    //  opened on this volume, not including direct access.  And also the
    //  count of the number of file objects that have a file opened for
    //  only read access (i.e., they cannot be modifying the disk).
    //

    CLONG OpenFileCount;
    CLONG ReadOnlyCount;

    //
    //  The bios parameter block field contains
    //  an unpacked copy of the bpb for the volume, it is initialized
    //  during mount time and can be read by everyone else after that.
    //

    BIOS_PARAMETER_BLOCK Bpb;

    PUCHAR First0x24BytesOfBootSector;

    //
    //  The following structure contains information useful to the
    //  allocation support routines.  Many of them are computed from
    //  elements of the Bpb, but are too involved to recompute every time
    //  they are needed.
    //

    struct {

        LBO RootDirectoryLbo;       // Lbo of beginning of root directory
        LBO FileAreaLbo;            // Lbo of beginning of file area
        ULONG RootDirectorySize;    // size of root directory in bytes

        ULONG NumberOfClusters;     // total number of clusters on the volume
        ULONG NumberOfFreeClusters; // number of free clusters on the volume

        UCHAR FatIndexBitSize;      // indicates if 12, 16, or 32 bit fat table

        UCHAR LogOfBytesPerSector;  // Log(Bios->BytesPerSector)
        UCHAR LogOfBytesPerCluster; // Log(Bios->SectorsPerCluster)

    } AllocationSupport;

    //
    //  The following Mcb is used to keep track of dirty sectors in the Fat.
    //  Runs of holes denote clean sectors while runs of LBO == VBO denote
    //  dirty sectors.  The VBOs are that of the volume file, starting at
    //  0.  The granuality of dirt is one sectors, and additions are only
    //  made in sector chunks to prevent problems with several simultaneous
    //  updaters.
    //

    LARGE_MCB DirtyFatMcb;

    //
    //  The FreeClusterBitMap keeps track of all the clusters in the fat.
    //  A 1 means occupied while a 0 means free.  It allows quick location
    //  of contiguous runs of free clusters.  It is initialized on mount
    //  or verify.
    //

    RTL_BITMAP FreeClusterBitMap;

    //
    //  The following fast mutex controls access to the free cluster bit map
    //  and the buckets.
    //

    FAST_MUTEX FreeClusterBitMapMutex;

    //
    //  A resource variable to control access to the volume specific data
    //  structures
    //

    ERESOURCE Resource;

    //
    //  A resource to make sure no one changes the volume bitmap while
    //  you're using it.  Only for volumes with NumberOfWindows > 1.
    //

    ERESOURCE ChangeBitMapResource;


    //
    //  The following field points to the file object used to do I/O to
    //  the virtual volume file.  The virtual volume file maps sectors
    //  0 through the end of fat and is of a fixed size (determined during
    //  mount)
    //

    PFILE_OBJECT VirtualVolumeFile;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SectionObjectPointers;

    //
    //  The following fields is a hint cluster index used by the file system
    //  when allocating a new cluster.
    //

    ULONG ClusterHint;

    //
    //  This field contains the "DeviceObject" that this volume is
    //  currently mounted on.  Note Vcb->Vpb->RealDevice is constant.
    //

    PDEVICE_OBJECT CurrentDevice;

    //
    //  This is a pointer to the file object and the Fcb which represent the ea data.
    //

    PFILE_OBJECT VirtualEaFile;
    struct _FCB *EaFcb;

    //
    //  The following field is a pointer to the file object that has the
    //  volume locked. if the VcbState has the locked flag set.
    //

    PFILE_OBJECT FileObjectWithVcbLocked;

    //
    //  The following is the head of a list of notify Irps.
    //

    LIST_ENTRY DirNotifyList;

    //
    //  The following is used to synchronize the dir notify list.
    //

    PNOTIFY_SYNC NotifySync;

    //
    //  The following fast mutex is used to synchronize directory stream
    //  file object creation.
    //

    FAST_MUTEX DirectoryFileCreationMutex;

    //
    //  This field holds the thread address of the current (or most recent
    //  depending on VcbState) thread doing a verify operation on this volume.
    //

    PKTHREAD VerifyThread;

    //
    //  The following two structures are used for CleanVolume callbacks.
    //

    KDPC CleanVolumeDpc;
    KTIMER CleanVolumeTimer;

    //
    //  This field records the last time FatMarkVolumeDirty was called, and
    //  avoids excessive calls to push the CleanVolume forward in time.
    //

    LARGE_INTEGER LastFatMarkVolumeDirtyCall;

    //
    //  The following fields holds a pointer to a struct which is used to
    //  hold performance counters.
    //

    struct _FILE_SYSTEM_STATISTICS *Statistics;

    //
    //  The property tunneling cache for this volume
    //

    TUNNEL Tunnel;

    //
    //  The media change count is returned by IOCTL_CHECK_VERIFY and
    //  is used to verify that no user-mode app has swallowed a media change
    //  notification.  This is only meaningful for removable media.
    //

    ULONG ChangeCount;

    //
    //  Preallocated VPB for swapout, so we are not forced to consider
    //  must succeed pool.
    //

    PVPB SwapVpb;

    //
    //  Per volume threading of the close queues.
    //

    LIST_ENTRY AsyncCloseList;
    LIST_ENTRY DelayedCloseList;

    //
    //  Fast mutex used by the ADVANCED FCB HEADER in this structure
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

} VCB;
typedef VCB *PVCB;

#define VCB_STATE_FLAG_LOCKED              (0x00000001)
#define VCB_STATE_FLAG_REMOVABLE_MEDIA     (0x00000002)
#define VCB_STATE_FLAG_VOLUME_DIRTY        (0x00000004)
#define VCB_STATE_FLAG_MOUNTED_DIRTY       (0x00000010)
#define VCB_STATE_FLAG_SHUTDOWN            (0x00000040)
#define VCB_STATE_FLAG_CLOSE_IN_PROGRESS   (0x00000080)
#define VCB_STATE_FLAG_DELETED_FCB         (0x00000100)
#define VCB_STATE_FLAG_CREATE_IN_PROGRESS  (0x00000200)
#define VCB_STATE_FLAG_BOOT_OR_PAGING_FILE (0x00000800)
#define VCB_STATE_FLAG_DEFERRED_FLUSH      (0x00001000)
#define VCB_STATE_FLAG_ASYNC_CLOSE_ACTIVE  (0x00002000)
#define VCB_STATE_FLAG_WRITE_PROTECTED     (0x00004000)
#define VCB_STATE_FLAG_REMOVAL_PREVENTED   (0x00008000)
#define VCB_STATE_FLAG_VOLUME_DISMOUNTED   (0x00010000)

//
//  N.B - VOLUME_DISMOUNTED is an indication that FSCTL_DISMOUNT volume was
//  executed on a volume. It does not replace VcbCondition as an indication
//  that the volume is invalid/unrecoverable.
//

//
//  Define the file system statistics struct.  Vcb->Statistics points to an
//  array of these (one per processor) and they must be 64 byte aligned to
//  prevent cache line tearing.
//

typedef struct _FILE_SYSTEM_STATISTICS {

        //
        //  This contains the actual data.
        //

        FILESYSTEM_STATISTICS Common;
        FAT_STATISTICS Fat;

        //
        //  Pad this structure to a multiple of 64 bytes.
        //

        UCHAR Pad[64-(sizeof(FILESYSTEM_STATISTICS)+sizeof(FAT_STATISTICS))%64];

} FILE_SYSTEM_STATISTICS;

typedef FILE_SYSTEM_STATISTICS *PFILE_SYSTEM_STATISTICS;


//
//  The Volume Device Object is an I/O system device object with a workqueue
//  and an VCB record appended to the end.  There are multiple of these
//  records, one for every mounted volume, and are created during
//  a volume mount operation.  The work queue is for handling an overload of
//  work requests to the volume.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    ULONG PostedRequestCount;

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    ULONG OverflowQueueCount;

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue;

    //
    //  The following spinlock protects access to all the above fields.
    //

    KSPIN_LOCK OverflowQueueSpinLock;

    //
    //  This is a common head for the FAT volume file
    //

    FSRTL_COMMON_FCB_HEADER VolumeFileHeader;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT;

typedef VOLUME_DEVICE_OBJECT *PVOLUME_DEVICE_OBJECT;


//
//  This is the structure used to contains the short name for a file
//

typedef struct _FILE_NAME_NODE {

    //
    //  This points back to the Fcb for this file.
    //

    struct _FCB *Fcb;

    //
    //  This is the name of this node.
    //

    union {

        OEM_STRING Oem;

        UNICODE_STRING Unicode;

    } Name;

    //
    //  Marker so we can figure out what kind of name we opened up in
    //  Fcb searches
    //

    BOOLEAN FileNameDos;

    //
    //  And the links.  Our parent Dcb has a pointer to the root entry.
    //

    RTL_SPLAY_LINKS Links;

} FILE_NAME_NODE;
typedef FILE_NAME_NODE *PFILE_NAME_NODE;

//
//  This structure contains fields which must be in non-paged pool.
//

typedef struct _NON_PAGED_FCB {

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SectionObjectPointers;

    //
    //  This context is non-zero only if the file currently has asynchronous
    //  non-cached valid data length extending writes.  It allows
    //  synchronization between pending writes and other operations.
    //

    ULONG OutstandingAsyncWrites;

    //
    //  This event is set when OutstandingAsyncWrites transitions to zero.
    //

    PKEVENT OutstandingAsyncEvent;

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

} NON_PAGED_FCB;

typedef NON_PAGED_FCB *PNON_PAGED_FCB;

//
//  The Fcb/Dcb record corresponds to every open file and directory, and to
//  every directory on an opened path.  They are ordered in two queues, one
//  queue contains every Fcb/Dcb record off of FatData.FcbQueue, the other
//  queue contains only device specific records off of Vcb.VcbSpecificFcbQueue
//

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

typedef struct _FCB {

    //
    //  The following field is used for fast I/O
    //
    //  The following comments refer to the use of the AllocationSize field
    //  of the FsRtl-defined header to the nonpaged Fcb.
    //
    //  For a directory when we create a Dcb we will not immediately
    //  initialize the cache map, instead we will postpone it until our first
    //  call to FatReadDirectoryFile or FatPrepareWriteDirectoryFile.
    //  At that time we will search the Fat to find out the current allocation
    //  size (by calling FatLookupFileAllocationSize) and then initialize the
    //  cache map to this allocation size.
    //
    //  For a file when we create an Fcb we will not immediately initialize
    //  the cache map, instead we will postpone it until we need it and
    //  then we determine the allocation size from either searching the
    //  fat to determine the real file allocation, or from the allocation
    //  that we've just allocated if we're creating a file.
    //
    //  A value of -1 indicates that we do not know what the current allocation
    //  size really is, and need to examine the fat to find it.  A value
    //  of than -1 is the real file/directory allocation size.
    //
    //  Whenever we need to extend the allocation size we call
    //  FatAddFileAllocation which (if we're really extending the allocation)
    //  will modify the Fat, Mcb, and update this field.  The caller
    //  of FatAddFileAllocation is then responsible for altering the Cache
    //  map size.
    //
    //  We are now using the ADVANCED fcb header to support filter contexts
    //  at the stream level
    //

    FSRTL_ADVANCED_FCB_HEADER Header;

    //
    //  This structure contains fields which must be in non-paged pool.
    //

    PNON_PAGED_FCB NonPaged;

    //
    //  The head of the fat alloaction chain.  FirstClusterOfFile == 0
    //  means that the file has no current allocation.
    //

    ULONG FirstClusterOfFile;

    //
    //  The links for the queue of all fcbs for a specific dcb off of
    //  Dcb.ParentDcbQueue.  For the root directory this queue is empty
    //  For a non-existent fcb this queue is off of the non existent
    //  fcb queue entry in the vcb.
    //

    LIST_ENTRY ParentDcbLinks;

    //
    //  A pointer to the Dcb that is the parent directory containing
    //  this fcb.  If this record itself is the root dcb then this field
    //  is null.
    //

    struct _FCB *ParentDcb;

    //
    //  A pointer to the Vcb containing this Fcb
    //

    PVCB Vcb;

    //
    //  The internal state of the Fcb.  This is a collection Fcb state flags.
    //  Also the shared access for each time this file/directory is opened.
    //

    ULONG FcbState;
    FCB_CONDITION FcbCondition;
    SHARE_ACCESS ShareAccess;

#ifdef SYSCACHE_COMPILE

    //
    //  For syscache we keep a bitmask that tells us if we have dispatched IO for
    //  the page aligned chunks of the stream.
    //

    PULONG WriteMask;
    ULONG WriteMaskData;

#endif

    //
    //  A count of the number of file objects that have been opened for
    //  this file/directory, but not yet been cleaned up yet.  This count
    //  is only used for data file objects, not for the Acl or Ea stream
    //  file objects.  This count gets decremented in FatCommonCleanup,
    //  while the OpenCount below gets decremented in FatCommonClose.
    //

    CLONG UncleanCount;

    //
    //  A count of the number of file objects that have opened
    //  this file/directory.  For files & directories the FsContext of the
    //  file object points to this record.
    //

    CLONG OpenCount;

    //
    //  A count of how many of "UncleanCount" handles were opened for
    //  non-cached I/O.
    //

    CLONG NonCachedUncleanCount;

    //
    //  The following field is used to locate the dirent for this fcb/dcb.
    //  All directory are opened as mapped files so the only additional
    //  information we need to locate this dirent (beside its parent directory)
    //  is the byte offset for the dirent.  Note that for the root dcb
    //  this field is not used.
    //

    VBO DirentOffsetWithinDirectory;

    //
    //  The following field is filled in when there is an Lfn associated
    //  with this file.  It is the STARTING offset of the Lfn.
    //

    VBO LfnOffsetWithinDirectory;

    //
    //  Thess entries is kept in ssync with the dirent.  It allows a more
    //  accurate verify capability and speeds up FatFastQueryBasicInfo().
    //

    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;

    //
    //  Valid data to disk
    //

    ULONG ValidDataToDisk;

    //
    //  The following field contains the retrieval mapping structure
    //  for the file/directory.  Note that for the Root Dcb this
    //  structure is set at mount time.  Also note that in this
    //  implementation of Fat the Mcb really maps VBOs to LBOs and not
    //  VBNs to LBNs.
    //

    LARGE_MCB Mcb;

    //
    //  The following union is cased off of the node type code for the fcb.
    //  There is a seperate case for the directory versus file fcbs.
    //

    union {

        //
        //  A Directory Control Block (Dcb)
        //

        struct {

            //
            //  A queue of all the fcbs/dcbs that are opened under this
            //  Dcb.
            //

            LIST_ENTRY ParentDcbQueue;

            //
            //  The following field points to the file object used to do I/O to
            //  the directory file for this dcb.  The directory file maps the
            //  sectors for the directory.  This field is initialized by
            //  CreateRootDcb but is left null by CreateDcb.  It isn't
            //  until we try to read/write the directory file that we
            //  create the stream file object for non root dcbs.
            //

            ULONG DirectoryFileOpenCount;
            PFILE_OBJECT DirectoryFile;

            //
            //  If the UnusedDirentVbo is != 0xffffffff, then the dirent at this
            //  offset is guarenteed to unused.  A value of 0xffffffff means
            //  it has yet to be initialized.  Note that a value beyond the
            //  end of allocation means that there an unused dirent, but we
            //  will have to allocate another cluster to use it.
            //
            //  DeletedDirentHint contains lowest possible VBO of a deleted
            //  dirent (assuming as above that it is not 0xffffffff).
            //

            VBO UnusedDirentVbo;
            VBO DeletedDirentHint;

            //
            //  The following two entries links together all the Fcbs
            //  opened under this Dcb sorted in a splay tree by name.
            //
            //  I'd like to go into why we have (and must have) two separate
            //  splay trees within the current fastfat architecture.  I will
            //  provide some insight into what would have to change if we
            //  wanted to have a single UNICODE tree.
            //
            //  What makes FAT unique is that both Oem and Unicode names sit
            //  side by side on disk.  Several unique UNICODE names coming
            //  into fastfat can match a single OEM on-disk name, and there
            //  is really no way to enumerate all the possible UNICODE
            //  source strings that can map to a given OEM name.  This argues
            //  for converting the incomming UNICODE name into OEM, and then
            //  running through an OEM splay tree of the open files.  This
            //  works well when there are only OEM names on disk.
            //
            //  The UNICODE name on disk can be VERY different from the short
            //  name in the DIRENT and not even representable in the OEM code
            //  page.  Even if it were representable in OEM, it is possible
            //  that a case varient of the original UNICODE name would match
            //  a different OEM name, causing us to miss the Fcb in the
            //  prefix lookup phase.  In these cases, we must put UNICODE
            //  name in the splay to guarentee that we find any case varient
            //  of the input UNICODE name.  See the routine description of
            //  FatConstructNamesInFcb() for a detailed analysis of how we
            //  detect this case.
            //
            //  The fundamental limitation we are imposing here is that if
            //  an Fcb exists for an open file, we MUST find it during the
            //  prefix stage.  This is a basic premise of the create path
            //  in fastfat.  In fact if we later find it gravelling through
            //  the disk (but not the splay tree), we will bug check if we
            //  try to add a duplicate entry to the splay tree (not to
            //  mention having two Fcbs).  If we had some mechanism to deal
            //  with cases (and they would be rare) that we don't find the
            //  entry in the splay tree, but the Fcb is actually in there,
            //  then we could go to a single UNICODE splay tree.  While
            //  this uses more pool for the splay tree, and makes string
            //  compares maybe take a bit as longer, it would eliminate the
            //  need for any NLS conversion during the prefix phase, so it
            //  might really be a net win.
            //
            //  The current scheme was optimized for non-extended names
            //  (i.e. US names).  As soon as you start using extended
            //  characters, then it is clearly a win as many code paths
            //  become active that would otherwise not be needed if we
            //  only had a single UNICODE splay tree.
            //
            //  We may think about changing this someday.
            //

            PRTL_SPLAY_LINKS RootOemNode;
            PRTL_SPLAY_LINKS RootUnicodeNode;

            //
            //  The following field keeps track of free dirents, i.e.,
            //  dirents that are either unallocated for deleted.
            //

            RTL_BITMAP FreeDirentBitmap;

            //
            //  Since the FCB specific part of this union is larger, use
            //  the slack here for an initial bitmap buffer.  Currently
            //  there is enough space here for an 8K cluster.
            //

            ULONG FreeDirentBitmapBuffer[1];

        } Dcb;

        //
        //  A File Control Block (Fcb)
        //

        struct {

            //
            //  The following field is used by the filelock module
            //  to maintain current byte range locking information.
            //

            FILE_LOCK FileLock;

            //
            //  The following field is used by the oplock module
            //  to maintain current oplock information.
            //

            OPLOCK Oplock;

            //
            //  This pointer is used to detect writes that eminated in the
            //  cache manager's lazywriter.  It prevents lazy writer threads,
            //  who already have the Fcb shared, from trying to acquire it
            //  exclusive, and thus causing a deadlock.
            //

            PVOID LazyWriteThread;

        } Fcb;

    } Specific;

    //
    //  The following field is used to verify that the Ea's for a file
    //  have not changed between calls to query for Ea's.  It is compared
    //  with a similar field in a Ccb.
    //
    //  IMPORTANT!! **** DO NOT MOVE THIS FIELD ****
    //
    //              The slack space in the union above is computed from
    //              the field offset of the EaModificationCount.
    //

    ULONG EaModificationCount;

    //
    //  The following field is the fully qualified file name for this FCB/DCB
    //  starting from the root of the volume, and last file name in the
    //  fully qualified name.
    //

    FILE_NAME_NODE ShortName;

    //
    //  The following field is only filled in if it is needed with the user's
    //  opened path
    //

    UNICODE_STRING FullFileName;

    USHORT FinalNameLength;

    //
    //  To make life simpler we also keep in the Fcb/Dcb a current copy of
    //  the fat attribute byte for the file/directory.  This field must
    //  also be updated when we create the Fcb, modify the File, or verify
    //  the Fcb
    //

    UCHAR DirentFatFlags;

    //
    //  The case preserved long filename
    //

    UNICODE_STRING ExactCaseLongName;

    //
    //  If the UNICODE Lfn is fully expressible in the system Oem code
    //  page, then we will store it in a prefix table, otherwise we will
    //  store the last UNICODE name in the Fcb.  In both cases the name
    //  has been upcased.
    //
    //  Note that we may need neither of these fields if an LFN was strict
    //  8.3 or differed only in case.  Indeed if there wasn't an LFN, we
    //  don't need them at all.
    //

    union {

        //
        //  This first field is present if FCB_STATE_HAS_OEM_LONG_NAME
        //  is set in the FcbState.
        //

        FILE_NAME_NODE Oem;

        //
        //  This first field is present if FCB_STATE_HAS_UNICODE_LONG_NAME
        //  is set in the FcbState.
        //

        FILE_NAME_NODE Unicode;

    } LongName;

    //
    //  Defragmentation / ReallocateOnWrite synchronization object.  This
    //  is filled in by FatMoveFile() and affects the read and write paths.
    //

    PKEVENT MoveFileEvent;

} FCB, *PFCB;

#ifndef BUILDING_FSKDEXT
//
//  DCB clashes with a type defined outside the filesystems,  in headers
//  pulled in by FSKD.  We don't need this typedef for fskd anyway....
//
typedef FCB DCB;
typedef DCB *PDCB;
#endif


//
//  Here are the Fcb state fields.
//

#define FCB_STATE_DELETE_ON_CLOSE        (0x00000001)
#define FCB_STATE_TRUNCATE_ON_CLOSE      (0x00000002)
#define FCB_STATE_PAGING_FILE            (0x00000004)
#define FCB_STATE_FORCE_MISS_IN_PROGRESS (0x00000008)
#define FCB_STATE_FLUSH_FAT              (0x00000010)
#define FCB_STATE_TEMPORARY              (0x00000020)
#define FCB_STATE_SYSTEM_FILE            (0x00000080)
#define FCB_STATE_NAMES_IN_SPLAY_TREE    (0x00000100)
#define FCB_STATE_HAS_OEM_LONG_NAME      (0x00000200)
#define FCB_STATE_HAS_UNICODE_LONG_NAME  (0x00000400)
#define FCB_STATE_DELAY_CLOSE            (0x00000800)

//
//  Copies of the dirent's FAT_DIRENT_NT_BYTE_* flags for
//  preserving case of the short name of a file
//

#define FCB_STATE_8_LOWER_CASE           (0x00001000)
#define FCB_STATE_3_LOWER_CASE           (0x00002000)

//
//  This is the slack allocation in the Dcb part of the UNION above
//

#define DCB_UNION_SLACK_SPACE ((ULONG)                       \
    (FIELD_OFFSET(DCB, EaModificationCount) -                \
     FIELD_OFFSET(DCB, Specific.Dcb.FreeDirentBitmapBuffer)) \
)

//
//  This is the special (64bit) allocation size that indicates the
//  real size must be retrieved from disk.  Define it here so we
//  avoid excessive magic numbering around the driver.
//

#define FCB_LOOKUP_ALLOCATIONSIZE_HINT   ((LONGLONG) -1)


//
//  The Ccb record is allocated for every file object.  Note that this
//  record is exactly 0x34 long on x86 so that it will fit into a 0x40
//  piece of pool.  Please carefully consider modifications.
//
//  Define the Flags field.
//

#define CCB_FLAG_MATCH_ALL               (0x0001)
#define CCB_FLAG_SKIP_SHORT_NAME_COMPARE (0x0002)

//
//  This tells us whether we allocated buffers to hold search templates.
//

#define CCB_FLAG_FREE_OEM_BEST_FIT       (0x0004)
#define CCB_FLAG_FREE_UNICODE            (0x0008)

//
//  These flags prevents cleanup from updating the modify time, etc.
//

#define CCB_FLAG_USER_SET_LAST_WRITE     (0x0010)
#define CCB_FLAG_USER_SET_LAST_ACCESS    (0x0020)
#define CCB_FLAG_USER_SET_CREATION       (0x0040)

//
//  This bit says the file object associated with this Ccb was opened for
//  read only access.
//

#define CCB_FLAG_READ_ONLY               (0x0080)

//
//  These flags, are used is DASD handles in read and write.
//

#define CCB_FLAG_DASD_FLUSH_DONE         (0x0100)
#define CCB_FLAG_DASD_PURGE_DONE         (0x0200)

//
//  This flag keeps track of a handle that was opened for
//  DELETE_ON_CLOSE.
//

#define CCB_FLAG_DELETE_ON_CLOSE         (0x0400)

//
//  This flag keeps track of which side of the name pair on the file
//  associated with the handle was opened
//

#define CCB_FLAG_OPENED_BY_SHORTNAME     (0x0800)

//
//  This flag indicates that the query template has not been upcased
// (i.e., query should be case-insensitive)
//

#define CCB_FLAG_QUERY_TEMPLATE_MIXED    (0x1000)

//
//  This flag indicates that reads and writes via this DASD handle
//  are allowed to start or extend past the end of file.
//

#define CCB_FLAG_ALLOW_EXTENDED_DASD_IO  (0x2000)

//
//  This flag indicates we want to match volume labels in directory
//  searches (important for the root dir defrag).
//

#define CCB_FLAG_MATCH_VOLUME_ID         (0x4000)

//
//  This flag indicates the ccb has been converted over into a
//  close context for asynchronous/delayed closing of the handle.
//

#define CCB_FLAG_CLOSE_CONTEXT           (0x8000)

//
//  This flag indicates that when the handle is closed, we want
//  a physical dismount to occur.
//

#define CCB_FLAG_COMPLETE_DISMOUNT       (0x10000)

//
//  This flag indicates the handle may not call priveleged
//  FSCTL which modify the volume.
//

#define CCB_FLAG_MANAGE_VOLUME_ACCESS    (0x20000)

//
//  This structure is used to keep track of information needed to do a
//  deferred close.  It is now embedded in a CCB so we don't have to
//  allocate one in the close path (with mustsucceed).
//

typedef struct _CLOSE_CONTEXT {

    //
    //  Two sets of links, one for the global list and one for closes
    //  on a particular volume.
    //
    
    LIST_ENTRY GlobalLinks;
    LIST_ENTRY VcbLinks;

    PVCB Vcb;
    PFCB Fcb;
    enum _TYPE_OF_OPEN TypeOfOpen;
    BOOLEAN Free;

} CLOSE_CONTEXT;

typedef CLOSE_CONTEXT *PCLOSE_CONTEXT;

typedef struct _CCB {

    //
    //  Type and size of this record (must be FAT_NTC_CCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Define a 24bit wide field for Flags, but a UCHAR for Wild Cards Present
    //  since it is used so often.  Line these up on byte boundaries for grins.
    //

    ULONG Flags:24;
    BOOLEAN ContainsWildCards;

    //
    //  Overlay a close context on the data of the CCB.  The remaining
    //  fields are not useful during close, and we would like to avoid
    //  paying extra pool for it.
    //

    union {
        
        struct {

            //
            //  Save the offset to start search from.
            //

            VBO OffsetToStartSearchFrom;

            //
            //  The query template is used to filter directory query requests.
            //  It originally is set to null and on the first call the NtQueryDirectory
            //  it is set to the input filename or "*" if the name is not supplied.
            //  All subsquent queries then use this template.
            //
            //  The Oem structure are unions because if the name is wild we store
            //  the arbitrary length string, while if the name is constant we store
            //  8.3 representation for fast comparison.
            //

            union {

                //
                //  If the template contains a wild card use this.
                //

                OEM_STRING Wild;

                //
                //  If the name is constant, use this part.
                //

                FAT8DOT3 Constant;

            } OemQueryTemplate;

            UNICODE_STRING UnicodeQueryTemplate;

            //
            //  The field is compared with the similar field in the Fcb to determine
            //  if the Ea's for a file have been modified.
            //

            ULONG EaModificationCount;

            //
            //  The following field is used as an offset into the Eas for a
            //  particular file.  This will be the offset for the next
            //  Ea to return.  A value of 0xffffffff indicates that the
            //  Ea's are exhausted.
            //

            ULONG OffsetOfNextEaToReturn;

        };

        CLOSE_CONTEXT CloseContext;
    };
    
} CCB;
typedef CCB *PCCB;

//
//  The Irp Context record is allocated for every orginating Irp.  It is
//  created by the Fsd dispatch routines, and deallocated by the FatComplete
//  request routine.  It contains a structure called of type REPINNED_BCBS
//  which is used to retain pinned bcbs needed to handle abnormal termination
//  unwinding.
//

#define REPINNED_BCBS_ARRAY_SIZE         (4)

typedef struct _REPINNED_BCBS {

    //
    //  A pointer to the next structure contains additional repinned bcbs
    //

    struct _REPINNED_BCBS *Next;

    //
    //  A fixed size array of pinned bcbs.  Whenever a new bcb is added to
    //  the repinned bcb structure it is added to this array.  If the
    //  array is already full then another repinned bcb structure is allocated
    //  and pointed to with Next.
    //

    PBCB Bcb[ REPINNED_BCBS_ARRAY_SIZE ];

} REPINNED_BCBS;
typedef REPINNED_BCBS *PREPINNED_BCBS;

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be FAT_NTC_IRP_CONTEXT)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

    //
    //  A pointer to the originating Irp.
    //

    PIRP OriginatingIrp;

    //
    //  Originating Device (required for workque algorithms)
    //

    PDEVICE_OBJECT RealDevice;

    //
    //  Originating Vcb (required for exception handling)
    //  On mounts, this will be set before any exceptions
    //  indicating corruption can be thrown.
    //

    PVCB Vcb;

    //
    //  Major and minor function codes copied from the Irp
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  The following fields indicate if we can wait/block for a resource
    //  or I/O, if we are to do everything write through, and if this
    //  entry into the Fsd is a recursive call.
    //

    UCHAR PinCount;

    ULONG Flags;

    //
    //  The following field contains the NTSTATUS value used when we are
    //  unwinding due to an exception
    //

    NTSTATUS ExceptionStatus;

    //
    //  The following context block is used for non-cached Io
    //

    struct _FAT_IO_CONTEXT *FatIoContext;

    //
    //  For a abnormal termination unwinding this field contains the Bcbs
    //  that are kept pinned until the Irp is completed.
    //

    REPINNED_BCBS Repinned;

} IRP_CONTEXT;
typedef IRP_CONTEXT *PIRP_CONTEXT;

#define IRP_CONTEXT_FLAG_DISABLE_DIRTY              (0x00000001)
#define IRP_CONTEXT_FLAG_WAIT                       (0x00000002)
#define IRP_CONTEXT_FLAG_WRITE_THROUGH              (0x00000004)
#define IRP_CONTEXT_FLAG_DISABLE_WRITE_THROUGH      (0x00000008)
#define IRP_CONTEXT_FLAG_RECURSIVE_CALL             (0x00000010)
#define IRP_CONTEXT_FLAG_DISABLE_POPUPS             (0x00000020)
#define IRP_CONTEXT_FLAG_DEFERRED_WRITE             (0x00000040)
#define IRP_CONTEXT_FLAG_VERIFY_READ                (0x00000080)
#define IRP_CONTEXT_STACK_IO_CONTEXT                (0x00000100)
#define IRP_CONTEXT_FLAG_IN_FSP                     (0x00000200)
#define IRP_CONTEXT_FLAG_USER_IO                    (0x00000400)       // for performance counters
#define IRP_CONTEXT_FLAG_DISABLE_RAISE              (0x00000800)
#define IRP_CONTEXT_FLAG_PARENT_BY_CHILD (0x80000000)


//
//  Context structure for non-cached I/O calls.  Most of these fields
//  are actually only required for the Read/Write Multiple routines, but
//  the caller must allocate one as a local variable anyway before knowing
//  whether there are multiple requests are not.  Therefore, a single
//  structure is used for simplicity.
//

typedef struct _FAT_IO_CONTEXT {

    //
    //  These two field are used for multiple run Io
    //

    LONG IrpCount;
    PIRP MasterIrp;

    //
    //  MDL to describe partial sector zeroing
    //

    PMDL ZeroMdl;

    union {

        //
        //  This element handles the asychronous non-cached Io
        //

        struct {
            PERESOURCE Resource;
            PERESOURCE Resource2;
            ERESOURCE_THREAD ResourceThreadId;
            ULONG RequestedByteCount;
            PFILE_OBJECT FileObject;
            PNON_PAGED_FCB NonPagedFcb;
        } Async;

        //
        //  and this element the sycnrhonous non-cached Io
        //

        KEVENT SyncEvent;

    } Wait;

} FAT_IO_CONTEXT;

typedef FAT_IO_CONTEXT *PFAT_IO_CONTEXT;

//
//  An array of these structures is passed to FatMultipleAsync describing
//  a set of runs to execute in parallel.
//

typedef struct _IO_RUNS {

    LBO Lbo;
    VBO Vbo;
    ULONG Offset;
    ULONG ByteCount;
    PIRP SavedIrp;

} IO_RUN;

typedef IO_RUN *PIO_RUN;

//
//  This structure is used by FatDeleteDirent to preserve the first cluster
//  and file size info for undelete utilities.
//

typedef struct _DELETE_CONTEXT {

    ULONG FileSize;
    ULONG FirstClusterOfFile;

} DELETE_CONTEXT;

typedef DELETE_CONTEXT *PDELETE_CONTEXT;

//
//  This record is used with to set a flush to go off one second after the
//  first write on slow devices with a physical indication of activity, like
//  a floppy.  This is an attempt to keep the red light on.
//

typedef struct _DEFERRED_FLUSH_CONTEXT {

    KDPC Dpc;
    KTIMER Timer;
    WORK_QUEUE_ITEM Item;

    PFILE_OBJECT File;

} DEFERRED_FLUSH_CONTEXT;

typedef DEFERRED_FLUSH_CONTEXT *PDEFERRED_FLUSH_CONTEXT;

//
//  This structure is used for the FatMarkVolumeClean callbacks.
//

typedef struct _CLEAN_AND_DIRTY_VOLUME_PACKET {

    WORK_QUEUE_ITEM Item;
    PIRP Irp;
    PVCB Vcb;
    PKEVENT Event;
} CLEAN_AND_DIRTY_VOLUME_PACKET, *PCLEAN_AND_DIRTY_VOLUME_PACKET;

//
//  This structure is used when a page fault is running out of stack.
//

typedef struct _PAGING_FILE_OVERFLOW_PACKET {
    PIRP Irp;
    PFCB Fcb;
} PAGING_FILE_OVERFLOW_PACKET, *PPAGING_FILE_OVERFLOW_PACKET;

//
//  This structure is used to access the EaFile.
//

#define EA_BCB_ARRAY_SIZE                   8

typedef struct _EA_RANGE {

    PCHAR Data;
    ULONG StartingVbo;
    ULONG Length;
    USHORT BcbChainLength;
    BOOLEAN AuxilaryBuffer;
    PBCB *BcbChain;
    PBCB BcbArray[EA_BCB_ARRAY_SIZE];

} EA_RANGE, *PEA_RANGE;

#define EA_RANGE_HEADER_SIZE        (FIELD_OFFSET( EA_RANGE, BcbArray ))

//
//  These symbols are used by the upcase/downcase routines.
//

#define WIDE_LATIN_CAPITAL_A    (0xff21)
#define WIDE_LATIN_CAPITAL_Z    (0xff3a)
#define WIDE_LATIN_SMALL_A      (0xff41)
#define WIDE_LATIN_SMALL_Z      (0xff5a)

//
//  These values are returned by FatInterpretClusterType.
//

typedef enum _CLUSTER_TYPE {
    FatClusterAvailable,
    FatClusterReserved,
    FatClusterBad,
    FatClusterLast,
    FatClusterNext
} CLUSTER_TYPE;


#endif // _FATSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fspdisp.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FspDisp.c

Abstract:

    This module implements the main dispatch procedure/thread for the Fat
    Fsp

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  Internal support routine, spinlock wrapper.
//

PVOID
FatRemoveOverflowEntry (
    IN PVOLUME_DEVICE_OBJECT VolDo
    );

//
//  Define our local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSP_DISPATCHER)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatFspDispatch)
#endif


VOID
FatFspDispatch (
    IN PVOID Context
    )

/*++

Routine Description:

    This is the main FSP thread routine that is executed to receive
    and dispatch IRP requests.  Each FSP thread begins its execution here.
    There is one thread created at system initialization time and subsequent
    threads created as needed.

Arguments:


    Context - Supplies the thread id.

Return Value:

    None - This routine never exits

--*/

{
    NTSTATUS Status;

    PIRP Irp;
    PIRP_CONTEXT IrpContext;
    PIO_STACK_LOCATION IrpSp;

    PVOLUME_DEVICE_OBJECT VolDo;

    IrpContext = (PIRP_CONTEXT)Context;

    Irp = IrpContext->OriginatingIrp;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Now because we are the Fsp we will force the IrpContext to
    //  indicate true on Wait.
    //

    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT | IRP_CONTEXT_FLAG_IN_FSP);

    //
    //  If this request has an associated volume device object, remember it.
    //

    if ( IrpSp->FileObject != NULL ) {

        VolDo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                   VOLUME_DEVICE_OBJECT,
                                   DeviceObject );
    } else {

        VolDo = NULL;
    }

    //
    //  Now case on the function code.  For each major function code,
    //  either call the appropriate FSP routine or case on the minor
    //  function and then call the FSP routine.  The FSP routine that
    //  we call is responsible for completing the IRP, and not us.
    //  That way the routine can complete the IRP and then continue
    //  post processing as required.  For example, a read can be
    //  satisfied right away and then read can be done.
    //
    //  We'll do all of the work within an exception handler that
    //  will be invoked if ever some underlying operation gets into
    //  trouble (e.g., if FatReadSectorsSync has trouble).
    //

    while ( TRUE ) {

        DebugTrace(0, Dbg, "FatFspDispatch: Irp = 0x%08lx\n", Irp);

        //
        //  If this Irp was top level, note it in our thread local storage.
        //

        FsRtlEnterFileSystem();

        if ( FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_RECURSIVE_CALL) ) {

            IoSetTopLevelIrp( (PIRP)FSRTL_FSP_TOP_LEVEL_IRP );

        } else {

            IoSetTopLevelIrp( Irp );
        }

        try {

            switch ( IrpContext->MajorFunction ) {

                //
                //  For Create Operation,
                //

                case IRP_MJ_CREATE:

                    (VOID) FatCommonCreate( IrpContext, Irp );
                    break;

                //
                //  For close operations.  We do a little kludge here in case
                //  this close causes a volume to go away.  It will NULL the
                //  VolDo local variable so that we will not try to look at
                //  the overflow queue.
                //

                case IRP_MJ_CLOSE:

                {
                    PVCB Vcb;
                    PFCB Fcb;
                    PCCB Ccb;
                    TYPE_OF_OPEN TypeOfOpen;

                    //
                    //  Extract and decode the file object
                    //

                    TypeOfOpen = FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb );

                    //
                    //  Do the close.  We have a slightly different format
                    //  for this call because of the async closes.
                    //

                    Status = FatCommonClose( Vcb, Fcb, Ccb, TypeOfOpen, TRUE, &VolDo);

                    ASSERT(Status == STATUS_SUCCESS);

                    FatCompleteRequest( IrpContext, Irp, Status );

                    break;
                }

                //
                //  For read operations
                //

                case IRP_MJ_READ:

                    (VOID) FatCommonRead( IrpContext, Irp );
                    break;

                //
                //  For write operations,
                //

                case IRP_MJ_WRITE:

                    (VOID) FatCommonWrite( IrpContext, Irp );
                    break;

                //
                //  For Query Information operations,
                //

                case IRP_MJ_QUERY_INFORMATION:

                    (VOID) FatCommonQueryInformation( IrpContext, Irp );
                    break;

                //
                //  For Set Information operations,
                //

                case IRP_MJ_SET_INFORMATION:

                    (VOID) FatCommonSetInformation( IrpContext, Irp );
                    break;

                //
                //  For Query EA operations,
                //

                case IRP_MJ_QUERY_EA:

                    (VOID) FatCommonQueryEa( IrpContext, Irp );
                    break;

                //
                //  For Set EA operations,
                //

                case IRP_MJ_SET_EA:

                    (VOID) FatCommonSetEa( IrpContext, Irp );
                    break;

                //
                //  For Flush buffers operations,
                //

                case IRP_MJ_FLUSH_BUFFERS:

                    (VOID) FatCommonFlushBuffers( IrpContext, Irp );
                    break;

                //
                //  For Query Volume Information operations,
                //

                case IRP_MJ_QUERY_VOLUME_INFORMATION:

                    (VOID) FatCommonQueryVolumeInfo( IrpContext, Irp );
                    break;

                //
                //  For Set Volume Information operations,
                //

                case IRP_MJ_SET_VOLUME_INFORMATION:

                    (VOID) FatCommonSetVolumeInfo( IrpContext, Irp );
                    break;

                //
                //  For File Cleanup operations,
                //

                case IRP_MJ_CLEANUP:

                    (VOID) FatCommonCleanup( IrpContext, Irp );
                    break;

                //
                //  For Directory Control operations,
                //

                case IRP_MJ_DIRECTORY_CONTROL:

                    (VOID) FatCommonDirectoryControl( IrpContext, Irp );
                    break;

                //
                //  For File System Control operations,
                //

                case IRP_MJ_FILE_SYSTEM_CONTROL:

                    (VOID) FatCommonFileSystemControl( IrpContext, Irp );
                    break;

                //
                //  For Lock Control operations,
                //

                case IRP_MJ_LOCK_CONTROL:

                    (VOID) FatCommonLockControl( IrpContext, Irp );
                    break;

                //
                //  For Device Control operations,
                //

                case IRP_MJ_DEVICE_CONTROL:

                    (VOID) FatCommonDeviceControl( IrpContext, Irp );
                    break;

                //
                //  For the Shutdown operation,
                //

                case IRP_MJ_SHUTDOWN:

                    (VOID) FatCommonShutdown( IrpContext, Irp );
                    break;

                //
                //  For plug and play operations.
                //

                case IRP_MJ_PNP:

                    //
                    //  I don't believe this should ever occur, but allow for the unexpected.
                    //

                    (VOID) FatCommonPnp( IrpContext, Irp );
                    break;

                //
                //  For any other major operations, return an invalid
                //  request.
                //

                default:

                    FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
                    break;

            }

        } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code.
            //

            (VOID) FatProcessException( IrpContext, Irp, GetExceptionCode() );
        }

        IoSetTopLevelIrp( NULL );

        FsRtlExitFileSystem();

        //
        //  If there are any entries on this volume's overflow queue, service
        //  them.
        //

        if ( VolDo != NULL ) {

            PVOID Entry;

            //
            //  We have a volume device object so see if there is any work
            //  left to do in its overflow queue.
            //

            Entry = FatRemoveOverflowEntry( VolDo );

            //
            //  There wasn't an entry, break out of the loop and return to
            //  the Ex Worker thread.
            //

            if ( Entry == NULL ) {

                break;
            }

            //
            //  Extract the IrpContext, Irp, and IrpSp, and loop.
            //

            IrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

            SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT | IRP_CONTEXT_FLAG_IN_FSP);

            Irp = IrpContext->OriginatingIrp;

            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            continue;

        } else {

            break;
        }
    }

    //
    //  Decrement the PostedRequestCount.
    //

    if ( VolDo ) {

        ExInterlockedAddUlong( &VolDo->PostedRequestCount,
                               0xffffffff,
                               &VolDo->OverflowQueueSpinLock );
    }

    return;
}


//
//  Internal support routine, spinlock wrapper.
//

PVOID
FatRemoveOverflowEntry (
    IN PVOLUME_DEVICE_OBJECT VolDo
    )
{
    PVOID Entry;
    KIRQL SavedIrql;

    KeAcquireSpinLock( &VolDo->OverflowQueueSpinLock, &SavedIrql );

    if (VolDo->OverflowQueueCount > 0) {

        //
        //  There is overflow work to do in this volume so we'll
        //  decrement the Overflow count, dequeue the IRP, and release
        //  the Event
        //

        VolDo->OverflowQueueCount -= 1;

        Entry = RemoveHeadList( &VolDo->OverflowQueue );

    } else {

        Entry = NULL;
    }

    KeReleaseSpinLock( &VolDo->OverflowQueueSpinLock, SavedIrql );

    return Entry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fatprocs.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FatProcs.h

Abstract:

    This module defines all of the globally used procedures in the FAT
    file system.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _FATPROCS_
#define _FATPROCS_

#include <ntifs.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>
#include <ntddstor.h>

#include "nodetype.h"
#include "Fat.h"
#include "Lfn.h"
#include "FatStruc.h"
#include "FatData.h"

#ifndef INLINE
#define INLINE __inline
#endif

//
//  We must explicitly tag our allocations.
//

#undef FsRtlAllocatePool
#undef FsRtlAllocatePoolWithQuota

//
//  A function that returns finished denotes if it was able to complete the
//  operation (TRUE) or could not complete the operation (FALSE) because the
//  wait value stored in the irp context was false and we would have had
//  to block for a resource or I/O
//

typedef BOOLEAN FINISHED;

//
//  Size (characters) of stack allocated name component buffers in 
//  the create/rename paths.
//

#define FAT_CREATE_INITIAL_NAME_BUF_SIZE    32

//
//  Some string buffer handling functions,  implemented in strucsup.c
//

VOID
FatFreeStringBuffer(
    IN PVOID String
    );

VOID
FatEnsureStringBufferEnough(
    IN OUT PVOID String,
    IN USHORT DesiredBufferSize
    );



BOOLEAN
FatAddMcbEntry (
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb,
    IN VBO Vbo,
    IN LBO Lbo,
    IN ULONG SectorCount
    );

BOOLEAN
FatLookupMcbEntry (
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index OPTIONAL
    );

BOOLEAN
FatLookupLastMcbEntry (
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb,
    OUT PVBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG Index OPTIONAL
    );

BOOLEAN
FatGetNextMcbEntry (
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb,
    IN ULONG RunIndex,
    OUT PVBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG SectorCount
    );

VOID
FatRemoveMcbEntry (
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb,
    IN VBO Vbo,
    IN ULONG SectorCount
    );


//
//  File access check routine, implemented in AcChkSup.c
//

BOOLEAN
FatCheckFileAccess (
    PIRP_CONTEXT IrpContext,
    IN UCHAR DirentAttributes,
    IN PACCESS_MASK DesiredAccess
    );

NTSTATUS
FatExplicitDeviceAccessGranted (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE ProcessorMode
    );


//
//  Allocation support routines, implemented in AllocSup.c
//

INLINE
BOOLEAN
FatIsIoRangeValid (
    IN PVCB Vcb,
    IN LARGE_INTEGER Start,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine enforces the restriction that object space must be
    representable in 32 bits.

Arguments:

    Vcb - the volume the range is on

    Start - starting byte (zero based) of the range

    Length - size of the range

Return Value:

    BOOLEAN - if, considering the cluster size, the neccesary size of
        the object to contain the range can be represented in 32 bits.

--*/

{
    //
    //  The only restriction on a FAT object is that the filesize must
    //  fit in 32bits, i.e. <= 0xffffffff. This then implies that the
    //  range of valid byte offsets is [0, fffffffe].
    //
    //  Two phases which check for illegality
    //
    //      - if the high 32bits are nonzero
    //      - if the length would cause a 32bit overflow
    //

    return !(Start.HighPart ||
             Start.LowPart + Length < Start.LowPart);
}

VOID
FatSetupAllocationSupport (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
FatTearDownAllocationSupport (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
FatLookupFileAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount,
    OUT PBOOLEAN Allocated,
    OUT PBOOLEAN EndOnMax,
    OUT PULONG Index OPTIONAL
    );

VOID
FatAddFileAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN ULONG AllocationSize
    );

VOID
FatTruncateFileAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN ULONG AllocationSize
    );

VOID
FatLookupFileAllocationSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb
    );

VOID
FatAllocateDiskSpace (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG AbsoluteClusterHint,
    IN OUT PULONG ByteCount,
    IN BOOLEAN ExactMatchRequired,
    OUT PLARGE_MCB Mcb
    );

VOID
FatDeallocateDiskSpace (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb
    );

VOID
FatSplitAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PLARGE_MCB Mcb,
    IN VBO SplitAtVbo,
    OUT PLARGE_MCB RemainingMcb
    );

VOID
FatMergeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PLARGE_MCB Mcb,
    IN PLARGE_MCB SecondMcb
    );

VOID
FatSetFatEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FatIndex,
    IN FAT_ENTRY FatEntry
    );

UCHAR
FatLogOf(
    IN ULONG Value
    );


//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

VOID
FatReadVolumeFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer
    );

VOID
FatPrepareWriteVolumeFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    IN BOOLEAN Reversible,
    IN BOOLEAN Zero
    );

VOID
FatReadDirectoryFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    IN BOOLEAN Pin,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    OUT PNTSTATUS Status
    );

VOID
FatPrepareWriteDirectoryFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    IN BOOLEAN Zero,
    IN BOOLEAN Reversible,
    OUT PNTSTATUS Status
    );

VOID
FatOpenDirectoryFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    );

PFILE_OBJECT
FatOpenEaFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB EaFcb
    );

VOID
FatCloseEaFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN FlushFirst
    );

VOID
FatSetDirtyBcb (
    IN PIRP_CONTEXT IrpContext,
    IN PBCB Bcb,
    IN PVCB Vcb OPTIONAL,
    IN BOOLEAN Reversible
    );

VOID
FatRepinBcb (
    IN PIRP_CONTEXT IrpContext,
    IN PBCB Bcb
    );

VOID
FatUnpinRepinnedBcbs (
    IN PIRP_CONTEXT IrpContext
    );

FINISHED
FatZeroData (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ULONG StartingZero,
    IN ULONG ByteCount
    );

NTSTATUS
FatCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
FatPinMappedData (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb
    );

//
// VOID
// FatUnpinBcb (
//     IN PIRP_CONTEXT IrpContext,
//     IN OUT PBCB Bcb,
//     );
//

//
//  This macro unpins a Bcb, in the checked build make sure all
//  requests unpin all Bcbs before leaving.
//

#if DBG

#define FatUnpinBcb(IRPCONTEXT,BCB) {       \
    if ((BCB) != NULL) {                    \
        CcUnpinData((BCB));                 \
        ASSERT( (IRPCONTEXT)->PinCount );   \
        (IRPCONTEXT)->PinCount -= 1;        \
        (BCB) = NULL;                       \
    }                                       \
}

#else

#define FatUnpinBcb(IRPCONTEXT,BCB) { \
    if ((BCB) != NULL) {              \
        CcUnpinData((BCB));           \
        (BCB) = NULL;                 \
    }                                 \
}

#endif // DBG

VOID
FatSyncUninitializeCacheMap (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject
    );


//
//  Device I/O routines, implemented in DevIoSup.c
//
//  These routines perform the actual device read and writes.  They only affect
//  the on disk structure and do not alter any other data structures.
//

VOID
FatPagingFileIo (
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
FatNonCachedIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB FcbOrDcb,
    IN ULONG StartingVbo,
    IN ULONG ByteCount,
    IN ULONG UserByteCount
    );

VOID
FatNonCachedNonAlignedRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB FcbOrDcb,
    IN ULONG StartingVbo,
    IN ULONG ByteCount
    );

VOID
FatMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PIRP Irp,
    IN ULONG MultipleIrpCount,
    IN PIO_RUN IoRuns
    );

VOID
FatSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PIRP Irp
    );

VOID
FatWaitSync (
    IN PIRP_CONTEXT IrpContext
    );

VOID
FatLockUserBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

PVOID
FatBufferUserBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PIRP Irp,
    IN ULONG BufferLength
    );

PVOID
FatMapUserBuffer (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PIRP Irp
    );

NTSTATUS
FatToggleMediaEjectDisable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN PreventRemoval
    );

NTSTATUS
FatPerformDevIoCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT Device,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN BOOLEAN OverrideVerify,
    OUT PIO_STATUS_BLOCK Iosb OPTIONAL
    );

//
//  Dirent support routines, implemented in DirSup.c
//

//
//  Tunneling is a deletion precursor (all tunneling cases do
//  not involve deleting dirents, however)
//

VOID
FatTunnelFcbOrDcb (
    IN PFCB FcbOrDcb,
    IN PCCB Ccb OPTIONAL
    );

ULONG
FatCreateNewDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB ParentDirectory,
    IN ULONG DirentsNeeded
    );

VOID
FatInitializeDirectoryDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN PDIRENT ParentDirent
    );

VOID
FatDeleteDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN PDELETE_CONTEXT DeleteContext OPTIONAL,
    IN BOOLEAN DeleteEa
    );

VOID
FatLocateDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB ParentDirectory,
    IN PCCB Ccb,
    IN VBO OffsetToStartSearchFrom,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb,
    OUT PVBO ByteOffset,
    OUT PBOOLEAN FileNameDos OPTIONAL,
    OUT PUNICODE_STRING Lfn OPTIONAL
    );

VOID
FatLocateSimpleOemDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB ParentDirectory,
    IN POEM_STRING FileName,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb,
    OUT PVBO ByteOffset
    );

BOOLEAN
FatLfnDirentExists (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN PUNICODE_STRING Lfn,
    IN PUNICODE_STRING LfnTmp
    );

VOID
FatLocateVolumeLabel (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb,
    OUT PVBO ByteOffset
    );

VOID
FatGetDirentFromFcbOrDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    OUT PDIRENT *Dirent,
    OUT PBCB *Bcb
    );

BOOLEAN
FatIsDirectoryEmpty (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    );

VOID
FatConstructDirent (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDIRENT Dirent,
    IN POEM_STRING FileName,
    IN BOOLEAN ComponentReallyLowercase,
    IN BOOLEAN ExtensionReallyLowercase,
    IN PUNICODE_STRING Lfn OPTIONAL,
    IN UCHAR Attributes,
    IN BOOLEAN ZeroAndSetTimeFields,
    IN PLARGE_INTEGER SetCreationTime OPTIONAL
    );

VOID
FatConstructLabelDirent (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDIRENT Dirent,
    IN POEM_STRING Label
    );

VOID
FatSetFileSizeInDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PULONG AlternativeFileSize OPTIONAL
    );

VOID
FatUpdateDirentFromFcb (
   IN PIRP_CONTEXT IrpContext,
   IN PFILE_OBJECT FileObject,
   IN PFCB FcbOrDcb,
   IN PCCB Ccb
   );

//
//  Generate a relatively unique static 64bit ID from a FAT Fcb/Dcb
//
//  ULONGLONG
//  FatDirectoryKey (FcbOrDcb);
//

#define FatDirectoryKey(FcbOrDcb)  ((ULONGLONG)((FcbOrDcb)->CreationTime.QuadPart ^ (FcbOrDcb)->FirstClusterOfFile))


//
//  The following routines are used to access and manipulate the
//  clusters containing EA data in the ea data file.  They are
//  implemented in EaSup.c
//

//
//  VOID
//  FatUpcaseEaName (
//      IN PIRP_CONTEXT IrpContext,
//      IN POEM_STRING EaName,
//      OUT POEM_STRING UpcasedEaName
//      );
//

#define FatUpcaseEaName( IRPCONTEXT, NAME, UPCASEDNAME ) \
    RtlUpperString( UPCASEDNAME, NAME )

VOID
FatGetEaLength (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDIRENT Dirent,
    OUT PULONG EaLength
    );

VOID
FatGetNeedEaCount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDIRENT Dirent,
    OUT PULONG NeedEaCount
    );

VOID
FatCreateEa (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PUCHAR Buffer,
    IN ULONG Length,
    IN POEM_STRING FileName,
    OUT PUSHORT EaHandle
    );

VOID
FatDeleteEa (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN USHORT EaHandle,
    IN POEM_STRING FileName
    );

VOID
FatGetEaFile (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    OUT PDIRENT *EaDirent,
    OUT PBCB *EaBcb,
    IN BOOLEAN CreateFile,
    IN BOOLEAN ExclusiveFcb
    );

VOID
FatReadEaSet (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN USHORT EaHandle,
    IN POEM_STRING FileName,
    IN BOOLEAN ReturnEntireSet,
    OUT PEA_RANGE EaSetRange
    );

VOID
FatDeleteEaSet (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PBCB EaBcb,
    OUT PDIRENT EaDirent,
    IN USHORT EaHandle,
    IN POEM_STRING Filename
    );

VOID
FatAddEaSet (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG EaSetLength,
    IN PBCB EaBcb,
    OUT PDIRENT EaDirent,
    OUT PUSHORT EaHandle,
    OUT PEA_RANGE EaSetRange
    );

VOID
FatDeletePackedEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_SET_HEADER EaSetHeader,
    IN OUT PULONG PackedEasLength,
    IN ULONG Offset
    );

VOID
FatAppendPackedEa (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_SET_HEADER *EaSetHeader,
    IN OUT PULONG PackedEasLength,
    IN OUT PULONG AllocationLength,
    IN PFILE_FULL_EA_INFORMATION FullEa,
    IN ULONG BytesPerCluster
    );

ULONG
FatLocateNextEa (
    IN PIRP_CONTEXT IrpContext,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    IN ULONG PreviousOffset
    );

BOOLEAN
FatLocateEaByName (
    IN PIRP_CONTEXT IrpContext,
    IN PPACKED_EA FirstPackedEa,
    IN ULONG PackedEasLength,
    IN POEM_STRING EaName,
    OUT PULONG Offset
    );

BOOLEAN
FatIsEaNameValid (
    IN PIRP_CONTEXT IrpContext,
    IN OEM_STRING Name
    );

VOID
FatPinEaRange (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT VirtualEaFile,
    IN PFCB EaFcb,
    IN OUT PEA_RANGE EaRange,
    IN ULONG StartingVbo,
    IN ULONG Length,
    IN NTSTATUS ErrorStatus
    );

VOID
FatMarkEaRangeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT EaFileObject,
    IN OUT PEA_RANGE EaRange
    );

VOID
FatUnpinEaRange (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PEA_RANGE EaRange
    );

//
//  The following macro computes the size of a full ea (not including
//  padding to bring it to a longword.  A full ea has a 4 byte offset,
//  folowed by 1 byte flag, 1 byte name length, 2 bytes value length,
//  the name, 1 null byte, and the value.
//
//      ULONG
//      SizeOfFullEa (
//          IN PFILE_FULL_EA_INFORMATION FullEa
//          );
//

#define SizeOfFullEa(EA) (4+1+1+2+(EA)->EaNameLength+1+(EA)->EaValueLength)


//
//  The following routines are used to manipulate the fscontext fields
//  of the file object, implemented in FilObSup.c
//

typedef enum _TYPE_OF_OPEN {

    UnopenedFileObject = 1,
    UserFileOpen,
    UserDirectoryOpen,
    UserVolumeOpen,
    VirtualVolumeFile,
    DirectoryFile,
    EaFile

} TYPE_OF_OPEN;

typedef enum _FAT_FLUSH_TYPE {
    
    NoFlush = 0,
    Flush,
    FlushAndInvalidate,
    FlushWithoutPurge

} FAT_FLUSH_TYPE;

VOID
FatSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PVOID VcbOrFcbOrDcb,
    IN PCCB Ccb OPTIONAL
    );

TYPE_OF_OPEN
FatDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVCB *Vcb,
    OUT PFCB *FcbOrDcb,
    OUT PCCB *Ccb
    );

VOID
FatPurgeReferencedFileObjects (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN FAT_FLUSH_TYPE FlushType
    );

VOID
FatForceCacheMiss (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN FAT_FLUSH_TYPE FlushType
    );


//
//  File system control routines, implemented in FsCtrl.c
//

VOID
FatFlushAndCleanVolume(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN FAT_FLUSH_TYPE FlushType
    );

BOOLEAN
FatIsBootSectorFat (
    IN PPACKED_BOOT_SECTOR BootSector
    );

NTSTATUS
FatLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    );

NTSTATUS
FatUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    );


//
//  Name support routines, implemented in NameSup.c
//

//
//  VOID
//  FatDissectName (
//      IN PIRP_CONTEXT IrpContext,
//      IN OEM_STRING InputString,
//      OUT POEM_STRING FirstPart,
//      OUT POEM_STRING RemainingPart
//      )
//
//  /*++
//
//  Routine Description:
//
//      This routine takes an input string and dissects it into two substrings.
//      The first output string contains the name that appears at the beginning
//      of the input string, the second output string contains the remainder of
//      the input string.
//
//      In the input string backslashes are used to separate names.  The input
//      string must not start with a backslash.  Both output strings will not
//      begin with a backslash.
//
//      If the input string does not contain any names then both output strings
//      are empty.  If the input string contains only one name then the first
//      output string contains the name and the second string is empty.
//
//      Note that both output strings use the same string buffer memory of the
//      input string.
//
//      Example of its results are:
//
//  //. .     InputString    FirstPart    RemainingPart
//  //
//  //. .     empty          empty        empty
//  //
//  //. .     A              A            empty
//  //
//  //. .     A\B\C\D\E      A            B\C\D\E
//  //
//  //. .     *A?            *A?          empty
//  //
//  //. .     \A             A            empty
//  //
//  //. .     A[,]           A[,]         empty
//  //
//  //. .     A\\B+;\C       A            \B+;\C
//
//  Arguments:
//
//      InputString - Supplies the input string being dissected
//
//      FirstPart - Receives the first name in the input string
//
//      RemainingPart - Receives the remaining part of the input string
//
//  Return Value:
//
//      BOOLEAN - TRUE if the input string is well formed and its first part
//          does not contain any illegal characters, and FALSE otherwise.
//
//  --*/
//

#define FatDissectName(IRPCONTEXT,INPUT_STRING,FIRST_PART,REMAINING_PART) { \
    FsRtlDissectDbcs( (INPUT_STRING),                                       \
                      (FIRST_PART),                                         \
                      (REMAINING_PART) );                                   \
}

//
//  BOOLEAN
//  FatDoesNameContainWildCards (
//      IN PIRP_CONTEXT IrpContext,
//      IN OEM_STRING Name
//      )
//
//  /*++
//
//  Routine Description:
//
//      This routine checks if the input name contains any wild card characters.
//
//  Arguments:
//
//      Name - Supplies the name to examine
//
//  Return Value:
//
//      BOOLEAN - TRUE if the input name contains any wildcard characters and
//          FALSE otherwise.
//
//  --*/
//

#define FatDoesNameContainWildCards(IRPCONTEXT,NAME) ( \
    FsRtlDoesDbcsContainWildCards( &(NAME) )           \
)

//
//  BOOLEAN
//  FatAreNamesEqual (
//      IN PIRP_CONTEXT IrpContext,
//      IN OEM_STRING ConstantNameA,
//      IN OEM_STRING ConstantNameB
//      )
//
//  /*++
//
//  Routine Description:
//
//      This routine simple returns whether the two names are exactly equal.
//      If the two names are known to be constant, this routine is much
//      faster than FatIsDbcsInExpression.
//
//  Arguments:
//
//      ConstantNameA - Constant name.
//
//      ConstantNameB - Constant name.
//
//  Return Value:
//
//      BOOLEAN - TRUE if the two names are lexically equal.
//

#define FatAreNamesEqual(IRPCONTEXT,NAMEA,NAMEB) (      \
    ((ULONG)(NAMEA).Length == (ULONG)(NAMEB).Length) && \
    (RtlEqualMemory( &(NAMEA).Buffer[0],                \
                     &(NAMEB).Buffer[0],                \
                     (NAMEA).Length ))                  \
)

//
//  BOOLEAN
//  FatIsNameShortOemValid (
//      IN PIRP_CONTEXT IrpContext,
//      IN OEM_STRING Name,
//      IN BOOLEAN CanContainWildCards,
//      IN BOOLEAN PathNamePermissible,
//      IN BOOLEAN LeadingBackslashPermissible
//      )
//
//  /*++
//
//  Routine Description:
//
//      This routine scans the input name and verifies that if only
//      contains valid characters
//
//  Arguments:
//
//      Name - Supplies the input name to check.
//
//      CanContainWildCards - Indicates if the name can contain wild cards
//          (i.e., * and ?).
//
//  Return Value:
//
//          BOOLEAN - Returns TRUE if the name is valid and FALSE otherwise.
//
//  --*/
//
//  The FatIsNameLongOemValid and FatIsNameLongUnicodeValid are similar.
//

#define FatIsNameShortOemValid(IRPCONTEXT,NAME,CAN_CONTAIN_WILD_CARDS,PATH_NAME_OK,LEADING_BACKSLASH_OK) ( \
    FsRtlIsFatDbcsLegal((NAME),                   \
                        (CAN_CONTAIN_WILD_CARDS), \
                        (PATH_NAME_OK),           \
                        (LEADING_BACKSLASH_OK))    \
)

#define FatIsNameLongOemValid(IRPCONTEXT,NAME,CAN_CONTAIN_WILD_CARDS,PATH_NAME_OK,LEADING_BACKSLASH_OK) ( \
    FsRtlIsHpfsDbcsLegal((NAME),                   \
                        (CAN_CONTAIN_WILD_CARDS), \
                        (PATH_NAME_OK),           \
                        (LEADING_BACKSLASH_OK))    \
)

INLINE
BOOLEAN
FatIsNameLongUnicodeValid (
    PIRP_CONTEXT IrpContext,
    PUNICODE_STRING Name,
    BOOLEAN CanContainWildcards,
    BOOLEAN PathNameOk,
    BOOLEAN LeadingBackslashOk
    )
{
    ULONG i;

    //
    //  I'm not bothering to do the whole thing, just enough to make this call look
    //  the same as the others.
    //

    ASSERT( !PathNameOk && !LeadingBackslashOk );

    for (i=0; i < Name->Length/sizeof(WCHAR); i++) {

        if ((Name->Buffer[i] < 0x80) &&
            !(FsRtlIsAnsiCharacterLegalHpfs(Name->Buffer[i], CanContainWildcards))) {

            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
FatIsNameInExpression (
    IN PIRP_CONTEXT IrpContext,
    IN OEM_STRING Expression,
    IN OEM_STRING Name
    );

VOID
FatStringTo8dot3 (
    IN PIRP_CONTEXT IrpContext,
    IN OEM_STRING InputString,
    OUT PFAT8DOT3 Output8dot3
    );

VOID
Fat8dot3ToString (
    IN PIRP_CONTEXT IrpContext,
    IN PDIRENT Dirent,
    IN BOOLEAN RestoreCase,
    OUT POEM_STRING OutputString
    );

VOID
FatGetUnicodeNameFromFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PUNICODE_STRING Lfn
    );

VOID
FatSetFullFileNameInFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
FatSetFullNameInFcb(
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING FinalName
    );

VOID
FatUnicodeToUpcaseOem (
    IN PIRP_CONTEXT IrpContext,
    IN POEM_STRING OemString,
    IN PUNICODE_STRING UnicodeString
    );

VOID
FatSelectNames (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Parent,
    IN POEM_STRING OemName,
    IN PUNICODE_STRING UnicodeName,
    IN OUT POEM_STRING ShortName,
    IN PUNICODE_STRING SuggestedShortName OPTIONAL,
    IN OUT BOOLEAN *AllLowerComponent,
    IN OUT BOOLEAN *AllLowerExtension,
    IN OUT BOOLEAN *CreateLfn
    );

VOID
FatEvaluateNameCase (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name,
    IN OUT BOOLEAN *AllLowerComponent,
    IN OUT BOOLEAN *AllLowerExtension,
    IN OUT BOOLEAN *CreateLfn
    );

BOOLEAN
FatSpaceInName (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING UnicodeName
    );


//
//  Resources support routines/macros, implemented in ResrcSup.c
//
//  The following routines/macros are used for gaining shared and exclusive
//  access to the global/vcb data structures.  The routines are implemented
//  in ResrcSup.c.  There is a global resources that everyone tries to take
//  out shared to do their work, with the exception of mount/dismount which
//  take out the global resource exclusive.  All other resources only work
//  on their individual item.  For example, an Fcb resource does not take out
//  a Vcb resource.  But the way the file system is structured we know
//  that when we are processing an Fcb other threads cannot be trying to remove
//  or alter the Fcb, so we do not need to acquire the Vcb.
//
//  The procedures/macros are:
//
//          Macro          FatData    Vcb        Fcb         Subsequent macros
//
//  AcquireExclusiveGlobal Read/Write None       None        ReleaseGlobal
//
//  AcquireSharedGlobal    Read       None       None        ReleaseGlobal
//
//  AcquireExclusiveVcb    Read       Read/Write None        ReleaseVcb
//
//  AcquireSharedVcb       Read       Read       None        ReleaseVcb
//
//  AcquireExclusiveFcb    Read       None       Read/Write  ConvertToSharFcb
//                                                           ReleaseFcb
//
//  AcquireSharedFcb       Read       None       Read        ReleaseFcb
//
//  ConvertToSharedFcb     Read       None       Read        ReleaseFcb
//
//  ReleaseGlobal
//
//  ReleaseVcb
//
//  ReleaseFcb
//

//
//  FINISHED
//  FatAcquireExclusiveGlobal (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  FINISHED
//  FatAcquireSharedGlobal (
//      IN PIRP_CONTEXT IrpContext
//      );
//

#define FatAcquireExclusiveGlobal(IRPCONTEXT) (                                                                \
    ExAcquireResourceExclusiveLite( &FatData.Resource, BooleanFlagOn((IRPCONTEXT)->Flags, IRP_CONTEXT_FLAG_WAIT) ) \
)

#define FatAcquireSharedGlobal(IRPCONTEXT) (                                                                \
    ExAcquireResourceSharedLite( &FatData.Resource, BooleanFlagOn((IRPCONTEXT)->Flags, IRP_CONTEXT_FLAG_WAIT) ) \
)

//
//  The following macro must only be called when Wait is TRUE!
//
//  FatAcquireExclusiveVolume (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  FatReleaseVolume (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//

#define FatAcquireExclusiveVolume(IRPCONTEXT,VCB) {                                     \
    PFCB Fcb = NULL;                                                                    \
    ASSERT(FlagOn((IRPCONTEXT)->Flags, IRP_CONTEXT_FLAG_WAIT));                         \
    (VOID)FatAcquireExclusiveVcb( (IRPCONTEXT), (VCB) );                                \
    while ( (Fcb = FatGetNextFcbBottomUp((IRPCONTEXT), Fcb, (VCB)->RootDcb)) != NULL) { \
        (VOID)FatAcquireExclusiveFcb((IRPCONTEXT), Fcb );                               \
    }                                                                                   \
}

#define FatReleaseVolume(IRPCONTEXT,VCB) {                                              \
    PFCB Fcb = NULL;                                                                    \
    ASSERT(FlagOn((IRPCONTEXT)->Flags, IRP_CONTEXT_FLAG_WAIT));                         \
    while ( (Fcb = FatGetNextFcbBottomUp((IRPCONTEXT), Fcb, (VCB)->RootDcb)) != NULL) { \
        (VOID)ExReleaseResourceLite( Fcb->Header.Resource );                                \
    }                                                                                   \
    FatReleaseVcb((IRPCONTEXT), (VCB));                                                 \
}

//
//  These macros can be used to determine what kind of FAT we have for an
//  initialized Vcb.  It is somewhat more elegant to use these (visually).
//

#define FatIsFat32(VCB) ((BOOLEAN)((VCB)->AllocationSupport.FatIndexBitSize == 32))
#define FatIsFat16(VCB) ((BOOLEAN)((VCB)->AllocationSupport.FatIndexBitSize == 16))
#define FatIsFat12(VCB) ((BOOLEAN)((VCB)->AllocationSupport.FatIndexBitSize == 12))

FINISHED
FatAcquireExclusiveVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

FINISHED
FatAcquireSharedVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

FINISHED
FatAcquireExclusiveFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

FINISHED
FatAcquireSharedFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

FINISHED
FatAcquireSharedFcbWaitForEx (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

#define FatVcbAcquiredExclusive(IRPCONTEXT,VCB) (                   \
    ExIsResourceAcquiredExclusiveLite(&(VCB)->Resource)  ||             \
    ExIsResourceAcquiredExclusiveLite(&FatData.Resource)                \
)

#define FatFcbAcquiredShared(IRPCONTEXT,FCB) (                      \
    ExIsResourceAcquiredSharedLite((FCB)->Header.Resource)              \
)

#define FatAcquireDirectoryFileMutex(VCB) {                         \
    ASSERT(KeAreApcsDisabled());                                    \
    ExAcquireFastMutexUnsafe(&(VCB)->DirectoryFileCreationMutex);   \
}

#define FatReleaseDirectoryFileMutex(VCB) {                         \
    ASSERT(KeAreApcsDisabled());                                    \
    ExReleaseFastMutexUnsafe(&(VCB)->DirectoryFileCreationMutex);   \
}

//
//  The following are cache manager call backs

BOOLEAN
FatAcquireVolumeForClose (
    IN PVOID Vcb,
    IN BOOLEAN Wait
    );

VOID
FatReleaseVolumeFromClose (
    IN PVOID Vcb
    );

BOOLEAN
FatAcquireFcbForLazyWrite (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
FatReleaseFcbFromLazyWrite (
    IN PVOID Null
    );

BOOLEAN
FatAcquireFcbForReadAhead (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
FatReleaseFcbFromReadAhead (
    IN PVOID Null
    );

NTSTATUS
FatAcquireForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FatReleaseForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
FatNoOpAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
FatNoOpRelease (
    IN PVOID Fcb
    );

//
//  VOID
//  FatConvertToSharedFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//

#define FatConvertToSharedFcb(IRPCONTEXT,Fcb) {             \
    ExConvertExclusiveToSharedLite( (Fcb)->Header.Resource );   \
    }

//
//  VOID
//  FatReleaseGlobal (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  FatReleaseVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  FatReleaseFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//

#define FatDeleteResource(RESRC) {                  \
    ExDeleteResourceLite( (RESRC) );                    \
}

#define FatReleaseGlobal(IRPCONTEXT) {              \
    ExReleaseResourceLite( &(FatData.Resource) );       \
    }

#define FatReleaseVcb(IRPCONTEXT,Vcb) {             \
    ExReleaseResourceLite( &((Vcb)->Resource) );        \
    }

#define FatReleaseFcb(IRPCONTEXT,Fcb) {             \
    ExReleaseResourceLite( (Fcb)->Header.Resource );    \
    }


//
//  In-memory structure support routine, implemented in StrucSup.c
//

VOID
FatInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PDEVICE_OBJECT FsDeviceObject
    );
VOID
FatDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
FatCreateRootDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

PFCB
FatCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN ULONG LfnOffsetWithinDirectory,
    IN ULONG DirentOffsetWithinDirectory,
    IN PDIRENT Dirent,
    IN PUNICODE_STRING Lfn OPTIONAL,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN SingleResource
    );

PDCB
FatCreateDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN ULONG LfnOffsetWithinDirectory,
    IN ULONG DirentOffsetWithinDirectory,
    IN PDIRENT Dirent,
    IN PUNICODE_STRING Lfn OPTIONAL
    );

VOID
FatDeleteFcb_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

#ifdef FASTFATDBG
#define FatDeleteFcb(IRPCONTEXT,FCB) {     \
    FatDeleteFcb_Real((IRPCONTEXT),(FCB)); \
    (FCB) = NULL;                          \
}
#else
#define FatDeleteFcb(IRPCONTEXT,VCB) {     \
    FatDeleteFcb_Real((IRPCONTEXT),(VCB)); \
}
#endif // FASTFAT_DBG

PCCB
FatCreateCcb (
    IN PIRP_CONTEXT IrpContext
    );
    
VOID
FatDeallocateCcbStrings(
        IN PCCB Ccb
        );
        
VOID
FatDeleteCcb_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    );

#ifdef FASTFATDBG
#define FatDeleteCcb(IRPCONTEXT,CCB) {     \
    FatDeleteCcb_Real((IRPCONTEXT),(CCB)); \
    (CCB) = NULL;                          \
}
#else
#define FatDeleteCcb(IRPCONTEXT,VCB) {     \
    FatDeleteCcb_Real((IRPCONTEXT),(VCB)); \
}
#endif // FASTFAT_DBG

PIRP_CONTEXT
FatCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

VOID
FatDeleteIrpContext_Real (
    IN PIRP_CONTEXT IrpContext
    );

#ifdef FASTFATDBG
#define FatDeleteIrpContext(IRPCONTEXT) {   \
    FatDeleteIrpContext_Real((IRPCONTEXT)); \
    (IRPCONTEXT) = NULL;                    \
}
#else
#define FatDeleteIrpContext(IRPCONTEXT) {   \
    FatDeleteIrpContext_Real((IRPCONTEXT)); \
}
#endif // FASTFAT_DBG

PFCB
FatGetNextFcbTopDown (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB TerminationFcb
    );

PFCB
FatGetNextFcbBottomUp (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB TerminationFcb
    );

//
//  These two macros just make the code a bit cleaner.
//

#define FatGetFirstChild(DIR) ((PFCB)(                          \
    IsListEmpty(&(DIR)->Specific.Dcb.ParentDcbQueue) ? NULL :   \
    CONTAINING_RECORD((DIR)->Specific.Dcb.ParentDcbQueue.Flink, \
                      DCB,                                      \
                      ParentDcbLinks.Flink)))

#define FatGetNextSibling(FILE) ((PFCB)(                     \
    &(FILE)->ParentDcb->Specific.Dcb.ParentDcbQueue.Flink == \
    (PVOID)(FILE)->ParentDcbLinks.Flink ? NULL :             \
    CONTAINING_RECORD((FILE)->ParentDcbLinks.Flink,          \
                      FCB,                                   \
                      ParentDcbLinks.Flink)))

BOOLEAN
FatCheckForDismount (
    IN PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    IN BOOLEAN Force
    );

VOID
FatConstructNamesInFcb (
    IN PIRP_CONTEXT IrpContext,
    PFCB Fcb,
    PDIRENT Dirent,
    PUNICODE_STRING Lfn OPTIONAL
    );

VOID
FatCheckFreeDirentBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    );

ULONG
FatVolumeUncleanCount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
FatPreallocateCloseContext (
    );

//  VOID
//  FatAllocateCloseContext (
//     )
//
//    This routine allocates a close context, presumeably on behalf
//    of a fileobject which does not have a structure we can embed one
//    in.
    
#define FatAllocateCloseContext() (PCLOSE_CONTEXT)                                       \
                                  ExInterlockedPopEntrySList( &FatCloseContextSList,     \
                                                              &FatData.GeneralSpinLock )
                                

//
//  BOOLEAN
//  FatIsRawDevice (
//      IN PIRP_CONTEXT IrpContext,
//      IN NTSTATUS Status
//      );
//

#define FatIsRawDevice(IC,S) (          \
    ((S) == STATUS_DEVICE_NOT_READY) || \
    ((S) == STATUS_NO_MEDIA_IN_DEVICE)  \
)


//
//  Routines to support managing file names Fcbs and Dcbs.
//  Implemented in SplaySup.c
//

VOID
FatInsertName (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PFILE_NAME_NODE Name
    );

VOID
FatRemoveNames (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

PFCB
FatFindFcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PRTL_SPLAY_LINKS *RootNode,
    IN PSTRING Name,
    OUT PBOOLEAN FileNameDos OPTIONAL
    );

BOOLEAN
FatIsHandleCountZero (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

//
//  Time conversion support routines, implemented in TimeSup.c
//

BOOLEAN
FatNtTimeToFatTime (
    IN PIRP_CONTEXT IrpContext,
    IN PLARGE_INTEGER NtTime,
    IN BOOLEAN Rounding,
    OUT PFAT_TIME_STAMP FatTime,
    OUT OPTIONAL PCHAR TenMsecs
    );

LARGE_INTEGER
FatFatTimeToNtTime (
    IN PIRP_CONTEXT IrpContext,
    IN FAT_TIME_STAMP FatTime,
    IN UCHAR TenMilliSeconds
    );

LARGE_INTEGER
FatFatDateToNtTime (
    IN PIRP_CONTEXT IrpContext,
    IN FAT_DATE FatDate
    );

FAT_TIME_STAMP
FatGetCurrentFatTime (
    IN PIRP_CONTEXT IrpContext
    );


//
//  Low level verification routines, implemented in VerfySup.c
//
//  The first routine is called to help process a verify IRP.  Its job is
//  to walk every Fcb/Dcb and mark them as need to be verified.
//
//  The other routines are used by every dispatch routine to verify that
//  an Vcb/Fcb/Dcb is still good.  The routine walks as much of the opened
//  file/directory tree as necessary to make sure that the path is still valid.
//  The function result indicates if the procedure needed to block for I/O.
//  If the structure is bad the procedure raise the error condition
//  STATUS_FILE_INVALID, otherwise they simply return to their caller
//

typedef enum _FAT_VOLUME_STATE {
    VolumeClean,
    VolumeDirty,
    VolumeDirtyWithSurfaceTest
} FAT_VOLUME_STATE, *PFAT_VOLUME_STATE;

VOID
FatMarkFcbCondition (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN FCB_CONDITION FcbCondition,
    IN BOOLEAN Recursive
    );

VOID
FatVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
FatVerifyFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
FatCleanVolumeDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
FatMarkVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FAT_VOLUME_STATE VolumeState
    );

VOID
FatFspMarkVolumeDirtyWithRecover (
    PVOID Parameter
    );

VOID
FatCheckDirtyBit (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
FatQuickVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

VOID
FatVerifyOperationIsLegal (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
FatPerformVerify (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT Device
    );


//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

VOID
FatOplockComplete (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
FatPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
FatAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatFsdPostRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

//
//  Miscellaneous support routines
//

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise.  It is followed by two macros for setting and clearing
//  flags
//

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)((((Flags) & (SingleFlag)) != 0)))
//#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) { \
//    (Flags) |= (SingleFlag);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) { \
//    (Flags) &= ~(SingleFlag);         \
//}
//#endif

//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define PtrOffset(BASE,OFFSET) ((ULONG)((ULONG_PTR)(OFFSET) - (ULONG_PTR)(BASE)))

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

#define CopyU4char(Dst,Src) {                                \
    *((UNALIGNED UCHAR4 *)(Dst)) = *((UCHAR4 *)(Src)); \
    }

//
//  VOID
//  FatNotifyReportChange (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN ULONG Filter,
//      IN ULONG Action
//      );
//

#define FatNotifyReportChange(I,V,F,FL,A) {                                                         \
    if ((F)->FullFileName.Buffer == NULL) {                                                         \
        FatSetFullFileNameInFcb((I),(F));                                                           \
    }                                                                                               \
    ASSERT( (F)->FullFileName.Length != 0 );                                                        \
    ASSERT( (F)->FinalNameLength != 0 );                                                            \
    ASSERT( (F)->FullFileName.Length > (F)->FinalNameLength );                                      \
    ASSERT( (F)->FullFileName.Buffer[((F)->FullFileName.Length - (F)->FinalNameLength)/sizeof(WCHAR) - 1] == L'\\' ); \
    FsRtlNotifyFullReportChange( (V)->NotifySync,                                                   \
                                 &(V)->DirNotifyList,                                               \
                                 (PSTRING)&(F)->FullFileName,                                       \
                                 (USHORT) ((F)->FullFileName.Length -                               \
                                           (F)->FinalNameLength),                                   \
                                 (PSTRING)NULL,                                                     \
                                 (PSTRING)NULL,                                                     \
                                 (ULONG)FL,                                                         \
                                 (ULONG)A,                                                          \
                                 (PVOID)NULL );                                                     \
}


//
//  The FSD Level dispatch routines.   These routines are called by the
//  I/O system via the dispatch table in the Driver Object.
//
//  They each accept as input a pointer to a device object (actually most
//  expect a volume device object, with the exception of the file system
//  control function which can also take a file system device object), and
//  a pointer to the IRP.  They either perform the function at the FSD level
//  or post the request to the FSP work queue for FSP level processing.
//

NTSTATUS
FatFsdCleanup (                         //  implemented in Cleanup.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdClose (                           //  implemented in Close.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdCreate (                          //  implemented in Create.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdDeviceControl (                   //  implemented in DevCtrl.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdDirectoryControl (                //  implemented in DirCtrl.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdQueryEa (                         //  implemented in Ea.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdSetEa (                           //  implemented in Ea.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdQueryInformation (                //  implemented in FileInfo.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdSetInformation (                  //  implemented in FileInfo.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdFlushBuffers (                    //  implemented in Flush.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdFileSystemControl (               //  implemented in FsCtrl.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdLockControl (                     //  implemented in LockCtrl.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdPnp (                            //  implemented in Pnp.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdRead (                            //  implemented in Read.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdShutdown (                        //  implemented in Shutdown.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdQueryVolumeInformation (          //  implemented in VolInfo.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdSetVolumeInformation (            //  implemented in VolInfo.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatFsdWrite (                           //  implemented in Write.c
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(IRP) IoIsOperationSynchronous(Irp)


//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRP's off of the work queue and calls the appropriate FSP level
//  work routine.
//

VOID
FatFspDispatch (                        //  implemented in FspDisp.c
    IN PVOID Context
    );

//
//  The following routines are the FSP work routines that are called
//  by the preceding FatFspDispath routine.  Each takes as input a pointer
//  to the IRP, perform the function, and return a pointer to the volume
//  device object that they just finished servicing (if any).  The return
//  pointer is then used by the main Fsp dispatch routine to check for
//  additional IRPs in the volume's overflow queue.
//
//  Each of the following routines is also responsible for completing the IRP.
//  We moved this responsibility from the main loop to the individual routines
//  to allow them the ability to complete the IRP and continue post processing
//  actions.
//

NTSTATUS
FatCommonCleanup (                      //  implemented in Cleanup.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonClose (                        //  implemented in Close.c
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN Wait,
    IN PVOLUME_DEVICE_OBJECT *VolDo OPTIONAL
    );

VOID
FatFspClose (                           //  implemented in Close.c
    IN PVCB Vcb OPTIONAL
    );

NTSTATUS
FatCommonCreate (                       //  implemented in Create.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonDirectoryControl (             //  implemented in DirCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonDeviceControl (                //  implemented in DevCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonQueryEa (                      //  implemented in Ea.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonSetEa (                        //  implemented in Ea.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonQueryInformation (             //  implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonSetInformation (               //  implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonFlushBuffers (                 //  implemented in Flush.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonFileSystemControl (            //  implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonLockControl (                  //  implemented in LockCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonPnp (                          //  implemented in Pnp.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonRead (                         //  implemented in Read.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonShutdown (                     //  implemented in Shutdown.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonQueryVolumeInfo (              //  implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonSetVolumeInfo (                //  implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatCommonWrite (                        //  implemented in Write.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

//
//  The following is implemented in Flush.c, and does what is says.
//

NTSTATUS
FatFlushFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN FAT_FLUSH_TYPE FlushType
    );

NTSTATUS
FatFlushDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN FAT_FLUSH_TYPE FlushType
    );

NTSTATUS
FatFlushFat (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

NTSTATUS
FatFlushVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FAT_FLUSH_TYPE FlushType
    );

NTSTATUS
FatHijackIrpAndFlushDevice (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetDeviceObject
    );

VOID
FatFlushFatEntries (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Cluster,
    IN ULONG Count
);

VOID
FatFlushDirentForFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
);



//
//  The following procedure is used by the FSP and FSD routines to complete
//  an IRP.
//
//  Note that this macro allows either the Irp or the IrpContext to be
//  null, however the only legal order to do this in is:
//
//      FatCompleteRequest( NULL, Irp, Status );  // completes Irp & preserves context
//      ...
//      FatCompleteRequest( IrpContext, NULL, DontCare ); // deallocates context
//
//  This would typically be done in order to pass a "naked" IrpContext off to
//  the Fsp for post processing, such as read ahead.
//

VOID
FatCompleteRequest_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN NTSTATUS Status
    );

#define FatCompleteRequest(IRPCONTEXT,IRP,STATUS) { \
    FatCompleteRequest_Real(IRPCONTEXT,IRP,STATUS); \
}

BOOLEAN
FatIsIrpTopLevel (
    IN PIRP Irp
    );

//
//  The Following routine makes a popup
//

VOID
FatPopUpFileCorrupt (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

//
//  Here are the callbacks used by the I/O system for checking for fast I/O or
//  doing a fast query info call, or doing fast lock calls.
//

BOOLEAN
FatFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
FatFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
FatFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
FatFastQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
FatFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
FatFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
FatFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
FatFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );


VOID
FatExamineFatEntries(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartIndex OPTIONAL,
    IN ULONG EndIndex OPTIONAL,
    IN BOOLEAN SetupWindows,
    IN PFAT_WINDOW SwitchToWindow OPTIONAL,
    IN PULONG BitMapBuffer OPTIONAL
    );

BOOLEAN
FatScanForDataTrack(
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject
    );

//
//  The following macro is used to determine is a file has been deleted.
//
//      BOOLEAN
//      IsFileDeleted (
//          IN PIRP_CONTEXT IrpContext,
//          IN PFCB Fcb
//          );
//

#define IsFileDeleted(IRPCONTEXT,FCB)                      \
    (FlagOn((FCB)->FcbState, FCB_STATE_DELETE_ON_CLOSE) && \
     ((FCB)->UncleanCount == 0))

//
//  The following macro is used by the dispatch routines to determine if
//  an operation is to be done with or without Write Through.
//
//      BOOLEAN
//      IsFileWriteThrough (
//          IN PFILE_OBJECT FileObject,
//          IN PVCB Vcb
//          );
//

#define IsFileWriteThrough(FO,VCB) (             \
    BooleanFlagOn((FO)->Flags, FO_WRITE_THROUGH) \
)

//
//  The following macro is used to set the is fast i/o possible field in
//  the common part of the nonpaged fcb
//
//
//      BOOLEAN
//      FatIsFastIoPossible (
//          IN PFCB Fcb
//          );
//

#define FatIsFastIoPossible(FCB) ((BOOLEAN)                                                            \
    (((FCB)->FcbCondition != FcbGood || !FsRtlOplockIsFastIoPossible( &(FCB)->Specific.Fcb.Oplock )) ? \
        FastIoIsNotPossible                                                                            \
    :                                                                                                  \
        (!FsRtlAreThereCurrentFileLocks( &(FCB)->Specific.Fcb.FileLock ) &&                            \
         ((FCB)->NonPaged->OutstandingAsyncWrites == 0) &&                                               \
         !FlagOn( (FCB)->Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED ) ?                             \
            FastIoIsPossible                                                                           \
        :                                                                                              \
            FastIoIsQuestionable                                                                       \
        )                                                                                              \
    )                                                                                                  \
)

//
//  The following macro is used to detemine if the file object is opened
//  for read only access (i.e., it is not also opened for write access or
//  delete access).
//
//      BOOLEAN
//      IsFileObjectReadOnly (
//          IN PFILE_OBJECT FileObject
//          );
//

#define IsFileObjectReadOnly(FO) (!((FO)->WriteAccess | (FO)->DeleteAccess))


//
//  The following two macro are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in the
//  Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as STATUS_FILE_INVALID (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  FatFsdXxx(...)
//  {
//      try {
//
//          ...
//
//      } except(FatExceptionFilter( IrpContext, GetExceptionCode() )) {
//
//          Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
//      }
//
//      Return Status;
//  }
//
//  To explicitly raise an exception that we expect, such as
//  STATUS_FILE_INVALID, use the below macro FatRaiseStatus().  To raise a
//  status from an unknown origin (such as CcFlushCache()), use the macro
//  FatNormalizeAndRaiseStatus.  This will raise the status if it is expected,
//  or raise STATUS_UNEXPECTED_IO_ERROR if it is not.
//
//  If we are vicariously handling exceptions without using FatProcessException(),
//  if there is the possibility that we raised that exception, one *must*
//  reset the IrpContext so a subsequent raise in the course of handling this
//  request that is *not* explicit, i.e. like a pagein error, does not get
//  spoofed into believing that the first raise status is the reason the second
//  occured.  This could have really nasty consequences.
//
//  It is an excellent idea to always FatResetExceptionState in these cases.
//
//  Note that when using these two macros, the original status is placed in
//  IrpContext->ExceptionStatus, signaling FatExceptionFilter and
//  FatProcessException that the status we actually raise is by definition
//  expected.
//

ULONG
FatExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

#if DBG
ULONG
FatBugCheckExceptionFilter (
    IN PEXCEPTION_POINTERS ExceptionPointer
    );
#endif

NTSTATUS
FatProcessException (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    );

//
//  VOID
//  FatRaiseStatus (
//      IN PRIP_CONTEXT IrpContext,
//      IN NT_STATUS Status
//  );
//
//

#if DBG
#define DebugBreakOnStatus(S) {                                                      \
    if (FatTestRaisedStatus) {                                                       \
        if ((S) == STATUS_DISK_CORRUPT_ERROR || (S) == STATUS_FILE_CORRUPT_ERROR) {  \
            DbgPrint( "FAT: Breaking on interesting raised status (%08x)\n", (S) );  \
            DbgPrint( "FAT: Set FatTestRaisedStatus @ %08x to 0 to disable\n",       \
                      &FatTestRaisedStatus );                                        \
            DbgBreakPoint();                                                         \
        }                                                                            \
    }                                                                                \
}
#else
#define DebugBreakOnStatus(S)
#endif

#define FatRaiseStatus(IRPCONTEXT,STATUS) {             \
    (IRPCONTEXT)->ExceptionStatus = (STATUS);           \
    DebugBreakOnStatus( (STATUS) )                      \
    ExRaiseStatus( (STATUS) );                          \
}
    
#define FatResetExceptionState( IRPCONTEXT ) {          \
    (IRPCONTEXT)->ExceptionStatus = STATUS_SUCCESS;     \
}

//
//  VOID
//  FatNormalAndRaiseStatus (
//      IN PRIP_CONTEXT IrpContext,
//      IN NT_STATUS Status
//  );
//

#define FatNormalizeAndRaiseStatus(IRPCONTEXT,STATUS) {                         \
    (IRPCONTEXT)->ExceptionStatus = (STATUS);                                   \
    ExRaiseStatus(FsRtlNormalizeNtstatus((STATUS),STATUS_UNEXPECTED_IO_ERROR)); \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }
#define try_leave(S) { S; leave; }


CLUSTER_TYPE
FatInterpretClusterType (
    IN PVCB Vcb,
    IN FAT_ENTRY Entry
    );


//
//  These routines define the FileId for FAT.  Lacking a fixed/uniquifiable
//  notion, we simply come up with one which is unique in a given snapshot
//  of the volume.  As long as the parent directory is not moved or compacted,
//  it may even be permanent.
//

//
//  The internal information used to identify the fcb/dcb on the
//  volume is the byte offset of the dirent of the file on disc.
//  Our root always has fileid 0.  FAT32 roots are chains and can
//  use the LBO of the cluster, 12/16 roots use the lbo in the Vcb.
//

#define FatGenerateFileIdFromDirentOffset(ParentDcb,DirentOffset)                                   \
    ((ParentDcb) ? ((NodeType(ParentDcb) != FAT_NTC_ROOT_DCB || FatIsFat32((ParentDcb)->Vcb)) ?     \
                  FatGetLboFromIndex( (ParentDcb)->Vcb,                                             \
                                      (ParentDcb)->FirstClusterOfFile ) :                           \
                  (ParentDcb)->Vcb->AllocationSupport.RootDirectoryLbo) +                           \
                 (DirentOffset)                                                                     \
                  :                                                                                 \
                 0)

//
//

#define FatGenerateFileIdFromFcb(Fcb)                                                               \
        FatGenerateFileIdFromDirentOffset( (Fcb)->ParentDcb, (Fcb)->DirentOffsetWithinDirectory )

//
//  Wrap to handle the ./.. cases appropriately.  Note that we commute NULL parent to 0. This would
//  only occur in an illegal root ".." entry.
//

#define FATDOT    ((ULONG)0x2020202E)
#define FATDOTDOT ((ULONG)0x20202E2E)

#define FatGenerateFileIdFromDirentAndOffset(Dcb,Dirent,DirentOffset)                               \
    ((*((PULONG)(Dirent)->FileName)) == FATDOT ? FatGenerateFileIdFromFcb(Dcb) :                    \
     ((*((PULONG)(Dirent)->FileName)) == FATDOTDOT ? ((Dcb)->ParentDcb ?                            \
                                                       FatGenerateFileIdFromFcb((Dcb)->ParentDcb) : \
                                                       0) :                                         \
      FatGenerateFileIdFromDirentOffset(Dcb,DirentOffset)))


//
//  BOOLEAN
//  FatDeviceIsFatFsdo(
//      IN PDEVICE_OBJECT D
//      );
//
//  Evaluates to TRUE if the supplied device object is one of the file system devices
//  we created at initialisation.
//

#define FatDeviceIsFatFsdo( D)  (((D) == FatData.DiskFileSystemDeviceObject) || ((D) == FatData.CdromFileSystemDeviceObject))

#endif // _FATPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fsctrl.c ===
/*++


Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Fat called
    by the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

    Scott Quinn     [ScottQ]    05-Apr-1996     Added fat32 support.
    Mike Sliger     [MSliger]   05-Apr-1996

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_FSCTRL)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCTRL)

//
//  Local procedure prototypes
//

NTSTATUS
FatMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PDEVICE_OBJECT FsDeviceObject
    );

NTSTATUS
FatVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

BOOLEAN
FatIsMediaWriteProtected (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject
    );

NTSTATUS
FatUserFsCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatDirtyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatIsPathnameValid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatInvalidateVolumes (
    IN PIRP Irp
    );

BOOLEAN
FatPerformVerifyDiskRead (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID Buffer,
    IN LBO Lbo,
    IN ULONG NumberOfBytesToRead,
    IN BOOLEAN ReturnOnError
    );

NTSTATUS
FatQueryRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatQueryBpb (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatGetStatistics (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatAllowExtendedDasdIo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

//
//  Local support routine prototypes
//

NTSTATUS
FatGetVolumeBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatGetRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
FatMoveFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
FatComputeMoveFileSplicePoints (
    PIRP_CONTEXT IrpContext,
    PFCB FcbOrDcb,
    ULONG FileOffset,
    ULONG TargetCluster,
    ULONG BytesToReallocate,
    PULONG FirstSpliceSourceCluster,
    PULONG FirstSpliceTargetCluster,
    PULONG SecondSpliceSourceCluster,
    PULONG SecondSpliceTargetCluster,
    PLARGE_MCB SourceMcb
);

VOID
FatComputeMoveFileParameter (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN ULONG FileOffset,
    IN OUT PULONG ByteCount,
    OUT PULONG BytesToReallocate,
    OUT PULONG BytesToWrite
);

NTSTATUS
FatSearchBufferForLabel(
    IN  PIRP_CONTEXT IrpContext,
    IN  PVPB  Vpb,
    IN  PVOID Buffer,
    IN  ULONG Size,
    OUT PBOOLEAN LabelFound
);

VOID
FatVerifyLookupFatEntry (
    IN  PIRP_CONTEXT IrpContext,
    IN  PVCB Vcb,
    IN  ULONG FatIndex,
    IN OUT PULONG FatEntry
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatAddMcbEntry)
#pragma alloc_text(PAGE, FatAllowExtendedDasdIo)
#pragma alloc_text(PAGE, FatCommonFileSystemControl)
#pragma alloc_text(PAGE, FatComputeMoveFileParameter)
#pragma alloc_text(PAGE, FatComputeMoveFileSplicePoints)
#pragma alloc_text(PAGE, FatDirtyVolume)
#pragma alloc_text(PAGE, FatDismountVolume)
#pragma alloc_text(PAGE, FatFsdFileSystemControl)
#pragma alloc_text(PAGE, FatGetRetrievalPointers)
#pragma alloc_text(PAGE, FatGetStatistics)
#pragma alloc_text(PAGE, FatGetVolumeBitmap)
#pragma alloc_text(PAGE, FatIsMediaWriteProtected)
#pragma alloc_text(PAGE, FatIsPathnameValid)
#pragma alloc_text(PAGE, FatIsVolumeDirty)
#pragma alloc_text(PAGE, FatIsVolumeMounted)
#pragma alloc_text(PAGE, FatLockVolume)
#pragma alloc_text(PAGE, FatLookupLastMcbEntry)
#pragma alloc_text(PAGE, FatMountVolume)
#pragma alloc_text(PAGE, FatMoveFile)
#pragma alloc_text(PAGE, FatOplockRequest)
#pragma alloc_text(PAGE, FatPerformVerifyDiskRead)
#pragma alloc_text(PAGE, FatQueryBpb)
#pragma alloc_text(PAGE, FatQueryRetrievalPointers)
#pragma alloc_text(PAGE, FatRemoveMcbEntry)
#pragma alloc_text(PAGE, FatSearchBufferForLabel)
#pragma alloc_text(PAGE, FatUnlockVolume)
#pragma alloc_text(PAGE, FatUserFsCtrl)
#pragma alloc_text(PAGE, FatVerifyLookupFatEntry)
#pragma alloc_text(PAGE, FatVerifyVolume)
#endif

#if DBG

BOOLEAN FatMoveFileDebug = 0;

#endif

//
//  These wrappers go around the MCB package; we scale the LBO's passed
//  in (which can be bigger than 32 bits on fat32) by the volume's sector
//  size.
//
//  Note we now use the real large mcb package.  This means these shims
//  now also convert the -1 unused LBN number to the 0 of the original
//  mcb package.
//

#define     MCB_SCALE_LOG2      (Vcb->AllocationSupport.LogOfBytesPerSector)
#define     MCB_SCALE           (1 << MCB_SCALE_LOG2)
#define     MCB_SCALE_MODULO    (MCB_SCALE - 1)


BOOLEAN
FatAddMcbEntry (
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb,
    IN VBO Vbo,
    IN LBO Lbo,
    IN ULONG SectorCount
    )

{
    PAGED_CODE();

    if (SectorCount) {

        //
        //  Round up sectors, but be careful as SectorCount approaches 4Gb.
        //  Note that for x>0, (x+m-1)/m = ((x-1)/m)+(m/m) = ((x-1)/m)+1
        //

        SectorCount--;
        SectorCount >>= MCB_SCALE_LOG2;
        SectorCount++;
    }

    Vbo >>= MCB_SCALE_LOG2;
    Lbo >>= MCB_SCALE_LOG2;

    return FsRtlAddLargeMcbEntry( Mcb,
                                  ((LONGLONG) Vbo),
                                  ((LONGLONG) Lbo),
                                  ((LONGLONG) SectorCount) );
}


BOOLEAN
FatLookupMcbEntry (
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index OPTIONAL
    )
{
    BOOLEAN Results;
    LONGLONG LiLbo;
    LONGLONG LiSectorCount;
    ULONG Remainder;

    LiLbo = 0;
    LiSectorCount = 0;

    Remainder = Vbo & MCB_SCALE_MODULO;

    Results = FsRtlLookupLargeMcbEntry( Mcb,
                                        (Vbo >> MCB_SCALE_LOG2),
                                        &LiLbo,
                                        ARGUMENT_PRESENT(SectorCount) ? &LiSectorCount : NULL,
                                        NULL,
                                        NULL,
                                        Index );

    if ((ULONG) LiLbo != -1) {

        *Lbo = (((LBO) LiLbo) << MCB_SCALE_LOG2);

        if (Results) {

            *Lbo += Remainder;
        }

    } else {

        *Lbo = 0;
    }

    if (ARGUMENT_PRESENT(SectorCount)) {

        *SectorCount = (ULONG) LiSectorCount;

        if (*SectorCount) {

            *SectorCount <<= MCB_SCALE_LOG2;

            if (*SectorCount == 0) {

                *SectorCount = (ULONG) -1;
            }

            if (Results) {

                *SectorCount -= Remainder;
            }
        }

    }

    return Results;
}

//
//  NOTE: Vbo/Lbn undefined if MCB is empty & return code false.
//

BOOLEAN
FatLookupLastMcbEntry (
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb,
    OUT PVBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG Index
    )

{
    BOOLEAN Results;
    LONGLONG LiVbo;
    LONGLONG LiLbo;
    ULONG LocalIndex;

    PAGED_CODE();

    LiVbo = LiLbo = 0;
    LocalIndex = 0;

    Results = FsRtlLookupLastLargeMcbEntryAndIndex( Mcb,
                                                    &LiVbo,
                                                    &LiLbo,
                                                    &LocalIndex );

    *Vbo = ((VBO) LiVbo) << MCB_SCALE_LOG2;

    if (((ULONG) LiLbo) != -1) {

        *Lbo = ((LBO) LiLbo) << MCB_SCALE_LOG2;

        *Lbo += (MCB_SCALE - 1);
        *Vbo += (MCB_SCALE - 1);

    } else {

        *Lbo = 0;
    }

    if (Index) {
        *Index = LocalIndex;
    }

    return Results;
}


BOOLEAN
FatGetNextMcbEntry (
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb,
    IN ULONG RunIndex,
    OUT PVBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG SectorCount
    )

{
    BOOLEAN Results;
    LONGLONG LiVbo;
    LONGLONG LiLbo;
    LONGLONG LiSectorCount;

    PAGED_CODE();

    LiVbo = LiLbo = 0;

    Results = FsRtlGetNextLargeMcbEntry( Mcb,
                                         RunIndex,
                                         &LiVbo,
                                         &LiLbo,
                                         &LiSectorCount );

    if (Results) {

        *Vbo = ((VBO) LiVbo) << MCB_SCALE_LOG2;

        if (((ULONG) LiLbo) != -1) {

            *Lbo = ((LBO) LiLbo) << MCB_SCALE_LOG2;

        } else {

            *Lbo = 0;
        }

        *SectorCount = ((ULONG) LiSectorCount) << MCB_SCALE_LOG2;

        if ((*SectorCount == 0) && (LiSectorCount != 0)) {
            *SectorCount = (ULONG) -1;  /* it overflowed */
        }
    }

    return Results;
}


VOID
FatRemoveMcbEntry (
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb,
    IN VBO Vbo,
    IN ULONG SectorCount
    )
{

    if ((SectorCount) && (SectorCount != 0xFFFFFFFF)) {

        SectorCount--;
        SectorCount >>= MCB_SCALE_LOG2;
        SectorCount++;
    }

    Vbo >>= MCB_SCALE_LOG2;

#if DBG
    try {
#endif

        FsRtlRemoveLargeMcbEntry( Mcb,
                                  (LONGLONG) Vbo,
                                  (LONGLONG) SectorCount);

#if DBG
    } except(FatBugCheckExceptionFilter( GetExceptionInformation() )) {

          NOTHING;
    }
#endif

}


NTSTATUS
FatFsdFileSystemControl (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of FileSystem control operations

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    BOOLEAN Wait;
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg,"FatFsdFileSystemControl\n", 0);

    //
    //  Call the common FileSystem Control routine, with blocking allowed if
    //  synchronous.  This opeation needs to special case the mount
    //  and verify suboperations because we know they are allowed to block.
    //  We identify these suboperations by looking at the file object field
    //  and seeing if its null.
    //

    if (IoGetCurrentIrpStackLocation(Irp)->FileObject == NULL) {

        Wait = TRUE;

    } else {

        Wait = CanFsdWait( Irp );
    }

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        PIO_STACK_LOCATION IrpSp;

        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  We need to made a special check here for the InvalidateVolumes
        //  FSCTL as that comes in with a FileSystem device object instead
        //  of a volume device object.
        //

        if (FatDeviceIsFatFsdo( IrpSp->DeviceObject) &&
            (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
            (IrpSp->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
            (IrpSp->Parameters.FileSystemControl.FsControlCode ==
             FSCTL_INVALIDATE_VOLUMES)) {

            Status = FatInvalidateVolumes( Irp );

        } else {

            IrpContext = FatCreateIrpContext( Irp, Wait );

            Status = FatCommonFileSystemControl( IrpContext, Irp );
        }

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdFileSystemControl -> %08lx\n", Status);

    return Status;
}


NTSTATUS
FatCommonFileSystemControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg,"FatCommonFileSystemControl\n", 0);
    DebugTrace( 0, Dbg,"Irp           = %08lx\n", Irp);
    DebugTrace( 0, Dbg,"MinorFunction = %08lx\n", IrpSp->MinorFunction);

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_USER_FS_REQUEST:

        Status = FatUserFsCtrl( IrpContext, Irp );
        break;

    case IRP_MN_MOUNT_VOLUME:

        Status = FatMountVolume( IrpContext,
                                 IrpSp->Parameters.MountVolume.DeviceObject,
                                 IrpSp->Parameters.MountVolume.Vpb,
                                 IrpSp->DeviceObject );

        //
        //  Complete the request.
        //
        //  We do this here because FatMountVolume can be called recursively,
        //  but the Irp is only to be completed once.
        //
        //  NOTE: I don't think this is true anymore (danlo 3/15/1999).  Probably
        //  an artifact of the old doublespace attempt.
        //

        FatCompleteRequest( IrpContext, Irp, Status );
        break;

    case IRP_MN_VERIFY_VOLUME:

        Status = FatVerifyVolume( IrpContext, Irp );
        break;

    default:

        DebugTrace( 0, Dbg, "Invalid FS Control Minor Function %08lx\n", IrpSp->MinorFunction);

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    DebugTrace(-1, Dbg, "FatCommonFileSystemControl -> %08lx\n", Status);

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PDEVICE_OBJECT FsDeviceObject
    )

/*++

Routine Description:

    This routine performs the mount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

    Its job is to verify that the volume denoted in the IRP is a Fat volume,
    and create the VCB and root DCB structures.  The algorithm it uses is
    essentially as follows:

    1. Create a new Vcb Structure, and initialize it enough to do cached
       volume file I/O.

    2. Read the disk and check if it is a Fat volume.

    3. If it is not a Fat volume then free the cached volume file, delete
       the VCB, and complete the IRP with STATUS_UNRECOGNIZED_VOLUME

    4. Check if the volume was previously mounted and if it was then do a
       remount operation.  This involves reinitializing the cached volume
       file, checking the dirty bit, resetting up the allocation support,
       deleting the VCB, hooking in the old VCB, and completing the IRP.

    5. Otherwise create a root DCB, create Fsp threads as necessary, and
       complete the IRP.

Arguments:

    TargetDeviceObject - This is where we send all of our requests.

    Vpb - This gives us additional information needed to complete the mount.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( IrpContext->OriginatingIrp );
    NTSTATUS Status;

    PBCB BootBcb;
    PPACKED_BOOT_SECTOR BootSector;

    PBCB DirentBcb;
    PDIRENT Dirent;
    ULONG ByteOffset;

    BOOLEAN MountNewVolume = FALSE;
    BOOLEAN WeClearedVerifyRequiredBit = FALSE;

    PDEVICE_OBJECT RealDevice;
    PVOLUME_DEVICE_OBJECT VolDo = NULL;
    PVCB Vcb = NULL;

    PLIST_ENTRY Links;

    IO_STATUS_BLOCK Iosb;
    ULONG ChangeCount = 0;

    DISK_GEOMETRY Geometry;

    PARTITION_INFORMATION_EX PartitionInformation;
    NTSTATUS StatusPartInfo;

    DebugTrace(+1, Dbg, "FatMountVolume\n", 0);
    DebugTrace( 0, Dbg, "TargetDeviceObject = %08lx\n", TargetDeviceObject);
    DebugTrace( 0, Dbg, "Vpb                = %08lx\n", Vpb);

    ASSERT( FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );
    ASSERT( FatDeviceIsFatFsdo( FsDeviceObject));

    //
    //  Verify that there is a disk here and pick up the change count.
    //

    Status = FatPerformDevIoCtrl( IrpContext,
                                  IOCTL_DISK_CHECK_VERIFY,
                                  TargetDeviceObject,
                                  &ChangeCount,
                                  sizeof(ULONG),
                                  FALSE,
                                  TRUE,
                                  &Iosb );

    if (!NT_SUCCESS( Status )) {

        //
        //  If we will allow a raw mount then avoid sending the popup.
        //
        //  Only send this on "true" disk devices to handle the accidental
        //  legacy of FAT. No other FS will throw a harderror on empty
        //  drives.
        //
        //  Cmd should really handle this per 9x.
        //

        if (!FlagOn( IrpSp->Flags, SL_ALLOW_RAW_MOUNT ) &&
            Vpb->RealDevice->DeviceType == FILE_DEVICE_DISK) {

            FatNormalizeAndRaiseStatus( IrpContext, Status );
        }

        return Status;
    }

    if (Iosb.Information != sizeof(ULONG)) {

        //
        //  Be safe about the count in case the driver didn't fill it in
        //

        ChangeCount = 0;
    }

    //
    //  If this is a CD class device,  then check to see if there is a 
    //  'data track' or not.  This is to avoid issuing paging reads which will
    //  fail later in the mount process (e.g. CD-DA or blank CD media)
    //

    if ((TargetDeviceObject->DeviceType == FILE_DEVICE_CD_ROM) &&
        !FatScanForDataTrack( IrpContext, TargetDeviceObject))  {

        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Ping the volume with a partition query and pick up the partition
    //  type.  We'll check this later to avoid some scurrilous volumes.
    //

    StatusPartInfo = FatPerformDevIoCtrl( IrpContext,
                                          IOCTL_DISK_GET_PARTITION_INFO_EX,
                                          TargetDeviceObject,
                                          &PartitionInformation,
                                          sizeof(PARTITION_INFORMATION_EX),
                                          FALSE,
                                          TRUE,
                                          &Iosb );

    //
    //  Make sure we can wait.
    //

    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);

    //
    //  Initialize the Bcbs and our final state so that the termination
    //  handlers will know what to free or unpin
    //

    BootBcb = NULL;
    DirentBcb = NULL;

    Vcb = NULL;
    VolDo = NULL;
    MountNewVolume = FALSE;

    try {

        BOOLEAN DoARemount = FALSE;

        PVCB OldVcb;
        PVPB OldVpb;

        //
        //  Synchronize with FatCheckForDismount(), which modifies the vpb.
        //

        (VOID)FatAcquireExclusiveGlobal( IrpContext );

        //
        //  Create a new volume device object.  This will have the Vcb
        //  hanging off of its end, and set its alignment requirement
        //  from the device we talk to.
        //

        if (!NT_SUCCESS(Status = IoCreateDevice( FatData.DriverObject,
                                                 sizeof(VOLUME_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT),
                                                 NULL,
                                                 FILE_DEVICE_DISK_FILE_SYSTEM,
                                                 0,
                                                 FALSE,
                                                 (PDEVICE_OBJECT *)&VolDo))) {

            try_return( Status );
        }

#ifdef _PNP_POWER_
        //
        // This driver doesn't talk directly to a device, and (at the moment)
        // isn't otherwise concerned about power management.
        //

        VolDo->DeviceObject.DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif

        //
        //  Our alignment requirement is the larger of the processor alignment requirement
        //  already in the volume device object and that in the TargetDeviceObject
        //

        if (TargetDeviceObject->AlignmentRequirement > VolDo->DeviceObject.AlignmentRequirement) {

            VolDo->DeviceObject.AlignmentRequirement = TargetDeviceObject->AlignmentRequirement;
        }

        //
        //  Initialize the overflow queue for the volume
        //

        VolDo->OverflowQueueCount = 0;
        InitializeListHead( &VolDo->OverflowQueue );

        VolDo->PostedRequestCount = 0;
        KeInitializeSpinLock( &VolDo->OverflowQueueSpinLock );

        //
        //  We must initialize the stack size in our device object before
        //  the following reads, because the I/O system has not done it yet.
        //  This must be done before we clear the device initializing flag
        //  otherwise a filter could attach and copy the wrong stack size into
        //  it's device object.
        //

        VolDo->DeviceObject.StackSize = (CCHAR)(TargetDeviceObject->StackSize + 1);

        //
        //  We must also set the sector size correctly in our device object 
        //  before clearing the device initializing flag.
        //
        
        Status = FatPerformDevIoCtrl( IrpContext,
                                      IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                      TargetDeviceObject,
                                      &Geometry,
                                      sizeof( DISK_GEOMETRY ),
                                      FALSE,
                                      TRUE,
                                      NULL );

        VolDo->DeviceObject.SectorSize = (USHORT)Geometry.BytesPerSector;

        //
        //  Indicate that this device object is now completely initialized
        //

        ClearFlag(VolDo->DeviceObject.Flags, DO_DEVICE_INITIALIZING);

        //
        //  Now Before we can initialize the Vcb we need to set up the device
        //  object field in the Vpb to point to our new volume device object.
        //  This is needed when we create the virtual volume file's file object
        //  in initialize vcb.
        //

        Vpb->DeviceObject = (PDEVICE_OBJECT)VolDo;

        //
        //  If the real device needs verification, temporarily clear the
        //  field.
        //

        RealDevice = Vpb->RealDevice;

        if ( FlagOn(RealDevice->Flags, DO_VERIFY_VOLUME) ) {

            ClearFlag(RealDevice->Flags, DO_VERIFY_VOLUME);

            WeClearedVerifyRequiredBit = TRUE;
        }

        //
        //  Initialize the new vcb
        //

        FatInitializeVcb( IrpContext, 
                          &VolDo->Vcb, 
                          TargetDeviceObject, 
                          Vpb, 
                          FsDeviceObject);
        //
        //  Get a reference to the Vcb hanging off the end of the device object
        //

        Vcb = &VolDo->Vcb;

        //
        //  Read in the boot sector, and have the read be the minumum size
        //  needed.  We know we can wait.
        //

        //
        //  We need to commute errors on CD so that CDFS will get its crack.  Audio
        //  and even data media may not be universally readable on sector zero.        
        //
        
        try {
        
            FatReadVolumeFile( IrpContext,
                               Vcb,
                               0,                          // Starting Byte
                               sizeof(PACKED_BOOT_SECTOR),
                               &BootBcb,
                               (PVOID *)&BootSector );
        
        } except( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM ?
                  EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

              NOTHING;
        }

        //
        //  Call a routine to check the boot sector to see if it is fat
        //

        if (BootBcb == NULL || !FatIsBootSectorFat( BootSector)) {

            DebugTrace(0, Dbg, "Not a Fat Volume\n", 0);
        
            //
            //  Complete the request and return to our caller
            //

            try_return( Status = STATUS_UNRECOGNIZED_VOLUME );
        }

        //
        //  Unpack the BPB.  We used to do some sanity checking of the FATs at
        //  this point, but authoring errors on third-party devices prevent
        //  us from continuing to safeguard ourselves.  We can only hope the
        //  boot sector check is good enough.
        //
        //  (read: digital cameras)
        //
        //  Win9x does the same.
        //

        FatUnpackBios( &Vcb->Bpb, &BootSector->PackedBpb );

        //
        //  Check if we have an OS/2 Boot Manager partition and treat it as an
        //  unknown file system.  We'll check the partition type in from the
        //  partition table and we ensure that it has less than 0x80 sectors,
        //  which is just a heuristic that will capture all real OS/2 BM partitions
        //  and avoid the chance we'll discover partitions which erroneously
        //  (but to this point, harmlessly) put down the OS/2 BM type.
        //
        //  Note that this is only conceivable on good old MBR media.
        //
        //  The OS/2 Boot Manager boot format mimics a FAT16 partition in sector
        //  zero but does is not a real FAT16 file system.  For example, the boot
        //  sector indicates it has 2 FATs but only really has one, with the boot
        //  manager code overlaying the second FAT.  If we then set clean bits in
        //  FAT[0] we'll corrupt that code.
        //

        if (NT_SUCCESS( StatusPartInfo ) &&
            (PartitionInformation.PartitionStyle == PARTITION_STYLE_MBR &&
             PartitionInformation.Mbr.PartitionType == PARTITION_OS2BOOTMGR) &&
            (Vcb->Bpb.Sectors != 0 &&
             Vcb->Bpb.Sectors < 0x80)) {

            DebugTrace( 0, Dbg, "OS/2 Boot Manager volume detected, volume not mounted. \n", 0 );
            
            //
            //  Complete the request and return to our caller
            //
            
            try_return( Status = STATUS_UNRECOGNIZED_VOLUME );
        }

        //
        //  Verify that the sector size recorded in the Bpb matches what the
        //  device currently reports it's sector size to be.
        //
        
        if ( !NT_SUCCESS( Status) || 
             (Geometry.BytesPerSector != Vcb->Bpb.BytesPerSector))  {

            try_return( Status = STATUS_UNRECOGNIZED_VOLUME );
        }

        //
        //  This is a fat volume, so extract the bpb, serial number.  The
        //  label we'll get later after we've created the root dcb.
        //
        //  Note that the way data caching is done, we set neither the
        //  direct I/O or Buffered I/O bit in the device object flags.
        //

        if (Vcb->Bpb.Sectors != 0) { Vcb->Bpb.LargeSectors = 0; }

        if (IsBpbFat32(&BootSector->PackedBpb)) {

            CopyUchar4( &Vpb->SerialNumber, ((PPACKED_BOOT_SECTOR_EX)BootSector)->Id );

        } else  {

            CopyUchar4( &Vpb->SerialNumber, BootSector->Id );

            //
            //  Allocate space for the stashed boot sector chunk.  This only has meaning on
            //  FAT12/16 volumes since this only is kept for the FSCTL_QUERY_FAT_BPB and it and
            //  its users are a bit wierd, thinking that a BPB exists wholly in the first 0x24
            //  bytes.
            //

            Vcb->First0x24BytesOfBootSector =
                FsRtlAllocatePoolWithTag( PagedPool,
                                          0x24,
                                          TAG_STASHED_BPB );

            //
            //  Stash a copy of the first 0x24 bytes
            //

            RtlCopyMemory( Vcb->First0x24BytesOfBootSector,
                           BootSector,
                           0x24 );
        }

        //
        //  Now unpin the boot sector, so when we set up allocation eveything
        //  works.
        //

        FatUnpinBcb( IrpContext, BootBcb );

        //
        //  Compute a number of fields for Vcb.AllocationSupport
        //

        FatSetupAllocationSupport( IrpContext, Vcb );

        //
        //  Sanity check the FsInfo information for FAT32 volumes.  Silently deal
        //  with messed up information by effectively disabling FsInfo updates.
        //

        if (FatIsFat32( Vcb )) {

            if (Vcb->Bpb.FsInfoSector >= Vcb->Bpb.ReservedSectors) {

                Vcb->Bpb.FsInfoSector = 0;
            }
        }

        //
        //  Create a root Dcb so we can read in the volume label.  If this is FAT32, we can
        //  discover corruption in the FAT chain.
        //
        //  NOTE: this exception handler presumes that this is the only spot where we can
        //  discover corruption in the mount process.  If this ever changes, this handler
        //  MUST be expanded.  The reason we have this guy here is because we have to rip
        //  the structures down now (in the finally below) and can't wait for the outer
        //  exception handling to do it for us, at which point everything will have vanished.
        //

        try {

            FatCreateRootDcb( IrpContext, Vcb );

        } except (GetExceptionCode() == STATUS_FILE_CORRUPT_ERROR ? EXCEPTION_EXECUTE_HANDLER :
                                                                    EXCEPTION_CONTINUE_SEARCH) {

            //
            //  The volume needs to be dirtied, do it now.  Note that at this point we have built
            //  enough of the Vcb to pull this off.
            //

            FatMarkVolume( IrpContext, Vcb, VolumeDirty );

            //
            //  Now keep bailing out ...
            //

            FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        FatLocateVolumeLabel( IrpContext,
                              Vcb,
                              &Dirent,
                              &DirentBcb,
                              &ByteOffset );

        if (Dirent != NULL) {

            OEM_STRING OemString;
            UNICODE_STRING UnicodeString;

            //
            //  Compute the length of the volume name
            //

            OemString.Buffer = &Dirent->FileName[0];
            OemString.MaximumLength = 11;

            for ( OemString.Length = 11;
                  OemString.Length > 0;
                  OemString.Length -= 1) {

                if ( (Dirent->FileName[OemString.Length-1] != 0x00) &&
                     (Dirent->FileName[OemString.Length-1] != 0x20) ) { break; }
            }

            UnicodeString.MaximumLength = MAXIMUM_VOLUME_LABEL_LENGTH;
            UnicodeString.Buffer = &Vcb->Vpb->VolumeLabel[0];

            Status = RtlOemStringToCountedUnicodeString( &UnicodeString,
                                                         &OemString,
                                                         FALSE );

            if ( !NT_SUCCESS( Status ) ) {

                try_return( Status );
            }

            Vpb->VolumeLabelLength = UnicodeString.Length;

        } else {

            Vpb->VolumeLabelLength = 0;
        }

        //
        //  Use the change count we noted initially *before* doing any work.
        //  If something came along in the midst of this operation, we'll
        //  verify and discover the problem.
        //

        Vcb->ChangeCount = ChangeCount;

        //
        //  Now scan the list of previously mounted volumes and compare
        //  serial numbers and volume labels off not currently mounted
        //  volumes to see if we have a match.
        //

        for (Links = FatData.VcbQueue.Flink;
             Links != &FatData.VcbQueue;
             Links = Links->Flink) {

            OldVcb = CONTAINING_RECORD( Links, VCB, VcbLinks );
            OldVpb = OldVcb->Vpb;

            //
            //  Skip over ourselves since we're already in the VcbQueue
            //

            if (OldVpb == Vpb) { continue; }

            //
            //  Check for a match:
            //
            //  Serial Number, VolumeLabel and Bpb must all be the same.
            //  Also the volume must have failed a verify before (ie.
            //  VolumeNotMounted), and it must be in the same physical
            //  drive than it was mounted in before.
            //

            if ( (OldVpb->SerialNumber == Vpb->SerialNumber) &&
                 (OldVcb->VcbCondition == VcbNotMounted) &&
                 (OldVpb->RealDevice == RealDevice) &&
                 (OldVpb->VolumeLabelLength == Vpb->VolumeLabelLength) &&
                 (RtlEqualMemory(&OldVpb->VolumeLabel[0],
                                 &Vpb->VolumeLabel[0],
                                 Vpb->VolumeLabelLength)) &&
                 (RtlEqualMemory(&OldVcb->Bpb,
                                 &Vcb->Bpb,
                                 IsBpbFat32(&Vcb->Bpb) ?
                                     sizeof(BIOS_PARAMETER_BLOCK) :
                                     FIELD_OFFSET(BIOS_PARAMETER_BLOCK,
                                                  LargeSectorsPerFat) ))) {

                DoARemount = TRUE;

                break;
            }
        }

        if ( DoARemount ) {

            PVPB *IrpVpb;

            DebugTrace(0, Dbg, "Doing a remount\n", 0);
            DebugTrace(0, Dbg, "Vcb = %08lx\n", Vcb);
            DebugTrace(0, Dbg, "Vpb = %08lx\n", Vpb);
            DebugTrace(0, Dbg, "OldVcb = %08lx\n", OldVcb);
            DebugTrace(0, Dbg, "OldVpb = %08lx\n", OldVpb);

            //
            // The old target device object is about to be overwritten.
            // Drop the reference being held on that device object.
            //

            ObDereferenceObject( OldVcb->TargetDeviceObject );

            //
            //  This is a remount, so link the old vpb in place
            //  of the new vpb and release the new vpb and the extra
            //  volume device object we created earlier.
            //

            OldVpb->RealDevice = Vpb->RealDevice;
            OldVpb->RealDevice->Vpb = OldVpb;
            OldVcb->TargetDeviceObject = TargetDeviceObject;
            OldVcb->VcbCondition = VcbGood;

            //
            //  Use the new changecount.
            //

            OldVcb->ChangeCount = Vcb->ChangeCount;

            //
            //  Delete the extra new vpb, and make sure we don't use it again.
            //
            //  Also if this is the Vpb referenced in the original Irp, set
            //  that reference back to the old VPB.
            //

            IrpVpb = &IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->Parameters.MountVolume.Vpb;

            if (*IrpVpb == Vpb) {

                *IrpVpb = OldVpb;
            }

            ExFreePool( Vpb );
            Vpb = NULL;

            //
            //  Make sure the remaining stream files are orphaned.
            //

            Vcb->VirtualVolumeFile->Vpb = NULL;
            Vcb->RootDcb->Specific.Dcb.DirectoryFile->Vpb = NULL;

            //
            //  Reinitialize the volume file cache and allocation support.
            //

            {
                CC_FILE_SIZES FileSizes;

                FileSizes.AllocationSize.QuadPart =
                FileSizes.FileSize.QuadPart = ( 0x40000 + 0x1000 );
                FileSizes.ValidDataLength = FatMaxLarge;

                DebugTrace(0, Dbg, "Truncate and reinitialize the volume file\n", 0);

                CcInitializeCacheMap( OldVcb->VirtualVolumeFile,
                                      &FileSizes,
                                      TRUE,
                                      &FatData.CacheManagerNoOpCallbacks,
                                      Vcb );

                //
                //  Redo the allocation support
                //

                FatSetupAllocationSupport( IrpContext, OldVcb );

                //
                //  Get the state of the dirty bit.
                //

                FatCheckDirtyBit( IrpContext, OldVcb );

                //
                //  Check for write protected media.
                //

                if (FatIsMediaWriteProtected(IrpContext, TargetDeviceObject)) {

                    SetFlag( OldVcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED );

                } else {

                    ClearFlag( OldVcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED );
                }
            }

            //
            //  Complete the request and return to our caller
            //

            try_return( Status = STATUS_SUCCESS );
        }

        DebugTrace(0, Dbg, "Mount a new volume\n", 0);

        //
        //  This is a new mount
        //
        //  Create a blank ea data file fcb, just not for Fat32.
        //

        if (!FatIsFat32(Vcb)) {

            DIRENT TempDirent;
            PFCB EaFcb;

            RtlZeroMemory( &TempDirent, sizeof(DIRENT) );
            RtlCopyMemory( &TempDirent.FileName[0], "EA DATA  SF", 11 );

            EaFcb = FatCreateFcb( IrpContext,
                                  Vcb,
                                  Vcb->RootDcb,
                                  0,
                                  0,
                                  &TempDirent,
                                  NULL,
                                  FALSE,
                                  TRUE );

            //
            //  Deny anybody who trys to open the file.
            //

            SetFlag( EaFcb->FcbState, FCB_STATE_SYSTEM_FILE );

            Vcb->EaFcb = EaFcb;
        }

        //
        //  Get the state of the dirty bit.
        //

        FatCheckDirtyBit( IrpContext, Vcb );

        //
        //  Check for write protected media.
        //

        if (FatIsMediaWriteProtected(IrpContext, TargetDeviceObject)) {

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED );

        } else {

            ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED );
        }

        //
        //  Lock volume in drive if we just mounted the boot drive.
        //

        if (FlagOn(RealDevice->Flags, DO_SYSTEM_BOOT_PARTITION)) {

            SetFlag(Vcb->VcbState, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE);

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA)) {

                FatToggleMediaEjectDisable( IrpContext, Vcb, TRUE );
            }
        }

        //
        //  Indicate to our termination handler that we have mounted
        //  a new volume.
        //

        MountNewVolume = TRUE;

        //
        //  Complete the request
        //

        Status = STATUS_SUCCESS;

        //
        //  Ref the root dir stream object so we can send mount notification.
        //

        ObReferenceObject( Vcb->RootDcb->Specific.Dcb.DirectoryFile );

        //
        //  Remove the extra reference to this target DO made on behalf of us
        //  by the IO system.  In the remount case, we permit regular Vcb
        //  deletion to do this work.
        //

        ObDereferenceObject( TargetDeviceObject );


    try_exit: NOTHING;

    } finally {

        DebugUnwind( FatMountVolume );

        FatUnpinBcb( IrpContext, BootBcb );
        FatUnpinBcb( IrpContext, DirentBcb );

        //
        //  Check if a volume was mounted.  If not then we need to
        //  mark the Vpb not mounted again and delete the volume.
        //

        if ( !MountNewVolume ) {

            if ( Vpb != NULL ) {

                Vpb->DeviceObject = NULL;
            }

            if ( Vcb != NULL ) {

                //
                //  Make sure we clean up the IrpContext field if the Vcb is
                //  being taken down.
                //

                IrpContext->Vcb = NULL;
                FatDeleteVcb( IrpContext, Vcb );
            }

            if ( VolDo != NULL ) {

                IoDeleteDevice( &VolDo->DeviceObject );
            }
        }

        if ( WeClearedVerifyRequiredBit == TRUE ) {

            SetFlag(RealDevice->Flags, DO_VERIFY_VOLUME);
        }

        FatReleaseGlobal( IrpContext );

        DebugTrace(-1, Dbg, "FatMountVolume -> %08lx\n", Status);
    }

    //
    //  Now send mount notification. Note that since this is outside of any
    //  synchronization since the synchronous delivery of this may go to
    //  folks that provoke re-entrance to the FS.
    //

    if (MountNewVolume) {

        FsRtlNotifyVolumeEvent( Vcb->RootDcb->Specific.Dcb.DirectoryFile, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( Vcb->RootDcb->Specific.Dcb.DirectoryFile );
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the verify volume operation by checking the volume
    label and serial number physically on the media with the the Vcb
    currently claiming to have the volume mounted. It is responsible for
    either completing or enqueuing the input Irp.

    Regardless of whether the verify operation succeeds, the following
    operations are performed:

        - Set Vcb->VirtualEaFile back to its virgin state.
        - Purge all cached data (flushing first if verify succeeds)
        - Mark all Fcbs as needing verification

    If the volumes verifies correctly we also must:

        - Check the volume dirty bit.
        - Reinitialize the allocation support
        - Flush any dirty data

    If the volume verify fails, it may never be mounted again.  If it is
    mounted again, it will happen as a remount operation.  In preparation
    for that, and to leave the volume in a state that can be "lazy deleted"
    the following operations are performed:

        - Set the Vcb condition to VcbNotMounted
        - Uninitialize the volume file cachemap
        - Tear down the allocation support

    In the case of an abnormal termination we haven't determined the state
    of the volume, so we set the Device Object as needing verification again.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - If the verify operation completes, it will return either
        STATUS_SUCCESS or STATUS_WRONG_VOLUME, exactly.  If an IO or
        other error is encountered, that status will be returned.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION IrpSp;

    PDIRENT RootDirectory = NULL;
    PPACKED_BOOT_SECTOR BootSector = NULL;

    BIOS_PARAMETER_BLOCK Bpb;

    PVOLUME_DEVICE_OBJECT VolDo;
    PVCB Vcb;
    PVPB Vpb;

    ULONG SectorSize;
    BOOLEAN ClearVerify = FALSE;
    BOOLEAN ReleaseEntireVolume = FALSE;
    BOOLEAN VerifyAlreadyDone = FALSE;

    DISK_GEOMETRY DiskGeometry;

    LBO RootDirectoryLbo;
    ULONG RootDirectorySize;
    BOOLEAN LabelFound;

    ULONG ChangeCount = 0;
    IO_STATUS_BLOCK Iosb;

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatVerifyVolume\n", 0);
    DebugTrace( 0, Dbg, "DeviceObject = %08lx\n", IrpSp->Parameters.VerifyVolume.DeviceObject);
    DebugTrace( 0, Dbg, "Vpb          = %08lx\n", IrpSp->Parameters.VerifyVolume.Vpb);

    //
    //  Save some references to make our life a little easier.  Note the Vcb for the purposes
    //  of exception handling.
    //

    VolDo = (PVOLUME_DEVICE_OBJECT)IrpSp->Parameters.VerifyVolume.DeviceObject;

    Vpb                   = IrpSp->Parameters.VerifyVolume.Vpb;
    IrpContext->Vcb = Vcb = &VolDo->Vcb;

    //
    //  If we cannot wait then enqueue the irp to the fsp and
    //  return the status to our caller.
    //

    if (!FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT)) {

        DebugTrace(0, Dbg, "Cannot wait for verify.\n", 0);

        Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatVerifyVolume -> %08lx\n", Status );
        return Status;
    }

    //
    //  We are serialized at this point allowing only one thread to
    //  actually perform the verify operation.  Any others will just
    //  wait and then no-op when checking if the volume still needs
    //  verification.
    //

    (VOID)FatAcquireExclusiveGlobal( IrpContext );
    (VOID)FatAcquireExclusiveVcb( IrpContext, Vcb );

    try {

        BOOLEAN AllowRawMount = BooleanFlagOn( IrpSp->Flags, SL_ALLOW_RAW_MOUNT );

        //
        //  Mark ourselves as verifying this volume so that recursive I/Os
        //  will be able to complete.
        //

        ASSERT( Vcb->VerifyThread == NULL );
        Vcb->VerifyThread = KeGetCurrentThread();

        //
        //  Check if the real device still needs to be verified.  If it doesn't
        //  then obviously someone beat us here and already did the work
        //  so complete the verify irp with success.  Otherwise reenable
        //  the real device and get to work.
        //

        if (!FlagOn(Vpb->RealDevice->Flags, DO_VERIFY_VOLUME)) {

            DebugTrace(0, Dbg, "RealDevice has already been verified\n", 0);

            VerifyAlreadyDone = TRUE;
            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  Ping the volume with a partition query to make Jeff happy.
        //

        {
            PARTITION_INFORMATION_EX PartitionInformation;

            (VOID) FatPerformDevIoCtrl( IrpContext,
                                        IOCTL_DISK_GET_PARTITION_INFO_EX,
                                        Vcb->TargetDeviceObject,
                                        &PartitionInformation,
                                        sizeof(PARTITION_INFORMATION_EX),
                                        FALSE,
                                        TRUE,
                                        &Iosb );
        }

        //
        //  Verify that there is a disk here and pick up the change count.
        //

        Status = FatPerformDevIoCtrl( IrpContext,
                                      IOCTL_DISK_CHECK_VERIFY,
                                      Vcb->TargetDeviceObject,
                                      &ChangeCount,
                                      sizeof(ULONG),
                                      FALSE,
                                      TRUE,
                                      &Iosb );

        if (!NT_SUCCESS( Status )) {

            //
            //  If we will allow a raw mount then return WRONG_VOLUME to
            //  allow the volume to be mounted by raw.
            //

            if (AllowRawMount) {

                try_return( Status = STATUS_WRONG_VOLUME );
            }

            FatNormalizeAndRaiseStatus( IrpContext, Status );
        }

        if (Iosb.Information != sizeof(ULONG)) {

            //
            //  Be safe about the count in case the driver didn't fill it in
            //

            ChangeCount = 0;
        }

        //
        //  Whatever happens we will have verified this volume at this change
        //  count, so record that fact.
        //

        Vcb->ChangeCount = ChangeCount;

        //
        //  If this is a CD class device,  then check to see if there is a 
        //  'data track' or not.  This is to avoid issuing paging reads which will
        //  fail later in the mount process (e.g. CD-DA or blank CD media)
        //

        if ((Vcb->TargetDeviceObject->DeviceType == FILE_DEVICE_CD_ROM) &&
            !FatScanForDataTrack( IrpContext, Vcb->TargetDeviceObject))  {

            try_return( Status = STATUS_WRONG_VOLUME);
        }

        //
        //  Some devices can change sector sizes on the fly.  Obviously, it
        //  isn't the same volume if that happens.
        //

        Status = FatPerformDevIoCtrl( IrpContext,
                                      IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                      Vcb->TargetDeviceObject,
                                      &DiskGeometry,
                                      sizeof( DISK_GEOMETRY ),
                                      FALSE,
                                      TRUE,
                                      NULL );

        if (!NT_SUCCESS( Status )) {

            //
            //  If we will allow a raw mount then return WRONG_VOLUME to
            //  allow the volume to be mounted by raw.
            //

            if (AllowRawMount) {

                try_return( Status = STATUS_WRONG_VOLUME );
            }

            FatNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  Read in the boot sector
        //

        SectorSize = (ULONG)Vcb->Bpb.BytesPerSector;

        if (SectorSize != DiskGeometry.BytesPerSector) {

            try_return( Status = STATUS_WRONG_VOLUME );
        }

        BootSector = FsRtlAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                              (ULONG) ROUND_TO_PAGES( SectorSize ),
                                              TAG_VERIFY_BOOTSECTOR);

        //
        //  If this verify is on behalf of a DASD open, allow a RAW mount.
        //

        if (!FatPerformVerifyDiskRead( IrpContext,
                                       Vcb,
                                       BootSector,
                                       0,
                                       SectorSize,
                                       AllowRawMount )) {

            try_return( Status = STATUS_WRONG_VOLUME );
        }

        //
        //  Call a routine to check the boot sector to see if it is fat.
        //  If it is not fat then mark the vcb as not mounted tell our
        //  caller its the wrong volume
        //

        if (!FatIsBootSectorFat( BootSector )) {

            DebugTrace(0, Dbg, "Not a Fat Volume\n", 0);

            try_return( Status = STATUS_WRONG_VOLUME );
        }

        //
        //  This is a fat volume, so extract serial number and see if it is
        //  ours.
        //

        {
            ULONG SerialNumber;

            if (IsBpbFat32(&BootSector->PackedBpb)) {
                CopyUchar4( &SerialNumber, ((PPACKED_BOOT_SECTOR_EX)BootSector)->Id );
            } else {
                CopyUchar4( &SerialNumber, BootSector->Id );
            }

            if (SerialNumber != Vpb->SerialNumber) {

                DebugTrace(0, Dbg, "Not our serial number\n", 0);

                try_return( Status = STATUS_WRONG_VOLUME );
            }
        }

        //
        //  Make sure the Bpbs are not different.  We have to zero out our
        //  stack version of the Bpb since unpacking leaves holes.
        //

        RtlZeroMemory( &Bpb, sizeof(BIOS_PARAMETER_BLOCK) );

        FatUnpackBios( &Bpb, &BootSector->PackedBpb );
        if (Bpb.Sectors != 0) { Bpb.LargeSectors = 0; }

        if ( !RtlEqualMemory( &Bpb,
                              &Vcb->Bpb,
                              IsBpbFat32(&Bpb) ?
                                    sizeof(BIOS_PARAMETER_BLOCK) :
                                    FIELD_OFFSET(BIOS_PARAMETER_BLOCK,
                                                 LargeSectorsPerFat) )) {

            DebugTrace(0, Dbg, "Bpb is different\n", 0);

            try_return( Status = STATUS_WRONG_VOLUME );
        }

        //
        //  Check the volume label.  We do this by trying to locate the
        //  volume label, making two strings one for the saved volume label
        //  and the other for the new volume label and then we compare the
        //  two labels.
        //

        if (FatRootDirectorySize(&Bpb) > 0) {

            RootDirectorySize = FatRootDirectorySize(&Bpb);
        
        } else {

            RootDirectorySize = FatBytesPerCluster(&Bpb);
        }

        RootDirectory = FsRtlAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                  (ULONG) ROUND_TO_PAGES( RootDirectorySize ),
                                                  TAG_VERIFY_ROOTDIR);

        if (!IsBpbFat32(&BootSector->PackedBpb)) {

            //
            //  The Fat12/16 case is simple -- read the root directory in and
            //  search it.
            //

            RootDirectoryLbo = FatRootDirectoryLbo(&Bpb);

            if (!FatPerformVerifyDiskRead( IrpContext,
                                           Vcb,
                                           RootDirectory,
                                           RootDirectoryLbo,
                                           RootDirectorySize,
                                           AllowRawMount )) {

                try_return( Status = STATUS_WRONG_VOLUME );
            }

            Status = FatSearchBufferForLabel(IrpContext, Vpb,
                                             RootDirectory, RootDirectorySize,
                                             &LabelFound);

            if (!NT_SUCCESS(Status)) {

                try_return( Status );
            }

            if (!LabelFound && Vpb->VolumeLabelLength > 0) {

                try_return( Status = STATUS_WRONG_VOLUME );
            }

        } else {

            ULONG RootDirectoryCluster;

            RootDirectoryCluster = Bpb.RootDirFirstCluster;

            while (RootDirectoryCluster != FAT_CLUSTER_LAST) {

                RootDirectoryLbo = FatGetLboFromIndex(Vcb, RootDirectoryCluster);

                if (!FatPerformVerifyDiskRead( IrpContext,
                                               Vcb,
                                               RootDirectory,
                                               RootDirectoryLbo,
                                               RootDirectorySize,
                                               AllowRawMount )) {

                    try_return( Status = STATUS_WRONG_VOLUME );
                }

                Status = FatSearchBufferForLabel(IrpContext, Vpb,
                                                 RootDirectory, RootDirectorySize,
                                                 &LabelFound);

                if (!NT_SUCCESS(Status)) {

                    try_return( Status );
                }

                if (LabelFound) {

                    //
                    //  Found a matching label.
                    //

                    break;
                }

                //
                //  Set ourselves up for the next loop iteration.
                //

                FatVerifyLookupFatEntry( IrpContext, Vcb,
                                         RootDirectoryCluster,
                                         &RootDirectoryCluster );

                switch (FatInterpretClusterType(Vcb, RootDirectoryCluster)) {

                case FatClusterAvailable:
                case FatClusterReserved:
                case FatClusterBad:

                    //
                    //  Bail all the way out if we have a bad root.
                    //

                    FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                    break;

                default:

                    break;
                }

            }

            if (RootDirectoryCluster == FAT_CLUSTER_LAST &&
                Vpb->VolumeLabelLength > 0) {

                //
                //  Should have found a label, didn't find any.
                //

                try_return( Status = STATUS_WRONG_VOLUME );
            }
        }


    try_exit: NOTHING;

        //
        //  Note that we have previously acquired the Vcb to serialize
        //  the EA file stuff the marking all the Fcbs as NeedToBeVerified.
        //
        //  Put the Ea file back in a virgin state.
        //

        FatCloseEaFile( IrpContext, Vcb, (BOOLEAN)(Status == STATUS_SUCCESS) );

        //
        //  Mark all Fcbs as needing verification, but only if we really have
        //  to do it.
        //

        if (!VerifyAlreadyDone) {

            FatMarkFcbCondition( IrpContext, Vcb->RootDcb, FcbNeedsToBeVerified, TRUE );
        }

        //
        //  If the verify didn't succeed, get the volume ready for a
        //  remount or eventual deletion.
        //

        if (Vcb->VcbCondition == VcbNotMounted) {

            //
            //  If the volume was already in an unmounted state, just bail
            //  and make sure we return STATUS_WRONG_VOLUME.
            //

            Status = STATUS_WRONG_VOLUME;

        } else if ( Status == STATUS_WRONG_VOLUME ) {

            //
            //  Grab everything so we can safely transition the volume state without
            //  having a thread stumble into the torn-down allocation engine.
            //

            FatAcquireExclusiveVolume( IrpContext, Vcb );
            ReleaseEntireVolume = TRUE;

            //
            //  Get rid of any cached data, without flushing
            //

            FatPurgeReferencedFileObjects( IrpContext, Vcb->RootDcb, NoFlush );

            //
            //  Uninitialize the volume file cache map.  Note that we cannot
            //  do a "FatSyncUninit" because of deadlock problems.  However,
            //  since this FileObject is referenced by us, and thus included
            //  in the Vpb residual count, it is OK to do a normal CcUninit.
            //

            CcUninitializeCacheMap( Vcb->VirtualVolumeFile,
                                    &FatLargeZero,
                                    NULL );

            FatTearDownAllocationSupport( IrpContext, Vcb );

            Vcb->VcbCondition = VcbNotMounted;

            ClearVerify = TRUE;

        } else if (!VerifyAlreadyDone) {

            //
            //  Grab everything so we can safely transition the volume state without
            //  having a thread stumble into the torn-down allocation engine.
            //

            FatAcquireExclusiveVolume( IrpContext, Vcb );
            ReleaseEntireVolume = TRUE;

            //
            //  Get rid of any cached data, flushing first.
            //
            //  Future work (and for bonus points, around the other flush points)
            //  could address the possibility that the dirent filesize hasn't been
            //  updated yet, causing us to fail the re-verification of a file in
            //  DetermineAndMark. This is pretty subtle and very very uncommon.
            //

            FatPurgeReferencedFileObjects( IrpContext, Vcb->RootDcb, Flush );

            //
            //  Flush and Purge the volume file.
            //

            (VOID)FatFlushFat( IrpContext, Vcb );
            CcPurgeCacheSection( &Vcb->SectionObjectPointers, NULL, 0, FALSE );

            //
            //  Redo the allocation support with newly paged stuff.
            //

            FatTearDownAllocationSupport( IrpContext, Vcb );
            FatSetupAllocationSupport( IrpContext, Vcb );

            FatCheckDirtyBit( IrpContext, Vcb );

            //
            //  Check for write protected media.
            //

            if (FatIsMediaWriteProtected(IrpContext, Vcb->TargetDeviceObject)) {

                SetFlag( Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED );

            } else {

                ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED );
            }

            ClearVerify = TRUE;
        }

        if (ClearVerify) {

            //
            //  Mark the device as no longer needing verification.
            //

            ClearFlag( Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );
        }

    } finally {

        DebugUnwind( FatVerifyVolume );

        //
        //  Free any buffer we may have allocated
        //

        if ( BootSector != NULL ) { ExFreePool( BootSector ); }
        if ( RootDirectory != NULL ) { ExFreePool( RootDirectory ); }

        //
        //  Show that we are done with this volume.
        //

        ASSERT( Vcb->VerifyThread == KeGetCurrentThread() );
        Vcb->VerifyThread = NULL;

        if (ReleaseEntireVolume) {

            FatReleaseVolume( IrpContext, Vcb );
        }

        FatReleaseVcb( IrpContext, Vcb );
        FatReleaseGlobal( IrpContext );

        //
        //  If this was not an abnormal termination, complete the irp.
        //

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatVerifyVolume -> %08lx\n", Status);
    }

    return Status;
}


//
//  Local Support Routine
//

BOOLEAN
FatIsBootSectorFat (
    IN PPACKED_BOOT_SECTOR BootSector
    )

/*++

Routine Description:

    This routine checks if the boot sector is for a fat file volume.

Arguments:

    BootSector - Supplies the packed boot sector to check

Return Value:

    BOOLEAN - TRUE if the volume is Fat and FALSE otherwise.

--*/

{
    BOOLEAN Result;
    BIOS_PARAMETER_BLOCK Bpb;

    DebugTrace(+1, Dbg, "FatIsBootSectorFat, BootSector = %08lx\n", BootSector);

    //
    //  The result is true unless we decide that it should be false
    //

    Result = TRUE;

    //
    //  Unpack the bios and then test everything
    //

    FatUnpackBios( &Bpb, &BootSector->PackedBpb );
    if (Bpb.Sectors != 0) { Bpb.LargeSectors = 0; }

    if ((BootSector->Jump[0] != 0xe9) &&
        (BootSector->Jump[0] != 0xeb) &&
        (BootSector->Jump[0] != 0x49)) {

        Result = FALSE;

    //
    //  Enforce some sanity on the sector size (easy check)
    //

    } else if ((Bpb.BytesPerSector !=  128) &&
               (Bpb.BytesPerSector !=  256) &&
               (Bpb.BytesPerSector !=  512) &&
               (Bpb.BytesPerSector != 1024) &&
               (Bpb.BytesPerSector != 2048) &&
               (Bpb.BytesPerSector != 4096)) {

        Result = FALSE;

    //
    //  Likewise on the clustering.
    //

    } else if ((Bpb.SectorsPerCluster !=  1) &&
               (Bpb.SectorsPerCluster !=  2) &&
               (Bpb.SectorsPerCluster !=  4) &&
               (Bpb.SectorsPerCluster !=  8) &&
               (Bpb.SectorsPerCluster != 16) &&
               (Bpb.SectorsPerCluster != 32) &&
               (Bpb.SectorsPerCluster != 64) &&
               (Bpb.SectorsPerCluster != 128)) {

        Result = FALSE;

    //
    //  Likewise on the reserved sectors (must reflect at least the boot sector!)
    //

    } else if (Bpb.ReservedSectors == 0) {

        Result = FALSE;

    //
    //  No FATs? Wrong ...
    //

    } else if (Bpb.Fats == 0) {

        Result = FALSE;

    //
    // Prior to DOS 3.2 might contains value in both of Sectors and
    // Sectors Large.
    //

    } else if ((Bpb.Sectors == 0) && (Bpb.LargeSectors == 0)) {

        Result = FALSE;

    //
    //  Check that FAT32 (SectorsPerFat == 0) claims some FAT space and
    //  is of a version we recognize, currently Version 0.0.
    //

    } else if (Bpb.SectorsPerFat == 0 && ( Bpb.LargeSectorsPerFat == 0 ||
                                           Bpb.FsVersion != 0 )) {

        Result = FALSE;

    } else if ((Bpb.Media != 0xf0) &&
               (Bpb.Media != 0xf8) &&
               (Bpb.Media != 0xf9) &&
               (Bpb.Media != 0xfb) &&
               (Bpb.Media != 0xfc) &&
               (Bpb.Media != 0xfd) &&
               (Bpb.Media != 0xfe) &&
               (Bpb.Media != 0xff) &&
               (!FatData.FujitsuFMR || ((Bpb.Media != 0x00) &&
                                        (Bpb.Media != 0x01) &&
                                        (Bpb.Media != 0xfa)))) {

        Result = FALSE;

    //
    //  If this isn't FAT32, then there better be a claimed root directory
    //  size here ...
    //

    } else if (Bpb.SectorsPerFat != 0 && Bpb.RootEntries == 0) {

        Result = FALSE;

    //
    //  If this is FAT32 (i.e., extended BPB), look for and refuse to mount
    //  mirror-disabled volumes. If we did, we would need to only write to
    //  the FAT# indicated in the ActiveFat field. The only user of this is
    //  the FAT->FAT32 converter after the first pass of protected mode work
    //  (booting into realmode) and NT should absolutely not be attempting
    //  to mount such an in-transition volume.
    //

    } else if (Bpb.SectorsPerFat == 0 && Bpb.MirrorDisabled) {

        Result = FALSE;
    }

    DebugTrace(-1, Dbg, "FatIsBootSectorFat -> %08lx\n", Result);

    return Result;
}


//
//  Local Support Routine
//

BOOLEAN
FatIsMediaWriteProtected (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject
    )

/*++

Routine Description:

    This routine determines if the target media is write protected.

Arguments:

    TargetDeviceObject - The target of the query

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIRP Irp;
    KEVENT Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    //
    //  Query the partition table
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  See if the media is write protected.  On success or any kind
    //  of error (possibly illegal device function), assume it is
    //  writeable, and only complain if he tells us he is write protected.
    //

    Irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_IS_WRITABLE,
                                         TargetDeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         &Event,
                                         &Iosb );

    //
    //  Just return FALSE in the unlikely event we couldn't allocate an Irp.
    //

    if ( Irp == NULL ) {

        return FALSE;
    }

    SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    Status = IoCallDriver( TargetDeviceObject, Irp );

    if ( Status == STATUS_PENDING ) {

        (VOID) KeWaitForSingleObject( &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER)NULL );

        Status = Iosb.Status;
    }

    return (BOOLEAN)(Status == STATUS_MEDIA_WRITE_PROTECTED);
}


//
//  Local Support Routine
//

NTSTATUS
FatUserFsCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    ULONG FsControlCode;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Save some references to make our life a little easier
    //

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace(+1, Dbg,"FatUserFsCtrl...\n", 0);
    DebugTrace( 0, Dbg,"FsControlCode = %08lx\n", FsControlCode);

    //
    //  Some of these Fs Controls use METHOD_NEITHER buffering.  If the previous mode
    //  of the caller was userspace and this is a METHOD_NEITHER, we have the choice
    //  of realy buffering the request through so we can possibly post, or making the
    //  request synchronous.  Since the former was not done by design, do the latter.
    //

    if (Irp->RequestorMode != KernelMode && (FsControlCode & 3) == METHOD_NEITHER) {

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    }

    //
    //  Case on the control code.
    //

    switch ( FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_OPLOCK_BREAK_ACK_NO_2:
    case FSCTL_REQUEST_FILTER_OPLOCK :

        Status = FatOplockRequest( IrpContext, Irp );
        break;

    case FSCTL_LOCK_VOLUME:

        Status = FatLockVolume( IrpContext, Irp );
        break;

    case FSCTL_UNLOCK_VOLUME:

        Status = FatUnlockVolume( IrpContext, Irp );
        break;

    case FSCTL_DISMOUNT_VOLUME:

        Status = FatDismountVolume( IrpContext, Irp );
        break;

    case FSCTL_MARK_VOLUME_DIRTY:

        Status = FatDirtyVolume( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_DIRTY:

        Status = FatIsVolumeDirty( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_MOUNTED:

        Status = FatIsVolumeMounted( IrpContext, Irp );
        break;

    case FSCTL_IS_PATHNAME_VALID:
        Status = FatIsPathnameValid( IrpContext, Irp );
        break;

    case FSCTL_QUERY_RETRIEVAL_POINTERS:
        Status = FatQueryRetrievalPointers( IrpContext, Irp );
        break;

    case FSCTL_QUERY_FAT_BPB:
        Status = FatQueryBpb( IrpContext, Irp );
        break;

    case FSCTL_FILESYSTEM_GET_STATISTICS:
        Status = FatGetStatistics( IrpContext, Irp );
        break;

    case FSCTL_GET_VOLUME_BITMAP:
        Status = FatGetVolumeBitmap( IrpContext, Irp );
        break;

    case FSCTL_GET_RETRIEVAL_POINTERS:
        Status = FatGetRetrievalPointers( IrpContext, Irp );
        break;

    case FSCTL_MOVE_FILE:
        Status = FatMoveFile( IrpContext, Irp );
        break;

    case FSCTL_ALLOW_EXTENDED_DASD_IO:
        Status = FatAllowExtendedDasdIo( IrpContext, Irp );
        break;

    default :

        DebugTrace(0, Dbg, "Invalid control code -> %08lx\n", FsControlCode );

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    DebugTrace(-1, Dbg, "FatUserFsCtrl -> %08lx\n", Status );
    return Status;
}



//
//  Local support routine
//

NTSTATUS
FatOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine to handle oplock requests made via the
    NtFsControlFile call.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    ULONG FsControlCode;
    PFCB Fcb;
    PVCB Vcb;
    PCCB Ccb;

    ULONG OplockCount = 0;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    BOOLEAN AcquiredVcb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;

    //
    //  Save some references to make our life a little easier
    //

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace(+1, Dbg, "FatOplockRequest...\n", 0);
    DebugTrace( 0, Dbg, "FsControlCode = %08lx\n", FsControlCode);

    //
    //  We only permit oplock requests on files.
    //

    if ( FatDecodeFileObject( IrpSp->FileObject,
                              &Vcb,
                              &Fcb,
                              &Ccb ) != UserFileOpen ) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DebugTrace(-1, Dbg, "FatOplockRequest -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make this a waitable Irpcontext so we don't fail to acquire
    //  the resources.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    //
    //  Use a try finally to free the Fcb/Vcb
    //

    try {

        //
        //  Switch on the function control code.  We grab the Fcb exclusively
        //  for oplock requests, shared for oplock break acknowledgement.
        //

        switch ( FsControlCode ) {

        case FSCTL_REQUEST_OPLOCK_LEVEL_1:
        case FSCTL_REQUEST_OPLOCK_LEVEL_2:
        case FSCTL_REQUEST_BATCH_OPLOCK:
        case FSCTL_REQUEST_FILTER_OPLOCK :

            FatAcquireSharedVcb( IrpContext, Fcb->Vcb );
            AcquiredVcb = TRUE;
            FatAcquireExclusiveFcb( IrpContext, Fcb );
            AcquiredFcb = TRUE;

            if (FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2) {

                OplockCount = (ULONG) FsRtlAreThereCurrentFileLocks( &Fcb->Specific.Fcb.FileLock );

            } else {

                OplockCount = Fcb->UncleanCount;
            }

            break;

        case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
        case FSCTL_OPBATCH_ACK_CLOSE_PENDING :
        case FSCTL_OPLOCK_BREAK_NOTIFY:
        case FSCTL_OPLOCK_BREAK_ACK_NO_2:

            FatAcquireSharedFcb( IrpContext, Fcb );
            AcquiredFcb = TRUE;
            break;

        default:

            FatBugCheck( FsControlCode, 0, 0 );
        }

        //
        //  Call the FsRtl routine to grant/acknowledge oplock.
        //

        Status = FsRtlOplockFsctrl( &Fcb->Specific.Fcb.Oplock,
                                    Irp,
                                    OplockCount );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );

    } finally {

        DebugUnwind( FatOplockRequest );

        //
        //  Release all of our resources
        //

        if (AcquiredVcb) {

            FatReleaseVcb( IrpContext, Fcb->Vcb );
        }

        if (AcquiredFcb)  {

            FatReleaseFcb( IrpContext, Fcb );
        }

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, FatNull, 0 );
        }

        DebugTrace(-1, Dbg, "FatOplockRequest -> %08lx\n", Status );
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the lock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatLockVolume...\n", 0);

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb ) != UserVolumeOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatLockVolume -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    if ((Ccb == NULL) || !FlagOn( Ccb->Flags, CCB_FLAG_MANAGE_VOLUME_ACCESS )) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatLockVolume -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Send our notification so that folks that like to hold handles on
    //  volumes can get out of the way.
    //

    FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_LOCK );

    //
    //  Acquire exclusive access to the Vcb and enqueue the Irp if we
    //  didn't get access.
    //

    if (!FatAcquireExclusiveVcb( IrpContext, Vcb )) {

        DebugTrace( 0, Dbg, "Cannot acquire Vcb\n", 0);

        Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatUnlockVolume -> %08lx\n", Status);
        return Status;
    }

    try {

        Status = FatLockVolumeInternal( IrpContext, Vcb, IrpSp->FileObject );

    } finally {

        //
        //  Since we drop and release the vcb while trying to punch the volume
        //  down, it may be the case that we decide the operation should not
        //  continue if the user raced a CloeseHandle() with us (and it finished
        //  the cleanup) while we were waiting for our closes to finish.
        //
        //  In this case, we will have been raised out of the acquire logic with
        //  STATUS_FILE_CLOSED, and the volume will not be held.
        //

        if (!AbnormalTermination() || ExIsResourceAcquiredExclusiveLite( &Vcb->Resource )) {

            FatReleaseVcb( IrpContext, Vcb );
        }

        if (!NT_SUCCESS( Status ) || AbnormalTermination()) {

            //
            //  The volume lock will be failing.
            //

            FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_LOCK_FAILED );
        }
    }

    FatCompleteRequest( IrpContext, Irp, Status );

    DebugTrace(-1, Dbg, "FatLockVolume -> %08lx\n", Status);

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the unlock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatUnlockVolume...\n", 0);

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb ) != UserVolumeOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatUnlockVolume -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    if ((Ccb == NULL) || !FlagOn( Ccb->Flags, CCB_FLAG_MANAGE_VOLUME_ACCESS )) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatUnlockVolume -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    Status = FatUnlockVolumeInternal( IrpContext, Vcb, IrpSp->FileObject );

    //
    //  Send notification that the volume is avaliable.
    //

    if (NT_SUCCESS( Status )) {

        FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_UNLOCK );
    }

    FatCompleteRequest( IrpContext, Irp, Status );

    DebugTrace(-1, Dbg, "FatUnlockVolume -> %08lx\n", Status);

    return Status;
}


NTSTATUS
FatLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs the actual lock volume operation.  It will be called
    by anyone wishing to try to protect the volume for a long duration.  PNP
    operations are such a user.

    The volume must be held exclusive by the caller.

Arguments:

    Vcb - The volume being locked.

    FileObject - File corresponding to the handle locking the volume.  If this
        is not specified, a system lock is assumed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL SavedIrql;
    ULONG RemainingUserReferences = (FileObject? 1: 0);

    ASSERT( ExIsResourceAcquiredExclusiveLite( &Vcb->Resource ) &&
            !ExIsResourceAcquiredExclusiveLite( &FatData.Resource ));
    //
    //  Go synchronous for the rest of the lock operation.  It may be
    //  reasonable to try to revisit this in the future, but for now
    //  the purge below expects to be able to wait.
    //
    //  We know it is OK to leave the flag up given how we're used at
    //  the moment.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    //
    //  If there are any open handles, this will fail.
    //

    if (!FatIsHandleCountZero( IrpContext, Vcb )) {

        return STATUS_ACCESS_DENIED;
    }

    //
    //  Force Mm to get rid of its referenced file objects.
    //

    FatFlushFat( IrpContext, Vcb );

    FatPurgeReferencedFileObjects( IrpContext, Vcb->RootDcb, Flush );

    FatCloseEaFile( IrpContext, Vcb, TRUE );

    //
    //  Now back out of our synchronization and wait for the lazy writer
    //  to finish off any lazy closes that could have been outstanding.
    //
    //  Since we flushed, we know that the lazy writer will issue all
    //  possible lazy closes in the next tick - if we hadn't, an otherwise
    //  unopened file with a large amount of dirty data could have hung
    //  around for a while as the data trickled out to the disk.
    //
    //  This is even more important now since we send notification to
    //  alert other folks that this style of check is about to happen so
    //  that they can close their handles.  We don't want to enter a fast
    //  race with the lazy writer tearing down his references to the file.
    //

    FatReleaseVcb( IrpContext, Vcb );

    Status = CcWaitForCurrentLazyWriterActivity();

    FatAcquireExclusiveVcb( IrpContext, Vcb );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Now rundown the delayed closes one last time.  We appear to be able
    //  to have additional collisions.
    //

    FatFspClose( Vcb );

    //
    //  Check if the Vcb is already locked, or if the open file count
    //  is greater than 1 (which implies that someone else also is
    //  currently using the volume, or a file on the volume), and that the
    //  VPB reference count only includes our residual and the handle (as
    //  appropriate).
    //
    //  We used to only check for the vpb refcount.  This is unreliable since
    //  the vpb refcount is dropped immediately before final close, meaning
    //  that even though we had a good refcount, the close was inflight and
    //  subsequent operations could get confused.  Especially if the PNP path
    //  was the lock caller, we delete the VCB with an outstanding opencount!
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    if (!FlagOn(Vcb->Vpb->Flags, VPB_LOCKED) &&
        (Vcb->Vpb->ReferenceCount <= 2 + RemainingUserReferences) &&
        (Vcb->OpenFileCount == (CLONG)( FileObject? 1: 0 ))) {

        SetFlag(Vcb->Vpb->Flags, VPB_LOCKED);
        SetFlag(Vcb->VcbState, VCB_STATE_FLAG_LOCKED);
        Vcb->FileObjectWithVcbLocked = FileObject;

    } else {

        Status = STATUS_ACCESS_DENIED;
    }

    IoReleaseVpbSpinLock( SavedIrql );

    //
    //  If we successully locked the volume, see if it is clean now.
    //

    if (NT_SUCCESS( Status ) &&
        FlagOn( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY ) &&
        !FlagOn( Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY ) &&
        !CcIsThereDirtyData(Vcb->Vpb)) {

        FatMarkVolume( IrpContext, Vcb, VolumeClean );
        ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY );
    }

    ASSERT( !NT_SUCCESS(Status) || (Vcb->OpenFileCount == (CLONG)( FileObject? 1: 0 )));

    return Status;
}


NTSTATUS
FatUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs the actual unlock volume operation.

    The volume must be held exclusive by the caller.

Arguments:

    Vcb - The volume being locked.

    FileObject - File corresponding to the handle locking the volume.  If this
        is not specified, a system lock is assumed.

Return Value:

    NTSTATUS - The return status for the operation

    Attempting to remove a system lock that did not exist is OK.

--*/

{
    KIRQL SavedIrql;
    NTSTATUS Status = STATUS_NOT_LOCKED;

    IoAcquireVpbSpinLock( &SavedIrql );

    if (FlagOn(Vcb->Vpb->Flags, VPB_LOCKED) && FileObject == Vcb->FileObjectWithVcbLocked) {

        //
        //  This one locked it, unlock the volume
        //

        ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED );
        ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_LOCKED );
        Vcb->FileObjectWithVcbLocked = NULL;

        Status = STATUS_SUCCESS;
    }

    IoReleaseVpbSpinLock( SavedIrql );

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the dismount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;
    BOOLEAN VcbHeld = FALSE;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatDismountVolume...\n", 0);

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens on media that is not boot/paging and is not
    //  already dismounted ... (but we need to check that stuff while
    //  synchronized)
    //

    if (FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb ) != UserVolumeOpen) {

        Status = STATUS_INVALID_PARAMETER;
        goto fn_return;
    }

    if ((Ccb == NULL) || !FlagOn( Ccb->Flags, CCB_FLAG_MANAGE_VOLUME_ACCESS )) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatDismountVolume -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make some unsynchronized checks to see if this operation is possible.
    //  We will repeat the appropriate ones inside synchronization, but it is
    //  good to avoid bogus notifications.
    //

    if (FlagOn( Vcb->VcbState, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE )) {

        Status = STATUS_ACCESS_DENIED;
        goto fn_return;
    }

    if (FlagOn( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DISMOUNTED )) {

        Status = STATUS_VOLUME_DISMOUNTED;
        goto fn_return;
    }

    //
    //  A bit of historical comment is in order.
    //
    //  In all versions prior to NT5, we only permitted dismount if the volume had
    //  previously been locked.  Now we must permit a forced dismount, meaning that
    //  we grab ahold of the whole kit-n-kaboodle - regardless of activity, open
    //  handles, etc. - to flush and invalidate the volume.
    //
    //  Previously, dismount assumed that lock had come along earlier and done some
    //  of the work that we are now going to do - i.e., flush, tear down the eas. All
    //  we had to do here is flush the device out and kill off as many of the orphan
    //  fcbs as possible. This now changes.
    //
    //  In fact, everything is a forced dismount now. This changes one interesting
    //  aspect, which is that it used to be the case that the handle used to dismount
    //  could come back, read, and induce a verify/remount. This is just not possible
    //  now.  The point of forced dismount is that very shortly someone will come along
    //  and be destructive to the possibility of using the media further - format, eject,
    //  etc.  By using this path, callers are expected to tolerate the consequences.
    //
    //  Note that the volume can still be successfully unlocked by this handle.
    //

    //
    //  Send notification.
    //

    FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_DISMOUNT );

    //
    //  Force ourselves to wait and grab everything.
    //

    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    (VOID)FatAcquireExclusiveGlobal( IrpContext );

    try {

        //
        //  Guess what? This can raise if a cleanup on the fileobject we
        //  got races in ahead of us.
        //

        FatAcquireExclusiveVolume( IrpContext, Vcb );
        VcbHeld = TRUE;

        if (FlagOn( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DISMOUNTED )) {

            try_return( Status = STATUS_VOLUME_DISMOUNTED );
        }

        FatFlushAndCleanVolume( IrpContext, Irp, Vcb, FlushAndInvalidate );

        //
        //  We defer the physical dismount until this handle is closed, per symmetric
        //  implemntation in the other FS. This permits a dismounter to issue IOCTL
        //  through this handle and perform device manipulation without racing with
        //  creates attempting to mount the volume again.
        //
        //  Raise a flag to tell the cleanup path to complete the dismount.
        //

        SetFlag( Ccb->Flags, CCB_FLAG_COMPLETE_DISMOUNT );

        //
        //  Indicate that the volume was dismounted so that we may return the
        //  correct error code when operations are attempted via open handles.
        //

        Vcb->VcbCondition = VcbBad;
        SetFlag( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DISMOUNTED );

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;

    } finally {

        if (VcbHeld) {

            FatReleaseVolume( IrpContext, Vcb );
        }

        FatReleaseGlobal( IrpContext );

        //
        //  I do not believe it is possible to raise, but for completeness
        //  notice and send notification of failure.  We absolutely
        //  cannot have raised in CheckForDismount.
        //
        //  We decline to call an attempt to dismount a dismounted volume
        //  a failure to do so.
        //

        if ((!NT_SUCCESS( Status ) && Status != STATUS_VOLUME_DISMOUNTED)
            || AbnormalTermination()) {

            FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_DISMOUNT_FAILED );
        }
    }

    fn_return:

    FatCompleteRequest( IrpContext, Irp, Status );
    DebugTrace(-1, Dbg, "FatDismountVolume -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatDirtyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine marks the volume as dirty.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatDirtyVolume...\n", 0);

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb ) != UserVolumeOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatDirtyVolume -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    if ((Ccb == NULL) || !FlagOn( Ccb->Flags, CCB_FLAG_MANAGE_VOLUME_ACCESS )) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatDirtyVolume -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }


    //
    //  Disable popups, we will just return any error.
    //

    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS);

    //
    //  Verify the Vcb.  We want to make sure we don't dirty some
    //  random chunk of media that happens to be in the drive now.
    //

    FatVerifyVcb( IrpContext, Vcb );

    SetFlag( Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY );

    FatMarkVolume( IrpContext, Vcb, VolumeDirty );

    FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    DebugTrace(-1, Dbg, "FatDirtyVolume -> STATUS_SUCCESS\n", 0);

    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

NTSTATUS
FatIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a volume is currently dirty.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PULONG VolumeState;

    //
    //  Get the current stack location and extract the output
    //  buffer information.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.  Look at the system buffer field in the
    //  irp first.  Then the Irp Mdl.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        VolumeState = Irp->AssociatedIrp.SystemBuffer;

    } else if (Irp->MdlAddress != NULL) {

        VolumeState = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, LowPagePriority );

        if (VolumeState == NULL) {

            FatCompleteRequest( IrpContext, Irp, STATUS_INSUFFICIENT_RESOURCES );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough and then initialize
    //  the answer to be that the volume isn't dirty.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(ULONG)) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    *VolumeState = 0;

    //
    //  Decode the file object
    //

    TypeOfOpen = FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb );

    if (TypeOfOpen != UserVolumeOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (Vcb->VcbCondition != VcbGood) {

        FatCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Disable PopUps, we want to return any error.
    //

    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS);

    //
    //  Verify the Vcb.  We want to make double sure that this volume
    //  is around so that we know our information is good.
    //

    FatVerifyVcb( IrpContext, Vcb );

    //
    //  Now set the returned information.  We can avoid probing the disk since
    //  we know our internal state is in sync.
    //

    if ( FlagOn(Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY | VCB_STATE_FLAG_MOUNTED_DIRTY) ) {

        SetFlag( *VolumeState, VOLUME_IS_DIRTY );
    }

    Irp->IoStatus.Information = sizeof( ULONG );

    FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

NTSTATUS
FatIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a volume is currently mounted.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb = NULL;
    PFCB Fcb;
    PCCB Ccb;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    Status = STATUS_SUCCESS;

    DebugTrace(+1, Dbg, "FatIsVolumeMounted...\n", 0);

    //
    //  Decode the file object.
    //

    (VOID)FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb );

    ASSERT( Vcb != NULL );

    //
    //  Disable PopUps, we want to return any error.
    //

    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS);

    //
    //  Verify the Vcb.
    //

    FatVerifyVcb( IrpContext, Vcb );

    FatCompleteRequest( IrpContext, Irp, Status );

    DebugTrace(-1, Dbg, "FatIsVolumeMounted -> %08lx\n", Status);

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatIsPathnameValid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a pathname is a-priori illegal by inspecting
    the the characters used.  It is required to be correct on a FALSE return.

    N.B.: current implementation is intentioanlly a no-op.  This may change
    in the future.  A careful reader of the previous implementation of this
    FSCTL in FAT would discover that it violated the requirement stated above
    and could return FALSE for a valid (createable) pathname.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    DebugTrace(+1, Dbg, "FatIsPathnameValid...\n", 0);

    FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    DebugTrace(-1, Dbg, "FatIsPathnameValid -> %08lx\n", STATUS_SUCCESS);

    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

NTSTATUS
FatQueryBpb (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine simply returns the first 0x24 bytes of sector 0.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;

    PFSCTL_QUERY_FAT_BPB_BUFFER BpbBuffer;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatQueryBpb...\n", 0);

    //
    //  Get the Vcb.  If we didn't keep the information needed for this call,
    //  we had a reason ...
    //

    Vcb = &((PVOLUME_DEVICE_OBJECT)IrpSp->DeviceObject)->Vcb;

    if (Vcb->First0x24BytesOfBootSector == NULL) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        DebugTrace(-1, Dbg, "FatQueryBpb -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Extract the buffer
    //

    BpbBuffer = (PFSCTL_QUERY_FAT_BPB_BUFFER)Irp->AssociatedIrp.SystemBuffer;

    //
    //  Make sure the buffer is big enough.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < 0x24) {

        FatCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        DebugTrace(-1, Dbg, "FatQueryBpb -> %08lx\n", STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Fill in the output buffer
    //

    RtlCopyMemory( BpbBuffer->First0x24BytesOfBootSector,
                   Vcb->First0x24BytesOfBootSector,
                   0x24 );

    Irp->IoStatus.Information = 0x24;

    FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    DebugTrace(-1, Dbg, "FatQueryBpb -> %08lx\n", STATUS_SUCCESS);
    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

NTSTATUS
FatInvalidateVolumes (
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine searches for all the volumes mounted on the same real device
    of the current DASD handle, and marks them all bad.  The only operation
    that can be done on such handles is cleanup and close.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    IRP_CONTEXT IrpContext;
    PIO_STACK_LOCATION IrpSp;

    LUID TcbPrivilege = {SE_TCB_PRIVILEGE, 0};

    HANDLE Handle;

    PLIST_ENTRY Links;

    PFILE_OBJECT FileToMarkBad;
    PDEVICE_OBJECT DeviceToMarkBad;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatInva