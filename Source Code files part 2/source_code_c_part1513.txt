SULT STDMETHODCALLTYPE getTexture( 
        //    /* [retval][out] */ I_dxj_Direct3dTexture7 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getUniquenessValue( 
            /* [retval][out] */ long __RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE isLost( 
            /* [retval][out] */ long __RPC_FAR *status);
        
        HRESULT STDMETHODCALLTYPE lock( 
            /* [in] */ Rect __RPC_FAR *r,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *desc,
            /* [in] */ long flags,
            /* [in] */ Handle hnd);
        
        HRESULT STDMETHODCALLTYPE releaseDC( 
            /* [in] */ long hdc);
        
        HRESULT STDMETHODCALLTYPE restore( void);
        
        HRESULT STDMETHODCALLTYPE setClipper( 
            /* [in] */ I_dxj_DirectDrawClipper __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setColorKey( 
            /* [in] */ long flags,
            /* [in] */ DDColorKey __RPC_FAR *val);
        
        HRESULT STDMETHODCALLTYPE setDrawStyle( 
            /* [in] */ long drawStyle);
        
        HRESULT STDMETHODCALLTYPE setDrawWidth( 
            /* [in] */ long drawWidth);
        
        HRESULT STDMETHODCALLTYPE setFillColor( 
            /* [in] */ long color);
        
        HRESULT STDMETHODCALLTYPE setFillStyle( 
            /* [in] */ long fillStyle);
        
        HRESULT STDMETHODCALLTYPE setFont( 
            /* [in] */ IFont __RPC_FAR *font);
        
        HRESULT STDMETHODCALLTYPE setFontTransparency( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setForeColor( 
            /* [in] */ long color);
        
        HRESULT STDMETHODCALLTYPE setLockedPixel( 
            /* [in] */ int x,
            /* [in] */ int y,
            /* [in] */ long col);
                
        HRESULT STDMETHODCALLTYPE setPalette( 
            /* [in] */ I_dxj_DirectDrawPalette __RPC_FAR *ddp);
        
        HRESULT STDMETHODCALLTYPE unlock( 
            /* [in] */ Rect __RPC_FAR *r);

		HRESULT STDMETHODCALLTYPE setPriority( long pri);
		HRESULT STDMETHODCALLTYPE getPriority( long *pri);

		HRESULT STDMETHODCALLTYPE setLOD( long lod);
		HRESULT STDMETHODCALLTYPE getLOD( long *lod);


		HRESULT STDMETHODCALLTYPE getLockedArray(SAFEARRAY **pArray);

        HRESULT STDMETHODCALLTYPE setFontBackColor( 
            /* [in] */ long color);

		HRESULT STDMETHODCALLTYPE getFontBackColor( 
            /* [out,retval] */ long *color);

		/* [helpcontext] */ HRESULT STDMETHODCALLTYPE updateOverlay( 
            /* [in] */ Rect __RPC_FAR *rect,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
            /* [in] */ Rect __RPC_FAR *rectD,
            /* [in] */ long flags);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE updateOverlayZOrder( 
            /* [in] */ long flags,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getOverlayPosition( 
            /* [out][in] */ long __RPC_FAR *x,
            /* [out][in] */ long __RPC_FAR *y);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setOverlayPosition( 
            /* [in] */ long x,
            /* [in] */ long y);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getOverlayZOrdersEnum( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectDrawEnumSurfaces __RPC_FAR *__RPC_FAR *retval) ;

		/* [helpcontext] */ HRESULT STDMETHODCALLTYPE updateOverlayFx( 
            /* [in] */ Rect __RPC_FAR *rect,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
            /* [in] */ Rect __RPC_FAR *rectD,
            /* [in] */ long flags,
			/* [in,out] */ DDOVERLAYFX_CDESC *desc);
			

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectDrawSurface7);
	//BOOL m_primaryflag;

private:
	C_dxj_DirectDrawSurface7Object *_dxj_DirectDrawSurface7Lock;


	DDSURFACEDESC2	m_ddsd;
	BOOL			m_bLocked;
	int				m_nPixelBytes;

	BOOL	m_fFontTransparent;
	BOOL	m_fFillSolid;
	BOOL	m_fFillTransparent;
	DWORD	m_fillStyle;
	DWORD	m_fillStyleHS;
	DWORD	m_fillColor;
	DWORD	m_foreColor;
	DWORD	m_fontBackColor;
	DWORD	m_drawStyle;
	DWORD	m_drawWidth;
	HPEN	m_hPen;
	HBRUSH	m_hBrush;
	HFONT	m_hFont;
	IFont	*m_pIFont;
	SAFEARRAY **m_ppSA;
	BOOL	m_bLockedArray;
	SAFEARRAY m_saLockedArray;
	DWORD	m_pad[4];
	
	

//pac

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectDrawSurface7)
};


// 
// Copies values from native unions into redundant Java members.
void 	ExpandDDSurface4Desc(LPDDSURFACEDESC lpDesc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\didevinstobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevinstobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "diDevInstObj.h"


extern BSTR GUIDtoBSTR(LPGUID g);

extern BSTR DINPUTGUIDtoBSTR(LPGUID g);
       
	

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getGuidInstance( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&m_inst.guidInstance);
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getGuidProduct( BSTR __RPC_FAR *ret){
	*ret=GUIDtoBSTR( &(m_inst.guidProduct));
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getGuidFFDriver( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&(m_inst.guidFFDriver));
	return S_OK;
}
        
        
//USES_CONVERSION;

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getProductName( BSTR __RPC_FAR *ret){
	*ret=T2BSTR(m_inst.tszProductName);		
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getInstanceName( BSTR __RPC_FAR *ret){
	*ret=T2BSTR(m_inst.tszInstanceName);		
	return S_OK;
}

        

        
STDMETHODIMP C_dxj_DIDeviceInstanceObject::getUsagePage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsagePage;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getUsage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsage;
	return S_OK;
}
        

STDMETHODIMP C_dxj_DIDeviceInstanceObject::getDevType( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwDevType;
	return S_OK;
}        
        
C_dxj_DIDeviceInstanceObject::C_dxj_DIDeviceInstanceObject()
{	
	ZeroMemory(&m_inst,sizeof(DIDEVICEINSTANCE));
}

void C_dxj_DIDeviceInstanceObject::init(DIDEVICEINSTANCE *inst)
{
	memcpy(&m_inst,inst,sizeof(DIDEVICEINSTANCE));
}

HRESULT C_dxj_DIDeviceInstanceObject::create(DIDEVICEINSTANCE *inst,I_dxj_DirectInputDeviceInstance **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;

	C_dxj_DIDeviceInstanceObject *c=NULL;
	c=new CComObject<C_dxj_DIDeviceInstanceObject>;
	c->init(inst);

	if( c == NULL ) return E_FAIL;
	hr=c->QueryInterface(IID_I_dxj_DirectInputDeviceInstance, (void**)ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\didevinstobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevinstobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DIDeviceInstanceObject :
		public I_dxj_DirectInputDeviceInstance,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DIDeviceInstanceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectInputDeviceInstance)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DIDeviceInstanceObject)

public:
	C_dxj_DIDeviceInstanceObject();	
  

        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidInstance( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidProduct( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
		/* [propget] */ HRESULT STDMETHODCALLTYPE getProductName( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getInstanceName( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidFFDriver( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUsagePage( 
            /* [retval][out] */ short __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUsage( 
            /* [retval][out] */ short __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getDevType( 
            /* [retval][out] */ long __RPC_FAR *ret);

		void init(DIDEVICEINSTANCE *inst);
		static HRESULT C_dxj_DIDeviceInstanceObject::create(DIDEVICEINSTANCE  *inst,I_dxj_DirectInputDeviceInstance **ret);


private:
		DIDEVICEINSTANCE m_inst;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\ddsurface7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddsurface7obj.cpp
//
//--------------------------------------------------------------------------

    // ddSurfaceObj.cpp : Implementation of CDirectApp and DLL registration.
    #include "stdafx.h"
    #include "stdio.h"
    #include "Direct.h"
    #include "dms.h"
    #include "dDraw7Obj.h"
    #include "ddClipperObj.h"    
    #include "ddGammaControlObj.h"
    #include "ddColorControlObj.h"
    #include "ddSurface7Obj.h"
    #include "ddPaletteObj.h"
    #include "DDEnumSurfacesObj.h"
    
	

    
    
    
    C_dxj_DirectDrawSurface7Object::C_dxj_DirectDrawSurface7Object(){ 
    	m__dxj_DirectDrawSurface7= NULL;
    	parent = NULL;
    	pinterface = NULL; 
    	nextobj =  g_dxj_DirectDrawSurface7;
    	creationid = ++g_creationcount;
    
	DPF1(1,"Constructor Creation Surface7 [%d] \n",g_creationcount);
    
    	g_dxj_DirectDrawSurface7 = (void *)this; 
    	_dxj_DirectDrawSurface7Lock=NULL; 
    
    	m_bLocked=FALSE;
    
    	m_drawStyle = 0;	//solid lines are default for DDraw
    	m_fillStyle = 1;	//transparent fill is default since DDRaw has no selected Brush
    	m_fFontTransparent = TRUE;
    	m_fFillTransparent = TRUE;
    	m_fFillSolid=TRUE;
    	m_foreColor = 0;	//black is the default color.
		m_fontBackColor=-1;	//white is the default fill color
    	m_drawWidth = 1;
    	m_hPen = NULL; 
    	m_hBrush = NULL;
    	m_hFont=NULL;
	  	m_pIFont=NULL;
		m_bLockedArray=FALSE;
		m_ppSA=NULL;

		setFillStyle(1);	//transparent
     }
    
    
    DWORD C_dxj_DirectDrawSurface7Object::InternalAddRef(){
    	DWORD i;
    	i=CComObjectRoot::InternalAddRef();        	
    	DPF2(1,"Surf7 [%d] AddRef %d \n",creationid,i);
    	return i;
    }
    
    DWORD C_dxj_DirectDrawSurface7Object::InternalRelease(){
    	DWORD i;
    	i=CComObjectRoot::InternalRelease();
    	DPF2(1,"Surf7 [%d] Release %d \n",creationid,i);
    	return i;
    }
    
    
    C_dxj_DirectDrawSurface7Object::~C_dxj_DirectDrawSurface7Object()
    {

		
        C_dxj_DirectDrawSurface7Object *prev=NULL; 
    	for(C_dxj_DirectDrawSurface7Object *ptr=(C_dxj_DirectDrawSurface7Object *)g_dxj_DirectDrawSurface7; ptr; ptr=(C_dxj_DirectDrawSurface7Object *)ptr->nextobj) 
    	{
    		if(ptr == this) 
    		{ 
    			if(prev) 
    				prev->nextobj = ptr->nextobj; 
    			else 
     				g_dxj_DirectDrawSurface7 = (void*)ptr->nextobj; 
    			break; 
    		} 
    		prev = ptr; 
    	} 
    	if(m__dxj_DirectDrawSurface7){
    		int count = IUNK(m__dxj_DirectDrawSurface7)->Release();
    		
    		DPF1(1,"DirectX IDirectDrawSurface7 Ref count [%d]",count);
    
    		if(count==0) m__dxj_DirectDrawSurface7 = NULL;
    	} 
    	if(parent) IUNK(parent)->Release();
    
    
    	 
        if (m_hFont)  DeleteObject (m_hFont);
        if (m_hPen)   DeleteObject (m_hPen);
        if (m_hBrush) DeleteObject (m_hBrush);
	  	if (m_pIFont) m_pIFont->Release();
    
    }
    
    
    
    GETSET_OBJECT(_dxj_DirectDrawSurface7);
    
    RETURN_NEW_ITEM_R(_dxj_DirectDrawSurface7, getPalette, GetPalette, _dxj_DirectDrawPalette)
    
    GET_DIRECT_R(_dxj_DirectDrawSurface7,  isLost, IsLost, long)
    GET_DIRECT1_R(_dxj_DirectDrawSurface7, getBltStatus,  GetBltStatus,  long, long)
    GET_DIRECT1_R(_dxj_DirectDrawSurface7, getFlipStatus, GetFlipStatus, long, long)
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::addAttachedSurface(I_dxj_DirectDrawSurface7 *s3)
    {
    	HRESULT hr;	
    
    	IDirectDrawSurface7 *realsurf=NULL;
    	if (s3) s3->InternalGetObject((IUnknown**)&realsurf);
    
    	if (m__dxj_DirectDrawSurface7 == NULL) return E_FAIL;
    	hr=m__dxj_DirectDrawSurface7->AddAttachedSurface(realsurf);
    	
    	return hr;
    }
    
    
    
    

    
    //PASS_THROUGH1_R(_dxj_DirectDrawSurface7, pageLock,   PageLock,  long)
    //PASS_THROUGH1_R(_dxj_DirectDrawSurface7, pageUnlock, PageUnlock,long)
    
    
    
    PASS_THROUGH_CAST_1_R(_dxj_DirectDrawSurface7,releaseDC,ReleaseDC,long,(HDC ))
    PASS_THROUGH_CAST_2_R(_dxj_DirectDrawSurface7,setColorKey,SetColorKey,long,(long),DDColorKey *,(LPDDCOLORKEY))
    PASS_THROUGH_CAST_2_R(_dxj_DirectDrawSurface7,getColorKey,GetColorKey,long,(long),DDColorKey *,(LPDDCOLORKEY))
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getDC(long *hdc)
    {	
          return m__dxj_DirectDrawSurface7->GetDC((HDC*)hdc);
    }
    
    
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::lock(  Rect *r,  DDSurfaceDesc2 *desc,  long flags,  Handle hnd)
    {
    	if (m_bLocked) return E_FAIL;
    	
    	HRESULT hr;
    
    	CopyInDDSurfaceDesc2(&m_ddsd,desc);
		hr = m__dxj_DirectDrawSurface7->Lock(NULL,&m_ddsd,(DWORD)flags,(void*)hnd);
    	if FAILED(hr) return hr;
        
     	CopyOutDDSurfaceDesc2(desc,&m_ddsd);
    
    
    	m_bLocked=TRUE;
    	m_nPixelBytes=m_ddsd.ddpfPixelFormat.dwRGBBitCount/8; 
    	return hr;
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::unlock(  Rect *r)
    {
    	HRESULT hr;
		if (m_bLockedArray) {				
			*m_ppSA=NULL;
			m_bLockedArray=FALSE;			
		}
		

		hr = m__dxj_DirectDrawSurface7->Unlock(NULL);
    
    	if FAILED(hr) return hr	;
    	m_bLocked=FALSE;
    
    	return hr;
    }


    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setLockedPixel( int x,  int y,  long col)
    {
    	if (!m_bLocked) return E_FAIL;
    
    	//__try {
    
    		char *pByte= (char*)((char*)m_ddsd.lpSurface+x*m_nPixelBytes+y*m_ddsd.lPitch);
    
    		if (m_nPixelBytes==2){
    			*((WORD*)pByte)=(WORD)col;	
    		}
    		else if (m_nPixelBytes==4){
    			*((DWORD*)pByte)=(DWORD)col;	
    		}
    		else if (m_nPixelBytes==1){
    			*pByte=(Byte)col;
    		}
    		else if (m_nPixelBytes==3){				
				*(pByte)= (char)(col & 0xFF);
				pByte++;
				*(pByte)= (char)((col & 0xFF00)>>8);
				pByte++;
    			*(pByte)= (char)((col & 0xFF0000)>>16);
    		}

    		else{
    			return E_FAIL;
    		}
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    	return S_OK;
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getLockedPixel( int x,  int y,  long *col)
    {
    	//__try {
    		char *pByte= (char*)((char*)m_ddsd.lpSurface+x*m_nPixelBytes+y*m_ddsd.lPitch);
    
    		if (m_nPixelBytes==2){
    			*col=(long) *((WORD*)pByte);	
    		}
    		else if (m_nPixelBytes==4){
    			*col=(long) *((DWORD*)pByte);	
    		}
	   		else if (m_nPixelBytes==3){
    			*col=(long) (*((DWORD*)pByte))& 0x00FFFFFF;	
    		}
    		else if (m_nPixelBytes==1){
    			*col=(long) *((long*)pByte);
    		}
    		else{
    			return E_FAIL;
    		}
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getClipper( I_dxj_DirectDrawClipper **val)
    {
    	LPDIRECTDRAWCLIPPER		ddc;
    	HRESULT hr=DD_OK;
    	if( (hr=m__dxj_DirectDrawSurface7->GetClipper( &ddc)) != DD_OK )
    		return hr;
    
    	INTERNAL_CREATE(_dxj_DirectDrawClipper, ddc, val);
    
    	return S_OK;
    }
    
    
    
    /////////////////////////////////////////////////////////////////////////////
    // this is NOT the normal Blt, that is BltFx in our interface
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::blt( Rect *pDest, I_dxj_DirectDrawSurface7 *ddS, Rect *pSrc, long flags, long *status)
    {
    	
    	LPDIRECTDRAWSURFACE7 lpdds = NULL;
    	LPRECT				 prcDest=(LPRECT)pDest;
    	LPRECT				 prcSrc =(LPRECT)pSrc;
    	
    	if (!ddS ) return E_INVALIDARG;
		
		ddS->InternalGetObject((IUnknown **)(&lpdds));
    	
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface7->Blt(prcDest, lpdds, prcSrc, flags, NULL);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    											
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::bltFx(Rect *pDest, I_dxj_DirectDrawSurface7 *ddS, Rect *pSrc, long flags, DDBltFx *bltfx, long *status )
    {
    
    	LPRECT				 prcDest=(LPRECT)pDest;
    	LPRECT				 prcSrc= (LPRECT)pSrc;
    	LPDIRECTDRAWSURFACE7 lpdds = NULL;
    
    	if ( !ddS ) return E_INVALIDARG;
		
		ddS->InternalGetObject((IUnknown **)(&lpdds));
    
    	if(bltfx)	bltfx->lSize = sizeof(DDBLTFX);
    
    
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface7->Blt(prcDest, lpdds, prcSrc, flags, (struct _DDBLTFX *)bltfx);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    	
    	return S_OK;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::bltColorFill( Rect *pDest, long fillvalue, long *status )
    {
    	HWnd hWnd = NULL;
    
    	DDBLTFX bltfx;
    
    	memset(&bltfx,0,sizeof(DDBLTFX));
    	bltfx.dwSize = sizeof(DDBLTFX);
    	bltfx.dwFillColor = (DWORD)fillvalue;
    
    
    	LPRECT prcDest=(LPRECT)pDest;
    
    	//allow user to pass uninitialed structure down to represent bitting to the whole surface
    	if ((prcDest) && (!prcDest->left) && (!prcDest->right) && (!prcDest->bottom) && (!prcDest->top))
    		prcDest=NULL;
    
    
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface7->Blt(prcDest, NULL, NULL, DDBLT_WAIT | DDBLT_COLORFILL, &bltfx);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::bltFast( long dx, long dy, I_dxj_DirectDrawSurface7 *dds, Rect *src, long trans, long *status)
    {
    
		if (!dds) return E_INVALIDARG;

    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpdds,dds)
    	
    	LPRECT prcSrc=(LPRECT)src;
    
		if (!src) return E_INVALIDARG;

    	//allow user to pass uninitialed structure down to represent bitting from the whole surface
    	if ((prcSrc) && (!prcSrc->left) && (!prcSrc->right) && (!prcSrc->bottom) && (!prcSrc->top))
    		prcSrc=NULL;
    	
    
    	//__try {
    		*status = m__dxj_DirectDrawSurface7->BltFast(dx, dy, lpdds, prcSrc, trans);
    	//}
    	//__except(1,1){
    	//	return E_INVALIDARG;
    	//}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::deleteAttachedSurface( I_dxj_DirectDrawSurface7 *dds)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpdds, dds)
    
    	return m__dxj_DirectDrawSurface7->DeleteAttachedSurface(0, lpdds);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::flip( I_dxj_DirectDrawSurface7 *dds, long flags)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpdds,dds)
    
    	return m__dxj_DirectDrawSurface7->Flip(lpdds, flags);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getAttachedSurface( DDSCaps2  *caps, I_dxj_DirectDrawSurface7 **dds)
    {
    	LPDIRECTDRAWSURFACE7 lpdds;	
    	HRESULT hr=DD_OK;
    	
    
    	if( (hr=m__dxj_DirectDrawSurface7->GetAttachedSurface( (DDSCAPS2*)caps, &lpdds)) != S_OK )
    		return hr;
    
    	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpdds, dds);
    
    	return S_OK;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getCaps( DDSCaps2 *caps)
    {
    	
    	HRESULT hr=DD_OK;
    
    	if( (hr=m__dxj_DirectDrawSurface7->GetCaps((DDSCAPS2*)caps)) != S_OK)
    		return hr;
    	
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getPixelFormat( DDPixelFormat *pf)
    {
    	
    	HRESULT hr=DD_OK;
    
    	DDPIXELFORMAT ddpf;
    	ddpf.dwSize = sizeof(DDPIXELFORMAT);
    
    	if( (hr=m__dxj_DirectDrawSurface7->GetPixelFormat(&ddpf)) != S_OK)
    		return hr;
    
    	CopyOutDDPixelFormat(pf,&ddpf);
    
    	
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getSurfaceDesc( DDSurfaceDesc2 *desc)
    {
    	desc->lpSurface = NULL;
    	HRESULT hr=DD_OK;
    
    	DDSURFACEDESC2 ddsd;
    	ddsd.dwSize=sizeof(DDSURFACEDESC2);
    	ddsd.ddpfPixelFormat.dwSize=sizeof(DDPIXELFORMAT);
    	ddsd.lpSurface=NULL;
    
    	if( (hr=m__dxj_DirectDrawSurface7->GetSurfaceDesc( &ddsd )) != S_OK )
    		return hr;
    
    	CopyOutDDSurfaceDesc2(desc,&ddsd);
    		
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::restore()
    {
    	return m__dxj_DirectDrawSurface7->Restore();
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setPalette( I_dxj_DirectDrawPalette *ddp)
    {
    	//
    	// ignore the return value here. Will only work on 256 colours anyway!
    	//
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWPALETTE,lpddp,ddp)
    
    	return m__dxj_DirectDrawSurface7->SetPalette(lpddp);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    //
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getDirectDraw( I_dxj_DirectDraw7 **val)
    {
    
    	IUnknown *pUnk=NULL;
    	LPDIRECTDRAW7 lpdd;
    	HRESULT hr=DD_OK;
    
    
    	if( (hr=m__dxj_DirectDrawSurface7->GetDDInterface((void **)&pUnk)) != S_OK)
    		return hr;
    	
    	hr=pUnk->QueryInterface(IID_IDirectDraw7,(void**)&lpdd);
    	if FAILED(hr) {
    		if (pUnk) pUnk->Release();
    		return hr;
    	}
    
    	INTERNAL_CREATE(_dxj_DirectDraw7, lpdd, val);
    
    	return S_OK;
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setClipper(I_dxj_DirectDrawClipper *val)
    {
    	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWCLIPPER, lpc, val);
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface7->SetClipper( lpc);
    	return hr;	
    }

    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::changeUniquenessValue()
    {	
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface7->ChangeUniquenessValue();	
    	return hr;
    }
    /////////////////////////////////////////////////////////////////////////////
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getUniquenessValue(long *ret)
    {	
    	HRESULT hr=DD_OK;
    	hr=m__dxj_DirectDrawSurface7->GetUniquenessValue((DWORD*)ret);	
    	return hr;
    }
    	 	 			
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getDirectDrawGammaControl(I_dxj_DirectDrawGammaControl **val)
    {
    
    	HRESULT hr;
    	LPDIRECTDRAWGAMMACONTROL lpGamma=NULL;
    	hr=m__dxj_DirectDrawSurface7->QueryInterface(IID_IDirectDrawGammaControl,(void **)&lpGamma);
    	if FAILED(hr) return hr;
    	INTERNAL_CREATE(_dxj_DirectDrawGammaControl,lpGamma,val);
    	if (*val==NULL) return E_OUTOFMEMORY;
    	return hr;
    	
    
    }
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getDirectDrawColorControl(I_dxj_DirectDrawColorControl **val)
    {
    
    	HRESULT hr;
    	LPDIRECTDRAWCOLORCONTROL lpCC=NULL;
    	hr=m__dxj_DirectDrawSurface7->QueryInterface(IID_IDirectDrawColorControl,(void **)&lpCC);
    	if FAILED(hr) return hr;
    	INTERNAL_CREATE(_dxj_DirectDrawColorControl,lpCC,val);
    	if (*val==NULL) return E_OUTOFMEMORY;
    	return hr;
    	
    
    }
    
    
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setFont( 
                /* [in] */ IFont __RPC_FAR *font)
    {
    
  	HRESULT hr;
    	if (!font) return E_INVALIDARG;
  	if (m_pIFont) m_pIFont->Release();
  	m_pIFont=NULL;
  	hr=font->Clone(&m_pIFont);
  	return hr;
  	   	
    }
    
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setFontTransparency(VARIANT_BOOL b)
    {
    	m_fFontTransparent=(b!=VARIANT_FALSE);
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getFontTransparency(VARIANT_BOOL *b)
    {
    	if (m_fFontTransparent) 
    		*b= VARIANT_TRUE;
    	else 
    		*b= VARIANT_FALSE;
    	return S_OK;
    }
    
    
          
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setDrawWidth(  long drawWidth)
    {	
                HPEN hNewPen=NULL;
    		if (drawWidth < 1) return E_INVALIDARG;
    		m_drawWidth=drawWidth;		
    		hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    		if (!hNewPen) return E_INVALIDARG;
    		DeleteObject(m_hPen);    
    		m_hPen=hNewPen;
    		return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getDrawWidth(long *val)
    {
    	*val=m_drawWidth;
    	return S_OK;
    }
    
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setDrawStyle(long drawStyle)
    {
    
        HPEN hNewPen=NULL;     
    	m_drawStyle=drawStyle;		
    	hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    	if (!hNewPen) return E_INVALIDARG;
    	DeleteObject(m_hPen);    
    	m_hPen=hNewPen;
    	return S_OK;
    }	
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getDrawStyle(long __RPC_FAR *val)
    {
    	*val=m_drawStyle;
    	return S_OK;
    }
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setFillStyle(long fillStyle)
    {
    	
        HBRUSH hNewBrush=NULL;
    
    	
		BOOL fillTransparent =m_fFillTransparent;
		BOOL fillSolid=m_fFillSolid;
		long fillStyle2=fillStyle;

		m_fillStyle = fillStyle;    
    	m_fFillTransparent = FALSE;
    	m_fFillSolid = FALSE;

    	switch(fillStyle){
    		case 6:	//vbCross:
    			m_fillStyleHS = HS_CROSS;
    			break;
    		case 7:	//vbDiagonalCross:
    			m_fillStyleHS = HS_DIAGCROSS;
    			break;
    		case 5: //vbxDownwardDiagonal:
    			m_fillStyleHS = HS_BDIAGONAL;
    			break;
    		case 2: //vbHorizontalLine:
    			m_fillStyleHS = HS_HORIZONTAL;
    			break;
    		case 4: //vbUpwardDiagonal:
    			m_fillStyleHS = HS_FDIAGONAL;
    			break;
    		case 3: //vbVerticalLine:
    			m_fillStyleHS = HS_VERTICAL;
    			break;
    		case 0: ///vbFSSolid:
    			m_fFillSolid = TRUE;
    			break;
    		case 1: //vbFSTransparent:
    			m_fFillTransparent = TRUE;
    			m_fFillSolid = TRUE;
				break;
    		default:
				m_fFillTransparent = fillTransparent;
    			m_fFillSolid = fillSolid;
				m_fillStyle=fillStyle2;
    			return E_INVALIDARG;
    	}
    
    
    	if (m_fFillTransparent) {
    		LOGBRUSH logb;
    		logb.lbStyle = BS_NULL;
    		hNewBrush = CreateBrushIndirect(&logb);
    	}
    	else if (m_fFillSolid) {
    		hNewBrush = CreateSolidBrush(m_fillColor);
    	}
    	else {
    		hNewBrush = CreateHatchBrush(m_fillStyleHS, m_fillColor);
    	}
    	if (!hNewBrush) return E_FAIL;
    
    	if (m_hBrush) DeleteObject(m_hBrush);
    	m_hBrush=hNewBrush;
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getFillStyle(long *val)
    {
    	*val=m_fillStyle;
    	return S_OK;
    }
    
    	
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setFillColor(long c)
    {   
    	m_fillColor = c;
        HBRUSH  hNewBrush;
    
    	if (m_fFillSolid){
    		hNewBrush= CreateSolidBrush(m_fillColor);
    	}
    	else {
    		hNewBrush= CreateHatchBrush(m_fillStyleHS, m_fillColor);
    	}
        
    	if (!hNewBrush) return E_INVALIDARG;
  	if (m_hBrush) DeleteObject(m_hBrush);
    	m_hBrush=hNewBrush;
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getFillColor(long *val)
    {
    	*val=m_fillColor;
    	return S_OK;
    }
    
            
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setForeColor(  long color)
    {
    	m_foreColor=color;
        HPEN hNewPen=NULL;
                    
        
        hNewPen = CreatePen(m_drawStyle, m_drawWidth, m_foreColor);
    	if (!hNewPen) return E_INVALIDARG;
        if (m_hPen)  DeleteObject (m_hPen);
    	m_hPen=hNewPen;
    	return S_OK;
    }
    
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getForeColor(long *val)
    {
    	*val=m_foreColor;
    	return S_OK;
    }
    
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawLine( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
    	POINT points[2];
        HRESULT hr;
    
        hr =m__dxj_DirectDrawSurface7->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        points[0].x = x1;
        points[0].y = y1;
        
        
        points[1].x = x2;
        points[1].y = y2;
        
    	
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);
    
		
        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);    		 
        }

        Polyline(hdc, points, 2);
        
    	//why do this..
        //if (oldpen)   SelectObject(hdc, oldpen);
        //if (oldbrush) SelectObject(hdc, oldbrush);
            
        m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
        
    	return S_OK;
    }
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawBox( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
        HRESULT hr;
    
        hr= m__dxj_DirectDrawSurface7->GetDC(&hdc);
        if FAILED(hr) return hr;
           
    	
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);

        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);    		 
        }
     
        Rectangle(hdc, x1,y1,x2,y2);
        
            
        m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	return S_OK;
    }
    
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawRoundedBox( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2,
                /* [in] */ long rw,
                /* [in] */ long rh)
    
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;
    	HRESULT hr;
    
        hr= m__dxj_DirectDrawSurface7->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);

        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);    		 
        }
        
        RoundRect(hdc, x1,y1,x2,y2,rw,rh);
                    
        m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	return S_OK;
    }        
        
        
        
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawEllipse( 
                /* [in] */ long x1,
                /* [in] */ long y1,
                /* [in] */ long x2,
                /* [in] */ long y2)
    {
    	
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;

    	HRESULT hr;
    
        hr=m__dxj_DirectDrawSurface7->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);

        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);    		 
        }
        
    	Ellipse(hdc, x1, y1, x2, y2);
                    
        m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	return S_OK;
    }        
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawCircle( 
                /* [in] */ long x,
                /* [in] */ long y,
                /* [in] */ long r)
    {
        HDC         hdc;
        HBRUSH      oldbrush;
        HPEN        oldpen;

    	HRESULT hr;
    	long x1,y1,x2,y2;
    
        hr= m__dxj_DirectDrawSurface7->GetDC(&hdc);
        if FAILED(hr) return hr;
        
        
    	//CONSIDER: doing this when dc is set 
        if (m_hPen)         oldpen = (HPEN)SelectObject(hdc,m_hPen);
        if (m_hBrush)       oldbrush = (HBRUSH)SelectObject(hdc,m_hBrush);        
        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);    		 
        }
            
        x1 = x - r;
        x2 = x + r;
        y1 = y - r;
        y2 = y + r;
    

        Ellipse(hdc, x1, y1, x2, y2);
                    
        m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	return S_OK;
    }
    
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::drawText( 
                /* [in] */ long x,
                /* [in] */ long y,
                /* [in] */ BSTR str,
                /* [in] */ VARIANT_BOOL b)
    {
        HDC hdc=NULL;
    	HRESULT hr;	
    	DWORD len=0;
    	UINT txtA;
    
    	if (!str) return E_INVALIDARG;

  		len = ((DWORD*)str)[-1]/2;
    
        hr=m__dxj_DirectDrawSurface7->GetDC(&hdc);
    	if FAILED(hr) return hr;
    	    	
    
        if (m_fFontTransparent){
             SetBkMode (hdc, TRANSPARENT);

    	}
    	else {    			
			SetBkMode (hdc, OPAQUE);
			SetBkColor (hdc,(COLORREF)m_fontBackColor);
    		 
        }
        
        SetTextColor(hdc, m_foreColor);
        

        
    	txtA=GetTextAlign(hdc);
    	if (b!=VARIANT_FALSE){				
    		if (!(txtA & TA_UPDATECP)) SetTextAlign(hdc,txtA | TA_UPDATECP);
    	}
    	else {		
    		if (txtA & TA_UPDATECP)	SetTextAlign(hdc,txtA-TA_UPDATECP);			
    	}
    	
  	if (m_pIFont) {
  		HFONT hFont=NULL;
  		m_pIFont->SetHdc(hdc);
  	    m_pIFont->get_hFont(&hFont);
  		SelectObject (hdc, hFont);
  	}
  
        ExtTextOutW(hdc, (int)x, (int)y, 0, 0, str, len, 0);
    
    	m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	return S_OK;
    
    }
            
    HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::bltToDC( 
                /* [in] */ long hdcDest,
                /* [in] */ Rect __RPC_FAR *srcRect,
                /* [in] */ Rect __RPC_FAR *destRect)
    {
    	HRESULT hr;
    	BOOL b;
    	HDC		hdc=NULL;
    	
    	if (!srcRect) return E_INVALIDARG;
    	if (!destRect) return E_INVALIDARG;
    
    	hr=m__dxj_DirectDrawSurface7->GetDC(&hdc);
    	if FAILED(hr) return hr;
    
		
    	int nWidthDest= destRect->right-destRect->left;
    	int nHeightDest=destRect->bottom-destRect->top;
    	int nWidthSrc= srcRect->right-srcRect->left;
    	int nHeightSrc=srcRect->bottom-srcRect->top;
    

		if ((0==srcRect->top) && (0==srcRect->left ) && (0==srcRect->top) &&(0==srcRect->bottom ))
		{
			DDSURFACEDESC2 desc;
			desc.dwSize=sizeof(DDSURFACEDESC2);
			m__dxj_DirectDrawSurface7->GetSurfaceDesc(&desc);
			nWidthSrc=desc.dwWidth;
			nHeightSrc=desc.dwHeight;
		}  



    	b=StretchBlt((HDC)hdcDest,
    		destRect->left,destRect->top,
    		nWidthDest, nHeightDest,
    		hdc,
    		srcRect->left,srcRect->top,
    		nWidthSrc, nHeightSrc, SRCCOPY);
      
    
    	m__dxj_DirectDrawSurface7->ReleaseDC(hdc);
    	
    	//CONSIDER: are we being presumptious that if blt fails its due to arg probs?
    	if (!b) return E_INVALIDARG;
    
    	return S_OK;
    
    }

    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getAttachedSurfaceEnum(I_dxj_DirectDrawEnumSurfaces **val)
    {
    
    	HRESULT hr;
    	hr=C_dxj_DirectDrawEnumSurfacesObject::createAttachedEnum((I_dxj_DirectDrawSurface7 *)this,val);
    	return hr;
    
    }

    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setPriority( long Priority)
	{
		return m__dxj_DirectDrawSurface7->SetPriority((DWORD)Priority);

	}

	STDMETHODIMP C_dxj_DirectDrawSurface7Object::getPriority( long *Priority)
	{
		return m__dxj_DirectDrawSurface7->GetPriority((DWORD*)Priority);
	}


    STDMETHODIMP C_dxj_DirectDrawSurface7Object::setLOD( long lod)
	{
		return m__dxj_DirectDrawSurface7->SetLOD((DWORD)lod);
	}

	STDMETHODIMP C_dxj_DirectDrawSurface7Object::getLOD(long *lod)
	{
		return m__dxj_DirectDrawSurface7->GetLOD((DWORD*)lod);

	}

	STDMETHODIMP C_dxj_DirectDrawSurface7Object::getLockedArray(SAFEARRAY **pArray)
	{
		

		if (!m_bLocked) return E_FAIL;
		

		if (!pArray) return E_INVALIDARG;
		if (*pArray) return E_INVALIDARG;
		m_ppSA=pArray;


		m_bLockedArray=TRUE;

		ZeroMemory(&m_saLockedArray,sizeof(SAFEARRAY));
		m_saLockedArray.cbElements =1;
		m_saLockedArray.cDims =2;
		m_saLockedArray.rgsabound[0].lLbound =0;
		m_saLockedArray.rgsabound[0].cElements =m_ddsd.dwHeight;
		m_saLockedArray.rgsabound[1].lLbound =0;
		m_saLockedArray.rgsabound[1].cElements =m_ddsd.lPitch;
		m_saLockedArray.pvData =m_ddsd.lpSurface;

		
		*pArray=&m_saLockedArray;
    
		
    	return S_OK;
	}



	HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::setFontBackColor( 
                /* [in] */ long color)
    {
		m_fontBackColor=(DWORD)color;
    	return S_OK;
    }
    

	HRESULT STDMETHODCALLTYPE C_dxj_DirectDrawSurface7Object::getFontBackColor( 
                /* [in] */ long *color)
    {    	
		if (!color) return E_INVALIDARG;            
        *color=(long)m_fontBackColor;    	                    
    	return S_OK;
    }
    
    		
	

	STDMETHODIMP C_dxj_DirectDrawSurface7Object::updateOverlayZOrder(long flags,I_dxj_DirectDrawSurface7 *dds)
    {
		HRESULT hr;
		DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpdds,dds)
		hr= m__dxj_DirectDrawSurface7->UpdateOverlayZOrder((DWORD)flags,lpdds);
		return hr;
	}

    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getOverlayZOrdersEnum(long flags,I_dxj_DirectDrawEnumSurfaces **val)
    {
    
    	HRESULT hr;
    	hr=C_dxj_DirectDrawEnumSurfacesObject::createZEnum((I_dxj_DirectDrawSurface7*)this,flags,val);
    	return hr;
    
    }
       
    
    STDMETHODIMP C_dxj_DirectDrawSurface7Object::getOverlayPosition( long *x, long *y)
    {   
    	return m__dxj_DirectDrawSurface7->GetOverlayPosition(x, y) ;
    }
    
	STDMETHODIMP C_dxj_DirectDrawSurface7Object::setOverlayPosition( long x, long y)
    {   
    	return m__dxj_DirectDrawSurface7->SetOverlayPosition(x, y) ;
    }
    


    STDMETHODIMP C_dxj_DirectDrawSurface7Object::updateOverlay( Rect *r, I_dxj_DirectDrawSurface7 *dds, Rect *d, long flags)
    {
    	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE7, lpdds, dds)
    
    	LPRECT pr1=NULL;
		LPRECT pr2=NULL;

		if (r) {
			pr1=(RECT*) r;
			if ((r->top==0)&&(r->bottom==0)&&(r->left==0)&&(r->right==0))
				pr1=NULL;
		}

		if (d) {
			pr2=(RECT*) d;
			if ((d->top==0)&&(d->bottom==0)&&(d->left==0)&&(d->right==0))
				pr2=NULL;
		}

		return m__dxj_DirectDrawSurface7->UpdateOverlay(pr1, lpdds, pr2, flags, NULL);
    }
    


    STDMETHODIMP C_dxj_DirectDrawSurface7Object::updateOverlayFx( Rect *r, I_dxj_DirectDrawSurface7 *dds, Rect *d, long flags, DDOVERLAYFX_CDESC *desc)
    {
		if (!desc) return E_INVALIDARG;

		DDOVERLAYFX *lpOverlayFx=(DDOVERLAYFX*)desc;
		

		lpOverlayFx->dwSize =sizeof(DDOVERLAYFX);

    	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE7, lpdds, dds)
    
    	LPRECT pr1=NULL;
		LPRECT pr2=NULL;

		if (r) {
			pr1=(RECT*) r;
			if ((r->top==0)&&(r->bottom==0)&&(r->left==0)&&(r->right==0))
				pr1=NULL;
		}

		if (d) {
			pr2=(RECT*) d;
			if ((d->top==0)&&(d->bottom==0)&&(d->left==0)&&(d->right==0))
				pr2=NULL;
		}

		return m__dxj_DirectDrawSurface7->UpdateOverlay(pr1, lpdds, pr2, flags, lpOverlayFx);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\didevobjinstobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevobjinstobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "diDevObjInstObj.h"


extern BSTR GUIDtoBSTR(LPGUID g);

extern BSTR DINPUTGUIDtoBSTR(LPGUID g);


	
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getGuidType( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&m_inst.guidType);
	return S_OK;
}

        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getOfs(  long __RPC_FAR *ret){
	*ret=(long)m_inst.dwOfs;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getType( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwType;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getFlags( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwFlags;
	return S_OK;
}

//USES_CONVERSION;

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getName( BSTR __RPC_FAR *ret){
	*ret=T2BSTR(m_inst.tszName);		
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getCollectionNumber( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wCollectionNumber;
	return S_OK;
}
        

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getDesignatorIndex( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wDesignatorIndex;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getUsagePage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsagePage;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getUsage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsage;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getExponent( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wExponent;
	return S_OK;
}


STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getDimension( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwDimension;
	return S_OK;
}

        
        
C_dxj_DIDeviceObjectInstanceObject::C_dxj_DIDeviceObjectInstanceObject()
{	
	ZeroMemory(&m_inst,sizeof(DIDEVICEOBJECTINSTANCE));
}

void C_dxj_DIDeviceObjectInstanceObject::init(DIDEVICEOBJECTINSTANCE *inst)
{
	memcpy(&m_inst,inst,sizeof(DIDEVICEOBJECTINSTANCE));
}

HRESULT C_dxj_DIDeviceObjectInstanceObject::create(DIDEVICEOBJECTINSTANCE *inst,I_dxj_DirectInputDeviceObjectInstance **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;

	C_dxj_DIDeviceObjectInstanceObject *c=NULL;
	c=new CComObject<C_dxj_DIDeviceObjectInstanceObject>;
	if( c == NULL ) return E_FAIL;
	c->init(inst);
	hr=c->QueryInterface(IID_I_dxj_DirectInputDeviceObjectInstance, (void**)ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\didevobjinstobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevobjinstobj.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_dxj_DIDeviceObjectInstanceObject :
		public I_dxj_DirectInputDeviceObjectInstance,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DIDeviceObjectInstanceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectInputDeviceObjectInstance)
	END_COM_MAP()

//	DECLARE_REGISTRY(CLSID_DPLConnection, "DIRECT.DPLConnection.5",		"DIRECT.DPLConnection.5",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)
	DECLARE_AGGREGATABLE(C_dxj_DIDeviceObjectInstanceObject)

public:
	C_dxj_DIDeviceObjectInstanceObject();	


	/* [propget] */ HRESULT STDMETHODCALLTYPE getGuidType( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getOfs( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getType( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getFlags( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getName( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getCollectionNumber( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getDesignatorIndex( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getUsagePage( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getUsage( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getDimension( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getExponent( 
		/* [retval][out] */ short __RPC_FAR *ret);

  
		static HRESULT C_dxj_DIDeviceObjectInstanceObject::create(DIDEVICEOBJECTINSTANCE *inst,I_dxj_DirectInputDeviceObjectInstance **ret);

		void init(DIDEVICEOBJECTINSTANCE *inst);
private:
		DIDEVICEOBJECTINSTANCE m_inst;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dienumdeviceobjectsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dienumdeviceobjectsobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DIEnumDeviceObjectsObj.h"
#include "didevObjInstOBj.h"

extern BSTR DINPUTGUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL CALLBACK DIEnumDeviceObjectsProc(
  LPCDIDEVICEOBJECTINSTANCE lpddoi,  
  LPVOID lpArg                       
  )
{
 
	if (!lpddoi) return FALSE;

	C_dxj_DIEnumDeviceObjectsObject *pObj=(C_dxj_DIEnumDeviceObjectsObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList){
			pObj->m_pList=(DIDEVICEOBJECTINSTANCE *)realloc(pObj->m_pList,sizeof(DIDEVICEOBJECTINSTANCE)* pObj->m_nMax);
		}
		else {
			pObj->m_pList=(DIDEVICEOBJECTINSTANCE *)malloc(sizeof(DIDEVICEOBJECTINSTANCE)* pObj->m_nMax);
		}

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),lpddoi,sizeof(DIDEVICEOBJECTINSTANCE ));
	

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DIEnumDeviceObjectsObject::C_dxj_DIEnumDeviceObjectsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DIEnumDeviceObjectsObject::~C_dxj_DIEnumDeviceObjectsObject()
{
	//empty list
	if (m_pList) free(m_pList);

}
		

HRESULT C_dxj_DIEnumDeviceObjectsObject::create(LPDIRECTINPUTDEVICE pDI,  long flags,I_dxj_DIEnumDeviceObjects **ppRet)
{
	HRESULT hr;
	C_dxj_DIEnumDeviceObjectsObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DIEnumDeviceObjectsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumObjects(
		(LPDIENUMDEVICEOBJECTSCALLBACK )DIEnumDeviceObjectsProc,
		(void*)pNew,
		(DWORD) flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DIEnumDeviceObjects,(void**)ppRet);
	return hr;
}


/* DEAD
HRESULT C_dxj_DIEnumDeviceObjectsObject::getItem( long index, DIDeviceObjectInstance *instCover)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;


	//TODO - consider what is going on here carefully
	if (instCover->strGuidType) SysFreeString(instCover->strGuidType);
	if (instCover->strName) SysFreeString(instCover->strName);

	
	DIDEVICEOBJECTINSTANCE *inst=&m_pList[index];

	//TODO - consider localization	
	if (inst->tszName){
		instCover->strName=T2BSTR(inst->tszName);
	}

	instCover->strGuidType=DINPUTGUIDtoBSTR(&inst->guidType);
	instCover->lOfs=inst->dwOfs;
	instCover->lType=inst->dwType;
	instCover->lFlags=inst->dwFlags;
	
	instCover->lFFMaxForce=inst->dwFFMaxForce;
	instCover->lFFForceResolution=inst->dwFFForceResolution;
	instCover->nCollectionNumber=inst->wCollectionNumber;
	instCover->nDesignatorIndex=inst->wDesignatorIndex;
	instCover->nUsagePage=inst->wUsagePage;
	instCover->nUsage=inst->wUsage;
	instCover->lDimension=inst->dwDimension;
	instCover->nExponent=inst->wExponent;
	instCover->nReserved=inst->wReserved;
	
	return S_OK;
}
*/


HRESULT C_dxj_DIEnumDeviceObjectsObject::getItem( long index, I_dxj_DirectInputDeviceObjectInstance **ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	DIDEVICEOBJECTINSTANCE *inst=&m_pList[index-1];

	if (!inst) return E_INVALIDARG;

	HRESULT hr;
	hr=C_dxj_DIDeviceObjectInstanceObject::create(inst,ret);
	return hr;
}

HRESULT C_dxj_DIEnumDeviceObjectsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dienumdevicesobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dienumdevicesobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dIEnumDevicesObj.h"
#include "diDevInstObj.h"

extern BSTR GUIDtoBSTR(LPGUID pGuid);
extern  HRESULT BSTRtoGUID(LPGUID pGuid,BSTR bstr);



/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL CALLBACK  objEnumInputDevicesCallback(
  LPDIDEVICEINSTANCE lpddi,  
  LPVOID lpArg               
  )
{

	DPF(1,"Entered objEnumInputDevicesCallback\r\n");

	if (!lpddi) return FALSE;

	C_dxj_DIEnumDevicesObject *pObj=(C_dxj_DIEnumDevicesObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList){
			pObj->m_pList=(DIDEVICEINSTANCE*)realloc(pObj->m_pList,sizeof(DIDEVICEINSTANCE)* pObj->m_nMax);
		}
		else {
			pObj->m_pList=(DIDEVICEINSTANCE*)malloc(   sizeof(DIDEVICEINSTANCE)* pObj->m_nMax);
		}
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),lpddi,sizeof(DIDEVICEINSTANCE));
	

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DIEnumDevicesObject::C_dxj_DIEnumDevicesObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DIEnumDevicesObject::~C_dxj_DIEnumDevicesObject()
{
	//empty list
	if (m_pList) free(m_pList);

}


HRESULT C_dxj_DIEnumDevicesObject::create(LPDIRECTINPUT pDI,long deviceType, long flags,I_dxj_DIEnumDevices **ppRet)
{
	HRESULT hr;
	C_dxj_DIEnumDevicesObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DIEnumDevicesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumDevices((DWORD)deviceType, 
		(LPDIENUMDEVICESCALLBACK)objEnumInputDevicesCallback,
		(void*)pNew,
		(DWORD) flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DIEnumDevices,(void**)ppRet);
	return hr;
}



HRESULT C_dxj_DIEnumDevicesObject::getItem( long index, I_dxj_DirectInputDeviceInstance **ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	HRESULT hr;
	
	hr=C_dxj_DIDeviceInstanceObject::create(&m_pList[index-1],ret);		
	return hr;
}

/* DEAD
HRESULT C_dxj_DIEnumDevicesObject::getItem( long index, DIDeviceInstance *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	if (info->strGuidInstance) SysFreeString(info->strGuidInstance);
	if (info->strGuidProduct) SysFreeString(info->strGuidProduct);
	if (info->strGuidFFDriver) SysFreeString(info->strGuidFFDriver);


	info->strGuidInstance=GUIDtoBSTR(&((m_pList[index]).guidInstance));
	info->strGuidProduct=GUIDtoBSTR(&((m_pList[index]).guidProduct));
	info->strGuidFFDriver=GUIDtoBSTR(&((m_pList[index]).guidFFDriver));
	info->lDevType=(long)(m_pList[index]).dwDevType;
	info->nUsagePage=(short)(m_pList[index]).wUsagePage;
	info->nUsage=(short)(m_pList[index]).wUsage;
	
	USES_CONVERSION;

	if (info->strProductName)
		SysFreeString(info->strProductName);
	if (info->strInstanceName)
		SysFreeString(info->strInstanceName);
	
	info->strInstanceName=NULL;
	info->strProductName=NULL;

	if (m_pList[index].tszProductName)
		info->strProductName=T2BSTR(m_pList[index].tszProductName);

	if (m_pList[index].tszInstanceName)
		info->strInstanceName=T2BSTR(m_pList[index].tszInstanceName);

	return S_OK;
}
*/

HRESULT C_dxj_DIEnumDevicesObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dienumeffectsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dienumeffectsobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dIEnumEffectsObj.h"


extern BSTR DINPUTGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR bstr);



////////////////////////////////////////////////////////////////////////////

extern "C" BOOL CALLBACK  objEnumInputEffectsCallback(
  LPCDIEFFECTINFO pdei,  
  LPVOID lpArg           
  )
{

	DPF(1,"Entered objEnumInputEffectsCallback\r\n");

	if (!pdei) return FALSE;

	C_dxj_DirectInputEnumEffectsObject *pObj=(C_dxj_DirectInputEnumEffectsObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList){
			pObj->m_pList=(DIEFFECTINFO*)realloc(pObj->m_pList,sizeof(DIEFFECTINFO)* pObj->m_nMax);
		}
		else {
			pObj->m_pList=(DIEFFECTINFO*)malloc(   sizeof(DIEFFECTINFO)* pObj->m_nMax);
		}
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pdei,sizeof(DIEFFECTINFO));
	
	DPF1(1,"objEnumInputEffects '%s'\n",pdei->tszName);

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DirectInputEnumEffectsObject::C_dxj_DirectInputEnumEffectsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DirectInputEnumEffectsObject::~C_dxj_DirectInputEnumEffectsObject()
{
	//empty list
	if (m_pList) free(m_pList);

}


HRESULT C_dxj_DirectInputEnumEffectsObject::create(LPDIRECTINPUTDEVICE2 pDI,long effectType,I_dxj_DirectInputEnumEffects **ppRet)
{
	HRESULT hr;
	C_dxj_DirectInputEnumEffectsObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectInputEnumEffectsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumEffects(
		objEnumInputEffectsCallback,
		(void*)pNew,
		(DWORD) effectType);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectInputEnumEffects,(void**)ppRet);
	return hr;
}



HRESULT C_dxj_DirectInputEnumEffectsObject::getEffectGuid( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	*ret=DINPUTGUIDtoBSTR(&(m_pList[index-1].guid));
		
	return S_OK;
}



HRESULT C_dxj_DirectInputEnumEffectsObject::getName( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	USES_CONVERSION;

	*ret=T2BSTR(m_pList[index-1].tszName);
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getType( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwEffType;
		
	return S_OK;
}


HRESULT C_dxj_DirectInputEnumEffectsObject::getStaticParams( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwStaticParams;
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getDynamicParams( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwDynamicParams;
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dienumdeviceobjectsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dienumdeviceobjectsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DIEnumDeviceObjectsObject : 
	public I_dxj_DIEnumDeviceObjects,
	public CComObjectRoot
{
public:
	C_dxj_DIEnumDeviceObjectsObject() ;
	virtual ~C_dxj_DIEnumDeviceObjectsObject() ;

BEGIN_COM_MAP(C_dxj_DIEnumDeviceObjectsObject)
	COM_INTERFACE_ENTRY(I_dxj_DIEnumDeviceObjects)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DIEnumDeviceObjectsObject)


public:
        HRESULT STDMETHODCALLTYPE getItem( 
            /* [in] */ long index,
            /* [out][in] */ I_dxj_DirectInputDeviceObjectInstance __RPC_FAR **info);
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
		
				
		static HRESULT C_dxj_DIEnumDeviceObjectsObject::create(LPDIRECTINPUTDEVICE pDI,  long flags,I_dxj_DIEnumDeviceObjects **ppRet);
public:
		DIDEVICEOBJECTINSTANCE *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dienumeffectsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dienumeffectsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DirectInputEnumEffectsObject : 
	public I_dxj_DirectInputEnumEffects,
	public CComObjectRoot
{
public:
	C_dxj_DirectInputEnumEffectsObject() ;
	virtual ~C_dxj_DirectInputEnumEffectsObject() ;

BEGIN_COM_MAP(C_dxj_DirectInputEnumEffectsObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputEnumEffects)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputEnumEffectsObject)

public:

         HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getEffectGuid( 
            /* [in] */ long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getStaticParams( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getDynamicParams( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
		
		static HRESULT C_dxj_DirectInputEnumEffectsObject::create(LPDIRECTINPUTDEVICE2 pDI,long effType,I_dxj_DirectInputEnumEffects **ppRet)	;

public:
		DIEFFECTINFO  *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dienumdevicesobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dienumdevicesobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DIEnumDevicesObject : 
	public I_dxj_DIEnumDevices,
	public CComObjectRoot
{
public:
	C_dxj_DIEnumDevicesObject() ;
	virtual ~C_dxj_DIEnumDevicesObject() ;

BEGIN_COM_MAP(C_dxj_DIEnumDevicesObject)
	COM_INTERFACE_ENTRY(I_dxj_DIEnumDevices)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DIEnumDevicesObject)

public:

        HRESULT STDMETHODCALLTYPE getItem( long index, I_dxj_DirectInputDeviceInstance **ret);
        HRESULT STDMETHODCALLTYPE getCount( long __RPC_FAR *count);
		
		
		static HRESULT C_dxj_DIEnumDevicesObject::create(LPDIRECTINPUT pDI,long deviceType, long flags,I_dxj_DIEnumDevices **ppRet)	;

public:
		DIDEVICEINSTANCE *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dinput1obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinput1obj.cpp
//
//--------------------------------------------------------------------------

    // dDrawColorControlObj.cpp : Implementation of CDirectApp and DLL registration.
    // DHF_DS entire file
    
    #include "stdafx.h"
    #include "Direct.h"
    #include "dms.h"
    #include "dInput1Obj.h"
    #include "dInputDeviceObj.h"
    #include "dinput.h"
    #include "DIEnumDevicesObj.h"
    
    extern HRESULT BSTRtoGUID(LPGUID,BSTR);
    extern HRESULT DINPUTBSTRtoGUID(LPGUID,BSTR);
    
    CONSTRUCTOR(_dxj_DirectInput, {});
    DESTRUCTOR(_dxj_DirectInput, {});
    GETSET_OBJECT(_dxj_DirectInput);
                                      
       
    STDMETHODIMP C_dxj_DirectInputObject::createDevice(BSTR strGuid, I_dxj_DirectInputDevice **dev)
    {    
    
    	HRESULT hr = DD_OK;
  		GUID		rguid;
    
    	LPDIRECTINPUTDEVICE realdevice1=NULL;
    	LPDIRECTINPUTDEVICE2 realdevice=NULL;
    
    	
		hr = DINPUTBSTRtoGUID(&rguid,strGuid);	
    	if FAILED(hr) return hr;	
    

    
     	hr=m__dxj_DirectInput->CreateDevice(rguid,&realdevice1,NULL);
    	if FAILED(hr) return hr;
    
    	hr=realdevice1->QueryInterface(IID_IDirectInputDevice2,(void**)&realdevice);
    	realdevice1->Release();
    	if FAILED(hr) return hr;
    
    	INTERNAL_CREATE(_dxj_DirectInputDevice,realdevice,dev);
    	if (*dev==NULL) {
    		realdevice->Release();
    		return E_OUTOFMEMORY;
    	}
    	
    
    	if (0==_wcsicmp(strGuid,L"guid_syskeyboard")){		
    		hr=realdevice->SetDataFormat(&c_dfDIKeyboard);
    	}
    	else if (0==_wcsicmp(strGuid,L"guid_sysmouse")){		
    		hr=realdevice->SetDataFormat(&c_dfDIMouse);
    	}
    	else {
    		hr=realdevice->SetDataFormat(&c_dfDIJoystick2);
    	}
    
    	return hr;
    }
    
    
    STDMETHODIMP C_dxj_DirectInputObject::runControlPanel( long hwndOwner )
    {
       HRESULT hr;
       hr = m__dxj_DirectInput->RunControlPanel((HWND)hwndOwner,  (DWORD)0);    
       return hr;
    }
    
    STDMETHODIMP C_dxj_DirectInputObject::getDeviceStatus( BSTR strGuid, VARIANT_BOOL *status){
       HRESULT hr;
       GUID g;
	   hr = DINPUTBSTRtoGUID(&g,strGuid);	       
       if FAILED(hr) return hr;

	   if (!status) return E_INVALIDARG;

       hr = m__dxj_DirectInput->GetDeviceStatus((REFGUID)g);    
    
	   if (hr==DI_OK)
			*status=VARIANT_TRUE;
	   else
			*status=VARIANT_FALSE;

       return S_OK;
    }
    
    
    STDMETHODIMP C_dxj_DirectInputObject::getDIEnumDevices(
    	long deviceType, long flags, I_dxj_DIEnumDevices **ppRet)
    
    {    
    	HRESULT hr;
    	hr = C_dxj_DIEnumDevicesObject::create(m__dxj_DirectInput,deviceType,flags,ppRet);
    	return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dinput1obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinput1obj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawColorControlObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectInput LPDIRECTINPUT

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInputObject : 
	public I_dxj_DirectInput,
	public CComObjectRoot
{
public:
	C_dxj_DirectInputObject() ;
	virtual ~C_dxj_DirectInputObject();

BEGIN_COM_MAP(C_dxj_DirectInputObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInput)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputObject)


public:
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE createDevice( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectInputDevice __RPC_FAR *__RPC_FAR *dev);
        
        HRESULT STDMETHODCALLTYPE getDIEnumDevices( 
            /* [in] */ long deviceType,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDevices __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDeviceStatus( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ VARIANT_BOOL *status);
        
        HRESULT STDMETHODCALLTYPE runControlPanel( 
            /* [in] */ long hwndOwner
            ///* [in] */ long flags
			);
                

private:
    DECL_VARIABLE(_dxj_DirectInput);

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInput)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dinputdeviceobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinputdeviceobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500


// dDrawColorControlObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dienumDeviceObjectsObj.h"
#include "dIEnumEffectsObj.h"
#include "dInputdeviceObj.h"
#include "dInputEffectObj.h"
#include "didevInstObj.h"
#include "didevObjInstObj.h"


//TODO move to typlib enum
#define dfDIKeyboard  1
#define dfDIMouse     2
#define dfDIJoystick  3
#define dfDIJoystick2 4

extern HRESULT FixUpCoverEffect(GUID g, DIEffect *cover,DIEFFECT *realEffect);
extern HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEffect *cover);


extern HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR str);
extern BSTR DINPUTGUIDtoBSTR(LPGUID pg);


HRESULT C_dxj_DirectInputDeviceObject::init()
{
	nFormat=0;
	return S_OK;
}
HRESULT C_dxj_DirectInputDeviceObject::cleanup()
{
	return S_OK;
}

CONSTRUCTOR(_dxj_DirectInputDevice, {init();});
DESTRUCTOR(_dxj_DirectInputDevice, {cleanup();});

//NOTE get set for Device object
// must use QI to get at other objects.
GETSET_OBJECT(_dxj_DirectInputDevice);
                                  
   
STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceObjectsEnum( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDeviceObjects  **ppret)
{
	HRESULT hr;
	hr=C_dxj_DIEnumDeviceObjectsObject::create(m__dxj_DirectInputDevice,flags,ppret);
	return hr;
}


STDMETHODIMP C_dxj_DirectInputDeviceObject::acquire(){
	return m__dxj_DirectInputDevice->Acquire();	
}


STDMETHODIMP C_dxj_DirectInputDeviceObject::getCapabilities(DIDevCaps *caps)
{
	//DIDevCaps same in VB/Java as in C
	caps->lSize=sizeof(DIDEVCAPS);
	HRESULT hr=m__dxj_DirectInputDevice->GetCapabilities((DIDEVCAPS*)caps);		
	return hr;
}

//VB cant return sucess codes so we will return an error code
#define VB_DI_BUFFEROVERFLOW 0x80040260
        

STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceData(            
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *deviceObjectDataArray,            
            /* [in] */ long flags,
			long *ret)

{
	HRESULT hr;
	
	if ((*deviceObjectDataArray)->cDims!=1) return E_INVALIDARG;
	if ((*deviceObjectDataArray)->cbElements!=sizeof(DIDEVICEOBJECTDATA)) return E_INVALIDARG;
	
	DWORD dwC= (*deviceObjectDataArray)->rgsabound[0].cElements;

	if (dwC==0) return E_INVALIDARG;
	
	LPDIDEVICEOBJECTDATA  pobjData=(LPDIDEVICEOBJECTDATA)((SAFEARRAY*)*deviceObjectDataArray)->pvData;
	hr=m__dxj_DirectInputDevice->GetDeviceData(sizeof(DIDEVICEOBJECTDATA), pobjData, (DWORD*)&dwC,flags);		
	
	*ret=dwC;

	if (hr==DI_BUFFEROVERFLOW) hr= VB_DI_BUFFEROVERFLOW;
		

	return hr;
}


STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceInfo(        
            /* [out] */ I_dxj_DirectInputDeviceInstance __RPC_FAR **info)
{
	HRESULT hr;

	//DIDeviceInstance not the Same in C as VB/J

	DIDEVICEINSTANCE inst;
	ZeroMemory(&inst,sizeof(DIDEVICEINSTANCE));
	inst.dwSize=sizeof(DIDEVICEINSTANCE);

	hr=m__dxj_DirectInputDevice->GetDeviceInfo(&inst);
	if FAILED(hr) return hr;

	hr=C_dxj_DIDeviceInstanceObject::create(&inst,info);
	return hr;

	/* DEAD
	info->strGuidInstance=GUIDtoBSTR(&inst.guidInstance);
	info->strGuidProduct=GUIDtoBSTR(&inst.guidProduct);
	info->strGuidFFDriver=GUIDtoBSTR(&inst.guidFFDriver);

	
	info->lDevType=(long)inst.dwDevType;
	info->nUsagePage=(short)inst.wUsagePage;
	info->nUsage=(short)inst.wUsage;
	
	USES_CONVERSION;
	
	if (info->strProductName)
		DXALLOCBSTR(info->strProductName);
	if (info->strInstanceName)
		DXALLOCBSTR(info->strInstanceName);
	
	info->strInstanceName=NULL;
	info->strProductName=NULL;

	if (inst.tszProductName)
		info->strProductName=T2BSTR(inst.tszProductName);

	if (inst.tszInstanceName)
		info->strInstanceName=T2BSTR(inst.tszInstanceName);
	*/
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceStateKeyboard(        
            /* [out] */ DIKeyboardState __RPC_FAR *state)
{
	HRESULT hr;

	if ((nFormat!= dfDIKeyboard) && (nFormat!=-1)) return DIERR_NOTINITIALIZED    ;

	hr=m__dxj_DirectInputDevice->GetDeviceState(256,(void*)state->key);	
	
	return hr;
}



        
STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceStateMouse( 
            /* [out] */ DIMouseState __RPC_FAR *state)
{
	HRESULT hr;

	if ((nFormat!= dfDIMouse) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;

	hr=m__dxj_DirectInputDevice->GetDeviceState(sizeof(DIMOUSESTATE),(void*)state);	
	return hr;
}
        
STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceStateJoystick( 
            /* [out] */ DIJoyState __RPC_FAR *state)
{
	HRESULT hr;

	//note Joystick1 or Joystick2 are valid formats since
	//one is a superset of the other
	if ((nFormat!= dfDIJoystick)&&(nFormat!= dfDIJoystick2) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;
	hr=m__dxj_DirectInputDevice->GetDeviceState(sizeof(DIJOYSTATE),(void*)state);	
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceStateJoystick2( 
            /* [out] */ DIJoyState2 __RPC_FAR *state)
{
	HRESULT hr;

	//only for format2
	if ((nFormat!= dfDIJoystick2) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;
	hr=m__dxj_DirectInputDevice->GetDeviceState(sizeof(DIJOYSTATE2),(void*)state);	
	return hr;
}


STDMETHODIMP C_dxj_DirectInputDeviceObject::getDeviceState( 
            /* [in] */ long cb,
            /* [in] */ void *pFormat)

{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectInputDevice->GetDeviceState((DWORD) cb,(void*)pFormat);	
	}
	__except(1,1){
		hr=E_INVALIDARG;
	}
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDeviceObject::getObjectInfo(                         
            /* [in] */ long obj,
            /* [in] */ long how,
				I_dxj_DirectInputDeviceObjectInstance **ret)
{
	

	DIDEVICEOBJECTINSTANCE inst;
	ZeroMemory(&inst,sizeof(DIDEVICEOBJECTINSTANCE));
	inst.dwSize=sizeof(DIDEVICEOBJECTINSTANCE);

	HRESULT hr;
	hr=m__dxj_DirectInputDevice->GetObjectInfo(&inst,(DWORD) obj,(DWORD)how);
	if FAILED(hr) return hr;
	
	hr=C_dxj_DIDeviceObjectInstanceObject::create(&inst,ret);

	return hr;

	/* DEAD

	//TODO - consider what is going on here carefully
	if (instCover->strGuidType) SysFreeString(instCover->strGuidType);
	if (instCover->strName) SysFreeString(instCover->strName);

	

	//TODO - consider localization	
	if (inst.tszName){
		instCover->strName=T2BSTR(inst.tszName);
	}

	instCover->strGuidType=DINPUTGUIDtoBSTR(&inst.guidType);
	instCover->lOfs=inst.dwOfs;
	instCover->lType=inst.dwType;
	instCover->lFlags=inst.dwFlags;
	
	instCover->lFFMaxForce=inst.dwFFMaxForce;
	instCover->lFFForceResolution=inst.dwFFForceResolution;
	instCover->nCollectionNumber=inst.wCollectionNumber;
	instCover->nDesignatorIndex=inst.wDesignatorIndex;
	instCover->nUsagePage=inst.wUsagePage;
	instCover->nUsage=inst.wUsage;
	instCover->lDimension=inst.dwDimension;
	instCover->nExponent=inst.wExponent;
	instCover->nReserved=inst.wReserved;
	
	return hr;
	*/
}


//  NOTE: - current working implemtation promotes
//			code bloat
//			might want to revist this and do it in a more
//			tidy fasion
//        
STDMETHODIMP C_dxj_DirectInputDeviceObject::getProperty( 
            /* [in] */ BSTR str,
            /* [out] */ void __RPC_FAR *propertyInfo)
{

	HRESULT hr;		

	//DWORD g;

	if (!propertyInfo) return E_INVALIDARG;

	((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);	

	if( 0==_wcsicmp(str,L"diprop_buffersize")){
			//g = (DWORD)&DIPROP_BUFFERSIZE;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_BUFFERSIZE,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_axismode")){
			//g = (DWORD)&DIPROP_AXISMODE;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_AXISMODE,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_granularity")){
			//g = (DWORD)&DIPROP_GRANULARITY;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_GRANULARITY,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_range")){
			//g = (DWORD)&DIPROP_RANGE;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_RANGE,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_deadzone")){
			//g = (DWORD)&DIPROP_DEADZONE;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_DEADZONE,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_ffgain")){
			//g = (DWORD)&DIPROP_FFGAIN;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_FFGAIN,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_saturation")){
			//g = (DWORD)&DIPROP_SATURATION;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_SATURATION,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_ffload")){
			//g = (DWORD)&DIPROP_FFLOAD;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_FFLOAD,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_autocenter")){
			//g = (DWORD)&DIPROP_AUTOCENTER;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_AUTOCENTER,(DIPROPHEADER*)propertyInfo);
	}
	else if( 0==_wcsicmp(str,L"diprop_calibrationmode")){
			//g = (DWORD)&DIPROP_CALIBRATIONMODE;
			hr=m__dxj_DirectInputDevice->GetProperty(DIPROP_CALIBRATIONMODE,(DIPROPHEADER*)propertyInfo);
	}
	else { 
		return E_INVALIDARG;		
	}

	/*
	__try{
		((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);	
		hr=m__dxj_DirectInputDevice->GetProperty((REFGUID)g,(DIPROPHEADER*)propertyInfo);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	*/
	return hr;
}
 
        
STDMETHODIMP C_dxj_DirectInputDeviceObject::runControlPanel( 
            /* [in] */ long hwnd)
{
	HRESULT hr;
        hr=m__dxj_DirectInputDevice->RunControlPanel((HWND) hwnd,(DWORD)0); 
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDeviceObject::setCooperativeLevel( 
            /* [in] */ long hwnd,
            /* [in] */ long flags)
{
	HRESULT hr;
        hr=m__dxj_DirectInputDevice->SetCooperativeLevel((HWND) hwnd,(DWORD)flags); 
	return hr;
}
    
STDMETHODIMP C_dxj_DirectInputDeviceObject::poll()
{
	HRESULT hr;
	hr=m__dxj_DirectInputDevice->Poll();	
	return hr;
}





    
STDMETHODIMP C_dxj_DirectInputDeviceObject::setCommonDataFormat( 
            /* [in] */ long format)
{
	//variant so that when structs can be packed in VARIANTS we can take care of it
	HRESULT hr;
	
	//	c_dfDIKeyboard 
	//	c_dfDIMouse 
	//	c_dfDIJoystick
	//	c_dfDIJoystick2
	nFormat=format;

	switch(format){
		case dfDIKeyboard:
			hr=m__dxj_DirectInputDevice->SetDataFormat(&c_dfDIKeyboard);
			break;
		case dfDIMouse:
			hr=m__dxj_DirectInputDevice->SetDataFormat(&c_dfDIMouse);
			break;
		case dfDIJoystick:
			hr=m__dxj_DirectInputDevice->SetDataFormat(&c_dfDIJoystick);
			break;
		case dfDIJoystick2:
			hr=m__dxj_DirectInputDevice->SetDataFormat(&c_dfDIJoystick2);
			break;
		default:
			return E_INVALIDARG;
	}

		
	return hr;
}
        		

STDMETHODIMP C_dxj_DirectInputDeviceObject::setDataFormat( 
            /* [in] */ DIDataFormat __RPC_FAR *format,
            SAFEARRAY __RPC_FAR * __RPC_FAR *formatArray)
{
	HRESULT		   hr;
	LPDIDATAFORMAT pFormat=(LPDIDATAFORMAT)format;
	LPGUID		   pGuid=NULL;
	LPGUID		   pGuidArray=NULL;
	DIObjectDataFormat	*pDiDataFormat=NULL;




	if ((!format) || (!formatArray)) return E_INVALIDARG;


	if (!ISSAFEARRAY1D(formatArray,pFormat->dwNumObjs)) return E_INVALIDARG;
	
	pFormat->dwSize=sizeof(DIDATAFORMAT);
	pFormat->rgodf=NULL;
	pFormat->rgodf=(LPDIOBJECTDATAFORMAT)DXHEAPALLOC(pFormat->dwNumObjs*sizeof(DIOBJECTDATAFORMAT));	
	if (!pFormat->rgodf) return E_OUTOFMEMORY;

	pGuidArray=(LPGUID)DXHEAPALLOC(pFormat->dwNumObjs*sizeof(GUID));
	if (!pGuidArray)
	{
		DXHEAPFREE(pFormat->rgodf);
		return E_OUTOFMEMORY;
	}			


	__try {
		for (DWORD i=0; i< pFormat->dwNumObjs;i++){
			pGuid=&(pGuidArray[i]);
			pDiDataFormat=&(((DIObjectDataFormat*)((SAFEARRAY*)*formatArray)->pvData)[i]);
			hr=DINPUTBSTRtoGUID(pGuid, pDiDataFormat->strGuid);
			if FAILED(hr) {
				DXHEAPFREE(pGuidArray);
				DXHEAPFREE(pFormat->rgodf);
				pFormat->rgodf=NULL;
			}		
			pFormat->rgodf[i].pguid=pGuid;
			pFormat->rgodf[i].dwOfs=pDiDataFormat->lOfs;
			pFormat->rgodf[i].dwType=pDiDataFormat->lType;
			pFormat->rgodf[i].dwFlags=pDiDataFormat->lFlags;
		}
		
		hr=m__dxj_DirectInputDevice->SetDataFormat(pFormat);
		

		DXHEAPFREE(pGuidArray);
		DXHEAPFREE(pFormat->rgodf);

	}
	__except(1,1){
				DXHEAPFREE(pGuidArray);
				DXHEAPFREE(pFormat->rgodf);
		return E_INVALIDARG;
	}	


	//indicate we have a custom format
	nFormat=-1;

	return hr;

}
        

STDMETHODIMP C_dxj_DirectInputDeviceObject::setEventNotification( 
            /* [in] */ long hEvent)
{

	HRESULT hr=m__dxj_DirectInputDevice->SetEventNotification((HANDLE)hEvent);	
	return hr;
}













STDMETHODIMP C_dxj_DirectInputDeviceObject::setProperty( 
            /* [in] */ BSTR __RPC_FAR str,
            /* [out] */ void __RPC_FAR *propertyInfo)
{

	HRESULT hr;			
	//DWORD g;
	
	if (!propertyInfo) return E_INVALIDARG;
	((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);
	if( 0==_wcsicmp(str,L"diprop_buffersize")){
		//g = (DWORD)&DIPROP_BUFFERSIZE;				
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_BUFFERSIZE,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_axismode")){
		//g = (DWORD)&DIPROP_AXISMODE;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_AXISMODE,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_granularity")){
		//g = (DWORD)&DIPROP_GRANULARITY;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_GRANULARITY,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_range")){
		//g = (DWORD)&DIPROP_RANGE;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_RANGE,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_deadzone")){
		//g = (DWORD)&DIPROP_DEADZONE;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_DEADZONE,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_ffgain")){
		//g = (DWORD)&DIPROP_FFGAIN;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_FFGAIN,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_saturation")){
		//g = (DWORD)&DIPROP_SATURATION;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_SATURATION,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_ffload")){
		//g = (DWORD)&DIPROP_FFLOAD;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_FFLOAD,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_autocenter")){
		//g = (DWORD)&DIPROP_AUTOCENTER;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_AUTOCENTER,(DIPROPHEADER*)propertyInfo);		
	}
	else if( 0==_wcsicmp(str,L"diprop_calibrationmode")){
		//g = (DWORD)&DIPROP_CALIBRATIONMODE;
		hr=m__dxj_DirectInputDevice->SetProperty(DIPROP_CALIBRATIONMODE,(DIPROPHEADER*)propertyInfo);		
	}
	else { 
		return E_INVALIDARG;		
	}

	/*
	__try {
		((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);
		hr=m__dxj_DirectInputDevice->SetProperty((REFGUID)g,(DIPROPHEADER*)propertyInfo);
	}
	__except (1,1){
		return E_INVALIDARG;
	}
	*/

	return hr;
}


STDMETHODIMP C_dxj_DirectInputDeviceObject::unacquire()
{
	HRESULT hr=m__dxj_DirectInputDevice->Unacquire();	
	return hr;
}
        



STDMETHODIMP C_dxj_DirectInputDeviceObject::createEffect( 
            /* [in] */ BSTR effectGuid,
            /* [in] */ DIEffect __RPC_FAR *effectInfo,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	GUID g;
	
	DIEFFECT realEffect;
	LPDIRECTINPUTEFFECT pRealEffect=NULL;

	hr=DINPUTBSTRtoGUID(&g,effectGuid);
	if FAILED(hr) return hr;

	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

	hr=m__dxj_DirectInputDevice->CreateEffect(g,&realEffect,&pRealEffect,NULL);
	if FAILED(hr) return hr;	

	INTERNAL_CREATE(_dxj_DirectInputEffect,pRealEffect,ret)

	return hr;
}

STDMETHODIMP C_dxj_DirectInputDeviceObject::createCustomEffect( 
            /* [in] */ DIEffect __RPC_FAR *effectInfo,
            /* [in] */ long channels,
            /* [in] */ long samplePeriod,
            /* [in] */ long nSamples,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *sampledata,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	GUID g=GUID_CustomForce;
	
	DIEFFECT realEffect;
	LPDIRECTINPUTEFFECT pRealEffect=NULL;

	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

	
	DICUSTOMFORCE customData;
	customData.cChannels =(DWORD)channels;
	customData.cSamples  =(DWORD)nSamples; 
	customData.dwSamplePeriod =(DWORD)samplePeriod;
	customData.rglForceData = (long*)(*sampledata)->pvData;
	
	realEffect.lpvTypeSpecificParams=&customData;
	realEffect.cbTypeSpecificParams=sizeof(DICUSTOMFORCE);
	
	__try {
		hr=m__dxj_DirectInputDevice->CreateEffect(g,&realEffect,&pRealEffect,NULL);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	if FAILED(hr) return hr;	

	INTERNAL_CREATE(_dxj_DirectInputEffect,pRealEffect,ret)

	return hr;
}



        
STDMETHODIMP C_dxj_DirectInputDeviceObject::sendDeviceData( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *data,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *retcount)
{
	DWORD dwCount=count;
	HRESULT hr;
    __try {
		hr=m__dxj_DirectInputDevice->SendDeviceData(
			sizeof(DIDEVICEOBJECTDATA),
			(DIDEVICEOBJECTDATA*)(*data)->pvData,
			&dwCount,
			(DWORD)flags);

	}
	__except(1,1){
		return E_INVALIDARG;
	}
	return hr;
}    

STDMETHODIMP C_dxj_DirectInputDeviceObject::sendForceFeedbackCommand( 
            /* [in] */ long flags) 
{
	HRESULT hr;
	hr=m__dxj_DirectInputDevice->SendForceFeedbackCommand((DWORD)flags);
	return hr;
}
        
STDMETHODIMP C_dxj_DirectInputDeviceObject::getForceFeedbackState( 
            /* [retval][out] */ long __RPC_FAR *state)
{
	if (!state) return E_INVALIDARG;
	HRESULT hr;
	hr=m__dxj_DirectInputDevice->GetForceFeedbackState((DWORD*)state);
	return hr;

}

STDMETHODIMP C_dxj_DirectInputDeviceObject::getEffectsEnum( long effType,
			I_dxj_DirectInputEnumEffects **ret)
{
	HRESULT hr=C_dxj_DirectInputEnumEffectsObject::create(m__dxj_DirectInputDevice,effType,ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dinputeffectobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dinputeffectobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dInputEffectObj.h"

extern HRESULT FixUpCoverEffect(GUID g, DIEffect *cover,DIEFFECT *realEffect);
extern HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEffect *cover);
extern BSTR DINPUTGUIDtoBSTR(LPGUID g);

CONSTRUCTOR(_dxj_DirectInputEffect, {});
DESTRUCTOR(_dxj_DirectInputEffect, {});
GETSET_OBJECT(_dxj_DirectInputEffect);
                                  
   
STDMETHODIMP C_dxj_DirectInputEffectObject::download()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Download();
	return hr;
}

STDMETHODIMP C_dxj_DirectInputEffectObject::getEffectGuid(BSTR *guid)
{
	HRESULT hr;
	GUID g;
	if (!guid) return E_INVALIDARG;
    hr=m__dxj_DirectInputEffect->GetEffectGuid(&g);
	*guid=DINPUTGUIDtoBSTR(&g);
	return hr;
}

   
STDMETHODIMP C_dxj_DirectInputEffectObject::getEffectStatus(long *ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
    hr=m__dxj_DirectInputEffect->GetEffectStatus((DWORD*)ret);
	return hr;
}

STDMETHODIMP C_dxj_DirectInputEffectObject::start(
			/* [in] */ long iterations,
            /* [in] */ long flags) 
     
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Start((DWORD)iterations,(DWORD)flags);
	return hr;
}


STDMETHODIMP C_dxj_DirectInputEffectObject::stop()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Stop();
	return hr;
}


STDMETHODIMP C_dxj_DirectInputEffectObject::unload()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Unload();
	return hr;
}
         
STDMETHODIMP C_dxj_DirectInputEffectObject::setParameters( 
            /* [in] */ DIEffect __RPC_FAR *effectInfo, long flags) 
{
	DIEFFECT realEffect;
	HRESULT hr;
	GUID g;
	m__dxj_DirectInputEffect->GetEffectGuid(&g);
	
	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

    hr=m__dxj_DirectInputEffect->SetParameters(&realEffect,(DWORD) flags);
	return hr;
}

#define DICONDITION_USE_BOTH_AXIS 1
#define DICONDITION_USE_DIRECTION 2


STDMETHODIMP C_dxj_DirectInputEffectObject::getParameters( 
            /* [in] */ DIEffect __RPC_FAR *effectInfo) 
{
	
	HRESULT hr;
	GUID g;
	DIEFFECT *pRealEffect=(DIEFFECT*)effectInfo;
	DWORD dwFlags= DIEP_ALLPARAMS;
	
 
	if (!effectInfo) return E_INVALIDARG;



	ZeroMemory(pRealEffect,sizeof(DIEffect));
	if (!pRealEffect->dwFlags) pRealEffect->dwFlags = DIEFF_OBJECTOFFSETS | DIEFF_POLAR;
	pRealEffect->dwSize =sizeof(DIEFFECT);
	pRealEffect->lpEnvelope =(DIENVELOPE*)&(effectInfo->envelope);
	pRealEffect->lpEnvelope->dwSize=sizeof(DIENVELOPE);
	pRealEffect->cAxes = 2;
	pRealEffect->rglDirection =(long*)&(effectInfo->x);
	
	hr=m__dxj_DirectInputEffect->GetEffectGuid(&g);
	if FAILED(hr) return hr;
			
	if (g==GUID_ConstantForce)
	{
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->constantForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DICONSTANTFORCE);		
	}		
	else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
	{
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->periodicForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DIPERIODIC);				
	}
	else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){		
			pRealEffect->cbTypeSpecificParams =sizeof(DICONDITION)*2;
			pRealEffect->lpvTypeSpecificParams =&(effectInfo->conditionX);
	}	
	else if (g==GUID_RampForce){		
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->rampForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DIRAMPFORCE);				
	}
	else {
		pRealEffect->lpvTypeSpecificParams =NULL;
		pRealEffect->cbTypeSpecificParams =0;
		dwFlags= dwFlags -DIEP_TYPESPECIFICPARAMS;
	}


	effectInfo->axisOffsets.x=DIJOFS_X;
	effectInfo->axisOffsets.y=DIJOFS_Y;
	pRealEffect->rgdwAxes=(DWORD*)&(effectInfo->axisOffsets);

	hr=m__dxj_DirectInputEffect->GetParameters(pRealEffect, dwFlags);

	if FAILED(hr) return hr;

	if (pRealEffect->cbTypeSpecificParams =sizeof(DICONDITION)*2)
		effectInfo->conditionFlags=DICONDITION_USE_BOTH_AXIS;
	else
		effectInfo->conditionFlags=DICONDITION_USE_DIRECTION;

	if (pRealEffect->lpEnvelope){
		effectInfo->bUseEnvelope=VARIANT_TRUE;
	}
	
	    
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dinputdeviceobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinputdeviceobj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawColorControlObject
#include "direct.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectInputDevice LPDIRECTINPUTDEVICE2

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInputDeviceObject : 
	public I_dxj_DirectInputDevice,	
	public CComObjectRoot
{
public:
	C_dxj_DirectInputDeviceObject() ;
	virtual ~C_dxj_DirectInputDeviceObject();

BEGIN_COM_MAP(C_dxj_DirectInputDeviceObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputDevice)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputDeviceObject)


public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE acquire( void);
        
         HRESULT STDMETHODCALLTYPE getDeviceObjectsEnum( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDeviceObjects __RPC_FAR *__RPC_FAR *ppret);
        
         HRESULT STDMETHODCALLTYPE getCapabilities( 
            /* [out][in] */ DIDevCaps __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getDeviceData( 
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *deviceObjectDataArray,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *c);
        
         HRESULT STDMETHODCALLTYPE getDeviceInfo( 
            /* [retval][out] */ I_dxj_DirectInputDeviceInstance __RPC_FAR *__RPC_FAR *deviceInstance);
        
         HRESULT STDMETHODCALLTYPE getDeviceStateKeyboard( 
            /* [out][in] */ DIKeyboardState __RPC_FAR *state);
        
         HRESULT STDMETHODCALLTYPE getDeviceStateMouse( 
            /* [out][in] */ DIMouseState __RPC_FAR *state);
        
         HRESULT STDMETHODCALLTYPE getDeviceStateJoystick( 
            /* [out][in] */ DIJoyState __RPC_FAR *state);
        
         HRESULT STDMETHODCALLTYPE getDeviceStateJoystick2( 
            /* [out][in] */ DIJoyState2 __RPC_FAR *state);
        
         HRESULT STDMETHODCALLTYPE getDeviceState( 
            /* [in] */ long cb,
            /* [in] */ void __RPC_FAR *state);
        
         HRESULT STDMETHODCALLTYPE getObjectInfo( 
            /* [in] */ long obj,
            /* [in] */ long how,
            /* [retval][out] */ I_dxj_DirectInputDeviceObjectInstance __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR guid,
            /* [out] */ void __RPC_FAR *propertyInfo);
        
         HRESULT STDMETHODCALLTYPE runControlPanel( 
            /* [in] */ long hwnd);
        
         HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ long hwnd,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setCommonDataFormat( 
            /* [in] */ long format);
        
         HRESULT STDMETHODCALLTYPE setDataFormat( 
            /* [in] */ DIDataFormat __RPC_FAR *format,
            SAFEARRAY __RPC_FAR * __RPC_FAR *formatArray);
        
         HRESULT STDMETHODCALLTYPE setEventNotification( 
            /* [in] */ long hEvent);
        
         HRESULT STDMETHODCALLTYPE setProperty( 
            /* [in] */ BSTR guid,
            /* [in] */ void __RPC_FAR *propertyInfo);
        
         HRESULT STDMETHODCALLTYPE unacquire( void);
        
         HRESULT STDMETHODCALLTYPE poll( void);
        
         HRESULT STDMETHODCALLTYPE createEffect( 
            /* [in] */ BSTR effectGuid,
            /* [in] */ DIEffect __RPC_FAR *effectinfo,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE createCustomEffect( 
            /* [in] */ DIEffect __RPC_FAR *effectinfo,
            /* [in] */ long channels,
            /* [in] */ long samplePeriod,
            /* [in] */ long nSamples,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *sampledata,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE sendDeviceData( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *data,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *retcount);
        
         HRESULT STDMETHODCALLTYPE sendForceFeedbackCommand( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE getForceFeedbackState( 
            /* [retval][out] */ long __RPC_FAR *state);
                
			
		HRESULT STDMETHODCALLTYPE getEffectsEnum( long flag,
            /* [retval][out] */ I_dxj_DirectInputEnumEffects __RPC_FAR *__RPC_FAR *ret) ;
        
private:
    DECL_VARIABLE(_dxj_DirectInputDevice);
	IDirectInputDevice2 *m__dxj_DirectInputDevice2;	
	HRESULT cleanup();
	HRESULT init();
public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInput)
	DWORD	nFormat;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\directinput.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       directinput.h
//
//--------------------------------------------------------------------------

// DiectInput.h : Declaration of the dInputDevice

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// Input Device Ojbect

#define typedef_dInputDevice LPDIRECTINPUTDEVICE

class CdInputDeviceObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<IdInputDevice, &IID_IdInputDevice, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public IdInputDevice,
#endif
	public CComObjectBase<&CLSID_dInputDevice>
{
public:
	CdInputDeviceObject() ;
BEGIN_COM_MAP(CdInputDeviceObject)
	COM_INTERFACE_ENTRY(IdInputDevice)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CdInputDeviceObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CdInputDeviceObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// IdInputDevice
public:
	// MUST BE FIRST!!
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

private:
    DECL_VARIABLE(dInputDevice);

public:
	DX3J_GLOBAL_LINKS( dInputDevice )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dinputeffectobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dinputeffectobj.h
//
//--------------------------------------------------------------------------

	

#include "resource.h"       // main symbols
extern void* g_dxj_DirectInputEffect;

#define typedef__dxj_DirectInputEffect LPDIRECTINPUTEFFECT

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInputEffectObject : 
	public I_dxj_DirectInputEffect,
	public CComObjectRoot
{
public:
	C_dxj_DirectInputEffectObject() ;
	virtual ~C_dxj_DirectInputEffectObject();

BEGIN_COM_MAP(C_dxj_DirectInputEffectObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputEffect)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputEffectObject)


public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE download( void) ;
        
         HRESULT STDMETHODCALLTYPE getEffectGuid( 
            /* [retval][out] */ BSTR *guid) ;
        
         HRESULT STDMETHODCALLTYPE getEffectStatus( 
            /* [retval][out] */ long __RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE start( 
            /* [in] */ long iterations,
            /* [in] */ long flags) ;
        
         HRESULT STDMETHODCALLTYPE stop( void) ;
        
         HRESULT STDMETHODCALLTYPE unload( void) ;
        
         HRESULT STDMETHODCALLTYPE setParameters( 
            /* [in] */ DIEffect __RPC_FAR *effectinfo, long flags) ;
        
         HRESULT STDMETHODCALLTYPE getParameters( 
            /* [out][in] */ DIEffect __RPC_FAR *effectinfo) ;
        
   
             

private:
    DECL_VARIABLE(_dxj_DirectInputEffect);

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInputEffect);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\directinput.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       directinput.cpp
//
//--------------------------------------------------------------------------

// dInputDevice.cpp : Implementation of dInputDevice and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DirectInput.h"

CONSTRUCTOR(dInputDevice, {});
DESTRUCTOR(dInputDevice, {});
GETSET_OBJECT(dInputDevice);

/////////////////////////////////////////////////////////////////////////////
// Direct Input Device Object 
//

#ifdef USING_IDISPATCH
STDMETHODIMP dInputDevice::InterfaceSupportsErrorInfo(REFIID riid)
{
	if (riid == IID_IdInputDevice)
		return S_OK;
	return S_FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\direct.cpp ===
// Direct.cpp : Implementation of DLL Exports.

// To fully complete this project follow these steps

// You will need the new MIDL compiler to build this project.  Additionally,
// if you are building the proxy stub DLL, you will need new headers and libs.

// 1) Add a custom build step to Direct.idl
//		You can select all of the .IDL files by holding Ctrl and clicking on
//		each of them.
//
//		Description
//			Running MIDL
//		Build Command(s)
//			midl Direct.idl
//		Outputs 
//			Direct.tlb
//			Direct.h
//			Direct_i.c
//
// NOTE: You must use the MIDL compiler from NT 4.0,
// preferably 3.00.15 or greater
//
// 2) Add a custom build step to the project to register the DLL
//		For this, you can select all projects at once
//		Description
//			Registering OLE Server...
//		Build Command(s)
//			regsvr32 /s /c "$(TargetPath)"
//			echo regsvr32 exec. time > "$(OutDir)\regsvr32.trg"
//		Outputs
//			$(OutDir)\regsvr32.trg

// 3) To add UNICODE support, follow these steps
//		Select Build|Configurations...
//		Press Add...
//		Change the configuration name to Unicode Release
//		Change the "Copy Settings From" combo to Direct - Win32 Release
//		Press OK
//		Press Add...
//		Change the configuration name to Unicode Debug
//		Change the "Copy Settings From" combo to Direct - Win32 Debug
//		Press OK
//		Press "Close"
//		Select Build|Settings...
//		Select the two UNICODE projects and press the C++ tab.
//		Select the "General" category
//		Add _UNICODE to the Preprocessor definitions
//		Select the Unicode Debug project
//		Press the "General" tab
//		Specify DebugU for the intermediate and output directories
//		Select the Unicode Release project
//		Press the "General" tab
//		Specify ReleaseU for the intermediate and output directories

// 4) Proxy stub DLL
//		To build a separate proxy/stub DLL,
//		run nmake -f ps.mak in the project directory.

#define DIRECTSOUND_VERSION 0x600
#define DIRECTINPUT_VERSION 0x0500

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "Direct.h"
#include "dms.h"

#include "DxGlob7Obj.h"

#include "dSound.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dSound3DListener.h"
#include "dSound3DBuffer.h"
#include "dSoundCaptureObj.h"
#include "dSoundCaptureBufferObj.h"

#include "DPAddressObj.h"
#include "DPLConnectionObj.h"
#include "dPlay4Obj.h"
#include "dPlayLobby3Obj.h"

#include "dDraw7obj.h"
#include "ddSurface7obj.h"
#include "ddClipperObj.h"
#include "ddColorControlObj.h"
#include "ddPaletteObj.h"

#include "d3d7Obj.h"
#include "d3dDevice7Obj.h"

#include "d3drmViewport2Obj.h"
#include "d3drmDevice3Obj.h"
#include "d3drmFrame3Obj.h"		
#include "d3drm3Obj.h"	
#include "d3drmMeshObj.h"
#include "d3drmFace2Obj.h"
#include "d3drmLightObj.h"
#include "d3drmTexture3Obj.h"
#include "d3drmMeshBuilder3Obj.h"
#include "d3drmWrapObj.h"
#include "d3drmMaterial2Obj.h"
#include "d3drmAnimation2Obj.h"
#include "d3drmAnimationSet2Obj.h"
#include "d3drmShadow2Obj.h"
#include "d3drmArrayObj.h"
#include "d3drmDeviceArrayObj.h"
#include "d3drmViewportArrayObj.h"
#include "d3drmFrameArrayObj.h"
#include "d3drmVisualArrayObj.h"
#include "d3drmProgressiveMeshObj.h"
#include "d3drmLightArrayObj.h"
#include "d3drmPickedArrayObj.h"
#include "d3drmPick2ArrayObj.h"
#include "d3drmFaceArrayObj.h"
#include "dInput1Obj.h"
#include "dInputDeviceObj.h"
#include "d3drmLightInterObj.h"
#include "d3drmMaterialInterObj.h"
#include "d3drmMeshInterObj.h"
#include "d3drmTextureInterObj.h"
#include "d3drmViewportInterObj.h"
#include "d3drmFrameInterObj.h"

#define IID_DEFINED
#include "Direct_i.c"
#include "d3drmobj.h"	

// When floating-point types are used, the compiler emits a reference to
// _fltused to initialize the CRT's floating-point package.  We're not
// using any of that support and the OS is responsible for initializing
// the FPU, so we'll link to the following _fltused instead to avoid CRT
// bloat.
//
// win2k doesnt like this so its been removed
// #ifdef NDEBUG
// extern "C" int _fltused = 0;
// #endif



// ATL COM OBJECT MAP
CComModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID__dxj_DirectX7,				 C_dxj_DirectX7Object)
END_OBJECT_MAP()

//
// thanks to precompiled headers, we never get this properly!
//
#undef DEFINE_GUID
#define __based(a)
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }



// LINK LIST OF TEXTURE CALLBACKS
// get cleaned up on DLL exit
extern "C" TextureCallback3				*TextureCallbacks3 = NULL;
extern "C" TextureCallback				*TextureCallbacks = NULL;
extern "C" FrameMoveCallback3			*FrameMoveCallbacks3 = NULL;
extern "C" DeviceUpdateCallback3		*DeviceUpdateCallbacks3 = NULL;
extern "C" DestroyCallback				*DestroyCallbacks = NULL;
extern "C" EnumerateObjectsCallback		*EnumCallbacks = NULL;
extern "C" LoadCallback					*LoadCallbacks = NULL;

// MISC GLOBALS
static const char	c_szWav[] = "WAVE";
long				g_debuglevel=0;
extern "C" int		nObjects = 0;
BOOL				is4Bit = FALSE;
int					g_creationcount=0;
CRITICAL_SECTION	g_cbCriticalSection;
OSVERSIONINFOA		sysinfo;

// HANDLES TO DX DLLS
HINSTANCE			g_hDDrawHandle=NULL;
HINSTANCE			g_hDSoundHandle=NULL;
HINSTANCE			g_hDPlay=NULL;
HINSTANCE			g_hInstD3DRMDLL=NULL;
HINSTANCE			g_hInstDINPUTDLL=NULL;
HINSTANCE			g_hInstD3DXOFDLL=NULL;
HINSTANCE			g_hInst=NULL;


//LINK LISTS OF AVAILABLE OBJECTS
void *g_dxj_Direct3dRMAnimation2		= 0;
void *g_dxj_Direct3dRMAnimationSet2		= 0;
void *g_dxj_Direct3dRMAnimationArray	= 0;
void *g_dxj_Direct3dRMObjectArray		= 0;
void *g_dxj_Direct3dRMDeviceArray		= 0;
void *g_dxj_Direct3dRMDevice3			= 0;
void *g_dxj_Direct3dRMFaceArray			= 0;
void *g_dxj_Direct3dRMFace2				= 0;
void *g_dxj_Direct3dRMFrameArray		= 0;
void *g_dxj_Direct3dRMFrame3			= 0;
void *g_dxj_Direct3dRMLightArray		= 0;
void *g_dxj_Direct3dRMLight				= 0;
void *g_dxj_Direct3dRMMaterial2			= 0;
void *g_dxj_Direct3dRMMeshBuilder3		= 0;
void *g_dxj_Direct3dRMMesh				= 0;
void *g_dxj_Direct3dRMProgressiveMesh	= 0;
void *g_dxj_Direct3dRM3					= 0;
void *g_dxj_Direct3dRMObject			= 0;
void *g_dxj_Direct3dRMPickArray			= 0;
void *g_dxj_Direct3dRMPick2Array		= 0;
void *g_dxj_Direct3dRMShadow2			= 0;
void *g_dxj_Direct3dRMTexture3			= 0;
void *g_dxj_Direct3dRMClippedVisual		= 0;
void *g_dxj_Direct3dRMViewportArray		= 0;
void *g_dxj_Direct3dRMViewport2			= 0;
void *g_dxj_Direct3dRMVisualArray		= 0;
void *g_dxj_Direct3dRMVisual			= 0;
void *g_dxj_Direct3dRMWinDevice			= 0;
void *g_dxj_Direct3dRMWrap				= 0;
void *g_dxj_Direct3dRMMeshInterpolator	= 0;
void *g_dxj_Direct3dRMLightInterpolator	= 0;
void *g_dxj_Direct3dRMFrameInterpolator	= 0;
void *g_dxj_Direct3dRMTextureInterpolator  = 0;
void *g_dxj_Direct3dRMViewportInterpolator = 0;
void *g_dxj_Direct3dRMMaterialInterpolator = 0;

void *g_dxj_DirectSound3dListener		= 0;
void *g_dxj_DirectSoundBuffer			= 0;
void *g_dxj_DirectSound3dBuffer			= 0;
void *g_dxj_DirectSound					= 0;
void *g_dxj_DirectSoundCapture			= 0;
void *g_dxj_DirectSoundCaptureBuffer	= 0;

void *g_dxj_DirectPlay4					= 0;
void *g_dxj_DirectPlayLobby3			= 0;
void *g_dxj_DPLConnection				= 0;
void *g_dxj_DPAddress					= 0;
void *g_dxj_DirectInput					= 0;
void *g_dxj_DirectInputDevice			= 0;
void *g_dxj_DirectInputEffect			= 0;

void *g_dxj_DirectDraw4					= 0;
void *g_dxj_DirectDrawSurface4			= 0;
void *g_dxj_DirectDrawClipper			= 0;
void *g_dxj_DirectDrawPalette			= 0;
void *g_dxj_DirectDrawColorControl		= 0;
void *g_dxj_DirectDrawGammaControl		= 0;
void *g_dxj_DirectDraw7					= 0;
void *g_dxj_DirectDrawSurface7			= 0;

void *g_dxj_Direct3dDevice7				= 0;
void *g_dxj_Direct3dVertexBuffer7		= 0;
void *g_dxj_Direct3d7					= 0;

void *g_dxj_DirectMusicLoader			= 0;
void *g_dxj_DirectMusicPerformance		= 0;
void *g_dxj_DirectMusicComposer			= 0;
void *g_dxj_DirectMusicStyle			= 0;
void *g_dxj_DirectMusicBand				= 0;
void *g_dxj_DirectMusicChordMap			= 0;
void *g_dxj_DirectMusicSegment			= 0;
void *g_dxj_DirectMusicSegmentState		= 0;
void *g_dxj_DirectMusicCollection		= 0;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// DLL LOADING
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HINSTANCE LoadD3DXOFDLL()
{
	char  Path[MAX_PATH] = {'\0'};
	if (!g_hInstD3DXOFDLL) 
	{
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\d3dXOF.dll" );
		g_hInstD3DXOFDLL=LoadLibrary(Path);
	}
	return g_hInstD3DXOFDLL;
}

HINSTANCE LoadDDrawDLL()
{
	char  Path[MAX_PATH] = {'\0'};
	if (!g_hDDrawHandle)
	{
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\ddraw.dll" );
		g_hDDrawHandle=LoadLibrary( Path );
	}
	return g_hDDrawHandle;
}

HINSTANCE LoadDSoundDLL()
{
	char  Path[MAX_PATH] = {'\0'};
	if (!g_hDSoundHandle) 
	{
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\dsound.dll" );
		g_hDSoundHandle=LoadLibrary( Path );
	}
	return g_hDSoundHandle;
}

HINSTANCE LoadDPlayDLL()
{
	char  Path[MAX_PATH] = {'\0'};
	if (!g_hDPlay)
	{
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\dplayx.dll" );
		g_hDPlay=LoadLibrary( Path );
	}
	return g_hDPlay;
}

HINSTANCE LoadD3DRMDLL()
{
	char  Path[MAX_PATH] = {'\0'};
	if (!g_hInstD3DRMDLL)
	{
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\d3drm.dll" );
		g_hInstD3DRMDLL=LoadLibrary( Path );
	}
	return g_hInstD3DRMDLL;
}

HINSTANCE LoadDINPUTDLL()
{
	if (!g_hInstDINPUTDLL) {
		char  Path[MAX_PATH] = {'\0'};
		GetSystemDirectory( Path, MAX_PATH );
		strcat(Path, "\\dinput.dll" );
		g_hInstDINPUTDLL=LoadLibrary( Path );
	}
	return g_hInstDINPUTDLL;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// DLL ENTRY POINTS
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{

	g_hInst=hInstance;

	if (dwReason == DLL_PROCESS_ATTACH)
	{
		//
		// Get the current display pixel depth
		// If it is 4-bit we are in trouble.
		//
        HDC hDisplayIC;
        BOOL bPalette = FALSE;
        hDisplayIC = CreateIC("DISPLAY", NULL, NULL, NULL);
		if (hDisplayIC)
        {
			if (GetDeviceCaps(hDisplayIC, BITSPIXEL) < 8)
				is4Bit = TRUE;
			DeleteDC(hDisplayIC);
        }

		//
		// Get the platform I'm running on. Used for NT or Win32 Checks.
		//
		GetVersionEx((OSVERSIONINFOA*)&sysinfo);

		/* now delay loading dlls
		g_hDSoundHandle  = LoadDSoundDLL();
		g_hDDrawHandle  = LoadDDrawDLL();
		g_hDPlay = LoadDPlayDLL();
		g_hInstD3DRMDLL = LoadD3DRMDLL();
		g_hInstSETUPDLL=NULL;
		g_hInstDINPUTDLL=LoadDINPUTDLL();
		g_hInstD3DXOFDLL=LoadD3DXOFDLL();
		*/

		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);

		
		InitializeCriticalSection(&g_cbCriticalSection);

		nObjects = 0;
		

	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		UINT i;	//for easy debugging
		
		//TEAR DOWN CALLBACK LISTS
		{
		 TextureCallback3 *pNext=NULL;
		 for (TextureCallback3 *pCB=TextureCallbacks3; (pCB); pCB=pNext)
		 {
	 		if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}
		
		{
		 FrameMoveCallback3 *pNext=NULL;
  		 for (FrameMoveCallback3 *pCB=FrameMoveCallbacks3; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}
		
		{
		 DeviceUpdateCallback3 *pNext=NULL;
		 for (DeviceUpdateCallback3 *pCB=DeviceUpdateCallbacks3; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}


		{
		 TextureCallback *pNext=NULL;
		 for (TextureCallback *pCB=TextureCallbacks; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}

		DPF (1,"Final Destroy Callbacks \n");
		{
 		 DestroyCallback *pNext=NULL;
		 for (DestroyCallback *pCB=DestroyCallbacks; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}
		DPF (1,"Final Destroy Callbacks Exit \n");

		{
		 EnumerateObjectsCallback *pNext=NULL;
		 for (EnumerateObjectsCallback *pCB=EnumCallbacks; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}


		{
		 LoadCallback *pNext=NULL;
		 for (LoadCallback *pCB=LoadCallbacks; (pCB); pCB=pNext)
		 {
			if (pCB->c)			i=(pCB->c)->Release();
			if (pCB->pUser)		i=(pCB->pUser)->Release();
			if (pCB->pParent)	i=(pCB->pParent)->Release();
			if (pCB->m_obj)		i=(pCB->m_obj)->Release();
			pNext=pCB->next;
			delete pCB;
		 }
		}

		//Andrewke bug30341 06/12/2000
		DeleteCriticalSection(&g_cbCriticalSection);

		//DEBUG CHECK ON REF COUNT FOR PROBLEMATIC OBJECTS
		#ifdef DEBUG		
			OBJCHECK("Direct3d7				",_dxj_Direct3d7			)
			OBJCHECK("Direct3dDevice7		",_dxj_Direct3dDevice7		)
			OBJCHECK("DirectDrawSurface7	",_dxj_DirectDrawSurface7	)
			OBJCHECK("DirectDraw7			",_dxj_DirectDraw7			)			
			DPF(4,"Dx7vb.dll will about to unload dx dlls\n\r");
		#endif

		//FREE DLLS
		if ( g_hDPlay ) 
			FreeLibrary(g_hDPlay);
		if ( g_hDSoundHandle )
			FreeLibrary(g_hDSoundHandle);
		if ( g_hDDrawHandle )
			FreeLibrary(g_hDDrawHandle);
		if ( g_hInstD3DRMDLL )
			FreeLibrary(g_hInstD3DRMDLL);
		if ( g_hInstDINPUTDLL )
			FreeLibrary(g_hInstDINPUTDLL);	
		if (g_hInstD3DXOFDLL)
			FreeLibrary(g_hInstD3DXOFDLL);	
		
		_Module.Term();

	}
	return TRUE;    
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
	HRESULT hRes = S_OK;
	// registers object, typelib and all interfaces in typelib
	hRes = _Module.RegisterServer(TRUE);
	if(hRes == S_OK)
	{
		//hRes = RegSecurityClass();
	}

	//now look
	HKEY hk=0;
	char szDocPath[MAX_PATH];
	DWORD cb=MAX_PATH;
	LONG res;
	DWORD type=REG_SZ;

	ZeroMemory(szDocPath,MAX_PATH);
	
	res=RegOpenKey(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Directx",&hk);
	if ((ERROR_SUCCESS!=res)||(hk==0) )
		return hRes;

	
	
	res=RegQueryValueEx(hk,"DXSDK Doc Path",NULL,&type,(LPBYTE)szDocPath,&cb);
	RegCloseKey(hk);

	if (ERROR_SUCCESS!=res) return hRes;

	hk=0;

	res=RegOpenKey(HKEY_LOCAL_MACHINE,"Software\\CLASSES\\TypeLib\\{E1211242-8E94-11D1-8808-00C04FC2C602}\\1.0\\HELPDIR",&hk);
	if (ERROR_SUCCESS!=res) return hRes;

	RegSetValueEx(hk,NULL,0,REG_SZ,(LPBYTE)szDocPath,cb);
	RegCloseKey(hk);


	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry
STDAPI DllUnregisterServer(void)
{
	HRESULT hRes = S_OK;
	hRes = _Module.UnregisterServer();
	if(hRes == S_OK)
	{
		//hRes = UnRegSecurityClass();
	}

	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// GUID CONVERSION FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// GUIDS_EQUAL - consider moving to dms.h

#define GUIDS_EQUAL(g,g2) (\
	(g.Data1==g2->Data1) && \
	(g.Data2==g2->Data2) && \
	(g.Data3==g2->Data3) && \
	(g.Data4[0]==g2->Data4[0]) && \
	(g.Data4[1]==g2->Data4[1]) && \
	(g.Data4[2]==g2->Data4[2]) && \
	(g.Data4[3]==g2->Data4[3]) && \
	(g.Data4[4]==g2->Data4[4]) && \
	(g.Data4[5]==g2->Data4[5]) && \
	(g.Data4[6]==g2->Data4[6]) && \
	(g.Data4[7]==g2->Data4[7]) )


/////////////////////////////////////////////////////////////////////////////
// GUIDtoBSTR - does conversion

BSTR GUIDtoBSTR(LPGUID pGuid){
	char  szOut[256];	
	char  szTemp[10];
	char  *pAt=NULL;
	int	  i;
	BSTR  bstrOut;

	// 00000000001111111111222222222233333333
	// 01234567890123456789012345678901234567
	// {XXXXXXXX-XXXX-XXXX-X  XXX-XXXXXXXXXXXX}
	if (pGuid!=NULL){

		szOut[0]='{';
		
		wsprintf(&(szOut)[1],"%.8X",pGuid->Data1);
		
		szOut[9]='-';
		
		wsprintf(szTemp,"%.4X",pGuid->Data2);
		memcpy(&(szOut[10]),szTemp,4);

		szOut[14]='-';

		wsprintf(szTemp,"%.4X",pGuid->Data3);
		memcpy(&(szOut[15]),szTemp,4);

		szOut[19]='-';

		for (i=0;i<2;i++){
			wsprintf(szTemp,"%.2X",pGuid->Data4[i]);
			memcpy(&(szOut[20+i*2]),szTemp,2);
			
		}

		szOut[24]='-';

		for (i=2;i<8;i++){
			wsprintf(szTemp,"%.2X",pGuid->Data4[i]);
			memcpy(&(szOut[21+i*2]),szTemp,2);
			
		}

		szOut[37]='}';
		szOut[38]='\0';

		USES_CONVERSION;
		bstrOut = T2BSTR(szOut);

	}
	else {
		bstrOut = T2BSTR("");
	}
		

	
	return bstrOut;
}

//////////////////////////////////////////////////////////////////////////////
// convertChar
// helper for GUIDtoBSTR
HRESULT convertChar(char *szIn,int i,char *valOut){
	int val[2];	//using int for easy out of bounds check
	
	char c;
	int j;
	
	for (j=0;j<2;j++){
	   c= szIn[i+j];
	   switch (c)
	   {
		case 'a':
		case 'A':
			val[j]=10;
			break;
		case 'b':
		case 'B':
			val[j]=11;
			break;
		case 'c':
		case 'C':
			val[j]=12;
			break;
		case 'd':
		case 'D':
			val[j]=13;
			break;

		case 'e':
		case 'E':
			val[j]=14;
			break;
		case 'f':
		case 'F':
			val[j]=15;
			break;
		default:
			val[j]=c-'0';
			if (val[j]<0) return E_INVALIDARG;
			if (val[j]>15) return E_INVALIDARG;
			break;
	   }
	}


	*valOut=(char)((val[0]<<4)|val[1]);
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// BSTRtoGUID - does conversion
//
HRESULT BSTRtoGUID(LPGUID pGuid, BSTR bstr){
	HRESULT hr;
	//byte
	// 
	// 
	//char
	//           1111111111222222222233333333
	// 01234567890123456789012345678901234567
	// {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}	
	USES_CONVERSION;
	if(!pGuid) return E_INVALIDARG;
	ZeroMemory(pGuid,sizeof(GUID));	
	if (!bstr) return S_OK;
		
	if (bstr[0]==0x00) return S_OK;

	LPSTR szGuid=W2T(bstr);
	
	//first and last char should be { }
	if ((szGuid[0]!='{')||(szGuid[37]!='}'))
		return E_INVALIDARG;
	if ((szGuid[9]!='-')||(szGuid[14]!='-')||(szGuid[19]!='-')||(szGuid[24]!='-'))
		return E_INVALIDARG;
	
	char val;
	char *pData=(char*)pGuid;
	int j=0;
	int i;
	
	//FIRST DWORD
	for ( i=7;i>=1;i=i-2){
		hr=convertChar(szGuid,i,&val);
		if FAILED(hr) return hr;				
		pData[j++]=val;
	}

	//FIRST WORD
	for ( i=12;i>=10;i=i-2){
		hr=convertChar(szGuid,i,&val);
		if FAILED(hr) return hr;
		pData[j++]=val;
	}

	//2nd WORD
	for ( i=17;i>=15;i=i-2){
		hr=convertChar(szGuid,i,&val);
		if FAILED(hr) return hr;
		pData[j++]=val;
	}


	//3rd DWORD - BYTE ARRAY
	for ( i=20;i<24;i=i+2){
		hr=convertChar(szGuid,i,&val);
		if FAILED(hr) return hr;
		pData[j++]=val;
	}

	//BYTE ARRAY
	for ( i=25;i<37;i=i+2){
		hr=convertChar(szGuid,i,&val);
		if FAILED(hr) return hr;
		pData[j++]=val;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// 
//
HRESULT BSTRtoPPGUID(LPGUID *ppGuid, BSTR bstr){
	if (!ppGuid) return E_INVALIDARG;
	if ((bstr==NULL)||(bstr[0]=='\0')){
		*ppGuid=NULL;
		return S_OK;
	}
	return BSTRtoGUID(*ppGuid,bstr);

}

/////////////////////////////////////////////////////////////////////////////
// D3DBSTRtoGUID - does conversion
//
HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str){
	HRESULT hr=S_OK;

	if (!pGuid) return E_INVALIDARG;

	if (!str) {
		ZeroMemory(pGuid,sizeof(GUID));
		return S_OK;
	}
	if( 0==_wcsicmp(str,L"iid_idirect3drgbdevice")){
			memcpy(pGuid,&IID_IDirect3DRGBDevice,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"iid_idirect3dhaldevice")){
			memcpy(pGuid,&IID_IDirect3DHALDevice,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"iid_idirect3dmmxdevice")){
			memcpy(pGuid,&IID_IDirect3DMMXDevice,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"iid_idirect3drefdevice")){
			memcpy(pGuid,&IID_IDirect3DRefDevice,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"iid_idirect3dnulldevice")){
			memcpy(pGuid,&IID_IDirect3DNullDevice,sizeof(GUID));
	}
	else {
		hr = BSTRtoGUID(pGuid,str);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// D3DGUIDtoBSTR - does conversion
//
BSTR D3DGUIDtoBSTR(LPGUID pg){

	HRESULT hr=S_OK;
	WCHAR *pStr=NULL;

	if (!pg)
		return NULL;
	else if (GUIDS_EQUAL(IID_IDirect3DNullDevice,pg)){
		pStr=L"IID_IDirect3DNullDevice";
	}
	else if (GUIDS_EQUAL(IID_IDirect3DRefDevice,pg)){
		pStr=L"IID_IDirect3DRefDevice";
	}
	else if (GUIDS_EQUAL(IID_IDirect3DMMXDevice,pg)){
		pStr=L"IID_IDirect3DMMXDevice";
	}
	
	else if (GUIDS_EQUAL(IID_IDirect3DHALDevice,pg)){
		pStr=L"IID_IDirect3DHALDevice";
	}
	else if (GUIDS_EQUAL(IID_IDirect3DRGBDevice,pg)){
		pStr=L"IID_IDirect3DRGBDevice";
	}

	if (pStr){
		return DXALLOCBSTR(pStr);
	}
	else {
		return GUIDtoBSTR(pg);
	}

}



/////////////////////////////////////////////////////////////////////////////
// DINPUTGUIDtoBSTR
//
BSTR DINPUTGUIDtoBSTR(LPGUID pg){

	HRESULT hr=S_OK;
	WCHAR *pStr=NULL;

	if (!pg)
		return NULL;
	else if (GUIDS_EQUAL(GUID_XAxis,pg)){
		pStr=L"GUID_XAxis";
	}
	else if (GUIDS_EQUAL(GUID_YAxis,pg)){
		pStr=L"GUID_YAxis";
	}
	else if (GUIDS_EQUAL(GUID_ZAxis,pg)){
		pStr=L"GUID_ZAxis";
	}
	
	else if (GUIDS_EQUAL(GUID_RxAxis,pg)){
		pStr=L"GUID_RxAxis";
	}
	else if (GUIDS_EQUAL(GUID_RyAxis,pg)){
		pStr=L"GUID_RyAxis";
	}
	else if (GUIDS_EQUAL(GUID_RzAxis,pg)){
		pStr=L"GUID_RzAxis";
	}

	else if (GUIDS_EQUAL(GUID_Slider,pg)){
		pStr=L"GUID_Slider";
	}
	else if (GUIDS_EQUAL(GUID_Button,pg)){
		pStr=L"GUID_Button";
	}
	else if (GUIDS_EQUAL(GUID_Key,pg)){
		pStr=L"GUID_Key";
	}
	else if (GUIDS_EQUAL(GUID_POV,pg)){
		pStr=L"GUID_POV";
	}
	else if (GUIDS_EQUAL(GUID_Unknown,pg)){
		pStr=L"GUID_Unknown";
	}
	else if (GUIDS_EQUAL(GUID_SysMouse,pg)){
		pStr=L"GUID_SysMouse";
	}
	else if (GUIDS_EQUAL(GUID_SysKeyboard,pg)){
		pStr=L"GUID_SysKeyboard";
	}


	else if (GUIDS_EQUAL(GUID_ConstantForce,pg)){
		pStr=L"GUID_ConstantForce";
	}
	else if (GUIDS_EQUAL(GUID_Square,pg)){
		pStr=L"GUID_Square";
	}
	else if (GUIDS_EQUAL(GUID_Sine,pg)){
		pStr=L"GUID_Sine";
	}
	else if (GUIDS_EQUAL(GUID_Triangle,pg)){
		pStr=L"GUID_Triangle";
	}
	else if (GUIDS_EQUAL(GUID_SawtoothUp,pg)){
		pStr=L"GUID_SawtoothUp";
	}
	else if (GUIDS_EQUAL(GUID_SawtoothDown,pg)){
		pStr=L"GUID_SawtoothDown";
	}
	else if (GUIDS_EQUAL(GUID_Spring,pg)){
		pStr=L"GUID_Spring";
	}
	else if (GUIDS_EQUAL(GUID_Damper,pg)){
		pStr=L"GUID_Damper";
	}
	else if (GUIDS_EQUAL(GUID_Inertia,pg)){
		pStr=L"GUID_Inertia";
	}
	else if (GUIDS_EQUAL(GUID_Friction,pg)){
		pStr=L"GUID_Friction";
	}
	else if (GUIDS_EQUAL(GUID_CustomForce,pg)){
		pStr=L"GUID_CustomForce";
	}
	else if (GUIDS_EQUAL(GUID_RampForce,pg)){
		pStr=L"GUID_RampForce";
	}




	//else if (GUIDS_EQUAL(GUID_Joystick,pg)){
	//	pStr=L"GUID_JoyStick";
	//}

	if (pStr){
		return DXALLOCBSTR(pStr);
	}
	else {
		return GUIDtoBSTR(pg);
	}

}


/////////////////////////////////////////////////////////////////////////////
// DINPUTBSTRtoGUID
//
HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR str){
	HRESULT hr=S_OK;

	if (!pGuid) return E_INVALIDARG;

	if (!str) {
		ZeroMemory(pGuid,sizeof(GUID));
		return S_OK;
	}
	if( 0==_wcsicmp(str,L"guid_xaxis")){
			memcpy(pGuid,&GUID_XAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_yaxis")){
			memcpy(pGuid,&GUID_YAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_zaxis")){
			memcpy(pGuid,&GUID_ZAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_rxaxis")){
			memcpy(pGuid,&GUID_RxAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_ryaxis")){
			memcpy(pGuid,&GUID_RyAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_rzaxis")){
			memcpy(pGuid,&GUID_RzAxis,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_slider")){
			memcpy(pGuid,&GUID_Slider,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_button")){
			memcpy(pGuid,&GUID_Button,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_key")){
			memcpy(pGuid,&GUID_Key,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_pov")){
			memcpy(pGuid,&GUID_POV,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_unknown")){
			memcpy(pGuid,&GUID_Unknown,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_sysmouse")){
			memcpy(pGuid,&GUID_SysMouse,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_syskeyboard")){
			memcpy(pGuid,&GUID_SysKeyboard,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_constantforce")){
			memcpy(pGuid,&GUID_ConstantForce,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_square")){
			memcpy(pGuid,&GUID_Square,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_sine")){
			memcpy(pGuid,&GUID_Sine,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_triangle")){
			memcpy(pGuid,&GUID_Triangle,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_sawtoothup")){
			memcpy(pGuid,&GUID_SawtoothUp,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_sawtoothdown")){
			memcpy(pGuid,&GUID_SawtoothDown,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_spring")){
			memcpy(pGuid,&GUID_Spring,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_damper")){
			memcpy(pGuid,&GUID_Damper,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_inertia")){
			memcpy(pGuid,&GUID_Inertia,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_friction")){
			memcpy(pGuid,&GUID_Friction,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"guid_customforce")){
			memcpy(pGuid,&GUID_CustomForce,sizeof(GUID));
	}

	else if( 0==_wcsicmp(str,L"guid_rampforce")){
			memcpy(pGuid,&GUID_RampForce,sizeof(GUID));
	}

	//else if( 0==_wcsicmp(str,L"guid_joystick")){
	//		memcpy(pGuid,&GUID_Joystick,sizeof(GUID));
	//}
	else {
		hr = BSTRtoGUID(pGuid,str);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// GENERAL HELPER FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CreateCoverObject
//
// NOTE this function call INTERNAL_CREATE_NOADDREF alot
// the only difference from INTERNAL_CREATE is that these objects will not
// have a reference to the object that created them if they are not
// available to the user in an existing user variable.. (not in the ll allready)
//
// The parent pointer is a vestige of DX5 support where we had to 
// manage the order of release calls. But that only happens for ddraw api

HRESULT CreateCoverObject(LPDIRECT3DRMOBJECT lpo, I_dxj_Direct3dRMObject **coverObj)
{	
	IUnknown *realThing=NULL;
	IUnknown *coverThing=NULL;
	IDirect3DRMInterpolator *pInter=NULL;

    //See if we where passed an interpolator
    if (S_OK==lpo->QueryInterface(IID_IDirect3DRMInterpolator,(void**)&pInter)){
		
        // Figure out what kind
		if (S_OK==pInter->QueryInterface(IID_IDirect3DRMFrame3,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMFrameInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);		
		}
		else if (S_OK==pInter->QueryInterface(IID_IDirect3DRMMeshBuilder3,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMMeshInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);
		}
		else if (S_OK==pInter->QueryInterface(IID_IDirect3DRMViewport2,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMViewportInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);
		}
		else if (S_OK==pInter->QueryInterface(IID_IDirect3DRMTexture3,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMTextureInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);
		}
		else if (S_OK==pInter->QueryInterface(IID_IDirect3DRMMaterial2,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMMaterialInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);
		}
		else if (S_OK==pInter->QueryInterface(IID_IDirect3DRMLight,(void**)&realThing)){	
			INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMLightInterpolator,(IDirect3DRMInterpolator*)pInter,&coverThing);
		}
		else {			            
            // release reference from original Interpolator QI and exit
            DPF(1,"CreateCoverObject unable to find interpolator\r\n");
			pInter->Release();
			return E_FAIL;
		}

        //dont need pinter anymore
        pInter->Release();

	}
    else {
        // Not an interpolator.. See what else it could be.
	    if (S_OK==lpo->QueryInterface(IID_IDirect3DRMMeshBuilder3,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMMeshBuilder3,(IDirect3DRMMeshBuilder3*)realThing,&coverThing);		
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMAnimation2,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMAnimation2,(IDirect3DRMAnimation2*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMAnimationSet2,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMAnimationSet2,(IDirect3DRMAnimationSet2*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMFrame3,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMFrame3,(IDirect3DRMFrame3*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMFace2,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMFace2,(IDirect3DRMFace2*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMDevice3,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMDevice3,(IDirect3DRMDevice3*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMTexture3,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMTexture3,(IDirect3DRMTexture3*)realThing,&coverThing);
	    }
	    else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMLight,(void**)&realThing)){
		    INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMLight,(IDirect3DRMLight*)realThing,&coverThing);
	    }
    
        // no longer support USERVISUALS
	    // else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMUserVisual,(void**)&realThing)){
	    //	INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMUserVisual,(IDirect3DRMUserVisual*)realThing,&coverThing);
	    // }
	    else {		
		    DPF(4,"CreateCoverObject didnt recognize guid");
		    return E_FAIL;
	    }
    }

    if (!coverThing) return E_OUTOFMEMORY;

     // All objects should support RMObject so get that interface	
    if (FAILED(coverThing->QueryInterface(IID_I_dxj_Direct3dRMObject, (void **)coverObj))) {
		coverThing->Release();
		return E_NOINTERFACE; 	
    }
    // Pass back cover object to user - has inc ref count from QI
	coverThing->Release();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//  CreateCoverVisual
//
//  Similar to CreateCoverObject
//
HRESULT CreateCoverVisual(LPDIRECT3DRMOBJECT lpo, I_dxj_Direct3dRMVisual **ppret)
{
	IUnknown *realThing=NULL;
	IUnknown *coverThing=NULL;
	I_dxj_Direct3dRMVisual *pObj=NULL;
	
	*ppret=NULL;

	//What kind of visual are we
	if (S_OK==lpo->QueryInterface(IID_IDirect3DRMMeshBuilder3,(void**)&realThing))  {		
		INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMMeshBuilder3,(IDirect3DRMMeshBuilder3*)realThing,&coverThing);
	}
	else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMTexture3,(void**)&realThing)){
		INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMTexture3,(IDirect3DRMTexture3*)realThing,&coverThing);
	}
	else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMMesh,(void**)&realThing)){
		INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMMesh,(IDirect3DRMMesh*)realThing,&coverThing);
	}
   	else if (S_OK==lpo->QueryInterface(IID_IDirect3DRMProgressiveMesh,(void**)&realThing)){
		INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMProgressiveMesh,(IDirect3DRMProgressiveMesh*)realThing,&coverThing);
	}
	else {		
		DPF(4," didnt recognize Visual in CreateCoverVisual");		
		return E_FAIL;
	}
	
    //release first QI
	if (realThing) realThing->Release();
	
    //make sure we have a coverThing.
	if (!coverThing) return E_FAIL;

    //QI for Visual Base Interface
	if (FAILED(coverThing->QueryInterface(IID_I_dxj_Direct3dRMVisual, (void **)ppret))){
		DPF(4,"CreateCoverVisual QI for object failed");
        coverThing->Release ();		
		return E_FAIL; 
	}
    
    //release 2nd QI
	coverThing->Release(); 
	
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// _GetName     helper function for RM object base class
//
extern "C" HRESULT _GetName(IDirect3DRMObject *iface, BSTR *Name, BOOL bNameNotClassName)
{
	DWORD cnt = 0;
	LPSTR str ;		// ANSI buffer on stack;

	if( bNameNotClassName )
	{
		if((iface->GetName(&cnt,(char*)NULL)) != D3DRM_OK) // size
			return E_FAIL;

		str = (LPSTR)alloca(cnt);		// ANSI buffer on stack;

		if((iface->GetName(&cnt, str)) != D3DRM_OK)
			return E_FAIL;
	}
	else
	{
		if((iface->GetClassName(&cnt,(char*)NULL)) != D3DRM_OK) // size
			return E_FAIL;

		str = (LPSTR)alloca(cnt);		// ANSI buffer on stack;

		if((iface->GetClassName(&cnt, str)) != D3DRM_OK)
			return E_FAIL;
	}

	PassBackUnicode(str, Name, cnt);
	return D3DRM_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Given an ANSI string, pass back a UNICODE string
// SysAllocString is your big friend here.
//
// CONSIDER finding all occerence of use and replacint with the
// T2BSTR macro .. much cleaner
//
extern "C" void PassBackUnicode(LPSTR str, BSTR *Name, DWORD cnt)
{
	//NOTE: length header is required to be filled, but the BSTR pointer
	//        points to the first character, not the length.
	// note, the count can never be too small as we get that from the string
	// before we pass it in!
	USES_CONVERSION;
	LPWSTR lpw = (LPWSTR)malloc((cnt+1)*2);

	if (!lpw) return;	//fix for bug45158 -no way of producing error code. (hmm)

	void *l = (void *)lpw;
	lpw = AtlA2WHelper(lpw, str, cnt);
	lpw[cnt] = 0;
	*Name = SysAllocString(lpw);
	free(l);
}

/////////////////////////////////////////////////////////////////////////////
// CopyOutDDSurfaceDesc2    real->cover
//
HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2 *dOut,DDSURFACEDESC2 *d){
	ZeroMemory(dOut, sizeof(DDSurfaceDesc2));
	memcpy (dOut,d,sizeof(DDSURFACEDESC2));	
	dOut->lMipMapCount=d->dwMipMapCount;
	dOut->lRefreshRate=d->dwRefreshRate;
	// Get Caps
	dOut->ddsCaps.lCaps = d->ddsCaps.dwCaps; 
	dOut->ddsCaps.lCaps2 = d->ddsCaps.dwCaps2; 
	dOut->ddsCaps.lCaps3 = d->ddsCaps.dwCaps3; 
	dOut->ddsCaps.lCaps4 = d->ddsCaps.dwCaps4; 
	CopyOutDDPixelFormat(&(dOut->ddpfPixelFormat) ,&(d->ddpfPixelFormat));
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CopyInDDSurfaceDesc2    cover->real
//
HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2 *dOut,DDSurfaceDesc2 *d){
	if(!d) return E_POINTER;															
	else if(!dOut) return E_POINTER;
	else if ( DDSD_MIPMAPCOUNT & d->lFlags ) d->lZBufferBitDepth = d->lMipMapCount;				
	else if ( DDSD_REFRESHRATE & d->lFlags ) d->lZBufferBitDepth = d->lRefreshRate;								
	memcpy (dOut,d,sizeof(DDSURFACEDESC2));

	CopyInDDPixelFormat(&(dOut->ddpfPixelFormat) ,&(d->ddpfPixelFormat));


	memcpy (&dOut->ddsCaps,&d->ddsCaps,sizeof(DDSCAPS2));
	dOut->dwSize=sizeof(DDSURFACEDESC2);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CopyInDDPixelFormat    cover->real
//
// note param ordering differnt that DDSURFACEDESC helpers
//
HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *pfOut, DDPixelFormat *pf)
{

	if (!pf) return E_POINTER;
	if (!pfOut) return E_POINTER;
	if ((pf->lFlags & DDPF_RGB)||(pf->lFlags &DDPF_RGBTOYUV)) {
		pf->internalVal1=pf->lRGBBitCount;
		pf->internalVal2=pf->lRBitMask;
		pf->internalVal3=pf->lGBitMask;
		pf->internalVal4=pf->lBBitMask;		
		if (pf->lFlags & DDPF_ALPHAPIXELS ){
			pf->internalVal5=pf->lRGBAlphaBitMask;
		}
		else if (pf->lFlags & DDPF_ZPIXELS ){
			pf->internalVal5=pf->lRGBZBitMask;
		}

	}
	else if (pf->lFlags & DDPF_YUV){
		pf->internalVal1=pf->lYUVBitCount;
		pf->internalVal2=pf->lYBitMask;
		pf->internalVal3=pf->lUBitMask;
		pf->internalVal4=pf->lVBitMask;
		if (pf->lFlags & DDPF_ALPHAPIXELS ){
			pf->internalVal5=pf->lYUVAlphaBitMask;
		}
		else if (pf->lFlags & DDPF_ZPIXELS ){
			pf->internalVal5=pf->lYUVZBitMask;
		}
	}
	
	else if (pf->lFlags & DDPF_BUMPDUDV) {
		pf->internalVal1=pf->lBumpBitCount;
		pf->internalVal2=pf->lBumpDuBitMask;
		pf->internalVal3=pf->lBumpDvBitMask;
		pf->internalVal4=pf->lBumpLuminanceBitMask;
	}

	//rest of internalVal1
	if (pf->lFlags & DDPF_ZBUFFER){
		pf->internalVal1=pf->lZBufferBitDepth;
	}
	else if (pf->lFlags & DDPF_ALPHA){
		pf->internalVal1=pf->lAlphaBitDepth;
	}
	else if (pf->lFlags & DDPF_LUMINANCE){
		pf->internalVal1=pf->lLuminanceBitCount;
	}

	//rest of internalVal2
	if (pf->lFlags & DDPF_STENCILBUFFER) {
		pf->internalVal2=pf->lStencilBitDepth;
	}
	else if ((pf ->lFlags & DDPF_LUMINANCE) || ( pf->lFlags & DDPF_BUMPLUMINANCE)){
		pf->internalVal2=pf->lLuminanceBitMask;
	}
	

	// internalVal3
	if ((pf->lFlags & DDPF_ZBUFFER)){
		pf->internalVal3=pf->lZBitMask;
	}

	// internalVal4
	if (pf->lFlags & DDPF_STENCILBUFFER){
		pf->internalVal4=pf->lStencilBitMask;
	}

	// internalVal5
	if (pf->lFlags & DDPF_LUMINANCE) {
		pf->internalVal5=pf->lLuminanceAlphaBitMask;
	}
	

	/*  map to indicate what is valid and when..

		long lRGBBitCount;			//DDPF_RGB 
		long lYUVBitCount;			//DDPF_YUV 
		long lZBufferBitDepth;		//DDPF_ZBUFFER 
		long lAlphaBitDepth;		//DDPF_ALPHA 
		long lLuminanceBitCount;	//DDPF_LUMINANCE 
		long lBumpBitCount;			//DDPF_BUMPDUDV 

		// union for internalVal2
		long lRBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
		long lYBitMask;				//DDPF_YUV 
		long lStencilBitMask;		//DDPF_STENCILBUFFER 
		long lLuminanceBitMask;		//DDPF_BUMPLUMINANCE or DDPF_LUMINANCE 
		long lBumpDiBitMask;		//DDPF_BUMPDUDV 

		// union for internalVal3
		long lGBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
		long lUBitMask;				//DPDF_YUV
		long lZBitMask;				//DDPF_STENCILBUFFER ?
		long lBumpDvBitMask;		//DDPF_BUMPDUDV 

		// union for internalVal4
		long lBBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
		long lVBitMask;				//DDPF_YUV 
		long lStencilBitMask;		//DDPF_STENCILBUFFER 
		long lBumpLuminanceBitMask;	//DDPF_BUMPDUDV 


		// union for internalVal5
		long lRGBAlphaBitMask;		//DDPF_RGB and DDPF_ALPHAPIXELS 
        long lYUVAlphaBitMask;		//DDPF_YUV & DDPF_ALPHAPIXELS 
        long lLuminanceAlphaBitMask; //DDPF_LUMINANCE
        long lRGBZBitMask;			//DDPF_ZPIXELS & DDPF_RGB
		long lYUVZBitMask;			//DDPF_ZPIXELS & DDPF_YUV
	*/

	memcpy(pfOut,pf,sizeof(DDPIXELFORMAT));
	pfOut->dwSize=sizeof(DDPIXELFORMAT);

	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CopyOutDDPixelFormat    real->cover
//
// note param ordering differnt that DDSURFACEDESC helpers
//
HRESULT CopyOutDDPixelFormat(DDPixelFormat *pfOut, DDPIXELFORMAT *pf)
{
	if (!pf) return E_POINTER;
	if (!pfOut) return E_POINTER;
	
	pfOut->lSize=pf->dwSize;	
	pfOut->lFlags=pf->dwFlags;
	pfOut->lFourCC=pf->dwFourCC ;	
	pfOut->lRGBBitCount=pf->dwRGBBitCount;			//DDPF_RGB 
	pfOut->lRGBBitCount=pf->dwRGBBitCount;			//DDPF_YUV 
	pfOut->lZBufferBitDepth=pf->dwZBufferBitDepth;		//DDPF_ZBUFFER 
	pfOut->lAlphaBitDepth=pf->dwAlphaBitDepth;		//DDPF_ALPHA 
	pfOut->lLuminanceBitCount=pf->dwLuminanceBitCount;	//DDPF_LUMINANCE 
	pfOut->lBumpBitCount=pf->dwBumpBitCount;			//DDPF_BUMPDUDV 

	// union for internalVal2
	pfOut->lRBitMask=pf->dwRBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
	pfOut->lYBitMask=pf->dwYBitMask;				//DDPF_YUV 
	pfOut->lStencilBitDepth=pf->dwStencilBitDepth;		//DDPF_STENCILBUFFER 
	pfOut->lLuminanceBitMask=pf->dwLuminanceBitMask;		//DDPF_BUMPLUMINANCE or DDPF_LUMINANCE 
	pfOut->lBumpDuBitMask=pf->dwBumpDuBitMask;		//DDPF_BUMPDUDV 

	// union for internalVal3
	pfOut->lGBitMask=pf->dwGBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
	pfOut->lUBitMask=pf->dwUBitMask;				//DPDF_YUV
	pfOut->lZBitMask=pf->dwZBitMask;				//DDPF_STENCILBUFFER ?
	pfOut->lBumpDvBitMask=pf->dwBumpDvBitMask;		//DDPF_BUMPDUDV 

	// union for internalVal4
	pfOut->lBBitMask=pf->dwBBitMask;				//DDPF_RGB or DDPF_RGBTOYUV 
	pfOut->lVBitMask=pf->dwVBitMask;				//DDPF_YUV 
	pfOut->lStencilBitMask=pf->dwStencilBitMask;		//DDPF_STENCILBUFFER 
	pfOut->lBumpLuminanceBitMask=pf->dwBumpLuminanceBitMask;	//DDPF_BUMPDUDV 
	


	// union for internalVal5
	pfOut->lRGBAlphaBitMask=pf->dwRGBAlphaBitMask;		//DDPF_RGB and DDPF_ALPHAPIXELS 
    pfOut->lYUVAlphaBitMask=pf->dwYUVAlphaBitMask;		//DDPF_YUV & DDPF_ALPHAPIXELS 
    pfOut->lLuminanceAlphaBitMask=pf->dwLuminanceAlphaBitMask; //DDPF_LUMINANCE
    pfOut->lRGBZBitMask=pf->dwRGBZBitMask;			//DDPF_ZPIXELS & DDPF_RGB
	pfOut->lYUVZBitMask=pf->dwYUVZBitMask;			//DDPF_ZPIXELS & DDPF_YUV
	
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CopyOutDDPixelFormat    cover->real
//
//
HRESULT FillRealSessionDesc(DPSESSIONDESC2 *dpSessionDesc,DPSessionDesc2 *sessionDesc){

	long l=0;
	HRESULT hr;

	memset(dpSessionDesc,0,sizeof(DPSESSIONDESC2));
	dpSessionDesc->dwSize			= sizeof(DPSESSIONDESC2);
	dpSessionDesc->dwFlags			= sessionDesc->lFlags;

	hr=BSTRtoGUID(&(dpSessionDesc->guidInstance),sessionDesc->strGuidInstance);
	if FAILED(hr) return hr;
	hr=BSTRtoGUID(&(dpSessionDesc->guidApplication),sessionDesc->strGuidApplication);
	if FAILED(hr) return hr;
	
	dpSessionDesc->dwMaxPlayers		= sessionDesc->lMaxPlayers;
	dpSessionDesc->dwCurrentPlayers	= sessionDesc->lCurrentPlayers;

	//using wide strings

	dpSessionDesc->lpszSessionName=NULL;
	if ((sessionDesc->strSessionName)&& (sessionDesc->strSessionName[0]!='\0')){
		dpSessionDesc->lpszSessionName=SysAllocString(sessionDesc->strSessionName);
	}
	
	dpSessionDesc->lpszPassword=NULL;
	if ((sessionDesc->strPassword)&& (sessionDesc->strPassword[0]!='\0')){
		dpSessionDesc->lpszPassword=SysAllocString(sessionDesc->strPassword);
	}
	
	
	dpSessionDesc->dwReserved1		= 0;
	dpSessionDesc->dwReserved2		= 0;
	dpSessionDesc->dwUser1			= sessionDesc->lUser1;
	dpSessionDesc->dwUser2			= sessionDesc->lUser2;
	dpSessionDesc->dwUser3			= sessionDesc->lUser3;
	dpSessionDesc->dwUser4			= sessionDesc->lUser4;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// FillCoverSessionDesc    real->cover
//
//
void FillCoverSessionDesc(DPSessionDesc2 *sessionDesc,DPSESSIONDESC2 *dpSessionDesc)
{
	sessionDesc->lFlags = dpSessionDesc->dwFlags;
	sessionDesc->lMaxPlayers = dpSessionDesc->dwMaxPlayers;
	sessionDesc->lCurrentPlayers = dpSessionDesc->dwCurrentPlayers;
	sessionDesc->lUser1 = (long)dpSessionDesc->dwUser1;
	sessionDesc->lUser2 = (long)dpSessionDesc->dwUser2;
	sessionDesc->lUser3 = (long)dpSessionDesc->dwUser3;
	sessionDesc->lUser4 = (long)dpSessionDesc->dwUser4;	

	// NOTE: if sessiondesc came in as [out] param then 
	// strGuidInstance -strPassword etc. would all be NULL
	// if it pas passed as in out we need to free the existing contents
	// before moving. Consulted with Matt curland to verify if ok. 

	if (sessionDesc->strGuidInstance) SysFreeString(sessionDesc->strGuidInstance);
	if (sessionDesc->strGuidApplication) SysFreeString(sessionDesc->strGuidApplication);
	if (sessionDesc->strSessionName) SysFreeString(sessionDesc->strSessionName);
	if (sessionDesc->strPassword) SysFreeString(sessionDesc->strPassword);

	sessionDesc->strGuidInstance=GUIDtoBSTR(&(dpSessionDesc->guidInstance));
	sessionDesc->strGuidApplication=GUIDtoBSTR(&(dpSessionDesc->guidApplication));	
	sessionDesc->strSessionName = SysAllocString(dpSessionDesc->lpszSessionName);
	sessionDesc->strPassword = SysAllocString(dpSessionDesc->lpszPassword);
}

/////////////////////////////////////////////////////////////////////////////
// IsAllZeros
//
BOOL IsAllZeros(void *pStruct,DWORD size){
	for (DWORD i=0;i<size;i++){
		if (((char*)pStruct)[i]!='\0'){
			return FALSE;
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CopyFloats
//
extern "C" void CopyFloats(D3DVALUE *dst, D3DVALUE *src, DWORD count)
{
	D3DVALUE *ptr1 = dst, *ptr2 = src;

	if (!count)		return;

	for (; count; count--)  *ptr1++ = *ptr2++;
	return;
}

/////////////////////////////////////////////////////////////////////////////
// IsWin95
//
// no longer needed since we support w95 now
#if 0
BOOL IsWin95(void)
{
	return FALSE;
    


	//We work on win95
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        DPF(1,"GetVersionEx failed - assuming Win95");
        return TRUE;
    }

    if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {

        if( ( osvi.dwMajorVersion > 4UL ) ||
            ( ( osvi.dwMajorVersion == 4UL ) &&
              ( osvi.dwMinorVersion >= 10UL ) &&
              ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
        {
            // is Win98
            DPF(2,"Detected Win98");
            return FALSE;
        }
        else
        {
            // is Win95
            DPF(2,"Detected Win95");
            return TRUE;
        }
    }
    else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        DPF(2,"Detected WinNT");
        return FALSE;
    }
    DPF(2,"OS Detection failed");
    return TRUE;

}
#endif

#define DICONDITION_USE_BOTH_AXIS 1
#define DICONDITION_USE_DIRECTION 2

/////////////////////////////////////////////////////////////////////////////
// FixUpRealEffect  cover->real
//
HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEffect *cover)
{
	if (!cover) return E_INVALIDARG;

	
	memcpy(realEffect,cover,sizeof(DIEFFECT));

	realEffect->dwSize =sizeof(DIEFFECT);	
	realEffect->lpEnvelope =NULL;
	realEffect->cbTypeSpecificParams =0;
	realEffect->lpvTypeSpecificParams =NULL;
	realEffect->cAxes =2;
	realEffect->dwFlags=realEffect->dwFlags | DIEFF_OBJECTOFFSETS ;
	realEffect->rglDirection =(long*)&(cover->x);
	realEffect->rgdwAxes =(DWORD*)&(cover->axisOffsets);	
	
	
	if (cover->bUseEnvelope){
		realEffect->lpEnvelope=(DIENVELOPE*)&(cover->envelope);
		
		((DIENVELOPE*)&(cover->envelope))->dwSize=sizeof(DIENVELOPE);
	}
	
	if (!cover->lFlags)
		realEffect->dwFlags= DIEFF_POLAR | DIEFF_OBJECTOFFSETS ;
	
	//constant
	if (g==GUID_ConstantForce)
	{
		realEffect->cbTypeSpecificParams =sizeof (DICONSTANTFORCE);
		realEffect->lpvTypeSpecificParams =&(cover->constantForce);
	}
	
	//periodic
	else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
	{

		realEffect->cbTypeSpecificParams =sizeof (DIPERIODIC);
		realEffect->lpvTypeSpecificParams =&(cover->periodicForce);

	}
	else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){

		if (cover->conditionFlags==DICONDITION_USE_BOTH_AXIS){
			realEffect->cbTypeSpecificParams =sizeof(DICONDITION)*2;
			realEffect->lpvTypeSpecificParams =&(cover->conditionX);			
		}
		else{
			realEffect->cbTypeSpecificParams =sizeof(DICONDITION);
			realEffect->lpvTypeSpecificParams =&(cover->conditionX);
		}

	}
	else if (g==GUID_RampForce){
		realEffect->cbTypeSpecificParams =sizeof(DIRAMPFORCE);
		realEffect->lpvTypeSpecificParams =&(cover->rampForce);
	}

	cover->axisOffsets.x=DIJOFS_X;
	cover->axisOffsets.y=DIJOFS_Y;
	realEffect->rgdwAxes=(DWORD*)&(cover->axisOffsets);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// FixUpCoverEffect  real->cover
//
HRESULT FixUpCoverEffect(GUID g, DIEffect *cover,DIEFFECT *realEffect)
{
	

	ZeroMemory(cover,sizeof(DIEffect));
	memcpy(cover,realEffect,sizeof(DIEFFECT));
	
	
	if (realEffect->lpEnvelope){
		memcpy(&cover->envelope,realEffect->lpEnvelope ,sizeof(DIENVELOPE));
		cover->bUseEnvelope=VARIANT_TRUE;
	}

	if (realEffect->rglDirection){
		cover->x=realEffect->rglDirection[0];
		cover->y=realEffect->rglDirection[1];
	}	
	

	
	if (realEffect->lpvTypeSpecificParams){
		
		if (g==GUID_ConstantForce)
		{
			memcpy(&(cover->constantForce),realEffect->lpvTypeSpecificParams,sizeof(DICONSTANTFORCE));
		}		
		//periodic
		else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
		{
			memcpy(&(cover->periodicForce),realEffect->lpvTypeSpecificParams,sizeof(DIPERIODIC));
		}
	
		else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){
			
			if (realEffect->cbTypeSpecificParams ==sizeof(DICONDITION)*2){
				memcpy(&(cover->conditionY),realEffect->lpvTypeSpecificParams,sizeof(DICONDITION)*2);
				cover->conditionFlags=DICONDITION_USE_BOTH_AXIS;
			}
			else{
				memcpy(&(cover->conditionX),realEffect->lpvTypeSpecificParams,sizeof(DICONDITION));
				cover->conditionFlags=DICONDITION_USE_DIRECTION;
			}

		}
		
		else if (g==GUID_RampForce){
			memcpy(&(cover->rampForce),realEffect->lpvTypeSpecificParams,sizeof(DIRAMPFORCE));			
		}

	}


	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CALLBACK FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// myLoadTextureCallback - rm texture callback
// only userd by pmesh...
//
extern "C" HRESULT __cdecl myLoadTextureCallback(char *tex_name, void *lpArg,
										 LPDIRECT3DRMTEXTURE * lpD3DRMTex)
{	
	// user arg will contain our own struct
	struct TextureCallback3 *tcb = (struct TextureCallback3 *)lpArg;
	I_dxj_Direct3dRMTexture3 *iunk = NULL;
    LPDIRECT3DRMTEXTURE       lpTex= NULL;

	int i=0;
	
	// convert to Unicode
	USES_CONVERSION;;
	BSTR tex=T2BSTR(tex_name);

	// user arg is an object -- hang on to it during our callback as a precaution
	if (tcb->pUser) tcb->pUser->AddRef();

	// call the VB callback..
	tcb->c->callbackRMLoadTexture(tex,tcb->pUser , &iunk);

	// give up the extra reference
	if (tcb->pUser) tcb->pUser->Release();


	// free the string allocated by T2BSTR
	SysFreeString(tex);

	// given  the user returned something in iunk..
	if ( iunk != NULL )
	{				
		// get the real object iunk covers 
		// note DO_GETOBJECT_NOTNULL does not addref and assumes 
		// the cover object allready has a reference.
		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMTEXTURE3,lp,iunk)		

        lp->QueryInterface(IID_IDirect3DRMTexture,(void**)&lpTex);

        // give it up to rm
		*lpD3DRMTex = lpTex;

		// we addref the real rm texture (as we are in a callback and
		// need to return an object to rm that it will later release)
		(*lpD3DRMTex)->AddRef();

        
		// release our reference to the cover object vb gave us
		iunk->Release();

    } 
	else
	{
		//otherwise return null to RM
		*lpD3DRMTex = NULL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// myLoadTextureCallback3 - rm texture callback

extern "C" HRESULT __cdecl myLoadTextureCallback3(char *tex_name, void *lpArg,
										 LPDIRECT3DRMTEXTURE3 * lpD3DRMTex)
{	
	// user arg will contain our own struct
	struct TextureCallback3 *tcb = (struct TextureCallback3 *)lpArg;
	I_dxj_Direct3dRMTexture3 *iunk = NULL;
	int i=0;
	
	// convert to Unicode
	USES_CONVERSION;;
	BSTR tex=T2BSTR(tex_name);

	// user arg is an object -- hang on to it during our callback as a precaution
	if (tcb->pUser) tcb->pUser->AddRef();

	// call the VB callback..
	tcb->c->callbackRMLoadTexture(tex,tcb->pUser , &iunk);

	// give up the extra reference
	if (tcb->pUser) tcb->pUser->Release();


	// free the string allocated by T2BSTR
	SysFreeString(tex);

	// given  the user returned something in iunk..
	if ( iunk != NULL )
	{				
		// get the real object iunk covers 
		// note DO_GETOBJECT_NOTNULL does not addref and assumes 
		// the cover object allready has a reference.
		DO_GETOBJECT_NOTNULL(LPDIRECT3DRMTEXTURE3,lp,iunk)		

   		// give it up to rm
		*lpD3DRMTex = lp;

		// we addref the real rm texture (as we are in a callback and
		// need to return an object to rm that it will later release)
		(*lpD3DRMTex)->AddRef();


		// release our reference to the cover object vb gave us
		iunk->Release();

    } 
	else
	{
		//otherwise return null to RM
		*lpD3DRMTex = NULL;
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// myFrameMoveCallback - rm frame move callback
//
// we use a helper so we can call into INTERNAL_CREATE ..
//
HRESULT myFrameMoveCallbackHelper(LPDIRECT3DRMFRAME lpf1, void *lpArg, D3DVALUE delta)
{ 
                                  	// get our structure from the user args..
	FrameMoveCallback3		*fmcb = (FrameMoveCallback3 *)lpArg;	
	LPDIRECT3DRMFRAME3		lpf=NULL;
	I_dxj_Direct3dRMFrame3		*frame3=NULL;
	HRESULT				hr;

	// if RM gave is a frame (which it always will) then get the 
	// Frame3 interface as the VB api only has 1 frame type
	if (lpf1){
		hr=lpf1->QueryInterface(IID_IDirect3DRMFrame3,(void**)&lpf);
		if FAILED(hr) return hr;
	}

	// Try and find the object in our link list of cover objects
	// if its not there then create one.
	//
	// note: will eat the reference to lpf so dont release
	// bug gives us a frame3 with incrermented ref count
	INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMFrame3,lpf,&frame3);

	// if Out of memory try and exit gracefully
	if (!frame3)   return E_FAIL;


	// make sure we have a reference to any user arg object
	if (fmcb->pUser) fmcb->pUser->AddRef();

	// make sure our vb callback doesnt go away
	fmcb->c->AddRef ();

	// call into VB
	fmcb->c->callbackRMFrameMove(frame3, fmcb->pUser, delta);
	
	// clean up our reference to the vb callback
	fmcb->c->Release();

	// clean up our reference to the user arg
	if (fmcb->pUser) fmcb->pUser->Release();

	// clean up of our reference to frame3
	frame3->Release();

	// clean up our reference created when we QI for Frame3
	lpf->Release();

	// clean up the variable passed to us..
	// lpf1->Release();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// myFrameMoveCallback - rm frame move callback
//
extern "C" void __cdecl myFrameMoveCallback( LPDIRECT3DRMFRAME lpf1, void *lpArg, D3DVALUE delta)
{
        
	DPF(4,"Entered myFrameMoveCallback\r\n");
    myFrameMoveCallbackHelper(lpf1,lpArg,delta);
    DPF(4,"Exiting myFrameMoveCallback\r\n");
}
	


/////////////////////////////////////////////////////////////////////////////
// myAddDestroyCallback
//
extern "C" void __cdecl myAddDestroyCallback(LPDIRECT3DRMOBJECT obj, void *lpArg)
{

	DPF(4,"Entered myAddDestroyCallback\r\n");
	
	// dont play with obj.... this can get you in a recursive
	// situation obj is at refcount zero but calling addref and release
	// on it will get you re-entered into this callback..
	// I guess in rm folks were expected to not do that but could
	// get the name..
	// we will just pass pack any user arg 

	// Get our struct from the user args
	d3drmCallback *destroyCb = (d3drmCallback*)lpArg;
	
	// make sure we keep are reference to the vb callback
	destroyCb->c->AddRef ();
	
	DPF(4,"myAddDestroyCallback:	completed Addref VBCallback\r\n");

	// make sure we have a reference to any user arg object
	if (destroyCb->pUser) destroyCb->pUser->AddRef();
	
	DPF(4,"myAddDestroyCallback:	completed Addref userargs\r\n");

	// call into VB..
	// CONSIDER what happens when VB is being shut down.
	// if we get a reference to the object does that mean that
	// we can still execute the code
	destroyCb->c->callbackRMDestroyObject(destroyCb->pUser);
	
	DPF(4,"myAddDestroyCallback:	call into VB\r\n");

	// release reference to user object
	if (destroyCb->pUser) destroyCb->pUser->AddRef();
	
	DPF(4,"myAddDestroyCallback:	completed release userargs\r\n");

	// release our reference to vb callback
	destroyCb->c->Release();
	
	DPF(4,"myAddDestroyCallback:	completed release VBCallback\r\n");
	

	DPF(4,"Leaving myAddDestroyCallback\r\n");
	
}


/////////////////////////////////////////////////////////////////////////////
// myAddUpdateCallback3
//
// NOTE: we can only pass the first update rect to VB
// 
// note we use a cover function so that we can make calls to INTERNAL_CREATE
//

#define MYVARIANTINIT(inArg,puser) \
	VariantInit(puser); \
	user.vt=VT_UNKNOWN; \
	user.punkVal = inArg; \
	user.punkVal->AddRef();

///////////////////////////////////////////////////////////////////////////
// myAddUpdateCallback3Helper - called by Load callback 
//
// seperated out only because have multiple load callbacks
//

HRESULT myAddUpdateCallback3Helper ( LPDIRECT3DRMDEVICE3 ref,void *lpArg, int x, LPD3DRECT update)
{
   	// Get our struct from the user args
	DeviceUpdateCallback3	*updateCb = (DeviceUpdateCallback3*)lpArg;
	I_dxj_Direct3dRMDevice3 *device3  = NULL;
	VARIANT					user;
	
    	// Try and find the object in our link list of cover objects
	// if its not there then create one.
	//
	// note: will eat the reference to lpf so dont release
	// bug gives us a frame3 with incrermented ref count
	INTERNAL_CREATE_NOADDREF(_dxj_Direct3dRMDevice3,ref,&device3);

	// for reason unbeknown to me we user a variant here instead
	// of an object in our callback
	MYVARIANTINIT(updateCb->pUser,&user);

	// keep a reference to the callback
	updateCb->c->AddRef();

	// call the callback
	updateCb->c->callbackRMUpdate( device3, NULL, x, (D3dRect*)update);
	
	// releae our reference to the callback
	updateCb->c->Release();

	// clear any refernce to user args
	VariantClear(&user);

    device3->Release();

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////
// myLoadCoverFunc - called by Load callback 
//
// seperated out only because have multiple load callbacks
//
extern "C" void __cdecl myAddUpdateCallback3 ( LPDIRECT3DRMDEVICE3 ref,void *lpArg, int x, LPD3DRECT update)
{
 
	DPF(4,"Entered myAddUpdateCallback\r\n");
    myAddUpdateCallback3Helper(ref,lpArg,x,update);
	DPF(4,"Exiting myAddUpdateCallback\r\n");

}

///////////////////////////////////////////////////////////////////////////
// myLoadCoverFunc - called by Load callback 
//
// seperated out only because have multiple load callbacks
//
HRESULT myLoadCoverFunc(LPDIRECT3DRMOBJECT lpo, REFIID ObjGuid, LPVOID lpArg){
	
    I_dxj_Direct3dRMObject *pObj=NULL;
    HRESULT hr;
    
    // Get our callback struct from the user args
	LoadCallback *loadcb = (LoadCallback*)lpArg;	
	
    

    hr =CreateCoverObject(lpo,&pObj);
    
	// If no coverthing exit
	if ((pObj==NULL) ||(hr!=S_OK)) {		
		DPF(4,"Load callback - unrecognized type");		
		return E_FAIL;
	}


	// get a string represenation of whats passed in
	BSTR guid=GUIDtoBSTR((LPGUID)&ObjGuid);

	// addref the user arg 
	if (loadcb->pUser) loadcb->pUser->AddRef();

	//call into VB
	hr=((I_dxj_Direct3dRMLoadCallback*)(loadcb->c))->callbackRMLoad(&pObj,guid,loadcb->pUser);	
		
	//release the user arg
	if (loadcb->pUser) loadcb->pUser->Release();

	//free the guid string
	SysFreeString(guid);
	
	//then release pObj
	pObj->Release();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// myd3drmLoadCallback
//
extern "C" void  __cdecl myd3drmLoadCallback(LPDIRECT3DRMOBJECT lpo, REFIID ObjGuid, LPVOID lpArg)
{
	
	DPF(4,"Entered d3drmLoadCallback \r\n");
	
	myLoadCoverFunc( lpo,  ObjGuid,  lpArg);
    
    DPF(4,"Exited d3drmLoadCallback \r\n");
	return;
}




/////////////////////////////////////////////////////////////////////////////
// myCoverEnumObjects
//
// NOTE the RM bug this deals with..
//
HRESULT  myCoverEnumObjects( LPDIRECT3DRMOBJECT lpo,void *lpArg){
	EnumerateObjectsCallback *cb = (EnumerateObjectsCallback*)lpArg;
    I_dxj_Direct3dRMObject *pObj=NULL;
    HRESULT hr;

	hr=CreateCoverObject(lpo,&pObj);

	
	//RM has a bug in it that gives an extra addreff to lpo
	//get rid of it
	if (lpo) lpo->Release();
    
    //Make sure things went ok
    if FAILED(hr) return hr;	
    if (!pObj ) return E_FAIL;
	


    //addref user args
	if (cb->pUser) cb->pUser->AddRef();

    //call into VB
	cb->c->callbackRMEnumerateObjects(pObj,  cb->pUser);
	
    //release user args
    if (cb->pUser) cb->pUser->Release();

    //release pObj
    pObj->Release();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//  myEnumerateObjectsCallback
//
extern "C" void __cdecl myEnumerateObjectsCallback( LPDIRECT3DRMOBJECT lpo,void *lpArg)
{	
	
	DPF(4,"Entered myEnumerateObjectsCallback\r\n");	
	myCoverEnumObjects(lpo,lpArg);
    DPF(4,"Exited  myEnumerateObjectsCallback\r\n");
	return;
}



/////////////////////////////////////////////////////////////////////////////
// UndoCallbackLink
//
extern "C" void UndoCallbackLink(GeneralCallback *entry, GeneralCallback **head)
{
	if (entry->next)
		entry->next->prev = entry->prev;	// pick members below us
	else 
		*head = entry->prev;				// possibly NULL

	if (entry->prev)
		entry->prev->next = entry->next;	// link to members above us

	if (entry->pUser) entry->pUser->Release();

	delete entry;
}




/////////////////////////////////////////////////////////////////////////////
// AddCallbackLink
//
// Add another entry in the object link list
extern "C" void* AddCallbackLink(void **ptr2,I_dxj_Direct3dRMCallback *enumC,void *args)
{
		d3drmCallback *enumcb = new d3drmCallback; // new link entry

		if ( !enumcb ) {

			
			DPF(4,"Creation using new failed\r\n");
			
			return (d3drmCallback*)NULL;
		}

		enumcb->c		= enumC;					// user callback
		enumcb->pUser	= (struct IUnknown *)args;	// callback args
		enumcb->pParent	= NULL;					
		enumcb->prev	= (d3drmCallback*)NULL;
		enumcb->m_stopflag = FALSE;
		enumcb->m_obj   = NULL;

		//CONSIDER:  locking the linked list here with a semaphore
		//	     to be more multithread friendly..
		//	     shame shame-  possible gpf otherwise

		enumcb->next	= (d3drmCallback*)(*ptr2);	// link to other calls
		*ptr2	= enumcb;						// we are at the top

		if (enumcb->pUser) enumcb->pUser->AddRef();

		if (enumcb->prev != NULL)				// nested callbacks
		{
			enumcb->prev->next = enumcb;		// back link


		DPF(4,"Callback nesting encountered\r\n");

		}

	// Need unlock here.
	return enumcb;
}


/////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT _AddDestroyCallback(IDirect3DRMObject *iface, I_dxj_Direct3dRMCallback *oC,
										  IUnknown *args)
{
    return E_NOTIMPL;

    #if 0
	DestroyCallback *dcb;

	// killed by companion DeleteDestroyCallback
	dcb = (DestroyCallback*)AddCallbackLink((void**)&DestroyCallbacks,
										(I_dxj_Direct3dRMCallback*)oC, (void*) args);
	if (!(dcb))
	{
		
		DPF(4,"AddDestroyCallback failed!\r\n");
		
		return E_FAIL;
	}

	if (iface->AddDestroyCallback(
							myAddDestroyCallback, dcb))	
		return E_FAIL;
	
	oC->AddRef();		// callback is persistent so make it so in Java/VB Land
	//oC->AddRef();		//? 2 ...
	return S_OK;
    #endif
}

/////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT _DeleteDestroyCallback(IDirect3DRMObject *iface, I_dxj_Direct3dRMCallback *oC,
										  IUnknown *args)
{
    return E_NOTIMPL;

    #if 0
	DestroyCallback *dcb = DestroyCallbacks;

	// look for our own specific entry
	for ( ;  dcb;  dcb = dcb->next )   {

		if( (dcb->c == oC) && (dcb->pUser == args) )	{

			//note: assume the callback is not called: only removed from a list.
			iface->DeleteDestroyCallback(
							myAddDestroyCallback, dcb);

			// Remove ourselves in a thread-safe manner.
			UndoCallbackLink((GeneralCallback*)dcb,
										(GeneralCallback**)&DestroyCallbacks);
			iface->Release();
			return S_OK;
		}
	}
	iface->Release();	// none found so a release is not needed
	return E_FAIL;
    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmchordmapobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmchordmapobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"


extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicChordMap, {});
DESTRUCTOR(_dxj_DirectMusicChordMap, {});
GETSET_OBJECT(_dxj_DirectMusicChordMap);


	

HRESULT C_dxj_DirectMusicChordMapObject::getScale(long *scale)
{  
	HRESULT hr;				
	hr=m__dxj_DirectMusicChordMap->GetScale((DWORD*)scale);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmbandobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmbandobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmSegmentObj.h"
#include "dmPerformanceObj.h"
#include "dmBandObj.h"


extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicBand;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicBand, {});
DESTRUCTOR(_dxj_DirectMusicBand, {});
GETSET_OBJECT(_dxj_DirectMusicBand);

typedef IDirectMusicSegment*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance*	LPDIRECTMUSICPERFORMANCE;



HRESULT C_dxj_DirectMusicBandObject::createSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{  
	HRESULT hr;			
	LPDIRECTMUSICSEGMENT pSeg=NULL;
	hr=m__dxj_DirectMusicBand->CreateSegment(&pSeg);
	if FAILED(hr) return hr;
	if (!pSeg) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,ret);
	return hr;
}

	

HRESULT C_dxj_DirectMusicBandObject::download( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
{  
	HRESULT hr;			
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPERFORMANCE,pPer,performance);
	hr=m__dxj_DirectMusicBand->Download(pPer);
	return hr;
}

HRESULT C_dxj_DirectMusicBandObject::unload( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
{  
	HRESULT hr;			
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPERFORMANCE,pPer,performance);
	hr=m__dxj_DirectMusicBand->Unload(pPer);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmbandobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmbandobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicBandObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicBand IDirectMusicBand*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicBandObject : 
	public I_dxj_DirectMusicBand,
	//public CComCoClass<C_dxj_DirectMusicBandObject, &CLSID__dxj_DirectMusicBand>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicBandObject();
	virtual ~C_dxj_DirectMusicBandObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicBandObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicBand)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicBand,		"DIRECT.DirectMusicBand.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicBandObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	HRESULT STDMETHODCALLTYPE createSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE download( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance);

	HRESULT STDMETHODCALLTYPE unload( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance);

  

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicBand);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicBand)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmchordmapobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmchordmapobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicChordMapObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicChordMap IDirectMusicChordMap*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicChordMapObject : 
	public I_dxj_DirectMusicChordMap,
	//public CComCoClass<C_dxj_DirectMusicChordMapObject, &CLSID__dxj_DirectMusicChordMap>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicChordMapObject();
	virtual ~C_dxj_DirectMusicChordMapObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicChordMapObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicChordMap)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicChordMap,		"DIRECT.DirectMusicChordMap.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicChordMapObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

  
    HRESULT STDMETHODCALLTYPE getScale(long *s); 
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicChordMap);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicChordMap)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\directxhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       directxhelp.h
//
//--------------------------------------------------------------------------

#ifndef __VBHELP_CAFD484C_C86F_11D2_A5A6_00C04FB92CC1_DEFINED__
#define __VBHELP_CAFD484C_C86F_11D2_A5A6_00C04FB92CC1_DEFINED__

#define _vbd3drm_Direct3DRMAnimation2 867001                                        //  Direct3DRMAnimation2
#define _vbd3drm_Direct3DRMAnimationArray 867002                                    //  Direct3DRMAnimationArray
#define _vbd3drm_Direct3DRMAnimationSet2 867003                                     //  Direct3DRMAnimationSet2
#define _vbd3drm_Visual_Basic_Callback_Interfaces 867004                            //  Visual Basic Callback Interfaces
#define _vbd3drm_Direct3DRMClippedVisual 867005                                     //  Direct3DRMClippedVisual
#define _vbd3drm_Direct3DRMDevice3 867006                                           //  Direct3DRMDevice3
#define _vbd3drm_Direct3DRMDeviceArray 867007                                       //  Direct3DRMDeviceArray
#define _vbd3drm_Visual_Basic_Enumerations 867008                                   //  Visual Basic Enumerations
#define _vbd3drm_Direct3DRMFace2 867009                                             //  Direct3DRMFace2
#define _vbd3drm_Direct3DRMFaceArray 867010                                         //  Direct3DRMFaceArray
#define _vbd3drm_Direct3DRMFrame3_Methods_A_to_M 867011                             //  Direct3DRMFrame3 Methods A to M
#define _vbd3drm_Direct3DRMFrame3_Methods_N_to_Z 867012                             //  Direct3DRMFrame3 Methods N to Z
#define _vbd3drm_Direct3DRMFrame3 867013                                            //  Direct3DRMFrame3
#define _vbd3drm_Direct3DRMFrameArray 867014                                        //  Direct3DRMFrameArray
#define _vbd3drm_Direct3DRMFrameInterpolator 867015                                 //  Direct3DRMFrameInterpolator
#define _vbd3drm_Further_Reading_for_Visual_Basic_Programmers 867016                //  Further Reading for Visual Basic Programmers
#define _vbd3drm_Direct3DRM3 867017                                                 //  Direct3DRM3
#define _vbd3drm_Visual_Basic_Interfaces 867018                                     //  Visual Basic Interfaces
#define _vbd3drm_Direct3DRMLight 867019                                             //  Direct3DRMLight
#define _vbd3drm_Direct3DRMLightArray 867020                                        //  Direct3DRMLightArray
#define _vbd3drm_Direct3DRMLightInterpolator 867021                                 //  Direct3DRMLightInterpolator
#define _vbd3drm_Direct3DRMMaterial2 867022                                         //  Direct3DRMMaterial2
#define _vbd3drm_Direct3DRMMaterialInterpolator 867023                              //  Direct3DRMMaterialInterpolator
#define _vbd3drm_Direct3DRMMesh 867024                                              //  Direct3DRMMesh
#define _vbd3drm_Direct3DRMMeshBuilder3 867025                                      //  Direct3DRMMeshBuilder3
#define _vbd3drm_Direct3DRMMeshInterpolator 867026                                  //  Direct3DRMMeshInterpolator
#define _vbd3drm_Direct3DRMObject 867027                                            //  Direct3DRMObject
#define _vbd3drm_Direct3DRMObjectArray 867028                                       //  Direct3DRMObjectArray
#define _vbd3drm_Direct3DRMPick2Array 867029                                        //  Direct3DRMPick2Array
#define _vbd3drm_Direct3DRMPickArray 867030                                         //  Direct3DRMPickArray
#define _vbd3drm_Direct3DRMProgressiveMesh 867031                                   //  Direct3DRMProgressiveMesh
#define _vbd3drm_Reference 867032                                                   //  Reference
#define _D3DRM_Error_Values 867033                                                  //  Visual Basic Error Values
#define _vbd3drm_Direct3DRMShadow2 867034                                           //  Direct3DRMShadow2
#define _vbd3drm_Visual_Basic_Types 867035                                          //  Visual Basic Types
#define _vbd3drm_Direct3DRMTexture3 867036                                          //  Direct3DRMTexture3
#define _vbd3drm_Direct3DRMTextureInterpolator 867037                               //  Direct3DRMTextureInterpolator
#define _vbd3drm_Direct3DRMUserVisual 867038                                        //  Direct3DRMUserVisual
#define _vbd3drm_Direct3DRMViewport2 867039                                         //  Direct3DRMViewport2
#define _vbd3drm_Direct3DRMViewportArray 867040                                     //  Direct3DRMViewportArray
#define _vbd3drm_Direct3DRMViewportInterpolator 867041                              //  Direct3DRMViewportInterpolator
#define _vbd3drm_Direct3DRMVisual 867042                                            //  Direct3DRMVisual
#define _vbd3drm_Direct3DRMVisualArray 867043                                       //  Direct3DRMVisualArray
#define _vbd3drm_Direct3DRMWrap 867044                                              //  Direct3DRMWrap
#define idh__dx_direct3d3_d3d_vb 867045                                             //  Direct3D3
#define idh__dx_direct3d3_createdevice_d3d_vb 867046                                //  Direct3D3.CreateDevice
#define idh__dx_direct3d3_createlight_d3d_vb 867047                                 //  Direct3D3.CreateLight
#define idh__dx_direct3d3_creatematerial_d3d_vb 867048                              //  Direct3D3.CreateMaterial
#define idh__dx_direct3d3_createvertexbuffer_d3d_vb 867049                          //  Direct3D3.CreateVertexBuffer
#define idh__dx_direct3d3_createviewport_d3d_vb 867050                              //  Direct3D3.CreateViewport
#define idh__dx_direct3d3_evictmanagedtextures_d3d_vb 867051                        //  Direct3D3.EvictManagedTextures
#define idh__dx_direct3d3_finddevice_d3d_vb 867052                                  //  Direct3D3.FindDevice
#define idh__dx_direct3d3_getdevicesenum_d3d_vb 867053                              //  Direct3D3.GetDevicesEnum
#define idh__dx_direct3d3_getdirectdraw_d3d_vb 867054                               //  Direct3D3.GetDirectDraw
#define idh__dx_direct3d3_getenumzbufferformats_d3d_vb 867055                       //  Direct3D3.GetEnumZBufferFormats
#define idh__dx_direct3ddevice3_d3d_vb 867056                                       //  Direct3DDevice3
#define idh__dx_direct3ddevice3_addviewport_d3d_vb 867057                           //  Direct3DDevice3.AddViewport
#define idh__dx_direct3ddevice3_begin_d3d_vb 867058                                 //  Direct3DDevice3.Begin
#define idh__dx_direct3ddevice3_beginindexed_d3d_vb 867059                          //  Direct3DDevice3.BeginIndexed
#define idh__dx_direct3ddevice3_beginscene_d3d_vb 867060                            //  Direct3DDevice3.BeginScene
#define idh__dx_direct3ddevice3_computespherevisibility_d3d_vb 867061               //  Direct3DDevice3.ComputeSphereVisibility
#define idh__dx_direct3ddevice3_deleteviewport_d3d_vb 867062                        //  Direct3DDevice3.DeleteViewport
#define idh__dx_direct3ddevice3_drawindexedprimitive_d3d_vb 867063                  //  Direct3DDevice3.DrawIndexedPrimitive
#define idh__dx_direct3ddevice3_drawindexedprimitivevb_d3d_vb 867064                //  Direct3DDevice3.DrawIndexedPrimitiveVB
#define idh__dx_direct3ddevice3_drawprimitive_d3d_vb 867065                         //  Direct3DDevice3.DrawPrimitive
#define idh__dx_direct3ddevice3_drawprimitivevb_d3d_vb 867066                       //  Direct3DDevice3.DrawPrimitiveVB
#define idh__dx_direct3ddevice3_end_d3d_vb 867067                                   //  Direct3DDevice3.End
#define idh__dx_direct3ddevice3_endscene_d3d_vb 867068                              //  Direct3DDevice3.EndScene
#define idh__dx_direct3ddevice3_getcaps_d3d_vb 867069                               //  Direct3DDevice3.GetCaps
#define idh__dx_direct3ddevice3_getclipstatus_d3d_vb 867070                         //  Direct3DDevice3.GetClipStatus
#define idh__dx_direct3ddevice3_getcurrentviewport_d3d_vb 867071                    //  Direct3DDevice3.GetCurrentViewport
#define idh__dx_direct3ddevice3_getdirect3d_d3d_vb 867072                           //  Direct3DDevice3.GetDirect3D
#define idh__dx_direct3ddevice3_getlightstate_d3d_vb 867073                         //  Direct3DDevice3.GetLightState
#define idh__dx_direct3ddevice3_getrenderstate_d3d_vb 867074                        //  Direct3DDevice3.GetRenderState
#define idh__dx_direct3ddevice3_getrendertarget_d3d_vb 867075                       //  Direct3DDevice3.GetRenderTarget
#define idh__dx_direct3ddevice3_getstats_d3d_vb 867076                              //  Direct3DDevice3.GetStats
#define idh__dx_direct3ddevice3_gettexture_d3d_vb 867077                            //  Direct3DDevice3.GetTexture
#define idh__dx_direct3ddevice3_gettextureformatsenum_d3d_vb 867078                 //  Direct3DDevice3.GetTextureFormatsEnum
#define idh__dx_direct3ddevice3_gettexturestagestate_d3d_vb 867079                  //  Direct3DDevice3.GetTextureStageState
#define idh__dx_direct3ddevice3_gettransform_d3d_vb 867080                          //  Direct3DDevice3.GetTransform
#define idh__dx_direct3ddevice3_index_d3d_vb 867081                                 //  Direct3DDevice3.Index
#define idh__dx_direct3ddevice3_multiplytransform_d3d_vb 867082                     //  Direct3DDevice3.MultiplyTransform
#define idh__dx_direct3ddevice3_nextviewport_d3d_vb 867083                          //  Direct3DDevice3.NextViewport
#define idh__dx_direct3ddevice3_setclipstatus_d3d_vb 867084                         //  Direct3DDevice3.SetClipStatus
#define idh__dx_direct3ddevice3_setcurrentviewport_d3d_vb 867085                    //  Direct3DDevice3.SetCurrentViewport
#define idh__dx_direct3ddevice3_setlightstate_d3d_vb 867086                         //  Direct3DDevice3.SetLightState
#define idh__dx_direct3ddevice3_setrenderstate_d3d_vb 867087                        //  Direct3DDevice3.SetRenderState
#define idh__dx_direct3ddevice3_setrendertarget_d3d_vb 867088                       //  Direct3DDevice3.SetRenderTarget
#define idh__dx_direct3ddevice3_settexture_d3d_vb 867089                            //  Direct3DDevice3.SetTexture
#define idh__dx_direct3ddevice3_settexturestagestate_d3d_vb 867090                  //  Direct3DDevice3.SetTextureStageState
#define idh__dx_direct3ddevice3_settransform_d3d_vb 867091                          //  Direct3DDevice3.SetTransform
#define idh__dx_direct3ddevice3_validatedevice_d3d_vb 867092                        //  Direct3DDevice3.ValidateDevice
#define idh__dx_direct3ddevice3_vertex_d3d_vb 867093                                //  Direct3DDevice3.Vertex
#define idh__dx_direct3denumdevices_d3d_vb 867094                                   //  Direct3DEnumDevices
#define idh__dx_direct3denumdevices_getcount_d3d_vb 867095                          //  Direct3DEnumDevices.GetCount
#define idh__dx_direct3denumdevices_getdescription_d3d_vb 867096                    //  Direct3DEnumDevices.GetDescription
#define idh__dx_direct3denumdevices_getguid_d3d_vb 867097                           //  Direct3DEnumDevices.GetGuid
#define idh__dx_direct3denumdevices_getheldesc_d3d_vb 867098                        //  Direct3DEnumDevices.GetHELDesc
#define idh__dx_direct3denumdevices_gethwdesc_d3d_vb 867099                         //  Direct3DEnumDevices.GetHWDesc
#define idh__dx_direct3denumdevices_getname_d3d_vb 867100                           //  Direct3DEnumDevices.GetName
#define idh__dx_direct3denumpixelformats_d3d_vb 867101                              //  Direct3DEnumPixelFormats
#define idh__dx_direct3denumpixelformats_getcount_d3d_vb 867102                     //  Direct3DEnumPixelFormats.GetCount
#define idh__dx_direct3denumpixelformats_getitem_d3d_vb 867103                      //  Direct3DEnumPixelFormats.GetItem
#define idh__dx_direct3dlight_d3d_vb 867104                                         //  Direct3DLight
#define idh__dx_direct3dlight_getlight_d3d_vb 867105                                //  Direct3DLight.GetLight
#define idh__dx_direct3dlight_setlight_d3d_vb 867106                                //  Direct3DLight.SetLight
#define idh__dx_direct3dmaterial3_d3d_vb 867107                                     //  Direct3DMaterial3
#define idh__dx_direct3dmaterial3_gethandle_d3d_vb 867108                           //  Direct3DMaterial3.GetHandle
#define idh__dx_direct3dmaterial3_getmaterial_d3d_vb 867109                         //  Direct3DMaterial3.GetMaterial
#define idh__dx_direct3dmaterial3_setmaterial_d3d_vb 867110                         //  Direct3DMaterial3.SetMaterial
#define idh__dx_direct3dtexture2_d3d_vb 867111                                      //  Direct3DTexture2
#define idh__dx_direct3dtexture2_gethandle_d3d_vb 867112                            //  Direct3DTexture2.GetHandle
#define idh__dx_direct3dtexture2_getsurface_d3d_vb 867113                           //  Direct3DTexture2.GetSurface
#define idh__dx_direct3dtexture2_load_d3d_vb 867114                                 //  Direct3DTexture2.Load
#define idh__dx_direct3dtexture2_palettechanged_d3d_vb 867115                       //  Direct3DTexture2.PaletteChanged
#define idh__dx_direct3dvertexbuffer_d3d_vb 867116                                  //  Direct3DVertexBuffer
#define idh__dx_direct3dvertexbuffer_getvertexbufferdesc_d3d_vb 867117              //  Direct3DVertexBuffer.GetVertexBufferDesc
#define idh__dx_direct3dvertexbuffer_getvertices_d3d_vb 867118                      //  Direct3DVertexBuffer.GetVertices
#define idh__dx_direct3dvertexbuffer_lock_d3d_vb 867119                             //  Direct3DVertexBuffer.Lock
#define idh__dx_direct3dvertexbuffer_optimize_d3d_vb 867120                         //  Direct3DVertexBuffer.Optimize
#define idh__dx_direct3dvertexbuffer_processvertices_d3d_vb 867121                  //  Direct3DVertexBuffer.ProcessVertices
#define idh__dx_direct3dvertexbuffer_setvertices_d3d_vb 867122                      //  Direct3DVertexBuffer.SetVertices
#define idh__dx_direct3dvertexbuffer_unlock_d3d_vb 867123                           //  Direct3DVertexBuffer.Unlock
#define idh__dx_direct3dviewport3_d3d_vb 867124                                     //  Direct3DViewport3
#define idh__dx_direct3dviewport3_addlight_d3d_vb 867125                            //  Direct3DViewport3.AddLight
#define idh__dx_direct3dviewport3_clear_d3d_vb 867126                               //  Direct3DViewport3.Clear
#define idh__dx_direct3dviewport3_clear2_d3d_vb 867127                              //  Direct3DViewport3.Clear2
#define idh__dx_direct3dviewport3_deletelight_d3d_vb 867128                         //  Direct3DViewport3.DeleteLight
#define idh__dx_direct3dviewport3_getbackground_d3d_vb 867129                       //  Direct3DViewport3.GetBackground
#define idh__dx_direct3dviewport3_getbackgrounddepth_d3d_vb 867130                  //  Direct3DViewport3.GetBackgroundDepth
#define idh__dx_direct3dviewport3_getviewport_d3d_vb 867131                         //  Direct3DViewport3.GetViewport
#define idh__dx_direct3dviewport3_getviewport2_d3d_vb 867132                        //  Direct3DViewport3.GetViewport2
#define idh__dx_direct3dviewport3_lightelements_d3d_vb 867133                       //  Direct3DViewport3.LightElements
#define idh__dx_direct3dviewport3_nextlight_d3d_vb 867134                           //  Direct3DViewport3.NextLight
#define idh__dx_direct3dviewport3_setbackground_d3d_vb 867135                       //  Direct3DViewport3.SetBackground
#define idh__dx_direct3dviewport3_setbackgrounddepth_d3d_vb 867136                  //  Direct3DViewport3.SetBackgroundDepth
#define idh__dx_direct3dviewport3_setviewport_d3d_vb 867137                         //  Direct3DViewport3.SetViewport
#define idh__dx_direct3dviewport3_setviewport2_d3d_vb 867138                        //  Direct3DViewport3.SetViewport2
#define idh__dx_direct3dviewport3_transformvertices_d3d_vb 867139                   //  Direct3DViewport3.TransformVertices
#define idh__dx_d3dclipstatus_d3d_vb 867140                                         //  D3DCLIPSTATUS
#define idh__dx_d3dcolorvalue_d3d_vb 867141                                         //  D3DCOLORVALUE
#define idh__dx_d3ddevicedesc_d3d_vb 867142                                         //  D3DDEVICEDESC
#define idh__dx_d3dfinddeviceresult2_d3d_vb 867143                                  //  D3DFINDDEVICERESULT2
#define idh__dx_d3dfinddevicesearch_d3d_vb 867144                                   //  D3DFINDDEVICESEARCH
#define idh__dx_d3dhvertex_d3d_vb 867145                                            //  D3DHVERTEX
#define idh__dx_d3dlight2_d3d_vb 867146                                             //  D3DLIGHT2
#define idh__dx_d3dlightdata_d3d_vb 867147                                          //  D3DLIGHTDATA
#define idh__dx_d3dlightingcaps_d3d_vb 867148                                       //  D3DLIGHTINGCAPS
#define idh__dx_d3dlvertex_d3d_vb 867149                                            //  D3DLVERTEX
#define idh__dx_d3dmaterial_d3d_vb 867150                                           //  D3DMATERIAL
#define idh__dx_d3dmatrix_d3d_vb 867151                                             //  D3DMATRIX
#define idh__dx_d3dprimcaps_d3d_vb 867152                                           //  D3DPRIMCAPS
#define idh__dx_d3drect_d3d_vb 867153                                               //  D3DRECT
#define idh__dx_d3drotation_d3d_vb 867154                                           //  D3DROTATION
#define idh__dx_d3dstats_d3d_vb 867155                                              //  D3DSTATS
#define idh__dx_d3dstatus_d3d_vb 867156                                             //  D3DSTATUS
#define idh__dx_d3dtlvertex_d3d_vb 867157                                           //  D3DTLVERTEX
#define idh__dx_d3dtransformdata_d3d_vb 867158                                      //  D3DTRANSFORMDATA
#define idh__dx_d3dvector_d3d_vb 867159                                             //  D3DVECTOR
#define idh__dx_d3dvertex_d3d_vb 867160                                             //  D3DVERTEX
#define idh__dx_d3dvertexbufferdesc_d3d_vb 867161                                   //  D3DVERTEXBUFFERDESC
#define idh__dx_d3dviewport_d3d_vb 867162                                           //  D3DVIEWPORT
#define idh__dx_d3dviewport2_d3d_vb 867163                                          //  D3DVIEWPORT2
#define idh__dx_dxdriverinfo_d3d_vb 867164                                          //  DXDRIVERINFO
#define idh__dx_const_d3d_d3d_vb 867165                                             //  CONST_D3D
#define idh__dx_const_d3dantialiasmode_d3d_vb 867166                                //  CONST_D3DANTIALIASMODE
#define idh__dx_const_d3dblend_d3d_vb 867167                                        //  CONST_D3DBLEND
#define idh__dx_const_d3dcapsblend_d3d_vb 867168                                    //  CONST_D3DCAPSBLEND
#define idh__dx_const_d3dcapscmp_d3d_vb 867169                                      //  CONST_D3DCAPSCMP
#define idh__dx_const_d3dcapsmisc_d3d_vb 867170                                     //  CONST_D3DCAPSMISC
#define idh__dx_const_d3dcapsraster_d3d_vb 867171                                   //  CONST_D3DCAPSRASTER
#define idh__dx_const_d3dcapsshade_d3d_vb 867172                                    //  CONST_D3DCAPSSHADE
#define idh__dx_const_d3dcapstexture_d3d_vb 867173                                  //  CONST_D3DCAPSTEXTURE
#define idh__dx_const_d3dcapstextureaddress_d3d_vb 867174                           //  CONST_D3DCAPSTEXTUREADDRESS
#define idh__dx_const_d3dcapstextureblend_d3d_vb 867175                             //  CONST_D3DCAPSTEXTUREBLEND
#define idh__dx_const_d3dcapstexturefilter_d3d_vb 867176                            //  CONST_D3DCAPSTEXTUREFILTER
#define idh__dx_const_d3dclearflags_d3d_vb 867177                                   //  CONST_D3DCLEARFLAGS
#define idh__dx_const_d3dclipflags_d3d_vb 867178                                    //  CONST_D3DCLIPFLAGS
#define idh__dx_const_d3dclipstatusflags_d3d_vb 867179                              //  CONST_D3DCLIPSTATUSFLAGS
#define idh__dx_const_d3dcmpfunc_d3d_vb 867180                                      //  CONST_D3DCMPFUNC
#define idh__dx_const_d3dcolormodel_d3d_vb 867181                                   //  CONST_D3DCOLORMODEL
#define idh__dx_const_d3dcull_d3d_vb 867182                                         //  CONST_D3DCULL
#define idh__dx_const_d3ddevicedesccaps_d3d_vb 867183                               //  CONST_D3DDEVICEDESCCAPS
#define idh__dx_const_d3ddevicedescflags_d3d_vb 867184                              //  CONST_D3DDEVICEDESCFLAGS
#define idh__dx_const_d3ddpflags_d3d_vb 867185                                      //  CONST_D3DDPFLAGS
#define idh__dx_const_d3dfillmode_d3d_vb 867186                                     //  CONST_D3DFILLMODE
#define idh__dx_const_d3dfinddevicesearchflags_d3d_vb 867187                        //  CONST_D3DFINDDEVICESEARCHFLAGS
#define idh__dx_const_d3dfogmode_d3d_vb 867188                                      //  CONST_D3DFOGMODE
#define idh__dx_const_d3dfvfcapsflags_d3d_vb 867189                                 //  CONST_D3DFVFCAPSFLAGS
#define idh__dx_const_d3dfvfflags_d3d_vb 867190                                     //  CONST_D3DFVFFLAGS
#define idh__dx_const_d3dimerr_d3d_vb 867191                                        //  CONST_D3DIMERR
#define idh__dx_const_d3dlight2flags_d3d_vb 867192                                  //  CONST_D3DLIGHT2FLAGS
#define idh__dx_const_d3dlightcapsflags_d3d_vb 867193                               //  CONST_D3DLIGHTCAPSFLAGS
#define idh__dx_const_d3dlightingmodelflags_d3d_vb 867194                           //  CONST_D3DLIGHTINGMODELFLAGS
#define idh__dx_const_d3dlightstatetype_d3d_vb 867195                               //  CONST_D3DLIGHTSTATETYPE
#define idh__dx_const_d3dlighttype_d3d_vb 867196                                    //  CONST_D3DLIGHTTYPE
#define idh__dx_const_d3dnextflags_d3d_vb 867197                                    //  CONST_D3DNEXTFLAGS
#define idh__dx_const_d3dpalflags_d3d_vb 867198                                     //  CONST_D3DPALFLAGS
#define idh__dx_const_d3dprimitivetype_d3d_vb 867199                                //  CONST_D3DPRIMITIVETYPE
#define idh__dx_const_d3drenderstatetype_d3d_vb 867200                              //  CONST_D3DRENDERSTATETYPE
#define idh__dx_const_d3dsetstatusflags_d3d_vb 867201                               //  CONST_D3DSETSTATUSFLAGS
#define idh__dx_const_d3dshademode_d3d_vb 867202                                    //  CONST_D3DSHADEMODE
#define idh__dx_const_d3dstencilcapsflags_d3d_vb 867203                             //  CONST_D3DSTENCILCAPSFLAGS
#define idh__dx_const_d3dstencilop_d3d_vb 867204                                    //  CONST_D3DSTENCILOP
#define idh__dx_const_d3dtaflags_d3d_vb 867205                                      //  CONST_D3DTAFLAGS
#define idh__dx_const_d3dtexopcapsflags_d3d_vb 867206                               //  CONST_D3DTEXOPCAPSFLAGS
#define idh__dx_const_d3dtextureaddress_d3d_vb 867207                               //  CONST_D3DTEXTUREADDRESS
#define idh__dx_const_d3dtextureblend_d3d_vb 867208                                 //  CONST_D3DTEXTUREBLEND
#define idh__dx_const_d3dtexturefilter_d3d_vb 867209                                //  CONST_D3DTEXTUREFILTER
#define idh__dx_const_d3dtexturemagfilter_d3d_vb 867210                             //  CONST_D3DTEXTUREMAGFILTER
#define idh__dx_const_d3dtextureminfilter_d3d_vb 867211                             //  CONST_D3DTEXTUREMINFILTER
#define idh__dx_const_d3dtexturemipfilter_d3d_vb 867212                             //  CONST_D3DTEXTUREMIPFILTER
#define idh__dx_const_d3dtextureop_d3d_vb 867213                                    //  CONST_D3DTEXTUREOP
#define idh__dx_const_d3dtexturestagestatetype_d3d_vb 867214                        //  CONST_D3DTEXTURESTAGESTATETYPE
#define idh__dx_const_d3dtransformcaps_d3d_vb 867215                                //  CONST_D3DTRANSFORMCAPS
#define idh__dx_const_d3dtransformflags_d3d_vb 867216                               //  CONST_D3DTRANSFORMFLAGS
#define idh__dx_const_d3dtransformstatetype_d3d_vb 867217                           //  CONST_D3DTRANSFORMSTATETYPE
#define idh__dx_const_d3dvbcapsflags_d3d_vb 867218                                  //  CONST_D3DVBCAPSFLAGS
#define idh__dx_const_d3dvertextype_d3d_vb 867219                                   //  CONST_D3DVERTEXTYPE
#define idh__dx_const_d3dvisflags_d3d_vb 867220                                     //  CONST_D3DVISFLAGS
#define idh__dx_const_d3dvopflags_d3d_vb 867221                                     //  CONST_D3DVOPFLAGS
#define idh__dx_const_d3dzbuffertype_d3d_vb 867222                                  //  CONST_D3DZBUFFERTYPE
#define idh__dx_directdraw4_ddraw_vb 867223                                         //  DirectDraw4
#define idh__dx_directdraw4_createclipper_ddraw_vb 867224                           //  DirectDraw4.CreateClipper
#define idh__dx_directdraw4_createpalette_ddraw_vb 867225                           //  DirectDraw4.CreatePalette
#define idh__dx_directdraw4_createsurface_ddraw_vb 867226                           //  DirectDraw4.CreateSurface
#define idh__dx_directdraw4_createsurfacefromfile_ddraw_vb 867227                   //  DirectDraw4.CreateSurfaceFromFile
#define idh__dx_directdraw4_createsurfacefromresource_ddraw_vb 867228               //  DirectDraw4.CreateSurfaceFromResource
#define idh__dx_directdraw4_duplicatesurface_ddraw_vb 867229                        //  DirectDraw4.DuplicateSurface
#define idh__dx_directdraw4_fliptogdisurface_ddraw_vb 867230                        //  DirectDraw4.FlipToGDISurface
#define idh__dx_directdraw4_getavailabletotalmem_ddraw_vb 867231                    //  DirectDraw4.GetAvailableTotalMem
#define idh__dx_directdraw4_getcaps_ddraw_vb 867232                                 //  DirectDraw4.GetCaps
#define idh__dx_directdraw4_getdirect3d_ddraw_vb 867233                             //  DirectDraw4.GetDirect3D
#define idh__dx_directdraw4_getdisplaymode_ddraw_vb 867234                          //  DirectDraw4.GetDisplayMode
#define idh__dx_directdraw4_getdisplaymodesenum_ddraw_vb 867235                     //  DirectDraw4.GetDisplayModesEnum
#define idh__dx_directdraw4_getfourcccodes_ddraw_vb 867236                          //  DirectDraw4.GetFourCCCodes
#define idh__dx_directdraw4_getfreemem_ddraw_vb 867237                              //  DirectDraw4.GetFreeMem
#define idh__dx_directdraw4_getgdisurface_ddraw_vb 867238                           //  DirectDraw4.GetGDISurface
#define idh__dx_directdraw4_getmonitorfrequency_ddraw_vb 867239                     //  DirectDraw4.GetMonitorFrequency
#define idh__dx_directdraw4_getnumfourcccodes_ddraw_vb 867240                       //  DirectDraw4.GetNumFourCCCodes
#define idh__dx_directdraw4_getscanline_ddraw_vb 867241                             //  DirectDraw4.GetScanLine
#define idh__dx_directdraw4_getsurfacefromdc_ddraw_vb 867242                        //  DirectDraw4.GetSurfaceFromDC
#define idh__dx_directdraw4_getsurfacesenum_ddraw_vb 867243                         //  DirectDraw4.GetSurfacesEnum
#define idh__dx_directdraw4_getverticalblankstatus_ddraw_vb 867244                  //  DirectDraw4.GetVerticalBlankStatus
#define idh__dx_directdraw4_loadpalettefrombitmap_ddraw_vb 867245                   //  DirectDraw4.LoadPaletteFromBitmap
#define idh__dx_directdraw4_restoreallsurfaces_ddraw_vb 867246                      //  DirectDraw4.RestoreAllSurfaces
#define idh__dx_directdraw4_restoredisplaymode_ddraw_vb 867247                      //  DirectDraw4.RestoreDisplayMode
#define idh__dx_directdraw4_setcooperativelevel_ddraw_vb 867248                     //  DirectDraw4.SetCooperativeLevel
#define idh__dx_directdraw4_setdisplaymode_ddraw_vb 867249                          //  DirectDraw4.SetDisplayMode
#define idh__dx_directdraw4_testcooperativelevel_ddraw_vb 867250                    //  DirectDraw4.TestCooperativeLevel
#define idh__dx_directdraw4_waitforverticalblank_ddraw_vb 867251                    //  DirectDraw4.WaitForVerticalBlank
#define idh__dx_directdrawclipper_ddraw_vb 867252                                   //  DirectDrawClipper
#define idh__dx_directdrawclipper_getcliplist_ddraw_vb 867253                       //  DirectDrawClipper.GetClipList
#define idh__dx_directdrawclipper_getcliplistsize_ddraw_vb 867254                   //  DirectDrawClipper.GetClipListSize
#define idh__dx_directdrawclipper_gethwnd_ddraw_vb 867255                           //  DirectDrawClipper.GetHWnd
#define idh__dx_directdrawclipper_iscliplistchanged_ddraw_vb 867256                 //  DirectDrawClipper.IsClipListChanged
#define idh__dx_directdrawclipper_setcliplist_ddraw_vb 867257                       //  DirectDrawClipper.SetClipList
#define idh__dx_directdrawclipper_sethwnd_ddraw_vb 867258                           //  DirectDrawClipper.SetHWnd
#define idh__dx_directdrawcolorcontrol_ddraw_vb 867259                              //  DirectDrawColorControl
#define idh__dx_directdrawcolorcontrol_getcolorcontrols_ddraw_vb 867260             //  DirectDrawColorControl.GetColorControls
#define idh__dx_directdrawcolorcontrol_setcolorcontrols_ddraw_vb 867261             //  DirectDrawColorControl.SetColorControls
#define idh__dx_directdrawenum_ddraw_vb 867262                                      //  DirectDrawEnum
#define idh__dx_directdrawenum_getcount_ddraw_vb 867263                             //  DirectDrawEnum.GetCount
#define idh__dx_directdrawenum_getdescription_ddraw_vb 867264                       //  DirectDrawEnum.GetDescription
#define idh__dx_directdrawenum_getguid_ddraw_vb 867265                              //  DirectDrawEnum.GetGuid
#define idh__dx_directdrawenum_getname_ddraw_vb 867266                              //  DirectDrawEnum.GetName
#define idh__dx_directdrawenummodes_ddraw_vb 867267                                 //  DirectDrawEnumModes
#define idh__dx_directdrawenummodes_getcount_ddraw_vb 867268                        //  DirectDrawEnumModes.GetCount
#define idh__dx_directdrawenummodes_getitem_ddraw_vb 867269                         //  DirectDrawEnumModes.GetItem
#define idh__dx_directdrawenumsurfaces_ddraw_vb 867270                              //  DirectDrawEnumSurfaces
#define idh__dx_directdrawenumsurfaces_getcount_ddraw_vb 867271                     //  DirectDrawEnumSurfaces.GetCount
#define idh__dx_directdrawenumsurfaces_getitem_ddraw_vb 867272                      //  DirectDrawEnumSurfaces.GetItem
#define idh__dx_directdrawgammacontrol_ddraw_vb 867273                              //  DirectDrawGammaControl
#define idh__dx_directdrawgammacontrol_getgammaramp_ddraw_vb 867274                 //  DirectDrawGammaControl.GetGammaRamp
#define idh__dx_directdrawgammacontrol_setgammaramp_ddraw_vb 867275                 //  DirectDrawGammaControl.SetGammaRamp
#define idh__dx_directdrawpalette_ddraw_vb 867276                                   //  DirectDrawPalette
#define idh__dx_directdrawpalette_getcaps_ddraw_vb 867277                           //  DirectDrawPalette.GetCaps
#define idh__dx_directdrawpalette_getentries_ddraw_vb 867278                        //  DirectDrawPalette.GetEntries
#define idh__dx_directdrawpalette_setentries_ddraw_vb 867279                        //  DirectDrawPalette.SetEntries
#define idh__dx_directdrawsurface4_ddraw_vb 867280                                  //  DirectDrawSurface4
#define idh__dx_directdrawsurface4_addattachedsurface_ddraw_vb 867281               //  DirectDrawSurface4.AddAttachedSurface
#define idh__dx_directdrawsurface4_addoverlaydirtyrect_ddraw_vb 867282              //  DirectDrawSurface4.AddOverlayDirtyRect
#define idh__dx_directdrawsurface4_blt_ddraw_vb 867283                              //  DirectDrawSurface4.Blt
#define idh__dx_directdrawsurface4_bltcolorfill_ddraw_vb 867284                     //  DirectDrawSurface4.BltColorFill
#define idh__dx_directdrawsurface4_bltfast_ddraw_vb 867285                          //  DirectDrawSurface4.BltFast
#define idh__dx_directdrawsurface4_bltfx_ddraw_vb 867286                            //  DirectDrawSurface4.BltFx
#define idh__dx_directdrawsurface4_changeuniquenessvalue_ddraw_vb 867287            //  DirectDrawSurface4.ChangeUniquenessValue
#define idh__dx_directdrawsurface4_deleteattachedsurface_ddraw_vb 867288            //  DirectDrawSurface4.DeleteAttachedSurface
#define idh__dx_directdrawsurface4_flip_ddraw_vb 867289                             //  DirectDrawSurface4.Flip
#define idh__dx_directdrawsurface4_freeprivatedata_ddraw_vb 867290                  //  DirectDrawSurface4.FreePrivateData
#define idh__dx_directdrawsurface4_getattachedsurface_ddraw_vb 867291               //  DirectDrawSurface4.GetAttachedSurface
#define idh__dx_directdrawsurface4_getattachedsurfaceenum_ddraw_vb 867292           //  DirectDrawSurface4.GetAttachedSurfaceEnum
#define idh__dx_directdrawsurface4_getbltstatus_ddraw_vb 867293                     //  DirectDrawSurface4.GetBltStatus
#define idh__dx_directdrawsurface4_getcaps_ddraw_vb 867294                          //  DirectDrawSurface4.GetCaps
#define idh__dx_directdrawsurface4_getclipper_ddraw_vb 867295                       //  DirectDrawSurface4.GetClipper
#define idh__dx_directdrawsurface4_getcolorkey_ddraw_vb 867296                      //  DirectDrawSurface4.GetColorKey
#define idh__dx_directdrawsurface4_getdc_ddraw_vb 867297                            //  DirectDrawSurface4.GetDC
#define idh__dx_directdrawsurface4_getdirectdraw_ddraw_vb 867298                    //  DirectDrawSurface4.GetDirectDraw
#define idh__dx_directdrawsurface4_getdirectdrawcolorcontrol_ddraw_vb 867299        //  DirectDrawSurface4.GetDirectDrawColorControl
#define idh__dx_directdrawsurface4_getdirectdrawgammacontrol_ddraw_vb 867300        //  DirectDrawSurface4.GetDirectDrawGammaControl
#define idh__dx_directdrawsurface4_getflipstatus_ddraw_vb 867301                    //  DirectDrawSurface4.GetFlipStatus
#define idh__dx_directdrawsurface4_getlockedpixel_ddraw_vb 867302                   //  DirectDrawSurface4.GetLockedPixel
#define idh__dx_directdrawsurface4_getlockedsurfacebits_ddraw_vb 867303             //  DirectDrawSurface4.GetLockedSurfaceBits
#define idh__dx_directdrawsurface4_getoverlaypositionx_ddraw_vb 867304              //  DirectDrawSurface4.GetOverlayPositionX
#define idh__dx_directdrawsurface4_getoverlaypositiony_ddraw_vb 867305              //  DirectDrawSurface4.GetOverlayPositionY
#define idh__dx_directdrawsurface4_getoverlayzordersenum_ddraw_vb 867306            //  DirectDrawSurface4.GetOverlayZOrdersEnum
#define idh__dx_directdrawsurface4_getpalette_ddraw_vb 867307                       //  DirectDrawSurface4.GetPalette
#define idh__dx_directdrawsurface4_getpixelformat_ddraw_vb 867308                   //  DirectDrawSurface4.GetPixelFormat
#define idh__dx_directdrawsurface4_getprivatedata_ddraw_vb 867309                   //  DirectDrawSurface4.GetPrivateData
#define idh__dx_directdrawsurface4_getprivatedatasize_ddraw_vb 867310               //  DirectDrawSurface4.GetPrivateDataSize
#define idh__dx_directdrawsurface4_getsurfacedesc_ddraw_vb 867311                   //  DirectDrawSurface4.GetSurfaceDesc
#define idh__dx_directdrawsurface4_gettexture_ddraw_vb 867312                       //  DirectDrawSurface4.GetTexture
#define idh__dx_directdrawsurface4_getuniquenessvalue_ddraw_vb 867313               //  DirectDrawSurface4.GetUniquenessValue
#define idh__dx_directdrawsurface4_islost_ddraw_vb 867314                           //  DirectDrawSurface4.IsLost
#define idh__dx_directdrawsurface4_lock_ddraw_vb 867315                             //  DirectDrawSurface4.Lock
#define idh__dx_directdrawsurface4_releasedc_ddraw_vb 867316                        //  DirectDrawSurface4.ReleaseDC
#define idh__dx_directdrawsurface4_restore_ddraw_vb 867317                          //  DirectDrawSurface4.Restore
#define idh__dx_directdrawsurface4_setclipper_ddraw_vb 867318                       //  DirectDrawSurface4.SetClipper
#define idh__dx_directdrawsurface4_setcolorkey_ddraw_vb 867319                      //  DirectDrawSurface4.SetColorKey
#define idh__dx_directdrawsurface4_setlockedpixel_ddraw_vb 867320                   //  DirectDrawSurface4.SetLockedPixel
#define idh__dx_directdrawsurface4_setlockedsurfacebits_ddraw_vb 867321             //  DirectDrawSurface4.SetLockedSurfaceBits
#define idh__dx_directdrawsurface4_setoverlayposition_ddraw_vb 867322               //  DirectDrawSurface4.SetOverlayPosition
#define idh__dx_directdrawsurface4_setpalette_ddraw_vb 867323                       //  DirectDrawSurface4.SetPalette
#define idh__dx_directdrawsurface4_setprivatedata_ddraw_vb 867324                   //  DirectDrawSurface4.SetPrivateData
#define idh__dx_directdrawsurface4_unlock_ddraw_vb 867325                           //  DirectDrawSurface4.Unlock
#define idh__dx_directdrawsurface4_updateoverlay_ddraw_vb 867326                    //  DirectDrawSurface4.UpdateOverlay
#define idh__dx_directdrawsurface4_updateoverlayzorder_ddraw_vb 867327              //  DirectDrawSurface4.UpdateOverlayZOrder
#define idh__dx_directx7_ddraw_vb 867328                                            //  DirectX7
#define idh__dx_ddbltfx_ddraw_vb 867329                                             //  DDBLTFX
#define idh__dx_ddcaps_ddraw_vb 867330                                              //  DDCAPS
#define idh__dx_ddcolorcontrol_ddraw_vb 867331                                      //  DDCOLORCONTROL
#define idh__dx_ddcolorkey_ddraw_vb 867332                                          //  DDCOLORKEY
#define idh__dx_ddgammaramp_ddraw_vb 867333                                         //  DDGAMMARAMP
#define idh__dx_ddoverlayfx_ddraw_vb 867334                                         //  DDOVERLAYFX
#define idh__dx_ddpixelformat_ddraw_vb 867335                                       //  DDPIXELFORMAT
#define idh__dx_ddscaps2_ddraw_vb 867336                                            //  DDSCAPS2
#define idh__dx_ddsurfacedesc2_ddraw_vb 867337                                      //  DDSURFACEDESC2
#define idh__dx_dxdriverinfo_ddraw_vb 867338                                        //  DXDRIVERINFO
#define idh__dx_paletteentry_ddraw_vb 867339                                        //  PALETTEENTRY
#define idh__dx_rect_ddraw_vb 867340                                                //  RECT
#define idh__dx_const_ddbitdepthflags_ddraw_vb 867341                               //  CONST_DDBITDEPTHFLAGS
#define idh__dx_const_ddbltfastflags_ddraw_vb 867342                                //  CONST_DDBLTFASTFLAGS
#define idh__dx_const_ddbltflags_ddraw_vb 867343                                    //  CONST_DDBLTFLAGS
#define idh__dx_const_ddbltfxflags_ddraw_vb 867344                                  //  CONST_DDBLTFXFLAGS
#define idh__dx_const_ddcaps1flags_ddraw_vb 867345                                  //  CONST_DDCAPS1FLAGS
#define idh__dx_const_ddcaps2flags_ddraw_vb 867346                                  //  CONST_DDCAPS2FLAGS
#define idh__dx_const_ddckeycapsflags_ddraw_vb 867347                               //  CONST_DDCKEYCAPSFLAGS
#define idh__dx_const_ddckeyflags_ddraw_vb 867348                                   //  CONST_DDCKEYFLAGS
#define idh__dx_const_ddcolorflags_ddraw_vb 867349                                  //  CONST_DDCOLORFLAGS
#define idh__dx_const_ddedmflags_ddraw_vb 867350                                    //  CONST_DDEDMFLAGS
#define idh__dx_const_ddenumoverlayzflags_ddraw_vb 867351                           //  CONST_DDENUMOVERLAYZFLAGS
#define idh__dx_const_ddenumsurfacesflags_ddraw_vb 867352                           //  CONST_DDENUMSURFACESFLAGS
#define idh__dx_const_ddflipflags_ddraw_vb 867353                                   //  CONST_DDFLIPFLAGS
#define idh__dx_const_ddfxalphacapsflags_ddraw_vb 867354                            //  CONST_DDFXALPHACAPSFLAGS
#define idh__dx_const_ddfxcapsflags_ddraw_vb 867355                                 //  CONST_DDFXCAPSFLAGS
#define idh__dx_const_ddgbsflags_ddraw_vb 867356                                    //  CONST_DDGBSFLAGS
#define idh__dx_const_ddgfsflags_ddraw_vb 867357                                    //  CONST_DDGFSFLAGS
#define idh__dx_const_ddlockflags_ddraw_vb 867358                                   //  CONST_DDLOCKFLAGS
#define idh__dx_const_ddoverflags_ddraw_vb 867359                                   //  CONST_DDOVERFLAGS
#define idh__dx_const_ddoverlayfxflags_ddraw_vb 867360                              //  CONST_DDOVERLAYFXFLAGS
#define idh__dx_const_ddoverzflags_ddraw_vb 867361                                  //  CONST_DDOVERZFLAGS
#define idh__dx_const_ddpcapsflags_ddraw_vb 867362                                  //  CONST_DDPCAPSFLAGS
#define idh__dx_const_ddpixelformatflags_ddraw_vb 867363                            //  CONST_DDPIXELFORMATFLAGS
#define idh__dx_const_ddraw_ddraw_vb 867364                                         //  CONST_DDRAW
#define idh__dx_const_ddsclflags_ddraw_vb 867365                                    //  CONST_DDSCLFLAGS
#define idh__dx_const_ddsdmflags_ddraw_vb 867366                                    //  CONST_DDSDMFLAGS
#define idh__dx_const_ddsgrflags_ddraw_vb 867367                                    //  CONST_DDSGRFLAGS
#define idh__dx_const_ddstereocapsflags_ddraw_vb 867368                             //  CONST_DDSTEREOCAPSFLAGS
#define idh__dx_const_ddsurfacecaps2flags_ddraw_vb 867369                           //  CONST_DDSURFACECAPS2FLAGS
#define idh__dx_const_ddsurfacecapsflags_ddraw_vb 867370                            //  CONST_DDSURFACECAPSFLAGS
#define idh__dx_const_ddsurfacedescflags_ddraw_vb 867371                            //  CONST_DDSURFACEDESCFLAGS
#define idh__dx_const_ddwaitvbflags_ddraw_vb 867372                                 //  CONST_DDWAITVBFLAGS
#define idh__dx_directinput_dinput_vb 867373                                        //  DirectInput
#define idh__dx_directinput_createdevice_dinput_vb 867374                           //  DirectInput.CreateDevice
#define idh__dx_directinput_getdevicestatus_dinput_vb 867375                        //  DirectInput.GetDeviceStatus
#define idh__dx_directinput_getdienumdevices_dinput_vb 867376                       //  DirectInput.GetDIEnumDevices
#define idh__dx_directinput_runcontrolpanel_dinput_vb 867377                        //  DirectInput.RunControlPanel
#define idh__dx_directinputdevice_dinput_vb 867378                                  //  DirectInputDevice
#define idh__dx_directinputdevice_acquire_dinput_vb 867379                          //  DirectInputDevice.Acquire
#define idh__dx_directinputdevice_getcapabilities_dinput_vb 867380                  //  DirectInputDevice.GetCapabilities
#define idh__dx_directinputdevice_getdevicedata_dinput_vb 867381                    //  DirectInputDevice.GetDeviceData
#define idh__dx_directinputdevice_getdeviceinfo_dinput_vb 867382                    //  DirectInputDevice.GetDeviceInfo
#define idh__dx_directinputdevice_getdienumdeviceobjects_dinput_vb 867383           //  DirectInputDevice.GetDeviceObjectsEnum
#define idh__dx_directinputdevice_getdevicestate_dinput_vb 867384                   //  DirectInputDevice.GetDeviceState
#define idh__dx_directinputdevice_getdevicestatejoystick_dinput_vb 867385           //  DirectInputDevice.GetDeviceStateJoystick
#define idh__dx_directinputdevice_getdevicestatejoystick2_dinput_vb 867386          //  DirectInputDevice.GetDeviceStateJoystick2
#define idh__dx_directinputdevice_getdevicestatekeyboard_dinput_vb 867387           //  DirectInputDevice.GetDeviceStateKeyboard
#define idh__dx_directinputdevice_getdevicestatemouse_dinput_vb 867388              //  DirectInputDevice.GetDeviceStateMouse
#define idh__dx_directinputdevice_getobjectinfo_dinput_vb 867389                    //  DirectInputDevice.GetObjectInfo
#define idh__dx_directinputdevice_getproperty_dinput_vb 867390                      //  DirectInputDevice.GetProperty
#define idh__dx_directinputdevice_poll_dinput_vb 867391                             //  DirectInputDevice.Poll
#define idh__dx_directinputdevice_runcontrolpanel_dinput_vb 867392                  //  DirectInputDevice.RunControlPanel
#define idh__dx_directinputdevice_setcooperativelevel_dinput_vb 867393              //  DirectInputDevice.SetCooperativeLevel
#define idh__dx_directinputdevice_setdataformat_dinput_vb 867394                    //  DirectInputDevice.SetDataFormat
#define idh__dx_directinputdevice_seteventnotification_dinput_vb 867395             //  DirectInputDevice.SetEventNotification
#define idh__dx_directinputdevice_setproperty_dinput_vb 867396                      //  DirectInputDevice.SetProperty
#define idh__dx_directinputdevice_unacquire_dinput_vb 867397                        //  DirectInputDevice.Unacquire
#define idh__dx_directinputenumdeviceobjects_dinput_vb 867398                       //  DirectInputEnumDeviceObjects
#define idh__dx_directinputenumdeviceobjects_getcount_dinput_vb 867399              //  DirectInputEnumDeviceObjects.GetCount
#define idh__dx_directinputenumdeviceobjects_getitem_dinput_vb 867400               //  DirectInputEnumDeviceObjects.GetItem
#define idh__dx_directinputenumdevices_dinput_vb 867401                             //  DirectInputEnumDevices
#define idh__dx_directinputenumdevices_getcount_dinput_vb 867402                    //  DirectInputEnumDevices.GetCount
#define idh__dx_directinputenumdevices_getitem_dinput_vb 867403                     //  DirectInputEnumDevices.GetItem
#define idh__dx_didataformat_dinput_vb 867404                                       //  DIDATAFORMAT
#define idh__dx_didevcaps_dinput_vb 867405                                          //  DIDEVCAPS
#define idh__dx_dideviceobjectdata_dinput_vb 867406                                 //  DIDEVICEOBJECTDATA
#define idh__dx_dijoystate_dinput_vb 867407                                         //  DIJOYSTATE
#define idh__dx_dijoystate2_desc_dinput_vb 867408                                   //  DIJOYSTATE2
#define idh__dx_dikeyboardstate_dinput_vb 867409                                    //  DIKEYBOARDSTATE
#define idh__dx_dimousestate_dinput_vb 867410                                       //  DIMOUSESTATE
#define idh__dx_diobjectdataformat_dinput_vb 867411                                 //  DIOBJECTDATAFORMAT
#define idh__dx_const_didataformatflags_dinput_vb 867412                            //  CONST_DIDATAFORMATFLAGS
#define idh__dx_const_didevcapsflags_dinput_vb 867413                               //  CONST_DIDEVCAPSFLAGS
#define idh__dx_const_dideviceobjinstaceflags_dinput_vb 867414                      //  CONST_DIDEVICEOBJINSTANCEFLAGS
#define idh__dx_const_didevicetype_dinput_vb 867415                                 //  CONST_DIDEVICETYPE
#define idh__dx_const_didftflags_dinput_vb 867416                                   //  CONST_DIDFTFLAGS
#define idh__dx_const_didgddflags_dinput_vb 867417                                  //  CONST_DIDGDDFLAGS
#define idh__dx_const_dienumdevicesflags_dinput_vb 867418                           //  CONST_DIENUMDEVICESFLAGS
#define idh__dx_const_dikeyflags_dinput_vb 867419                                   //  CONST_DIKEYFLAGS
#define idh__dx_const_dinputerr_dinput_vb 867420                                    //  CONST_DINPUTERR
#define idh__dx_const_diphflags_dinput_vb 867421                                    //  CONST_DIPHFLAGS
#define idh__dx_const_disclflags_dinput_vb 867422                                   //  CONST_DISCLFLAGS
#define idh__dx_keyboard_device_constants_dinput_vb 867423                          //  Keyboard Device Constants
#define idh__dx_directinput_and_japanese_keyboards_dinput_vb 867424                 //  DirectInput and Japanese Keyboards
#define idh__dx_mouse_device_constants_dinput_vb 867425                             //  Mouse Device Constants
#define idh__dx_joystick_device_constants_dinput_vb 867426                          //  Joystick Device Constants
#define idh__dx_directmusicband_dmusic_vb 867427                                    //  DirectMusicBand
#define idh__dx_directmusicband_createsegment_dmusic_vb 867428                      //  DirectMusicBand.CreateSegment
#define idh__dx_directmusicband_download_dmusic_vb 867429                           //  DirectMusicBand.Download
#define idh__dx_directmusicband_unload_dmusic_vb 867430                             //  DirectMusicBand.Unload
#define idh__dx_directmusicchordmap_dmusic_vb 867431                                //  DirectMusicChordMap
#define idh__dx_directmusiccollection_dmusic_vb 867432                              //  DirectMusicCollection
#define idh__dx_directmusiccomposer_dmusic_vb 867433                                //  DirectMusicComposer
#define idh__dx_directmusiccomposer_autotransition_dmusic_vb 867434                 //  DirectMusicComposer.AutoTransition
#define idh__dx_directmusiccomposer_changechordmap_dmusic_vb 867435                 //  DirectMusicComposer.ChangeChordMap
#define idh__dx_directmusiccomposer_composesegmentfromshape_dmusic_vb 867436        //  DirectMusicComposer.ComposeSegmentFromShape
#define idh__dx_directmusiccomposer_composesegmentfromtemplate_dmusic_vb 867437     //  DirectMusicComposer.ComposeSegmentFromTemplate
#define idh__dx_directmusiccomposer_composetemplatefromshape_dmusic_vb 867438       //  DirectMusicComposer.ComposeTemplateFromShape
#define idh__dx_directmusiccomposer_composetransition_dmusic_vb 867439              //  DirectMusicComposer.ComposeTransition
#define idh__dx_directmusicloader_dmusic_vb 867440                                  //  DirectMusicLoader
#define idh__dx_directmusicloader_loadband_dmusic_vb 867441                         //  DirectMusicLoader.LoadBand
#define idh__dx_directmusicloader_loadbandfromresource_dmusic_vb 867442             //  DirectMusicLoader.LoadBandFromResource
#define idh__dx_directmusicloader_loadcollection_dmusic_vb 867443                   //  DirectMusicLoader.LoadCollection
#define idh__dx_directmusicloader_loadcollectionfromresource_dmusic_vb 867444       //  DirectMusicLoader.LoadCollectionFromResource
#define idh__dx_directmusicloader_loadsegment_dmusic_vb 867445                      //  DirectMusicLoader.LoadSegment
#define idh__dx_directmusicloader_loadsegmentfromresource_dmusic_vb 867446          //  DirectMusicLoader.LoadSegmentFromResource
#define idh__dx_directmusicloader_loadstyle_dmusic_vb 867447                        //  DirectMusicLoader.LoadStyle
#define idh__dx_directmusicloader_loadstylefromresource_dmusic_vb 867448            //  DirectMusicLoader.LoadStyleFromResource
#define idh__dx_directmusicloader_setsearchdirectory_dmusic_vb 867449               //  DirectMusicLoader.SetSearchDirectory
#define idh__dx_directmusicperformance_dmusic_vb 867450                             //  DirectMusicPerformance
#define idh__dx_directmusicperformance_addnotificationtype_dmusic_vb 867451         //  DirectMusicPerformance.AddNotificationType
#define idh__dx_directmusicperformance_adjusttime_dmusic_vb 867452                  //  DirectMusicPerformance.AdjustTime
#define idh__dx_directmusicperformance_clocktomusictime_dmusic_vb 867453            //  DirectMusicPerformance.ClockToMusicTime
#define idh__dx_directmusicperformance_closedown_dmusic_vb 867454                   //  DirectMusicPerformance.CloseDown
#define idh__dx_directmusicperformance_getbumperlength_dmusic_vb 867455             //  DirectMusicPerformance.GetBumperLength
#define idh__dx_directmusicperformance_getchordmap_dmusic_vb 867456                 //  DirectMusicPerformance.GetChordmap
#define idh__dx_directmusicperformance_getclocktime_dmusic_vb 867457                //  DirectMusicPerformance.GetClockTime
#define idh__dx_directmusicperformance_getcommand_dmusic_vb 867458                  //  DirectMusicPerformance.GetCommand
#define idh__dx_directmusicperformance_getgroovelevel_dmusic_vb 867459              //  DirectMusicPerformance.GetGrooveLevel
#define idh__dx_directmusicperformance_getlatencytime_dmusic_vb 867460              //  DirectMusicPerformance.GetLatencyTime
#define idh__dx_directmusicperformance_getmasterautodownload_dmusic_vb 867461       //  DirectMusicPerformance.GetMasterAutoDownload
#define idh__dx_directmusicperformance_getmastergroovelevel_dmusic_vb 867462        //  DirectMusicPerformance.GetMasterGrooveLevel
#define idh__dx_directmusicperformance_getmastertempo_dmusic_vb 867463              //  DirectMusicPerformance.GetMasterTempo
#define idh__dx_directmusicperformance_getmastervolume_dmusic_vb 867464             //  DirectMusicPerformance.GetMasterVolume
#define idh__dx_directmusicperformance_getmusictime_dmusic_vb 867465                //  DirectMusicPerformance.GetMusicTime
#define idh__dx_directmusicperformance_getnotificationpmsg_dmusic_vb 867466         //  DirectMusicPerformance.GetNotificationPMsg
#define idh__dx_directmusicperformance_getportcaps_dmusic_vb 867467                 //  DirectMusicPerformance.GetPortCaps
#define idh__dx_directmusicperformance_getportcount_dmusic_vb 867468                //  DirectMusicPerformance.GetPortCount
#define idh__dx_directmusicperformance_getportname_dmusic_vb 867469                 //  DirectMusicPerformance.GetPortName
#define idh__dx_directmusicperformance_getpreparetime_dmusic_vb 867470              //  DirectMusicPerformance.GetPrepareTime
#define idh__dx_directmusicperformance_getqueuetime_dmusic_vb 867471                //  DirectMusicPerformance.GetQueueTime
#define idh__dx_directmusicperformance_getresolvedtime_dmusic_vb 867472             //  DirectMusicPerformance.GetResolvedTime
#define idh__dx_directmusicperformance_getsegmentstate_dmusic_vb 867473             //  DirectMusicPerformance.GetSegmentState
#define idh__dx_directmusicperformance_getstyle_dmusic_vb 867474                    //  DirectMusicPerformance.GetStyle
#define idh__dx_directmusicperformance_gettempo_dmusic_vb 867475                    //  DirectMusicPerformance.GetTempo
#define idh__dx_directmusicperformance_gettimesig_dmusic_vb 867476                  //  DirectMusicPerformance.GetTimeSig
#define idh__dx_directmusicperformance_gmreset_dmusic_vb 867477                     //  DirectMusicPerformance.GMReset
#define idh__dx_directmusicperformance_init_dmusic_vb 867478                        //  DirectMusicPerformance.Init
#define idh__dx_directmusicperformance_invalidate_dmusic_vb 867479                  //  DirectMusicPerformance.Invalidate
#define idh__dx_directmusicperformance_isplaying_dmusic_vb 867480                   //  DirectMusicPerformance.IsPlaying
#define idh__dx_directmusicperformance_musictoclocktime_dmusic_vb 867481            //  DirectMusicPerformance.MusicToClockTime
#define idh__dx_directmusicperformance_playsegment_dmusic_vb 867482                 //  DirectMusicPerformance.PlaySegment
#define idh__dx_directmusicperformance_removenotificationtype_dmusic_vb 867483      //  DirectMusicPerformance.RemoveNotificationType
#define idh__dx_directmusicperformance_sendcurvepmsg_dmusic_vb 867484               //  DirectMusicPerformance.SendCurvePMSG
#define idh__dx_directmusicperformance_sendmidipmsg_dmusic_vb 867485                //  DirectMusicPerformance.SendMIDIPMSG
#define idh__dx_directmusicperformance_sendnotepmsg_dmusic_vb 867486                //  DirectMusicPerformance.SendNotePMSG
#define idh__dx_directmusicperformance_sendpatchpmsg_dmusic_vb 867487               //  DirectMusicPerformance.SendPatchPMSG
#define idh__dx_directmusicperformance_sendtempopmsg_dmusic_vb 867488               //  DirectMusicPerformance.SendTempoPMSG
#define idh__dx_directmusicperformance_sendtimesigpmsg_dmusic_vb 867489             //  DirectMusicPerformance.SendTimeSigPMSG
#define idh__dx_directmusicperformance_sendtransposepmsg_dmusic_vb 867490           //  DirectMusicPerformance.SendTransposePMSG
#define idh__dx_directmusicperformance_setbumperlength_dmusic_vb 867491             //  DirectMusicPerformance.SetBumperLength
#define idh__dx_directmusicperformance_setmasterautodownload_dmusic_vb 867492       //  DirectMusicPerformance.SetMasterAutoDownload
#define idh__dx_directmusicperformance_setmastergroovelevel_dmusic_vb 867493        //  DirectMusicPerformance.SetMasterGrooveLevel
#define idh__dx_directmusicperformance_setmastertempo_dmusic_vb 867494              //  DirectMusicPerformance.SetMasterTempo
#define idh__dx_directmusicperformance_setmastervolume_dmusic_vb 867495             //  DirectMusicPerformance.SetMasterVolume
#define idh__dx_directmusicperformance_setnotificationhandle_dmusic_vb 867496       //  DirectMusicPerformance.SetNotificationHandle
#define idh__dx_directmusicperformance_setport_dmusic_vb 867497                     //  DirectMusicPerformance.SetPort
#define idh__dx_directmusicperformance_setpreparetime_dmusic_vb 867498              //  DirectMusicPerformance.SetPrepareTime
#define idh__dx_directmusicperformance_stop_dmusic_vb 867499                        //  DirectMusicPerformance.Stop
#define idh__dx_directmusicsegment_dmusic_vb 867500                                 //  DirectMusicSegment
#define idh__dx_directmusicsegment_clone_dmusic_vb 867501                           //  DirectMusicSegment.Clone
#define idh__dx_directmusicsegment_connecttocollection_dmusic_vb 867502             //  DirectMusicSegment.ConnectToCollection
#define idh__dx_directmusicsegment_download_dmusic_vb 867503                        //  DirectMusicSegment.Download
#define idh__dx_directmusicsegment_getlength_dmusic_vb 867504                       //  DirectMusicSegment.GetLength
#define idh__dx_directmusicsegment_getlooppointend_dmusic_vb 867505                 //  DirectMusicSegment.GetLoopPointEnd
#define idh__dx_directmusicsegment_getlooppointstart_dmusic_vb 867506               //  DirectMusicSegment.GetLoopPointStart
#define idh__dx_directmusicsegment_getrepeats_dmusic_vb 867507                      //  DirectMusicSegment.GetRepeats
#define idh__dx_directmusicsegment_getstartpoint_dmusic_vb 867508                   //  DirectMusicSegment.GetStartPoint
#define idh__dx_directmusicsegment_setautodownloadenable_dmusic_vb 867509           //  DirectMusicSegment.SetAutoDownloadEnable
#define idh__dx_directmusicsegment_setlength_dmusic_vb 867510                       //  DirectMusicSegment.SetLength
#define idh__dx_directmusicsegment_setlooppoints_dmusic_vb 867511                   //  DirectMusicSegment.SetLoopPoints
#define idh__dx_directmusicsegment_setrepeats_dmusic_vb 867512                      //  DirectMusicSegment.SetRepeats
#define idh__dx_directmusicsegment_setstandardmidifile_dmusic_vb 867513             //  DirectMusicSegment.SetStandardMidiFile
#define idh__dx_directmusicsegment_setstartpoint_dmusic_vb 867514                   //  DirectMusicSegment.SetStartPoint
#define idh__dx_directmusicsegment_settempoenable_dmusic_vb 867515                  //  DirectMusicSegment.SetTempoEnable
#define idh__dx_directmusicsegment_settimesigenable_dmusic_vb 867516                //  DirectMusicSegment.SetTimeSigEnable
#define idh__dx_directmusicsegment_unload_dmusic_vb 867517                          //  DirectMusicSegment.Unload
#define idh__dx_directmusicsegmentstate_dmusic_vb 867518                            //  DirectMusicSegmentState
#define idh__dx_directmusicsegmentstate_getrepeats_dmusic_vb 867519                 //  DirectMusicSegmentState.GetRepeats
#define idh__dx_directmusicsegmentstate_getseek_dmusic_vb 867520                    //  DirectMusicSegmentState.GetSeek
#define idh__dx_directmusicsegmentstate_getsegment_dmusic_vb 867521                 //  DirectMusicSegmentState.GetSegment
#define idh__dx_directmusicsegmentstate_getstartpoint_dmusic_vb 867522              //  DirectMusicSegmentState.GetStartPoint
#define idh__dx_directmusicsegmentstate_getstarttime_dmusic_vb 867523               //  DirectMusicSegmentState.GetStartTime
#define idh__dx_directmusicstyle_dmusic_vb 867524                                   //  DirectMusicStyle
#define idh__dx_directmusicstyle_getband_dmusic_vb 867525                           //  DirectMusicStyle.GetBand
#define idh__dx_directmusicstyle_getbandcount_dmusic_vb 867526                      //  DirectMusicStyle.GetBandCount
#define idh__dx_directmusicstyle_getbandname_dmusic_vb 867527                       //  DirectMusicStyle.GetBandName
#define idh__dx_directmusicstyle_getchordmap_dmusic_vb 867528                       //  DirectMusicStyle.GetChordmap
#define idh__dx_directmusicstyle_getchordmapcount_dmusic_vb 867529                  //  DirectMusicStyle.GetChordmapCount
#define idh__dx_directmusicstyle_getchordmapname_dmusic_vb 867530                   //  DirectMusicStyle.GetChordmapName
#define idh__dx_directmusicstyle_getdefaultband_dmusic_vb 867531                    //  DirectMusicStyle.GetDefaultBand
#define idh__dx_directmusicstyle_getdefaultchordmap_dmusic_vb 867532                //  DirectMusicStyle.GetDefaultChordMap
#define idh__dx_directmusicstyle_getmotif_dmusic_vb 867533                          //  DirectMusicStyle.GetMotif
#define idh__dx_directmusicstyle_getmotifcount_dmusic_vb 867534                     //  DirectMusicStyle.GetMotifCount
#define idh__dx_directmusicstyle_getmotifname_dmusic_vb 867535                      //  DirectMusicStyle.GetMotifName
#define idh__dx_directmusicstyle_gettempo_dmusic_vb 867536                          //  DirectMusicStyle.GetTempo
#define idh__dx_directmusicstyle_gettimesignature_dmusic_vb 867537                  //  DirectMusicStyle.GetTimeSignature
#define idh__dx_dmus_curve_pmsg_dmusic_vb 867538                                    //  DMUS_CURVE_PMSG
#define idh__dx_dmus_note_pmsg_dmusic_vb 867539                                     //  DMUS_NOTE_PMSG
#define idh__dx_dmus_notification_pmsg_dmusic_vb 867540                             //  DMUS_NOTIFICATION_PMSG
#define idh__dx_dmus_portcaps_dmusic_vb 867541                                      //  DMUS_PORTCAPS
#define idh__dx_dmus_timesignature_dmusic_vb 867542                                 //  DMUS_TIMESIGNATURE
#define idh__dx_const_dmus_notificationtype_dmusic_vb 867543                        //  CONST_DMUS_NOTIFICATIONTYPE
#define idh__dx_enumdmus_commandt_types_dmusic_vb 867544                            //  enumDMUS_COMMANDT_TYPES
#define idh__dx_enumdmus_composef_flags_dmusic_vb 867545                            //  enumDMUS_COMPOSEF_FLAGS
#define idh__dx_enumdmus_playmode_flags_dmusic_vb 867546                            //  enumDMUS_PLAYMODE_FLAGS
#define idh__dx_enumdmus_pmsgf_flags_dmusic_vb 867547                               //  enumDMUS_PMSGF_FLAGS
#define idh__dx_enumdmus_segf_flags_dmusic_vb 867548                                //  enumDMUS_SEGF_FLAGS
#define idh__dx_enumdmus_shapet_types_dmusic_vb 867549                              //  enumDMUS_SHAPET_TYPES
#define idh__dx_directplay4_dplay_vb 867550                                         //  DirectPlay4
#define idh__dx_directplay4_addgrouptogroup_dplay_vb 867551                         //  DirectPlay4.AddGroupToGroup
#define idh__dx_directplay4_addplayertogroup_dplay_vb 867552                        //  DirectPlay4.AddPlayerToGroup
#define idh__dx_directplay4_cancelmessage_dplay_vb 867553                           //  DirectPlay4.CancelMessage
#define idh__dx_directplay4_cancelpriority_dplay_vb 867554                          //  DirectPlay4.CancelPriority
#define idh__dx_directplay4_close_dplay_vb 867555                                   //  DirectPlay4.Close
#define idh__dx_directplay4_creategroup_dplay_vb 867556                             //  DirectPlay4.CreateGroup
#define idh__dx_directplay4_creategroupingroup_dplay_vb 867557                      //  DirectPlay4.CreateGroupInGroup
#define idh__dx_directplay4_createmessage_dplay_vb 867558                           //  DirectPlay4.CreateMessage
#define idh__dx_directplay4_createplayer_dplay_vb 867559                            //  DirectPlay4.CreatePlayer
#define idh__dx_directplay4_createsessiondata_dplay_vb 867560                       //  DirectPlay4.CreateSessionData
#define idh__dx_directplay4_deletegroupfromgroup_dplay_vb 867561                    //  DirectPlay4.DeleteGroupFromGroup
#define idh__dx_directplay4_deleteplayerfromgroup_dplay_vb 867562                   //  DirectPlay4.DeletePlayerFromGroup
#define idh__dx_directplay4_destroygroup_dplay_vb 867563                            //  DirectPlay4.DestroyGroup
#define idh__dx_directplay4_destroyplayer_dplay_vb 867564                           //  DirectPlay4.DestroyPlayer
#define idh__dx_directplay4_getcaps_dplay_vb 867565                                 //  DirectPlay4.GetCaps
#define idh__dx_directplay4_getdpenumconnections_dplay_vb 867566                    //  DirectPlay4.GetDPEnumConnections
#define idh__dx_directplay4_getdpenumgroupplayers_dplay_vb 867567                   //  DirectPlay4.GetDPEnumGroupPlayers
#define idh__dx_directplay4_getdpenumgroups_dplay_vb 867568                         //  DirectPlay4.GetDPEnumGroups
#define idh__dx_directplay4_getdpenumgroupsingroup_dplay_vb 867569                  //  DirectPlay4.GetDPEnumGroupsInGroup
#define idh__dx_directplay4_getdpenumplayers_dplay_vb 867570                        //  DirectPlay4.GetDPEnumPlayers
#define idh__dx_directplay4_getdpenumsessions_dplay_vb 867571                       //  DirectPlay4.GetDPEnumSessions
#define idh__dx_directplay4_getgroupdata_dplay_vb 867572                            //  DirectPlay4.GetGroupData
#define idh__dx_directplay4_getgroupflags_dplay_vb 867573                           //  DirectPlay4.GetGroupFlags
#define idh__dx_directplay4_getgrouplongname_dplay_vb 867574                        //  DirectPlay4.GetGroupLongName
#define idh__dx_directplay4_getgroupowner_dplay_vb 867575                           //  DirectPlay4.GetGroupOwner
#define idh__dx_directplay4_getgroupparent_dplay_vb 867576                          //  DirectPlay4.GetGroupParent
#define idh__dx_directplay4_getgroupshortname_dplay_vb 867577                       //  DirectPlay4.GetGroupShortName
#define idh__dx_directplay4_getmessagecount_dplay_vb 867578                         //  DirectPlay4.GetMessageCount
#define idh__dx_directplay4_getmessagequeue_dplay_vb 867579                         //  DirectPlay4.GetMessageQueue
#define idh__dx_directplay4_getplayeraccountid_dplay_vb 867580                      //  DirectPlay4.GetPlayerAccountId
#define idh__dx_directplay4_getplayeraddress_dplay_vb 867581                        //  DirectPlay4.GetPlayerAddress
#define idh__dx_directplay4_getplayercaps_dplay_vb 867582                           //  DirectPlay4.GetPlayerCaps
#define idh__dx_directplay4_getplayerdata_dplay_vb 867583                           //  DirectPlay4.GetPlayerData
#define idh__dx_directplay4_getplayerflags_dplay_vb 867584                          //  DirectPlay4.GetPlayerFlags
#define idh__dx_directplay4_getplayerformalname_dplay_vb 867585                     //  DirectPlay4.GetPlayerFormalName
#define idh__dx_directplay4_getplayerfriendlyname_dplay_vb 867586                   //  DirectPlay4.GetPlayerFriendlyName
#define idh__dx_directplay4_getsessiondesc_dplay_vb 867587                          //  DirectPlay4.GetSessionDesc
#define idh__dx_directplay4_initializeconnection_dplay_vb 867588                    //  DirectPlay4.InitializeConnection
#define idh__dx_directplay4_open_dplay_vb 867589                                    //  DirectPlay4.Open
#define idh__dx_directplay4_receive_dplay_vb 867590                                 //  DirectPlay4.Receive
#define idh__dx_directplay4_secureopen_dplay_vb 867591                              //  DirectPlay4.SecureOpen
#define idh__dx_directplay4_send_dplay_vb 867592                                    //  DirectPlay4.Send
#define idh__dx_directplay4_sendchatmessage_dplay_vb 867593                         //  DirectPlay4.SendChatMessage
#define idh__dx_directplay4_sendex_dplay_vb 867594                                  //  DirectPlay4.SendEx
#define idh__dx_directplay4_setgroupconnectionsettings_dplay_vb 867595              //  DirectPlay4.SetGroupConnectionSettings
#define idh__dx_directplay4_setgroupdata_dplay_vb 867596                            //  DirectPlay4.SetGroupData
#define idh__dx_directplay4_setgroupname_dplay_vb 867597                            //  DirectPlay4.SetGroupName
#define idh__dx_directplay4_setgroupowner_dplay_vb 867598                           //  DirectPlay4.SetGroupOwner
#define idh__dx_directplay4_setplayerdata_dplay_vb 867599                           //  DirectPlay4.SetPlayerData
#define idh__dx_directplay4_setplayername_dplay_vb 867600                           //  DirectPlay4.SetPlayerName
#define idh__dx_directplay4_setsessiondesc_dplay_vb 867601                          //  DirectPlay4.SetSessionDesc
#define idh__dx_directplay4_startsession_dplay_vb 867602                            //  DirectPlay4.StartSession
#define idh__dx_directplayaddress_dplay_vb 867603                                   //  DirectPlayAddress
#define idh__dx_directplayenumaddress_dplay_vb 867604                               //  DirectPlayEnumAddress
#define idh__dx_directplayenumaddress_getcount_dplay_vb 867605                      //  DirectPlayEnumAddress.GetCount
#define idh__dx_directplayenumaddress_getdata_dplay_vb 867606                       //  DirectPlayEnumAddress.GetData
#define idh__dx_directplayenumaddress_gettype_dplay_vb 867607                       //  DirectPlayEnumAddress.GetType
#define idh__dx_directplayenumaddresstypes_dplay_vb 867608                          //  DirectPlayEnumAddressTypes
#define idh__dx_directplayenumaddresstypes_getcount_dplay_vb 867609                 //  DirectPlayEnumAddressTypes.GetCount
#define idh__dx_directplayenumaddresstypes_gettype_dplay_vb 867610                  //  DirectPlayEnumAddressTypes.GetType
#define idh__dx_directplayenumconnections_dplay_vb 867611                           //  DirectPlayEnumConnections
#define idh__dx_directplayenumconnections_getaddress_dplay_vb 867612                //  DirectPlayEnumConnections.GetAddress
#define idh__dx_directplayenumconnections_getcount_dplay_vb 867613                  //  DirectPlayEnumConnections.GetCount
#define idh__dx_directplayenumconnections_getflags_dplay_vb 867614                  //  DirectPlayEnumConnections.GetFlags
#define idh__dx_directplayenumconnections_getguid_dplay_vb 867615                   //  DirectPlayEnumConnections.GetGuid
#define idh__dx_directplayenumconnections_getshortname_dplay_vb 867616              //  DirectPlayEnumConnections.GetName
#define idh__dx_directplayenumlocalapplications_dplay_vb 867617                     //  DirectPlayEnumLocalApplications
#define idh__dx_directplayenumlocalapplications_getcount_dplay_vb 867618            //  DirectPlayEnumLocalApplications.GetCount
#define idh__dx_directplayenumlocalapplications_getguid_dplay_vb 867619             //  DirectPlayEnumLocalApplications.GetGuid
#define idh__dx_directplayenumlocalapplications_getname_dplay_vb 867620             //  DirectPlayEnumLocalApplications.GetName
#define idh__dx_directplayenumplayers_dplay_vb 867621                               //  DirectPlayEnumPlayers
#define idh__dx_directplayenumplayers_getcount_dplay_vb 867622                      //  DirectPlayEnumPlayers.GetCount
#define idh__dx_directplayenumplayers_getdpid_dplay_vb 867623                       //  DirectPlayEnumPlayers.GetDPID
#define idh__dx_directplayenumplayers_getflags_dplay_vb 867624                      //  DirectPlayEnumPlayers.GetFlags
#define idh__dx_directplayenumplayers_getlongname_dplay_vb 867625                   //  DirectPlayEnumPlayers.GetLongName
#define idh__dx_directplayenumplayers_getshortname_dplay_vb 867626                  //  DirectPlayEnumPlayers.GetShortName
#define idh__dx_directplayenumplayers_gettype_dplay_vb 867627                       //  DirectPlayEnumPlayers.GetType
#define idh__dx_directplayenumserviceproviders_dplay_vb 867628                      //  DirectPlayEnumServiceProviders
#define idh__dx_directplayenumserviceproviders_getcount_dplay_vb 867629             //  DirectPlayEnumServiceProviders.GetCount
#define idh__dx_directplayenumserviceproviders_getguid_dplay_vb 867630              //  DirectPlayEnumServiceProviders.GetGuid
#define idh__dx_directplayenumserviceproviders_getname_dplay_vb 867631              //  DirectPlayEnumServiceProviders.GetName
#define idh__dx_directplayenumserviceproviders_getversion_dplay_vb 867632           //  DirectPlayEnumServiceProviders.GetVersion
#define idh__dx_directplayenumsessions_dplay_vb 867633                              //  DirectPlayEnumSessions
#define idh__dx_directplayenumsessions_getcount_dplay_vb 867634                     //  DirectPlayEnumSessions.GetCount
#define idh__dx_directplayenumsessions_getitem_dplay_vb 867635                      //  DirectPlayEnumSessions.GetItem
#define idh__dx_directplaylobby3_dplay_vb 867636                                    //  DirectPlayLobby3
#define idh__dx_directplaylobby3_connect_dplay_vb 867637                            //  DirectPlayLobby3.Connect
#define idh__dx_directplaylobby3_createaddress_dplay_vb 867638                      //  DirectPlayLobby3.CreateAddress
#define idh__dx_directplaylobby3_createcompoundaddress_dplay_vb 867639              //  DirectPlayLobby3.CreateCompoundAddress
#define idh__dx_directplaylobby3_createconnectiondata_dplay_vb 867640               //  DirectPlayLobby3.CreateConnectionData
#define idh__dx_directplaylobby3_createmessage_dplay_vb 867641                      //  DirectPlayLobby3.CreateMessage
#define idh__dx_directplaylobby3_getconnectionsettings_dplay_vb 867642              //  DirectPlayLobby3.GetConnectionSettings
#define idh__dx_directplaylobby3_getdpenumaddress_dplay_vb 867643                   //  DirectPlayLobby3.GetDPEnumAddress
#define idh__dx_directplaylobby3_getdpenumaddresstypes_dplay_vb 867644              //  DirectPlayLobby3.GetDPEnumAddressTypes
#define idh__dx_directplaylobby3_getdpenumlocalapplications_dplay_vb 867645         //  DirectPlayLobby3.GetDPEnumLocalApplications
#define idh__dx_directplaylobby3_receivelobbymessage_dplay_vb 867646                //  DirectPlayLobby3.ReceiveLobbyMessage
#define idh__dx_directplaylobby3_registerapplication_dplay_vb 867647                //  DirectPlayLobby3.RegisterApplication
#define idh__dx_directplaylobby3_runapplication_dplay_vb 867648                     //  DirectPlayLobby3.RunApplication
#define idh__dx_directplaylobby3_sendlobbymessage_dplay_vb 867649                   //  DirectPlayLobby3.SendLobbyMessage
#define idh__dx_directplaylobby3_setconnectionsettings_dplay_vb 867650              //  DirectPlayLobby3.SetConnectionSettings
#define idh__dx_directplaylobby3_setlobbymessageevent_dplay_vb 867651               //  DirectPlayLobby3.SetLobbyMessageEvent
#define idh__dx_directplaylobby3_unregisterapplication_dplay_vb 867652              //  DirectPlayLobby3.UnregisterApplication
#define idh__dx_directplaylobby3_waitforconnectionsettings_dplay_vb 867653          //  DirectPlayLobby3.WaitForConnectionSettings
#define idh__dx_directplaylobbyconnection_dplay_vb 867654                           //  DirectPlayLobbyConnection
#define idh__dx_directplaylobbyconnection_getaddress_dplay_vb 867655                //  DirectPlayLobbyConnection.GetAddress
#define idh__dx_directplaylobbyconnection_getflags_dplay_vb 867656                  //  DirectPlayLobbyConnection.GetFlags
#define idh__dx_directplaylobbyconnection_getguidsp_dplay_vb 867657                 //  DirectPlayLobbyConnection.GetGuidSP
#define idh__dx_directplaylobbyconnection_getplayerlongname_dplay_vb 867658         //  DirectPlayLobbyConnection.GetPlayerLongName
#define idh__dx_directplaylobbyconnection_getplayershortname_dplay_vb 867659        //  DirectPlayLobbyConnection.GetPlayerShortName
#define idh__dx_directplaylobbyconnection_getsessiondesc_dplay_vb 867660            //  DirectPlayLobbyConnection.GetSessionDesc
#define idh__dx_directplaylobbyconnection_setaddress_dplay_vb 867661                //  DirectPlayLobbyConnection.SetAddress
#define idh__dx_directplaylobbyconnection_setflags_dplay_vb 867662                  //  DirectPlayLobbyConnection.SetFlags
#define idh__dx_directplaylobbyconnection_setguidsp_dplay_vb 867663                 //  DirectPlayLobbyConnection.SetGuidSP
#define idh__dx_directplaylobbyconnection_setplayerlongname_dplay_vb 867664         //  DirectPlayLobbyConnection.SetPlayerLongName
#define idh__dx_directplaylobbyconnection_setplayershortname_dplay_vb 867665        //  DirectPlayLobbyConnection.SetPlayerShortName
#define idh__dx_directplaylobbyconnection_setsessiondesc_dplay_vb 867666            //  DirectPlayLobbyConnection.SetSessionDesc
#define idh__dx_directplaymessage_dplay_vb 867667                                   //  DirectPlayMessage
#define idh__dx_directplaymessage_clear_dplay_vb 867668                             //  DirectPlayMessage.Clear
#define idh__dx_directplaymessage_getmessagedata_dplay_vb 867669                    //  DirectPlayMessage.GetMessageData
#define idh__dx_directplaymessage_getmessagesize_dplay_vb 867670                    //  DirectPlayMessage.GetMessageSize
#define idh__dx_directplaymessage_movetotop_dplay_vb 867671                         //  DirectPlayMessage.MoveToTop
#define idh__dx_directplaymessage_readbyte_dplay_vb 867672                          //  DirectPlayMessage.ReadByte
#define idh__dx_directplaymessage_readdouble_dplay_vb 867673                        //  DirectPlayMessage.ReadDouble
#define idh__dx_directplaymessage_readguid_dplay_vb 867674                          //  DirectPlayMessage.ReadGuid
#define idh__dx_directplaymessage_readlong_dplay_vb 867675                          //  DirectPlayMessage.ReadLong
#define idh__dx_directplaymessage_readshort_dplay_vb 867676                         //  DirectPlayMessage.ReadShort
#define idh__dx_directplaymessage_readsingle_dplay_vb 867677                        //  DirectPlayMessage.ReadSingle
#define idh__dx_directplaymessage_readstring_dplay_vb 867678                        //  DirectPlayMessage.ReadString
#define idh__dx_directplaymessage_setmessagedata_dplay_vb 867679                    //  DirectPlayMessage.SetMessageData
#define idh__dx_directplaymessage_writebyte_dplay_vb 867680                         //  DirectPlayMessage.WriteByte
#define idh__dx_directplaymessage_writedouble_dplay_vb 867681                       //  DirectPlayMessage.WriteDouble
#define idh__dx_directplaymessage_writeguid_dplay_vb 867682                         //  DirectPlayMessage.WriteGuid
#define idh__dx_directplaymessage_writelong_dplay_vb 867683                         //  DirectPlayMessage.WriteLong
#define idh__dx_directplaymessage_writeshort_dplay_vb 867684                        //  DirectPlayMessage.WriteShort
#define idh__dx_directplaymessage_writesingle_dplay_vb 867685                       //  DirectPlayMessage.WriteSingle
#define idh__dx_directplaymessage_writestring_dplay_vb 867686                       //  DirectPlayMessage.WriteString
#define idh__dx_directplaysessiondata_dplay_vb 867687                               //  DirectPlaySessionData
#define idh__dx_directplaysessiondata_getcurrentplayers_dplay_vb 867688             //  DirectPlaySessionData.GetCurrentPlayers
#define idh__dx_directplaysessiondata_getflags_dplay_vb 867689                      //  DirectPlaySessionData.GetFlags
#define idh__dx_directplaysessiondata_getguidapplication_dplay_vb 867690            //  DirectPlaySessionData.GetGuidApplication
#define idh__dx_directplaysessiondata_getguidinstance_dplay_vb 867691               //  DirectPlaySessionData.GetGuidInstance
#define idh__dx_directplaysessiondata_getmaxplayers_dplay_vb 867692                 //  DirectPlaySessionData.GetMaxPlayers
#define idh__dx_directplaysessiondata_getsessionname_dplay_vb 867693                //  DirectPlaySessionData.GetSessionName
#define idh__dx_directplaysessiondata_getsessionpassword_dplay_vb 867694            //  DirectPlaySessionData.GetSessionPassword
#define idh__dx_directplaysessiondata_getuser_n__dplay_vb 867695                    //  DirectPlaySessionData.GetUser(n)
#define idh__dx_directplaysessiondata_setflags_dplay_vb 867696                      //  DirectPlaySessionData.SetFlags
#define idh__dx_directplaysessiondata_setguidapplication_dplay_vb 867697            //  DirectPlaySessionData.SetGuidApplication
#define idh__dx_directplaysessiondata_setguidinstance_dplay_vb 867698               //  DirectPlaySessionData.SetGuidInstance
#define idh__dx_directplaysessiondata_setmaxplayers_dplay_vb 867699                 //  DirectPlaySessionData.SetMaxPlayers
#define idh__dx_directplaysessiondata_setsessionname_dplay_vb 867700                //  DirectPlaySessionData.SetSessionName
#define idh__dx_directplaysessiondata_setsessionpassword_dplay_vb 867701            //  DirectPlaySessionData.SetSessionPassword
#define idh__dx_directplaysessiondata_setuser_n__dplay_vb 867702                    //  DirectPlaySessionData.SetUser(n)
#define idh__dx_dpapplicationdesc_dplay_vb 867703                                   //  DPAPPLICATIONDESC
#define idh__dx_dpcaps_dplay_vb 867704                                              //  DPCAPS
#define idh__dx_dpcompoundaddresselement_dplay_vb 867705                            //  DPCOMPOUNDADDRESSELEMENT
#define idh__dx_dpcredentials_dplay_vb 867706                                       //  DPCREDENTIALS
#define idh__dx_dpplayerids_dplay_vb 867707                                         //  DPPLAYERIDS
#define idh__dx_dpsecuritydesc_dplay_vb 867708                                      //  DPSECURITYDESC
#define idh__dx_const_dpcapsflags_dplay_vb 867709                                   //  CONST_DPCAPSFLAGS
#define idh__dx_const_dpconnectflags_dplay_vb 867710                                //  CONST_DPCONNECTFLAGS
#define idh__dx_const_dpenumconnectionflags_dplay_vb 867711                         //  CONST_DPENUMCONNECTIONFLAGS
#define idh__dx_const_dpenumgroupflags_dplay_vb 867712                              //  CONST_DPENUMGROUPFLAGS
#define idh__dx_const_dpenumplayerflags_dplay_vb 867713                             //  CONST_DPENUMPLAYERFLAGS
#define idh__dx_const_dpenumsessionflags_dplay_vb 867714                            //  CONST_DPENUMSESSIONFLAGS
#define idh__dx_const_dpgetcapsflags_dplay_vb 867715                                //  CONST_DPGETCAPSFLAGS
#define idh__dx_const_dpgetflags_dplay_vb 867716                                    //  CONST_DPGETFLAGS
#define idh__dx_const_dpgroupflags_dplay_vb 867717                                  //  CONST_DPGROUPFLAGS
#define idh__dx_const_dpidflags_dplay_vb 867718                                     //  CONST_DPIDFLAGS
#define idh__dx_const_dpplayerflags_dplay_vb 867719                                 //  CONST_DPPLAYERFLAGS
#define idh__dx_const_dpsessionflags_dplay_vb 867720                                //  CONST_DPSESSIONFLAGS
#define idh__dx_const_dpsetflags_dplay_vb 867721                                    //  CONST_DPSETFLAGS
#define idh__dx_directsound_dsound_vb 867722                                        //  DirectSound
#define idh__dx_directsound_compact_dsound_vb 867723                                //  DirectSound.Compact
#define idh__dx_directsound_createsoundbuffer_dsound_vb 867724                      //  DirectSound.CreateSoundBuffer
#define idh__dx_directsound_createsoundbufferfromfile_dsound_vb 867725              //  DirectSound.CreateSoundBufferFromFile
#define idh__dx_directsound_createsoundbufferfromresource_dsound_vb 867726          //  DirectSound.CreateSoundBufferFromResource
#define idh__dx_directsound_duplicatesoundbuffer_dsound_vb 867727                   //  DirectSound.DuplicateSoundBuffer
#define idh__dx_directsound_getcaps_dsound_vb 867728                                //  DirectSound.GetCaps
#define idh__dx_directsound_getspeakerconfig_dsound_vb 867729                       //  DirectSound.GetSpeakerConfig
#define idh__dx_directsound_setcooperativelevel_dsound_vb 867730                    //  DirectSound.SetCooperativeLevel
#define idh__dx_directsound_setspeakerconfig_dsound_vb 867731                       //  DirectSound.SetSpeakerConfig
#define idh__dx_directsound3dbuffer_dsound_vb 867732                                //  DirectSounD3DBuffer
#define idh__dx_directsound3dbuffer_getallparameters_dsound_vb 867733               //  DirectSounD3DBuffer.GetAllParameters
#define idh__dx_directsound3dbuffer_getconeangles_dsound_vb 867734                  //  DirectSounD3DBuffer.GetConeAngles
#define idh__dx_directsound3dbuffer_getconeorientation_dsound_vb 867735             //  DirectSounD3DBuffer.GetConeOrientation
#define idh__dx_directsound3dbuffer_getconeoutsidevolume_dsound_vb 867736           //  DirectSounD3DBuffer.GetConeOutsideVolume
#define idh__dx_directsound3dbuffer_getdirectsound3dlistener_dsound_vb 867737       //  DirectSounD3DBuffer.GetDirectSounD3DListener
#define idh__dx_directsound3dbuffer_getdirectsoundbuffer_dsound_vb 867738           //  DirectSounD3DBuffer.GetDirectSoundBuffer
#define idh__dx_directsound3dbuffer_getmaxdistance_dsound_vb 867739                 //  DirectSounD3DBuffer.GetMaxDistance
#define idh__dx_directsound3dbuffer_getmindistance_dsound_vb 867740                 //  DirectSounD3DBuffer.GetMinDistance
#define idh__dx_directsound3dbuffer_getmode_dsound_vb 867741                        //  DirectSounD3DBuffer.GetMode
#define idh__dx_directsound3dbuffer_getposition_dsound_vb 867742                    //  DirectSounD3DBuffer.GetPosition
#define idh__dx_directsound3dbuffer_getvelocity_dsound_vb 867743                    //  DirectSounD3DBuffer.GetVelocity
#define idh__dx_directsound3dbuffer_setallparameters_dsound_vb 867744               //  DirectSounD3DBuffer.SetAllParameters
#define idh__dx_directsound3dbuffer_setconeangles_dsound_vb 867745                  //  DirectSounD3DBuffer.SetConeAngles
#define idh__dx_directsound3dbuffer_setconeorientation_dsound_vb 867746             //  DirectSounD3DBuffer.SetConeOrientation
#define idh__dx_directsound3dbuffer_setconeoutsidevolume_dsound_vb 867747           //  DirectSounD3DBuffer.SetConeOutsideVolume
#define idh__dx_directsound3dbuffer_setmaxdistance_dsound_vb 867748                 //  DirectSounD3DBuffer.SetMaxDistance
#define idh__dx_directsound3dbuffer_setmindistance_dsound_vb 867749                 //  DirectSounD3DBuffer.SetMinDistance
#define idh__dx_directsound3dbuffer_setmode_dsound_vb 867750                        //  DirectSounD3DBuffer.SetMode
#define idh__dx_directsound3dbuffer_setposition_dsound_vb 867751                    //  DirectSounD3DBuffer.SetPosition
#define idh__dx_directsound3dbuffer_setvelocity_dsound_vb 867752                    //  DirectSounD3DBuffer.SetVelocity
#define idh__dx_directsound3dlistener_dsound_vb 867753                              //  DirectSounD3DListener
#define idh__dx_directsound3dlistener_commitdeferredsettings_dsound_vb 867754       //  DirectSounD3DListener.CommitDeferredSettings
#define idh__dx_directsound3dlistener_getallparameters_dsound_vb 867755             //  DirectSounD3DListener.GetAllParameters
#define idh__dx_directsound3dlistener_getdirectsoundbuffer_dsound_vb 867756         //  DirectSounD3DListener.GetDirectSoundBuffer
#define idh__dx_directsound3dlistener_getdistancefactor_dsound_vb 867757            //  DirectSounD3DListener.GetDistanceFactor
#define idh__dx_directsound3dlistener_getdopplerfactor_dsound_vb 867758             //  DirectSounD3DListener.GetDopplerFactor
#define idh__dx_directsound3dlistener_getorientation_dsound_vb 867759               //  DirectSounD3DListener.GetOrientation
#define idh__dx_directsound3dlistener_getposition_dsound_vb 867760                  //  DirectSounD3DListener.GetPosition
#define idh__dx_directsound3dlistener_getrollofffactor_dsound_vb 867761             //  DirectSounD3DListener.GetRolloffFactor
#define idh__dx_directsound3dlistener_getvelocity_dsound_vb 867762                  //  DirectSounD3DListener.GetVelocity
#define idh__dx_directsound3dlistener_setallparameters_dsound_vb 867763             //  DirectSounD3DListener.SetAllParameters
#define idh__dx_directsound3dlistener_setdistancefactor_dsound_vb 867764            //  DirectSounD3DListener.SetDistanceFactor
#define idh__dx_directsound3dlistener_setdopplerfactor_dsound_vb 867765             //  DirectSounD3DListener.SetDopplerFactor
#define idh__dx_directsound3dlistener_setorientation_dsound_vb 867766               //  DirectSounD3DListener.SetOrientation
#define idh__dx_directsound3dlistener_setposition_dsound_vb 867767                  //  DirectSounD3DListener.SetPosition
#define idh__dx_directsound3dlistener_setrollofffactor_dsound_vb 867768             //  DirectSounD3DListener.SetRolloffFactor
#define idh__dx_directsound3dlistener_setvelocity_dsound_vb 867769                  //  DirectSounD3DListener.SetVelocity
#define idh__dx_directsoundbuffer_dsound_vb 867770                                  //  DirectSoundBuffer
#define idh__dx_directsoundbuffer_getcaps_dsound_vb 867771                          //  DirectSoundBuffer.GetCaps
#define idh__dx_directsoundbuffer_getcurrentposition_dsound_vb 867772               //  DirectSoundBuffer.GetCurrentPosition
#define idh__dx_directsoundbuffer_getdirectsound3dbuffer_dsound_vb 867773           //  DirectSoundBuffer.GetDirectSounD3DBuffer
#define idh__dx_directsoundbuffer_getdirectsound3dlistener_dsound_vb 867774         //  DirectSoundBuffer.GetDirectSounD3DListener
#define idh__dx_directsoundbuffer_getformat_dsound_vb 867775                        //  DirectSoundBuffer.GetFormat
#define idh__dx_directsoundbuffer_getfrequency_dsound_vb 867776                     //  DirectSoundBuffer.GetFrequency
#define idh__dx_directsoundbuffer_getpan_dsound_vb 867777                           //  DirectSoundBuffer.GetPan
#define idh__dx_directsoundbuffer_getstatus_dsound_vb 867778                        //  DirectSoundBuffer.GetStatus
#define idh__dx_directsoundbuffer_getvolume_dsound_vb 867779                        //  DirectSoundBuffer.GetVolume
#define idh__dx_directsoundbuffer_play_dsound_vb 867780                             //  DirectSoundBuffer.Play
#define idh__dx_directsoundbuffer_readbuffer_dsound_vb 867781                       //  DirectSoundBuffer.ReadBuffer
#define idh__dx_directsoundbuffer_restore_dsound_vb 867782                          //  DirectSoundBuffer.Restore
#define idh__dx_directsoundbuffer_setcurrentposition_dsound_vb 867783               //  DirectSoundBuffer.SetCurrentPosition
#define idh__dx_directsoundbuffer_setformat_dsound_vb 867784                        //  DirectSoundBuffer.SetFormat
#define idh__dx_directsoundbuffer_setfrequency_dsound_vb 867785                     //  DirectSoundBuffer.SetFrequency
#define idh__dx_directsoundbuffer_setnotificationpositions_dsound_vb 867786         //  DirectSoundBuffer.SetNotificationPositions
#define idh__dx_directsoundbuffer_setpan_dsound_vb 867787                           //  DirectSoundBuffer.SetPan
#define idh__dx_directsoundbuffer_setvolume_dsound_vb 867788                        //  DirectSoundBuffer.SetVolume
#define idh__dx_directsoundbuffer_stop_dsound_vb 867789                             //  DirectSoundBuffer.Stop
#define idh__dx_directsoundbuffer_writebuffer_dsound_vb 867790                      //  DirectSoundBuffer.WriteBuffer
#define idh__dx_directsoundcapture_dsound_vb 867791                                 //  DirectSoundCapture
#define idh__dx_directsoundcapture_createcapturebuffer_dsound_vb 867792             //  DirectSoundCapture.CreateCaptureBuffer
#define idh__dx_directsoundcapture_getcaps_dsound_vb 867793                         //  DirectSoundCapture.GetCaps
#define idh__dx_directsoundcapturebuffer_dsound_vb 867794                           //  DirectSoundCaptureBuffer
#define idh__dx_directsoundcapturebuffer_getcaps_dsound_vb 867795                   //  DirectSoundCaptureBuffer.GetCaps
#define idh__dx_directsoundcapturebuffer_getcurrentposition_dsound_vb 867796        //  DirectSoundCaptureBuffer.GetCurrentPosition
#define idh__dx_directsoundcapturebuffer_getformat_dsound_vb 867797                 //  DirectSoundCaptureBuffer.GetFormat
#define idh__dx_directsoundcapturebuffer_getstatus_dsound_vb 867798                 //  DirectSoundCaptureBuffer.GetStatus
#define idh__dx_directsoundcapturebuffer_readbuffer_dsound_vb 867799                //  DirectSoundCaptureBuffer.ReadBuffer
#define idh__dx_directsoundcapturebuffer_setnotificationpositions_dsound_vb 867800  //  DirectSoundCaptureBuffer.SetNotificationPositions
#define idh__dx_directsoundcapturebuffer_start_dsound_vb 867801                     //  DirectSoundCaptureBuffer.Start
#define idh__dx_directsoundcapturebuffer_stop_dsound_vb 867802                      //  DirectSoundCaptureBuffer.Stop
#define idh__dx_directsoundcapturebuffer_writebuffer_dsound_vb 867803               //  DirectSoundCaptureBuffer.WriteBuffer
#define idh__dx_directsoundenum_dsound_vb 867804                                    //  DirectSoundEnum
#define idh__dx_directsoundenum_getcount_dsound_vb 867805                           //  DirectSoundEnum.GetCount
#define idh__dx_directsoundenum_getitem_dsound_vb 867806                            //  DirectSoundEnum.GetItem
#define idh__dx_directx7_dsound_vb 867807                                           //  DirectX7
#define idh__dx_ds3dbuffer_dsound_vb 867808                                         //  DS3DBUFFER
#define idh__dx_ds3dlistener_dsound_vb 867809                                       //  DS3DLISTENER
#define idh__dx_dsbcaps_dsound_vb 867810                                            //  DSBCAPS
#define idh__dx_dsbpositionnotify_dsound_vb 867811                                  //  DSBPOSITIONNOTIFY
#define idh__dx_dsbufferdesc_dsound_vb 867812                                       //  DSBUFFERDESC
#define idh__dx_dscaps_dsound_vb 867813                                             //  DSCAPS
#define idh__dx_dscbcaps_dsound_vb 867814                                           //  DSCBCAPS
#define idh__dx_dscbufferdesc_dsound_vb 867815                                      //  DSCBUFFERDESC
#define idh__dx_dsccaps_dsound_vb 867816                                            //  DSCCAPS
#define idh__dx_dscursors_dsound_vb 867817                                          //  DSCURSORS
#define idh__dx_dxdriverinfo_dsound_vb 867818                                       //  DXDRIVERINFO
#define idh__dx_waveformatex_dsound_vb 867819                                       //  WAVEFORMATEX
#define idh__dx_const_ds3dapplyflags_dsound_vb 867820                               //  CONST_DS3DAPPLYFLAGS
#define idh__dx_const_ds3dmodeflags_dsound_vb 867821                                //  CONST_DS3DMODEFLAGS
#define idh__dx_const_dsbcapsflags_dsound_vb 867822                                 //  CONST_DSBCAPSFLAGS
#define idh__dx_const_dsblockflags_dsound_vb 867823                                 //  CONST_DSBLOCKFLAGS
#define idh__dx_const_dsbplayflags_dsound_vb 867824                                 //  CONST_DSBPLAYFLAGS
#define idh__dx_const_dsbstatusflags_dsound_vb 867825                               //  CONST_DSBSTATUSFLAGS
#define idh__dx_const_dscapsflags_dsound_vb 867826                                  //  CONST_DSCAPSFLAGS
#define idh__dx_const_dscbcapsflags_dsound_vb 867827                                //  CONST_DSCBCAPSFLAGS
#define idh__dx_const_dscblockflags_dsound_vb 867828                                //  CONST_DSCBLOCKFLAGS
#define idh__dx_const_dscbstartflags_dsound_vb 867829                               //  CONST_DSCBSTARTFLAGS
#define idh__dx_const_dscbstatusflags_dsound_vb 867830                              //  CONST_DSCBSTATUSFLAGS
#define idh__dx_const_dsccapsflags_dsound_vb 867831                                 //  CONST_DSCCAPSFLAGS
#define idh__dx_const_dsound_dsound_vb 867832                                       //  CONST_DSOUND
#define idh__dx_const_dssclflags_dsound_vb 867833                                   //  CONST_DSSCLFLAGS
#define idh__dx_const_dsspeakerflags_dsound_vb 867834                               //  CONST_DSSPEAKERFLAGS
#define idh__dx_const_waveformatflags_dsound_vb 867835                              //  CONST_WAVEFORMATFLAGS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmcollectionobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcollectionobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmCollectionObj.h"


extern void *g_dxj_DirectMusicCollection;


CONSTRUCTOR(_dxj_DirectMusicCollection, {});
DESTRUCTOR(_dxj_DirectMusicCollection, {});
GETSET_OBJECT(_dxj_DirectMusicCollection);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmcollectionobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmcollectionobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicCollectionObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicCollection IDirectMusicCollection*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicCollectionObject : 
	public I_dxj_DirectMusicCollection,
	//public CComCoClass<C_dxj_DirectMusicCollectionObject, &CLSID__dxj_DirectMusicCollection>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicCollectionObject();
	virtual ~C_dxj_DirectMusicCollectionObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicCollectionObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicCollection)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicCollection,		"DIRECT.DirectMusicCollection.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicCollectionObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

      
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicCollection);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicCollection)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmcomposerobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcomposerobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicComposerObject

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicComposer IDirectMusicComposer*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicComposerObject : 
	public I_dxj_DirectMusicComposer,
	//public CComCoClass<C_dxj_DirectMusicComposerObject, &CLSID__dxj_DirectMusicComposer>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicComposerObject();
	virtual ~C_dxj_DirectMusicComposerObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicComposerObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicComposer)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicComposer,		"DIRECT.DirectMusicComposer.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicComposerObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

    
	    HRESULT STDMETHODCALLTYPE autoTransition( 
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *Performance,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppTransSeg);
    
    HRESULT STDMETHODCALLTYPE composeSegmentFromTemplate( 
		/* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *TemplateSeg,
        /* [in] */ short Activity,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeSegmentFromShape( 
        /* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ short numberOfMeasures,
        /* [in] */ short shape,
        /* [in] */ short activity,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeTransition( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *pFromSeg,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long mtTime,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeTemplateFromShape( 
        /* [in] */ short numMeasures,
        /* [in] */ short shape,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ short endLength,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *TempSeg);
    
    HRESULT STDMETHODCALLTYPE changeChordMap( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ VARIANT_BOOL trackScale,
        /* [retval][out] */ I_dxj_DirectMusicChordMap  *ChordMap);
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicComposer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicComposer)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmloaderobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmloaderobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicLoaderObject

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicLoader IDirectMusicLoader*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicLoaderObject : 
	public I_dxj_DirectMusicLoader,
	//public CComCoClass<C_dxj_DirectMusicLoaderObject, &CLSID__dxj_DirectMusicLoader>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicLoaderObject();
	virtual ~C_dxj_DirectMusicLoaderObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicLoaderObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicLoader)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicLoader,		"DIRECT.DirectMusicLoader.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicLoaderObject)


// I_dxj_Direct3dRMLight
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	 HRESULT STDMETHODCALLTYPE loadSegment( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadStyle( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadBand( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);

 	 HRESULT STDMETHODCALLTYPE loadCollection( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadSegmentFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadStyleFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadBandFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadCollectionFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE setSearchDirectory( BSTR path);

 	 HRESULT STDMETHODCALLTYPE loadChordMap( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadChordMapFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);



////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicLoader);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicLoader)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmcomposerobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcomposerobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"
#include "dmStyleObj.h"
#include "dmComposerObj.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicComposer;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicComposer, {});
DESTRUCTOR(_dxj_DirectMusicComposer, {});
GETSET_OBJECT(_dxj_DirectMusicComposer);

typedef IDirectMusicSegment*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance*	LPDIRECTMUSICPERFORMANCE;
typedef IDirectMusicChordMap*		LPDIRECTMUSICCHORDMAP;
typedef IDirectMusicStyle*			LPDIRECTMUSICSTYLE;

HRESULT C_dxj_DirectMusicComposerObject::autoTransition( 
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *Performance,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppTransSeg)
{
	HRESULT hr;			
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPERFORMANCE, pPerf,Performance);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pToSeg,ToSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->AutoTransition(pPerf,pToSeg,(WORD)lCommand,(DWORD)lFlags,pMap,&pNewSeg,NULL,NULL);
	if FAILED(hr) return hr;
	if (pNewSeg)	{
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,ppTransSeg);
	}
	else{
		*ppTransSeg=NULL;
	}

	return hr;
}

HRESULT C_dxj_DirectMusicComposerObject::composeSegmentFromTemplate( 
		/* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *TemplateSeg,
        /* [in] */ short activity,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSTYLE, pStyle,style);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pTemp,TemplateSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeSegmentFromTemplate(pStyle,pTemp,activity,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}

HRESULT C_dxj_DirectMusicComposerObject::composeSegmentFromShape( 
        /* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ short numberOfMeasures,
        /* [in] */ short shape,
        /* [in] */ short activity,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;	
	
	BOOL bi= (bIntro==VARIANT_TRUE);
	BOOL be= (bEnd==VARIANT_TRUE);

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSTYLE, pStyle,style);	
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeSegmentFromShape(pStyle,numberOfMeasures,shape,activity,bi,be,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}



HRESULT C_dxj_DirectMusicComposerObject::composeTransition( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *FromSeg,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long mtTime,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pFromSeg,FromSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pToSeg,ToSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeTransition(pFromSeg,pToSeg,(MUSIC_TIME)mtTime,(WORD)lCommand,(DWORD)lFlags,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}
    


HRESULT C_dxj_DirectMusicComposerObject::composeTemplateFromShape( 
        /* [in] */ short numMeasures,
        /* [in] */ short shape,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ short endLength,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *TempSeg)
{
	HRESULT hr;		
	BOOL bi=(bIntro==VARIANT_TRUE);
	BOOL be=(bEnd==VARIANT_TRUE);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeTemplateFromShape(numMeasures,shape,bi,be,endLength,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,TempSeg);

	return hr;
}
        


HRESULT C_dxj_DirectMusicComposerObject::changeChordMap( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ VARIANT_BOOL trackScale,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR  *ChordMap)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pSeg,segment);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,ChordMap);
	BOOL bs=(trackScale==VARIANT_TRUE);	

	
	hr=m__dxj_DirectMusicComposer->ChangeChordMap(pSeg,bs,pMap);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmloaderobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmloaderobj.cpp
//
//--------------------------------------------------------------------------

// dmLoaderObj.cpp

#include "stdafx.h"
#include "Direct.h"
#include "dmusici.h"
#include "dms.h"
#include "dmLoaderObj.h"
#include "dmBandObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmCollectionObj.h"
#include "dmChordMapObj.h"

extern void *g_dxj_DirectMusicLoader;
extern void *g_dxj_DirectMusicBand;
extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicCollection;
extern void *g_dxj_DirectMusicChordMap;
	

CONSTRUCTOR(_dxj_DirectMusicLoader, {});
DESTRUCTOR(_dxj_DirectMusicLoader, {});
GETSET_OBJECT(_dxj_DirectMusicLoader);


extern HRESULT CREATE_DMSEGMENT_NOADDREF(IDirectMusicSegment *pSeg,I_dxj_DirectMusicSegment **segment) ;


BOOL HasBackslash(BSTR b){
	
	DWORD cbLen=SysStringLen(b);
	
	for (DWORD i=0;i<cbLen;i++) 
	{
		if (b[i]==((unsigned short)'\\'))
			 return TRUE;
	}
	return FALSE;
}


HRESULT C_dxj_DirectMusicLoaderObject::loadSegment( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (!filename)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_FILENAME |  DMUS_OBJ_CLASS ; //DMUS_OBJ_FULLPATH
	objdesc.guidClass=CLSID_DirectMusicSegment;
	
	if (((DWORD*)filename)[-1]>DMUS_MAX_FILENAME) return E_INVALIDARG;
	wcscpy(objdesc.wszFileName, filename);	
	IDirectMusicSegment *pOut=NULL;
    
	if (HasBackslash(filename)){
		objdesc.dwValidData=objdesc.dwValidData | DMUS_OBJ_FULLPATH;
	}

	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicSegment,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	//INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pOut,ret);
	hr=CREATE_DMSEGMENT_NOADDREF(pOut,ret);
	if FAILED(hr) return hr;

	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadStyle( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (!filename)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_FILENAME |  DMUS_OBJ_CLASS ;
	objdesc.guidClass=CLSID_DirectMusicStyle;
	if (((DWORD*)filename)[-1]>DMUS_MAX_FILENAME) return E_INVALIDARG;
	wcscpy(objdesc.wszFileName, filename);

	IDirectMusicSegment *pOut=NULL;
    
	if (HasBackslash(filename)){
		objdesc.dwValidData=objdesc.dwValidData | DMUS_OBJ_FULLPATH;
	}


	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicStyle,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}
HRESULT C_dxj_DirectMusicLoaderObject::loadBand( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (!filename)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_FILENAME |  DMUS_OBJ_CLASS ;
	objdesc.guidClass=CLSID_DirectMusicBand;
	if (((DWORD*)filename)[-1]>DMUS_MAX_FILENAME) return E_INVALIDARG;
	wcscpy(objdesc.wszFileName, filename);

	IDirectMusicSegment *pOut=NULL;

   	if (HasBackslash(filename)){
		objdesc.dwValidData=objdesc.dwValidData | DMUS_OBJ_FULLPATH;
	}

	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicBand,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadCollection( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (!filename)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_FILENAME | DMUS_OBJ_CLASS ;
	objdesc.guidClass=CLSID_DirectMusicCollection;
	if (((DWORD*)filename)[-1]>DMUS_MAX_FILENAME) return E_INVALIDARG;
	wcscpy(objdesc.wszFileName, filename);

	IDirectMusicSegment *pOut=NULL;

    if (HasBackslash(filename)){
		objdesc.dwValidData=objdesc.dwValidData | DMUS_OBJ_FULLPATH;
	}

	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicCollection,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicCollection,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadChordMap( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (!filename)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_FILENAME | DMUS_OBJ_CLASS ;
	objdesc.guidClass=CLSID_DirectMusicChordMap;
	if (((DWORD*)filename)[-1]>DMUS_MAX_FILENAME) return E_INVALIDARG;
	wcscpy(objdesc.wszFileName, filename);

	IDirectMusicSegment *pOut=NULL;
    
   	if (HasBackslash(filename)){
		objdesc.dwValidData=objdesc.dwValidData | DMUS_OBJ_FULLPATH;
	}

	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicChordMap,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}


HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadSegmentFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{

	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;
	

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98
		// so we convert to ansi first
		LPCTSTR pszName = W2T(moduleName);
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMSEG");
	if (!hres) return E_FAIL;
	

	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;


	dwSize=SizeofResource(hMod,hres); 
	
	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicSegment;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicSegment,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;	
	return hr;
}

HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadStyleFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{
    HRESULT hr;
	HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98				
		// convert to ansi first
		LPCTSTR pszName = W2T(moduleName);
		hMod= GetModuleHandle(pszName);

	}

	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMSTYLE");


	if (!hres) return E_FAIL;


	pMem=(void*)LoadResource(hMod,hres);


	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicStyle;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicStyle,(void**)&pOut);	
	
	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
}

HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadBandFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98
		// converting to ansi first
		LPCTSTR pszName = W2T(moduleName);
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMBAND");
	if (!hres) return E_FAIL;
	
	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 
	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicBand;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicBand,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}


 HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadCollectionFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98		
		// converting to ansi first
		LPCTSTR pszName = W2T(moduleName);
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMCOL");
	if (!hres) return E_FAIL;
	
	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicCollection;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicCollection,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicCollection,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
	

}

 
HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadChordMapFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// converting to ansi first
		 LPCTSTR pszName = W2T(moduleName);
		 hMod= GetModuleHandle(pszName);
	}

	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMCHORD");
	if (!hres) {
		//MessageBox(NULL,"FindResourceW Failed","test",MB_OK);
		return E_FAIL;
	}

	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem){
		//MessageBox(NULL,"LoadResource Failed","test",MB_OK);
		return E_FAIL;
	}

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicChordMap;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicChordMap,(void**)&pOut);	
	if FAILED(hr) {
		//MessageBox(NULL,"GetObject Failed","test",MB_OK);
		return hr;
	}

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
	

}


 HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::setSearchDirectory( BSTR dir)
 {
	HRESULT hr;
	hr=m__dxj_DirectMusicLoader->SetSearchDirectory(GUID_DirectMusicAllTypes,dir, TRUE);    //?
	return hr;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmperformanceobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmperformanceobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicPerformanceObject

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicPerformance IDirectMusicPerformance*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicPerformanceObject : 
	public I_dxj_DirectMusicPerformance,
	//public CComCoClass<C_dxj_DirectMusicPerformanceObject, &CLSID__dxj_DirectMusicPerformance>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicPerformanceObject();
	virtual ~C_dxj_DirectMusicPerformanceObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicPerformanceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicPerformance)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicPerformance,		"DIRECT.DirectMusicPerformance.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicPerformanceObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);



    HRESULT STDMETHODCALLTYPE init( 
        /* [in] */ I_dxj_DirectSound __RPC_FAR *DirectSound,
        /* [in] */ long hWnd);
    
    HRESULT STDMETHODCALLTYPE closeDown( void);
    
    HRESULT STDMETHODCALLTYPE playSegment( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ long lFlags,
        /* [in] */ long startTime,
        /* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState);
    
    HRESULT STDMETHODCALLTYPE stop( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
        /* [in] */ long mtTime,
        /* [in] */ long lFlags);
    
    HRESULT STDMETHODCALLTYPE getSegmentState( 
        /* [in] */ long mtTime,
        /* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE invalidate( 
        /* [in] */ long mtTime,
        /* [in] */ long flags);
    
    HRESULT STDMETHODCALLTYPE isPlaying( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
    
    HRESULT STDMETHODCALLTYPE addNotificationType( 
        /* [in] */ CONST_DMUS_NOTIFICATION_TYPE type);
    
    HRESULT STDMETHODCALLTYPE removeNotificationType( 
        /* [in] */ CONST_DMUS_NOTIFICATION_TYPE type);
    
    HRESULT STDMETHODCALLTYPE setNotificationHandle( 
        /* [in] */ long hnd);
    
    HRESULT STDMETHODCALLTYPE getNotificationPMSG( 
        /* [out][in] */ DMUS_NOTIFICATION_PMSG_CDESC __RPC_FAR *message, VARIANT_BOOL *b);
    
    HRESULT STDMETHODCALLTYPE musicToClockTime( 
        /* [in] */ long mtTime,
        /* [retval][out] */ long __RPC_FAR *rtTime);
    
    HRESULT STDMETHODCALLTYPE clockToMusicTime( 
        /* [in] */ long rtTime,
        /* [retval][out] */ long __RPC_FAR *mtTime);
    
    HRESULT STDMETHODCALLTYPE getMusicTime( 
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getClockTime( 
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getPrepareTime( 
        /* [retval][out] */ long __RPC_FAR *lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE getBumperLength( 
        /* [retval][out] */ long __RPC_FAR *lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE getLatencyTime( 
        /* [retval][out] */ long __RPC_FAR *rtTime0);
    
    HRESULT STDMETHODCALLTYPE getQueueTime( 
        /* [retval][out] */ long __RPC_FAR *rtTime);
    
    HRESULT STDMETHODCALLTYPE getResolvedTime( 
        /* [in] */ long rtTime,
        /* [in] */ long flags,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE setPrepareTime( 
        /* [in] */ long lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE setBumperLength( 
        /* [in] */ long lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE adjustTime( 
        /* [in] */ long rtAmount);
    
    HRESULT STDMETHODCALLTYPE setMasterAutoDownload( 
        /* [in] */ VARIANT_BOOL b);
    
    HRESULT STDMETHODCALLTYPE getMasterAutoDownload( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
    
    HRESULT STDMETHODCALLTYPE setMasterTempo( 
        /* [in] */ float tempo);
    
    HRESULT STDMETHODCALLTYPE getMasterTempo( 
        /* [retval][out] */ float __RPC_FAR *tempo);
    
    HRESULT STDMETHODCALLTYPE setMasterVolume( 
        /* [in] */ long vol);
    
    HRESULT STDMETHODCALLTYPE getMasterVolume( 
        /* [retval][out] */ long __RPC_FAR *v);
    
    HRESULT STDMETHODCALLTYPE setMasterGrooveLevel( 
        /* [in] */ short level);
    
    HRESULT STDMETHODCALLTYPE getMasterGrooveLevel( 
        /* [retval][out] */  __RPC_FAR short *level);
    
    HRESULT STDMETHODCALLTYPE Reset(long flags);
    
    HRESULT STDMETHODCALLTYPE getStyle( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getChordMap( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getCommand( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ Byte __RPC_FAR *command);
    
    HRESULT STDMETHODCALLTYPE getGrooveLevel( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ Byte __RPC_FAR *level);
    
    HRESULT STDMETHODCALLTYPE getTempo( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ double __RPC_FAR *tempo);
    
    HRESULT STDMETHODCALLTYPE getTimeSig( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSig);
    
    HRESULT STDMETHODCALLTYPE sendNotePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ DMUS_NOTE_PMSG_CDESC __RPC_FAR *msg);
    
    HRESULT STDMETHODCALLTYPE sendCurvePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ DMUS_CURVE_PMSG_CDESC __RPC_FAR *msg);
    
    HRESULT STDMETHODCALLTYPE sendMIDIPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ Byte status,
        /* [in] */ Byte byte1,
        /* [in] */ Byte byte2);
    
    HRESULT STDMETHODCALLTYPE sendPatchPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ Byte instrument,
        /* [in] */ Byte byte1,
        /* [in] */ Byte byte2);
    
    HRESULT STDMETHODCALLTYPE sendTempoPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
       // /* [in] */ long channel,
        /* [in] */ double tempo);
    
    HRESULT STDMETHODCALLTYPE sendTransposePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ short transpose);
    
    HRESULT STDMETHODCALLTYPE sendTimeSigPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timesig);
    
    HRESULT STDMETHODCALLTYPE getPortName( 
        /* [in] */ long i,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getPortCount( 
        /* [retval][out] */ long __RPC_FAR *c);
    
    HRESULT STDMETHODCALLTYPE getPortCaps( long i,
        /* [out][in] */ DMUS_PORTCAPS_CDESC __RPC_FAR *caps);
    
    HRESULT STDMETHODCALLTYPE setPort( 
        /* [in] */ long portid,
        /* [in] */ long numGroups);
        
////////////////////////////////////////////////////////////////////////////////////
//
private:
	HRESULT InternalInit();
	HRESULT InternalCleanup();
	

	IDirectMusic *m_pDM;
	IDirectMusicPort *m_pPort;
    DECL_VARIABLE(_dxj_DirectMusicPerformance);
	long m_portid;
	long m_number_of_groups;


	

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicPerformance)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmperformanceobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmperformanceobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmPerformanceObj.h"
#include "dmSegmentStateObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmChordMapObj.h"
//#include "dsoundobj.h"

extern void *g_dxj_DirectMusicPerformance;
extern void *g_dxj_DirectMusicSegmentState;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern CRITICAL_SECTION g_cbCriticalSection;

CONSTRUCTOR(_dxj_DirectMusicPerformance, {InternalInit();});
DESTRUCTOR(_dxj_DirectMusicPerformance, {InternalCleanup();});
GETSET_OBJECT(_dxj_DirectMusicPerformance);

typedef IDirectMusicSegment* LPDIRECTMUSICSEGMENT;
typedef IDirectMusicSegmentState* LPDIRECTMUSICSEGMENTSTATE ;

HRESULT C_dxj_DirectMusicPerformanceObject::InternalInit(){
	m_pDM = NULL;
	m_pPort=NULL;
	m_portid=-1;
	m_number_of_groups=4;

	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::InternalCleanup(){	
	if (m_pPort) m_pPort->Release();
	if (m_pDM) m_pDM->Release();
	m__dxj_DirectMusicPerformance->CloseDown();
	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::init( 
		/* [in] */ I_dxj_DirectSound __RPC_FAR *DirectSound,
		/* [in] */ long hWnd)
{
	HRESULT hr;	
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND,pSound,DirectSound);
    
	hr=m__dxj_DirectMusicPerformance->Init(&m_pDM,pSound,(HWND)hWnd);
	if FAILED(hr) return hr;
	
	//hr=m__dxj_DirectMusicPerformance->AddPort(NULL);
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::closeDown( )
{
	HRESULT hr;	
	hr=m__dxj_DirectMusicPerformance->CloseDown();
	return hr;
}
 

#define VBREF_TO_REALREFTIME(startTime) ((__int64)startTime*10000)
#define REALREF_TO_VBREFTIME(startTime) ((long)(startTime/10000))

HRESULT C_dxj_DirectMusicPerformanceObject::playSegment( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ long lFlags,
		/* [in] */ long startTime,
		/* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState)
{
	HRESULT hr;	
	if (!segment) return E_INVALIDARG;
	if (!segmentState) return E_INVALIDARG;
					     
	DO_GETOBJECT_NOTNULL(IDirectMusicSegment*,pSeg,segment);
	IDirectMusicSegmentState *pState=NULL;
	
	__int64 outTime=(__int64)startTime;
	if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(startTime);
	
	hr=m__dxj_DirectMusicPerformance->PlaySegment(pSeg,(DWORD)lFlags,outTime,&pState);
	if FAILED(hr) return hr;
	if (!pState) return E_FAIL;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegmentState,pState,segmentState);
	
	if (*segmentState==NULL) return E_OUTOFMEMORY;
	return hr;
}

	 





HRESULT C_dxj_DirectMusicPerformanceObject::getSegmentState( 
		/* [in] */ long mtTime,
		/* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState)
{
	HRESULT hr;	
	IDirectMusicSegmentState *pState=NULL;
	hr=m__dxj_DirectMusicPerformance->GetSegmentState(&pState,(MUSIC_TIME)mtTime);
	if FAILED(hr) return hr;
	if (!pState) return E_FAIL;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegmentState,pState,segmentState);
	if (*segmentState==NULL) return E_OUTOFMEMORY;
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::invalidate( 
		/* [in] */ long mtTime,
		/* [in] */ long flags)

{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->Invalidate((MUSIC_TIME)mtTime,(DWORD)flags);
	return hr;
}



HRESULT C_dxj_DirectMusicPerformanceObject::isPlaying( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
		/* [retval][out] */ VARIANT_BOOL __RPC_FAR *b)
		
{
	HRESULT hr;	
	
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT,pSeg,segment);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENTSTATE,pSegState,segmentState);
			
	hr=m__dxj_DirectMusicPerformance->IsPlaying(pSeg,pSegState);	
	if (hr==S_FALSE){
		*b=VARIANT_FALSE;
	}
	else if (hr==S_OK){
		*b=VARIANT_TRUE;
	}
	else{
		return hr;
	}
	return S_OK;
}



HRESULT C_dxj_DirectMusicPerformanceObject::addNotificationType(CONST_DMUS_NOTIFICATION_TYPE t)		
{
	HRESULT hr;	
	GUID g;
	switch (t){	
	 case DMUS_NOTIFY_ON_CHORD:
		g=GUID_NOTIFICATION_CHORD;
		break;

	 case DMUS_NOTIFY_ON_COMMAND:
		g=GUID_NOTIFICATION_COMMAND;
		break;
	 case DMUS_NOTIFY_ON_MEASUREANDBEAT:
		g=GUID_NOTIFICATION_MEASUREANDBEAT;
		break;
	 case DMUS_NOTIFY_ON_PERFORMANCE:
		g=GUID_NOTIFICATION_PERFORMANCE;
		break;
	 case DMUS_NOTIFY_ON_SEGMENT:
		g=GUID_NOTIFICATION_SEGMENT;
		break;
	 default:
		return E_INVALIDARG;
	}
	
	hr=m__dxj_DirectMusicPerformance->AddNotificationType(g);	
	return hr;
}


HRESULT C_dxj_DirectMusicPerformanceObject::removeNotificationType( /* [in] */CONST_DMUS_NOTIFICATION_TYPE t)		
{
	HRESULT hr;	
	GUID g;
	switch (t){	
	 case DMUS_NOTIFY_ON_CHORD:
		g=GUID_NOTIFICATION_CHORD;
		break;

	 case DMUS_NOTIFY_ON_COMMAND:
		g=GUID_NOTIFICATION_COMMAND;
		break;
	 case DMUS_NOTIFY_ON_MEASUREANDBEAT:
		g=GUID_NOTIFICATION_MEASUREANDBEAT;
		break;
	 case DMUS_NOTIFY_ON_PERFORMANCE:
		g=GUID_NOTIFICATION_PERFORMANCE;
		break;
	 case DMUS_NOTIFY_ON_SEGMENT:
		g=GUID_NOTIFICATION_SEGMENT;
		break;
	 default:
		return E_INVALIDARG;
	}
	hr=m__dxj_DirectMusicPerformance->RemoveNotificationType(g);	
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::setNotificationHandle( 	/* [in] */ long hnd)		
{
	HRESULT hr;	
	hr=m__dxj_DirectMusicPerformance->SetNotificationHandle((HWND)hnd,0);	
	return hr;
}	
	

HRESULT C_dxj_DirectMusicPerformanceObject::getNotificationPMSG( DMUS_NOTIFICATION_PMSG_CDESC *pMsgOut, VARIANT_BOOL *bOut)				
{
	HRESULT hr;	
	DMUS_NOTIFICATION_PMSG *pMsg=NULL;
	
	if (!pMsgOut) return E_INVALIDARG;
	if (!bOut) return E_INVALIDARG;

	hr=m__dxj_DirectMusicPerformance->GetNotificationPMsg(&pMsg);	
	if FAILED(hr) return hr;
	
	*bOut=VARIANT_FALSE;	

	if (!pMsg) 	return S_OK;

	if (hr!=S_FALSE) 	*bOut=VARIANT_TRUE;	
	

	pMsgOut->mtTime=(long)pMsg->mtTime;
	pMsgOut->ctTime=(long)REALREF_TO_VBREFTIME(pMsg->rtTime);
	pMsgOut->lFlags=(long)pMsg->dwFlags;
	
	pMsgOut->lNotificationOption =pMsg->dwNotificationOption;
	pMsgOut->lField1=pMsg->dwField1;
	pMsgOut->lField2=pMsg->dwField2;


	if (0==memcmp(&GUID_NOTIFICATION_CHORD,&pMsg->guidNotificationType,sizeof(GUID))){
		pMsgOut->lNotificationType=DMUS_NOTIFY_ON_CHORD;
	}
	else if (0==memcmp(&GUID_NOTIFICATION_COMMAND,&pMsg->guidNotificationType,sizeof(GUID))){
		pMsgOut->lNotificationType=DMUS_NOTIFY_ON_COMMAND;
	}
	else if (0==memcmp(&GUID_NOTIFICATION_MEASUREANDBEAT,&pMsg->guidNotificationType,sizeof(GUID))){
		pMsgOut->lNotificationType=DMUS_NOTIFY_ON_MEASUREANDBEAT;
	}
	else if (0==memcmp(&GUID_NOTIFICATION_PERFORMANCE,&pMsg->guidNotificationType,sizeof(GUID))){
		pMsgOut->lNotificationType=DMUS_NOTIFY_ON_PERFORMANCE;
	}
	else if (0==memcmp(&GUID_NOTIFICATION_SEGMENT,&pMsg->guidNotificationType,sizeof(GUID))){
		pMsgOut->lNotificationType=DMUS_NOTIFY_ON_SEGMENT;
	}
	else {
		pMsgOut->lNotificationType=0;		
	}

	m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG *)pMsg);

	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::musicToClockTime( /* [in] */ long mtTime,
		/* [retval][out] */ long __RPC_FAR *rtTime)				
{
	HRESULT hr;	
	__int64 outTime;
	hr=m__dxj_DirectMusicPerformance->MusicToReferenceTime((MUSIC_TIME)mtTime,&outTime);
	if FAILED(hr) return hr;
	*rtTime=REALREF_TO_VBREFTIME(outTime);
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::clockToMusicTime( 	/* [in] */ long rtTime,
		/* [retval][out] */ long __RPC_FAR *mtTime)				
{
	HRESULT hr;	
	__int64 outTime=VBREF_TO_REALREFTIME(rtTime);;
	hr=m__dxj_DirectMusicPerformance->ReferenceToMusicTime(outTime,(MUSIC_TIME*)mtTime);		
	return hr;
}	
	 


HRESULT C_dxj_DirectMusicPerformanceObject::getMusicTime( /* [retval][out] */ long __RPC_FAR *mtTime)		
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->GetTime(NULL,(MUSIC_TIME*)mtTime);		
	return hr;
}	
	 

HRESULT C_dxj_DirectMusicPerformanceObject::getClockTime( /* [retval][out] */ long __RPC_FAR *rtTime)		
{
	HRESULT hr;	
	__int64 outTime=0;
	hr=m__dxj_DirectMusicPerformance->GetTime(&outTime,NULL);
	*rtTime=REALREF_TO_VBREFTIME(outTime);
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::getPrepareTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->GetPrepareTime((DWORD*)pTime);	
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getBumperLength(/* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->GetBumperLength((DWORD*)pTime);	
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getLatencyTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__int64 t;
	if (!pTime) return E_INVALIDARG;
	hr=m__dxj_DirectMusicPerformance->GetLatencyTime(&t);	
	*pTime=REALREF_TO_VBREFTIME(t);
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getQueueTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__int64 t;
	if (!pTime) return E_INVALIDARG;
	hr=m__dxj_DirectMusicPerformance->GetQueueTime(&t);	
	*pTime=REALREF_TO_VBREFTIME(t);
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getResolvedTime( /* [in] */ long rtTime, /* [in] */ long flags,	/* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;		
	__int64 outtime1= VBREF_TO_REALREFTIME(rtTime);
	__int64 outtime2=0;
	hr=m__dxj_DirectMusicPerformance->GetResolvedTime(outtime1,&outtime2,(DWORD)flags);	
	*ret=REALREF_TO_VBREFTIME(outtime2);
	return hr;
}	

	 

HRESULT C_dxj_DirectMusicPerformanceObject::setPrepareTime( /* [retval][out] */ long  t)		
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->SetPrepareTime((DWORD)t);	
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::setBumperLength(/* [retval][out] */ long  t)		
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicPerformance->SetBumperLength((DWORD)t);	
	return hr;
}	



HRESULT C_dxj_DirectMusicPerformanceObject::adjustTime( 		
		/* [retval][out] */ long  t)		
{
	HRESULT hr;		
	REFERENCE_TIME rt =(REFERENCE_TIME)t;
	hr=m__dxj_DirectMusicPerformance->AdjustTime(rt);	
	return hr;
}	








HRESULT C_dxj_DirectMusicPerformanceObject::setMasterAutoDownload( /* [in] */ VARIANT_BOOL bval)
{
	HRESULT hr;
	BOOL b=(BOOL)(bval==VARIANT_TRUE);

	hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfAutoDownload,(void*)&b,sizeof(BOOL));
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterAutoDownload( /* [in] */ VARIANT_BOOL *bIn)
{
	HRESULT hr;
	BOOL	b;
	hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfAutoDownload,(void*) &b,sizeof(BOOL));
	if (b){
		*bIn=VARIANT_TRUE;
	}
	else{
		*bIn=VARIANT_FALSE;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::setMasterTempo( /* [in] */ float tempo)
{
	HRESULT hr;
	hr=m__dxj_DirectMusicPerformance->SetGlobalParam( GUID_PerfMasterTempo ,(void*) &tempo,sizeof(float));
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterTempo( /* [in] */ float *tempo)
{
	HRESULT hr;
	hr=m__dxj_DirectMusicPerformance->GetGlobalParam( GUID_PerfMasterTempo ,(void*) tempo,sizeof(float));
	return hr;
}


HRESULT C_dxj_DirectMusicPerformanceObject::setMasterVolume( /* [in] */ long vol)
{
	HRESULT hr;
	hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfMasterVolume  ,(void*) &vol,sizeof(long));
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterVolume( /* [in] */ long *vol)
{
	HRESULT hr;
	hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfMasterVolume ,(void*) vol,sizeof(long));
	return hr;
}



HRESULT C_dxj_DirectMusicPerformanceObject::setMasterGrooveLevel( /* [in] */ short level)
{
	HRESULT hr;
	
	char l=(char)level;

	hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfMasterGrooveLevel  ,(void*) &l,sizeof(char));
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterGrooveLevel( /* [in] */ short *level)
{
	HRESULT hr;
	if (!level) return E_INVALIDARG;
	char l=0;

	hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfMasterGrooveLevel ,(void*) &l,sizeof(char));
	*level=(short)l;
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::stop( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,		
		/* [in] */ long endTime,
		/* [in] */ long lFlags)
		
{
	HRESULT hr;	
	
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT,pSeg,segment);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENTSTATE,pSegState,segmentState);
	
	
	
	__int64 outTime=(__int64)endTime;
	if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(endTime);
	
	hr=m__dxj_DirectMusicPerformance->Stop(pSeg,pSegState,(MUSIC_TIME)outTime,(DWORD)lFlags);	
	
	return hr;
}




HRESULT C_dxj_DirectMusicPerformanceObject::Reset(long resetFlags)
{
    DMUS_SYSEX_PMSG     *pGMReset;
    BYTE                abGMReset[] = {0xF0,0x7E,0x7F,0x09,0x01,0xF7};
    DWORD               dwLen;
	HRESULT				hr=S_OK;

	if (!resetFlags){
		dwLen = sizeof(abGMReset)/sizeof(abGMReset[0]);

		if(SUCCEEDED( m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_SYSEX_PMSG) + dwLen,
																(DMUS_PMSG**)&pGMReset )))
		{
			ZeroMemory(pGMReset, sizeof(pGMReset));
			pGMReset->dwSize = sizeof(DMUS_SYSEX_PMSG);
			pGMReset->dwPChannel = 0;
			pGMReset->dwVirtualTrackID = 0;
			pGMReset->dwType = DMUS_PMSGT_SYSEX ;
			pGMReset->dwVoiceID = 0;
			pGMReset->dwGroupID = 0xFFFFFFFF;

			pGMReset->dwLen = dwLen;
			memcpy(pGMReset->abData, abGMReset, dwLen);

			if (SUCCEEDED(m__dxj_DirectMusicPerformance->GetTime(NULL, &pGMReset->mtTime)))
			{
				pGMReset->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_IMMEDIATE;
			}

			hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pGMReset);
		}
	}
	else if(resetFlags==1){

		//1) Find out what port we're playing through
		//2)  Close the port
		//3) Open the port back up.
		
		hr=setPort(m_portid,m_number_of_groups);
	}
	else {
		hr=E_INVALIDARG;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getStyle( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{				
		HRESULT hr;	
		IDirectMusicStyle *pStyle=NULL;

		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_IDirectMusicStyle,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&pStyle );	
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pStyle,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
		return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getChordMap( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
		HRESULT hr;	
		IDirectMusicChordMap *pMap=NULL;

		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_IDirectMusicChordMap,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&pMap );	
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
		return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getCommand( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ Byte __RPC_FAR *command)
{
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;								
		if (!command) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&cmd );	
		if FAILED(hr) return hr;		
		*command=cmd.bCommand;		
		return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getGrooveLevel( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ Byte __RPC_FAR *level)
{
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;			
		if (!level) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&cmd );	
		if FAILED(hr) return hr;		
		*level=cmd.bGrooveLevel;		
		return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getTempo( 		
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ double __RPC_FAR *tempo)
{
	HRESULT hr;	
	DMUS_TEMPO_PARAM tmp;
	if (!tempo) return E_INVALIDARG;
	hr=m__dxj_DirectMusicPerformance->GetParam(GUID_TempoParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&tmp );	
	if FAILED(hr) return hr;		
	*tempo=tmp.dblTempo;		
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getTimeSig( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSig)
{
	
	HRESULT hr;	
	if (!timeSig) return E_INVALIDARG;
	hr=m__dxj_DirectMusicPerformance->GetParam(GUID_TimeSignature,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,(DMUS_TIMESIGNATURE*)timeSig);		
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendNotePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ DMUS_NOTE_PMSG_CDESC __RPC_FAR *msg)
{


	HRESULT		hr;
	DMUS_NOTE_PMSG	*pPMSG=NULL;
	if (!msg) return E_INVALIDARG;
	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG),(DMUS_PMSG**)&pPMSG);
	if FAILED(hr) return hr;

	//memcpy(pPMSG,msg,sizeof(DMUS_NOTE_PMSG));
	//depends on alignment settings
	//and how dll is compiled to work right.
	//copy member by member instead..
	ZeroMemory(pPMSG,sizeof(DMUS_NOTE_PMSG));
	pPMSG->dwSize=sizeof(DMUS_NOTE_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_NOTE;	
	pPMSG->dwPChannel =(DWORD)channel;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	
	
	pPMSG->mtDuration=(MUSIC_TIME)msg->mtDuration;
	pPMSG->wMusicValue=(WORD)msg->musicValue;
	pPMSG->wMeasure=(WORD)msg->measure;
	pPMSG->nOffset=(short)msg->offset;
	pPMSG->bBeat=(BYTE)msg->beat;
	pPMSG->bGrid=(BYTE)msg->grid;
	pPMSG->bVelocity=(BYTE)msg->velocity;
	pPMSG->bFlags=(BYTE)msg->flags;
	pPMSG->bTimeRange=(BYTE)msg->timeRange;
	pPMSG->bDurRange=(BYTE)msg->durRange;
	pPMSG->bVelRange=(BYTE)msg->velRange;
	pPMSG->bPlayModeFlags=(BYTE)msg->playModeFlags;
	pPMSG->bSubChordLevel=(BYTE)msg->subChordLevel;
	pPMSG->bMidiValue=(BYTE)msg->midiValue;
	pPMSG->cTranspose=(char)msg->transpose;


	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
	return hr;

}

HRESULT C_dxj_DirectMusicPerformanceObject::sendCurvePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ DMUS_CURVE_PMSG_CDESC __RPC_FAR *msg)
{
	HRESULT		hr;
	DMUS_CURVE_PMSG	*pPMSG=NULL;
	if (!msg) return E_INVALIDARG;

	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG**)&pPMSG);

	
	pPMSG->dwSize=sizeof(DMUS_CURVE_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_CURVE;	
	pPMSG->dwPChannel =(DWORD)channel;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;

	pPMSG->mtDuration=msg->mtDuration;
	pPMSG->mtOriginalStart=msg->mtOriginalStart;
	pPMSG->mtResetDuration=msg->mtResetDuration;	
	pPMSG->nStartValue =(short)msg->startValue;
	pPMSG->nEndValue =(short)msg->endValue;
	pPMSG->nResetValue =(short)msg->resetValue;
	pPMSG->wMeasure =(short)msg->measure;
	pPMSG->nOffset =(short)msg->offset;
	pPMSG->bBeat =(Byte)msg->beat;
	pPMSG->bGrid =(Byte)msg->grid;
	pPMSG->bType =(Byte)msg->type;
	pPMSG->bCurveShape =(Byte)msg->curveShape;
	pPMSG->bCCData =(Byte)msg->ccData;
	pPMSG->bFlags =(Byte)msg->flags;


	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendMIDIPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ Byte status,
		/* [in] */ Byte byte1,
		/* [in] */ Byte byte2)
{
	HRESULT		hr;
	DMUS_MIDI_PMSG	*pPMSG=NULL;
	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG),(DMUS_PMSG**)&pPMSG);	
	ZeroMemory(pPMSG,sizeof(DMUS_MIDI_PMSG));
	pPMSG->dwSize=sizeof(DMUS_MIDI_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_MIDI;	
	pPMSG->dwPChannel =(DWORD)channel;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	pPMSG->bStatus=status;
	pPMSG->bByte1=byte1;
	pPMSG->bByte2=byte2;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendPatchPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ Byte instrument,
		/* [in] */ Byte byte1,
		/* [in] */ Byte byte2)
{
	HRESULT		hr;
	DMUS_PATCH_PMSG	*pPMSG=NULL; 
	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_PATCH_PMSG),(DMUS_PMSG**)&pPMSG);	
	ZeroMemory(pPMSG,sizeof(DMUS_PATCH_PMSG));
	pPMSG->dwSize=sizeof(DMUS_PATCH_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_PATCH;	
	pPMSG->dwPChannel =(DWORD)channel;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	pPMSG->byInstrument=instrument;
	pPMSG->byMSB=byte1;
	pPMSG->byLSB=byte2;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
	return hr;}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTempoPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		///* [in] */ long channel,
		/* [in] */ double tempo)
{
	HRESULT		hr;
	DMUS_TEMPO_PMSG	*pPMSG=NULL;
	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pPMSG);	
	ZeroMemory(pPMSG,sizeof(DMUS_TEMPO_PMSG));
	pPMSG->dwSize=sizeof(DMUS_TEMPO_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_TEMPO;	
	pPMSG->dwPChannel =(DWORD)0;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	pPMSG->dblTempo=tempo;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG); 
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTransposePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ short transpose)
{
	
	HRESULT		hr;
	DMUS_TRANSPOSE_PMSG	*pPMSG=NULL;
	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TRANSPOSE_PMSG),(DMUS_PMSG**)&pPMSG);	
	ZeroMemory(pPMSG,sizeof(DMUS_TRANSPOSE_PMSG));
	pPMSG->dwSize=sizeof(DMUS_TRANSPOSE_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_TRANSPOSE;	
	pPMSG->dwPChannel =(DWORD)channel;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	pPMSG->nTranspose=transpose;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG); 
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTimeSigPMSG( 
		/* [in] */ long mtTime,		
		/* [in] */ long flags,
		/* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timesig)
{
	HRESULT		hr;
	DMUS_TIMESIG_PMSG	*pPMSG=NULL;
	if (!timesig) return E_INVALIDARG;

	hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TIMESIG_PMSG),(DMUS_PMSG**)&pPMSG);
	ZeroMemory(pPMSG,sizeof(DMUS_TIMESIG_PMSG));
	pPMSG->dwSize=sizeof(DMUS_TIMESIG_PMSG);
	pPMSG->mtTime=(MUSIC_TIME)mtTime;	
	pPMSG->dwFlags=(DWORD)flags;
	pPMSG->dwType=DMUS_PMSGT_CURVE;	
	pPMSG->dwPChannel =(DWORD)0;
	pPMSG->dwVirtualTrackID  =(DWORD)0;
	pPMSG->dwGroupID=(DWORD)-1;
	if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;

	pPMSG->bBeatsPerMeasure   =timesig->beatsPerMeasure; 
	pPMSG->bBeat=timesig->beat;  
	pPMSG->wGridsPerBeat=timesig->gridsPerBeat;

	hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  

	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getPortName( 
		/* [in] */ long i,
		/* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;	
	DMUS_PORTCAPS caps;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (i<=0) return E_INVALIDARG;

	if (!name) return E_INVALIDARG;
	ZeroMemory(&caps,sizeof(DMUS_PORTCAPS));
	caps.dwSize=sizeof(DMUS_PORTCAPS);
	hr=m_pDM->EnumPort(  (DWORD) i-1,   &caps );
	
	if (hr!=S_OK) return E_INVALIDARG;	//happens when we are out of bounds
										//manbug23240
	if FAILED(hr) return hr;			//for other resason ?

	*name=SysAllocString(caps.wszDescription);
	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getPortCount( 
		/* [retval][out] */ long __RPC_FAR *c)
{
	HRESULT hr=S_OK;	
	DMUS_PORTCAPS caps;
	DWORD i=0;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (!c) return E_INVALIDARG;
	while (hr==S_OK){
		caps.dwSize=sizeof(DMUS_PORTCAPS);
		hr=m_pDM->EnumPort(  i++,   &caps );
		if FAILED(hr) return hr;
	}
	*c=(long)i-1;
	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::getPortCaps( long i,
		/* [retval][out] */ DMUS_PORTCAPS_CDESC __RPC_FAR *c)
{
	HRESULT hr;		
	if (!c) return E_INVALIDARG;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (i<=0) return E_INVALIDARG;

	ZeroMemory(c,sizeof(DMUS_PORTCAPS));
	((DMUS_PORTCAPS*)c)->dwSize=sizeof(DMUS_PORTCAPS);
	hr=m_pDM->EnumPort(  (DWORD) i-1,   (DMUS_PORTCAPS*)c );
	if (hr==S_FALSE) return E_INVALIDARG;

	return hr;		
}

HRESULT C_dxj_DirectMusicPerformanceObject::setPort( 
		/* [in] */ long portid,
		/* [in] */ long number_of_groups)
{
	if (!m_pDM) return DMUS_E_NOT_INIT;

	HRESULT             hr;
    DMUS_PORTPARAMS     dmos;
	DMUS_PORTCAPS       caps;
	GUID				guidSink;

	
    // Initialize the performance. Have the performance create the
    // DirectMusic object by setting pDM to NULL. It is needed to
    // create the port.

	    // Create the port.
    ZeroMemory( &dmos, sizeof(DMUS_PORTPARAMS) );
    dmos.dwSize = sizeof(DMUS_PORTPARAMS);  
    dmos.dwChannelGroups = number_of_groups;
    dmos.dwEffectFlags = 0;
    dmos.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_EFFECTS;
	ZeroMemory(&caps,sizeof(DMUS_PORTCAPS));
	caps.dwSize=sizeof(DMUS_PORTCAPS);

	DWORD j=0;

	if (m_pPort){
		
		//j=m_pPort->AddRef();
		//j=m_pPort->Release();

		j=m_pPort->Release();
		hr= m__dxj_DirectMusicPerformance->RemovePort(m_pPort);
		
		
		
		if FAILED(hr) return hr;
	}


	if (portid<=0) {
		ZeroMemory( &guidSink, sizeof(GUID) );
	}
	else {
		hr=m_pDM->EnumPort(  (DWORD) portid-1,   &caps );
		if FAILED(hr) return hr;
		memcpy(&guidSink,&caps.guidPort,sizeof(GUID));
	}

	// Create the port
    hr = m_pDM->CreatePort( guidSink, &dmos, &m_pPort, NULL );
    if  FAILED(hr)  return hr;

	// Activate
    hr = m_pDM->Activate( TRUE );
    if  FAILED(hr)  return hr;

	//j=m_pPort->AddRef();
	//j=m_pPort->Release();

	// Add the port to the performance.

    // Succeeded in creating the port. Add the port to the
    // Performance with five groups of 16 midi channels.
    hr = m__dxj_DirectMusicPerformance->AddPort( m_pPort );
    if  FAILED(hr)  return hr;


	//j=m_pPort->AddRef();
	//j=m_pPort->Release();

	// Assign PChannel blocks for the number of groups we want.

	for( long i = 0; i < number_of_groups; i++ )
	{
		m__dxj_DirectMusicPerformance->AssignPChannelBlock( i, m_pPort, i+1 );
	}

	m_portid=portid;
	m_number_of_groups=number_of_groups;
	return S_OK;

}




















//DEAD CODE left here for reference
#if 0

	HRESULT C_dxj_DirectMusicPerformanceObject::addCommandParam( 
			/* [in] */ long trackIndex,
			/* [in] */ long mtTime,
			/* [in] */ Byte command,
			/* [in] */ Byte grooveLevel)
	{	
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;
		cmd.bCommand=(BYTE)command;
		cmd.bGrooveLevel=(BYTE)grooveLevel;
		cmd.bGrooveRange=0;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,&cmd);	
		return hr;
	}


	HRESULT C_dxj_DirectMusicPerformanceObject::addBandChange(  /* [in] */ long trackIndex, /* [in] */ long mtTime, /* [in] */ I_dxj_DirectMusicBand __RPC_FAR *band)
	{
		if (!band) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicBand*,pBand,band);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_IDirectMusicBand,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,pBand);	
		return hr;
	}
 
	HRESULT C_dxj_DirectMusicPerformanceObject::addTempoChange( 
			/* [in] */ long trackIndex,
			/* [in] */ long mtTime,
			/* [in] */  double tempo)
	{
		HRESULT hr;	
		DMUS_TEMPO_PARAM tmp;
		tmp.dblTempo=tempo;
		tmp.mtTime=(MUSIC_TIME)mtTime;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_TempoParam,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,&tmp);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::addTimeSigChange( /* [in] */ long trackIndex,/* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSignature)
	{
		HRESULT hr;	
		if (!timeSignature) return E_INVALIDARG;
		MUSIC_TIME mtTime=((DMUS_TIMESIGNATURE*)timeSignature)->mtTime;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_TimeSignature,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,(DMUS_TIMESIGNATURE*)timeSignature);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::setAutoDownloadEnable( /* [in] */ long trackIndex, /* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Disable_Auto_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Enable_Auto_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}

     
	HRESULT C_dxj_DirectMusicPerformanceObject::setTempoEnable( /* [in] */ long trackIndex,/* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_DisableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_EnableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}


	HRESULT C_dxj_DirectMusicPerformanceObject::setTimeSigEnable( /* [in] */ long trackIndex,/* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_DisableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_EnableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::clearAllBands ()
	{
		HRESULT hr;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Clear_All_Bands,0xFFFFFFFF,0,0,NULL);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::download(  /* [in] */ long trackIndex,    /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
	{
		if (!performance) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,pPerformance);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::unload( /* [in] */ long trackIndex,   /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
	{
		if (!performance) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Unload,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,pPerformance);	
		return hr;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmsegmentobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicSegmentObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicSegment IDirectMusicSegment*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicSegmentObject : 
	public I_dxj_DirectMusicSegment,
	//public CComCoClass<C_dxj_DirectMusicSegmentObject, &CLSID__dxj_DirectMusicSegment>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicSegmentObject();
	virtual ~C_dxj_DirectMusicSegmentObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicSegmentObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicSegment)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicSegment,		"DIRECT.DirectMusicSegment.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicSegmentObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

        HRESULT STDMETHODCALLTYPE clone( 
            /* [in] */ long mtStart,
            /* [in] */ long mtEnd,
            /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppSegment);
        
        HRESULT STDMETHODCALLTYPE setStartPoint( 
            /* [in] */ long mtStart);
        
        HRESULT STDMETHODCALLTYPE getStartPoint( 
            /* [retval][out] */ long __RPC_FAR *pmtStart);
        
        HRESULT STDMETHODCALLTYPE setLoopPoints( 
            /* [in] */ long mtStart,
            /* [in] */ long mtEnd);
        
        HRESULT STDMETHODCALLTYPE getLoopPointStart( 
            /* [retval][out] */ long __RPC_FAR *pmtStart);
        
        HRESULT STDMETHODCALLTYPE getLoopPointEnd( 
            /* [retval][out] */ long __RPC_FAR *pmtEnd);
        
        HRESULT STDMETHODCALLTYPE getLength( 
            /* [retval][out] */ long __RPC_FAR *pmtLength);
        
        HRESULT STDMETHODCALLTYPE setLength( 
            /* [in] */ long mtLength);
        
        HRESULT STDMETHODCALLTYPE getRepeats( 
            /* [retval][out] */ long __RPC_FAR *lRepeats);
        
        HRESULT STDMETHODCALLTYPE setRepeats( 
            /* [in] */ long lRepeats);
        
        
        HRESULT STDMETHODCALLTYPE download( 
            /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performace);
        
        HRESULT STDMETHODCALLTYPE unload( 
            /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performace);
        
        
        HRESULT STDMETHODCALLTYPE setAutoDownloadEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setTempoEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setTimeSigEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setStandardMidiFile();
        
        HRESULT STDMETHODCALLTYPE connectToCollection( 
            /* [in] */ I_dxj_DirectMusicCollection __RPC_FAR *c);
	
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicSegment);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicSegment)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dms.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dms.h
//
//--------------------------------------------------------------------------
 

//
// dms.h : david's funky stuff
//
// CLONETO, QIOVERLOAD: see d3drmVisualObj.cpp
//
//
//
#include "basetsd.h"
#include "dvp.h"

#ifdef DEBUG
 #define DPF(n,o)		{OutputDebugString(o);}
 #define DPF1(n,o,p)		{char szOutN[1024]; wsprintf(szOutN,o,p);OutputDebugString(szOutN);}
 #define DPF2(n,o,p,e)	{char szOutN[1024]; wsprintf(szOutN,o,p,e);OutputDebugString(szOutN);}
#else
 #define DPF(n,o)		
 #define DPF1(n,o,p)		
 #define DPF2(n,o,p,e)	
#endif

#define INTERNAL_CREATE_RETOBJ(objType,objOther,retval,classobj) \
{ 	C##objType##Object *prev=NULL; \
	*retval = NULL;	\
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
	{	IUnknown *unk=0; \
		ptr->InternalGetObject(&unk); \
		if(unk == objOther) \
		{ \
			*retval = (I##objType*)ptr->pinterface; \
			IUNK(ptr->pinterface)->AddRef(); \
			IUNK(objOther)->Release(); \
			classobj=ptr; \
			break; \
		} \
		prev = ptr; \
	} \
	if(!ptr) \
	{	C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
		c->parent = this; \
		((I##objType *)this)->AddRef();  \
		c->InternalSetObject(objOther); \
		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) \
			return E_FAIL; \
		c->pinterface = (void*)*retval; \
		classobj=c; \
} }



#define INTERNAL_CREATE_STRUCT(objType,retval) { C##objType##Object *c=new CComObject<C##objType##Object>;\
	if (c==NULL) return E_OUTOFMEMORY;\
	if (FAILED(((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL;\
	}


#define INTERNAL_CREATE_NOADDREF(objType,objOther,retval) {C##objType##Object *prev=NULL; *retval = NULL; \
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj){IUnknown *unk=0;ptr->InternalGetObject(&unk); 	if(unk == objOther) { 	*retval = (I##objType*)ptr->pinterface;	IUNK(ptr->pinterface)->AddRef(); IUNK(objOther)->Release(); break;	} 	prev = ptr; } \
	if(!ptr) { 	C##objType##Object *c=new CComObject<C##objType##Object>; if( c == NULL ) {	objOther->Release();return E_FAIL;}	c->InternalSetObject(objOther);  if FAILED(((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval)) 	return E_FAIL; c->pinterface = (void*)*retval; }}	
		
// Given a java interface (objtype), envoke InternalSetObject and set the given
// DIRECTX pointer (objOther). Also envoke QueryInterface and set a ** interface
// ptr to a DIRECTX object (retval). So we create a DIRECTX object.
//#define INTERNAL_CREATE(objType,objOther,retval){C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
//c->parent = this; AddRef(); c->InternalSetObject(objOther);if (FAILED(c->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; }
//			if (FAILED(ptr->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; 
#ifdef _DEBUG
#define INTERNAL_CREATE(objType,objOther,retval) \
{ \
	DWORD refcount; char buffer[256]; wsprintf(buffer,"INTERNAL_CREATE %s \n",__FILE__); \
	OutputDebugString(buffer); \
	C##objType##Object *prev=NULL; \
	*retval = NULL;	\
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
	{\
		IUnknown *unk=0; \
		ptr->InternalGetObject(&unk); \
		if(unk == objOther) \
		{ \
			*retval = (I##objType*)ptr->pinterface;\
			IUNK(ptr->pinterface)->AddRef();\
			IUNK(objOther)->Release(); \
			refcount = *(((DWORD*)ptr)+1); \
			wsprintf(buffer,"		Retrived Object [%s] RefCount %d \n\r",__FILE__, refcount);\
			OutputDebugString(buffer);\
			break; \
		} \
		prev = ptr; \
	} \
	if(!ptr) \
	{ \
		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
		c->parent = this; \
		((I##objType *)this)->AddRef(); \
		refcount = *(((DWORD*)this)+1); \
		wsprintf(buffer,"Object [%s] RefCount[%d]\n\r",__FILE__, refcount);\
		OutputDebugString(buffer);\
		c->InternalSetObject(objOther);if (FAILED((	((I##objType *)c))->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
		c->pinterface = (void*)*retval; \
	} \
}
#else
#define INTERNAL_CREATE(objType,objOther,retval) \
{ \
	C##objType##Object *prev=NULL; \
	*retval = NULL;	\
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
	{\
		IUnknown *unk=0; \
		ptr->InternalGetObject(&unk); \
		if(unk == objOther) \
		{ \
			*retval = (I##objType*)ptr->pinterface; \
			IUNK(ptr->pinterface)->AddRef(); \
			IUNK(objOther)->Release(); \
			break; \
		} \
		prev = ptr; \
	} \
	if(!ptr) \
	{ \
		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
		c->parent = this; \
		((I##objType *)this)->AddRef();  \
		c->InternalSetObject(objOther); \
		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
		c->pinterface = (void*)*retval; \
	} \
}
#endif



#define INTERNAL_CREATE_2REFS(objType,objParentType,objParent, objOther,retval) \
{	 \
	C##objType##Object *prev=NULL; \
	*retval = NULL;	\
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
	{\
		IUnknown *unk=0; \
		ptr->InternalGetObject(&unk); \
		if(unk == objOther) \
		{ \
			*retval = (I##objType*)ptr->pinterface; \
			IUNK(ptr->pinterface)->AddRef(); \
			IUNK(objOther)->Release(); \
			break; \
		} \
		prev = ptr; \
	} \
	if(!ptr) \
	{ \
		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
		c->parent = this; \
		c->parent2 = IUNK(objParent); \
		((I##objType *)this)->AddRef();  \
		((I##objParentType*)objParent)->AddRef();  \
		c->InternalSetObject(objOther); \
		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
		c->pinterface = (void*)*retval; \
	} \
}


#define INTERNAL_CREATE_1REFS(objType,objParentType,objParent, objOther,retval) \
{	 \
	C##objType##Object *prev=NULL; \
	*retval = NULL;	\
	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
	{\
		IUnknown *unk=0; \
		ptr->InternalGetObject(&unk); \
		if(unk == objOther) \
		{ \
			*retval = (I##objType*)ptr->pinterface; \
			IUNK(ptr->pinterface)->AddRef(); \
			IUNK(objOther)->Release(); \
			break; \
		} \
		prev = ptr; \
	} \
	if(!ptr) \
	{ \
		C##objType##Object *c=new CComObject<C##objType##Object>; \
        if( c == NULL ) \
        { objOther->Release(); return E_FAIL;} \
		c->parent = IUNK(objParent); \
		((I##objParentType*)objParent)->AddRef();  \
		c->InternalSetObject(objOther); \
		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
		c->pinterface = (void*)*retval; \
	} \
}


typedef struct FrameMoveCallback3
{
	FrameMoveCallback3  *next;
	FrameMoveCallback3  *prev;
	I_dxj_Direct3dRMFrameMoveCallback3 *c;
	IUnknown		*pUser;
	IUnknown		*pParent;
	IUnknown		*m_obj;
	int				m_stopflag;
} FrameMoveCallback3;


struct TextureCallback
{
	TextureCallback  *next;
	TextureCallback  *prev;
	I_dxj_Direct3dRMLoadTextureCallback3 *c;
	IUnknown		 *pUser;
	IUnknown		 *pParent;
	IUnknown		 *m_obj;
	int				 m_stopflag;
};


typedef struct TextureCallback3
{
	TextureCallback3  *next;
	TextureCallback3  *prev;
	I_dxj_Direct3dRMLoadTextureCallback3 *c;
	IUnknown		 *pUser;
	IUnknown		 *pParent;
	IUnknown		 *m_obj;
	int				 m_stopflag;
} TextureCallback3;

struct d3drmCallback		// used for AddDestroyCallback
{
	d3drmCallback   *next;
	d3drmCallback   *prev;
	I_dxj_Direct3dRMCallback  *c;
	IUnknown		*pUser;
	IUnknown	  *pParent;
	IUnknown			   *m_obj;
	int					    m_stopflag;
};

struct DestroyCallback	
{
	DestroyCallback   *next;
	DestroyCallback   *prev;
	I_dxj_Direct3dRMCallback  *c;
	IUnknown		*pUser;
	IUnknown		  *pParent;
	IUnknown			   *m_obj;
	int					    m_stopflag;
};

struct EnumerateObjectsCallback
{
	EnumerateObjectsCallback  *next;
	EnumerateObjectsCallback  *prev;
	I_dxj_Direct3dRMEnumerateObjectsCallback *c;
	IUnknown			  *pUser;
	IUnknown	  *pParent;
	IUnknown			   *m_obj;
	int					    m_stopflag;
};




struct GeneralCallback
{
	GeneralCallback  *next;
	GeneralCallback  *prev;
	IUnknown		 *c;
	IUnknown		 *pUser;
	IUnknown		 *pParent;
	IUnknown		 *m_obj;
	int				 m_stopflag;
};

typedef struct DeviceUpdateCallback3
{
	DeviceUpdateCallback3  *next;
	DeviceUpdateCallback3  *prev;
	I_dxj_Direct3dRMDeviceUpdateCallback3 *c;
	IUnknown				*pUser;
	IUnknown				*pParent;
	IUnknown				*m_obj;
	int						m_stopflag;
} DeviceUpdateCallback3;

struct LoadCallback
{
	LoadCallback  *next;
	LoadCallback  *prev;
	I_dxj_Direct3dRMLoadCallback *c;
	IUnknown	  *pUser;
	IUnknown	  *pParent;
	IUnknown	  *m_obj;
	int			  m_stopflag;
};




/////////////////////////////////////////////////////////////////////////
#define MAX_INTERNAL_STR_LEN	256

struct JavaString
{
	DWORD nBytes;
	WCHAR Item[MAX_INTERNAL_STR_LEN];
};

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// mod:dp helper macros for stuffing expanded unions in DirectX Structures

#define IUNK(o) ((IUnknown*)(void*)(o))
#define IS_NULLGUID(g) (\
	(g->data1==0) && \
	(g->data2==0) && \
	(g->data3==0) && \
	(g->data4[0]==0) && \
	(g->data4[1]==0) && \
	(g->data4[2]==0) && \
	(g->data4[3]==0) && \
	(g->data4[4]==0) && \
	(g->data4[5]==0) && \
	(g->data4[6]==0) && \
	(g->data4[7]==0) )

 	


extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2 *dOut,DDSURFACEDESC2 *d);
extern HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2 *dOut,DDSurfaceDesc2 *d);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *ddpfOut,DDPixelFormat *pf);
extern HRESULT CopyOutDDPixelFormat( DDPixelFormat *ddpfOut,DDPIXELFORMAT *pf);

/////////////////////////////////////////////////////////////////////////
#define JAVASTRING(item) {sizeof(item)*2-2, L##item}

#define PASS_THROUGH(cl,m) STDMETHODIMP C##cl##Object::m() { return m_##cl->m();}
#define PASS_THROUGH1(c,m,t1) STDMETHODIMP C##c##Object::m(t1 v1) { return m_##c->m(v1);}
#define PASS_THROUGH2(c,m,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2) { return m_##c->m(v1, v2);}
#define PASS_THROUGH3(c,m,t1,t2,t3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,t3 v3) { return m_##c->m(v1, v2,v3);}
#define PASS_THROUGH4(c,m,t1,t2,t3,t4) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4){return m_##c->m(v1, v2,v3,v4);}
#define PASS_THROUGH5(c,m,t1,t2,t3,t4,t5) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){return m_##c->m(v1, v2,v3,v4,v5);}
#define PASS_THROUGH6(c,m,t1,t2,t3,t4,t5,t6) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){return m_##c->m(v1, v2,v3,v4,v5,v6);}
#define PASS_THROUGH7(c,m,t1,t2,t3,t4,t5,t6,t7) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){return m_##c->m(v1, v2,v3,v4,v5,v6,v7);}
#define PASS_THROUGH8(c,m,t1,t2,t3,t4,t5,t6,t7,t8) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){return m_##c->m(v1,v2,v3,v4,v5,v6,v7,v8);}

#define PASS_THROUGH_CAST_1(c,m,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1) { return m_##c->m(tt1 v1);}
#define PASS_THROUGH_CAST_2(c,m,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2) { return m_##c->m(tt1 v1, tt2 v2);}
#define PASS_THROUGH_CAST_3(c,m,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,t3 v3) { return m_##c->m(tt1 v1,tt2 v2,tt3 v3);}
#define PASS_THROUGH_CAST_4(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4){return m_##c->m(tt1 v1, tt2 v2,tt3 v3,tt4 v4);}
#define PASS_THROUGH_CAST_5(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5);}
#define PASS_THROUGH_CAST_6(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6);}
#define PASS_THROUGH_CAST_7(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7);}
#define PASS_THROUGH_CAST_8(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7,t8,tt8) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7,tt8 v8);}

//mod:dp additions due to renaming 
#define PASS_THROUGH_R(c,m1,m2) STDMETHODIMP C##c##Object::m1() { if(m_##c==NULL)return E_FAIL; return m_##c->m2();}
#define PASS_THROUGH1_R(c,m1,m2,t1) STDMETHODIMP C##c##Object::m1(t1 v1) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1);}
#define PASS_THROUGH2_R(c,m1,m2,t1,t2) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2);}
#define PASS_THROUGH3_R(c,m1,m2,t1,t2,t3) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2,t3 v3) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3);}
#define PASS_THROUGH4_R(c,m1,m2,t1,t2,t3,t4) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4);}
#define PASS_THROUGH5_R(c,m1,m2,t1,t2,t3,t4,t5) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5);}
#define PASS_THROUGH6_R(c,m1,m2,t1,t2,t3,t4,t5,t6) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5,v6);}
#define PASS_THROUGH7_R(c,m1,m2,t1,t2,t3,t4,t5,t6,t7) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5,v6,v7);}
#define PASS_THROUGH8_R(c,m1,m2,t1,t2,t3,t4,t5,t6,t7,t8) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1,v2,v3,v4,v5,v6,v7,v8);}

#define PASS_THROUGH_CAST_1_R(c,m1,m2,t1,tt1) STDMETHODIMP C##c##Object::m1(t1 v1) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1);}
#define PASS_THROUGH_CAST_2_R(c,m1,m2,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1, tt2 v2);}
#define PASS_THROUGH_CAST_3_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2,t3 v3) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3);}
#define PASS_THROUGH_CAST_4_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1, tt2 v2,tt3 v3,tt4 v4);}
#define PASS_THROUGH_CAST_5_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5);}
#define PASS_THROUGH_CAST_6_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6);}
#define PASS_THROUGH_CAST_7_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7);}
#define PASS_THROUGH_CAST_8_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7,t8,tt8) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7,tt8 v8);}

#define COPY_OR_CLEAR(dest, src, si) {if(src) memcpy((void *)dest, (void *)src, si);else memset((void *)dest, si, 0);}
#define COPY(dest, src, si) memcpy((void *)dest, (void *)src, si)

// ??
#define DECLSET_OBJECT(ifacevar, var, typ) {if(var) var->Release();	var = (typ)ifacevar;}
#define DECLGET_OBJECT(ifacevar, var){*ifacevar = (IUnknown *)var;}


#define ISEQUAL(c) \
	STDMETHODIMP C##c##Object::isEqual(I##c *d, int *retval)\
					{	IUnknown *IU1;\
						IUnknown *IU2;\
						if (d == NULL)\
							return E_FAIL;	\
						this->InternalGetObject((IUnknown **)(&IU1)); \
						d->InternalGetObject((IUnknown **)(&IU2)); \
						if (IU1 == IU2) \
							*retval = TRUE; \
						else \
							*retval = FALSE; \
						return S_OK;}

#define DX3J_GLOBAL_LINKS( obj_type ) \
int creationid;\
void *parent; \
void *pinterface; \
void *nextobj; 

/*STDMETHOD(isEqual)(IUnknown *pobj, int *ret)*/; 

// Given a class (c)
#define GETSET_OBJECT(c) \
	STDMETHODIMP C##c##Object::InternalSetObject(IUnknown *l)\
					{DECLSET_OBJECT(l,m_##c,typedef_##c);return S_OK;} \
	STDMETHODIMP C##c##Object::InternalGetObject(IUnknown **l)\
					{DECLGET_OBJECT(l,m_##c);return S_OK;} 
	//ISEQUAL(c);

// Given a java interface, go get a pointer_to_a_pointer to a DIRECTX object
//pac DO_GETOBJECT_NOTNULL is too dangerous and is commented.  use DO_GETOBJECT_NOTNULL
//#define DO_GETOBJECT(t,v,i) t v;i->InternalGetObject((IUnknown **)(&v));
#define DO_GETOBJECT_NOTNULL(t,v,i) t v=NULL;if(i) i->InternalGetObject((IUnknown **)(&v));


//
extern int g_creationcount;


#ifdef _DEBUG

#define CONSTRUCTOR(c, o) C##c##Object::C##c##Object(){ \
	 m_##c = NULL; parent = NULL; pinterface = NULL; \
	 nextobj =  g##c##;\
	 creationid = ++g_creationcount;\
	 char buffer[256];\
	 wsprintf(buffer,"Constructor Creation Id [%d] %s",g_creationcount,__FILE__);\
	 OutputDebugString(buffer);\
	 g##c## = (void *)this; o }

#else
#define CONSTRUCTOR(c, o) C##c##Object::C##c##Object(){ \
     m_##c = NULL; parent = NULL; pinterface = NULL; \
     nextobj = (void*)g##c##; \
     creationid = ++g_creationcount; \
     g##c## = (void*)this; o}
#endif

#ifdef _DEBUG

#define DESTRUCTOR(c, o) C##c##Object::~C##c##Object(){o; \
	char buffer[256]; \
	wsprintf(buffer,"Destructor Id[%d] %s ",creationid,__FILE__); \
	OutputDebugString(buffer); 	C##c##Object *prev=NULL; \
	for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
	{\
		if(ptr == this) \
		{ \
			if(prev) \
				prev->nextobj = ptr->nextobj; \
			else \
				g##c## = (void*)ptr->nextobj; \
			break; \
		} \
		prev = ptr; \
	} \
	if(m_##c){ 	int count = IUNK(m_##c)->Release(); wsprintf(buffer,"DirectX %s Ref count [%d]",__FILE__,count); OutputDebugString(buffer); \
		if(count==0){ char szOut[512];wsprintf(szOut,"\n Real %s released \n",__FILE__); OutputDebugString(szOut); m_##c = NULL; } \
	} \
	if(parent) IUNK(parent)->Release(); \
}

#else
#define DESTRUCTOR(c, o) C##c##Object::~C##c##Object(){o; \
	C##c##Object *prev=NULL; \
	for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
	{\
		if(ptr == this) \
		{ \
			if(prev) \
				prev->nextobj = ptr->nextobj; \
			else \
				g##c## = (void*)ptr->nextobj; \
			break; \
		} \
		prev = ptr; \
	} \
	if(m_##c){ \
		if (IUNK(m_##c)->Release()==0) m_##c = NULL; \
	} \
	if(parent) IUNK(parent)->Release();\
}
#endif 



#define OBJCHECK(lable, c) { \
	char buffer[256];\
	if ( g##c ) \
	{\
		int count = 0; \
		C##c##Object *prev=NULL; \
		C##c##Object *ptr;\
		for(ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
		{\
			DWORD refcount = *(((DWORD*)ptr)+1);\
			wsprintf( buffer,"%s: Ref Count [%d] CreateId [%d]\n\r",lable,refcount,ptr->creationid);\
			OutputDebugString(buffer);\
			count++;\
		}\
		wsprintf(buffer,"%s: %d \n\r",lable,count);\
		OutputDebugString(buffer);\
	}\
}




#ifdef _DEBUG
#define CONSTRUCTOR_STRUCT(c, o) C##c##Object::C##c##Object(){  nextobj = g##c##;\
	 creationid = ++g_creationcount;\
	char buffer[256];\
	wsprintf(buffer,"Creation Id [%d]",g_creationcount);\
	OutputDebugString(buffer);\
	 g##c## = (void*)this;o}
#else
#define CONSTRUCTOR_STRUCT(c, o) C##c##Object::C##c##Object(){ \
 nextobj =(void*) g##c##; \
 creationid = ++g_creationcount; \
 g##c## = (void*)this; \
 o}
#endif




#define DESTRUCTOR_STRUCT(c, o) C##c##Object::~C##c##Object(){o; \
C##c##Object *prev=NULL; \
for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
{\
	if(ptr == this) \
	{ \
		if(prev) \
			prev->nextobj = ptr->nextobj; \
		else \
			g##c## = (void*)ptr->nextobj; \
		break; \
	} \
	prev = ptr; \
} \
}

#define CHECK_AND_RETURN_RMVIS(real,cover,f) {##real *lpReal=NULL;\
		if (S_OK==lp->QueryInterface(IID_##real, (void**) &lpReal)){\
	 	 I##cover *lpFake=NULL;\
		 INTERNAL_CREATE(cover, lpReal, (void**)&lpFake);\
		 if (!lpFake) {IUNK(lpFake)->Release(); return E_OUTOFMEMORY;}\
		 ((I##cover *)lpFake)->QueryInterface(IID_I_dxj_Direct3dRMVisual,(void**)f);\
		 ((I##cover *)lpFake)->Release();\
		 return S_OK;\
		}}	

// Given a java class (c), create a DIRECTX object and an interface ** ptr to it.
#define RETURN_NEW_ITEM(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST(c,m,oc, ty) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(ty &lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_NOREL(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE_NOREL(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM1(c,m,oc,t1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM2(c,m,oc,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(v1,v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_1(c,m,oc,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(tt1 v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_2(c,m,oc,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(tt1 v1,tt2 v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_3(c,m,oc,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2, t3 v3, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(tt1 v1,tt2 v2,tt3 v3,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

//mod:dp additions due to renaming 
// Given a java class (c), create a DIRECTX object and an interface ** ptr to it.
#define RETURN_NEW_ITEM_R(c,m,m2,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM1_R(c,m,m2,oc,t1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM2_R(c,m,m2,oc,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(v1,v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_R(c,m,m2,oc,ty) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(ty &lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_1_R(c,m,m2,oc,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(tt1 v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_2_R(c,m,m2,oc,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
	if( m_##c->m2(tt1 v1,tt2 v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}

#if 0 
#define RETURN_NEW_ITEM_NOREL(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE_NOREL(oc, lp, rv);\
	return S_OK;}

#define RETURN_NEW_ITEM_CAST_3(c,m,oc,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2, t3 v3, I##oc **rv){typedef_##oc lp;\
	if( m_##c->m(tt1 v1,tt2 v2,tt3 v3,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
	return S_OK;}
#endif

// Return a primitive value by reference.
#define GET_DIRECT(cl,met,t) STDMETHODIMP C##cl##Object::met(t *h){*h=(t)m_##cl->met();return S_OK;}
#define GET_DIRECT1(cl,met,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t *h){*h=(t)m_##cl->met(v1);return S_OK;}
#define GET_DIRECT2(cl,met,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t *h){*h=(t)m_##cl->met(v1,v2);return S_OK;}

#define GET_DIRECT_R(cl,met,met2,t) STDMETHODIMP C##cl##Object::met(t *h){*h=(t)m_##cl->met2();return S_OK;}
#define GET_DIRECT1_R(cl,met,met2,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t *h){*h=(t)m_##cl->met2(v1);return S_OK;}
#define GET_DIRECT2_R(cl,met,met2,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t *h){*h=(t)m_##cl->met2(v1,v2);return S_OK;}


// Return a pointer to a primitive value as a ** ptr.
#define GET_DIRECTPTR(cl,met,t) STDMETHODIMP C##cl##Object::met(t **h){*h=(struct t*)m_##cl->met();return S_OK;}
#define GET_DIRECTPTR1(cl,met,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t **h){*h=(struct t*)m_##cl->met(v1);return S_OK;}
#define GET_DIRECTPTR2(cl,met,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t **h){*h=(struct t*)m_##cl->met(v1,v2);return S_OK;}

//Do a DO_GETOBJECT_NOTNULL and then call a method on the object
#define DO_GETOBJECT_ANDUSEIT(cl,me,iface) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(lp); }

#define DO_GETOBJECT_ANDUSEIT_CAST(cl,me,iface, t1) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me((t1)lp); }

#define DO_GETOBJECT_ANDUSEIT1(cl,me,iface,t1) STDMETHODIMP C##cl##Object::me(t1 v1,I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(v1, lp); }

#define DO_GETOBJECT_ANDUSEIT2(cl,me,iface,t1,t2) STDMETHODIMP C##cl##Object::me(t1 v1,t2 v2,I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(v1, v2, lp); }

//mod:dp additions due to renaming 
//Do a DO_GETOBJECT_NOTNULL and then call a method on the object
#define DO_GETOBJECT_ANDUSEIT_R(cl,me, m2, iface) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(lp); }

#define DO_GETOBJECT_ANDUSEIT_CAST_R(cl,me, m2, iface, t1) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2((t1)lp); }

#define DO_GETOBJECT_ANDUSEIT1_R(cl,me, m2, iface,t1) STDMETHODIMP C##cl##Object::me(t1 v1,I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(v1, lp); }

#define DO_GETOBJECT_ANDUSEIT2_R(cl,me, m2, iface,t1,t2) STDMETHODIMP C##cl##Object::me(t1 v1,t2 v2,I##iface *vis) \
	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(v1, v2, lp); }


// Make a copy of an object!
//#define CLONE(cl) STDMETHODIMP C##cl##Object::Clone(Id3drmObject **retval){typedef_##cl lp;\
//	m_##cl->Clone(0,IID_I##cl,(void **)&lp);INTERNAL_CREATE(cl,lp,retval);return S_OK;}

//#define CLONE(cl) STDMETHODIMP C##cl##Object::Clone(I##cl **retval){typedef_##cl lp;\
//m_##cl->Clone(0,IID_I##cl,(void **)&lp);INTERNAL_CREATE(cl, lp, retval);	return S_OK;}

//#define CLONE_R(cl,c2) STDMETHODIMP C##cl##Object::clone(I##cl **retval){typedef_##cl lp;\
//m_##cl->Clone(0,IID_I##c2,(void **)&lp);INTERNAL_CREATE(cl, lp, retval);	return S_OK;}


#define CLONE_R(cl,c2) STDMETHODIMP C##cl##Object::clone(IUnknown **retval){typedef_##cl lp;\
m_##cl->Clone(0,IID_I##c2,(void **)&lp);INTERNAL_CREATE(cl, lp, (I##cl **)retval);	return S_OK;}


// ??
// Call the d3drmObject->GetName method
extern "C" HRESULT _GetName(IDirect3DRMObject *i, BSTR *Name, BOOL bName);

#define GETNAME(cl) STDMETHODIMP C##cl##Object::GetName(BSTR *n){return _GetName(m_##cl, n, TRUE);}
#define GETCLASSNAME(cl) STDMETHODIMP C##cl##Object::GetClassName(BSTR *n){return _GetName(m_##cl, n, FALSE);}

#define SETNAME(cl) STDMETHODIMP C##cl##Object::SetName(BSTR Name){	\
	USES_CONVERSION;\
	LPSTR str = W2T(Name); return m_##cl->SetName( str );}

#define GETNAME_R(cl) STDMETHODIMP C##cl##Object::getName(BSTR *n){return _GetName(m_##cl, n, TRUE);}
#define GETCLASSNAME_R(cl) STDMETHODIMP C##cl##Object::getClassName(BSTR *n){return _GetName(m_##cl, n, FALSE);}

#define SETNAME_R(cl) STDMETHODIMP C##cl##Object::setName(BSTR Name){	\
	USES_CONVERSION;\
	LPSTR str = W2T(Name); return m_##cl->SetName( str );}

extern "C" HRESULT _DeleteDestroyCallback(IDirect3DRMObject *iface, I_dxj_Direct3dRMCallback *oC,
										  IUnknown *args);
#define DELETEDESTROYCALLBACK(cl) STDMETHODIMP C##cl##Object::DeleteDestroyCallback( I_dxj_Direct3dRMCallback *oC, IUnknown *args) \
	{return _DeleteDestroyCallback(m_##cl, oC, args);}

#define DELETEDESTROYCALLBACK_R(cl) STDMETHODIMP C##cl##Object::deleteDestroyCallback( I_dxj_Direct3dRMCallback *oC, IUnknown *args) \
	{return _DeleteDestroyCallback(m_##cl, oC, args);}

extern "C" HRESULT _AddDestroyCallback(IDirect3DRMObject *iface, I_dxj_Direct3dRMCallback *oC,
										  IUnknown *args);
#define ADDDESTROYCALLBACK(cl) STDMETHODIMP C##cl##Object::AddDestroyCallback(I_dxj_Direct3dRMCallback *oC, IUnknown *args) \
	{return _AddDestroyCallback(m_##cl, oC, args);}

#define ADDDESTROYCALLBACK_R(cl) STDMETHODIMP C##cl##Object::addDestroyCallback(I_dxj_Direct3dRMCallback *oC, IUnknown *args) \
	{return _AddDestroyCallback(m_##cl, oC, args);}

#define CLONETO(clMe, cl, ifaceThat) STDMETHODIMP C##clMe##Object::Get##cl(I##cl **retval) \
{ typedef_##cl lp; if (m_##clMe->QueryInterface(ifaceThat, (void **) &lp) != S_OK) return S_FALSE; \
	INTERNAL_CREATE( cl, lp, retval); return S_OK; }

#define CLONETO_RX(clMe, cl, ifaceThat)										\
STDMETHODIMP C##clMe##Object::getDirect3dRM##cl(I_dxj_Direct3dRM##cl **retval)   \
{																			\
typedef__dxj_Direct3dRM##cl lp; 											\
if (m_##clMe->QueryInterface(ifaceThat, (void **) &lp) != S_OK)				\
	return S_FALSE;															\
INTERNAL_CREATE( _dxj_Direct3dRM##cl, lp, retval); 							\
return S_OK; 																\
}																  

#define ISSAFEARRAY1D(ppsa,count) ((*ppsa) &&  ( ((SAFEARRAY*)*ppsa)->cDims==1) && (((SAFEARRAY*)*ppsa)->rgsabound[0].cElements >= count))

/**********************************************************************************************/
extern "C" BOOL ParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader,
											BYTE **ppbWaveData,DWORD *pcbWaveSize);
extern "C" BOOL GetWaveResource(HMODULE hModule, LPCTSTR lpName,
			 WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pcbWaveSize);

extern "C" DWORD bppToddbd(int bpp);

extern "C" void UndoCallbackLink(GeneralCallback *e, GeneralCallback **h);

extern "C" void PassBackUnicode(LPSTR str, BSTR *Name, DWORD cnt);
extern "C" void ctojDSBufferDesc( LPDSBUFFERDESC lpdd,
									 DSBufferDesc *ddsb, WaveFormatex *wave);
extern "C" void jtocDSBufferDesc( LPDSBUFFERDESC lpdd,
									 DSBufferDesc *ddsb, WaveFormatex *wave);
extern "C" void ctojWaveFormatEx( LPWAVEFORMATEX lpdd, WaveFormatex *wave);
extern "C" void CopyFloats(D3DVALUE *mat1, D3DVALUE *mat2, DWORD count);

extern "C" void* CheckCallbackLink(void *current, void **head);
extern "C" void* AddCallbackLink(void **ptr2, I_dxj_Direct3dRMCallback *enumC, void *args);
extern "C" void* AddCallbackLinkRetVal(IUnknown *m_obj, void **ptr2, I_dxj_Direct3dRMCallback *enumC, void *args);
extern "C" void SetStopFlag(IUnknown *m_obj, void** ptr2);

extern "C" BOOL PASCAL myEnumSoundDriversCallback(GUID &SPGuid, LPSTR description, 
													LPSTR module, void *lpArg);

extern "C" void __cdecl myFrameMoveCallback( LPDIRECT3DRMFRAME lpf,
                           void *lpArg, D3DVALUE delta);

extern "C" void __cdecl myFrameMoveCallback2( LPDIRECT3DRMFRAME lpf,
                           void *lpArg, D3DVALUE delta);

extern "C" void __cdecl myFrameMoveCallback3( LPDIRECT3DRMFRAME3 lpf,
                            void *lpArg, D3DVALUE delta);

extern "C" HRESULT __cdecl myLoadTextureCallback(char *tex_name,
							void *lpArg,LPDIRECT3DRMTEXTURE * lpD3DRMTex);

extern "C" HRESULT __cdecl myLoadTextureCallback3(char *tex_name,
							void *lpArg,LPDIRECT3DRMTEXTURE3 * lpD3DRMTex);

extern "C" void __cdecl myAddUpdateCallback3(LPDIRECT3DRMDEVICE3 ref,
										void *lpArg, int rectCount, LPD3DRECT update);

extern "C" void __cdecl myEnumerateObjectsCallback( LPDIRECT3DRMOBJECT lpo,void *lpArg);

extern "C" int __cdecl myUserVisualCallback(LPDIRECT3DRMUSERVISUAL lpUV,void *lpArg,
		DWORD reason, LPDIRECT3DRMDEVICE lpD, LPDIRECT3DRMVIEWPORT lpV);

extern "C" BOOL PASCAL myEnumServiceProvidersCallback(LPGUID lpSPGuid,  LPWSTR lpFriendlyName, 
					DWORD dwMajorVersion,DWORD dwMinorVersion, void *lpArg);

extern "C" BOOL PASCAL myEnumPlayersCallback2(DPID dpid, 
						DWORD dwPlayerType, LPCDPNAME lpName,
						DWORD dwFlags, LPVOID lpContext);

extern "C" BOOL PASCAL myEnumSessionsCallback2(const DPSESSIONDESC2 *gameDesc,
						 	 DWORD *timeout, DWORD dwFlags, void *lpArg);

extern "C" BOOL PASCAL myEnumAddressCallback(LPGUID guidDataType, 
						DWORD dwDataSize, LPCVOID lpData,	LPVOID lpContext);

extern "C" BOOL PASCAL myEnumAddressTypesCallback(LPGUID guidDataType, 
										LPVOID lpContext, DWORD dwFlags);
extern "C" BOOL PASCAL myEnumLocalApplicationsCallback(LPCDPLAPPINFO lpAppInfo, 
										LPVOID lpContext, DWORD dwFlags);

extern "C" BOOL PASCAL myEnumConnectionsCallback(	LPCGUID lpguidSP,
		LPVOID lpConnection,	DWORD dwConnectionSize,	LPCDPNAME lpName,
		DWORD dwFlags,	LPVOID lpContext);


extern "C" HRESULT PASCAL myEnumSurfacesCallback(LPDIRECTDRAWSURFACE lpDDSurface,
						 LPDDSURFACEDESC lpDDSurfaceDesc,void *lpContext);

extern "C" HRESULT PASCAL myEnumModesCallback(LPDDSURFACEDESC lpDDSurfaceDesc,
														 void *lpContext);

extern "C" HRESULT myEnumOverlayZOrdersCallback(LPDIRECTDRAWSURFACE lpDDS,
														void *lpContext);

extern "C" HRESULT PASCAL myEnumDevicesCallback( LPGUID Guid, LPSTR DevDesc,
						LPSTR DevName, LPD3DDEVICEDESC lpD3DHWDevDesc,
							LPD3DDEVICEDESC lpD3DHELDevDesc, void *lpArg);

extern "C" void myd3dValidateCallback(void *lpArg, DWORD offset);

extern "C" HRESULT myEnumTextureFormatsCallback(
									 LPDDSURFACEDESC lpDdsd, void *lpArg);

extern "C" void __cdecl myAddDestroyCallback(LPDIRECT3DRMOBJECT lpObj,void *lpArg);

extern "C" void __cdecl myd3drmLoadCallback(LPDIRECT3DRMOBJECT lpo,
											  REFIID ObjectGuid, LPVOID lpArg);
extern "C" HRESULT WINAPI myEnumVideoCallback( LPDDVIDEOPORTCAPS lpDDVideoPortCaps,    LPVOID lpContext    );

extern "C" BOOL WINAPI myDirectDrawEnumCallback(  GUID FAR *lpGUID, LPSTR lpDriverDescription,  
			LPSTR lpDriverName, LPVOID lpContext );

extern "C" BOOL CALLBACK myEnumDeviceObjectsCallback(  LPCDIDEVICEOBJECTINSTANCE pI,    LPVOID lpArg ) ;
extern "C" BOOL CALLBACK myEnumCreatedEffectObjectsCallback(LPDIRECTINPUTEFFECT peff,    LPVOID lpArg );
extern "C" BOOL CALLBACK myEnumEffectsCallback(  LPCDIEFFECTINFO pdei,    LPVOID lpArg   );
extern "C" BOOL CALLBACK myEnumInputDevicesCallback(  LPDIDEVICEINSTANCE lpddi,    LPVOID pvRef   );

//////////////////////////////////////////////////////////////////////////

extern "C" TextureCallback				*TextureCallbacks;			//d3drmTexture3
extern "C" TextureCallback3				*TextureCallbacks3;			//d3drmTexture3
extern "C" FrameMoveCallback3			*FrameMoveCallbacks3;		//d3drmFrame3
extern "C" DeviceUpdateCallback3		*DeviceUpdateCallbacks3;
extern "C" EnumerateObjectsCallback		*EnumCallbacks;			
extern "C" LoadCallback					*LoadCallbacks;			
extern "C" DestroyCallback				*DestroyCallbacks;



extern HRESULT CopyInDDSuraceDesc2(DDSURFACEDESC2 *dOut,DDSurfaceDesc2 *d);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *pfOut, DDPixelFormat *pf);
extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2 *dOut,DDSURFACEDESC2 *d);
extern HRESULT CopyOutDDPixelFormat(DDPixelFormat *pfOut, DDPIXELFORMAT *pf);
extern HRESULT CreateCoverObject(LPDIRECT3DRMOBJECT lp, I_dxj_Direct3dRMObject** f);
extern HRESULT CreateCoverVisual(LPDIRECT3DRMOBJECT lp, I_dxj_Direct3dRMVisual** v);
/*
 **********************************************************************
 * INTERNAL_CREATE(thisClass, var, retval)
 *		thisClass	class we are working on
 *		var			variable created in routine to get DirectX object
 *		retval		return value back to java
 *
 * wrap a DirectX object in one of ours and shove it in the return value
 ***********************************************************************
 * INTERNAL_CREATE_NOREL(thisClass, var, retval)
 *		thisClass	class we are working on
 *		var			variable created in routine to get DirectX object
 *		retval		return value back to java
 *
 * wrap a DirectX object in one of ours and shove it in the return value
 * If the layer obejct fails, DONT release the DirectX object
 ***********************************************************************
 * DO_GETOBJECT_NOTNULL(type,var,iface)
 *		type		type of variable we are creating
 *		var			variable we are creating
 *		iface		layer iface where we are getting the object from
 *
 * declare and get a DirectX object from a layer object
 ***********************************************************************
 * DO_GETOBJECT_NOTNULL(type,var,iface)
 *		type		type of variable we are creating
 *		var			variable we are creating
 *		iface		layer iface where we are getting the object from
 *
 * same as DO_GETOBJECT_NOTNULL except that we check for iface==NULL before calling
 ***********************************************************************
 * PASS_THROUGH[x](class,method,[...])
 *		class		this class
 *		method		method to call
 *
 * pass call straight through
 ***********************************************************************
 * PASS_THROUGH_CAST_[x](class,method,[...])
 *		class		this class
 *		method		method to call
 *
 * pass call straight through, casting the parameters to allow the call to pass
 ***********************************************************************
 * RETURN_NEW_ITEM(thisClass,method,OtherClass)
 *		thisClass	class being worked on
 *		method		method working on
 *		otherClass	class whose object we want
 *
 * call DirectX method to get the DirectX object, then wrap it in one of our layer
 * objects
 ***********************************************************************
 * RETURN_NEW_ITEM[1,2](thisClass,method,OtherClass,type)
 *		thisClass	class being worked on
 *		method		method working on
 *		otherClass	class whose object we want
 *		type		type of parameter
 *
 * Same as RETURN_NEWITEM except that there is an extra parameter (or two) BEFORE the
 * returned one
 ***********************************************************************
 * RETURN_NEW_ITEM_CAST_[1,2](thisClass,method,OtherClass,type)
 *		thisClass	class being worked on
 *		method		method working on
 *		otherClass	class whose object we want
 *		type		type of parameter
 *
 * Same as RETURN_NEW_ITEM[1,2] except that there the extra parameter(s) are type cast
 ******************************************************************************
 * RETURN_NEW_ITEM_NOREL(thisClass,method,OtherClass)
 *		thisClass	class being worked on
 *		method		method working on
 *		otherClass	class whose object we want
 *
 * same as RETURN_NEW_ITEM except that calls INTERNAL_CREATE_NOTREL instead of
 * INTERNAL_CREATE
 ******************************************************************************
 * GET_DIRECT(cl,met,t)
 *		class		class being worked on
 *		method		method being worked on
 *		t			type of the variable being returned
 *
 * DirectX returns value directly (no HRESULT), we get the value from Direct and
 * then return S_OK. (see CddSurfaceObject::Restore, may need to be added).
 * Note: the value is passed back via a pointer to that value.
 ******************************************************************************
 * GET_DIRECT[1,2](cl,met,t,t1)
 *		class		class being worked on
 *		method		method being worked on
 *		t			type of the variable being returned
 *      t1			type of extra variable(s) BEFORE retval
 *
 * same as GET_DIRECT but there is another parameter (or two) BEFORE the returned one
 ****************************************************************************************
 * GET_DIRECTPTR(cl,met,t)
 *		class		class being worked on
 *		method		method being worked on
 *		t			type of the variable being returned
 *
 * DirectX returns a pointer to a value directly (no HRESULT), we get the value from
 * Direct and then return S_OK. In this case it is a pointer to a pointer.
 ***************************************************************************************
 * GET_DIRECTPTR[1,2](cl,met,t,t1)
 *		class		class being worked on
 *		method		method being worked on
 *		t			type of the variable being returned
 *      t1			type of extra variable(s) BEFORE retval
 *
 * same as GET_DIRECTPTR but there is a parameter (or two) BEFORE the one returned.
 ***************************************************************************************
 * DO_GETOBJECT_ANDUSEIT(cl,me,iface)
 *		class		class being worked on
 *		method		method being worked on
 *		iface		secondary interface we are interested in
 *
 * get an internal object from iface and use it in the method. we return from the method
 ***************************************************************************************
 * DO_GETOBJECT_ANDUSEIT_CAST(cl,me,iface,type)
 *		class		class being worked on
 *		method		method being worked on
 *		iface		secondary interface we are interested in
 *		type		type to cast to in the actual call.
 * get an internal object from iface and use it in the method. we return from the method
 ***************************************************************************************
 * DO_GETOBJECT_ANDUSEIT[1,2](cl,me,iface,ty)
 *		class		class being worked on
 *		method		method being worked on
 *		iface		secondary interface we are interested in
 *		type		type of parameter BEFORE 2nd object
 *
 * same as DO_GETOBJECT_ANDUSEIT except there is another parameter (or two) BEFORE
 * the object one
 ************************************************************************************
 * CLONE(cl)
 *		class		class to clone
 *
 * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
 ************************************************************************************
 * GETNAME(cl)
 *		class		class to retive name of
 * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
 ************************************************************************************
 * GETCLASSNAME(cl)
 *		class		class to retive name of
 * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
 ************************************************************************************
 * DELETEDESTROYCALLBACK(cl)
 *		class		class to retive name of
 * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
 ************************************************************************************
 * QIOVERLOAD(cl, ifaceThat, clThat)
 *		class		class being worked on
 *		iface		iface of DIRECT object.  Should really typedef_## this!
 *		clThat		object we are going to create
 *
 * this is really bright - overloading QI to get new objects
 ************************************************************************************
 * CLONETO(cl, clThat, ifaceThat)
 *		class		class being worked on
 *		iface		iface of DIRECT object.  Should really typedef_## this!
 *		clThat		object we are going to create
 *
 * this is really bright - overloading QI to get new objects
 ************************************************************************************
 */


extern void *g_dxj_DirectDraw7;
extern void *g_dxj_Direct3dTexture7;
extern void *g_dxj_DirectDrawSurface7;
extern void *g_dxj_Direct3dDevice7;
extern void *g_dxj_Direct3dVertexBuffer7;
extern void *g_dxj_Direct3d7;


extern void *g_dxj_DirectDrawSurface4;
extern void *g_dxj_Direct3dDevice3;
extern void *g_dxj_Direct3dLight;
extern void *g_dxj_Direct3dMaterial3;
extern void *g_dxj_Direct3dVertexBuffer;
extern void *g_dxj_Direct3d3;
extern void *g_dxj_Direct3dRMAnimation2;
extern void *g_dxj_Direct3dRMAnimationSet2;
extern void *g_dxj_Direct3dRMObjectArray;
extern void *g_dxj_Direct3dRMDeviceArray;
extern void *g_dxj_Direct3dRMDevice3;
extern void *g_dxj_Direct3dRMFaceArray;
extern void *g_dxj_Direct3dRMFace2;
extern void *g_dxj_Direct3dRMFrameArray;
extern void *g_dxj_Direct3dRMFrame3;
extern void *g_dxj_Direct3dRMLightArray;
extern void *g_dxj_Direct3dRMLight;
extern void *g_dxj_Direct3dRMMaterial2;
extern void *g_dxj_Direct3dRMMeshBuilder3;
extern void *g_dxj_Direct3dRMMesh;
extern void *g_dxj_Direct3dRMProgressiveMesh;
extern void *g_dxj_Direct3dRMObject;
extern void *g_dxj_Direct3dRMPickArray;
extern void *g_dxj_Direct3dRMPick2Array;
extern void *g_dxj_Direct3dRMShadow2;
extern void *g_dxj_Direct3dRMTexture3;
extern void *g_dxj_Direct3dRMUserVisual;
extern void *g_dxj_Direct3dRMViewportArray;
extern void *g_dxj_Direct3dRMVisualArray;
extern void *g_dxj_Direct3dRMVisual;
extern void *g_dxj_Direct3dRMClippedVisual;
extern void *g_dxj_Direct3dRMWinDevice;
extern void *g_dxj_Direct3dRMWrap;
extern void *g_dxj_Direct3dTexture2;
extern void *g_dxj_Direct3dViewport3;
extern void *g_dxj_DirectDrawClipper;
extern void *g_dxj_DirectDrawPalette;
extern void *g_dxj_DirectDraw4;
extern void *g_dxj_DDVideoPortContainer;
extern void *g_dxj_DirectDrawVideoPort;
extern void *g_dxj_DirectDrawColorControl;
extern void *g_dxj_DirectSound3dListener;
extern void *g_dxj_DirectSoundBuffer;
extern void *g_dxj_DirectSound3dBuffer;
extern void *g_dxj_DirectSound;
extern void *g_dxj_DirectSoundCapture;
extern void *g_dxj_DirectSoundCaptureBuffer;
extern void *g_dxj_DirectSoundNotify;
extern void *g_dxj_DirectPlay3;
extern void *g_dxj_DirectPlayLobby2;
extern void *g_dxj_Direct3dRM3;
extern void *g_dxj_Direct3dRMViewport2;
extern void *g_dxj_DirectInput;
extern void *g_dxj_DirectInputDevice;
extern void *g_dxj_DirectInputEffect;
extern void *g_dxj_DPAddress;
extern void *g_dxj_DPLConnection;
extern void *g_dxj_DirectDrawGammaControl;
extern void *g_dxj_DirectPlay4;
extern void *g_dxj_DirectPlayLobby3;


#define DXHEAPALLOC malloc
#define DXSTACKALLOC lalloc
#define DXHEAPFREE free
#define DXALLOCBSTR SysAllocString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmsegmentstateobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentstateobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmSegmentStateObj.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicSegmentState;
extern void *g_dxj_DirectMusicSegment;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicSegmentState, {});
DESTRUCTOR(_dxj_DirectMusicSegmentState, {});
GETSET_OBJECT(_dxj_DirectMusicSegmentState);


HRESULT C_dxj_DirectMusicSegmentStateObject::getRepeats( long __RPC_FAR *repeats)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetRepeats((DWORD*)repeats);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getSeek( long __RPC_FAR *seek)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetSeek(seek);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getStartPoint( long __RPC_FAR *t)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetStartPoint(t);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getStartTime( long __RPC_FAR *t)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetStartTime(t);
	return hr;
}




HRESULT CREATE_DMSEGMENT_NOADDREF(IDirectMusicSegment *pSeg,I_dxj_DirectMusicSegment **segment) 
{
	C_dxj_DirectMusicSegmentObject *prev=NULL;
	*segment = NULL; 
	for(	
		C_dxj_DirectMusicSegmentObject 
			*ptr=(C_dxj_DirectMusicSegmentObject *)g_dxj_DirectMusicSegment;
			ptr;
			ptr=(C_dxj_DirectMusicSegmentObject *)ptr->nextobj
		)
	{
		IUnknown *unk=0;
		ptr->InternalGetObject(&unk); 
		if(unk == pSeg) 
		{ 
			*segment = (I_dxj_DirectMusicSegment*)ptr->pinterface;
			IUNK(ptr->pinterface)->AddRef();
			break;
		}
		prev = ptr;
	} 
	if(!ptr) 
	{
		C_dxj_DirectMusicSegmentObject *c=new CComObject<C_dxj_DirectMusicSegmentObject>;
		if( c == NULL ) 
		{
			pSeg->Release();
			return E_FAIL;
		}
		c->InternalSetObject(pSeg);  
		if FAILED(((I_dxj_DirectMusicSegment *)c)->QueryInterface(IID_I_dxj_DirectMusicSegment, (void **)segment)) 
		{
			return E_FAIL; 
		}
		if (!(*segment)) return E_FAIL;

		c->pinterface = (void*)*segment;
	}	
	return S_OK;
}



HRESULT C_dxj_DirectMusicSegmentStateObject::getSegment( 		
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *segment)
{
	HRESULT hr;	
	IDirectMusicSegment *pSeg=NULL;
	if(!segment) return E_INVALIDARG;

	hr=m__dxj_DirectMusicSegmentState->GetSegment(&pSeg);
	if FAILED(hr) return hr;	
	
		
	//INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,segment);
	hr= CREATE_DMSEGMENT_NOADDREF(pSeg,segment);
	if FAILED(hr) return hr;

	if (*segment==NULL) return E_OUTOFMEMORY;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmsegmentobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentobj.cpp
//
//--------------------------------------------------------------------------

// dmSegmentObj.cpp

#include "stdafx.h"
#include "Direct.h"
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "dms.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicSegment;

//CONSTRUCTOR(_dxj_DirectMusicSegment, {});

C_dxj_DirectMusicSegmentObject::C_dxj_DirectMusicSegmentObject()
{ 
     m__dxj_DirectMusicSegment = NULL;
	 parent = NULL; 
	 pinterface = NULL; 
     nextobj = (void*)g_dxj_DirectMusicSegment; 
     creationid = ++g_creationcount; 
     g_dxj_DirectMusicSegment = (void*)this; 

}

DESTRUCTOR(_dxj_DirectMusicSegment, {});
GETSET_OBJECT(_dxj_DirectMusicSegment);


HRESULT C_dxj_DirectMusicSegmentObject::clone( 
        /* [in] */ long mtStart,
        /* [in] */ long mtEnd,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppSegment)
{
	HRESULT hr;	
	IDirectMusicSegment *pOut=NULL;    
	hr=m__dxj_DirectMusicSegment->Clone((MUSIC_TIME)mtStart,(MUSIC_TIME)mtEnd,&pOut);	
	if FAILED(hr) return hr;
	if (!pOut)return E_OUTOFMEMORY;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pOut,ppSegment);
	if (!*ppSegment)return E_OUTOFMEMORY;
	return hr;

}


HRESULT C_dxj_DirectMusicSegmentObject::setStartPoint(   /* [in] */ long mtStart)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegment->SetStartPoint((MUSIC_TIME)mtStart);	
	return hr;
}


HRESULT C_dxj_DirectMusicSegmentObject::getStartPoint(   /* [in] */ long *mtStart)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicSegment->GetStartPoint((MUSIC_TIME*)mtStart);	
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setLoopPoints(   /* [in] */ long mtStart,   /* [in] */ long mtEnd)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegment->SetLoopPoints((MUSIC_TIME)mtStart,(MUSIC_TIME)mtEnd);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLoopPointStart(   long *mtOut)
{
	HRESULT hr;		
	MUSIC_TIME mtStart =0;
	MUSIC_TIME mtEnd =0;	
	hr=m__dxj_DirectMusicSegment->GetLoopPoints((MUSIC_TIME*)&mtStart,(MUSIC_TIME*)&mtEnd);
	*mtOut=(long)mtStart;
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLoopPointEnd(   long *mtOut)
{
	HRESULT hr;		
	MUSIC_TIME mtStart =0;
	MUSIC_TIME mtEnd =0;	
	hr=m__dxj_DirectMusicSegment->GetLoopPoints((MUSIC_TIME*)&mtStart,(MUSIC_TIME*)&mtEnd);
	*mtOut=(long)mtEnd;
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setLength(   /* [in] */ long mtLength)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicSegment->SetLength((MUSIC_TIME)mtLength);	
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLength(   /* [in] */ long *mtLength)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicSegment->GetLength((MUSIC_TIME*)mtLength);	
	return hr;
}
   


HRESULT C_dxj_DirectMusicSegmentObject::setRepeats(   /* [in] */ long lrep)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicSegment->SetRepeats((DWORD)lrep);	
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getRepeats(   /* [in] */ long *lrep)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicSegment->GetRepeats((DWORD*)lrep);	
	return hr;
}
     




HRESULT C_dxj_DirectMusicSegmentObject::download( 
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
{
	if (!performance) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
	HRESULT hr;	
	hr=m__dxj_DirectMusicSegment->SetParam(GUID_Download,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,pPerformance);	
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::unload(         
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
{
	if (!performance) return E_INVALIDARG;	
	DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
	HRESULT hr;	
	hr=m__dxj_DirectMusicSegment->SetParam(GUID_Unload,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,pPerformance);	
	return hr;
}



HRESULT C_dxj_DirectMusicSegmentObject::setAutoDownloadEnable(         
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	if (b==VARIANT_FALSE){
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_Disable_Auto_Download,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
	}
	else {
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_Enable_Auto_Download,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
	}		
	return hr;
}

     
HRESULT C_dxj_DirectMusicSegmentObject::setTempoEnable( 
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	DWORD trackIndex=0;

	if (b==VARIANT_FALSE){
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_DisableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
	}
	else {
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_EnableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
	}		
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setTimeSigEnable(         
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	DWORD trackIndex=0;
	if (b==VARIANT_FALSE){
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_DisableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
	}
	else {
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_EnableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
	}		
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setStandardMidiFile()
{
	HRESULT hr;	
	hr=m__dxj_DirectMusicSegment->SetParam(GUID_StandardMIDIFile,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
	return hr;
}
     

HRESULT C_dxj_DirectMusicSegmentObject:: connectToCollection( 
            /* [in] */ I_dxj_DirectMusicCollection __RPC_FAR *c)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(IDirectMusicCollection*,pCol,c);
	hr=m__dxj_DirectMusicSegment->SetParam(GUID_ConnectToDLSCollection,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,(void*)pCol);	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmsegmentstateobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentstateobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicSegmentStateObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicSegmentState IDirectMusicSegmentState*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicSegmentStateObject : 
	public I_dxj_DirectMusicSegmentState,
	//public CComCoClass<C_dxj_DirectMusicSegmentStateObject, &CLSID__dxj_DirectMusicSegmentState>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicSegmentStateObject();
	virtual ~C_dxj_DirectMusicSegmentStateObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicSegmentStateObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicSegmentState)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicSegmentState,		"DIRECT.DirectMusicSegmentState.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicSegmentStateObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	HRESULT STDMETHODCALLTYPE getRepeats( 
		/* [retval][out] */ long __RPC_FAR *repeats);

	HRESULT STDMETHODCALLTYPE getSeek( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getStartPoint( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getStartTime( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *segment);

	
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicSegmentState);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicSegmentState)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmstyleobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmstyleobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmBandObj.h"

extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;
extern void *g_dxj_DirectMusicBand;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicStyle, {});
DESTRUCTOR(_dxj_DirectMusicStyle, {});
GETSET_OBJECT(_dxj_DirectMusicStyle);

typedef IDirectMusicSegment*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance*	LPDIRECTMUSICPERFORMANCE;
typedef IDirectMusicChordMap*		LPDIRECTMUSICCHORDMAP;
typedef IDirectMusicStyle*			LPDIRECTMUSICSTYLE;

HRESULT C_dxj_DirectMusicStyleObject:: getBandName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{  
	HRESULT hr;			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumBand((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getBandCount( long *count)        
{    			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumBand((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getBand( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicBand *pBand=NULL;

	hr=m__dxj_DirectMusicStyle->GetBand(name,&pBand);
	if FAILED(hr) return hr;
	if (!pBand) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pBand,ret);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject::getDefaultBand( 
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicBand *pBand=NULL;
	*ret=NULL;
	hr=m__dxj_DirectMusicStyle->GetDefaultBand(&pBand);
	if FAILED(hr) return hr;
	if (hr==S_FALSE) return S_OK;
	if (!pBand) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pBand,ret);
	return hr;
}

    
HRESULT C_dxj_DirectMusicStyleObject:: getMotifName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{    
	HRESULT hr;
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumMotif((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getMotifCount( long *count)        
{    			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumMotif((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getMotif( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicSegment *pSeg=NULL;

	hr=m__dxj_DirectMusicStyle->GetMotif(name,&pSeg);
	if FAILED(hr) return hr;
	if (!pSeg) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,ret);
	return hr;
}



HRESULT C_dxj_DirectMusicStyleObject:: getChordMapName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{    	
	HRESULT hr;
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumChordMap((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getChordMapCount( long *count)        
{ 
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumChordMap((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getChordMap( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicChordMap	*pMap=NULL;

	hr=m__dxj_DirectMusicStyle->GetChordMap(name,&pMap);
	if FAILED(hr) return hr;
	if (!pMap) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getDefaultChordMap( 
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicChordMap	*pMap=NULL;
	*ret=NULL;
	hr=m__dxj_DirectMusicStyle->GetDefaultChordMap(&pMap);
	if (hr==S_FALSE) return S_OK;

	if FAILED(hr) return hr;
	if (!pMap) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
	return hr;
}


HRESULT C_dxj_DirectMusicStyleObject:: getEmbellishmentMinLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;			
	DWORD dwMin=0;
	DWORD dwMax=0;

	hr=m__dxj_DirectMusicStyle->GetEmbellishmentLength((DWORD)type,(DWORD)level,&dwMin,&dwMax);
	*ret=(long)dwMin;
	return hr;
}
		
HRESULT C_dxj_DirectMusicStyleObject:: getEmbellishmentMaxLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;			
	DWORD dwMin=0;
	DWORD dwMax=0;

	hr=m__dxj_DirectMusicStyle->GetEmbellishmentLength((DWORD)type,(DWORD)level,&dwMin,&dwMax);	
	*ret=(long)dwMax;
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject::getTempo( 
        /* [retval][out] */ double __RPC_FAR *ret)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicStyle->GetTempo(ret);	
	return hr;
}

		

HRESULT C_dxj_DirectMusicStyleObject::getTimeSignature( 
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *pTimeSig)
{
	HRESULT hr;				
	if (!pTimeSig) return E_INVALIDARG;
	hr=m__dxj_DirectMusicStyle->GetTimeSignature((DMUS_TIMESIGNATURE*)pTimeSig);	
	return hr;
}
// GetDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpaddressobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpaddressobj.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPAddressObj.h"


CONSTRUCTOR_STRUCT(_dxj_DPAddress, {init();})
DESTRUCTOR_STRUCT(_dxj_DPAddress, {cleanUp();})


void C_dxj_DPAddressObject::init() {
	m_pAddress=NULL;	
	m_size=0;
}
void C_dxj_DPAddressObject::cleanUp() {
	//DPF(DPF_VERRBOSE,"_dxj_DPAddress object being destroyed");
	if (m_pAddress) free (m_pAddress);
	m_size=0;
}



HRESULT C_dxj_DPAddressObject::setAddress( 
            /* [in] */ long pAddress,
            /* [in] */ long length) {

	if (m_pAddress) free (m_pAddress);
	m_pAddress=NULL;
	m_pAddress=malloc((DWORD)length);
	if (m_pAddress==NULL) return E_OUTOFMEMORY;

	if (pAddress==NULL) return E_FAIL;	
	memcpy((void*)m_pAddress,(void*)pAddress,length);
	m_size=(DWORD)length; 

	return S_OK;

 }
        
HRESULT C_dxj_DPAddressObject::getAddress( 
            /* [out] */ long  *pAddress,
            /* [out] */ long  *length) {

	*pAddress=(long)PtrToLong(m_pAddress);	//bugbug SUNDOWN- sundown wont be able to do this
					//will need to implement new non VB interface to get at this functionality internally
	*length=(long)m_size;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dmstyleobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmstyleobj.h
//
//--------------------------------------------------------------------------

//: Declaration of the C_dxj_DirectMusicStyleObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicStyle IDirectMusicStyle*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicStyleObject : 
	public I_dxj_DirectMusicStyle,
	//public CComCoClass<C_dxj_DirectMusicStyleObject, &CLSID__dxj_DirectMusicStyle>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicStyleObject();
	virtual ~C_dxj_DirectMusicStyleObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicStyleObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicStyle)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicStyle,		"DIRECT.DirectMusicStyle.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicStyleObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

  
          
    HRESULT STDMETHODCALLTYPE getBandName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getBandCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getBand( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getDefaultBand( 
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getMotifName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getMotifCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getMotif( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getChordMapName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getChordMapCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getChordMap( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getDefaultChordMap( 
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getEmbellishmentMinLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getEmbellishmentMaxLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getTimeSignature( 
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *pTimeSig);
    
    HRESULT STDMETHODCALLTYPE getTempo( 
        /* [retval][out] */ double __RPC_FAR *pTempo);
  

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicStyle);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicStyle)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpaddressobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpaddressobj.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_dxj_DPAddressObject :
		public I_dxj_DPAddress,
//		public CComCoClass<C_dxj_DPAddressObject, &CLSID_DPAddress>,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DPAddressObject)
		COM_INTERFACE_ENTRY(I_dxj_DPAddress)
	END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__DPAddress, "DIRECT.DPAddress.5",		"DIRECT.DPAddress.5",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)
	DECLARE_AGGREGATABLE(C_dxj_DPAddressObject)

public:
	C_dxj_DPAddressObject();
	~C_dxj_DPAddressObject();

   HRESULT STDMETHODCALLTYPE setAddress( 
            /* [in] */ long pAddress,
            /* [in] */ long length) ;
        
   HRESULT STDMETHODCALLTYPE getAddress( 
            /* [out] */ long  *pAddress,
            /* [out] */ long  *length) ;
                
private:
	void    *m_pAddress;
	DWORD 	m_size;
	void    *nextobj;
	int		creationid;
	void cleanUp();
	void init();
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumaddressobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dpenumaddressobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

#define DPENUMGROUPSINGROUP 1
#define DPEnumAddress 2	
#define DPENUMGROUPPLAYERS 3
#define DPENUMGROUPS 4


class C_dxj_DPEnumAddressObject : 
	public I_dxj_DPEnumAddress,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumAddressObject() ;
	virtual ~C_dxj_DPEnumAddressObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumAddressObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumAddress)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumAddressObject)

public:
	    HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
        
        HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *str);
        
        HRESULT STDMETHODCALLTYPE getData( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *str);
        
        				
		static HRESULT C_dxj_DPEnumAddressObject::create(IDirectPlayLobby3 * pdp, I_dxj_DPAddress *addr, I_dxj_DPEnumAddress **ret);
		
		void cleanup();	


public:
		
		I_dxj_DPAddress **m_pList;
		GUID		 *m_pList2;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumconnectionsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumconnectionsobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPEnumConnectionsObj.h"
#include "DPAddressObj.h"

extern  BSTR DPLGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DPLBSTRtoPPGUID(LPGUID *,BSTR);


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL FAR PASCAL myEnumConnectionsCallback(
	LPCGUID lpguidSP,
	LPVOID lpConnection,
	DWORD dwConnectionSize,
	LPCDPNAME lpName,
	DWORD dwFlags,
	LPVOID lpArg
	){

	
	DPF(1,"Entered objEnumConnectionsCallback\r\n");

	
	C_dxj_DPEnumConnectionsObject *pObj=(C_dxj_DPEnumConnectionsObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList)
			pObj->m_pList=(DPConnection*)realloc(pObj->m_pList,sizeof(DPConnection)* pObj->m_nMax);
		else
			pObj->m_pList=(DPConnection*)malloc(sizeof(DPConnection)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}

		if (pObj->m_pList2)
			pObj->m_pList2=(I_dxj_DPAddress**)realloc(pObj->m_pList,sizeof(void*) * pObj->m_nMax);
		else
			pObj->m_pList2=(I_dxj_DPAddress**)malloc(sizeof(void*) * pObj->m_nMax);

		if (pObj->m_pList2==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}

	}
	
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DPConnection));
	
	pObj->m_pList2[pObj->m_nCount]=NULL;


	I_dxj_DPAddress *address=NULL;
	
	if (lpName->lpszShortName)
		pObj->m_pList[pObj->m_nCount].strShortName = SysAllocString(lpName->lpszShortName);
	if (lpName->lpszLongName)
		pObj->m_pList[pObj->m_nCount].strLongName = SysAllocString(lpName->lpszLongName);
	if (lpguidSP)
		pObj->m_pList[pObj->m_nCount].strGuid = DPLGUIDtoBSTR((LPGUID)lpguidSP);
	
	pObj->m_pList[pObj->m_nCount].lFlags=(DWORD)dwFlags;

	//internal create does the addref.
	#pragma message ("make sure InternalCreate does addref")

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&address));		
	pObj->m_pList2[pObj->m_nCount]=address;

	if (address) address->setAddress((long)PtrToLong(lpConnection),(long)dwConnectionSize);	//bugbug SUNDOWN	
	pObj->m_nCount++;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

C_dxj_DPEnumConnectionsObject::C_dxj_DPEnumConnectionsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_pList2=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DPEnumConnectionsObject::~C_dxj_DPEnumConnectionsObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			DPConnection *conn=&(m_pList[i]);
			if (conn->strShortName ) SysFreeString(conn->strShortName);
			if (conn->strLongName) SysFreeString(conn->strLongName);			
			if (conn->strGuid) SysFreeString(conn->strGuid);			
		}
		free(m_pList);
	}
	if (m_pList2){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList2[i]) m_pList2[i]->Release();
		}
		free(m_pList2);
	}

}

HRESULT C_dxj_DPEnumConnectionsObject::create(
		IDirectPlay3 * pdp,
		BSTR strGuid,
		long flags, I_dxj_DPEnumConnections **ppRet)
{
	HRESULT hr;
	C_dxj_DPEnumConnectionsObject *pNew=NULL;
	GUID g;
	LPGUID pguid=&g;

	hr=DPLBSTRtoPPGUID(&pguid,strGuid);
	if FAILED(hr) return hr;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DPEnumConnectionsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	hr = pdp->EnumConnections(pguid,
						myEnumConnectionsCallback,
						pNew, (long)flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;


	#pragma message ("make sure free on failure cleans up in enumerators on STrings and objects")
	if FAILED(hr) 
	{
		//free(pNew->m_pList);
		//pNew->m_pList=NULL;
		//destructor will clean up properly
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DPEnumConnections,(void**)ppRet);
	return hr;
}

/* DEAD CODE
HRESULT C_dxj_DPEnumConnectionsObject::getItem( long index, DPConnection *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	if (!info) return E_INVALIDARG;

	if (info->strGuid) SysFreeString(info->strGuid);
	if (info->strShortName) SysFreeString(info->strShortName);
	if (info->strLongName) SysFreeString(info->strLongName);

	info->strGuid=SysAllocString(m_pList[index].strGuid);
	info->strShortName=SysAllocString(m_pList[index].strShortName);
	info->strLongName=SysAllocString(m_pList[index].strLongName);
	info->lFlags=m_pList[index].lFlags;
			


	return S_OK;
}
*/

HRESULT C_dxj_DPEnumConnectionsObject::getFlags( long index, long  *retV)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*retV=m_pList[index-1].lFlags;
	return S_OK;
}
 
HRESULT C_dxj_DPEnumConnectionsObject::getGuid( long index, BSTR  *retV)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*retV=SysAllocString(m_pList[index-1].strGuid);
	return S_OK;
}       

HRESULT C_dxj_DPEnumConnectionsObject::getName( long index, BSTR  *retV)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*retV=SysAllocString(m_pList[index-1].strShortName);
	return S_OK;
}       

/*        
HRESULT C_dxj_DPEnumConnectionsObject::getLongName( long index, BSTR  *retV)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*retV=SysAllocString(m_pList[index-1].strLongName);
	return S_OK;
}       
*/
HRESULT C_dxj_DPEnumConnectionsObject::getAddress(long index,I_dxj_DPAddress **ppret){
	if (m_pList2==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (m_pList2[index-1]==NULL) return E_FAIL;
	HRESULT hr=m_pList2[index-1]->QueryInterface(IID_I_dxj_DPAddress,(void**)ppret);
	return hr;
}

HRESULT C_dxj_DPEnumConnectionsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumaddresstypesobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dpenumaddresstypesobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       



class C_dxj_DPEnumAddressTypesObject : 
	public I_dxj_DPEnumAddressTypes,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumAddressTypesObject() ;
	virtual ~C_dxj_DPEnumAddressTypesObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumAddressTypesObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumAddressTypes)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumAddressTypesObject)

public:
	    HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
        
        HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *str);
        
		static HRESULT C_dxj_DPEnumAddressTypesObject::create(IDirectPlayLobby3 * pdp, BSTR strGuid, I_dxj_DPEnumAddressTypes **ret);
		void cleanup();	


public:
		
		GUID		 *m_pList2;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumconnectionsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumconnectionsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       



class C_dxj_DPEnumConnectionsObject : 
	public I_dxj_DPEnumConnections,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumConnectionsObject() ;
	virtual ~C_dxj_DPEnumConnectionsObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumConnectionsObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumConnections)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumConnectionsObject)

public:
	    HRESULT STDMETHODCALLTYPE getAddress( 
            /* [in] */ long index,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *retV);
        
        HRESULT STDMETHODCALLTYPE getFlags( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *retV);
        
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retV);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retV);
        
        //HRESULT STDMETHODCALLTYPE getLongName( 
        //    /* [in] */ long index,
        //    /* [retval][out] */ BSTR __RPC_FAR *retV);
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);

	
		
		static HRESULT C_dxj_DPEnumConnectionsObject::create(IDirectPlay3 * pdp, BSTR guid, long flags, I_dxj_DPEnumConnections **ppRet);

public:
		DPConnection	*m_pList;
		I_dxj_DPAddress **m_pList2;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumaddresstypesobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dpenumaddresstypesobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPEnumAddressTypesObj.h"
#include "DPAddressObj.h"

extern BSTR DPLGUIDtoBSTR(LPGUID pGuid);
extern HRESULT BSTRtoDPLGUID(LPGUID pGuid,BSTR str);

/////////////////////////////////////////////////////////////////////////////
// The callback is invoked as a result of IDirectPlay2::EnumPlayers(), 
// IDirectPlay2::EnumGroups() and IDirectPlay2::EnumGroupPlayers() calls.
/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL FAR PASCAL EnumAddressTypesCallback(  REFGUID guidDataType,  LPVOID lpArg , DWORD flags )

{

	C_dxj_DPEnumAddressTypesObject *pObj=(C_dxj_DPEnumAddressTypesObject*)lpArg;

	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;


		if (pObj->m_pList2)
			pObj->m_pList2=(GUID*)realloc(pObj->m_pList2,sizeof(GUID) * pObj->m_nMax);
		else
			pObj->m_pList2=(GUID*)malloc(sizeof(I_dxj_DPAddress*)* pObj->m_nMax);

		
		
		if  (pObj->m_pList2==NULL)
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}



	ZeroMemory(&(pObj->m_pList2[pObj->m_nCount]), sizeof(GUID));
	
	//memcpy(&(pObj->m_pList2[pObj->m_nCount]), guidDataType,sizeof(GUID));
	pObj->m_pList2[pObj->m_nCount]= guidDataType;

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DPEnumAddressTypesObject::C_dxj_DPEnumAddressTypesObject()
{	
	m_nMax=0;
	m_pList2=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DPEnumAddressTypesObject::~C_dxj_DPEnumAddressTypesObject()
{
	//cleanup();
	if (m_pList2) free(m_pList2);
}

void C_dxj_DPEnumAddressTypesObject::cleanup()
{
	if (m_pList2) free(m_pList2);

}


HRESULT C_dxj_DPEnumAddressTypesObject::create(IDirectPlayLobby3 * pdp, BSTR strGuid, I_dxj_DPEnumAddressTypes **ret)
{
	HRESULT hr;
	
	GUID spGuid;
	hr=BSTRtoDPLGUID(&spGuid,strGuid);
	if FAILED(hr) return hr;

	C_dxj_DPEnumAddressTypesObject	*pNew=NULL;

	
	
	if (!strGuid) return E_INVALIDARG;
	if (!ret) return E_INVALIDARG;

	*ret=NULL;

	

	pNew= new CComObject<C_dxj_DPEnumAddressTypesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pdp->EnumAddressTypes( EnumAddressTypesCallback, spGuid, pNew,0 );
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		pNew->cleanup	();
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DPEnumAddressTypes,(void**)ret);
	return hr;
}



 
HRESULT C_dxj_DPEnumAddressTypesObject::getType( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *ret)
{
	if (m_pList2==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	*ret=DPLGUIDtoBSTR(&(m_pList2[index-1]));
	return S_OK;
}



HRESULT C_dxj_DPEnumAddressTypesObject::getCount(  long *ret)
{
	*ret=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumlocalapplicationsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumlocalapplicationsobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPEnumLocalApplicationsObj.h"


extern  BSTR DPLGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DPLBSTRtoPPGUID(LPGUID *,BSTR);


/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL  PASCAL objEnumLocalApplicationsCallback(
					LPCDPLAPPINFO lpAppInfo, 
					LPVOID lpArg, DWORD dwFlags)
{

	DPF(1,"Entered objEnumLocalApplicationsCallback\r\n");
	
	C_dxj_DPEnumLocalApplicationsObject *pObj=(C_dxj_DPEnumLocalApplicationsObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		
		if (pObj->m_pList)
			pObj->m_pList=(DPLAppInfo*)realloc(pObj->m_pList,sizeof(DPLAppInfo)* pObj->m_nMax);
		else
			pObj->m_pList=(DPLAppInfo*)malloc(sizeof(DPLAppInfo)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	
	}
	
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DPLAppInfo));
	
	if (!lpAppInfo) {
		pObj->m_bProblem=TRUE;
		return FALSE;
	}

	
	pObj->m_pList[pObj->m_nCount].strGuidApplication= DPLGUIDtoBSTR((GUID*)&(lpAppInfo->guidApplication));
	
	if (lpAppInfo->lpszAppName)
		pObj->m_pList[pObj->m_nCount].strAppName = SysAllocString(lpAppInfo->lpszAppName);
	
	//pObj->m_pList[pObj->m_nCount].lFlags=(DWORD)dwFlags;

	
	pObj->m_nCount++;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

C_dxj_DPEnumLocalApplicationsObject::C_dxj_DPEnumLocalApplicationsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DPEnumLocalApplicationsObject::~C_dxj_DPEnumLocalApplicationsObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			DPLAppInfo *conn=&(m_pList[i]);
			if (conn->strGuidApplication ) SysFreeString(conn->strGuidApplication);
			if (conn->strAppName) SysFreeString(conn->strAppName);						
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DPEnumLocalApplicationsObject::create(
		IDirectPlayLobby3 * pdp,
		long flags, I_dxj_DPEnumLocalApplications **ppRet)
{
	HRESULT hr;
	C_dxj_DPEnumLocalApplicationsObject *pNew=NULL;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DPEnumLocalApplicationsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	hr = pdp->EnumLocalApplications(
			objEnumLocalApplicationsCallback, 
			pNew, (DWORD)flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;
	
	if FAILED(hr) 
	{
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DPEnumLocalApplications,(void**)ppRet);
	return hr;
}


HRESULT C_dxj_DPEnumLocalApplicationsObject::getName(  long index, BSTR __RPC_FAR *ret) 
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=SysAllocString(m_pList[index-1].strAppName);
	return S_OK;
}





HRESULT C_dxj_DPEnumLocalApplicationsObject::getGuid(  long index, BSTR __RPC_FAR *ret) 
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=SysAllocString(m_pList[index-1].strGuidApplication);
	return S_OK;
}        
       

/*
HRESULT C_dxj_DPEnumLocalApplicationsObject::getItem( long index, DPLAppInfo *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index]),sizeof(DPLAppInfo));


	if (info->strGuidApplication) SysFreeString(info->strGuidApplication);
	if (info->strAppName) SysFreeString(info->strAppName);

	info->strAppName=SysAllocString(info->strAppName);
	info->strGuidApplication=SysAllocString(info->strGuidApplication);

	
	return S_OK;
}
*/

HRESULT C_dxj_DPEnumLocalApplicationsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumlocalapplications.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpenumlocalapplications.h
//
//--------------------------------------------------------------------------



#include "resource.h"       



class C_dxj_DPEnumLocalApplicationsObject : 
	public I_dxj_DPEnumLocalApplications,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumLocalApplicationsObject() ;
	virtual ~C_dxj_DPEnumLocalApplicationsObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumLocalApplicationsObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumLocalApplications)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumLocalApplicationsObject)

public:
		
	
		HRESULT STDMETHODCALLTYPE getItem( long index, DPLAppInfo *desc);		
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT create(IDirectPlayLobby3 * pdp,  long flags, I_dxj_DPEnumLocalApplications **ppRet);

public:
		DPLAppInfo	*m_pList;		
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumlocalapplicationsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpenumlocalapplicationsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       



class C_dxj_DPEnumLocalApplicationsObject : 
	public I_dxj_DPEnumLocalApplications,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumLocalApplicationsObject() ;
	virtual ~C_dxj_DPEnumLocalApplicationsObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumLocalApplicationsObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumLocalApplications)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumLocalApplicationsObject)

public:
		
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count) ;
        
        HRESULT STDMETHODCALLTYPE getName( long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret) ;
        
        HRESULT STDMETHODCALLTYPE getGuid( long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret) ;
		
		
		static HRESULT create(	IDirectPlayLobby3 * pdp,	long flags, I_dxj_DPEnumLocalApplications **ppRet);

public:
		DPLAppInfo	*m_pList;		
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxglob7obj.h"
#include "DPEnumObj.h"

extern  BSTR DPLGUIDtoBSTR(LPGUID pGuid);

//typedef HRESULT (__stdcall *DIRECTPLAYENUMERATE)( LPDPENUMDPCALLBACK, LPVOID );

extern "C" BOOL PASCAL objEnumServiceProvidersCallback(LPGUID lpGUID,  LPWSTR lpName, 
					DWORD dwMajorVersion,DWORD dwMinorVersion, void *lpArg)
{

	DPF(1,"Entered objEnumServiceProvidersCallback\r\n");



	C_dxj_DPEnumObject *pObj=(C_dxj_DPEnumObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		
		if (pObj->m_pList)
			pObj->m_pList=(DPServiceProvider*)realloc(pObj->m_pList,sizeof(DPServiceProvider)* pObj->m_nMax);
		else
			pObj->m_pList=(DPServiceProvider*)malloc(sizeof(DPServiceProvider)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}


	USES_CONVERSION;


	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DPServiceProvider));
	pObj->m_pList[pObj->m_nCount].strGuid=DPLGUIDtoBSTR((GUID*)lpGUID);
	
	if (lpName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=W2BSTR(lpName);
	}

	pObj->m_pList[pObj->m_nCount].lMajorVersion=(DWORD)dwMajorVersion;
	pObj->m_pList[pObj->m_nCount].lMinorVersion=(DWORD)dwMinorVersion;

	pObj->m_nCount++;

	return TRUE;
}




C_dxj_DPEnumObject::C_dxj_DPEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}

C_dxj_DPEnumObject::~C_dxj_DPEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].strName) SysFreeString(m_pList[i].strName);			
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DPEnumObject::create(DIRECTPLAYENUMERATE pcbFunc,I_dxj_DPEnumServiceProviders **ppRet)
{
	HRESULT hr;
	C_dxj_DPEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DPEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DPEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pcbFunc(objEnumServiceProvidersCallback,(void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}
	
	hr=pNew->QueryInterface(IID_I_dxj_DPEnumServiceProviders,(void**)ppRet);


	return hr;
}

HRESULT C_dxj_DPEnumObject::getName( long index, BSTR __RPC_FAR *ret)
{

	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	*ret=SysAllocString(m_pList[index-1].strName);
	return S_OK;

}
        
HRESULT C_dxj_DPEnumObject::getGuid( long index, BSTR __RPC_FAR *ret) 
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	*ret=SysAllocString(m_pList[index-1].strGuid);
	return S_OK;
}

HRESULT C_dxj_DPEnumObject::getVersion( 
            /* [in] */ long index,
            /* [in] */ long __RPC_FAR *majorVersion,
            /* [out][in] */ long __RPC_FAR *minorVersion)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	*majorVersion=m_pList[index-1].lMajorVersion;
	*minorVersion=m_pList[index-1].lMinorVersion;
	return S_OK;
}

HRESULT C_dxj_DPEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}

/*
HRESULT C_dxj_DPEnumObject::getItem( long index, DPServiceProvider *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	ZeroMemory(info,sizeof(DPServiceProvider));
	
	if  (info->strGuid) SysFreeString(info->strGuid);
	if  (info->strName) SysFreeString(info->strName);


	if (m_pList[index].strGuid) info->strGuid=SysAllocString(m_pList[index].strGuid);
	if (m_pList[index].strName) info->strName=SysAllocString(m_pList[index].strName);
	info->lMajorVersion=m_pList[index].lMajorVersion;
	info->lMinorVersion=m_pList[index].lMinorVersion;
	
	return S_OK;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumplayersobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpenumplayersobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

#define DPENUMGROUPSINGROUP 1
#define DPENUMPLAYERS 2	
#define DPENUMGROUPPLAYERS 3
#define DPENUMGROUPS 4


class C_dxj_DPEnumPlayersObject : 
	public I_dxj_DPEnumPlayers2,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumPlayersObject() ;
	virtual ~C_dxj_DPEnumPlayersObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumPlayersObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumPlayers2)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumPlayersObject)

public:
	    HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getFlags( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getDPID( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getShortName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retV);
        
        HRESULT STDMETHODCALLTYPE getLongName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retV);
        		
		static HRESULT C_dxj_DPEnumPlayersObject::create(IDirectPlay3 * pdp, long customFlags,long groupId, BSTR strGuid, long flags, I_dxj_DPEnumPlayers2 **ppRet);
								
		
		


public:
		DPPlayerInfo *m_pList;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumplayersobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumplayersobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPEnumPlayersObj.h"


extern  BSTR GUIDtoBSTR(LPGUID pGuid);
extern  HRESULT BSTRtoPPGUID(LPGUID *,BSTR);
extern  BSTR DPLGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DPLBSTRtoPPGUID(LPGUID *,BSTR);

/////////////////////////////////////////////////////////////////////////////
// The callback is invoked as a result of IDirectPlay2::EnumPlayers(), 
// IDirectPlay2::EnumGroups() and IDirectPlay2::EnumGroupPlayers() calls.
/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL PASCAL objEnumPlayersCallback2(DPID dpid, 
						DWORD dwPlayerType, LPCDPNAME lpName,
						DWORD dwFlags, LPVOID lpArg)
{
	
	DPF(1,"Entered objEnumPlayersCallback2 \r\n");


	C_dxj_DPEnumPlayersObject *pObj=(C_dxj_DPEnumPlayersObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
			pObj->m_pList=(DPPlayerInfo*)realloc(pObj->m_pList,sizeof(DPPlayerInfo)* pObj->m_nMax);
		else
			pObj->m_pList=(DPPlayerInfo*)malloc(sizeof(DPPlayerInfo)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}


	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DPPlayerInfo));
	pObj->m_pList[pObj->m_nCount].lDPID=(long)dpid;
	pObj->m_pList[pObj->m_nCount].lPlayerType=(long)dwPlayerType;
	pObj->m_pList[pObj->m_nCount].lFlags=(long)dwFlags;

	//unsing unicode DPLAY
	pObj->m_pList[pObj->m_nCount].strShortName=SysAllocString(lpName->lpszShortName);
	pObj->m_pList[pObj->m_nCount].strLongName=SysAllocString(lpName->lpszLongName);
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DPEnumPlayersObject::C_dxj_DPEnumPlayersObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DPEnumPlayersObject::~C_dxj_DPEnumPlayersObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if( m_pList[i].strShortName) SysFreeString(m_pList[i].strShortName);
			if( m_pList[i].strLongName) SysFreeString(m_pList[i].strLongName);			
		}
		free(m_pList);
	}

}

HRESULT C_dxj_DPEnumPlayersObject::create(IDirectPlay3 * pdp, long customFlags,long id, BSTR strGuid,long flags, I_dxj_DPEnumPlayers2 **ppRet)
{
	HRESULT hr;
	C_dxj_DPEnumPlayersObject *pNew=NULL;
	GUID g;
	LPGUID pguid=&g;

	hr= DPLBSTRtoPPGUID(&pguid,strGuid);
	if FAILED(hr) return hr;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DPEnumPlayersObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


	switch (customFlags){
		case DPENUMGROUPSINGROUP:
			hr = pdp->EnumGroupsInGroup((DPID)id,(GUID*) pguid,
						objEnumPlayersCallback2,
						pNew, (long)flags);
			break;
		case DPENUMPLAYERS:
			hr=pdp->EnumPlayers((GUID*) pguid,
						objEnumPlayersCallback2,
						pNew, (long)flags);
			break;
		case DPENUMGROUPPLAYERS:

			hr = pdp->EnumGroupPlayers( (DPID)id, (GUID*)pguid,
								objEnumPlayersCallback2,
								pNew, flags);
			break;
		case DPENUMGROUPS:
			hr=pdp->EnumGroups( (GUID*)pguid,
						objEnumPlayersCallback2,
						pNew, (DWORD)flags);

			break;
		default:
			hr=E_INVALIDARG;
			break;
	}
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DPEnumPlayers2,(void**)ppRet);
	return hr;
}

/* DEAD
HRESULT C_dxj_DPEnumPlayersObject::getItem( long index, DPPlayerInfo *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 0) return E_INVALIDARG;
	if (index >= m_nCount) return E_INVALIDARG;

	memcpy(info,&(m_pList[index]),sizeof(DPPlayerInfo));


	if (info->strShortName) SysFreeString(info->strShortName);
    if (info->strLongName) SysFreeString(info->strLongName);

	//unsing unicode DPLAY
	info->strShortName=SysAllocString(m_pList[index].strShortName);
	info->strLongName=SysAllocString(m_pList[index].strLongName);
	
	
	return S_OK;
}
*/


HRESULT C_dxj_DPEnumPlayersObject::getFlags( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=m_pList[index-1].lFlags;
	return S_OK;
}
        
 
HRESULT C_dxj_DPEnumPlayersObject::getType( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=m_pList[index-1].lPlayerType;
	return S_OK;
}



HRESULT C_dxj_DPEnumPlayersObject::getDPID( 
            /* [in] */ long index,
            /* [retval][out] */ long __RPC_FAR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=m_pList[index-1].lDPID;
	return S_OK;
}


HRESULT C_dxj_DPEnumPlayersObject::getShortName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=SysAllocString(m_pList[index-1].strShortName);
	return S_OK;
}        


HRESULT C_dxj_DPEnumPlayersObject::getLongName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	*ret=SysAllocString(m_pList[index-1].strLongName);
	return S_OK;
}        
        
HRESULT C_dxj_DPEnumPlayersObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumsessionsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpenumsessionsobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dpSessdataObj.h"
#include "DPEnumSessionsObj.h"



extern  BSTR GUIDtoBSTR(LPGUID pGuid);
extern  HRESULT BSTRtoPPGUID(LPGUID *,BSTR);
extern  BSTR DPLGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DPLBSTRtoPPGUID(LPGUID *,BSTR);

extern HRESULT FillRealSessionDesc(DPSESSIONDESC2 *dpSessionDesc,DPSessionDesc2 *sessionDesc);
extern void FillCoverSessionDesc(DPSessionDesc2 *sessionDesc,DPSESSIONDESC2 *dpSessionDesc);


/////////////////////////////////////////////////////////////////////////////

extern "C" BOOL PASCAL objEnumSessionsCallback2(const DPSESSIONDESC2 *gameDesc,
						 	 DWORD *timeout, DWORD dwFlags, void *lpArg)
{
	
	DPF(1,"Entered objEnumSessionsCallback2\r\n");

	
	//with no elements in a list will still call this callback once
	if (!gameDesc) return FALSE;

	C_dxj_DPEnumSessionsObject *pObj=(C_dxj_DPEnumSessionsObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		
		if (pObj->m_pList)
			pObj->m_pList=(DPSessionDesc2*)realloc(pObj->m_pList,sizeof(DPSessionDesc2)* pObj->m_nMax);
		else
			pObj->m_pList=(DPSessionDesc2*)malloc(sizeof(DPSessionDesc2)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}


	
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DPSessionDesc2));
	FillCoverSessionDesc(&(pObj->m_pList[pObj->m_nCount]),(DPSESSIONDESC2*)gameDesc);
	
	pObj->m_nCount++;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

C_dxj_DPEnumSessionsObject::C_dxj_DPEnumSessionsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DPEnumSessionsObject::~C_dxj_DPEnumSessionsObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			DPSessionDesc2 *sessionDesc=&(m_pList[i]);
			if (sessionDesc->strGuidInstance) SysFreeString(sessionDesc->strGuidInstance);
			if (sessionDesc->strGuidApplication) SysFreeString(sessionDesc->strGuidApplication);
			if (sessionDesc->strSessionName) SysFreeString(sessionDesc->strSessionName);
			if (sessionDesc->strPassword) SysFreeString(sessionDesc->strPassword);

		}
		free(m_pList);
	}

}

HRESULT C_dxj_DPEnumSessionsObject::create(
		IDirectPlay4 * pdp,
		I_dxj_DirectPlaySessionData *sess,
		long timeout, long flags, I_dxj_DPEnumSessions2 **ppRet)
{
	HRESULT hr;
	C_dxj_DPEnumSessionsObject *pNew=NULL;

	if (!sess) return E_INVALIDARG;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DPEnumSessionsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	if (sess){
		DPSESSIONDESC2 dpSessionDesc;
		//hr=FillRealSessionDesc(&dpSessionDesc,sess);
		//if FAILED(hr) return hr;
		sess->AddRef();

		sess->getData((void*)&dpSessionDesc);

		hr = pdp->EnumSessions(&dpSessionDesc, (DWORD)timeout, objEnumSessionsCallback2, pNew,(DWORD) flags);
		//if (dpSessionDesc.lpszSessionName)	SysFreeString(dpSessionDesc.lpszSessionName);
		//if (dpSessionDesc.lpszPassword)		SysFreeString(dpSessionDesc.lpszPassword);
		sess->Release();

	}
	else {
		hr = pdp->EnumSessions(NULL,(DWORD)timeout, objEnumSessionsCallback2, pNew,(DWORD) flags);
	}

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;



	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DPEnumSessions2,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_DPEnumSessionsObject::getItem( long index, I_dxj_DirectPlaySessionData **info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	HRESULT hr=C_dxj_DirectPlaySessionDataObject::create(&(m_pList[index-1]),info);
	
	/*
	memcpy(info,&(m_pList[index]),sizeof(DPSessionDesc2));

	if (info->strGuidInstance) SysFreeString(info->strGuidInstance);
	if (info->strGuidApplication) SysFreeString(info->strGuidApplication);
	if (info->strSessionName) SysFreeString(info->strSessionName);
	if (info->strPassword) SysFreeString(info->strPassword);

	info->strGuidInstance=  SysAllocString(m_pList[index].strGuidInstance);
	info->strGuidApplication=  SysAllocString(m_pList[index].strGuidApplication);
	info->strSessionName = SysAllocString(m_pList[index].strSessionName);
	info->strPassword = SysAllocString(m_pList[index].strPassword);
	*/
	return hr;
}

HRESULT C_dxj_DPEnumSessionsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpenumobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DPEnumObject : 
	public I_dxj_DPEnumServiceProviders,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumObject() ;
	virtual ~C_dxj_DPEnumObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumServiceProviders)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumObject)

public:
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getVersion( 
            /* [in] */ long index,
            /* [in] */ long __RPC_FAR *majorVersion,
            /* [out][in] */ long __RPC_FAR *minorVersion);
		
		HRESULT STDMETHODCALLTYPE getCount( long *count);
        
		static HRESULT C_dxj_DPEnumObject::create(DIRECTPLAYENUMERATE pcbFunc,I_dxj_DPEnumServiceProviders **ppRet);
		

public:
		DPServiceProvider *m_pList;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpenumsessionsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpenumsessionsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       



class C_dxj_DPEnumSessionsObject : 
	public I_dxj_DPEnumSessions2,
	public CComObjectRoot
{
public:
	C_dxj_DPEnumSessionsObject() ;
	virtual ~C_dxj_DPEnumSessionsObject() ;

BEGIN_COM_MAP(C_dxj_DPEnumSessionsObject)
	COM_INTERFACE_ENTRY(I_dxj_DPEnumSessions2)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPEnumSessionsObject)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, I_dxj_DirectPlaySessionData **desc);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		
		static HRESULT C_dxj_DPEnumSessionsObject::create(IDirectPlay4 * pdp, I_dxj_DirectPlaySessionData *desc, long timeout,long flags, I_dxj_DPEnumSessions2 **ppRet);

public:
		DPSessionDesc2 *m_pList;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpladdressobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpladdressobj.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_DPAddressObject :
		public IDPAddress,
		public CComCoClass<C_DPAddressObject, &CLSID__DPAddress>,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_DPAddressObject)
		COM_INTERFACE_ENTRY(IDPAddress)
	END_COM_MAP()

	DECLARE_REGISTRY(CLSID__DPAddress, "DIRECT.DPAddress.5",		"DIRECT.DPAddress.5",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)
	DECLARE_AGGREGATABLE(C_DPAddressObject)

public:
	C_DPAddressObject();
	~C_DPAddressObject();

  virtual HRESULT STDMETHODCALLTYPE setAddress( 
            /* [in] */ long pAddress,
            /* [in] */ long length) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getAddress( 
            /* [out] */ long __RPC_FAR *pAddress,
            /* [out] */ long __RPC_FAR *length) = 0;
                
private:
	DPAddress m_connect;
	DPSESSIONDESC2 m_sessionDesc;
	DPNAME		  m_dpName;
	IUnknown	  *nextobj;
	DWORD		  creationid;
	void		  *m_pAddress;
	void cleanUp();
	void init();
	
};

extern IUnknown *g_DPAddress;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dplay4obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dplay4obj.h
//
//--------------------------------------------------------------------------

// _dxj_DirectPlay4Obj.h : Declaration of the C_dxj_DirectPlay4Object
// DHF begin - entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectPlay4 LPDIRECTPLAY4

/////////////////////////////////////////////////////////////////////////////
// DirectPlay4

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlay4Object :
 
#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlay4, &IID_I_dxj_DirectPlay4, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlay4,
#endif

//	public CComCoClass<C_dxj_DirectPlay4Object, &CLSID__dxj_DirectPlay4>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectPlay4Object() ;
	~C_dxj_DirectPlay4Object() ;

BEGIN_COM_MAP(C_dxj_DirectPlay4Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlay4)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectPlay4, "DIRECT.DirectPlay4.3",		"DIRECT.DiectPlay2.3",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectPlay4Object) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectPlay4Object)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlay4
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE addGroupToGroup( 
            /* [in] */ long ParentGroupId,
            /* [in] */ long GroupId);
        
        HRESULT STDMETHODCALLTYPE addPlayerToGroup( 
            /* [in] */ long groupId,
            /* [in] */ long playerId);
        
        HRESULT STDMETHODCALLTYPE cancelMessage( 
            /* [in] */ long msgid);
        
        HRESULT STDMETHODCALLTYPE cancelPriority( 
            /* [in] */ long minPrority,
            /* [in] */ long maxPriority);
        
        HRESULT STDMETHODCALLTYPE close( void);
        
        HRESULT STDMETHODCALLTYPE createGroup( 
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *v1);
        
        HRESULT STDMETHODCALLTYPE createGroupInGroup( 
            /* [in] */ long parentid,
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *v1);
        
        HRESULT STDMETHODCALLTYPE createPlayer( 
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long receiveEvent,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *v1);
        
        HRESULT STDMETHODCALLTYPE deleteGroupFromGroup( 
            /* [in] */ long groupParentId,
            /* [in] */ long groupId);
        
        HRESULT STDMETHODCALLTYPE deletePlayerFromGroup( 
            /* [in] */ long groupId,
            /* [in] */ long playerId);
        
        HRESULT STDMETHODCALLTYPE destroyGroup( 
            /* [in] */ long groupId);
        
        HRESULT STDMETHODCALLTYPE destroyPlayer( 
            /* [in] */ long playerId);
        
        HRESULT STDMETHODCALLTYPE getDPEnumConnections( 
            /* [in] */ BSTR guid,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumConnections __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumGroupPlayers( 
            /* [in] */ long groupId,
            /* [in] */ BSTR sessionGuid,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumPlayers2 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumGroups( 
            /* [in] */ BSTR sessionGuid,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumPlayers2 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumGroupsInGroup( 
            /* [in] */ long groupId,
            /* [in] */ BSTR sessionGuid,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumPlayers2 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumPlayers( 
            /* [in] */ BSTR sessionGuid,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumPlayers2 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumSessions( 
            /* [in] */ I_dxj_DirectPlaySessionData __RPC_FAR *sessionDesc,
            /* [in] */ long timeOut,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumSessions2 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DPCaps __RPC_FAR *caps,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE getGroupData( 
            /* [in] */ long groupId,
            /* [in] */ long flags,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getGroupFlags( 
            /* [in] */ long groupId,
            /* [retval][out] */ long __RPC_FAR *flags);
        
        HRESULT STDMETHODCALLTYPE getGroupLongName( 
            /* [in] */ long groupId,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getGroupShortName( 
            /* [in] */ long groupId,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getGroupParent( 
            /* [in] */ long groupId,
            /* [retval][out] */ long __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getGroupOwner( 
            /* [in] */ long groupId,
            /* [retval][out] */ long __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getMessageCount( 
            /* [in] */ long playerId,
            /* [retval][out] */ long __RPC_FAR *count);
        
        HRESULT STDMETHODCALLTYPE getMessageQueue( 
            /* [in] */ long from,
            /* [in] */ long to,
            /* [in] */ long flags,
            /* [out][in] */ long __RPC_FAR *nMessage,
            /* [out][in] */ long __RPC_FAR *nBytes);
        
        HRESULT STDMETHODCALLTYPE getPlayerAccountId( 
            /* [in] */ long playerid,
            /* [retval][out] */ BSTR __RPC_FAR *acctid);
        
        HRESULT STDMETHODCALLTYPE getPlayerAddress( 
            /* [in] */ long playerId,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getPlayerCaps( 
            /* [in] */ long playerId,
            /* [out] */ DPCaps __RPC_FAR *caps,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE getPlayerData( 
            /* [in] */ long playerId,
            /* [in] */ long flags,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getPlayerFlags( 
            /* [in] */ long id,
            /* [retval][out] */ long __RPC_FAR *retflags);
        
        HRESULT STDMETHODCALLTYPE getPlayerFormalName( 
            /* [in] */ long playerId,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getPlayerFriendlyName( 
            /* [in] */ long playerId,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        HRESULT STDMETHODCALLTYPE getSessionDesc( 
            /* [out][in] */ I_dxj_DirectPlaySessionData __RPC_FAR **sessionDesc);
        
        HRESULT STDMETHODCALLTYPE initializeConnection( 
            /* [in] */ I_dxj_DPAddress __RPC_FAR *address);
        
        HRESULT STDMETHODCALLTYPE open( 
            /* [out][in] */ I_dxj_DirectPlaySessionData __RPC_FAR *sessionDesc,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE receive( 
            /* [out][in] */ long __RPC_FAR *fromPlayerId,
            /* [out][in] */ long __RPC_FAR *toPlayerId,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE receiveSize( 
            /* [out][in] */ long __RPC_FAR *fromPlayerId,
            /* [out][in] */ long __RPC_FAR *toPlayerId,
            /* [in] */ long flags,
            /* [retval][out] */ int __RPC_FAR *dataSize);
        
        HRESULT STDMETHODCALLTYPE secureOpen( 
            /* [in] */ I_dxj_DirectPlaySessionData __RPC_FAR *sessiondesc,
            /* [in] */ long flags,
            /* [in] */ DPSecurityDesc __RPC_FAR *security,
            /* [in] */ DPCredentials __RPC_FAR *credentials);
        
        HRESULT STDMETHODCALLTYPE send( 
            /* [in] */ long fromPlayerId,
            /* [in] */ long toPlayerId,
            /* [in] */ long flags,
            /* [in] */ I_dxj_DirectPlayMessage __RPC_FAR *msg);
        
        HRESULT STDMETHODCALLTYPE sendChatMessage( 
            /* [in] */ long fromPlayerId,
            /* [in] */ long toPlayerId,
            /* [in] */ long flags,
            /* [in] */ BSTR message);
        
        HRESULT STDMETHODCALLTYPE sendEx( 
            /* [in] */ long fromPlayerId,
            /* [in] */ long toPlayerId,
            /* [in] */ long flags,
            /* [in] */ I_dxj_DirectPlayMessage __RPC_FAR *msg,
            /* [in] */ long priority,
            /* [in] */ long timeout,
            /* [in] */ long context,
            /* [retval][out] */ long __RPC_FAR *messageid);
        
        HRESULT STDMETHODCALLTYPE createMessage( 
            /* [retval][out] */ I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *msg);
        
        HRESULT STDMETHODCALLTYPE setGroupConnectionSettings( 
            /* [in] */ long id,
            /* [in] */ I_dxj_DPLConnection __RPC_FAR *connection);
        
        HRESULT STDMETHODCALLTYPE setGroupData( 
            /* [in] */ long groupId,
            /* [in] */ BSTR data,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setGroupName( 
            /* [in] */ long groupId,
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setGroupOwner( 
            /* [in] */ long groupId,
            /* [in] */ long ownerId);
        
        HRESULT STDMETHODCALLTYPE setPlayerData( 
            /* [in] */ long playerId,
            /* [in] */ BSTR data,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setPlayerName( 
            /* [in] */ long playerId,
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setSessionDesc( 
            /* [in] */ I_dxj_DirectPlaySessionData __RPC_FAR *sessionDesc);
        
        HRESULT STDMETHODCALLTYPE startSession( 
            /* [in] */ long id);
        
        HRESULT STDMETHODCALLTYPE createSessionData( 
            /* [retval][out] */ I_dxj_DirectPlaySessionData __RPC_FAR *__RPC_FAR *sessionDesc);



////////////////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlay4);
	C_dxj_DirectPlay4Object *nextPlayObj;

private:
	void doRemoveThisPlayObj();

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectPlay4 )
};

//MUST DEFINE THIS IN DIRECT.CPP
extern C_dxj_DirectPlay4Object *Play4Objs;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dplay4obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dplay4obj.cpp
//
//--------------------------------------------------------------------------

// _dxj_DirectPlay2Obj.cpp : Implementation of C_dxj_DirectPlay2Object
// DHF begin - entire file




#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dPlay.h"
#include "DPAddressObj.h"
#include "DPLConnectionObj.h"
#include "dPlay4Obj.h"
#include "DPEnumPlayersObj.h"
#include "DPEnumSessionsObj.h"
#include "DPEnumConnectionsObj.h"
#include "dpMsgObj.h"
#include "dpSessDataObj.h"


typedef HRESULT (__stdcall *DIRECTPLAYCREATE)( LPGUID lpGUID, LPDIRECTPLAY *lplpDP, IUnknown *pUnk);
extern DIRECTPLAYCREATE pDirectPlayCreate;
typedef HRESULT (__stdcall *DIRECTPLAYENUMERATE)( LPDPENUMDPCALLBACK, LPVOID );
extern DIRECTPLAYENUMERATE pDirectPlayEnumerate;

extern HRESULT FillRealSessionDesc(DPSESSIONDESC2 *dpSessionDesc,DPSessionDesc2 *sessionDesc);
extern void FillCoverSessionDesc(DPSessionDesc2 *sessionDesc,DPSESSIONDESC2 *dpSessionDesc);

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern HRESULT BSTRtoPPGUID(LPGUID*,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern void *g_dxj_DirectPlay4;

C_dxj_DirectPlay4Object::C_dxj_DirectPlay4Object()
{
	m__dxj_DirectPlay4 = NULL;
	parent = NULL; 	
	nextobj = g_dxj_DirectPlay4;
	g_dxj_DirectPlay4 = this;
	creationid = ++g_creationcount;
}

DESTRUCTOR(_dxj_DirectPlay4, {})
GETSET_OBJECT(_dxj_DirectPlay4);

//
/*** I_dxj_DirectPlay4 methods ***/
//
PASS_THROUGH_CAST_2_R(_dxj_DirectPlay4, addPlayerToGroup, AddPlayerToGroup, Dpid,(DPID), Dpid,(DPID));
PASS_THROUGH_R(_dxj_DirectPlay4, close, Close);
//PASS_THROUGH_CAST_1_R(_dxj_DirectPlay4, initialize, Initialize, DxGuid*, (LPGUID));
PASS_THROUGH_CAST_2_R(_dxj_DirectPlay4, deletePlayerFromGroup, DeletePlayerFromGroup, Dpid, (DPID), Dpid, (DPID));
PASS_THROUGH_CAST_1_R(_dxj_DirectPlay4, destroyPlayer, DestroyPlayer, Dpid,(DPID));
PASS_THROUGH_CAST_1_R(_dxj_DirectPlay4, destroyGroup, DestroyGroup, Dpid,(DPID));

PASS_THROUGH_CAST_2_R(_dxj_DirectPlay4, getMessageCount, GetMessageCount, Dpid,(DPID), long *,(DWORD*));
//PASS_THROUGH_CAST_3_R(_dxj_DirectPlay4, getPlayerCaps, GetPlayerCaps, Dpid, (DPID), DPCaps*, (DPCAPS*), long, (DWORD));
//PASS_THROUGH_CAST_2_R(_dxj_DirectPlay4, startSession, StartSession, long, (DWORD), Dpid, (DPID));
//PASS_THROUGH_CAST_3_R(_dxj_DirectPlay4, getPlayerCaps, GetPlayerCaps, Dpid, (DPID), DPCaps*, (DPCAPS*), long, (DWORD));
//PASS_THROUGH_CAST_2_R(_dxj_DirectPlay4, getCaps, GetCaps, DPCaps*, (LPDPCAPS), long, (DWORD));

STDMETHODIMP C_dxj_DirectPlay4Object::getCaps(DPCaps *c,long flags){
	if (!c) return E_INVALIDARG;
	c->lSize=sizeof(DPCAPS);
	HRESULT hr = m__dxj_DirectPlay4->GetCaps((DPCAPS*)c,(DWORD)flags);
	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::startSession(Dpid id){
	HRESULT hr = m__dxj_DirectPlay4->StartSession(0,(DPID)id);
	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerCaps(Dpid id, DPCaps *caps, long flags)
{
	((DPCAPS*)caps)->dwSize=sizeof(DPCAPS);
	HRESULT hr = m__dxj_DirectPlay4->GetPlayerCaps((DPID)id,(DPCAPS*)caps,(DWORD)flags);
	return hr;

}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::createGroup( 
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
					   long flags,
            /* [retval][out] */ Dpid  *v1) 
{
	if ( m__dxj_DirectPlay4 == NULL )		return E_FAIL;

	DPNAME dpName;
	ZeroMemory(&dpName,sizeof(DPNAME));

	dpName.dwSize = sizeof(dpName);
	

	if ((!friendlyName) ||(!formalName)) return E_INVALIDARG;

	if (0==_wcsicmp(friendlyName,formalName)) return E_INVALIDARG;


	if ( friendlyName[0]!=0 )
	{
		dpName.lpszShortName = (LPWSTR)alloca(sizeof(WCHAR)*(wcslen(friendlyName)+1));
		wcscpy(dpName.lpszShortName, friendlyName);
	}
	if ( formalName[0]!=0 )
	{
		dpName.lpszLongName = (LPWSTR)alloca(sizeof(WCHAR)*(wcslen(formalName)+1));
		wcscpy(dpName.lpszLongName, formalName);
	}
		
	HRESULT hr = m__dxj_DirectPlay4->CreateGroup((DWORD*)v1, &dpName, NULL, 0, (DWORD)flags);

	return hr;

}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::createPlayer( 
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long receiveEvent,
			/* [in] */ long flags,
            /* [retval][out] */ Dpid __RPC_FAR *v1) 
{
	if ( m__dxj_DirectPlay4 == NULL )		return E_FAIL;

	
	DPNAME dpName;
	ZeroMemory(&dpName,sizeof(DPNAME));
	dpName.dwSize = sizeof(DPNAME);

	if ((!friendlyName) ||(!formalName)) return E_INVALIDARG;

	if (0==_wcsicmp(friendlyName,formalName)) return E_INVALIDARG;
			

	if ( friendlyName[0]!=0 )
	{
		dpName.lpszShortName = (LPWSTR)friendlyName;
		//dpName.lpszShortName = (LPWSTR)alloca(sizeof(WCHAR)*(wcslen(friendlyName)+1));
		//wcscpy(dpName.lpszShortName, friendlyName);
	}
	if ( formalName[0]!=0 )
	{
		//dpName.lpszLongName = (LPWSTR)alloca(sizeof(WCHAR)*(wcslen(formalName)+1));
		//wcscpy(dpName.lpszLongName, formalName);
		dpName.lpszLongName = (LPWSTR)formalName;
	}
	
	HRESULT hr = m__dxj_DirectPlay4->CreatePlayer((DWORD*)v1, &dpName, (LPVOID)receiveEvent, NULL, 0, (DWORD)flags);


	//if (dpName.lpszShortName) free(dpName.lpszShortName);
	//if (dpName.lpszLongName) free(dpName.lpszLongName);

	
	return hr;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumGroupPlayers(
		Dpid groupPID,
		BSTR strGuid,
		long flags,
		I_dxj_DPEnumPlayers2 **retVal){
		HRESULT hr=C_dxj_DPEnumPlayersObject::create(m__dxj_DirectPlay4,DPENUMGROUPPLAYERS,groupPID,strGuid,flags,retVal);
		return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumGroups(
		BSTR strGuid,
		long flags, 
		I_dxj_DPEnumPlayers2 **retVal){
		HRESULT hr=C_dxj_DPEnumPlayersObject::create(m__dxj_DirectPlay4,DPENUMGROUPS,0,strGuid,flags,retVal);
		return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumGroupsInGroup(
		Dpid groupPID,
		BSTR strGuid,
		long flags, 
		I_dxj_DPEnumPlayers2 **retVal){
		HRESULT hr=C_dxj_DPEnumPlayersObject::create(m__dxj_DirectPlay4,DPENUMGROUPSINGROUP,groupPID,strGuid,flags,retVal);
		return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumPlayers(
		BSTR strGuid,
		long flags,
		I_dxj_DPEnumPlayers2 **retVal){
		HRESULT hr=C_dxj_DPEnumPlayersObject::create(m__dxj_DirectPlay4,DPENUMPLAYERS,0,strGuid,flags,retVal);
		return hr;
}


//////////////////////////////////////////////////////////////////////////
// USE void because we can accept null in VB
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumSessions(
		I_dxj_DirectPlaySessionData *sessionDesc,
		long timeout,
		long flags, 
		I_dxj_DPEnumSessions2 **retVal)
{				
		HRESULT hr=C_dxj_DPEnumSessionsObject::create(m__dxj_DirectPlay4,sessionDesc,timeout,flags,retVal);
		return hr;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getGroupData(  Dpid id,long flags,   BSTR *ret)
{
	
	DWORD	size;
	HRESULT hr;
	void	*pData=NULL;

	//ASSERT ( m__dxj_DirectPlay4 != NULL )		
	if (!ret) return E_INVALIDARG;

	hr= m__dxj_DirectPlay4->GetGroupData((DWORD)id, (void*)NULL, (LPDWORD)&size, (DWORD)flags);	
	
	if (size==0) {
		*ret=NULL;
		return S_OK;
	}

	//we only want data we can cast to a string
	if ((size % 2)!=0) return E_INVALIDARG;

	
	pData=malloc(size+2);
	if (!pData) return E_OUTOFMEMORY;	

	//null terminate.
	((char*)pData)[size]='\0';
	((char*)pData)[size+1]='\0';

	hr= m__dxj_DirectPlay4->GetGroupData((DWORD)id, (void*)pData, (LPDWORD)&size, (DWORD)flags);	
	if FAILED(hr) 	{
		if (pData) free(pData);
		return hr;
	}
	
	*ret=SysAllocString((WCHAR*)pData);

	if (pData) free(pData);

	return hr;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getGroupShortName(Dpid id, BSTR *friendlyN) 
{
	DWORD dwDataSize;

	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	if(!friendlyN) return E_INVALIDARG;

	*friendlyN=NULL;

	HRESULT hr=m__dxj_DirectPlay4->GetGroupName(id, (char*)NULL, &dwDataSize);
	
	if (dwDataSize<sizeof(DPNAME)) return E_INVALIDARG;
	
	// Supply the stack based buffers needed by DIRECTX
	LPDPNAME dpName = (LPDPNAME)alloca(dwDataSize);	
	ZeroMemory(dpName,dwDataSize);
	dpName->dwSize=sizeof(DPNAME);
	hr = m__dxj_DirectPlay4->GetGroupName((DPID)id, dpName, &dwDataSize);	
	if FAILED(hr) return hr;
	*friendlyN = SysAllocString(dpName->lpszShortName);	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getGroupLongName(Dpid id, BSTR *formalN) 
{
	DWORD dwDataSize=0;

	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;
	
	if(!formalN) return E_INVALIDARG;

	*formalN=NULL;

	HRESULT hr=m__dxj_DirectPlay4->GetGroupName(id, (char*)NULL, &dwDataSize);
		
	if (dwDataSize<sizeof(DPNAME)) return E_INVALIDARG;

	// Supply the stack based buffers needed by DIRECTX
	LPDPNAME dpName = (LPDPNAME)alloca(dwDataSize);	
	ZeroMemory(dpName,dwDataSize);
	dpName->dwSize=sizeof(DPNAME);
	hr = m__dxj_DirectPlay4->GetGroupName(id, dpName, &dwDataSize);
	if FAILED(hr) return hr;
	*formalN = SysAllocString(dpName->lpszLongName);			
	return hr;
}

//////////////////////////////////////////////////////////////////////////
// Gets a DirectPlay abstract address using a player id 
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerAddress( 
            /* [in] */ Dpid id,
            /* [out] */ I_dxj_DPAddress **ret)            
{
	if ( m__dxj_DirectPlay4 == NULL )		return E_FAIL;

	void *pAddress;
	DWORD size=0;

	HRESULT hr;

	hr= m__dxj_DirectPlay4->GetPlayerAddress((DPID)id, NULL,&size);
	if (size==0) return E_FAIL;

	pAddress=malloc(size);
	if (pAddress==NULL) return E_OUTOFMEMORY;

	hr= m__dxj_DirectPlay4->GetPlayerAddress((DPID)id,pAddress,&size);

	if FAILED(hr){
		free(pAddress);
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,ret);
	
	if (*ret==NULL) return E_OUTOFMEMORY;

	hr=(*ret)->setAddress((long)PtrToLong(pAddress),size);	//bugbug SUNDOWN
	free(pAddress);

	return hr;
}


//////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerData( 
            /* [in] */ Dpid id,
			long flags,
            /* [out] */ BSTR *ret)
{

	DWORD	size;
	HRESULT hr;
	void	*pData=NULL;

	//ASSERT ( m__dxj_DirectPlay4 != NULL )		

	hr=m__dxj_DirectPlay4->GetPlayerData((DWORD)id, (void*)NULL, (LPDWORD)&size, (DWORD)flags);
	
	if (size==0) {
		*ret=NULL;
		return S_OK;
	}

	//we only want data we can cast to a string
	if ((size % 2)!=0) return E_INVALIDARG;

	pData=malloc(size+sizeof(WCHAR));	
	if (!pData) return E_OUTOFMEMORY;

	ZeroMemory(pData,size+sizeof(WCHAR));
	
	hr= m__dxj_DirectPlay4->GetPlayerData((DWORD)id, (void*)pData, (LPDWORD)&size, (DWORD)flags);	
	if FAILED(hr) 	{
		if (pData) free(pData);
	}
	
	*ret=SysAllocString((WCHAR*)pData);

	if (pData) free(pData);

	return hr;	
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerFriendlyName(Dpid id, BSTR *friendlyN) 
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	DWORD dwDataSize;

	HRESULT hr;
	hr=m__dxj_DirectPlay4->GetPlayerName((DPID)id, (char*)NULL, &dwDataSize);	

	// Supply the stack based buffers needed by DIRECTX
	LPDPNAME dpName = (LPDPNAME)alloca(dwDataSize);	
	ZeroMemory(dpName,dwDataSize);
	dpName->dwSize=sizeof(DPNAME);
	
	hr = m__dxj_DirectPlay4->GetPlayerName((DPID)id, dpName, &dwDataSize);
	if FAILED(hr) return hr;

	*friendlyN = SysAllocString(dpName->lpszShortName);	
	

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerFormalName(Dpid id, BSTR *formalN) 
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	DWORD dwDataSize;
	HRESULT hr;

	hr=m__dxj_DirectPlay4->GetPlayerName((DPID)id, (char*)NULL, &dwDataSize);

	//// Supply the stack based buffers needed by DIRECTX
	LPDPNAME dpName = (LPDPNAME)alloca(dwDataSize);		// ANSI buffer on stack;		
	ZeroMemory(dpName,dwDataSize);
	dpName->dwSize=sizeof(DPNAME);

	hr=m__dxj_DirectPlay4->GetPlayerName((DPID)id, dpName, &dwDataSize); // get ANSI
	if FAILED(hr) return hr;

	*formalN = SysAllocString(dpName->lpszLongName);
	
	
	return hr;
}

//////////////////////////////////////////////////////////////////////////
// Gets the current session description
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getSessionDesc(
			/* [out] */ I_dxj_DirectPlaySessionData __RPC_FAR **sessionDesc)
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	if ( sessionDesc == NULL )
		return E_FAIL;

	DWORD dataSize = 0;
	HRESULT hr = m__dxj_DirectPlay4->GetSessionDesc(NULL, &dataSize);

	LPVOID data = alloca(dataSize);
	hr = m__dxj_DirectPlay4->GetSessionDesc((LPVOID)data, &dataSize);
	if(hr != DP_OK) {
		return hr;
	}
	LPDPSESSIONDESC2 dpSessionDesc = (LPDPSESSIONDESC2)data;

	hr=C_dxj_DirectPlaySessionDataObject::create(dpSessionDesc,sessionDesc);

	return hr;
}



//////////////////////////////////////////////////////////////////////////
// Establish a gaming session instance - create or join a game session
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::open(I_dxj_DirectPlaySessionData *sessionDesc,	long flags)
{
	
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	if ( sessionDesc == NULL )
		return E_INVALIDARG;

	DPSESSIONDESC2	dpSessionDesc;
	
	//CONSIDER - validating sessiondesc object
	//	     to return friendly error

	sessionDesc->AddRef();
	sessionDesc->getData(&dpSessionDesc);
	
	
	HRESULT hr = m__dxj_DirectPlay4->Open(&dpSessionDesc, flags);

	//SysFreeString(dpSessionDesc.lpszPassword);
	//SysFreeString(dpSessionDesc.lpszSessionName);
	sessionDesc->Release();

	if FAILED(hr) return hr;

	//FillCoverSessionDesc(sessionDesc,&dpSessionDesc);

	return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::receive( 
            /* [in, out] */ Dpid  *fromPlayerId,
            /* [in, out] */ Dpid  *toPlayerId,
            /* [in]  */ long flags,
			I_dxj_DirectPlayMessage **msg )

{
	
	
	HRESULT hr;
	DWORD dwSize=0;
    void  *pData=NULL;
	
	
	//#pragma message ("check with DPLAY folks if this is necessary")
	//DONE: The loop is not neccesary.. 
	//aaronO indicated the message order is consistent
	//a call to recieve to get the size can always be folowed by a call to get 
	//the message - ANDREWKE
	//
	//BOOL  fCont=TRUE;
	//while (fCont){

	hr = m__dxj_DirectPlay4->Receive((DPID*)fromPlayerId, (DPID*)toPlayerId, (DWORD)flags, NULL, &dwSize);
	
	//fix for manbug24192
	if 	(hr == DPERR_NOMESSAGES ) {
		*msg=NULL;
		return S_OK;
	}
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;
	

	hr=C_dxj_DirectPlayMessageObject::create((DWORD)*fromPlayerId,dwSize,&pData,msg);
	if FAILED(hr) return hr;
	
	hr = m__dxj_DirectPlay4->Receive((DPID*)fromPlayerId, (DPID*)toPlayerId, (DWORD)flags,pData, &dwSize);

	//should never hit this
	// if ( hr == DPERR_BUFFERTOOSMALL){
	//	fCont=TRUE;
	//	(*msg)->Release();
	//	
	// }
	// else{
	//	fCont=FALSE;
	// }
	//} end while
	
	if 	FAILED(hr) {
		if (*msg) (*msg)->Release();
		*msg=NULL;		
	}
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectPlay4Object::receiveSize( 
            /* [in,out] */ Dpid  *fromPlayerId,
            /* [in,out] */ Dpid  *toPlayerId,
            /* [in] */ long flags,
            /* [retval][out] */ int *dataSize)
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	unsigned long  *id1 = 0, *id2 = 0;

	HRESULT hr = m__dxj_DirectPlay4->Receive((DPID*)fromPlayerId, (DPID*)toPlayerId, 
		(DWORD)flags, (void*)NULL, (LPDWORD)dataSize);
	if ( hr == DPERR_BUFFERTOOSMALL || hr == DPERR_NOMESSAGES )
		hr = S_OK;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::send( 
            /* [in] */ Dpid fromPlayerId,
            /* [in] */ Dpid toPlayerId,
            /* [in] */ long flags,
            /* [in] */ I_dxj_DirectPlayMessage *msg)            
{
	
	HRESULT hr;	
	void *pdata=NULL;
	DWORD dataSize=0;
	
	if (!msg) return E_INVALIDARG;

	__try {
		msg->getPointer((long*)&pdata);
		msg->getMessageSize((long*)&dataSize);
		hr= m__dxj_DirectPlay4->Send((DPID)fromPlayerId, (DPID)toPlayerId, (DWORD)flags, 
			(void*)pdata, (DWORD) dataSize);
	}
	__except (1,1)
	{
		return E_INVALIDARG;	
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::setGroupData( 
            /* [in] */ long id,
            /* [in] */ BSTR data,            
            /* [in] */ long flags)        
{
	
	HRESULT hr;
	DWORD datasize=0;
	void *pdata=NULL;
	
	if (data){
		pdata=data;
		datasize= ((DWORD*)data)[-1];
	}
	
	__try {
		hr = m__dxj_DirectPlay4->SetGroupData((DPID)id,(void*)pdata,
				(DWORD)datasize, (DWORD)flags);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::setGroupName( 
            /* [in] */ Dpid id,
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags) 
{
	//ASSERT( m__dxj_DirectPlay4 != NULL )
		

	DPNAME dpName;
	ZeroMemory(&dpName,sizeof(DPNAME));
	dpName.dwSize = sizeof(DPNAME);
	
	dpName.lpszShortName=NULL;
	dpName.lpszLongName=NULL;

	if ( friendlyName )
	{
		dpName.lpszShortName = friendlyName;
	}
	if ( formalName )
	{
		dpName.lpszLongName = formalName;		
	}

	HRESULT hr = m__dxj_DirectPlay4->SetGroupName((DPID)id, &dpName, flags);

	return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::setPlayerData( 
            /* [in] */ long id,
            /* [in] */ BSTR data,
            /* [in] */ long flags)        
{

		HRESULT hr;
	DWORD datasize=0;
	void *pdata=NULL;
	
	if (data){
		if (data[0]!=0x00) {
			pdata=data;
			datasize= ((DWORD*)data)[-1];
		}
	}
	
	__try {
		hr = m__dxj_DirectPlay4->SetPlayerData((DPID)id,(void*)pdata,
				(DWORD)datasize, (DWORD)flags);
	}
	__except(1,1){
		return E_INVALIDARG;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::setPlayerName( 
            /* [in] */ Dpid id,
            /* [in] */ BSTR friendlyName,
            /* [in] */ BSTR formalName,
            /* [in] */ long flags) 
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	DWORD l=0;

	DPNAME dpName;
	ZeroMemory(&dpName,sizeof(DPNAME))	;	
	dpName.dwSize=sizeof(DPNAME);
	dpName.lpszShortName = friendlyName;
	dpName.lpszLongName = formalName;
	
  	HRESULT hr = m__dxj_DirectPlay4->SetPlayerName((DPID) id, &dpName, (DWORD)flags);

	return hr;
}

//////////////////////////////////////////////////////////////////////////
// Sets the current session description
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::setSessionDesc( 
            /* [in] */ I_dxj_DirectPlaySessionData __RPC_FAR *sessionDesc           
		   )
{
	if ( m__dxj_DirectPlay4 == NULL )
		return E_FAIL;

	if (!sessionDesc) return E_INVALIDARG;

	DPSESSIONDESC2	dpSessionDesc;
	sessionDesc->AddRef();
	sessionDesc->getData(&dpSessionDesc);
	HRESULT hr = m__dxj_DirectPlay4->SetSessionDesc(&dpSessionDesc, 0);
	sessionDesc->Release();
	
	return hr;
}



STDMETHODIMP C_dxj_DirectPlay4Object::setGroupConnectionSettings(// long flags,
																 Dpid idGroup, I_dxj_DPLConnection *connect)
{
	DPLCONNECTION *con;
	connect->getConnectionStruct((long*)&con);
	
	HRESULT hr = m__dxj_DirectPlay4->SetGroupConnectionSettings((DWORD)0,(DPID) idGroup,con);
	
	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::sendChatMessage( 
		Dpid fromPlayerId, Dpid toPlayerId, long flags, BSTR message)
{

	DPCHAT  dpChat;	

	dpChat.dwSize=sizeof(DPCHAT);
	dpChat.dwFlags=(DWORD)0;
	dpChat.lpszMessage=message;

	HRESULT hr = m__dxj_DirectPlay4->SendChatMessage((DPID)fromPlayerId,(DPID)toPlayerId,(DWORD)flags,&dpChat);

	
	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::secureOpen(I_dxj_DirectPlaySessionData *desc, 
		long flags, DPSecurityDesc *security, DPCredentials *credentials){

	DPSESSIONDESC2 dpSessionDesc;
	DPSECURITYDESC dpSecurity;
	DPCREDENTIALS  dpCredentials;

	LPCDPSECURITYDESC lpSecurity=NULL;
	LPCDPCREDENTIALS lpCredentials=NULL;
	DWORD			l=0,i,j;

	if (desc==NULL) return E_INVALIDARG;
	//FillRealSessionDesc(&dpSessionDesc,desc);
	


	ZeroMemory((void*)&dpSecurity,sizeof(DPSECURITYDESC));
	ZeroMemory((void*)&dpCredentials,sizeof(DPCREDENTIALS));


	if (security){
		
		//if all members are NULL then replace with null pointer
		j=0;

		for (i=0;i<sizeof(DPSecurityDesc);i++){
			if (((char*)security)[i]==0) j++;
		}

				
		if (j!=sizeof(DPSecurityDesc)){


			dpSecurity.dwSize=sizeof(DPSECURITYDESC);
			l=0;l=wcslen(security->strSSPIProvider);
			if (l){
				dpSecurity.lpszSSPIProvider = SysAllocString(security->strSSPIProvider);				
			}	

			l=0;l=wcslen(security->strCAPIProvider);
			if (l){
				dpSecurity.lpszCAPIProvider = SysAllocString(security->strCAPIProvider);				
			}	
	
			lpSecurity=&dpSecurity;
		}
	}
	
	
	if (credentials){
		

		//if all members are NULL then replace with null pointer
		j=0;
		for (i=0;i<sizeof(DPCredentials);i++){
			if (((char*)credentials)[i]==0) j++;
		}

		if (j!=sizeof(DPCredentials)){
			
			dpCredentials.dwSize=sizeof(DPCREDENTIALS);


			l=0;l=wcslen(credentials->strUsername);
			if (l){
				//dpCredentials.lpszUsername = (LPWSTR)alloca(sizeof(WCHAR)*(l+1));
				//wcscpy(dpCredentials.lpszUsername , credentials->username);
				dpCredentials.lpszUsername=SysAllocString(credentials->strUsername);
			}	

			l=0;l=wcslen(credentials->strPassword);
			if (l){
				//dpCredentials.lpszPassword = (LPWSTR)alloca(sizeof(WCHAR)*(l+1));
				//wcscpy(dpCredentials.lpszPassword , credentials->password);
				dpCredentials.lpszPassword = SysAllocString(credentials->strPassword);
			}	

			l=0;l=wcslen(credentials->strDomain);
			if (l){
				//dpCredentials.lpszDomain = (LPWSTR)alloca(sizeof(WCHAR)*(l+1));
				//wcscpy(dpCredentials.lpszDomain , credentials->domain);
				dpCredentials.lpszDomain = SysAllocString(credentials->strDomain);
			}	

			lpSecurity=&dpSecurity;
		}
	}
	
	desc->AddRef();
	desc->getData(&dpSessionDesc);

	HRESULT hr = m__dxj_DirectPlay4->SecureOpen(&dpSessionDesc,(DWORD)flags,
			lpSecurity,	lpCredentials);

	desc->Release();

	if (dpCredentials.lpszDomain)	SysFreeString(dpCredentials.lpszDomain);
	if (dpCredentials.lpszPassword) SysFreeString(dpCredentials.lpszPassword);
	if (dpCredentials.lpszUsername)	SysFreeString(dpCredentials.lpszUsername);	
	if (dpSecurity.lpszSSPIProvider)SysFreeString(dpSecurity.lpszSSPIProvider);
	if (dpSecurity.lpszCAPIProvider)SysFreeString(dpSecurity.lpszCAPIProvider);

	return hr;
	
}

STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerFlags(Dpid id, long *ret){
	HRESULT hr = m__dxj_DirectPlay4->GetPlayerFlags((DPID)id,(DWORD*)ret);
	return hr;		
}

STDMETHODIMP C_dxj_DirectPlay4Object::getGroupFlags(Dpid id, long *ret){
	HRESULT hr = m__dxj_DirectPlay4->GetGroupFlags((DPID)id,(DWORD*)ret);
	return hr;		
}

STDMETHODIMP C_dxj_DirectPlay4Object::getGroupParent(Dpid id, long *ret){
	HRESULT hr = m__dxj_DirectPlay4->GetGroupParent((DPID)id,(DPID*)ret);
	return hr;		
}

STDMETHODIMP C_dxj_DirectPlay4Object::deleteGroupFromGroup(Dpid id, Dpid id2){
	HRESULT hr = m__dxj_DirectPlay4->DeleteGroupFromGroup((DPID)id,(DPID)id2);
	return hr;		
}

STDMETHODIMP C_dxj_DirectPlay4Object::addGroupToGroup(Dpid id, Dpid id2){
	HRESULT hr = m__dxj_DirectPlay4->AddGroupToGroup((DPID)id,(DPID)id2);
	return hr;		
}



STDMETHODIMP C_dxj_DirectPlay4Object::getPlayerAccountId(Dpid id, BSTR *ret){
	LPDPACCOUNTDESC pdesc;
	HRESULT hr;
	DWORD size=0;

	hr=m__dxj_DirectPlay4->GetPlayerAccount((DPID)id,0,NULL,&size);

	if (size==0) return E_FAIL;

	pdesc=(LPDPACCOUNTDESC)malloc(size);
	if (!pdesc) return E_OUTOFMEMORY;	

	hr=m__dxj_DirectPlay4->GetPlayerAccount((DPID)id,0,(void*)pdesc,&size);
	if FAILED(hr) {
		free(pdesc);
		return hr;
	}
	*ret=SysAllocString(pdesc->lpszAccountID);

	return S_OK;
}


STDMETHODIMP C_dxj_DirectPlay4Object::initializeConnection(I_dxj_DPAddress *con//,long flags
														   )
{
	DWORD size;
	void *pData;
	if (!con) return E_INVALIDARG;

	con->getAddress((long*)&pData,(long*)&size);
	HRESULT hr=m__dxj_DirectPlay4->InitializeConnection(pData,(DWORD)0);
	return hr;
	
}


STDMETHODIMP C_dxj_DirectPlay4Object::createGroupInGroup(Dpid id,BSTR longName,BSTR shortName,long flags, Dpid *retval){

	DPNAME dpName;
	DWORD  l1=0;
	DWORD  l2=0;

	ZeroMemory(&dpName,sizeof(DPNAME));
	dpName.dwSize=sizeof(DPNAME);

	if (shortName){
		l1=wcslen(shortName);
		if (l1>0){
			dpName.lpszShortName = (LPWSTR)alloca(sizeof(WCHAR)*(l1+1));
			wcscpy(dpName.lpszShortName, shortName);
		}
	}

	if (longName){
		l2=0;l2=wcslen(longName);
		if (l2>0){
			dpName.lpszLongName = (LPWSTR)alloca(sizeof(WCHAR)*(l2+1));
			wcscpy(dpName.lpszLongName, longName);
		}
	}
	
	DPID ret;
	HRESULT hr;

	if ((l1==0)&&(l2==0)){
		hr=m__dxj_DirectPlay4->CreateGroupInGroup((DPID)id,&ret,NULL,NULL,0,(DWORD)flags);
	}
	else {
		hr=m__dxj_DirectPlay4->CreateGroupInGroup((DPID)id,&ret,&dpName,NULL,0,(DWORD)flags);
	}

	*retval=(Dpid)ret;
	return hr;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlay4Object::getDPEnumConnections(	
		BSTR strGuid,
		long flags, 
		I_dxj_DPEnumConnections **retVal){
		HRESULT hr=C_dxj_DPEnumConnectionsObject::create(m__dxj_DirectPlay4,strGuid,flags,retVal);
		return hr;
}



STDMETHODIMP C_dxj_DirectPlay4Object::getMessageQueue( 
		/* [in] */ long from,
		/* [in] */ long to,
		 long flags,
		 long *nMessages,
		 long *nBytes)
{
	return m__dxj_DirectPlay4->GetMessageQueue((DPID)from,(DPID)to,(DWORD)flags,(DWORD*)nMessages,(DWORD*)nBytes);

}

STDMETHODIMP C_dxj_DirectPlay4Object::getGroupOwner( 
		/* [in] */ long groupId,
		/* [retval][out] */ long __RPC_FAR *ret)
{
	return m__dxj_DirectPlay4->GetGroupOwner((DWORD)groupId,(DWORD*)ret);
}


STDMETHODIMP C_dxj_DirectPlay4Object::cancelPriority( 
	 long minPriority,
	 long maxPriority
//	 long flags
	)
{
	return m__dxj_DirectPlay4->CancelPriority((DWORD)minPriority,(DWORD)maxPriority,(DWORD) 0);

}
	

STDMETHODIMP C_dxj_DirectPlay4Object::cancelMessage( 
		/* [in] */ long msgid
		///* [in] */ long flags
		)
{
	return m__dxj_DirectPlay4->CancelMessage((DWORD)msgid,(DWORD)0);

}
	

STDMETHODIMP C_dxj_DirectPlay4Object::setGroupOwner( 
		/* [in] */ long groupId,
		/* [in] */ long ownerId)
{
	return m__dxj_DirectPlay4->SetGroupOwner((DWORD)groupId,(DWORD)ownerId);

}

STDMETHODIMP C_dxj_DirectPlay4Object::sendEx( 
            /* [in] */ long fromPlayerId,
            /* [in] */ long toPlayerId,
            /* [in] */ long flags,
            /* [in] */ I_dxj_DirectPlayMessage *msg,            
            /* [in] */ long priority,
            /* [in] */ long timeout,
            /* [in] */ long context,
            /* [retval][out] */ long  *messageid)
{



	
	HRESULT hr;	
	void *pdata=NULL;
	DWORD dataSize=0;
	
	if (!msg) return E_INVALIDARG;

	__try {
		msg->getPointer((long*)&pdata);
		msg->getMessageSize((long*)&dataSize);
		hr= m__dxj_DirectPlay4->SendEx((DPID)fromPlayerId, (DPID)toPlayerId, (DWORD)flags, 
			(void*)pdata, (DWORD) dataSize,	
				    (DWORD) priority,
					(DWORD) timeout,
					(void*) context,
					(DWORD_PTR*) messageid);	//bugbug SUNDOWN
	}
	__except (1,1)
	{
		return E_INVALIDARG;	
	}

	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::createSessionData(  I_dxj_DirectPlaySessionData __RPC_FAR *__RPC_FAR *sessionDesc)
{
	HRESULT hr;
	hr=C_dxj_DirectPlaySessionDataObject::create((DPSESSIONDESC2*)NULL,sessionDesc);
	return hr;
}

STDMETHODIMP C_dxj_DirectPlay4Object::createMessage(  I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	hr= C_dxj_DirectPlayMessageObject::create(1,0,NULL,ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dplaylobby3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dplaylobby3obj.cpp
//
//--------------------------------------------------------------------------

// _dxj_DirectPlayLobbyObj.cp\p : Implementation of C_dxj_DirectPlayLobbyObject
// DHF begin - entire file

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dplay.h"
#include "dplobby.h"
#include "dxglob7obj.h"

#include "dPlayLobby3Obj.h"
#include "dPlay4Obj.h"
#include "DPAddressObj.h"
#include "DPLConnectionObj.h"
#include "DPEnumLocalApplications.h"
//#include "dpEnumAddressObj.h"
//#include "dpEnumAddressTypesObj.h"
#include "dpmsgObj.h"
#include "string.h"

typedef HRESULT (__stdcall *DIRECTPLAYLOBBYCREATE)(LPGUID, LPDIRECTPLAYLOBBY *, IUnknown *, LPVOID, DWORD );
extern DIRECTPLAYLOBBYCREATE pDirectPlayLobbyCreate;
typedef HRESULT (__stdcall *DIRECTPLAYENUMERATE)( LPDPENUMDPCALLBACK, LPVOID );
extern DIRECTPLAYENUMERATE pDirectPlayEnumerate;
extern HRESULT BSTRtoPPGUID(LPGUID*,BSTR);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern void *g_dxj_DirectPlay4;
extern HINSTANCE g_hDPlay;


BSTR DPLGUIDtoBSTR(LPGUID pGuid);
HRESULT DPLBSTRtoGUID(LPGUID pGuid,BSTR str);

C_dxj_DirectPlayLobby3Object::C_dxj_DirectPlayLobby3Object()
{
	m__dxj_DirectPlayLobby3 = NULL;	
	#pragma message("DirectPlayLobby3 should be in object list")
}


C_dxj_DirectPlayLobby3Object::~C_dxj_DirectPlayLobby3Object()
{
	
	if(m__dxj_DirectPlayLobby3)
	{
		m__dxj_DirectPlayLobby3->Release();
		m__dxj_DirectPlayLobby3 = NULL;
	}	
}

GETSET_OBJECT(_dxj_DirectPlayLobby3);


//
/*** I_dxj_DirectPlayLobby methods ***/
//

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::connect(long flags, I_dxj_DirectPlay4 **val)
{
	LPDIRECTPLAY2	dp=NULL;
	LPDIRECTPLAY4	dp4=NULL;
	HRESULT hr;
	
	hr= m__dxj_DirectPlayLobby3->Connect((DWORD) flags, &dp, NULL);
	if FAILED(hr) return hr;

	hr= dp->QueryInterface(IID_IDirectPlay4,(void**)&dp4);
	
	dp->Release();
	
	if FAILED(hr) return hr;

		
	INTERNAL_CREATE(_dxj_DirectPlay4, dp4, val)

	return hr;
}


//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::getConnectionSettings( 
            /* [in] */ long AppID,
            /* [out]*/ I_dxj_DPLConnection **con){

	DWORD dataSize = 0;
	LPVOID data;
	HRESULT hr;
	
	if (!con) return E_INVALIDARG;

	hr= m__dxj_DirectPlayLobby3->GetConnectionSettings((DWORD)AppID, NULL, &dataSize);	
	
	//fix for bug 23385
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;	
	*con=NULL;

	//Andrewke-
	//we now pass pack null if there are no connection settings.
	//will this ever happen?
	if (dataSize==0) return S_OK;	

	data = alloca(dataSize);
	hr = m__dxj_DirectPlayLobby3->GetConnectionSettings((DWORD)AppID, (LPVOID)data, &dataSize);

	if FAILED(hr){		
		return E_OUTOFMEMORY;
	}

	I_dxj_DPLConnection *dplConnection=NULL;
	INTERNAL_CREATE_STRUCT(_dxj_DPLConnection,(&dplConnection));
	if (dplConnection==NULL){
		return E_OUTOFMEMORY;
	}

	hr=dplConnection->setConnectionStruct((long)PtrToLong(data)); //NOTE SUNDOWN issue
	if FAILED(hr){
		return hr;
	}
	
	*con=dplConnection;

	return S_OK;
}



//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::receiveLobbyMessage( 
        /* [in] */ long appID,
        /* [out] */ long *messageFlags,
        /* [out] */ I_dxj_DirectPlayMessage **msg)
{



	HRESULT hr;
	DWORD dwSize=0;
    void  *pData=NULL;
	BOOL  fCont=TRUE;
	
	if (!msg) return E_INVALIDARG;
	if (!messageFlags) return E_INVALIDARG;
	
		
	hr= m__dxj_DirectPlayLobby3->ReceiveLobbyMessage (0,
											appID,
											(DWORD*)messageFlags,
											(void*)NULL,
											(LPDWORD)&dwSize);

	if 	(hr == DPERR_NOMESSAGES ) {
			*msg=NULL;
			return S_OK;
	}
	
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;
	

	hr=C_dxj_DirectPlayMessageObject::create((DWORD)0,dwSize,&pData,msg);
	if FAILED(hr) return hr;
		

	hr= m__dxj_DirectPlayLobby3->ReceiveLobbyMessage (0,
											appID,
											(DWORD*)messageFlags,
											(void*)pData,
											(LPDWORD)&dwSize);

			
	if 	FAILED(hr) {
		if (*msg) (*msg)->Release();

		*msg=NULL;
		return hr;
	}
	
	return hr;


}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::receiveLobbyMessageSize( 
        /* [in] */ long appID,
        /* [out] */ long *messageFlags,
        /* [out] */ long __RPC_FAR *dataSize)
{
	*dataSize = 0;
	HRESULT hr = m__dxj_DirectPlayLobby3->ReceiveLobbyMessage (0,
											appID,
											(DWORD*)messageFlags,
											NULL,
											(LPDWORD)dataSize);
	if (hr==DPERR_BUFFERTOOSMALL) hr=S_OK;
	return hr;
}

//////////////////////////////////////////////////////////////////////////
// Launch a DirectPlay application.
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::runApplication(			
			I_dxj_DPLConnection *conn,														 
            long  hReceiveEvent	,
			long  *appId
			) 
{
	if (!appId) return E_INVALIDARG;
	if (!conn) return E_INVALIDARG;

	void *lpConnection=NULL;
	HRESULT hr;

	*appId=0;
	hr=conn->getConnectionStruct((long*)&lpConnection);
	if FAILED(hr) return hr;

	hr = m__dxj_DirectPlayLobby3->RunApplication (0,
								(DWORD*)appId,
								(DPLCONNECTION*)lpConnection,
								(void*)hReceiveEvent);
	

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::sendLobbyMessage( 
		/* [in] */ long flags,															
        /* [in] */ long appID,
        /* [in] */ I_dxj_DirectPlayMessage *msg)
{
	//if (!ISSAFEARRAY1D(ppData,(DWORD)dataSize)) return E_INVALIDARG;

	HRESULT hr;
	if (!msg) return E_INVALIDARG;
	void *pData=NULL;
	DWORD dataSize=0;

	msg->AddRef();
	msg->getPointer((long*)&pData);
	msg->getMessageSize((long*)&dataSize);
	
	__try {
		hr = m__dxj_DirectPlayLobby3->SendLobbyMessage ((DWORD)flags,
											(DWORD)appID,
											pData,
											(DWORD)dataSize);
	}
	__except(1,1){
		msg->Release();
		return E_INVALIDARG;
	}
	
	msg->Release();
	return hr;
}
 
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::setConnectionSettings ( long appID, I_dxj_DPLConnection *con)
{
	void *lpConnection=NULL;
	HRESULT hr;

	if (!con) return E_INVALIDARG;

	hr=con->getConnectionStruct((long*)&lpConnection);
	if FAILED(hr) return hr;


	hr = m__dxj_DirectPlayLobby3->SetConnectionSettings (0,
											(DWORD)appID,
											(DPLCONNECTION*)lpConnection);
	return hr;
}

//////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectPlayLobby3Object::setLobbyMessageEvent( 
            /* [in] */ long appId,
            /* [in] */ long hReceiveEvent)
{
	HRESULT hr = m__dxj_DirectPlayLobby3->SetLobbyMessageEvent(0, (long)appId, (HANDLE)hReceiveEvent);
	return hr;
}




        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::getDPEnumLocalApplications( 
            ///* [in] */ long flags,
            /* [retval][out] */ I_dxj_DPEnumLocalApplications __RPC_FAR *__RPC_FAR *retVal)
{
	HRESULT hr;
	hr=C_dxj_DPEnumLocalApplicationsObject::create(m__dxj_DirectPlayLobby3,0,retVal);
	return hr;
}


STDMETHODIMP C_dxj_DirectPlayLobby3Object::waitForConnectionSettings( 
            /* [in] */ long flags)
{
	HRESULT hr = m__dxj_DirectPlayLobby3->WaitForConnectionSettings((DWORD)flags);
	return hr;
}


STDMETHODIMP C_dxj_DirectPlayLobby3Object::unregisterApplication(// long flags,
																 BSTR guid)
{
	GUID g;	
	HRESULT hr;

	hr=DPLBSTRtoGUID(&g,guid);	
	if FAILED(hr) return E_INVALIDARG;

	hr =m__dxj_DirectPlayLobby3->UnregisterApplication((DWORD) 0, g);

	return hr;
}


STDMETHODIMP C_dxj_DirectPlayLobby3Object::registerApplication(// long flags, 
															   DpApplicationDesc2 *appDesc)
{
	HRESULT hr;
	DPAPPLICATIONDESC2 desc;

	if (!appDesc->strGuid) return E_INVALIDARG;

	ZeroMemory(&desc,sizeof(DPAPPLICATIONDESC2));
	desc.dwSize=sizeof(DPAPPLICATIONDESC2);
	desc.dwFlags=(DWORD)appDesc->lFlags;
	desc.lpszApplicationName=appDesc->strApplicationName;
	desc.lpszFilename=appDesc->strFilename;
	desc.lpszCommandLine=appDesc->strCommandLine;
	desc.lpszPath=appDesc->strPath;
	desc.lpszCurrentDirectory=appDesc->strCurrentDirectory;
	desc.lpszDescriptionW=appDesc->strDescription;
	desc.lpszAppLauncherName=appDesc->strAppLauncherName;
	
	hr=DPLBSTRtoGUID(&desc.guidApplication,appDesc->strGuid);
	if FAILED(hr) return E_INVALIDARG;
		
	hr =m__dxj_DirectPlayLobby3->RegisterApplication((DWORD) 0, &desc);

	return hr;
}



STDMETHODIMP C_dxj_DirectPlayLobby3Object::createConnectionData(  I_dxj_DPLConnection __RPC_FAR *__RPC_FAR *ret)
{ 
	
	INTERNAL_CREATE_STRUCT(_dxj_DPLConnection,ret);		
	return S_OK;
}

STDMETHODIMP C_dxj_DirectPlayLobby3Object::createMessage(  I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	hr= C_dxj_DirectPlayMessageObject::create(1,0,NULL,ret);
	return hr;
}



//CONSIDER - why pass int - more appopriate to pass in short
STDMETHODIMP C_dxj_DirectPlayLobby3Object::createINetAddress( 
            /* [in] */ BSTR addr,
            /* [in] */ int port,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	DPCOMPOUNDADDRESSELEMENT elem[3];
	DWORD dwSize=0;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;
	WORD wport=(WORD)port;
	DWORD dwElements=2;

	if (!addr) return E_INVALIDARG;

	elem[0].guidDataType=DPAID_ServiceProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &DPSPGUID_TCPIP;

	elem[1].guidDataType=DPAID_INetW;
	elem[1].dwDataSize =SysStringByteLen(addr)+sizeof(WCHAR);
	elem[1].lpData = (void*) addr;

	elem[2].guidDataType=DPAID_INetPort;
	elem[2].dwDataSize =sizeof(WORD);
	elem[2].lpData = &wport;

	if (port)  dwElements=3;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,dwElements,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,dwElements,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize); //NOTE SUNDOWN issue need to use PtrToLong
	free(pAddress);

	*ret=pDPAddress;		

	return hr;
}
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::createComPortAddress( 
            /* [in] */ long port,
            /* [in] */ long baudRate,
            /* [in] */ long stopBits,
            /* [in] */ long parity,
            /* [in] */ long flowcontrol,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	DPCOMPORTADDRESS cpa;

	cpa.dwBaudRate =(DWORD)baudRate;
	cpa.dwComPort =(DWORD)port;
	cpa.dwFlowControl =(DWORD)flowcontrol;
	cpa.dwStopBits =(DWORD)stopBits;
	cpa.dwParity =(DWORD)parity;
	
	DPCOMPOUNDADDRESSELEMENT elem[2];
	DWORD dwSize=0;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;

	

	elem[0].guidDataType=DPAID_ServiceProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &DPSPGUID_SERIAL;					

	elem[1].guidDataType=DPAID_ComPort;
	elem[1].dwDataSize =sizeof(DPCOMPORTADDRESS);
	elem[1].lpData = (void*) &cpa;


	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,2,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,2,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize); //NOTE SUNDOWN issue
	free(pAddress);

	*ret=pDPAddress;		

	return hr;
}

STDMETHODIMP C_dxj_DirectPlayLobby3Object::createLobbyProviderAddress( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	
	DPCOMPOUNDADDRESSELEMENT elem[2];
	DWORD dwSize=0;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;
	GUID lobbyGuid;

	

	if (!guid) return E_INVALIDARG;

	hr=DPLBSTRtoGUID(&lobbyGuid,guid);
	if FAILED(hr) return E_INVALIDARG;


	
	elem[0].guidDataType=DPAID_LobbyProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &lobbyGuid;


	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize); //NOTE SUNDOWN
	free(pAddress);

	*ret=pDPAddress;		

	return hr;

}
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::createServiceProviderAddress( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	DPCOMPOUNDADDRESSELEMENT elem[1];
	DWORD dwSize=0;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;
	GUID SPGuid;

	
	if (!guid) return E_INVALIDARG;

	hr=DPLBSTRtoGUID(&SPGuid,guid);
	if FAILED(hr) return E_INVALIDARG;


	elem[0].guidDataType=DPAID_ServiceProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &SPGuid;


	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize);	//NOTE SUNDOWN
	free(pAddress);

	*ret=pDPAddress;		

	return hr;
}
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::createModemAddress( 
            /* [in] */ BSTR modem,
            /* [in] */ BSTR phone,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	DPCOMPOUNDADDRESSELEMENT elem[3];
	DWORD dwSize=0;
	DWORD i =1;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;
	
	
	if (!phone) return E_INVALIDARG;
	if (!modem) return E_INVALIDARG;

	


	elem[0].guidDataType=DPAID_ServiceProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &DPSPGUID_MODEM;					

	if (modem[0]!=0) {

		elem[i].guidDataType=DPAID_ModemW;
		elem[i].dwDataSize =SysStringByteLen(modem)+sizeof(WCHAR);
		elem[i].lpData = (void*) modem;	
		i++;
	}
	if (phone[0]!=0) {

	    elem[i].guidDataType=DPAID_PhoneW;
	    elem[i].dwDataSize =SysStringByteLen(phone)+sizeof(WCHAR);
	    elem[i].lpData = (void*) phone;
        i++;
    }
	

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,i,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,i,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize);	//NOTE SUNDOWN
	free(pAddress);

	*ret=pDPAddress;		

	return hr;
}


STDMETHODIMP C_dxj_DirectPlayLobby3Object::createIPXAddress(             
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	DPCOMPOUNDADDRESSELEMENT elem[1];
	DWORD dwSize=0;
	LPVOID pAddress=NULL;
	HRESULT hr;
	I_dxj_DPAddress *pDPAddress= NULL;
	GUID SPGuid=DPSPGUID_IPX;

	elem[0].guidDataType=DPAID_ServiceProvider;
	elem[0].dwDataSize =sizeof(GUID);
	elem[0].lpData = (void*) &SPGuid;


	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,NULL,&dwSize);
	if (hr!=DPERR_BUFFERTOOSMALL) return hr;

			
	pAddress=malloc(dwSize);
	if (!pAddress) return E_OUTOFMEMORY;

	hr=m__dxj_DirectPlayLobby3->CreateCompoundAddress(elem,1,pAddress,&dwSize);
	if FAILED(hr) {
		free(pAddress);				
		return hr;
	}

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,(&pDPAddress));
	if (pDPAddress==NULL) {
		free(pAddress);			
		return E_OUTOFMEMORY;
	}

	pDPAddress->setAddress((long)PtrToLong(pAddress),(long)dwSize); //NOTE SUNDOWN
	free(pAddress);

	*ret=pDPAddress;		

	return hr;
}
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::createCustomAddress( 
            /* [in] */ long size,
            /* [in] */ void __RPC_FAR *data,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret)
{
	return E_NOTIMPL;
}

 
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::getModemName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR *name)
{

		USES_CONVERSION;

		LPDIRECTPLAY4	dp=NULL;
    	LPDIRECTPLAY	lpDP=NULL;
    	GUID			guid=DPSPGUID_MODEM;
		HRESULT			hr;
		DIRECTPLAYCREATE pDirectPlayCreate = NULL;
		DWORD dwSize=0;
		DWORD	dwAt=0;
		void *pData=NULL;
		LPWSTR pszwName=NULL;
		char	*szLast=NULL;

		DWORD		dwCount;
		DWORD		i;
		BOOL	bZero;

		pDirectPlayCreate=(DIRECTPLAYCREATE)GetProcAddress( g_hDPlay, "DirectPlayCreate" );        
    	if (pDirectPlayCreate == NULL )	return E_NOINTERFACE;
    
    

    	// create a DirectPlay1 interface
    	hr = (pDirectPlayCreate)(&guid, &lpDP, NULL);
    	if FAILED(hr) goto cleanup;
	  	
    
    	// now get Dplay4 interface
    	hr = lpDP->QueryInterface(IID_IDirectPlay4,(LPVOID *)&dp);				
    	lpDP->Release(); lpDP=NULL;
  		if FAILED(hr) goto cleanup;
  						



		hr=dp->GetPlayerAddress(0,NULL,&dwSize);
		if (dwSize<=0) {
			hr=E_INVALIDARG;
			goto cleanup;
		}

		pData=malloc(dwSize);
		if (!pData){			
			hr= E_OUTOFMEMORY;
			goto cleanup;
		}	

		hr=dp->GetPlayerAddress(0,pData,&dwSize);
		if FAILED(hr) goto cleanup;
		
		if (dwSize<=80) {
			hr=E_INVALIDARG;
			goto cleanup;
		}

		//Get String count
		
		bZero=FALSE;
		dwCount=0;
		for( i=80;i<dwSize;i++){
			if (((char*)pData)[i]==0){
				if (bZero) break;
				dwCount++;				
				bZero=TRUE;
			}
			else {
				bZero=FALSE;
			}			
		}
		
		if (((DWORD)index > dwCount) || (index <=0)){
			hr=E_INVALIDARG;
			goto cleanup;
		}

		szLast=& (((char*)pData)[80]);		

		dwAt=0;
		for	( i=80;i<dwSize;i++){
			if (((char*)pData)[i]==0){													
				if ((DWORD)(index-1)==dwAt) break;
				dwAt++;							
				szLast=&( ( (char*)pData)[i+1]);				
			}			
		}
		
		if (i>dwSize) { 
			hr=E_INVALIDARG;
			goto cleanup;
		}

	
		pszwName = T2W(szLast);	
		*name=SysAllocString(pszwName);
		


cleanup:
		if (pData) 	free(pData);
		if (dp) dp->Release();
		
		return hr;
}
        
STDMETHODIMP C_dxj_DirectPlayLobby3Object::getModemCount( 
            /* [retval][out] */ long __RPC_FAR *count)
{

		LPDIRECTPLAY4	dp=NULL;
    	LPDIRECTPLAY	lpDP=NULL;
    	GUID			guid=DPSPGUID_MODEM;
		HRESULT			hr;
		DIRECTPLAYCREATE pDirectPlayCreate = NULL;
		DWORD dwSize=0;
		
		void *pData=NULL;		
		DWORD		dwCount;
		DWORD		i;
		BOOL		bZero;

		if (!count) return E_INVALIDARG;


		pDirectPlayCreate=(DIRECTPLAYCREATE)GetProcAddress( g_hDPlay, "DirectPlayCreate" );        
    	if (pDirectPlayCreate == NULL )	return E_NOINTERFACE;
    
    

    	// create a DirectPlay1 interface
    	hr = (pDirectPlayCreate)(&guid, &lpDP, NULL);
		if (hr==DPERR_UNAVAILABLE) {		          
			hr = S_OK;
			*count=0;
			goto cleanup;
		}
		if FAILED(hr) goto cleanup;
	  	
    
    	// now get Dplay4 interface
    	hr = lpDP->QueryInterface(IID_IDirectPlay4,(LPVOID *)&dp);				
    	lpDP->Release(); lpDP=NULL;
  		if FAILED(hr) goto cleanup;
  						



		hr=dp->GetPlayerAddress(0,NULL,&dwSize);
		if (dwSize<=0) {
			hr=E_INVALIDARG;
			goto cleanup;
		}

		pData=malloc(dwSize);
		if (!pData){			
			hr= E_OUTOFMEMORY;
			goto cleanup;
		}	

		hr=dp->GetPlayerAddress(0,pData,&dwSize);
		if (hr==DPERR_UNAVAILABLE) {		          
			hr = S_OK;
			*count=0;
			goto cleanup;
		}
		if FAILED(hr) goto cleanup;
		
		if (dwSize<=80) {
			hr=E_INVALIDARG;
			goto cleanup;
		}

		//Get String count
		
		bZero=FALSE;
		dwCount=0;
		for( i=80;i<dwSize;i++){
			if (((char*)pData)[i]==0){
				if (bZero) break;
				dwCount++;				
				bZero=TRUE;
			}
			else {
				bZero=FALSE;
			}			
		}
		*count=(long)dwCount;

cleanup:
		if (pData) 	free(pData);
		if (dp) dp->Release();
		
		return hr;
}
        


	
#define GUIDS_EQUAL(g2,g) (\
	(g.Data1==g2->Data1) && \
	(g.Data2==g2->Data2) && \
	(g.Data3==g2->Data3) && \
	(g.Data4[0]==g2->Data4[0]) && \
	(g.Data4[1]==g2->Data4[1]) && \
	(g.Data4[2]==g2->Data4[2]) && \
	(g.Data4[3]==g2->Data4[3]) && \
	(g.Data4[4]==g2->Data4[4]) && \
	(g.Data4[5]==g2->Data4[5]) && \
	(g.Data4[6]==g2->Data4[6]) && \
	(g.Data4[7]==g2->Data4[7]) )




HRESULT DPLBSTRtoGUID(LPGUID pGuid,BSTR str)
{

	HRESULT hr;
	if( 0==_wcsicmp(str,L"dpaid_comport")){
		memcpy(pGuid,&DPAID_ComPort,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_inet")){
		memcpy(pGuid,&DPAID_INet,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_inetport")){
		memcpy(pGuid,&DPAID_INetPort,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_lobbyprovider")){
		memcpy(pGuid,&DPAID_LobbyProvider,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_modem")){
		memcpy(pGuid,&DPAID_Modem,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_phone")){
		memcpy(pGuid,&DPAID_Phone,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_serviceprovider")){
		memcpy(pGuid,&DPAID_ServiceProvider,sizeof(GUID));
	}
	else if( 0==_wcsicmp(str,L"dpaid_totalsize")){
		memcpy(pGuid,&DPAID_TotalSize,sizeof(GUID));
	}	


	else if( 0==_wcsicmp(str,L"dpspguid_modem")){
		memcpy(pGuid,&DPSPGUID_MODEM,sizeof(GUID));
	}	
	else if( 0==_wcsicmp(str,L"dpspguid_ipx")){
		memcpy(pGuid,&DPSPGUID_IPX,sizeof(GUID));
	}	
	else if( 0==_wcsicmp(str,L"dpspguid_tcpip")){
		memcpy(pGuid,&DPSPGUID_TCPIP,sizeof(GUID));
	}	

	else if( 0==_wcsicmp(str,L"dpspguid_serial")){
		memcpy(pGuid,&DPSPGUID_SERIAL,sizeof(GUID));
	}	


	

	
	else { 
		hr=BSTRtoGUID(pGuid,str);
		return hr;
	}

	return S_OK;
}

HRESULT DPLBSTRtoPPGUID(LPGUID *ppGuid,BSTR str)
{
	if ((!str) || (str[0]==0)){
			ppGuid=NULL;
			return S_OK;
	}
	
	return DPLBSTRtoGUID(*ppGuid,str);
}


BSTR DPLGUIDtoBSTR(LPGUID pGuid)
{
	WCHAR *pOut=NULL;

	
	if( GUIDS_EQUAL(pGuid,DPAID_ComPort)){
		pOut=L"DPAID_ComPort";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_INet)){
		pOut=L"DPAID_INet";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_INetPort)){
		pOut=L"DPAID_INetPort";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_LobbyProvider)){
		pOut=L"DPAID_LobbyProvider";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_Modem)){
		pOut=L"DPAID_Modem";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_Phone)){
		pOut=L"DPAID_Phone";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_ServiceProvider)){
		pOut=L"DPAID_ServiceProvider";
	}
	else if( GUIDS_EQUAL(pGuid,DPAID_TotalSize)){
		pOut=L"DPAID_TotalSize";
	}	
	else if( GUIDS_EQUAL(pGuid,DPSPGUID_MODEM)){
		pOut=L"DPSPGUID_MODEM";
	}
	else if( GUIDS_EQUAL(pGuid,DPSPGUID_IPX)){
		pOut=L"DPSPGUID_IPX";
	}
	else if( GUIDS_EQUAL(pGuid,DPSPGUID_TCPIP)){
		pOut=L"DPSPGUID_TCPIP";
	}
	else if( GUIDS_EQUAL(pGuid,DPSPGUID_SERIAL)){
		pOut=L"DPSPGUID_SERIAL";
	}

	
	
	
	
	if (pOut) {
		return SysAllocString(pOut);	
	}
	else {
		return GUIDtoBSTR(pGuid);
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dplconnection.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dplconnection.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_DPLConnectionObject :
		public IDPLConnection,
		public CComCoClass<C_DPLConnectionObject, &CLSID__DPLConnection>,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_DPLConnectionObject)
		COM_INTERFACE_ENTRY(IDPLConnection)
	END_COM_MAP()

	DECLARE_REGISTRY(CLSID__DPLConnection, "DIRECT.DPLConnection.5",		"DIRECT.DPLConnection.5",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)
	DECLARE_AGGREGATABLE(C_DPLConnectionObject)

public:
	C_DPLConnectionObject();
	~C_DPLConnectionObject();

         /* [hidden] */ HRESULT STDMETHODCALLTYPE getConnectionStruct( 
            /* [out] */ long __RPC_FAR *connect) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE setConnectionStruct( 
            /* [in] */ long connect) ;
        
         HRESULT STDMETHODCALLTYPE setFlags( 
            /* [in] */ long flags) ;
        
         HRESULT STDMETHODCALLTYPE getFlags( 
            /* [retval][out] */ long __RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE setSessionDesc( 
            /* [in] */ DPSessionDesc2 __RPC_FAR *sessionDesc) ;
        
         HRESULT STDMETHODCALLTYPE getSessionDesc( 
            /* [out] */ DPSessionDesc2 __RPC_FAR *sessionDesc) ;
        
         HRESULT STDMETHODCALLTYPE setGuidSP( 
            /* [in] */ DxGuid __RPC_FAR *guid) ;
        
         HRESULT STDMETHODCALLTYPE getGuidSP( 
            /* [out] */ DxGuid __RPC_FAR *guid) ;
        
         HRESULT STDMETHODCALLTYPE setAddress( 
            /* [in] */ IDPAddress __RPC_FAR *address) ;
        
         HRESULT STDMETHODCALLTYPE getAddress( 
            /* [retval][out] */ IDPAddress __RPC_FAR *__RPC_FAR *address) ;
        
         HRESULT STDMETHODCALLTYPE setPlayerShortName( 
            /* [in] */ BSTR name) ;
        
         HRESULT STDMETHODCALLTYPE getPlayerShortName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
        
         HRESULT STDMETHODCALLTYPE setPlayerLongName( 
            /* [in] */ BSTR name) ;
        
         HRESULT STDMETHODCALLTYPE getPlayerLongName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) ;
  

private:
	DPLCONNECTION m_connect;
	DPSESSIONDESC2 m_sessionDesc;
	DPNAME		  m_dpName;
	IUnknown	  *nextobj;
	DWORD		  creationid;
	void		  *m_pAddress;
	void cleanUp();
	void init();
	
};

extern IUnknown *g_DPLConnection;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dplaylobby3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dplaylobby3obj.h
//
//--------------------------------------------------------------------------

// _dxj_DirectPlayLobby3Obj.h : Declaration of the C_dxj_DirectPlayLobby3Object
// DHF begin - entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectPlayLobby3 LPDIRECTPLAYLOBBY3

/////////////////////////////////////////////////////////////////////////////
// DirectPlayLobby3

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayLobby3Object :
 
	public I_dxj_DirectPlayLobby3,

//	public CComCoClass<C_dxj_DirectPlayLobby3Object, &CLSID__dxj_DirectPlayLobby3>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectPlayLobby3Object() ;
	virtual ~C_dxj_DirectPlayLobby3Object() ;

BEGIN_COM_MAP(C_dxj_DirectPlayLobby3Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayLobby3)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectPlayLobby3,   "DIRECT.DirectPlayLobby3.5",	"DIRECT.DiectPlayLobby3.5",	IDS_DPLAYLOBBY_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectPlayLobby3Object) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectPlayLobby3Object)


public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
		/* [in] */ IUnknown __RPC_FAR *lpdd);

	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
		/* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

        HRESULT STDMETHODCALLTYPE connect( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DirectPlay4 __RPC_FAR *__RPC_FAR *directPlay);
        
//        HRESULT STDMETHODCALLTYPE createAddress( 
//            /* [in] */ BSTR spGuid,
//            /* [in] */ BSTR addressTypeGuid,
//            /* [in] */ BSTR addressString,
//            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
//        HRESULT STDMETHODCALLTYPE createCompoundAddress( 
//            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *elements,
//            /* [in] */ long elementCount,
//            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
//        HRESULT STDMETHODCALLTYPE getDPEnumAddress( 
//		    /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *addr,
//            /* [retval][out] */ I_dxj_DPEnumAddress __RPC_FAR *__RPC_FAR *retVal);
        
//        HRESULT STDMETHODCALLTYPE getDPEnumAddressTypes( 
//            /* [in] */ BSTR guid,
//              /* [retval][out] */ I_dxj_DPEnumAddressTypes __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDPEnumLocalApplications( 
            /* [retval][out] */ I_dxj_DPEnumLocalApplications __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getConnectionSettings( 
            /* [in] */ long applicationId,
            /* [retval][out] */ I_dxj_DPLConnection __RPC_FAR *__RPC_FAR *connection);
        
        HRESULT STDMETHODCALLTYPE receiveLobbyMessage( 
            /* [in] */ long applicationId,
            /* [out][in] */ long __RPC_FAR *messageFlags,
            /* [retval][out] */ I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *data);
        
        HRESULT STDMETHODCALLTYPE receiveLobbyMessageSize( 
            /* [in] */ long applicationId,
            /* [out][in] */ long __RPC_FAR *messageFlags,
            /* [retval][out] */ long __RPC_FAR *dataSize);
        
        HRESULT STDMETHODCALLTYPE runApplication(             
            /* [in] */ I_dxj_DPLConnection __RPC_FAR *connection,
            /* [in] */ long receiveEvent,
			/* [out,retval] */ long __RPC_FAR *applicationId
            );
        
        HRESULT STDMETHODCALLTYPE sendLobbyMessage( 
            /* [in] */ long flags,
            /* [in] */ long applicationId,
            /* [in] */ I_dxj_DirectPlayMessage __RPC_FAR *msg);
        
        HRESULT STDMETHODCALLTYPE setConnectionSettings( 
            /* [in] */ long applicationId,
            /* [in] */ I_dxj_DPLConnection __RPC_FAR *connection);
        
        HRESULT STDMETHODCALLTYPE setLobbyMessageEvent( 
            /* [in] */ long applicationId,
            /* [in] */ long receiveEvent);
        
        HRESULT STDMETHODCALLTYPE registerApplication( 
            /* [in] */ DpApplicationDesc2 __RPC_FAR *ApplicationInfo);
        
        HRESULT STDMETHODCALLTYPE unregisterApplication( 
            /* [in] */ BSTR guidApplication);
        
        HRESULT STDMETHODCALLTYPE waitForConnectionSettings( 
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE createMessage( 
            /* [retval][out] */ I_dxj_DirectPlayMessage __RPC_FAR *__RPC_FAR *msg);

		HRESULT STDMETHODCALLTYPE createConnectionData( 
            /* [retval][out] */ I_dxj_DPLConnection __RPC_FAR *__RPC_FAR *con);


         HRESULT STDMETHODCALLTYPE createINetAddress( 
            /* [in] */ BSTR addr,
            /* [in] */ int port,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE createComPortAddress( 
            /* [in] */ long port,
            /* [in] */ long baudRate,
            /* [in] */ long stopBits,
            /* [in] */ long parity,
            /* [in] */ long flowcontrol,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE createLobbyProviderAddress( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE createServiceProviderAddress( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE createModemAddress( 
            /* [in] */ BSTR modem,
            /* [in] */ BSTR phone,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);

         HRESULT STDMETHODCALLTYPE createIPXAddress( 
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
			
         HRESULT STDMETHODCALLTYPE createCustomAddress( 
            /* [in] */ long size,
            /* [in] */ void __RPC_FAR *data,
            /* [retval][out] */ I_dxj_DPAddress __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getModemName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR *name);
        
         HRESULT STDMETHODCALLTYPE getModemCount( 
            /* [retval][out] */ long __RPC_FAR *count);
        
	////////////////////////////////////////////////////////////////////////////////////
	//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayLobby3);
	
	DWORD m_modemIndex;
	BSTR  m_modemResult;

private:

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectPlayLobby3 )
};

//MUST DEFINE THIS IN DIRECT.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dplconnectionobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dplconnectionobj.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_dxj_DPLConnectionObject :
		public I_dxj_DPLConnection,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DPLConnectionObject)
		COM_INTERFACE_ENTRY(I_dxj_DPLConnection)
	END_COM_MAP()

//	DECLARE_REGISTRY(CLSID_DPLConnection, "DIRECT.DPLConnection.5",		"DIRECT.DPLConnection.5",		IDS_DPLAY2_DESC, THREADFLAGS_BOTH)
	DECLARE_AGGREGATABLE(C_dxj_DPLConnectionObject)

public:
	C_dxj_DPLConnectionObject();
	~C_dxj_DPLConnectionObject();

          HRESULT STDMETHODCALLTYPE getConnectionStruct( 
				 long  *connect) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE setConnectionStruct( 
            /* [in] */ long connect) ;
        
         HRESULT STDMETHODCALLTYPE setFlags( 
            /* [in] */ long flags) ;
        
         HRESULT STDMETHODCALLTYPE getFlags( 
            /* [retval][out] */ long  *ret) ;
        
         HRESULT STDMETHODCALLTYPE setSessionDesc( 
            /* [in] */ I_dxj_DirectPlaySessionData  *sessionDesc) ;
        
         HRESULT STDMETHODCALLTYPE getSessionDesc( 
            /* [out] */ I_dxj_DirectPlaySessionData  **sessionDesc) ;
        
         HRESULT STDMETHODCALLTYPE setGuidSP( 
            /* [in] */ BSTR  strGuid) ;
        
         HRESULT STDMETHODCALLTYPE getGuidSP( 
            /* [out] */ BSTR *strGuid) ;
        
         HRESULT STDMETHODCALLTYPE setAddress( 
            /* [in] */ I_dxj_DPAddress  *address) ;
        
         HRESULT STDMETHODCALLTYPE getAddress( 
            /* [retval][out] */ I_dxj_DPAddress  **address) ;
        
         HRESULT STDMETHODCALLTYPE setPlayerShortName( 
            /* [in] */ BSTR name) ;
        
         HRESULT STDMETHODCALLTYPE getPlayerShortName( 
            /* [retval][out] */ BSTR  *name) ;
        
         HRESULT STDMETHODCALLTYPE setPlayerLongName( 
            /* [in] */ BSTR name) ;
        
         HRESULT STDMETHODCALLTYPE getPlayerLongName( 
            /* [retval][out] */ BSTR  *name) ;
  

private:
	DPLCONNECTION m_connect;
	DPSESSIONDESC2 m_sessionDesc;
	DPNAME		  m_dpName;
	void		  *nextobj;
	int			  creationid;
	void		  *m_pAddress;
	void cleanUp();
	void init();
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dplconnectionobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dplconnectionobj.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dplConnectionObj.h"
#include "dpAddressObj.h"
#include "dpSessDataObj.h"

#pragma message ("Should INTERNAL_CREATE_STRUCT play with AddRef and refcount")

extern HRESULT FillRealSessionDesc(DPSESSIONDESC2 *dpSessionDesc,DPSessionDesc2 *sessionDesc);
extern void FillCoverSessionDesc(DPSessionDesc2 *sessionDesc, DPSESSIONDESC2 *dpSessionDesc);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLBSTRtoGUID(LPGUID,BSTR);
extern BSTR DPLGUIDtoBSTR(LPGUID);

CONSTRUCTOR_STRUCT(_dxj_DPLConnection, {init();})

//ANDREWKE - broke out for debuging
//DESTRUCTOR_STRUCT(_dxj_DPLConnection, {cleanUp();})
C_dxj_DPLConnectionObject::~C_dxj_DPLConnectionObject()
{

	C_dxj_DPLConnectionObject *prev=NULL; 
	for (
		C_dxj_DPLConnectionObject *ptr=(C_dxj_DPLConnectionObject *)g_dxj_DPLConnection; 
		ptr;
		ptr=(C_dxj_DPLConnectionObject *)ptr->nextobj
		) 
		{
			if(ptr == this) 	
			{ 
				if(prev) 
					prev->nextobj = ptr->nextobj; 
				else 
					g_dxj_DPLConnection = (void*)ptr->nextobj; 
				break;
			} 
			prev = ptr; 
		} 
	

	cleanUp();
}



void C_dxj_DPLConnectionObject::init() {
	ZeroMemory(&m_connect,sizeof(DPLCONNECTION));
	m_connect.dwSize=sizeof(DPLCONNECTION);
	ZeroMemory(&m_dpName,sizeof(DPNAME));		
	m_dpName.dwSize=sizeof(DPNAME);
	m_pAddress=NULL;	
	ZeroMemory(&m_sessionDesc,sizeof(DPSESSIONDESC2));
	
}

void C_dxj_DPLConnectionObject::cleanUp() {

	if (m_pAddress) free (m_pAddress);
	
	if (m_dpName.lpszShortName) SysFreeString(m_dpName.lpszShortName);
	if (m_dpName.lpszLongName) SysFreeString(m_dpName.lpszLongName);
	if (m_sessionDesc.lpszSessionName) SysFreeString(m_sessionDesc.lpszSessionName);
	if (m_sessionDesc.lpszPassword) SysFreeString(m_sessionDesc.lpszPassword);

}


HRESULT C_dxj_DPLConnectionObject::getConnectionStruct( long *pOut){
	//TODO this is haneous;
	*pOut=(long)&m_connect;	
	return S_OK;
}

//TODO consider - most of the time you are handed a buffer with
//all the necessary pointers in tact. why not copy the buffer
//as is? 
HRESULT C_dxj_DPLConnectionObject::setConnectionStruct( long pIn){
	DPLCONNECTION *pcon=(LPDPLCONNECTION)pIn;

	memcpy((void*)&m_connect,(void*)pcon,sizeof(DPLCONNECTION));
			
	ZeroMemory(&m_dpName,sizeof(DPNAME));
	ZeroMemory(&m_sessionDesc,sizeof(DPSESSIONDESC2));

	if (pcon->lpPlayerName){		
		
		//copy over the flags...
		memcpy ((void*)&m_dpName,(void*)pcon->lpPlayerName,sizeof(DPNAME));

		//copy over the names
		m_dpName.lpszShortName=SysAllocString(pcon->lpPlayerName->lpszShortName);
		m_dpName.lpszLongName=SysAllocString(pcon->lpPlayerName->lpszLongName);


	}
	if (pcon->lpSessionDesc){
		//copy over flags
		memcpy ((void*)&m_sessionDesc,(void*)pcon->lpSessionDesc,sizeof(DPSESSIONDESC2));

		if (m_sessionDesc.lpszSessionName) SysFreeString(m_sessionDesc.lpszSessionName);
		if (m_sessionDesc.lpszPassword)SysFreeString(m_sessionDesc.lpszPassword);
		m_sessionDesc.lpszSessionName=SysAllocString(pcon->lpSessionDesc->lpszSessionName);
		m_sessionDesc.lpszPassword=SysAllocString(pcon->lpSessionDesc->lpszPassword);		
	}

	if (pcon->lpAddress){
		if (m_pAddress)
			free(m_pAddress);
		m_pAddress=malloc(pcon->dwAddressSize);
		if (m_pAddress==NULL) 
			return E_OUTOFMEMORY;
		memcpy ((void*)m_pAddress,(void*)pcon->lpAddress,pcon->dwAddressSize);
	}
	
	
	return S_OK;
}



HRESULT C_dxj_DPLConnectionObject::setFlags(long flags){
	m_connect.dwFlags=(DWORD)flags;
	return S_OK;
}

HRESULT C_dxj_DPLConnectionObject::getFlags(long *flags){
	*flags=(long)m_connect.dwFlags;
	return S_OK;
}

HRESULT C_dxj_DPLConnectionObject::setSessionDesc(I_dxj_DirectPlaySessionData *desc){
	//FillRealSessionDesc(&m_sessionDesc,desc);	
	if (!desc) return E_INVALIDARG;
	desc->AddRef();
	desc->getData((long*)&m_sessionDesc);
	
	m_connect.lpSessionDesc=&m_sessionDesc;

	//we copy over the structure but we dont own the strings yet
	if (m_sessionDesc.lpszSessionName) SysFreeString(m_sessionDesc.lpszSessionName);
	if (m_sessionDesc.lpszPassword) SysFreeString(m_sessionDesc.lpszPassword);

	m_sessionDesc.lpszSessionName=SysAllocString(m_sessionDesc.lpszSessionName);
	m_sessionDesc.lpszPassword=SysAllocString(m_sessionDesc.lpszPassword);		

	desc->Release();

	return S_OK;
}

HRESULT C_dxj_DPLConnectionObject::getSessionDesc(I_dxj_DirectPlaySessionData **desc){
	//FillCoverSessionDesc(desc,&m_sessionDesc);	
	HRESULT hr;
	hr=C_dxj_DirectPlaySessionDataObject::create(&m_sessionDesc,desc);
	return hr;
}


HRESULT C_dxj_DPLConnectionObject::setGuidSP(BSTR strGuid){
	HRESULT hr=DPLBSTRtoGUID(&m_connect.guidSP,strGuid);
	return hr;
}

HRESULT C_dxj_DPLConnectionObject::getGuidSP(BSTR *strGuid){
	*strGuid=DPLGUIDtoBSTR(&m_connect.guidSP);	
	return S_OK;
}

         

        

HRESULT C_dxj_DPLConnectionObject::getPlayerShortName(BSTR *name){
	*name = SysAllocString(m_dpName.lpszShortName);	
	return S_OK;
}
HRESULT C_dxj_DPLConnectionObject::getPlayerLongName(BSTR *name){
	*name = SysAllocString(m_dpName.lpszLongName);	
	return S_OK;
}

HRESULT C_dxj_DPLConnectionObject::setPlayerShortName(BSTR name){
	
	if (m_dpName.lpszShortName) SysFreeString (m_dpName.lpszShortName);
	m_dpName.lpszShortName=NULL;

	if (!name) return S_OK;
		
	m_dpName.lpszShortName = SysAllocString(name);
	
	m_connect.lpPlayerName=&m_dpName;
	return S_OK;


}

HRESULT C_dxj_DPLConnectionObject::setPlayerLongName(BSTR name){
	
	if (m_dpName.lpszLongName) SysFreeString (m_dpName.lpszLongName);
	m_dpName.lpszLongName=NULL;
	
	if (!name) return S_OK;
	

	
	m_dpName.lpszLongName =SysAllocString(name);
	
	m_connect.lpPlayerName=&m_dpName;
	return S_OK;
}


HRESULT C_dxj_DPLConnectionObject::getAddress(I_dxj_DPAddress **pRetAddress){
	

	HRESULT hr;

	INTERNAL_CREATE_STRUCT(_dxj_DPAddress,pRetAddress);
	
	if (*pRetAddress==NULL) return E_OUTOFMEMORY;

	hr=(*pRetAddress)->setAddress((long)m_connect.lpAddress,m_connect.dwAddressSize);
	
	//ASSERT(SUCCESS(hr),"setAddress C_dxj_DPLConnectionObject::getAddress)

	if FAILED(hr) return hr;

	return S_OK;
}

HRESULT C_dxj_DPLConnectionObject::setAddress(I_dxj_DPAddress *address){
	
	DWORD length=0;
	Byte  *pAddress=NULL;

	//BUGFIX for MANBUG28198	2/2/00	ANDREWKE
	if (!address) return E_INVALIDARG;	

	//NOTE: TODO make this cleaner
	address->getAddress((long*)&pAddress,(long*)&length);

	if (m_pAddress) free (m_pAddress);
	m_pAddress=NULL;
	m_pAddress=malloc((DWORD)length);
	if (m_pAddress==NULL) return E_OUTOFMEMORY;

	#pragma message ("Write ASSERT macro")
	if (pAddress==NULL) return E_FAIL;	
	memcpy((void*)m_pAddress,(void*)pAddress,length);
	
	m_connect.lpAddress=m_pAddress;
	m_connect.dwAddressSize=length;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpsessdataobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpsessdataobj.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dpSessDataObj.h"


extern BSTR GUIDtoBSTR(LPGUID pg);
extern HRESULT BSTRtoGUID(LPGUID pg,BSTR s);

C_dxj_DirectPlaySessionDataObject::C_dxj_DirectPlaySessionDataObject()
{
	ZeroMemory(&m_desc,sizeof(DPSESSIONDESC2));
	m_desc.dwSize=sizeof(DPSESSIONDESC2);
}

C_dxj_DirectPlaySessionDataObject::~C_dxj_DirectPlaySessionDataObject()
{
	if (m_desc.lpszSessionName) SysFreeString(m_desc.lpszSessionName);
	if (m_desc.lpszPassword) SysFreeString(m_desc.lpszPassword);
}


HRESULT C_dxj_DirectPlaySessionDataObject::setGuidInstance( BSTR guid)
{
	HRESULT hr =BSTRtoGUID(&m_desc.guidInstance,guid);	
	return hr;
}
HRESULT C_dxj_DirectPlaySessionDataObject::getGuidInstance( BSTR *guid)
{
	*guid=GUIDtoBSTR(&m_desc.guidInstance);	
	return S_OK;
}


HRESULT C_dxj_DirectPlaySessionDataObject::setGuidApplication( BSTR guid)
{
	HRESULT hr =BSTRtoGUID(&m_desc.guidApplication,guid);	
	return hr;
}
HRESULT C_dxj_DirectPlaySessionDataObject::getGuidApplication( BSTR *guid)
{
	*guid=GUIDtoBSTR(&m_desc.guidApplication);	
	return S_OK;
}        


        
HRESULT C_dxj_DirectPlaySessionDataObject::setMaxPlayers( long val)
{
	m_desc.dwMaxPlayers=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getMaxPlayers( long *val)
{
	*val=(long)m_desc.dwMaxPlayers;
    return S_OK;
}

    
HRESULT C_dxj_DirectPlaySessionDataObject::setCurrentPlayers( long val)
{
	m_desc.dwCurrentPlayers=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getCurrentPlayers( long *val)
{
	*val=(long)m_desc.dwCurrentPlayers;
    return S_OK;
}         


HRESULT C_dxj_DirectPlaySessionDataObject::setSessionName( BSTR name)
{
	if (m_desc.lpszSessionName) SysFreeString(m_desc.lpszSessionName);
	m_desc.lpszSessionName=SysAllocString(name);
	return S_OK;	
}
HRESULT C_dxj_DirectPlaySessionDataObject::getSessionName( BSTR *name)
{
	*name=SysAllocString(m_desc.lpszSessionName);	
	return S_OK;
}


HRESULT C_dxj_DirectPlaySessionDataObject::setSessionPassword( BSTR name)
{
	if (m_desc.lpszPassword) SysFreeString(m_desc.lpszPassword);
	m_desc.lpszPassword=SysAllocString(name);
	return S_OK;	
}
HRESULT C_dxj_DirectPlaySessionDataObject::getSessionPassword( BSTR *name)
{
	*name=SysAllocString(m_desc.lpszPassword);	
	return S_OK;
}



HRESULT C_dxj_DirectPlaySessionDataObject::setFlags( long val)
{
	m_desc.dwFlags=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getFlags( long *val)
{
	*val=(long)m_desc.dwFlags;
    return S_OK;
}

        
HRESULT C_dxj_DirectPlaySessionDataObject::setUser1( long val)
{
	m_desc.dwUser1=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getUser1( long *val)
{
	*val=(long)m_desc.dwUser1;
    return S_OK;
}


        
HRESULT C_dxj_DirectPlaySessionDataObject::setUser2( long val)
{
	m_desc.dwUser2=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getUser2( long *val)
{
	*val=(long)m_desc.dwUser2;
    return S_OK;
}


        
HRESULT C_dxj_DirectPlaySessionDataObject::setUser3( long val)
{
	m_desc.dwUser3=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getUser3( long *val)
{
	*val=(long)m_desc.dwUser3;
    return S_OK;
}
	


        
HRESULT C_dxj_DirectPlaySessionDataObject::setUser4( long val)
{
	m_desc.dwUser4=(DWORD)val;
    return S_OK;
}
       
HRESULT C_dxj_DirectPlaySessionDataObject::getUser4( long *val)
{
	*val=(long)m_desc.dwUser4;
    return S_OK;
}


void C_dxj_DirectPlaySessionDataObject::init(DPSESSIONDESC2 *desc)
{
	memcpy(&m_desc,desc,sizeof(DPSESSIONDESC2));
	m_desc.lpszSessionName=SysAllocString(desc->lpszSessionName);
	m_desc.lpszPassword=SysAllocString(desc->lpszPassword);
}


void C_dxj_DirectPlaySessionDataObject::init(DPSessionDesc2 *desc)
{	
	m_desc.lpszSessionName=SysAllocString(desc->strSessionName);
	m_desc.lpszPassword=SysAllocString(desc->strPassword);

	BSTRtoGUID(&(m_desc.guidInstance),desc->strGuidInstance);
	BSTRtoGUID(&(m_desc.guidApplication),desc->strGuidApplication);
	
	m_desc.lpszPassword=SysAllocString(desc->strPassword);
	m_desc.dwSize=sizeof(DPSESSIONDESC2);
	m_desc.dwFlags=desc->lFlags;
	m_desc.dwMaxPlayers=desc->lMaxPlayers;
	m_desc.dwCurrentPlayers=desc->lCurrentPlayers;
	m_desc.dwUser1=desc->lUser1;
	m_desc.dwUser2=desc->lUser2;
	m_desc.dwUser3=desc->lUser3;
	m_desc.dwUser4=desc->lUser4;

}


HRESULT C_dxj_DirectPlaySessionDataObject::create(DPSESSIONDESC2 *desc,I_dxj_DirectPlaySessionData **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectPlaySessionDataObject *c=NULL;
	c=new CComObject<C_dxj_DirectPlaySessionDataObject>;
	if( c == NULL ) return E_OUTOFMEMORY;
	if (desc)	c->init(desc);

	hr=c->QueryInterface(IID_I_dxj_DirectPlaySessionData, (void**)ret);
	return hr;
}


HRESULT C_dxj_DirectPlaySessionDataObject::create(DPSessionDesc2 *desc,I_dxj_DirectPlaySessionData **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectPlaySessionDataObject *c=NULL;
	c=new CComObject<C_dxj_DirectPlaySessionDataObject>;
	if( c == NULL ) return E_OUTOFMEMORY;
	if (desc)	c->init(desc);

	hr=c->QueryInterface(IID_I_dxj_DirectPlaySessionData, (void**)ret);
	return hr;
}


HRESULT C_dxj_DirectPlaySessionDataObject::getData(void *val){
	__try {
		memcpy(val,&m_desc,sizeof(DPSESSIONDESC2));
	}
	__except(1,1){
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpsessiondescobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpsessiondescobj.cpp
//
//--------------------------------------------------------------------------

/*
	interface I_dxj_DPSessionDesc;
	interface I_dxj_DDVideoPortCaps;
	interface I_dxj_DIDeviceObjectInstance;
	interface I_dxj_DIEffectInfo;
*/


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPSessionDescObj.h"

C_dxj_DPSessionDescObject::C_dxj_DPSessionDescObject(){
	ZeroMemory(&m_desc,sizeof(DPSessionDesc));
}
C_dxj_DPSessionDescObject::~C_dxj_DPSessionDescObject(){
}

STDMETHODIMP C_dxj_DPSessionDescObject::getDescription(DPSessionDesc *desc){
	if (desc==NULL) return E_INVALIDARG; 
	memcpy(&m_desc,desc,sizeof(DPSessionDesc));
	return S_OK;
}
STDMETHODIMP C_dxj_DPSessionDescObject::setDescription(DPSessionDesc *desc){
	if (desc==NULL) return E_INVALIDARG; 
	memcpy(desc,&m_desc,sizeof(DPSessionDesc));
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpmsgobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dpMsgObj.h"
#include "dplconnectionobj.h"
#include "dpsessdataobj.h"

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);


HRESULT C_dxj_DirectPlayMessageObject::create(DWORD from,DWORD size,void **data,I_dxj_DirectPlayMessage **ret)
{	
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
	

	C_dxj_DirectPlayMessageObject *c=NULL;
	c=new CComObject<C_dxj_DirectPlayMessageObject>;
	if( c == NULL ) return E_OUTOFMEMORY;
	c->init(from);
	if (size!=0) {
		hr=c->AllocData(size);
		if FAILED(hr){
			delete c;
			return E_OUTOFMEMORY;
		}
		*data=c->m_pData;
	}

	hr=c->QueryInterface(IID_I_dxj_DirectPlayMessage, (void**)ret);
	return hr;

}
HRESULT C_dxj_DirectPlayMessageObject::init(DWORD f){
	if (!f)
		m_fSystem=TRUE;
	else
		m_fSystem=FALSE;
	return S_OK;
}


C_dxj_DirectPlayMessageObject::C_dxj_DirectPlayMessageObject()
{
	m_dwSize=0;
	m_pData=NULL;
	m_fSystem=FALSE;
	m_nWriteIndex=0;
	m_nReadIndex=0;
}

C_dxj_DirectPlayMessageObject::~C_dxj_DirectPlayMessageObject()
{
	clear();

}

HRESULT C_dxj_DirectPlayMessageObject::writeString(BSTR string)
{
	if (!string) return E_INVALIDARG;

	//read the length of the string 
	DWORD l= (((DWORD*)string)[-1]);
	DWORD growSize=l*sizeof(WCHAR)+sizeof(DWORD);	

	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;
		
	}
	
	
	//save a DWORD with the length of the string
	*((DWORD*)(m_pData+m_nWriteIndex)) =l;
	
				
	
	//increment our write pointer past the DWORD
	m_nWriteIndex=m_nWriteIndex+sizeof(DWORD);

	//save the string to our buffer
	wcscpy((WCHAR*) &(m_pData[m_nWriteIndex]),string);

	//increment the write pointer passed the data we wrote
	m_nWriteIndex=m_nWriteIndex+l*sizeof(WCHAR);


	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readString(BSTR *string)
{
	DWORD l;
	WCHAR *pstr=NULL;

	//make sure m_pData is set
	if (!m_pData) return E_OUTOFMEMORY;
	
	//make sure we havent gone past
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	if (m_dwSize< m_nReadIndex+sizeof(DWORD)) return E_FAIL;

	if (m_fSystem){
		pstr=*((WCHAR**)(m_pData+m_nReadIndex));
		m_nReadIndex=m_nReadIndex+sizeof(DWORD); //move on to the next arg if fail on a system message
		__try {
			*string=SysAllocString(pstr);	
		}
		__except(1,1){
			return E_FAIL;
		}

	}
	else {	
		//extract the length of the string
		l= *((DWORD*)(m_pData+m_nReadIndex));	
		m_nReadIndex=m_nReadIndex+sizeof(DWORD);
		if (m_dwSize< m_nReadIndex+l*sizeof(WCHAR)) return E_FAIL;
		
		*string=SysAllocString((WCHAR*)&(m_pData[m_nReadIndex]));
		m_nReadIndex=m_nReadIndex+l*sizeof(WCHAR);
	}
	return S_OK;
}



HRESULT C_dxj_DirectPlayMessageObject::writeLong(long val)
{
	
	DWORD growSize=sizeof(long);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;		
	}

	*((long*) &(m_pData[m_nWriteIndex]))=val;	
	m_nWriteIndex=m_nWriteIndex+sizeof(long);
		
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readLong(long *val)
{	
	if (!m_pData) return E_FAIL;
	if (m_nReadIndex>m_dwSize) return E_FAIL;


	*val= *((long*)(m_pData+m_nReadIndex));	
	m_nReadIndex=m_nReadIndex+sizeof(long);	
	return S_OK;
}


HRESULT C_dxj_DirectPlayMessageObject::writeShort(short val)
{

	
	DWORD growSize=sizeof(short);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;		
	}

	*((short*) (&m_pData[m_nWriteIndex]))=val;	
	m_nWriteIndex=m_nWriteIndex+sizeof(short);
		
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readShort(short *val)
{	
	if (!m_pData) return E_OUTOFMEMORY;
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	*val= *((short*)(m_pData+m_nReadIndex))	;
	m_nReadIndex=m_nReadIndex+sizeof(short);	
	return S_OK;
}


HRESULT C_dxj_DirectPlayMessageObject::writeSingle(float val)
{

	
	DWORD growSize=sizeof(float);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;		
	}

	*((float*)&(m_pData[m_nWriteIndex]))=val;	
	m_nWriteIndex=m_nWriteIndex+sizeof(float);
		
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readSingle(float *val)
{	
	if (!m_pData) return E_OUTOFMEMORY;
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	*val= *((float*)(m_pData+m_nReadIndex))	;
	m_nReadIndex=m_nReadIndex+sizeof(float);	
	return S_OK;
}




HRESULT C_dxj_DirectPlayMessageObject::writeDouble(double val)
{
	
	DWORD growSize=sizeof(double);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;		
	}

	*((double*)(&m_pData[m_nWriteIndex]))=val;	
	m_nWriteIndex=m_nWriteIndex+sizeof(double);
		
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readDouble(double *val)
{	
	if (!m_pData) return E_FAIL;
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	*val= *((double*)(m_pData+m_nReadIndex));	
	m_nReadIndex=m_nReadIndex+sizeof(double);	
	return S_OK;
}



HRESULT C_dxj_DirectPlayMessageObject::writeByte(Byte val)
{
	
	DWORD growSize=sizeof(BYTE);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;		
	}

	*((BYTE*)&(m_pData[m_nWriteIndex]))=val;	
	m_nWriteIndex=m_nWriteIndex+sizeof(BYTE);
		
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readByte(Byte *val)
{	
	if (!m_pData) return E_FAIL;
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	*val= *((BYTE*)(m_pData+m_nReadIndex))	;
	m_nReadIndex=m_nReadIndex+sizeof(BYTE);	
	return S_OK;
}



HRESULT C_dxj_DirectPlayMessageObject::writeGuid(BSTR string)
{
	HRESULT hr;

	
	DWORD growSize=sizeof(GUID);
	if (m_nWriteIndex+growSize>=m_dwSize) {
		if FAILED(GrowBuffer(growSize)) return E_OUTOFMEMORY;
		
	}

	hr=BSTRtoGUID((LPGUID)&(m_pData[m_nWriteIndex]),string);
	if FAILED(hr) return hr;
	
	//increment our write pointer past the DWORD
	m_nWriteIndex=m_nWriteIndex+sizeof(GUID);
	

	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readGuid(BSTR *string)
{

	//make sure m_pData is set
	if (!m_pData) return E_FAIL;
	
	//make sure we havent gone past
	if (m_nReadIndex>m_dwSize) return E_FAIL;

	if (m_dwSize < m_nReadIndex+sizeof(GUID)) return E_FAIL;

	*string=GUIDtoBSTR( (LPGUID)	&(m_pData[m_nReadIndex]) );
		
	return S_OK;
}


HRESULT C_dxj_DirectPlayMessageObject::moveToTop()
{
	m_nReadIndex=0;
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::getMessageSize(long *ret)
{
	*ret=m_dwSize;
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::getMessageData(void *ret)
{
	__try{
		memcpy(ret,m_pData,m_dwSize);
	}
	__except(1,1){
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::setMessageData(void *data, long size)
{
	clear();
	m_dwSize=(DWORD)size;
	m_pData=(char*)malloc(size);

	if (!m_pData) return E_OUTOFMEMORY;

	__try{
		memcpy(m_pData,data,m_dwSize);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	return S_OK;
}



HRESULT C_dxj_DirectPlayMessageObject::clear()
{
	if (m_pData) free(m_pData);

	m_dwSize=0;
	m_pData=NULL;
	m_fSystem=FALSE;
	m_nWriteIndex=0;
	m_nReadIndex=0;
	return S_OK;
}


HRESULT C_dxj_DirectPlayMessageObject::getPointer(long *ret)
{
	*ret=(long)PtrToLong(m_pData);	//bugbug SUNDOWN
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::AllocData(long size)
{
	clear();
	m_pData=(char*)malloc(size);	
	if (!m_pData) return E_OUTOFMEMORY;
	ZeroMemory(m_pData,size);

	m_dwSize=size;

	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::GrowBuffer(DWORD size){
	if (m_pData) 
	{
		m_pData=(char*)realloc(m_pData,m_dwSize+size);
		if (!m_pData) return E_FAIL;		
	}
	else  
	{
		m_pData=(char*)malloc(m_dwSize+size);
		if (!m_pData) return E_FAIL;		
	}
	m_dwSize=m_dwSize+size;
	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readSysMsgData(BSTR *ret)
{	
	if (!m_pData) return E_FAIL;
	

	WCHAR *pstr;
	DWORD size;
	DWORD type;
	
	//valid on DPSYS_CREATEPLAYERORGROUP
	//valid on DPSYS_DESTROYPLAYERORGROUP
	//valid on DPSYS_SETPLAYERORGROUPDATA
	//make sure we have enough space to check the type
	if (m_dwSize<4) return E_FAIL;
	type= *((DWORD*)(m_pData));	
	if (!((type==DPSYS_CREATEPLAYERORGROUP)||(type==DPSYS_DESTROYPLAYERORGROUP)||(type==DPSYS_SETPLAYERORGROUPDATA)))
		return E_FAIL;

	
	

	//read the pointer to BSTR
	if (m_nReadIndex >m_dwSize) return E_FAIL;
	pstr=*((WCHAR**)(m_pData+m_nReadIndex));
	
	//read the size
	m_nReadIndex=m_nReadIndex+sizeof(DWORD); //move on to the next arg if fail on a system message
	if (m_nReadIndex >m_dwSize) return E_FAIL;
	size= *((DWORD*)(m_pData+m_nReadIndex));	



	__try {
		*ret=SysAllocString(pstr);	
	}
	__except(1,1){
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayMessageObject::readSysMsgConnection( I_dxj_DPLConnection **ret)
{

		//valid on DPSYS_STARTSESSION
		//make sure we have enough space to check the type
		if (m_dwSize<8) return E_FAIL;
		DWORD type= *((DWORD*)(m_pData));	
		if (!(type==DPSYS_STARTSESSION)) return E_FAIL;
		
		DWORD dwConnection= *((DWORD*)(m_pData+sizeof(DWORD)));	


		INTERNAL_CREATE_STRUCT(_dxj_DPLConnection,ret);
		if (!ret) return E_OUTOFMEMORY;

		HRESULT hr=(*ret)->setConnectionStruct( dwConnection);		

		return hr;
}

HRESULT C_dxj_DirectPlayMessageObject::readSysMsgSessionDesc( I_dxj_DirectPlaySessionData **ret)
{

		//valid on DPSYS_SETSESSIONDESC
		//make sure we have enough space to check the type
		if (m_dwSize<8) return E_FAIL;
		DWORD type= *((DWORD*)(m_pData));	
		if (!(type==DPSYS_SETSESSIONDESC)) return E_FAIL;
		
		DPSESSIONDESC2 *pDesc= (LPDPSESSIONDESC2) *((DWORD*)(m_pData+sizeof(DWORD)));	

		HRESULT hr=C_dxj_DirectPlaySessionDataObject::create(pDesc,ret);

		return hr;
}


HRESULT C_dxj_DirectPlayMessageObject::readSysChatString( BSTR *ret)
{

		//valid on DPSYS_CHAT. 
		//make sure we have enough space to check the type
		if (m_dwSize<40) return E_FAIL;
		DWORD type= *((DWORD*)(m_pData));	
		if (!(type==DPSYS_CHAT)) return E_FAIL;
		

		DPMSG_CHAT *pChatMsg = (DPMSG_CHAT*)m_pData;

		__try{

			*ret = SysAllocString(pChatMsg->lpChat->lpszMessage);
		}
		__except(1,1){
			return E_FAIL;
		}	
		
		return S_OK;
}


HRESULT C_dxj_DirectPlayMessageObject::moveToSecureMessage()
{
		//valid on DPSYS_CHAT. 
		//make sure we have enough space to check the type
		if (m_dwSize<18) return E_FAIL;
		DWORD type= *((DWORD*)(m_pData));	
		if (!(type==DPSYS_SECUREMESSAGE)) return E_FAIL;

		DPMSG_SECUREMESSAGE *pMsg = (DPMSG_SECUREMESSAGE*)m_pData;
		DWORD newIndex=0;
		__try{
			newIndex= ((DWORD)pMsg->lpData)-((DWORD)m_pData);
		}
		__except(1,1)
		{
			return E_FAIL;
		}

		if (newIndex >m_dwSize) return E_FAIL;
		m_nReadIndex=newIndex;

		return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpmsgobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpmsgobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectPlayMessageObject :
		public I_dxj_DirectPlayMessage,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectPlayMessageObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectPlayMessage)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectPlayMessageObject)

public:
		C_dxj_DirectPlayMessageObject();	
		~C_dxj_DirectPlayMessageObject();

         HRESULT STDMETHODCALLTYPE writeGuid( 
            /* [in] */ BSTR val);
        
         HRESULT STDMETHODCALLTYPE readGuid( 
            /* [retval][out] */ BSTR __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeString( 
            /* [in] */ BSTR val);
        
         HRESULT STDMETHODCALLTYPE readString( 
            /* [retval][out] */ BSTR __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeLong( 
            /* [in] */ long val);
        
         HRESULT STDMETHODCALLTYPE readLong( 
            /* [retval][out] */ long __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeShort( 
            /* [in] */ short val);
        
         HRESULT STDMETHODCALLTYPE readShort( 
            /* [retval][out] */ short __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeSingle( 
            /* [in] */ float val);
        
         HRESULT STDMETHODCALLTYPE readSingle( 
            /* [retval][out] */ float __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeDouble( 
            /* [in] */ double val);
        
         HRESULT STDMETHODCALLTYPE readDouble( 
            /* [retval][out] */ double __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE writeByte( 
            /* [in] */ Byte val);
        
         HRESULT STDMETHODCALLTYPE readByte( 
            /* [retval][out] */ Byte __RPC_FAR *val);
        
         HRESULT STDMETHODCALLTYPE moveToTop( void);
        
         HRESULT STDMETHODCALLTYPE clear( void);
        
         HRESULT STDMETHODCALLTYPE getMessageSize( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getMessageData( 
            /* [out][in] */ void __RPC_FAR *userDefinedType);
        
         HRESULT STDMETHODCALLTYPE setMessageData( 
            /* [in] */ void __RPC_FAR *userDefinedType,
            /* [in] */ long size);
		
		HRESULT STDMETHODCALLTYPE getPointer(long *ret);

		 
		HRESULT STDMETHODCALLTYPE readSysMsgConnection( I_dxj_DPLConnection **ret);
		HRESULT STDMETHODCALLTYPE readSysMsgSessionDesc( I_dxj_DirectPlaySessionData **ret);
		HRESULT STDMETHODCALLTYPE readSysMsgData( BSTR *ret);
		HRESULT STDMETHODCALLTYPE readSysChatString( BSTR *ret);
		HRESULT STDMETHODCALLTYPE moveToSecureMessage();


		HRESULT AllocData(long size);
			
		HRESULT GrowBuffer(DWORD size);

		
		
		HRESULT init(DWORD f);

		static HRESULT C_dxj_DirectPlayMessageObject::create(DWORD from,DWORD size,void **data,I_dxj_DirectPlayMessage **ret);		


		char *m_pData;		
		DWORD m_dwSize;
		DWORD m_nWriteIndex;
		DWORD m_nReadIndex;

		BOOL m_fSystem;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsenumobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsenumobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DSEnumObject : 
	public I_dxj_DSEnum,
	public CComObjectRoot
{
public:
	C_dxj_DSEnumObject() ;
	virtual ~C_dxj_DSEnumObject() ;

BEGIN_COM_MAP(C_dxj_DSEnumObject)
	COM_INTERFACE_ENTRY(I_dxj_DSEnum)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DSEnumObject)

public:
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getDescription( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid) ;
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count) ;
				
		static HRESULT create(DSOUNDENUMERATE pcbFunc,DSOUNDCAPTUREENUMERATE pcbFunc2,I_dxj_DSEnum **ppRet);		

public:
		DxDriverInfo *m_pList;
		long		m_nCount;
		long		m_nMax;
		BOOL		m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpsessiondescobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dpsessiondescobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DPSessionDescObject : 
	public I_dxj_DPSessionDesc,
	public CComCoClass<C_dxj_DPSessionDescObject, &CLSID__dxj_DPSessionDesc>, 
	public CComObjectRoot
{
public:
	C_dxj_DPSessionDescObject() ;
	virtual ~C_dxj_DPSessionDescObject() ;

BEGIN_COM_MAP(C_dxj_DPSessionDescObject)
	COM_INTERFACE_ENTRY( I_dxj_DPSessionDesc)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DPSessionDescObject)
DECLARE_REGISTRY(CLSID__dxj_D3dDeviceDesc,	"DIRECT.DPSessionDesc.5",		"DIRECT.DPSessionDesc.5",	IDS_GENERIC_DESC, THREADFLAGS_BOTH)


public:

        HRESULT STDMETHODCALLTYPE getDescription( DPSessionDesc *desc);
		HRESULT STDMETHODCALLTYPE setDescription( DPSessionDesc *desc);

private:
		DPSessionDesc m_desc;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dpsessdataobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dpsessdataobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DirectPlaySessionDataObject :
		public I_dxj_DirectPlaySessionData,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DirectPlaySessionDataObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectPlaySessionData)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectPlaySessionDataObject)

public:
	C_dxj_DirectPlaySessionDataObject();	
    ~C_dxj_DirectPlaySessionDataObject();

        /* [propput] */ HRESULT STDMETHODCALLTYPE setGuidInstance( 
            /* [in] */ BSTR guid);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidInstance( 
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setGuidApplication( 
            /* [in] */ BSTR guid);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidApplication( 
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setMaxPlayers( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getMaxPlayers( 
            /* [retval][out] */ long __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setCurrentPlayers( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getCurrentPlayers( 
            /* [retval][out] */ long __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setSessionName( 
            /* [in] */ BSTR val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getSessionName( 
            /* [retval][out] */ BSTR __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setSessionPassword( 
            /* [in] */ BSTR val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getSessionPassword( 
            /* [retval][out] */ BSTR __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setUser1( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUser1( 
            /* [retval][out] */ long __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setUser2( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUser2( 
            /* [retval][out] */ long __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setUser3( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUser3( 
            /* [retval][out] */ long __RPC_FAR *val);
        
        /* [propput] */ HRESULT STDMETHODCALLTYPE setUser4( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUser4( 
            /* [retval][out] */ long __RPC_FAR *val);

        /* [propput] */ HRESULT STDMETHODCALLTYPE setFlags( 
            /* [in] */ long val);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getFlags( 
            /* [retval][out] */ long __RPC_FAR *val);

        
		/* [propget] */ HRESULT STDMETHODCALLTYPE getData(void *val);
		
			
		void init(DPSESSIONDESC2 *desc);	
		void init(DPSessionDesc2 *desc);

		static HRESULT C_dxj_DirectPlaySessionDataObject::create(DPSESSIONDESC2  *desc,I_dxj_DirectPlaySessionData **ret);
		static HRESULT C_dxj_DirectPlaySessionDataObject::create(DPSessionDesc2  *desc,I_dxj_DirectPlaySessionData **ret);			   

private:
		DPSESSIONDESC2 m_desc;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsenumobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsenumobj.cpp
//
//--------------------------------------------------------------------------

#define DIRECTSOUND_VERSION 0x600
#define OLDDSENUM 1

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dxglob7obj.h"
#include "DSEnumObj.h"
 

extern BSTR GUIDtoBSTR(LPGUID pGuid);

extern "C" BOOL PASCAL  objDirectSoundEnumCallback( 

#ifdef OLDDSENUM
	LPGUID lpGuid,
#else
	LPCGUID lpGuid,
#endif

  LPCSTR lpDriverDescription,  
  LPCSTR lpDriverName,         
  LPVOID lpArg            
)
{
        GUID guid;
        ZeroMemory(&guid,sizeof(GUID));
        if (lpGuid){
           memcpy(&guid,lpGuid,sizeof(GUID));
        }

	
	DPF(1,"Entered objDirectDrawEnumCallback \r\n");

	
	C_dxj_DSEnumObject *pObj=(C_dxj_DSEnumObject*)lpArg;
	if (pObj==NULL) return TRUE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList)
			pObj->m_pList=(DxDriverInfo*)realloc(pObj->m_pList,sizeof(DxDriverInfo)* pObj->m_nMax);
		else
			pObj->m_pList=(DxDriverInfo*)malloc(sizeof(DxDriverInfo)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfo));
        pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)&guid);
//      pObj->m_pList[pObj->m_nCount].strGuid=GUIDtoBSTR((GUID*)lpGuid); 
	if (lpDriverDescription!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(lpDriverDescription);
	}
	if (lpDriverName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(lpDriverName);
	}

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DSEnumObject::C_dxj_DSEnumObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DSEnumObject::~C_dxj_DSEnumObject()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_DSEnumObject::create(DSOUNDENUMERATE pcbFunc,DSOUNDCAPTUREENUMERATE pcbFunc2,I_dxj_DSEnum **ppRet)
{
	HRESULT hr=S_OK;	
	C_dxj_DSEnumObject *pNew=NULL;

	//ASSERT(ppRet,"C_dxj_DSEnumObject::create passed invalid arg");
	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DSEnumObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	if (pcbFunc) 
	{
		hr=pcbFunc(objDirectSoundEnumCallback,pNew);	
	}
	else if (pcbFunc2)
	{
		hr=pcbFunc2(objDirectSoundEnumCallback,pNew);
	}
	else {
		hr = E_INVALIDARG;
	}

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		//let destructor do the clean up
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DSEnum,(void**)ppRet);
	return hr;
}




HRESULT C_dxj_DSEnumObject::getName( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	
	*ret=SysAllocString(m_pList[index-1].strName);		

	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getDescription( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	

	*ret=SysAllocString(m_pList[index-1].strDescription);

	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getGuid( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;	

	*ret=SysAllocString(m_pList[index-1].strGuid);
	return S_OK;
}

HRESULT C_dxj_DSEnumObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsound3dbuffer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsound3dbuffer.h
//
//--------------------------------------------------------------------------

// dSound3DBuffer.h : Declaration of the C_dxj_DirectSound3dBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound3dBuffer LPDIRECTSOUND3DBUFFER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSound3dBufferObject : 
	public I_dxj_DirectSound3dBuffer,
	//public CComCoClass<C_dxj_DirectSound3dBufferObject, &CLSID__dxj_DirectSound3dBuffer>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSound3dBufferObject() ;
	virtual ~C_dxj_DirectSound3dBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSound3dBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound3dBuffer)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSound3dBuffer,	"DIRECT.DirectSound3dBuffer.3",		"DIRECT.DirectSound3dBuffer.3",			IDS_DSOUND3DBUFFER_DESC, THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_DirectSound3dBufferObject)

// I_dxj_DirectSound3dBuffer
public:
	/*** IDirectSoundBuffer3D methods ***/
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getDirectSound3dListener( 
            /* [retval][out] */ I_dxj_DirectSound3dListener __RPC_FAR *__RPC_FAR *retVal);
        
         HRESULT STDMETHODCALLTYPE getDirectSoundBuffer( 
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *retVal);
        
         HRESULT STDMETHODCALLTYPE getAllParameters( 
            /* [out][in] */ DS3dBuffer __RPC_FAR *buffer);
        
         HRESULT STDMETHODCALLTYPE getConeAngles( 
            /* [out][in] */ long __RPC_FAR *inCone,
            /* [out][in] */ long __RPC_FAR *outCone);
        
         HRESULT STDMETHODCALLTYPE getConeOrientation( 
            /* [out][in] */ D3dVector __RPC_FAR *orientation);
        
         HRESULT STDMETHODCALLTYPE getConeOutsideVolume( 
            /* [retval][out] */ long __RPC_FAR *coneOutsideVolume);
        
         HRESULT STDMETHODCALLTYPE getMaxDistance( 
            /* [retval][out] */ float __RPC_FAR *maxDistance);
        
         HRESULT STDMETHODCALLTYPE getMinDistance( 
            /* [retval][out] */ float __RPC_FAR *minDistance);
        
         HRESULT STDMETHODCALLTYPE getMode( 
            /* [retval][out] */ long __RPC_FAR *mode);
        
         HRESULT STDMETHODCALLTYPE getPosition( 
            /* [out][in] */ D3dVector __RPC_FAR *position);
        
         HRESULT STDMETHODCALLTYPE getVelocity( 
            /* [out][in] */ D3dVector __RPC_FAR *velocity);
        
         HRESULT STDMETHODCALLTYPE setAllParameters( 
            /* [in] */ DS3dBuffer __RPC_FAR *buffer,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeAngles( 
            /* [in] */ long inCone,
            /* [in] */ long outCone,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeOrientation( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setConeOutsideVolume( 
            /* [in] */ long coneOutsideVolume,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMaxDistance( 
            /* [in] */ float maxDistance,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMinDistance( 
            /* [in] */ float minDistance,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setMode( 
            /* [in] */ long mode,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag);
private:
    DECL_VARIABLE(_dxj_DirectSound3dBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound3dBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsound3dlistener.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsound3dlistener.cpp
//
//--------------------------------------------------------------------------

// dSound3DListener.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file
#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dSound3DListener.h"

CONSTRUCTOR(_dxj_DirectSound3dListener, {});
DESTRUCTOR(_dxj_DirectSound3dListener,  {});
GETSET_OBJECT(_dxj_DirectSound3dListener);

	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getDistanceFactor, GetDistanceFactor, d3dvalue*);
	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getDopplerFactor, GetDopplerFactor, d3dvalue*);
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, getOrientation, GetOrientation, D3dVector*, (_D3DVECTOR*) , D3dVector*, (_D3DVECTOR*) );
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dListener, getPosition, GetPosition, D3dVector*, (_D3DVECTOR*));
	PASS_THROUGH1_R(_dxj_DirectSound3dListener, getRolloffFactor, GetRolloffFactor, d3dvalue*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dListener, getVelocity, GetVelocity, D3dVector*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setDistanceFactor, SetDistanceFactor, d3dvalue ,(float),long,( DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setDopplerFactor, SetDopplerFactor, d3dvalue , (float),long,(DWORD));
	PASS_THROUGH_CAST_7_R(_dxj_DirectSound3dListener, setOrientation, SetOrientation, 
		d3dvalue,(float), d3dvalue, (float), d3dvalue,(float),d3dvalue,(float),d3dvalue, (float),
		d3dvalue,(float),long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dListener, setPosition, SetPosition, d3dvalue,(float), d3dvalue, (float),d3dvalue,(float),long,( DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dListener, setRolloffFactor, SetRolloffFactor,d3dvalue,(float),  long, (DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dListener, setVelocity, SetVelocity, d3dvalue,(float), d3dvalue,(float), d3dvalue,(float),long,(DWORD));
	PASS_THROUGH_R(_dxj_DirectSound3dListener, commitDeferredSettings, CommitDeferredSettings);

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::getAllParameters( DS3dListener* lobj )
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DLISTENER);
	return m__dxj_DirectSound3dListener->GetAllParameters( (LPDS3DLISTENER)lobj );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::setAllParameters( DS3dListener *lobj, long apply)
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DLISTENER);
	return m__dxj_DirectSound3dListener->SetAllParameters( (LPDS3DLISTENER)lobj, (DWORD)apply );
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dListenerObject::getDirectSoundBuffer( I_dxj_DirectSoundBuffer **retv)
{
	HRESULT hr;
	IDirectSoundBuffer *pdsb;
	hr=m__dxj_DirectSound3dListener->QueryInterface(IID_IDirectSoundBuffer,(void**)&pdsb);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectSoundBuffer,pdsb,retv);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsound3dbuffer.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsound3dbuffer.cpp
//
//--------------------------------------------------------------------------

// dSound3DBuffer.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"
#include "dSound3DBuffer.h"
#include "dSound3DListener.h"

CONSTRUCTOR(_dxj_DirectSound3dBuffer, {});
DESTRUCTOR(_dxj_DirectSound3dBuffer,  {});
GETSET_OBJECT(_dxj_DirectSound3dBuffer);

	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, getConeAngles, GetConeAngles, long*,(DWORD*), long*,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getConeOrientation, GetConeOrientation, D3dVector*, (_D3DVECTOR*));
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getConeOutsideVolume, GetConeOutsideVolume, long*);
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getMaxDistance, GetMaxDistance, d3dvalue*);
	PASS_THROUGH1_R(_dxj_DirectSound3dBuffer, getMinDistance, GetMinDistance, d3dvalue*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getMode, GetMode,  long *,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getPosition, GetPosition, D3dVector*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSound3dBuffer, getVelocity, GetVelocity, D3dVector*, (_D3DVECTOR*));
	PASS_THROUGH_CAST_3_R(_dxj_DirectSound3dBuffer, setConeAngles, SetConeAngles, long,(DWORD) ,long,(DWORD) ,long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setConeOrientation,  SetConeOrientation, d3dvalue,(float), d3dvalue,(float), d3dvalue,(float), long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setConeOutsideVolume, SetConeOutsideVolume, long, (long),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMaxDistance, SetMaxDistance, d3dvalue, (float),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMinDistance, SetMinDistance, d3dvalue,(float),long,(DWORD));
	PASS_THROUGH_CAST_2_R(_dxj_DirectSound3dBuffer, setMode, SetMode, long,(unsigned long) , long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setPosition, SetPosition, d3dvalue,(float), d3dvalue,(float), d3dvalue,(float), long,(DWORD));
	PASS_THROUGH_CAST_4_R(_dxj_DirectSound3dBuffer, setVelocity, SetVelocity, d3dvalue,(float), d3dvalue,(float), d3dvalue,(float), long,(DWORD));

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::getAllParameters( DS3dBuffer* lobj )
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DBUFFER);
	return m__dxj_DirectSound3dBuffer->GetAllParameters( (LPDS3DBUFFER)lobj );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::setAllParameters( DS3dBuffer *lobj, long apply)
{
	if(!lobj)
		return E_POINTER;

	lobj->lSize = sizeof(DS3DBUFFER);
	return m__dxj_DirectSound3dBuffer->SetAllParameters( (LPDS3DBUFFER)lobj, (DWORD)apply );
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::getDirectSoundBuffer( I_dxj_DirectSoundBuffer **retv)
{
	HRESULT hr;
	IDirectSoundBuffer *pdsb;
	hr=m__dxj_DirectSound3dBuffer->QueryInterface(IID_IDirectSoundBuffer,(void**)&pdsb);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectSoundBuffer,pdsb,retv);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSound3dBufferObject::getDirectSound3dListener( I_dxj_DirectSound3dListener **retv)
{
	HRESULT hr;
	IDirectSound3DListener *pdsb;
	hr=m__dxj_DirectSound3dBuffer->QueryInterface(IID_IDirectSound3DListener,(void**)&pdsb);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectSound3dListener,pdsb,retv);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsound3dlistener.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsound3dlistener.h
//
//--------------------------------------------------------------------------

// dSound3DListener.h : Declaration of the C_dxj_DirectSound3dListenerObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound3dListener LPDIRECTSOUND3DLISTENER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSound3dListenerObject : 
	public I_dxj_DirectSound3dListener,
	//public CComCoClass<C_dxj_DirectSound3dListenerObject, &CLSID__dxj_DirectSound3dListener>,
	public CComObjectRoot
{
public:
	C_dxj_DirectSound3dListenerObject() ;
	virtual ~C_dxj_DirectSound3dListenerObject() ;

BEGIN_COM_MAP(C_dxj_DirectSound3dListenerObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound3dListener)
END_COM_MAP()

//y	DECLARE_REGISTRY(CLSID__dxj_DirectSound3dListener,	"DIRECT.DirectSound3dListener.3",	"DIRECT.DirectSound3dListener.3",		IDS_DSOUND3DLISTENER_DESC, THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_DirectSound3dListenerObject)

// I_dxj_DirectSound3dListener
public:
	/*** IDirectSound3D methods ***/
	//
	//updated

	     /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE getAllParameters( 
            /* [out][in] */ DS3dListener __RPC_FAR *listener) ;
        
         HRESULT STDMETHODCALLTYPE getDistanceFactor( 
            /* [retval][out] */ float __RPC_FAR *distanceFactor) ;
        
         HRESULT STDMETHODCALLTYPE getDopplerFactor( 
            /* [retval][out] */ float __RPC_FAR *dopplerFactor) ;
        
         HRESULT STDMETHODCALLTYPE getOrientation( 
            /* [out][in] */ D3dVector __RPC_FAR *orientFront,
            /* [out][in] */ D3dVector __RPC_FAR *orientTop) ;
        
         HRESULT STDMETHODCALLTYPE getPosition( 
            /* [out] */ D3dVector __RPC_FAR *position) ;
        
         HRESULT STDMETHODCALLTYPE getRolloffFactor( 
            /* [retval][out] */ float __RPC_FAR *rolloffFactor) ;
        
         HRESULT STDMETHODCALLTYPE getVelocity( 
            /* [retval][out] */ D3dVector __RPC_FAR *velocity) ;
        
         HRESULT STDMETHODCALLTYPE setAllParameters( 
            /* [in] */ DS3dListener __RPC_FAR *listener,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setDistanceFactor( 
            /* [in] */ float distanceFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setDopplerFactor( 
            /* [in] */ float dopplerFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setOrientation( 
            /* [in] */ float xFront,
            /* [in] */ float yFront,
            /* [in] */ float zFront,
            /* [in] */ float xTop,
            /* [in] */ float yTop,
            /* [in] */ float zTop,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setPosition( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setRolloffFactor( 
            /* [in] */ float rolloffFactor,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE setVelocity( 
            /* [in] */ float x,
            /* [in] */ float y,
            /* [in] */ float z,
            /* [in] */ long applyFlag) ;
        
         HRESULT STDMETHODCALLTYPE commitDeferredSettings( void) ;
        
         HRESULT STDMETHODCALLTYPE getDirectSoundBuffer( 
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *retVal) ;
private:
    DECL_VARIABLE(_dxj_DirectSound3dListener);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound3dListener )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsoundbufferobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundbufferobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundBuffer LPDIRECTSOUNDBUFFER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundBuffer, &IID_I_dxj_DirectSoundBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundBuffer,
#endif

	//public CComCoClass<C_dxj_DirectSoundBufferObject, &CLSID__dxj_DirectSoundBuffer>,
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundBufferObject() ;
	virtual ~C_dxj_DirectSoundBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundBuffer)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//y	DECLARE_REGISTRY(CLSID__dxj_DirectSoundBuffer,	"DIRECT.DirectSoundBuffer.3",		"DIRECT.DirectSoundBuffer.3",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundBufferObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundBuffer
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getDirectSound3dListener( 
            /* [retval][out] */ I_dxj_DirectSound3dListener __RPC_FAR *__RPC_FAR *lpdsl);
        
         HRESULT STDMETHODCALLTYPE getDirectSound3dBuffer( 
            /* [retval][out] */ I_dxj_DirectSound3dBuffer __RPC_FAR *__RPC_FAR *lpdsb);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSBCaps __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getCurrentPosition( 
            /* [out] */ DSCursors __RPC_FAR *cursors);
        
         HRESULT STDMETHODCALLTYPE getFormat( 
            /* [out][in] */ WaveFormatex __RPC_FAR *format);
        
         HRESULT STDMETHODCALLTYPE getVolume( 
            /* [retval][out] */ long __RPC_FAR *volume);
        
         HRESULT STDMETHODCALLTYPE getPan( 
            /* [retval][out] */ long __RPC_FAR *pan);
        
         HRESULT STDMETHODCALLTYPE getFrequency( 
            /* [retval][out] */ long __RPC_FAR *frequency);
        
         HRESULT STDMETHODCALLTYPE getStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE initialize( 
            /* [in] */ I_dxj_DirectSound __RPC_FAR *directSound,
            /* [out][in] */ DSBufferDesc __RPC_FAR *bufferDesc,
            /* [out][in] */ byte __RPC_FAR *wbuf);
        
         HRESULT STDMETHODCALLTYPE writeBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *buffer,
			void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE readBuffer( 
            /* [in] */ long start,
            /* [in] */ long size,
            ///* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *buffer,
				void * buf,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE play( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE setCurrentPosition( 
            /* [in] */ long newPosition);
        
         HRESULT STDMETHODCALLTYPE setFormat( 
            /* [in] */ WaveFormatex __RPC_FAR *format);
        
         HRESULT STDMETHODCALLTYPE setVolume( 
            /* [in] */ long volume);
        
         HRESULT STDMETHODCALLTYPE setPan( 
            /* [in] */ long pan);
        
         HRESULT STDMETHODCALLTYPE setFrequency( 
            /* [in] */ long frequency);
        
         HRESULT STDMETHODCALLTYPE stop( void);
        
         HRESULT STDMETHODCALLTYPE restore( void);
		 
		 HRESULT  STDMETHODCALLTYPE setNotificationPositions(long nElements,SAFEARRAY  **ppsa);

		 HRESULT STDMETHODCALLTYPE saveToFile(BSTR b);

private:
    DECL_VARIABLE(_dxj_DirectSoundBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsoundbufferobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundbufferobj.cpp
//
//--------------------------------------------------------------------------

// dSoundBufferObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file
#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundBufferObj.h"
#include "dSoundObj.h"
#include "dSound3DListener.h"
#include "dSound3DBuffer.h"


extern HRESULT InternalSaveToFile(IDirectSoundBuffer *pBuff,BSTR file);

CONSTRUCTOR(_dxj_DirectSoundBuffer, {});
DESTRUCTOR(_dxj_DirectSoundBuffer, {});
GETSET_OBJECT(_dxj_DirectSoundBuffer);

	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, getVolume, GetVolume, long*);
	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, getPan, GetPan, long*);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, getFrequency, GetFrequency, long*,(DWORD*));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, getStatus, GetStatus, long*,(DWORD*));

	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, setCurrentPosition, SetCurrentPosition, long,(DWORD));
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, setFormat, SetFormat, WaveFormatex*, (LPWAVEFORMATEX));
//	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, setVolume, SetVolume, LONG);
	PASS_THROUGH1_R(_dxj_DirectSoundBuffer, setPan, SetPan, LONG);
	PASS_THROUGH_CAST_1_R(_dxj_DirectSoundBuffer, setFrequency, SetFrequency, long,(DWORD));
	PASS_THROUGH_R(_dxj_DirectSoundBuffer, stop, Stop);
	PASS_THROUGH_R(_dxj_DirectSoundBuffer, restore, Restore);


STDMETHODIMP C_dxj_DirectSoundBufferObject::setVolume(LONG vol)
{
#ifdef JAVA
	IDxSecurity *ids=0;
	HRESULT hr = CoCreateInstance(CLSID_DxSecurity, 0, 1, IID_IDxSecurity, (void **)&ids);
	if(hr == S_OK)
		hr = ids->isFullDirectX();

	if(hr != S_OK )
		return E_FAIL;
#endif

	return m__dxj_DirectSoundBuffer->SetVolume(vol); 
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::getDirectSound3dListener(I_dxj_DirectSound3dListener **retval)
{
    IDirectSound3DListener *lp3dl;
	HRESULT hr = DD_OK;

    if( (hr=m__dxj_DirectSoundBuffer->QueryInterface(IID_IDirectSound3DListener, (void**) &lp3dl)) != DD_OK)
		return hr;

	INTERNAL_CREATE(_dxj_DirectSound3dListener, lp3dl, retval);

	return hr;
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::getDirectSound3dBuffer(I_dxj_DirectSound3dBuffer **retval)
{
    IDirectSound3DBuffer *lp3db;
	HRESULT hr = DD_OK;

    if( (hr=m__dxj_DirectSoundBuffer->QueryInterface(IID_IDirectSound3DBuffer, (void**) &lp3db)) != DD_OK)
		return hr;

	INTERNAL_CREATE(_dxj_DirectSound3dBuffer, lp3db, retval);

	return hr;
}

STDMETHODIMP C_dxj_DirectSoundBufferObject::getCaps(DSBCaps* caps)
{
	if(!caps)
		return E_POINTER;

	caps->lSize = sizeof(DSBCAPS);
	return m__dxj_DirectSoundBuffer->GetCaps((LPDSBCAPS)caps); 
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::getCurrentPosition(DSCursors *desc) 
{ 
	if(!desc)
		return E_POINTER;

  return (m__dxj_DirectSoundBuffer->GetCurrentPosition((DWORD*)&desc->lPlay, (DWORD*)&desc->lWrite) ); 
}

/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::writeBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 
	#pragma message ("SoundBuffer writeBuffer ")

	byte *buffer=(byte*)buf; //(byte*)((SAFEARRAY*)*ppsa)->pvData;

	if(!buffer)
		return E_POINTER;

	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	__try {
	if ((val = m__dxj_DirectSoundBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (size1)	
		memcpy (p1, &buffer[start], size1);

	if (size2)	
		memcpy(p2, &buffer, size2);

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	val=m__dxj_DirectSoundBuffer->Unlock(p1, size1, p2, size2);
	}
	__except(0,0){
		return E_FAIL;
	}
	return val;
}


/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::readBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 

	//byte *buffer=(byte*)((SAFEARRAY*)*ppsa)->pvData;
	byte *buffer=(byte*)buf;

	if(!buffer)
		return E_POINTER;
	
	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	
   __try {
	if ((val = m__dxj_DirectSoundBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (size1)	
		memcpy (&buffer[start],p1,  size1);

	if (size2)	
		memcpy(&buffer,p2,  size2);

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	val= m__dxj_DirectSoundBuffer->Unlock(p1, size1, p2, size2);
   }
   __except(1,1){
	return E_FAIL;
   }
   return val;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::getFormat(WaveFormatex *format) 
{ 
	DWORD *wsize=0;	// docdoc: throw away returned written size

	HRESULT hr=DS_OK;
	hr=m__dxj_DirectSoundBuffer->GetFormat((LPWAVEFORMATEX)format, (DWORD)sizeof(WaveFormatex), wsize);
			
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::initialize(I_dxj_DirectSound *ds, DSBufferDesc *buf,
				BYTE *wave) 
{
	if(! (ds && buf && wave) )
		return E_POINTER;

	// make Java desc look like DirectX desc
	buf->lSize = sizeof(DSBUFFERDESC);
	buf->lpwfxFormat = PtrToLong(wave);	//bugbug SUNDOWN

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND, lpds, ds)

	m__dxj_DirectSoundBuffer->Initialize(lpds, (LPDSBUFFERDESC)buf);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundBufferObject::play(long flags) 
{
	HRESULT hr=DS_OK;
	if((hr=m__dxj_DirectSoundBuffer->Play(0, 0, (DWORD)flags)) != DS_OK)
		return hr;

	return hr;
}



STDMETHODIMP C_dxj_DirectSoundBufferObject::setNotificationPositions (long nElements,SAFEARRAY  **ppsa)
{
	if (!ISSAFEARRAY1D(ppsa,(DWORD)nElements))
		return E_INVALIDARG;
	
	HRESULT hr;
	LPDIRECTSOUNDNOTIFY pDSN=NULL;
	hr=m__dxj_DirectSoundBuffer->QueryInterface(IID_IDirectSoundNotify,(void**)&pDSN);
	if FAILED(hr) return hr;

    hr=pDSN->SetNotificationPositions((DWORD)nElements,(LPCDSBPOSITIONNOTIFY)((SAFEARRAY*)*ppsa)->pvData);	
		
	pDSN->Release();

	return hr;
}


STDMETHODIMP C_dxj_DirectSoundBufferObject::saveToFile(BSTR file)
{

	HRESULT hr= InternalSaveToFile(m__dxj_DirectSoundBuffer,file);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsoundcapturebufferobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundcapturebufferobj.cpp
//
//--------------------------------------------------------------------------

// dSoundCaptureBufferObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file
#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundObj.h"
#include "dSoundCaptureBufferObj.h"
#include "dSoundCaptureObj.h"

CONSTRUCTOR(_dxj_DirectSoundCaptureBuffer, {});
DESTRUCTOR(_dxj_DirectSoundCaptureBuffer, {});
GETSET_OBJECT(_dxj_DirectSoundCaptureBuffer);

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getCaps(DSCBCaps *caps)
{    
	((DSCBCAPS*)caps)->dwSize=sizeof(DSCBCAPS);
    return m__dxj_DirectSoundCaptureBuffer->GetCaps((DSCBCAPS*)caps);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getCurrentPosition(DSCursors *desc) 
{    	
	/////////////////////////////////////////////////////////////////////////////
	if(!desc)
		return E_POINTER;

	return (m__dxj_DirectSoundCaptureBuffer->GetCurrentPosition((DWORD*)&desc->lPlay, (DWORD*)&desc->lWrite) ); 
}


STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getStatus(long *stat)
{    	
    return m__dxj_DirectSoundCaptureBuffer->GetStatus((DWORD*)stat);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::start(long flags)
{    	
    return m__dxj_DirectSoundCaptureBuffer->Start((DWORD)flags);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::stop()
{    	
    return m__dxj_DirectSoundCaptureBuffer->Stop();
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::getFormat(WaveFormatex *format)
{    	
	DWORD cb=0;
    return m__dxj_DirectSoundCaptureBuffer->GetFormat((WAVEFORMATEX*)format,sizeof(WaveFormatex),&cb);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::initialize(I_dxj_DirectSoundCaptureBuffer *buffer,DSCBufferDesc *desc)
{    	
	((DSCBUFFERDESC*)desc)->dwSize=sizeof(DSCBUFFERDESC);
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDCAPTURE, lpref, buffer);
    return m__dxj_DirectSoundCaptureBuffer->Initialize(lpref,(DSCBUFFERDESC*)desc);
}

STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::setNotificationPositions (long nElements,SAFEARRAY  **ppsa)
{
	if (!ISSAFEARRAY1D(ppsa,(DWORD)nElements))
		return E_INVALIDARG;
	
	HRESULT hr;
	LPDIRECTSOUNDNOTIFY pDSN=NULL;
	hr=m__dxj_DirectSoundCaptureBuffer->QueryInterface(IID_IDirectSoundNotify,(void**)&pDSN);
	if FAILED(hr) return hr;

    hr=pDSN->SetNotificationPositions((DWORD)nElements,(LPCDSBPOSITIONNOTIFY)((SAFEARRAY*)*ppsa)->pvData);	
		
	pDSN->Release();

	return hr;
}

        

/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::writeBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 
	#pragma message ("SoundBuffer writeBuffer ")

	byte *buffer=(byte*)buf; //(byte*)((SAFEARRAY*)*ppsa)->pvData;

	if(!buffer)
		return E_POINTER;

	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	__try {
	if ((val = m__dxj_DirectSoundCaptureBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (size1)	
		memcpy (p1, &buffer[start], size1);

	if (size2)	
		memcpy(p2, &buffer, size2);

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	val=m__dxj_DirectSoundCaptureBuffer->Unlock(p1, size1, p2, size2);
	}
	__except(0,0){
		return E_FAIL;
	}
	return val;
}


/////////////////////////////////////////////////////////////////////////////
//Java has no direct access to system memory, so it allocates it's own buffer
//which is passed into WriteBuffer(). Because the environment is now double
//buffered there is no need to Lock Java memory. WriteBuffer() calls
//both lock and Unlock internally to write the result after the fact.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundCaptureBufferObject::readBuffer(long start, long totsz, 
													void  *buf,  long flags) 
{ 

	//byte *buffer=(byte*)((SAFEARRAY*)*ppsa)->pvData;
	byte *buffer=(byte*)buf;

	if(!buffer)
		return E_POINTER;
	
	LPVOID	p1, p2;
	DWORD	size1=0, size2=0;
	HRESULT val = E_FAIL;
	
   __try {
	if ((val = m__dxj_DirectSoundCaptureBuffer->Lock((DWORD)start, (DWORD)totsz, &p1, &size1, &p2, &size2, 
															(DWORD)flags)) != DS_OK)
		return val;

	// Copy to buffer end, then do a wrapped portion if it exists, then unlock
	if (size1)	
		memcpy (&buffer[start],p1,  size1);

	if (size2)	
		memcpy(&buffer,p2,  size2);

	//docdoc: because Lock and Unlock are tied together within WriteBuffer,
	//        DSBufferDesc no longer needs to save Lock's system pointers.
	val= m__dxj_DirectSoundCaptureBuffer->Unlock(p1, size1, p2, size2);
   }
   __except(0,0){
	return E_FAIL;
   }
   return val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsoundcaptureobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundcaptureobj.cpp
//
//--------------------------------------------------------------------------

// dSoundCaptureObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file
#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"

#include "dms.h"
#include "dSoundObj.h"
#include "dSoundCaptureObj.h"
#include "dSoundCaptureBufferObj.h"

CONSTRUCTOR(_dxj_DirectSoundCapture, {});
DESTRUCTOR(_dxj_DirectSoundCapture, {});
GETSET_OBJECT(_dxj_DirectSoundCapture);

   

STDMETHODIMP C_dxj_DirectSoundCaptureObject::createCaptureBuffer(
	DSCBufferDesc *desc,I_dxj_DirectSoundCaptureBuffer **retval)
{
    
	HRESULT hr = DD_OK;
	IDirectSoundCaptureBuffer *lpBuffer=NULL;
	DSCBUFFERDESC *realDesc=(DSCBUFFERDESC*)desc;


	realDesc->dwSize=sizeof(DSCBUFFERDESC);	
	desc->pFormat=(long)PtrToLong(&(desc->fxFormat));	//bugbug SUNDOWN

    hr=m__dxj_DirectSoundCapture->CreateCaptureBuffer(realDesc,&lpBuffer,NULL);	
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_DirectSoundCaptureBuffer, lpBuffer, retval);
	return hr;
}

STDMETHODIMP C_dxj_DirectSoundCaptureObject::getCaps(DSCCaps *caps){
	((DSCCAPS*)caps)->dwSize=sizeof(DSCCAPS);
	return m__dxj_DirectSoundCapture->GetCaps((DSCCAPS*)caps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsoundcapturebufferobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsoundcapturebufferobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundCaptureBufferObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundCaptureBuffer LPDIRECTSOUNDCAPTUREBUFFER

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundCaptureBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundCaptureBuffer, &IID_I_dxj_DirectSoundCaptureBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundCaptureBuffer,
#endif

//	public CComCoClass<C_dxj_DirectSoundCaptureBufferObject, &CLSID__dxj_DirectSoundCaptureBuffer>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundCaptureBufferObject() ;
	virtual ~C_dxj_DirectSoundCaptureBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundCaptureBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundCaptureBuffer)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSoundCaptureBuffer,	"DIRECT.DirectSoundCaptureBuffer.5",		"DIRECT.DirectSoundCaptureBuffer.5",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundCaptureBufferObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundCaptureBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundCaptureBuffer
public:
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCBCaps __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE getCurrentPosition( DSCursors *desc);                  			

         HRESULT STDMETHODCALLTYPE getFormat( 
            /* [out][in] */ WaveFormatex __RPC_FAR *waveformat);
        
         HRESULT STDMETHODCALLTYPE getStatus( 
            /* [retval][out] */ long __RPC_FAR *status);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE initialize( 
            /* [in] */ I_dxj_DirectSoundCaptureBuffer __RPC_FAR *captureBuffer,
            /* [in] */ DSCBufferDesc __RPC_FAR *bufferDesc);
        
         HRESULT STDMETHODCALLTYPE start( 
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE stop( void);

		 HRESULT  STDMETHODCALLTYPE setNotificationPositions(long nElements,SAFEARRAY  **ppsa);

		 HRESULT STDMETHODCALLTYPE readBuffer(long start, long totsz, 
													void  *buf,  long flags) ;
		 HRESULT STDMETHODCALLTYPE writeBuffer(long start, long totsz, 
													void  *buf,  long flags) ;


private:
    DECL_VARIABLE(_dxj_DirectSoundCaptureBuffer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundCaptureBuffer )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsoundcaptureobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dsoundcaptureobj.h
//
//--------------------------------------------------------------------------

// dSoundBufferObj.h : Declaration of the C_dxj_DirectSoundCaptureObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSoundCapture LPDIRECTSOUNDCAPTURE

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundCaptureObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSoundCapture, &IID_I_dxj_DirectSoundCapture, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSoundCapture,
#endif

	//public CComCoClass<C_dxj_DirectSoundCaptureObject, &CLSID__dxj_DirectSoundCapture>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundCaptureObject() ;
	virtual ~C_dxj_DirectSoundCaptureObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundCaptureObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSoundCapture)

#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSoundCapture,	"DIRECT.DirectSoundCapture.5",		"DIRECT.DirectSoundCapture.5",			IDS_DSOUNDBUFFER_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundCaptureObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundCaptureObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundCapture
public:
	//updated

         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE createCaptureBuffer( 
            /* [in] */ DSCBufferDesc __RPC_FAR *bufferDesc,
            /* [retval][out] */ I_dxj_DirectSoundCaptureBuffer __RPC_FAR *__RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCCaps __RPC_FAR *caps) ;

private:
    DECL_VARIABLE(_dxj_DirectSoundCapture);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSoundCapture )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsoundobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundobj.h
//
//--------------------------------------------------------------------------

// dSoundObj.h : Declaration of the C_dxj_DirectSoundObject
// DHF_DS entire file

#include "resource.h"       // main symbols

#define typedef__dxj_DirectSound  LPDIRECTSOUND
 
/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectSoundObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectSound, &IID_I_dxj_DirectSound, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectSound,
#endif

	//public CComCoClass<C_dxj_DirectSoundObject, &CLSID__dxj_DirectSound>, 
	public CComObjectRoot
{
public:
	C_dxj_DirectSoundObject() ;
	virtual ~C_dxj_DirectSoundObject() ;

BEGIN_COM_MAP(C_dxj_DirectSoundObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectSound)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_DirectSound, "DIRECT.DirectSound.3",				"DIRECT.DirectSound.3",					IDS_DSOUND_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectSoundObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectSoundBuffer
public:


         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE createSoundBuffer( 
            /* [in] */ DSBufferDesc __RPC_FAR *bufferDesc,
            /* [in] */ WaveFormatex __RPC_FAR *format,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE createSoundBufferFromFile( 
            /* [in] */ BSTR fileName,
            /* [out][in] */ DSBufferDesc __RPC_FAR *bufferDesc,
            /* [out] */ WaveFormatex __RPC_FAR *format,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE createSoundBufferFromResource( 
            /* [in] */ BSTR resourceFile,
            /* [in] */ BSTR resourceName,
            /* [out][in] */ DSBufferDesc __RPC_FAR *bufferDesc,
            /* [out] */ WaveFormatex __RPC_FAR *format,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *soundBuffer);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ DSCaps __RPC_FAR *caps);
        
         HRESULT STDMETHODCALLTYPE duplicateSoundBuffer( 
            /* [in] */ I_dxj_DirectSoundBuffer __RPC_FAR *original,
            /* [retval][out] */ I_dxj_DirectSoundBuffer __RPC_FAR *__RPC_FAR *duplicate);
        
         HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ HWnd hwnd,
            /* [in] */ long level);
        
        
         HRESULT STDMETHODCALLTYPE getSpeakerConfig( 
            /* [retval][out] */ long __RPC_FAR *speakerConfig);
        
         HRESULT STDMETHODCALLTYPE setSpeakerConfig( 
            /* [in] */ long speakerConfig);


////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectSound);
	GUID *m_pDriverGuid;

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectSound )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dxglob7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dxglob7obj.cpp
//
//--------------------------------------------------------------------------


#define DIRECTINPUT_VERSION 0x0500
#define DIRECTSOUND_VERSION 0x600

// dSoundResourceObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "windows.h"
#include "mmsystem.h"

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "math.h"

#include "dxGlob7Obj.h"


#include "d3drm.h"
#include "ddraw.h"
#include "dmusici.h"
#include "dmusicf.h"

#include "ddraw4Obj.h"    
#include "ddraw7Obj.h"
#include "DDEnumObj.h"
    	


#include "d3drm3Obj.h"

#include "dsoundObj.h"
#include "dsoundCaptureObj.h"
#include "DSEnumObj.h"    


#include "dplay4obj.h"
#include "dplaylobby3obj.h"
#include "DPEnumObj.h"

#include "dinput1Obj.h"




#include "dmSegmentObj.h"
#include "dmSegmentStateObj.h"
#include "dmChordMapObj.h"
#include "dmBandObj.h"
#include "dmCollectionObj.h"
#include "dmStyleObj.h"
#include "dmPerformanceObj.h"
#include "dmLoaderObj.h"
#include "dmComposerObj.h"


//#include "webObj.h"

extern HINSTANCE g_hInstD3DRMDLL;
extern HINSTANCE g_hDSoundHandle;
extern HINSTANCE g_hDPlay;
extern HINSTANCE g_hDDrawHandle;
extern HINSTANCE g_hInstDINPUTDLL;
extern HINSTANCE g_hInst;

extern HRESULT BSTRtoPPGUID(LPGUID*,BSTR);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);

extern void *g_dxj_DirectMusicLoader;
extern void *g_dxj_DirectMusicComposer;
extern void *g_dxj_DirectMusicPerformance;

extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLBSTRtoGUID(LPGUID pGuid,BSTR str);

extern HINSTANCE LoadDDrawDLL();
extern HINSTANCE LoadD3DXOFDLL();
extern HINSTANCE LoadDPlayDLL();
extern HINSTANCE LoadDSoundDLL();
extern HINSTANCE LoadD3DRMDLL();
extern HINSTANCE LoadDINPUTDLL();

DWORD WINAPI ThreadFunc(LPVOID param);

C_dxj_DirectX7Object::C_dxj_DirectX7Object(){
        	

    m_pDirectDrawCreate=NULL;
    m_pDirectDrawCreateEx=NULL;
    m_pDirectDrawCreateClipper=NULL;
    m_pDirectSoundCreate=NULL;
    m_pDirectSoundEnumerate=NULL;
    m_pDirectSoundCaptureEnumerate=NULL;
	m_pDirectSoundCaptureCreate=NULL;
    m_pDirectPlayCreate=NULL;
    m_pDirectPlayEnumerate=NULL;
    m_pDirectPlayLobbyCreate=NULL;
    m_pDirect3DRMCreate=NULL;
    m_pDirectDrawEnumerate=NULL;
    m_pDirectDrawEnumerateEx=NULL;
    m_pEventList=NULL;
}

void C_dxj_DirectX7Object::LoadDSOUND()
{   
	if (!g_hDSoundHandle )	LoadDSoundDLL();  
    if (!m_pDirectSoundCreate)              m_pDirectSoundCreate = (DSOUNDCREATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCreate" );
    if (!m_pDirectSoundCaptureCreate)       m_pDirectSoundCaptureCreate = (DSOUNDCAPTURECREATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCaptureCreate" );
    if (!m_pDirectSoundEnumerate)           m_pDirectSoundEnumerate = (DSOUNDENUMERATE)GetProcAddress( g_hDSoundHandle, "DirectSoundEnumerateA" );
    if (!m_pDirectSoundCaptureEnumerate)    m_pDirectSoundCaptureEnumerate = (DSOUNDCAPTUREENUMERATE)GetProcAddress( g_hDSoundHandle, "DirectSoundCaptureEnumerateA" );
    
}

void C_dxj_DirectX7Object::LoadDDRAW()
{
    
    if (!g_hDDrawHandle ) LoadDDrawDLL();    	
    if (!m_pDirectDrawCreate)           m_pDirectDrawCreate = (DDRAWCREATE)GetProcAddress( g_hDDrawHandle, "DirectDrawCreate" );
    if (!m_pDirectDrawCreateEx)         m_pDirectDrawCreateEx = (DDRAWCREATEEX)GetProcAddress( g_hDDrawHandle, "DirectDrawCreateEx" );
    if (!m_pDirectDrawCreateClipper)    m_pDirectDrawCreateClipper = (DDCREATECLIPPER)GetProcAddress( g_hDDrawHandle, "DirectDrawCreateClipper" );
    if (!m_pDirectDrawEnumerate)        m_pDirectDrawEnumerate = (DDENUMERATE)GetProcAddress( g_hDDrawHandle, "DirectDrawEnumerateA" );
    if (!m_pDirectDrawEnumerateEx)    	m_pDirectDrawEnumerateEx = (DDENUMERATEEX)GetProcAddress( g_hDDrawHandle, "DirectDrawEnumerateExA" );
    
}

void C_dxj_DirectX7Object::LoadDPLAY()
{
    

    if (!g_hDPlay ) LoadDPlayDLL();
    
    //Note use of Wide char for DirectPlayLobby Create and
    //Ansi for DirectPlay
    if (!m_pDirectPlayCreate)           m_pDirectPlayCreate = (DIRECTPLAYCREATE)GetProcAddress( g_hDPlay, "DirectPlayCreate" );
    if (!m_pDirectPlayEnumerate)        m_pDirectPlayEnumerate = (DIRECTPLAYENUMERATE)GetProcAddress( g_hDPlay, "DirectPlayEnumerateW" );
    if (!m_pDirectPlayLobbyCreate)      m_pDirectPlayLobbyCreate = (DIRECTPLAYLOBBYCREATE)GetProcAddress( g_hDPlay, "DirectPlayLobbyCreateW" );
    

}

void C_dxj_DirectX7Object::LoadD3DRM()
{
    
    if (!g_hInstD3DRMDLL)  {
            LoadD3DXOFDLL();
	        LoadD3DRMDLL();
    }

        //Note: always ansi no unicode version
    if (!m_pDirect3DRMCreate)           m_pDirect3DRMCreate =(DIRECT3DRMCREATE)GetProcAddress( g_hInstD3DRMDLL, "Direct3DRMCreate" );

    
            
}

C_dxj_DirectX7Object::~C_dxj_DirectX7Object()
{
    DWORD i=1;

    while (m_pEventList) {


 	//bugbug SUNDOWN gotcha
  	//vb does not have 64 bit values 
	//and we use the same api to release the event
	//but handles are 64 bit
	//note handles never get near 32 bits in win32
	//but whose knows on win64
        	destroyEvent((long)PtrToLong(m_pEventList->hEvent));

    	//m_pEventList=m_pEventList->pNext; done by destroyEvent
    }
}


STDMETHODIMP C_dxj_DirectX7Object::direct3dRMCreate( I_dxj_Direct3dRM3 **ret){
    HRESULT		  hr;
    LPDIRECT3DRM  realrm1=NULL;
    LPDIRECT3DRM3 realrm3=NULL;

    LoadD3DRM();


    if (!m_pDirect3DRMCreate) return E_FAIL;

    hr=(m_pDirect3DRMCreate)(&realrm1);
    if FAILED(hr) return  hr;

    hr=realrm1->QueryInterface(IID_IDirect3DRM3,(void**) &realrm3);
    if FAILED(hr){
        realrm1->Release();
        return hr;
    }

    INTERNAL_CREATE(_dxj_Direct3dRM3,realrm3,ret);
    realrm1->Release();
    
    if (*ret==NULL) {
        realrm3->Release();
        return E_FAIL;
    }
    return hr;		
}


STDMETHODIMP C_dxj_DirectX7Object::directDraw4Create(BSTR strGuid, I_dxj_DirectDraw4 **ret){
    HRESULT		  hr;
    LPDIRECTDRAW  realdraw1=NULL;
    LPDIRECTDRAW4 realdraw4=NULL;
    GUID		  guid;
    LPGUID		  pguid=&guid;
    DWORD		  i=0;

    LoadDDRAW();


    hr=BSTRtoPPGUID(&pguid,strGuid);
    if FAILED(hr) return E_FAIL;
        
    
    if (!m_pDirectDrawCreate) return E_FAIL;

    hr=(m_pDirectDrawCreate)((GUID*)pguid,&realdraw1,NULL);
    if FAILED(hr) return  hr;


    hr=realdraw1->QueryInterface(IID_IDirectDraw4,(void**) &realdraw4);
    if FAILED(hr){
        i=realdraw1->Release();
        return hr;
    }

    i=realdraw1->Release();
        
    INTERNAL_CREATE(_dxj_DirectDraw4,realdraw4,ret);


    
    if (*ret==NULL) {
        i=realdraw4->Release();
        return E_FAIL;
    }
    return hr;		
}


STDMETHODIMP C_dxj_DirectX7Object::directDrawCreate(BSTR strGuid, I_dxj_DirectDraw7 **ret){
    HRESULT		  hr;	
    LPDIRECTDRAW7 realdraw7=NULL;
    GUID		  guid;
    LPGUID		  pguid=&guid;
    DWORD		  i=0;

    LoadDDRAW();


    ZeroMemory(&guid,sizeof(GUID));	//andrewke bugfix post dx7

    hr=BSTRtoPPGUID(&pguid,strGuid);
    if FAILED(hr) return E_FAIL;
        
        
    if (!m_pDirectDrawCreateEx) return E_FAIL;


    hr=(m_pDirectDrawCreateEx)(pguid,(void**)&realdraw7,IID_IDirectDraw7,NULL);
    
    if FAILED(hr) return  hr;

        
    INTERNAL_CREATE(_dxj_DirectDraw7,realdraw7,ret);

    
    if (*ret==NULL) {
        i=realdraw7->Release();
        return E_FAIL;
    }
    return hr;		
}



STDMETHODIMP C_dxj_DirectX7Object::directSoundCreate(BSTR  strGuid, I_dxj_DirectSound **ret){
    HRESULT			hr;
    LPDIRECTSOUND	realsound1=NULL;
    GUID			guid;
    LPGUID			pguid=&guid;

    LoadDSOUND();

    hr=BSTRtoPPGUID(&pguid,strGuid);
    if FAILED(hr) return hr;

    if (!m_pDirectSoundCreate) return E_FAIL;

    hr=(m_pDirectSoundCreate)((GUID*)pguid,&realsound1,NULL);
    if FAILED(hr) return  hr;


    INTERNAL_CREATE(_dxj_DirectSound,realsound1,ret);
    
    if (*ret==NULL) {
        realsound1->Release();
        return E_FAIL;
    }

    return hr;		
}


STDMETHODIMP C_dxj_DirectX7Object::directSoundCaptureCreate(BSTR strGuid, I_dxj_DirectSoundCapture **ret){
    HRESULT		  hr;
    LPDIRECTSOUNDCAPTURE realsound1=NULL;
    GUID			guid;
    LPGUID			pguid=&guid;
    hr=BSTRtoPPGUID(&pguid,strGuid);
    if FAILED(hr) return hr;

	LoadDSOUND();


    if (!m_pDirectSoundCaptureCreate) return E_FAIL;

    hr=(m_pDirectSoundCaptureCreate)(pguid,&realsound1,NULL);
    if FAILED(hr) return  hr;


    INTERNAL_CREATE(_dxj_DirectSoundCapture,realsound1,ret);
    
    if (*ret==NULL) {
        realsound1->Release();
        return E_FAIL;
    }

    return hr;		
}


STDMETHODIMP C_dxj_DirectX7Object::getDSCaptureEnum( I_dxj_DSEnum **retVal)
{	
    HRESULT hr;

    LoadDSOUND();

    if (!m_pDirectSoundCaptureEnumerate) return E_FAIL;	
    hr=C_dxj_DSEnumObject::create(NULL,m_pDirectSoundCaptureEnumerate,retVal);

    return hr;

}
        




STDMETHODIMP C_dxj_DirectX7Object::getDDEnum( I_dxj_DirectDrawEnum **retVal)
{

    LoadDDRAW();

    HRESULT hr;
    if (!m_pDirectDrawEnumerateEx) return E_FAIL;	
    hr=C_dxj_DirectDrawEnumObject::create(m_pDirectDrawEnumerateEx,retVal);
    return hr;

}

/////////////////////////////////////////////////////////////////////////////


STDMETHODIMP C_dxj_DirectX7Object::getDSEnum( I_dxj_DSEnum **retVal)
{	
    HRESULT hr;
    LoadDSOUND();

    if (!m_pDirectSoundEnumerate) return E_FAIL;	
    hr=C_dxj_DSEnumObject::create(m_pDirectSoundEnumerate,NULL,retVal);

    return hr;

}




/////////////////////////////////////////////////////////////////////////////


STDMETHODIMP C_dxj_DirectX7Object::colorGetAlpha(long color, float *retval)
{
  static float (WINAPI *ProcAdd)(long)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){	
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (float (WINAPI*)(long)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMColorGetAlpha"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *retval=(ProcAdd) ((D3DCOLOR) color);  
  return S_OK;
}



STDMETHODIMP C_dxj_DirectX7Object::colorGetRed(long color, float *retval)
{
  static float (WINAPI *ProcAdd)(long)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;	
    ProcAdd = (float (WINAPI*)(long)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMColorGetRed"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *retval=(ProcAdd) ((D3DCOLOR) color);  
  return S_OK;
}

         
STDMETHODIMP C_dxj_DirectX7Object::colorGetGreen(long color, float *retval)
{
  static float (WINAPI *ProcAdd)(long)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;	
    ProcAdd = (float (WINAPI*)(long)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMColorGetGreen"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *retval=(ProcAdd) ((D3DCOLOR) color);  
  return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::colorGetBlue(long color, float *retval)
{
  static float (WINAPI *ProcAdd)(long)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (float (WINAPI*)(long)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMColorGetBlue"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *retval=(ProcAdd) ((D3DCOLOR) color);  
  return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::createColorRGB(float r, float g, float b, long *color)
{
  static long (WINAPI *ProcAdd)(float,float,float)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (long (WINAPI*)(float,float,float)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMCreateColorRGB"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *color=(ProcAdd) (r,g,b);  
  return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::createColorRGBA(float r, float g, float b, float a, long *color)
{
  static long (WINAPI *ProcAdd)(float,float,float,float)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (long (WINAPI*)(float,float,float,float)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMCreateColorRGBA"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *color=(ProcAdd) (r,g,b,a);  
  return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::matrixFromQuaternion(D3dMatrix *matrix, D3dRMQuaternion *quat)
{    
    if ((!matrix) || (!quat)) return E_INVALIDARG;

    D3DMATRIX *mat=(D3DMATRIX*)matrix;
    FLOAT w=quat->s;
    FLOAT x=quat->v.x;
    FLOAT y=quat->v.y;
    FLOAT z=quat->v.z;

    FLOAT xx = x*x,   xy = x*y,   xz = x*z,   xw = x*w;
    FLOAT yy = y*y,   yz = y*z,   yw = y*w;
    FLOAT zz = z*z,   zw = z*w;
    FLOAT ww = w*w;

    mat->_11 = xx-yy-zz+ww;
    mat->_12 = 2.0f*(xy-zw);
    mat->_13 = 2.0f*(xz+yw);

    mat->_21 = 2.0f*(xy+zw);
    mat->_22 = -xx+yy-zz+ww;
    mat->_23 = 2.0f*(yz-xw);

    mat->_31 = 2.0f*(xz-yw);
    mat->_32 = 2.0f*(yz+xw);
    mat->_33 = -xx-yy+zz+ww;

    mat->_14 = mat->_41 = 0.0f;
    mat->_24 = mat->_42 = 0.0f;
    mat->_34 = mat->_43 = 0.0f;
    mat->_44 = xx+yy+zz+ww;

return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::quaternionRotation(D3dRMQuaternion *quat, D3dVector *axis, float theta)
{
  static D3dRMQuaternion* (WINAPI *ProcAdd)(D3dRMQuaternion*,D3dVector*,float)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dRMQuaternion* (WINAPI*)(D3dRMQuaternion*,D3dVector*,float)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMQuaternionRotation"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if (NULL== (ProcAdd) (quat,axis,theta)) return E_FAIL;    
  return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::quaternionMultiply(D3dRMQuaternion *quatr, D3dRMQuaternion *quat1, D3dRMQuaternion *quat2)
{
  static D3dRMQuaternion* (WINAPI *ProcAdd)(D3dRMQuaternion*,D3dRMQuaternion*,D3dRMQuaternion*)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dRMQuaternion* (WINAPI*)(D3dRMQuaternion*,D3dRMQuaternion*,D3dRMQuaternion*)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMQuaternionMultiply"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if (NULL== (ProcAdd) (quatr,quat1,quat2)) return E_FAIL;
  return S_OK;
}


STDMETHODIMP C_dxj_DirectX7Object::quaternionSlerp(D3dRMQuaternion *quatr, D3dRMQuaternion *quat1, D3dRMQuaternion *quat2, float t)
{
  static D3dRMQuaternion* (WINAPI *ProcAdd)(D3dRMQuaternion*,D3dRMQuaternion*,D3dRMQuaternion*,float)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dRMQuaternion* (WINAPI*)(D3dRMQuaternion*,D3dRMQuaternion*,D3dRMQuaternion*,float)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMQuaternionSlerp"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if (NULL== (ProcAdd) (quatr,quat1,quat2,t)) return E_FAIL;
  return S_OK;
}


STDMETHODIMP C_dxj_DirectX7Object::vectorAdd(D3dVector *v, D3dVector *a, D3dVector *b)
{
  v->x = a->x + b->x;
  v->y = a->y + b->y;
  v->z = a->z + b->z;
  return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::vectorCopy(D3dVector *dest, D3dVector *src)
{
  memcpy(dest,src,sizeof(D3DVECTOR));

  return S_OK;
}


STDMETHODIMP C_dxj_DirectX7Object::vectorCrossProduct(D3dVector *v, D3dVector *a, D3dVector *b)
{
    v->x = ((a->y) * (b->z)) - ((a->z) * (b->y));
    v->y = ((a->z) * (b->x)) - ((a->x) * (b->z));
    v->z = ((a->x) * (b->y)) - ((a->y) * (b->x));

  return S_OK;
}        


STDMETHODIMP C_dxj_DirectX7Object::vectorDotProduct(D3dVector *a, D3dVector *b, float *ret)
{
  //TODO consider overflow?
  *ret =	(a->x * b->x) + (a->y *b->y) + (a->z * b->z);
      
  return S_OK;
}        

STDMETHODIMP C_dxj_DirectX7Object::vectorModulus(D3dVector *a,  float *ret)
{
  //NOTE: would do it myself but dont want to link in c runtime for Sqrt

  static float (WINAPI *ProcAdd)(D3dVector*)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (float (WINAPI*)(D3dVector*)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMVectorModulus"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  *ret=(ProcAdd) (a);    
  return S_OK;
    
}        


STDMETHODIMP C_dxj_DirectX7Object::vectorNormalize(D3dVector *dest)
{

    
    double l;

      
    l = dest->x * dest->x + dest->y * dest->y + dest->z * dest->z;
    l = sqrt(l);
    dest->x = dest->x / (float)l;
    dest->y = dest->y / (float)l;
    dest->z = dest->z / (float)l;

  return S_OK;
    
}        



STDMETHODIMP C_dxj_DirectX7Object::vectorRandom(D3dVector *a)
{
  static D3dVector* (WINAPI *ProcAdd)(D3dVector*)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dVector* (WINAPI*)(D3dVector*)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMVectorRandom"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if ((ProcAdd)(a)==NULL) return E_FAIL;    
  return S_OK;
    
}        


STDMETHODIMP C_dxj_DirectX7Object::vectorReflect(D3dVector *dest,D3dVector *ray,D3dVector *norm)
{
  static D3dVector* (WINAPI *ProcAdd)(D3dVector*,D3dVector*,D3dVector*)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dVector* (WINAPI*)(D3dVector*,D3dVector*,D3dVector*)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMVectorReflect"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if ((ProcAdd)(dest,ray,norm)==NULL) return E_FAIL;    
  return S_OK;	
}


STDMETHODIMP C_dxj_DirectX7Object::vectorRotate(D3dVector *dest,D3dVector *vA,D3dVector *vAxis, float theta)
{
  static D3dVector* (WINAPI *ProcAdd)(D3dVector*,D3dVector*,D3dVector*,float)=NULL;  
  LoadD3DRMDLL();
  if (ProcAdd==NULL){
    if (g_hInstD3DRMDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (D3dVector* (WINAPI*)(D3dVector*,D3dVector*,D3dVector*,float)) GetProcAddress(g_hInstD3DRMDLL, "D3DRMVectorRotate"); 
    if (ProcAdd==NULL) return E_FAIL;
  }		
  if ((ProcAdd)(dest,vA,vAxis,theta)==NULL) return E_FAIL;    
  return S_OK;	
}
        

STDMETHODIMP C_dxj_DirectX7Object::vectorScale(D3dVector *v, D3dVector *a, float factor)
{
    v->x=a->x *factor;
    v->y=a->y *factor;
    v->z=a->z *factor;
  return S_OK;
}        
        						   

STDMETHODIMP C_dxj_DirectX7Object::vectorSubtract(D3dVector *v, D3dVector *a, D3dVector *b)
{
  v->x = a->x - b->x;
  v->y = a->y - b->y;
  v->z = a->z - b->z;
  return S_OK;
}
  

      



STDMETHODIMP C_dxj_DirectX7Object::directPlayCreate(BSTR strGuid, I_dxj_DirectPlay4 **directPlay)
{
    LPDIRECTPLAY4	dp;
    HRESULT hr=E_FAIL;
    LPDIRECTPLAY lpDP=NULL;
    GUID	guid;
    
    LoadDPLAY();
    

    ZeroMemory(&guid,sizeof(GUID));


    hr=DPLBSTRtoGUID(&guid,strGuid);
    if FAILED(hr) return E_INVALIDARG;


    if (m_pDirectPlayCreate == NULL )	return E_FAIL;

    // create a DirectPlay1 interface
    hr = (m_pDirectPlayCreate)(&guid, &lpDP, NULL);
    if FAILED(hr) return hr;
    if (!lpDP) return E_FAIL;

    // now get Dplay3 interface
    hr = lpDP->QueryInterface(IID_IDirectPlay4,(LPVOID *)&dp);				
    lpDP->Release();
    if FAILED(hr) return hr;

    if (!dp) return E_FAIL;

    *directPlay=NULL;
    INTERNAL_CREATE(_dxj_DirectPlay4, dp, directPlay);
    if (*directPlay==NULL) return E_FAIL;

    return hr;
}


STDMETHODIMP C_dxj_DirectX7Object::directPlayLobbyCreate(I_dxj_DirectPlayLobby3 **ret)
{
    LPDIRECTPLAYLOBBY3	dp=NULL;
    HRESULT hr=E_FAIL;
    LPDIRECTPLAYLOBBY  lpDP=NULL;

    LoadDPLAY();

    if (m_pDirectPlayLobbyCreate == NULL )	return E_FAIL;


    // create a DirectPlay1 interface
    hr = m_pDirectPlayLobbyCreate(NULL, &lpDP, NULL,NULL,0);
    if FAILED(hr) return hr;

if (!lpDP) return E_FAIL;

    // no get Dplay3 interface
    hr = lpDP->QueryInterface(IID_IDirectPlayLobby3,(LPVOID *)&dp);			
    lpDP->Release();
if FAILED(hr) return hr;

    *ret=NULL;
    
if (!dp) return E_FAIL;

    INTERNAL_CREATE(_dxj_DirectPlayLobby3, dp, ret);
    if (*ret==NULL) return E_FAIL;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectX7Object::getDPEnum( I_dxj_DPEnumServiceProviders **retVal)
{	
    HRESULT hr;
    LoadDPLAY();


    if (!m_pDirectPlayEnumerate) return E_FAIL;	
    hr=C_dxj_DPEnumObject::create(m_pDirectPlayEnumerate,retVal);

    return hr;

}

////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectX7Object::directInputCreate(I_dxj_DirectInput **ret){
  
  LoadDINPUTDLL();

  HRESULT hr;
  static HRESULT (WINAPI *ProcAdd)(HINSTANCE,DWORD,LPDIRECTINPUT*,LPUNKNOWN)=NULL;  
  if (ProcAdd==NULL){
    if (g_hInstDINPUTDLL==NULL) return E_NOINTERFACE;
    ProcAdd = (HRESULT (WINAPI*)(HINSTANCE,DWORD,LPDIRECTINPUT*,LPUNKNOWN)) GetProcAddress(g_hInstDINPUTDLL, "DirectInputCreateA"); 
    if (ProcAdd==NULL) return E_FAIL;
  }	
 
  LPDIRECTINPUT lpInput=NULL;

  hr= (ProcAdd)(g_hInst,(DWORD)DIRECTINPUT_VERSION,&lpInput,NULL);
  if FAILED(hr) return hr;

  INTERNAL_CREATE(_dxj_DirectInput,lpInput,ret);	

  return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
STDMETHODIMP C_dxj_DirectX7Object::tickCount( long *retval)
{

    *retval = GetTickCount();

    return S_OK;
}


STDMETHODIMP C_dxj_DirectX7Object::systemBpp(long *retval)
{
    HDC hdc;

    hdc = ::GetDC(NULL);
    if (!hdc) return E_OUTOFMEMORY;
    *retval = GetDeviceCaps(hdc, BITSPIXEL);
    ::ReleaseDC(NULL, hdc);

    return S_OK;
}



STDMETHODIMP C_dxj_DirectX7Object::rotateXMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians){


        	//id matrix
        	float fcos;
        	float fsin;

        	ZeroMemory(mDest,sizeof(D3dMatrix));
        	mDest->rc11 = 1;
        	mDest->rc44 = 1;

        	fsin=(float)sin(radians);
        	fcos=(float)cos(radians);

        		
        	mDest->rc22 = fcos;
        	mDest->rc33 = fcos;
        	mDest->rc23 = -fsin;
        	mDest->rc32 = fsin;


        	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::rotateYMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians){

        	//id matrix
        	float fcos;
        	float fsin;

        	ZeroMemory(mDest,sizeof(D3dMatrix));
        	mDest->rc22 = 1;
        	mDest->rc44 = 1;

        	fsin=(float)sin(radians);
        	fcos=(float)cos(radians);

        		
        	mDest->rc11 = fcos;
        	mDest->rc33 = fcos;
        	mDest->rc13 = fsin;
        	mDest->rc31 = -fsin;

        	return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::rotateZMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians){


        	//id matrix
        	float fcos;
        	float fsin;

        	ZeroMemory(mDest,sizeof(D3dMatrix));
        	mDest->rc33 = 1;
        	mDest->rc44 = 1;

        	fsin=(float)sin(radians);
        	fcos=(float)cos(radians);

        		
        	mDest->rc11 = fcos;
        	mDest->rc22 = fcos;
        	mDest->rc12 = -fsin;
        	mDest->rc21 = fsin;

        	return S_OK;

}
        
STDMETHODIMP C_dxj_DirectX7Object::viewMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *view,
            /* [in] */ D3dVector __RPC_FAR *from,
            /* [in] */ D3dVector __RPC_FAR *at,
            /* [in] */ D3dVector __RPC_FAR *world_up,
            /* [in] */ float roll)
{

    


        D3dVector up;
        D3dVector right;
        D3dVector view_Dir;

        ZeroMemory(view,sizeof(D3dMatrix));
        view->rc11 = 1;
        view->rc22 = 1;
        view->rc33 = 1;
        view->rc44 = 1;

        view_Dir.x=at->x-from->x;
        view_Dir.y=at->y-from->y;
        view_Dir.z=at->z-from->z;
            
        vectorNormalize(&view_Dir);

        
        //think lefthanded coords
        vectorCrossProduct(&right, world_up, &view_Dir);
        vectorCrossProduct(&up, &view_Dir, &right);
    
        vectorNormalize(&right);
        vectorNormalize(&up);
    
        view->rc11 = right.x;
        view->rc21 = right.y;
        view->rc31 = right.z;
        view->rc12 = up.x ;  //AK? should this be negative?
        view->rc22 = up.y;
        view->rc32 = up.z;
        view->rc13 = view_Dir.x;
        view->rc23 = view_Dir.y;
        view->rc33 = view_Dir.z;
    
        view->rc41 =  -((right.x * from->x) + (right.y * from->y) + (right.z * from->z));
        view->rc42 =  -((up.x * from->x) + (up.y * from->y) + (up.z * from->z));
        view->rc43 =  -((view_Dir.x * from->x) + (view_Dir.y * from->y) + (view_Dir.z * from->z));


        if (roll!=0){
        	D3dMatrix rotZMat;
        	rotateZMatrix(&rotZMat,-roll);
        	matrixMultiply(view,&rotZMat,view);
        }


        return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::matrixMultiply( 
            /* [out][in] */ D3dMatrix __RPC_FAR *result,
          /* [in] */ D3dMatrix __RPC_FAR *a,
          /* [in] */ D3dMatrix __RPC_FAR *b)
{

  D3dMatrix ret;

  ZeroMemory(&ret,sizeof(D3dMatrix));
  ret.rc11 = b->rc11 * a->rc11 + b->rc21 * a->rc12 + b->rc31 * a->rc13 + b->rc41 * a->rc14;
  ret.rc12 = b->rc12 * a->rc11 + b->rc22 * a->rc12 + b->rc32 * a->rc13 + b->rc42 * a->rc14;
  ret.rc13 = b->rc13 * a->rc11 + b->rc23 * a->rc12 + b->rc33 * a->rc13 + b->rc43 * a->rc14;
  ret.rc14 = b->rc14 * a->rc11 + b->rc24 * a->rc12 + b->rc34 * a->rc13 + b->rc44 * a->rc14;
  ret.rc21 = b->rc11 * a->rc21 + b->rc21 * a->rc22 + b->rc31 * a->rc23 + b->rc41 * a->rc24;
  ret.rc22 = b->rc12 * a->rc21 + b->rc22 * a->rc22 + b->rc32 * a->rc23 + b->rc42 * a->rc24;
  ret.rc23 = b->rc13 * a->rc21 + b->rc23 * a->rc22 + b->rc33 * a->rc23 + b->rc43 * a->rc24;
  ret.rc24 = b->rc14 * a->rc21 + b->rc24 * a->rc22 + b->rc34 * a->rc23 + b->rc44 * a->rc24;
  ret.rc31 = b->rc11 * a->rc31 + b->rc21 * a->rc32 + b->rc31 * a->rc33 + b->rc41 * a->rc34;
  ret.rc32 = b->rc12 * a->rc31 + b->rc22 * a->rc32 + b->rc32 * a->rc33 + b->rc42 * a->rc34;
  ret.rc33 = b->rc13 * a->rc31 + b->rc23 * a->rc32 + b->rc33 * a->rc33 + b->rc43 * a->rc34;
  ret.rc34 = b->rc14 * a->rc31 + b->rc24 * a->rc32 + b->rc34 * a->rc33 + b->rc44 * a->rc34;
  ret.rc41 = b->rc11 * a->rc41 + b->rc21 * a->rc42 + b->rc31 * a->rc43 + b->rc41 * a->rc44;
  ret.rc42 = b->rc12 * a->rc41 + b->rc22 * a->rc42 + b->rc32 * a->rc43 + b->rc42 * a->rc44;
  ret.rc43 = b->rc13 * a->rc41 + b->rc23 * a->rc42 + b->rc33 * a->rc43 + b->rc43 * a->rc44;
  ret.rc44 = b->rc14 * a->rc41 + b->rc24 * a->rc42 + b->rc34 * a->rc43 + b->rc44 * a->rc44;
  memcpy(result,&ret,sizeof(D3dMatrix));
        
  return S_OK;

}
        
STDMETHODIMP C_dxj_DirectX7Object::projectionMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float near_plane,
            /* [in] */ float far_plane,
            /* [in] */ float fov)
{
    float c,s,Q;

        
    
    c =(float) cos(fov * 0.5);
    s = (float)sin(fov * 0.5);
    
    if (far_plane==0) return E_INVALIDARG;
    Q = s / (1 - near_plane / far_plane);

    ZeroMemory(mDest,sizeof(D3dMatrix));
    
    mDest->rc11 = c;
    mDest->rc22 = c;
    mDest->rc33 = Q;
    mDest->rc43 = -Q * near_plane;
    mDest->rc34 = s;

    return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::copyMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ D3dMatrix __RPC_FAR *mSrc)
{
    memcpy(mDest,mSrc,sizeof(D3dMatrix));
    return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::identityMatrix( 
          /* [out][in] */ D3dMatrix __RPC_FAR *mDest)
{
    ZeroMemory (mDest,sizeof(D3dMatrix));
    mDest->rc11=1;
    mDest->rc22=1;
    mDest->rc33=1;
    mDest->rc44=1;

    return S_OK;

}
        
STDMETHODIMP C_dxj_DirectX7Object::zeroMatrix( 
        	/* [out][in] */ D3dMatrix __RPC_FAR *mDest)
{
    ZeroMemory (mDest,sizeof(D3dMatrix));
    return S_OK;

}


STDMETHODIMP C_dxj_DirectX7Object::directMusicLoaderCreate ( 
            /* [retval][out] */ I_dxj_DirectMusicLoader __RPC_FAR *__RPC_FAR *ret)
{
    HRESULT hr;
    

    IDirectMusicLoader *pLoader=NULL;    


    hr =CoCreateInstance(
            CLSID_DirectMusicLoader, 
        	NULL,
            CLSCTX_INPROC,   
        	IID_IDirectMusicLoader,
            (void**)&pLoader);



    if (FAILED(hr))  return E_NOINTERFACE;
    
    if (!pLoader) return E_FAIL;
    INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicLoader,pLoader,ret);

    return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::directMusicComposerCreate ( 
            /* [retval][out] */ I_dxj_DirectMusicComposer __RPC_FAR *__RPC_FAR *ret)
{
    

    IDirectMusicComposer *pComp=NULL;    
    if (FAILED(CoCreateInstance(
            CLSID_DirectMusicComposer, 
        	NULL,
            CLSCTX_INPROC,   
        	IID_IDirectMusicComposer,
            (void**)&pComp        )))   {
         return E_NOINTERFACE;
    }
    if (!pComp) return E_FAIL;
    INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicComposer,pComp,ret);
    return S_OK;
}


STDMETHODIMP C_dxj_DirectX7Object::directMusicPerformanceCreate ( 
            /* [retval][out] */ I_dxj_DirectMusicPerformance __RPC_FAR *__RPC_FAR *ret)
{

        

    IDirectMusicPerformance *pPerf=NULL;    
    if (FAILED(CoCreateInstance(
            CLSID_DirectMusicPerformance, 
        	NULL,
            CLSCTX_INPROC,   
        	IID_IDirectMusicPerformance,
            (void**)&pPerf        )))   {
         return E_NOINTERFACE;
    }
    if (!pPerf) return E_FAIL;
    INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicPerformance,pPerf,ret);
    return S_OK;
}



STDMETHODIMP C_dxj_DirectX7Object::getWindowRect( 
            /* [in] */ long hwnd,
            /* [out][in] */ Rect __RPC_FAR *r) 
{
    BOOL b=GetWindowRect((HWND)hwnd,(LPRECT)r);
    if (!b) return E_FAIL;
    return S_OK;
}
        



STDMETHODIMP C_dxj_DirectX7Object::createEvent( 
            /* [in] */ I_dxj_DirectXEvent __RPC_FAR *event,
            /* [retval][out] */ long __RPC_FAR *h) 
{

    HRESULT	  hr;
    LPSTREAM  pStm=NULL;
    IUnknown *pUnk=NULL;

    HANDLE hEvent=NULL;	
    EVENTTHREADINFO *pNewEvent=NULL;
    EVENTTHREADINFO *pTemp=NULL;
    if (!event) return E_INVALIDARG;
    if (!h) return E_INVALIDARG;

    pNewEvent=(EVENTTHREADINFO*)malloc(sizeof(EVENTTHREADINFO));
    if (!pNewEvent) return E_OUTOFMEMORY;
    pNewEvent->pNext=NULL;
    pNewEvent->fEnd=FALSE;	
    pNewEvent->pCallback=event;
    pNewEvent->pStream=NULL;
    pNewEvent->threadID=0;

    event->AddRef();



    pNewEvent->hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (!pNewEvent->hEvent){
        free(pNewEvent);
        event->Release();
        return E_FAIL;
    }

    //pNewEvent->hEndEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    
    hr=event->QueryInterface(IID_IUnknown,(void**)&pUnk);
    if FAILED(hr) {
      	free(pNewEvent);
      	event->Release();
      	return E_FAIL;
    }

    hr=CoMarshalInterThreadInterfaceInStream(IID_IUnknown,pUnk,&pStm);
    if (pUnk) pUnk->Release();
    if FAILED(hr) {  			
      	free(pNewEvent);
      	event->Release();			
      	return E_FAIL;
    }

    pNewEvent->pStream=pStm;

    pNewEvent->hThread=CreateThread(NULL,0,ThreadFunc,(unsigned long*)pNewEvent,CREATE_SUSPENDED ,&pNewEvent->threadID);
    if (!pNewEvent->threadID) {
        	CloseHandle(pNewEvent->hEvent);
        	free(pNewEvent);
        	event->Release();
        	return E_FAIL;
    }


    if (!m_pEventList){
        m_pEventList=pNewEvent;
    }
    else{
        pTemp=m_pEventList;
        m_pEventList=pNewEvent;	
        pNewEvent->pNext=pTemp;
    }


    ResumeThread(pNewEvent->hThread);
        

*h=(long)PtrToLong(pNewEvent->hEvent); //bugbug SUNDOWN -
    return S_OK;
}
        
STDMETHODIMP C_dxj_DirectX7Object::setEvent( 
            /* [in] */ long eventId)  
{
    SetEvent((HANDLE)eventId);
    return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::destroyEvent( 
            /* [in] */ long eventId)  
{
    //find the info on the stack
    if (!m_pEventList) return E_INVALIDARG;

    EVENTTHREADINFO *pTemp=NULL;
    EVENTTHREADINFO *pLast=NULL;

    //rely on lazy evaluation
    for (pTemp=m_pEventList; ((pTemp)&&(pTemp->hEvent!=(HANDLE)eventId));pLast=pTemp,pTemp=pTemp->pNext);
    if (!pTemp) return E_INVALIDARG;

    //remove it from our Link List
    if (!pLast) {
        m_pEventList=pTemp->pNext;		
    }
    else {
        pLast->pNext=pTemp->pNext;
    }

    //indicate that we want to kill the thread
    pTemp->fEnd=TRUE;

    //Fire the event in case we are waiting	
    if (pTemp->hEvent) SetEvent(pTemp->hEvent);

    //Wait for it to finish out
    if (pTemp->hThread) WaitForSingleObject(pTemp->hThread,1000);

    //wait for the end event to signal
    //if (pTemp->hEndEvent) WaitForSingleObject(pTemp->hEndEvent,1000);

    //desctroy the event
    if (pTemp->hEvent) CloseHandle(pTemp->hEvent);
    //if (pTemp->hEndEvent) CloseHandle (pTemp->hEndEvent);
    
    if (pTemp->pCallback) pTemp->pCallback->Release();
    
    //thread is gone..
    
    //free the memory
    free(pTemp);

    return S_OK;
}

DWORD WINAPI ThreadFunc(LPVOID param){
    HRESULT hr;
    IUnknown *pUnk=NULL;
    EVENTTHREADINFO *pCntrl=(EVENTTHREADINFO *)param;
    I_dxj_DirectXEvent	*pVBCallback=NULL;
        

    OleInitialize(NULL);


    LCID LOCAL_SYSTEM_DEFAULT=GetSystemDefaultLCID();


    //note pstrm is released even on failure
    hr=CoGetInterfaceAndReleaseStream(pCntrl->pStream,IID_IUnknown,(void**)&pUnk);
    pCntrl->pCallback=NULL;	//since released to 0

    if FAILED(hr) return -1;
    if (!pUnk) return -1;
    

    
    hr=pUnk->QueryInterface(IID_I_dxj_DirectXEvent,(void**)&pVBCallback);
    pUnk->Release();

    if FAILED(hr) return -1;  

    while (pCntrl->fEnd==FALSE) 
    {
        WaitForSingleObject(pCntrl->hEvent,INFINITE);
      	if ((pVBCallback )&&(pCntrl->fEnd==FALSE))
    	{
     		pVBCallback->AddRef();
    		pVBCallback->DXCallback((long)PtrToLong(pCntrl->hEvent)); //bugbug SUNDOWN
      		pVBCallback->Release();
     	}
    }


    if (pVBCallback) pVBCallback->Release();

    OleUninitialize();

    //we need to syncronize the ending of the thread..
    //if (pCntrl->hEndEvent) SetEvent(pCntrl->hEndEvent);		
    
    return 0;
}


STDMETHODIMP C_dxj_DirectX7Object::createD3DVertex(float x, float y, float z, float nx, float ny, float nz, float tu, float tv,  D3dVertex *v)
{
    if (!v) return E_INVALIDARG;
    ((D3DVERTEX*)v)->x=x;
    ((D3DVERTEX*)v)->y=y;
    ((D3DVERTEX*)v)->z=z;
    ((D3DVERTEX*)v)->nx=nx;
    ((D3DVERTEX*)v)->ny=ny;
    ((D3DVERTEX*)v)->nz=nz;
    ((D3DVERTEX*)v)->tu=tu;
    ((D3DVERTEX*)v)->tv=tv;
    return S_OK;
}
STDMETHODIMP C_dxj_DirectX7Object::createD3DLVertex(float x, float y, float z, long color,  long specular,  float tu,  float tv,  D3dLVertex *v)
{
    if (!v) return E_INVALIDARG;
    ((D3DLVERTEX*)v)->x=x;
    ((D3DLVERTEX*)v)->y=y;
    ((D3DLVERTEX*)v)->z=z;
    ((D3DLVERTEX*)v)->color=color;
    ((D3DLVERTEX*)v)->specular=specular;
    ((D3DLVERTEX*)v)->dwReserved=0;
    ((D3DLVERTEX*)v)->tu=tu;
    ((D3DLVERTEX*)v)->tv=tv;
    return S_OK;
}
STDMETHODIMP C_dxj_DirectX7Object::createD3DTLVertex(float sx, float sy, float sz, float rhw, long color, long  specular, float tu, float tv,   D3dTLVertex *v)
{
    if (!v) return E_INVALIDARG;
    ((D3DTLVERTEX*)v)->sx=sx;
    ((D3DTLVERTEX*)v)->sy=sy;
    ((D3DTLVERTEX*)v)->sz=sz;
    ((D3DTLVERTEX*)v)->rhw=rhw;
    ((D3DTLVERTEX*)v)->color=color;
    ((D3DTLVERTEX*)v)->specular=specular;		
    ((D3DTLVERTEX*)v)->tu=tu;
    ((D3DTLVERTEX*)v)->tv=tv;
    return S_OK;
}

STDMETHODIMP C_dxj_DirectX7Object::createNewGuid(BSTR *ret)
{
	HRESULT hr;
  	GUID g=GUID_NULL;
  	if (!ret) return E_INVALIDARG;

  	hr=::CoCreateGuid(&g);
	if FAILED(hr) return hr;
  	*ret=GUIDtoBSTR(&g);
  	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dsoundobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsoundobj.cpp
//
//--------------------------------------------------------------------------

// dSoundObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include "dSoundObj.h"
#include "dSoundBufferObj.h"

extern HRESULT InternalCreateSoundBufferFromFile(LPDIRECTSOUND lpDirectSound,LPDSBUFFERDESC pDesc,WCHAR *file,LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer) ;
extern HRESULT InternalCreateSoundBufferFromResource(LPDIRECTSOUND lpDirectSound,LPDSBUFFERDESC pDesc,HANDLE resHandle,WCHAR *resName,LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer);

CONSTRUCTOR(_dxj_DirectSound, {m__dxj_DirectSound=NULL;m_pDriverGuid=NULL;});
DESTRUCTOR(_dxj_DirectSound,  {if (m_pDriverGuid) delete m_pDriverGuid;});
GETSET_OBJECT(_dxj_DirectSound);
	//
    /*** IDirectSound methods ***/
	//

PASS_THROUGH_CAST_1_R(_dxj_DirectSound, getSpeakerConfig, GetSpeakerConfig, long*,(DWORD*)); 
PASS_THROUGH_CAST_1_R(_dxj_DirectSound, setSpeakerConfig, SetSpeakerConfig, long,(DWORD)); 

STDMETHODIMP C_dxj_DirectSoundObject::getCaps(DSCaps* caps)
{
	caps->lSize = sizeof(DSCAPS);
	return m__dxj_DirectSound->GetCaps((LPDSCAPS)caps); 
}

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectSoundObject::setCooperativeLevel(HWnd h, long d)
{
	if( m__dxj_DirectSound == NULL )
		return E_FAIL;

	return m__dxj_DirectSound->SetCooperativeLevel((HWND)h, (DWORD)d); 
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectSoundObject::duplicateSoundBuffer(I_dxj_DirectSoundBuffer *src, 
													I_dxj_DirectSoundBuffer **val) 
{
	if(! (src && val) )
		return E_POINTER;

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDBUFFER, lpdsb, src);

	//Need to create a second one
	LPDIRECTSOUNDBUFFER		dsb=0;
	HRESULT hr=DD_OK;
	hr=m__dxj_DirectSound->DuplicateSoundBuffer((LPDIRECTSOUNDBUFFER)lpdsb, &dsb); 
	if(hr == DD_OK)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}
	return hr;
}

#pragma message ("Consider putting waveformat back in DSBufferDesc")

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectSoundObject::createSoundBuffer(DSBufferDesc *desc, 
			WaveFormatex *wave, I_dxj_DirectSoundBuffer **val) 
{
	LPDIRECTSOUNDBUFFER		dsb;	// Need to get the buffer first
	BOOL bDirty=FALSE;

	// make Java desc look like DirectX desc
	desc->lSize = sizeof(DSBUFFERDESC);
	
	for (int i=0;i<sizeof(WAVEFORMATEX);i++) {
		if (((byte*)wave)[i]!=0) bDirty=TRUE;
	}

	if (bDirty==TRUE){
		desc->lpwfxFormat = PtrToLong(wave);	//bugbug SUNDOWN
	}
	else {
		desc->lpwfxFormat = 0;
	}

	LPDSBUFFERDESC lpds ;
	lpds = (LPDSBUFFERDESC)desc;
	HRESULT hr=S_OK;
	hr = m__dxj_DirectSound->CreateSoundBuffer(lpds, &dsb, NULL);
 
	if(hr == DD_OK)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}
	return hr;
}

STDMETHODIMP C_dxj_DirectSoundObject::createSoundBufferFromFile(BSTR fileName, DSBufferDesc *desc, 
			WaveFormatex *wave, I_dxj_DirectSoundBuffer **val) 
{
	LPDIRECTSOUNDBUFFER		dsb;	// Need to get the buffer first
	LPDSBUFFERDESC			lpds ;
	HRESULT					hr=S_OK;

		
	*val=NULL;	
	desc->lSize = sizeof(DSBUFFERDESC);
	desc->lpwfxFormat = (long)PtrToLong(wave);		//bugbug SUNDOWN
	lpds = (LPDSBUFFERDESC)desc;
	
	hr=InternalCreateSoundBufferFromFile(m__dxj_DirectSound,(LPDSBUFFERDESC)desc,
			(WCHAR*)fileName,&dsb); 

	if(hr == DD_OK)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}
	return hr;


}



STDMETHODIMP C_dxj_DirectSoundObject::createSoundBufferFromResource(BSTR resFile, BSTR resName, DSBufferDesc *desc, 
			WaveFormatex *wave, I_dxj_DirectSoundBuffer **val) 
{

		
	
	LPDIRECTSOUNDBUFFER		dsb;	// Need to get the buffer first
	LPDSBUFFERDESC			lpds ;
	HRESULT					hr=S_OK;	
	HMODULE					hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((resFile) &&(resFile[0]!=0)){
		// NOTE
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// use ansi verion
		 LPCTSTR pszName = W2T(resFile);
		 hMod= GetModuleHandle(pszName);
	}

		
	*val=NULL;	
	desc->lSize = sizeof(DSBUFFERDESC);
	desc->lpwfxFormat = (long)PtrToLong(wave);	//NOTE SUNDOWN issue
	lpds = (LPDSBUFFERDESC)desc;
	
	hr=InternalCreateSoundBufferFromResource(m__dxj_DirectSound,(LPDSBUFFERDESC)desc,
			(HANDLE)hMod,(WCHAR*)resName,&dsb);

	
	if(hr == DD_OK)
	{
		INTERNAL_CREATE(_dxj_DirectSoundBuffer, dsb, val);
	}


	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\dxglob7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dxglob7obj.h
//
//--------------------------------------------------------------------------


#include "resource.h"       // main symbols


typedef HRESULT (__stdcall *DDRAWCREATE)( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
typedef HRESULT (__stdcall *DDCREATECLIPPER)( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
typedef HRESULT (__stdcall *DDENUMERATE)(LPDDENUMCALLBACK, LPVOID);
typedef HRESULT (__stdcall *DDENUMERATEEX)(LPDDENUMCALLBACKEX, LPVOID, DWORD);
typedef HRESULT (__stdcall *DIRECT3DRMCREATE)(LPDIRECT3DRM *lpCreate);
typedef HRESULT (__stdcall *DSOUNDCREATE)(GUID FAR * lpGUID, LPDIRECTSOUND * ppDS, IUnknown FAR *pUnkOuter );
typedef HRESULT (__stdcall *DSOUNDCAPTURECREATE)(GUID FAR * lpGUID, LPDIRECTSOUNDCAPTURE * ppDS, IUnknown FAR *pUnkOuter );
typedef HRESULT (CALLBACK *DSOUNDENUMERATE)(LPDSENUMCALLBACK lpCallback, LPVOID lpContext );
typedef HRESULT (CALLBACK *DSOUNDCAPTUREENUMERATE)(LPDSENUMCALLBACK lpCallback, LPVOID lpContext );
typedef HRESULT (__stdcall *DIRECTPLAYCREATE)( LPGUID lpGUID, LPDIRECTPLAY *lplpDP, IUnknown *pUnk);
typedef HRESULT (__stdcall *DIRECTPLAYENUMERATE)( LPDPENUMDPCALLBACK, LPVOID );
typedef HRESULT (__stdcall *DIRECTPLAYLOBBYCREATE)(LPGUID, LPDIRECTPLAYLOBBY *, IUnknown *, LPVOID, DWORD );
typedef HRESULT (__stdcall *DDRAWCREATEEX)(  GUID FAR * rGuid, LPVOID  *lplpDD, REFIID  iid,IUnknown FAR *pUnkOuter );


typedef struct tag_EVENTTHREADINFO {
	HANDLE hEvent;
	struct tag_EVENTTHREADINFO *pNext;
	IStream *pStream;
	I_dxj_DirectXEvent *pCallback;
	DWORD threadID;
	HANDLE hThread;
	BOOL	fEnd;
	HANDLE  hEndEvent;
} EVENTTHREADINFO;


class C_dxj_DirectX7Object :
	public I_dxj_DirectX7,
	public CComCoClass<C_dxj_DirectX7Object, &CLSID__dxj_DirectX7>, public CComObjectRoot
{
public:
	C_dxj_DirectX7Object() ;
	virtual ~C_dxj_DirectX7Object() ;

BEGIN_COM_MAP(C_dxj_DirectX7Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectX7)
END_COM_MAP()

	DECLARE_REGISTRY(CLSID__dxj_DirectX7,	"DIRECT.DirectX6.0",		"DIRECT.DirectX6.0",	IDS_DIRECTX6_DESC, THREADFLAGS_BOTH)

// Use DECLARE_NOT_AGGREGATABLE(C_dxj_DirectSoundResourceObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(C_dxj_DirectX7Object)


public:

        HRESULT STDMETHODCALLTYPE direct3dRMCreate( 
            /* [retval][out] */ I_dxj_Direct3dRM3 __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directDrawCreate( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectDraw7 __RPC_FAR *__RPC_FAR *ret);        
			
        HRESULT STDMETHODCALLTYPE getDDEnum( 
            /* [retval][out] */ I_dxj_DirectDrawEnum __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directSoundCreate( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectSound __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directSoundCaptureCreate( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectSoundCapture __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getDSEnum( 
            /* [retval][out] */ I_dxj_DSEnum __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE getDSCaptureEnum( 
            /* [retval][out] */ I_dxj_DSEnum __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE directInputCreate( 
            /* [retval][out] */ I_dxj_DirectInput __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directPlayCreate( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectPlay4 __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directPlayLobbyCreate( 
            /* [retval][out] */ I_dxj_DirectPlayLobby3 __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE getDPEnum( 
            /* [retval][out] */ I_dxj_DPEnumServiceProviders __RPC_FAR *__RPC_FAR *retval);
        
        HRESULT STDMETHODCALLTYPE colorGetAlpha( 
            /* [in] */ long color,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE colorGetBlue( 
            /* [in] */ long color,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE colorGetGreen( 
            /* [in] */ long color,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE colorGetRed( 
            /* [in] */ long color,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE createColorRGB( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b,
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE createColorRGBA( 
            /* [in] */ float r,
            /* [in] */ float g,
            /* [in] */ float b,
            /* [in] */ float a,
            /* [retval][out] */ long __RPC_FAR *color);
        
        HRESULT STDMETHODCALLTYPE matrixFromQuaternion( 
            /* [out] */ D3dMatrix __RPC_FAR *matrix,
            /* [in] */ D3dRMQuaternion __RPC_FAR *quat);
        
        HRESULT STDMETHODCALLTYPE quaternionRotation( 
            /* [out] */ D3dRMQuaternion __RPC_FAR *quat,
            /* [in] */ D3dVector __RPC_FAR *axis,
            /* [in] */ float theta);
        
        HRESULT STDMETHODCALLTYPE quaternionMultiply( 
            /* [out] */ D3dRMQuaternion __RPC_FAR *quat,
            /* [in] */ D3dRMQuaternion __RPC_FAR *quatA,
            /* [in] */ D3dRMQuaternion __RPC_FAR *quatB);
        
        HRESULT STDMETHODCALLTYPE quaternionSlerp( 
            /* [out] */ D3dRMQuaternion __RPC_FAR *quat,
            /* [in] */ D3dRMQuaternion __RPC_FAR *quatA,
            /* [in] */ D3dRMQuaternion __RPC_FAR *quatB,
            /* [in] */ float alpha);
        
        HRESULT STDMETHODCALLTYPE vectorAdd( 
            /* [out] */ D3dVector __RPC_FAR *v,
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ D3dVector __RPC_FAR *vB);
        
        HRESULT STDMETHODCALLTYPE vectorCrossProduct( 
            /* [out] */ D3dVector __RPC_FAR *v,
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ D3dVector __RPC_FAR *vB);
        
        HRESULT STDMETHODCALLTYPE vectorDotProduct( 
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ D3dVector __RPC_FAR *vB,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE vectorModulus( 
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [retval][out] */ float __RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE vectorNormalize( 
            /* [out][in] */ D3dVector __RPC_FAR *v);
        
        HRESULT STDMETHODCALLTYPE vectorRandom( 
            /* [out][in] */ D3dVector __RPC_FAR *v);
        
        HRESULT STDMETHODCALLTYPE vectorReflect( 
            /* [out] */ D3dVector __RPC_FAR *vDest,
            /* [in] */ D3dVector __RPC_FAR *vRay,
            /* [in] */ D3dVector __RPC_FAR *vNormal);
        
        HRESULT STDMETHODCALLTYPE vectorRotate( 
            /* [out] */ D3dVector __RPC_FAR *vDest,
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ D3dVector __RPC_FAR *vAxis,
            /* [in] */ float theta);
        
        HRESULT STDMETHODCALLTYPE vectorScale( 
            /* [out] */ D3dVector __RPC_FAR *vDest,
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ float factor);
        
        HRESULT STDMETHODCALLTYPE vectorSubtract( 
            /* [out] */ D3dVector __RPC_FAR *v,
            /* [in] */ D3dVector __RPC_FAR *vA,
            /* [in] */ D3dVector __RPC_FAR *vB);
        
        HRESULT STDMETHODCALLTYPE vectorCopy( 
            /* [out][in] */ D3dVector __RPC_FAR *vDest,
            /* [in] */ D3dVector __RPC_FAR *vSrc);
        
        HRESULT STDMETHODCALLTYPE rotateXMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians);
        
        HRESULT STDMETHODCALLTYPE rotateYMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians);
        
        HRESULT STDMETHODCALLTYPE rotateZMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float radians);
        
        HRESULT STDMETHODCALLTYPE viewMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ D3dVector __RPC_FAR *vFrom,
            /* [in] */ D3dVector __RPC_FAR *vTo,
            /* [in] */ D3dVector __RPC_FAR *vUp,
            /* [in] */ float roll);
        
        HRESULT STDMETHODCALLTYPE matrixMultiply( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ D3dMatrix __RPC_FAR *mA,
            /* [in] */ D3dMatrix __RPC_FAR *mB);
        
        HRESULT STDMETHODCALLTYPE projectionMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ float nearPlane,
            /* [in] */ float farplane,
            /* [in] */ float fov);
        
        HRESULT STDMETHODCALLTYPE copyMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest,
            /* [in] */ D3dMatrix __RPC_FAR *mSrc);
        
        HRESULT STDMETHODCALLTYPE identityMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest);
        
        HRESULT STDMETHODCALLTYPE zeroMatrix( 
            /* [out][in] */ D3dMatrix __RPC_FAR *mDest);
        
        
        HRESULT STDMETHODCALLTYPE tickCount( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE systemBpp( 
            /* [retval][out] */ long __RPC_FAR *retv);
        
      
        HRESULT STDMETHODCALLTYPE directMusicLoaderCreate( 
            /* [retval][out] */ I_dxj_DirectMusicLoader __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directMusicComposerCreate( 
            /* [retval][out] */ I_dxj_DirectMusicComposer __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE directMusicPerformanceCreate( 
            /* [retval][out] */ I_dxj_DirectMusicPerformance __RPC_FAR *__RPC_FAR *ret);
			
    
        HRESULT STDMETHODCALLTYPE getWindowRect( 
            /* [in] */ long hwnd,
            /* [out][in] */ Rect __RPC_FAR *r) ;
        
        HRESULT STDMETHODCALLTYPE createEvent( 
            /* [in] */ I_dxj_DirectXEvent __RPC_FAR *event,
            /* [retval][out] */ long __RPC_FAR *h) ;
        
        HRESULT STDMETHODCALLTYPE setEvent( 
            /* [in] */ long eventId) ;
        
        HRESULT STDMETHODCALLTYPE destroyEvent( 
            /* [in] */ long eventId) ;


		HRESULT STDMETHODCALLTYPE createD3DVertex(float x, float y, float z, float nx, float ny, float nz, float tu, float tv,  D3dVertex *v);
		HRESULT STDMETHODCALLTYPE createD3DLVertex(float x, float y, float z, long color,  long specular,  float tu,  float tv,  D3dLVertex *v);
		HRESULT STDMETHODCALLTYPE createD3DTLVertex(float sx, float sy, float sz, float rhw, long color, long  specular, float tu, float tv,   D3dTLVertex *v);

        HRESULT STDMETHODCALLTYPE directDraw4Create( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectDraw4 __RPC_FAR *__RPC_FAR *ret);        

		HRESULT STDMETHODCALLTYPE createNewGuid(BSTR *ret);

        void LoadDDRAW();
        void LoadDPLAY();
        void LoadDSOUND();
        void LoadDINPUT();
        void LoadD3DRM();

private:

	DDRAWCREATE				m_pDirectDrawCreate;
	DDRAWCREATEEX	    	m_pDirectDrawCreateEx;
	DDCREATECLIPPER			m_pDirectDrawCreateClipper;
	DSOUNDCREATE			m_pDirectSoundCreate;
	DSOUNDCAPTURECREATE		m_pDirectSoundCaptureCreate;
	DSOUNDENUMERATE			m_pDirectSoundEnumerate;
	DSOUNDCAPTUREENUMERATE	m_pDirectSoundCaptureEnumerate;
	DIRECTPLAYCREATE		m_pDirectPlayCreate;
	DIRECTPLAYENUMERATE		m_pDirectPlayEnumerate;
	DIRECTPLAYLOBBYCREATE	m_pDirectPlayLobbyCreate;
	DIRECT3DRMCREATE		m_pDirect3DRMCreate;
	DDENUMERATE				m_pDirectDrawEnumerate;
	DDENUMERATEEX			m_pDirectDrawEnumerateEx;
	EVENTTHREADINFO			*m_pEventList;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\frmsave.h ===
//**************************************************************************
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999 All Rights Reserved.
//
//  File:   frmsave.h
//
//  Description:    Save LPDIRECT3DRMFRAME to an x file.
//
//  History:
//      011/06/98    CongpaY     Created
//
//**************************************************************************

typedef struct _Header {
    WORD major;
    WORD minor;
    DWORD flags;
} Header;

typedef struct _ColorRGBA {
    float r;
    float g;
    float b;
    float a;
} ColorRGBA;

typedef struct _ColorRGB {
    float r;
    float g;
    float b;
} ColorRGB;

typedef struct _IndexedColor {
    DWORD index;
    ColorRGBA color;
} IndexedColor;

typedef struct _VertexColors {
    DWORD cVertices;
    IndexedColor vertexColors[1];
} VertexColors;

typedef struct _Boolean2d {
    BOOL u;
    BOOL v;
} Boolean2d;

typedef struct _FaceWraps {
    DWORD cFaces;
    Boolean2d faceWraps[1];
} FaceWraps;

typedef struct _Coords2d {
    float u;
    float v;
} Coords2d;

typedef struct _TextureCoords {
    DWORD cVertices;
    Coords2d textureCoords[1];
} TextureCoords;

typedef struct _FaceMaterials {
    DWORD cMaterials;
    DWORD cFaceIndexes;
    DWORD faceIndexes[1];
} FaceMaterials;

typedef struct _BaseMaterial {
    ColorRGBA faceColor;
    float power;
    ColorRGB specularColor;
    ColorRGB emissiveColor;
} BaseMaterial;

typedef struct _FaceMaterial {
    D3DCOLOR faceColor;
    LPDIRECT3DRMMATERIAL pMaterial;
    LPDIRECT3DRMTEXTURE pTexture;
    _FaceMaterial *pNext;
} FaceMaterial;

typedef void (__stdcall *CREATEXFILE)( IDirectXFile **);

class FaceMaterialList
{
    DWORD cElements;
    FaceMaterial *pFirst;	

public:
    FaceMaterialList();
    ~FaceMaterialList();

    DWORD Find(D3DCOLOR faceColor,
               LPDIRECT3DRMMATERIAL pMaterial,
               LPDIRECT3DRMTEXTURE pTexture);

    DWORD Count() { return cElements; }
    FaceMaterial *First() { return pFirst; }
};

class NameEntry {
public:
    LPSTR pName;
    NameEntry *pNext;
};

class NameList
{
    NameEntry *pFirst;
    NameEntry **ppLast;
public:
    NameList();
    ~NameList();
    void Add(LPSTR pName);
};

class Saver {
public:
    Saver();
    ~Saver();

    HRESULT Init(LPCSTR filename,
                 D3DRMXOFFORMAT d3dFormat,
                 D3DRMSAVEOPTIONS d3dSaveFlags);

    HRESULT SaveHeaderObject();
    
    HRESULT SaveFrame(LPDIRECT3DRMFRAME3 pFrame,
                      LPDIRECT3DRMFRAME3 pRefFrame = NULL,
                      LPDIRECTXFILEDATA  pRefFrameObj = NULL);
private:	
    LPDIRECTXFILE pXFile;
    LPDIRECTXFILESAVEOBJECT pSave;
    D3DRMXOFFORMAT d3dFormat;
    D3DRMSAVEOPTIONS d3dSaveFlags;
    NameList lNames;

    HRESULT SaveFrameTransform(LPDIRECTXFILEDATA pFrameObj,
                               LPDIRECT3DRMFRAME3 pFrame,
                               LPDIRECT3DRMFRAME3 pRefFrame);
    
    HRESULT SaveMeshBuilder(LPDIRECTXFILEDATA pFrameObj,
                            LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateMeshObject(DWORD cVertices,
                             DWORD cFaces,
                             DWORD dwFaceData,
                             LPDWORD pdwFaceData,
                             LPDIRECT3DRMMESHBUILDER3 pMeshBuilder,
                             LPDIRECTXFILEDATA *ppMeshObj);
    
    HRESULT CreateNormalsObject(LPDIRECTXFILEDATA pMeshObj,
                                DWORD cNormals,
                                DWORD cFaces,
                                DWORD dwFaceData,
                                LPDWORD pdwFaceData,
                                LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateVertexColorsObject(LPDIRECTXFILEDATA pMeshObj,
                                     DWORD cVertices,
                                     LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
    
    HRESULT CreateMaterialListObject(LPDIRECTXFILEDATA pMeshObj,
                                     LPDIRECT3DRMFACEARRAY pFaceArray);
    
    HRESULT CreateMaterialObject(LPDIRECTXFILEDATA pMatListObj,
                                 FaceMaterial *pMat);
    
    HRESULT CreateTextureWrapsObject(LPDIRECTXFILEDATA pMeshObj,
                                     LPDIRECT3DRMFACEARRAY pFaceArray);
    
    HRESULT CreateTextureCoordsObject(LPDIRECTXFILEDATA pMeshObj,
                                      DWORD cVertices,
                                      LPDIRECT3DRMMESHBUILDER3 pMeshBuilder);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\guids.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       guids.cpp
//
//--------------------------------------------------------------------------

#define DIRECTSOUND_VERSION 0x600


#define INITGUID 1
#include "objbase.h"
#include "dmusici.h"
#include "dsound.h"
#include "dplay.h"
#include "dplobby.h"
#include "ddraw.h"
#include "d3drm.h"
#include "d3drmwin.h"
#include "d3d.h"
#include "dinput.h"
#include "rmxfguid.h"
//#include "rmxftmpl.h"
#include <dxfile.h>


int pad;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\frmsave.cpp ===
//**************************************************************************
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999 All Rights Reserved.
//
//  File:   frmsave.cpp
//
//  Description:    Save LPDIRECT3DRMFRAME to an x file.
//
//  History:
//      011/06/98    CongpaY     Created
//
//**************************************************************************


#include <d3drm.h>
#include <dxfile.h>
#include <rmxftmpl.h>
#include <rmxfguid.h>
#include "frmsave.h"

extern HINSTANCE g_hInstD3DXOFDLL;

#define MyD3DRMColorGetAlpha(color)  ((float)((color & 0xFF000000)>>24)/(float)255)
#define MyD3DRMColorGetRed(color)  ((float)((color & 0x00FF0000)>>16)/(float)255)
#define MyD3DRMColorGetGreen(color)  ((float)((color & 0x0000FF00)>>8)/(float)255)
#define MyD3DRMColorGetBlue(color)  ((float)((color & 0x000000FF))/(float)255)


HRESULT FrameToXFile(LPDIRECT3DRMFRAME3 pFrame,
                     LPCSTR filename,
                     D3DRMXOFFORMAT d3dFormat,
                     D3DRMSAVEOPTIONS d3dSaveFlags)
{
    Saver saver;
    saver.Init(filename, d3dFormat, d3dSaveFlags);
    saver.SaveHeaderObject();
    saver.SaveFrame(pFrame);
    return S_OK;
}

Saver::Saver()
{
	pXFile=NULL;
	pSave=NULL;
}

Saver::~Saver()
{
    if (pSave) pSave->Release();
    if (pXFile) pXFile->Release();
}

HRESULT Saver::Init(LPCSTR filename,
                    D3DRMXOFFORMAT d3dFormatArg,
                    D3DRMSAVEOPTIONS d3dSaveFlagsArg)
{
    HRESULT hr;
    d3dFormat = d3dFormatArg;
    d3dSaveFlags = d3dSaveFlagsArg;


    CREATEXFILE pCreateXFile=(CREATEXFILE)GetProcAddress( g_hInstD3DXOFDLL, "DirectXFileCreate" );	
    if (!pCreateXFile) return E_NOTIMPL;
		
	
    DXFILEFORMAT xFormat;

    if (d3dFormat == D3DRMXOF_BINARY)
        xFormat = DXFILEFORMAT_BINARY;
    else if (d3dFormat == D3DRMXOF_TEXT)
        xFormat = DXFILEFORMAT_TEXT;
    else
        xFormat = DXFILEFORMAT_COMPRESSED;

    //DirectXFileCreate(&pXFile);
    pCreateXFile(&pXFile);
    if (!pXFile) return E_FAIL;
    
    hr=pXFile->RegisterTemplates((LPVOID)D3DRM_XTEMPLATES, D3DRM_XTEMPLATE_BYTES);
    if FAILED(hr) 
    {
	pXFile->Release();
	pXFile=NULL;
	return hr;
    }

    hr=pXFile->CreateSaveObject(filename, xFormat, &pSave);
    if FAILED(hr) 
    {
	pXFile->Release();
	pXFile=NULL;
	pSave=NULL;
	return hr;
    }

    return S_OK;
}

HRESULT Saver::SaveHeaderObject()
{
    LPDIRECTXFILEDATA pHeader=NULL;
    Header data;
    HRESULT hr;

    data.major = 1;
    data.minor = 0;
    data.flags = (d3dFormat == D3DRMXOF_TEXT)? 1 : 0;

    if (!pSave) return E_FAIL;

    hr=pSave->CreateDataObject(TID_DXFILEHeader,
                            NULL,
                            NULL,
                            sizeof(Header),
                            &data,
                            &pHeader);
    if FAILED(hr) return hr;
    if (!pHeader) return hr;	

    hr=pSave->SaveData(pHeader);
    pHeader->Release();
    return hr;
}

HRESULT Saver::SaveFrame(LPDIRECT3DRMFRAME3 pFrame,
                         LPDIRECT3DRMFRAME3 pRefFrame,
                         LPDIRECTXFILEDATA pRefFrameObj)
{
    DWORD i;
    HRESULT hr;
    LPDIRECTXFILEDATA pFrameObj=NULL;

    if (!pSave) return E_FAIL;
    if (!pFrame) return E_FAIL;

    hr=pSave->CreateDataObject(TID_D3DRMFrame,
                            NULL, 
                            NULL,
                            0,
                            NULL,
                            &pFrameObj);
    if FAILED(hr) return hr;
    if (!pFrameObj) return E_FAIL;

    hr=SaveFrameTransform(pFrameObj, pFrame, pRefFrame);
    if FAILED(hr) {
	pFrameObj->Release();
	return hr;  
    }    

    // Enumerate visuals.

    DWORD cVisuals=0;

    hr=pFrame->GetVisuals(&cVisuals, NULL);
    if FAILED(hr) {
	pFrameObj->Release();
	return hr;  
    }    
	

    if (cVisuals)
    {
        LPUNKNOWN *ppUnk = new LPUNKNOWN[cVisuals];

        hr=pFrame->GetVisuals(&cVisuals, ppUnk);
	if SUCCEEDED(hr)
	{
            for (i = 0; i < cVisuals; i++)
            {
              LPDIRECT3DRMFRAME3 pChildFrame;
	      if (ppUnk[i]) 
              {
                 hr = ppUnk[i]->QueryInterface(IID_IDirect3DRMFrame3, (LPVOID *)&pChildFrame);

                 if (SUCCEEDED(hr))
                 {
                   SaveFrame(pChildFrame, pFrame, pFrameObj);
                   pChildFrame->Release();
                 }
                 else
                 {
                   LPDIRECT3DRMMESHBUILDER3 pMeshBuilder;
                   hr = ppUnk[i]->QueryInterface(IID_IDirect3DRMMeshBuilder3, (LPVOID *)&pMeshBuilder);
     
                   if (SUCCEEDED(hr))
                   {
                       SaveMeshBuilder(pFrameObj, pMeshBuilder);
                       pMeshBuilder->Release();
                   }
	        }         
                ppUnk[i]->Release();
             }
          }
	
          delete[] ppUnk;
       }
    }  //cVisuals

    // Enumerate child frames.

    LPDIRECT3DRMFRAMEARRAY pFrameArray=NULL;

    hr=pFrame->GetChildren(&pFrameArray);
    if SUCCEEDED(hr) 
    {
       for (i = 0; i < pFrameArray->GetSize(); i++)
       {
           LPDIRECT3DRMFRAME pTmpFrame;
           LPDIRECT3DRMFRAME3 pChildFrame;
           pFrameArray->GetElement(i, &pTmpFrame);
           pTmpFrame->QueryInterface(IID_IDirect3DRMFrame3, (LPVOID *)&pChildFrame);
           pTmpFrame->Release();
           SaveFrame(pChildFrame, pFrame, pFrameObj);
           pChildFrame->Release();
       }

       pFrameArray->Release();

       // Add frame object to the saved list.

       if (pRefFrameObj)
           pRefFrameObj->AddDataObject(pFrameObj);
       else
           pSave->SaveData(pFrameObj);

       pFrameObj->Release();
    }

    return hr;
}

HRESULT Saver::SaveFrameTransform(LPDIRECTXFILEDATA pFrameObj,
                                  LPDIRECT3DRMFRAME3 pFrame,
                                  LPDIRECT3DRMFRAME3 pRefFrame)
{
    LPDIRECTXFILEDATA pFrameTransformObj=NULL;
    D3DRMMATRIX4D rmMatrix;
    HRESULT hr;

    if (!pFrame) return E_INVALIDARG;

    pFrame->GetTransform(pRefFrame, rmMatrix);

    hr=pSave->CreateDataObject(TID_D3DRMFrameTransformMatrix,
                            NULL,
                            NULL,
                            sizeof(D3DRMMATRIX4D),
                            &rmMatrix,
                            &pFrameTransformObj);
    if FAILED(hr) return hr;

    hr=pFrameObj->AddDataObject(pFrameTransformObj);
    pFrameTransformObj->Release();
    return hr;
}

HRESULT Saver::SaveMeshBuilder(LPDIRECTXFILEDATA pFrameObj,
                               LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    LPDIRECTXFILEDATA pMeshObj;
    DWORD cVertices, cNormals, cFaces, dwFaceData, *pdwFaceData;
    LPDIRECT3DRMFACEARRAY pFaceArray = NULL;
    HRESULT hr;

    if (!pMeshBuilder) return E_INVALIDARG;
    //pFrameObj can be null

    hr=pMeshBuilder->GetGeometry(&cVertices, NULL,
                              &cNormals, NULL,
                              &dwFaceData, NULL);
    if FAILED(hr) return hr;

    cFaces = pMeshBuilder->GetFaceCount();

    if (!cVertices || !cNormals || !dwFaceData || !cFaces)
        return S_OK;

    pdwFaceData = new DWORD[dwFaceData];
    if FAILED(pdwFaceData) return E_OUTOFMEMORY;

    hr=pMeshBuilder->GetGeometry(NULL, NULL,
                              NULL, NULL,
                              &dwFaceData, pdwFaceData);
    if FAILED(hr) return hr;

    hr=CreateMeshObject(cVertices, cFaces, dwFaceData, pdwFaceData,
                     pMeshBuilder, &pMeshObj);
    if FAILED(hr) return hr;

    D3DRMCOLORSOURCE clrSrc = pMeshBuilder->GetColorSource();

    if (clrSrc == D3DRMCOLOR_FROMVERTEX)
    {
        CreateVertexColorsObject(pMeshObj, cVertices, pMeshBuilder);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_MATERIALS)
    {
        if (!pFaceArray)
            pMeshBuilder->GetFaces(&pFaceArray);
        CreateMaterialListObject(pMeshObj, pFaceArray);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_NORMALS)
    {
        CreateNormalsObject(pMeshObj,
                            cNormals, cFaces, dwFaceData, pdwFaceData,
                            pMeshBuilder);
    }
    

    if (d3dSaveFlags & D3DRMXOFSAVE_TEXTURETOPOLOGY)
    {
        if (!pFaceArray)
            pMeshBuilder->GetFaces(&pFaceArray);
        CreateTextureWrapsObject(pMeshObj, pFaceArray);
    }

    if (d3dSaveFlags & D3DRMXOFSAVE_TEXTURECOORDINATES)
    {
        CreateTextureCoordsObject(pMeshObj, cVertices, pMeshBuilder);
    }

    if (pFrameObj)
        pFrameObj->AddDataObject(pMeshObj);
    else
        pSave->SaveData(pMeshObj);

    pMeshObj->Release();
    delete[] pdwFaceData;
    if (pFaceArray)
        pFaceArray->Release();

    return S_OK;
}

HRESULT Saver::CreateMeshObject(DWORD cVertices,
                                DWORD cFaces,
                                DWORD dwFaceData,
                                LPDWORD pdwFaceData,
                                LPDIRECT3DRMMESHBUILDER3 pMeshBuilder,
                                LPDIRECTXFILEDATA *ppMeshObj)
{
    // mesh data is vertex_count + vertices + face_count + face_vertex_data;
    HRESULT hr;

    if (!pMeshBuilder) return E_INVALIDARG;
    if (!pSave) return E_INVALIDARG;

    DWORD cbSize, *data;
    cbSize = cVertices * sizeof(D3DVECTOR) +
        (1 + (dwFaceData + cFaces + 1)/2) * sizeof(DWORD);

    data = (LPDWORD) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;
    data[0] = cVertices;
    LPD3DVECTOR pVertices = (LPD3DVECTOR)&data[1];
    pMeshBuilder->GetGeometry(&cVertices, pVertices,
                              NULL, NULL,
                              NULL, NULL);

    LPDWORD pdwTmp = (LPDWORD)&pVertices[cVertices];
    *pdwTmp++ = cFaces;

    while (*pdwFaceData)
    {
        DWORD cFaceVertices = *pdwFaceData++;
        *pdwTmp++ = cFaceVertices;

        for (DWORD i = 0; i < cFaceVertices; i++)
        {
            *pdwTmp++ = *pdwFaceData++;
            pdwFaceData++; // skip normal index.
        }
    }

    DWORD dwSize;
    pMeshBuilder->GetName(&dwSize, NULL);
    
    LPSTR szName = NULL;
    if (dwSize)
    {
        szName = new char[dwSize];
        pMeshBuilder->GetName(&dwSize, szName);
    }

    hr=pSave->CreateDataObject(TID_D3DRMMesh,
                            szName,
                            NULL,
                            cbSize,
                            data,
                            ppMeshObj);

    if (szName) lNames.Add(szName);
    delete[] data;
    return S_OK;
}

HRESULT Saver::CreateNormalsObject(LPDIRECTXFILEDATA pMeshObj,
                                   DWORD cNormals,
                                   DWORD cFaces,
                                   DWORD dwFaceData,
                                   LPDWORD pdwFaceData,
                                   LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{                                
    // normals data is normal_count + normals + face_count + face_normal_data;
    HRESULT hr;

    if (!pMeshObj) return E_INVALIDARG;

    DWORD cbSize, *data;
    cbSize = cNormals * sizeof(D3DVECTOR) +
        (1 + (dwFaceData + cFaces + 1)/2) * sizeof(DWORD);

    data = (LPDWORD) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;

    data[0] = cNormals;

    LPD3DVECTOR pNormals = (LPD3DVECTOR)&data[1];

    hr=pMeshBuilder->GetGeometry(NULL, NULL,
                              &cNormals, pNormals,      
	                        NULL, NULL);
    if FAILED(hr) return hr;

    LPDWORD pdwTmp = (LPDWORD)&pNormals[cNormals];
    *pdwTmp++ = cFaces;

    while (*pdwFaceData)
    {
        DWORD cFaceVertices = *pdwFaceData++;
        *pdwTmp++ = cFaceVertices;

        for (DWORD i = 0; i < cFaceVertices; i++)
        {
            pdwFaceData++; // skip vertex index.
            *pdwTmp++ = *pdwFaceData++;
        }
    }

    LPDIRECTXFILEDATA pNormalsObj=NULL;

    hr=pSave->CreateDataObject(TID_D3DRMMeshNormals,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pNormalsObj);
    if FAILED(hr) return hr;

    pMeshObj->AddDataObject(pNormalsObj);
    pNormalsObj->Release();
    delete[] data;

    return S_OK;
}

HRESULT Saver::CreateVertexColorsObject(LPDIRECTXFILEDATA pMeshObj,
                                        DWORD cVertices,
                                        LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    DWORD cbSize;
    VertexColors *data;
    HRESULT hr;
    
    if (!pSave) return E_INVALIDARG;
    if (!pMeshBuilder) return E_INVALIDARG;

    cbSize = sizeof(DWORD) + cVertices * sizeof(IndexedColor);

    data = (VertexColors *) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;

    data->cVertices = cVertices;

    for (DWORD i = 0; i < cVertices; i++)
    {
        D3DCOLOR color = pMeshBuilder->GetVertexColor(i);
        data->vertexColors[i].index = i;
        data->vertexColors[i].color.r = MyD3DRMColorGetRed(color);
        data->vertexColors[i].color.g = MyD3DRMColorGetGreen(color);
        data->vertexColors[i].color.b = MyD3DRMColorGetBlue(color);
        data->vertexColors[i].color.a = MyD3DRMColorGetAlpha(color);
    }

    LPDIRECTXFILEDATA pVertexColorsObj=NULL;

    hr=pSave->CreateDataObject(TID_D3DRMMeshVertexColors,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pVertexColorsObj);
    if FAILED(hr) {
        delete[] data;                        
	return hr;
    }

    pMeshObj->AddDataObject(pVertexColorsObj);
    pVertexColorsObj->Release();
    delete[] data;                        

    return S_OK;
}

HRESULT Saver::CreateMaterialListObject(LPDIRECTXFILEDATA pMeshObj,
                                        LPDIRECT3DRMFACEARRAY pFaceArray)
{
    DWORD cbSize, cFaces;
    FaceMaterials *data;
    FaceMaterialList lMat;
    

    cFaces = pFaceArray->GetSize();
    cbSize = (2 + cFaces) * sizeof(DWORD);

    data = (FaceMaterials *) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;

    data->cFaceIndexes = cFaces;
    LPDWORD pdwIndex = data->faceIndexes;

    for (DWORD i = 0; i < cFaces; i++, pdwIndex++)
    {
        LPDIRECT3DRMFACE pFace;
        pFaceArray->GetElement(i, &pFace);

        D3DCOLOR faceColor;
        LPDIRECT3DRMMATERIAL pMaterial;
        LPDIRECT3DRMTEXTURE pTexture;

        faceColor = pFace->GetColor();
        pFace->GetMaterial(&pMaterial);
        pFace->GetTexture(&pTexture);
        
        *pdwIndex = lMat.Find(faceColor, pMaterial, pTexture);

        pMaterial->Release();
        if (pTexture) pTexture->Release();
        pFace->Release();
    }

    data->cMaterials = lMat.Count();

    if (data->cMaterials == 1)
    {
        data->cFaceIndexes = 1;
        data->faceIndexes[0] = 0;
        cbSize = 3 * sizeof(DWORD);
    }

    LPDIRECTXFILEDATA pMatListObj;

    pSave->CreateDataObject(TID_D3DRMMeshMaterialList,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pMatListObj);

    FaceMaterial *pMat;
    for (pMat = lMat.First(); pMat; pMat = pMat->pNext)
    {
        CreateMaterialObject(pMatListObj,
                             pMat);
    }

    pMeshObj->AddDataObject(pMatListObj);
    pMatListObj->Release();
    delete[] data;
    
    return S_OK;
}

HRESULT Saver::CreateMaterialObject(LPDIRECTXFILEDATA pMatListObj,
                                    FaceMaterial *pMat)
{
    BaseMaterial data;

    data.faceColor.r = MyD3DRMColorGetRed(pMat->faceColor);
    data.faceColor.g = MyD3DRMColorGetGreen(pMat->faceColor);
    data.faceColor.b = MyD3DRMColorGetBlue(pMat->faceColor);
    data.faceColor.a = MyD3DRMColorGetAlpha(pMat->faceColor);

    data.power = pMat->pMaterial->GetPower();

    pMat->pMaterial->GetSpecular(&data.specularColor.r,
                                 &data.specularColor.g,
                                 &data.specularColor.b);

    pMat->pMaterial->GetEmissive(&data.emissiveColor.r,
                                 &data.emissiveColor.g,
                                 &data.emissiveColor.b);

    LPDIRECTXFILEDATA pMaterialObj;

    pSave->CreateDataObject(TID_D3DRMMaterial,
                            NULL,
                            NULL,
                            sizeof(BaseMaterial),
                            &data,
                            &pMaterialObj);

    if (pMat->pTexture)
    {
        IDirectXFileData *pTextureObj;

        DWORD dwSize;
        pMat->pTexture->GetName(&dwSize, NULL);

        if (dwSize)
        {
            LPSTR szName = new char[dwSize];
            pMat->pTexture->GetName(&dwSize, szName);
    
            pSave->CreateDataObject(TID_D3DRMTextureFilename,
                                    NULL,
                                    NULL,
                                    sizeof(LPSTR),
                                    &szName,
                                    &pTextureObj);
    
            pMaterialObj->AddDataObject(pTextureObj);
            pTextureObj->Release();
            lNames.Add(szName);
        }
    }

    pMatListObj->AddDataObject(pMaterialObj);
    pMaterialObj->Release();

    return S_OK;
}

HRESULT Saver::CreateTextureWrapsObject(LPDIRECTXFILEDATA pMeshObj,
                                        LPDIRECT3DRMFACEARRAY pFaceArray)
{
    DWORD cbSize, cFaces;
    FaceWraps *data;

    cFaces = pFaceArray->GetSize();
    cbSize = sizeof(DWORD) + cFaces * sizeof(Boolean2d);

    data = (FaceWraps *) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;

    data->cFaces = cFaces;
    Boolean2d *pWrap = data->faceWraps;

    for (DWORD i = 0; i < cFaces; i++, pWrap++)
    {
        LPDIRECT3DRMFACE pFace;
        pFaceArray->GetElement(i, &pFace);
        pFace->GetTextureTopology(&pWrap->u, &pWrap->v);
        pFace->Release();
    }

    LPDIRECTXFILEDATA pTextureWrapsObj;

    pSave->CreateDataObject(TID_D3DRMMeshFaceWraps,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pTextureWrapsObj);

    pMeshObj->AddDataObject(pTextureWrapsObj);
    pTextureWrapsObj->Release();
    delete[] data;                        

    return S_OK;
}

HRESULT Saver::CreateTextureCoordsObject(LPDIRECTXFILEDATA pMeshObj,
                                         DWORD cVertices,
                                         LPDIRECT3DRMMESHBUILDER3 pMeshBuilder)
{
    DWORD cbSize;
    TextureCoords *data;

    cbSize = sizeof(DWORD) + cVertices * sizeof(Coords2d);

    data = (TextureCoords *) new BYTE[cbSize];
    if (!data) return E_OUTOFMEMORY;

    data->cVertices = cVertices;
    Coords2d *pCoords = data->textureCoords;

    for (DWORD i = 0; i < cVertices; i++, pCoords++)
    {
        pMeshBuilder->GetTextureCoordinates(i, &pCoords->u, &pCoords->v);
    }

    LPDIRECTXFILEDATA pTexCoordsObj;

    pSave->CreateDataObject(TID_D3DRMMeshTextureCoords,
                            NULL,
                            NULL,
                            cbSize,
                            data,
                            &pTexCoordsObj);

    pMeshObj->AddDataObject(pTexCoordsObj);
    pTexCoordsObj->Release();
    delete[] data;                        

    return S_OK;
}

FaceMaterialList::FaceMaterialList()
  : cElements(0), pFirst(NULL)
{
}

FaceMaterialList::~FaceMaterialList()
{
    FaceMaterial *pMat = pFirst;
    while (pMat)
    {
        FaceMaterial *pNext = pMat->pNext;
        pMat->pMaterial->Release();
        if (pMat->pTexture) pMat->pTexture->Release();
        delete pMat;
        pMat = pNext;
    }
}

DWORD FaceMaterialList::Find(D3DCOLOR faceColor,
                             LPDIRECT3DRMMATERIAL pMaterial,
                             LPDIRECT3DRMTEXTURE pTexture)
{
    FaceMaterial *pTmp = pFirst;
    FaceMaterial **ppNew = &pFirst;

    for (DWORD i = 0; pTmp; i++, pTmp = pTmp->pNext)
    {
        if (pTmp->faceColor == faceColor &&
            pTmp->pMaterial == pMaterial &&
            pTmp->pTexture == pTexture)
            return i;

        if (!pTmp->pNext)
            ppNew = &pTmp->pNext;
    }

    FaceMaterial *pNew = new FaceMaterial;
    if (!pNew) return 0;

    pNew->faceColor = faceColor;
    pNew->pMaterial = pMaterial;
    pNew->pTexture = pTexture;
    pNew->pNext = NULL;
    pMaterial->AddRef();
    if (pTexture) pTexture->AddRef();

    *ppNew = pNew;
    cElements++;
    return i;
}

NameList::NameList()
 : pFirst(NULL),
   ppLast(NULL)
{
}

NameList::~NameList()
{
    NameEntry *pEntry = pFirst;

    while (pEntry)
    {
        NameEntry *pNext = pEntry->pNext;
        delete[] pEntry->pName;
        delete pEntry;
        pEntry = pNext;
    }
}

void NameList::Add(LPSTR pName)
{
    NameEntry *pNew = new NameEntry;
    if (!pNew) return;
	
    pNew->pName = pName;
    pNew->pNext = NULL;

    if (ppLast)
        *ppLast = pNew;
    else
        pFirst = pNew;

    ppLast = &pNew->pNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

RegisterBin: $(TARGET)
!ifndef NTDEBUG
!MESSAGE Registering $(TARGETNAME)
	regsvr32 -s -u $(?F)
	regsvr32 -s $?
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Direct.rc
//
#define IDS_DSOUND_DESC                 1
#define IDS_GENERIC_DESC                1
#define IDS_DIRECTX6_DESC               2
#define IDS_DDRAW_DESC                  3
#define IDS_DIRECTX7_DESC               3
#define IDS_DDCLIPPER_DESC              5
#define IDS_D3DRMVIEWPORT_DESC          7
#define IDS_D3DRMDEVICE_DESC            9
#define IDS_D3DRMFRAME_DESC             11
#define IDS_D3DRMMESH_DESC              13
#define IDS_D3DRMMESHBUILDER_DESC       15
#define IDS_D3DRMFACE_DESC              17
#define IDS_D3DRMLIGHT_DESC             19
#define IDS_D3DRMTEXTURE_DESC           21
#define IDS_D3DRMWRAP_DESC              23
#define IDS_D3DRMMATERIAL_DESC          25
#define IDS_D3DRMANIMATION_DESC         27
#define IDS_D3DRMANIMATIONSET_DESC      29
#define IDS_D3DRMUSERVISUAL_DESC        31
#define IDS_D3DRMSHADOW_DESC            33
#define IDS_D3D_DESC                    35
#define IDS_D3DTEXTURE_DESC             37
#define IDS_D3DLIGHT_DESC               39
#define IDS_D3DMATERIAL_DESC            41
#define IDS_D3DEXECUTEBUFFER_DESC       43
#define IDS_DBITMAP_DESC                45
#define IDS_D3DVIEWPORT_DESC            47
#define IDS_D3DRM_DESC                  49
#define IDS_D3DRMOBJECT_DESC            51
#define IDS_D3DRMVISUAL_DESC            53
#define IDS_D3DRMWINDEVICE_DESC         55
#define IDS_DDSURFACE_DESC              57
#define IDS_DDPALETTE_DESC              59
#define IDS_DPLAY_DESC                  61
#define IDS_DSOUNDBUFFER_DESC           63
#define IDS_DMSTEST_DESC                65
#define IDS_D3DRMDEVICEARRAY_DESC       67
#define IDS_D3DRMVIEWPORTARRAY_DESC     69
#define IDS_D3DRMFRAMEARRAY_DESC        71
#define IDS_D3DRMVISUALARRAY_DESC       73
#define IDS_CHOOSECOLOR_DESC            75
#define IDS_D3DRMLIGHTARRAY_DESC        77
#define IDS_D3DRMPICKEDARRAY_DESC       79
#define IDS_D3DRMFACEARRAY_DESC         81
#define IDS_DIRECT42_DESC               83
#define IDS_D3DDEVICE_DESC              83
#define IDS_DIRECTINPUTDEVICE           83
#define IDS_DIRECT43_DESC               85
#define IDS_DIRECT44_DESC               87
#define IDS_DSOUNDRESOURCE_DESC         87
#define IDS_JOYSTICK                    87
#define IDS_DIRECT45_DESC               89
#define IDS_DPLAY2_DESC                 89
#define IDS_DIRECT46_DESC               91
#define IDS_DPLAYLOBBY_DESC             91
#define IDS_DIRECT47_DESC               93
#define IDS_DIRECT48_DESC               95
#define IDS_DIRECT49_DESC               97
#define IDS_DIRECT50_DESC               99
#define IDS_DIRECT51_DESC               101
#define IDS_D3DRMARRAY_DESC             101
#define IDS_DIRECT52_DESC               103
#define IDS_DIRECT53_DESC               105
#define IDS_DIRECT54_DESC               107
#define IDS_DIRECT55_DESC               109
#define IDS_DIRECT56_DESC               111
#define IDS_DIRECT57_DESC               113
#define IDS_DIRECT58_DESC               115
#define IDS_DIRECT59_DESC               117
#define IDS_DIRECT60_DESC               119
#define IDS_DSOUND3DBUFFER_DESC         120
#define IDS_DSOUND3DLISTENER_DESC       121
#define IDS_DDVIDEOPORT_DESC            122

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        209
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
#include <statreg.h>
#include <statreg.cpp>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\sources.inc ===
!IF 0


Copyright (C) Microsoft Corporation, 1989 - 1999

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Andrew Kertesz (Andrewke) 20-DEC-98

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF


MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dx7vb
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=direct.def
!IF 0
        DLLENTRY=_DllMainCRTStartup
!ENDIF

DLLENTRY=DllMain

USE_MAPSYM=1
USE_CRTDLL=1
USE_STATIC_ATL=1
DX7=1
DX6=1


PLAT_DIR           = daytona
# ALT_PROJECT_TARGET = .
!if defined(NTDEBUG) && "$(NTDEBUG)" != "ntsdnodebug"
DEBUG=1
!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(BASEDIR)\public\sdk\lib\*\kernel32.lib		\
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib		\
           $(BASEDIR)\public\sdk\lib\*\uuid.lib                 \
           $(BASEDIR)\public\sdk\lib\*\ole32.lib                \
           $(BASEDIR)\public\sdk\lib\*\gdi32.lib                \
           $(BASEDIR)\public\sdk\lib\*\winmm.lib                \
           $(BASEDIR)\public\sdk\lib\*\dinput.lib               \
           $(BASEDIR)\public\sdk\lib\*\msacm32.lib              \
           $(BASEDIR)\public\sdk\lib\*\USER32.lib              \
           $(BASEDIR)\public\sdk\lib\*\OLEAUT32.lib            
           

PASS0_HEADERDIR=$O

INCLUDES=$(DXROOT)\inc; \
	 ..\inc; \
	 $(SDK_INC_PATH); \
	 $(PASS0_HEADERDIR);




SOURCES=   \
        ..\direct.idl              \
	..\directvb.idl            \
        ..\direct.cpp              \
        ..\dxGlob7Obj.cpp          \
        ..\StdAfx.cpp              \
        ..\wave.cpp                \
        \
        ..\dmLoaderObj.cpp         \
        ..\dmSegmentObj.cpp        \
        ..\dmBandObj.cpp           \
        ..\dmChordMapObj.cpp       \
        ..\dmCollectionObj.cpp     \
        ..\dmPerformanceObj.cpp    \
        ..\dmSegmentStateObj.cpp   \
        ..\dmStyleObj.cpp          \
        ..\dmComposerObj.cpp       \
        \
        ..\d3d7Obj.cpp \
        ..\d3ddevice7obj.cpp \
        ..\D3DEnumDevices7Obj.cpp \
        ..\D3DEnumPixelFormats7Obj.cpp \
        ..\d3dVertexBuffer7Obj.cpp \
        \
        ..\d3drm3Obj.cpp \
        ..\d3drmAnimation2Obj.cpp \
        ..\d3drmAnimationSet2Obj.cpp \
        ..\d3drmObjectArrayObj.cpp \
        ..\d3drmClippedVisualObj.cpp \
        ..\d3drmDevice3Obj.cpp \
        ..\d3drmDeviceArrayObj.cpp \
        ..\d3drmFace2Obj.cpp \
        ..\d3drmFaceArrayObj.cpp \
        ..\d3drmFrame3Obj.cpp \
        ..\d3drmFrameArrayObj.cpp \
        ..\d3drmLightArrayObj.cpp \
        ..\d3drmLightObj.cpp \
        ..\d3drmMaterial2Obj.cpp \
        ..\d3drmMeshBuilder3Obj.cpp \
        ..\d3drmMeshObj.cpp \
        ..\d3drmPicked2ArrayObj.cpp \
        ..\d3drmPickedArrayObj.cpp \
        ..\d3drmProgressiveMeshObj.cpp \
        ..\d3drmShadow2Obj.cpp \
        ..\d3drmTexture3Obj.cpp \
        ..\d3drmViewport2Obj.cpp \
        ..\d3drmViewportArrayObj.cpp \
        ..\d3drmVisualArrayObj.cpp \
        ..\d3drmWrapObj.cpp \
        ..\d3drmMeshInterObj.cpp \
        ..\d3drmViewportInterObj.cpp \
        ..\d3drmMaterialInterObj.cpp \
        ..\d3drmTextureInterObj.cpp \
        ..\d3drmLightInterObj.cpp \
        ..\d3drmFrameInterObj.cpp \
	..\d3drmAnimationArrayObj.cpp \
	..\frmsave.cpp \
        \
        ..\ddClipperObj.cpp \
        ..\ddColorControlObj.cpp \
        ..\DDEnumModesObj.cpp \
        ..\DDEnumObj.cpp \
        ..\DDEnumSurfacesObj.cpp \
        ..\ddGammaControlObj.cpp \
        ..\ddPaletteObj.cpp \
        ..\dDraw7Obj.cpp \
        ..\ddSurface7Obj.cpp \
        ..\dDraw4Obj.cpp \
        ..\ddSurface4Obj.cpp \
        ..\ddIdentifierObj.cpp \
        \
        ..\DIEnumDeviceObjectsObj.cpp \
        ..\DIEnumDevicesObj.cpp \
        ..\dInput1Obj.cpp \
        ..\dInputDeviceObj.cpp \
        ..\dInputEffectObj.cpp \
        ..\dIDevObjInstObj.cpp \
        ..\dIDevInstObj.cpp \
	..\dIEnumEffectsObj.cpp \
        \
        ..\DPAddressObj.cpp \
        ..\DPEnumConnectionsObj.cpp \
        ..\DPEnumLocalApplicationsObj.cpp \
        ..\DPEnumObj.cpp \
        ..\DPEnumPlayersObj.cpp \
        ..\DPEnumSessionsObj.cpp \
        ..\Dplay4obj.cpp \
        ..\Dplaylobby3obj.cpp \
        ..\DPLConnectionObj.cpp \
        ..\DPMsgObj.cpp    \
        ..\DPSessDataObj.cpp       \
        \
        ..\DSEnumObj.cpp \
        ..\dSound3DBuffer.cpp \
        ..\dSound3DListener.cpp \
        ..\dSoundBufferObj.cpp \
        ..\dSoundCaptureBufferObj.cpp \
        ..\dSoundCaptureObj.cpp \
        ..\dSoundObj.cpp      \
        \
        ..\dxvb.rc \
        \
        ..\guids.cpp
        

!if "$(__PRODUCT)" == "DX7"
!if  "$(ALPHA)"=="1" || "$(WIN95)"=="1"
NTTARGETFILE1=RegisterBin
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\guids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       guids.h
//
//--------------------------------------------------------------------------

#if 0
DEFINE_GUID( IID_IDirectDraw,			0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw4,                  0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDrawSurface,		0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,		0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );
DEFINE_GUID( IID_IDirectDrawSurface3,           0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );
DEFINE_GUID( IID_IDirectDrawSurface4,           0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B );

DEFINE_GUID( IID_IDirectDrawPalette,		0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,		0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawColorControl, 	0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawGammaControl,       0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );

DEFINE_GUID(IID_IDirectSound3DListener,0x279AFA84,0x4981,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60);
DEFINE_GUID(IID_IDirectSound3DBuffer,0x279AFA86,0x4981,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60);
DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);
DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);
DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);
DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);



DEFINE_GUID( IID_IDirect3D,             0x3BBA0080,0x2421,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3D2,            0x6aae1ec1,0x662a,0x11d0,0x88,0x9d,0x00,0xaa,0x00,0xbb,0xb7,0x6a);
DEFINE_GUID( IID_IDirect3D3,            0xbb223240,0xe72b,0x11d0,0xa9,0xb4,0x00,0xaa,0x00,0xc0,0x99,0x3e);
DEFINE_GUID( IID_IDirect3DRampDevice,   0xF2086B20,0x259F,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMMXDevice,    0x881949a1,0xd6f3,0x11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DRefDevice,    0x50936643, 0x13e9, 0x11d1, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DNullDevice, 0x8767df22, 0xbacc, 0x11d1, 0x89, 0x69, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( IID_IDirect3DDevice,       0x64108800,0x957d,0X11d0,0x89,0xab,0x00,0xa0,0xc9,0x05,0x41,0x29 );
DEFINE_GUID( IID_IDirect3DDevice2,  0x93281501, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DDevice3,  0xb0ab3b60, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
DEFINE_GUID( IID_IDirect3DTexture,      0x2CDCD9E0,0x25A0,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DTexture2, 0x93281502, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DLight,        0x4417C142,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial,     0x4417C144,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DMaterial2,    0x93281503, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DMaterial3,    0xca9c46f4, 0xd3c5, 0x11d1, 0xb7, 0x5a, 0x0, 0x60, 0x8, 0x52, 0xb3, 0x12);
DEFINE_GUID( IID_IDirect3DExecuteBuffer,0x4417C145,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport,     0x4417C146,0x33AD,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
DEFINE_GUID( IID_IDirect3DViewport2,    0x93281500, 0x8cf8, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( IID_IDirect3DViewport3,    0xb0ab3b61, 0x33d7, 0x11d1, 0xa9, 0x81, 0x0, 0xc0, 0x4f, 0xd7, 0xb1, 0x74);
DEFINE_GUID( IID_IDirect3DVertexBuffer, 0x7a503555, 0x4a83, 0x11d1, 0xa5, 0xdb, 0x0, 0xa0, 0xc9, 0x3, 0x67, 0xf8);




DEFINE_GUID(IID_IDirectPlay2, 0x2b74f7c0, 0x9154, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);
DEFINE_GUID(IID_IDirectPlay2A,0x9d460580, 0xa822, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);
DEFINE_GUID(IID_IDirectPlay3, 0x133efe40, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay3A,0x133efe41, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay4, 0xab1c530, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlay4A,0xab1c531, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlayLobby, 0xaf465c71, 0x9588, 0x11cf, 0xa0, 0x20, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
DEFINE_GUID(IID_IDirectPlayLobbyA, 0x26c66a70, 0xb367, 0x11cf, 0xa0, 0x24, 0x0, 0xaa, 0x0, 0x61, 0x57, 0xac);
DEFINE_GUID(IID_IDirectPlayLobby2, 0x194c220, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
DEFINE_GUID(IID_IDirectPlayLobby2A, 0x1bb4af80, 0xa303, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
DEFINE_GUID(IID_IDirectPlayLobby3, 0x2db72490, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlayLobby3A, 0x2db72491, 0x652c, 0x11d1, 0xa7, 0xa8, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(CLSID_DirectPlayLobby, 0x2fe8f810, 0xb2a5, 0x11d0, 0xa7, 0x87, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {762CCDA1-D916-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_MessagesSupported, 
0x762ccda1, 0xd916, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {F56920A0-D218-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_LobbyGuid, 
0xf56920a0, 0xd218, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {B4319322-D20D-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerGuid, 
0xb4319322, 0xd20d, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {48784000-D219-11d0-BA39-00C04FD7ED67}
DEFINE_GUID(DPLPROPERTY_PlayerScore, 
0x48784000, 0xd219, 0x11d0, 0xba, 0x39, 0x0, 0xc0, 0x4f, 0xd7, 0xed, 0x67);
// {1318F560-912C-11d0-9DAA-00A0C90A43CB}
DEFINE_GUID(DPAID_TotalSize, 
0x1318f560, 0x912c, 0x11d0, 0x9d, 0xaa, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
// {07D916C0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_ServiceProvider, 
0x7d916c0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {59B95640-9667-11d0-A77D-0000F803ABFC}
DEFINE_GUID(DPAID_LobbyProvider, 
0x59b95640, 0x9667, 0x11d0, 0xa7, 0x7d, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
// {78EC89A0-E0AF-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPAID_Phone, 
0x78ec89a0, 0xe0af, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {BA5A7A70-9DBF-11d0-9CC1-00A0C905425E}
DEFINE_GUID(DPAID_PhoneW, 
0xba5a7a70, 0x9dbf, 0x11d0, 0x9c, 0xc1, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);
// {F6DCC200-A2FE-11d0-9C4F-00A0C905425E}
DEFINE_GUID(DPAID_Modem, 
0xf6dcc200, 0xa2fe, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject,          0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMObject2,         0x4516ec7c, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice,          0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice2,         0x4516ec78, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice3,     0x549f498b, 0xbfeb, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMViewport,        0xeb16cb02, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport2,   0x4a1b1be6, 0xbfed, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMFrame,           0xeb16cb03, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrame2,          0xc3dfbd60, 0x3988, 0x11d0, 0x9e, 0xc2, 0x0, 0x0, 0xc0, 0x29, 0x1a, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFrame3,              0xff6b7f70, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMVisual,          0xeb16cb04, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMesh,            0xa3a80d01, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder,     0xa3a80d02, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder2,    0x4516ec77, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder3,    0xff6b7f71, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMFace,            0xeb16cb07, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLight,           0xeb16cb08, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture,         0xeb16cb09, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture2,        0x120f30c0, 0x1629, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);
DEFINE_GUID(IID_IDirect3DRMTexture3,        0xff6b7f73, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMWrap,            0xeb16cb0a, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial,        0xeb16cb0b, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial2,       0xff6b7f75, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimation,       0xeb16cb0d, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimation2,      0xff6b7f77, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimationSet,    0xeb16cb0e, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationSet2,   0xff6b7f79, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMObjectArray,     0x242f6bc2, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDeviceArray,     0xeb16cb10, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewportArray,   0xeb16cb11, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrameArray,      0xeb16cb12, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisualArray,     0xeb16cb13, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLightArray,      0xeb16cb14, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMPickedArray,     0xeb16cb16, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFaceArray,       0xeb16cb17, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationArray,  0xd5f1cae0, 0x4bd7, 0x11d1, 0xb9, 0x74, 0x0, 0x60, 0x8, 0x3e, 0x45, 0xf3);
DEFINE_GUID(IID_IDirect3DRMUserVisual,      0x59163de0, 0x6d43, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow,          0xaf359780, 0x6ba3, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow2,         0x86b44e25, 0x9c82, 0x11d1, 0xbb, 0xb, 0x0, 0xa0, 0xc9, 0x81, 0xa0, 0xa6);
DEFINE_GUID(IID_IDirect3DRMInterpolator,    0x242f6bc1, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMProgressiveMesh, 0x4516ec79, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMPicked2Array,    0x4516ec7b, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMClippedVisual,   0x5434e733, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);
DEFINE_GUID(IID_IDirect3DRMWinDevice,   0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);



DEFINE_GUID(IID_IDirect3DRM2,   0x4516ecc8, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRM3,   0x2e34065, 0xc243, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);

DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ConstantForce,0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_RampForce,    0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Square,       0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Sine,         0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Triangle,     0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothUp,   0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothDown, 0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Spring,       0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Damper,       0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Inertia,      0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Friction,     0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_CustomForce,  0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\daytona\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#define DX6 1
#define DX7 1
#include "windows.h"
#include "mmsystem.h"

#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include "atlcom.h"


#include "ddraw.h"
#include "dvp.h"

#ifndef _DEBUG
__inline void* __cdecl malloc(size_t cbSize)
{
    return (void*) LocalAlloc(LMEM_FIXED, cbSize);
}

__inline void* __cdecl realloc(void* oldptr, size_t cbSize)
{
    return (void*) LocalReAlloc(oldptr, cbSize, LMEM_MOVEABLE);
}

__inline void __cdecl free(void *pv)
{
    LocalFree((HLOCAL)pv);
}

__inline void* __cdecl operator new(size_t cbSize)
{
    return (void*) malloc(cbSize);
}

__inline void __cdecl operator delete(void *pv)
{
    free(pv);
}

__inline int __cdecl _purecall(void)
{
    return(0);
}
#endif

#include "d3d.h"
#include "d3dcaps.h"
#include "d3drm.h"
#include "d3drmwin.h"

#include "dSound.h"
#include "dPlay.h"
#include "dpLobby.h" 
#include "d3drmdef.h"
#include "d3drmobj.h"
#include "dinput.h"


#define DECL_VARIABLE(c) typedef_##c m_##c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\inc\dinput.h ===
/****************************************************************************
 *
 *  Copyright (C) 1996-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinput.h
 *  Content:    DirectInput include file
 *
 ****************************************************************************/

#ifndef __DINPUT_INCLUDED__
#define __DINPUT_INCLUDED__

#ifndef DIJ_RINGZERO

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#endif

#endif /* DIJ_RINGZERO */

#ifdef __cplusplus
extern "C" {
#endif




/*
 *  To build applications for older versions of DirectInput 
 *
 *  #define DIRECTINPUT_VERSION 0x0300
 *  or
 *  #define DIRECTINPUT_VERSION 0x0500
 *
 *  before #include <dinput.h>.  By default, #include <dinput.h>
 *  will produce a DirectX 7-compatible header file.
 *
 */

#ifndef DIRECTINPUT_VERSION
#define DIRECTINPUT_VERSION         0x0700
#endif

#ifndef DIJ_RINGZERO
/****************************************************************************
 *
 *      Class IDs
 *
 ****************************************************************************/

DEFINE_GUID(CLSID_DirectInput,      0x25E609E0,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(CLSID_DirectInputDevice,0x25E609E1,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Interfaces
 *
 ****************************************************************************/

DEFINE_GUID(IID_IDirectInputA,     0x89521360,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputW,     0x89521361,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput2A,    0x5944E662,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput2W,    0x5944E663,0xAA8A,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInput7A,    0X9A4CB684,0X236D,0X11D3,0X8E,0X9D,0X00,0XC0,0X4F,0X68,0X44,0XAE);
DEFINE_GUID(IID_IDirectInput7W,    0X9A4CB685,0X236D,0X11D3,0X8E,0X9D,0X00,0XC0,0X4F,0X68,0X44,0XAE);
DEFINE_GUID(IID_IDirectInputDeviceA, 0x5944E680,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDeviceW, 0x5944E681,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice2A,0x5944E682,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(IID_IDirectInputDevice2W,0x5944E683,0xC92E,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(IID_IDirectInputEffect,  0xE7E1F7C0,0x88D2,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);

DEFINE_GUID(IID_IDirectInputDevice7A,0X57D7C6BC,0X2356,0X11D3,0X8E,0X9D,0X00,0XC0,0X4F,0X68,0X44,0XAE);
DEFINE_GUID(IID_IDirectInputDevice7W,0X57D7C6BD,0X2356,0X11D3,0X8E,0X9D,0X00,0XC0,0X4F,0X68,0X44,0XAE);

/****************************************************************************
 *
 *      Predefined object types
 *
 ****************************************************************************/

DEFINE_GUID(GUID_XAxis,   0xA36D02E0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_YAxis,   0xA36D02E1,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_ZAxis,   0xA36D02E2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RxAxis,  0xA36D02F4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RyAxis,  0xA36D02F5,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_RzAxis,  0xA36D02E3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Slider,  0xA36D02E4,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_Button,  0xA36D02F0,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Key,     0x55728220,0xD33C,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_POV,     0xA36D02F2,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

DEFINE_GUID(GUID_Unknown, 0xA36D02F3,0xC9F3,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Predefined product GUIDs
 *
 ****************************************************************************/

DEFINE_GUID(GUID_SysMouse,   0x6F1D2B60,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboard,0x6F1D2B61,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_Joystick   ,0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouseEm, 0x6F1D2B80,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysMouseEm2,0x6F1D2B81,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboardEm, 0x6F1D2B82,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);
DEFINE_GUID(GUID_SysKeyboardEm2,0x6F1D2B83,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00);

/****************************************************************************
 *
 *      Predefined force feedback effects
 *
 ****************************************************************************/

DEFINE_GUID(GUID_ConstantForce, 0x13541C20,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_RampForce,     0x13541C21,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Square,        0x13541C22,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Sine,          0x13541C23,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Triangle,      0x13541C24,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothUp,    0x13541C25,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_SawtoothDown,  0x13541C26,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Spring,        0x13541C27,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Damper,        0x13541C28,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Inertia,       0x13541C29,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_Friction,      0x13541C2A,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);
DEFINE_GUID(GUID_CustomForce,   0x13541C2B,0x8E33,0x11D0,0x9A,0xD0,0x00,0xA0,0xC9,0xA0,0x6E,0x35);

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Interfaces and Structures...
 *
 ****************************************************************************/

#if(DIRECTINPUT_VERSION >= 0x0500)

/****************************************************************************
 *
 *      IDirectInputEffect
 *
 ****************************************************************************/

#define DIEFT_ALL                   0x00000000

#define DIEFT_CONSTANTFORCE         0x00000001
#define DIEFT_RAMPFORCE             0x00000002
#define DIEFT_PERIODIC              0x00000003
#define DIEFT_CONDITION             0x00000004
#define DIEFT_CUSTOMFORCE           0x00000005
#define DIEFT_HARDWARE              0x000000FF
#define DIEFT_FFATTACK              0x00000200
#define DIEFT_FFFADE                0x00000400
#define DIEFT_SATURATION            0x00000800
#define DIEFT_POSNEGCOEFFICIENTS    0x00001000
#define DIEFT_POSNEGSATURATION      0x00002000
#define DIEFT_DEADBAND              0x00004000
#define DIEFT_STARTDELAY            0x00008000
#define DIEFT_GETTYPE(n)            LOBYTE(n)

#define DI_DEGREES                  100
#define DI_FFNOMINALMAX             10000
#define DI_SECONDS                  1000000

typedef struct DICONSTANTFORCE {
    LONG  lMagnitude;
} DICONSTANTFORCE, *LPDICONSTANTFORCE;
typedef const DICONSTANTFORCE *LPCDICONSTANTFORCE;

typedef struct DIRAMPFORCE {
    LONG  lStart;
    LONG  lEnd;
} DIRAMPFORCE, *LPDIRAMPFORCE;
typedef const DIRAMPFORCE *LPCDIRAMPFORCE;

typedef struct DIPERIODIC {
    DWORD dwMagnitude;
    LONG  lOffset;
    DWORD dwPhase;
    DWORD dwPeriod;
} DIPERIODIC, *LPDIPERIODIC;
typedef const DIPERIODIC *LPCDIPERIODIC;

typedef struct DICONDITION {
    LONG  lOffset;
    LONG  lPositiveCoefficient;
    LONG  lNegativeCoefficient;
    DWORD dwPositiveSaturation;
    DWORD dwNegativeSaturation;
    LONG  lDeadBand;
} DICONDITION, *LPDICONDITION;
typedef const DICONDITION *LPCDICONDITION;

typedef struct DICUSTOMFORCE {
    DWORD cChannels;
    DWORD dwSamplePeriod;
    DWORD cSamples;
    LPLONG rglForceData;
} DICUSTOMFORCE, *LPDICUSTOMFORCE;
typedef const DICUSTOMFORCE *LPCDICUSTOMFORCE;


typedef struct DIENVELOPE {
    DWORD dwSize;                   /* sizeof(DIENVELOPE)   */
    DWORD dwAttackLevel;
    DWORD dwAttackTime;             /* Microseconds         */
    DWORD dwFadeLevel;
    DWORD dwFadeTime;               /* Microseconds         */
} DIENVELOPE, *LPDIENVELOPE;
typedef const DIENVELOPE *LPCDIENVELOPE;


/* This structure is defined for DirectX 5.0 compatibility */
typedef struct DIEFFECT_DX5 {
    DWORD dwSize;                   /* sizeof(DIEFFECT_DX5) */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */
    LPDWORD rgdwAxes;               /* Array of axes        */
    LPLONG rglDirection;            /* Array of directions  */
    LPDIENVELOPE lpEnvelope;        /* Optional             */
    DWORD cbTypeSpecificParams;     /* Size of params       */
    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
} DIEFFECT_DX5, *LPDIEFFECT_DX5;
typedef const DIEFFECT_DX5 *LPCDIEFFECT_DX5;

typedef struct DIEFFECT {
    DWORD dwSize;                   /* sizeof(DIEFFECT)     */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */
    LPDWORD rgdwAxes;               /* Array of axes        */
    LPLONG rglDirection;            /* Array of directions  */
    LPDIENVELOPE lpEnvelope;        /* Optional             */
    DWORD cbTypeSpecificParams;     /* Size of params       */
    LPVOID lpvTypeSpecificParams;   /* Pointer to params    */
#if(DIRECTINPUT_VERSION >= 0x0600)
    DWORD  dwStartDelay;            /* Microseconds         */
#endif /* DIRECTINPUT_VERSION >= 0x0600 */
} DIEFFECT, *LPDIEFFECT;
typedef DIEFFECT DIEFFECT_DX6;
typedef LPDIEFFECT LPDIEFFECT_DX6;
typedef const DIEFFECT *LPCDIEFFECT;


#if(DIRECTINPUT_VERSION >= 0x0700)
#ifndef DIJ_RINGZERO
typedef struct DIFILEEFFECT{
    DWORD       dwSize;
    GUID        GuidEffect;
    LPCDIEFFECT lpDiEffect;
    CHAR        szFriendlyName[MAX_PATH];                    
}DIFILEEFFECT, *LPDIFILEEFFECT;                                            
typedef const DIFILEEFFECT *LPCDIFILEEFFECT;                                            
typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSINFILECALLBACK)(LPCDIFILEEFFECT , LPVOID); 
#endif /* DIJ_RINGZERO */
#endif /* DIRECTINPUT_VERSION >= 0x0700 */

#define DIEFF_OBJECTIDS             0x00000001
#define DIEFF_OBJECTOFFSETS         0x00000002
#define DIEFF_CARTESIAN             0x00000010
#define DIEFF_POLAR                 0x00000020
#define DIEFF_SPHERICAL             0x00000040

#define DIEP_DURATION               0x00000001
#define DIEP_SAMPLEPERIOD           0x00000002
#define DIEP_GAIN                   0x00000004
#define DIEP_TRIGGERBUTTON          0x00000008
#define DIEP_TRIGGERREPEATINTERVAL  0x00000010
#define DIEP_AXES                   0x00000020
#define DIEP_DIRECTION              0x00000040
#define DIEP_ENVELOPE               0x00000080
#define DIEP_TYPESPECIFICPARAMS     0x00000100
#if(DIRECTINPUT_VERSION >= 0x0600)
#define DIEP_STARTDELAY             0x00000200
#define DIEP_ALLPARAMS_DX5          0x000001FF
#define DIEP_ALLPARAMS              0x000003FF
#else /* DIRECTINPUT_VERSION < 0x0600 */
#define DIEP_ALLPARAMS              0x000001FF
#endif /* DIRECTINPUT_VERSION < 0x0600 */
#define DIEP_START                  0x20000000
#define DIEP_NORESTART              0x40000000
#define DIEP_NODOWNLOAD             0x80000000
#define DIEB_NOTRIGGER              0xFFFFFFFF

#define DIES_SOLO                   0x00000001
#define DIES_NODOWNLOAD             0x80000000

#define DIEGES_PLAYING              0x00000001
#define DIEGES_EMULATED             0x00000002

typedef struct DIEFFESCAPE {
    DWORD   dwSize;
    DWORD   dwCommand;
    LPVOID  lpvInBuffer;
    DWORD   cbInBuffer;
    LPVOID  lpvOutBuffer;
    DWORD   cbOutBuffer;
} DIEFFESCAPE, *LPDIEFFESCAPE;

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputEffect

DECLARE_INTERFACE_(IDirectInputEffect, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputEffect methods ***/
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(GetEffectGuid)(THIS_ LPGUID) PURE;
    STDMETHOD(GetParameters)(THIS_ LPDIEFFECT,DWORD) PURE;
    STDMETHOD(SetParameters)(THIS_ LPCDIEFFECT,DWORD) PURE;
    STDMETHOD(Start)(THIS_ DWORD,DWORD) PURE;
    STDMETHOD(Stop)(THIS) PURE;
    STDMETHOD(GetEffectStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(Download)(THIS) PURE;
    STDMETHOD(Unload)(THIS) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
};

typedef struct IDirectInputEffect *LPDIRECTINPUTEFFECT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputEffect_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputEffect_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputEffect_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputEffect_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputEffect_GetEffectGuid(p,a) (p)->lpVtbl->GetEffectGuid(p,a)
#define IDirectInputEffect_GetParameters(p,a,b) (p)->lpVtbl->GetParameters(p,a,b)
#define IDirectInputEffect_SetParameters(p,a,b) (p)->lpVtbl->SetParameters(p,a,b)
#define IDirectInputEffect_Start(p,a,b) (p)->lpVtbl->Start(p,a,b)
#define IDirectInputEffect_Stop(p) (p)->lpVtbl->Stop(p)
#define IDirectInputEffect_GetEffectStatus(p,a) (p)->lpVtbl->GetEffectStatus(p,a)
#define IDirectInputEffect_Download(p) (p)->lpVtbl->Download(p)
#define IDirectInputEffect_Unload(p) (p)->lpVtbl->Unload(p)
#define IDirectInputEffect_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#else
#define IDirectInputEffect_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputEffect_AddRef(p) (p)->AddRef()
#define IDirectInputEffect_Release(p) (p)->Release()
#define IDirectInputEffect_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputEffect_GetEffectGuid(p,a) (p)->GetEffectGuid(a)
#define IDirectInputEffect_GetParameters(p,a,b) (p)->GetParameters(a,b)
#define IDirectInputEffect_SetParameters(p,a,b) (p)->SetParameters(a,b)
#define IDirectInputEffect_Start(p,a,b) (p)->Start(a,b)
#define IDirectInputEffect_Stop(p) (p)->Stop()
#define IDirectInputEffect_GetEffectStatus(p,a) (p)->GetEffectStatus(a)
#define IDirectInputEffect_Download(p) (p)->Download()
#define IDirectInputEffect_Unload(p) (p)->Unload()
#define IDirectInputEffect_Escape(p,a) (p)->Escape(a)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0500 */

/****************************************************************************
 *
 *      IDirectInputDevice
 *
 ****************************************************************************/

#define DIDEVTYPE_DEVICE    1
#define DIDEVTYPE_MOUSE     2
#define DIDEVTYPE_KEYBOARD  3
#define DIDEVTYPE_JOYSTICK  4
#define DIDEVTYPE_HID       0x00010000

#define DIDEVTYPEMOUSE_UNKNOWN          1
#define DIDEVTYPEMOUSE_TRADITIONAL      2
#define DIDEVTYPEMOUSE_FINGERSTICK      3
#define DIDEVTYPEMOUSE_TOUCHPAD         4
#define DIDEVTYPEMOUSE_TRACKBALL        5

#define DIDEVTYPEKEYBOARD_UNKNOWN       0
#define DIDEVTYPEKEYBOARD_PCXT          1
#define DIDEVTYPEKEYBOARD_OLIVETTI      2
#define DIDEVTYPEKEYBOARD_PCAT          3
#define DIDEVTYPEKEYBOARD_PCENH         4
#define DIDEVTYPEKEYBOARD_NOKIA1050     5
#define DIDEVTYPEKEYBOARD_NOKIA9140     6
#define DIDEVTYPEKEYBOARD_NEC98         7
#define DIDEVTYPEKEYBOARD_NEC98LAPTOP   8
#define DIDEVTYPEKEYBOARD_NEC98106      9
#define DIDEVTYPEKEYBOARD_JAPAN106     10
#define DIDEVTYPEKEYBOARD_JAPANAX      11
#define DIDEVTYPEKEYBOARD_J3100        12

#define DIDEVTYPEJOYSTICK_UNKNOWN       1
#define DIDEVTYPEJOYSTICK_TRADITIONAL   2
#define DIDEVTYPEJOYSTICK_FLIGHTSTICK   3
#define DIDEVTYPEJOYSTICK_GAMEPAD       4
#define DIDEVTYPEJOYSTICK_RUDDER        5
#define DIDEVTYPEJOYSTICK_WHEEL         6
#define DIDEVTYPEJOYSTICK_HEADTRACKER   7

#define GET_DIDEVICE_TYPE(dwDevType)    LOBYTE(dwDevType)
#define GET_DIDEVICE_SUBTYPE(dwDevType) HIBYTE(dwDevType)

#if(DIRECTINPUT_VERSION >= 0x0500)
/* This structure is defined for DirectX 3.0 compatibility */
typedef struct DIDEVCAPS_DX3 {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwDevType;
    DWORD   dwAxes;
    DWORD   dwButtons;
    DWORD   dwPOVs;
} DIDEVCAPS_DX3, *LPDIDEVCAPS_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVCAPS {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwDevType;
    DWORD   dwAxes;
    DWORD   dwButtons;
    DWORD   dwPOVs;
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFSamplePeriod;
    DWORD   dwFFMinTimeResolution;
    DWORD   dwFirmwareRevision;
    DWORD   dwHardwareRevision;
    DWORD   dwFFDriverVersion;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVCAPS, *LPDIDEVCAPS;

#define DIDC_ATTACHED           0x00000001
#define DIDC_POLLEDDEVICE       0x00000002
#define DIDC_EMULATED           0x00000004
#define DIDC_POLLEDDATAFORMAT   0x00000008
#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIDC_FORCEFEEDBACK      0x00000100
#define DIDC_FFATTACK           0x00000200
#define DIDC_FFFADE             0x00000400
#define DIDC_SATURATION         0x00000800
#define DIDC_POSNEGCOEFFICIENTS 0x00001000
#define DIDC_POSNEGSATURATION   0x00002000
#define DIDC_DEADBAND           0x00004000
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#define DIDC_STARTDELAY         0x00008000
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDC_ALIAS              0x00010000
#define DIDC_PHANTOM            0x00020000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#define DIDFT_ALL           0x00000000

#define DIDFT_RELAXIS       0x00000001
#define DIDFT_ABSAXIS       0x00000002
#define DIDFT_AXIS          0x00000003

#define DIDFT_PSHBUTTON     0x00000004
#define DIDFT_TGLBUTTON     0x00000008
#define DIDFT_BUTTON        0x0000000C

#define DIDFT_POV           0x00000010
#define DIDFT_COLLECTION    0x00000040
#define DIDFT_NODATA        0x00000080

#define DIDFT_ANYINSTANCE   0x00FFFF00
#define DIDFT_INSTANCEMASK  DIDFT_ANYINSTANCE
#define DIDFT_MAKEINSTANCE(n) ((WORD)(n) << 8)
#define DIDFT_GETTYPE(n)     LOBYTE(n)
#define DIDFT_GETINSTANCE(n) LOWORD((n) >> 8)
#define DIDFT_FFACTUATOR        0x01000000
#define DIDFT_FFEFFECTTRIGGER   0x02000000
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDFT_OUTPUT            0x10000000
#define DIDFT_VENDORDEFINED     0x04000000
#define DIDFT_ALIAS             0x08000000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#define DIDFT_ENUMCOLLECTION(n) ((WORD)(n) << 8)
#define DIDFT_NOCOLLECTION      0x00FFFF00

#ifndef DIJ_RINGZERO

typedef struct _DIOBJECTDATAFORMAT {
    const GUID *pguid;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
} DIOBJECTDATAFORMAT, *LPDIOBJECTDATAFORMAT;
typedef const DIOBJECTDATAFORMAT *LPCDIOBJECTDATAFORMAT;

typedef struct _DIDATAFORMAT {
    DWORD   dwSize;
    DWORD   dwObjSize;
    DWORD   dwFlags;
    DWORD   dwDataSize;
    DWORD   dwNumObjs;
    LPDIOBJECTDATAFORMAT rgodf;
} DIDATAFORMAT, *LPDIDATAFORMAT;
typedef const DIDATAFORMAT *LPCDIDATAFORMAT;

#define DIDF_ABSAXIS            0x00000001
#define DIDF_RELAXIS            0x00000002

#ifdef __cplusplus
extern "C" {
#endif
extern const DIDATAFORMAT c_dfDIMouse;

#if(DIRECTINPUT_VERSION >= 0x0700)
extern const DIDATAFORMAT c_dfDIMouse2;
#endif /* DIRECTINPUT_VERSION >= 0x0700 */

extern const DIDATAFORMAT c_dfDIKeyboard;

#if(DIRECTINPUT_VERSION >= 0x0500)
extern const DIDATAFORMAT c_dfDIJoystick;
extern const DIDATAFORMAT c_dfDIJoystick2;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

#ifdef __cplusplus
};
#endif

#if(DIRECTINPUT_VERSION >= 0x0500)
/* These structures are defined for DirectX 3.0 compatibility */

typedef struct DIDEVICEOBJECTINSTANCE_DX3A {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    CHAR    tszName[MAX_PATH];
} DIDEVICEOBJECTINSTANCE_DX3A, *LPDIDEVICEOBJECTINSTANCE_DX3A;
typedef struct DIDEVICEOBJECTINSTANCE_DX3W {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    WCHAR   tszName[MAX_PATH];
} DIDEVICEOBJECTINSTANCE_DX3W, *LPDIDEVICEOBJECTINSTANCE_DX3W;
#ifdef UNICODE
typedef DIDEVICEOBJECTINSTANCE_DX3W DIDEVICEOBJECTINSTANCE_DX3;
typedef LPDIDEVICEOBJECTINSTANCE_DX3W LPDIDEVICEOBJECTINSTANCE_DX3;
#else
typedef DIDEVICEOBJECTINSTANCE_DX3A DIDEVICEOBJECTINSTANCE_DX3;
typedef LPDIDEVICEOBJECTINSTANCE_DX3A LPDIDEVICEOBJECTINSTANCE_DX3;
#endif // UNICODE
typedef const DIDEVICEOBJECTINSTANCE_DX3A *LPCDIDEVICEOBJECTINSTANCE_DX3A;
typedef const DIDEVICEOBJECTINSTANCE_DX3W *LPCDIDEVICEOBJECTINSTANCE_DX3W;
typedef const DIDEVICEOBJECTINSTANCE_DX3  *LPCDIDEVICEOBJECTINSTANCE_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVICEOBJECTINSTANCEA {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    CHAR    tszName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
    WORD    wCollectionNumber;
    WORD    wDesignatorIndex;
    WORD    wUsagePage;
    WORD    wUsage;
    DWORD   dwDimension;
    WORD    wExponent;
    WORD    wReportId;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEOBJECTINSTANCEA, *LPDIDEVICEOBJECTINSTANCEA;
typedef struct DIDEVICEOBJECTINSTANCEW {
    DWORD   dwSize;
    GUID    guidType;
    DWORD   dwOfs;
    DWORD   dwType;
    DWORD   dwFlags;
    WCHAR   tszName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    DWORD   dwFFMaxForce;
    DWORD   dwFFForceResolution;
    WORD    wCollectionNumber;
    WORD    wDesignatorIndex;
    WORD    wUsagePage;
    WORD    wUsage;
    DWORD   dwDimension;
    WORD    wExponent;
    WORD    wReportId;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEOBJECTINSTANCEW, *LPDIDEVICEOBJECTINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEOBJECTINSTANCEW DIDEVICEOBJECTINSTANCE;
typedef LPDIDEVICEOBJECTINSTANCEW LPDIDEVICEOBJECTINSTANCE;
#else
typedef DIDEVICEOBJECTINSTANCEA DIDEVICEOBJECTINSTANCE;
typedef LPDIDEVICEOBJECTINSTANCEA LPDIDEVICEOBJECTINSTANCE;
#endif // UNICODE
typedef const DIDEVICEOBJECTINSTANCEA *LPCDIDEVICEOBJECTINSTANCEA;
typedef const DIDEVICEOBJECTINSTANCEW *LPCDIDEVICEOBJECTINSTANCEW;
typedef const DIDEVICEOBJECTINSTANCE  *LPCDIDEVICEOBJECTINSTANCE;

typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKA)(LPCDIDEVICEOBJECTINSTANCEA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICEOBJECTSCALLBACKW)(LPCDIDEVICEOBJECTINSTANCEW, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKW
#else
#define LPDIENUMDEVICEOBJECTSCALLBACK  LPDIENUMDEVICEOBJECTSCALLBACKA
#endif // !UNICODE

#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIDOI_FFACTUATOR        0x00000001
#define DIDOI_FFEFFECTTRIGGER   0x00000002
#define DIDOI_POLLED            0x00008000
#define DIDOI_ASPECTPOSITION    0x00000100
#define DIDOI_ASPECTVELOCITY    0x00000200
#define DIDOI_ASPECTACCEL       0x00000300
#define DIDOI_ASPECTFORCE       0x00000400
#define DIDOI_ASPECTMASK        0x00000F00
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIDOI_GUIDISUSAGE       0x00010000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

typedef struct DIPROPHEADER {
    DWORD   dwSize;
    DWORD   dwHeaderSize;
    DWORD   dwObj;
    DWORD   dwHow;
} DIPROPHEADER, *LPDIPROPHEADER;
typedef const DIPROPHEADER *LPCDIPROPHEADER;

#define DIPH_DEVICE             0
#define DIPH_BYOFFSET           1
#define DIPH_BYID               2
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIPH_BYUSAGE            3

#define DIMAKEUSAGEDWORD(UsagePage, Usage) \
                                (DWORD)MAKELONG(Usage, UsagePage)
#endif /* DIRECTINPUT_VERSION >= 0x050a */

typedef struct DIPROPDWORD {
    DIPROPHEADER diph;
    DWORD   dwData;
} DIPROPDWORD, *LPDIPROPDWORD;
typedef const DIPROPDWORD *LPCDIPROPDWORD;

typedef struct DIPROPRANGE {
    DIPROPHEADER diph;
    LONG    lMin;
    LONG    lMax;
} DIPROPRANGE, *LPDIPROPRANGE;
typedef const DIPROPRANGE *LPCDIPROPRANGE;

#define DIPROPRANGE_NOMIN       ((LONG)0x80000000)
#define DIPROPRANGE_NOMAX       ((LONG)0x7FFFFFFF)

#if(DIRECTINPUT_VERSION >= 0x050a)
typedef struct DIPROPCAL {
    DIPROPHEADER diph;
    LONG    lMin;
    LONG    lCenter;
    LONG    lMax;
} DIPROPCAL, *LPDIPROPCAL;
typedef const DIPROPCAL *LPCDIPROPCAL;

typedef struct DIPROPGUIDANDPATH {
    DIPROPHEADER diph;
    GUID    guidClass;
    WCHAR   wszPath[MAX_PATH];
} DIPROPGUIDANDPATH, *LPDIPROPGUIDANDPATH;
typedef const DIPROPGUIDANDPATH *LPCDIPROPGUIDANDPATH;

typedef struct DIPROPSTRING {
    DIPROPHEADER diph;
    WCHAR   wsz[MAX_PATH];
} DIPROPSTRING, *LPDIPROPSTRING;
typedef const DIPROPSTRING *LPCDIPROPSTRING;

#endif /* DIRECTINPUT_VERSION >= 0x050a */
#ifdef __cplusplus
#define MAKEDIPROP(prop)    (*(const GUID *)(prop))
#else
#define MAKEDIPROP(prop)    ((REFGUID)(prop))
#endif

#define DIPROP_BUFFERSIZE       MAKEDIPROP(1)

#define DIPROP_AXISMODE         MAKEDIPROP(2)

#define DIPROPAXISMODE_ABS      0
#define DIPROPAXISMODE_REL      1

#define DIPROP_GRANULARITY      MAKEDIPROP(3)

#define DIPROP_RANGE            MAKEDIPROP(4)

#define DIPROP_DEADZONE         MAKEDIPROP(5)

#define DIPROP_SATURATION       MAKEDIPROP(6)

#define DIPROP_FFGAIN           MAKEDIPROP(7)

#define DIPROP_FFLOAD           MAKEDIPROP(8)

#define DIPROP_AUTOCENTER       MAKEDIPROP(9)

#define DIPROPAUTOCENTER_OFF    0
#define DIPROPAUTOCENTER_ON     1

#define DIPROP_CALIBRATIONMODE  MAKEDIPROP(10)

#define DIPROPCALIBRATIONMODE_COOKED    0
#define DIPROPCALIBRATIONMODE_RAW       1

#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIPROP_CALIBRATION      MAKEDIPROP(11)

#define DIPROP_GUIDANDPATH      MAKEDIPROP(12)

#define DIPROP_INSTANCENAME     MAKEDIPROP(13)

#define DIPROP_PRODUCTNAME      MAKEDIPROP(14)
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#define DIPROP_JOYSTICKID       MAKEDIPROP(15)

#define DIPROP_GETPORTDISPLAYNAME       MAKEDIPROP(16)


#define DIPROP_ENABLEREPORTID       MAKEDIPROP(17)


#define DIPROP_GETPHYSICALRANGE            MAKEDIPROP(18)

#define DIPROP_GETLOGICALRANGE            MAKEDIPROP(19)


typedef struct DIDEVICEOBJECTDATA {
    DWORD   dwOfs;
    DWORD   dwData;
    DWORD   dwTimeStamp;
    DWORD   dwSequence;
} DIDEVICEOBJECTDATA, *LPDIDEVICEOBJECTDATA;
typedef const DIDEVICEOBJECTDATA *LPCDIDEVICEOBJECTDATA;

#define DIGDD_PEEK          0x00000001

#define DISEQUENCE_COMPARE(dwSequence1, cmp, dwSequence2) \
                        ((int)((dwSequence1) - (dwSequence2)) cmp 0)
#define DISCL_EXCLUSIVE     0x00000001
#define DISCL_NONEXCLUSIVE  0x00000002
#define DISCL_FOREGROUND    0x00000004
#define DISCL_BACKGROUND    0x00000008
#define DISCL_NOWINKEY      0x00000010

#if(DIRECTINPUT_VERSION >= 0x0500)
/* These structures are defined for DirectX 3.0 compatibility */

typedef struct DIDEVICEINSTANCE_DX3A {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    CHAR    tszInstanceName[MAX_PATH];
    CHAR    tszProductName[MAX_PATH];
} DIDEVICEINSTANCE_DX3A, *LPDIDEVICEINSTANCE_DX3A;
typedef struct DIDEVICEINSTANCE_DX3W {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    WCHAR   tszInstanceName[MAX_PATH];
    WCHAR   tszProductName[MAX_PATH];
} DIDEVICEINSTANCE_DX3W, *LPDIDEVICEINSTANCE_DX3W;
#ifdef UNICODE
typedef DIDEVICEINSTANCE_DX3W DIDEVICEINSTANCE_DX3;
typedef LPDIDEVICEINSTANCE_DX3W LPDIDEVICEINSTANCE_DX3;
#else
typedef DIDEVICEINSTANCE_DX3A DIDEVICEINSTANCE_DX3;
typedef LPDIDEVICEINSTANCE_DX3A LPDIDEVICEINSTANCE_DX3;
#endif // UNICODE
typedef const DIDEVICEINSTANCE_DX3A *LPCDIDEVICEINSTANCE_DX3A;
typedef const DIDEVICEINSTANCE_DX3W *LPCDIDEVICEINSTANCE_DX3W;
typedef const DIDEVICEINSTANCE_DX3  *LPCDIDEVICEINSTANCE_DX3;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */

typedef struct DIDEVICEINSTANCEA {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    CHAR    tszInstanceName[MAX_PATH];
    CHAR    tszProductName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    GUID    guidFFDriver;
    WORD    wUsagePage;
    WORD    wUsage;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEINSTANCEA, *LPDIDEVICEINSTANCEA;
typedef struct DIDEVICEINSTANCEW {
    DWORD   dwSize;
    GUID    guidInstance;
    GUID    guidProduct;
    DWORD   dwDevType;
    WCHAR   tszInstanceName[MAX_PATH];
    WCHAR   tszProductName[MAX_PATH];
#if(DIRECTINPUT_VERSION >= 0x0500)
    GUID    guidFFDriver;
    WORD    wUsagePage;
    WORD    wUsage;
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
} DIDEVICEINSTANCEW, *LPDIDEVICEINSTANCEW;
#ifdef UNICODE
typedef DIDEVICEINSTANCEW DIDEVICEINSTANCE;
typedef LPDIDEVICEINSTANCEW LPDIDEVICEINSTANCE;
#else
typedef DIDEVICEINSTANCEA DIDEVICEINSTANCE;
typedef LPDIDEVICEINSTANCEA LPDIDEVICEINSTANCE;
#endif // UNICODE
typedef const DIDEVICEINSTANCEA *LPCDIDEVICEINSTANCEA;
typedef const DIDEVICEINSTANCEW *LPCDIDEVICEINSTANCEW;
typedef const DIDEVICEINSTANCE  *LPCDIDEVICEINSTANCE;

#undef INTERFACE
#define INTERFACE IDirectInputDeviceW

DECLARE_INTERFACE_(IDirectInputDeviceW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceW methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceW *LPDIRECTINPUTDEVICEW;

#undef INTERFACE
#define INTERFACE IDirectInputDeviceA

DECLARE_INTERFACE_(IDirectInputDeviceA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceA methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
};

typedef struct IDirectInputDeviceA *LPDIRECTINPUTDEVICEA;

#ifdef UNICODE
#define IID_IDirectInputDevice IID_IDirectInputDeviceW
#define IDirectInputDevice IDirectInputDeviceW
#define IDirectInputDeviceVtbl IDirectInputDeviceWVtbl
#else
#define IID_IDirectInputDevice IID_IDirectInputDeviceA
#define IDirectInputDevice IDirectInputDeviceA
#define IDirectInputDeviceVtbl IDirectInputDeviceAVtbl
#endif
typedef struct IDirectInputDevice *LPDIRECTINPUTDEVICE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#else
#define IDirectInputDevice_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice_AddRef(p) (p)->AddRef()
#define IDirectInputDevice_Release(p) (p)->Release()
#define IDirectInputDevice_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice_Acquire(p) (p)->Acquire()
#define IDirectInputDevice_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#endif

#endif /* DIJ_RINGZERO */


#if(DIRECTINPUT_VERSION >= 0x0500)

#define DISFFC_RESET            0x00000001
#define DISFFC_STOPALL          0x00000002
#define DISFFC_PAUSE            0x00000004
#define DISFFC_CONTINUE         0x00000008
#define DISFFC_SETACTUATORSON   0x00000010
#define DISFFC_SETACTUATORSOFF  0x00000020

#define DIGFFS_EMPTY            0x00000001
#define DIGFFS_STOPPED          0x00000002
#define DIGFFS_PAUSED           0x00000004
#define DIGFFS_ACTUATORSON      0x00000010
#define DIGFFS_ACTUATORSOFF     0x00000020
#define DIGFFS_POWERON          0x00000040
#define DIGFFS_POWEROFF         0x00000080
#define DIGFFS_SAFETYSWITCHON   0x00000100
#define DIGFFS_SAFETYSWITCHOFF  0x00000200
#define DIGFFS_USERFFSWITCHON   0x00000400
#define DIGFFS_USERFFSWITCHOFF  0x00000800
#define DIGFFS_DEVICELOST       0x80000000

#ifndef DIJ_RINGZERO

typedef struct DIEFFECTINFOA {
    DWORD   dwSize;
    GUID    guid;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    CHAR    tszName[MAX_PATH];
} DIEFFECTINFOA, *LPDIEFFECTINFOA;
typedef struct DIEFFECTINFOW {
    DWORD   dwSize;
    GUID    guid;
    DWORD   dwEffType;
    DWORD   dwStaticParams;
    DWORD   dwDynamicParams;
    WCHAR   tszName[MAX_PATH];
} DIEFFECTINFOW, *LPDIEFFECTINFOW;
#ifdef UNICODE
typedef DIEFFECTINFOW DIEFFECTINFO;
typedef LPDIEFFECTINFOW LPDIEFFECTINFO;
#else
typedef DIEFFECTINFOA DIEFFECTINFO;
typedef LPDIEFFECTINFOA LPDIEFFECTINFO;
#endif // UNICODE
typedef const DIEFFECTINFOA *LPCDIEFFECTINFOA;
typedef const DIEFFECTINFOW *LPCDIEFFECTINFOW;
typedef const DIEFFECTINFO  *LPCDIEFFECTINFO;

#define DISDD_CONTINUE          0x00000001

typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKA)(LPCDIEFFECTINFOA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMEFFECTSCALLBACKW)(LPCDIEFFECTINFOW, LPVOID);
#ifdef UNICODE
#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKW
#else
#define LPDIENUMEFFECTSCALLBACK  LPDIENUMEFFECTSCALLBACKA
#endif // !UNICODE
typedef BOOL (FAR PASCAL * LPDIENUMCREATEDEFFECTOBJECTSCALLBACK)(LPDIRECTINPUTEFFECT, LPVOID);

#undef INTERFACE
#define INTERFACE IDirectInputDevice2W

DECLARE_INTERFACE_(IDirectInputDevice2W, IDirectInputDeviceW)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceW methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;

    /*** IDirectInputDevice2W methods ***/
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
};

typedef struct IDirectInputDevice2W *LPDIRECTINPUTDEVICE2W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice2A

DECLARE_INTERFACE_(IDirectInputDevice2A, IDirectInputDeviceA)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDeviceA methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;

    /*** IDirectInputDevice2A methods ***/
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
};

typedef struct IDirectInputDevice2A *LPDIRECTINPUTDEVICE2A;

#ifdef UNICODE
#define IID_IDirectInputDevice2 IID_IDirectInputDevice2W
#define IDirectInputDevice2 IDirectInputDevice2W
#define IDirectInputDevice2Vtbl IDirectInputDevice2WVtbl
#else
#define IID_IDirectInputDevice2 IID_IDirectInputDevice2A
#define IDirectInputDevice2 IDirectInputDevice2A
#define IDirectInputDevice2Vtbl IDirectInputDevice2AVtbl
#endif
typedef struct IDirectInputDevice2 *LPDIRECTINPUTDEVICE2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice2_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice2_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice2_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice2_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice2_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice2_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice2_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice2_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice2_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice2_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#else
#define IDirectInputDevice2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice2_AddRef(p) (p)->AddRef()
#define IDirectInputDevice2_Release(p) (p)->Release()
#define IDirectInputDevice2_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice2_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice2_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice2_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice2_Acquire(p) (p)->Acquire()
#define IDirectInputDevice2_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice2_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice2_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice2_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice2_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice2_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice2_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice2_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice2_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice2_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice2_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice2_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice2_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice2_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice2_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice2_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice2_Poll(p) (p)->Poll()
#define IDirectInputDevice2_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0500 */

#if(DIRECTINPUT_VERSION >= 0x0700)
#define DIFEF_DEFAULT               0x00000000
#define DIFEF_INCLUDENONSTANDARD    0x00000001
#define DIFEF_MODIFYIFNEEDED		0x00000010

#ifndef DIJ_RINGZERO

#undef INTERFACE
#define INTERFACE IDirectInputDevice7W

DECLARE_INTERFACE_(IDirectInputDevice7W, IDirectInputDevice2W)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice2W methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEW,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEW) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOW,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;

    /*** IDirectInputDevice7W methods ***/
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCWSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCWSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
};

typedef struct IDirectInputDevice7W *LPDIRECTINPUTDEVICE7W;

#undef INTERFACE
#define INTERFACE IDirectInputDevice7A

DECLARE_INTERFACE_(IDirectInputDevice7A, IDirectInputDevice2A)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputDevice2A methods ***/
    STDMETHOD(GetCapabilities)(THIS_ LPDIDEVCAPS) PURE;
    STDMETHOD(EnumObjects)(THIS_ LPDIENUMDEVICEOBJECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetProperty)(THIS_ REFGUID,LPDIPROPHEADER) PURE;
    STDMETHOD(SetProperty)(THIS_ REFGUID,LPCDIPROPHEADER) PURE;
    STDMETHOD(Acquire)(THIS) PURE;
    STDMETHOD(Unacquire)(THIS) PURE;
    STDMETHOD(GetDeviceState)(THIS_ DWORD,LPVOID) PURE;
    STDMETHOD(GetDeviceData)(THIS_ DWORD,LPDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;
    STDMETHOD(SetDataFormat)(THIS_ LPCDIDATAFORMAT) PURE;
    STDMETHOD(SetEventNotification)(THIS_ HANDLE) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(GetObjectInfo)(THIS_ LPDIDEVICEOBJECTINSTANCEA,DWORD,DWORD) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPDIDEVICEINSTANCEA) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD,REFGUID) PURE;
    STDMETHOD(CreateEffect)(THIS_ REFGUID,LPCDIEFFECT,LPDIRECTINPUTEFFECT *,LPUNKNOWN) PURE;
    STDMETHOD(EnumEffects)(THIS_ LPDIENUMEFFECTSCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetEffectInfo)(THIS_ LPDIEFFECTINFOA,REFGUID) PURE;
    STDMETHOD(GetForceFeedbackState)(THIS_ LPDWORD) PURE;
    STDMETHOD(SendForceFeedbackCommand)(THIS_ DWORD) PURE;
    STDMETHOD(EnumCreatedEffectObjects)(THIS_ LPDIENUMCREATEDEFFECTOBJECTSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(Escape)(THIS_ LPDIEFFESCAPE) PURE;
    STDMETHOD(Poll)(THIS) PURE;
    STDMETHOD(SendDeviceData)(THIS_ DWORD,LPCDIDEVICEOBJECTDATA,LPDWORD,DWORD) PURE;

    /*** IDirectInputDevice7A methods ***/
    STDMETHOD(EnumEffectsInFile)(THIS_ LPCSTR,LPDIENUMEFFECTSINFILECALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(WriteEffectToFile)(THIS_ LPCSTR,DWORD,LPDIFILEEFFECT,DWORD) PURE;
};

typedef struct IDirectInputDevice7A *LPDIRECTINPUTDEVICE7A;

#ifdef UNICODE
#define IID_IDirectInputDevice7 IID_IDirectInputDevice7W
#define IDirectInputDevice7 IDirectInputDevice7W
#define IDirectInputDevice7Vtbl IDirectInputDevice7WVtbl
#else
#define IID_IDirectInputDevice7 IID_IDirectInputDevice7A
#define IDirectInputDevice7 IDirectInputDevice7A
#define IDirectInputDevice7Vtbl IDirectInputDevice7AVtbl
#endif
typedef struct IDirectInputDevice7 *LPDIRECTINPUTDEVICE7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInputDevice7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInputDevice7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInputDevice7_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInputDevice7_GetCapabilities(p,a) (p)->lpVtbl->GetCapabilities(p,a)
#define IDirectInputDevice7_EnumObjects(p,a,b,c) (p)->lpVtbl->EnumObjects(p,a,b,c)
#define IDirectInputDevice7_GetProperty(p,a,b) (p)->lpVtbl->GetProperty(p,a,b)
#define IDirectInputDevice7_SetProperty(p,a,b) (p)->lpVtbl->SetProperty(p,a,b)
#define IDirectInputDevice7_Acquire(p) (p)->lpVtbl->Acquire(p)
#define IDirectInputDevice7_Unacquire(p) (p)->lpVtbl->Unacquire(p)
#define IDirectInputDevice7_GetDeviceState(p,a,b) (p)->lpVtbl->GetDeviceState(p,a,b)
#define IDirectInputDevice7_GetDeviceData(p,a,b,c,d) (p)->lpVtbl->GetDeviceData(p,a,b,c,d)
#define IDirectInputDevice7_SetDataFormat(p,a) (p)->lpVtbl->SetDataFormat(p,a)
#define IDirectInputDevice7_SetEventNotification(p,a) (p)->lpVtbl->SetEventNotification(p,a)
#define IDirectInputDevice7_SetCooperativeLevel(p,a,b) (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectInputDevice7_GetObjectInfo(p,a,b,c) (p)->lpVtbl->GetObjectInfo(p,a,b,c)
#define IDirectInputDevice7_GetDeviceInfo(p,a) (p)->lpVtbl->GetDeviceInfo(p,a)
#define IDirectInputDevice7_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInputDevice7_Initialize(p,a,b,c) (p)->lpVtbl->Initialize(p,a,b,c)
#define IDirectInputDevice7_CreateEffect(p,a,b,c,d) (p)->lpVtbl->CreateEffect(p,a,b,c,d)
#define IDirectInputDevice7_EnumEffects(p,a,b,c) (p)->lpVtbl->EnumEffects(p,a,b,c)
#define IDirectInputDevice7_GetEffectInfo(p,a,b) (p)->lpVtbl->GetEffectInfo(p,a,b)
#define IDirectInputDevice7_GetForceFeedbackState(p,a) (p)->lpVtbl->GetForceFeedbackState(p,a)
#define IDirectInputDevice7_SendForceFeedbackCommand(p,a) (p)->lpVtbl->SendForceFeedbackCommand(p,a)
#define IDirectInputDevice7_EnumCreatedEffectObjects(p,a,b,c) (p)->lpVtbl->EnumCreatedEffectObjects(p,a,b,c)
#define IDirectInputDevice7_Escape(p,a) (p)->lpVtbl->Escape(p,a)
#define IDirectInputDevice7_Poll(p) (p)->lpVtbl->Poll(p)
#define IDirectInputDevice7_SendDeviceData(p,a,b,c,d) (p)->lpVtbl->SendDeviceData(p,a,b,c,d)
#define IDirectInputDevice7_EnumEffectsInFile(p,a,b,c,d) (p)->lpVtbl->EnumEffectsInFile(p,a,b,c,d)
#define IDirectInputDevice7_WriteEffectToFile(p,a,b,c,d) (p)->lpVtbl->WriteEffectToFile(p,a,b,c,d)
#else
#define IDirectInputDevice7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInputDevice7_AddRef(p) (p)->AddRef()
#define IDirectInputDevice7_Release(p) (p)->Release()
#define IDirectInputDevice7_GetCapabilities(p,a) (p)->GetCapabilities(a)
#define IDirectInputDevice7_EnumObjects(p,a,b,c) (p)->EnumObjects(a,b,c)
#define IDirectInputDevice7_GetProperty(p,a,b) (p)->GetProperty(a,b)
#define IDirectInputDevice7_SetProperty(p,a,b) (p)->SetProperty(a,b)
#define IDirectInputDevice7_Acquire(p) (p)->Acquire()
#define IDirectInputDevice7_Unacquire(p) (p)->Unacquire()
#define IDirectInputDevice7_GetDeviceState(p,a,b) (p)->GetDeviceState(a,b)
#define IDirectInputDevice7_GetDeviceData(p,a,b,c,d) (p)->GetDeviceData(a,b,c,d)
#define IDirectInputDevice7_SetDataFormat(p,a) (p)->SetDataFormat(a)
#define IDirectInputDevice7_SetEventNotification(p,a) (p)->SetEventNotification(a)
#define IDirectInputDevice7_SetCooperativeLevel(p,a,b) (p)->SetCooperativeLevel(a,b)
#define IDirectInputDevice7_GetObjectInfo(p,a,b,c) (p)->GetObjectInfo(a,b,c)
#define IDirectInputDevice7_GetDeviceInfo(p,a) (p)->GetDeviceInfo(a)
#define IDirectInputDevice7_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInputDevice7_Initialize(p,a,b,c) (p)->Initialize(a,b,c)
#define IDirectInputDevice7_CreateEffect(p,a,b,c,d) (p)->CreateEffect(a,b,c,d)
#define IDirectInputDevice7_EnumEffects(p,a,b,c) (p)->EnumEffects(a,b,c)
#define IDirectInputDevice7_GetEffectInfo(p,a,b) (p)->GetEffectInfo(a,b)
#define IDirectInputDevice7_GetForceFeedbackState(p,a) (p)->GetForceFeedbackState(a)
#define IDirectInputDevice7_SendForceFeedbackCommand(p,a) (p)->SendForceFeedbackCommand(a)
#define IDirectInputDevice7_EnumCreatedEffectObjects(p,a,b,c) (p)->EnumCreatedEffectObjects(a,b,c)
#define IDirectInputDevice7_Escape(p,a) (p)->Escape(a)
#define IDirectInputDevice7_Poll(p) (p)->Poll()
#define IDirectInputDevice7_SendDeviceData(p,a,b,c,d) (p)->SendDeviceData(a,b,c,d)
#define IDirectInputDevice7_EnumEffectsInFile(p,a,b,c,d) (p)->EnumEffectsInFile(a,b,c,d)
#define IDirectInputDevice7_WriteEffectToFile(p,a,b,c,d) (p)->WriteEffectToFile(a,b,c,d)
#endif

#endif /* DIJ_RINGZERO */

#endif /* DIRECTINPUT_VERSION >= 0x0700 */

/****************************************************************************
 *
 *      Mouse
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

typedef struct _DIMOUSESTATE {
    LONG    lX;
    LONG    lY;
    LONG    lZ;
    BYTE    rgbButtons[4];
} DIMOUSESTATE, *LPDIMOUSESTATE;

#if DIRECTINPUT_VERSION >= 0x0700
typedef struct _DIMOUSESTATE2 {
    LONG    lX;
    LONG    lY;
    LONG    lZ;
    BYTE    rgbButtons[8];
} DIMOUSESTATE2, *LPDIMOUSESTATE2;
#endif


#define DIMOFS_X        FIELD_OFFSET(DIMOUSESTATE, lX)
#define DIMOFS_Y        FIELD_OFFSET(DIMOUSESTATE, lY)
#define DIMOFS_Z        FIELD_OFFSET(DIMOUSESTATE, lZ)
#define DIMOFS_BUTTON0 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 0)
#define DIMOFS_BUTTON1 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 1)
#define DIMOFS_BUTTON2 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 2)
#define DIMOFS_BUTTON3 (FIELD_OFFSET(DIMOUSESTATE, rgbButtons) + 3)
#if (DIRECTINPUT_VERSION >= 0x0700)
#define DIMOFS_BUTTON4 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 4)
#define DIMOFS_BUTTON5 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 5)
#define DIMOFS_BUTTON6 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 6)
#define DIMOFS_BUTTON7 (FIELD_OFFSET(DIMOUSESTATE2, rgbButtons) + 7)
#endif
#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Keyboard
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

/****************************************************************************
 *
 *      DirectInput keyboard scan codes
 *
 ****************************************************************************/

#define DIK_ESCAPE          0x01
#define DIK_1               0x02
#define DIK_2               0x03
#define DIK_3               0x04
#define DIK_4               0x05
#define DIK_5               0x06
#define DIK_6               0x07
#define DIK_7               0x08
#define DIK_8               0x09
#define DIK_9               0x0A
#define DIK_0               0x0B
#define DIK_MINUS           0x0C    /* - on main keyboard */
#define DIK_EQUALS          0x0D
#define DIK_BACK            0x0E    /* backspace */
#define DIK_TAB             0x0F
#define DIK_Q               0x10
#define DIK_W               0x11
#define DIK_E               0x12
#define DIK_R               0x13
#define DIK_T               0x14
#define DIK_Y               0x15
#define DIK_U               0x16
#define DIK_I               0x17
#define DIK_O               0x18
#define DIK_P               0x19
#define DIK_LBRACKET        0x1A
#define DIK_RBRACKET        0x1B
#define DIK_RETURN          0x1C    /* Enter on main keyboard */
#define DIK_LCONTROL        0x1D
#define DIK_A               0x1E
#define DIK_S               0x1F
#define DIK_D               0x20
#define DIK_F               0x21
#define DIK_G               0x22
#define DIK_H               0x23
#define DIK_J               0x24
#define DIK_K               0x25
#define DIK_L               0x26
#define DIK_SEMICOLON       0x27
#define DIK_APOSTROPHE      0x28
#define DIK_GRAVE           0x29    /* accent grave */
#define DIK_LSHIFT          0x2A
#define DIK_BACKSLASH       0x2B
#define DIK_Z               0x2C
#define DIK_X               0x2D
#define DIK_C               0x2E
#define DIK_V               0x2F
#define DIK_B               0x30
#define DIK_N               0x31
#define DIK_M               0x32
#define DIK_COMMA           0x33
#define DIK_PERIOD          0x34    /* . on main keyboard */
#define DIK_SLASH           0x35    /* / on main keyboard */
#define DIK_RSHIFT          0x36
#define DIK_MULTIPLY        0x37    /* * on numeric keypad */
#define DIK_LMENU           0x38    /* left Alt */
#define DIK_SPACE           0x39
#define DIK_CAPITAL         0x3A
#define DIK_F1              0x3B
#define DIK_F2              0x3C
#define DIK_F3              0x3D
#define DIK_F4              0x3E
#define DIK_F5              0x3F
#define DIK_F6              0x40
#define DIK_F7              0x41
#define DIK_F8              0x42
#define DIK_F9              0x43
#define DIK_F10             0x44
#define DIK_NUMLOCK         0x45
#define DIK_SCROLL          0x46    /* Scroll Lock */
#define DIK_NUMPAD7         0x47
#define DIK_NUMPAD8         0x48
#define DIK_NUMPAD9         0x49
#define DIK_SUBTRACT        0x4A    /* - on numeric keypad */
#define DIK_NUMPAD4         0x4B
#define DIK_NUMPAD5         0x4C
#define DIK_NUMPAD6         0x4D
#define DIK_ADD             0x4E    /* + on numeric keypad */
#define DIK_NUMPAD1         0x4F
#define DIK_NUMPAD2         0x50
#define DIK_NUMPAD3         0x51
#define DIK_NUMPAD0         0x52
#define DIK_DECIMAL         0x53    /* . on numeric keypad */
#define DIK_OEM_102         0x56    /* < > | on UK/Germany keyboards */
#define DIK_F11             0x57
#define DIK_F12             0x58

#define DIK_F13             0x64    /*                     (NEC PC98) */
#define DIK_F14             0x65    /*                     (NEC PC98) */
#define DIK_F15             0x66    /*                     (NEC PC98) */

#define DIK_KANA            0x70    /* (Japanese keyboard)            */
#define DIK_ABNT_C1         0x73    /* / ? on Portugese (Brazilian) keyboards */
#define DIK_CONVERT         0x79    /* (Japanese keyboard)            */
#define DIK_NOCONVERT       0x7B    /* (Japanese keyboard)            */
#define DIK_YEN             0x7D    /* (Japanese keyboard)            */
#define DIK_ABNT_C2         0x7E    /* Numpad . on Portugese (Brazilian) keyboards */
#define DIK_NUMPADEQUALS    0x8D    /* = on numeric keypad (NEC PC98) */
#define DIK_PREVTRACK       0x90    /* Previous Track (DIK_CIRCUMFLEX on Japanese keyboard) */
#define DIK_AT              0x91    /*                     (NEC PC98) */
#define DIK_COLON           0x92    /*                     (NEC PC98) */
#define DIK_UNDERLINE       0x93    /*                     (NEC PC98) */
#define DIK_KANJI           0x94    /* (Japanese keyboard)            */
#define DIK_STOP            0x95    /*                     (NEC PC98) */
#define DIK_AX              0x96    /*                     (Japan AX) */
#define DIK_UNLABELED       0x97    /*                        (J3100) */
#define DIK_NEXTTRACK       0x99    /* Next Track */
#define DIK_NUMPADENTER     0x9C    /* Enter on numeric keypad */
#define DIK_RCONTROL        0x9D
#define DIK_MUTE            0xA0    /* Mute */
#define DIK_CALCULATOR      0xA1    /* Calculator */
#define DIK_PLAYPAUSE       0xA2    /* Play / Pause */
#define DIK_MEDIASTOP       0xA4    /* Media Stop */
#define DIK_VOLUMEDOWN      0xAE    /* Volume - */
#define DIK_VOLUMEUP        0xB0    /* Volume + */
#define DIK_WEBHOME         0xB2    /* Web home */
#define DIK_NUMPADCOMMA     0xB3    /* , on numeric keypad (NEC PC98) */
#define DIK_DIVIDE          0xB5    /* / on numeric keypad */
#define DIK_SYSRQ           0xB7
#define DIK_RMENU           0xB8    /* right Alt */
#define DIK_PAUSE           0xC5    /* Pause */
#define DIK_HOME            0xC7    /* Home on arrow keypad */
#define DIK_UP              0xC8    /* UpArrow on arrow keypad */
#define DIK_PRIOR           0xC9    /* PgUp on arrow keypad */
#define DIK_LEFT            0xCB    /* LeftArrow on arrow keypad */
#define DIK_RIGHT           0xCD    /* RightArrow on arrow keypad */
#define DIK_END             0xCF    /* End on arrow keypad */
#define DIK_DOWN            0xD0    /* DownArrow on arrow keypad */
#define DIK_NEXT            0xD1    /* PgDn on arrow keypad */
#define DIK_INSERT          0xD2    /* Insert on arrow keypad */
#define DIK_DELETE          0xD3    /* Delete on arrow keypad */
#define DIK_LWIN            0xDB    /* Left Windows key */
#define DIK_RWIN            0xDC    /* Right Windows key */
#define DIK_APPS            0xDD    /* AppMenu key */
#define DIK_POWER           0xDE    /* System Power */
#define DIK_SLEEP           0xDF    /* System Sleep */
#define DIK_WAKE            0xE3    /* System Wake */
#define DIK_WEBSEARCH       0xE5    /* Web Search */
#define DIK_WEBFAVORITES    0xE6    /* Web Favorites */
#define DIK_WEBREFRESH      0xE7    /* Web Refresh */
#define DIK_WEBSTOP         0xE8    /* Web Stop */
#define DIK_WEBFORWARD      0xE9    /* Web Forward */
#define DIK_WEBBACK         0xEA    /* Web Back */
#define DIK_MYCOMPUTER      0xEB    /* My Computer */
#define DIK_MAIL            0xEC    /* Mail */
#define DIK_MEDIASELECT     0xED    /* Media Select */

/*
 *  Alternate names for keys, to facilitate transition from DOS.
 */
#define DIK_BACKSPACE       DIK_BACK            /* backspace */
#define DIK_NUMPADSTAR      DIK_MULTIPLY        /* * on numeric keypad */
#define DIK_LALT            DIK_LMENU           /* left Alt */
#define DIK_CAPSLOCK        DIK_CAPITAL         /* CapsLock */
#define DIK_NUMPADMINUS     DIK_SUBTRACT        /* - on numeric keypad */
#define DIK_NUMPADPLUS      DIK_ADD             /* + on numeric keypad */
#define DIK_NUMPADPERIOD    DIK_DECIMAL         /* . on numeric keypad */
#define DIK_NUMPADSLASH     DIK_DIVIDE          /* / on numeric keypad */
#define DIK_RALT            DIK_RMENU           /* right Alt */
#define DIK_UPARROW         DIK_UP              /* UpArrow on arrow keypad */
#define DIK_PGUP            DIK_PRIOR           /* PgUp on arrow keypad */
#define DIK_LEFTARROW       DIK_LEFT            /* LeftArrow on arrow keypad */
#define DIK_RIGHTARROW      DIK_RIGHT           /* RightArrow on arrow keypad */
#define DIK_DOWNARROW       DIK_DOWN            /* DownArrow on arrow keypad */
#define DIK_PGDN            DIK_NEXT            /* PgDn on arrow keypad */

/*
 *  Alternate names for keys originally not used on US keyboards.
 */
#define DIK_CIRCUMFLEX      DIK_PREVTRACK       /* Japanese keyboard */

#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *      Joystick
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

typedef struct DIJOYSTATE {
    LONG    lX;                     /* x-axis position              */
    LONG    lY;                     /* y-axis position              */
    LONG    lZ;                     /* z-axis position              */
    LONG    lRx;                    /* x-axis rotation              */
    LONG    lRy;                    /* y-axis rotation              */
    LONG    lRz;                    /* z-axis rotation              */
    LONG    rglSlider[2];           /* extra axes positions         */
    DWORD   rgdwPOV[4];             /* POV directions               */
    BYTE    rgbButtons[32];         /* 32 buttons                   */
} DIJOYSTATE, *LPDIJOYSTATE;

typedef struct DIJOYSTATE2 {
    LONG    lX;                     /* x-axis position              */
    LONG    lY;                     /* y-axis position              */
    LONG    lZ;                     /* z-axis position              */
    LONG    lRx;                    /* x-axis rotation              */
    LONG    lRy;                    /* y-axis rotation              */
    LONG    lRz;                    /* z-axis rotation              */
    LONG    rglSlider[2];           /* extra axes positions         */
    DWORD   rgdwPOV[4];             /* POV directions               */
    BYTE    rgbButtons[128];        /* 128 buttons                  */
    LONG    lVX;                    /* x-axis velocity              */
    LONG    lVY;                    /* y-axis velocity              */
    LONG    lVZ;                    /* z-axis velocity              */
    LONG    lVRx;                   /* x-axis angular velocity      */
    LONG    lVRy;                   /* y-axis angular velocity      */
    LONG    lVRz;                   /* z-axis angular velocity      */
    LONG    rglVSlider[2];          /* extra axes velocities        */
    LONG    lAX;                    /* x-axis acceleration          */
    LONG    lAY;                    /* y-axis acceleration          */
    LONG    lAZ;                    /* z-axis acceleration          */
    LONG    lARx;                   /* x-axis angular acceleration  */
    LONG    lARy;                   /* y-axis angular acceleration  */
    LONG    lARz;                   /* z-axis angular acceleration  */
    LONG    rglASlider[2];          /* extra axes accelerations     */
    LONG    lFX;                    /* x-axis force                 */
    LONG    lFY;                    /* y-axis force                 */
    LONG    lFZ;                    /* z-axis force                 */
    LONG    lFRx;                   /* x-axis torque                */
    LONG    lFRy;                   /* y-axis torque                */
    LONG    lFRz;                   /* z-axis torque                */
    LONG    rglFSlider[2];          /* extra axes forces            */
} DIJOYSTATE2, *LPDIJOYSTATE2;

#define DIJOFS_X            FIELD_OFFSET(DIJOYSTATE, lX)
#define DIJOFS_Y            FIELD_OFFSET(DIJOYSTATE, lY)
#define DIJOFS_Z            FIELD_OFFSET(DIJOYSTATE, lZ)
#define DIJOFS_RX           FIELD_OFFSET(DIJOYSTATE, lRx)
#define DIJOFS_RY           FIELD_OFFSET(DIJOYSTATE, lRy)
#define DIJOFS_RZ           FIELD_OFFSET(DIJOYSTATE, lRz)
#define DIJOFS_SLIDER(n)   (FIELD_OFFSET(DIJOYSTATE, rglSlider) + \
                                                        (n) * sizeof(LONG))
#define DIJOFS_POV(n)      (FIELD_OFFSET(DIJOYSTATE, rgdwPOV) + \
                                                        (n) * sizeof(DWORD))
#define DIJOFS_BUTTON(n)   (FIELD_OFFSET(DIJOYSTATE, rgbButtons) + (n))
#define DIJOFS_BUTTON0      DIJOFS_BUTTON(0)
#define DIJOFS_BUTTON1      DIJOFS_BUTTON(1)
#define DIJOFS_BUTTON2      DIJOFS_BUTTON(2)
#define DIJOFS_BUTTON3      DIJOFS_BUTTON(3)
#define DIJOFS_BUTTON4      DIJOFS_BUTTON(4)
#define DIJOFS_BUTTON5      DIJOFS_BUTTON(5)
#define DIJOFS_BUTTON6      DIJOFS_BUTTON(6)
#define DIJOFS_BUTTON7      DIJOFS_BUTTON(7)
#define DIJOFS_BUTTON8      DIJOFS_BUTTON(8)
#define DIJOFS_BUTTON9      DIJOFS_BUTTON(9)
#define DIJOFS_BUTTON10     DIJOFS_BUTTON(10)
#define DIJOFS_BUTTON11     DIJOFS_BUTTON(11)
#define DIJOFS_BUTTON12     DIJOFS_BUTTON(12)
#define DIJOFS_BUTTON13     DIJOFS_BUTTON(13)
#define DIJOFS_BUTTON14     DIJOFS_BUTTON(14)
#define DIJOFS_BUTTON15     DIJOFS_BUTTON(15)
#define DIJOFS_BUTTON16     DIJOFS_BUTTON(16)
#define DIJOFS_BUTTON17     DIJOFS_BUTTON(17)
#define DIJOFS_BUTTON18     DIJOFS_BUTTON(18)
#define DIJOFS_BUTTON19     DIJOFS_BUTTON(19)
#define DIJOFS_BUTTON20     DIJOFS_BUTTON(20)
#define DIJOFS_BUTTON21     DIJOFS_BUTTON(21)
#define DIJOFS_BUTTON22     DIJOFS_BUTTON(22)
#define DIJOFS_BUTTON23     DIJOFS_BUTTON(23)
#define DIJOFS_BUTTON24     DIJOFS_BUTTON(24)
#define DIJOFS_BUTTON25     DIJOFS_BUTTON(25)
#define DIJOFS_BUTTON26     DIJOFS_BUTTON(26)
#define DIJOFS_BUTTON27     DIJOFS_BUTTON(27)
#define DIJOFS_BUTTON28     DIJOFS_BUTTON(28)
#define DIJOFS_BUTTON29     DIJOFS_BUTTON(29)
#define DIJOFS_BUTTON30     DIJOFS_BUTTON(30)
#define DIJOFS_BUTTON31     DIJOFS_BUTTON(31)


#endif /* DIJ_RINGZERO */

/****************************************************************************
 *
 *  IDirectInput
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#define DIENUM_STOP             0
#define DIENUM_CONTINUE         1

typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKA)(LPCDIDEVICEINSTANCEA, LPVOID);
typedef BOOL (FAR PASCAL * LPDIENUMDEVICESCALLBACKW)(LPCDIDEVICEINSTANCEW, LPVOID);
#ifdef UNICODE
#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKW
#else
#define LPDIENUMDEVICESCALLBACK  LPDIENUMDEVICESCALLBACKA
#endif // !UNICODE

#define DIEDFL_ALLDEVICES       0x00000000
#define DIEDFL_ATTACHEDONLY     0x00000001
#if(DIRECTINPUT_VERSION >= 0x0500)
#define DIEDFL_FORCEFEEDBACK    0x00000100
#endif /* DIRECTINPUT_VERSION >= 0x0500 */
#if(DIRECTINPUT_VERSION >= 0x050a)
#define DIEDFL_INCLUDEALIASES   0x00010000
#define DIEDFL_INCLUDEPHANTOMS  0x00020000
#endif /* DIRECTINPUT_VERSION >= 0x050a */

#undef INTERFACE
#define INTERFACE IDirectInputW

DECLARE_INTERFACE_(IDirectInputW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputW methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
};

typedef struct IDirectInputW *LPDIRECTINPUTW;

#undef INTERFACE
#define INTERFACE IDirectInputA

DECLARE_INTERFACE_(IDirectInputA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputA methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
};

typedef struct IDirectInputA *LPDIRECTINPUTA;

#ifdef UNICODE
#define IID_IDirectInput IID_IDirectInputW
#define IDirectInput IDirectInputW
#define IDirectInputVtbl IDirectInputWVtbl
#else
#define IID_IDirectInput IID_IDirectInputA
#define IDirectInput IDirectInputA
#define IDirectInputVtbl IDirectInputAVtbl
#endif
typedef struct IDirectInput *LPDIRECTINPUT;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#else
#define IDirectInput_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput_AddRef(p) (p)->AddRef()
#define IDirectInput_Release(p) (p)->Release()
#define IDirectInput_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput_Initialize(p,a,b) (p)->Initialize(a,b)
#endif

#undef INTERFACE
#define INTERFACE IDirectInput2W

DECLARE_INTERFACE_(IDirectInput2W, IDirectInputW)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputW methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;

    /*** IDirectInput2W methods ***/
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;
};

typedef struct IDirectInput2W *LPDIRECTINPUT2W;

#undef INTERFACE
#define INTERFACE IDirectInput2A

DECLARE_INTERFACE_(IDirectInput2A, IDirectInputA)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInputA methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;

    /*** IDirectInput2A methods ***/
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;
};

typedef struct IDirectInput2A *LPDIRECTINPUT2A;

#ifdef UNICODE
#define IID_IDirectInput2 IID_IDirectInput2W
#define IDirectInput2 IDirectInput2W
#define IDirectInput2Vtbl IDirectInput2WVtbl
#else
#define IID_IDirectInput2 IID_IDirectInput2A
#define IDirectInput2 IDirectInput2A
#define IDirectInput2Vtbl IDirectInput2AVtbl
#endif
typedef struct IDirectInput2 *LPDIRECTINPUT2;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput2_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput2_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput2_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput2_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput2_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput2_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput2_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput2_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#else
#define IDirectInput2_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput2_AddRef(p) (p)->AddRef()
#define IDirectInput2_Release(p) (p)->Release()
#define IDirectInput2_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput2_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput2_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput2_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput2_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput2_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#endif


#undef INTERFACE
#define INTERFACE IDirectInput7W

DECLARE_INTERFACE_(IDirectInput7W, IDirectInput2W)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput2W methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEW *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKW,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCWSTR,LPGUID) PURE;

    /*** IDirectInput7W methods ***/
    STDMETHOD(CreateDeviceEx)(THIS_ REFGUID,REFIID,LPVOID *,LPUNKNOWN) PURE;
};

typedef struct IDirectInput7W *LPDIRECTINPUT7W;

#undef INTERFACE
#define INTERFACE IDirectInput7A

DECLARE_INTERFACE_(IDirectInput7A, IDirectInput2A)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectInput2A methods ***/
    STDMETHOD(CreateDevice)(THIS_ REFGUID,LPDIRECTINPUTDEVICEA *,LPUNKNOWN) PURE;
    STDMETHOD(EnumDevices)(THIS_ DWORD,LPDIENUMDEVICESCALLBACKA,LPVOID,DWORD) PURE;
    STDMETHOD(GetDeviceStatus)(THIS_ REFGUID) PURE;
    STDMETHOD(RunControlPanel)(THIS_ HWND,DWORD) PURE;
    STDMETHOD(Initialize)(THIS_ HINSTANCE,DWORD) PURE;
    STDMETHOD(FindDevice)(THIS_ REFGUID,LPCSTR,LPGUID) PURE;

    /*** IDirectInput7A methods ***/
    STDMETHOD(CreateDeviceEx)(THIS_ REFGUID,REFIID,LPVOID *,LPUNKNOWN) PURE;
};

typedef struct IDirectInput7A *LPDIRECTINPUT7A;

#ifdef UNICODE
#define IID_IDirectInput7 IID_IDirectInput7W
#define IDirectInput7 IDirectInput7W
#define IDirectInput7Vtbl IDirectInput7WVtbl
#else
#define IID_IDirectInput7 IID_IDirectInput7A
#define IDirectInput7 IDirectInput7A
#define IDirectInput7Vtbl IDirectInput7AVtbl
#endif
typedef struct IDirectInput7 *LPDIRECTINPUT7;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectInput7_QueryInterface(p,a,b) (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectInput7_AddRef(p) (p)->lpVtbl->AddRef(p)
#define IDirectInput7_Release(p) (p)->lpVtbl->Release(p)
#define IDirectInput7_CreateDevice(p,a,b,c) (p)->lpVtbl->CreateDevice(p,a,b,c)
#define IDirectInput7_EnumDevices(p,a,b,c,d) (p)->lpVtbl->EnumDevices(p,a,b,c,d)
#define IDirectInput7_GetDeviceStatus(p,a) (p)->lpVtbl->GetDeviceStatus(p,a)
#define IDirectInput7_RunControlPanel(p,a,b) (p)->lpVtbl->RunControlPanel(p,a,b)
#define IDirectInput7_Initialize(p,a,b) (p)->lpVtbl->Initialize(p,a,b)
#define IDirectInput7_FindDevice(p,a,b,c) (p)->lpVtbl->FindDevice(p,a,b,c)
#define IDirectInput7_CreateDeviceEx(p,a,b,c,d) (p)->lpVtbl->CreateDeviceEx(p,a,b,c,d)
#else
#define IDirectInput7_QueryInterface(p,a,b) (p)->QueryInterface(a,b)
#define IDirectInput7_AddRef(p) (p)->AddRef()
#define IDirectInput7_Release(p) (p)->Release()
#define IDirectInput7_CreateDevice(p,a,b,c) (p)->CreateDevice(a,b,c)
#define IDirectInput7_EnumDevices(p,a,b,c,d) (p)->EnumDevices(a,b,c,d)
#define IDirectInput7_GetDeviceStatus(p,a) (p)->GetDeviceStatus(a)
#define IDirectInput7_RunControlPanel(p,a,b) (p)->RunControlPanel(a,b)
#define IDirectInput7_Initialize(p,a,b) (p)->Initialize(a,b)
#define IDirectInput7_FindDevice(p,a,b,c) (p)->FindDevice(a,b,c)
#define IDirectInput7_CreateDeviceEx(p,a,b,c,d) (p)->CreateDeviceEx(a,b,c,d)
#endif

extern HRESULT WINAPI DirectInputCreateA(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *ppDI, LPUNKNOWN punkOuter);
extern HRESULT WINAPI DirectInputCreateW(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *ppDI, LPUNKNOWN punkOuter);
#ifdef UNICODE
#define DirectInputCreate  DirectInputCreateW
#else
#define DirectInputCreate  DirectInputCreateA
#endif // !UNICODE

extern HRESULT WINAPI DirectInputCreateEx(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
#endif /* DIJ_RINGZERO */


/****************************************************************************
 *
 *  Return Codes
 *
 ****************************************************************************/

/*
 *  The operation completed successfully.
 */
#define DI_OK                           S_OK

/*
 *  The device exists but is not currently attached.
 */
#define DI_NOTATTACHED                  S_FALSE

/*
 *  The device buffer overflowed.  Some input was lost.
 */
#define DI_BUFFEROVERFLOW               S_FALSE

/*
 *  The change in device properties had no effect.
 */
#define DI_PROPNOEFFECT                 S_FALSE

/*
 *  The operation had no effect.
 */
#define DI_NOEFFECT                     S_FALSE

/*
 *  The device is a polled device.  As a result, device buffering
 *  will not collect any data and event notifications will not be
 *  signalled until GetDeviceState is called.
 */
#define DI_POLLEDDEVICE                 ((HRESULT)0x00000002L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but the effect was not
 *  downloaded because the device is not exclusively acquired
 *  or because the DIEP_NODOWNLOAD flag was passed.
 */
#define DI_DOWNLOADSKIPPED              ((HRESULT)0x00000003L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but in order to change
 *  the parameters, the effect needed to be restarted.
 */
#define DI_EFFECTRESTARTED              ((HRESULT)0x00000004L)

/*
 *  The parameters of the effect were successfully updated by
 *  IDirectInputEffect::SetParameters, but some of them were
 *  beyond the capabilities of the device and were truncated.
 */
#define DI_TRUNCATED                    ((HRESULT)0x00000008L)

/*
 *  Equal to DI_EFFECTRESTARTED | DI_TRUNCATED.
 */
#define DI_TRUNCATEDANDRESTARTED        ((HRESULT)0x0000000CL)

/*
 *  The application requires a newer version of DirectInput.
 */
#define DIERR_OLDDIRECTINPUTVERSION     \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_OLD_WIN_VERSION)

/*
 *  The application was written for an unsupported prerelease version
 *  of DirectInput.
 */
#define DIERR_BETADIRECTINPUTVERSION    \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_RMODE_APP)

/*
 *  The object could not be created due to an incompatible driver version
 *  or mismatched or incomplete driver components.
 */
#define DIERR_BADDRIVERVER              \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BAD_DRIVER_LEVEL)

/*
 * The device or device instance or effect is not registered with DirectInput.
 */
#define DIERR_DEVICENOTREG              REGDB_E_CLASSNOTREG

/*
 * The requested object does not exist.
 */
#define DIERR_NOTFOUND                  \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)

/*
 * The requested object does not exist.
 */
#define DIERR_OBJECTNOTFOUND            \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)

/*
 * An invalid parameter was passed to the returning function,
 * or the object was not in a state that admitted the function
 * to be called.
 */
#define DIERR_INVALIDPARAM              E_INVALIDARG

/*
 * The specified interface is not supported by the object
 */
#define DIERR_NOINTERFACE               E_NOINTERFACE

/*
 * An undetermined error occured inside the DInput subsystem
 */
#define DIERR_GENERIC                   E_FAIL

/*
 * The DInput subsystem couldn't allocate sufficient memory to complete the
 * caller's request.
 */
#define DIERR_OUTOFMEMORY               E_OUTOFMEMORY

/*
 * The function called is not supported at this time
 */
#define DIERR_UNSUPPORTED               E_NOTIMPL

/*
 * This object has not been initialized
 */
#define DIERR_NOTINITIALIZED            \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_NOT_READY)

/*
 * This object is already initialized
 */
#define DIERR_ALREADYINITIALIZED        \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_ALREADY_INITIALIZED)

/*
 * This object does not support aggregation
 */
#define DIERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

/*
 * Another app has a higher priority level, preventing this call from
 * succeeding.
 */
#define DIERR_OTHERAPPHASPRIO           E_ACCESSDENIED

/*
 * Access to the device has been lost.  It must be re-acquired.
 */
#define DIERR_INPUTLOST                 \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_READ_FAULT)

/*
 * The operation cannot be performed while the device is acquired.
 */
#define DIERR_ACQUIRED                  \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_BUSY)

/*
 * The operation cannot be performed unless the device is acquired.
 */
#define DIERR_NOTACQUIRED               \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ERROR_INVALID_ACCESS)

/*
 * The specified property cannot be changed.
 */
#define DIERR_READONLY                  E_ACCESSDENIED

/*
 * The device already has an event notification associated with it.
 */
#define DIERR_HANDLEEXISTS              E_ACCESSDENIED

/*
 * Data is not yet available.
 */
#ifndef E_PENDING
#define E_PENDING                       0x8000000AL
#endif

/*
 * Unable to IDirectInputJoyConfig_Acquire because the user
 * does not have sufficient privileges to change the joystick
 * configuration.
 */
#define DIERR_INSUFFICIENTPRIVS         0x80040200L

/*
 * The device is full.
 */
#define DIERR_DEVICEFULL                0x80040201L

/*
 * Not all the requested information fit into the buffer.
 */
#define DIERR_MOREDATA                  0x80040202L

/*
 * The effect is not downloaded.
 */
#define DIERR_NOTDOWNLOADED             0x80040203L

/*
 *  The device cannot be reinitialized because there are still effects
 *  attached to it.
 */
#define DIERR_HASEFFECTS                0x80040204L

/*
 *  The operation cannot be performed unless the device is acquired
 *  in DISCL_EXCLUSIVE mode.
 */
#define DIERR_NOTEXCLUSIVEACQUIRED      0x80040205L

/*
 *  The effect could not be downloaded because essential information
 *  is missing.  For example, no axes have been associated with the
 *  effect, or no type-specific information has been created.
 */
#define DIERR_INCOMPLETEEFFECT          0x80040206L

/*
 *  Attempted to read buffered device data from a device that is
 *  not buffered.
 */
#define DIERR_NOTBUFFERED               0x80040207L

/*
 *  An attempt was made to modify parameters of an effect while it is
 *  playing.  Not all hardware devices support altering the parameters
 *  of an effect while it is playing.
 */
#define DIERR_EFFECTPLAYING             0x80040208L

/*
 *  The operation could not be completed because the device is not
 *  plugged in.
 */
#define DIERR_UNPLUGGED                 0x80040209L

/*
 *  SendDeviceData failed because more information was requested
 *  to be sent than can be sent to the device.  Some devices have
 *  restrictions on how much data can be sent to them.  (For example,
 *  there might be a limit on the number of buttons that can be
 *  pressed at once.)
 */
#define DIERR_REPORTFULL                0x8004020AL

#ifdef __cplusplus
};
#endif

#endif  /* __DINPUT_INCLUDED__ */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current sdk files
 *
 ****************************************************************************/

#ifdef _INC_MMSYSTEM
#ifndef MMNOJOY

#ifndef __VJOYDX_INCLUDED__
#define __VJOYDX_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Flag to indicate that the dwReserved2 field of the JOYINFOEX structure
 * contains mini-driver specific data to be passed by VJoyD to the mini-
 * driver instead of doing a poll.
 */
#define JOY_PASSDRIVERDATA          0x10000000l

/*
 * Informs the joystick driver that the configuration has been changed
 * and should be reloaded from the registery.
 * dwFlags is reserved and should be set to zero
 */
WINMMAPI MMRESULT WINAPI joyConfigChanged( DWORD dwFlags );


/*
 * Hardware Setting indicating that the device is a headtracker
 */
#define JOY_HWS_ISHEADTRACKER       0x02000000l

/*
 * Hardware Setting indicating that the VxD is used to replace
 * the standard analog polling
 */
#define JOY_HWS_ISGAMEPORTDRIVER    0x04000000l

/*
 * Hardware Setting indicating that the driver needs a standard
 * gameport in order to communicate with the device.
 */
#define JOY_HWS_ISANALOGPORTDRIVER  0x08000000l

/*
 * Hardware Setting indicating that VJoyD should not load this
 * driver, it will be loaded externally and will register with
 * VJoyD of it's own accord.
 */
#define JOY_HWS_AUTOLOAD            0x10000000l

/*
 * Hardware Setting indicating that the driver acquires any
 * resources needed without needing a devnode through VJoyD.
 */
#define JOY_HWS_NODEVNODE           0x20000000l


/*
 * Hardware Setting indicating that the device is a gameport bus
 */
#define JOY_HWS_ISGAMEPORTBUS       0x80000000l
#define JOY_HWS_GAMEPORTBUSBUSY     0x00000001l

/*
 * Usage Setting indicating that the settings are volatile and
 * should be removed if still present on a reboot.
 */
#define JOY_US_VOLATILE             0x00000008L

#ifdef __cplusplus
};
#endif

#endif  /* __VJOYDX_INCLUDED__ */

#endif  /* not MMNOJOY */
#endif  /* _INC_MMSYSTEM */

/****************************************************************************
 *
 *  Definitions for non-IDirectInput (VJoyD) features defined more recently
 *  than the current ddk files
 *
 ****************************************************************************/

#ifndef DIJ_RINGZERO

#ifdef _INC_MMDDK
#ifndef MMNOJOYDEV

#ifndef __VJOYDXD_INCLUDED__
#define __VJOYDXD_INCLUDED__
/*
 * Poll type in which the do_other field of the JOYOEMPOLLDATA
 * structure contains mini-driver specific data passed from an app.
 */
#define JOY_OEMPOLL_PASSDRIVERDATA  7

#endif  /* __VJOYDXD_INCLUDED__ */

#endif  /* not MMNOJOYDEV */
#endif  /* _INC_MMDDK */

#endif /* DIJ_RINGZERO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\inc\dmdls.h ===
/************************************************************************
*                                                                       *
*   dmdls.h -- DLS download definitions for DirectMusic API's           *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef _DMDLS_
#define _DMDLS_

#include "dls1.h"

typedef long PCENT;     /* Pitch cents */
typedef long GCENT;     /* Gain cents */
typedef long TCENT;     /* Time cents */
typedef long PERCENT;   /* Per.. cent! */

typedef LONGLONG REFERENCE_TIME;
typedef REFERENCE_TIME *LPREFERENCE_TIME;

#ifndef MAKE_FOURCC
#define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))


typedef DWORD           FOURCC;         /* a four character code */
#endif

typedef struct _DMUS_DOWNLOADINFO
{
    DWORD dwDLType;                     /* Instrument or Wave */
    DWORD dwDLId;                       /* Unique identifier to tag this download. */
    DWORD dwNumOffsetTableEntries;      /* Number of index in the offset address table. */
    DWORD cbSize;                       /* Total size of this memory chunk. */
} DMUS_DOWNLOADINFO;

#define DMUS_DOWNLOADINFO_INSTRUMENT    1
#define DMUS_DOWNLOADINFO_WAVE          2
#define DMUS_DOWNLOADINFO_INSTRUMENT2   3   /* New version for better DLS2 support. */

#define DMUS_DEFAULT_SIZE_OFFSETTABLE   1

/* Flags for DMUS_INSTRUMENT's ulFlags member */
 
#define DMUS_INSTRUMENT_GM_INSTRUMENT   (1 << 0)

typedef struct _DMUS_OFFSETTABLE
{
    ULONG ulOffsetTable[DMUS_DEFAULT_SIZE_OFFSETTABLE];
} DMUS_OFFSETTABLE;

typedef struct _DMUS_INSTRUMENT
{
    ULONG           ulPatch;
    ULONG           ulFirstRegionIdx;             
    ULONG           ulGlobalArtIdx;         /* If zero the instrument does not have an articulation */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the instrument */
    ULONG           ulCopyrightIdx;         /* If zero no Copyright information associated with the instrument */
    ULONG           ulFlags;                        
} DMUS_INSTRUMENT;

typedef struct _DMUS_REGION
{
    RGNRANGE        RangeKey;
    RGNRANGE        RangeVelocity;
    USHORT          fusOptions;
    USHORT          usKeyGroup;
    ULONG           ulRegionArtIdx;         /* If zero the region does not have an articulation */
    ULONG           ulNextRegionIdx;        /* If zero no more regions */
    ULONG           ulFirstExtCkIdx;        /* If zero no 3rd party entenstion chunks associated with the region */
    WAVELINK        WaveLink;
    WSMPL           WSMP;                   /*  If WSMP.cSampleLoops > 1 then a WLOOP is included */
    WLOOP           WLOOP[1];
} DMUS_REGION;

typedef struct _DMUS_LFOPARAMS
{
    PCENT       pcFrequency;
    TCENT       tcDelay;
    GCENT       gcVolumeScale;
    PCENT       pcPitchScale;
    GCENT       gcMWToVolume;
    PCENT       pcMWToPitch;
} DMUS_LFOPARAMS;

typedef struct _DMUS_VEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
} DMUS_VEGPARAMS;

typedef struct _DMUS_PEGPARAMS
{
    TCENT       tcAttack;
    TCENT       tcDecay;
    PERCENT     ptSustain;
    TCENT       tcRelease;
    TCENT       tcVel2Attack;
    TCENT       tcKey2Decay;
    PCENT       pcRange;
} DMUS_PEGPARAMS;

typedef struct _DMUS_MSCPARAMS
{
    PERCENT     ptDefaultPan;
} DMUS_MSCPARAMS;

typedef struct _DMUS_ARTICPARAMS
{
    DMUS_LFOPARAMS   LFO;
    DMUS_VEGPARAMS   VolEG;
    DMUS_PEGPARAMS   PitchEG;
    DMUS_MSCPARAMS   Misc;
} DMUS_ARTICPARAMS;

typedef struct _DMUS_ARTICULATION           /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT format. */
{
    ULONG           ulArt1Idx;              /* DLS Level 1 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
} DMUS_ARTICULATION;

typedef struct _DMUS_ARTICULATION2          /* Articulation chunk for DMUS_DOWNLOADINFO_INSTRUMENT2 format. */
{
    ULONG           ulArtIdx;               /* DLS Level 1/2 articulation chunk */
    ULONG           ulFirstExtCkIdx;        /* 3rd party extenstion chunks associated with the articulation */
    ULONG           ulNextArtIdx;           /* Additional articulation chunks */
} DMUS_ARTICULATION2;

#define DMUS_MIN_DATA_SIZE 4       
/*  The actual number is determined by cbSize of struct _DMUS_EXTENSIONCHUNK */

typedef struct _DMUS_EXTENSIONCHUNK
{
    ULONG           cbSize;                      /*  Size of extension chunk  */
    ULONG           ulNextExtCkIdx;              /*  If zero no more 3rd party entenstion chunks */
    FOURCC          ExtCkID;                                      
    BYTE            byExtCk[DMUS_MIN_DATA_SIZE]; /*  The actual number that follows is determined by cbSize */
} DMUS_EXTENSIONCHUNK;

/*  The actual number is determined by cbSize of struct _DMUS_COPYRIGHT */

typedef struct _DMUS_COPYRIGHT
{
    ULONG           cbSize;                             /*  Size of copyright information */
    BYTE            byCopyright[DMUS_MIN_DATA_SIZE];    /*  The actual number that follows is determined by cbSize */
} DMUS_COPYRIGHT;

typedef struct _DMUS_WAVEDATA
{
    ULONG           cbSize;
    BYTE            byData[DMUS_MIN_DATA_SIZE]; 
} DMUS_WAVEDATA;

typedef struct _DMUS_WAVE
{
    ULONG           ulFirstExtCkIdx;    /* If zero no 3rd party entenstion chunks associated with the wave */
    ULONG           ulCopyrightIdx;     /* If zero no Copyright information associated with the wave */
    ULONG           ulWaveDataIdx;      /* Location of actual wave data. */
    WAVEFORMATEX    WaveformatEx;       
} DMUS_WAVE;

typedef struct _DMUS_NOTERANGE *LPDMUS_NOTERANGE;
typedef struct _DMUS_NOTERANGE
{
    DWORD           dwLowNote;  /* Sets the low note for the range of MIDI note events to which the instrument responds.*/
    DWORD           dwHighNote; /* Sets the high note for the range of MIDI note events to which the instrument responds.*/
} DMUS_NOTERANGE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\wave.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       wave.cpp
//
//--------------------------------------------------------------------------

#define DIRECTSOUND_VERSION 0x600

#include "stdafx.h"
#include "Direct.h"
#include "dSound.h"
#include "dms.h"
#include <mmreg.h>
#include <msacm.h>


// FOURCC codes
#undef FOURCC_RIFF
#define FOURCC_RIFF         'FFIR'

#undef FOURCC_MEM
#define FOURCC_MEM          ' MEM'

#undef FOURCC_WAVE
#define FOURCC_WAVE         'EVAW'

#undef FOURCC_FORMAT
#define FOURCC_FORMAT       ' tmf'

#undef FOURCC_DATA
#define FOURCC_DATA         'atad'

#define RPF(level,str,err) \
	{ char outBuf[MAX_PATH]; \
	  wsprintf(outBuf,str,err); \
	  OutputDebugString(outBuf); \
	}


#define DPFLVL_ERROR 1



/***************************************************************************
 *
 *  FillWfx
 *
 *  Description:
 *      Fills a WAVEFORMATEX structure, given only the necessary values.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: structure to fill.
 *      WORD [in]: number of channels.
 *      DWORD [in]: samples per second.
 *      WORD [in]: bits per sample.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME

void FillWfx(LPWAVEFORMATEX pwfx, WORD wChannels, DWORD dwSamplesPerSec, WORD wBitsPerSample)
{
    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = min(2, max(1, wChannels));
    pwfx->nSamplesPerSec = min(DSBFREQUENCY_MAX, max(DSBFREQUENCY_MIN, dwSamplesPerSec));
    
    if(wBitsPerSample < 12)
    {
        pwfx->wBitsPerSample = 8;
    }
    else
    {
        pwfx->wBitsPerSample = 16;
    }

    pwfx->nBlockAlign = pwfx->nChannels * pwfx->wBitsPerSample / 8;
    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;
    pwfx->cbSize = 0;
}


#if 0

HRESULT InternalCreateSoundBuffer(LPDSBUFFERDESC pDsbDesc, byte *pbWaveData,DWORD cbWaveData,LPDIRECTSOUND lpDirectSound, LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer)
{

    HRESULT                 hr                  = DS_OK;
    HACMSTREAM              has                 = NULL;
    BOOL                    fPrep               = FALSE;
    ACMSTREAMHEADER         ash;
    DWORD                   dwBufferBytes;
    LPVOID                  pvWrite;
    DWORD                   cbWrite;
    HMMIO                   hmm                 = NULL;
	MMRESULT                mmr;
	MMIOINFO                mmioinfo;
    MMCKINFO                ckiRiff;
    MMCKINFO                cki;
	LPWAVEFORMATEX          pwfxSrcFormat       = NULL;
    LPWAVEFORMATEX          pwfxDestFormat      = NULL;
	BOOL					bNULLFORMAT			= FALSE;    
	


    ZeroMemory(&mmioinfo, sizeof(mmioinfo));

	if(SUCCEEDED(hr)){
		mmioinfo.fccIOProc = FOURCC_MEM;
		mmioinfo.pchBuffer = (HPSTR)pbWaveData;
		mmioinfo.cchBuffer = cbWaveData;
    
		hmm = mmioOpen(NULL, &mmioinfo, MMIO_READ);
		
		if(!hmm)
		{
			DPF1(1, "Unable to open file via MMIO.  Error %lu", mmioinfo.wErrorRet);
			hr = E_FAIL; 
		}
	 }

    // Decend into the RIFF chunk
    if(SUCCEEDED(hr))
    {
        ckiRiff.ckid = FOURCC_RIFF;
        mmr = mmioDescend(hmm, &ckiRiff, NULL, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to descend into RIFF chunk.  Error %lu", mmr);
            hr = E_FAIL; 
        }
    }

    // Verify that this is a wave file
    if(SUCCEEDED(hr) && FOURCC_WAVE != ckiRiff.fccType)
    {
        DPF1(1, "File is not type WAVE %d",GetLastError());
        hr = DSERR_BADFORMAT;
    }

    // Decend into the format chunk
    if(SUCCEEDED(hr))
    {
        cki.ckid = FOURCC_FORMAT;
        mmr = mmioDescend(hmm, &cki, &ckiRiff, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to descend into format chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }

        if(SUCCEEDED(hr))
        {
            pwfxSrcFormat = (LPWAVEFORMATEX)(pbWaveData + cki.dwDataOffset);
        }
    }



    // Ascend out of the format chunk
    if(SUCCEEDED(hr))
    {
        mmr = mmioAscend(hmm, &cki, 0);

        if(MMSYSERR_NOERROR != mmr)
        {
            DPF(1, "Unable to ascend out of format chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
    }

    // Descend into the data chunk
    if(SUCCEEDED(hr))
    {
        cki.ckid = FOURCC_DATA;
        mmr = mmioDescend(hmm, &cki, &ckiRiff, MMIO_FINDCHUNK);

        if(MMSYSERR_NOERROR != mmr)
        {
            RPF(DPFLVL_ERROR, "Unable to descend into data chunk.  Error %lu", mmr);
            hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
    }

    // Prepare PCM conversion
    if(SUCCEEDED(hr))
    {
        if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
        {
            // Populate the buffer description
            dwBufferBytes = cki.cksize;
            pwfxDestFormat = pwfxSrcFormat;
        }
        else
        {
            // Open an ACM conversion stream
            mmr = acmStreamOpen(&has, NULL, (LPWAVEFORMATEX)pwfxSrcFormat, pwfxDestFormat, NULL, 0, 0, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                RPF(DPFLVL_ERROR, "Unable to open an ACM stream.  Error %lu", mmr);
                hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
            }

            // Get the size of the PCM data
            if(SUCCEEDED(hr))
            {
                mmr = acmStreamSize(has, cki.cksize, &dwBufferBytes, ACM_STREAMSIZEF_SOURCE);

                if(MMSYSERR_NOERROR != mmr)
                {
                    RPF(DPFLVL_ERROR, "Unable to determine converted data size.  Error %lu", mmr);
                    hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
                }
            }

            // Create the destination format
            if(SUCCEEDED(hr))
            {
                pwfxDestFormat = (WAVEFORMATEX*)malloc(sizeof(WAVEFORMATEX));
                if (pwfxDestFormat==NULL) hr=E_OUTOFMEMORY;				
            }
        
            if(SUCCEEDED(hr))
            {
                FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
            }
        }
    }

	
	LPDIRECTSOUNDBUFFER lpDirectSoundBuffer=NULL;
	
    if(SUCCEEDED(hr))
    {
		//hr = InitializeEmpty(pDsbDesc->dwFlags, dwBufferBytes, pwfxDestFormat, NULL);
		pDsbDesc->dwBufferBytes=dwBufferBytes;
		
		if (pDsbDesc->lpwfxFormat){
			memcpy(pDsbDesc->lpwfxFormat,pwfxDestFormat,sizeof(WAVEFORMATEX));
		}
		else {
			pDsbDesc->lpwfxFormat=pwfxDestFormat;
		}

		hr=lpDirectSound->CreateSoundBuffer(pDsbDesc,lplpDirectSoundBuffer,NULL);
		if (*lplpDirectSoundBuffer==NULL) hr= E_FAIL;
		lpDirectSoundBuffer=*lplpDirectSoundBuffer;
	}


    

    // Lock the buffer in order to write the PCM data to it
    if(SUCCEEDED(hr))
    {
        hr = lpDirectSoundBuffer->Lock(0, dwBufferBytes, &pvWrite, &cbWrite, NULL, NULL,0);
    }

    // Convert to PCM
    if(SUCCEEDED(hr))
    {
        if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
        {
            CopyMemory(pvWrite, pbWaveData + cki.dwDataOffset, cbWrite);
        }
        else
        {
            // Prepare the conversion header
            ZeroMemory(&ash, sizeof(ash));

            ash.cbStruct = sizeof(ash);
            ash.pbSrc = pbWaveData + cki.dwDataOffset;
            ash.cbSrcLength = cki.cksize;
            ash.pbDst = (LPBYTE)pvWrite;
            ash.cbDstLength = cbWrite;

            mmr = acmStreamPrepareHeader(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                RPF(DPFLVL_ERROR, "Unable to prepare ACM stream header.  Error %lu", mmr);
                hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
            }

            fPrep = SUCCEEDED(hr);

            // Convert the buffer
            if(SUCCEEDED(hr))
            {
                mmr = acmStreamConvert(has, &ash, 0);

                if(MMSYSERR_NOERROR != mmr)
                {
                    RPF(DPFLVL_ERROR, "Unable to convert wave data.  Error %lu", mmr);
                    hr = E_FAIL; //MMRESULTtoHRESULT(mmr);
                }
            }
        }
    }

    // Unlock the buffer
    if(SUCCEEDED(hr))
    {
        hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
    }

    // Clean up
    if(fPrep)
    {
        acmStreamUnprepareHeader(has, &ash, 0);
    }

    if(has)
    {
        acmStreamClose(has, 0);
    }
    
    if(hmm)
    {
        mmioClose(hmm, 0);
    }

    if(pwfxDestFormat != pwfxSrcFormat)
    {
        free(pwfxDestFormat);
    }

    return hr;

}

#endif


















///////////////////////////////////////////////////////////////////////////////////////////
		

HRESULT InternalCreateSoundBuffer(LPDSBUFFERDESC pDsbDesc, byte *pbWaveData, DWORD cbWaveData,LPDIRECTSOUND lpDirectSound, LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer)
{

    HRESULT                 hr                  = DS_OK;
    HACMSTREAM              has                 = NULL;
    BOOL                    fPrep               = FALSE;    
    DWORD                   dwBufferBytes		= 0;
    LPVOID                  pvWrite				= NULL;
    DWORD                   cbWrite				= 0;
	LPWAVEFORMATEX			pwfxFormat			= NULL;
	LPWAVEFORMATEX          pwfxSrcFormat       = NULL;
    LPWAVEFORMATEX          pwfxDestFormat      = NULL;    
	MMRESULT                mmr					= 0;
	DWORD					dwDataLength		= 0;
	DWORD					dwOffset			= 0;
	char					*pChunk				= NULL;
	LPDIRECTSOUNDBUFFER		lpDirectSoundBuffer	= NULL;
	ACMSTREAMHEADER         ash;
	BOOL					bNULLFORMAT			=FALSE;
	BOOL					bDirty				=FALSE;

	
	struct tag_FileHeader
	{
		DWORD       dwRiff;
		DWORD       dwFileSize;
		DWORD       dwWave;
		DWORD       dwFormat;
		DWORD       dwFormatLength;		
	} FileHeader;
	
	ZeroMemory(&FileHeader,sizeof(struct tag_FileHeader));
	
	//	If our file is big enough to have a header copy it over
	//	other wise error out
	if (cbWaveData>sizeof(struct tag_FileHeader)) 
	{
		memcpy(&FileHeader,pbWaveData,sizeof(struct tag_FileHeader));
	}
	else 
	{
		hr= E_INVALIDARG;
	}

	// File must be a riff file ( 52 R, 49 I, 46 F, 46 F)
	if (FileHeader.dwRiff != 0x46464952) 
	{
		DPF(1, "DXVB: not a RIFF file\n");
		return E_INVALIDARG;	
	}

	//  must be a WAVE format ( 57 W, 41 A, 56 V, 45 E )
	if (FileHeader.dwWave != 0x45564157)
	{
		DPF(1, "DXVB: not a WAVE file\n");
		return E_INVALIDARG;	
	}

	//  check for odd stuff
	//  note 18bytes is a typical WAVEFORMATEX
	if (FileHeader.dwFormatLength <= 14) return E_INVALIDARG;
	if (FileHeader.dwFormatLength > 1000) return E_INVALIDARG;

	//allocate the waveformat
	pwfxFormat=(WAVEFORMATEX*)alloca(FileHeader.dwFormatLength);
	if (!pwfxFormat) return E_OUTOFMEMORY;

	//copy it to our own data structure
	pChunk=(char*)(pbWaveData+sizeof (struct tag_FileHeader));
	memcpy(pwfxFormat,pChunk,FileHeader.dwFormatLength);

	
	// Now look for the next chunk after the WaveFormat
	pChunk=(char*)(pChunk+FileHeader.dwFormatLength);
		
	// Look for option FACT chunk and skip it
	//	(66 F, 61 A, 63 C, 74 T)
	// this chunk is required for compressed wave files
	// but is optional for PCM
	//
	if ( ((DWORD*)pChunk)[0]==0x74636166) 
	{
		dwOffset=((DWORD*)pChunk)[1];
		dwBufferBytes=((DWORD*)pChunk)[2];	//number of bytes of PCM data
		pChunk =(char*)(pChunk+ dwOffset+8);	
		
	}

	//Look for required data chunk
	// (64 D, 61 A, 74 T, 61 A)
	if (((DWORD*)pChunk)[0]!=0x61746164) 
	{
				DPF(1, "DXVB: no DATA chunk in wave file\n");
				return E_INVALIDARG;	
	}

	dwDataLength=((DWORD*)pChunk)[1];
	pChunk=(char*)(pChunk+8);
								
	
	//IF we assume PCM 
	//pcm files are not required to have their fact chunk 
	//so be ware they may missreport the data length			
	dwBufferBytes=dwDataLength;	
	pwfxDestFormat=pwfxSrcFormat=pwfxFormat;

	// if we are not PCM then we need to do some things first
	if (pwfxFormat->wFormatTag!=WAVE_FORMAT_PCM)
	{
	

		// source format is from the file 
	
		pwfxSrcFormat=pwfxFormat;				//from file
		pwfxDestFormat=pDsbDesc->lpwfxFormat ;	//from user	
		

		
		//pick the format of the file passed in
		FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
		

		// Open an ACM conversion stream
		mmr = acmStreamOpen(&has, NULL, (LPWAVEFORMATEX)pwfxSrcFormat, pwfxDestFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME );
		if(MMSYSERR_NOERROR != mmr)
		{
			DPF1(1, "Unable to open an ACM stream.  Error %lu\n", mmr);
			return E_FAIL;
		}

	
        // Get the size of the PCM data
        mmr = acmStreamSize(has, dwDataLength, &dwBufferBytes, ACM_STREAMSIZEF_SOURCE);
        if(MMSYSERR_NOERROR != mmr)
        {
            DPF1(1, "Unable to determine converted data size.  Error %lu\n", mmr);
            return E_FAIL; //MMRESULTtoHRESULT(mmr);
        }
   

		// Allocate a DestFormat struct
        //pwfxDestFormat = (WAVEFORMATEX*)alloca(sizeof(WAVEFORMATEX));
        //if (!pwfxDestFormat) return E_OUTOFMEMORY;				
        

		// Fill the format with information from the source but
		// FillWfx sets the format to PCM
        //FillWfx(pwfxDestFormat, pwfxSrcFormat->nChannels, pwfxSrcFormat->nSamplesPerSec, pwfxSrcFormat->wBitsPerSample);
        

    }

	
	// fill the buffer desc the user passed in with the buffer bytes
	// this is the number of PCM bytes
	pDsbDesc->dwBufferBytes=dwBufferBytes;
	
	// if they provide us a pointer to a waveformatex
	// copy over the format to the input desc and use it
	// otherwise have it point to our data format temprarily
	if (pDsbDesc->lpwfxFormat){
			memcpy(pDsbDesc->lpwfxFormat,pwfxDestFormat,sizeof(WAVEFORMATEX));
		}
	else {
		pDsbDesc->lpwfxFormat=pwfxDestFormat;
		//make sure we null out the format before passing it back to the user
		//NOTE: consider the problems in a multithreaded enviroment
		//where the users data structures are being accesed by multiple
		//threads... on the other hand if thats going on..
		//then the user would need to syncronize things on his or her own 
		//for everything else including calling into apis that fill structures..
		bNULLFORMAT=TRUE;		
	}

	// Create the buffer
	hr=lpDirectSound->CreateSoundBuffer(pDsbDesc,lplpDirectSoundBuffer,NULL);
	if FAILED(hr) return hr;
	if (*lplpDirectSoundBuffer==NULL) return E_FAIL;	//todo ASSERT this instead..
	
	// for more convenient referencing...
	lpDirectSoundBuffer=*lplpDirectSoundBuffer;
	
    
    // Lock the buffer in order to write the PCM data to it
	// cbWrite will contain the number of locked bytes
    hr = lpDirectSoundBuffer->Lock(0, dwBufferBytes, &pvWrite, &cbWrite, NULL, NULL,0);
	if FAILED(hr) return hr;


	// If the sorce format was pcm then copy from the file to the buffer
    if(WAVE_FORMAT_PCM == pwfxSrcFormat->wFormatTag)
    {
    	CopyMemory(pvWrite, pChunk, cbWrite);


		// Unlock the buffer
		hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
    
		if (FAILED(hr)) 
		{
			 DPF(1, "DXVB: lpDirectSoundBuffer->Unlock failed.. \n");
			 return hr;
		}

    }

	// if the source format is compressed then convert first then copy
    else
    {
            // Prepare the conversion header
            ZeroMemory(&ash, sizeof(ash));

            ash.cbStruct = sizeof(ash);
            ash.pbSrc = (unsigned char*)pChunk;	//start of compressed data
            ash.cbSrcLength = dwDataLength;		//number of bytes of compressed data
            ash.pbDst = (LPBYTE)pvWrite;		//where to put the decompressed data
            ash.cbDstLength = cbWrite;			//how big is that buffer

            mmr = acmStreamPrepareHeader(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
                DPF1(1, "DXVB: Unable to prepare ACM stream header.  Error %lu \n", mmr);
                return E_FAIL;
            }

            
            mmr = acmStreamConvert(has, &ash, 0);

            if(MMSYSERR_NOERROR != mmr)
            {
				DPF1(1, "DXVB:  Unable to convert wave data.  Error %lu \n", mmr);
                return hr;  
            }

			// Unlock the buffer
			hr = lpDirectSoundBuffer->Unlock(pvWrite, cbWrite, NULL, 0);
			if (FAILED(hr)) 
			{
				DPF(1, "DXVB: lpDirectSoundBuffer->Unlock failed.. \n");
				return hr;
			}

		    acmStreamUnprepareHeader(has, &ash, 0);
	        acmStreamClose(has, 0);
    }
    
	
	if (bNULLFORMAT){
		pDsbDesc->lpwfxFormat=NULL;
	}

    return hr;

}





HRESULT InternalCreateSoundBufferFromFile(LPDIRECTSOUND lpDirectSound,LPDSBUFFERDESC pDesc,WCHAR *file,LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer) 
{
		HRESULT					hr=S_OK;
	    HANDLE                  hFile               = NULL;
	    HANDLE                  hFileMapping        = NULL;
	    DWORD                   cbWaveData;
		LPBYTE                  pbWaveData          = NULL;

		#pragma message("CreateFileW should be used for localization why wont it work")
		//hFile = CreateFileW(file, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);        
		
		USES_CONVERSION;
		LPSTR pStrA=W2T(file);
		
		if (!pStrA) return E_INVALIDARG;
		hFile = CreateFileA(pStrA, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);        
		
        if(INVALID_HANDLE_VALUE == hFile)
        {
            hFile = NULL;
        }

        if(!hFile)
        {
            RPF(DPFLVL_ERROR, "Unable to open file.  Error %lu", GetLastError());
            hr=STG_E_FILENOTFOUND;
			return hr;
        }

        if(hFile)
        {
            cbWaveData = GetFileSize(hFile, NULL);

            if(-1 == cbWaveData)
            {
                RPF(DPFLVL_ERROR, "Unable to get file size.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

        if(SUCCEEDED(hr))
        {
            hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, cbWaveData, NULL);

            if(INVALID_HANDLE_VALUE == hFileMapping)
            {
                hFileMapping = NULL;
            }
            
            if(!hFileMapping)
            {
                RPF(DPFLVL_ERROR, "Unable to create file mapping.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

        if(SUCCEEDED(hr))
        {
            pbWaveData = (LPBYTE)MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, cbWaveData);

            if(!pbWaveData)
            {
                RPF(DPFLVL_ERROR, "Unable to map view of file.  Error %lu", GetLastError());
                hr = E_FAIL; //DSERR_FILEREADFAULT;
            }
        }

		if(SUCCEEDED(hr)) {
			hr=InternalCreateSoundBuffer(pDesc, pbWaveData, cbWaveData,lpDirectSound, lplpDirectSoundBuffer);
		}

	    if(pbWaveData)
        {
            UnmapViewOfFile(pbWaveData);
        }

        if(hFileMapping)
        {
            CloseHandle(hFileMapping);
        }
        
        if(hFile)
        {
            CloseHandle(hFile);
        }
		

		return hr;
    

}

HRESULT InternalCreateSoundBufferFromResource(LPDIRECTSOUND lpDirectSound,LPDSBUFFERDESC pDesc,HANDLE resHandle,WCHAR *resName,LPDIRECTSOUNDBUFFER *lplpDirectSoundBuffer)
{
    const LPCSTR            apszResourceTypeA[] = { "WAVE", "WAV" };
    const LPCWSTR           apszResourceTypeW[] = { L"WAVE", L"WAV" };
    UINT                    cResourceType       = 2;
    HRSRC                   hRsrc               = NULL;
    DWORD                   cbWaveData;
    LPBYTE                  pbWaveData          = NULL;
	HRESULT					hr=S_OK;
	
	LPCDSBUFFERDESC	pDsbDesc=pDesc;

    
	while(!hRsrc && cResourceType--)
    {
        hRsrc = FindResourceW((HINSTANCE)resHandle, resName, apszResourceTypeW[cResourceType]);            
    }

    if(!hRsrc)
    {
		RPF(DPFLVL_ERROR,"Unable to find resource.  Error %lu", GetLastError());
        hr = STG_E_FILENOTFOUND;
    }

    if(SUCCEEDED(hr))
    {
        cbWaveData = SizeofResource((HINSTANCE)resHandle, hRsrc);
        if(!cbWaveData)
        {

            RPF(DPFLVL_ERROR, "Unable to get resource size.  Error %lu", GetLastError());
            hr = E_FAIL;
        }
    }
        
    if(SUCCEEDED(hr))
    {                
        pbWaveData = (LPBYTE)LoadResource((HINSTANCE)resHandle, hRsrc);            
        if(!pbWaveData)
        {
            RPF(DPFLVL_ERROR, "Unable to load resource.  Error %lu", GetLastError());
            hr = E_FAIL;
        }
    }

	if(SUCCEEDED(hr)) {
		hr=InternalCreateSoundBuffer(pDesc, pbWaveData, cbWaveData,lpDirectSound, lplpDirectSoundBuffer);
	}

	//loadResource
   return hr;
}




HRESULT InternalSaveToFile(IDirectSoundBuffer *pBuff,BSTR file)
{
	WAVEFORMATEX waveFormat;
	DWORD dwWritten=0;
	DWORD dwBytes=0;
	LPBYTE lpByte=NULL;
	HRESULT hr;
	HANDLE hFile=NULL;

	if (!pBuff) return E_FAIL;
	if (!file) return E_INVALIDARG;

	
	pBuff->GetFormat(&waveFormat,sizeof(WAVEFORMATEX),NULL);


    

	USES_CONVERSION;
	LPSTR pStrA=W2T(file);

    hFile = CreateFile 
                (
                    pStrA,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                );
	if (INVALID_HANDLE_VALUE != hFile)
    {
			
		struct tag_FileHeader
		{
			DWORD       dwRiff;
			DWORD       dwFileSize;
			DWORD       dwWave;
			DWORD       dwFormat;
			DWORD       dwFormatLength;
			WORD        wFormatTag;
			WORD        nChannels;
			DWORD       nSamplesPerSec;
			DWORD       nAvgBytesPerSec;
			WORD        nBlockAlign;
			WORD        wBitsPerSample;
			DWORD       dwData;
			DWORD       dwDataLength;
		} FileHeader;    

		hr=pBuff->Lock(0,0,(void**)&lpByte,&dwBytes,NULL,NULL,DSBLOCK_ENTIREBUFFER);
		if FAILED(hr) {
			CloseHandle(hFile);
			return hr;
		}

        FileHeader.dwRiff             = 0x46464952;                // RIFF
        FileHeader.dwWave             = 0x45564157;                // WAVE
        FileHeader.dwFormat           = 0x20746D66;                // fmt_chnk
        FileHeader.dwFormatLength     = 16; 
	    FileHeader.wFormatTag         = WAVE_FORMAT_PCM;
	    FileHeader.nChannels          = waveFormat.nChannels ;
	    FileHeader.nSamplesPerSec     = waveFormat.nSamplesPerSec ;
	    FileHeader.wBitsPerSample     = waveFormat.wBitsPerSample ;
	    FileHeader.nBlockAlign        = FileHeader.wBitsPerSample / 8 * FileHeader.nChannels;
	    FileHeader.nAvgBytesPerSec    = FileHeader.nSamplesPerSec * FileHeader.nBlockAlign;
        FileHeader.dwData             = 0x61746164;					// data_chnk
        FileHeader.dwDataLength       = dwBytes;
        FileHeader.dwFileSize         = dwBytes + sizeof(FileHeader);


        WriteFile(hFile, &FileHeader, sizeof(FileHeader), &dwWritten, NULL);
        

        WriteFile(hFile, lpByte, dwBytes, &dwWritten, NULL);

		hr=pBuff->Unlock(lpByte,0,NULL,0); 

        CloseHandle(hFile);
    }
    else{
		return E_FAIL;
	}
    

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\inc\dmerror.h ===
/************************************************************************
*                                                                       *
*   dmerror.h -- Error code returned by DirectMusic API's               *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef _DMERROR_
#define _DMERROR_

#define FACILITY_DIRECTMUSIC      0x878       /* Shared with DirectSound */
#define DMUS_ERRBASE              0x1000      /* Make error codes human readable in hex */

#ifndef MAKE_HRESULT
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif
    
#define MAKE_DMHRESULTSUCCESS(code)     MAKE_HRESULT(0, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))
#define MAKE_DMHRESULTERROR(code)       MAKE_HRESULT(1, FACILITY_DIRECTMUSIC, (DMUS_ERRBASE + (code)))

/* DMUS_S_PARTIALLOAD
 *
 * The object could only load partially. This can happen if some components are
 * not registered properly, such as embedded tracks and tools.
 */
#define DMUS_S_PARTIALLOAD              MAKE_DMHRESULTSUCCESS(0x091)

/* DMUS_S_PARTIALDOWNLOAD
 *
 * This code indicates that a band download was only successful in reaching
 * some, but not all, of the referenced ports. Some samples may not play
 * correctly.
 */
#define DMUS_S_PARTIALDOWNLOAD          MAKE_DMHRESULTSUCCESS(0x092)

/* DMUS_S_REQUEUE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should cue the PMsg again automatically.
 */

#define DMUS_S_REQUEUE                  MAKE_DMHRESULTSUCCESS(0x200)

/* DMUS_S_FREE
 *
 * Return value from IDirectMusicTool::ProcessPMsg() which indicates to the
 * performance that it should free the PMsg automatically.
 */
#define DMUS_S_FREE                     MAKE_DMHRESULTSUCCESS(0x201)

/* DMUS_S_END
 *
 * Return value from IDirectMusicTrack::Play() which indicates to the
 * segment that the track has no more data after mtEnd.
 */
#define DMUS_S_END                      MAKE_DMHRESULTSUCCESS(0x202)

/* DMUS_S_STRING_TRUNCATED
 *
 * Returned string has been truncated to fit the buffer size.
 */
#define DMUS_S_STRING_TRUNCATED         MAKE_DMHRESULTSUCCESS(0x210)

/* DMUS_S_LAST_TOOL
 *
 * Returned from IDirectMusicGraph::StampPMsg(), this indicates that the PMsg
 * is already stamped with the last tool in the graph. The returned PMsg's
 * tool pointer is now NULL.
 */
#define DMUS_S_LAST_TOOL                MAKE_DMHRESULTSUCCESS(0x211)

/* DMUS_S_OVER_CHORD
 *
 * Returned from IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that no note has been calculated because the music value has the note 
 * at a position higher than the top note of the chord. This applies only
 * to DMUS_PLAYMODE_NORMALCHORD play mode. This success code indicates
 * that the caller should not do anything with the note. It is not meant
 * to be played against this chord.
 */
#define DMUS_S_OVER_CHORD               MAKE_DMHRESULTSUCCESS(0x212)

/* DMUS_S_UP_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is below 0, 
 * so it has been bumped up one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_UP_OCTAVE                MAKE_DMHRESULTSUCCESS(0x213)

/* DMUS_S_DOWN_OCTAVE
 *
 * Returned from IDirectMusicPerformance::MIDIToMusic(),  and
 * IDirectMusicPerformance::MusicToMIDI(), this indicates 
 * that the note conversion generated a note value that is above 127, 
 * so it has been bumped down one or more octaves to be in the proper
 * MIDI range of 0 through 127. 
 * Note that this is valid for MIDIToMusic() when using play modes
 * DMUS_PLAYMODE_FIXEDTOCHORD and DMUS_PLAYMODE_FIXEDTOKEY, both of
 * which store MIDI values in wMusicValue. With MusicToMIDI(), it is
 * valid for all play modes.
 * Ofcourse, DMUS_PLAYMODE_FIXED will never return this success code.
 */
#define DMUS_S_DOWN_OCTAVE              MAKE_DMHRESULTSUCCESS(0x214)

/* DMUS_S_NOBUFFERCONTROL
 *
 * Although the audio output from the port will be routed to the
 * same device as the given DirectSound buffer, buffer controls
 * such as pan and volume will not affect the output.
 *
 */
#define DMUS_S_NOBUFFERCONTROL          MAKE_DMHRESULTSUCCESS(0x215)

/* DMUS_E_DRIVER_FAILED
 *
 * An unexpected error was returned from a device driver, indicating
 * possible failure of the driver or hardware.
 */
#define DMUS_E_DRIVER_FAILED            MAKE_DMHRESULTERROR(0x0101)

/* DMUS_E_PORTS_OPEN
 *
 * The requested operation cannot be performed while there are 
 * instantiated ports in any process in the system.
 */
#define DMUS_E_PORTS_OPEN               MAKE_DMHRESULTERROR(0x0102)

/* DMUS_E_DEVICE_IN_USE
 *
 * The requested device is already in use (possibly by a non-DirectMusic
 * client) and cannot be opened again.
 */
#define DMUS_E_DEVICE_IN_USE            MAKE_DMHRESULTERROR(0x0103)

/* DMUS_E_INSUFFICIENTBUFFER
 *
 * Buffer is not large enough for requested operation.
 */
#define DMUS_E_INSUFFICIENTBUFFER       MAKE_DMHRESULTERROR(0x0104)

/* DMUS_E_BUFFERNOTSET
 *
 * No buffer was prepared for the download data.
 */
#define DMUS_E_BUFFERNOTSET             MAKE_DMHRESULTERROR(0x0105)

/* DMUS_E_BUFFERNOTAVAILABLE
 *
 * Download failed due to inability to access or create download buffer.
 */
#define DMUS_E_BUFFERNOTAVAILABLE       MAKE_DMHRESULTERROR(0x0106)

/* DMUS_E_NOTADLSCOL
 *
 * Error parsing DLS collection. File is corrupt.
 */
#define DMUS_E_NOTADLSCOL               MAKE_DMHRESULTERROR(0x0108)

/* DMUS_E_INVALIDOFFSET
 *
 * Wave chunks in DLS collection file are at incorrect offsets.
 */
#define DMUS_E_INVALIDOFFSET            MAKE_DMHRESULTERROR(0x0109)

/* DMUS_E_ALREADY_LOADED
 *
 * Second attempt to load a DLS collection that is currently open. 
 */
#define DMUS_E_ALREADY_LOADED           MAKE_DMHRESULTERROR(0x0111)

/* DMUS_E_INVALIDPOS
 *
 * Error reading wave data from DLS collection. Indicates bad file.
 */
#define DMUS_E_INVALIDPOS               MAKE_DMHRESULTERROR(0x0113)

/* DMUS_E_INVALIDPATCH
 *
 * There is no instrument in the collection that matches patch number.
 */
#define DMUS_E_INVALIDPATCH             MAKE_DMHRESULTERROR(0x0114)

/* DMUS_E_CANNOTSEEK
 *
 * The IStream* doesn't support Seek().
 */
#define DMUS_E_CANNOTSEEK               MAKE_DMHRESULTERROR(0x0115)

/* DMUS_E_CANNOTWRITE
 *
 * The IStream* doesn't support Write().
 */
#define DMUS_E_CANNOTWRITE              MAKE_DMHRESULTERROR(0x0116)

/* DMUS_E_CHUNKNOTFOUND
 *
 * The RIFF parser doesn't contain a required chunk while parsing file.
 */
#define DMUS_E_CHUNKNOTFOUND            MAKE_DMHRESULTERROR(0x0117)

/* DMUS_E_INVALID_DOWNLOADID
 *
 * Invalid download id was used in the process of creating a download buffer.
 */
#define DMUS_E_INVALID_DOWNLOADID       MAKE_DMHRESULTERROR(0x0119)

/* DMUS_E_NOT_DOWNLOADED_TO_PORT
 *
 * Tried to unload an object that was not downloaded or previously unloaded.
 */
#define DMUS_E_NOT_DOWNLOADED_TO_PORT   MAKE_DMHRESULTERROR(0x0120)

/* DMUS_E_ALREADY_DOWNLOADED
 *
 * Buffer was already downloaded to synth.
 */
#define DMUS_E_ALREADY_DOWNLOADED       MAKE_DMHRESULTERROR(0x0121)

/* DMUS_E_UNKNOWN_PROPERTY
 *
 * The specified property item was not recognized by the target object.
 */
#define DMUS_E_UNKNOWN_PROPERTY         MAKE_DMHRESULTERROR(0x0122)

/* DMUS_E_SET_UNSUPPORTED
 *
 * The specified property item may not be set on the target object.
 */
#define DMUS_E_SET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0123)

/* DMUS_E_GET_UNSUPPORTED
 *
 * The specified property item may not be retrieved from the target object.
 */ 
#define DMUS_E_GET_UNSUPPORTED          MAKE_DMHRESULTERROR(0x0124)

/* DMUS_E_NOTMONO
 *
 * Wave chunk has more than one interleaved channel. DLS format requires MONO.
 */
#define DMUS_E_NOTMONO                  MAKE_DMHRESULTERROR(0x0125)

/* DMUS_E_BADARTICULATION
 *
 * Invalid articulation chunk in DLS collection.
 */
#define DMUS_E_BADARTICULATION          MAKE_DMHRESULTERROR(0x0126)

/* DMUS_E_BADINSTRUMENT
 *
 * Invalid instrument chunk in DLS collection.
 */
#define DMUS_E_BADINSTRUMENT            MAKE_DMHRESULTERROR(0x0127)

/* DMUS_E_BADWAVELINK
 *
 * Wavelink chunk in DLS collection points to invalid wave.
 */
#define DMUS_E_BADWAVELINK              MAKE_DMHRESULTERROR(0x0128)

/* DMUS_E_NOARTICULATION
 *
 * Articulation missing from instrument in DLS collection.
 */
#define DMUS_E_NOARTICULATION           MAKE_DMHRESULTERROR(0x0129)

/* DMUS_E_NOTPCM
 *
 * Downoaded DLS wave is not in PCM format. 
*/
#define DMUS_E_NOTPCM                   MAKE_DMHRESULTERROR(0x012A)

/* DMUS_E_BADWAVE
 *
 * Bad wave chunk in DLS collection
 */
#define DMUS_E_BADWAVE                  MAKE_DMHRESULTERROR(0x012B)

/* DMUS_E_BADOFFSETTABLE
 *
 * Offset Table for download buffer has errors. 
 */
#define DMUS_E_BADOFFSETTABLE           MAKE_DMHRESULTERROR(0x012C)

/* DMUS_E_UNKNOWNDOWNLOAD
 *
 * Attempted to download unknown data type.
 */
#define DMUS_E_UNKNOWNDOWNLOAD          MAKE_DMHRESULTERROR(0x012D)

/* DMUS_E_NOSYNTHSINK
 *
 * The operation could not be completed because no sink was connected to
 * the synthesizer.
 */
#define DMUS_E_NOSYNTHSINK              MAKE_DMHRESULTERROR(0x012E)

/* DMUS_E_ALREADYOPEN
 *
 * An attempt was made to open the software synthesizer while it was already 
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYOPEN              MAKE_DMHRESULTERROR(0x012F)

/* DMUS_E_ALREADYCLOSE
 *
 * An attempt was made to close the software synthesizer while it was already 
 * open.
 * ASSERT?
 */
#define DMUS_E_ALREADYCLOSED            MAKE_DMHRESULTERROR(0x0130)

/* DMUS_E_SYNTHNOTCONFIGURED
 *
 * The operation could not be completed because the software synth has not 
 * yet been fully configured.
 * ASSERT?
 */
#define DMUS_E_SYNTHNOTCONFIGURED       MAKE_DMHRESULTERROR(0x0131)

/* DMUS_E_SYNTHACTIVE
 *
 * The operation cannot be carried out while the synthesizer is active.
 */
#define DMUS_E_SYNTHACTIVE              MAKE_DMHRESULTERROR(0x0132)

/* DMUS_E_CANNOTREAD
 *
 * An error occurred while attempting to read from the IStream* object.
 */
#define DMUS_E_CANNOTREAD               MAKE_DMHRESULTERROR(0x0133)

/* DMUS_E_DMUSIC_RELEASED
 *
 * The operation cannot be performed because the final instance of the
 * DirectMusic object was released. Ports cannot be used after final 
 * release of the DirectMusic object.
 */
#define DMUS_E_DMUSIC_RELEASED          MAKE_DMHRESULTERROR(0x0134)

/* DMUS_E_BUFFER_EMPTY
 *
 * There was no data in the referenced buffer.
 */
#define DMUS_E_BUFFER_EMPTY             MAKE_DMHRESULTERROR(0x0135)

/* DMUS_E_BUFFER_FULL
 *
 * There is insufficient space to insert the given event into the buffer.
 */
#define DMUS_E_BUFFER_FULL              MAKE_DMHRESULTERROR(0x0136)

/* DMUS_E_PORT_NOT_CAPTURE
 *
 * The given operation could not be carried out because the port is a
 * capture port.
 */
#define DMUS_E_PORT_NOT_CAPTURE         MAKE_DMHRESULTERROR(0x0137)

/* DMUS_E_PORT_NOT_RENDER
 *
 * The given operation could not be carried out because the port is a
 * render port.
 */
#define DMUS_E_PORT_NOT_RENDER          MAKE_DMHRESULTERROR(0x0138)

/* DMUS_E_DSOUND_NOT_SET
 *
 * The port could not be created because no DirectSound has been specified.
 * Specify a DirectSound interface via the IDirectMusic::SetDirectSound
 * method; pass NULL to have DirectMusic manage usage of DirectSound.
 */
#define DMUS_E_DSOUND_NOT_SET           MAKE_DMHRESULTERROR(0x0139)

/* DMUS_E_ALREADY_ACTIVATED
 *
 * The operation cannot be carried out while the port is active.
 */
#define DMUS_E_ALREADY_ACTIVATED        MAKE_DMHRESULTERROR(0x013A)

/* DMUS_E_INVALIDBUFFER
 *
 * Invalid DirectSound buffer was handed to port. 
 */
#define DMUS_E_INVALIDBUFFER            MAKE_DMHRESULTERROR(0x013B)

/* DMUS_E_WAVEFORMATNOTSUPPORTED
 *
 * Invalid buffer format was handed to the synth sink.
 */
#define DMUS_E_WAVEFORMATNOTSUPPORTED   MAKE_DMHRESULTERROR(0x013C)

/* DMUS_E_SYNTHINACTIVE
 *
 * The operation cannot be carried out while the synthesizer is inactive.
 */
#define DMUS_E_SYNTHINACTIVE            MAKE_DMHRESULTERROR(0x013D)

/* DMUS_E_DSOUND_ALREADY_SET
 *
 * IDirectMusic::SetDirectSound has already been called. It may not be
 * changed while in use.
 */
#define DMUS_E_DSOUND_ALREADY_SET       MAKE_DMHRESULTERROR(0x013E)

/* DMUS_E_INVALID_EVENT
 *
 * The given event is invalid (either it is not a valid MIDI message
 * or it makes use of running status). The event cannot be packed
 * into the buffer.
 */
#define DMUS_E_INVALID_EVENT            MAKE_DMHRESULTERROR(0x013F)

/* DMUS_E_UNSUPPORTED_STREAM
 *
 * The IStream* object does not contain data supported by the loading object.
 */
#define DMUS_E_UNSUPPORTED_STREAM       MAKE_DMHRESULTERROR(0x0150)

/* DMUS_E_ALREADY_INITED
 *
 * The object has already been initialized.
 */
#define DMUS_E_ALREADY_INITED           MAKE_DMHRESULTERROR(0x0151)

/* DMUS_E_INVALID_BAND
 *
 * The file does not contain a valid band.
 */
#define DMUS_E_INVALID_BAND             MAKE_DMHRESULTERROR(0x0152)

/* DMUS_E_TRACK_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a track header as the first chunk,
 * and therefore can not be read by the segment object.
 */
#define DMUS_E_TRACK_HDR_NOT_FIRST_CK   MAKE_DMHRESULTERROR(0x0155)

/* DMUS_E_TOOL_HDR_NOT_FIRST_CK
 *
 * The IStream* object's data does not have a tool header as the first chunk,
 * and therefore can not be read by the graph object.
 */
#define DMUS_E_TOOL_HDR_NOT_FIRST_CK    MAKE_DMHRESULTERROR(0x0156)

/* DMUS_E_INVALID_TRACK_HDR
 *
 * The IStream* object's data contains an invalid track header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the segment object.
 */
#define DMUS_E_INVALID_TRACK_HDR        MAKE_DMHRESULTERROR(0x0157)

/* DMUS_E_INVALID_TOOL_HDR
 *
 * The IStream* object's data contains an invalid tool header (ckid is 0 and
 * fccType is NULL,) and therefore can not be read by the graph object.
 */
#define DMUS_E_INVALID_TOOL_HDR         MAKE_DMHRESULTERROR(0x0158)

/* DMUS_E_ALL_TOOLS_FAILED
 *
 * The graph object was unable to load all tools from the IStream* object data.
 * This may be due to errors in the stream, or the tools being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TOOLS_FAILED         MAKE_DMHRESULTERROR(0x0159)

/* DMUS_E_ALL_TRACKS_FAILED
 *
 * The segment object was unable to load all tracks from the IStream* object data.
 * This may be due to errors in the stream, or the tracks being incorrectly
 * registered on the client.
 */
#define DMUS_E_ALL_TRACKS_FAILED        MAKE_DMHRESULTERROR(0x0160)

/* DMUS_E_NOT_FOUND
 *
 * The requested item was not contained by the object.
 */
#define DMUS_E_NOT_FOUND                MAKE_DMHRESULTERROR(0x0161)

/* DMUS_E_NOT_INIT
 *
 * A required object is not initialized or failed to initialize.
 */
#define DMUS_E_NOT_INIT                 MAKE_DMHRESULTERROR(0x0162)

/* DMUS_E_TYPE_DISABLED
 *
 * The requested parameter type is currently disabled. Parameter types may
 * be enabled and disabled by certain calls to SetParam().
 */
#define DMUS_E_TYPE_DISABLED            MAKE_DMHRESULTERROR(0x0163)

/* DMUS_E_TYPE_UNSUPPORTED
 *
 * The requested parameter type is not supported on the object.
 */
#define DMUS_E_TYPE_UNSUPPORTED         MAKE_DMHRESULTERROR(0x0164)

/* DMUS_E_TIME_PAST
 *
 * The time is in the past, and the operation can not succeed.
 */
#define DMUS_E_TIME_PAST                MAKE_DMHRESULTERROR(0x0165)

/* DMUS_E_TRACK_NOT_FOUND
 *
 * The requested track is not contained by the segment.
 */
#define DMUS_E_TRACK_NOT_FOUND			MAKE_DMHRESULTERROR(0x0166)

/* DMUS_E_NO_MASTER_CLOCK
 *
 * There is no master clock in the performance. Be sure to call
 * IDirectMusicPerformance::Init().
 */
#define DMUS_E_NO_MASTER_CLOCK          MAKE_DMHRESULTERROR(0x0170)

/* DMUS_E_LOADER_NOCLASSID
 *
 * The class id field is required and missing in the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOCLASSID         MAKE_DMHRESULTERROR(0x0180)

/* DMUS_E_LOADER_BADPATH
 *
 * The requested file path is invalid.
 */
#define DMUS_E_LOADER_BADPATH           MAKE_DMHRESULTERROR(0x0181)

/* DMUS_E_LOADER_FAILEDOPEN
 *
 * File open failed - either file doesn't exist or is locked.
 */
#define DMUS_E_LOADER_FAILEDOPEN        MAKE_DMHRESULTERROR(0x0182)

/* DMUS_E_LOADER_FORMATNOTSUPPORTED
 *
 * Search data type is not supported.
 */
#define DMUS_E_LOADER_FORMATNOTSUPPORTED    MAKE_DMHRESULTERROR(0x0183)

/* DMUS_E_LOADER_FAILEDCREATE
 *
 * Unable to find or create object.
 */
#define DMUS_E_LOADER_FAILEDCREATE      MAKE_DMHRESULTERROR(0x0184)

/* DMUS_E_LOADER_OBJECTNOTFOUND
 *
 * Object was not found.
 */
#define DMUS_E_LOADER_OBJECTNOTFOUND    MAKE_DMHRESULTERROR(0x0185)

/* DMUS_E_LOADER_NOFILENAME
 *
 * The file name is missing from the DMUS_OBJECTDESC.
 */
#define DMUS_E_LOADER_NOFILENAME	    MAKE_DMHRESULTERROR(0x0186)

/* DMUS_E_INVALIDFILE
 *
 * The file requested is not a valid file.
 */
#define DMUS_E_INVALIDFILE              MAKE_DMHRESULTERROR(0x0200)

/* DMUS_E_ALREADY_EXISTS
 *
 * The tool is already contained in the graph. Create a new instance.
 */
#define DMUS_E_ALREADY_EXISTS           MAKE_DMHRESULTERROR(0x0201)

/* DMUS_E_OUT_OF_RANGE
 *
 * Value is out of range, for instance the requested length is longer than
 * the segment.
 */
#define DMUS_E_OUT_OF_RANGE             MAKE_DMHRESULTERROR(0x0202)

/* DMUS_E_SEGMENT_INIT_FAILED
 *
 * Segment initialization failed, most likely due to a critical memory situation.
 */
#define DMUS_E_SEGMENT_INIT_FAILED      MAKE_DMHRESULTERROR(0x0203)

/* DMUS_E_ALREADY_SENT
 *
 * The DMUS_PMSG has already been sent to the performance object via
 * IDirectMusicPerformance::SendPMsg().
 */
#define DMUS_E_ALREADY_SENT             MAKE_DMHRESULTERROR(0x0204)

/* DMUS_E_CANNOT_FREE
 *
 * The DMUS_PMSG was either not allocated by the performance via
 * IDirectMusicPerformance::AllocPMsg(), or it was already freed via
 * IDirectMusicPerformance::FreePMsg().
 */
#define DMUS_E_CANNOT_FREE              MAKE_DMHRESULTERROR(0x0205)

/* DMUS_E_CANNOT_OPEN_PORT
 *
 * The default system port could not be opened.
 */
#define DMUS_E_CANNOT_OPEN_PORT         MAKE_DMHRESULTERROR(0x0206)

/* DMUS_E_CONNOT_CONVERT
 *
 * A call to MIDIToMusic() or MusicToMIDI() resulted in an error because
 * the requested conversion could not happen. This usually occurs when the
 * provided DMUS_CHORD_KEY structure has an invalid chord or scale pattern.
 */
#define DMUS_E_CONNOT_CONVERT           MAKE_DMHRESULTERROR(0x0207)

/* DMUS_E_DESCEND_CHUNK_FAIL
 * 
 * DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
 * was reached before the desired chunk was found.
 */
#define DMUS_E_DESCEND_CHUNK_FAIL       MAKE_DMHRESULTERROR(0x0210)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\win9x\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\inc\dmusicc.h ===
/************************************************************************
*                                                                       *
*   dmusicc.h -- This module defines the DirectMusic core API's         *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef _DMUSICC_
#define _DMUSICC_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include "dls1.h"
#include "dmerror.h"
#include "dmdls.h"
#include "dsound.h"
#include "dmusbuff.h"

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

#define DMUS_MAX_DESCRIPTION 128
#define DMUS_MAX_DRIVER 128

typedef struct _DMUS_BUFFERDESC *LPDMUS_BUFFERDESC;
typedef struct _DMUS_BUFFERDESC{
    DWORD dwSize;
    DWORD dwFlags;
    GUID guidBufferFormat;
    DWORD cbBuffer;
} DMUS_BUFFERDESC;

/* DMUS_EFFECT_ flags are used in the dwEffectFlags fields of both DMUS_PORTCAPS 
 * and DMUS_PORTPARAMS.
 */
#define DMUS_EFFECT_NONE             0x00000000
#define DMUS_EFFECT_REVERB           0x00000001
#define DMUS_EFFECT_CHORUS           0x00000002

/* For DMUS_PORTCAPS dwClass
 */ 
#define DMUS_PC_INPUTCLASS       (0)
#define DMUS_PC_OUTPUTCLASS      (1)

/* For DMUS_PORTCAPS dwFlags
 */
#define DMUS_PC_DLS              (0x00000001)
#define DMUS_PC_EXTERNAL         (0x00000002)
#define DMUS_PC_SOFTWARESYNTH    (0x00000004)
#define DMUS_PC_MEMORYSIZEFIXED  (0x00000008)
#define DMUS_PC_GMINHARDWARE     (0x00000010)
#define DMUS_PC_GSINHARDWARE     (0x00000020)
#define DMUS_PC_XGINHARDWARE     (0x00000040)
#define DMUS_PC_DIRECTSOUND      (0x00000080)
#define DMUS_PC_SHAREABLE        (0x00000100)
#define DMUS_PC_DLS2             (0x00000200)
#define DMUS_PC_SYSTEMMEMORY     (0x7FFFFFFF)


typedef struct _DMUS_PORTCAPS *LPDMUS_PORTCAPS;
typedef struct _DMUS_PORTCAPS
{
    DWORD   dwSize;
    DWORD   dwFlags;
    GUID    guidPort;
    DWORD   dwClass;
    DWORD   dwType;
    DWORD   dwMemorySize;
    DWORD   dwMaxChannelGroups;
    DWORD   dwMaxVoices;    
    DWORD   dwMaxAudioChannels;
    DWORD   dwEffectFlags;
    WCHAR   wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_PORTCAPS;

/* Values for DMUS_PORTCAPS dwType. This field indicates the underlying 
 * driver type of the port.
 */
#define DMUS_PORT_WINMM_DRIVER      (0)
#define DMUS_PORT_USER_MODE_SYNTH   (1)
#define DMUS_PORT_KERNEL_MODE       (2)

/* These flags (set in dwValidParams) indicate which other members of the */
/* DMUS_PORTPARAMS are valid. */
/* */
#define DMUS_PORTPARAMS_VOICES           0x00000001
#define DMUS_PORTPARAMS_CHANNELGROUPS    0x00000002
#define DMUS_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define DMUS_PORTPARAMS_SAMPLERATE       0x00000008
#define DMUS_PORTPARAMS_EFFECTS          0x00000020
#define DMUS_PORTPARAMS_SHARE            0x00000040

typedef struct _DMUS_PORTPARAMS *LPDMUS_PORTPARAMS;
typedef struct _DMUS_PORTPARAMS
{
    DWORD   dwSize;
    DWORD   dwValidParams;
    DWORD   dwVoices;
    DWORD   dwChannelGroups;
    DWORD   dwAudioChannels;
    DWORD   dwSampleRate;
    DWORD   dwEffectFlags;
    BOOL    fShare;
} DMUS_PORTPARAMS;

typedef struct _DMUS_SYNTHSTATS *LPDMUS_SYNTHSTATS;
typedef struct _DMUS_SYNTHSTATS
{
    DWORD   dwSize;             /* Size in bytes of the structure */
    DWORD   dwValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   dwVoices;           /* Average number of voices playing. */
    DWORD   dwTotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   dwCPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   dwLostNotes;        /* Number of notes lost in 1 second. */
    DWORD   dwFreeMemory;       /* Free memory in bytes */
    long    lPeakVolume;        /* Decibel level * 100. */
} DMUS_SYNTHSTATS;

#define DMUS_SYNTHSTATS_VOICES          (1 << 0)
#define DMUS_SYNTHSTATS_TOTAL_CPU       (1 << 1)
#define DMUS_SYNTHSTATS_CPU_PER_VOICE   (1 << 2)
#define DMUS_SYNTHSTATS_LOST_NOTES      (1 << 3)
#define DMUS_SYNTHSTATS_PEAK_VOLUME     (1 << 4)
#define DMUS_SYNTHSTATS_FREE_MEMORY     (1 << 5)

#define DMUS_SYNTHSTATS_SYSTEMMEMORY    DMUS_PC_SYSTEMMEMORY

typedef struct _DMUS_WAVES_REVERB_PARAMS
{
    float   fInGain;        /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;     /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal)
                            Negative values gives less wet signal.
                            The coeficients are calculated so that the overall output level stays 
                            (approximately) constant regardless of the ammount of reverb mix. */
    float   fReverbTime;    /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio; /* The ratio of the high frequencies to the global reverb time. 
                            Unless very 'splashy-bright' reverbs are wanted, this should be set to 
                            a value < 1.0.
                            For example if dRevTime==1000ms and dHighFreqRTRatio=0.1 than the 
                            decay time for high frequencies will be 100ms.*/

} DMUS_WAVES_REVERB_PARAMS;

/*  Note: Default values for Reverb are:
    fInGain             = 0.0dB   (no change in level)
    fReverbMix          = -10.0dB   (a reasonable reverb mix)
    fReverbTime         = 1000.0ms (one second global reverb time)
    fHighFreqRTRatio    = 0.001    (the ratio of the high frequencies to the global reverb time) 
*/

typedef enum
{
    DMUS_CLOCK_SYSTEM = 0,
    DMUS_CLOCK_WAVE = 1
} DMUS_CLOCKTYPE;

typedef struct _DMUS_CLOCKINFO *LPDMUS_CLOCKINFO;
typedef struct _DMUS_CLOCKINFO
{
    DWORD           dwSize;
    DMUS_CLOCKTYPE  ctType;
    GUID            guidClock;          /* Identifies this time source */
    WCHAR           wszDescription[DMUS_MAX_DESCRIPTION];
} DMUS_CLOCKINFO;

interface IDirectMusic;
interface IDirectMusicBuffer;
interface IDirectMusicPort;
interface IDirectMusicThru;
interface IReferenceClock;

#ifndef __cplusplus 
typedef interface IDirectMusic IDirectMusic;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicThru IDirectMusicThru;
typedef interface IReferenceClock IReferenceClock;
#endif

typedef IDirectMusic *LPDIRECTMUSIC;
typedef IDirectMusicBuffer *LPDIRECTMUSICBUFFER;
typedef IDirectMusicPort *LPDIRECTMUSICPORT;

#undef  INTERFACE
#define INTERFACE  IDirectMusic
DECLARE_INTERFACE_(IDirectMusic, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusic */
    STDMETHOD(EnumPort)             (THIS_ DWORD dwIndex, 
                                           LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(CreateMusicBuffer)    (THIS_ LPDMUS_BUFFERDESC pBufferDesc, 
                                           LPDIRECTMUSICBUFFER *ppBuffer, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(CreatePort)           (THIS_ REFCLSID rclsidPort, 
                                           LPDMUS_PORTPARAMS pPortParams, 
                                           LPDIRECTMUSICPORT *ppPort, 
                                           LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(EnumMasterClock)      (THIS_ DWORD dwIndex, 
                                           LPDMUS_CLOCKINFO lpClockInfo) PURE;
    STDMETHOD(GetMasterClock)       (THIS_ LPGUID pguidClock, 
                                           IReferenceClock **ppReferenceClock) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ REFGUID rguidClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(GetDefaultPort)       (THIS_ LPGUID pguidPort) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicBuffer
DECLARE_INTERFACE_(IDirectMusicBuffer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicBuffer */
    STDMETHOD(Flush)                (THIS) PURE;
    STDMETHOD(TotalTime)            (THIS_ LPREFERENCE_TIME prtTime) PURE;
    
    STDMETHOD(PackStructured)       (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD dwChannelMessage) PURE;
    
    STDMETHOD(PackUnstructured)     (THIS_ REFERENCE_TIME rt,
                                           DWORD dwChannelGroup,
                                           DWORD cb,
                                           LPBYTE lpb) PURE;
    
    STDMETHOD(ResetReadPtr)         (THIS) PURE;
    STDMETHOD(GetNextEvent)         (THIS_ LPREFERENCE_TIME prt,
                                           LPDWORD pdwChannelGroup,
                                           LPDWORD pdwLength,
                                           LPBYTE *ppData) PURE;

    STDMETHOD(GetRawBufferPtr)      (THIS_ LPBYTE *ppData) PURE;
    STDMETHOD(GetStartTime)         (THIS_ LPREFERENCE_TIME prt) PURE;
    STDMETHOD(GetUsedBytes)         (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetMaxBytes)          (THIS_ LPDWORD pcb) PURE;
    STDMETHOD(GetBufferFormat)      (THIS_ LPGUID pGuidFormat) PURE;

    STDMETHOD(SetStartTime)         (THIS_ REFERENCE_TIME rt) PURE;
    STDMETHOD(SetUsedBytes)         (THIS_ DWORD cb) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicInstrument
DECLARE_INTERFACE_(IDirectMusicInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicInstrument */
    STDMETHOD(GetPatch)                 (THIS_ DWORD* pdwPatch) PURE;
    STDMETHOD(SetPatch)                 (THIS_ DWORD dwPatch) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownloadedInstrument
DECLARE_INTERFACE_(IDirectMusicDownloadedInstrument, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicDownloadedInstrument */
    /* None at this time */
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicCollection
DECLARE_INTERFACE_(IDirectMusicCollection, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /* IDirectMusicCollection */
    STDMETHOD(GetInstrument)            (THIS_ DWORD dwPatch, 
                                               IDirectMusicInstrument** ppInstrument) PURE;
    STDMETHOD(EnumInstrument)           (THIS_ DWORD dwIndex, 
                                               DWORD* pdwPatch, 
                                               LPWSTR pwszName, 
                                               DWORD dwNameLen) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicDownload 
DECLARE_INTERFACE_(IDirectMusicDownload , IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicDownload */
    STDMETHOD(GetBuffer)            (THIS_ void** ppvBuffer, 
                                           DWORD* pdwSize) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicPortDownload
DECLARE_INTERFACE_(IDirectMusicPortDownload, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPortDownload */
    STDMETHOD(GetBuffer)            (THIS_ DWORD dwDLId, 
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(AllocateBuffer)       (THIS_ DWORD dwSize, 
                                           IDirectMusicDownload** ppIDMDownload) PURE;
    STDMETHOD(GetDLId)              (THIS_ DWORD* pdwStartDLId, 
                                           DWORD dwCount) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
    STDMETHOD(Unload)               (THIS_ IDirectMusicDownload* pIDMDownload) PURE;
};

/* Standard values for voice priorities. Numerically higher priorities are higher in priority.
 * These priorities are used to set the voice priority for all voices on a channel. They are
 * used in the dwPriority parameter of IDirectMusicPort::GetPriority and returned in the
 * lpwPriority parameter of pdwPriority.
 *
 * These priorities are shared with DirectSound.
 */

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000) 

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)
 
 
#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */


#undef  INTERFACE
#define INTERFACE  IDirectMusicPort
DECLARE_INTERFACE_(IDirectMusicPort, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPort */
    /*  */
    STDMETHOD(PlayBuffer)           (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(SetReadNotificationHandle) (THIS_ HANDLE hEvent) PURE;
    STDMETHOD(Read)                 (THIS_ LPDIRECTMUSICBUFFER pBuffer) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument *pInstrument, 
                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
                                     DMUS_NOTERANGE *pNoteRanges,
                                     DWORD dwNumNoteRanges) PURE;
    STDMETHOD(UnloadInstrument)     (THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDMUS_PORTCAPS pPortCaps) PURE;
    STDMETHOD(DeviceIoControl)      (THIS_ DWORD dwIoControlCode, 
                                           LPVOID lpInBuffer, 
                                           DWORD nInBufferSize, 
                                           LPVOID lpOutBuffer, 
                                           DWORD nOutBufferSize, 
                                           LPDWORD lpBytesReturned, 
                                           LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwChannelGroups) PURE;
    STDMETHOD(GetNumChannelGroups)  (THIS_ LPDWORD pdwChannelGroups) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fActive) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound, LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize, LPDWORD pdwBufferSize) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicThru
DECLARE_INTERFACE_(IDirectMusicThru, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    /* IDirectMusicThru 
     */
    STDMETHOD(ThruChannel)          (THIS_ DWORD dwSourceChannelGroup, 
                                           DWORD dwSourceChannel, 
                                           DWORD dwDestinationChannelGroup,
                                           DWORD dwDestinationChannel,
                                           LPDIRECTMUSICPORT pDestinationPort) PURE;
};

#ifndef __IReferenceClock_INTERFACE_DEFINED__
#define __IReferenceClock_INTERFACE_DEFINED__

DEFINE_GUID(IID_IReferenceClock,0x56a86897,0x0ad4,0x11ce,0xb0,0x3a,0x00,0x20,0xaf,0x0b,0xa7,0x70);

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */
    
    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#endif /* __IReferenceClock_INTERFACE_DEFINED__ */

DEFINE_GUID(CLSID_DirectMusic,0x636b9f10,0x0c7d,0x11d1,0x95,0xb2,0x00,0x20,0xaf,0xdc,0x74,0x21);
DEFINE_GUID(CLSID_DirectMusicCollection,0x480ff4b0, 0x28b2, 0x11d1, 0xbe, 0xf7, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);

DEFINE_GUID(IID_IDirectMusic,0x6536115a,0x7b2d,0x11d2,0xba,0x18,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicBuffer,0xd2ac2878, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPort, 0x08f2d8c9,0x37c2,0x11d2,0xb9,0xf9,0x00,0x00,0xf8,0x75,0xac,0x12);
DEFINE_GUID(IID_IDirectMusicThru, 0xced153e7, 0x3606, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(IID_IDirectMusicPortDownload,0xd2ac287a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownload,0xd2ac287b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicCollection,0xd2ac287c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicInstrument,0xd2ac287d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicDownloadedInstrument,0xd2ac287e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Alternate interface ID for IID_IDirectMusic, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusic2,0x6fc2cae1, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);


/* Property Query GUID_DMUS_PROP_GM_Hardware - Local GM set, no need to download
 * Property Query GUID_DMUS_PROP_GS_Hardware - Local GS set, no need to download
 * Property Query GUID_DMUS_PROP_XG_Hardware - Local XG set, no need to download
 * Property Query GUID_DMUS_PROP_DLS1        - Support DLS level 1
 * Property Query GUID_DMUS_PROP_INSTRUMENT2 - Support new INSTRUMENT2 download format
 * Property Query GUID_DMUS_PROP_XG_Capable  - Support minimum requirements of XG
 * Property Query GUID_DMUS_PROP_GS_Capable  - Support minimum requirements of GS
 * Property Query GUID_DMUS_PROP_SynthSink_DSOUND - Synthsink talks to DSound
 * Property Query GUID_DMUS_PROP_SynthSink_WAVE - Synthsink talks to Wave device
 *
 * Item 0: Supported
 * Returns a DWORD which is non-zero if the feature is supported
 */
DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_DLS2,        0xf14599e5, 0x4689, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_INSTRUMENT2, 0x865fd372, 0x9f67, 0x11d2, 0x87, 0x2a, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_DSOUND,0xaa97844, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SynthSink_WAVE,0xaa97845, 0xc877, 0x11d1, 0x87, 0xc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_DMUS_PROP_SampleMemorySize, 0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_SamplePlaybackRate, 0x2a91f713, 0xa4bf, 0x11d2, 0xbb, 0xdf, 0x0, 0x60, 0x8, 0x33, 0xdb, 0xd8);

/* Property Get/Set GUID_DMUS_PROP_WriteLatency
 *
 * Item 0: Synth buffer write latency, in milliseconds
 * Get/Set SynthSink latency, the average time after the play head that the next buffer gets written.
 */
DEFINE_GUID(GUID_DMUS_PROP_WriteLatency,0x268a0fa0, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get/Set GUID_DMUS_PROP_WritePeriod
 *
 * Item 0: Synth buffer write period, in milliseconds
 * Get/Set SynthSink buffer write period, time span between successive writes.
 */
DEFINE_GUID(GUID_DMUS_PROP_WritePeriod,0x268a0fa1, 0x60f2, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Get GUID_DMUS_PROP_MemorySize
 *
 * Item 0: Memory size
 * Returns a DWORD containing the total number of bytes of sample RAM
 */
DEFINE_GUID(GUID_DMUS_PROP_MemorySize,  0x178f2f28, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_WavesReverb
 *
 * Item 0: DMUS_WAVES_REVERB structure
 * Sets reverb parameters
 */
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb,0x4cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_Effects
 *
 * Item 0: DWORD with effects flags. 
 * Get/Set effects bits, same as dwEffectFlags in DMUS_PORTPARAMS and DMUS_PORTCAPS:
 * DMUS_EFFECT_NONE 
 * DMUS_EFFECT_REVERB 
 * DMUS_EFFECT_CHORUS 
 */
DEFINE_GUID(GUID_DMUS_PROP_Effects, 0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Property Set GUID_DMUS_PROP_LegacyCaps
 *
 * Item 0: The MIDINCAPS or MIDIOUTCAPS which describes the port's underlying WinMM device. This property is only supported
 * by ports which wrap WinMM devices.
 */

DEFINE_GUID(GUID_DMUS_PROP_LegacyCaps,0xcfa7cdc2, 0x00a1, 0x11d2, 0xaa, 0xd5, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_Volume
 *
 * Item 0: A long which contains an offset, in 1/100 dB, to be added to the final volume
 *
 */
DEFINE_GUID(GUID_DMUS_PROP_Volume, 0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Min and Max values for setting volume with GUID_DMUS_PROP_Volume */

#define DMUS_VOLUME_MAX     2000        /* +20 dB */
#define DMUS_VOLUME_MIN   -20000        /* -200 dB */

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICC_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\inc\dmksctrl.h ===
/************************************************************************
*                                                                       *
*   dmksctrl.h -- Definition of IKsControl                              *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
*                                                                       *
*   This header file contains the definition of IKsControl, which       *
*   duplicates definitions from ks.h and ksproxy.h. Your code should    *
*   include ks.h and ksproxy.h directly if you have them (they are      *
*   provided in the Windows 98 DDK and will be in the Windows NT 5      *
*   SDK).                                                               *
*                                                                       *
************************************************************************/

#ifndef _DMKSCTRL_
#define _DMKSCTRL_

#pragma warning(push)
#pragma warning(disable:4201)   /* Disable warnings on anonymous unions */

#include <pshpack8.h>

#include <objbase.h>

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif /* !defined(DEFINE_GUIDEX) */

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif /* !defined(STATICGUIDOF) */
#endif /* !defined(_NTRTL_) */

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl\
    0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
#endif /* STATIC_IID_IKsControl */

/* 
 * Warning: This will prevent the rest of ks.h from being pulled in if ks.h is 
 * included after dmksctrl.h. Make sure you do not include both headers in
 * the same source file.
 */
#ifndef _KS_
#define _KS_

#if (defined(_MSC_EXTENSIONS) || defined(__cplusplus)) && !defined(CINTERFACE)
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#else
typedef struct {
    union {
        struct {
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        } Data;
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;
#endif

typedef KSIDENTIFIER KSPROPERTY, *PKSPROPERTY, KSMETHOD, *PKSMETHOD, KSEVENT, *PKSEVENT;

#define KSMETHOD_TYPE_NONE                  0x00000000
#define KSMETHOD_TYPE_READ                  0x00000001
#define KSMETHOD_TYPE_WRITE                 0x00000002
#define KSMETHOD_TYPE_MODIFY                0x00000003
#define KSMETHOD_TYPE_SOURCE                0x00000004

#define KSMETHOD_TYPE_SEND                  0x00000001
#define KSMETHOD_TYPE_SETSUPPORT            0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define KSPROPERTY_TYPE_GET                 0x00000001
#define KSPROPERTY_TYPE_SET                 0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200
#define KSPROPERTY_TYPE_RELATIONS           0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY            0x10000000
#endif  /* _KS_ */

#ifndef _IKsControl_
#define _IKsControl_

#ifdef DECLARE_INTERFACE_


#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl, IUnknown)
{
     /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*IKsControl*/
    STDMETHOD(KsProperty)(
        THIS_
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsMethod)(
        THIS_
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsEvent)(
        THIS_
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
    ) PURE;
};

#endif /* DECLARE_INTERFACE_ */
#endif /* _IKsControl_ */

#include <poppack.h>

DEFINE_GUID(IID_IKsControl, 0x28F54685, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);

/* These formats are in ksmedia.h
 */
#ifndef _KSMEDIA_

DEFINE_GUID(KSDATAFORMAT_SUBTYPE_MIDI, 0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00);
DEFINE_GUID(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC, 0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);

#endif

#pragma warning(pop)

#endif /* _DMKSCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\choosecolorobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       choosecolorobj.h
//
//--------------------------------------------------------------------------

// ChooseColorObj.h : Declaration of the CChooseColorObject


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CChooseColorObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<IChooseColor, &IID_IChooseColor, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public IChooseColor,
#endif
	public CComObjectBase<&CLSID_ChooseColor>
{
public:
	CChooseColorObject() ;
BEGIN_COM_MAP(CChooseColorObject)
	COM_INTERFACE_ENTRY(IChooseColor)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CChooseColorObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CChooseColorObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif
// IChooseColor
public:
	STDMETHOD(setOwner)(long hwnd);
	STDMETHOD(setInitialColor)(COLORREF c);
	STDMETHOD(setFlags)(long flags);
	STDMETHOD(show)(int *selected);
	STDMETHOD(getColor)(COLORREF *c);
private:
	HWND m_hwnd;
	COLORREF m_color;
	DWORD m_flags;
	BOOL m_completed;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\inc\dmusbuff.h ===
/***************************************************************************
*                                                                          *
*   DMusBuff.h -- This module defines the buffer format for DirectMusic    *
*                 Shared file between user mode and kernel mode components *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusBuff_
#define _DMusBuff_

/* Format of DirectMusic events in a buffer
 *
 * A buffer contains 1 or more events, each with the following header.
 * Immediately following the header is the event data. The header+data
 * size is rounded to the nearest quadword (8 bytes).
 */
 
#include <pshpack4.h>                       /* Do not pad at end - that's where the data is */ 
typedef struct _DMUS_EVENTHEADER *LPDMUS_EVENTHEADER;
typedef struct _DMUS_EVENTHEADER
{
    DWORD           cbEvent;                /* Unrounded bytes in event */
    DWORD           dwChannelGroup;         /* Channel group of event */
    REFERENCE_TIME  rtDelta;                /* Delta from start time of entire buffer */
    DWORD           dwFlags;                /* Flags DMUS_EVENT_xxx */
} DMUS_EVENTHEADER;
#include <poppack.h>

#define DMUS_EVENT_STRUCTURED   0x00000001  /* Unstructured data (SysEx, etc.) */

/* The number of bytes to allocate for an event with 'cb' data bytes.
 */ 
#define QWORD_ALIGN(x) (((x) + 7) & ~7)
#define DMUS_EVENT_SIZE(cb) QWORD_ALIGN(sizeof(DMUS_EVENTHEADER) + cb)


#endif /* _DMusBuff_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3d7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3d7obj.cpp
//
//--------------------------------------------------------------------------

// d3dObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3d7Obj.h"
#include "d3dDevice7Obj.h"
#include "d3dEnumDevices7Obj.h"
#include "ddSurface7Obj.h"
#include "D3DEnumPixelFormats7Obj.h"
#include "d3dVertexBuffer7Obj.h"
#include "dDraw7Obj.h"

typedef HRESULT (__stdcall *DDRAWCREATE)( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT D3DBSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID);


C_dxj_Direct3d7Object::C_dxj_Direct3d7Object(){
	m__dxj_Direct3d7=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	DPF1(1,"Constructor Creation  Direct3d3[%d] \n ",g_creationcount);
	
	nextobj =  g_dxj_Direct3d7;
	g_dxj_Direct3d7 = (void *)this;
}


C_dxj_Direct3d7Object::~C_dxj_Direct3d7Object()
{
    C_dxj_Direct3d7Object *prev=NULL; 
	for(C_dxj_Direct3d7Object *ptr=(C_dxj_Direct3d7Object *)g_dxj_Direct3d7; ptr; ptr=(C_dxj_Direct3d7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3d7 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3d7){
		int count = IUNK(m__dxj_Direct3d7)->Release();
		
		DPF1(1,"DirectX IDirect3d7 Ref count [%d] \n",count);
		

		if(count==0) m__dxj_Direct3d7 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
}



DWORD C_dxj_Direct3d7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();	
	DPF2(1,"Direct3d3[%d] AddRef %d \n",creationid,i);
	return i;
}

DWORD C_dxj_Direct3d7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"Direct3d7 [%d] Release %d \n",creationid,i);
	return i;
}


GETSET_OBJECT(_dxj_Direct3d7);

#if 0
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::findDevice(D3dFindDeviceSearch *ds, D3dFindDeviceResult7 *dr )
{
	HRESULT hr;
	
	


	//Fixup FindDeviceSearch
	ds->lSize  = sizeof(D3DFINDDEVICESEARCH);
	ds->dpcPrimCaps.lSize =sizeof(D3DPRIMCAPS);		
	ZeroMemory((LPGUID)&(ds->guidStruct),sizeof(GUID));
	hr=BSTRtoGUID((LPGUID)&(ds->guidStruct), ds->strGuid);

	//if FAILED(hr) return E_INVALIDARG;
	
	//Fixup FindDeviceResult
	memset(dr,0,sizeof(D3DFINDDEVICERESULT7));
	dr->lSize = sizeof(D3DFINDDEVICERESULT7);
	dr->ddHwDesc.lSize=sizeof(D3DDEVICEDESC7);
	dr->ddSwDesc.lSize=sizeof(D3DDEVICEDESC7);
	


	// NOTE THE TOP PORTIONS OF D3dFindDeviceSearch and D3dFindDeviceResult
	// are the same As D3DFINDEVICSEARCH and D3DFINDRESULT
	// 
	hr = m__dxj_Direct3d7->FindDevice((D3DFINDDEVICESEARCH*)ds, (D3DFINDDEVICERESULT7*)dr);

	dr->strGuid=D3DGUIDtoBSTR((LPGUID) &(dr->guidStruct));
		
	return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::getDevicesEnum(I_dxj_Direct3DEnumDevices **ppRet)
{
	HRESULT hr=E_FAIL;
	hr=C_dxj_Direct3DEnumDevices7Object::create(m__dxj_Direct3d7,ppRet);

	return hr;
}

//TODO tighter code produced if made into an inline function
//and use a for loop to compare byte by byte
#define GUIDISEQUAL(a,b) \
	((((DxGuid *)a)->data1==((DxGuid *)b)->data1) && \
	(((DxGuid *)a)->data2==((DxGuid *)b)->data2) && \
	(((DxGuid *)a)->data3==((DxGuid *)b)->data3) && \
	(((DxGuid *)a)->data4[0]==((DxGuid *)b)->data4[0]) && \
	(((DxGuid *)a)->data4[1]==((DxGuid *)b)->data4[1]) && \
	(((DxGuid *)a)->data4[2]==((DxGuid *)b)->data4[2]) && \
	(((DxGuid *)a)->data4[3]==((DxGuid *)b)->data4[3]) && \
	(((DxGuid *)a)->data4[4]==((DxGuid *)b)->data4[4]) && \
	(((DxGuid *)a)->data4[5]==((DxGuid *)b)->data4[5]) && \
	(((DxGuid *)a)->data4[6]==((DxGuid *)b)->data4[6]) && \
	(((DxGuid *)a)->data4[7]==((DxGuid *)b)->data4[7])) 




		
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::createDevice(BSTR strClsid, I_dxj_DirectDrawSurface7 *surf,I_dxj_Direct3dDevice7 **retv)
{
	LPDIRECT3DDEVICE7 lpNew=NULL;
	HRESULT hr;

	GUID clsid;

	hr=D3DBSTRtoGUID(&clsid,strClsid);
	if FAILED(hr) return E_INVALIDARG;

	
	//CreateDevice wants a DirectDrawSurface as opposed to 
	//a DirectDrawSurface3 . we implement as cast
	//cause DX allows us to.
	//Consider - Is the cost of a QI call really to much?
	//AK

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpSurf, surf);
	

	hr=m__dxj_Direct3d7->CreateDevice(clsid,  lpSurf,  &lpNew);

	if FAILED(hr) return hr;
 
	//INTERNAL_CREATE(_dxj_Direct3dDevice3, lpNew, retv);
	INTERNAL_CREATE_2REFS(_dxj_Direct3dDevice7,_dxj_DirectDrawSurface7,surf, lpNew,retv) 
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3d7Object::getDirectDraw(I_dxj_DirectDraw7 **retv)
{
	IDirectDraw7 *pdd7;
	HRESULT hr;
	hr=m__dxj_Direct3d7->QueryInterface(IID_IDirectDraw7,(void**)&pdd7);
	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_DirectDraw7, pdd7, retv);
        
	return hr; 
}


STDMETHODIMP C_dxj_Direct3d7Object::createVertexBuffer( 
            /* [in] */ D3dVertexBufferDesc *desc,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *__RPC_FAR *f)
{
 
	LPDIRECT3DVERTEXBUFFER7 pBuff=NULL;
	HRESULT hr;
	
	if (!desc) return E_INVALIDARG;
	desc->lSize=sizeof(D3DVERTEXBUFFERDESC);

	hr=m__dxj_Direct3d7->CreateVertexBuffer((LPD3DVERTEXBUFFERDESC) desc,
				&pBuff,
				(DWORD)flags
				);

	if FAILED(hr) return hr;

	INTERNAL_CREATE(_dxj_Direct3dVertexBuffer7, pBuff, f);


	DWORD fvf=(DWORD)desc->lFVF;
	long  n=0;

	if (fvf == D3DFVF_VERTEX)  n=sizeof(D3DVERTEX);
	else if (fvf == D3DFVF_LVERTEX)  n=sizeof(D3DLVERTEX);
	else if (fvf == D3DFVF_TLVERTEX)  n=sizeof(D3DLVERTEX);
	else 
	{
	 	if (fvf & D3DFVF_DIFFUSE ) n=n+sizeof(DWORD);
		if (fvf & D3DFVF_SPECULAR ) n=n+sizeof(DWORD);	
		if (fvf & D3DFVF_NORMAL  ) n=n+sizeof(float)*3;
		if (fvf & D3DFVF_XYZ   ) n=n+sizeof(float)*3;
		if (fvf & D3DFVF_XYZRHW    ) n=n+sizeof(float)*4;
		if (fvf & D3DFVF_TEX0 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX1 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX2 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX3 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX4 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX5 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX6 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX7 	    ) n=n+sizeof(float)*2;
		if (fvf & D3DFVF_TEX8 	    ) n=n+sizeof(float)*2;
	}

	(*f)->setVertexSize(n);

	return S_OK;
}
        
STDMETHODIMP C_dxj_Direct3d7Object::getEnumZBufferFormats( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retval)
{
		
	HRESULT  hr=C_dxj_Direct3DEnumPixelFormats7Object::create2(m__dxj_Direct3d7, guid, retval);
	return hr;
}
        
STDMETHODIMP C_dxj_Direct3d7Object::evictManagedTextures( void)
{
	HRESULT hr;
	hr=m__dxj_Direct3d7->EvictManagedTextures();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\inc\dmusicf.h ===
/************************************************************************
*                                                                       *
*   dmusicf.h -- This module defines the DirectMusic file formats       *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef _DMUSICF_
#define _DMUSICF_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

interface IDirectMusicCollection;
#ifndef __cplusplus 
typedef interface IDirectMusicCollection IDirectMusicCollection;
#endif

/* Common chunks */

#define DMUS_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DMUS_FOURCC_INFO_LIST         mmioFOURCC('I','N','F','O')
#define DMUS_FOURCC_UNFO_LIST         mmioFOURCC('U','N','F','O')
#define DMUS_FOURCC_UNAM_CHUNK         mmioFOURCC('U','N','A','M')
#define DMUS_FOURCC_UART_CHUNK         mmioFOURCC('U','A','R','T')
#define DMUS_FOURCC_UCOP_CHUNK         mmioFOURCC('U','C','O','P')
#define DMUS_FOURCC_USBJ_CHUNK         mmioFOURCC('U','S','B','J')
#define DMUS_FOURCC_UCMT_CHUNK         mmioFOURCC('U','C','M','T')
#define DMUS_FOURCC_CATEGORY_CHUNK    mmioFOURCC('c','a','t','g')
#define DMUS_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')

/* The following structures are used by the Tracks, and are the packed structures */
/* that are passed to the Tracks inside the IStream. */


typedef struct _DMUS_IO_SEQ_ITEM
{
    MUSIC_TIME    mtTime;
    MUSIC_TIME    mtDuration;
    DWORD         dwPChannel;
    short         nOffset; 
    BYTE          bStatus;
    BYTE          bByte1;
    BYTE          bByte2;
} DMUS_IO_SEQ_ITEM;


typedef struct _DMUS_IO_CURVE_ITEM
{
    MUSIC_TIME  mtStart;
    MUSIC_TIME  mtDuration;
    MUSIC_TIME  mtResetDuration;
    DWORD       dwPChannel;
    short       nOffset;
    short       nStartValue;
    short       nEndValue;
    short       nResetValue;
    BYTE        bType;
    BYTE        bCurveShape;
    BYTE        bCCData;
    BYTE        bFlags;
} DMUS_IO_CURVE_ITEM;


typedef struct _DMUS_IO_TEMPO_ITEM
{
    MUSIC_TIME    lTime;
    double        dblTempo;
} DMUS_IO_TEMPO_ITEM;


typedef struct _DMUS_IO_SYSEX_ITEM
{
    MUSIC_TIME    mtTime;
    DWORD         dwPChannel;
    DWORD         dwSysExLength;
} DMUS_IO_SYSEX_ITEM;


typedef struct _DMUS_IO_TIMESIGNATURE_ITEM
{
    MUSIC_TIME    lTime;
    BYTE          bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE          bBeat;              /* what note receives the beat (bottom of time sig.) */
                                      /* we can assume that 0 means 256th note */
    WORD          wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIGNATURE_ITEM;

/* PARAM structures, used by GetParam() and SetParam() */
typedef struct _DMUS_COMMAND_PARAM
{
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
} DMUS_COMMAND_PARAM;

typedef struct _DMUS_COMMAND_PARAM_2
{
	MUSIC_TIME mtTime;
    BYTE bCommand;
    BYTE bGrooveLevel;
    BYTE bGrooveRange;
} DMUS_COMMAND_PARAM_2;

typedef DMUS_CHORD_KEY DMUS_CHORD_PARAM; /* DMUS_CHORD_KEY defined in dmusici.h */

typedef struct _DMUS_RHYTHM_PARAM
{
    DMUS_TIMESIGNATURE  TimeSig;
    DWORD               dwRhythmPattern;
} DMUS_RHYTHM_PARAM;

typedef struct _DMUS_TEMPO_PARAM
{
    MUSIC_TIME  mtTime;
    double      dblTempo;
} DMUS_TEMPO_PARAM;


typedef struct _DMUS_MUTE_PARAM
{
    DWORD   dwPChannel;
    DWORD   dwPChannelMap;
    BOOL    fMute;
} DMUS_MUTE_PARAM;

/* Style chunks */

#define DMUS_FOURCC_STYLE_FORM        mmioFOURCC('D','M','S','T')
#define DMUS_FOURCC_STYLE_CHUNK       mmioFOURCC('s','t','y','h')
#define DMUS_FOURCC_PART_LIST         mmioFOURCC('p','a','r','t')
#define DMUS_FOURCC_PART_CHUNK        mmioFOURCC('p','r','t','h')
#define DMUS_FOURCC_NOTE_CHUNK        mmioFOURCC('n','o','t','e')
#define DMUS_FOURCC_CURVE_CHUNK       mmioFOURCC('c','r','v','e')
#define DMUS_FOURCC_PATTERN_LIST      mmioFOURCC('p','t','t','n')
#define DMUS_FOURCC_PATTERN_CHUNK     mmioFOURCC('p','t','n','h')
#define DMUS_FOURCC_RHYTHM_CHUNK      mmioFOURCC('r','h','t','m')
#define DMUS_FOURCC_PARTREF_LIST      mmioFOURCC('p','r','e','f')
#define DMUS_FOURCC_PARTREF_CHUNK     mmioFOURCC('p','r','f','c')
#define DMUS_FOURCC_STYLE_PERS_REF_LIST   mmioFOURCC('p', 'r', 'r', 'f')
#define DMUS_FOURCC_MOTIFSETTINGS_CHUNK   mmioFOURCC('m', 't', 'f', 's')

/* Flags used by variations: these make up the DWORDs in dwVariationChoices.               */

/* These flags determine the types of chords supported by a given variation in DirectMusic */
/* mode.  The first seven flags (bits 1-7) are set if the variation supports major chords  */
/* rooted in scale positions, so, e.g., if bits 1, 2, and 4 are set, the variation         */
/* supports major chords rooted in the tonic, second, and fourth scale positions.  The     */
/* next seven flags serve the same purpose, but for minor chords, and the following seven  */
/* flags serve the same purpose for chords that are not major or minor (e.g., SUS 4        */
/* chords).  Bits 22, 23, and 24 are set if the variation supports chords rooted in the    */
/* scale, chords rooted sharp of scale tones, and chords rooted flat of scale tones,       */
/* respectively.  For example, to support a C# minor chord in the scale of C Major,        */
/* bits 8 (for tonic minor) and 24 (for sharp) need to be set.  Bits 25, 26, an 27 handle  */
/* chords that are triads, 6th or 7th chords, and chords with extensions, respectively.    */
/* bits 28 and 29 handle chords that are followed by tonic and dominant chords,            */
/* respectively.                                                                           */
#define DMUS_VARIATIONF_MAJOR        0x0000007F /* Seven positions in the scale - major chords. */    
#define DMUS_VARIATIONF_MINOR        0x00003F80 /* Seven positions in the scale - minor chords. */    
#define DMUS_VARIATIONF_OTHER        0x001FC000 /* Seven positions in the scale - other chords. */    
#define DMUS_VARIATIONF_ROOT_SCALE   0x00200000 /* Handles chord roots in the scale. */         
#define DMUS_VARIATIONF_ROOT_FLAT    0x00400000 /* Handles flat chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_ROOT_SHARP   0x00800000 /* Handles sharp chord roots (based on scale notes). */         
#define DMUS_VARIATIONF_TYPE_TRIAD   0x01000000 /* Handles simple chords - triads. */  
#define DMUS_VARIATIONF_TYPE_6AND7   0x02000000 /* Handles simple chords - 6 and 7. */  
#define DMUS_VARIATIONF_TYPE_COMPLEX 0x04000000 /* Handles complex chords. */  
#define DMUS_VARIATIONF_DEST_TO1     0x08000000 /* Handles transitions to 1 chord. */  
#define DMUS_VARIATIONF_DEST_TO5     0x10000000 /* Handles transitions to 5 chord. */  

/* The top three bits of the variation flags are the Mode bits.  If all are 0, it's IMA. */  
/* If the smallest is 1, it's Direct Music. */
#define DMUS_VARIATIONF_MODES        0xE0000000
#define DMUS_VARIATIONF_IMA25_MODE   0x00000000
#define DMUS_VARIATIONF_DMUS_MODE    0x20000000

#pragma pack(2)

typedef struct _DMUS_IO_TIMESIG
{
    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;   /* beats per measure (top of time sig) */
    BYTE    bBeat;              /* what note receives the beat (bottom of time sig.) */
                                /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;      /* grids per beat */
} DMUS_IO_TIMESIG;

typedef struct _DMUS_IO_STYLE
{
    DMUS_IO_TIMESIG     timeSig;        /* Styles have a default Time Signature */
    double              dblTempo;   
} DMUS_IO_STYLE;

typedef struct _DMUS_IO_VERSION
{
    DWORD               dwVersionMS;        /* Version # high-order 32 bits */
    DWORD               dwVersionLS;        /* Version # low-order 32 bits  */
} DMUS_IO_VERSION;

typedef struct _DMUS_IO_PATTERN
{
    DMUS_IO_TIMESIG     timeSig;        /* Patterns can override the Style's Time sig. */
    BYTE                bGrooveBottom;  /* bottom of groove range */
    BYTE                bGrooveTop;     /* top of groove range */
    WORD                wEmbellishment; /* Fill, Break, Intro, End, Normal, Motif */
    WORD                wNbrMeasures;   /* length in measures */
} DMUS_IO_PATTERN;

typedef struct _DMUS_IO_STYLEPART
{
    DMUS_IO_TIMESIG     timeSig;        /* can override pattern's */
    DWORD               dwVariationChoices[32]; /* MOAW choice bitfield */
    GUID                guidPartID;     /* identifies the part */
    WORD                wNbrMeasures;   /* length of the Part */
    BYTE                bPlayModeFlags; /* see PLAYMODE flags */
    BYTE                bInvertUpper;   /* inversion upper limit */
    BYTE                bInvertLower;   /* inversion lower limit */
} DMUS_IO_STYLEPART;

typedef struct _DMUS_IO_PARTREF
{
    GUID    guidPartID;         /* unique ID for matching up with parts */
    WORD    wLogicalPartID;     /* corresponds to port/device/midi channel */
    BYTE    bVariationLockID;   /* parts with the same ID lock variations. */
                                /* high bit is used to identify master Part */
    BYTE    bSubChordLevel;     /* tells which sub chord level this part wants */
    BYTE    bPriority;          /* 256 priority levels. Parts with lower priority */
                                /* aren't played first when a device runs out of */
                                /* notes */
    BYTE    bRandomVariation;   /* when set, matching variations play in random order */
                                /* when clear, matching variations play sequentially */
} DMUS_IO_PARTREF;

typedef struct _DMUS_IO_STYLENOTE
{
    MUSIC_TIME  mtGridStart;    /* when this note occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this note lasts */
    short       nTimeOffset;    /* offset from mtGridStart */
    WORD        wMusicValue;    /* Position in scale. */
    BYTE        bVelocity;      /* Note velocity. */
    BYTE        bTimeRange;     /* Range to randomize start time. */
    BYTE        bDurRange;      /* Range to randomize duration. */
    BYTE        bVelRange;      /* Range to randomize velocity. */
    BYTE        bInversionID;   /* Identifies inversion group to which this note belongs */
    BYTE        bPlayModeFlags; /* Can override part */
} DMUS_IO_STYLENOTE;

typedef struct _DMUS_IO_STYLECURVE
{
    MUSIC_TIME  mtGridStart;    /* when this curve occurs */
    DWORD       dwVariation;    /* variation bits */
    MUSIC_TIME  mtDuration;     /* how long this curve lasts */
    MUSIC_TIME  mtResetDuration;/* how long after the end of the curve to reset the curve */
    short       nTimeOffset;    /* offset from mtGridStart */
    short       nStartValue;    /* curve's start value */
    short       nEndValue;      /* curve's end value */
    short       nResetValue;    /* the value to which to reset the curve */
    BYTE        bEventType;     /* type of curve */
    BYTE        bCurveShape;    /* shape of curve */
    BYTE        bCCData;        /* CC# */
    BYTE        bFlags;         /* Bit 1=TRUE means to send nResetValue. Otherwise, don't.
                                   Other bits are reserved. */
} DMUS_IO_STYLECURVE;

typedef struct _DMUS_IO_MOTIFSETTINGS
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than mtLoopStart. By default equal to length of motif. */
    DWORD       dwResolution;   /* Default resolution. */
} DMUS_IO_MOTIFSETTINGS;

#pragma pack()


/*
RIFF
(
    'DMST'          // Style
    <styh-ck>       // Style header chunk
    <guid-ck>       // Every Style has a GUID
    [<UNFO-list>]   // Name, author, copyright info., comments
    [<vers-ck>]     // version chunk
    <part-list>...  // List of parts in the Style, used by patterns
    <pttn-list>...  // List of patterns in the Style
    <DMBD-form>...  // List of bands in the Style
    [<motf-list>]   // List of motifs in the Style
    [<prrf-list>]   // List of chord map references in the Style
)

    // <styh-ck>
    styh
    (
        <DMUS_IO_STYLE>
    )

    // <guid-ck>
    guid
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <part-list>
    LIST
    (
        'part'
        <prth-ck>       // Part header chunk
        [<UNFO-list>]
        [<note-ck>]     // List of notes in Part
        [<crve-ck>]     // List of curves in Part
    )

        // <orth-ck>
        prth
        (
            <DMUS_IO_STYLEPART>
        )

        // <note-ck>
        'note'
        (
            // sizeof DMUS_IO_STYLENOTE:DWORD
            <DMUS_IO_STYLENOTE>...
        )

        // <crve-ck>
        'crve'
        (
            // sizeof DMUS_IO_STYLECURVE:DWORD
            <DMUS_IO_STYLECURVE>...
        )

    // <pttn-list>
    LIST
    (
        'pttn'
        <ptnh-ck>       // Pattern header chunk
        <rhtm-ck>       // List of rhythms for chord matching
        [<UNFO-list>]
        [<mtfs-ck>]     // Motif settings chunk
        <pref-list>...  // List of part reference id's
    )

        // <ptnh-ck>
        ptnh
        (
            <DMUS_IO_PATTERN>
        )

        // <rhtm-ck>
        'rhtm'
        (
            // DWORD's representing rhythms for chord matching based on number
            // of measures in the pattern
        )

        // pref-list
        LIST
        (
            'pref'
            <prfc-ck>   // part ref chunk
        )

        // <prfc-ck>
        prfc
        (
            <DMUS_IO_PARTREF>
        )

        // <mtfs-ck>
        mtfs
        (
            <DMUS_IO_MOTIFSETTINGS>
        )

    // <prrf-list>
    LIST
    (
        'prrf'
        // some number of <DMRF>
    )
*/

/* Chord and command file formats */

#define DMUS_FOURCC_CHORDTRACK_LIST         mmioFOURCC('c','o','r','d')
#define DMUS_FOURCC_CHORDTRACKHEADER_CHUNK  mmioFOURCC('c','r','d','h')
#define DMUS_FOURCC_CHORDTRACKBODY_CHUNK    mmioFOURCC('c','r','d','b')

#define DMUS_FOURCC_COMMANDTRACK_CHUNK      mmioFOURCC('c','m','n','d')

typedef struct _DMUS_IO_CHORD
{
    WCHAR       wszName[16];    /* Name of the chord */
    MUSIC_TIME  mtTime;         /* Time of this chord */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
} DMUS_IO_CHORD;

typedef struct _DMUS_IO_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_IO_SUBCHORD;

typedef struct _DMUS_IO_COMMAND
{
    MUSIC_TIME  mtTime;         /* Time of this command */
    WORD        wMeasure;       /* Measure this falls on */
    BYTE        bBeat;          /* Beat this falls on */
    BYTE        bCommand;       /* Command type (see #defines below) */
    BYTE        bGrooveLevel;   /* Groove level (0 if command is not a groove) */
    BYTE        bGrooveRange;   /* Groove range  */
} DMUS_IO_COMMAND;


/*

    // <cord-list>
    LIST
    (
        'cord'
        <crdh-ck>
        <crdb-ck>       // Chord body chunk
    )

        // <crdh-ck>
        crdh
        (
            // Scale: dword (upper 8 bits for root, lower 24 for scale)
        )

        // <crdb-ck>
        crdb
        (
            // sizeof DMUS_IO_CHORD:dword
            <DMUS_IO_CHORD>
            // # of DMUS_IO_SUBCHORDS:dword
            // sizeof DMUS_IO_SUBCHORDS:dword
            // a number of <DMUS_IO_SUBCHORD>
        )


    // <cmnd-list>
    'cmnd'
    (
        //sizeof DMUS_IO_COMMAND: DWORD
        <DMUS_IO_COMMAND>...
    )

*/

/*  File io for DirectMusic Tool and ToolGraph objects
*/

/* RIFF ids: */

#define DMUS_FOURCC_TOOLGRAPH_FORM  mmioFOURCC('D','M','T','G')
#define DMUS_FOURCC_TOOL_LIST       mmioFOURCC('t','o','l','l')
#define DMUS_FOURCC_TOOL_FORM       mmioFOURCC('D','M','T','L')
#define DMUS_FOURCC_TOOL_CHUNK      mmioFOURCC('t','o','l','h')

/* io structures: */

typedef struct _DMUS_IO_TOOL_HEADER
{
    GUID        guidClassID;    /* Class id of tool. */
    long        lIndex;         /* Position in graph. */
    DWORD       cPChannels;     /* Number of items in channels array. */
    FOURCC      ckid;           /* chunk ID of tool's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid. */
    DWORD       dwPChannels[1]; /* Array of PChannels, size determined by cPChannels. */
} DMUS_IO_TOOL_HEADER;

/*
RIFF
(
    'DMTG'          // DirectMusic ToolGraph chunk
    [<guid-ck>]     // GUID for ToolGraph
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <toll-list>     // List of Tools
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <toll-list>
    LIST
    (
        'toll'          // List of tools
        <DMTL-form>...  // Each tool is encapsulated in a RIFF chunk
    )

// <DMTL-form>      // Tools can be embedded in a graph or stored as separate files.
RIFF
(
    'DMTL'
    <tolh-ck>
    [<guid-ck>]     // Optional GUID for tool object instance (not to be confused with Class id in track header)
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Optional name, author, copyright info., comments
    [<data>]        // Tool data. Must be a RIFF readable chunk.
)

    // <tolh-ck>            // Tool header chunk
    (
        'tolh'
        <DMUS_IO_TOOL_HEADER>   // Tool header
    )
*/

/*  File io for DirectMusic Band Track object */


/* RIFF ids: */
#define DMUS_FOURCC_BANDTRACK_FORM  mmioFOURCC('D','M','B','T')
#define DMUS_FOURCC_BANDTRACK_CHUNK mmioFOURCC('b','d','t','h')
#define DMUS_FOURCC_BANDS_LIST      mmioFOURCC('l','b','d','l')
#define DMUS_FOURCC_BAND_LIST       mmioFOURCC('l','b','n','d')
#define DMUS_FOURCC_BANDITEM_CHUNK  mmioFOURCC('b','d','i','h')

/*  io structures */
typedef struct _DMUS_IO_BAND_TRACK_HEADER
{
    BOOL bAutoDownload;     /* Determines if Auto-Download is enabled. */
} DMUS_IO_BAND_TRACK_HEADER;

typedef struct _DMUS_IO_BAND_ITEM_HEADER
{
    MUSIC_TIME lBandTime;   /* Position in track list. */
} DMUS_IO_BAND_ITEM_HEADER;

/*
RIFF
(
    'DMBT'          // DirectMusic Band Track form-type
    [<bdth-ck>]     // Band track header
    [<guid-ck>]     // GUID for band track
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbdl-list>     // List of Band Lists
)

    // <bnth-ck>
    'bdth'
    (
        <DMUS_IO_BAND_TRACK_HEADER>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbdl-list>
    LIST
    (
        'lbdl'          // List of bands
        <lbnd-list>     // Each band is encapsulated in a list
    )

        // <lbnd-list>
        LIST
        (
            'lbnd'
            <bdih-ck>
            <DMBD-form> // Band
        )

            // <bdih-ck>            // band item header
            (
                <DMUS_IO_BAND_ITEM_HEADER>  // Band item header
            )
*/      


/*  File io for DirectMusic Band object
*/

/* RIFF ids: */

#define DMUS_FOURCC_BAND_FORM           mmioFOURCC('D','M','B','D')
#define DMUS_FOURCC_INSTRUMENTS_LIST    mmioFOURCC('l','b','i','l')
#define DMUS_FOURCC_INSTRUMENT_LIST     mmioFOURCC('l','b','i','n')
#define DMUS_FOURCC_INSTRUMENT_CHUNK    mmioFOURCC('b','i','n','s')

/* Flags for DMUS_IO_INSTRUMENT
 */
#define DMUS_IO_INST_PATCH          (1 << 0)        /* dwPatch is valid. */
#define DMUS_IO_INST_BANKSELECT     (1 << 1)        /* dwPatch contains a valid Bank Select MSB and LSB part */
#define DMUS_IO_INST_ASSIGN_PATCH   (1 << 3)        /* dwAssignPatch is valid */
#define DMUS_IO_INST_NOTERANGES     (1 << 4)        /* dwNoteRanges is valid */
#define DMUS_IO_INST_PAN            (1 << 5)        /* bPan is valid */
#define DMUS_IO_INST_VOLUME         (1 << 6 )       /* bVolume is valid */
#define DMUS_IO_INST_TRANSPOSE      (1 << 7)        /* nTranspose is valid */
#define DMUS_IO_INST_GM             (1 << 8)        /* Instrument is from GM collection */
#define DMUS_IO_INST_GS             (1 << 9)        /* Instrument is from GS collection */
#define DMUS_IO_INST_XG             (1 << 10)       /* Instrument is from XG collection */
#define DMUS_IO_INST_CHANNEL_PRIORITY (1 << 11)     /* dwChannelPriority is valid */
#define DMUS_IO_INST_USE_DEFAULT_GM_SET (1 << 12)   /* Always use the default GM set for this patch,  */
                                                    /* don't rely on the synth caps stating GM or GS in hardware. */

/*  io structures */
typedef struct _DMUS_IO_INSTRUMENT
{
    DWORD   dwPatch;            /* MSB, LSB and Program change to define instrument */
    DWORD   dwAssignPatch;      /* MSB, LSB and Program change to assign to instrument when downloading */
    DWORD   dwNoteRanges[4];    /* 128 bits; one for each MIDI note instrument needs to able to play */
    DWORD   dwPChannel;         /* PChannel instrument plays on */
    DWORD   dwFlags;            /* DMUS_IO_INST_ flags */
    BYTE    bPan;               /* Pan for instrument */
    BYTE    bVolume;            /* Volume for instrument */
    short   nTranspose;         /* Number of semitones to transpose notes */
    DWORD   dwChannelPriority;  /* Channel priority */
} DMUS_IO_INSTRUMENT;

/*
// <DMBD-form> bands can be embedded in other forms
RIFF
(
    'DMBD'          // DirectMusic Band chunk
    [<guid-ck>]     // GUID for band
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <lbil-list>     // List of Instruments
)

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <lbil-list>
    LIST
    (
        'lbil'          // List of instruments
        <lbin-list>     // Each instrument is encapsulated in a list
    )

        // <lbin-list>
        LIST
        (
            'lbin'
            <bins-ck>
            [<DMRF-list>]       // Optional reference to DLS Collection file.
        )

            // <bins-ck>            // Instrument chunk
            (
                'bins'
                <DMUS_IO_INSTRUMENT>    // Instrument header
            )
*/      

/*  File io for DirectMusic Segment object */

/* RIFF ids: */

#define DMUS_FOURCC_SEGMENT_FORM    mmioFOURCC('D','M','S','G')
#define DMUS_FOURCC_SEGMENT_CHUNK   mmioFOURCC('s','e','g','h')
#define DMUS_FOURCC_TRACK_LIST      mmioFOURCC('t','r','k','l')
#define DMUS_FOURCC_TRACK_FORM      mmioFOURCC('D','M','T','K')
#define DMUS_FOURCC_TRACK_CHUNK     mmioFOURCC('t','r','k','h')

/*  io structures:*/

typedef struct _DMUS_IO_SEGMENT_HEADER
{
    DWORD       dwRepeats;      /* Number of repeats. By default, 0. */
    MUSIC_TIME  mtLength;       /* Length, in music time. */
    MUSIC_TIME  mtPlayStart;    /* Start of playback. By default, 0. */
    MUSIC_TIME  mtLoopStart;    /* Start of looping portion. By default, 0. */
    MUSIC_TIME  mtLoopEnd;      /* End of loop. Must be greater than dwPlayStart. By default equal to length. */
    DWORD       dwResolution;   /* Default resolution. */
} DMUS_IO_SEGMENT_HEADER;

typedef struct _DMUS_IO_TRACK_HEADER
{
    GUID        guidClassID;    /* Class id of track. */
    DWORD       dwPosition;     /* Position in track list. */
    DWORD       dwGroup;        /* Group bits for track. */
    FOURCC      ckid;           /* chunk ID of track's data chunk if 0 fccType valid. */
    FOURCC      fccType;        /* list type if NULL ckid valid */
} DMUS_IO_TRACK_HEADER;

/*
RIFF
(
    'DMSG'          // DirectMusic Segment chunk
    <segh-ck>       // Segment header chunk
    [<guid-ck>]     // GUID for segment
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Name, author, copyright info., comments
    <trkl-list>     // List of Tracks
    [<DMTG-form>]   // Optional ToolGraph
)

    // <segh-ck>        
    'segh'
    (
        <DMUS_IO_SEGMENT_HEADER>
    )
    
    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )

    // <trkl-list>
    LIST
    (
        'trkl'          // List of tracks
        <DMTK-form>...  // Each track is encapsulated in a RIFF chunk
    )

// <DMTK-form>      // Tracks can be embedded in a segment or stored as separate files.
RIFF
(
    'DMTK'
    <trkh-ck>
    [<guid-ck>]     // Optional GUID for track object instance (not to be confused with Class id in track header)
    [<vers-ck>]     // Optional version info
    [<UNFO-list>]   // Optional name, author, copyright info., comments
    [<data>]        // Track data. Must be a RIFF readable chunk.
)

    // <trkh-ck>            // Track header chunk
    (
        'trkh'
        <DMUS_IO_TRACK_HEADER>  // Track header
    )
*/

/*  File io for DirectMusic reference chunk. 
    This is used to embed a reference to an object.
*/

/*  RIFF ids: */

#define DMUS_FOURCC_REF_LIST        mmioFOURCC('D','M','R','F')
#define DMUS_FOURCC_REF_CHUNK       mmioFOURCC('r','e','f','h')
#define DMUS_FOURCC_DATE_CHUNK      mmioFOURCC('d','a','t','e')
#define DMUS_FOURCC_NAME_CHUNK      mmioFOURCC('n','a','m','e')
#define DMUS_FOURCC_FILE_CHUNK      mmioFOURCC('f','i','l','e')

typedef struct _DMUS_IO_REFERENCE
{
    GUID    guidClassID;    /* Class id is always required. */
    DWORD   dwValidData;    /* Flags. */
} DMUS_IO_REFERENCE;

/*
LIST
(
    'DMRF'          // DirectMusic Reference chunk
    <refh-ck>       // Reference header chunk
    [<guid-ck>]     // Optional object GUID.
    [<date-ck>]     // Optional file date.
    [<name-ck>]     // Optional name.
    [<file-ck>]     // Optional file name.
    [<catg-ck>]     // Optional category name.
    [<vers-ck>]     // Optional version info.
)

    // <refh-ck>
    'refh'
    (
        <DMUS_IO_REFERENCE>
    )

    // <guid-ck>
    'guid'
    (
        <GUID>
    )

    // <date-ck>
    date
    (
        <FILETIME>
    )

    // <name-ck>
    name
    (
        // Name, stored as NULL terminated string of WCHARs
    )

    // <file-ck>
    file
    (
        // File name, stored as NULL terminated string of WCHARs
    )

    // <catg-ck>
    catg
    (
        // Category name, stored as NULL terminated string of WCHARs
    )

    // <vers-ck>
    vers
    (
        <DMUS_IO_VERSION>
    )
*/

/* Chord Maps */

/* runtime chunks */
#define DMUS_FOURCC_CHORDMAP_FORM       mmioFOURCC('D','M','P','R')
#define DMUS_FOURCC_IOCHORDMAP_CHUNK    mmioFOURCC('p','e','r','h')
#define DMUS_FOURCC_SUBCHORD_CHUNK      mmioFOURCC('c','h','d','t')
#define DMUS_FOURCC_CHORDENTRY_CHUNK    mmioFOURCC('c','h','e','h')
#define DMUS_FOURCC_SUBCHORDID_CHUNK    mmioFOURCC('s','b','c','n')
#define DMUS_FOURCC_IONEXTCHORD_CHUNK   mmioFOURCC('n','c','r','d')
#define DMUS_FOURCC_NEXTCHORDSEQ_CHUNK  mmioFOURCC('n','c','s','q')
#define DMUS_FOURCC_IOSIGNPOST_CHUNK    mmioFOURCC('s','p','s','h')
#define DMUS_FOURCC_CHORDNAME_CHUNK     mmioFOURCC('I','N','A','M')

/* runtime list chunks */
#define DMUS_FOURCC_CHORDENTRY_LIST     mmioFOURCC('c','h','o','e')
#define DMUS_FOURCC_CHORDMAP_LIST       mmioFOURCC('c','m','a','p')
#define DMUS_FOURCC_CHORD_LIST          mmioFOURCC('c','h','r','d')
#define DMUS_FOURCC_CHORDPALETTE_LIST   mmioFOURCC('c','h','p','l')
#define DMUS_FOURCC_CADENCE_LIST        mmioFOURCC('c','a','d','e')
#define DMUS_FOURCC_SIGNPOSTITEM_LIST   mmioFOURCC('s','p','s','t')

#define DMUS_FOURCC_SIGNPOST_LIST       mmioFOURCC('s','p','s','q')

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
/* DMUS_SIGNPOSTF_ flags are also used in templates (DMUS_IO_SIGNPOST) */
#define DMUS_SIGNPOSTF_A        1      
#define DMUS_SIGNPOSTF_B        2
#define DMUS_SIGNPOSTF_C        4
#define DMUS_SIGNPOSTF_D        8
#define DMUS_SIGNPOSTF_E        0x10
#define DMUS_SIGNPOSTF_F        0x20
#define DMUS_SIGNPOSTF_LETTER   (DMUS_SIGNPOSTF_A | DMUS_SIGNPOSTF_B | DMUS_SIGNPOSTF_C | DMUS_SIGNPOSTF_D | DMUS_SIGNPOSTF_E | DMUS_SIGNPOSTF_F)
#define DMUS_SIGNPOSTF_1        0x100
#define DMUS_SIGNPOSTF_2        0x200
#define DMUS_SIGNPOSTF_3        0x400
#define DMUS_SIGNPOSTF_4        0x800
#define DMUS_SIGNPOSTF_5        0x1000
#define DMUS_SIGNPOSTF_6        0x2000
#define DMUS_SIGNPOSTF_7        0x4000
#define DMUS_SIGNPOSTF_ROOT     (DMUS_SIGNPOSTF_1 | DMUS_SIGNPOSTF_2 | DMUS_SIGNPOSTF_3 | DMUS_SIGNPOSTF_4 | DMUS_SIGNPOSTF_5 | DMUS_SIGNPOSTF_6 | DMUS_SIGNPOSTF_7)
#define DMUS_SIGNPOSTF_CADENCE  0x8000

/* values for dwChord field of DMUS_IO_PERS_SIGNPOST */
#define DMUS_SPOSTCADENCEF_1  2   /* Use the first cadence chord. */
#define DMUS_SPOSTCADENCEF_2  4   /* Use the second cadence chord. */

/* run time data structs */
typedef struct _DMUS_IO_CHORDMAP
{
    WCHAR   wszLoadName[20];
    DWORD   dwScalePattern;
    DWORD   dwFlags;
} DMUS_IO_CHORDMAP;

typedef struct _DMUS_IO_CHORDMAP_SUBCHORD
{
    DWORD   dwChordPattern;
    DWORD   dwScalePattern;
    DWORD   dwInvertPattern;
    BYTE    bChordRoot;
    BYTE    bScaleRoot;
    WORD    wCFlags;
    DWORD   dwLevels;   /* parts or which subchord levels this chord supports */
} DMUS_IO_CHORDMAP_SUBCHORD;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SUBCHORD DMUS_IO_PERS_SUBCHORD;

typedef struct _DMUS_IO_CHORDENTRY
{
    DWORD   dwFlags;
    WORD    wConnectionID;  /* replaces runtime "pointer to this" */
} DMUS_IO_CHORDENTRY;

typedef struct _DMUS_IO_NEXTCHORD
{
    DWORD   dwFlags;
    WORD    nWeight;
    WORD    wMinBeats;
    WORD    wMaxBeats;
    WORD    wConnectionID;  /* points to an ioChordEntry */
} DMUS_IO_NEXTCHORD;

typedef struct _DMUS_IO_CHORDMAP_SIGNPOST
{
    DWORD   dwChords;   /* 1bit per group */
    DWORD   dwFlags;
} DMUS_IO_CHORDMAP_SIGNPOST;

/* Legacy name... */
typedef DMUS_IO_CHORDMAP_SIGNPOST DMUS_IO_PERS_SIGNPOST;

/*
RIFF
(
    'DMPR'
    <perh-ck>           // Chord map header chunk
    [<guid-ck>]         // guid chunk
    [<vers-ck>]         // version chunk (two DWORDS)
    [<UNFO-list>]       // Unfo chunk
    <chdt-ck>           // subchord database
    <chpl-list>         // chord palette
    <cmap-list>         // chord map
    <spsq-list>         // signpost list
 )

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
                                <cheh-ck>   // chord entry data
                                <chrd-list> // chord definition
                                <ncsq-ck>   // connecting(next) chords
                     )

<chrd-list> ::= LIST('chrd' 
                                <INAM-ck>   // name of chord in wide char format
                                <sbcn-ck>   // list of subchords composing chord
                    )

<chpl-list> ::= LIST('chpl' 
                                <chrd-list> ... // chord definition
                    )

<spsq-list> ::== LIST('spsq' <spst-list> ... )

<spst-list> ::= LIST('spst'
                             <spsh-ck>
                             <chrd-list>
                             [<cade-list>]
                    )

<cade-list> ::= LIST('cade' <chrd-list> ...)

<perh-ck> ::= perh(<DMUS_IO_CHORDMAP>)

<chdt-ck> ::= chdt(<cbChordSize::WORD>
                   <DMUS_IO_PERS_SUBCHORD> ... )

<cheh-ck> ::= cheh(<DMUS_IO_CHORDENTRY>)

<sbcn-ck> ::= sbcn(<cSubChordID:WORD> ...)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> 
                   <DMUS_IO_NEXTCHORD>...)

<spsh-ck> ::= spsh(<DMUS_IO_PERS_SIGNPOST>)

*/

/* Signpost tracks */

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK     mmioFOURCC( 's', 'g', 'n', 'p' )


typedef struct _DMUS_IO_SIGNPOST
{
    MUSIC_TIME  mtTime;
    DWORD       dwChords;
    WORD        wMeasure;
} DMUS_IO_SIGNPOST;

/*

    // <sgnp-list>
    'sgnp'
    (
        //sizeof DMUS_IO_SIGNPOST: DWORD
        <DMUS_IO_SIGNPOST>...
    )

*/

#define DMUS_FOURCC_MUTE_CHUNK  mmioFOURCC('m','u','t','e')

typedef struct _DMUS_IO_MUTE
{
    MUSIC_TIME  mtTime;
    DWORD       dwPChannel;
    DWORD       dwPChannelMap;
} DMUS_IO_MUTE;

/*

    // <mute-list>
    'mute'
    (
        //sizeof DMUS_IO_MUTE:DWORD
        <DMUS_IO_MUTE>...
    )


*/

/* Used for both style and chord map tracks */

#define DMUS_FOURCC_TIME_STAMP_CHUNK    mmioFOURCC('s', 't', 'm', 'p')

/* Style tracks */

#define DMUS_FOURCC_STYLE_TRACK_LIST    mmioFOURCC('s', 't', 't', 'r')
#define DMUS_FOURCC_STYLE_REF_LIST      mmioFOURCC('s', 't', 'r', 'f')

/*

    // <sttr-list>
    LIST('sttr'
    (
        // some number of <strf-list>
    )

    // <strf-list>
    LIST('strf'
    (
        <stmp-ck>
        <DMRF>
    )

    // <stmp-ck> defined in ..\dmcompos\dmcompp.h

*/

/* Chord map tracks */

#define DMUS_FOURCC_PERS_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERS_REF_LIST   mmioFOURCC('p', 'f', 'r', 'f')

/*

    // <pftr-list>
    LIST('pftr'
    (
        // some number of <pfrf-list>
    )

    // <pfrf-list>
    LIST('pfrf'
    (
        <stmp-ck>
        <DMRF>
    )

  // <stmp-ck>
  'stmp'
  (
    // time:DWORD
  )



*/

#define DMUS_FOURCC_TEMPO_TRACK     mmioFOURCC('t','e','t','r')

/*
    // tempo list
    'tetr'
    (
        // sizeof DMUS_IO_TEMPO_ITEM: DWORD
        <DMUS_IO_TEMPO_ITEM>...
    )
  */

#define DMUS_FOURCC_SEQ_TRACK       mmioFOURCC('s','e','q','t')
#define DMUS_FOURCC_SEQ_LIST        mmioFOURCC('e','v','t','l')
#define DMUS_FOURCC_CURVE_LIST      mmioFOURCC('c','u','r','l')

/*
    // sequence track
    'seqt'
    (
        // sequence list
        'evtl'
        (
            // sizeof DMUS_IO_SEQ_ITEM: DWORD
            <DMUS_IO_SEQ_ITEM>...
        )
        // curve list
        'curl'
        (
            // sizeof DMUS_IO_CURVE_ITEM: DWORD
            <DMUS_IO_CURVE_ITEM>...
        )
    )
*/

#define DMUS_FOURCC_SYSEX_TRACK     mmioFOURCC('s','y','e','x')

/*
    // sysex track
    'syex'
    (
        // list of:
        // {
        //      <DMUS_IO_SYSEX_ITEM>
        //      sys-ex: data
        // }...
    )
*/

#define DMUS_FOURCC_TIMESIGNATURE_TRACK mmioFOURCC('t','i','m','s')

/*
    // time signature track
    'tims'
    (
        // size of DMUS_IO_TIMESIGNATURE_ITEM : DWORD
        <DMUS_IO_TIMESIGNATURE_ITEM>...
    )
*/

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICF_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\inc\dmusici.h ===
/************************************************************************
*                                                                       *
*   dmusici.h -- This module contains the API for the                   *
*                DirectMusic performance layer                          *
*                                                                       *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef _DMUSICI_
#define _DMUSICI_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>
#include "dmusicc.h"

#include <pshpack8.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef WORD            TRANSITION_TYPE;
typedef __int64         REFERENCE_TIME;
typedef long            MUSIC_TIME;

#define DMUS_PPQ        768     /* parts per quarter note */

interface IDirectMusic;
interface IDirectMusicTrack;
interface IDirectMusicPerformance;
interface IDirectMusicTool;
interface IDirectMusicSegment;
interface IDirectMusicSegmentState;
interface IDirectMusicGraph;
interface IDirectMusicPort;
interface IDirectMusicBuffer;
interface IDirectMusicInstrument;
interface IDirectMusicDownloadedInstrument;
interface IDirectMusicBand;
interface IDirectMusicChordMap;
interface IDirectMusicLoader;
interface IDirectMusicObject;
#ifndef __cplusplus 
typedef interface IDirectMusic IDirectMusic;
typedef interface IDirectMusicTrack IDirectMusicTrack;
typedef interface IDirectMusicPerformance IDirectMusicPerformance;
typedef interface IDirectMusicTool IDirectMusicTool;
typedef interface IDirectMusicSegment IDirectMusicSegment;
typedef interface IDirectMusicSegmentState IDirectMusicSegmentState;
typedef interface IDirectMusicGraph IDirectMusicGraph;
typedef interface IDirectMusicPort IDirectMusicPort;
typedef interface IDirectMusicBuffer IDirectMusicBuffer;
typedef interface IDirectMusicInstrument IDirectMusicInstrument;
typedef interface IDirectMusicDownloadedInstrument IDirectMusicDownloadedInstrument;
typedef interface IDirectMusicBand IDirectMusicBand;
typedef interface IDirectMusicChordMap IDirectMusicChordMap;
typedef interface IDirectMusicObject IDirectMusicObject;
typedef interface IDirectMusicLoader IDirectMusicLoader;
#endif

typedef enum enumDMUS_COMMANDT_TYPES
{
    DMUS_COMMANDT_GROOVE            = 0,
    DMUS_COMMANDT_FILL              = 1,
    DMUS_COMMANDT_INTRO             = 2,
    DMUS_COMMANDT_BREAK             = 3,
    DMUS_COMMANDT_END               = 4,
    DMUS_COMMANDT_ENDANDINTRO       = 5
} DMUS_COMMANDT_TYPES;

typedef enum enumDMUS_SHAPET_TYPES
{
    DMUS_SHAPET_FALLING             = 0,
    DMUS_SHAPET_LEVEL               = 1,
    DMUS_SHAPET_LOOPABLE            = 2,
    DMUS_SHAPET_LOUD                = 3,
    DMUS_SHAPET_QUIET               = 4,
    DMUS_SHAPET_PEAKING             = 5,
    DMUS_SHAPET_RANDOM              = 6,
    DMUS_SHAPET_RISING              = 7,
    DMUS_SHAPET_SONG                = 8
}   DMUS_SHAPET_TYPES;

typedef enum enumDMUS_COMPOSEF_FLAGS
{       
    DMUS_COMPOSEF_NONE              = 0,
    DMUS_COMPOSEF_ALIGN             = 0x1,
    DMUS_COMPOSEF_OVERLAP           = 0x2,
    DMUS_COMPOSEF_IMMEDIATE         = 0x4,
    DMUS_COMPOSEF_GRID              = 0x8,
    DMUS_COMPOSEF_BEAT              = 0x10,
    DMUS_COMPOSEF_MEASURE           = 0x20,
    DMUS_COMPOSEF_AFTERPREPARETIME  = 0x40,
    DMUS_COMPOSEF_MODULATE          = 0x1000,
    DMUS_COMPOSEF_LONG              = 0x2000
}   DMUS_COMPOSEF_FLAGS;

#define DMUS_PMSG_PART                                                                              \
    DWORD               dwSize;                                                                     \
    REFERENCE_TIME      rtTime;             /* real time (in 100 nanosecond increments) */          \
    MUSIC_TIME          mtTime;             /* music time */                                        \
    DWORD               dwFlags;            /* various bits (see DMUS_PMSG_FLAGS enumeration) */    \
    DWORD               dwPChannel;         /* Performance Channel. The Performance can */          \
                                            /* use this to determine the port/channel. */           \
    DWORD               dwVirtualTrackID;   /* virtual track ID */                                  \
    IDirectMusicTool*   pTool;              /* tool interface pointer */                            \
    IDirectMusicGraph*  pGraph;             /* tool graph interface pointer */                      \
    DWORD               dwType;             /* PMSG type (see DMUS_PMSGT_TYPES defines) */              \
    DWORD               dwVoiceID;          /* unique voice id which allows synthesizers to */      \
                                            /* identify a specific event. For DirectX 6.0, */       \
                                            /* this field should always be 0. */                    \
    DWORD               dwGroupID;          /* Track group id */                                 \
    IUnknown*           punkUser;           /* user com pointer, auto released upon PMSG free */

/* every DMUS_PMSG is based off of this structure. The Performance needs 
   to access these members consistently in every PMSG that goes through it. */
typedef struct _DMUS_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

} DMUS_PMSG;

/* DMUS_PMSGF_FLAGS fill the DMUS_PMSG's dwFlags member */
typedef enum enumDMUS_PMSGF_FLAGS
{
    DMUS_PMSGF_REFTIME          = 1,      /* if rtTime is valid */
    DMUS_PMSGF_MUSICTIME        = 2,      /* if mtTime is valid */
    DMUS_PMSGF_TOOL_IMMEDIATE   = 4,      /* if PMSG should be processed immediately */ 
    DMUS_PMSGF_TOOL_QUEUE       = 8,      /* if PMSG should be processed a little early, at Queue time */
    DMUS_PMSGF_TOOL_ATTIME      = 16,     /* if PMSG should be processed at the time stamp */
    DMUS_PMSGF_TOOL_FLUSH       = 32      /* if PMSG is being flushed */
    /* The values of DMUS_TIME_RESOLVE_FLAGS may also be used inside the */
    /* DMUS_PMSG's dwFlags member. */
} DMUS_PMSGF_FLAGS;

/* DMUS_PMSGT_TYPES fill the DMUS_PMSG's dwType member */
typedef enum enumDMUS_PMSGT_TYPES
{
    DMUS_PMSGT_MIDI             = 0,      /* MIDI short message */
    DMUS_PMSGT_NOTE             = 1,      /* Interactive Music Note */
    DMUS_PMSGT_SYSEX            = 2,      /* MIDI long message (system exclusive message) */
    DMUS_PMSGT_NOTIFICATION     = 3,      /* Notification message */
    DMUS_PMSGT_TEMPO            = 4,      /* Tempo message */
    DMUS_PMSGT_CURVE            = 5,      /* Control change / pitch bend, etc. curve */
    DMUS_PMSGT_TIMESIG          = 6,      /* Time signature */
    DMUS_PMSGT_PATCH            = 7,      /* Patch changes */
    DMUS_PMSGT_TRANSPOSE        = 8,      /* Transposition messages */
    DMUS_PMSGT_CHANNEL_PRIORITY = 9,      /* Channel priority */
    DMUS_PMSGT_STOP             = 10,     /* Stop message */
    DMUS_PMSGT_DIRTY            = 11,     /* Tells Tools that cache GetParam() info to refresh */
    DMUS_PMSGT_USER             = 255     /* User message */
} DMUS_PMSGT_TYPES;

/* DMUS_SEGF_FLAGS correspond to IDirectMusicPerformance::PlaySegment, and other API */
typedef enum enumDMUS_SEGF_FLAGS
{
    DMUS_SEGF_REFTIME           = 64,     /* time parameter is in reference time  */
    DMUS_SEGF_SECONDARY         = 128,    /* secondary segment */
    DMUS_SEGF_QUEUE             = 256,    /* queue at the end of the primary segment queue (primary only) */
    DMUS_SEGF_CONTROL           = 512,    /* play as a control track (secondary segments only) */
    DMUS_SEGF_AFTERPREPARETIME  = 1<<10,  /* play after the prepare time (See IDirectMusicPerformance::GetPrepareTime) */
    DMUS_SEGF_GRID              = 1<<11,  /* play on grid boundary */
    DMUS_SEGF_BEAT              = 1<<12,  /* play on beat boundary */
    DMUS_SEGF_MEASURE           = 1<<13,  /* play on measure boundary */
    DMUS_SEGF_DEFAULT           = 1<<14,  /* use segment's default boundary */
    DMUS_SEGF_NOINVALIDATE      = 1<<15   /* play without invalidating the currently playing segment(s) */
} DMUS_SEGF_FLAGS;

/* DMUS_TIME_RESOLVE_FLAGS correspond to IDirectMusicPerformance::GetResolvedTime, and can */
/* also be used interchangeably with the corresponding DMUS_SEGF_FLAGS, since their values */
/* are intentionally the same */
typedef enum enumDMUS_TIME_RESOLVE_FLAGS
{
    DMUS_TIME_RESOLVE_AFTERPREPARETIME  = 1<<10,  /* resolve to a time after the prepare time */
    DMUS_TIME_RESOLVE_GRID              = 1<<11,  /* resolve to a time on a grid boundary */
    DMUS_TIME_RESOLVE_BEAT              = 1<<12,  /* resolve to a time on a beat boundary */
    DMUS_TIME_RESOLVE_MEASURE           = 1<<13   /* resolve to a time on a measure boundary */
} DMUS_TIME_RESOLVE_FLAGS;

/* The following flags are sent in the IDirectMusicTrack::Play() method */
/* inside the dwFlags parameter */
typedef enum enumDMUS_TRACKF_FLAGS
{
    DMUS_TRACKF_SEEK            = 1,      /* set on a seek */
    DMUS_TRACKF_LOOP            = 2,      /* set on a loop (repeat) */
    DMUS_TRACKF_START           = 4,      /* set on first call to Play */
    DMUS_TRACKF_FLUSH           = 8,      /* set when this call is in response to a flush on the perfomance */
    DMUS_TRACKF_DIRTY           = 16,     /* set when the track should consider any cached values from a previous call to GetParam to be invalidated */
} DMUS_TRACKF_FLAGS;

#define DMUS_MAXSUBCHORD 8

typedef struct _DMUS_SUBCHORD
{
    DWORD   dwChordPattern;     /* Notes in the subchord */
    DWORD   dwScalePattern;     /* Notes in the scale */
    DWORD   dwInversionPoints;  /* Where inversions can occur */
    DWORD   dwLevels;           /* Which levels are supported by this subchord */
    BYTE    bChordRoot;         /* Root of the subchord */
    BYTE    bScaleRoot;         /* Root of the scale */
} DMUS_SUBCHORD;

typedef struct _DMUS_CHORD_KEY
{
    WCHAR           wszName[16];        /* Name of the chord */
    WORD            wMeasure;           /* Measure this falls on */
    BYTE            bBeat;              /* Beat this falls on */
    BYTE            bSubChordCount;     /* Number of chords in the list of subchords */
    DMUS_SUBCHORD   SubChordList[DMUS_MAXSUBCHORD]; /* List of sub chords */
    DWORD           dwScale;            /* Scale underlying the entire chord */
    BYTE            bKey;               /* Key underlying the entire chord */
} DMUS_CHORD_KEY;

/* DMUS_NOTE_PMSG */
typedef struct _DMUS_NOTE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME mtDuration;     /* duration */
    WORD    wMusicValue;       /* Description of note in chord and key. */
    WORD    wMeasure;          /* Measure in which this note occurs */
    short   nOffset;           /* Offset from grid at which this note occurs */
    BYTE    bBeat;             /* Beat (in measure) at which this note occurs */
    BYTE    bGrid;             /* Grid offset from beat at which this note occurs */
    BYTE    bVelocity;         /* Note velocity */
    BYTE    bFlags;            /* see DMUS_NOTE_FLAGS */
    BYTE    bTimeRange;        /* Range to randomize time. */
    BYTE    bDurRange;         /* Range to randomize duration. */
    BYTE    bVelRange;         /* Range to randomize velocity. */
    BYTE    bPlayModeFlags;    /* Play mode */
    BYTE    bSubChordLevel;    /* Which subchord level this note uses.  */
    BYTE    bMidiValue;        /* The MIDI note value, converted from wMusicValue */
    char    cTranspose;        /* Transposition to add to midi note value after converted from wMusicValue. */
} DMUS_NOTE_PMSG;

typedef enum enumDMUS_NOTEF_FLAGS
{
    DMUS_NOTEF_NOTEON = 1,     /* Set if this is a MIDI Note On. Otherwise, it is MIDI Note Off */
} DMUS_NOTEF_FLAGS;

/* The DMUS_PLAYMODE_FLAGS are used to determine how to convert wMusicValue
   into the appropriate bMidiValue.
*/

typedef enum enumDMUS_PLAYMODE_FLAGS
{
    DMUS_PLAYMODE_KEY_ROOT          = 1,  /* Transpose on top of the key root. */
    DMUS_PLAYMODE_CHORD_ROOT        = 2,  /* Transpose on top of the chord root. */
    DMUS_PLAYMODE_SCALE_INTERVALS   = 4,  /* Use scale intervals from scale pattern. */
    DMUS_PLAYMODE_CHORD_INTERVALS   = 8,  /* Use chord intervals from chord pattern. */
    DMUS_PLAYMODE_NONE              = 16, /* No mode. Indicates the parent part's mode should be used. */
} DMUS_PLAYMODE_FLAGS;

/* The following are playback modes that can be created by combining the DMUS_PLAYMODE_FLAGS
   in various ways:
*/

/* Fixed. wMusicValue holds final MIDI note value. This is used for drums, sound effects, and sequenced
   notes that should not be transposed by the chord or scale.
*/
#define DMUS_PLAYMODE_FIXED             0  
/* In fixed to key, the musicvalue is again a fixed MIDI value, but it
   is transposed on top of the key root. 
*/
#define DMUS_PLAYMODE_FIXEDTOKEY        DMUS_PLAYMODE_KEY_ROOT
/* In fixed to chord, the musicvalue is also a fixed MIDI value, but it
   is transposed on top of the chord root. 
*/
#define DMUS_PLAYMODE_FIXEDTOCHORD      DMUS_PLAYMODE_CHORD_ROOT
/* In Pedalpoint, the key root is used and the notes only track the intervals in
   the scale. The chord root and intervals are completely ignored. This is useful
   for melodic lines that play relative to the key root.
*/
#define DMUS_PLAYMODE_PEDALPOINT        (DMUS_PLAYMODE_KEY_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* In the Melodic mode, the chord root is used but the notes only track the intervals in
   the scale. The key root and chord intervals are completely ignored. This is useful
   for melodic lines that play relative to the chord root. 
*/
#define DMUS_PLAYMODE_MELODIC           (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_SCALE_INTERVALS)
/* Normal chord mode is the prevalent playback mode. 
   The notes track the intervals in the chord, which is based on the chord root. 
   If there is a scale component to the MusicValue, the additional intervals 
   are pulled from the scale and added.
   If the chord does not have an interval to match the chord component of
   the MusicValue, the note is silent.
*/
#define DMUS_PLAYMODE_NORMALCHORD       (DMUS_PLAYMODE_CHORD_ROOT | DMUS_PLAYMODE_CHORD_INTERVALS)
/* If it is desirable to play a note that is above the top of the chord, the
   always play mode (known as "purpleized" in a former life) finds a position
   for the note by using intervals from the scale. Essentially, this mode is
   a combination of the Normal and Melodic playback modes, where a failure
   in Normal causes a second try in Melodic mode.
*/
#define DMUS_PLAYMODE_ALWAYSPLAY        (DMUS_PLAYMODE_MELODIC | DMUS_PLAYMODE_NORMALCHORD)

/*  Legacy names for modes... */
#define DMUS_PLAYMODE_PURPLEIZED        DMUS_PLAYMODE_ALWAYSPLAY
#define DMUS_PLAYMODE_SCALE_ROOT        DMUS_PLAYMODE_KEY_ROOT
#define DMUS_PLAYMODE_FIXEDTOSCALE      DMUS_PLAYMODE_FIXEDTOKEY


/* DMUS_MIDI_PMSG */
typedef struct _DMUS_MIDI_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    bStatus;
    BYTE    bByte1;
    BYTE    bByte2;
    BYTE    bPad[1];
} DMUS_MIDI_PMSG;

/* DMUS_PATCH_PMSG */
typedef struct _DMUS_PATCH_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    BYTE    byInstrument;
    BYTE    byMSB;
    BYTE    byLSB;
    BYTE    byPad[1];
} DMUS_PATCH_PMSG;

/* DMUS_TRANSPOSE_PMSG */
typedef struct _DMUS_TRANSPOSE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    short   nTranspose;
} DMUS_TRANSPOSE_PMSG;

/* DMUS_CHANNEL_PRIORITY_PMSG */
typedef struct _DMUS_CHANNEL_PRIORITY_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwChannelPriority;
} DMUS_CHANNEL_PRIORITY_PMSG;

/* DMUS_TEMPO_PMSG */
typedef struct _DMUS_TEMPO_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    double  dblTempo;                       /* the tempo */
} DMUS_TEMPO_PMSG;

#define DMUS_TEMPO_MAX          1000
#define DMUS_TEMPO_MIN          1

#define DMUS_MASTERTEMPO_MAX    100.0f
#define DMUS_MASTERTEMPO_MIN    0.01f

/* DMUS_SYSEX_PMSG */
typedef struct _DMUS_SYSEX_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DWORD   dwLen;          /* length of the data */
    BYTE    abData[1];      /* array of data, length equal to dwLen */
} DMUS_SYSEX_PMSG;

/* DMUS_CURVE_PMSG */
typedef struct _DMUS_CURVE_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    MUSIC_TIME      mtDuration;      /* how long this curve lasts */
    MUSIC_TIME      mtOriginalStart; /* must be set to either zero when this PMSG is created or to the original mtTime of the curve */
    MUSIC_TIME      mtResetDuration; /* how long after the curve is finished to reset to the
                                        reset value, nResetValue */
    short           nStartValue;     /* curve's start value */
    short           nEndValue;       /* curve's end value */
    short           nResetValue;     /* curve's reset value, sent after mtResetDuration or
                                        upon a flush or invalidation */
    WORD            wMeasure;        /* Measure in which this curve occurs */
    short           nOffset;         /* Offset from grid at which this curve occurs */
    BYTE            bBeat;           /* Beat (in measure) at which this curve occurs */
    BYTE            bGrid;           /* Grid offset from beat at which this curve occurs */
    BYTE            bType;           /* type of curve */
    BYTE            bCurveShape;     /* shape of curve */
    BYTE            bCCData;         /* CC# if this is a control change type */
    BYTE            bFlags;          /* set to 1 if the nResetValue must be sent when the 
                                        time is reached or an invalidate occurs because
                                        of a transition. If 0, the curve stays
                                        permanently stuck at the new value. All bits besides
                                        1 are reserved. */

} DMUS_CURVE_PMSG;

typedef enum enumDMUS_CURVE_FLAGS
{
    DMUS_CURVE_RESET = 1,           /* Set if the curve needs to be reset. */
} DMUS_CURVE_FLAGS;


#define DMUS_CURVE_RESET    1        

/* Curve shapes */
enum
{ 
    DMUS_CURVES_LINEAR  = 0,
    DMUS_CURVES_INSTANT = 1,
    DMUS_CURVES_EXP     = 2,
    DMUS_CURVES_LOG     = 3,
    DMUS_CURVES_SINE    = 4
};
/* curve types */
#define DMUS_CURVET_PBCURVE      0x03
#define DMUS_CURVET_CCCURVE      0x04
#define DMUS_CURVET_MATCURVE     0x05
#define DMUS_CURVET_PATCURVE     0x06

/* DMUS_TIMESIG_PMSG */
typedef struct _DMUS_TIMESIG_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    /* Time signatures define how many beats per measure, which note receives */
    /* the beat, and the grid resolution. */
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIG_PMSG;

/* notification type values */
/* The following correspond to GUID_NOTIFICATION_SEGMENT */
#define DMUS_NOTIFICATION_SEGSTART      0
#define DMUS_NOTIFICATION_SEGEND        1
#define DMUS_NOTIFICATION_SEGALMOSTEND  2
#define DMUS_NOTIFICATION_SEGLOOP       3
#define DMUS_NOTIFICATION_SEGABORT      4
/* The following correspond to GUID_NOTIFICATION_PERFORMANCE */
#define DMUS_NOTIFICATION_MUSICSTARTED  0
#define DMUS_NOTIFICATION_MUSICSTOPPED  1
/* The following corresponds to GUID_NOTIFICATION_MEASUREANDBEAT */
#define DMUS_NOTIFICATION_MEASUREBEAT   0
/* The following corresponds to GUID_NOTIFICATION_CHORD */
#define DMUS_NOTIFICATION_CHORD         0
/* The following correspond to GUID_NOTIFICATION_COMMAND */
#define DMUS_NOTIFICATION_GROOVE        0
#define DMUS_NOTIFICATION_EMBELLISHMENT 1

/* DMUS_NOTIFICATION_PMSG */
typedef struct _DMUS_NOTIFICATION_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    GUID    guidNotificationType;
    DWORD   dwNotificationOption;
    DWORD   dwField1;
    DWORD   dwField2;
} DMUS_NOTIFICATION_PMSG;


#define DMUS_MAX_NAME           64         /* Maximum object name length. */
#define DMUS_MAX_CATEGORY       64         /* Maximum object category name length. */
#define DMUS_MAX_FILENAME       MAX_PATH
    
typedef struct _DMUS_VERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DMUS_VERSION, FAR *LPDMUS_VERSION;

/* Time Signature structure, used by IDirectMusicStyle */
/* Also used as a parameter for GetParam() and SetParam */
typedef struct _DMUS_TIMESIGNATURE
{
    MUSIC_TIME mtTime;
    BYTE    bBeatsPerMeasure;       /* beats per measure (top of time sig) */
    BYTE    bBeat;                  /* what note receives the beat (bottom of time sig.) */
                                    /* we can assume that 0 means 256th note */
    WORD    wGridsPerBeat;          /* grids per beat */
} DMUS_TIMESIGNATURE;

/*      The DMUSOBJECTDESC structure is used to communicate everything you could */
/*      possibly use to describe a DirectMusic object.  */

typedef struct _DMUS_OBJECTDESC
{
    DWORD          dwSize;                 /* Size of this structure. */
    DWORD          dwValidData;            /* Flags indicating which fields below are valid. */
    GUID           guidObject;             /* Unique ID for this object. */
    GUID           guidClass;              /* GUID for the class of object. */
    FILETIME       ftDate;                 /* Last edited date of object. */
    DMUS_VERSION   vVersion;               /* Version. */
    WCHAR          wszName[DMUS_MAX_NAME]; /* Name of object. */
    WCHAR          wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
    WCHAR          wszFileName[DMUS_MAX_FILENAME]; /* File path. */
    LONGLONG       llMemLength;            /* Size of Memory data. */
    LPBYTE         pbMemData;              /* Memory pointer for data. */
} DMUS_OBJECTDESC;

typedef DMUS_OBJECTDESC *LPDMUS_OBJECTDESC;

/*      Flags for dwValidData. When set, a flag indicates that the  */
/*      corresponding field in DMUSOBJECTDESC holds valid data. */

#define DMUS_OBJ_OBJECT         (1 << 0)     /* Object GUID is valid. */
#define DMUS_OBJ_CLASS          (1 << 1)     /* Class GUID is valid. */
#define DMUS_OBJ_NAME           (1 << 2)     /* Name is valid. */
#define DMUS_OBJ_CATEGORY       (1 << 3)     /* Category is valid. */
#define DMUS_OBJ_FILENAME       (1 << 4)     /* File path is valid. */
#define DMUS_OBJ_FULLPATH       (1 << 5)     /* Path is full path. */
#define DMUS_OBJ_URL            (1 << 6)     /* Path is URL. */
#define DMUS_OBJ_VERSION        (1 << 7)     /* Version is valid. */
#define DMUS_OBJ_DATE           (1 << 8)     /* Date is valid. */
#define DMUS_OBJ_LOADED         (1 << 9)     /* Object is currently loaded in memory. */
#define DMUS_OBJ_MEMORY         (1 << 10)    /* Object is pointed to by pbMemData. */

typedef IDirectMusicObject __RPC_FAR *LPDMUS_OBJECT;
typedef IDirectMusicLoader __RPC_FAR *LPDMUS_LOADER;
typedef IDirectMusicBand __RPC_FAR *LPDMUS_BAND;


#define DMUSB_LOADED    (1 << 0)        /* Set when band has been loaded */
#define DMUSB_DEFAULT   (1 << 1)        /* Set when band is default band for a style */

#undef  INTERFACE
#define INTERFACE  IDirectMusicBand
DECLARE_INTERFACE_(IDirectMusicBand, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicBand */
    STDMETHOD(CreateSegment)        (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(Download)             (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
    STDMETHOD(Unload)               (THIS_ IDirectMusicPerformance* pPerformance) PURE;     
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicObject
DECLARE_INTERFACE_(IDirectMusicObject, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicObject */
    STDMETHOD(GetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetDescriptor)        (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(ParseDescriptor)      (THIS_ LPSTREAM pStream, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicLoader
DECLARE_INTERFACE_(IDirectMusicLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicLoader */
    STDMETHOD(GetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc,
                                           REFIID riid,
                                           LPVOID FAR *ppv) PURE;
    STDMETHOD(SetObject)            (THIS_ LPDMUS_OBJECTDESC pDesc) PURE;
    STDMETHOD(SetSearchDirectory)   (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzPath, 
                                           BOOL fClear) PURE;
    STDMETHOD(ScanDirectory)        (THIS_ REFGUID rguidClass, 
                                           WCHAR *pwzFileExtension, 
                                           WCHAR *pwzScanFileName) PURE;
    STDMETHOD(CacheObject)          (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ReleaseObject)        (THIS_ IDirectMusicObject * pObject) PURE;
    STDMETHOD(ClearCache)           (THIS_ REFGUID rguidClass) PURE;
    STDMETHOD(EnableCache)          (THIS_ REFGUID rguidClass, 
                                           BOOL fEnable) PURE;
    STDMETHOD(EnumObject)           (THIS_ REFGUID rguidClass, 
                                           DWORD dwIndex, 
                                           LPDMUS_OBJECTDESC pDesc) PURE;
};                                  

/*  Stream object supports IDirectMusicGetLoader interface to access loader while file parsing. */

#undef  INTERFACE
#define INTERFACE  IDirectMusicGetLoader
DECLARE_INTERFACE_(IDirectMusicGetLoader, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicGetLoader */
    STDMETHOD(GetLoader)            (THIS_ IDirectMusicLoader ** ppLoader) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicSegment */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegment
DECLARE_INTERFACE_(IDirectMusicSegment, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegment */
    STDMETHOD(GetLength)                (THIS_ MUSIC_TIME* pmtLength) PURE;
    STDMETHOD(SetLength)                (THIS_ MUSIC_TIME mtLength) PURE;
    STDMETHOD(GetRepeats)               (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(SetRepeats)               (THIS_ DWORD  dwRepeats) PURE;
    STDMETHOD(GetDefaultResolution)     (THIS_ DWORD* pdwResolution) PURE;
    STDMETHOD(SetDefaultResolution)     (THIS_ DWORD  dwResolution) PURE;
    STDMETHOD(GetTrack)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               IDirectMusicTrack** ppTrack) PURE;
    STDMETHOD(GetTrackGroup)            (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD* pdwGroupBits) PURE;
    STDMETHOD(InsertTrack)              (THIS_ IDirectMusicTrack* pTrack, 
                                               DWORD dwGroupBits) PURE;
    STDMETHOD(RemoveTrack)              (THIS_ IDirectMusicTrack* pTrack) PURE;
    STDMETHOD(InitPlay)                 (THIS_ IDirectMusicSegmentState** ppSegState, 
                                               IDirectMusicPerformance* pPerformance,
                                               DWORD dwFlags) PURE;
    STDMETHOD(GetGraph)                 (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(AddNotificationType)      (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)   (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(GetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               MUSIC_TIME* pmtNext, 
                                               void* pParam) PURE; 
    STDMETHOD(SetParam)                 (THIS_ REFGUID rguidType, 
                                               DWORD dwGroupBits, 
                                               DWORD dwIndex, 
                                               MUSIC_TIME mtTime, 
                                               void* pParam) PURE;
    STDMETHOD(Clone)                    (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd, 
                                               IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(SetStartPoint)            (THIS_ MUSIC_TIME mtStart) PURE;
    STDMETHOD(GetStartPoint)            (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(SetLoopPoints)            (THIS_ MUSIC_TIME mtStart, 
                                               MUSIC_TIME mtEnd) PURE;
    STDMETHOD(GetLoopPoints)            (THIS_ MUSIC_TIME* pmtStart, 
                                               MUSIC_TIME* pmtEnd) PURE;
    STDMETHOD(SetPChannelsUsed)         (THIS_ DWORD dwNumPChannels, 
                                               DWORD* paPChannels) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState */
#undef  INTERFACE
#define INTERFACE  IDirectMusicSegmentState
DECLARE_INTERFACE_(IDirectMusicSegmentState, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicSegmentState */
    STDMETHOD(GetRepeats)           (THIS_ DWORD* pdwRepeats) PURE;
    STDMETHOD(GetSegment )          (THIS_ IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetStartTime)         (THIS_ MUSIC_TIME* pmtStart) PURE;
    STDMETHOD(GetSeek)              (THIS_ MUSIC_TIME* pmtSeek) PURE;
    STDMETHOD(GetStartPoint)        (THIS_ MUSIC_TIME* pmtStart) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTrack */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTrack
DECLARE_INTERFACE_(IDirectMusicTrack, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicTrack */
    STDMETHOD(Init)                   (THIS_ IDirectMusicSegment* pSegment) PURE;
    STDMETHOD(InitPlay)               (THIS_ IDirectMusicSegmentState* pSegmentState, 
                                             IDirectMusicPerformance* pPerformance, 
                                             void** ppStateData, 
                                             DWORD dwVirtualTrackID,
                                             DWORD dwFlags) PURE;
    STDMETHOD(EndPlay)                (THIS_ void* pStateData) PURE;
    STDMETHOD(Play)                   (THIS_ void* pStateData, 
                                             MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             MUSIC_TIME mtOffset, 
                                             DWORD dwFlags, 
                                             IDirectMusicPerformance* pPerf, 
                                             IDirectMusicSegmentState* pSegSt, 
                                             DWORD dwVirtualID) PURE;
    STDMETHOD(GetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             MUSIC_TIME* pmtNext, 
                                             void* pParam) PURE; 
    STDMETHOD(SetParam)               (THIS_ REFGUID rguidType, 
                                             MUSIC_TIME mtTime, 
                                             void* pParam) PURE;
    STDMETHOD(IsParamSupported)       (THIS_ REFGUID rguidType) PURE;
    STDMETHOD(AddNotificationType)    (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType) (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(Clone)                  (THIS_ MUSIC_TIME mtStart, 
                                             MUSIC_TIME mtEnd, 
                                             IDirectMusicTrack** ppTrack) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance */
#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformance
DECLARE_INTERFACE_(IDirectMusicPerformance, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicPerformance */
    STDMETHOD(Init)                 (THIS_ IDirectMusic** ppDirectMusic,
                                           LPDIRECTSOUND pDirectSound,
                                           HWND hWnd) PURE;
    STDMETHOD(PlaySegment)          (THIS_ IDirectMusicSegment* pSegment, 
                                           DWORD dwFlags, 
                                           __int64 i64StartTime, 
                                           IDirectMusicSegmentState** ppSegmentState) PURE;
    STDMETHOD(Stop)                 (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegmentState, 
                                           MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetSegmentState)      (THIS_ IDirectMusicSegmentState** ppSegmentState, 
                                           MUSIC_TIME mtTime) PURE;
    STDMETHOD(SetPrepareTime)       (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetPrepareTime)       (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SetBumperLength)      (THIS_ DWORD dwMilliSeconds) PURE;
    STDMETHOD(GetBumperLength)      (THIS_ DWORD* pdwMilliSeconds) PURE;
    STDMETHOD(SendPMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(MusicToReferenceTime) (THIS_ MUSIC_TIME mtTime, 
                                           REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(ReferenceToMusicTime) (THIS_ REFERENCE_TIME rtTime, 
                                           MUSIC_TIME* pmtTime) PURE;
    STDMETHOD(IsPlaying)            (THIS_ IDirectMusicSegment* pSegment, 
                                           IDirectMusicSegmentState* pSegState) PURE;
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME* prtNow, 
                                           MUSIC_TIME* pmtNow) PURE;
    STDMETHOD(AllocPMsg)            (THIS_ ULONG cb, 
                                           DMUS_PMSG** ppPMSG) PURE;
    STDMETHOD(FreePMsg)             (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(GetGraph)             (THIS_ IDirectMusicGraph** ppGraph) PURE;
    STDMETHOD(SetGraph)             (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hNotification, 
                                           REFERENCE_TIME rtMinimum) PURE;
    STDMETHOD(GetNotificationPMsg)  (THIS_ DMUS_NOTIFICATION_PMSG** ppNotificationPMsg) PURE;
    STDMETHOD(AddNotificationType)  (THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(RemoveNotificationType)(THIS_ REFGUID rguidNotificationType) PURE;
    STDMETHOD(AddPort)              (THIS_ IDirectMusicPort* pPort) PURE;
    STDMETHOD(RemovePort)           (THIS_ IDirectMusicPort* pPort ) PURE;
    STDMETHOD(AssignPChannelBlock)  (THIS_ DWORD dwBlockNum, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup ) PURE;
    STDMETHOD(AssignPChannel)       (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort* pPort, 
                                           DWORD dwGroup, 
                                           DWORD dwMChannel ) PURE;
    STDMETHOD(PChannelInfo)         (THIS_ DWORD dwPChannel, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(DownloadInstrument)   (THIS_ IDirectMusicInstrument* pInst, 
                                           DWORD dwPChannel, 
                                           IDirectMusicDownloadedInstrument** ppDownInst, 
                                           DMUS_NOTERANGE* pNoteRanges, 
                                           DWORD dwNumNoteRanges, 
                                           IDirectMusicPort** ppPort, 
                                           DWORD* pdwGroup, 
                                           DWORD* pdwMChannel ) PURE;
    STDMETHOD(Invalidate)           (THIS_ MUSIC_TIME mtTime, 
                                           DWORD dwFlags) PURE;
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pParam) PURE; 
    STDMETHOD(SetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           void* pParam) PURE;
    STDMETHOD(GetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(SetGlobalParam)       (THIS_ REFGUID rguidType, 
                                           void* pParam, 
                                           DWORD dwSize) PURE;
    STDMETHOD(GetLatencyTime)       (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(GetQueueTime)         (THIS_ REFERENCE_TIME* prtTime) PURE;
    STDMETHOD(AdjustTime)           (THIS_ REFERENCE_TIME rtAmount) PURE;
    STDMETHOD(CloseDown)            (THIS) PURE;
    STDMETHOD(GetResolvedTime)      (THIS_ REFERENCE_TIME rtTime,
                                           REFERENCE_TIME* prtResolved,
                                           DWORD dwTimeResolveFlags) PURE;
    STDMETHOD(MIDIToMusic)          (THIS_ BYTE bMIDIValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           WORD *pwMusicValue) PURE;
    STDMETHOD(MusicToMIDI)          (THIS_ WORD wMusicValue,
                                           DMUS_CHORD_KEY* pChord,
                                           BYTE bPlayMode,
                                           BYTE bChordLevel,
                                           BYTE *pbMIDIValue) PURE;
    STDMETHOD(TimeToRhythm)         (THIS_ MUSIC_TIME mtTime,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           WORD *pwMeasure,
                                           BYTE *pbBeat,
                                           BYTE *pbGrid,
                                           short *pnOffset) PURE;
    STDMETHOD(RhythmToTime)         (THIS_ WORD wMeasure,
                                           BYTE bBeat,
                                           BYTE bGrid,
                                           short nOffset,
                                           DMUS_TIMESIGNATURE *pTimeSig,
                                           MUSIC_TIME *pmtTime) PURE;                                        
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicTool */
#undef  INTERFACE
#define INTERFACE  IDirectMusicTool
DECLARE_INTERFACE_(IDirectMusicTool, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicTool */
    STDMETHOD(Init)                 (THIS_ IDirectMusicGraph* pGraph) PURE;
    STDMETHOD(GetMsgDeliveryType)   (THIS_ DWORD* pdwDeliveryType ) PURE;
    STDMETHOD(GetMediaTypeArraySize)(THIS_ DWORD* pdwNumElements ) PURE;
    STDMETHOD(GetMediaTypes)        (THIS_ DWORD** padwMediaTypes, 
                                           DWORD dwNumElements) PURE;
    STDMETHOD(ProcessPMsg)          (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(Flush)                (THIS_ IDirectMusicPerformance* pPerf, 
                                           DMUS_PMSG* pPMSG, 
                                           REFERENCE_TIME rtTime) PURE;
};

/*////////////////////////////////////////////////////////////////////
// IDirectMusicGraph */
#undef  INTERFACE
#define INTERFACE  IDirectMusicGraph
DECLARE_INTERFACE_(IDirectMusicGraph, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicGraph */
    STDMETHOD(StampPMsg)            (THIS_ DMUS_PMSG* pPMSG) PURE;
    STDMETHOD(InsertTool)           (THIS_ IDirectMusicTool* pTool, 
                                           DWORD* pdwPChannels, 
                                           DWORD cPChannels, 
                                           LONG lIndex) PURE;
    STDMETHOD(GetTool)              (THIS_ DWORD dwIndex, 
                                           IDirectMusicTool** ppTool) PURE;
    STDMETHOD(RemoveTool)           (THIS_ IDirectMusicTool* pTool) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicStyle */
#undef  INTERFACE
#define INTERFACE  IDirectMusicStyle
DECLARE_INTERFACE_(IDirectMusicStyle, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)         (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)          (THIS) PURE;
    STDMETHOD_(ULONG,Release)         (THIS) PURE;

    /*  IDirectMusicStyle */
    STDMETHOD(GetBand)                (THIS_ WCHAR* pwszName, 
                                             IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumBand)               (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetDefaultBand)         (THIS_ IDirectMusicBand** ppBand) PURE;
    STDMETHOD(EnumMotif)              (THIS_ DWORD dwIndex, 
                                             WCHAR* pwszName) PURE;
    STDMETHOD(GetMotif)               (THIS_ WCHAR* pwszName, 
                                             IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(GetDefaultChordMap)     (THIS_ IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(EnumChordMap)           (THIS_ DWORD dwIndex, 
                                             WCHAR *pwszName) PURE;
    STDMETHOD(GetChordMap)            (THIS_ WCHAR* pwszName, 
                                             IDirectMusicChordMap** ppChordMap) PURE;
    STDMETHOD(GetTimeSignature)       (THIS_ DMUS_TIMESIGNATURE* pTimeSig) PURE;
    STDMETHOD(GetEmbellishmentLength) (THIS_ DWORD dwType, 
                                             DWORD dwLevel, 
                                             DWORD* pdwMin, 
                                             DWORD* pdwMax) PURE;
    STDMETHOD(GetTempo)               (THIS_ double* pTempo) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicChordMap */
#undef  INTERFACE
#define INTERFACE  IDirectMusicChordMap
DECLARE_INTERFACE_(IDirectMusicChordMap, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicChordMap */
    STDMETHOD(GetScale)             (THIS_ DWORD* pdwScale) PURE;
};

/*/////////////////////////////////////////////////////////////////////
// IDirectMusicComposer */
#undef  INTERFACE
#define INTERFACE  IDirectMusicComposer
DECLARE_INTERFACE_(IDirectMusicComposer, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicComposer */
    STDMETHOD(ComposeSegmentFromTemplate)   (THIS_ IDirectMusicStyle* pStyle, 
                                                   IDirectMusicSegment* pTemplate, 
                                                   WORD wActivity, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppSegment) PURE;
    STDMETHOD(ComposeSegmentFromShape)      (THIS_ IDirectMusicStyle* pStyle, 
                                                   WORD wNumMeasures, 
                                                   WORD wShape, 
                                                   WORD wActivity, 
                                                   BOOL fIntro, 
                                                   BOOL fEnd, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppSegment ) PURE;
    STDMETHOD(ComposeTransition)            (THIS_ IDirectMusicSegment* pFromSeg, 
                                                   IDirectMusicSegment* pToSeg, 
                                                   MUSIC_TIME mtTime, 
                                                   WORD wCommand, 
                                                   DWORD dwFlags, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppTransSeg) PURE;
    STDMETHOD(AutoTransition)               (THIS_ IDirectMusicPerformance* pPerformance, 
                                                   IDirectMusicSegment* pToSeg, 
                                                   WORD wCommand, 
                                                   DWORD dwFlags, 
                                                   IDirectMusicChordMap* pChordMap, 
                                                   IDirectMusicSegment** ppTransSeg, 
                                                   IDirectMusicSegmentState** ppToSegState, 
                                                   IDirectMusicSegmentState** ppTransSegState) PURE;
    STDMETHOD(ComposeTemplateFromShape)     (THIS_ WORD wNumMeasures, 
                                                   WORD wShape, 
                                                   BOOL fIntro, 
                                                   BOOL fEnd, 
                                                   WORD wEndLength, 
                                                   IDirectMusicSegment** ppTemplate) PURE;
    STDMETHOD(ChangeChordMap)            (THIS_ IDirectMusicSegment* pSegment, 
                                                   BOOL fTrackScale, 
                                                   IDirectMusicChordMap* pChordMap) PURE;
};

/* CLSID's */
DEFINE_GUID(CLSID_DirectMusicPerformance,0xd2ac2881, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegment,0xd2ac2882, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSegmentState,0xd2ac2883, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicGraph,0xd2ac2884, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyle,0xd2ac288a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicChordMap,0xd2ac288f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicComposer,0xd2ac2890, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicLoader,0xd2ac2892, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);
DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Special GUID for all object types. This is used by the loader. */
DEFINE_GUID(GUID_DirectMusicAllTypes,0xd2ac2893, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Notification guids */
DEFINE_GUID(GUID_NOTIFICATION_SEGMENT,0xd2ac2899, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_PERFORMANCE,0x81f75bc5, 0x4e5d, 0x11d2, 0xbc, 0xc7, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_NOTIFICATION_MEASUREANDBEAT,0xd2ac289a, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_CHORD,0xd2ac289b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_NOTIFICATION_COMMAND,0xd2ac289c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Track param type guids */
/* Use to get/set a DMUS_COMMAND_PARAM param in the Command track */
DEFINE_GUID(GUID_CommandParam,0xd2ac289d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_COMMAND_PARAM_2 param in the Command track */
DEFINE_GUID(GUID_CommandParam2, 0x28f97ef7, 0x9538, 0x11d2, 0x97, 0xa9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Use to get/set a DMUS_CHORD_PARAM param in the Chord track */
DEFINE_GUID(GUID_ChordParam,0xd2ac289e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_RHYTHM_PARAM param in the Chord track */
DEFINE_GUID(GUID_RhythmParam,0xd2ac289f, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicStyle param in the Style track */
DEFINE_GUID(GUID_IDirectMusicStyle,0xd2ac28a1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get a DMUS_TIMESIGNATURE param in the Style and TimeSig tracks */
DEFINE_GUID(GUID_TimeSignature,0xd2ac28a4, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_TEMPO_PARAM param in the Tempo track */
DEFINE_GUID(GUID_TempoParam,0xd2ac28a5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to set an IDirectMusicBand param in the Band track */
DEFINE_GUID(GUID_IDirectMusicBand,0xd2ac28ac, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set an IDirectMusicChordMap param in the ChordMap track */
DEFINE_GUID(GUID_IDirectMusicChordMap,0xd2ac28ad, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Use to get/set a DMUS_MUTE_PARAM param in the Mute track */
DEFINE_GUID(GUID_MuteParam,0xd2ac28af, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* These guids are used in IDirectMusicSegment::SetParam to tell the band track to perform various actions.
 */
/* Download bands for the IDirectMusicSegment */
DEFINE_GUID(GUID_Download,0xd2ac28a7, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Unload bands for the IDirectMusicSegment */
DEFINE_GUID(GUID_Unload,0xd2ac28a8, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Connect segment's bands to an IDirectMusicCollection */
DEFINE_GUID(GUID_ConnectToDLSCollection, 0x1db1ae6b, 0xe92e, 0x11d1, 0xa8, 0xc5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);

/* Enable/disable autodownloading of bands */
DEFINE_GUID(GUID_Enable_Auto_Download,0xd2ac28a9, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_Disable_Auto_Download,0xd2ac28aa, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Clear all bands */
DEFINE_GUID(GUID_Clear_All_Bands,0xd2ac28ab, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Set segment to manage all program changes, bank selects, etc. for simple playback of a standard MIDI file */
DEFINE_GUID(GUID_StandardMIDIFile, 0x6621075, 0xe92e, 0x11d1, 0xa8, 0xc5, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0x6e);
/* For compatibility with beta releases... */
#define GUID_IgnoreBankSelectForGM 	GUID_StandardMIDIFile

/* Disable/enable param guids. Use these in SetParam calls to disable or enable sending
 * specific PMsg types.
 */
DEFINE_GUID(GUID_DisableTimeSig, 0x45fc707b, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_EnableTimeSig, 0x45fc707c, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_DisableTempo, 0x45fc707d, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(GUID_EnableTempo, 0x45fc707e, 0x1db4, 0x11d2, 0xbc, 0xac, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* Used in SetParam calls for pattern-based tracks.  A nonzero value seeds the random number 
generator for variation selection; a value of zero reverts to the default behavior of 
getting the seed from the system clock.
*/
DEFINE_GUID(GUID_SeedVariations, 0x65b76fa5, 0xff37, 0x11d2, 0x81, 0x4e, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);

/* Global data guids */
DEFINE_GUID(GUID_PerfMasterTempo,0xd2ac28b0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterVolume,0xd2ac28b1, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfMasterGrooveLevel,0xd2ac28b2, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(GUID_PerfAutoDownload, 0xfb09565b, 0x3631, 0x11d2, 0xbc, 0xb8, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);

/* GUID for default GM/GS dls collection. */
DEFINE_GUID(GUID_DefaultGMCollection, 0xf17e8673, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* IID's */
DEFINE_GUID(IID_IDirectMusicLoader, 0x2ffaaca2, 0x5dca, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicGetLoader,0x68a04844, 0xd13d, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicObject,0xd2ac28b5, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicSegment, 0xf96029a2, 0x4282, 0x11d2, 0x87, 0x17, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicSegmentState, 0xa3afdcc7, 0xd3ee, 0x11d1, 0xbc, 0x8d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicTrack, 0xf96029a1, 0x4282, 0x11d2, 0x87, 0x17, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicPerformance,0x7d43d03, 0x6523, 0x11d2, 0x87, 0x1d, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicTool,0xd2ac28ba, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicGraph,0x2befc277, 0x5497, 0x11d2, 0xbc, 0xcb, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb);
DEFINE_GUID(IID_IDirectMusicStyle,0xd2ac28bd, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicChordMap,0xd2ac28be, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicComposer,0xd2ac28bf, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
DEFINE_GUID(IID_IDirectMusicBand,0xd2ac28c0, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

/* Alternate interface IDs, available in DX7 release and after. */
DEFINE_GUID(IID_IDirectMusicPerformance2,0x6fc2cae0, 0xbc78, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSegment2, 0xd38894d1, 0xc052, 0x11d2, 0x87, 0x2f, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#include <poppack.h>

#endif /* #ifndef _DMUSICI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3d7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3d7obj.h
//
//--------------------------------------------------------------------------

// d3dObj.h : Declaration of the C_dxj_Direct3dObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3d7 LPDIRECT3D7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3d7Object : 
	public I_dxj_Direct3d7,
	//public CComCoClass<C_dxj_Direct3d7Object, &CLSID__dxj_Direct3d7>, 
	public CComObjectRoot
{
public:
	C_dxj_Direct3d7Object() ;
	virtual ~C_dxj_Direct3d7Object() ;
	DWORD InternalAddRef();
	DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_Direct3d7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3d7)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3d7,				"DIRECT.Direct3d.3",                "DIRECT.Direct3d7.3",				IDS_D3D_DESC,				THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3d7Object)

// I_dxj_Direct3d
public:
		 //UPDATED
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

	        
        HRESULT STDMETHODCALLTYPE createDevice( 
            /* [in] */ BSTR guid,
            I_dxj_DirectDrawSurface7 __RPC_FAR *surf,
            /* [retval][out] */ I_dxj_Direct3dDevice7 __RPC_FAR *__RPC_FAR *ret);
        
     //   HRESULT STDMETHODCALLTYPE createTexture( 
     //       /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *dds,
     //       /* [retval][out] */ I_dxj_Direct3dTexture7 __RPC_FAR *__RPC_FAR *ret);
        
        HRESULT STDMETHODCALLTYPE createVertexBuffer( 
            /* [in] */ D3dVertexBufferDesc __RPC_FAR *desc,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *__RPC_FAR *f);
        
        HRESULT STDMETHODCALLTYPE evictManagedTextures( void);
        
       // HRESULT STDMETHODCALLTYPE findDevice( 
       //     /* [in] */ D3dFindDeviceSearch __RPC_FAR *ds,
       //     /* [out][in] */ D3dFindDeviceResult7 __RPC_FAR *findresult);
        
        HRESULT STDMETHODCALLTYPE getDevicesEnum( 
            /* [retval][out] */ I_dxj_Direct3DEnumDevices __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getDirectDraw( 
            /* [retval][out] */ I_dxj_DirectDraw7 __RPC_FAR *__RPC_FAR *retv);
        
        HRESULT STDMETHODCALLTYPE getEnumZBufferFormats( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retv);       
			

private:
    DECL_VARIABLE(_dxj_Direct3d7);


public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3d7 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx7vb\inc\dsound.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *
 **************************************************************************/

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

#include "d3dtypes.h"

#define COM_NO_WINDOWS_H
#include <objbase.h>

#define _FACDS  0x878
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef DIRECTSOUND_VERSION
#define DIRECTSOUND_VERSION  0x0700       /* version 7.0 */
#endif /* !DIRECTSOUND_VERSION */


// DirectSound Component GUID {47D4D946-62E8-11cf-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound Capture Component GUID {B0210780-89CD-11d0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

typedef struct IDirectSound *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify *LPDIRECTSOUNDNOTIFY;

//
// Compatibility typedefs
//

#ifndef _LPCWAVEFORMATEX_DEFINED
#define _LPCWAVEFORMATEX_DEFINED
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
#endif // _LPCWAVEFORMATEX_DEFINED

#ifndef __LPCGUID_DEFINED__
#define __LPCGUID_DEFINED__
typedef const GUID *LPCGUID;
#endif // __LPCGUID_DEFINED__

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;

//
// Structures
//

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
#if DIRECTSOUND_VERSION >= 0x0700
    GUID            guid3DAlgorithm;
#endif
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

typedef struct _DSBUFFERDESC1
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC1, *LPDSBUFFERDESC1;

typedef const DSBUFFERDESC1 *LPCDSBUFFERDESC1;

typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPCGUID, LPDIRECTSOUND *, LPUNKNOWN);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA, LPVOID);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW, LPVOID);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPCGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA, LPVOID);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW, LPVOID);

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IUnknown
//

#if !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->lpVtbl->QueryInterface(p,a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->lpVtbl->AddRef(p)
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->lpVtbl->Release(p)
#endif // IUnknown_Release
#else // !defined(__cplusplus) || defined(CINTERFACE)
#ifndef IUnknown_QueryInterface
#define IUnknown_QueryInterface(p,a,b)  (p)->QueryInterface(a,b)
#endif // IUnknown_QueryInterface
#ifndef IUnknown_AddRef
#define IUnknown_AddRef(p)              (p)->AddRef()
#endif // IUnknown_AddRef
#ifndef IUnknown_Release
#define IUnknown_Release(p)             (p)->Release()
#endif // IUnknown_Release
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC, LPDIRECTSOUNDBUFFER *, LPUNKNOWN) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER, LPDIRECTSOUNDBUFFER *) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND, DWORD) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID) PURE;
};

#define IDirectSound_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSound_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD, LPDWORD) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX, DWORD, LPDWORD) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND, LPCDSBUFFERDESC) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD, DWORD, DWORD) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#define IDirectSoundBuffer_QueryInterface(p,a,b)        IUnknown_QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    IUnknown_AddRef(p)
#define IDirectSoundBuffer_Release(p)                   IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3DListener methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetOrientation)           (THIS_ LPD3DVECTOR, LPD3DVECTOR) PURE;
    STDMETHOD(GetPosition)              (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetVelocity)              (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER, DWORD) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#define IDirectSound3DListener_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSound3DListener_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSound3DBuffer methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD, LPDWORD) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD) PURE;
    STDMETHOD(GetPosition)          (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetVelocity)          (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER, DWORD) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD, DWORD, DWORD) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG, DWORD) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
};

#define IDirectSound3DBuffer_QueryInterface(p,a,b)          IUnknown_QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                      IUnknown_AddRef(p)
#define IDirectSound3DBuffer_Release(p)                     IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_GetAllParameters(p,a)          (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)           (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)        (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)      (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)               (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)            (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)            (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)                   (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)               (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)        (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)         (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d)  (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)    (p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)         (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)          (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)          (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)                 (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)         (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC, LPDIRECTSOUNDCAPTUREBUFFER *, LPUNKNOWN) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS ) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID) PURE;
};

#define IDirectSoundCapture_QueryInterface(p,a,b)           IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       IUnknown_AddRef(p)
#define IDirectSoundCapture_Release(p)                      IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS ) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX, DWORD, LPDWORD ) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD ) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE, LPCDSCBUFFERDESC) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) PURE;
    STDMETHOD(Start)                (THIS_ DWORD) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID, DWORD, LPVOID, DWORD) PURE;
};

#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)         IUnknown_QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                     IUnknown_AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                    IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                  (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)     (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)            (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)                (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)             (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)         (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                    (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                       (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)             (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD, LPCDSBPOSITIONNOTIFY) PURE;
};

#define IDirectSoundNotify_QueryInterface(p,a,b)            IUnknown_QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        IUnknown_AddRef(p)
#define IDirectSoundNotify_Release(p)                       IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID, ULONG, PULONG) PURE;
};

#define IKsPropertySet_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   IUnknown_AddRef(p)
#define IKsPropertySet_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_


//
// Return Codes
//

// The function completed successfully
#define DS_OK                           S_OK

// The function completed successfully, but we had to substitute the 3D algorithm
#define DS_NO_VIRTUALIZATION            MAKE_HRESULT(0, _FACDS, 10)

// The call failed because resources (such as a priority level)
// were already being used by another caller
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)

// The control (vol,pan,etc.) requested by the caller is not available
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)

// An undetermined error occured inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL

// The caller does not have the priority level required for the function to
// succeed
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

// The buffer memory has been lost, and must be restored
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)

// Another app has a higher priority level, preventing this call from
// succeeding
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE

// Access is denied
#define DSERR_ACCESSDENIED              E_ACCESSDENIED

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004

#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005
#define DSSPEAKER_5POINT1           0x00000006

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000
#define DSBCAPS_LOCDEFER            0x00040000

#define DSBPLAY_LOOPING             0x00000001
#define DSBPLAY_LOCHARDWARE         0x00000002
#define DSBPLAY_LOCSOFTWARE         0x00000004
#define DSBPLAY_TERMINATEBY_TIME    0x00000008
#define DSBPLAY_TERMINATEBY_DISTANCE    0x000000010
#define DSBPLAY_TERMINATEBY_PRIORITY    0x000000020

#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004
#define DSBSTATUS_LOCHARDWARE       0x00000008
#define DSBSTATUS_LOCSOFTWARE       0x00000010
#define DSBSTATUS_TERMINATED        0x00000020

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002

#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001

#define DS3D_MINDISTANCEFACTOR      FLT_MIN
#define DS3D_MAXDISTANCEFACTOR      FLT_MAX
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME DSBVOLUME_MAX

#define DSCCAPS_EMULDRIVER          DSCAPS_EMULDRIVER
#define DSCCAPS_CERTIFIED           DSCAPS_CERTIFIED

#define DSCBCAPS_WAVEMAPPED         0x80000000

#define DSCBLOCK_ENTIREBUFFER       0x00000001

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002

#define DSCBSTART_LOOPING           0x00000001

#define DSBPN_OFFSETSTOP            0xFFFFFFFF


//
// DirectSound3D Algorithms
//

// Default DirectSound3D algorithm {00000000-0000-0000-0000-000000000000}
#define DS3DALG_DEFAULT GUID_NULL

// No virtualization {C241333F-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_NO_VIRTUALIZATION, 0xc241333f, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// High-quality HRTF algorithm {C2413340-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_FULL, 0xc2413340, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

// Lower-quality HRTF algorithm {C2413342-1C1B-11d2-94F5-00C04FC28ACA}
DEFINE_GUID(DS3DALG_HRTF_LIGHT, 0xc2413342, 0x1c1b, 0x11d2, 0x94, 0xf5, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

#ifdef __cplusplus
};
#endif // __cplusplus

#endif  // __DSOUND_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3denumdevices7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumdevices7obj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_Direct3DEnumDevices7Object : 
	public I_dxj_Direct3DEnumDevices,
	public CComObjectRoot
{
public:
	C_dxj_Direct3DEnumDevices7Object() ;
	virtual ~C_dxj_Direct3DEnumDevices7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3DEnumDevices7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumDevices)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_Direct3DEnumDevices7Object)

public:
	    HRESULT STDMETHODCALLTYPE getDesc( 
            /* [in] */ long index,
            /* [out][in] */ D3dDeviceDesc7 __RPC_FAR *hwDesc);
        
        
        HRESULT STDMETHODCALLTYPE getGuid( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getDescription( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *guid);
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);

		static HRESULT C_dxj_Direct3DEnumDevices7Object::create(LPDIRECT3D7 pD3D7,I_dxj_Direct3DEnumDevices **ppRet);
		
	
public:
		DxDriverInfo	*m_pList;
		D3DDEVICEDESC7	*m_pListHW;
		
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3denumpixelformats7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3denumpixelformats7obj.h
//
//--------------------------------------------------------------------------




#include "resource.h"       

class C_dxj_Direct3DEnumPixelFormats7Object : 
	public I_dxj_Direct3DEnumPixelFormats,
	public CComObjectRoot
{
public:
	C_dxj_Direct3DEnumPixelFormats7Object() ;
	virtual ~C_dxj_Direct3DEnumPixelFormats7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3DEnumPixelFormats7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumPixelFormats)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_Direct3DEnumPixelFormats7Object)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDPixelFormat *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		static HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create1(LPDIRECT3DDEVICE7 pd3d,  I_dxj_Direct3DEnumPixelFormats **ppRet);
		static HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create2(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats **ppRet);
				                 
public:
		DDPIXELFORMAT	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3denumpixelformats7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       d3denumpixelformats7obj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumPixelFormats7obj.h"

extern HRESULT CopyOutDDPixelFormat( DDPixelFormat *ddpfOut,DDPIXELFORMAT *pf);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *ddpfOut,DDPixelFormat *pf);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID pg);
extern HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str);

extern	BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumPixelFormatsCallback(DDPIXELFORMAT  *pf, void *lpArg)
{

	DPF(1,"Entered objEnumPixelFormatsCallback\r\n");



	
	C_dxj_Direct3DEnumPixelFormats7Object *pObj=(C_dxj_Direct3DEnumPixelFormats7Object*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList)
			pObj->m_pList=(DDPIXELFORMAT*)realloc(pObj->m_pList,sizeof(DDPixelFormat)* pObj->m_nMax);
		else
			pObj->m_pList=(DDPIXELFORMAT*)malloc(sizeof(DDPixelFormat)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pf,sizeof(DDPIXELFORMAT));
		
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_Direct3DEnumPixelFormats7Object::C_dxj_Direct3DEnumPixelFormats7Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_Direct3DEnumPixelFormats7Object::~C_dxj_Direct3DEnumPixelFormats7Object()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create1(LPDIRECT3DDEVICE7 pd3d,  I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumPixelFormats7Object *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_Direct3DEnumPixelFormats7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_Direct3DEnumPixelFormats7Object::create2(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumPixelFormats7Object *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_Direct3DEnumPixelFormats7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumPixelFormats,(void**)ppRet);
	return hr;
}




HRESULT C_dxj_Direct3DEnumPixelFormats7Object::getItem( long index, DDPixelFormat *desc)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	CopyOutDDPixelFormat(desc ,&(m_pList[index-1]));

	return S_OK;
}


HRESULT C_dxj_Direct3DEnumPixelFormats7Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3denumpixelformatsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumpixelformatsobj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumPixelFormatsobj.h"

extern HRESULT CopyOutDDPixelFormat( DDPixelFormat *ddpfOut,DDPIXELFORMAT *pf);
extern HRESULT CopyInDDPixelFormat(DDPIXELFORMAT *ddpfOut,DDPixelFormat *pf);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BSTR D3DGUIDtoBSTR(LPGUID pg);
extern HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str);

extern	BOOL IsAllZeros(void *pStruct,DWORD size); 

extern "C" HRESULT PASCAL objEnumPixelFormatsCallback(DDPIXELFORMAT  *pf, void *lpArg)
{

	DPF(1,"Entered objEnumPixelFormatsCallback\r\n");

	
	C_dxj_D3DEnumPixelFormatsObject *pObj=(C_dxj_D3DEnumPixelFormatsObject*)lpArg;
	if (pObj==NULL) return DDENUMRET_OK;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList)
			pObj->m_pList=(DDPIXELFORMAT*)realloc(pObj->m_pList,sizeof(DDPixelFormat)* pObj->m_nMax);
		else
			pObj->m_pList=(DDPIXELFORMAT*)malloc(sizeof(DDPixelFormat)* pObj->m_nMax);

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}

	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pf,sizeof(DDPIXELFORMAT));
		
	
	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_D3DEnumPixelFormatsObject::C_dxj_D3DEnumPixelFormatsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_D3DEnumPixelFormatsObject::~C_dxj_D3DEnumPixelFormatsObject()
{
	//empty list
	if (m_pList){
		free(m_pList);
	}

}


HRESULT C_dxj_D3DEnumPixelFormatsObject::create(LPDIRECT3DDEVICE3 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_D3DEnumPixelFormatsObject::create2(LPDIRECT3D3 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}



#if 0
HRESULT C_dxj_D3DEnumPixelFormatsObject::create3(LPDIRECT3DDEVICE7 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;

	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumTextureFormats(objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}

HRESULT C_dxj_D3DEnumPixelFormatsObject::create4(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	C_dxj_D3DEnumPixelFormatsObject *pNew=NULL;
	GUID guid;

	hr=D3DBSTRtoGUID(&guid,strGuid);
	if FAILED(hr) return hr;
	
	*ppRet=NULL;

	if (!pd3d) return E_INVALIDARG;

	pNew= new CComObject<C_dxj_D3DEnumPixelFormatsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;
	
	
	hr=pd3d->EnumZBufferFormats(guid,objEnumPixelFormatsCallback,(void*)pNew);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_D3DEnumPixelFormats,(void**)ppRet);
	return hr;
}
#endif


HRESULT C_dxj_D3DEnumPixelFormatsObject::getItem( long index, DDPixelFormat *desc)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	CopyOutDDPixelFormat(desc ,&(m_pList[index-1]));

	return S_OK;
}


HRESULT C_dxj_D3DEnumPixelFormatsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3denumpixelformatsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumpixelformatsobj.h
//
//--------------------------------------------------------------------------




#include "resource.h"       

class C_dxj_D3DEnumPixelFormatsObject : 
	public I_dxj_Direct3DEnumPixelFormats7,
	public CComObjectRoot
{
public:
	C_dxj_D3DEnumPixelFormatsObject() ;
	virtual ~C_dxj_D3DEnumPixelFormatsObject() ;

BEGIN_COM_MAP(C_dxj_D3DEnumPixelFormatsObject)
	COM_INTERFACE_ENTRY(I_dxj_Direct3DEnumPixelFormats7)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_D3DEnumPixelFormatsObject)

public:
		HRESULT STDMETHODCALLTYPE getItem( long index, DDPixelFormat *info);
        HRESULT STDMETHODCALLTYPE getCount(long *count);
		static HRESULT C_dxj_D3DEnumPixelFormatsObject::create(LPDIRECT3DDEVICE3 pd3d,  I_dxj_Direct3DEnumPixelFormats7 **ppRet);
		static HRESULT C_dxj_D3DEnumPixelFormatsObject::create2(LPDIRECT3D3 pd3d,  BSTR strGuid, I_dxj_Direct3DEnumPixelFormats7 **ppRet);
		//static HRESULT C_dxj_D3DEnumPixelFormatsObject::create3(LPDIRECT3DDEVICE7 pd3d,  I_dxj_D3DEnumPixelFormats **ppRet);
		//static HRESULT C_dxj_D3DEnumPixelFormatsObject::create4(LPDIRECT3D7 pd3d,  BSTR strGuid, I_dxj_D3DEnumPixelFormats **ppRet);
				                 
public:
		DDPIXELFORMAT	*m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3dvertexbuffer7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3dvertexbuffer7obj.h
//
//--------------------------------------------------------------------------

// d3dMaterialObj.h : Declaration of the C_dxj_Direct3dMaterialObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dVertexBuffer7 LPDIRECT3DVERTEXBUFFER7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_Direct3dVertexBuffer7Object : 
	public I_dxj_Direct3dVertexBuffer7,
	public CComObjectRoot
{
public:
	C_dxj_Direct3dVertexBuffer7Object() ;
	virtual ~C_dxj_Direct3dVertexBuffer7Object() ;

BEGIN_COM_MAP(C_dxj_Direct3dVertexBuffer7Object)
	COM_INTERFACE_ENTRY(I_dxj_Direct3dVertexBuffer7)
END_COM_MAP()



DECLARE_AGGREGATABLE(C_dxj_Direct3dVertexBuffer7Object)


public:
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE getVertexBufferDesc( 
            /* [out][in] */ D3dVertexBufferDesc __RPC_FAR *desc);
        
        HRESULT STDMETHODCALLTYPE lock( 
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE unlock( void);
        
        HRESULT STDMETHODCALLTYPE optimize( 
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev
            );
        
        HRESULT STDMETHODCALLTYPE processVertices( 
            /* [in] */ long vertexOp,
            /* [in] */ long destIndex,
            /* [in] */ long count,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *srcBuffer,
            /* [in] */ long srcIndex,
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev,
            /* [in] */ long flags);
        
        HRESULT STDMETHODCALLTYPE setVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts);
        
        HRESULT STDMETHODCALLTYPE getVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts);

		HRESULT STDMETHODCALLTYPE setVertexSize( /* [in] */ long n);

private:
    DECL_VARIABLE(_dxj_Direct3dVertexBuffer7);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dVertexBuffer7)
	void	*m_pData;
	DWORD	m_vertSize;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3ddevice3obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice3obj.h
//
//--------------------------------------------------------------------------

// d3dDeviceObj.h : Declaration of the C_dxj_Direct3dDeviceObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dDevice3 LPDIRECT3DDEVICE3

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't
//          like references as template arguments.

class C_dxj_Direct3dDevice3Object : 
        public I_dxj_Direct3dDevice3,
		//public CComCoClass<C_dxj_Direct3dDevice3Object, &CLSID__dxj_Direct3dDevice3>,
		public CComObjectRoot
{
public:
        C_dxj_Direct3dDevice3Object();
        virtual ~C_dxj_Direct3dDevice3Object();
		DWORD InternalAddRef();
		DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_Direct3dDevice3Object)
        COM_INTERFACE_ENTRY(I_dxj_Direct3dDevice3)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dDevice3,			"DIRECT.Direct3dDevice3.3",          "DIRECT.Direct3dDevice3.3",			IDS_D3DDEVICE_DESC,			THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dDevice3Object)

// I_dxj_Direct3dDevice
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
         HRESULT STDMETHODCALLTYPE addViewport( 
            /* [in] */ I_dxj_Direct3dViewport3 __RPC_FAR *viewport);
        
         HRESULT STDMETHODCALLTYPE deleteViewport( 
            /* [in] */ I_dxj_Direct3dViewport3 __RPC_FAR *vport);
        
         HRESULT STDMETHODCALLTYPE beginIndexed( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ d3dVertexType d3dvt,
            /* [in] */ void __RPC_FAR *verts,
            /* [in] */ long vertexCount,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE drawIndexedPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ d3dVertexType d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indices,
            /* [in] */ long IndicesCount,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE drawPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ d3dVertexType d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE vertex( 
            /* [in] */ void __RPC_FAR *vertex);
        
         HRESULT STDMETHODCALLTYPE getDirect3D( 
            /* [retval][out] */ I_dxj_Direct3d3 __RPC_FAR *__RPC_FAR *dev);
        
         HRESULT STDMETHODCALLTYPE getCurrentViewport( 
            /* [retval][out] */ I_dxj_Direct3dViewport3 __RPC_FAR *__RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE nextViewport( 
            /* [in] */ I_dxj_Direct3dViewport3 __RPC_FAR *vp1,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_Direct3dViewport3 __RPC_FAR *__RPC_FAR *vp2);
        
         HRESULT STDMETHODCALLTYPE setCurrentViewport( 
            /* [in] */ I_dxj_Direct3dViewport3 __RPC_FAR *viewport);
        
         HRESULT STDMETHODCALLTYPE setRenderTarget( 
            /* [in] */ I_dxj_DirectDrawSurface4 __RPC_FAR *surface);
        
         HRESULT STDMETHODCALLTYPE getRenderTarget( 
            /* [retval][out] */ I_dxj_DirectDrawSurface4 __RPC_FAR *__RPC_FAR *ppval);
        
         HRESULT STDMETHODCALLTYPE begin( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ d3dVertexType d3dvt,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE beginScene( void);
        
         HRESULT STDMETHODCALLTYPE end();
        
         HRESULT STDMETHODCALLTYPE endScene( void);
        
         HRESULT STDMETHODCALLTYPE getTextureFormatsEnum( 
            /* [retval][out] */ I_dxj_D3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retval);
        
         HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ D3dDeviceDesc __RPC_FAR *hwDesc,
            /* [out][in] */ D3dDeviceDesc __RPC_FAR *helDesc);
        
         HRESULT STDMETHODCALLTYPE getClipStatus( 
            /* [out][in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
         HRESULT STDMETHODCALLTYPE getLightState( 
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *lightstate);
        
         HRESULT STDMETHODCALLTYPE getRenderState( 
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *renderstate);
        
         HRESULT STDMETHODCALLTYPE getStats( 
            /* [out][in] */ D3dStats __RPC_FAR *stat);
        
         HRESULT STDMETHODCALLTYPE getTransform( 
            /* [in] */ long transformType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
         HRESULT STDMETHODCALLTYPE index( 
            /* [in] */ short vertexIndex);
        
         HRESULT STDMETHODCALLTYPE multiplyTransform( 
            /* [in] */ long dstTransfromStateType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
         HRESULT STDMETHODCALLTYPE setClipStatus( 
            /* [in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
         HRESULT STDMETHODCALLTYPE setLightState( 
            /* [in] */ long state,
            /* [in] */ long lightstate);
        
         HRESULT STDMETHODCALLTYPE setRenderState( 
            /* [in] */ long state,
            /* [in] */ long renderstate);
        
         HRESULT STDMETHODCALLTYPE setTransform( 
            /* [in] */ d3dTransformStateType transformType,
            /* [in] */ D3dMatrix __RPC_FAR *matrix);
        
         HRESULT STDMETHODCALLTYPE computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radi,
            /* [retval][out] */ long __RPC_FAR *returnVal);
        
         HRESULT STDMETHODCALLTYPE drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer __RPC_FAR *vertexBuffer,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer __RPC_FAR *vertexBuffer,
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags);
        
         HRESULT STDMETHODCALLTYPE validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes);
        
         HRESULT STDMETHODCALLTYPE getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_Direct3dTexture2 __RPC_FAR *__RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *retv);
        
         HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ long stage,
            /* [in] */ I_dxj_Direct3dTexture2 __RPC_FAR *texture);
        
         HRESULT STDMETHODCALLTYPE setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long value);

////////////////////////////////////////////////////////////////////////////////////
private:
    DECL_VARIABLE(_dxj_Direct3dDevice3);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dDevice3)
	void *parent2; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3ddevice3obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice3obj.cpp
//
//--------------------------------------------------------------------------

// d3dDeviceObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3d3Obj.h"
#include "d3dDevice3Obj.h"
#include "d3dTexture2Obj.h"
#include "d3dViewport3Obj.h"
#include "ddSurface4Obj.h"
#include "d3dEnumPixelFormatsObj.h"

//////////////////////////////////////////////////////////////////
// C_dxj_Direct3dDevice3Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice3Object::C_dxj_Direct3dDevice3Object(){
	m__dxj_Direct3dDevice3=NULL;
	parent=NULL;
	parent2=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;

	#ifdef DEBUG
	char buffer[256];
	wsprintf(buffer,"Constructor Creation  Direct3dDevice3[%d] \n",g_creationcount);
	OutputDebugString(buffer);
	#endif

	nextobj =  g_dxj_Direct3dDevice3;
	g_dxj_Direct3dDevice3 = (void *)this;
}

//////////////////////////////////////////////////////////////////
// ~C_dxj_Direct3dDevice3Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice3Object::~C_dxj_Direct3dDevice3Object()
{
    C_dxj_Direct3dDevice3Object *prev=NULL; 
	for(C_dxj_Direct3dDevice3Object *ptr=(C_dxj_Direct3dDevice3Object *)g_dxj_Direct3dDevice3; ptr; ptr=(C_dxj_Direct3dDevice3Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dDevice3 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dDevice3){
		int count = IUNK(m__dxj_Direct3dDevice3)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer, "DirectX IDirect3dDevice3 Ref count [%d] \n",count);
		#endif

		if(count==0) m__dxj_Direct3dDevice3 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
	if(parent2) IUNK(parent2)->Release();
}


//////////////////////////////////////////////////////////////////
// InternalAddRef
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice3Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	#ifdef DEBUG
	char szBuf[MAX_PATH];
	wsprintf(szBuf,"Direct3dDevice3[%d] AddRef %d \n",creationid,i);
	OutputDebugString(szBuf);
	#endif
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalRelease
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice3Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	#ifdef DEBUG
	char szBuf[MAX_PATH];
	wsprintf(szBuf,"Direct3dDevice3 [%d] Release %d \n",creationid,i);
	OutputDebugString(szBuf);
	#endif
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
//////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_Direct3dDevice3);

//////////////////////////////////////////////////////////////////
// addViewport
// begin
// beginScene
// deleteViewport
// endScene
// setClipStatus
// setLightState
// setRenderState
// getClipStatus
// getStats
// getDirect3d
// getLightState
// getRenderState
// index
//////////////////////////////////////////////////////////////////
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dDevice3, addViewport, AddViewport, _dxj_Direct3dViewport3);
PASS_THROUGH_CAST_3_R(_dxj_Direct3dDevice3, begin, Begin, d3dPrimitiveType, (D3DPRIMITIVETYPE),d3dVertexType, (D3DVERTEXTYPE),long,(DWORD));
PASS_THROUGH_R(_dxj_Direct3dDevice3, beginScene, BeginScene);
DO_GETOBJECT_ANDUSEIT_R(_dxj_Direct3dDevice3, deleteViewport, DeleteViewport, _dxj_Direct3dViewport3);
PASS_THROUGH_R(_dxj_Direct3dDevice3, endScene, EndScene);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice3, setClipStatus, SetClipStatus, D3dClipStatus*,(D3DCLIPSTATUS*));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice3, setLightState, SetLightState, long ,(D3DLIGHTSTATETYPE), long ,(DWORD));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice3, setRenderState, SetRenderState, long,(D3DRENDERSTATETYPE), long ,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice3, getClipStatus, GetClipStatus, D3dClipStatus*, (D3DCLIPSTATUS *));


PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice3, getLightState, GetLightState, long ,(D3DLIGHTSTATETYPE), long*,(DWORD*));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice3, getRenderState, GetRenderState, long ,(D3DRENDERSTATETYPE), long*,(DWORD*));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice3, index, Index, short,(WORD));

//////////////////////////////////////////////////////////////////
// end
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::end(){
	HRESULT hr;
	hr=m__dxj_Direct3dDevice3->End(0);
	return hr;
}

//////////////////////////////////////////////////////////////////
// getRenderTarget
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::getRenderTarget(I_dxj_DirectDrawSurface4 **ppsurf)
{
	#pragma message ("fix in Dx5 interface")

	LPDIRECTDRAWSURFACE4	lpSurf4=NULL;
	HRESULT hr;
	hr=m__dxj_Direct3dDevice3->GetRenderTarget(&lpSurf4);
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface4, lpSurf4, ppsurf);
	
	return S_OK;
}


//////////////////////////////////////////////////////////////////
// getTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::getTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice3->GetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX)m);
}

//////////////////////////////////////////////////////////////////
// multiplyTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::multiplyTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice3->MultiplyTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}

//////////////////////////////////////////////////////////////////
// setTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::setTransform(long transtype,
								D3dMatrix  *m){	
	return m__dxj_Direct3dDevice3->SetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}

//////////////////////////////////////////////////////////////////
// nextViewport
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice3Object::nextViewport(I_dxj_Direct3dViewport3 *ref, long flags, I_dxj_Direct3dViewport3 **vp)
{
	if (!ref) return E_INVALIDARG;
	LPDIRECT3DVIEWPORT3	lpvp;
	DO_GETOBJECT_NOTNULL(LPDIRECT3DVIEWPORT3, lpref, ref);
	HRESULT hr=m__dxj_Direct3dDevice3->NextViewport(lpref, &lpvp, flags);
	if (hr != DD_OK )   return hr;		
	INTERNAL_CREATE(_dxj_Direct3dViewport3, lpvp, vp);
	return S_OK;
}

//////////////////////////////////////////////////////////////////
// setCurrentViewport
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::setCurrentViewport(I_dxj_Direct3dViewport3 *viewport)
{	
	if (!viewport) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECT3DVIEWPORT3, lpref, viewport);
	return m__dxj_Direct3dDevice3->SetCurrentViewport(lpref);
}

//////////////////////////////////////////////////////////////////
// setRenderTarget
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::setRenderTarget(I_dxj_DirectDrawSurface4 *surf)
{		
	HRESULT hr;	
	if (!surf) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE4, lpref, surf);
	hr= m__dxj_Direct3dDevice3->SetRenderTarget(lpref,0);
	return hr;
}
		

//////////////////////////////////////////////////////////////////
// getCurrentViewport
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::getCurrentViewport(I_dxj_Direct3dViewport3 **ppvp)
{
	LPDIRECT3DVIEWPORT3	lpvp=NULL;
	HRESULT hr=m__dxj_Direct3dDevice3->GetCurrentViewport(&lpvp);
	if (hr!= DD_OK )   return hr;
	
	INTERNAL_CREATE(_dxj_Direct3dViewport3, lpvp, ppvp);
	return S_OK;
}


//////////////////////////////////////////////////////////////////
// beginIndexed
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::beginIndexed(
								d3dPrimitiveType  d3dpt,								
								long d3dvt,
								void *verts,
								long vertexCount,
								long flags){

	HRESULT hr;

	__try 	{
		hr= m__dxj_Direct3dDevice3->BeginIndexed(
		  (D3DPRIMITIVETYPE) d3dpt,
		  (DWORD) d3dvt,
		  (void*) verts,
		  (DWORD) vertexCount,
		  (DWORD) flags);	
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////
// drawIndexedPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::drawIndexedPrimitive(
								d3dPrimitiveType  d3dpt,	
								long d3dvt,
								void *Verts,
								long vertexCount,
								SAFEARRAY **ppsaIndex,
								long indexArraySize,
								long flags){

	HRESULT hr;

	__try {
		hr=m__dxj_Direct3dDevice3->DrawIndexedPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(unsigned short*) ((SAFEARRAY*)*ppsaIndex)->pvData,
			(DWORD)indexArraySize,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////
// drawPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::drawPrimitive(
								d3dPrimitiveType  d3dpt,
								long d3dvt,								
								void* Verts,
								long vertexCount,
								long flags){
	HRESULT hr;
	__try {
		hr= m__dxj_Direct3dDevice3->DrawPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}
	return hr;
}

//////////////////////////////////////////////////////////////////
// vertex
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::vertex(void *vert){		
	HRESULT hr;
	__try {
		hr=m__dxj_Direct3dDevice3->Vertex((void*)vert);
	}
	__except(1,1){
		return DDERR_EXCEPTION;
	}
	return hr;
};

//////////////////////////////////////////////////////////////////
// getTextureFormatsEnum
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::getTextureFormatsEnum(I_dxj_D3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	hr=C_dxj_D3DEnumPixelFormatsObject::create(m__dxj_Direct3dDevice3,ppRet);
	return hr;
}



//////////////////////////////////////////////////////////////////
// computeSphereVisibility
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radi,
            /* [retval][out] */ long __RPC_FAR *returnVal)
{
		HRESULT hr=m__dxj_Direct3dDevice3->ComputeSphereVisibility((LPD3DVECTOR)center,radi,1,0,(DWORD*)returnVal);
		return hr;
}

//////////////////////////////////////////////////////////////////
// drawIndexedPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer __RPC_FAR *vertexBuffer,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags)
{
	HRESULT hr;

	if (!indexArray) return E_FAIL;

	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice3->DrawIndexedPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(WORD*) ((SAFEARRAY*)*indexArray)->pvData,					
			(DWORD)indexcount,
			(DWORD)flags);

	}
	__except(1,1){
		return DDERR_EXCEPTION;
	}
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// drawPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer __RPC_FAR *vertexBuffer,            
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags)
{
	HRESULT hr;


	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice3->DrawPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(DWORD) startVertex,
			(DWORD) numVertices,
			(DWORD)flags);

	}
	__except(1,1){

		return DDERR_EXCEPTION;
	}
	return hr;
}



//////////////////////////////////////////////////////////////////
// validateDevice
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes)
{
	HRESULT hr=m__dxj_Direct3dDevice3->ValidateDevice((DWORD*)passes);
	return hr;
}

//////////////////////////////////////////////////////////////////
// getTexture
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice3Object::getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_Direct3dTexture2 __RPC_FAR *__RPC_FAR *retv)
{
	LPDIRECT3DTEXTURE2 lpNew=NULL;
	HRESULT hr;

	*retv=NULL;
	hr=m__dxj_Direct3dDevice3->GetTexture((DWORD)stage,&lpNew);
	
	//null is valid
	if (lpNew==NULL) return S_OK;

	INTERNAL_CREATE(_dxj_Direct3dTexture2, lpNew, retv);	
	if (*retv==NULL) return E_OUTOFMEMORY;

	return hr;
}

//////////////////////////////////////////////////////////////////
// getTextureStageState
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice3Object::getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *retv)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice3->GetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD*)retv);
	return hr;
}

//////////////////////////////////////////////////////////////////
// setTexture
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice3Object::setTexture( 
             long stage,
             I_dxj_Direct3dTexture2  *tex)
{
	
	HRESULT hr;

	if (tex==NULL)
	{ 
		hr=m__dxj_Direct3dDevice3->SetTexture((DWORD)stage,NULL);
	}
	else 
	{
		DO_GETOBJECT_NOTNULL(LPDIRECT3DTEXTURE2, lpTex, tex);	
		hr=m__dxj_Direct3dDevice3->SetTexture((DWORD)stage,lpTex);
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// setTextureStageState
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice3Object::setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long val)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice3->SetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD)val);
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getCaps
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice3Object::getCaps( 
            D3dDeviceDesc *a,D3dDeviceDesc *b)
{
	if (a) a->lSize=sizeof(D3DDEVICEDESC);
	if (b) b->lSize=sizeof(D3DDEVICEDESC);

	HRESULT hr;
	hr=m__dxj_Direct3dDevice3->GetCaps((D3DDEVICEDESC*)a,(D3DDEVICEDESC*)b);
	return hr;
}


//////////////////////////////////////////////////////////////////
// getDirect3D
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice3Object::getDirect3D( I_dxj_Direct3d3 **ret)
{

	HRESULT hr;
	LPDIRECT3D3 lpD3D=NULL;
	hr=m__dxj_Direct3dDevice3->GetDirect3D(&lpD3D);
	if FAILED(hr) return hr;
	if (!lpD3D) return E_FAIL;
	INTERNAL_CREATE(_dxj_Direct3d3,lpD3D,ret);
	return hr;

}



//////////////////////////////////////////////////////////////////
// getStats
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice3Object::getStats( D3dStats *stats)
{

	HRESULT hr;
	if (!stats) return E_INVALIDARG;
	D3DSTATS *lpStats=(D3DSTATS*)stats;
	lpStats->dwSize=sizeof(D3DSTATS);
	hr=m__dxj_Direct3dDevice3->GetStats(lpStats);

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3ddevice7obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice7obj.h
//
//--------------------------------------------------------------------------

// d3dDeviceObj.h : Declaration of the C_dxj_Direct3dDeviceObject


#include "resource.h"       // main symbols

#define typedef__dxj_Direct3dDevice7 LPDIRECT3DDEVICE7

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't
//          like references as template arguments.

class C_dxj_Direct3dDevice7Object : 
        public I_dxj_Direct3dDevice7,
		//public CComCoClass<C_dxj_Direct3dDevice7Object, &CLSID__dxj_Direct3dDevice7>,
		public CComObjectRoot
{
public:
        C_dxj_Direct3dDevice7Object();
        virtual ~C_dxj_Direct3dDevice7Object();
		DWORD InternalAddRef();
		DWORD InternalRelease();

BEGIN_COM_MAP(C_dxj_Direct3dDevice7Object)
        COM_INTERFACE_ENTRY(I_dxj_Direct3dDevice7)
END_COM_MAP()

//	DECLARE_REGISTRY(CLSID__dxj_Direct3dDevice7,			"DIRECT.Direct3dDevice7.3",          "DIRECT.Direct3dDevice7.3",			IDS_D3DDEVICE_DESC,			THREADFLAGS_BOTH)

DECLARE_AGGREGATABLE(C_dxj_Direct3dDevice7Object)

// I_dxj_Direct3dDevice
public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
          HRESULT STDMETHODCALLTYPE applyStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE beginScene( void);
        
          HRESULT STDMETHODCALLTYPE beginStateBlock( void);
        
          HRESULT STDMETHODCALLTYPE captureStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE clear( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *recs,
            /* [in] */ long flags,
            /* [in] */ long color,
            /* [in] */ float z,
            /* [in] */ long stencil);
        
          HRESULT STDMETHODCALLTYPE computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radius,
            /* [retval][out] */ long __RPC_FAR *returnVal);
        
          HRESULT STDMETHODCALLTYPE deleteStateBlock( 
            /* [in] */ long blockHandle);
        
          HRESULT STDMETHODCALLTYPE drawIndexedPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ long d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indices,
            /* [in] */ long IndicesCount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawPrimitive( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ long d3dvt,
            /* [in] */ void __RPC_FAR *vertices,
            /* [in] */ long VertexCount,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags);
                  
          HRESULT STDMETHODCALLTYPE endScene( void);
        
          HRESULT STDMETHODCALLTYPE endStateBlock( 
            /* [in] */ long __RPC_FAR *blockHandle);
        
          HRESULT STDMETHODCALLTYPE getCaps( 
            /* [out][in] */ D3dDeviceDesc7 __RPC_FAR *desc);
        
          HRESULT STDMETHODCALLTYPE getClipStatus( 
            /* [out][in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
          HRESULT STDMETHODCALLTYPE getDirect3D( 
            /* [retval][out] */ I_dxj_Direct3d7 __RPC_FAR *__RPC_FAR *dev);
        
          HRESULT STDMETHODCALLTYPE getLight( 
            /* [in] */ long LightIndex,
            /* [out][in] */ D3dLight7 __RPC_FAR *Light);
        
          HRESULT STDMETHODCALLTYPE getLightEnable( 
            /* [in] */ long LightIndex,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
        
          HRESULT STDMETHODCALLTYPE getMaterial( 
            /* [out][in] */ D3dMaterial7 __RPC_FAR *Material);
        
          HRESULT STDMETHODCALLTYPE getRenderState( 
            /* [in] */ d3dRenderStateType state,
            /* [retval][out] */ long __RPC_FAR *renderstate);
        
          HRESULT STDMETHODCALLTYPE getRenderTarget( 
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *ppval);
        
          HRESULT STDMETHODCALLTYPE getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv);
        
          HRESULT STDMETHODCALLTYPE getTextureFormatsEnum( 
            /* [retval][out] */ I_dxj_Direct3DEnumPixelFormats __RPC_FAR *__RPC_FAR *retval);
        
          HRESULT STDMETHODCALLTYPE getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *val);
        
          HRESULT STDMETHODCALLTYPE getTransform( 
            /* [in] */ d3dTransformStateType transformType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
          HRESULT STDMETHODCALLTYPE getViewport( 
            /* [out][in] */ D3dViewport7 __RPC_FAR *viewport);
        
          HRESULT STDMETHODCALLTYPE lightEnable( 
            /* [in] */ long LightIndex,
            /* [in] */ VARIANT_BOOL b);
        
          HRESULT STDMETHODCALLTYPE load( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *DestTex,
            /* [in] */ long xDest,
            /* [in] */ long yDest,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *SrcTex,
            /* [in] */ Rect __RPC_FAR *rcSrcRect,
            /* [in] */ long flags);
        
          HRESULT STDMETHODCALLTYPE multiplyTransform( 
            /* [in] */ long dstTransfromStateType,
            /* [out][in] */ D3dMatrix __RPC_FAR *matrix);
        
        
          HRESULT STDMETHODCALLTYPE preLoad( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *surf);
        
          HRESULT STDMETHODCALLTYPE setClipStatus( 
            /* [in] */ D3dClipStatus __RPC_FAR *clipStatus);
        
          HRESULT STDMETHODCALLTYPE setLight( 
            /* [in] */ long LightIndex,
            /* [in] */ D3dLight7 __RPC_FAR *Light);
        
          HRESULT STDMETHODCALLTYPE setMaterial( 
            /* [in] */ D3dMaterial7 __RPC_FAR *mat);
        
          HRESULT STDMETHODCALLTYPE setRenderState( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ long renderstate);
        
          HRESULT STDMETHODCALLTYPE setRenderTarget( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *surface);
        
          HRESULT STDMETHODCALLTYPE setTexture( 
            /* [in] */ long stage,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *texture);
        
          HRESULT STDMETHODCALLTYPE setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long value);
        
          HRESULT STDMETHODCALLTYPE setTransform( 
            /* [in] */ d3dTransformStateType transformType,
            /* [in] */ D3dMatrix __RPC_FAR *matrix);
        
          HRESULT STDMETHODCALLTYPE setViewport( 
            /* [in] */ D3dViewport7 __RPC_FAR *viewport);
        
          HRESULT STDMETHODCALLTYPE validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes);
   

          HRESULT STDMETHODCALLTYPE setTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float value);
        
          HRESULT STDMETHODCALLTYPE getTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float *value);



		HRESULT STDMETHODCALLTYPE getInfo (             
            /* [in] */		long lDevInfoID,
            /* [out][in] */ void __RPC_FAR *DevInfoType,
            /* [in] */		long lSize);


        HRESULT STDMETHODCALLTYPE setRenderStateSingle( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ float renderstate);

        HRESULT STDMETHODCALLTYPE getRenderStateSingle( 
            /* [in] */ d3dRenderStateType state,
            /* [in] */ float *renderstate);



		HRESULT STDMETHODCALLTYPE	getDeviceGuid( 
			/* [out,retval] */	BSTR *ret);


		HRESULT STDMETHODCALLTYPE createStateBlock( long flags, long *retv);

        HRESULT STDMETHODCALLTYPE setClipPlane( long index, float A, float B, float C, float D);

        HRESULT STDMETHODCALLTYPE getClipPlane( long index, float *A, float *B, float *C, float *D);


////////////////////////////////////////////////////////////////////////////////////
private:
    DECL_VARIABLE(_dxj_Direct3dDevice7);

public:
	DX3J_GLOBAL_LINKS( _dxj_Direct3dDevice7)
	void *parent2; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3ddevice7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3ddevice7obj.cpp
//
//--------------------------------------------------------------------------

// d3dDeviceObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3d7Obj.h"
#include "d3dDevice7Obj.h"
#include "ddSurface7Obj.h"
#include "d3dEnumPixelFormats7Obj.h"

extern BSTR D3DGUIDtoBSTR(LPGUID);


//////////////////////////////////////////////////////////////////
// C_dxj_Direct3dDevice7Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice7Object::C_dxj_Direct3dDevice7Object(){
	m__dxj_Direct3dDevice7=NULL;
	parent=NULL;
	pinterface=NULL;
	creationid = ++g_creationcount;
	DPF1(1,"Constructor Creation  Direct3dDevice7[%d] \n",g_creationcount);
	

	nextobj =  g_dxj_Direct3dDevice7;
	g_dxj_Direct3dDevice7 = (void *)this;
}

//////////////////////////////////////////////////////////////////
// ~C_dxj_Direct3dDevice7Object
//////////////////////////////////////////////////////////////////
C_dxj_Direct3dDevice7Object::~C_dxj_Direct3dDevice7Object()
{
    C_dxj_Direct3dDevice7Object *prev=NULL; 
	for(C_dxj_Direct3dDevice7Object *ptr=(C_dxj_Direct3dDevice7Object *)g_dxj_Direct3dDevice7; ptr; ptr=(C_dxj_Direct3dDevice7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_Direct3dDevice7 = (void*)ptr->nextobj; 
			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_Direct3dDevice7){
		int count = IUNK(m__dxj_Direct3dDevice7)->Release();
		
		DPF1(1, "DirectX IDirect3dDevice7 Ref count [%d] \n",count);

		if(count==0) m__dxj_Direct3dDevice7 = NULL;
	} 
	if(parent) IUNK(parent)->Release();
	if(parent2) IUNK(parent2)->Release();
	
	parent=NULL;
	parent2=NULL;
}


///////////////// /////////////////////////////////////////////////
// InternalAddRef
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"Direct3dDevice7[%d] AddRef %d \n",creationid,i);
	
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalRelease
//////////////////////////////////////////////////////////////////
DWORD C_dxj_Direct3dDevice7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(szBuf,"Direct3dDevice7 [%d] Release %d \n",creationid,i);
	
	return i;
}

//////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
//////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_Direct3dDevice7);

//////////////////////////////////////////////////////////////////
// beginScene
// endScene
// setClipStatus
// setLightState
// setRenderState
// getClipStatus
// getLightState
// getRenderState
//////////////////////////////////////////////////////////////////
PASS_THROUGH_R(_dxj_Direct3dDevice7, beginScene, BeginScene);
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice7, setClipStatus, SetClipStatus, D3dClipStatus*,(D3DCLIPSTATUS*));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, setRenderState, SetRenderState, long,(D3DRENDERSTATETYPE), long ,(DWORD));
PASS_THROUGH_CAST_1_R(_dxj_Direct3dDevice7, getClipStatus, GetClipStatus, D3dClipStatus*, (D3DCLIPSTATUS *));
PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, getRenderState, GetRenderState, long ,(D3DRENDERSTATETYPE), long*,(DWORD*));

//////////////////////////////////////////////////////////////////
// endScene
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::endScene()
{

	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->EndScene();


	#ifdef _X86_
		_asm FINIT
	#endif
	return hr;
}


//////////////////////////////////////////////////////////////////
// getRenderTarget
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::getRenderTarget(I_dxj_DirectDrawSurface7 **ppsurf)
{	

	LPDIRECTDRAWSURFACE7	lpSurf=NULL;
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetRenderTarget(&lpSurf);
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpSurf, ppsurf);
	
	return S_OK;
}


//////////////////////////////////////////////////////////////////
// getTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice7->GetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX)m);
}

//////////////////////////////////////////////////////////////////
// multiplyTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::multiplyTransform(long transtype,
								D3dMatrix *m){	
	return m__dxj_Direct3dDevice7->MultiplyTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}

//////////////////////////////////////////////////////////////////
// setTransform
//////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTransform(long transtype,
								D3dMatrix  *m){	
	return m__dxj_Direct3dDevice7->SetTransform(
			(D3DTRANSFORMSTATETYPE) transtype,
			(LPD3DMATRIX) m);
}


//////////////////////////////////////////////////////////////////
// setRenderTarget
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::setRenderTarget(I_dxj_DirectDrawSurface7 *surf)
{		
	HRESULT hr;	
	if (!surf) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpref, surf);
	hr= m__dxj_Direct3dDevice7->SetRenderTarget(lpref,0);
	return hr;
}
		




//////////////////////////////////////////////////////////////////
// getTextureFormatsEnum
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureFormatsEnum(I_dxj_Direct3DEnumPixelFormats **ppRet)
{
	HRESULT hr;
	hr=C_dxj_Direct3DEnumPixelFormats7Object::create1(m__dxj_Direct3dDevice7,ppRet);
	return hr;
}





//////////////////////////////////////////////////////////////////
// validateDevice
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::validateDevice( 
            /* [retval][out] */ long __RPC_FAR *passes)
{
	HRESULT hr=m__dxj_Direct3dDevice7->ValidateDevice((DWORD*)passes);
	return hr;
}

//////////////////////////////////////////////////////////////////
// getTexture
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTexture( 
            /* [in] */ long stage,
            /* [retval][out] */ I_dxj_DirectDrawSurface7 __RPC_FAR *__RPC_FAR *retv)
{
	LPDIRECTDRAWSURFACE7 lpNew=NULL;
	HRESULT hr;

	*retv=NULL;
	hr=m__dxj_Direct3dDevice7->GetTexture((DWORD)stage,&lpNew);
	
	//null is valid
	if (lpNew==NULL) return S_OK;

	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lpNew, retv);	
	if (*retv==NULL) return E_OUTOFMEMORY;

	return hr;
}

//////////////////////////////////////////////////////////////////
// getTextureStageState
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [retval][out] */ long __RPC_FAR *retv)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD*)retv);
	return hr;
}

//////////////////////////////////////////////////////////////////
// setTexture
//////////////////////////////////////////////////////////////////			
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTexture( 
             long stage,
             I_dxj_DirectDrawSurface7  *tex)
{
	
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7, lpTex, tex);	
	hr=m__dxj_Direct3dDevice7->SetTexture((DWORD)stage,lpTex);

	return hr;
}


//////////////////////////////////////////////////////////////////
// setTextureStageState
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTextureStageState( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ long val)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->SetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD)val);
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getCaps
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getCaps( 
            D3dDeviceDesc7 *a)
{
	//if (a) a->lSize=sizeof(D3DDEVICEDESC7);
	

	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetCaps((D3DDEVICEDESC7*)a);
	return hr;
}


//////////////////////////////////////////////////////////////////
// getDirect3D
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getDirect3D( I_dxj_Direct3d7 **ret)
{

	HRESULT hr;
	LPDIRECT3D7 lpD3D=NULL;
	hr=m__dxj_Direct3dDevice7->GetDirect3D(&lpD3D);
	if FAILED(hr) return hr;
	if (!lpD3D) return E_FAIL;
	INTERNAL_CREATE(_dxj_Direct3d7,lpD3D,ret);
	return hr;

}



//////////////////////////////////////////////////////////////////
// setViewport
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setViewport( D3dViewport7 *viewport)
{

	HRESULT hr;	
	if(!viewport) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetViewport((D3DVIEWPORT7*)viewport);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getViewport
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getViewport( D3dViewport7 *viewport)
{

	HRESULT hr;	
	if(!viewport) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetViewport((D3DVIEWPORT7*)viewport);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// setMaterial
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setMaterial( D3dMaterial7 *mat)
{

	HRESULT hr;	
	if(!mat) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetMaterial((D3DMATERIAL7*)mat);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getMaterial
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getMaterial( D3dMaterial7 *mat)
{

	HRESULT hr;	
	if(!mat) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetMaterial((D3DMATERIAL7*)mat);		
	return hr;

}



//////////////////////////////////////////////////////////////////
// setLight
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setLight( long i,D3dLight7 *lgt)
{

	HRESULT hr;	
	if(!lgt) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->SetLight((DWORD)i,(D3DLIGHT7*)lgt);		
	return hr;

}

//////////////////////////////////////////////////////////////////
// getLight
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getLight( long i,D3dLight7 *lgt)
{

	HRESULT hr;	
	if(!lgt) return E_INVALIDARG;
	hr=m__dxj_Direct3dDevice7->GetLight((DWORD)i,(D3DLIGHT7*)lgt);		
	return hr;

}


//////////////////////////////////////////////////////////////////
// beginStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::beginStateBlock()
{

	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->BeginStateBlock();		
	return hr;

}

//////////////////////////////////////////////////////////////////
// endStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::endStateBlock( long *retv)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->EndStateBlock((DWORD*)retv);		
	return hr;
}


//////////////////////////////////////////////////////////////////
// deleteStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::deleteStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->DeleteStateBlock((DWORD)m);		
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// ApplyStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::applyStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->ApplyStateBlock((DWORD)m);		
	return hr;
}

//////////////////////////////////////////////////////////////////
// createStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::createStateBlock(long type, long *retval)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->CreateStateBlock((D3DSTATEBLOCKTYPE)type,(DWORD*)retval);		
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// captureStateBlock
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::captureStateBlock(long m)
{
	HRESULT hr;	
	hr=m__dxj_Direct3dDevice7->CaptureStateBlock((DWORD)m);		
	return hr;
}
    


//////////////////////////////////////////////////////////////////
// lightEnable
//////////////////////////////////////////////////////////////////					
STDMETHODIMP C_dxj_Direct3dDevice7Object::lightEnable( long index,  VARIANT_BOOL b){
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->LightEnable((DWORD)index,(b!=VARIANT_FALSE));
	return hr;
}

//////////////////////////////////////////////////////////////////
// lightEnable
//////////////////////////////////////////////////////////////////					
STDMETHODIMP C_dxj_Direct3dDevice7Object::getLightEnable( long index,  VARIANT_BOOL *bOut){
	HRESULT hr;
	BOOL	b;
	hr=m__dxj_Direct3dDevice7->GetLightEnable((DWORD)index,&b);
	if (b){
		*bOut=VARIANT_TRUE;
	}
	else {
		*bOut=VARIANT_FALSE;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// drawIndexedPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawIndexedPrimitive(
								d3dPrimitiveType  d3dpt,	
								long d3dvt,
								void *Verts,
								long vertexCount,
								SAFEARRAY **ppsaIndex,
								long indexArraySize,
								long flags){

	HRESULT hr;

	__try {
		hr=m__dxj_Direct3dDevice7->DrawIndexedPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(unsigned short*) ((SAFEARRAY*)*ppsaIndex)->pvData,
			(DWORD)indexArraySize,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////
// drawPrimitive
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawPrimitive(
								d3dPrimitiveType  d3dpt,
								long d3dvt,								
								void* Verts,
								long vertexCount,
								long flags){
	HRESULT hr;
	__try {
		hr= m__dxj_Direct3dDevice7->DrawPrimitive(
			(D3DPRIMITIVETYPE) d3dpt,
			(DWORD) d3dvt,
			(void*) Verts,
			(DWORD)vertexCount,
			(DWORD) flags);
	}
	__except(1, 1){	
		return DDERR_EXCEPTION;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// clear
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::clear(long count,SAFEARRAY **psa, long flags, long color, float z, long stencil )
{		 	
	if (!ISSAFEARRAY1D(psa,(DWORD)count)) return E_INVALIDARG;		
	return m__dxj_Direct3dDevice7->Clear( (DWORD)count,(D3DRECT*)((SAFEARRAY*)*psa)->pvData, flags ,color,z,stencil); 
}


//////////////////////////////////////////////////////////////////
// computeSphereVisibility
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::computeSphereVisibility( 
            D3dVector __RPC_FAR *center,
            float __RPC_FAR *radi,
            /* [retval][out] */ long __RPC_FAR *returnVal)
{
		HRESULT hr=m__dxj_Direct3dDevice7->ComputeSphereVisibility((LPD3DVECTOR)center,radi,1,0,(DWORD*)returnVal);
		return hr;
}

//////////////////////////////////////////////////////////////////
// drawIndexedPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawIndexedPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,
					   long startIndex,
					   long numIndex,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *indexArray,
            /* [in] */ long indexcount,
            /* [in] */ long flags)
{
	HRESULT hr;

	if (!indexArray) return E_FAIL;

	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER7 , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice7->DrawIndexedPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(DWORD) startIndex,
			(DWORD) numIndex,
			(WORD*) ((SAFEARRAY*)*indexArray)->pvData,					
			(DWORD)indexcount,
			(DWORD)flags);

	}
	__except(1,1){
		return DDERR_EXCEPTION;
	}
	return hr;
}
        
//////////////////////////////////////////////////////////////////
// drawPrimitiveVB
//////////////////////////////////////////////////////////////////		
STDMETHODIMP C_dxj_Direct3dDevice7Object::drawPrimitiveVB( 
            /* [in] */ d3dPrimitiveType d3dpt,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vertexBuffer,            
            /* [in] */ long startVertex,
            /* [in] */ long numVertices,
            /* [in] */ long flags)
{
	HRESULT hr;


	DO_GETOBJECT_NOTNULL(  LPDIRECT3DVERTEXBUFFER7 , lpVB, vertexBuffer);
	__try{

		hr=m__dxj_Direct3dDevice7->DrawPrimitiveVB
			((D3DPRIMITIVETYPE)d3dpt,
			lpVB,
			(DWORD) startVertex,
			(DWORD) numVertices,
			(DWORD)flags);

	}
	__except(1,1){

		return DDERR_EXCEPTION;
	}
	return hr;
}


STDMETHODIMP C_dxj_Direct3dDevice7Object::preLoad( I_dxj_DirectDrawSurface7 *surf)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(  LPDIRECTDRAWSURFACE7 , lpSurf, surf);
	hr= m__dxj_Direct3dDevice7->PreLoad(lpSurf);
	return hr;
}



//////////////////////////////////////////////////////////////////
// load
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::load( 
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *tex1,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ I_dxj_DirectDrawSurface7 __RPC_FAR *tex2,
            /* [in] */ Rect __RPC_FAR *rc,
            /* [in] */ long flags)
{
	HRESULT hr;	
	
	if (!tex1) return E_INVALIDARG;
	if (!tex2) return E_INVALIDARG;
	if (!rc) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpTex1,tex1);
	DO_GETOBJECT_NOTNULL(LPDIRECTDRAWSURFACE7,lpTex2,tex2);

	//dont allow this as it gpfs some drivers and is invalid anyway
	if (lpTex1==lpTex2) return E_INVALIDARG;

	POINT p;
	p.x=x;
	p.y=y;

	hr=m__dxj_Direct3dDevice7->Load(lpTex1,&p,lpTex2,(LPRECT)rc,(DWORD)flags);

	return hr;
}


//PASS_THROUGH_CAST_2_R(_dxj_Direct3dDevice7, setRenderState, SetRenderState, long,(D3DRENDERSTATETYPE), long ,(DWORD));


//////////////////////////////////////////////////////////////////
// setRenderStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setRenderStateSingle( 
            /* [in] */ long renderstate,            
            /* [in] */ float val)
{
	HRESULT hr;	 
	hr=m__dxj_Direct3dDevice7->SetRenderState((D3DRENDERSTATETYPE) renderstate, *((DWORD*)&val));
	return hr;
}


//////////////////////////////////////////////////////////////////
// getRenderStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getRenderStateSingle( 
            /* [in] */ long renderstate,            
            /* [in] */ float *val)
{
	HRESULT hr;	 
	hr=m__dxj_Direct3dDevice7->GetRenderState((D3DRENDERSTATETYPE) renderstate, (DWORD*)val);
	return hr;
}



//////////////////////////////////////////////////////////////////
// setTextureStageStateSingle
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float val)
{
	HRESULT hr;
	 
	hr=m__dxj_Direct3dDevice7->SetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, *((DWORD*)&val));
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getTextureStageState
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::getTextureStageStateSingle( 
            /* [in] */ long stage,
            /* [in] */ long state,
            /* [in] */ float *val)
{
	HRESULT hr;
	hr=m__dxj_Direct3dDevice7->GetTextureStageState((DWORD)stage,(D3DTEXTURESTAGESTATETYPE) state, (DWORD*)val);
	return hr;
}
        

//////////////////////////////////////////////////////////////////
// getInfo
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getInfo( 
            /* [in] */ long lDevInfoID,
            /* [out][in] */ void __RPC_FAR *DevInfoType,
            /* [in] */ long lSize)
{
	HRESULT hr;
	__try 
	{
		hr=m__dxj_Direct3dDevice7->GetInfo((DWORD)lDevInfoID,DevInfoType, (DWORD)lSize);
	}
	__except(1,1)
	{
		return E_FAIL;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////
// getDeviceGuid
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getDeviceGuid( BSTR *ret)
{
	HRESULT hr;
	D3DDEVICEDESC7 desc;
	
	if (!ret) return E_INVALIDARG;

	//desc.dwSize=sizeof(D3DDEVICEDESC7);
		
	hr=m__dxj_Direct3dDevice7->GetCaps(&desc);
	if FAILED(hr) return hr;


	*ret=D3DGUIDtoBSTR(&desc.deviceGUID);
	return hr;

}



//////////////////////////////////////////////////////////////////
// setClipPlane
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::setClipPlane(long index,float A, float B, float C, float D)
{
    HRESULT hr;		
    float floats[4];
    
    floats[0]=A;
    floats[1]=B;
    floats[2]=C;
    floats[3]=D;

	hr=m__dxj_Direct3dDevice7->SetClipPlane((DWORD)index, floats);

	return hr;

}

//////////////////////////////////////////////////////////////////
// setClipPlane
//////////////////////////////////////////////////////////////////				
        
STDMETHODIMP C_dxj_Direct3dDevice7Object::getClipPlane(long index,float *A, float *B, float *C, float *D)
{
    HRESULT hr;		
    float floats[4];
    
	hr=m__dxj_Direct3dDevice7->GetClipPlane((DWORD)index, floats);
    if FAILED(hr) return hr;
    
    *A=floats[0];
    *B=floats[1];
    *C=floats[2];
    *D=floats[3];

	return hr;

}


        
#if 0 
//////////////////////////////////////////////////////////////////
// clear
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::clear( 
            /* [in] */ long l1,
            /* [in] */ D3dRect __RPC_FAR *rc,
            /* [in] */ long l2,
            /* [in] */ long color,
            /* [in] */ float z,
            /* [in] */ long l3)
{
	HRESULT hr;
	if (!rc) return E_INVALIDARG;
	__try{
		hr=m__dxj_Direct3dDevice7->Clear((DWORD)l1,(D3DRECT*)rc,(DWORD)l2,(DWORD)color,(float)z,(DWORD)l3);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	
	return hr;
}

//////////////////////////////////////////////////////////////////
// setVertexComponent
//////////////////////////////////////////////////////////////////				
STDMETHODIMP C_dxj_Direct3dDevice7Object::setVertexComponent(  
  		    /* [in] */ long __RPC_FAR component,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *vb,
            /* [in] */ long l1,
            /* [in] */ long l2)
{
	HRESULT hr;
	if (!vb) return E_INVALIDARG;
	DO_GETOBJECT_NOTNULL(LPDIRECT3DVERTEXBUFFER7,pVB,vb);

	hr=m__dxj_Direct3dDevice7->SetVertexComponent((D3DVERTEXCOMPONENT)component, pVB,(DWORD)l1,(DWORD)l2);
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3dx8obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       d3dx8obj.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3dx8Obj.h"
#include "d3dx8.h"
#include "filestrm.h"
#include "dxerr8.h"
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }


STDMETHODIMP C_dxj_D3DX8Object::CreateFont( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
            /* [in] */ HANDLE hFont,
#else
            /* [in] */ long hFont,
#endif
            /* [retval][out] */ D3DXFont **retFont)
{
    HRESULT hr;
    hr= ::D3DXCreateFont( 
         (IDirect3DDevice8*) Device,
         (HFONT) hFont,
         (ID3DXFont**) retFont);
    return hr;
}



STDMETHODIMP C_dxj_D3DX8Object::DrawText( 
            /* [in] */ D3DXFont *BitmapFont,
            /* [in] */ long Color,
            /* [in] */ BSTR TextString,
            /* [in] */ RECT *Rect,
            /* [in] */ long Format)
{
    HRESULT hr;
    if (!BitmapFont) return E_INVALIDARG;

    USES_CONVERSION;
    char *szStr=W2T(TextString);
    
    ((ID3DXFont*)BitmapFont)->DrawTextA(szStr,-1, Rect, (DWORD) Format,(DWORD) Color);

    return S_OK;
}
        
STDMETHODIMP C_dxj_D3DX8Object::GetFVFVertexSize( 
            /* [in] */ long FVF,
            /* [retval][out] */ long*size)
{
    *size=(long)::D3DXGetFVFVertexSize((DWORD)FVF);
    return S_OK;
}
        

        
STDMETHODIMP C_dxj_D3DX8Object::AssembleShaderFromFile( 
            /* [in] */ BSTR SrcFile,
            /* [in] */ long flags,
            /* [in] */ BSTR *ErrLog,
	    /* [in] */ D3DXBuffer **Constants,
            /* [retval][out] */ D3DXBuffer **ppVertexShader)
{
    HRESULT hr;
    USES_CONVERSION;
    char *szFile=W2T(SrcFile);
    LPD3DXBUFFER pBuffer = NULL;
	WCHAR *wszData = NULL;

    hr=::D3DXAssembleShaderFromFile(
        szFile,
	(DWORD) flags,
	(ID3DXBuffer**) Constants,
        (ID3DXBuffer**) ppVertexShader,
        &pBuffer);

	if (FAILED(hr))
	{
		if (ErrLog)
		{
			if (*ErrLog)
				
			{
				SysFreeString(*ErrLog);
			}
		}
		
		if (pBuffer)
		{
			wszData = T2W((TCHAR*)pBuffer->GetBufferPointer());
			*ErrLog = SysAllocString(wszData);
		}
	}
	SAFE_RELEASE(pBuffer)
    //Wide string version still not exported
    //
    //hr=::D3DXAssembleVertexShaderFromFileW(
    //  (WCHAR*) SrcFile,
    //  (ID3DXBuffer**) ppVertexShader,
    //  NULL);
    
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::AssembleShader( 
            /* [in] */ BSTR  SrcData,
            /* [in] */ long flags,
	    /* [in] */ D3DXBuffer **Constants,
			/* [in][out][optional] */ BSTR *ErrLog,
            /* [retval][out] */ D3DXBuffer **ppVertexShader)
{
	WCHAR *wszData = NULL;
    char *szData=NULL;
    LPD3DXBUFFER pBuffer = NULL;
    DWORD dwLen=0;  
    HRESULT hr;
    USES_CONVERSION;        

    __try {
	DPF(1,"-----------------------------------In try block\n");
    szData=W2T((WCHAR*)SrcData);
    dwLen=strlen(szData);
	DPF(1,"-----------------------------------About to call Assembleshader\n");
    hr=::D3DXAssembleShader(
			szData,
			dwLen,
			(DWORD) flags,
			(ID3DXBuffer**) Constants,
			(ID3DXBuffer**) ppVertexShader,
			(ID3DXBuffer**) &pBuffer);
		DPF(1,"-----------------------------------Out of assembleshader\n");

		if (FAILED(hr))
		{
			DPF(1,"-----------------------------------Failed HR - WARNING\n");
			if (ErrLog)
			{
				DPF(1,"-----------------------------------Failed ERRLOG\n");
				if (*ErrLog)
				{
					DPF(1,"-----------------------------------Failed *ERRLOG\n");
					SysFreeString(*ErrLog);
				}
			}
			
			if (pBuffer)
			{
				wszData = T2W((TCHAR*)pBuffer->GetBufferPointer());
				*ErrLog = SysAllocString(wszData);
			}
		}
		SAFE_RELEASE(pBuffer)
    }
    __except(1,1)
    {
		SAFE_RELEASE(pBuffer)
        return E_INVALIDARG;
    }
    return hr;
}

        

        
STDMETHODIMP C_dxj_D3DX8Object::GetErrorString( 
            /* [in] */ long hr,
            /* [retval][out] */ BSTR* retStr)
{
    if (!retStr) return E_INVALIDARG;

    //NOT SysAllocString return NULL if DXGetErrorString returns NULL
    *retStr=SysAllocString(DXGetErrorString8W(hr));
    return S_OK;
}
 


       
STDMETHODIMP C_dxj_D3DX8Object::LoadSurfaceFromFile( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void*DestRect,
            /* [in] */ BSTR SrcFile,
            /* [in] */ void*SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo)
{
    HRESULT hr;

    hr=::D3DXLoadSurfaceFromFileW( 
        (IDirect3DSurface8*) DestSurface,
        (PALETTEENTRY*) DestPalette,
        (RECT*)     DestRect,
        (WCHAR*)    SrcFile,
        (RECT*)     SrcRect,
        (DWORD)     Filter,
        (D3DCOLOR)  ColorKey,
        (D3DXIMAGE_INFO*)SrcInfo);

    return hr;
}
    
    
        
STDMETHODIMP C_dxj_D3DX8Object::LoadSurfaceFromFileInMemory( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void* DestPalette,
            /* [in] */ void* DestRect,
            /* [in] */ void* SrcData,
            /* [in] */ long  LengthInBytes,
            /* [in] */ void* SrcRect,
            /* [in] */ long  Filter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo)
{   
    HRESULT hr;
    __try { 

    hr=::D3DXLoadSurfaceFromFileInMemory( 
        (IDirect3DSurface8*) DestSurface,
        (PALETTEENTRY*) DestPalette,
        (RECT*)     DestRect,
                    SrcData,
        (DWORD)     LengthInBytes,
        (RECT*)     SrcRect,
        (DWORD)     Filter,
        (D3DCOLOR)  ColorKey,
        (D3DXIMAGE_INFO*)SrcInfo);
    }
    __except(1,1)
    {
        return E_INVALIDARG;
    }

    return hr;

}

// TODO: fix from RECT to void pointer
        
STDMETHODIMP C_dxj_D3DX8Object::LoadSurfaceFromSurface( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ IUnknown *SrcSurface,
            /* [in] */ void *SrcPalette,
            /* [in] */ void *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey)
{
    HRESULT hr;

    hr=::D3DXLoadSurfaceFromSurface( 
            (IDirect3DSurface8*) DestSurface,
            (PALETTEENTRY*) DestPalette,
            (RECT*)    DestRect,
            (IDirect3DSurface8*) SrcSurface,
            (PALETTEENTRY*) SrcPalette,
            (RECT*) SrcRect,
            (DWORD) Filter,
            (D3DCOLOR) ColorKey);

    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::LoadSurfaceFromMemory( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ void *SrcData,
            /* [in] */ long formatSrc,
            /* [in] */ long SrcPitch,
            /* [in] */ void *SrcPalette,
            /* [in] */ RECT_CDESC *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey)
{
    HRESULT hr;

    hr =::D3DXLoadSurfaceFromMemory( 
            (IDirect3DSurface8*) DestSurface,
            (PALETTEENTRY*) DestPalette,
            (RECT*)         DestRect,
                            SrcData,
            (D3DFORMAT)     formatSrc,
            (DWORD)         SrcPitch,
            (PALETTEENTRY*) SrcPalette,
            (RECT*)         SrcRect,
            (DWORD)         Filter,
            (D3DCOLOR)      ColorKey);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::LoadSurfaceFromResource(
        IUnknown *pDestSurface,
        void*     pDestPalette,
        void*     pDestRect,
#ifdef _WIN64
        HANDLE      hSrcModule,
#else
        long      hSrcModule,
#endif
        BSTR      SrcResource,
        void*     pSrcRect,
        long      Filter,
        long      ColorKey,
        void*     SrcInfo)
{
    HRESULT hr;

    hr=::D3DXLoadSurfaceFromResourceW(
            (LPDIRECT3DSURFACE8)pDestSurface,
            (PALETTEENTRY*)     pDestPalette,
            (RECT*)             pDestRect,
            (HMODULE)           hSrcModule,
            (LPCWSTR)           SrcResource,
            (RECT*)             pSrcRect,
            (DWORD)             Filter,
            (D3DCOLOR)          ColorKey,
            (D3DXIMAGE_INFO*)   SrcInfo);

    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CheckTextureRequirements( 
            /* [out][in] */ IUnknown *Device,
            /* [out][in] */ long*Width,
            /* [out][in] */ long*Height,
            /* [out][in] */ long*NumMipLevels,
                            long Usage,
            /* [out][in] */ long*pPixelFormat,
                long Pool)
{
    HRESULT hr;

    hr=::D3DXCheckTextureRequirements( 
        (IDirect3DDevice8*) Device,
        (UINT*) Width,
        (UINT*) Height,
        (UINT*) NumMipLevels,
        (DWORD) Usage,
        (D3DFORMAT*) pPixelFormat,
        (D3DPOOL) Pool);


    return hr;


}
        
STDMETHODIMP C_dxj_D3DX8Object::CreateTexture( 
            /* [in] */ IUnknown *Device,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [retval][out] */ IUnknown **ppTexture)
{
    HRESULT hr;

    hr=::D3DXCreateTexture( 
        (IDirect3DDevice8*) Device,
        (DWORD) Width,
        (DWORD) Height,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (IDirect3DTexture8**) ppTexture);

    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromResource( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
			/* [in] */ HANDLE hSrcModule,
#else
			/* [in] */ long hSrcModule,
#endif
            /* [in] */ BSTR SrcResource,
            /* [retval][out] */ IUnknown **ppTexture)
{
    HRESULT hr;

    hr=::D3DXCreateTextureFromResourceW( 
        (IDirect3DDevice8*) Device,
        (HMODULE) hSrcModule,
        (WCHAR*) SrcResource,
        (IDirect3DTexture8**) ppTexture);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromResourceEx( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
            /* [in] */ HANDLE hSrcModule,
#else
            /* [in] */ long hSrcModule,
#endif
            /* [in] */ BSTR SrcResource,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture)
{
    HRESULT hr;


    hr=::D3DXCreateTextureFromResourceExW( 
            (IDirect3DDevice8*)     Device,
            (HMODULE)               hSrcModule,
            (WCHAR*)                SrcResource,
            (UINT)                  Width,
            (UINT)                  Height,
            (UINT)                  MipLevels,
            (DWORD)                 Usage,
            (D3DFORMAT)             PixelFormat,
            (D3DPOOL)               Pool,
            (DWORD)                 Filter,
            (DWORD)                 MipFilter,
            (D3DCOLOR)              ColorKey,
            (D3DXIMAGE_INFO*)       SrcInfo,
            (PALETTEENTRY*)         Palette,
            (LPDIRECT3DTEXTURE8*)   ppTexture);

    return hr;
}
            
STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromFile( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [retval][out] */ IUnknown **ppTexture)
{
    HRESULT hr;

    hr=::D3DXCreateTextureFromFileW( 
                (IDirect3DDevice8*)     Device,
                (WCHAR*)                SrcFile,
                (IDirect3DTexture8**)   ppTexture);

    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromFileEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
                       long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void*Palette,
            /* [retval][out] */ IUnknown **ppTexture)
{
    HRESULT hr;

    hr=::D3DXCreateTextureFromFileExW( 
        (IDirect3DDevice8*) Device,
        (WCHAR*) SrcFile,
        (DWORD) Width,
        (DWORD) Height,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (DWORD) Filter,
        (DWORD) MipFilter,
        (D3DCOLOR) ColorKey,
        (D3DXIMAGE_INFO*) SrcInfo,
        (PALETTEENTRY*) Palette,
        (IDirect3DTexture8**) ppTexture);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromFileInMemory( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [retval][out] */ IUnknown **ppTexture)

{
    HRESULT hr;

    hr=::D3DXCreateTextureFromFileInMemory( 
        (IDirect3DDevice8*) Device,
        (void*) SrcData,
        (DWORD) LengthInBytes,
        (IDirect3DTexture8**) ppTexture);

    return hr;
}
                
STDMETHODIMP C_dxj_D3DX8Object::CreateTextureFromFileInMemoryEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture)
{

    HRESULT hr;

    hr=::D3DXCreateTextureFromFileInMemoryEx( 
        (IDirect3DDevice8*) Device,
        SrcData,
        (DWORD) LengthInBytes,
        (DWORD) Width,
        (DWORD) Height,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (DWORD) Filter,
        (DWORD) MipFilter,
        (D3DCOLOR) ColorKey,
        (D3DXIMAGE_INFO*)   SrcInfo,
        (PALETTEENTRY*) Palette,
        (IDirect3DTexture8**) ppTexture);

    return hr;
}
               

STDMETHODIMP C_dxj_D3DX8Object::FilterTexture( 
            /* [in] */ IUnknown *Texture,
            /* [in] */ void *Palette,
            /* [in] */ long SrcLevel,
            /* [in] */ long Filter)
{
    HRESULT hr;

    hr =::D3DXFilterTexture(
        (IDirect3DTexture8*) Texture,
        (PALETTEENTRY*) Palette,
        (UINT) SrcLevel,
        (DWORD) Filter);

    return hr;
}


/************************************************/

STDMETHODIMP C_dxj_D3DX8Object::CheckCubeTextureRequirements( 
            /* [out][in] */ IUnknown *Device,
            /* [out][in] */ long *Size,
            /* [out][in] */ long *NumMipLevels,
                            long Usage,
            /* [out][in] */ long *pPixelFormat,
                            long Pool)
{
    HRESULT hr;

    hr=::D3DXCheckCubeTextureRequirements( 
        (IDirect3DDevice8*) Device,
        (UINT*) Size,
        (UINT*) NumMipLevels,
        (DWORD) Usage,
        (D3DFORMAT*) pPixelFormat,
        (D3DPOOL)Pool);

    return hr;
}

                                    
        
STDMETHODIMP C_dxj_D3DX8Object::CreateCubeTexture( 
            /* [in] */ IUnknown *Device,
            /* [in] */ long Size,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,   
            /* [retval][out] */ IUnknown **ppCubeTexture)
{
    HRESULT hr;

    hr=::D3DXCreateCubeTexture( 
        (IDirect3DDevice8*) Device,
        (DWORD) Size,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (IDirect3DCubeTexture8**) ppCubeTexture);

    return hr;
}



STDMETHODIMP C_dxj_D3DX8Object::CreateCubeTextureFromFile( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [retval][out] */ IUnknown **ppCubeTexture)
{
    HRESULT hr;
    hr=::D3DXCreateCubeTextureFromFileW( 
        (IDirect3DDevice8*) Device,
        (WCHAR*) SrcFile,
        (IDirect3DCubeTexture8**) ppCubeTexture);
    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::CreateCubeTextureFromFileEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [in] */ long Width,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,   
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void*Palette,
            /* [retval][out] */ IUnknown **ppCubeTexture)
{
    HRESULT hr;
    hr=::D3DXCreateCubeTextureFromFileExW( 
        (IDirect3DDevice8*) Device,
        (WCHAR*) SrcFile,
        (DWORD) Width,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (DWORD) Filter,
        (DWORD) MipFilter,
        (D3DCOLOR) ColorKey,
        (D3DXIMAGE_INFO*) SrcInfo,
        (PALETTEENTRY*) Palette,
        (IDirect3DCubeTexture8**) ppCubeTexture);

    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::CreateCubeTextureFromFileInMemory( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [retval][out] */ IUnknown **ppCubeTexture)

{
    HRESULT hr;
    hr=::D3DXCreateCubeTextureFromFileInMemory( 
        (IDirect3DDevice8*) Device,
         SrcData,
        (DWORD) LengthInBytes,
        (IDirect3DCubeTexture8**) ppCubeTexture);
    return hr;
}
                
STDMETHODIMP C_dxj_D3DX8Object::CreateCubeTextureFromFileInMemoryEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [in] */ long Width,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,   
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppCubeTexture)
{

    HRESULT hr;
    hr=::D3DXCreateCubeTextureFromFileInMemoryEx( 
        (IDirect3DDevice8*) Device,
        SrcData,
        (DWORD) LengthInBytes,
        (DWORD) Width,
        (DWORD) MipLevels,
        (DWORD) Usage,
        (D3DFORMAT) PixelFormat,
        (D3DPOOL) Pool,
        (DWORD) Filter,
        (DWORD) MipFilter,
        (D3DCOLOR) ColorKey,
	(D3DXIMAGE_INFO*) SrcInfo,
        (PALETTEENTRY*) Palette,
        (IDirect3DCubeTexture8**) ppCubeTexture);

    return hr;
}



STDMETHODIMP C_dxj_D3DX8Object::FilterCubeTexture( 
            /* [in] */ IUnknown *CubeTexture,
            /* [in] */ void *Palette,
            /* [in] */ long SrcLevel,
            /* [in] */ long Filter)
{
    HRESULT hr;

    hr =::D3DXFilterCubeTexture(
        (IDirect3DCubeTexture8*) CubeTexture,
        (PALETTEENTRY*) Palette,
        (UINT) SrcLevel,
        (DWORD) Filter);

    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::CheckVolumeTextureRequirements(
        IUnknown          *Device,
        long*             Width,
        long*             Height,
        long*             Depth,
        long*             NumMipLevels,
        long              Usage,
        long*             Format,
        long              Pool)
{

    HRESULT hr;

    hr=::D3DXCheckVolumeTextureRequirements( 
                (IDirect3DDevice8*) Device,
                (UINT*) Width, (UINT*) Height, (UINT*) Depth,
                (UINT*) NumMipLevels,
                (DWORD) Usage,
                (D3DFORMAT*)Format,
                (D3DPOOL) Pool);


    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::CreateVolumeTexture(
    IUnknown            *Device,
    long            Width,
    long            Height,
    long            Depth,
    long            MipLevels,
    long            Usage,
    long            PixelFormat,
    long            Pool,   
    IUnknown        **ppVolumeTexture)
{
    HRESULT hr;

    hr=::D3DXCreateVolumeTexture(
            (IDirect3DDevice8*) Device,
            (UINT)              Width,
            (UINT)              Height,
            (UINT)              Depth,
            (UINT)              MipLevels,
            (DWORD)             Usage,
            (D3DFORMAT)         PixelFormat,
            (D3DPOOL)           Pool,
            (LPDIRECT3DVOLUMETEXTURE8*) ppVolumeTexture);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::FilterVolumeTexture(
    IUnknown  *pVolumeTexture,
    void      *pPalette,
    long      SrcLevel,
    long      Filter)
{
    HRESULT hr;

        hr=::D3DXFilterVolumeTexture(
            (LPDIRECT3DVOLUMETEXTURE8)  pVolumeTexture,
            (PALETTEENTRY*)             pPalette,
            (UINT)                      SrcLevel,
            (DWORD)                     Filter);

    return hr;

}

STDMETHODIMP C_dxj_D3DX8Object::LoadVolumeFromVolume(
    IUnknown          *pDestVolume,
    void              *pDestPalette,
    void              *pDestBox,
    IUnknown          *pSrcVolume,
    void              *pSrcPalette,
    void              *pSrcBox,
    long              Filter,
    long              ColorKey)
{ 

    HRESULT hr;

    hr=::D3DXLoadVolumeFromVolume(
            (LPDIRECT3DVOLUME8)     pDestVolume,
            (PALETTEENTRY*)         pDestPalette,
            (D3DBOX*)               pDestBox,
            (LPDIRECT3DVOLUME8)     pSrcVolume,
            (PALETTEENTRY*)         pSrcPalette,
            (D3DBOX*)               pSrcBox,
            (DWORD)                 Filter,
            (D3DCOLOR)              ColorKey);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::LoadVolumeFromMemory(
    IUnknown        *pDestVolume,
    void            *pDestPalette,
    void            *pDestRect,
    void            *pSrcMemory,
    long            SrcFormat,
    long            SrcRowPitch,
    long            SrcSlicePitch,
    void            *pSrcPalette,
    void            *pSrcBox,
    long            Filter,
    long            ColorKey)
{
    HRESULT hr;

    hr=::D3DXLoadVolumeFromMemory(
           (LPDIRECT3DVOLUME8)     pDestVolume,
           (PALETTEENTRY*)         pDestPalette,
           (D3DBOX*)               pDestRect,
           (LPVOID)                pSrcMemory,
           (D3DFORMAT)             SrcFormat,
           (UINT)                  SrcRowPitch,
           (UINT)                  SrcSlicePitch,
           (PALETTEENTRY*)         pSrcPalette,
           (D3DBOX*)               pSrcBox,
           (DWORD)                 Filter,
           (D3DCOLOR)              ColorKey);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::CreateMesh( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long options,
            /* [in] */ void *Declaration,
            /* [in] */ IUnknown __RPC_FAR *pD3D,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *ppMesh)
{
    HRESULT hr;

    hr=::D3DXCreateMesh(
        (DWORD) numFaces,
        (DWORD) numVertices,
        (DWORD) options,
        (DWORD*) Declaration,
        (LPDIRECT3DDEVICE8)pD3D,
        (ID3DXMesh**)ppMesh);
        
    return hr;
}




STDMETHODIMP C_dxj_D3DX8Object::CreateMeshFVF( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long options,
            /* [in] */ long fvf,
            /* [in] */ IUnknown __RPC_FAR *pD3D,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *ppMesh)
{
    HRESULT hr;
    hr=::D3DXCreateMeshFVF(
        (DWORD) numFaces,
        (DWORD) numVertices,
        (DWORD) options,
        (DWORD) fvf,
        (LPDIRECT3DDEVICE8)pD3D,
        (ID3DXMesh**)ppMesh);
        
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateSPMesh( 
            /* [in] */ D3DXMesh __RPC_FAR *pMesh,
            void* Adjacency, 
            void* VertexAttributeWeights,
            void* VertexWeights,
            /* [retval][out] */ D3DXSPMesh __RPC_FAR *__RPC_FAR *ppSMesh)
{
    HRESULT hr;
    hr=::D3DXCreateSPMesh(
        (ID3DXMesh*)             pMesh,
        (DWORD*)                 Adjacency,
        (LPD3DXATTRIBUTEWEIGHTS) VertexAttributeWeights,
        (float *)                VertexWeights,
        (ID3DXSPMesh**)          ppSMesh);      
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::GeneratePMesh( 
            /* [in] */ D3DXMesh __RPC_FAR *pMesh,
            /* [in] */ void* Adjacency, 
            /* [in] */ void* VertexAttributeWeights,
            /* [in] */ void* VertexWeights,
            /* [in] */ long minValue,
            /* [in] */ long options,
            /* [retval][out] */ D3DXPMesh __RPC_FAR *__RPC_FAR *ppPMesh)
{
    HRESULT hr;
    hr=::D3DXGeneratePMesh(
        (ID3DXMesh*) pMesh,
        (DWORD*) Adjacency,
        (LPD3DXATTRIBUTEWEIGHTS) VertexAttributeWeights,
        (float *) VertexWeights,
        (DWORD) minValue,
        (DWORD) options,
        (ID3DXPMesh**)ppPMesh);     

    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::SimplifyMesh( 
            /* [in] */ D3DXMesh __RPC_FAR *pMesh,
            void* Adjacency, 
            void* VertexAttributeWeights,
            void* VertexWeights,
            long minValue,
            long options,
            D3DXMesh __RPC_FAR *__RPC_FAR *ppMesh)
{
    HRESULT hr;
    hr=::D3DXSimplifyMesh(
        (ID3DXMesh*) pMesh,
        (DWORD*) Adjacency,
        (LPD3DXATTRIBUTEWEIGHTS) VertexAttributeWeights,
        (float *) VertexWeights,
        (DWORD)  minValue,
        (DWORD) options,
        (ID3DXMesh**)ppMesh);       
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::ComputeBoundingSphere( 
            /* [in] */ void __RPC_FAR *PointsFVF,
            /* [in] */ long numVertices,
            /* [in] */ long FVF,
            /* [in] */ D3DVECTOR_CDESC __RPC_FAR *Centers,
            /* [out][in] */ float __RPC_FAR *RadiusArray)
{
    HRESULT hr;
    hr=::D3DXComputeBoundingSphere(
        PointsFVF,
        (DWORD) numVertices,
        (DWORD) FVF,
        (D3DXVECTOR3*) Centers,
        RadiusArray);
    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::ComputeBoundingBox( 
            /* [in] */ void __RPC_FAR *PointsFVF,
            /* [in] */ long numVertices,
            /* [in] */ long FVF,
            /* [out] */ D3DVECTOR_CDESC __RPC_FAR *MinVec,
            /* [out] */ D3DVECTOR_CDESC __RPC_FAR *MaxVec)
{
    HRESULT hr;
    hr=::D3DXComputeBoundingBox(
        PointsFVF,
        (DWORD) numVertices,
        (DWORD) FVF,
        (D3DXVECTOR3*) MinVec,
        (D3DXVECTOR3*) MaxVec);

    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::ComputeNormals( D3DXBaseMesh *pMesh)
{
    HRESULT hr;
    hr=::D3DXComputeNormals((ID3DXBaseMesh*)pMesh, NULL);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateBuffer( 
            /* [in] */ long numBytes,
            /* [retval][out] */ D3DXBuffer __RPC_FAR *__RPC_FAR *ppBuffer)
{
    HRESULT hr;
    hr=::D3DXCreateBuffer((DWORD) numBytes,(ID3DXBuffer**) ppBuffer);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::LoadMeshFromX( 
            /* [in] */ BSTR Filename,
            /* [in] */ long options,
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [out] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [out] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retMaterials,
            /* [out] */ long __RPC_FAR *retMaterialCount,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *retMesh)
{
    USES_CONVERSION;
    HRESULT hr;
    if (!D3DDevice) return E_INVALIDARG;

    char *szName=W2T(Filename);
    hr=::D3DXLoadMeshFromX(
        szName,
        (DWORD) options,
        (IDirect3DDevice8*) D3DDevice,
        (ID3DXBuffer**) retAdjacency,
        (ID3DXBuffer**) retMaterials,
        (DWORD*)    retMaterialCount,
        (ID3DXMesh**) retMesh);
        
    return hr;
}



STDMETHODIMP C_dxj_D3DX8Object::SaveMeshToX( 
            /* [in] */ BSTR Filename,
            /* [in] */ D3DXMesh __RPC_FAR *Mesh,
            /* [in] */ void *AdjacencyArray,
            /* [in] */ D3DXMATERIAL_CDESC __RPC_FAR *MaterialArray,
            /* [in] */ long MaterialCount,
            /* [in] */ long xFormat)
{
    HRESULT hr;
    USES_CONVERSION;
    char *szName=W2T(Filename);
    
    D3DXMATERIAL *pMaterials=NULL;
    if (MaterialCount > 0)  {

        //cleaned up when out of scope
        pMaterials=(D3DXMATERIAL*)alloca(sizeof(D3DXMATERIAL)*MaterialCount);   
        if (!pMaterials) return E_OUTOFMEMORY;

        __try 
        {
            for (long i=0; i<MaterialCount; i++)
            {
                memcpy (&(pMaterials[i].MatD3D), &(MaterialArray[i].MatD3D),sizeof(D3DMATERIAL8));
                pMaterials[i].pTextureFilename=W2T(MaterialArray[i].TextureFilename);
            
            }
        }
        __except(1,1)
        {
           return E_INVALIDARG;
        }

    }


    
    hr=::D3DXSaveMeshToX(
        szName,
        (ID3DXMesh*) Mesh,
        (DWORD*) AdjacencyArray,
        (D3DXMATERIAL*) pMaterials,
        (DWORD) MaterialCount,
        (DWORD) xFormat);
        
    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::SavePMeshToFile( 
            /* [in] */ BSTR Filename,
            /* [in] */ D3DXPMesh __RPC_FAR *Mesh,
            /* [in] */ D3DXMATERIAL_CDESC __RPC_FAR *MaterialArray,
            /* [in] */ long MaterialCount)

{
    HRESULT hr=S_OK;

	if (!Filename)
		return E_INVALIDARG;

    USES_CONVERSION;
    char *szName=W2T(Filename);

    if (!Mesh) return E_INVALIDARG;

    IStream *pStream= (IStream*) new CFileStream(szName, FALSE,TRUE,&hr);
    if (!pStream) return E_OUTOFMEMORY;
    if FAILED(hr) return hr;


    __try 
    {
	D3DXMATERIAL *pRealMaterials=NULL;
	if (MaterialCount > 0)
        {
                pRealMaterials= (D3DXMATERIAL *) malloc( sizeof(D3DXMATERIAL) * MaterialCount );
                if (!pRealMaterials) return E_OUTOFMEMORY;
        }
        for (long i=0;i<MaterialCount;i++)
	{
                memcpy (&(pRealMaterials[i].MatD3D), &(MaterialArray[i].MatD3D),sizeof (D3DMATERIAL8));

		//can be NULL - freed on return as they are allocated locally
		pRealMaterials[i].pTextureFilename=W2T(MaterialArray[i].TextureFilename);
        }

        hr=((ID3DXPMesh*)Mesh)->Save(pStream,pRealMaterials,(DWORD)MaterialCount);

	free(pRealMaterials);


    }
    __except(1,1)
    {
        pStream->Release();
        return E_INVALIDARG;
    }

    pStream->Release();
    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::LoadPMeshFromFile( 
            /* [in] */ BSTR Filename,
            /* [in] */ long options,
            /* [in] */ IUnknown __RPC_FAR *pD3DDevice,
            /* [out] */ D3DXBuffer **RetMaterials,
            /* [out] */ long __RPC_FAR *RetNumMaterials,
            /* [retval][out] */ D3DXPMesh __RPC_FAR *__RPC_FAR *RetPMesh) 

{
    HRESULT hr=S_OK;

    USES_CONVERSION;
    char *szName=W2T(Filename);


    IStream *pStream= (IStream*) new CFileStream(szName, TRUE,FALSE,&hr);
    if (!pStream) return E_OUTOFMEMORY;
    if FAILED(hr) return hr;

    hr=D3DXCreatePMeshFromStream(
            pStream, 
            (DWORD) options,
            (LPDIRECT3DDEVICE8) pD3DDevice, 
            (LPD3DXBUFFER *)RetMaterials,
            (DWORD*) RetNumMaterials,
            (LPD3DXPMESH *) RetPMesh);

    pStream->Release();
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::LoadMeshFromXof( 
            /* [in] */ IUnknown __RPC_FAR *xofobjMesh,
            /* [in] */ long options,
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [out] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [out] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retMaterials,
            /* [out] */ long __RPC_FAR *retMaterialCount,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *retMesh)
{
    HRESULT hr=S_OK;

    IDirectXFileData    *pRealXFileData=NULL;
    I_dxj_DirectXFileData   *pCoverXFileData=NULL;

    if (!xofobjMesh) return E_INVALIDARG;

    hr= xofobjMesh->QueryInterface(IID_IDirectXFileData,(void**)&pRealXFileData);
    if FAILED(hr) 
    {
        hr=xofobjMesh->QueryInterface(IID_I_dxj_DirectXFileData,(void**)&pCoverXFileData);  
            if FAILED(hr) return hr;
    
        //beware does not addref but interface cant go away as long as we have 
        //ref count on cover object
        hr=pCoverXFileData->InternalGetObject((IUnknown**)&pRealXFileData);         
        if (FAILED(hr) || (!pRealXFileData))
        {
            //We should never get here but 
            //Consider changing this to an assert
            pCoverXFileData->Release();
            return E_FAIL;          
        }

        
        pRealXFileData->AddRef();

        pCoverXFileData->Release();
            if FAILED(hr) return hr;
    }


    hr=::D3DXLoadMeshFromXof(
        pRealXFileData,
        (DWORD) options,
        (IDirect3DDevice8*) D3DDevice,
        (ID3DXBuffer**) retAdjacency,
        (ID3DXBuffer**) retMaterials,
        (DWORD*)    retMaterialCount,
        (ID3DXMesh**) retMesh); 
        

    return hr;
}
 
        
STDMETHODIMP C_dxj_D3DX8Object::TessellateNPatches( 
            /* [in] */ D3DXMesh __RPC_FAR *MeshIn,
        /* [in] */ void*Adjacency,
            /* [in] */ float NumSegs,
		VARIANT_BOOL QuadraticInterpNormals,
		/*[in,out, optional] */ D3DXBuffer **AdjacencyOut, 
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *pptmMeshOut)
{
    HRESULT hr;
    BOOL bQuadraticInterpNormals=QuadraticInterpNormals ? TRUE : FALSE;

	
    hr=::D3DXTessellateNPatches(
        (ID3DXMesh*) MeshIn,
        (DWORD*) Adjacency,
        (float) NumSegs,
	bQuadraticInterpNormals,
        (ID3DXMesh**)pptmMeshOut,
	(ID3DXBuffer**)AdjacencyOut);
    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::DeclaratorFromFVF( 
            long FVF,
            D3DXDECLARATOR_CDESC *Declarator)
{
    HRESULT hr;
    hr=::D3DXDeclaratorFromFVF(
        (DWORD) FVF,
        (DWORD*) Declarator);
    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::FVFFromDeclarator( 
            D3DXDECLARATOR_CDESC *Declarator,
            long *FVF)
{
    HRESULT hr;
    hr=::D3DXFVFFromDeclarator(
        (DWORD*) Declarator,
        (DWORD*) FVF);
    return hr;
}




        
STDMETHODIMP C_dxj_D3DX8Object::BufferGetMaterial( 
            /* [in] */ D3DXBuffer __RPC_FAR  *MaterialBuffer,
            /* [in] */ long index,
            /* [retval][out] */ D3DMATERIAL8_CDESC __RPC_FAR *mat)
{
    if (!MaterialBuffer) return E_INVALIDARG;

    D3DXMATERIAL *pMatArray=(D3DXMATERIAL*) ((ID3DXBuffer*)MaterialBuffer)->GetBufferPointer();
    __try {
        memcpy(mat,&(pMatArray[index].MatD3D),sizeof(D3DMATERIAL8));
    }
    __except(1,1){
        return E_INVALIDARG;
    }
    return S_OK;
}

        
STDMETHODIMP C_dxj_D3DX8Object::BufferGetTextureName( 
            /* [in] */ D3DXBuffer __RPC_FAR  *MaterialBuffer,
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retName)
{
    USES_CONVERSION;
    WCHAR *wszName=NULL;

    if (!MaterialBuffer) return E_INVALIDARG;

    D3DXMATERIAL *pMatArray=(D3DXMATERIAL*)((ID3DXBuffer*)MaterialBuffer)->GetBufferPointer();
    __try {
        wszName=T2W(pMatArray[index].pTextureFilename);
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    *retName=SysAllocString(wszName);

    return S_OK;
}

        
STDMETHODIMP C_dxj_D3DX8Object::BufferGetBoneName( 
            /* [in] */ D3DXBuffer __RPC_FAR  *BoneNameBuffer,
            /* [in] */ long index,
            /* [retval][out] */ BSTR __RPC_FAR *retName)
{
    USES_CONVERSION;
    WCHAR *wszName=NULL;

    if (!BoneNameBuffer) return E_INVALIDARG;

    char **ppArray=(char**)((ID3DXBuffer*)BoneNameBuffer)->GetBufferPointer();
    __try {
        wszName=T2W(ppArray[index]);
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    *retName=SysAllocString(wszName);

    return S_OK;
}
        
STDMETHODIMP C_dxj_D3DX8Object::BufferGetData( 
            /* [in] */ D3DXBuffer __RPC_FAR *Buffer,
            /* [in] */ long index,
            /* [in] */ long typesize,
            /* [in] */ long typecount,
            /* [out][in] */ void __RPC_FAR *data)
{

    if (!Buffer) return E_INVALIDARG;

    char *pData=(char*)((ID3DXBuffer*)Buffer)->GetBufferPointer();
    
    DWORD dwStart= (DWORD) index*typesize;
    DWORD dwCount= (DWORD) typecount*typesize;

    __try {
        memcpy(data,&(pData[dwStart]),dwCount);
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    return S_OK;
}


STDMETHODIMP C_dxj_D3DX8Object:: BufferGetBoneCombo( 
            D3DXBuffer  *Buffer,
	    long index,
            D3DXBONECOMBINATION_CDESC *desc)
{

    if (!Buffer) return E_INVALIDARG;

    D3DXBONECOMBINATION_CDESC *pData=(D3DXBONECOMBINATION_CDESC*)((ID3DXBuffer*)Buffer)->GetBufferPointer();
    

    __try {
        memcpy(desc,&(pData[index]),sizeof (D3DXBONECOMBINATION_CDESC));
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    return S_OK;
}

				 
STDMETHODIMP C_dxj_D3DX8Object::BufferGetBoneComboBoneIds( 
            D3DXBuffer  *Buffer,
	    long index,
	    long PaletteSize,
	    void *BoneIds)
{

    if (!Buffer) return E_INVALIDARG;
    if (PaletteSize <=0) return E_INVALIDARG;

    D3DXBONECOMBINATION *pData=(D3DXBONECOMBINATION*)((ID3DXBuffer*)Buffer)->GetBufferPointer();

    __try {
        memcpy(BoneIds,pData[index].BoneId,PaletteSize*sizeof(DWORD));
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    return S_OK;
}


        
STDMETHODIMP C_dxj_D3DX8Object::BufferSetData( 
            /* [in] */ D3DXBuffer __RPC_FAR *Buffer,
            /* [in] */ long index,
            /* [in] */ long typesize,
            /* [in] */ long typecount,
            /* [out][in] */ void __RPC_FAR *data)
{

    if (!Buffer) return E_INVALIDARG;

    char *pData=(char*)((ID3DXBuffer*)Buffer)->GetBufferPointer();
    
    DWORD dwStart= (DWORD) index*typesize;
    DWORD dwCount= (DWORD) typecount*typesize;

    __try {
        memcpy(&(pData[dwStart]),data,dwCount);
    }
    __except(1,1){
        return E_INVALIDARG;
    }

    return S_OK;

}

STDMETHODIMP C_dxj_D3DX8Object::Intersect(
            /* [in] */ D3DXMesh *MeshIn,
            /* [in] */ D3DVECTOR_CDESC *RayPos,
            /* [in] */ D3DVECTOR_CDESC *RayDir,
            /* [out] */ LONG *retHit,
            /* [out] */ LONG *retFaceIndex,
            /* [out] */ FLOAT *U,
            /* [out] */ FLOAT *V,
            /* [out] */ FLOAT *retDist,
            /* [out] */ LONG *countHits,
            /* [retval][out] */ D3DXBuffer **AllHits)
{

    HRESULT hr;
    hr=D3DXIntersect(
            (LPD3DXMESH) MeshIn,
            (D3DXVECTOR3*) RayPos,
            (D3DXVECTOR3*) RayDir,
            (BOOL *)    retHit,
            (DWORD*)    retFaceIndex,
            (float*)    U,
            (float*)    V,
            (float*)    retDist,
			(LPD3DXBUFFER*) AllHits,
			(DWORD*)countHits);
    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::SphereBoundProbe(
    D3DVECTOR_CDESC *Center,
    float Radius,
        D3DVECTOR_CDESC *RayPosition,
        D3DVECTOR_CDESC *RayDirection,
    VARIANT_BOOL *retHit)
{
    BOOL bRet=FALSE;

    bRet=D3DXSphereBoundProbe(
        (D3DXVECTOR3 *) Center,
        Radius,
        (D3DXVECTOR3 *) RayPosition,
        (D3DXVECTOR3 *) RayDirection);
    if (bRet)
    {
    *retHit=VARIANT_TRUE;
    }
    else
    {
    *retHit=VARIANT_FALSE;
    }
    return S_OK;
}



STDMETHODIMP C_dxj_D3DX8Object::ComputeBoundingSphereFromMesh(
                /*[in]*/            D3DXMesh *MeshIn, 
                /*[in]*/            D3DVECTOR_CDESC *Centers, 
                /*[in,out]*/        float *RadiusArray)
{

    HRESULT hr;
    BYTE    *pPointsFVF=NULL;

    if (!MeshIn) return E_INVALIDARG;

    DWORD dwFVF= ((LPD3DXMESH)MeshIn)->GetFVF();
    DWORD dwVertices= ((LPD3DXMESH)MeshIn)->GetNumVertices();   

    hr=((LPD3DXMESH)MeshIn)->LockVertexBuffer(0,&pPointsFVF);
    if FAILED(hr) return hr;
            

    hr=::D3DXComputeBoundingSphere(
        pPointsFVF,
        dwVertices,
        dwFVF,
        (D3DXVECTOR3*) Centers,
        RadiusArray);

    ((LPD3DXMESH)MeshIn)->UnlockVertexBuffer();


    return hr;

}



STDMETHODIMP C_dxj_D3DX8Object::ComputeBoundingBoxFromMesh( 
            /*[in]*/     D3DXMesh *MeshIn, 
            /*[in,out]*/ D3DVECTOR_CDESC *MinArray, 
            /*[in,out]*/ D3DVECTOR_CDESC *MaxArray)

{

    HRESULT hr;
    BYTE    *pPointsFVF=NULL;

    if (!MeshIn) return E_INVALIDARG;

    DWORD dwFVF= ((LPD3DXMESH)MeshIn)->GetFVF();
    DWORD dwVertices= ((LPD3DXMESH)MeshIn)->GetNumVertices();   

    hr=((LPD3DXMESH)MeshIn)->LockVertexBuffer(0,&pPointsFVF);
    if FAILED(hr) return hr;
            

    hr=::D3DXComputeBoundingBox(
        pPointsFVF,
        dwVertices,
        dwFVF,
        (D3DXVECTOR3*) MinArray,
        (D3DXVECTOR3*) MaxArray);


    ((LPD3DXMESH)MeshIn)->UnlockVertexBuffer();


    return hr;

}


STDMETHODIMP C_dxj_D3DX8Object::CreateSkinMesh( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long numBones,
            /* [in] */ long options,
            /* [in] */ void __RPC_FAR *Declaration,
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [retval][out] */ D3DXSkinMesh __RPC_FAR *__RPC_FAR *SkinMesh) 
{
    HRESULT hr;
    hr=::D3DXCreateSkinMesh((DWORD) numFaces,(DWORD)numVertices,
            (DWORD)numBones,(DWORD)options,
            (DWORD *)Declaration,(IDirect3DDevice8*) D3DDevice,
            (ID3DXSkinMesh**) SkinMesh);
    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::CreateSkinMeshFVF( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long numBones,
            /* [in] */ long options,
            /* [in] */ long fvf,
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            D3DXSkinMesh __RPC_FAR *__RPC_FAR *SkinMeshRet) 
{
    HRESULT hr;
    hr =::D3DXCreateSkinMeshFVF((DWORD)numFaces,(DWORD)numVertices,(DWORD)numBones,
            (DWORD)options,(DWORD)fvf,(IDirect3DDevice8*)D3DDevice,
            (ID3DXSkinMesh**) SkinMeshRet);
    
    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::CreateSkinMeshFromMesh( 
            /* [in] */ D3DXMesh __RPC_FAR *Mesh,
            /* [in] */ long numBones,
            /* [retval][out] */ D3DXSkinMesh __RPC_FAR *__RPC_FAR *SkinMeshRet) 
{
    HRESULT hr;
	if (!Mesh)
		return E_INVALIDARG;

    hr=::D3DXCreateSkinMeshFromMesh((ID3DXMesh*) Mesh,(DWORD)numBones,(ID3DXSkinMesh**) SkinMeshRet);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::LoadSkinMeshFromXof( 
            /* [in] */      IUnknown    *xofobjMesh,
            /* [in] */      long        options,
            /* [in] */      IUnknown    *D3DDevice,
            /* [out][in] */ D3DXBuffer  **RetAdjacency,
            /* [out][in] */ D3DXBuffer  **RetMaterials,
            /* [out][in] */ long        *RetMaterialCount,
            /* [out][in] */ D3DXBuffer  **RetBoneNames,
            /* [out][in] */ D3DXBuffer  **RetBoneTransforms,
            /* [retval][out] */ D3DXSkinMesh **RetMesh) 
{
    HRESULT hr=S_OK;

    IDirectXFileData    *pRealXFileData=NULL;
    I_dxj_DirectXFileData   *pCoverXFileData=NULL;

    if (!xofobjMesh) return E_INVALIDARG;

    hr= xofobjMesh->QueryInterface(IID_IDirectXFileData,(void**)&pRealXFileData);
    if FAILED(hr) 
    {
        hr=xofobjMesh->QueryInterface(IID_I_dxj_DirectXFileData,(void**)&pCoverXFileData);  
            if FAILED(hr) return hr;
    
        //beware does not addref but interface cant go away as long as we have 
        //ref count on cover object
        hr=pCoverXFileData->InternalGetObject((IUnknown**)&pRealXFileData);         
        if (FAILED(hr) || (!pRealXFileData))
        {
            //We should never get here but 
            //Consider changing this to an assert
            pCoverXFileData->Release();
            return E_FAIL;          
        }

        
        pRealXFileData->AddRef();

        pCoverXFileData->Release();
            if FAILED(hr) return hr;
    }


    hr=::D3DXLoadSkinMeshFromXof(
        pRealXFileData,
        (DWORD) options,
        (IDirect3DDevice8*) D3DDevice,
        (ID3DXBuffer**) RetAdjacency,
        (ID3DXBuffer**) RetMaterials,
        (DWORD*)    RetMaterialCount,
        (ID3DXBuffer**) RetBoneNames, 
        (ID3DXBuffer**) RetBoneTransforms,
        (ID3DXSkinMesh**) RetMesh); 
        

    return hr;

}



STDMETHODIMP C_dxj_D3DX8Object::CreatePolygon( 
            /* [in] */  IUnknown __RPC_FAR *D3DDevice,
            /* [in] */  float Length,
            /* [in] */  long Sides,
            /* [out][in] */     D3DXBuffer  **retAdjacency,
            /* [retval][out] */ D3DXMesh    **RetMesh) 
{
    HRESULT hr;
    hr=D3DXCreatePolygon(
        (IDirect3DDevice8*) D3DDevice,
        Length,
        (UINT) Sides,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::CreateBox( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [in] */ float Width,
            /* [in] */ float Height,
            /* [in] */ float Depth,
            /* [out][in] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh) 
{
    HRESULT hr;
    hr=D3DXCreateBox(
        (IDirect3DDevice8*) D3DDevice,
        Width,
        Height,
        Depth,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateCylinder( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [in] */ float Radius1,
            /* [in] */ float Radius2,
            /* [in] */ float Length,
            /* [in] */ long Slices,
            /* [in] */ long Stacks,
            /* [out][in] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh)
{
    HRESULT hr;
    hr=D3DXCreateCylinder(
        (IDirect3DDevice8*) D3DDevice,
        Radius1,
        Radius2,
        Length,
        (UINT)Slices,
        (UINT)Stacks,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}
 
       
STDMETHODIMP C_dxj_D3DX8Object::CreateSphere( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [in] */ float Radius,
            /* [in] */ long Slices,
            /* [in] */ long Stacks,
            /* [out][in] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh)
{
    HRESULT hr;
    hr=D3DXCreateSphere(
        (IDirect3DDevice8*) D3DDevice,
        Radius,
        (UINT)Slices,
        (UINT)Stacks,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateTorus( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [in] */ float InnerRadius,
            /* [in] */ float OuterRadius,
            /* [in] */ long Sides,
            /* [in] */ long Rings,
            /* [out][in] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh) 
{
    HRESULT hr;
    hr=D3DXCreateTorus(
        (IDirect3DDevice8*) D3DDevice,
        InnerRadius,
        OuterRadius,
        (UINT)Sides,
        (UINT)Rings,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateTeapot( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [out][in] */ D3DXBuffer __RPC_FAR *__RPC_FAR *retAdjacency,
            /* [retval][out] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh)
{
    HRESULT hr;
    hr=D3DXCreateTeapot(
        (IDirect3DDevice8*) D3DDevice,
        (ID3DXMesh**)RetMesh,
        (ID3DXBuffer**)retAdjacency);
    return hr;
}

        
STDMETHODIMP C_dxj_D3DX8Object::CreateText( 
            /* [in] */ IUnknown __RPC_FAR *D3DDevice,
            /* [in] */ HDC hDC,
            /* [in] */ BSTR Text,
            /* [in] */ float Deviation,
            /* [in] */ float Extrusion,
            /* [out][in] */ D3DXMesh __RPC_FAR *__RPC_FAR *RetMesh,
	    /* [in,out] */ D3DXBuffer **AdjacencyOut, 
            /* [out][in] */ void __RPC_FAR *GlyphMetrics)
{
    HRESULT hr;
    hr=D3DXCreateTextW(
        (IDirect3DDevice8*) D3DDevice,
        hDC,
        (WCHAR*)Text,
        Deviation,
        Extrusion,
        (ID3DXMesh**)RetMesh,
	(ID3DXBuffer**)AdjacencyOut,
        (LPGLYPHMETRICSFLOAT) GlyphMetrics);
    return hr;
}

        

STDMETHODIMP C_dxj_D3DX8Object::CreateSprite(
        /* [in] */ IUnknown __RPC_FAR *D3DDevice,
        /* [retval][out] */  D3DXSprite **  retSprite)
{
    HRESULT hr;
    hr=D3DXCreateSprite(
        (IDirect3DDevice8*) D3DDevice,
        (ID3DXSprite **)retSprite);
    return hr;
}

STDMETHODIMP C_dxj_D3DX8Object::CreateRenderToSurface(
        IUnknown __RPC_FAR *D3DDevice,
        long Width,
        long Height, 
        long Format, 
        long DepthStencil,
        long DepthStencilFormat,
        D3DXRenderToSurface **RetRenderToSurface)

{
    HRESULT hr;
    hr=D3DXCreateRenderToSurface(
        (IDirect3DDevice8*) D3DDevice,
        (UINT) Width, (UINT) Height, (D3DFORMAT) Format, (BOOL) DepthStencil, (D3DFORMAT) DepthStencilFormat,
        (ID3DXRenderToSurface**) RetRenderToSurface);

    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::CleanMesh( 
                D3DXMesh  *MeshIn,
                void      *Adjacency,
		/* [in][out][optional] */ BSTR *ErrLog,
		/* [out] */ D3DXBuffer *AdjacencyOut,
                D3DXMesh  **MeshOut) 
{
    HRESULT hr;
    LPD3DXBUFFER pBuffer = NULL;
    WCHAR *wszData = NULL;
    USES_CONVERSION;

    hr=::D3DXCleanMesh( (ID3DXMesh*) MeshIn, (DWORD*) Adjacency, (ID3DXMesh**) MeshOut, (DWORD*)AdjacencyOut->GetBufferPointer(), &pBuffer);
			
    if (pBuffer)
    {
      wszData = T2W((TCHAR*)pBuffer->GetBufferPointer());
      *ErrLog = SysAllocString(wszData);
    }
    return hr;
}
        
STDMETHODIMP C_dxj_D3DX8Object::ValidMesh( 
            /* [in] */ D3DXMesh __RPC_FAR *MeshIn,
            /* [in] */ void __RPC_FAR *Adjacency,
		/* [in][out][optional] */ BSTR *ErrLog,
         VARIANT_BOOL *retHit) 
{
    BOOL bRet;
    LPD3DXBUFFER pBuffer = NULL;
    WCHAR *wszData = NULL;
    USES_CONVERSION;

    bRet =D3DXValidMesh( (ID3DXMesh*) MeshIn, (DWORD*) Adjacency, &pBuffer);
    if (bRet){
        *retHit=VARIANT_TRUE;
    }
    else{
        *retHit=VARIANT_FALSE;
    }
			
    if (pBuffer)
    {
      wszData = T2W((TCHAR*)pBuffer->GetBufferPointer());
      *ErrLog = SysAllocString(wszData);
    }
    return S_OK;
}
        
STDMETHODIMP C_dxj_D3DX8Object::BoxBoundProbe( 
            /* [in] */ D3DVECTOR_CDESC __RPC_FAR *MinVert,
            /* [in] */ D3DVECTOR_CDESC __RPC_FAR *MaxVert,
            /* [in] */ D3DVECTOR_CDESC __RPC_FAR *RayPosition,
            /* [in] */ D3DVECTOR_CDESC __RPC_FAR *RayDirection,
                       VARIANT_BOOL              *retHit) 
{

    BOOL bRet;
    
    bRet=::D3DXBoxBoundProbe( (D3DXVECTOR3*) MinVert, 
             (D3DXVECTOR3*) MaxVert,
             (D3DXVECTOR3*) RayPosition,
             (D3DXVECTOR3*) RayDirection);

    if (bRet)
    {
        *retHit=VARIANT_TRUE;
    }
    else
    {
        *retHit=VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP C_dxj_D3DX8Object::SaveSurfaceToFile(
		/* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown*        SrcSurface,
        /* [in] */ PALETTEENTRY*       SrcPalette,
        /* [in] */ RECT*               SrcRect)
{
    HRESULT hr;

    hr=::D3DXSaveSurfaceToFileW( 
                (WCHAR*)                DestFile,
				(D3DXIMAGE_FILEFORMAT)DestFormat,
				(LPDIRECT3DSURFACE8) SrcSurface,
				SrcPalette,
				SrcRect);

    return hr;
}


STDMETHODIMP C_dxj_D3DX8Object::SaveVolumeToFile(
        /* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown*         SrcVolume,
        /* [in] */ PALETTEENTRY*       SrcPalette,
        /* [in] */ void* SrcBox)
{
    HRESULT hr;

    hr=::D3DXSaveVolumeToFileW( 
                (WCHAR*)                DestFile,
				(D3DXIMAGE_FILEFORMAT)DestFormat,
				(LPDIRECT3DVOLUME8) SrcVolume,
				SrcPalette,
				(D3DBOX*)SrcBox);

    return hr;
}
 
STDMETHODIMP C_dxj_D3DX8Object::SaveTextureToFile(
        /* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown* SrcTexture,
        /* [in] */ PALETTEENTRY* SrcPalette)
{
    HRESULT hr;

    hr=::D3DXSaveTextureToFileW( 
                (WCHAR*)                DestFile,
				(D3DXIMAGE_FILEFORMAT)DestFormat,
				(LPDIRECT3DBASETEXTURE8) SrcTexture,
				SrcPalette);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3denumdevices7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3denumdevices7obj.cpp
//
//--------------------------------------------------------------------------

 
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "D3DEnumDevices7Obj.h"

extern  BSTR D3DGUIDtoBSTR(LPGUID pGuid);




/////////////////////////////////////////////////////////////////////////////
extern "C" HRESULT PASCAL objEnumDevices7Callback(
						//LPGUID lpGuid, 
						LPSTR DevDesc,
						LPSTR DevName, 
						LPD3DDEVICEDESC7 lpD3DDevDesc,
						void *lpArg)
{

	C_dxj_Direct3DEnumDevices7Object *pObj=(C_dxj_Direct3DEnumDevices7Object*)lpArg;
	if (pObj==NULL) return D3DENUMRET_OK;
	
	//if (!lpGuid) return D3DENUMRET_CANCEL;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		
		if (pObj->m_pList)
			pObj->m_pList=(DxDriverInfo*)realloc(pObj->m_pList,sizeof(DxDriverInfo)* pObj->m_nMax);
		else
			pObj->m_pList=(DxDriverInfo*)malloc(sizeof(DxDriverInfo)* pObj->m_nMax);


		if (pObj->m_pListHW)
			pObj->m_pListHW=(D3DDEVICEDESC7*)realloc(pObj->m_pListHW,sizeof(D3DDEVICEDESC7)* pObj->m_nMax);
		else
			pObj->m_pListHW=(D3DDEVICEDESC7*)malloc(sizeof(D3DDEVICEDESC7)* pObj->m_nMax);
		

	}
	
	USES_CONVERSION;
	ZeroMemory(&(pObj->m_pList[pObj->m_nCount]),sizeof(DxDriverInfo));
	pObj->m_pList[pObj->m_nCount].strGuid=D3DGUIDtoBSTR(&(lpD3DDevDesc->deviceGUID));
	
	if (DevDesc!=NULL) {
		pObj->m_pList[pObj->m_nCount].strDescription=T2BSTR(DevDesc);
	}
	if (DevName!=NULL){
		pObj->m_pList[pObj->m_nCount].strName=T2BSTR(DevName);
	}

	ZeroMemory(&(pObj->m_pListHW[pObj->m_nCount]),sizeof(D3DDEVICEDESC7));
	
	
	if (lpD3DDevDesc){
		memcpy(&(pObj->m_pListHW[pObj->m_nCount]),lpD3DDevDesc,sizeof(D3DDEVICEDESC7));
	}
	

	pObj->m_nCount++;
	
	return D3DENUMRET_OK;
}


C_dxj_Direct3DEnumDevices7Object::C_dxj_Direct3DEnumDevices7Object()
{	
	m_nMax=0;
	m_pList=NULL;
	m_pListHW=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_Direct3DEnumDevices7Object::~C_dxj_Direct3DEnumDevices7Object()
{
	//empty list
	if (m_pList){
		for (int i=0;i<m_nCount;i++)
		{
			if (m_pList[i].strGuid) SysFreeString(m_pList[i].strGuid);
			if (m_pList[i].strDescription) SysFreeString(m_pList[i].strDescription);
			if (m_pList[i].strName) SysFreeString(m_pList[i].strName);
		}
		free(m_pList);
	}

}


HRESULT C_dxj_Direct3DEnumDevices7Object::create(LPDIRECT3D7 pD3D,I_dxj_Direct3DEnumDevices **ppRet)
{
	HRESULT hr;
	C_dxj_Direct3DEnumDevices7Object *pNew=NULL;

	*ppRet=NULL;

	pNew= new CComObject<C_dxj_Direct3DEnumDevices7Object>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;

	hr=pD3D->EnumDevices(objEnumDevices7Callback, (void*)pNew);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		if (pNew->m_pListHW) free(pNew->m_pListHW);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_Direct3DEnumDevices,(void**)ppRet);
	return hr;
}


        
HRESULT C_dxj_Direct3DEnumDevices7Object::getGuid( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strGuid);
	
	return S_OK;
}

HRESULT C_dxj_Direct3DEnumDevices7Object::getName( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strName);
	
	return S_OK;
}


HRESULT C_dxj_Direct3DEnumDevices7Object::getDescription( long index, BSTR *info)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	if (!info) return E_INVALIDARG;

	*info=SysAllocString(m_pList[index-1].strDescription);
	
	return S_OK;
}
        

HRESULT C_dxj_Direct3DEnumDevices7Object::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}

HRESULT C_dxj_Direct3DEnumDevices7Object::getDesc(long index, D3dDeviceDesc7 *desc)
{
	if (m_pListHW==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	memcpy(desc,&(m_pListHW[index-1]),sizeof(D3dDeviceDesc7));
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3dvertexbuffer7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       d3dvertexbuffer7obj.cpp
//
//--------------------------------------------------------------------------

// d3dMaterialObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "d3dVertexBuffer7Obj.h"

CONSTRUCTOR(_dxj_Direct3dVertexBuffer7,  {m_pData=NULL;m_vertSize=0;});
DESTRUCTOR(_dxj_Direct3dVertexBuffer7,  {});
GETSET_OBJECT(_dxj_Direct3dVertexBuffer7);


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::getVertexBufferDesc( 
            /* [out][in] */ D3dVertexBufferDesc __RPC_FAR *desc)
{
	HRESULT hr;
	((D3DVERTEXBUFFERDESC*)desc)->dwSize=sizeof(D3DVERTEXBUFFERDESC);
	hr=m__dxj_Direct3dVertexBuffer7->GetVertexBufferDesc((D3DVERTEXBUFFERDESC*)desc);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::processVertices( 
            /* [in] */ long vertexOp,
            /* [in] */ long destIndex,
            /* [in] */ long count,
            /* [in] */ I_dxj_Direct3dVertexBuffer7 __RPC_FAR *srcBuffer,
            /* [in] */ long srcIndex,
            /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev,
			long flags
            )
{
	HRESULT hr;

	if (!srcBuffer) return E_INVALIDARG;
	if (!dev) return E_INVALIDARG;

	DO_GETOBJECT_NOTNULL( LPDIRECT3DVERTEXBUFFER7, realBuffer, srcBuffer);
	DO_GETOBJECT_NOTNULL( LPDIRECT3DDEVICE7, realDev, dev);

	hr=m__dxj_Direct3dVertexBuffer7->ProcessVertices(
		(DWORD) vertexOp,
		(DWORD) destIndex,
		(DWORD) count,
		realBuffer,
		(DWORD) srcIndex,
		realDev,
		(DWORD) flags);


	return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::lock( 
            /* [in] */ long flags)
{
	HRESULT hr;
	

	hr=m__dxj_Direct3dVertexBuffer7->Lock((DWORD) flags, &m_pData,NULL);
		
	return hr;
}
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::setVertexSize( /* [in] */ long n)
{
	m_vertSize=(DWORD)n;
		
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::unlock()
{
	HRESULT hr;
	hr=m__dxj_Direct3dVertexBuffer7->Unlock();
	m_pData=NULL;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::optimize(
		    /* [in] */ I_dxj_Direct3dDevice7 __RPC_FAR *dev
             )
        
{
	HRESULT hr;
	if (!dev) return E_INVALIDARG;
	
	DO_GETOBJECT_NOTNULL( LPDIRECT3DDEVICE7, realdev, dev);
	
	hr=m__dxj_Direct3dVertexBuffer7->Optimize(realdev,(DWORD) 0);
	
	return hr;
}
        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::setVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts)        
{
		
	if (!m_vertSize) return E_FAIL;
	if (!m_pData) return E_FAIL;

	__try {
		memcpy(&(((char*)m_pData) [startIndex*m_vertSize]),verts,count*m_vertSize);
	}
	__except(1,1){
		return E_FAIL;
	}
	
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////        

STDMETHODIMP C_dxj_Direct3dVertexBuffer7Object::getVertices( 
            /* [in] */ long startIndex,
            /* [in] */ long count,
            /* [in] */ void __RPC_FAR *verts)        
{
	
	if (!m_vertSize) {				
		return E_FAIL;
	}
	if (!m_pData) {		
		return E_FAIL;
	}

	__try {
		memcpy(verts,&( ((char*)m_pData) [startIndex*m_vertSize]),count*m_vertSize);
	}
	__except(1,1){		
		return E_FAIL;
	}
	

	
	return S_OK;
}
           


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3dxerr.h ===
//----------------------------------------------------------------------
//                                                                      
//   d3dxerr.h --  0xC code definitions for the D3DX API                
//                                                                      
//   Copyright (c) 1991-1999, Microsoft Corp. All rights reserved.      
//                                                                      
//----------------------------------------------------------------------
#ifndef __D3DXERR_H__
#define __D3DXERR_H__

// 
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_D3DX    0x877



//
// MessageId: D3DXERR_NOMEMORY
//
// MessageText:
//
//  Out of memory.
// 
#define D3DXERR_NOMEMORY    ((HRESULT)0xC8770BB8L)


//
// MessageId: D3DXERR_NULLPOINTER
//
// MessageText:
//
//  A NULL pointer was passed as a parameter.
// 
#define D3DXERR_NULLPOINTER    ((HRESULT)0xC8770BB9L)


//
// MessageId: D3DXERR_INVALIDD3DXDEVICEINDEX
//
// MessageText:
//
//  The Device Index passed in is invalid.
// 
#define D3DXERR_INVALIDD3DXDEVICEINDEX    ((HRESULT)0xC8770BBAL)


//
// MessageId: D3DXERR_NODIRECTDRAWAVAILABLE
//
// MessageText:
//
//  DirectDraw has not been created.
// 
#define D3DXERR_NODIRECTDRAWAVAILABLE    ((HRESULT)0xC8770BBBL)


//
// MessageId: D3DXERR_NODIRECT3DAVAILABLE
//
// MessageText:
//
//  Direct3D has not been created.
// 
#define D3DXERR_NODIRECT3DAVAILABLE    ((HRESULT)0xC8770BBCL)


//
// MessageId: D3DXERR_NODIRECT3DDEVICEAVAILABLE
//
// MessageText:
//
//  Direct3D device has not been created.
// 
#define D3DXERR_NODIRECT3DDEVICEAVAILABLE    ((HRESULT)0xC8770BBDL)


//
// MessageId: D3DXERR_NOPRIMARYAVAILABLE
//
// MessageText:
//
//  Primary surface has not been created.
// 
#define D3DXERR_NOPRIMARYAVAILABLE    ((HRESULT)0xC8770BBEL)


//
// MessageId: D3DXERR_NOZBUFFERAVAILABLE
//
// MessageText:
//
//  Z buffer has not been created.
// 
#define D3DXERR_NOZBUFFERAVAILABLE    ((HRESULT)0xC8770BBFL)


//
// MessageId: D3DXERR_NOBACKBUFFERAVAILABLE
//
// MessageText:
//
//  Backbuffer has not been created.
// 
#define D3DXERR_NOBACKBUFFERAVAILABLE    ((HRESULT)0xC8770BC0L)


//
// MessageId: D3DXERR_COULDNTUPDATECAPS
//
// MessageText:
//
//  Failed to update caps database after changing display mode.
// 
#define D3DXERR_COULDNTUPDATECAPS    ((HRESULT)0xC8770BC1L)


//
// MessageId: D3DXERR_NOZBUFFER
//
// MessageText:
//
//  Could not create Z buffer.
// 
#define D3DXERR_NOZBUFFER    ((HRESULT)0xC8770BC2L)


//
// MessageId: D3DXERR_INVALIDMODE
//
// MessageText:
//
//  Display mode is not valid.
// 
#define D3DXERR_INVALIDMODE    ((HRESULT)0xC8770BC3L)


//
// MessageId: D3DXERR_INVALIDPARAMETER
//
// MessageText:
//
//  One or more of the parameters passed is invalid.
// 
#define D3DXERR_INVALIDPARAMETER    ((HRESULT)0xC8770BC4L)


//
// MessageId: D3DXERR_INITFAILED
//
// MessageText:
//
//  D3DX failed to initialize itself.
// 
#define D3DXERR_INITFAILED    ((HRESULT)0xC8770BC5L)


//
// MessageId: D3DXERR_STARTUPFAILED
//
// MessageText:
//
//  D3DX failed to start up.
// 
#define D3DXERR_STARTUPFAILED    ((HRESULT)0xC8770BC6L)


//
// MessageId: D3DXERR_D3DXNOTSTARTEDYET
//
// MessageText:
//
//  D3DXInitialize() must be called first.
// 
#define D3DXERR_D3DXNOTSTARTEDYET    ((HRESULT)0xC8770BC7L)


//
// MessageId: D3DXERR_NOTINITIALIZED
//
// MessageText:
//
//  D3DX is not initialized yet.
// 
#define D3DXERR_NOTINITIALIZED    ((HRESULT)0xC8770BC8L)


//
// MessageId: D3DXERR_FAILEDDRAWTEXT
//
// MessageText:
//
//  Failed to render text to the surface.
// 
#define D3DXERR_FAILEDDRAWTEXT    ((HRESULT)0xC8770BC9L)


//
// MessageId: D3DXERR_BADD3DXCONTEXT
//
// MessageText:
//
//  Bad D3DX context.
// 
#define D3DXERR_BADD3DXCONTEXT    ((HRESULT)0xC8770BCAL)


//
// MessageId: D3DXERR_CAPSNOTSUPPORTED
//
// MessageText:
//
//  The requested device capabilities are not supported.
// 
#define D3DXERR_CAPSNOTSUPPORTED    ((HRESULT)0xC8770BCBL)


//
// MessageId: D3DXERR_UNSUPPORTEDFILEFORMAT
//
// MessageText:
//
//  The image file format is unrecognized.
// 
#define D3DXERR_UNSUPPORTEDFILEFORMAT    ((HRESULT)0xC8770BCCL)


//
// MessageId: D3DXERR_IFLERROR
//
// MessageText:
//
//  The image file loading library error.
// 
#define D3DXERR_IFLERROR    ((HRESULT)0xC8770BCDL)


//
// MessageId: D3DXERR_FAILEDGETCAPS
//
// MessageText:
//
//  Could not obtain device caps.
// 
#define D3DXERR_FAILEDGETCAPS    ((HRESULT)0xC8770BCEL)


//
// MessageId: D3DXERR_CANNOTRESIZEFULLSCREEN
//
// MessageText:
//
//  Resize does not work for full-screen.
// 
#define D3DXERR_CANNOTRESIZEFULLSCREEN    ((HRESULT)0xC8770BCFL)


//
// MessageId: D3DXERR_CANNOTRESIZENONWINDOWED
//
// MessageText:
//
//  Resize does not work for non-windowed contexts.
// 
#define D3DXERR_CANNOTRESIZENONWINDOWED    ((HRESULT)0xC8770BD0L)


//
// MessageId: D3DXERR_FRONTBUFFERALREADYEXISTS
//
// MessageText:
//
//  Front buffer already exists.
// 
#define D3DXERR_FRONTBUFFERALREADYEXISTS    ((HRESULT)0xC8770BD1L)


//
// MessageId: D3DXERR_FULLSCREENPRIMARYEXISTS
//
// MessageText:
//
//  The app is using the primary in full-screen mode.
// 
#define D3DXERR_FULLSCREENPRIMARYEXISTS    ((HRESULT)0xC8770BD2L)


//
// MessageId: D3DXERR_GETDCFAILED
//
// MessageText:
//
//  Could not get device context.
// 
#define D3DXERR_GETDCFAILED    ((HRESULT)0xC8770BD3L)


//
// MessageId: D3DXERR_BITBLTFAILED
//
// MessageText:
//
//  Could not bitBlt.
// 
#define D3DXERR_BITBLTFAILED    ((HRESULT)0xC8770BD4L)


//
// MessageId: D3DXERR_NOTEXTURE
//
// MessageText:
//
//  There is no surface backing up this texture.
// 
#define D3DXERR_NOTEXTURE    ((HRESULT)0xC8770BD5L)


//
// MessageId: D3DXERR_MIPLEVELABSENT
//
// MessageText:
//
//  There is no such miplevel for this surface.
// 
#define D3DXERR_MIPLEVELABSENT    ((HRESULT)0xC8770BD6L)


//
// MessageId: D3DXERR_SURFACENOTPALETTED
//
// MessageText:
//
//  The surface is not paletted.
// 
#define D3DXERR_SURFACENOTPALETTED    ((HRESULT)0xC8770BD7L)


//
// MessageId: D3DXERR_ENUMFORMATSFAILED
//
// MessageText:
//
//  An error occured while enumerating surface formats.
// 
#define D3DXERR_ENUMFORMATSFAILED    ((HRESULT)0xC8770BD8L)


//
// MessageId: D3DXERR_COLORDEPTHTOOLOW
//
// MessageText:
//
//  D3DX only supports color depths of 16 bit or greater.
// 
#define D3DXERR_COLORDEPTHTOOLOW    ((HRESULT)0xC8770BD9L)


//
// MessageId: D3DXERR_INVALIDFILEFORMAT
//
// MessageText:
//
//  The file format is invalid.
// 
#define D3DXERR_INVALIDFILEFORMAT    ((HRESULT)0xC8770BDAL)


//
// MessageId: D3DXERR_NOMATCHFOUND
//
// MessageText:
//
//  No suitable match found.
// 
#define D3DXERR_NOMATCHFOUND    ((HRESULT)0xC8770BDBL)



#endif //__D3DXERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3dx8obj.h ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       D3DX8obj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_D3DX8Object : 
	public I_dxj_D3DX8,
	public CComCoClass<C_dxj_D3DX8Object, &CLSID_D3DX8>,
	public CComObjectRoot
{
public:


DECLARE_REGISTRY(CLSID_D3DX8,	"DIRECT.D3DX8.0",		"DIRECT.D3DX8.0",	IDS_D3DX8_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(C_dxj_D3DX8Object)
	COM_INTERFACE_ENTRY( I_dxj_D3DX8)
END_COM_MAP()



public:
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateFont( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
	        /* [in] */ HANDLE hFont,
#else
	        /* [in] */ long hFont,
#endif
            /* [retval][out] */ D3DXFont **retFont);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE DrawText( 
            /* [in] */ D3DXFont *d3dFont,
            /* [in] */ long Color,
            /* [in] */ BSTR TextString,
            /* [in] */ RECT *Rect,
            /* [in] */ long Format);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE GetFVFVertexSize( 
            /* [in] */ long FVF,
            /* [retval][out] */ long *size);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE AssembleShaderFromFile( 
            /* [in] */ BSTR SrcFile,
            /* [in] */ long Flags,
            /* [in] */ BSTR *ErrLog,
            /* [out][in] */ D3DXBuffer **Constants,
            /* [retval][out] */ D3DXBuffer **ppVertexShader);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE AssembleShader( 
            /* [in] */ BSTR SrcData,
            /* [in] */ long Flags,
            /* [out][in] */ D3DXBuffer **Constants,
			/* [in][out][optional] */ BSTR *ErrLog,
            /* [retval][out] */ D3DXBuffer **ppVertexShader);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE GetErrorString( 
            /* [in] */ long hr,
            /* [retval][out] */ BSTR *retStr);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSurfaceFromFile( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ BSTR SrcFile,
            /* [in] */ void *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSurfaceFromFileInMemory( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [in] */ void *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSurfaceFromSurface( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ IUnknown *SrcSurface,
            /* [in] */ void *SrcPalette,
            /* [in] */ void *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSurfaceFromMemory( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ void *SrcData,
            /* [in] */ long formatSrc,
            /* [in] */ long SrcPitch,
            /* [in] */ void *SrcPalette,
            /* [in] */ RECT_CDESC *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CheckTextureRequirements( 
            /* [out][in] */ IUnknown *Device,
            /* [out][in] */ long *Width,
            /* [out][in] */ long *Height,
            /* [out][in] */ long *NumMipLevels,
            /* [in] */ long Usage,
            /* [out][in] */ long *PixelFormat,
            /* [in] */ long Pool);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTexture( 
            /* [in] */ IUnknown *Device,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromResource( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
	        /* [in] */ HANDLE hModule,
#else
	        /* [in] */ long hModule,
#endif
            /* [in] */ BSTR SrcResource,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromFile( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromFileEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromFileInMemory( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromFileInMemoryEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE FilterTexture( 
            /* [in] */ IUnknown *Texture,
            /* [in] */ void *Palette,
            /* [in] */ long SrcLevel,
            /* [in] */ long Filter);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CheckCubeTextureRequirements( 
            /* [in] */ IUnknown *Device,
            /* [out][in] */ long *Size,
            /* [out][in] */ long *NumMipLevels,
            /* [in] */ long Usage,
            /* [out][in] */ long *PixelFormat,
            /* [in] */ long Pool);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCubeTexture( 
            /* [in] */ IUnknown *pDevice,
            /* [in] */ long Size,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [retval][out] */ IUnknown **ppCubeTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCubeTextureFromFile( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [retval][out] */ IUnknown **ppCubeTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCubeTextureFromFileEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ BSTR SrcFile,
            /* [in] */ long TextureSize,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCubeTextureFromFileInMemory( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCubeTextureFromFileInMemoryEx( 
            /* [in] */ IUnknown *Device,
            /* [in] */ void *SrcData,
            /* [in] */ long LengthInBytes,
            /* [in] */ long TextureSize,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **ppTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE FilterCubeTexture( 
            /* [in] */ IUnknown *CubeTexture,
            /* [in] */ void *Palette,
            /* [in] */ long SrcLevel,
            /* [in] */ long Filter);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CheckVolumeTextureRequirements( 
            /* [in] */ IUnknown *Device,
            /* [out] */ long *Width,
            /* [out] */ long *Height,
            /* [out] */ long *Depth,
            /* [out] */ long *NumMipLevels,
            /* [in] */ long Usage,
            /* [out][in] */ long *PixelFormat,
            /* [in] */ long Pool);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTextureFromResourceEx( 
            /* [in] */ IUnknown *Device,
#ifdef _WIN64
            /* [in] */ HANDLE hSrcModule,
#else
            /* [in] */ long hSrcModule,
#endif
            /* [in] */ BSTR SrcResource,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [in] */ long Filter,
            /* [in] */ long MipFilter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo,
            /* [in] */ void *Palette,
            /* [retval][out] */ IUnknown **retTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateVolumeTexture( 
            /* [in] */ IUnknown *Device,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long Depth,
            /* [in] */ long MipLevels,
            /* [in] */ long Usage,
            /* [in] */ long PixelFormat,
            /* [in] */ long Pool,
            /* [retval][out] */ IUnknown **ppVolumeTexture);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE FilterVolumeTexture( 
            /* [in] */ IUnknown *VolumeTexture,
            /* [in] */ void *Palette,
            /* [in] */ long SrcLevel,
            /* [in] */ long Filter);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSurfaceFromResource( 
            /* [in] */ IUnknown *DestSurface,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
#ifdef _WIN64
            /* [in] */ HANDLE hSrcModule,
#else
            /* [in] */ long hSrcModule,
#endif
            /* [in] */ BSTR SrcResource,
            /* [in] */ void *SrcRect,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey,
            /* [in] */ void *SrcInfo);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadVolumeFromVolume( 
            /* [in] */ IUnknown *DestVolume,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestBox,
            /* [in] */ IUnknown *SrcVolume,
            /* [in] */ void *SrcPalette,
            /* [in] */ void *SrcBox,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadVolumeFromMemory( 
            /* [in] */ IUnknown *DestVolume,
            /* [in] */ void *DestPalette,
            /* [in] */ void *DestRect,
            /* [in] */ void *SrcMemory,
            /* [in] */ long SrcFormat,
            /* [in] */ long SrcRowPitch,
            /* [in] */ long SrcSlicePitch,
            /* [in] */ void *SrcPalette,
            /* [in] */ void *SrcBox,
            /* [in] */ long Filter,
            /* [in] */ long ColorKey);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateMesh( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long options,
            /* [in] */ void *declaration,
            /* [in] */ IUnknown *pD3D,
            /* [retval][out] */ D3DXMesh **ppMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateMeshFVF( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long options,
            /* [in] */ long fvf,
            /* [in] */ IUnknown *pD3D,
            /* [retval][out] */ D3DXMesh **ppMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSPMesh( 
            /* [in] */ D3DXMesh *pMesh,
            /* [in] */ void *adjacency,
            /* [in] */ void *VertexAttributeWeights,
            /* [in] */ void *VertexWeights,
            /* [retval][out] */ D3DXSPMesh **ppSMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE GeneratePMesh( 
            /* [in] */ D3DXMesh *Mesh,
            /* [in] */ void *Adjacency,
            /* [in] */ void *VertexAttributeWeights,
            /* [in] */ void *VertexWeights,
            /* [in] */ long minValue,
            /* [in] */ long options,
            /* [retval][out] */ D3DXPMesh **ppPMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SimplifyMesh( 
            /* [in] */ D3DXMesh *Mesh,
            /* [in] */ void *Adjacency,
            /* [in] */ void *VertexAttributeWeights,
            /* [in] */ void *VertexWeights,
            /* [in] */ long minValue,
            /* [in] */ long options,
            /* [retval][out] */ D3DXMesh **ppMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ComputeBoundingSphere( 
            /* [in] */ void *PointsFVF,
            /* [in] */ long numVertices,
            /* [in] */ long FVF,
            /* [in] */ D3DVECTOR_CDESC *Centers,
            /* [out][in] */ float *RadiusArray);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ComputeBoundingBox( 
            /* [in] */ void *PointsFVF,
            /* [in] */ long numVertices,
            /* [in] */ long FVF,
            /* [out][in] */ D3DVECTOR_CDESC *MinVert,
            /* [out][in] */ D3DVECTOR_CDESC *MaxVert);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ComputeNormals( 
            /* [in] */ D3DXBaseMesh *pMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE DeclaratorFromFVF( 
            /* [in] */ long FVF,
            /* [out] */ D3DXDECLARATOR_CDESC *Declarator);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE FVFFromDeclarator( 
            /* [in] */ D3DXDECLARATOR_CDESC *Declarator,
            /* [retval][out] */ long *fvf);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateBuffer( 
            /* [in] */ long numBytes,
            /* [retval][out] */ D3DXBuffer **ppBuffer);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadMeshFromX( 
            /* [in] */ BSTR Filename,
            /* [in] */ long options,
            /* [in] */ IUnknown *D3DDevice,
            /* [out][in] */ D3DXBuffer **retAdjacency,
            /* [out][in] */ D3DXBuffer **retMaterials,
            /* [out][in] */ long *retMaterialCount,
            /* [retval][out] */ D3DXMesh **retMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SaveMeshToX( 
            /* [in] */ BSTR Filename,
            /* [in] */ D3DXMesh *Mesh,
            /* [in] */ void *AdjacencyArray,
            /* [in] */ D3DXMATERIAL_CDESC *MaterialArray,
            /* [in] */ long MaterialCount,
            /* [in] */ long xFormat);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadMeshFromXof( 
            /* [in] */ IUnknown *xofobjMesh,
            /* [in] */ long options,
            /* [in] */ IUnknown *D3DDevice,
            /* [out][in] */ D3DXBuffer **retBufAdjacency,
            /* [out][in] */ D3DXBuffer **retMaterials,
            /* [out][in] */ long *retMaterialCount,
            /* [retval][out] */ D3DXMesh **retMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE TessellateNPatches( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [in] */ void *AdjacencyIn,
            /* [in] */ float NumSegs,
    	    /* [in] */ VARIANT_BOOL QuadraticInterpNormals,
	    /* [in,out, optional] */ D3DXBuffer **AdjacencyOut, 
            /* [retval][out] */ D3DXMesh **MeshOut);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetMaterial( 
            /* [in] */ D3DXBuffer *MaterialBuffer,
            /* [in] */ long index,
            /* [out] */ D3DMATERIAL8_CDESC *mat);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetTextureName( 
            /* [in] */ D3DXBuffer *MaterialBuffer,
            /* [in] */ long index,
            /* [retval][out] */ BSTR *retName);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetData( 
            /* [in] */ D3DXBuffer *Buffer,
            /* [in] */ long index,
            /* [in] */ long typesize,
            /* [in] */ long typecount,
            /* [out][in] */ void *data);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferSetData( 
            /* [in] */ D3DXBuffer *Buffer,
            /* [in] */ long index,
            /* [in] */ long typesize,
            /* [in] */ long typecount,
            /* [out][in] */ void *data);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE Intersect( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [in] */ D3DVECTOR_CDESC *RayPos,
            /* [in] */ D3DVECTOR_CDESC *RayDir,
            /* [out] */ LONG *retHit,
            /* [out] */ LONG *retFaceIndex,
            /* [out] */ FLOAT *U,
            /* [out] */ FLOAT *V,
            /* [out] */ FLOAT *retDist,
            /* [out] */ LONG *countHits,
            /* [retval][out] */ D3DXBuffer **AllHits);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SphereBoundProbe( 
            /* [in] */ D3DVECTOR_CDESC *Center,
            /* [in] */ float Radius,
            /* [in] */ D3DVECTOR_CDESC *RayPosition,
            /* [in] */ D3DVECTOR_CDESC *Raydirection,
            /* [retval][out] */ VARIANT_BOOL *retHit);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ComputeBoundingSphereFromMesh( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [out][in] */ D3DVECTOR_CDESC *Centers,
            /* [out][in] */ float *RadiusArray);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ComputeBoundingBoxFromMesh( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [out][in] */ D3DVECTOR_CDESC *MinArray,
            /* [out][in] */ D3DVECTOR_CDESC *MaxArray);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSkinMesh( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long numBones,
            /* [in] */ long options,
            /* [in] */ void *Declaration,
            /* [in] */ IUnknown *D3DDevice,
            /* [retval][out] */ D3DXSkinMesh **SkinMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSkinMeshFVF( 
            /* [in] */ long numFaces,
            /* [in] */ long numVertices,
            /* [in] */ long numBones,
            /* [in] */ long options,
            /* [in] */ long fvf,
            /* [in] */ IUnknown *D3DDevice,
            /* [retval][out] */ D3DXSkinMesh **ppSkinMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSkinMeshFromMesh( 
            /* [in] */ D3DXMesh *Mesh,
            /* [in] */ long numBones,
            /* [retval][out] */ D3DXSkinMesh **ppSkinMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadSkinMeshFromXof( 
            /* [in] */ IUnknown *xofobjMesh,
            /* [in] */ long options,
            /* [in] */ IUnknown *D3DDevice,
            /* [out][in] */ D3DXBuffer **AdjacencyOut,
            /* [out][in] */ D3DXBuffer **MaterialsOut,
            /* [out][in] */ long *NumMatOut,
            /* [out][in] */ D3DXBuffer **BoneNamesOut,
            /* [out][in] */ D3DXBuffer **BoneTransformsOut,
            /* [retval][out] */ D3DXSkinMesh **ppMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreatePolygon( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ float Length,
            /* [in] */ long Sides,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateBox( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ float Width,
            /* [in] */ float Height,
            /* [in] */ float Depth,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateCylinder( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ float Radius1,
            /* [in] */ float Radius2,
            /* [in] */ float Length,
            /* [in] */ long Slices,
            /* [in] */ long Stacks,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSphere( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ float Radius,
            /* [in] */ long Slices,
            /* [in] */ long Stacks,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTorus( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ float InnerRadius,
            /* [in] */ float OuterRadius,
            /* [in] */ long Sides,
            /* [in] */ long Rings,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateTeapot( 
            /* [in] */ IUnknown *D3DDevice,
            /* [out][in] */ D3DXBuffer **RetAdjacency,
            /* [retval][out] */ D3DXMesh **RetMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateText( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ HDC hDC,
            /* [in] */ BSTR Text,
            /* [in] */ float Deviation,
            /* [in] */ float Extrusion,
            /* [out][in] */ D3DXMesh **RetMesh,
	    /* [in,out]  */ D3DXBuffer **AdjacencyOut, 
            /* [out][in] */ void *GlyphMetrics);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetBoneName( 
            /* [in] */ D3DXBuffer *BoneNameBuffer,
            /* [in] */ long index,
            /* [retval][out] */ BSTR *retName);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateSprite( 
            /* [in] */ IUnknown *D3DDevice,
            /* [retval][out] */ D3DXSprite **retSprite);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CreateRenderToSurface( 
            /* [in] */ IUnknown *D3DDevice,
            /* [in] */ long Width,
            /* [in] */ long Height,
            /* [in] */ long Format,
            /* [in] */ long DepthStencil,
            /* [in] */ long DepthStencilFormat,
            /* [retval][out] */ D3DXRenderToSurface **RetRenderToSurface);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CleanMesh( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [in] */ void *Adjacency,
		/* [in][out][optional] */ BSTR *ErrLog,
		/* [in,out] */ D3DXBuffer *AdjacencyOut,
            /* [retval][out] */ D3DXMesh **MeshOut);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ValidMesh( 
            /* [in] */ D3DXMesh *MeshIn,
            /* [in] */ void *Adjacency,
		/* [in][out][optional] */ BSTR *ErrLog,
            /* [retval][out] */ VARIANT_BOOL *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BoxBoundProbe( 
            /* [in] */ D3DVECTOR_CDESC *MinVert,
            /* [in] */ D3DVECTOR_CDESC *MaxVert,
            /* [in] */ D3DVECTOR_CDESC *RayPosition,
            /* [in] */ D3DVECTOR_CDESC *RayDirection,
            /* [retval][out] */ VARIANT_BOOL *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SavePMeshToFile( 
            /* [in] */ BSTR Filename,
            /* [in] */ D3DXPMesh *Mesh,
            /* [in] */ D3DXMATERIAL_CDESC *MaterialArray,
            /* [in] */ long MaterialCount);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE LoadPMeshFromFile( 
            /* [in] */ BSTR Filename,
	    /* [in] */ long options,
            /* [in] */ IUnknown *D3DDevice,
            /* [out] */ D3DXBuffer **RetMaterials,
            /* [out] */ long *RetNumMaterials,
            /* [retval][out] */ D3DXPMesh **RetPMesh);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetBoneCombo( 
            /* [in] */ D3DXBuffer *BoneComboBuffer,
            /* [in] */ long index,
            /* [out][in] */ D3DXBONECOMBINATION_CDESC *boneCombo);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BufferGetBoneComboBoneIds( 
            /* [in] */ D3DXBuffer *BoneComboBuffer,
            /* [in] */ long index,
            /* [in] */ long PaletteSize,
            /* [in] */ void *BoneIds);

        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SaveSurfaceToFile(
		/* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown*        SrcSurface,
        /* [in] */ PALETTEENTRY*       SrcPalette,
        /* [in] */ RECT*               SrcRect);

        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SaveVolumeToFile(
        /* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown*         SrcVolume,
        /* [in] */ PALETTEENTRY*       SrcPalette,
        /* [in] */ void* SrcBox);
 
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SaveTextureToFile(
        /* [in] */ BSTR DestFile,
        /* [in] */ LONG DestFormat,
        /* [in] */ IUnknown* SrcTexture,
        /* [in] */ PALETTEENTRY* SrcPalette);
        
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3dxmathvb.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.cpp
//  Content:    
//
//////////////////////////////////////////////////////////////////////////////


#include "pchmath.h"
#define EPSILON 0.00001f



#include "d3dxmathvb.inl"

//
// WithinEpsilon - Are two values within EPSILON of each other?
//

static inline BOOL 
WithinEpsilon(float a, float b)
{
    float f = a - b;
    return -EPSILON <= f && f <= EPSILON;
}


//
// sincosf - Compute the sin and cos of an angle at the same time
//

static inline void
sincosf(float angle, float *psin, float *pcos)
{
#ifdef _X86_
#define fsincos __asm _emit 0xd9 __asm _emit 0xfb
    __asm {
        mov eax, psin
        mov edx, pcos
        fld angle
        fsincos
        fstp DWORD ptr [edx]
        fstp DWORD ptr [eax]
    }
#undef fsincos
#else //!_X86_
    *psin = sinf(angle);
    *pcos = cosf(angle);
#endif //!_X86_
}


//--------------------------
// 2D Vector
//--------------------------

D3DXVECTOR2* WINAPI VB_D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec2LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }    
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
    }

    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pT1, 
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2CatmullRom
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV0, const D3DXVECTOR2 *pV1,
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;
    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR2* WINAPI VB_D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

    float w;

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(2)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(3), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [w]
    }

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pM->_42;
    w   = pV->x * pM->_14 + pV->y * pM->_24 + pM->_44;

    *pOut = *((D3DXVECTOR2 *) &v);
#endif // !_X86_
    
    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fxch  st(1)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fxch  st(1)

        faddp st(2), st
        faddp st(2), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR2 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21;
    v.y = pV->x * pM->_12 + pV->y * pM->_22;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 3D Vector
//--------------------------

D3DXVECTOR3* WINAPI VB_D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec3LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
    }

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pT1, 
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3CatmullRom
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV0, const D3DXVECTOR3 *pV1,
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    pOut->z = 0.5f * (sV0 * pV0->z + sV1 * pV1->z + sV2 * pV2->z + sV3 * pV3->z);
    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR3* WINAPI VB_D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

    float w;

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [w]
    }

#else // !_X86_
    D3DXVECTOR3 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pM->_43;
    w   = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pM->_44;

    *pOut = v;
#endif // !_X86_
    
    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fxch  st(2)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR3 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR3* WINAPI VB_D3DXVec3Project
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const D3DXMATRIX *pProjection, const D3DXMATRIX *pView, const D3DXMATRIX *pWorld)
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXMATRIX mat;
    const D3DXMATRIX *pMat = &mat;

    switch(((NULL != pWorld) << 2) | ((NULL != pView) << 1) | (NULL != pProjection))
    {
    case 0: // ---
        D3DXMatrixIdentity(&mat);
        break;

    case 1: // --P
        pMat = pProjection;
        break;

    case 2: // -V-
        pMat = pView;
        break;

    case 3: // -VP
        D3DXMatrixMultiply(&mat, pView, pProjection);
        break;

    case 4: // W--
        pMat = pWorld;
        break;

    case 5: // W-P
        D3DXMatrixMultiply(&mat, pWorld, pProjection);
        break;

    case 6: // WV-
        D3DXMatrixMultiply(&mat, pWorld, pView);
        break;

    case 7: // WVP
        D3DXMatrixMultiply(&mat, pWorld, pView);
        D3DXMatrixMultiply(&mat, &mat, pProjection);
        break;
    }


    D3DXVec3TransformCoord(pOut, pV, pMat);

    if(pViewport)
    {
        pOut->x = ( pOut->x + 1.0f) * 0.5f * (float) pViewport->Width  + (float) pViewport->X;
        pOut->y = (-pOut->y + 1.0f) * 0.5f * (float) pViewport->Height + (float) pViewport->Y;
        pOut->z = pOut->z * (pViewport->MaxZ - pViewport->MinZ) +  pViewport->MinZ;
    }

    return pOut;
}


D3DXVECTOR3* WINAPI VB_D3DXVec3Unproject
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const D3DXMATRIX *pProjection, const D3DXMATRIX *pView, const D3DXMATRIX *pWorld)
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXMATRIX mat;

    switch(((NULL != pWorld) << 2) | ((NULL != pView) << 1) | (NULL != pProjection))
    {
    case 0: // ---
        D3DXMatrixIdentity(&mat);
        break;

    case 1: // --P
        D3DXMatrixInverse(&mat, NULL, pProjection);
        break;

    case 2: // -V-
        D3DXMatrixInverse(&mat, NULL, pView);
        break;

    case 3: // -VP
        D3DXMatrixMultiply(&mat, pView, pProjection);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;

    case 4: // W--
        D3DXMatrixInverse(&mat, NULL, pWorld);
        break;

    case 5: // W-P
        D3DXMatrixMultiply(&mat, pWorld, pProjection);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;

    case 6: // WV-
        D3DXMatrixMultiply(&mat, pWorld, pView);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;

    case 7: // WVP
        D3DXMatrixMultiply(&mat, pWorld, pView);
        D3DXMatrixMultiply(&mat, &mat, pProjection);
        D3DXMatrixInverse(&mat, NULL, &mat);
        break;
    }


    if(pViewport)
    {
        pOut->x = (pV->x - (float) pViewport->X) / (float) pViewport->Width * 2.0f - 1.0f;
        pOut->y = -((pV->y - (float) pViewport->Y) / (float) pViewport->Height * 2.0f - 1.0f);
        pOut->z = (pV->z - pViewport->MinZ) / (pViewport->MaxZ - pViewport->MinZ);

        D3DXVec3TransformCoord(pOut, pOut, &mat);
    }
    else
    {
        D3DXVec3TransformCoord(pOut, pV, &mat);
    }

    return pOut;
}


//--------------------------
// 4D Vector
//--------------------------

D3DXVECTOR4* WINAPI VB_D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2, 
      const D3DXVECTOR4 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    D3DXVECTOR4 v;

    v.x = pV1->y * (pV2->z * pV3->w - pV3->z * pV2->w) -
          pV1->z * (pV2->y * pV3->w - pV3->y * pV2->w) +
          pV1->w * (pV2->y * pV3->z - pV3->y * pV2->z);

    v.y = pV1->x * (pV3->z * pV2->w - pV2->z * pV3->w) -
          pV1->z * (pV3->x * pV2->w - pV2->x * pV3->w) +
          pV1->w * (pV3->x * pV2->z - pV2->x * pV3->z);

    v.z = pV1->x * (pV2->y * pV3->w - pV3->y * pV2->w) -
          pV1->y * (pV2->x * pV3->w - pV3->x * pV2->w) +
          pV1->w * (pV2->x * pV3->y - pV3->x * pV2->y);

    v.w = pV1->x * (pV3->y * pV2->z - pV2->y * pV3->z) -
          pV1->y * (pV3->x * pV2->z - pV2->x * pV3->z) +
          pV1->z * (pV3->x * pV2->y - pV2->x * pV3->y);

    *pOut = v;
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec4LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pT1, 
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    pOut->w = sV1 * pV1->w + sT1 * pT1->w + sV2 * pV2->w + sT2 * pT2->w;
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4CatmullRom
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV0, const D3DXVECTOR4 *pV1,
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pV3, float s )
{
#if DBG
    if(!pOut || !pV0 || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV0 = -s3 + s2 + s2 - s;
    float sV1 = 3.0f * s3 - 5.0f * s2 + 2.0f;
    float sV2 = -3.0f * s3 + 4.0f * s2 + s;
    float sV3 = s3 - s2;

    pOut->x = 0.5f * (sV0 * pV0->x + sV1 * pV1->x + sV2 * pV2->x + sV3 * pV3->x);
    pOut->y = 0.5f * (sV0 * pV0->y + sV1 * pV1->y + sV2 * pV2->y + sV3 * pV3->y);
    pOut->z = 0.5f * (sV0 * pV0->z + sV1 * pV1->z + sV2 * pV2->z + sV3 * pV3->z);
    pOut->w = 0.5f * (sV0 * pV0->w + sV1 * pV1->w + sV2 * pV2->w + sV3 * pV3->w);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    pOut->w = pV1->w + f * (pV2->w - pV1->w) + g * (pV3->w - pV1->w);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+0)*4] ; M30
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+2)*4] ; M32
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+1)*4] ; M31
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+3)*4] ; M33
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->_11 + pV->y * pM->_21 + pV->z * pM->_31 + pV->w * pM->_41;
    v.y = pV->x * pM->_12 + pV->y * pM->_22 + pV->z * pM->_32 + pV->w * pM->_42;
    v.z = pV->x * pM->_13 + pV->y * pM->_23 + pV->z * pM->_33 + pV->w * pM->_43;
    v.w = pV->x * pM->_14 + pV->y * pM->_24 + pV->z * pM->_34 + pV->w * pM->_44;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 4D Matrix
//--------------------------

float WINAPI VB_D3DXMatrixfDeterminant
    ( const D3DXMATRIX *pM )
{
#if DBG
    if(!pM)
        return 0.0f;
#endif

    return (pM->_11 * (pM->_22 * (pM->_33 * pM->_44 - pM->_43 * pM->_34) -
                       pM->_23 * (pM->_32 * pM->_44 - pM->_42 * pM->_34) +
                       pM->_24 * (pM->_32 * pM->_43 - pM->_42 * pM->_33)))

         - (pM->_12 * (pM->_21 * (pM->_33 * pM->_44 - pM->_43 * pM->_34) -
                       pM->_23 * (pM->_31 * pM->_44 - pM->_41 * pM->_34) +
                       pM->_24 * (pM->_31 * pM->_43 - pM->_41 * pM->_33)))

         + (pM->_13 * (pM->_21 * (pM->_32 * pM->_44 - pM->_42 * pM->_34) -
                       pM->_22 * (pM->_31 * pM->_44 - pM->_41 * pM->_34) +
                       pM->_24 * (pM->_31 * pM->_42 - pM->_41 * pM->_32)))

         - (pM->_14 * (pM->_21 * (pM->_32 * pM->_43 - pM->_42 * pM->_33) -
                       pM->_22 * (pM->_31 * pM->_43 - pM->_41 * pM->_33) +
                       pM->_23 * (pM->_31 * pM->_42 - pM->_41 * pM->_32)));
}


D3DXMATRIX* WINAPI VB_D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM1, const D3DXMATRIX *pM2 )
{
#if DBG
    if(!pOut || !pM1 || !pM2)
        return NULL;
#endif

#ifdef _X86_
#define MAT(m,a,b) DWORD PTR [(m)+(a)*4+(b)*4]

    D3DXMATRIX Out;

    if(pM2 != pOut)
        goto LRowByColumn;
    if(pM1 != pOut)
        goto LColumnByRow;

    Out = *pM2;
    pM2 = &Out;
    goto LRowByColumn;


LRowByColumn:
    __asm {     
        mov ebx, DWORD PTR[pOut]    // result
        mov ecx, DWORD PTR[pM1]     // a
        mov edx, DWORD PTR[pM2]     // b
        mov edi, -4

    LLoopRow:
        mov esi, -4

        fld MAT(ecx, 0, 0)          // a0
        fld MAT(ecx, 0, 1)          // a1 
        fld MAT(ecx, 0, 2)          // a2  
        fld MAT(ecx, 0, 3)          // a3

    LLoopColumn:
        fld st(3)                   // a0
        fmul MAT(edx, esi, 1*4)     // a0*b0
        fld st(3)                   // a1
        fmul MAT(edx, esi, 2*4)     // a1*b1
        fld st(3)                   // a2
        fmul MAT(edx, esi, 3*4)     // a2*b2
        fld st(3)                   // a3
        fmul MAT(edx, esi, 4*4)     // a3*b3

        fxch st(3)
        faddp st(1), st             // a2*b2+a0*b0
        fxch st(2)
        faddp st(1), st             // a3*b3+a1*b1
        faddp st(1), st             // a3*b3+a1*b1+a2*b2+a0*b0
        fstp MAT(ebx, esi, 4)

        inc esi
        jnz LLoopColumn

        ffree st(3)
        ffree st(2)
        ffree st(1)
        ffree st(0)

        lea ecx, MAT(ecx, 0, 4)
        lea ebx, MAT(ebx, 0, 4)

        inc edi
        jnz LLoopRow
    }

    return pOut;


LColumnByRow:
    __asm {     
        mov ebx, DWORD PTR[pOut]    // result
        mov ecx, DWORD PTR[pM1]     // a
        mov edx, DWORD PTR[pM2]     // b
        mov edi, -4

    LLoopColumn2:
        mov esi, -16

        fld MAT(edx, edi, 1*4);     // b0
        fld MAT(edx, edi, 2*4);     // b1
        fld MAT(edx, edi, 3*4);     // b2
        fld MAT(edx, edi, 4*4);     // b3

    LLoopRow2:
        fld st(3)                   // b0
        fmul MAT(ecx, esi, 0+16)    // a0*b0
        fld st(3)                   // b1
        fmul MAT(ecx, esi, 1+16)    // a1*b1
        fld st(3)                   // b2
        fmul MAT(ecx, esi, 2+16)    // a2*b2
        fld st(3)                   // b3
        fmul MAT(ecx, esi, 3+16)    // a3*b3

        fxch st(3)
        faddp st(1), st             // a2*b2+a0*b0
        fxch st(2)
        faddp st(1), st             // a3*b3+a1*b1
        faddp st(1), st             // a3*b3+a1*b1+a2*b2+a0*b0
        fstp MAT(ebx, esi, 0+16)

        add esi, 4
        jnz LLoopRow2

        ffree st(3)
        ffree st(2)
        ffree st(1)
        ffree st(0)

        lea ebx, MAT(ebx, 0, 1)
        inc edi
        jnz LLoopColumn2
    }

    return pOut;
#undef MAT
#else //!_X86_
    D3DXMATRIX Out;
    D3DXMATRIX *pM = (pOut == pM1 || pOut == pM2) ? &Out : pOut;

    pM->_11 = pM1->_11 * pM2->_11 + pM1->_12 * pM2->_21 + pM1->_13 * pM2->_31 + pM1->_14 * pM2->_41;
    pM->_12 = pM1->_11 * pM2->_12 + pM1->_12 * pM2->_22 + pM1->_13 * pM2->_32 + pM1->_14 * pM2->_42;
    pM->_13 = pM1->_11 * pM2->_13 + pM1->_12 * pM2->_23 + pM1->_13 * pM2->_33 + pM1->_14 * pM2->_43;
    pM->_14 = pM1->_11 * pM2->_14 + pM1->_12 * pM2->_24 + pM1->_13 * pM2->_34 + pM1->_14 * pM2->_44;

    pM->_21 = pM1->_21 * pM2->_11 + pM1->_22 * pM2->_21 + pM1->_23 * pM2->_31 + pM1->_24 * pM2->_41;
    pM->_22 = pM1->_21 * pM2->_12 + pM1->_22 * pM2->_22 + pM1->_23 * pM2->_32 + pM1->_24 * pM2->_42;
    pM->_23 = pM1->_21 * pM2->_13 + pM1->_22 * pM2->_23 + pM1->_23 * pM2->_33 + pM1->_24 * pM2->_43;
    pM->_24 = pM1->_21 * pM2->_14 + pM1->_22 * pM2->_24 + pM1->_23 * pM2->_34 + pM1->_24 * pM2->_44;

    pM->_31 = pM1->_31 * pM2->_11 + pM1->_32 * pM2->_21 + pM1->_33 * pM2->_31 + pM1->_34 * pM2->_41;
    pM->_32 = pM1->_31 * pM2->_12 + pM1->_32 * pM2->_22 + pM1->_33 * pM2->_32 + pM1->_34 * pM2->_42;
    pM->_33 = pM1->_31 * pM2->_13 + pM1->_32 * pM2->_23 + pM1->_33 * pM2->_33 + pM1->_34 * pM2->_43;
    pM->_34 = pM1->_31 * pM2->_14 + pM1->_32 * pM2->_24 + pM1->_33 * pM2->_34 + pM1->_34 * pM2->_44;

    pM->_41 = pM1->_41 * pM2->_11 + pM1->_42 * pM2->_21 + pM1->_43 * pM2->_31 + pM1->_44 * pM2->_41;
    pM->_42 = pM1->_41 * pM2->_12 + pM1->_42 * pM2->_22 + pM1->_43 * pM2->_32 + pM1->_44 * pM2->_42;
    pM->_43 = pM1->_41 * pM2->_13 + pM1->_42 * pM2->_23 + pM1->_43 * pM2->_33 + pM1->_44 * pM2->_43;
    pM->_44 = pM1->_41 * pM2->_14 + pM1->_42 * pM2->_24 + pM1->_43 * pM2->_34 + pM1->_44 * pM2->_44;

    if(pM != pOut)
        *pOut = *pM;

    return pOut;
#endif //!_X86_
}

D3DXMATRIX* WINAPI VB_D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    float f;

    f = pM->_12; pOut->_12 = pM->_21; pOut->_21 = f;
    f = pM->_13; pOut->_13 = pM->_31; pOut->_31 = f;
    f = pM->_14; pOut->_14 = pM->_41; pOut->_41 = f;
    f = pM->_23; pOut->_23 = pM->_32; pOut->_32 = f;
    f = pM->_24; pOut->_24 = pM->_42; pOut->_42 = f;
    f = pM->_34; pOut->_34 = pM->_43; pOut->_43 = f;

    if(pOut != pM)
    {
        pOut->_11 = pM->_11;
        pOut->_22 = pM->_22;
        pOut->_33 = pM->_33;
        pOut->_44 = pM->_44;
    }

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixInverse
    ( D3DXMATRIX *pOut, float *pfDeterminant, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    // XXXlorenmcq - The code was designed to work on a processor with more 
    //  than 4 general-purpose registers.  Is there a more optimal way of 
    //  doing this on X86?

    float fX00, fX01, fX02;
    float fX10, fX11, fX12;
    float fX20, fX21, fX22;
    float fX30, fX31, fX32;
    float fY01, fY02, fY03, fY12, fY13, fY23;
    float fZ02, fZ03, fZ12, fZ13, fZ22, fZ23, fZ32, fZ33;

#define fX03 fX01
#define fX13 fX11
#define fX23 fX21
#define fX33 fX31
#define fZ00 fX02
#define fZ10 fX12
#define fZ20 fX22
#define fZ30 fX32
#define fZ01 fX03
#define fZ11 fX13
#define fZ21 fX23
#define fZ31 fX33
#define fDet fY01
#define fRcp fY02

    // read 1st two columns of matrix
    fX00 = pM->_11;
    fX01 = pM->_12;
    fX10 = pM->_21;
    fX11 = pM->_22;
    fX20 = pM->_31;
    fX21 = pM->_32;
    fX30 = pM->_41;
    fX31 = pM->_42;

    // compute all six 2x2 determinants of 1st two columns
    fY01 = fX00 * fX11 - fX10 * fX01;
    fY02 = fX00 * fX21 - fX20 * fX01;
    fY03 = fX00 * fX31 - fX30 * fX01;
    fY12 = fX10 * fX21 - fX20 * fX11;
    fY13 = fX10 * fX31 - fX30 * fX11;
    fY23 = fX20 * fX31 - fX30 * fX21;

    // read 2nd two columns of matrix
    fX02 = pM->_13;
    fX03 = pM->_14;
    fX12 = pM->_23;
    fX13 = pM->_24;
    fX22 = pM->_33;
    fX23 = pM->_34;
    fX32 = pM->_43;
    fX33 = pM->_44;

    // compute all 3x3 cofactors for 2nd two columns
    fZ33 = fX02 * fY12 - fX12 * fY02 + fX22 * fY01;
    fZ23 = fX12 * fY03 - fX32 * fY01 - fX02 * fY13;
    fZ13 = fX02 * fY23 - fX22 * fY03 + fX32 * fY02;
    fZ03 = fX22 * fY13 - fX32 * fY12 - fX12 * fY23;
    fZ32 = fX13 * fY02 - fX23 * fY01 - fX03 * fY12;
    fZ22 = fX03 * fY13 - fX13 * fY03 + fX33 * fY01;
    fZ12 = fX23 * fY03 - fX33 * fY02 - fX03 * fY23;
    fZ02 = fX13 * fY23 - fX23 * fY13 + fX33 * fY12;

    // compute all six 2x2 determinants of 2nd two columns
    fY01 = fX02 * fX13 - fX12 * fX03;
    fY02 = fX02 * fX23 - fX22 * fX03;
    fY03 = fX02 * fX33 - fX32 * fX03;
    fY12 = fX12 * fX23 - fX22 * fX13;
    fY13 = fX12 * fX33 - fX32 * fX13;
    fY23 = fX22 * fX33 - fX32 * fX23;

    // read 1st two columns of matrix
    fX00 = pM->_11;
    fX01 = pM->_12;
    fX10 = pM->_21;
    fX11 = pM->_22;
    fX20 = pM->_31;
    fX21 = pM->_32;
    fX30 = pM->_41;
    fX31 = pM->_42;

    // compute all 3x3 cofactors for 1st two columns
    fZ30 = fX11 * fY02 - fX21 * fY01 - fX01 * fY12;
    fZ20 = fX01 * fY13 - fX11 * fY03 + fX31 * fY01;
    fZ10 = fX21 * fY03 - fX31 * fY02 - fX01 * fY23;
    fZ00 = fX11 * fY23 - fX21 * fY13 + fX31 * fY12;
    fZ31 = fX00 * fY12 - fX10 * fY02 + fX20 * fY01;
    fZ21 = fX10 * fY03 - fX30 * fY01 - fX00 * fY13;
    fZ11 = fX00 * fY23 - fX20 * fY03 + fX30 * fY02;
    fZ01 = fX20 * fY13 - fX30 * fY12 - fX10 * fY23;

    // compute 4x4 determinant & its reciprocal
    fDet = fX30 * fZ30 + fX20 * fZ20 + fX10 * fZ10 + fX00 * fZ00;

    if(pfDeterminant)
        *pfDeterminant = fDet;

    fRcp = 1.0f / fDet;

    if(!_finite(fRcp))
        return NULL;


    // multiply all 3x3 cofactors by reciprocal & transpose
    pOut->_11 = fZ00 * fRcp;
    pOut->_12 = fZ10 * fRcp;
    pOut->_13 = fZ20 * fRcp;
    pOut->_14 = fZ30 * fRcp;
    pOut->_21 = fZ01 * fRcp;
    pOut->_22 = fZ11 * fRcp;
    pOut->_23 = fZ21 * fRcp;
    pOut->_24 = fZ31 * fRcp;
    pOut->_31 = fZ02 * fRcp;
    pOut->_32 = fZ12 * fRcp;
    pOut->_33 = fZ22 * fRcp;
    pOut->_34 = fZ32 * fRcp;
    pOut->_41 = fZ03 * fRcp;
    pOut->_42 = fZ13 * fRcp;
    pOut->_43 = fZ23 * fRcp;
    pOut->_44 = fZ33 * fRcp;

    
    return pOut;
}



D3DXMATRIX* WINAPI VB_D3DXMatrixScaling
    ( D3DXMATRIX *pOut, float sx, float sy, float sz )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 =
    pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

    pOut->_11 = sx;
    pOut->_22 = sy;
    pOut->_33 = sz;
    pOut->_44 = 1.0f;
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, float x, float y, float z )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 = 0.0f;

    pOut->_11 = pOut->_22 = pOut->_33 = pOut->_44 = 1.0f;

    pOut->_41 = x;
    pOut->_42 = y;
    pOut->_43 = z;
    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 = 1.0f; pOut->_12 = 0.0f; pOut->_13 = 0.0f; pOut->_14 = 0.0f;
    pOut->_21 = 0.0f; pOut->_22 =    c; pOut->_23 =    s; pOut->_24 = 0.0f;
    pOut->_31 = 0.0f; pOut->_32 =   -s; pOut->_33 =    c; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 =    c; pOut->_12 = 0.0f; pOut->_13 =   -s; pOut->_14 = 0.0f;
    pOut->_21 = 0.0f; pOut->_22 = 1.0f; pOut->_23 = 0.0f; pOut->_24 = 0.0f;
    pOut->_31 =    s; pOut->_32 = 0.0f; pOut->_33 =    c; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->_11 =    c; pOut->_12 =    s; pOut->_13 = 0.0f; pOut->_14 = 0.0f;
    pOut->_21 =   -s; pOut->_22 =    c; pOut->_23 = 0.0f; pOut->_24 = 0.0f;
    pOut->_31 = 0.0f; pOut->_32 = 0.0f; pOut->_33 = 1.0f; pOut->_34 = 0.0f;
    pOut->_41 = 0.0f; pOut->_42 = 0.0f; pOut->_43 = 0.0f; pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);
    float c1 = 1 - c;

    D3DXVECTOR3 v = *pV;
    VB_D3DXVec3Normalize(&v, &v);

    float xyc1 = v.x * v.y * c1;
    float yzc1 = v.y * v.z * c1;
    float zxc1 = v.z * v.x * c1;

    pOut->_11 = v.x * v.x * c1 + c;
    pOut->_12 = xyc1 + v.z * s;
    pOut->_13 = zxc1 - v.y * s;
    pOut->_14 = 0.0f;

    pOut->_21 = xyc1 - v.z * s;
    pOut->_22 = v.y * v.y * c1 + c;
    pOut->_23 = yzc1 + v.x * s;
    pOut->_24 = 0.0f;

    pOut->_31 = zxc1 + v.y * s;
    pOut->_32 = yzc1 - v.x * s;
    pOut->_33 = v.z * v.z * c1 + c;
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, const D3DXQUATERNION *pQ)
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float x2 = pQ->x + pQ->x;
    float y2 = pQ->y + pQ->y;
    float z2 = pQ->z + pQ->z;

    float wx2 = pQ->w * x2;
    float wy2 = pQ->w * y2;
    float wz2 = pQ->w * z2;
    float xx2 = pQ->x * x2;
    float xy2 = pQ->x * y2;
    float xz2 = pQ->x * z2;
    float yy2 = pQ->y * y2;
    float yz2 = pQ->y * z2;
    float zz2 = pQ->z * z2;

    pOut->_11 = 1.0f - yy2 - zz2;
    pOut->_12 = xy2 + wz2;
    pOut->_13 = xz2 - wy2;
    pOut->_14 = 0.0f;

    pOut->_21 = xy2 - wz2;
    pOut->_22 = 1.0f - xx2 - zz2;
    pOut->_23 = yz2 + wx2;
    pOut->_24 = 0.0f;

    pOut->_31 = xz2 + wy2;
    pOut->_32 = yz2 - wx2;
    pOut->_33 = 1.0f - xx2 - yy2;
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = 0.0f;
    pOut->_44 = 1.0f;


    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    D3DXQUATERNION q;

    D3DXQuaternionRotationYawPitchRoll(&q, yaw, pitch, roll);
    D3DXMatrixRotationQuaternion(pOut, &q);

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pScalingCenter, 
      const D3DXQUATERNION *pScalingRotation, const D3DXVECTOR3 *pScaling,
      const D3DXVECTOR3 *pRotationCenter, const D3DXQUATERNION *pRotation,
      const D3DXVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    D3DXMATRIX matS, matR, matRI;

    if (pScaling)
    {
        if (pScalingRotation)
        {
            matS._12 = matS._13 = matS._14 =
            matS._21 = matS._23 = matS._24 =
            matS._31 = matS._32 = matS._34 =
            matS._41 = matS._42 = matS._43 = 0.0f;

            matS._11 = pScaling->x;
            matS._22 = pScaling->y;
            matS._33 = pScaling->z;
            matS._44 = 1.0f;

            D3DXMatrixRotationQuaternion(&matR, pScalingRotation);


            if (pScalingCenter)
            {
                // SC-1, SR-1, S, SR, SC
                D3DXMatrixTranspose(&matRI, &matR);
                D3DXMatrixIdentity(pOut);

                pOut->_41 -= pScalingCenter->x;
                pOut->_42 -= pScalingCenter->y;
                pOut->_43 -= pScalingCenter->z;

                D3DXMatrixMultiply(pOut, pOut, &matRI);
                D3DXMatrixMultiply(pOut, pOut, &matS);
                D3DXMatrixMultiply(pOut, pOut, &matR);

                pOut->_41 += pScalingCenter->x;
                pOut->_42 += pScalingCenter->y;
                pOut->_43 += pScalingCenter->z;
            }
            else
            {
                // SR-1, S, SR
                D3DXMatrixTranspose(pOut, &matR);
                D3DXMatrixMultiply(pOut, pOut, &matS);
                D3DXMatrixMultiply(pOut, pOut, &matR);
            }
        }
        else
        {
            // S
            pOut->_12 = pOut->_13 = pOut->_14 =
            pOut->_21 = pOut->_23 = pOut->_24 =
            pOut->_31 = pOut->_32 = pOut->_34 =
            pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

            pOut->_11 = pScaling->x;
            pOut->_22 = pScaling->y;
            pOut->_33 = pScaling->z;
            pOut->_44 = 1.0f;
        }

    }
    else
    {
        D3DXMatrixIdentity(pOut);
    }

    if (pRotation)
    {
        D3DXMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->_41 -= pRotationCenter->x;
            pOut->_42 -= pRotationCenter->y;
            pOut->_43 -= pRotationCenter->z;

            D3DXMatrixMultiply(pOut, pOut, &matR);

            pOut->_41 += pRotationCenter->x;
            pOut->_42 += pRotationCenter->y;
            pOut->_43 += pRotationCenter->z;
        }
        else
        {
            // R
            D3DXMatrixMultiply(pOut, pOut, &matR);
        }
    }

    if (pTranslation)
    {
        // T
        pOut->_41 += pTranslation->x;
        pOut->_42 += pTranslation->y;
        pOut->_43 += pTranslation->z;
    }
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, float Scaling, const D3DXVECTOR3 *pRotationCenter, 
      const D3DXQUATERNION *pRotation, const D3DXVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    // S
    pOut->_12 = pOut->_13 = pOut->_14 =
    pOut->_21 = pOut->_23 = pOut->_24 =
    pOut->_31 = pOut->_32 = pOut->_34 =
    pOut->_41 = pOut->_42 = pOut->_43 = 0.0f;

    pOut->_11 = Scaling;
    pOut->_22 = Scaling;
    pOut->_33 = Scaling;
    pOut->_44 = 1.0f;


    if (pRotation)
    {
        D3DXMATRIX matR;
        D3DXMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->_41 -= pRotationCenter->x;
            pOut->_42 -= pRotationCenter->y;
            pOut->_43 -= pRotationCenter->z;

            D3DXMatrixMultiply(pOut, pOut, &matR);

            pOut->_41 += pRotationCenter->x;
            pOut->_42 += pRotationCenter->y;
            pOut->_43 += pRotationCenter->z;
        }
        else
        {
            // R
            D3DXMatrixMultiply(pOut, pOut, &matR);
        }
    }


    if (pTranslation)
    {
        // T
        pOut->_41 += pTranslation->x;
        pOut->_42 += pTranslation->y;
        pOut->_43 += pTranslation->z;
    }

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixLookAtRH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    D3DXVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (-Z)
    D3DXVec3Subtract(&ZAxis, pEye, pAt);
    D3DXVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    D3DXVec3Cross(&XAxis, pUp, &ZAxis);
    D3DXVec3Normalize(&XAxis, &XAxis);
    D3DXVec3Cross(&YAxis, &ZAxis, &XAxis);

    // Set rotation and translate by pEye
    pOut->_11 = XAxis.x;
    pOut->_21 = XAxis.y;
    pOut->_31 = XAxis.z;
    pOut->_41 = -D3DXVec3Dot(&XAxis, pEye);

    pOut->_12 = YAxis.x;
    pOut->_22 = YAxis.y;
    pOut->_32 = YAxis.z;
    pOut->_42 = -D3DXVec3Dot(&YAxis, pEye);

    pOut->_13 = ZAxis.x;
    pOut->_23 = ZAxis.y;
    pOut->_33 = ZAxis.z;
    pOut->_43 = -D3DXVec3Dot(&ZAxis, pEye);

    pOut->_14 = 0.0f;
    pOut->_24 = 0.0f;
    pOut->_34 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    D3DXVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (+Z)
    D3DXVec3Subtract(&ZAxis, pAt, pEye);
    D3DXVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    D3DXVec3Cross(&XAxis, pUp, &ZAxis);
    D3DXVec3Normalize(&XAxis, &XAxis);
    D3DXVec3Cross(&YAxis, &ZAxis, &XAxis);

    // Set rotation and translate by pEye
    pOut->_11 = XAxis.x;
    pOut->_21 = XAxis.y;
    pOut->_31 = XAxis.z;
    pOut->_41 = -D3DXVec3Dot(&XAxis, pEye);

    pOut->_12 = YAxis.x;
    pOut->_22 = YAxis.y;
    pOut->_32 = YAxis.z;
    pOut->_42 = -D3DXVec3Dot(&YAxis, pEye);

    pOut->_13 = ZAxis.x;
    pOut->_23 = ZAxis.y;
    pOut->_33 = ZAxis.z;
    pOut->_43 = -D3DXVec3Dot(&ZAxis, pEye);

    pOut->_14 = 0.0f;
    pOut->_24 = 0.0f;
    pOut->_34 = 0.0f;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveRH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f * zn / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{

#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f * zn / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFovRH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = aspect * h;

    pOut->_11 = w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = aspect * h;

    pOut->_11 = w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenterRH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * zn * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = (l + r) * wInv;
    pOut->_32 = (t + b) * hInv;
    pOut->_33 = zf / (zn - zf);
    pOut->_34 = -1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 0.0f;


    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * zn * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * zn * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = -(l + r) * wInv;
    pOut->_32 = -(t + b) * hInv;
    pOut->_33 = zf / (zf - zn);
    pOut->_34 = 1.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 0.0f;


    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoRH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zn - zf);
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 1.0f;
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->_11 = 2.0f / w;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f / h;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zf - zn);
    pOut->_34 = 0.0f;

    pOut->_41 = 0.0f;
    pOut->_42 = 0.0f;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenterRH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zn - zf);
    pOut->_34 = 0.0f;

    pOut->_41 = -(l + r) * wInv;
    pOut->_42 = -(t + b) * hInv;
    pOut->_43 = pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->_11 = 2.0f * wInv;
    pOut->_12 = 0.0f;
    pOut->_13 = 0.0f;
    pOut->_14 = 0.0f;

    pOut->_21 = 0.0f;
    pOut->_22 = 2.0f * hInv;
    pOut->_23 = 0.0f;
    pOut->_24 = 0.0f;

    pOut->_31 = 0.0f;
    pOut->_32 = 0.0f;
    pOut->_33 = 1.0f / (zf - zn);
    pOut->_34 = 0.0f;

    pOut->_41 = -(l + r) * wInv;
    pOut->_42 = -(t + b) * hInv;
    pOut->_43 = -pOut->_33 * zn;
    pOut->_44 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixShadow
    ( D3DXMATRIX *pOut, const D3DXVECTOR4 *pLight,
      const D3DXPLANE *pPlane )
{
#if DBG
    if(!pOut || !pLight || !pPlane)
        return NULL;
#endif

    D3DXPLANE p;
    D3DXPlaneNormalize(&p, pPlane);    
    float dot = D3DXPlaneDot(&p, pLight);
    p = -p;

    pOut->_11 = p.a * pLight->x + dot;
    pOut->_21 = p.b * pLight->x;
    pOut->_31 = p.c * pLight->x;
    pOut->_41 = p.d * pLight->x;

    pOut->_12 = p.a * pLight->y;
    pOut->_22 = p.b * pLight->y + dot;
    pOut->_32 = p.c * pLight->y;
    pOut->_42 = p.d * pLight->y;

    pOut->_13 = p.a * pLight->z;
    pOut->_23 = p.b * pLight->z;
    pOut->_33 = p.c * pLight->z + dot;
    pOut->_43 = p.d * pLight->z;

    pOut->_14 = p.a * pLight->w;
    pOut->_24 = p.b * pLight->w;
    pOut->_34 = p.c * pLight->w;
    pOut->_44 = p.d * pLight->w + dot;


    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixReflect
    ( D3DXMATRIX *pOut, const D3DXPLANE *pPlane )
{
#if DBG
    if(!pOut || !pPlane)
        return NULL;
#endif

    D3DXPLANE p;
    D3DXPlaneNormalize(&p, pPlane);
    
    float fa = -2.0f * p.a;
    float fb = -2.0f * p.b;
    float fc = -2.0f * p.c;

    pOut->_11 = fa * p.a + 1.0f;
    pOut->_12 = fb * p.a;
    pOut->_13 = fc * p.a;
    pOut->_14 = 0.0f;

    pOut->_21 = fa * p.b;
    pOut->_22 = fb * p.b + 1.0f;
    pOut->_23 = fc * p.b;
    pOut->_24 = 0.0f;

    pOut->_31 = fa * p.c;
    pOut->_32 = fb * p.c;
    pOut->_33 = fc * p.c + 1.0f;
    pOut->_34 = 0.0f;

    pOut->_41 = fa * p.d;
    pOut->_42 = fb * p.d;
    pOut->_43 = fc * p.d;
    pOut->_44 = 1.0f;

    return pOut;
}

//--------------------------
// Quaternion
//--------------------------

void WINAPI VB_D3DXQuaternionToAxisAngle
    ( const D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, float *pAngle )
{
#if DBG
    if(!pQ)
        return;
#endif

    // expects unit quaternions!
	// q = cos(A/2), sin(A/2) * v

    float lsq = D3DXQuaternionLengthSq(pQ);

    if(lsq > EPSILON * EPSILON)
    {        
        if(pAxis)
        {
            float scale = 1.0f / sqrtf(lsq);
            pAxis->x = pQ->x * scale;
            pAxis->y = pQ->y * scale;
            pAxis->z = pQ->z * scale;
        }

        if(pAngle)
            *pAngle = 2.0f * acosf(pQ->w);

    }
    else
    {
        if(pAxis)
        {
            pAxis->x = 1.0;
            pAxis->y = 0.0;
            pAxis->z = 0.0;
        }

        if(pAngle)
            *pAngle = 0.0f;
    }
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, const D3DXMATRIX *pM)
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif


    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".  (Taken from GDMAG feb'98 p38)

    float trace = pM->_11 + pM->_22 + pM->_33;
    float root;

    if ( trace > 0.0f )
    {
        // |w| > 1/2, may as well choose w > 1/2

        root = sqrtf(trace + 1.0f);  // 2w
        pOut->w = 0.5f * root;

        root = 0.5f / root;  // 1/(4w)
        pOut->x = (pM->_23 - pM->_32) * root;
        pOut->y = (pM->_31 - pM->_13) * root;
        pOut->z = (pM->_12 - pM->_21) * root;
    }
    else
    {
        // |w| <= 1/2
        static const int next[3] = { 1, 2, 0 };

        int i = 0;
        i += (pM->_22 > pM->_11);
        i += (pM->_33 > pM->m[i][i]);

        int j = next[i];
        int k = next[j];

        root = sqrtf(pM->m[i][i] - pM->m[j][j] - pM->m[k][k] + 1.0f);
        (*pOut)[i] = 0.5f * root;

        if(0.0f != root)
            root = 0.5f / root;

        pOut->w    = (pM->m[j][k] - pM->m[k][j]) * root;
        (*pOut)[j] = (pM->m[i][j] + pM->m[j][i]) * root;
        (*pOut)[k] = (pM->m[i][k] + pM->m[k][i]) * root;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXVECTOR3 v;
    D3DXVec3Normalize(&v, pV);

    float s;
    sincosf(0.5f * angle, &s, &pOut->w);

    pOut->x = v.x * s;
    pOut->y = v.y * s;
    pOut->z = v.z * s;

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    //  Roll first, about axis the object is facing, then
    //  pitch upward, then yaw to face into the new heading

    float SR, CR, SP, CP, SY, CY;

    sincosf(0.5f * roll,  &SR, &CR);
    sincosf(0.5f * pitch, &SP, &CP);
    sincosf(0.5f * yaw,   &SY, &CY);

    pOut->x = CY*SP*CR + SY*CP*SR;
    pOut->y = SY*CP*CR - CY*SP*SR;
    pOut->z = CY*CP*SR - SY*SP*CR;
    pOut->w = CY*CP*CR + SY*SP*SR;

    return pOut;
}

/*
float WINAPI VB_D3DXQuaternionDot
    ( CONST D3DXQUATERNION *pQ1, CONST D3DXQUATERNION *pQ2 )
{
#ifdef DBG
    if(!pQ1 || !pQ2)
        return 0.0f;
#endif

    return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
}
*/



D3DXQUATERNION* WINAPI VB_D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2 )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pQ2]
        mov   edx, DWORD PTR [pQ1]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+0*4] ; wx
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+2*4] ; wz
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+1*4] ; wy
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+3*4] ; ww
        fxch  st(3)
        // wx wy wz ww

        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+3*4] ; xw
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+1*4] ; xy
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+2*4] ; xz
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+0*4] ; xx
        fxch  st(3)
        // xw xz xy xx  wx wy wz ww

        faddp st(4), st
        fsubp st(4), st
        faddp st(4), st
        fsubp st(4), st
        // wx-xw wy-xz wz+xy ww-xx

        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+2*4] ; yz
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+0*4] ; yx
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+3*4] ; yw
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+1*4] ; yy
        fxch  st(3)
        // yz yw yx yy  wx-xw wy-xz wz+xy ww-xx

        faddp st(4), st
        faddp st(4), st
        fsubp st(4), st
        fsubp st(4), st
        // wx-xw+yz wy-xz+yw wz+xy-yx ww-xx-yy

        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+1*4] ; zy
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+3*4] ; zw
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+0*4] ; zx
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+2*4] ; zz
        fxch  st(3)
        // zy zx zw zz wx-xw+yz wy-xz+yw wz+xy-yx ww-xx-yy

        fsubp st(4), st
        faddp st(4), st
        faddp st(4), st
        fsubp st(4), st
        // wx-xw+yz-zy wy-xz+yw+zx wz+xy-yx+zw ww-xx-yy-zz

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXQUATERNION Q;

    Q.x = pQ2->w * pQ1->x + pQ2->x * pQ1->w + pQ2->y * pQ1->z - pQ2->z * pQ1->y;
    Q.y = pQ2->w * pQ1->y - pQ2->x * pQ1->z + pQ2->y * pQ1->w + pQ2->z * pQ1->x;
    Q.z = pQ2->w * pQ1->z + pQ2->x * pQ1->y - pQ2->y * pQ1->x + pQ2->z * pQ1->w;
    Q.w = pQ2->w * pQ1->w - pQ2->x * pQ1->x - pQ2->y * pQ1->y - pQ2->z * pQ1->z;

    *pOut = Q;
    return pOut;
#endif // !_X86_
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = D3DXQuaternionLengthSq(pQ);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pQ)
            *pOut = *pQ;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pQ / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = D3DXQuaternionLengthSq(pQ);

    if(f > EPSILON*EPSILON)
    {
        D3DXQuaternionConjugate(pOut, pQ);

        if(!WithinEpsilon(f, 1.0f))
            *pOut /= f;
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects unit quaternions!
    // q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)

    float theta, s;

    if(pQ->w < 1.0f)
    {
        theta = acosf(pQ->w);
        s = sinf(theta);

        if(!WithinEpsilon(s, 0.0f))
        {
            float scale = theta / s;
            pOut->x = pQ->x * scale;
            pOut->y = pQ->y * scale;
            pOut->z = pQ->z * scale;
            pOut->w = 0.0f;
        }
        else
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
            pOut->w = 0.0f;
        }
    }
    else
    {
        pOut->x = pQ->x;
        pOut->y = pQ->y;
        pOut->z = pQ->z;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects pure quaternions! (w == 0)
    // q = (0, theta * v) ; exp(q) = (cos(theta), sin(theta) * v)

    float theta, s;

    theta = sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z);
    sincosf(theta, &s, &pOut->w);

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ)
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
        }
    }
    else
    {
        s /= theta;

        pOut->x = pQ->x * s;
        pOut->y = pQ->y * s;
        pOut->z = pQ->z * s;
    }

    return pOut;
}


D3DXQUATERNION* WINAPI VB_D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, float b )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif

    // expects unit quaternions!
    float a, c, flip, s, omega, sInv;

    a = 1.0f - b;
    c = D3DXQuaternionDot(pQ1, pQ2);
    flip = (c >= 0.0f) ? 1.0f : -1.0f;
    c *= flip;

	if(1.0f - c > EPSILON) {
        s = sqrtf(1.0f - c * c);
 		omega = atan2f(s, c);
 		sInv = 1.0f / s;

 		a = sinf(a * omega) * sInv;
 		b = sinf(b * omega) * sInv;
 	}

    b *= flip;

    pOut->x = a * pQ1->x + b * pQ2->x;
    pOut->y = a * pQ1->y + b * pQ2->y;
    pOut->z = a * pQ1->z + b * pQ2->z;
    pOut->w = a * pQ1->w + b * pQ2->w;

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      const D3DXQUATERNION *pQ4, float t )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3 || !pQ4)
        return NULL;
#endif

    // expects unit quaternions!
    D3DXQUATERNION QA, QB;

    D3DXQuaternionSlerp(&QA, pQ1, pQ4, t);
    D3DXQuaternionSlerp(&QB, pQ2, pQ3, t);
    D3DXQuaternionSlerp(pOut, &QA, &QB, 2.0f * t * (1.0f - t));

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      float f, float g )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3)
        return NULL;
#endif

    // expects unit quaternions!
    D3DXQUATERNION QA, QB;
    float s = f + g;

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ1)
            *pOut = *pQ1;
    }
    else
    {
        D3DXQuaternionSlerp(&QA, pQ1, pQ2, s);
        D3DXQuaternionSlerp(&QB, pQ1, pQ3, s);
        D3DXQuaternionSlerp(pOut, &QA, &QB, g / s);
    }

    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DXPLANE* WINAPI VB_D3DXPlaneNormalize
    ( D3DXPLANE *pOut, const D3DXPLANE *pP )
{
#if DBG
    if(!pOut || !pP)
        return NULL;
#endif

    float f = pP->a * pP->a + pP->b * pP->b + pP->c * pP->c;

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pP)
            *pOut = *pP;
    }
    else if(f > EPSILON * EPSILON)
    {
        float fInv = 1.0f / sqrtf(f);

        pOut->a = pP->a * fInv;
        pOut->b = pP->b * fInv;
        pOut->c = pP->c * fInv;
        pOut->d = pP->d * fInv;
    }
    else
    {
        pOut->a = 0.0f;
        pOut->b = 0.0f;
        pOut->c = 0.0f;
        pOut->d = 0.0f;
    }

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, const D3DXPLANE *pP, const D3DXVECTOR3 *pV1, 
      const D3DXVECTOR3 *pV2)
{
#if DBG
    if(!pOut || !pP || !pV1 || !pV2)
        return NULL;
#endif

    float d =  D3DXPlaneDotNormal(pP, pV1) - D3DXPlaneDotNormal(pP, pV2);

    if(d == 0.0f)
        return NULL;

    float f = D3DXPlaneDotCoord(pP, pV1) / d;

    if(!_finite(f))
        return NULL;

    D3DXVec3Lerp(pOut, pV1, pV2, f);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pPoint, const D3DXVECTOR3 *pNormal)
{
#if DBG
    if(!pOut || !pPoint || !pNormal)
        return NULL;
#endif

    pOut->a = pNormal->x;
    pOut->b = pNormal->y;
    pOut->c = pNormal->z;
    pOut->d = -D3DXVec3Dot(pPoint, pNormal);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2, 
      const D3DXVECTOR3 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    D3DXVECTOR3 V12 = *pV1 - *pV2;
    D3DXVECTOR3 V13 = *pV1 - *pV3;

    D3DXVec3Cross((D3DXVECTOR3 *) pOut, &V12, &V13);
    D3DXVec3Normalize((D3DXVECTOR3 *) pOut, (D3DXVECTOR3 *) pOut);

    pOut->d = -D3DXPlaneDotNormal(pOut, pV1);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneTransform
    ( D3DXPLANE *pOut, const D3DXPLANE *pP, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pP || !pM)
        return NULL;
#endif

    D3DXPLANE P;
    D3DXPlaneNormalize(&P, pP);

    D3DXVECTOR3 V(-P.a * P.d, -P.b * P.d, -P.c * P.d);
    D3DXVec3TransformCoord(&V, &V, pM);

    D3DXVec3TransformNormal((D3DXVECTOR3 *) pOut, (const D3DXVECTOR3 *) &P, pM);
    D3DXVec3Normalize((D3DXVECTOR3 *) pOut, (const D3DXVECTOR3 *) pOut);

    pOut->d = -D3DXPlaneDotNormal(pOut, &V);
    return pOut;
}


//--------------------------
// Color
//--------------------------

D3DXCOLOR* WINAPI VB_D3DXColorAdjustSaturation 
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    // Approximate values for each component's contribution to luminance.
    // (Based upon the NTSC standard described in the comp.graphics.algorithms
    // colorspace FAQ)
    float grey = pC->r * 0.2125f + pC->g * 0.7154f + pC->b * 0.0721f;

    pOut->r = grey + s * (pC->r - grey);
    pOut->g = grey + s * (pC->g - grey);
    pOut->b = grey + s * (pC->b - grey);
    pOut->a = pC->a;
    return pOut;
}

D3DXCOLOR* WINAPI VB_D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float c)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 0.5f + c * (pC->r - 0.5f);
    pOut->g = 0.5f + c * (pC->g - 0.5f);
    pOut->b = 0.5f + c * (pC->b - 0.5f);
    pOut->a = pC->a;
    return pOut;
}

	


//--------------------------
// ColorAUX
//--------------------------

long WINAPI VB_D3DColorARGB(short a, short r, short g , short b)
{
	return D3DCOLOR_ARGB(a,r,g,b);
}

long WINAPI VB_D3DColorRGBA(short r, short g , short b, short a)
{
	return D3DCOLOR_RGBA(r,g,b,a);
}

long WINAPI VB_D3DColorXRGB(short r, short g , short b)
{
	return D3DCOLOR_XRGB(r,g,b);
}

long WINAPI VB_D3DColorMake(float r,float g, float b, float a)
{
	return D3DCOLOR_COLORVALUE(r,g,b,a);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3dxmath.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.cpp
//  Content:    
//
//////////////////////////////////////////////////////////////////////////////

#include "pchmath.h"
#define EPSILON 0.00001f



//
// WithinEpsilon - Are two values within EPSILON of each other?
//

static inline BOOL 
WithinEpsilon(float a, float b)
{
    float f = a - b;
    return -EPSILON <= f && f <= EPSILON;
}


//
// sincosf - Compute the sin and cos of an angle at the same time
//

static inline void
sincosf(float angle, float *psin, float *pcos)
{
#ifdef _X86_
#define fsincos __asm _emit 0xd9 __asm _emit 0xfb
    __asm {
        mov eax, psin
        mov edx, pcos
        fld angle
        fsincos
        fstp DWORD ptr [edx]
        fstp DWORD ptr [eax]
    }
#undef fsincos
#else //!_X86_
    *psin = sinf(angle);
    *pcos = cosf(angle);
#endif //!_X86_
}


//--------------------------
// 2D Vector
//--------------------------

D3DXVECTOR2* WINAPI VB_D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = VB_D3DXVec2LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }    
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
    }

    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pT1, 
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pM->m30;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pM->m31;
    v.z = pV->x * pM->m02 + pV->y * pM->m12 + pM->m32;
    v.w = pV->x * pM->m03 + pV->y * pM->m13 + pM->m33;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR2* WINAPI VB_D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

    float w;

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(2)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(3), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [w]
    }

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pM->m30;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pM->m31;
    w   = pV->x * pM->m03 + pV->y * pM->m13 + pM->m33;

    *pOut = *((D3DXVECTOR2 *) &v);
#endif // !_X86_
    
    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

D3DXVECTOR2* WINAPI VB_D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fxch  st(1)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fxch  st(1)

        faddp st(2), st
        faddp st(2), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR2 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10;
    v.y = pV->x * pM->m01 + pV->y * pM->m11;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 3D Vector
//--------------------------

D3DXVECTOR3* WINAPI VB_D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = VB_D3DXVec3LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
    }

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pT1, 
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pV->z * pM->m20 + pM->m30;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pV->z * pM->m21 + pM->m31;
    v.z = pV->x * pM->m02 + pV->y * pM->m12 + pV->z * pM->m22 + pM->m32;
    v.w = pV->x * pM->m03 + pV->y * pM->m13 + pV->z * pM->m23 + pM->m33;

    *pOut = v;
    return pOut;
#endif // !_X86_
}

D3DXVECTOR3* WINAPI VB_D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

    float w;

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [edx+(3*4+0)*4] ; M30
        faddp st(1), st
        fld   DWORD PTR [edx+(3*4+1)*4] ; M31
        faddp st(2), st
        fld   DWORD PTR [edx+(3*4+2)*4] ; M32
        faddp st(3), st
        fld   DWORD PTR [edx+(3*4+3)*4] ; M33
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [w]
    }

#else // !_X86_
    D3DXVECTOR3 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pV->z * pM->m20 + pM->m30;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pV->z * pM->m21 + pM->m31;
    v.z = pV->x * pM->m02 + pV->y * pM->m12 + pV->z * pM->m22 + pM->m32;
    w   = pV->x * pM->m03 + pV->y * pM->m13 + pV->z * pM->m23 + pM->m33;

    *pOut = v;
#endif // !_X86_
    
    if(!WithinEpsilon(w, 1.0f))
        *pOut /= w;

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fxch  st(2)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fxch  st(2)

        faddp st(3), st
        faddp st(3), st
        faddp st(3), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR3 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pV->z * pM->m20;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pV->z * pM->m21;
    v.z = pV->x * pM->m02 + pV->y * pM->m12 + pV->z * pM->m22;

    *pOut = v;
    return pOut;
#endif // !_X86_
}



//--------------------------
// 4D Vector
//--------------------------

D3DXVECTOR4* WINAPI VB_D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2, 
      const D3DXVECTOR4 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    D3DXVECTOR4 v;

    v.x = pV1->y * (pV2->z * pV3->w - pV3->z * pV2->w) -
          pV1->z * (pV2->y * pV3->w - pV3->y * pV2->w) +
          pV1->w * (pV2->y * pV3->z - pV3->y * pV2->z);

    v.y = pV1->x * (pV3->z * pV2->w - pV2->z * pV3->w) -
          pV1->z * (pV3->x * pV2->w - pV2->x * pV3->w) +
          pV1->w * (pV3->x * pV2->z - pV2->x * pV3->z);

    v.z = pV1->x * (pV2->y * pV3->w - pV3->y * pV2->w) -
          pV1->y * (pV2->x * pV3->w - pV3->x * pV2->w) +
          pV1->w * (pV2->x * pV3->y - pV3->x * pV2->y);

    v.w = pV1->x * (pV3->y * pV2->z - pV2->y * pV3->z) -
          pV1->y * (pV3->x * pV2->z - pV2->x * pV3->z) +
          pV1->z * (pV3->x * pV2->y - pV2->x * pV3->y);

    *pOut = v;
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float f = D3DXVec4LengthSq(pV);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pV)
            *pOut = *pV;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pV / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pT1, 
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pT2, float s )
{
#if DBG
    if(!pOut || !pV1 || !pT1 || !pV2 || !pT2)
        return NULL;
#endif

    float s2 = s * s;
    float s3 = s * s2;

    float sV1 = 2.0f * s3 - 3.0f * s2 + 1.0f;
    float sT1 = s3 - 2.0f * s2 + s;
    float sV2 = -2.0f * s3 + 3.0f * s2;
    float sT2 = s3 - s2;

    pOut->x = sV1 * pV1->x + sT1 * pT1->x + sV2 * pV2->x + sT2 * pT2->x;
    pOut->y = sV1 * pV1->y + sT1 * pT1->y + sV2 * pV2->y + sT2 * pT2->y;
    pOut->z = sV1 * pV1->z + sT1 * pT1->z + sV2 * pV2->z + sT2 * pT2->z;
    pOut->w = sV1 * pV1->w + sT1 * pT1->w + sV2 * pV2->w + sT2 * pT2->w;
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3, float f, float g)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    pOut->x = pV1->x + f * (pV2->x - pV1->x) + g * (pV3->x - pV1->x);
    pOut->y = pV1->y + f * (pV2->y - pV1->y) + g * (pV3->y - pV1->y);
    pOut->z = pV1->z + f * (pV2->z - pV1->z) + g * (pV3->z - pV1->z);
    pOut->w = pV1->w + f * (pV2->w - pV1->w) + g * (pV3->w - pV1->w);
    return pOut;
}

D3DXVECTOR4* WINAPI VB_D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pV || !pM)
        return NULL;
#endif

#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pV]
        mov   edx, DWORD PTR [pM]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+0)*4] ; M00
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+2)*4] ; M02
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+1)*4] ; M01
        fld   DWORD PTR [eax+0*4]       ; X
        fmul  DWORD PTR [edx+(0*4+3)*4] ; M03
        fxch  st(3)

        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+0)*4] ; M10
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+2)*4] ; M12
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+1)*4] ; M11
        fld   DWORD PTR [eax+1*4]       ; Y
        fmul  DWORD PTR [edx+(1*4+3)*4] ; M13
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+0)*4] ; M20
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+2)*4] ; M22
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+1)*4] ; M21
        fld   DWORD PTR [eax+2*4]       ; Z
        fmul  DWORD PTR [edx+(2*4+3)*4] ; M23
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+0)*4] ; M30
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+2)*4] ; M32
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+1)*4] ; M31
        fld   DWORD PTR [eax+3*4]       ; W
        fmul  DWORD PTR [edx+(3*4+3)*4] ; M33
        fxch  st(3)

        faddp st(4), st
        faddp st(4), st
        faddp st(4), st
        faddp st(4), st

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXVECTOR4 v;

    v.x = pV->x * pM->m00 + pV->y * pM->m10 + pV->z * pM->m20 + pV->w * pM->m30;
    v.y = pV->x * pM->m01 + pV->y * pM->m11 + pV->z * pM->m21 + pV->w * pM->m31;
    v.z = pV->x * pM->m02 + pV->y * pM->m12 + pV->z * pM->m22 + pV->w * pM->m32;
    v.w = pV->x * pM->m03 + pV->y * pM->m13 + pV->z * pM->m23 + pV->w * pM->m33;

    *pOut = v;
    return pOut;
#endif // !_X86_
}


//--------------------------
// 4D Matrix
//--------------------------

float WINAPI VB_D3DXMatrixfDeterminant
    ( const D3DXMATRIX *pM )
{
#if DBG
    if(!pM)
        return 0.0f;
#endif

    return (pM->m00 * (pM->m11 * (pM->m22 * pM->m33 - pM->m32 * pM->m23) -
                       pM->m12 * (pM->m21 * pM->m33 - pM->m31 * pM->m23) +
                       pM->m13 * (pM->m21 * pM->m32 - pM->m31 * pM->m22)))

         - (pM->m01 * (pM->m10 * (pM->m22 * pM->m33 - pM->m32 * pM->m23) -
                       pM->m12 * (pM->m20 * pM->m33 - pM->m30 * pM->m23) +
                       pM->m13 * (pM->m20 * pM->m32 - pM->m30 * pM->m22)))

         + (pM->m02 * (pM->m10 * (pM->m21 * pM->m33 - pM->m31 * pM->m23) -
                       pM->m11 * (pM->m20 * pM->m33 - pM->m30 * pM->m23) +
                       pM->m13 * (pM->m20 * pM->m31 - pM->m30 * pM->m21)))

         - (pM->m03 * (pM->m10 * (pM->m21 * pM->m32 - pM->m31 * pM->m22) -
                       pM->m11 * (pM->m20 * pM->m32 - pM->m30 * pM->m22) +
                       pM->m12 * (pM->m20 * pM->m31 - pM->m30 * pM->m21)));
}


D3DXMATRIX* WINAPI VB_D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM1, const D3DXMATRIX *pM2 )
{
#if DBG
    if(!pOut || !pM1 || !pM2)
        return NULL;
#endif

#ifdef _X86_
#define MAT(m,a,b) DWORD PTR [(m)+(a)*4+(b)*4]

    D3DXMATRIX Out;

    if(pM2 != pOut)
        goto LRowByColumn;
    if(pM1 != pOut)
        goto LColumnByRow;

    Out = *pM2;
    pM2 = &Out;
    goto LRowByColumn;


LRowByColumn:
    __asm {     
        mov ebx, DWORD PTR[pOut]    // result
        mov ecx, DWORD PTR[pM1]     // a
        mov edx, DWORD PTR[pM2]     // b
        mov edi, -4

    LLoopRow:
        mov esi, -4

        fld MAT(ecx, 0, 0)          // a0
        fld MAT(ecx, 0, 1)          // a1 
        fld MAT(ecx, 0, 2)          // a2  
        fld MAT(ecx, 0, 3)          // a3

    LLoopColumn:
        fld st(3)                   // a0
        fmul MAT(edx, esi, 1*4)     // a0*b0
        fld st(3)                   // a1
        fmul MAT(edx, esi, 2*4)     // a1*b1
        fld st(3)                   // a2
        fmul MAT(edx, esi, 3*4)     // a2*b2
        fld st(3)                   // a3
        fmul MAT(edx, esi, 4*4)     // a3*b3

        fxch st(3)
        faddp st(1), st             // a2*b2+a0*b0
        fxch st(2)
        faddp st(1), st             // a3*b3+a1*b1
        faddp st(1), st             // a3*b3+a1*b1+a2*b2+a0*b0
        fstp MAT(ebx, esi, 4)

        inc esi
        jnz LLoopColumn

        ffree st(3)
        ffree st(2)
        ffree st(1)
        ffree st(0)

        lea ecx, MAT(ecx, 0, 4)
        lea ebx, MAT(ebx, 0, 4)

        inc edi
        jnz LLoopRow
    }

    return pOut;


LColumnByRow:
    __asm {     
        mov ebx, DWORD PTR[pOut]    // result
        mov ecx, DWORD PTR[pM1]     // a
        mov edx, DWORD PTR[pM2]     // b
        mov edi, -4

    LLoopColumn2:
        mov esi, -16

        fld MAT(edx, edi, 1*4);     // b0
        fld MAT(edx, edi, 2*4);     // b1
        fld MAT(edx, edi, 3*4);     // b2
        fld MAT(edx, edi, 4*4);     // b3

    LLoopRow2:
        fld st(3)                   // b0
        fmul MAT(ecx, esi, 0+16)    // a0*b0
        fld st(3)                   // b1
        fmul MAT(ecx, esi, 1+16)    // a1*b1
        fld st(3)                   // b2
        fmul MAT(ecx, esi, 2+16)    // a2*b2
        fld st(3)                   // b3
        fmul MAT(ecx, esi, 3+16)    // a3*b3

        fxch st(3)
        faddp st(1), st             // a2*b2+a0*b0
        fxch st(2)
        faddp st(1), st             // a3*b3+a1*b1
        faddp st(1), st             // a3*b3+a1*b1+a2*b2+a0*b0
        fstp MAT(ebx, esi, 0+16)

        add esi, 4
        jnz LLoopRow2

        ffree st(3)
        ffree st(2)
        ffree st(1)
        ffree st(0)

        lea ebx, MAT(ebx, 0, 1)
        inc edi
        jnz LLoopColumn2
    }

    return pOut;
#undef MAT
#else //!_X86_
    D3DXMATRIX Out;
    D3DXMATRIX *pM = (pOut == pM1 || pOut == pM2) ? &Out : pOut;

    pM->m00 = pM1->m00 * pM2->m00 + pM1->m01 * pM2->m10 + pM1->m02 * pM2->m20 + pM1->m03 * pM2->m30;
    pM->m01 = pM1->m00 * pM2->m01 + pM1->m01 * pM2->m11 + pM1->m02 * pM2->m21 + pM1->m03 * pM2->m31;
    pM->m02 = pM1->m00 * pM2->m02 + pM1->m01 * pM2->m12 + pM1->m02 * pM2->m22 + pM1->m03 * pM2->m32;
    pM->m03 = pM1->m00 * pM2->m03 + pM1->m01 * pM2->m13 + pM1->m02 * pM2->m23 + pM1->m03 * pM2->m33;

    pM->m10 = pM1->m10 * pM2->m00 + pM1->m11 * pM2->m10 + pM1->m12 * pM2->m20 + pM1->m13 * pM2->m30;
    pM->m11 = pM1->m10 * pM2->m01 + pM1->m11 * pM2->m11 + pM1->m12 * pM2->m21 + pM1->m13 * pM2->m31;
    pM->m12 = pM1->m10 * pM2->m02 + pM1->m11 * pM2->m12 + pM1->m12 * pM2->m22 + pM1->m13 * pM2->m32;
    pM->m13 = pM1->m10 * pM2->m03 + pM1->m11 * pM2->m13 + pM1->m12 * pM2->m23 + pM1->m13 * pM2->m33;

    pM->m20 = pM1->m20 * pM2->m00 + pM1->m21 * pM2->m10 + pM1->m22 * pM2->m20 + pM1->m23 * pM2->m30;
    pM->m21 = pM1->m20 * pM2->m01 + pM1->m21 * pM2->m11 + pM1->m22 * pM2->m21 + pM1->m23 * pM2->m31;
    pM->m22 = pM1->m20 * pM2->m02 + pM1->m21 * pM2->m12 + pM1->m22 * pM2->m22 + pM1->m23 * pM2->m32;
    pM->m23 = pM1->m20 * pM2->m03 + pM1->m21 * pM2->m13 + pM1->m22 * pM2->m23 + pM1->m23 * pM2->m33;

    pM->m30 = pM1->m30 * pM2->m00 + pM1->m31 * pM2->m10 + pM1->m32 * pM2->m20 + pM1->m33 * pM2->m30;
    pM->m31 = pM1->m30 * pM2->m01 + pM1->m31 * pM2->m11 + pM1->m32 * pM2->m21 + pM1->m33 * pM2->m31;
    pM->m32 = pM1->m30 * pM2->m02 + pM1->m31 * pM2->m12 + pM1->m32 * pM2->m22 + pM1->m33 * pM2->m32;
    pM->m33 = pM1->m30 * pM2->m03 + pM1->m31 * pM2->m13 + pM1->m32 * pM2->m23 + pM1->m33 * pM2->m33;

    if(pM != pOut)
        *pOut = *pM;

    return pOut;
#endif //!_X86_
}

D3DXMATRIX* WINAPI VB_D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    float f;

    f = pM->m01; pOut->m01 = pM->m10; pOut->m10 = f;
    f = pM->m02; pOut->m02 = pM->m20; pOut->m20 = f;
    f = pM->m03; pOut->m03 = pM->m30; pOut->m30 = f;
    f = pM->m12; pOut->m12 = pM->m21; pOut->m21 = f;
    f = pM->m13; pOut->m13 = pM->m31; pOut->m31 = f;
    f = pM->m23; pOut->m23 = pM->m32; pOut->m32 = f;

    if(pOut != pM)
    {
        pOut->m00 = pM->m00;
        pOut->m11 = pM->m11;
        pOut->m22 = pM->m22;
        pOut->m33 = pM->m33;
    }

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixInverse
    ( D3DXMATRIX *pOut, float *pfDeterminant, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    // XXXlorenmcq - The code was designed to work on a processor with more 
    //  than 4 general-purpose registers.  Is there a more optimal way of 
    //  doing this on X86?

    float fX00, fX01, fX02;
    float fX10, fX11, fX12;
    float fX20, fX21, fX22;
    float fX30, fX31, fX32;
    float fY01, fY02, fY03, fY12, fY13, fY23;
    float fZ02, fZ03, fZ12, fZ13, fZ22, fZ23, fZ32, fZ33;

#define fX03 fX01
#define fX13 fX11
#define fX23 fX21
#define fX33 fX31
#define fZ00 fX02
#define fZ10 fX12
#define fZ20 fX22
#define fZ30 fX32
#define fZ01 fX03
#define fZ11 fX13
#define fZ21 fX23
#define fZ31 fX33
#define fDet fY01
#define fRcp fY02

    // read 1st two columns of matrix
    fX00 = pM->m00;
    fX01 = pM->m01;
    fX10 = pM->m10;
    fX11 = pM->m11;
    fX20 = pM->m20;
    fX21 = pM->m21;
    fX30 = pM->m30;
    fX31 = pM->m31;

    // compute all six 2x2 determinants of 1st two columns
    fY01 = fX00 * fX11 - fX10 * fX01;
    fY02 = fX00 * fX21 - fX20 * fX01;
    fY03 = fX00 * fX31 - fX30 * fX01;
    fY12 = fX10 * fX21 - fX20 * fX11;
    fY13 = fX10 * fX31 - fX30 * fX11;
    fY23 = fX20 * fX31 - fX30 * fX21;

    // read 2nd two columns of matrix
    fX02 = pM->m02;
    fX03 = pM->m03;
    fX12 = pM->m12;
    fX13 = pM->m13;
    fX22 = pM->m22;
    fX23 = pM->m23;
    fX32 = pM->m32;
    fX33 = pM->m33;

    // compute all 3x3 cofactors for 2nd two columns
    fZ33 = fX02 * fY12 - fX12 * fY02 + fX22 * fY01;
    fZ23 = fX12 * fY03 - fX32 * fY01 - fX02 * fY13;
    fZ13 = fX02 * fY23 - fX22 * fY03 + fX32 * fY02;
    fZ03 = fX22 * fY13 - fX32 * fY12 - fX12 * fY23;
    fZ32 = fX13 * fY02 - fX23 * fY01 - fX03 * fY12;
    fZ22 = fX03 * fY13 - fX13 * fY03 + fX33 * fY01;
    fZ12 = fX23 * fY03 - fX33 * fY02 - fX03 * fY23;
    fZ02 = fX13 * fY23 - fX23 * fY13 + fX33 * fY12;

    // compute all six 2x2 determinants of 2nd two columns
    fY01 = fX02 * fX13 - fX12 * fX03;
    fY02 = fX02 * fX23 - fX22 * fX03;
    fY03 = fX02 * fX33 - fX32 * fX03;
    fY12 = fX12 * fX23 - fX22 * fX13;
    fY13 = fX12 * fX33 - fX32 * fX13;
    fY23 = fX22 * fX33 - fX32 * fX23;

    // read 1st two columns of matrix
    fX00 = pM->m00;
    fX01 = pM->m01;
    fX10 = pM->m10;
    fX11 = pM->m11;
    fX20 = pM->m20;
    fX21 = pM->m21;
    fX30 = pM->m30;
    fX31 = pM->m31;

    // compute all 3x3 cofactors for 1st two columns
    fZ30 = fX11 * fY02 - fX21 * fY01 - fX01 * fY12;
    fZ20 = fX01 * fY13 - fX11 * fY03 + fX31 * fY01;
    fZ10 = fX21 * fY03 - fX31 * fY02 - fX01 * fY23;
    fZ00 = fX11 * fY23 - fX21 * fY13 + fX31 * fY12;
    fZ31 = fX00 * fY12 - fX10 * fY02 + fX20 * fY01;
    fZ21 = fX10 * fY03 - fX30 * fY01 - fX00 * fY13;
    fZ11 = fX00 * fY23 - fX20 * fY03 + fX30 * fY02;
    fZ01 = fX20 * fY13 - fX30 * fY12 - fX10 * fY23;

    // compute 4x4 determinant & its reciprocal
    fDet = fX30 * fZ30 + fX20 * fZ20 + fX10 * fZ10 + fX00 * fZ00;

    if(pfDeterminant)
        *pfDeterminant = fDet;

    fRcp = 1.0f / fDet;

    if(!_finite(fRcp))
        return NULL;


    // multiply all 3x3 cofactors by reciprocal & transpose
    pOut->m00 = fZ00 * fRcp;
    pOut->m01 = fZ10 * fRcp;
    pOut->m02 = fZ20 * fRcp;
    pOut->m03 = fZ30 * fRcp;
    pOut->m10 = fZ01 * fRcp;
    pOut->m11 = fZ11 * fRcp;
    pOut->m12 = fZ21 * fRcp;
    pOut->m13 = fZ31 * fRcp;
    pOut->m20 = fZ02 * fRcp;
    pOut->m21 = fZ12 * fRcp;
    pOut->m22 = fZ22 * fRcp;
    pOut->m23 = fZ32 * fRcp;
    pOut->m30 = fZ03 * fRcp;
    pOut->m31 = fZ13 * fRcp;
    pOut->m32 = fZ23 * fRcp;
    pOut->m33 = fZ33 * fRcp;
    
    return pOut;
}



D3DXMATRIX* WINAPI VB_D3DXMatrixScaling
    ( D3DXMATRIX *pOut, float sx, float sy, float sz )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m01 = pOut->m02 = pOut->m03 = 
    pOut->m10 = pOut->m12 = pOut->m13 = 
    pOut->m20 = pOut->m21 = pOut->m23 = 
    pOut->m30 = pOut->m31 = pOut->m32 = 0.0f;

    pOut->m00 = sx;
    pOut->m11 = sy;
    pOut->m22 = sz;
    pOut->m33 = 1.0f;
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, float x, float y, float z )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m01 = pOut->m02 = pOut->m03 = 
    pOut->m10 = pOut->m12 = pOut->m13 = 
    pOut->m20 = pOut->m21 = pOut->m23 = 0.0f;

    pOut->m00 = pOut->m11 = pOut->m22 = pOut->m33 = 1.0f;

    pOut->m30 = x;
    pOut->m31 = y;
    pOut->m32 = z;
    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->m00 = 1.0f; pOut->m01 = 0.0f; pOut->m02 = 0.0f; pOut->m03 = 0.0f;
    pOut->m10 = 0.0f; pOut->m11 =    c; pOut->m12 =    s; pOut->m13 = 0.0f;
    pOut->m20 = 0.0f; pOut->m21 =   -s; pOut->m22 =    c; pOut->m23 = 0.0f;
    pOut->m30 = 0.0f; pOut->m31 = 0.0f; pOut->m32 = 0.0f; pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->m00 =    c; pOut->m01 = 0.0f; pOut->m02 =   -s; pOut->m03 = 0.0f;
    pOut->m10 = 0.0f; pOut->m11 = 1.0f; pOut->m12 = 0.0f; pOut->m13 = 0.0f;
    pOut->m20 =    s; pOut->m21 = 0.0f; pOut->m22 =    c; pOut->m23 = 0.0f;
    pOut->m30 = 0.0f; pOut->m31 = 0.0f; pOut->m32 = 0.0f; pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, float angle )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);

    pOut->m00 =    c; pOut->m01 =    s; pOut->m02 = 0.0f; pOut->m03 = 0.0f;
    pOut->m10 =   -s; pOut->m11 =    c; pOut->m12 = 0.0f; pOut->m13 = 0.0f;
    pOut->m20 = 0.0f; pOut->m21 = 0.0f; pOut->m22 = 1.0f; pOut->m23 = 0.0f;
    pOut->m30 = 0.0f; pOut->m31 = 0.0f; pOut->m32 = 0.0f; pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    float s, c;
    sincosf(angle, &s, &c);
    float c1 = 1 - c;

    D3DXVECTOR3 v = *pV;
    VB_D3DXVec3Normalize(&v, &v);

    float xyc1 = v.x * v.y * c1;
    float yzc1 = v.y * v.z * c1;
    float zxc1 = v.z * v.x * c1;

    pOut->m00 = v.x * v.x * c1 + c;
    pOut->m01 = xyc1 + v.z * s;
    pOut->m02 = zxc1 - v.y * s;
    pOut->m03 = 0.0f;

    pOut->m10 = xyc1 - v.z * s;
    pOut->m11 = v.y * v.y * c1 + c;
    pOut->m12 = yzc1 + v.x * s;
    pOut->m13 = 0.0f;

    pOut->m20 = zxc1 + v.y * s;
    pOut->m21 = yzc1 - v.x * s;
    pOut->m22 = v.z * v.z * c1 + c;
    pOut->m23 = 0.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = 0.0f;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, const D3DXQUATERNION *pQ)
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float x2 = pQ->x + pQ->x;
    float y2 = pQ->y + pQ->y;
    float z2 = pQ->z + pQ->z;

    float wx2 = pQ->w * x2;
    float wy2 = pQ->w * y2;
    float wz2 = pQ->w * z2;
    float xx2 = pQ->x * x2;
    float xy2 = pQ->x * y2;
    float xz2 = pQ->x * z2;
    float yy2 = pQ->y * y2;
    float yz2 = pQ->y * z2;
    float zz2 = pQ->z * z2;

    pOut->m00 = 1.0f - yy2 - zz2;
    pOut->m01 = xy2 + wz2;
    pOut->m02 = xz2 - wy2;
    pOut->m03 = 0.0f;

    pOut->m10 = xy2 - wz2;
    pOut->m11 = 1.0f - xx2 - zz2;
    pOut->m12 = yz2 + wx2;
    pOut->m13 = 0.0f;
    
    pOut->m20 = xz2 + wy2;
    pOut->m21 = yz2 - wx2;
    pOut->m22 = 1.0f - xx2 - yy2;
    pOut->m23 = 0.0f;
    
    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = 0.0f;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    D3DXQUATERNION q;

    VB_D3DXQuaternionRotationYawPitchRoll(&q, yaw, pitch, roll);
    D3DXMatrixRotationQuaternion(pOut, &q);

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pScalingCenter, 
      const D3DXQUATERNION *pScalingRotation, const D3DXVECTOR3 *pScaling,
      const D3DXVECTOR3 *pRotationCenter, const D3DXQUATERNION *pRotation,
      const D3DXVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    D3DXMATRIX matS, matR, matRI;

    if (pScaling)
    {
        if (pScalingRotation)
        {
            matS.m01 = matS.m02 = matS.m03 =
            matS.m10 = matS.m12 = matS.m13 =
            matS.m20 = matS.m21 = matS.m23 =
            matS.m30 = matS.m31 = matS.m32 = 0.0f;

            matS.m00 = pScaling->x;
            matS.m11 = pScaling->y;
            matS.m22 = pScaling->z;
            matS.m33 = 1.0f;

            D3DXMatrixRotationQuaternion(&matR, pScalingRotation);


            if (pScalingCenter)
            {
                // SC-1, SR-1, S, SR, SC
                D3DXMatrixTranspose(&matRI, &matR);
                D3DXMatrixIdentity(pOut);

                pOut->m30 -= pScalingCenter->x;
                pOut->m31 -= pScalingCenter->y;
                pOut->m32 -= pScalingCenter->z;

                D3DXMatrixMultiply(pOut, pOut, &matRI);
                D3DXMatrixMultiply(pOut, pOut, &matS);
                D3DXMatrixMultiply(pOut, pOut, &matR);

                pOut->m30 += pScalingCenter->x;
                pOut->m31 += pScalingCenter->y;
                pOut->m32 += pScalingCenter->z;
            }
            else
            {
                // SR-1, S, SR
                D3DXMatrixTranspose(pOut, &matR);
                D3DXMatrixMultiply(pOut, pOut, &matS);
                D3DXMatrixMultiply(pOut, pOut, &matR);
            }
        }
        else
        {
            // S
            pOut->m01 = pOut->m02 = pOut->m03 =
            pOut->m10 = pOut->m12 = pOut->m13 =
            pOut->m20 = pOut->m21 = pOut->m23 =
            pOut->m30 = pOut->m31 = pOut->m32 = 0.0f;

            pOut->m00 = pScaling->x;
            pOut->m11 = pScaling->y;
            pOut->m22 = pScaling->z;
            pOut->m33 = 1.0f;
        }

    }
    else
    {
        D3DXMatrixIdentity(pOut);
    }

    if (pRotation)
    {
        D3DXMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->m30 -= pRotationCenter->x;
            pOut->m31 -= pRotationCenter->y;
            pOut->m32 -= pRotationCenter->z;

            D3DXMatrixMultiply(pOut, pOut, &matR);

            pOut->m30 += pRotationCenter->x;
            pOut->m31 += pRotationCenter->y;
            pOut->m32 += pRotationCenter->z;
        }
        else
        {
            // R
            D3DXMatrixMultiply(pOut, pOut, &matR);
        }
    }

    if (pTranslation)
    {
        // T
        pOut->m30 += pTranslation->x;
        pOut->m31 += pTranslation->y;
        pOut->m32 += pTranslation->z;
    }

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, float Scaling, const D3DXVECTOR3 *pRotationCenter, 
      const D3DXQUATERNION *pRotation, const D3DXVECTOR3 *pTranslation)
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    // S
    pOut->m01 = pOut->m02 = pOut->m03 =
    pOut->m10 = pOut->m12 = pOut->m13 =
    pOut->m20 = pOut->m21 = pOut->m23 =
    pOut->m30 = pOut->m31 = pOut->m32 = 0.0f;

    pOut->m00 = Scaling;
    pOut->m11 = Scaling;
    pOut->m22 = Scaling;
    pOut->m33 = 1.0f;


    if (pRotation)
    {
        D3DXMATRIX matR;
        D3DXMatrixRotationQuaternion(&matR, pRotation);

        if (pRotationCenter)
        {
            // RC-1, R, RC
            pOut->m30 -= pRotationCenter->x;
            pOut->m31 -= pRotationCenter->y;
            pOut->m32 -= pRotationCenter->z;

            D3DXMatrixMultiply(pOut, pOut, &matR);

            pOut->m30 += pRotationCenter->x;
            pOut->m31 += pRotationCenter->y;
            pOut->m32 += pRotationCenter->z;
        }
        else
        {
            // R
            D3DXMatrixMultiply(pOut, pOut, &matR);
        }
    }


    if (pTranslation)
    {
        // T
        pOut->m30 += pTranslation->x;
        pOut->m31 += pTranslation->y;
        pOut->m32 += pTranslation->z;
    }

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixLookAt
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    D3DXVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (-Z)
    VB_D3DXVec3Subtract(&ZAxis, pEye, pAt);
    VB_D3DXVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    VB_D3DXVec3Cross(&XAxis, pUp, &ZAxis);
    VB_D3DXVec3Normalize(&XAxis, &XAxis);
    VB_D3DXVec3Cross(&YAxis, &ZAxis, &XAxis);

    // Set rotation and translate by pEye
    pOut->m00 = XAxis.x;
    pOut->m10 = XAxis.y;
    pOut->m20 = XAxis.z;
    pOut->m30 = -VB_D3DXVec3Dot(&XAxis, pEye);

    pOut->m01 = YAxis.x;
    pOut->m11 = YAxis.y;
    pOut->m21 = YAxis.z;
    pOut->m31 = -VB_D3DXVec3Dot(&YAxis, pEye);

    pOut->m02 = ZAxis.x;
    pOut->m12 = ZAxis.y;
    pOut->m22 = ZAxis.z;
    pOut->m32 = -VB_D3DXVec3Dot(&ZAxis, pEye);
    
    pOut->m03 = 0.0f;
    pOut->m13 = 0.0f;
    pOut->m23 = 0.0f;
    pOut->m33 = 1.0f;
    
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp )
{
#if DBG
    if(!pOut || !pEye || !pAt || !pUp)
        return NULL;
#endif

    D3DXVECTOR3 XAxis, YAxis, ZAxis;

    // Compute direction of gaze. (+Z)
    VB_D3DXVec3Subtract(&ZAxis, pAt, pEye);
    VB_D3DXVec3Normalize(&ZAxis, &ZAxis);

    // Compute orthogonal axes from cross product of gaze and pUp vector.
    VB_D3DXVec3Cross(&XAxis, &ZAxis, pUp);
    VB_D3DXVec3Normalize(&XAxis, &XAxis);
    VB_D3DXVec3Cross(&YAxis, &XAxis, &ZAxis);

    // Set rotation and translate by pEye
    pOut->m00 = XAxis.x;
    pOut->m10 = XAxis.y;
    pOut->m20 = XAxis.z;
    pOut->m30 = -VB_D3DXVec3Dot(&XAxis, pEye);

    pOut->m01 = YAxis.x;
    pOut->m11 = YAxis.y;
    pOut->m21 = YAxis.z;
    pOut->m31 = -VB_D3DXVec3Dot(&YAxis, pEye);

    pOut->m02 = ZAxis.x;
    pOut->m12 = ZAxis.y;
    pOut->m22 = ZAxis.z;
    pOut->m32 = -VB_D3DXVec3Dot(&ZAxis, pEye);
    
    pOut->m03 = 0.0f;
    pOut->m13 = 0.0f;
    pOut->m23 = 0.0f;
    pOut->m33 = 1.0f;
    
    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspective
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m00 = 2.0f * zn / w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * zn / h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = zf / (zn - zf);
    pOut->m23 = -1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m00 = 2.0f * zn / w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * zn / h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = zf / (zf - zn);
    pOut->m23 = 1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = -pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFov
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = aspect * h;

    pOut->m00 = w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = zf / (zn - zf);
    pOut->m23 = -1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float s, c;
    sincosf(0.5f * fovy, &s, &c);

    float h = c / s;
    float w = aspect * h;

    pOut->m00 = w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = zf / (zf - zn);
    pOut->m23 = 1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = -pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenter
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->m00 = 2.0f * zn * wInv;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * zn * hInv;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = (l + r) * wInv;
    pOut->m21 = (t + b) * hInv;
    pOut->m22 = zf / (zn - zf);
    pOut->m23 = -1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->m00 = 2.0f * zn * wInv;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * zn * hInv;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = -(l + r) * wInv;
    pOut->m21 = -(t + b) * hInv;
    pOut->m22 = zf / (zf - zn);
    pOut->m23 = 1.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = -pOut->m22 * zn;
    pOut->m33 = 0.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrtho
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m00 = 2.0f / w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f / h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = 1.0f / (zn - zf);
    pOut->m23 = 0.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = pOut->m22 * zn;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    pOut->m00 = 2.0f / w;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f / h;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = 1.0f / (zf - zn);
    pOut->m23 = 0.0f;

    pOut->m30 = 0.0f;
    pOut->m31 = 0.0f;
    pOut->m32 = -pOut->m22 * zn;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenter
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->m00 = 2.0f * wInv;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * hInv;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = 1.0f / (zn - zf);
    pOut->m23 = 0.0f;

    pOut->m30 = -(l + r) * wInv;
    pOut->m31 = -(t + b) * hInv;
    pOut->m32 = pOut->m22 * zn;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    float wInv = 1.0f / (r - l);
    float hInv = 1.0f / (t - b);

    pOut->m00 = 2.0f * wInv;
    pOut->m01 = 0.0f;
    pOut->m02 = 0.0f;
    pOut->m03 = 0.0f;

    pOut->m10 = 0.0f;
    pOut->m11 = 2.0f * hInv;
    pOut->m12 = 0.0f;
    pOut->m13 = 0.0f;

    pOut->m20 = 0.0f;
    pOut->m21 = 0.0f;
    pOut->m22 = 1.0f / (zf - zn);
    pOut->m23 = 0.0f;

    pOut->m30 = -(l + r) * wInv;
    pOut->m31 = -(t + b) * hInv;
    pOut->m32 = -pOut->m22 * zn;
    pOut->m33 = 1.0f;

    return pOut;
}

D3DXMATRIX* WINAPI VB_D3DXMatrixShadow
    ( D3DXMATRIX *pOut, const D3DXVECTOR4 *pLight,
      const D3DXPLANE *pPlane )
{
#if DBG
    if(!pOut || !pLight || !pPlane)
        return NULL;
#endif

    D3DXPLANE p;
    VB_D3DXPlaneNormalize(&p, pPlane);    
    float dot = VB_D3DXPlaneDot(&p, pLight);
    p = -p;

    pOut->m00 = p.a * pLight->x + dot;
    pOut->m10 = p.b * pLight->x;
    pOut->m20 = p.c * pLight->x;
    pOut->m30 = p.d * pLight->x;

    pOut->m01 = p.a * pLight->y;
    pOut->m11 = p.b * pLight->y + dot;
    pOut->m21 = p.c * pLight->y;
    pOut->m31 = p.d * pLight->y;

    pOut->m02 = p.a * pLight->z;
    pOut->m12 = p.b * pLight->z;
    pOut->m22 = p.c * pLight->z + dot;
    pOut->m32 = p.d * pLight->z;

    pOut->m03 = p.a * pLight->w;
    pOut->m13 = p.b * pLight->w;
    pOut->m23 = p.c * pLight->w;
    pOut->m33 = p.d * pLight->w + dot;

    return pOut;
}


D3DXMATRIX* WINAPI VB_D3DXMatrixReflect
    ( D3DXMATRIX *pOut, const D3DXPLANE *pPlane )
{
#if DBG
    if(!pOut || !pPlane)
        return NULL;
#endif

    D3DXPLANE p;
    VB_D3DXPlaneNormalize(&p, pPlane);
    
    float fa = -2.0f * p.a;
    float fb = -2.0f * p.b;
    float fc = -2.0f * p.c;

    pOut->m00 = fa * p.a + 1.0f;
    pOut->m01 = fb * p.a;
    pOut->m02 = fc * p.a;
    pOut->m03 = 0.0f;

    pOut->m10 = fa * p.b;
    pOut->m11 = fb * p.b + 1.0f;
    pOut->m12 = fc * p.b;
    pOut->m13 = 0.0f;

    pOut->m20 = fa * p.c;
    pOut->m21 = fb * p.c;
    pOut->m22 = fc * p.c + 1.0f;
    pOut->m23 = 0.0f;

    pOut->m30 = fa * p.d;
    pOut->m31 = fb * p.d;
    pOut->m32 = fc * p.d;
    pOut->m33 = 1.0f;

    return pOut;
}

//--------------------------
// Quaternion
//--------------------------

void WINAPI VB_D3DXQuaternionToAxisAngle
    ( const D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, float *pAngle )
{
#if DBG
    if(!pQ)
        return;
#endif

    // expects unit quaternions!
	// q = cos(A/2), sin(A/2) * v

    float lsq = VB_D3DXQuaternionLengthSq(pQ);

    if(lsq > EPSILON * EPSILON)
    {        
        if(pAxis)
        {
            float scale = 1.0f / sqrtf(lsq);
            pAxis->x = pQ->x * scale;
            pAxis->y = pQ->y * scale;
            pAxis->z = pQ->z * scale;
        }

        if(pAngle)
            *pAngle = 2.0f * acosf(pQ->w);

    }
    else
    {
        if(pAxis)
        {
            pAxis->x = 1.0;
            pAxis->y = 0.0;
            pAxis->z = 0.0;
        }

        if(pAngle)
            *pAngle = 0.0f;
    }
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, const D3DXMATRIX *pM)
{
#if DBG
    if(!pOut || !pM)
        return NULL;
#endif

    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".  (Taken from GDMAG feb'98 p38)

    float trace = pM->m00 + pM->m11 + pM->m22;
    float root;

    if ( trace > 0.0f )
    {
        // |w| > 1/2, may as well choose w > 1/2

        root = sqrtf(trace + 1.0f);  // 2w
        pOut->w = 0.5f * root;

        root = 0.5f / root;  // 1/(4w)
        pOut->x = (pM->m12 - pM->m21) * root;
        pOut->y = (pM->m20 - pM->m02) * root;
        pOut->z = (pM->m01 - pM->m10) * root;
    }
    else
    {
        // |w| <= 1/2
        static const int next[3] = { 1, 2, 0 };

        int i = 0;
        i += (pM->m11 > pM->m00);
        i += (pM->m22 > pM->m[i][i]);

        int j = next[i];
        int k = next[j];

        root = sqrtf(pM->m[i][i] - pM->m[j][j] - pM->m[k][k] + 1.0f);
        (*pOut)[i] = 0.5f * root;

        if(0.0f != root)
            root = 0.5f / root;

        pOut->w    = (pM->m[j][k] - pM->m[k][j]) * root;
        (*pOut)[j] = (pM->m[i][j] + pM->m[j][i]) * root;
        (*pOut)[k] = (pM->m[i][k] + pM->m[k][i]) * root;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, const D3DXVECTOR3 *pV, float angle )
{
#if DBG
    if(!pOut || !pV)
        return NULL;
#endif

    D3DXVECTOR3 v;
    VB_D3DXVec3Normalize(&v, pV);

    float s;
    sincosf(0.5f * angle, &s, &pOut->w);

    pOut->x = v.x * s;
    pOut->y = v.y * s;
    pOut->z = v.z * s;

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, float yaw, float pitch, float roll )
{
#if DBG
    if(!pOut)
        return NULL;
#endif

    //  Roll first, about axis the object is facing, then
    //  pitch upward, then yaw to face into the new heading

    float SR, CR, SP, CP, SY, CY;

    sincosf(0.5f * roll,  &SR, &CR);
    sincosf(0.5f * pitch, &SP, &CP);
    sincosf(0.5f * yaw,   &SY, &CY);

    pOut->x = CY*SP*CR + SY*CP*SR;
    pOut->y = SY*CP*CR - CY*SP*SR;
    pOut->z = CY*CP*SR - SY*SP*CR;
    pOut->w = CY*CP*CR + SY*SP*SR;

    return pOut;
}


D3DXQUATERNION* WINAPI VB_D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2 )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif


#ifdef _X86_
    __asm {
        mov   eax, DWORD PTR [pQ2]
        mov   edx, DWORD PTR [pQ1]
        mov   ecx, DWORD PTR [pOut]

        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+0*4] ; wx
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+2*4] ; wz
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+1*4] ; wy
        fld   DWORD PTR [eax+3*4]
        fmul  DWORD PTR [edx+3*4] ; ww
        fxch  st(3)
        // wx wy wz ww

        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+3*4] ; xw
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+1*4] ; xy
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+2*4] ; xz
        fld   DWORD PTR [eax+0*4]
        fmul  DWORD PTR [edx+0*4] ; xx
        fxch  st(3)
        // xw xz xy xx  wx wy wz ww

        faddp st(4), st
        fsubp st(4), st
        faddp st(4), st
        fsubp st(4), st
        // wx-xw wy-xz wz+xy ww-xx

        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+2*4] ; yz
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+0*4] ; yx
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+3*4] ; yw
        fld   DWORD PTR [eax+1*4]
        fmul  DWORD PTR [edx+1*4] ; yy
        fxch  st(3)
        // yz yw yx yy  wx-xw wy-xz wz+xy ww-xx

        faddp st(4), st
        faddp st(4), st
        fsubp st(4), st
        fsubp st(4), st
        // wx-xw+yz wy-xz+yw wz+xy-yx ww-xx-yy

        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+1*4] ; zy
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+3*4] ; zw
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+0*4] ; zx
        fld   DWORD PTR [eax+2*4]
        fmul  DWORD PTR [edx+2*4] ; zz
        fxch  st(3)
        // zy zx zw zz wx-xw+yz wy-xz+yw wz+xy-yx ww-xx-yy

        fsubp st(4), st
        faddp st(4), st
        faddp st(4), st
        fsubp st(4), st
        // wx-xw+yz-zy wy-xz+yw+zx wz+xy-yx+zw ww-xx-yy-zz

        fstp  DWORD PTR [ecx+0*4]
        fstp  DWORD PTR [ecx+1*4]	
        fstp  DWORD PTR [ecx+2*4]
        fstp  DWORD PTR [ecx+3*4]
    }

    return pOut;

#else // !_X86_
    D3DXQUATERNION Q;

    Q.x = pQ2->w * pQ1->x + pQ2->x * pQ1->w + pQ2->y * pQ1->z - pQ2->z * pQ1->y;
    Q.y = pQ2->w * pQ1->y - pQ2->x * pQ1->z + pQ2->y * pQ1->w + pQ2->z * pQ1->x;
    Q.z = pQ2->w * pQ1->z + pQ2->x * pQ1->y - pQ2->y * pQ1->x + pQ2->z * pQ1->w;
    Q.w = pQ2->w * pQ1->w - pQ2->x * pQ1->x - pQ2->y * pQ1->y - pQ2->z * pQ1->z;

    *pOut = Q;
    return pOut;
#endif // !_X86_
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = VB_D3DXQuaternionLengthSq(pQ);

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pQ)
            *pOut = *pQ;
    }
    else if(f > EPSILON * EPSILON)
    {
        *pOut = *pQ / sqrtf(f);
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    float f = VB_D3DXQuaternionLengthSq(pQ);

    if(f > EPSILON*EPSILON)
    {
        VB_D3DXQuaternionConjugate(pOut, pQ);

        if(!WithinEpsilon(f, 1.0f))
            *pOut /= f;
    }
    else
    {
        pOut->x = 0.0f;
        pOut->y = 0.0f;
        pOut->z = 0.0f;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects unit quaternions!
    // q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)

    float theta, s, scale;

    if(pQ->w < 1.0f)
    {
        theta = acosf(pQ->w);
        s = sinf(theta);

        if(!WithinEpsilon(s, 0.0f))
        {
            float scale = theta / s;
            pOut->x = pQ->x * scale;
            pOut->y = pQ->y * scale;
            pOut->z = pQ->z * scale;
            pOut->w = 0.0f;
        }
        else
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
            pOut->w = 0.0f;
        }
    }
    else
    {
        pOut->x = pQ->x;
        pOut->y = pQ->y;
        pOut->z = pQ->z;
        pOut->w = 0.0f;
    }

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#if DBG
    if(!pOut || !pQ)
        return NULL;
#endif

    // expects pure quaternions! (w == 0)
    // q = (0, theta * v) ; exp(q) = (cos(theta), sin(theta) * v)

    float theta, s;

    theta = sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z);
    sincosf(theta, &s, &pOut->w);

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ)
        {
            pOut->x = pQ->x;
            pOut->y = pQ->y;
            pOut->z = pQ->z;
        }
    }
    else
    {
        s /= theta;

        pOut->x = pQ->x * s;
        pOut->y = pQ->y * s;
        pOut->z = pQ->z * s;
    }

    return pOut;
}


D3DXQUATERNION* WINAPI VB_D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, float b )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2)
        return NULL;
#endif

    // expects unit quaternions!
    float a, c, flip, s, omega, sInv;

    a = 1.0f - b;
    c = VB_D3DXQuaternionDot(pQ1, pQ2);
    flip = (c >= 0.0f) ? 1.0f : -1.0f;
    c *= flip;

	if(1.0f - c > EPSILON) {
        s = sqrtf(1.0f - c * c);
 		omega = atan2f(s, c);
 		sInv = 1.0f / s;

 		a = sinf(a * omega) * sInv;
 		b = sinf(b * omega) * sInv;
 	}

    b *= flip;

    pOut->x = a * pQ1->x + b * pQ2->x;
    pOut->y = a * pQ1->y + b * pQ2->y;
    pOut->z = a * pQ1->z + b * pQ2->z;
    pOut->w = a * pQ1->w + b * pQ2->w;

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      const D3DXQUATERNION *pQ4, float t )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3 || !pQ4)
        return NULL;
#endif

    // expects unit quaternions!
    D3DXQUATERNION QA, QB;

    VB_D3DXQuaternionSlerp(&QA, pQ1, pQ4, t);
    VB_D3DXQuaternionSlerp(&QB, pQ2, pQ3, t);
    VB_D3DXQuaternionSlerp(pOut, &QA, &QB, 2.0f * t * (1.0f - t));

    return pOut;
}

D3DXQUATERNION* WINAPI VB_D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      float f, float g )
{
#if DBG
    if(!pOut || !pQ1 || !pQ2 || !pQ3)
        return NULL;
#endif

    // expects unit quaternions!
    D3DXQUATERNION QA, QB;
    float s = f + g;

    if(WithinEpsilon(s, 0.0f))
    {
        if(pOut != pQ1)
            *pOut = *pQ1;
    }
    else
    {
        VB_D3DXQuaternionSlerp(&QA, pQ1, pQ2, s);
        VB_D3DXQuaternionSlerp(&QB, pQ1, pQ3, s);
        VB_D3DXQuaternionSlerp(pOut, &QA, &QB, g / s);
    }

    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DXPLANE* WINAPI VB_D3DXPlaneNormalize
    ( D3DXPLANE *pOut, const D3DXPLANE *pP )
{
#if DBG
    if(!pOut || !pP)
        return NULL;
#endif

    float f = pP->a * pP->a + pP->b * pP->b + pP->c * pP->c;

    if(WithinEpsilon(f, 1.0f))
    {
        if(pOut != pP)
            *pOut = *pP;
    }
    else if(f > EPSILON * EPSILON)
    {
        float fInv = 1.0f / sqrtf(f);

        pOut->a = pP->a * fInv;
        pOut->b = pP->b * fInv;
        pOut->c = pP->c * fInv;
        pOut->d = pP->d * fInv;
    }
    else
    {
        pOut->a = 0.0f;
        pOut->b = 0.0f;
        pOut->c = 0.0f;
        pOut->d = 0.0f;
    }

    return pOut;
}

D3DXVECTOR3* WINAPI VB_D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, const D3DXPLANE *pP, const D3DXVECTOR3 *pV1, 
      const D3DXVECTOR3 *pV2)
{
#if DBG
    if(!pOut || !pP || !pV1 || !pV2)
        return NULL;
#endif

    float d =  VB_D3DXPlaneDotNormal(pP, pV1) - VB_D3DXPlaneDotNormal(pP, pV2);

    if(d == 0.0f)
        return NULL;

    float f = VB_D3DXPlaneDotCoord(pP, pV1) / d;

    if(!_finite(f))
        return NULL;

    VB_D3DXVec3Lerp(pOut, pV1, pV2, f);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pPoint, const D3DXVECTOR3 *pNormal)
{
#if DBG
    if(!pOut || !pPoint || !pNormal)
        return NULL;
#endif

    pOut->a = pNormal->x;
    pOut->b = pNormal->y;
    pOut->c = pNormal->z;
    pOut->d = -VB_D3DXVec3Dot(pPoint, pNormal);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2, 
      const D3DXVECTOR3 *pV3)
{
#if DBG
    if(!pOut || !pV1 || !pV2 || !pV3)
        return NULL;
#endif

    D3DXVECTOR3 V12 = *pV1 - *pV2;
    D3DXVECTOR3 V13 = *pV1 - *pV3;

    VB_D3DXVec3Cross((D3DXVECTOR3 *) pOut, &V12, &V13);
    VB_D3DXVec3Normalize((D3DXVECTOR3 *) pOut, (D3DXVECTOR3 *) pOut);

    pOut->d = -VB_D3DXPlaneDotNormal(pOut, pV1);
    return pOut;
}

D3DXPLANE* WINAPI VB_D3DXPlaneTransform
    ( D3DXPLANE *pOut, const D3DXPLANE *pP, const D3DXMATRIX *pM )
{
#if DBG
    if(!pOut || !pP || !pM)
        return NULL;
#endif

    D3DXPLANE P;
    VB_D3DXPlaneNormalize(&P, pP);

    D3DXVECTOR3 V(-P.a * P.d, -P.b * P.d, -P.c * P.d);
    VB_D3DXVec3TransformCoord(&V, &V, pM);

    VB_D3DXVec3TransformNormal((D3DXVECTOR3 *) pOut, (const D3DXVECTOR3 *) &P, pM);
    VB_D3DXVec3Normalize((D3DXVECTOR3 *) pOut, (const D3DXVECTOR3 *) pOut);

    pOut->d = -VB_D3DXPlaneDotNormal(pOut, &V);
    return pOut;
}


//--------------------------
// Color
//--------------------------

D3DXCOLOR* WINAPI VB_D3DXColorAdjustSaturation 
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    // Approximate values for each component's contribution to luminance.
    // (Based upon the NTSC standard described in the comp.graphics.algorithms
    // colorspace FAQ)
    float grey = pC->r * 0.2125f + pC->g * 0.7154f + pC->b * 0.0721f;

    pOut->r = grey + s * (pC->r - grey);
    pOut->g = grey + s * (pC->g - grey);
    pOut->b = grey + s * (pC->b - grey);
    pOut->a = pC->a;
    return pOut;
}

D3DXCOLOR* WINAPI VB_D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float c)
{
#if DBG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 0.5f + c * (pC->r - 0.5f);
    pOut->g = 0.5f + c * (pC->g - 0.5f);
    pOut->b = 0.5f + c * (pC->b - 0.5f);
    pOut->a = pC->a;
    return pOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3dxmathvb.inl ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.inl
//  Content:    D3DX math inline functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DXMATHVB_INL__
#define __D3DXMATHVB_INL__





//===========================================================================
//
// Inline functions
//
//===========================================================================


//--------------------------
// 2D Vector
//--------------------------

float  D3DVBCALL VB_D3DXVec2Length
    ( const D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y);
#endif 
}

 float  D3DVBCALL VB_D3DXVec2LengthSq
    ( const D3DXVECTOR2 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y;
}

 float D3DVBCALL   VB_D3DXVec2Dot
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y;
}

 float D3DVBCALL  D3DVBINLINE VB_D3DXVec2CCW
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->y - pV1->y * pV2->x;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Add
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    return pOut;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    return pOut;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    return pOut;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    return pOut;
}

D3DVBINLINE D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    return pOut;
}


//--------------------------
// 3D Vector
//--------------------------

D3DVBINLINE float D3DVBCALL VB_D3DXVec3Length
    ( const D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);
#endif
}

D3DVBINLINE float D3DVBCALL VB_D3DXVec3LengthSq
    ( const D3DXVECTOR3 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;
}

D3DVBINLINE float D3DVBCALL VB_D3DXVec3Dot
    ( const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
    D3DXVECTOR3 v;

#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    v.x = pV1->y * pV2->z - pV1->z * pV2->y;
    v.y = pV1->z * pV2->x - pV1->x * pV2->z;
    v.z = pV1->x * pV2->y - pV1->y * pV2->x;

    *pOut = v;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Add
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    return pOut;
}

D3DVBINLINE D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    return pOut;
}


//--------------------------
// 4D Vector
//--------------------------

D3DVBINLINE float D3DVBCALL VB_D3DXVec4Length
    ( const D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#else
    return (float) sqrt(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w);
#endif
}

D3DVBINLINE float D3DVBCALL VB_D3DXVec4LengthSq
    ( const D3DXVECTOR4 *pV )
{
#ifdef D3DX_DEBUG
    if(!pV)
        return 0.0f;
#endif

    return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z + pV->w * pV->w;
}

D3DVBINLINE float D3DVBCALL VB_D3DXVec4Dot
    ( const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2 )
{
#ifdef D3DX_DEBUG
    if(!pV1 || !pV2)
        return 0.0f;
#endif

    return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z + pV1->w * pV2->w;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Add
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + pV2->x;
    pOut->y = pV1->y + pV2->y;
    pOut->z = pV1->z + pV2->z;
    pOut->w = pV1->w + pV2->w;
    return pOut;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x - pV2->x;
    pOut->y = pV1->y - pV2->y;
    pOut->z = pV1->z - pV2->z;
    pOut->w = pV1->w - pV2->w;
    return pOut;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z < pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w < pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
    pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
    pOut->z = pV1->z > pV2->z ? pV1->z : pV2->z;
    pOut->w = pV1->w > pV2->w ? pV1->w : pV2->w;
    return pOut;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV)
        return NULL;
#endif

    pOut->x = pV->x * s;
    pOut->y = pV->y * s;
    pOut->z = pV->z * s;
    pOut->w = pV->w * s;
    return pOut;
}

D3DVBINLINE D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      float s )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pV1 || !pV2)
        return NULL;
#endif

    pOut->x = pV1->x + s * (pV2->x - pV1->x);
    pOut->y = pV1->y + s * (pV2->y - pV1->y);
    pOut->z = pV1->z + s * (pV2->z - pV1->z);
    pOut->w = pV1->w + s * (pV2->w - pV1->w);
    return pOut;
}


//--------------------------
// 4D Matrix
//--------------------------

D3DVBINLINE D3DXMATRIX* D3DVBCALL VB_D3DXMatrixIdentity
    ( D3DXMATRIX *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] = 
    pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] = 
    pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] = 
    pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;

    pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;
    return pOut;
}


D3DVBINLINE BOOL D3DVBCALL  VB_D3DXMatrixIsIdentity
    ( const D3DXMATRIX *pM )
{
#ifdef D3DX_DEBUG
    if(!pM)
        return FALSE;
#endif

    return pM->m[0][0] == 1.0f && pM->m[0][1] == 0.0f && pM->m[0][2] == 0.0f && pM->m[0][3] == 0.0f &&
           pM->m[1][0] == 0.0f && pM->m[1][1] == 1.0f && pM->m[1][2] == 0.0f && pM->m[1][3] == 0.0f &&
           pM->m[2][0] == 0.0f && pM->m[2][1] == 0.0f && pM->m[2][2] == 1.0f && pM->m[2][3] == 0.0f &&
           pM->m[3][0] == 0.0f && pM->m[3][1] == 0.0f && pM->m[3][2] == 0.0f && pM->m[3][3] == 1.0f;
}


//--------------------------
// Quaternion
//--------------------------

D3DVBINLINE float D3DVBCALL VB_D3DXQuaternionLength
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

#ifdef __cplusplus
    return sqrtf(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#else
    return (float) sqrt(pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w);
#endif
}

D3DVBINLINE float D3DVBCALL VB_D3DXQuaternionLengthSq
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return 0.0f;
#endif

    return pQ->x * pQ->x + pQ->y * pQ->y + pQ->z * pQ->z + pQ->w * pQ->w;
}

D3DVBINLINE float D3DVBCALL VB_D3DXQuaternionDot
    ( const D3DXQUATERNION *pQ1, const D3DXQUATERNION *pQ2 )
{
#ifdef D3DX_DEBUG
    if(!pQ1 || !pQ2)
        return 0.0f;
#endif

    return pQ1->x * pQ2->x + pQ1->y * pQ2->y + pQ1->z * pQ2->z + pQ1->w * pQ2->w;
}


D3DVBINLINE D3DXQUATERNION* D3DVBCALL VB_D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut )
{
#ifdef D3DX_DEBUG
    if(!pOut)
        return NULL;
#endif

    pOut->x = pOut->y = pOut->z = 0.0f;
    pOut->w = 1.0f;
    return pOut;
}

D3DVBINLINE BOOL D3DVBCALL VB_D3DXQuaternionIsIdentity
    ( const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pQ)
        return FALSE;
#endif

    return pQ->x == 0.0f && pQ->y == 0.0f && pQ->z == 0.0f && pQ->w == 1.0f;
}


D3DVBINLINE D3DXQUATERNION* D3DVBCALL VB_D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ )
{
#ifdef D3DX_DEBUG
    if(!pOut || !pQ)
        return NULL;
#endif

    pOut->x = -pQ->x;
    pOut->y = -pQ->y;
    pOut->z = -pQ->z;
    pOut->w =  pQ->w;
    return pOut;
}


//--------------------------
// Plane
//--------------------------

D3DVBINLINE float D3DVBCALL VB_D3DXPlaneDot
    ( const D3DXPLANE *pP, const D3DXVECTOR4 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d * pV->w;
}

D3DVBINLINE float D3DVBCALL VB_D3DXPlaneDotCoord
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;
}

D3DVBINLINE float D3DVBCALL VB_D3DXPlaneDotNormal
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV)
{
#ifdef D3DX_DEBUG
    if(!pP || !pV)
        return 0.0f;
#endif

    return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z;
}


//--------------------------
// Color
//--------------------------

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorNegative
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = 1.0f - pC->r;
    pOut->g = 1.0f - pC->g;
    pOut->b = 1.0f - pC->b;
    pOut->a = pC->a;
    return pOut;
}

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorAdd        
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + pC2->r;
    pOut->g = pC1->g + pC2->g;
    pOut->b = pC1->b + pC2->b;
    pOut->a = pC1->a + pC2->a;
    return pOut;
}

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorSubtract   
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r - pC2->r;
    pOut->g = pC1->g - pC2->g;
    pOut->b = pC1->b - pC2->b;
    pOut->a = pC1->a - pC2->a;
    return pOut;
}

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorScale      
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC)
        return NULL;
#endif

    pOut->r = pC->r * s;
    pOut->g = pC->g * s;
    pOut->b = pC->b * s;
    pOut->a = pC->a * s;
    return pOut;
} 

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorModulate   
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r * pC2->r;
    pOut->g = pC1->g * pC2->g;
    pOut->b = pC1->b * pC2->b;
    pOut->a = pC1->a * pC2->a;
    return pOut;
}

D3DVBINLINE D3DXCOLOR* D3DVBCALL VB_D3DXColorLerp       
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2, float s)
{
#ifdef D3DX_DEBUG
    if(!pOut || !pC1 || !pC2)
        return NULL;
#endif

    pOut->r = pC1->r + s * (pC2->r - pC1->r);
    pOut->g = pC1->g + s * (pC2->g - pC1->g);
    pOut->b = pC1->b + s * (pC2->b - pC1->b);
    pOut->a = pC1->a + s * (pC2->a - pC1->a);
    return pOut;
}


#endif // __D3DXMATHVB_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3dxtexvb.cpp ===
#include <windows.h>
#include <d3dx8tex.h>


DEFINE_GUID(g_GUIDDXVBLOCK, 0x5dd2e8da, 0x1c77, 0x4d40, 0xb0, 0xcf, 0x98, 0xfe, 0xfd, 0xff, 0x95, 0x12);


typedef struct _LOCKDATA {
	SAFEARRAY   *psaRealArray;
	BOOL	    bLocked;
	SAFEARRAY   *psaLockedArray;
} LOCKDATA;






HRESULT WINAPI DXLockArray8(IUnknown *resource, void *pBits,   SAFEARRAY **ppSafeArray)
{

		if (!resource) return E_INVALIDARG; 
		if (!ppSafeArray) return E_INVALIDARG;
		if (!*ppSafeArray) return E_INVALIDARG;

		
		
		LOCKDATA 		LockData;		//Structure we copy into resource
		HRESULT			hr;
		IDirect3DResource8 	*pResource=NULL;
		DWORD 			dwSize=sizeof(LOCKDATA);


		//See if we have a resource
		hr = resource->QueryInterface(IID_IDirect3DResource8,(void**)&pResource);
		if FAILED(hr) return E_INVALIDARG;	
		
		GUID g=g_GUIDDXVBLOCK;				//Guid to identify data in resource

		//See if there is any data in the resource
		ZeroMemory(&LockData,sizeof(LOCKDATA));		
		hr=pResource->GetPrivateData(g,&LockData,&dwSize);

		//if it was locked allready - we need to fail
		//and not lock it twice
		if (SUCCEEDED(hr) && (LockData.bLocked)){
			pResource->Release();
			return E_FAIL; 	//CONSIDER returning DDERR_LOCKEDSURFACES;
		}
		
		//SAVE the vb pointer to the safe array
		LockData.psaRealArray=*ppSafeArray;	//should be NULL

		//Set this flag to make sure we dont lock twice
		LockData.bLocked=TRUE;

		//Allocate our own new safe array
		LockData.psaLockedArray=(SAFEARRAY*)malloc(sizeof(SAFEARRAY));
		if (!LockData.psaLockedArray)
			return E_OUTOFMEMORY;

		ZeroMemory(LockData.psaLockedArray,sizeof(SAFEARRAY));


		memcpy(LockData.psaLockedArray,*ppSafeArray,sizeof(SAFEARRAY));
		LockData.psaLockedArray->pvData	= pBits;

		*ppSafeArray=LockData.psaLockedArray;
    
		hr=pResource->SetPrivateData(g,&LockData,dwSize,0);
		pResource->Release();


#if 0

		DWORD dwElemSize=0;
		D3DRESOURCETYPE resType=pResource->GetType();

		switch (resType)
		{
  		
		case D3DRESOURCETYPE_VERTEXBUFFER:


			LPDIRECT3DVERTEXBUFFER8 *pVertBuff=NULL;		


			//User must have created a 1d array
			if ((*ppSafeArray)->cbElements != 1) {
				pResource->Release();
				return E_INVALIDARG;
			}

			hr=pResource->QueryInterface(IID_IDirect3DVertexBuffer8,(void**)&pVertBuff);
			if FAILED(hr) {
				pResource->Release();
				return E_INVALIDARG;
			}

			D3DVERTEXBUFFER_DESC vbdesc =pVertBuff->GetVertexBufferDesc()
			dwElemSize=(*ppSafeArray)->cbElements;


			//Make sure our size is evenly divisible by the vertex format
			if ((vbdesc.Size %  dwElemSize) !=0) {
				pResource->Release();
				pVertBuff->Release();
				return E_INVALIDARG;
			}
			
			//Take Element size from our safearray
			LockData.psaLockedArray->cbElements =dwElemSize;
			LockData.psaLockedArray->cDims =1;
			LockData.psaLockedArray->rgsabound[0].lLbound =0;
			LockData.psaLockedArray->rgsabound[0].cElements = vdesc.Size / dwElemSize;
			LockData.psaLockedArray->pvData = pBits;

			pVertexBuffer->Release();
			break;

		case D3DRESOURCETYPE_INDEXBUFFER:


			LPDIRECT3DINDEXBUFFER8 *pIndBuff=NULL;		

			hr=pResource->QueryInterface(IID_IDirect3DIndexBuffer8,(void**)&pIndBuff);
			if FAILED(hr) {
				pResource->Release();
				return E_INVALIDARG;
			}


			D3DINDEXBUFFER_DESC ibdesc =pVertBuff->GetIndexBufferDesc()
			dwElemSize=(*ppSafeArray)->cbElements;

			//Make sure the created the right kind of array
			if ((ibdesc.Format==D3DFMT_INDEX_16)&&(dwElemSize!=2)){
				pResource->Release();
				pIndBuffer->Release();
				return E_INVALIDARG;
			}
			
			if ((ibdesc.Format==D3DFMT_INDEX_32)&&(dwElemSize!=4)){
				pResource->Release();
				pIndBuffer->Release();
				return E_INVALIDARG;
			}

			//User must have created a 1d array
			if ((*ppSafeArray)->cbElements != 1) {
				pResource->Release();
				pIndBuffer->Release();
				return E_INVALIDARG;
			}

			//Make sure our size is evenly divisible 
			if ((vbdesc.Size %  dwElemSize) !=0) {
				pResource->Release();
				pIndBuff->Release();
				return E_INVALIDARG;
			}
			
			//Take Element size from our safearray
			LockData.psaLockedArray->cbElements =dwElemSize;
			LockData.psaLockedArray->cDims =1;
			LockData.psaLockedArray->rgsabound[0].lLbound =0;
			LockData.psaLockedArray->rgsabound[0].cElements = vdesc.Size / dwElemSize;
			LockData.psaLockedArray->pvData = pBits;

			pIndBuffer->Release();
			break;
			


		}
#endif


		return hr;
}

HRESULT WINAPI DXUnlockArray8(IUnknown *resource,   SAFEARRAY **ppSafeArray)
{
		

		LOCKDATA 		LockData;		
		DWORD 			dwSize=sizeof(LOCKDATA);
		HRESULT			hr;
		LPDIRECT3DRESOURCE8 	pResource=NULL;

		if (!resource) return E_INVALIDARG; 
		if (!ppSafeArray) return E_INVALIDARG;
		if (!*ppSafeArray) return E_INVALIDARG;

		//See if we have a resource
		hr = resource->QueryInterface(IID_IDirect3DResource8,(void**)&pResource);
		if FAILED(hr) return E_INVALIDARG;	

		
		GUID g=g_GUIDDXVBLOCK;
		ZeroMemory(&LockData,sizeof(LOCKDATA));		
		hr=pResource->GetPrivateData(g,&LockData,&dwSize);
		if FAILED(hr) {
			pResource->Release();
			return E_FAIL;
		}

		if (!LockData.bLocked) {
			pResource->Release();
			return E_FAIL; //CONSIDER DDERR_LOCKEDSURFACES;
		}
				

		(*ppSafeArray)=LockData.psaRealArray;

		if (LockData.psaLockedArray) free(LockData.psaLockedArray);
		ZeroMemory(&LockData,sizeof(LOCKDATA));	
		hr=pResource->SetPrivateData(g,&LockData,dwSize,0);
		pResource->Release();

		return hr;
}


HRESULT WINAPI D3DVertexBuffer8SetData(IDirect3DVertexBuffer8 *pVBuffer,int offset, int size, DWORD flags, void *data)
{
		
 
		if (!pVBuffer) return E_INVALIDARG;

		HRESULT		hr;
		BYTE 		*pbData=NULL;

		hr=pVBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy ((void*)pbData,data,(DWORD)size);			
		}
		_except(1,1)
		{
			return E_INVALIDARG;
		}

		hr=pVBuffer->Unlock();

		return hr;
}


HRESULT WINAPI D3DVertexBuffer8GetData(IDirect3DVertexBuffer8 *pVBuffer,int offset,  int size, DWORD flags,void *data)
{
		
 
		if (!pVBuffer) return E_INVALIDARG;

		HRESULT		hr;
		BYTE 		*pbData=NULL;
		
		hr=pVBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy (data,(void*)pbData,(DWORD)size);			
		}
		_except(1,1)
		{
			return E_INVALIDARG;
		}

		hr=pVBuffer->Unlock();

		return hr;
}
	
		
		
HRESULT WINAPI D3DIndexBuffer8SetData(IDirect3DIndexBuffer8 *pIBuffer,int offset, int size,DWORD flags, void *data)
{
		
 
		if (!pIBuffer) return E_INVALIDARG;

		HRESULT		hr;
		BYTE 		*pbData=NULL;
		
		hr=pIBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy ((void*)pbData,data,(DWORD)size);			
		}
		_except(1,1)
		{
			return E_INVALIDARG;
		}

		hr=pIBuffer->Unlock();

		return hr;
}


HRESULT WINAPI D3DIndexBuffer8GetData(IDirect3DIndexBuffer8 *pIBuffer,int offset, int size,DWORD flags, void *data)
{
		
 
		if (!pIBuffer) return E_INVALIDARG;

		HRESULT		hr;
		BYTE 		*pbData=NULL;

		
		hr=pIBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy (data,(void*)pbData,(DWORD)size);		
		}
		_except(1,1)
		{
			return E_INVALIDARG;
		}

		hr=pIBuffer->Unlock();

		return hr;
}
	
//////////////////////////////////////////////////////////

HRESULT WINAPI D3DXMeshVertexBuffer8SetData(IUnknown *pObj,int offset, int size, DWORD flags, void *data)
{

		HRESULT			hr;
		BYTE 			*pbData=NULL;
		LPD3DXBASEMESH		pMesh=NULL;		
 		LPDIRECT3DVERTEXBUFFER8 pVBuffer=NULL;

		if (!pObj) return E_INVALIDARG;
		
		hr=pObj->QueryInterface(IID_ID3DXBaseMesh,(void**)&pMesh);
		if FAILED(hr) return E_INVALIDARG;

		hr=pMesh->GetVertexBuffer(&pVBuffer);
		pMesh->Release();
		if FAILED(hr) 	   return hr;			

		

	

		hr=pVBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy ((void*)pbData,data,(DWORD)size);		
		}
		_except(1,1)
		{
			pVBuffer->Release();
			return E_INVALIDARG;
		}

		hr=pVBuffer->Unlock();
		pVBuffer->Release();
		return hr;
}


HRESULT WINAPI D3DXMeshVertexBuffer8GetData(IUnknown *pObj,int offset,  int size, DWORD flags,void *data)
{
		HRESULT			hr;
		BYTE 			*pbData=NULL;
		LPD3DXBASEMESH		pMesh=NULL;		
 		LPDIRECT3DVERTEXBUFFER8 pVBuffer=NULL;

		if (!pObj) return E_INVALIDARG;
		
		hr=pObj->QueryInterface(IID_ID3DXBaseMesh,(void**)&pMesh);
		if FAILED(hr) return E_INVALIDARG;

		hr=pMesh->GetVertexBuffer(&pVBuffer);
		pMesh->Release();
		if FAILED(hr) 	   return hr;			

		
		
		hr=pVBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy (data,(void*)pbData,(DWORD)size);		
		}
		_except(1,1)
		{
			pVBuffer->Release();
			return E_INVALIDARG;
		}

		hr=pVBuffer->Unlock();

		pVBuffer->Release();
		return hr;
}
	

HRESULT WINAPI D3DXMeshIndexBuffer8SetData(IUnknown *pObj,int offset, int size, DWORD flags, void *data)
{

		HRESULT			hr;
		BYTE 			*pbData=NULL;
		LPD3DXBASEMESH		pMesh=NULL;		
 		LPDIRECT3DINDEXBUFFER8 	pIBuffer=NULL;

		if (!pObj) return E_INVALIDARG;
		
		hr=pObj->QueryInterface(IID_ID3DXBaseMesh,(void**)&pMesh);
		if FAILED(hr) return E_INVALIDARG;

		hr=pMesh->GetIndexBuffer(&pIBuffer);
		pMesh->Release();
		if FAILED(hr) 	   return hr;			


		
 		
		hr=pIBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy ((void*)pbData,data,(DWORD)size);	
		}
		_except(1,1)
		{
			pIBuffer->Release();
			return E_INVALIDARG;
		}

		hr=pIBuffer->Unlock();
		pIBuffer->Release();

		return hr;
}


HRESULT WINAPI D3DXMeshIndexBuffer8GetData(IUnknown *pObj,int offset, int size, DWORD flags, void *data)
{

		HRESULT			hr;
		BYTE 			*pbData=NULL;
		LPD3DXBASEMESH		pMesh=NULL;		
 		LPDIRECT3DINDEXBUFFER8 	pIBuffer=NULL;

		if (!pObj) return E_INVALIDARG;
		
		hr=pObj->QueryInterface(IID_ID3DXBaseMesh,(void**)&pMesh);
		if FAILED(hr) return E_INVALIDARG;

		hr=pMesh->GetIndexBuffer(&pIBuffer);
		pMesh->Release();
		if FAILED(hr) 	   return hr;			


		
		hr=pIBuffer->Lock((UINT)offset,(UINT)size, &pbData,flags);
		if FAILED(hr) return hr;
		
		_try {
			memcpy (data,(void*)pbData,(DWORD)size);
			//memcpy (data,(void*)&(pbData[offset]),(DWORD)size);
		}
		_except(1,1)
		{
			pIBuffer->Release();
			return E_INVALIDARG;
		}

		hr=pIBuffer->Unlock();
		pIBuffer->Release();

		return hr;
}


HRESULT WINAPI DXCopyMemory (void *Dest, void *Src, DWORD size)
{
	_try {
		memcpy (Dest,Src,size);
	}
	_except(1,1)
	{
		return E_INVALIDARG;
	}
	return S_OK;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\didevinstobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevinstobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "diDevInstObj.h"
#include "dinputDeviceObj.h"


extern BSTR GUIDtoBSTR(LPGUID g);

extern BSTR DINPUTGUIDtoBSTR(LPGUID g);
       
	

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getGuidInstance( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&m_inst.guidInstance);
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getGuidProduct( BSTR __RPC_FAR *ret){
	*ret=GUIDtoBSTR( &(m_inst.guidProduct));
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getGuidFFDriver( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&(m_inst.guidFFDriver));
	return S_OK;
}
        
        
//USES_CONVERSION;

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getProductName( BSTR __RPC_FAR *ret){
	*ret=SysAllocString(m_inst.tszProductName);	//T2BSTR(m_inst.tszProductName);		
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getInstanceName( BSTR __RPC_FAR *ret){
	*ret=SysAllocString(m_inst.tszInstanceName);	//(m_inst.tszInstanceName);			
	return S_OK;
}

        

        
STDMETHODIMP C_dxj_DIDeviceInstance8Object::getUsagePage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsagePage;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getUsage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsage;
	return S_OK;
}
        

STDMETHODIMP C_dxj_DIDeviceInstance8Object::getDevType( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwDevType;
	return S_OK;
}        
        
C_dxj_DIDeviceInstance8Object::C_dxj_DIDeviceInstance8Object()
{	
	ZeroMemory(&m_inst,sizeof(DIDEVICEINSTANCEW));
}

void C_dxj_DIDeviceInstance8Object::init(DIDEVICEINSTANCEW *inst)
{
	memcpy(&m_inst,inst,sizeof(DIDEVICEINSTANCEW));
}



HRESULT C_dxj_DIDeviceInstance8Object::create(DIDEVICEINSTANCEW *inst,I_dxj_DirectInputDeviceInstance8 **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;

	C_dxj_DIDeviceInstance8Object *c=NULL;
	c=new CComObject<C_dxj_DIDeviceInstance8Object>;
	c->init(inst);

	if( c == NULL ) return E_FAIL;
	hr=c->QueryInterface(IID_I_dxj_DirectInputDeviceInstance8, (void**)ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\didevinstobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevinstobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"
	  
class C_dxj_DIDeviceInstance8Object :
		public I_dxj_DirectInputDeviceInstance8,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DIDeviceInstance8Object)
		COM_INTERFACE_ENTRY(I_dxj_DirectInputDeviceInstance8)
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DIDeviceInstance8Object)

public:
	C_dxj_DIDeviceInstance8Object();	
  

        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidInstance( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidProduct( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
		/* [propget] */ HRESULT STDMETHODCALLTYPE getProductName( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getInstanceName( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getGuidFFDriver( 
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUsagePage( 
            /* [retval][out] */ short __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getUsage( 
            /* [retval][out] */ short __RPC_FAR *ret);
        
        /* [propget] */ HRESULT STDMETHODCALLTYPE getDevType( 
            /* [retval][out] */ long __RPC_FAR *ret);


		void init(DIDEVICEINSTANCEW *inst);
		static HRESULT C_dxj_DIDeviceInstance8Object::create(DIDEVICEINSTANCEW  *inst,I_dxj_DirectInputDeviceInstance8 **ret);


private:
		DIDEVICEINSTANCEW m_inst;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\ddraw7obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ddraw7obj.cpp
//
//--------------------------------------------------------------------------

// dDrawObj.cpp : Implementation of CDirectApp and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dDraw7Obj.h"
#include "ddClipperObj.h"
#include "ddSurface7Obj.h"
#include "ddPaletteObj.h"
#include "ddEnumModesObj.h"
#include "ddEnumSurfacesObj.h"
#include "d3d7Obj.h"
#include "ddIdentifierObj.h"
					   

extern BOOL is4Bit;
extern HRESULT CopyInDDSurfaceDesc2(DDSURFACEDESC2 *,DDSurfaceDesc2*);
extern HRESULT CopyOutDDSurfaceDesc2(DDSurfaceDesc2*,DDSURFACEDESC2 *);


///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw7Object::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DDraw7 [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectDraw7Object::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DDraw4 [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectDraw7Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw7Object::C_dxj_DirectDraw7Object(){ 
		
	DPF1(1,"Constructor Creation  DirectDraw7Object[%d] \n ",g_creationcount);

	m__dxj_DirectDraw7= NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectDraw7;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectDraw7 = (void *)this; 
	m_hwnd=NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectDraw7Object
///////////////////////////////////////////////////////////////////
C_dxj_DirectDraw7Object::~C_dxj_DirectDraw7Object()
{

	DPF(1,"Entering ~DirectDraw7Object destructor \n");

     C_dxj_DirectDraw7Object *prev=NULL; 
	for(C_dxj_DirectDraw7Object *ptr=(C_dxj_DirectDraw7Object *)g_dxj_DirectDraw7; ptr; ptr=(C_dxj_DirectDraw7Object *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectDraw7 = (void*)ptr->nextobj; 
			
			DPF(1,"DirectDraw7Object found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectDraw7){
		int count = IUNK(m__dxj_DirectDraw7)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectDraw7 Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectDraw7 = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}



///////////////////////////////////////////////////////////////////
// InternalGetObject
// InternalSetObject
// restoreDisplayMode
// flipToGDISurface
// setDisplayMode
///////////////////////////////////////////////////////////////////
GETSET_OBJECT(_dxj_DirectDraw7);
PASS_THROUGH_R(_dxj_DirectDraw7, restoreDisplayMode, RestoreDisplayMode)
PASS_THROUGH_R(_dxj_DirectDraw7, flipToGDISurface, FlipToGDISurface)
PASS_THROUGH5_R(_dxj_DirectDraw7, setDisplayMode, SetDisplayMode, long,long,long,long,long)


///////////////////////////////////////////////////////////////////
// getMonitorFrequency
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getMonitorFrequency(long *ret)
{
	HRESULT hr;
	hr=m__dxj_DirectDraw7->GetMonitorFrequency((DWORD*)ret);
	return hr;
}
														  


///////////////////////////////////////////////////////////////////
// getGDISurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getGDISurface(I_dxj_DirectDrawSurface7 **rv)
{ 
	
	LPDIRECTDRAWSURFACE7 lp4=NULL;	

	if ( is4Bit )
		return E_FAIL;

	*rv = NULL;
	HRESULT hr = DD_OK;

	if( ( hr=m__dxj_DirectDraw7->GetGDISurface(&lp4) ) != DD_OK) 
		return hr;
	 		
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, lp4, rv);

	return hr; 
}

///////////////////////////////////////////////////////////////////
// getVerticalBlankStatus
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getVerticalBlankStatus( long *status)
{
	if ( is4Bit )
		return E_FAIL;

	return m__dxj_DirectDraw7->GetVerticalBlankStatus((int *)status);
}

///////////////////////////////////////////////////////////////////
// setCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::setCooperativeLevel( HWnd hwn, long flags)
{
	if ( is4Bit )
		return E_FAIL;

	m_hwnd = (HWND)hwn;

	return m__dxj_DirectDraw7->SetCooperativeLevel((HWND)hwn, (DWORD)flags);
}

///////////////////////////////////////////////////////////////////
// waitForVerticalBlank
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::waitForVerticalBlank(long flags,long handle, long *status)
{
	if ( is4Bit )
		return E_FAIL;

	*status = m__dxj_DirectDraw7->WaitForVerticalBlank(flags, (void *)handle);
	return S_OK;
}



///////////////////////////////////////////////////////////////////
// createClipper
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createClipper(long flags, I_dxj_DirectDrawClipper **val)
{
	if ( is4Bit )
		return E_FAIL;

	DPF1(1,"enter DDraw4[%d]::createClipper ",creationid);

	//
	// need to create one of MY surfaces!
	//
	LPDIRECTDRAWCLIPPER		ddc;
	HRESULT hr = DD_OK;
	if( (hr=m__dxj_DirectDraw7->CreateClipper( flags, &ddc, NULL)) != DD_OK )
		return hr;

	INTERNAL_CREATE(_dxj_DirectDrawClipper, ddc, val);

	DPF1(1,"exit DDraw4[%d]::createClipper ",creationid);

	return hr;
}

///////////////////////////////////////////////////////////////////
// createPalette
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createPalette(long flags, SAFEARRAY **pe, I_dxj_DirectDrawPalette **val)
{
	LPPALETTEENTRY ppe;
	
	if ( is4Bit )
		return E_FAIL;


	if (!ISSAFEARRAY1D(pe,(DWORD)256)) return E_INVALIDARG;

	ppe = (LPPALETTEENTRY)((SAFEARRAY*)*pe)->pvData;

	LPDIRECTDRAWPALETTE		ddp;
	HRESULT hr = DD_OK;
	
	*val = NULL;

	if( (hr=m__dxj_DirectDraw7->CreatePalette( flags, (LPPALETTEENTRY)ppe, &ddp, NULL)) == DD_OK )
	{
		INTERNAL_CREATE( _dxj_DirectDrawPalette, ddp, val);
	}

	return hr;
}

///////////////////////////////////////////////////////////////////
// createSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createSurface(DDSurfaceDesc2 *dd, I_dxj_DirectDrawSurface7 **retval)
{
	HRESULT retv;
	LPDIRECTDRAWSURFACE7	  dds7; // DirectX object pointer
	DDSURFACEDESC2			  ddsd;
	DPF1(1,"enter DDraw7[%d]::createSurface ",creationid);
	
	

	if ( is4Bit )
		return E_FAIL;

	if(! (dd && retval) )
		return E_POINTER;
		
	CopyInDDSurfaceDesc2(&ddsd,dd);

	//docdoc: CreateSurface returns error if 'punk' is anything but NULL
	retv = m__dxj_DirectDraw7->CreateSurface( &ddsd, &dds7, NULL);
	if FAILED(retv)	return retv;
	
	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, retval);

	dd->lpSurface = NULL;

	
	DPF1(1,"exit DDraw7[%d]::createSurface ",creationid);
	
	


	return S_OK;
}

///////////////////////////////////////////////////////////////////
// duplicateSurface
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::duplicateSurface(I_dxj_DirectDrawSurface7 *ddIn, I_dxj_DirectDrawSurface7 **ddOut)
{
	HRESULT retval;

	if ( is4Bit )
		return E_FAIL;

	//
	// need to create one of MY surfaces!
	//	
	LPDIRECTDRAWSURFACE7 lpddout7=NULL;


	DO_GETOBJECT_NOTNULL( LPDIRECTDRAWSURFACE7, lpddin, ddIn);

	if( (retval = m__dxj_DirectDraw7->DuplicateSurface(lpddin, &lpddout7)) != DD_OK )
		return retval;

	INTERNAL_CREATE( _dxj_DirectDrawSurface7, lpddout7, ddOut);

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getCaps
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getCaps(DDCaps *driverCaps,  DDCaps *HELcaps)
{
	if ( is4Bit )
		return E_FAIL;
	if (!driverCaps) return E_INVALIDARG;
	if (!HELcaps) return E_INVALIDARG;

	((DDCAPS*)driverCaps)->dwSize=sizeof(DDCAPS);
	((DDCAPS*)HELcaps)->dwSize=sizeof(DDCAPS);

	HRESULT hr = m__dxj_DirectDraw7->GetCaps((DDCAPS*)driverCaps, (DDCAPS*)HELcaps);

	return hr;
}

///////////////////////////////////////////////////////////////////
// getDisplayMode
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDisplayMode(DDSurfaceDesc2 *desc)
{
	HRESULT retval;
	DDSURFACEDESC2 ddsd;

	if (!desc) return E_INVALIDARG;

	CopyInDDSurfaceDesc2(&ddsd,desc);

	retval = m__dxj_DirectDraw7->GetDisplayMode(&ddsd);

	if( retval != S_OK)		
		return retval;

	CopyOutDDSurfaceDesc2(desc,&ddsd);

	desc->lpSurface = NULL;

	return S_OK;
}

///////////////////////////////////////////////////////////////////
// getAvailableTotalMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getAvailableTotalMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw7->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, (unsigned long *)m, NULL);
}

///////////////////////////////////////////////////////////////////
// getFreeMem
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getFreeMem(DDSCaps2 *ddsCaps, long *m)
{
	return m__dxj_DirectDraw7->GetAvailableVidMem((LPDDSCAPS2)ddsCaps, NULL, (unsigned long *)m);
}


///////////////////////////////////////////////////////////////////
// getDirect3D
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDirect3D(I_dxj_Direct3d7 **retval)
{
    LPDIRECT3D7 lpD3D;
	HRESULT hr = DD_OK;

	if ( is4Bit )
		return E_FAIL;

    if( (hr=m__dxj_DirectDraw7->QueryInterface(IID_IDirect3D7, (void**) &lpD3D)) != DD_OK)
		return hr;

  	INTERNAL_CREATE(_dxj_Direct3d7, lpD3D, retval);

	return hr;
}

///////////////////////////////////////////////////////////////////
// getNumFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getNumFourCCCodes(long *retval)
{
    return m__dxj_DirectDraw7->GetFourCCCodes((DWORD*)retval, NULL);
}


///////////////////////////////////////////////////////////////////
// getScanLine
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getScanLine(long *lines, long *status)
{ 
	*status = (long)m__dxj_DirectDraw7->GetScanLine((DWORD*)lines);
	return S_OK;
}

///////////////////////////////////////////////////////////////////
// loadPaletteFromBitmap
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::loadPaletteFromBitmap(BSTR bName, I_dxj_DirectDrawPalette **retval)
{
	USES_CONVERSION;
    IDirectDrawPalette* ddpal;
    int                 i;
    int                 n;
    int                 fh;
    HRSRC               h;
    LPBITMAPINFOHEADER  lpbi;
    PALETTEENTRY        ape[256];
    RGBQUAD *           prgb;
	

	HRESULT hr=S_OK;

	if ( is4Bit )
		return E_FAIL;

	LPCTSTR szBitmap = W2T(bName);
	


    for (i=0; i<256; i++)		// build a 332 palette as the default
    {
        ape[i].peRed   = (BYTE)(((i >> 5) & 0x07) * 255 / 7);
        ape[i].peGreen = (BYTE)(((i >> 2) & 0x07) * 255 / 7);
        ape[i].peBlue  = (BYTE)(((i >> 0) & 0x03) * 255 / 3);
        ape[i].peFlags = (BYTE)0;
    }

    //
    // get a pointer to the bitmap resource.
    //
    if (szBitmap && (h = FindResource(NULL, szBitmap, RT_BITMAP)))
    {
        lpbi = (LPBITMAPINFOHEADER)LockResource(LoadResource(NULL, h));
        if (!lpbi){
		DPF(1,"lock resource failed\n");
	}
        prgb = (RGBQUAD*)((BYTE*)lpbi + lpbi->biSize);

        if (lpbi == NULL || lpbi->biSize < sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (lpbi->biBitCount > 8)
            n = 0;
        else if (lpbi->biClrUsed == 0)
            n = 1 << lpbi->biBitCount;
        else
            n = lpbi->biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            ape[i].peRed   = prgb[i].rgbRed;
            ape[i].peGreen = prgb[i].rgbGreen;
            ape[i].peBlue  = prgb[i].rgbBlue;
            ape[i].peFlags = 0;
        }
    }
    else if (szBitmap && (fh = _lopen(szBitmap, OF_READ)) != -1)
    {
        BITMAPFILEHEADER bf;
        BITMAPINFOHEADER bi;

        _lread(fh, &bf, sizeof(bf));
        _lread(fh, &bi, sizeof(bi));
        _lread(fh, ape, sizeof(ape));
        _lclose(fh);

        if (bi.biSize != sizeof(BITMAPINFOHEADER))
            n = 0;
        else if (bi.biBitCount > 8)
            n = 0;
        else if (bi.biClrUsed == 0)
            n = 1 << bi.biBitCount;
        else
            n = bi.biClrUsed;

        //
        //  a DIB color table has its colors stored BGR not RGB
        //  so flip them around.
        //
        for(i=0; i<n; i++ )
        {
            BYTE r = ape[i].peRed;
            ape[i].peRed  = ape[i].peBlue;
            ape[i].peBlue = r;
        }
    }

    m__dxj_DirectDraw7->CreatePalette(DDPCAPS_8BIT, ape, &ddpal, NULL);

	if( ddpal )
	{
		INTERNAL_CREATE(_dxj_DirectDrawPalette, ddpal, retval);
	}
	else
	{
		//
		// no object, set the return value to NULL as well.
		//
		*retval = NULL;
		hr = E_FAIL;
	}

    return hr;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromFile
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::createSurfaceFromFile(BSTR file, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface7 **surf)
{

	DPF1(1,"enter DDraw7[%d]::createSurfaceFromFile ",creationid);


	HDC							hdc;
	HDC							hdcImage;
    BITMAP						bm;
    HRESULT						hr;
	HBITMAP						hbm;
	HRESULT						retv;
	LPDIRECTDRAWSURFACE7		dds7; // DirectX object pointer	
	LPSTR						szFileName=NULL;
    int							width=0;
    int							height=0;


	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;
	
	
	USES_CONVERSION;
	szFileName=W2T(file);

	
	


	//If width and height are zero then we will generate our own width and
	//height from the bitmap.
	//The LoadImage api however doesnt work propery without size params
	//Consider there must be a way to make it work.
	if ((desc->lWidth!=0)&&(desc->lHeight!=0)&&(desc->lFlags & DDSD_WIDTH)&&(desc->lFlags & DDSD_HEIGHT))
	{
		width=desc->lWidth ;
		height=desc->lHeight; 
	}

	if (desc->lFlags==0) {
		desc->lFlags=DDSD_CAPS;
		((DDSURFACEDESC*)desc)->ddsCaps.dwCaps=DDSCAPS_OFFSCREENPLAIN;
	}
	
    //hbm = (HBITMAP)LoadImageW((HINSTANCE)NULL, file, IMAGE_BITMAP, 
	//				width, height, 
	//				LR_LOADFROMFILE|LR_CREATEDIBSECTION);

	hbm = (HBITMAP)LoadImage((HINSTANCE)NULL, szFileName, IMAGE_BITMAP, 
				width, height, 
					LR_LOADFROMFILE|LR_CREATEDIBSECTION);

	DWORD dwErr=GetLastError();		
	if (!hbm){
		
		//often users pass in width and height in twips and not pixels
		//loadimage compails and returns  ERROR_NOT_ENOUGH_MEMORY		
		

		if (dwErr==ERROR_NOT_ENOUGH_MEMORY)
		{
			return E_OUTOFMEMORY;
		}
		else if (dwErr==ERROR_INVALID_PARAMETER)
		{
			return E_INVALIDARG;
		}
		else {
			return CTL_E_FILENOTFOUND;
		}
	}

	// get size of the bitmap
    //	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	width=bm.bmWidth;
	height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw7->CreateSurface(&ddsd, &dds7, NULL)) != DD_OK )
		return retv;

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
     dds7->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

	SelectObject(hdcImage, hbm);		

    if (!hdcImage){
		DeleteObject(hbm);
		return E_FAIL;
	}
	

    if ((hr = dds7->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds7->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(buffer,"exit DDraw7[%d]::createSurfaceFromFile",creationid);	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// createSurfaceFromResource
///////////////////////////////////////////////////////////////////

STDMETHODIMP C_dxj_DirectDraw7Object::createSurfaceFromResource(BSTR resFile, BSTR resourceName, DDSurfaceDesc2 *desc, I_dxj_DirectDrawSurface7 **surf)
{

	DPF1(1,"enter DDraw4[%d]::createSurfaceFromResource ",creationid);

	if ( is4Bit )
		return E_FAIL;

	if(! (desc && surf) )
		return E_POINTER;


	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;

	HDC							hdc;
	HDC							hdcImage;
    BITMAP						bm;
	HBITMAP						hbm;
	HRESULT						retv;		
	LPDIRECTDRAWSURFACE7		dds7; // DirectX object pointer	
	LPSTR						szResName=NULL;

	if (!resourceName)	return E_INVALIDARG;
	if (!surf)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((resFile) &&(resFile[0]!=0)){
		// NOTE:
		// seems that GetModuleHandleW is
		// always returning 0 on w98
		// converting to ansi first
		 LPCTSTR pszName = W2T(resFile);
		 hMod= GetModuleHandle(pszName);
	}
	else {
		hMod= GetModuleHandle(NULL);
	}


	
	LPCTSTR pszName2 = W2T(resourceName);

    //hbm = (HBITMAP)LoadImageW((HINSTANCE)hMod, resourceName, 
	//				IMAGE_BITMAP, 
	//				0, 0, 
	//				LR_CREATEDIBSECTION);
	

    hbm = (HBITMAP)LoadImage((HINSTANCE)hMod, 
					pszName2, 
					IMAGE_BITMAP, 
					0, 0, 
					LR_CREATEDIBSECTION);


	if (!hbm){
		//MessageBox(NULL,"FAILED ON LOAD IMAGE","TEST",MB_OK);
		return E_FAIL;
	}


	// get size of the bitmap
    //	
	GetObject(hbm, sizeof(bm), &bm);      // get size of bitmap
	DWORD width=bm.bmWidth;
	DWORD height=bm.bmHeight; 
	desc->lFlags = desc->lFlags | DDSD_WIDTH | DDSD_HEIGHT;

	if ((desc->lWidth==0)||(desc->lHeight==0))
	{
		desc->lWidth  =width;
		desc->lHeight =height; 
	}

	DDSURFACEDESC2 ddsd;
	CopyInDDSurfaceDesc2(&ddsd,desc);
	
	if( (retv = m__dxj_DirectDraw7->CreateSurface(&ddsd, &dds7, NULL)) != DD_OK )
		return retv;

	CopyOutDDSurfaceDesc2(desc,&ddsd);


	INTERNAL_CREATE(_dxj_DirectDrawSurface7, dds7, surf);


	desc->lpSurface = NULL;

    //
    // make sure this surface is restored.
    //
    dds7->Restore();

    //
    //  select bitmap into a memoryDC so we can use it.
    //
    hdcImage = CreateCompatibleDC(NULL);

	SelectObject(hdcImage, hbm);		

    if (!hdcImage){
		DeleteObject(hbm);
		return E_FAIL;
	}
	

    if ((hr = dds7->GetDC(&hdc)) == DD_OK)
    {
        StretchBlt(hdc, 0, 0, desc->lWidth , desc->lHeight, hdcImage,
						 0, 0, width, height, SRCCOPY);
        
        dds7->ReleaseDC(hdc);
    }

    DeleteDC(hdcImage);

	if (hbm) DeleteObject(hbm);

	
	DPF1(1r,"exit DDraw4[%d]::createSurfaceFromFile",creationid);
	

	return S_OK;
}


///////////////////////////////////////////////////////////////////
// getFourCCCodes
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getFourCCCodes(SAFEARRAY **ppsa)
{
	DWORD count= ((SAFEARRAY*)*ppsa)->rgsabound[0].cElements;
	if ( ((SAFEARRAY*)*ppsa)->cDims!=1) return E_INVALIDARG;

    return m__dxj_DirectDraw7->GetFourCCCodes(&count,(DWORD*)((SAFEARRAY*)*ppsa)->pvData);

}

///////////////////////////////////////////////////////////////////
// getDisplayModesEnum
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::getDisplayModesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 *ddsd,
            /* [retval][out] */ I_dxj_DirectDrawEnumModes __RPC_FAR *__RPC_FAR *retval)
{
	HRESULT hr;	
	hr=C_dxj_DirectDrawEnumModesObject::create(m__dxj_DirectDraw7,flags, ddsd,  retval);
	return hr;	
}

///////////////////////////////////////////////////////////////////
// testCooperativeLevel
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::testCooperativeLevel( 
            /* [in,out] */ long *status)
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw7->TestCooperativeLevel();
	*status=(long)hr;
	return S_OK;	
}

///////////////////////////////////////////////////////////////////
// restoreAllSurfaces
///////////////////////////////////////////////////////////////////
STDMETHODIMP C_dxj_DirectDraw7Object::restoreAllSurfaces()
{
	HRESULT hr;	
	hr=m__dxj_DirectDraw7->RestoreAllSurfaces();
	return hr;	
}

STDMETHODIMP C_dxj_DirectDraw7Object::getSurfaceFromDC(long hdc, I_dxj_DirectDrawSurface7 **ret)
{
	HRESULT hr;	
	LPDIRECTDRAWSURFACE7 pDDS=NULL;
	hr=m__dxj_DirectDraw7->GetSurfaceFromDC((HDC)hdc,&pDDS);
	if FAILED(hr) return hr;
	INTERNAL_CREATE(_dxj_DirectDrawSurface7,pDDS,ret);
	return hr;	
}




STDMETHODIMP C_dxj_DirectDraw7Object::getSurfacesEnum( 
            /* [in] */ long flags,
            /* [in] */ DDSurfaceDesc2 __RPC_FAR *desc,
            /* [retval][out] */ I_dxj_DirectDrawEnumSurfaces __RPC_FAR *__RPC_FAR *ret)  
 
{
	HRESULT hr=C_dxj_DirectDrawEnumSurfacesObject::create((I_dxj_DirectDraw7*)this , flags, desc,ret);
	return hr;
}


STDMETHODIMP C_dxj_DirectDraw7Object::getDeviceIdentifier( 
             long flags,I_dxj_DirectDrawIdentifier **ret) 
{
	HRESULT hr;				
	hr=C_dxj_DirectDrawIdentifierObject::Create(m__dxj_DirectDraw7,(DWORD)flags,ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\d3dxmathvb.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dxmath.h
//  Content:    D3DX math types and functions
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __D3DXMATHVB_H__
#define __D3DXMATHVB_H__

//#include <d3d.h>
#include <math.h>
#include <limits.h>
//#include "d3dxerr.h"

#ifndef D3DXINLINE
#ifdef __cplusplus
#define D3DXINLINE inline
#else
#define D3DXINLINE _inline
#endif
#endif

#pragma warning(disable:4201) // anonymous unions warning

//===========================================================================
//
// General purpose utilities
//
//===========================================================================
//#define D3DX_PI    ((float)  3.141592654f)
//#define D3DX_1BYPI ((float)  0.318309886f)

#define D3DXToRadian( degree ) ((degree) * (D3DX_PI / 180.0f))
#define D3DXToDegree( radian ) ((radian) * (180.0f / D3DX_PI))





//===========================================================================
//
// D3DX math functions:
//
// NOTE:
//  * All these functions can take the same object as in and out parameters.
//
//  * Out parameters are typically also returned as return values, so that
//    the output of one function may be used as a parameter to another.
//
//===========================================================================

//--------------------------
// 2D Vector
//--------------------------

// inline

float D3DVBCALL VB_D3DXVec2Length
    ( const D3DXVECTOR2 *pV );

float D3DVBCALL VB_D3DXVec2LengthSq
    ( const D3DXVECTOR2 *pV );

float D3DVBCALL VB_D3DXVec2Dot
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Z component of ((x1,y1,0) cross (x2,y2,0))
float D3DVBCALL VB_D3DXVec2CCW
    ( const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Add
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Subtract
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2)
D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Minimize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2)
D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Maximize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2 );

D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Scale
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, float s );

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR2* D3DVBCALL VB_D3DXVec2Lerp
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR2* WINAPI VB_D3DXVec2Normalize
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR2* WINAPI VB_D3DXVec2Hermite
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pT1,
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pT2, float s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR2* WINAPI VB_D3DXVec2CatmullRom
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV0, const D3DXVECTOR2 *pV1,
      const D3DXVECTOR2 *pV2, const D3DXVECTOR2 *pV3, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR2* WINAPI VB_D3DXVec2BaryCentric
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV1, const D3DXVECTOR2 *pV2,
      D3DXVECTOR2 *pV3, float f, float g);

// Transform (x, y, 0, 1) by matrix.
D3DXVECTOR4* WINAPI VB_D3DXVec2Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

// Transform (x, y, 0, 1) by matrix, project result back into w=1.
D3DXVECTOR2* WINAPI VB_D3DXVec2TransformCoord
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

// Transform (x, y, 0, 0) by matrix.
D3DXVECTOR2* WINAPI VB_D3DXVec2TransformNormal
    ( D3DXVECTOR2 *pOut, const D3DXVECTOR2 *pV, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 3D Vector
//--------------------------

// inline

float D3DVBCALL  VB_D3DXVec3Length
    ( const D3DXVECTOR3 *pV );

float D3DVBCALL VB_D3DXVec3LengthSq
    ( const D3DXVECTOR3 *pV );

float D3DVBCALL VB_D3DXVec3Dot
    ( const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Cross
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Add
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Subtract
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Minimize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Maximize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2 );

D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, float s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR3* D3DVBCALL VB_D3DXVec3Lerp
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

D3DXVECTOR3* WINAPI VB_D3DXVec3Normalize
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR3* WINAPI VB_D3DXVec3Hermite
    ( D3DXVECTOR3 *pOut,  const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pT1,
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pT2, float s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR3* WINAPI VB_D3DXVec3CatmullRom
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV0, const D3DXVECTOR3 *pV1,
      const D3DXVECTOR3 *pV2, const D3DXVECTOR3 *pV3, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR3* WINAPI VB_D3DXVec3BaryCentric
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3, float f, float g);

// Transform (x, y, z, 1) by matrix.
D3DXVECTOR4* WINAPI VB_D3DXVec3Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

// Transform (x, y, z, 1) by matrix, project result back into w=1.
D3DXVECTOR3* WINAPI VB_D3DXVec3TransformCoord
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

// Transform (x, y, z, 0) by matrix.
D3DXVECTOR3* WINAPI VB_D3DXVec3TransformNormal
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DXMATRIX *pM );

// Project vector from object space into screen space
D3DXVECTOR3* WINAPI VB_D3DXVec3Project
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const D3DXMATRIX *pProjection, const D3DXMATRIX *pView, const D3DXMATRIX *pWorld);

// Project vector from screen space into object space
D3DXVECTOR3* WINAPI VB_D3DXVec3Unproject
    ( D3DXVECTOR3 *pOut, const D3DXVECTOR3 *pV, const D3DVIEWPORT8 *pViewport,
      const D3DXMATRIX *pProjection, const D3DXMATRIX *pView, const D3DXMATRIX *pWorld);

#ifdef __cplusplus
}
#endif



//--------------------------
// 4D Vector
//--------------------------

// inline

float D3DVBCALL VB_D3DXVec4Length
    ( const D3DXVECTOR4 *pV );

float D3DVBCALL VB_D3DXVec4LengthSq
    ( const D3DXVECTOR4 *pV );

float D3DVBCALL VB_D3DXVec4Dot
    ( const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2 );

D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Add
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Subtract
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

// Minimize each component.  x = min(x1, x2), y = min(y1, y2), ...
D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Minimize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

// Maximize each component.  x = max(x1, x2), y = max(y1, y2), ...
D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Maximize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2);

D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Scale
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, float s);

// Linear interpolation. V1 + s(V2-V1)
D3DXVECTOR4* D3DVBCALL VB_D3DXVec4Lerp
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      float s );

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Cross-product in 4 dimensions.
D3DXVECTOR4* WINAPI VB_D3DXVec4Cross
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3);

D3DXVECTOR4* WINAPI VB_D3DXVec4Normalize
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV );

// Hermite interpolation between position V1, tangent T1 (when s == 0)
// and position V2, tangent T2 (when s == 1).
D3DXVECTOR4* WINAPI VB_D3DXVec4Hermite
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pT1,
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pT2, float s );

// CatmullRom interpolation between V1 (when s == 0) and V2 (when s == 1)
D3DXVECTOR4* WINAPI VB_D3DXVec4CatmullRom
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV0, const D3DXVECTOR4 *pV1,
      const D3DXVECTOR4 *pV2, const D3DXVECTOR4 *pV3, float s );

// Barycentric coordinates.  V1 + f(V2-V1) + g(V3-V1)
D3DXVECTOR4* WINAPI VB_D3DXVec4BaryCentric
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV1, const D3DXVECTOR4 *pV2,
      const D3DXVECTOR4 *pV3, float f, float g);

// Transform vector by matrix.
D3DXVECTOR4* WINAPI VB_D3DXVec4Transform
    ( D3DXVECTOR4 *pOut, const D3DXVECTOR4 *pV, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// 4D Matrix
//--------------------------

// inline

D3DXMATRIX* D3DVBCALL VB_D3DXMatrixIdentity
    ( D3DXMATRIX *pOut );

BOOL D3DVBCALL VB_D3DXMatrixIsIdentity
    ( const D3DXMATRIX *pM );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

float WINAPI D3DXMatrixfDeterminant
    ( const D3DXMATRIX *pM );

// Matrix multiplication.  The result represents the transformation M2 
// followed by the transformation M1.  (Out = M1 * M2)
D3DXMATRIX* WINAPI VB_D3DXMatrixMultiply
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM1, const D3DXMATRIX *pM2 );

D3DXMATRIX* WINAPI VB_D3DXMatrixTranspose
    ( D3DXMATRIX *pOut, const D3DXMATRIX *pM );

// Calculate inverse of matrix.  Inversion my fail, in which case NULL will
// be returned.  The determinant of pM is also returned it pfDeterminant
// is non-NULL.
D3DXMATRIX* WINAPI VB_D3DXMatrixInverse
    ( D3DXMATRIX *pOut, float *pfDeterminant, const D3DXMATRIX *pM );

// Build a matrix which scales by (sx, sy, sz)
D3DXMATRIX* WINAPI VB_D3DXMatrixScaling
    ( D3DXMATRIX *pOut, float sx, float sy, float sz );

// Build a matrix which translates by (x, y, z)
D3DXMATRIX* WINAPI VB_D3DXMatrixTranslation
    ( D3DXMATRIX *pOut, float x, float y, float z );

// Build a matrix which rotates around the X axis
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around the Y axis
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around the Z axis
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, float angle );

// Build a matrix which rotates around an arbitrary axis
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationAxis
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pV, float angle );

// Build a matrix from a quaternion
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationQuaternion
    ( D3DXMATRIX *pOut, const D3DXQUATERNION *pQ);

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXMATRIX* WINAPI VB_D3DXMatrixRotationYawPitchRoll
    ( D3DXMATRIX *pOut, float yaw, float pitch, float roll );


// Build transformation matrix.  NULL arguments are treated as identity.
// Mout = Msc-1 * Msr-1 * Ms * Msr * Msc * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI VB_D3DXMatrixTransformation
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pScalingCenter,
      const D3DXQUATERNION *pScalingRotation, const D3DXVECTOR3 *pScaling,
      const D3DXVECTOR3 *pRotationCenter, const D3DXQUATERNION *pRotation,
      const D3DXVECTOR3 *pTranslation);

// Build affine transformation matrix.  NULL arguments are treated as identity.
// Mout = Ms * Mrc-1 * Mr * Mrc * Mt
D3DXMATRIX* WINAPI VB_D3DXMatrixAffineTransformation
    ( D3DXMATRIX *pOut, float Scaling, const D3DXVECTOR3 *pRotationCenter,
      const D3DXQUATERNION *pRotation, const D3DXVECTOR3 *pTranslation);

// Build a lookat matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixLookAtRH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp );

// Build a lookat matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixLookAtLH
    ( D3DXMATRIX *pOut, const D3DXVECTOR3 *pEye, const D3DXVECTOR3 *pAt,
      const D3DXVECTOR3 *pUp );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveRH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFovRH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveFovLH
    ( D3DXMATRIX *pOut, float fovy, float aspect, float zn, float zf );

// Build a perspective projection matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenterRH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build a perspective projection matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixPerspectiveOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoRH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoLH
    ( D3DXMATRIX *pOut, float w, float h, float zn, float zf );

// Build an ortho projection matrix. (right-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenterRH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build an ortho projection matrix. (left-handed)
D3DXMATRIX* WINAPI VB_D3DXMatrixOrthoOffCenterLH
    ( D3DXMATRIX *pOut, float l, float r, float b, float t, float zn,
      float zf );

// Build a matrix which flattens geometry into a plane, as if casting
// a shadow from a light.
D3DXMATRIX* WINAPI VB_D3DXMatrixShadow
    ( D3DXMATRIX *pOut, const D3DXVECTOR4 *pLight,
      const D3DXPLANE *pPlane );

// Build a matrix which reflects the coordinate system about a plane
D3DXMATRIX* WINAPI VB_D3DXMatrixReflect
    ( D3DXMATRIX *pOut, const D3DXPLANE *pPlane );

#ifdef __cplusplus
}
#endif


//--------------------------
// Quaternion
//--------------------------

// inline

float D3DVBCALL VB_D3DXQuaternionLength
    ( const D3DXQUATERNION *pQ );

// Length squared, or "norm"
float D3DVBCALL VB_D3DXQuaternionLengthSq
    ( const D3DXQUATERNION *pQ );

float D3DVBCALL VB_D3DXQuaternionDot
    ( const D3DXQUATERNION *pQ1, const D3DXQUATERNION *pQ2 );

// (0, 0, 0, 1)
D3DXQUATERNION* D3DVBCALL VB_D3DXQuaternionIdentity
    ( D3DXQUATERNION *pOut );

BOOL D3DVBCALL VB_D3DXQuaternionIsIdentity
    ( const D3DXQUATERNION *pQ );

// (-x, -y, -z, w)
D3DXQUATERNION* D3DVBCALL VB_D3DXQuaternionConjugate
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );


// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Compute a quaternin's axis and angle of rotation. Expects unit quaternions.
void WINAPI VB_D3DXQuaternionToAxisAngle
    ( const D3DXQUATERNION *pQ, D3DXVECTOR3 *pAxis, float *pAngle );

// Build a quaternion from a rotation matrix.
D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationMatrix
    ( D3DXQUATERNION *pOut, const D3DXMATRIX *pM);

// Rotation about arbitrary axis.
D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationAxis
    ( D3DXQUATERNION *pOut, const D3DXVECTOR3 *pV, float angle );

// Yaw around the Y axis, a pitch around the X axis,
// and a roll around the Z axis.
D3DXQUATERNION* WINAPI VB_D3DXQuaternionRotationYawPitchRoll
    ( D3DXQUATERNION *pOut, float yaw, float pitch, float roll );

// Quaternion multiplication.  The result represents the rotation Q2 
// followed by the rotation Q1.  (Out = Q2 * Q1)
D3DXQUATERNION* WINAPI VB_D3DXQuaternionMultiply
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2 );

D3DXQUATERNION* WINAPI VB_D3DXQuaternionNormalize
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Conjugate and re-norm
D3DXQUATERNION* WINAPI VB_D3DXQuaternionInverse
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Expects unit quaternions.
// if q = (cos(theta), sin(theta) * v); ln(q) = (0, theta * v)
D3DXQUATERNION* WINAPI VB_D3DXQuaternionLn
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Expects pure quaternions. (w == 0)  w is ignored in calculation.
// if q = (0, theta * v); exp(q) = (cos(theta), sin(theta) * v)
D3DXQUATERNION* WINAPI VB_D3DXQuaternionExp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ );

// Spherical linear interpolation between Q1 (s == 0) and Q2 (s == 1).
// Expects unit quaternions.
D3DXQUATERNION* WINAPI VB_D3DXQuaternionSlerp
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, float t );

// Spherical quadrangle interpolation.
// Slerp(Slerp(Q1, Q4, t), Slerp(Q2, Q3, t), 2t(1-t))
D3DXQUATERNION* WINAPI VB_D3DXQuaternionSquad
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      const D3DXQUATERNION *pQ4, float t );

// Slerp(Slerp(Q1, Q2, f+g), Slerp(Q1, Q3, f+g), g/(f+g))
D3DXQUATERNION* WINAPI VB_D3DXQuaternionBaryCentric
    ( D3DXQUATERNION *pOut, const D3DXQUATERNION *pQ1,
      const D3DXQUATERNION *pQ2, const D3DXQUATERNION *pQ3,
      float f, float g );

#ifdef __cplusplus
}
#endif


//--------------------------
// Plane
//--------------------------

// inline

// ax + by + cz + dw
float D3DVBCALL VB_D3DXPlaneDot
    ( const D3DXPLANE *pP, const D3DXVECTOR4 *pV);

// ax + by + cz + d
float D3DVBCALL VB_D3DXPlaneDotCoord
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV);

// ax + by + cz
float D3DVBCALL VB_D3DXPlaneDotNormal
    ( const D3DXPLANE *pP, const D3DXVECTOR3 *pV);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Normalize plane (so that |a,b,c| == 1)
D3DXPLANE* WINAPI VB_D3DXPlaneNormalize
    ( D3DXPLANE *pOut, const D3DXPLANE *pP);

// Find the intersection between a plane and a line.  If the line is
// parallel to the plane, NULL is returned.
D3DXVECTOR3* WINAPI VB_D3DXPlaneIntersectLine
    ( D3DXVECTOR3 *pOut, const D3DXPLANE *pP, const D3DXVECTOR3 *pV1,
      const D3DXVECTOR3 *pV2);

// Construct a plane from a point and a normal
D3DXPLANE* WINAPI VB_D3DXPlaneFromPointNormal
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pPoint, const D3DXVECTOR3 *pNormal);

// Construct a plane from 3 points
D3DXPLANE* WINAPI VB_D3DXPlaneFromPoints
    ( D3DXPLANE *pOut, const D3DXVECTOR3 *pV1, const D3DXVECTOR3 *pV2,
      const D3DXVECTOR3 *pV3);

// Transform a plane by a matrix.  The vector (a,b,c) must be normal.
// M must be an affine transform.
D3DXPLANE* WINAPI VB_D3DXPlaneTransform
    ( D3DXPLANE *pOut, const D3DXPLANE *pP, const D3DXMATRIX *pM );

#ifdef __cplusplus
}
#endif


//--------------------------
// Color
//--------------------------

// inline

// (1-r, 1-g, 1-b, a)
D3DXCOLOR* D3DVBCALL VB_D3DXColorNegative
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC);

D3DXCOLOR* D3DVBCALL VB_D3DXColorAdd
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

D3DXCOLOR* D3DVBCALL  VB_D3DXColorSubtract
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

D3DXCOLOR* D3DVBCALL VB_D3DXColorScale
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s);

// (r1*r2, g1*g2, b1*b2, a1*a2)
D3DXCOLOR* D3DVBCALL VB_D3DXColorModulate
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2);

// Linear interpolation of r,g,b, and a. C1 + s(C2-C1)
D3DXCOLOR* D3DVBCALL VB_D3DXColorLerp
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC1, const D3DXCOLOR *pC2, float s);

// non-inline
#ifdef __cplusplus
extern "C" {
#endif

// Interpolate r,g,b between desaturated color and color.
// DesaturatedColor + s(Color - DesaturatedColor)
D3DXCOLOR* WINAPI VB_D3DXColorAdjustSaturation
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float s);

// Interpolate r,g,b between 50% grey and color.  Grey + s(Color - Grey)
D3DXCOLOR* WINAPI VB_D3DXColorAdjustContrast
    (D3DXCOLOR *pOut, const D3DXCOLOR *pC, float c);

#ifdef __cplusplus
}
#endif



#pragma warning(default:4201)

#endif // __D3DXMATHVB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dienumdeviceobjectsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dienumdeviceobjectsobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DIEnumDeviceObjectsObj.h"
#include "didevObjInstOBj.h"

extern BSTR DINPUTGUIDtoBSTR(LPGUID pGuid);


extern "C" BOOL CALLBACK DIEnumDeviceObjectsProc(
  LPCDIDEVICEOBJECTINSTANCEW lpddoi,  
  LPVOID lpArg                       
  )
{
 
	if (!lpddoi) return FALSE;

	C_dxj_DIEnumDeviceObjectsObject *pObj=(C_dxj_DIEnumDeviceObjectsObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;
		if (pObj->m_pList){
			pObj->m_pList=(DIDEVICEOBJECTINSTANCEW *)realloc(pObj->m_pList,sizeof(DIDEVICEOBJECTINSTANCEW)* pObj->m_nMax);
		}
		else {
			pObj->m_pList=(DIDEVICEOBJECTINSTANCEW *)malloc(sizeof(DIDEVICEOBJECTINSTANCEW)* pObj->m_nMax);
		}

		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),lpddoi,sizeof(DIDEVICEOBJECTINSTANCEW));
	

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DIEnumDeviceObjectsObject::C_dxj_DIEnumDeviceObjectsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DIEnumDeviceObjectsObject::~C_dxj_DIEnumDeviceObjectsObject()
{
	//empty list
	if (m_pList) free(m_pList);

}
		

HRESULT C_dxj_DIEnumDeviceObjectsObject::create(LPDIRECTINPUTDEVICE8W pDI,  long flags,I_dxj_DIEnumDeviceObjects **ppRet)
{
	HRESULT hr;
	C_dxj_DIEnumDeviceObjectsObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DIEnumDeviceObjectsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumObjects(
		(LPDIENUMDEVICEOBJECTSCALLBACKW)DIEnumDeviceObjectsProc,
		(void*)pNew,
		(DWORD) flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DIEnumDeviceObjects,(void**)ppRet);
	return hr;
}



HRESULT C_dxj_DIEnumDeviceObjectsObject::getItem( long index, I_dxj_DirectInputDeviceObjectInstance **ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	DIDEVICEOBJECTINSTANCEW *inst=&m_pList[index-1];

	if (!inst) return E_INVALIDARG;

	HRESULT hr;
	hr=C_dxj_DIDeviceObjectInstanceObject::create(inst,ret);
	return hr;
}

HRESULT C_dxj_DIEnumDeviceObjectsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\didevobjinstobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevobjinstobj.h
//
//--------------------------------------------------------------------------


#include "resource.h"

class C_dxj_DIDeviceObjectInstanceObject :
		public I_dxj_DirectInputDeviceObjectInstance,
		public CComObjectRoot
{
public:
		
	BEGIN_COM_MAP(C_dxj_DIDeviceObjectInstanceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectInputDeviceObjectInstance)
	END_COM_MAP()


	DECLARE_AGGREGATABLE(C_dxj_DIDeviceObjectInstanceObject)

public:
	C_dxj_DIDeviceObjectInstanceObject();	


	/* [propget] */ HRESULT STDMETHODCALLTYPE getGuidType( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getOfs( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getType( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getFlags( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getName( 
		/* [retval][out] */ BSTR __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getCollectionNumber( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getDesignatorIndex( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getUsagePage( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getUsage( 
		/* [retval][out] */ short __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getDimension( 
		/* [retval][out] */ long __RPC_FAR *ret);

	/* [propget] */ HRESULT STDMETHODCALLTYPE getExponent( 
		/* [retval][out] */ short __RPC_FAR *ret);

  
		static HRESULT C_dxj_DIDeviceObjectInstanceObject::create(DIDEVICEOBJECTINSTANCEW *inst,I_dxj_DirectInputDeviceObjectInstance **ret);

		void init(DIDEVICEOBJECTINSTANCEW *inst);
private:
		DIDEVICEOBJECTINSTANCEW m_inst;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\didevobjinstobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       didevobjinstobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "diDevObjInstObj.h"


extern BSTR GUIDtoBSTR(LPGUID g);

extern BSTR DINPUTGUIDtoBSTR(LPGUID g);


	
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getGuidType( BSTR __RPC_FAR *ret){
	*ret=DINPUTGUIDtoBSTR(&m_inst.guidType);
	return S_OK;
}

        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getOfs(  long __RPC_FAR *ret){
	*ret=(long)m_inst.dwOfs;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getType( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwType;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getFlags( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwFlags;
	return S_OK;
}

//USES_CONVERSION;

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getName( BSTR __RPC_FAR *ret){
	*ret=SysAllocString(m_inst.tszName);	//T2BSTR(m_inst.tszName);		
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getCollectionNumber( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wCollectionNumber;
	return S_OK;
}
        

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getDesignatorIndex( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wDesignatorIndex;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getUsagePage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsagePage;
	return S_OK;
}

STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getUsage( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wUsage;
	return S_OK;
}
        
STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getExponent( short __RPC_FAR *ret)
{
	*ret=(short)m_inst.wExponent;
	return S_OK;
}


STDMETHODIMP C_dxj_DIDeviceObjectInstanceObject::getDimension( long __RPC_FAR *ret)
{
	*ret=(long)m_inst.dwDimension;
	return S_OK;
}

        
        
C_dxj_DIDeviceObjectInstanceObject::C_dxj_DIDeviceObjectInstanceObject()
{	
	ZeroMemory(&m_inst,sizeof(DIDEVICEOBJECTINSTANCEW));
}

void C_dxj_DIDeviceObjectInstanceObject::init(DIDEVICEOBJECTINSTANCEW *inst)
{
	memcpy(&m_inst,inst,sizeof(DIDEVICEOBJECTINSTANCEW));
}

HRESULT C_dxj_DIDeviceObjectInstanceObject::create(DIDEVICEOBJECTINSTANCEW *inst,I_dxj_DirectInputDeviceObjectInstance **ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;

	C_dxj_DIDeviceObjectInstanceObject *c=NULL;
	c=new CComObject<C_dxj_DIDeviceObjectInstanceObject>;
	if( c == NULL ) return E_FAIL;
	c->init(inst);
	hr=c->QueryInterface(IID_I_dxj_DirectInputDeviceObjectInstance, (void**)ret);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dienumdeviceobjectsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dienumdeviceobjectsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DIEnumDeviceObjectsObject : 
	public I_dxj_DIEnumDeviceObjects,
	public CComObjectRoot
{
public:
	C_dxj_DIEnumDeviceObjectsObject() ;
	virtual ~C_dxj_DIEnumDeviceObjectsObject() ;

BEGIN_COM_MAP(C_dxj_DIEnumDeviceObjectsObject)
	COM_INTERFACE_ENTRY(I_dxj_DIEnumDeviceObjects)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DIEnumDeviceObjectsObject)


public:
        HRESULT STDMETHODCALLTYPE getItem( 
            /* [in] */ long index,
            /* [out][in] */ I_dxj_DirectInputDeviceObjectInstance __RPC_FAR **info);
        
        HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *count);
		
				
		static HRESULT C_dxj_DIEnumDeviceObjectsObject::create(LPDIRECTINPUTDEVICE8W pDI,  long flags,I_dxj_DIEnumDeviceObjects **ppRet);
public:
		DIDEVICEOBJECTINSTANCEW *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dienumeffectsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dienumeffectsobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dIEnumEffectsObj.h"


extern BSTR DINPUTGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR bstr);



////////////////////////////////////////////////////////////////////////////

/*extern "C"*/ BOOL CALLBACK  objEnumInputEffectsCallback(
  LPCDIEFFECTINFOW pdei,  
  LPVOID lpArg           
  )
{

	DPF(1,"Entered objEnumInputEffectsCallback\r\n");

	if (!pdei) return FALSE;

	C_dxj_DirectInputEnumEffectsObject *pObj=(C_dxj_DirectInputEnumEffectsObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList){
			pObj->m_pList=(DIEFFECTINFOW*)realloc(pObj->m_pList,sizeof(DIEFFECTINFOW)* pObj->m_nMax);
		}
		else {
			pObj->m_pList=(DIEFFECTINFOW*)malloc(   sizeof(DIEFFECTINFOW)* pObj->m_nMax);
		}
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),pdei,sizeof(DIEFFECTINFOW));
	
	DPF1(1,"objEnumInputEffects '%s'\n",pdei->tszName);

	pObj->m_nCount++;
	
	return TRUE;
}


C_dxj_DirectInputEnumEffectsObject::C_dxj_DirectInputEnumEffectsObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DirectInputEnumEffectsObject::~C_dxj_DirectInputEnumEffectsObject()
{
	//empty list
	if (m_pList) free(m_pList);

}


HRESULT C_dxj_DirectInputEnumEffectsObject::create(LPDIRECTINPUTDEVICE8W pDI,long effectType,I_dxj_DirectInputEnumEffects **ppRet)
{
	HRESULT hr;
	C_dxj_DirectInputEnumEffectsObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DirectInputEnumEffectsObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumEffects(
		objEnumInputEffectsCallback,
		(void*)pNew,
		(DWORD) effectType);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		pNew->m_pList=NULL;
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DirectInputEnumEffects,(void**)ppRet);
	return hr;
}



HRESULT C_dxj_DirectInputEnumEffectsObject::getEffectGuid( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	*ret=DINPUTGUIDtoBSTR(&(m_pList[index-1].guid));
		
	return S_OK;
}



HRESULT C_dxj_DirectInputEnumEffectsObject::getName( long index, BSTR *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	USES_CONVERSION;

	*ret=SysAllocString(m_pList[index-1].tszName); //T2BSTR(m_pList[index-1].tszName);
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getType( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwEffType;
		
	return S_OK;
}


HRESULT C_dxj_DirectInputEnumEffectsObject::getStaticParams( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwStaticParams;
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getDynamicParams( long index, long *ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;
	
	

	*ret=(long)m_pList[index-1].dwDynamicParams;
		
	return S_OK;
}

HRESULT C_dxj_DirectInputEnumEffectsObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dienumdevicesobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dienumdevicesobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dIEnumDevicesObj.h"
#include "diDevInstObj.h"

extern BSTR DINPUTGUIDtoBSTR(LPGUID pGuid);
extern  HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR bstr);
extern HRESULT FillRealActionFormat(DIACTIONFORMATW *real, DIACTIONFORMAT_CDESC *cover, SAFEARRAY **actionArray,long ActionCount );

//dienumdevicesobj.cpp(105) : error C2664: 'EnumDevicesBySemantics' : cannot convert parameter 3 from 
//'int (struct DIDEVICEINSTANCEW *const ,struct IDirectInputDevice8W *,unsigned long,unsigned long,void *)' to 
//              'int (__stdcall *)(const struct DIDEVICEINSTANCEW *,struct IDirectInputDevice8W *,unsigned long,unsigned long,void *)'

//CALLBACK
/////////////////////////////////////////////////////////////////////////////
//extern "C" 
BOOL _stdcall objEnumInputDevicesCallback(
  const struct DIDEVICEINSTANCEW * lpddi,  
  //IDirectInputDevice8W *pDev,
  //unsigned long UnknownVar1,
  //unsigned long UnknownVar2,
  LPVOID lpArg               
  )
{

	DPF(1,"Entered objEnumInputDevicesCallback\r\n");

	if (!lpddi) return FALSE;

	C_dxj_DIEnumDevicesObject *pObj=(C_dxj_DIEnumDevicesObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList){
			pObj->m_pList=(DIDEVICEINSTANCEW*)realloc(pObj->m_pList,sizeof(DIDEVICEINSTANCEW)* pObj->m_nMax);
		}
		else {
			pObj->m_pList=(DIDEVICEINSTANCEW*)malloc(   sizeof(DIDEVICEINSTANCEW)* pObj->m_nMax);
		}
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),lpddi,sizeof(DIDEVICEINSTANCEW));
	

	pObj->m_nCount++;
	
	return TRUE;
}


BOOL _stdcall objEnumInputDevicesBySemanticsCallback(
  const struct DIDEVICEINSTANCEW * lpddi,  
  IDirectInputDevice8W *pDev,
  unsigned long UnknownVar1,
  unsigned long UnknownVar2,
  LPVOID lpArg               
  )
{

	DPF(1,"Entered objEnumInputDevicesCallback\r\n");

	if (!lpddi) return FALSE;

	C_dxj_DIEnumDevicesObject *pObj=(C_dxj_DIEnumDevicesObject*)lpArg;
	if (pObj==NULL) return FALSE;

	if (pObj->m_nCount >= pObj->m_nMax) 
	{
		pObj->m_nMax += 10;

		if (pObj->m_pList){
			pObj->m_pList=(DIDEVICEINSTANCEW*)realloc(pObj->m_pList,sizeof(DIDEVICEINSTANCEW)* pObj->m_nMax);
		}
		else {
			pObj->m_pList=(DIDEVICEINSTANCEW*)malloc(   sizeof(DIDEVICEINSTANCEW)* pObj->m_nMax);
		}
		if (pObj->m_pList==NULL) 
		{
			pObj->m_bProblem=TRUE;
			return FALSE;
		}
	}
	
	memcpy(&(pObj->m_pList[pObj->m_nCount]),lpddi,sizeof(DIDEVICEINSTANCEW));
	

	pObj->m_nCount++;
	
	return TRUE;
}

C_dxj_DIEnumDevicesObject::C_dxj_DIEnumDevicesObject()
{	
	m_nMax=0;
	m_pList=NULL;
	m_nCount=0;
	m_bProblem=FALSE;
}
C_dxj_DIEnumDevicesObject::~C_dxj_DIEnumDevicesObject()
{
	//empty list
	if (m_pList) free(m_pList);

}


HRESULT C_dxj_DIEnumDevicesObject::createSuitable(LPDIRECTINPUT8W pDI,BSTR str1, DIACTIONFORMAT_CDESC *format, long actionCount,SAFEARRAY **actionArray,long flags, I_dxj_DIEnumDevices8 **ppRet)
{

	HRESULT hr;
	DIACTIONFORMATW frmt;

	C_dxj_DIEnumDevicesObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DIEnumDevicesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


	hr=FillRealActionFormat(&frmt, format, actionArray,actionCount );
	if FAILED(hr) return hr;


	hr=pDI->EnumDevicesBySemantics((LPWSTR)str1,&frmt, objEnumInputDevicesBySemanticsCallback,pNew,(DWORD)flags);
	
	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;


	if FAILED(hr) 
	{
	
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DIEnumDevices8,(void**)ppRet);

	return hr;
}


HRESULT C_dxj_DIEnumDevicesObject::create(LPDIRECTINPUT8W pDI,long deviceType, long flags,I_dxj_DIEnumDevices8 **ppRet)
{
	HRESULT hr;
	C_dxj_DIEnumDevicesObject *pNew=NULL;


	*ppRet=NULL;

	pNew= new CComObject<C_dxj_DIEnumDevicesObject>;			
	if (!pNew) return E_OUTOFMEMORY;

	pNew->m_bProblem=FALSE;


  	hr = pDI->EnumDevices((DWORD)deviceType, 
			objEnumInputDevicesCallback,
		(void*)pNew,
		(DWORD) flags);

	if (pNew->m_bProblem) hr=E_OUTOFMEMORY;

	if FAILED(hr) 
	{
		if (pNew->m_pList) free(pNew->m_pList);
		delete pNew;	
		return hr;
	}

	hr=pNew->QueryInterface(IID_I_dxj_DIEnumDevices8,(void**)ppRet);
	return hr;
}



HRESULT C_dxj_DIEnumDevicesObject::getItem( long index, I_dxj_DirectInputDeviceInstance8 **ret)
{
	if (m_pList==NULL) return E_FAIL;
	if (index < 1) return E_INVALIDARG;
	if (index > m_nCount) return E_INVALIDARG;

	HRESULT hr;
	
	hr=C_dxj_DIDeviceInstance8Object::create(&m_pList[index-1],ret);		
	return hr;
}


HRESULT C_dxj_DIEnumDevicesObject::getCount(long *retVal)
{
	*retVal=m_nCount;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dienumdevicesobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dienumdevicesobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DIEnumDevicesObject : 
	public I_dxj_DIEnumDevices8,
	public CComObjectRoot
{
public:
	C_dxj_DIEnumDevicesObject() ;
	virtual ~C_dxj_DIEnumDevicesObject() ;

BEGIN_COM_MAP(C_dxj_DIEnumDevicesObject)
	COM_INTERFACE_ENTRY(I_dxj_DIEnumDevices8)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DIEnumDevicesObject)

public:

        HRESULT STDMETHODCALLTYPE getItem( long index, I_dxj_DirectInputDeviceInstance8 **ret);
        HRESULT STDMETHODCALLTYPE getCount( long __RPC_FAR *count);
		
		
		static HRESULT C_dxj_DIEnumDevicesObject::create(LPDIRECTINPUT8W pDI,long deviceType, long flags,I_dxj_DIEnumDevices8 **ppRet)	;
    	static HRESULT C_dxj_DIEnumDevicesObject::createSuitable(LPDIRECTINPUT8W pDI,BSTR str1, DIACTIONFORMAT_CDESC *format, long actionCount,SAFEARRAY **actionArray,long flags, I_dxj_DIEnumDevices8 **ppRet);
			   
public:
		DIDEVICEINSTANCEW *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dienumeffectsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dienumeffectsobj.h
//
//--------------------------------------------------------------------------



#include "resource.h"       

class C_dxj_DirectInputEnumEffectsObject : 
	public I_dxj_DirectInputEnumEffects,
	public CComObjectRoot
{
public:
	C_dxj_DirectInputEnumEffectsObject() ;
	virtual ~C_dxj_DirectInputEnumEffectsObject() ;

BEGIN_COM_MAP(C_dxj_DirectInputEnumEffectsObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputEnumEffects)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputEnumEffectsObject)

public:

         HRESULT STDMETHODCALLTYPE getCount( 
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getEffectGuid( 
            /* [in] */ long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getStaticParams( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getDynamicParams( 
            /* [in] */ long i,
            /* [retval][out] */ long __RPC_FAR *ret);
        
         HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ long i,
            /* [retval][out] */ BSTR __RPC_FAR *ret);
        
		
		static HRESULT C_dxj_DirectInputEnumEffectsObject::create(LPDIRECTINPUTDEVICE8W pDI,long effType,I_dxj_DirectInputEnumEffects **ppRet)	;

public:
		DIEFFECTINFOW  *m_pList;
		long			m_nCount;
		long			m_nMax;
		BOOL			m_bProblem;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dinput1obj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinput1obj.cpp
//
//--------------------------------------------------------------------------

    // dDrawColorControlObj.cpp : Implementation of CDirectApp and DLL registration.
    // DHF_DS entire file
    
    #include "stdafx.h"
    #include "Direct.h"
    #include "dms.h"
    #include "dInput1Obj.h"
    #include "dInputDeviceObj.h"
    #include "dinput.h"
    #include "DIEnumDevicesObj.h"
    
    extern HRESULT BSTRtoGUID(LPGUID,BSTR);
    extern HRESULT DINPUTBSTRtoGUID(LPGUID,BSTR);
    
    CONSTRUCTOR(_dxj_DirectInput8, {});
    DESTRUCTOR(_dxj_DirectInput8, {});
    GETSET_OBJECT(_dxj_DirectInput8);

    HRESULT FillRealActionFormat(DIACTIONFORMATW *real, DIACTIONFORMAT_CDESC *cover, SAFEARRAY **actionArray,long ActionCount );                                      
       
    STDMETHODIMP C_dxj_DirectInput8Object::createDevice(BSTR strGuid, I_dxj_DirectInputDevice8 **dev)
    {    
    
    	HRESULT hr = S_OK;
  		GUID		rguid;
    	LPDIRECTINPUTDEVICE8W realdevice=NULL;
    
    	
	hr = DINPUTBSTRtoGUID(&rguid,strGuid);	
    	if FAILED(hr) return hr;	
    
    
     	hr=m__dxj_DirectInput8->CreateDevice(rguid,&realdevice,NULL);
    	if FAILED(hr) return hr;
    
    
    	INTERNAL_CREATE(_dxj_DirectInputDevice8,realdevice,dev);
    	if (*dev==NULL) {
    		realdevice->Release();
    		return E_OUTOFMEMORY;
    	}
    	
    
    	if (0==_wcsicmp(strGuid,L"guid_syskeyboard")){		
    		hr=realdevice->SetDataFormat(&c_dfDIKeyboard);
    	}
    	else if (0==_wcsicmp(strGuid,L"guid_sysmouse")){		
    		hr=realdevice->SetDataFormat(&c_dfDIMouse);
    	}
    	else {
    		hr=realdevice->SetDataFormat(&c_dfDIJoystick2);
    	}
    
    	return hr;
    }
    
    
#ifdef _WIN64
    STDMETHODIMP C_dxj_DirectInput8Object::RunControlPanel( HWND hwndOwner )
#else
    STDMETHODIMP C_dxj_DirectInput8Object::RunControlPanel( long hwndOwner )
#endif
    {
       HRESULT hr;
       hr = m__dxj_DirectInput8->RunControlPanel((HWND)hwndOwner,  (DWORD)0);    
       return hr;
    }
    
    STDMETHODIMP C_dxj_DirectInput8Object::GetDeviceStatus( BSTR strGuid, VARIANT_BOOL *status){
       HRESULT hr;
       GUID g;
	   hr = DINPUTBSTRtoGUID(&g,strGuid);	       
       if FAILED(hr) return hr;

	   if (!status) return E_INVALIDARG;

       hr = m__dxj_DirectInput8->GetDeviceStatus((REFGUID)g);    
    
	   if (hr==DI_OK)
			*status=VARIANT_TRUE;
	   else
			*status=VARIANT_FALSE;

       return S_OK;
    }
    
    
    STDMETHODIMP C_dxj_DirectInput8Object::getDIDevices(
    	long deviceType, long flags, I_dxj_DIEnumDevices8 **ppRet)
    
    {    
    	HRESULT hr;
    	hr = C_dxj_DIEnumDevicesObject::create(m__dxj_DirectInput8,deviceType,flags,ppRet);
    	return hr;
    }


	    
    STDMETHODIMP C_dxj_DirectInput8Object::getDevicesBySemantics(
		 /* [in] */ BSTR str1,
        /* [in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
        /* [in] */ long flags,
        /* [retval][out] */ I_dxj_DIEnumDevices8 __RPC_FAR *__RPC_FAR *ret)
    {    
    	HRESULT hr;
    	hr = C_dxj_DIEnumDevicesObject::createSuitable(m__dxj_DirectInput8,str1,format,format->lActionCount,&format->ActionArray,flags,ret);
    	return hr;
    }

	BOOL CALLBACK DIConfigureDevicesCallback(
		  IUnknown FAR * lpDDSTarget,  
		  LPVOID pvRef   
	)
	{
		HANDLE eventID=(HANDLE)pvRef;
		::SetEvent((HANDLE)eventID);	//CONSIDER 64 bit ramification of casting to a handle
		return TRUE;
	}


    STDMETHODIMP C_dxj_DirectInput8Object::ConfigureDevices   (
#ifdef _WIN64
						HANDLE hEvent,
#else
						long hEvent,
#endif
						DICONFIGUREDEVICESPARAMS_CDESC *CDParams,
						long flags
						)
    {

	HRESULT hr;
	BSTR bstr;
	long lElements;
	long i;


	DICONFIGUREDEVICESPARAMSW RealCDParams;

	if (CDParams->ActionFormats==0) return E_INVALIDARG;

	ZeroMemory(&RealCDParams,sizeof(DICONFIGUREDEVICESPARAMSW));
	RealCDParams.dwSize=sizeof(DICONFIGUREDEVICESPARAMSW);
	RealCDParams.dwcUsers=CDParams->UserCount;
	RealCDParams.dwcFormats=CDParams->FormatCount;
	RealCDParams.hwnd=(HWND)CDParams->hwnd;

	//CONSIDER if we need to ADDREF 
	RealCDParams.lpUnkDDSTarget=CDParams->DDSTarget;
	memcpy(&RealCDParams.dics,&CDParams->dics,sizeof(DICOLORSET));
	
	lElements=(long)CDParams->UserNames->rgsabound[0].cElements;
	if (lElements==0){
		RealCDParams.lptszUserNames=NULL;
	}
	else {
		if (lElements < CDParams->UserCount) return E_INVALIDARG;

		DWORD dwMemSize=MAX_PATH*sizeof(WCHAR)*CDParams->UserCount;		
		RealCDParams.lptszUserNames=(WCHAR*)malloc(dwMemSize);
		if (!RealCDParams.lptszUserNames) return E_OUTOFMEMORY;

		ZeroMemory(RealCDParams.lptszUserNames,dwMemSize);

		WCHAR *pCharbuff=RealCDParams.lptszUserNames;
		for (i=0;i<CDParams->UserCount;i++)
		{		
			bstr=((BSTR*) (CDParams->UserNames->pvData))[i];
			if (bstr) wcscpy(pCharbuff,(WCHAR*)bstr);
			pCharbuff+=MAX_PATH;	//advance 1024 wchars
		}
		
	}

	lElements=(long)CDParams->ActionFormats->rgsabound[0].cElements;
	if (lElements < CDParams->FormatCount) {
		if ( RealCDParams.lptszUserNames) free(RealCDParams.lptszUserNames);
		return E_INVALIDARG;
	}

	DIACTIONFORMATW *pRealActionFormats=(DIACTIONFORMATW*)malloc(CDParams->FormatCount*sizeof(DIACTIONFORMATW));
	if (!pRealActionFormats) {
		if ( RealCDParams.lptszUserNames) free(RealCDParams.lptszUserNames);
		return E_OUTOFMEMORY;
	}

	RealCDParams.lprgFormats=pRealActionFormats;

	DIACTIONFORMAT_CDESC *pCoverFormats=(DIACTIONFORMAT_CDESC *) (CDParams->ActionFormats->pvData);	
	if (!pCoverFormats) {
		if (RealCDParams.lptszUserNames) free(RealCDParams.lptszUserNames);
		if (pRealActionFormats) free (pRealActionFormats);
		return E_INVALIDARG;
	}	



	for (i=0;i<CDParams->FormatCount;i++)
	{
		FillRealActionFormat(				
			&(pRealActionFormats[i]), 
			&(pCoverFormats[i]),
			&(pCoverFormats[i].ActionArray),
			pCoverFormats[i].lActionCount);
	}
	

	if (hEvent)
	{
	       	hr = m__dxj_DirectInput8->ConfigureDevices(
			DIConfigureDevicesCallback,
		   	&RealCDParams,
			(DWORD)flags,
			(void*)hEvent);
	}
	else 
	{
	       	hr = m__dxj_DirectInput8->ConfigureDevices(
			NULL,
		   	&RealCDParams,
			(DWORD)flags,
			NULL);
	}
	
	if ( RealCDParams.lptszUserNames) free(RealCDParams.lptszUserNames);

	//TODO make sure action format info is deallocated correctly
	if (pRealActionFormats) free (pRealActionFormats);

	return hr;
    }




    HRESULT FillRealActionFormat(DIACTIONFORMATW *real, DIACTIONFORMAT_CDESC *cover, SAFEARRAY **actionArray,long ActionCount )
    {
		HRESULT hr;
		ZeroMemory(real,sizeof(DIACTIONFORMATW));
		real->dwSize=sizeof(DIACTIONFORMATW);
		real->dwActionSize=sizeof(DIACTIONW);
		real->dwDataSize=(DWORD)ActionCount*sizeof(DWORD);
		real->dwGenre= (DWORD)cover->lGenre;
		real->lAxisMin= cover->lAxisMin;
		real->lAxisMax= cover->lAxisMax;
		real->dwBufferSize= (DWORD)cover->lBufferSize;
		real->dwNumActions=(DWORD)ActionCount;
		real->rgoAction= ((LPDIACTIONW) (*actionArray)->pvData);
		if (cover->ActionMapName)
		{
			wcscpy(real->tszActionMap,(WCHAR*)cover->ActionMapName);
		}		
		hr=DINPUTBSTRtoGUID(&real->guidActionMap,cover->guidActionMap);
		if FAILED(hr) return hr;

		return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\directinput.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       directinput.cpp
//
//--------------------------------------------------------------------------

// dInputDevice.cpp : Implementation of dInputDevice and DLL registration.

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DirectInput.h"

CONSTRUCTOR(dInputDevice, {});
DESTRUCTOR(dInputDevice, {});
GETSET_OBJECT(dInputDevice);

/////////////////////////////////////////////////////////////////////////////
// Direct Input Device Object 
//

#ifdef USING_IDISPATCH
STDMETHODIMP dInputDevice::InterfaceSupportsErrorInfo(REFIID riid)
{
	if (riid == IID_IdInputDevice)
		return S_OK;
	return S_FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\directinput.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       directinput.h
//
//--------------------------------------------------------------------------

// DiectInput.h : Declaration of the dInputDevice

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// Input Device Ojbect

#define typedef_dInputDevice LPDIRECTINPUTDEVICE

class CdInputDeviceObject : 
#ifdef USING_IDISPATCH
	public CComDualImpl<IdInputDevice, &IID_IdInputDevice, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public IdInputDevice,
#endif
	public CComObjectBase<&CLSID_dInputDevice>
{
public:
	CdInputDeviceObject() ;
BEGIN_COM_MAP(CdInputDeviceObject)
	COM_INTERFACE_ENTRY(IdInputDevice)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()
// Use DECLARE_NOT_AGGREGATABLE(CdInputDeviceObject) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CdInputDeviceObject)
#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// IdInputDevice
public:
	// MUST BE FIRST!!
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

private:
    DECL_VARIABLE(dInputDevice);

public:
	DX3J_GLOBAL_LINKS( dInputDevice )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dinputdeviceobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinputdeviceobj.cpp
//
//--------------------------------------------------------------------------




// dDrawColorControlObj.cpp : Implementation of CDirectApp and DLL registration.
// DHF_DS entire file

#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dienumDeviceObjectsObj.h"
#include "dIEnumEffectsObj.h"
#include "dInputdeviceObj.h"
#include "dInputEffectObj.h"
#include "didevInstObj.h"
#include "didevObjInstObj.h"


//TODO move to typlib enum
#define dfDIKeyboard  1
#define dfDIMouse     2
#define dfDIJoystick  3
#define dfDIJoystick2 4
#define dfDIMouse2    5

extern HRESULT FixUpCoverEffect(GUID  g, DIEFFECT_CDESC *cover,DIEFFECT *realEffect);
extern HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEFFECT_CDESC *cover);


extern HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR str);
extern BSTR DINPUTGUIDtoBSTR(LPGUID pg);
extern HRESULT FillRealActionFormat(DIACTIONFORMATW *real, DIACTIONFORMAT_CDESC *cover, SAFEARRAY **actionArray,long ActionCount );
#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }

HRESULT C_dxj_DirectInputDevice8Object::init()
{
	nFormat=0;
	return S_OK;
}
HRESULT C_dxj_DirectInputDevice8Object::cleanup()
{
	return S_OK;
}

CONSTRUCTOR(_dxj_DirectInputDevice8, {init();});
DESTRUCTOR(_dxj_DirectInputDevice8, {cleanup();});

//NOTE get set for Device object
// must use QI to get at other objects.
GETSET_OBJECT(_dxj_DirectInputDevice8);
                                  
   
STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceObjectsEnum( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDeviceObjects  **ppret)
{
	HRESULT hr;
	hr=C_dxj_DIEnumDeviceObjectsObject::create(m__dxj_DirectInputDevice8,flags,ppret);
	return hr;
}


STDMETHODIMP C_dxj_DirectInputDevice8Object::acquire(){
	return m__dxj_DirectInputDevice8->Acquire();	
}


STDMETHODIMP C_dxj_DirectInputDevice8Object::getCapabilities(DIDEVCAPS_CDESC *caps)
{
	//DIDevCaps same in VB/Java as in C
	caps->lSize=sizeof(DIDEVCAPS);
	HRESULT hr=m__dxj_DirectInputDevice8->GetCapabilities((DIDEVCAPS*)caps);		
	return hr;
}

//VB cant return sucess codes so we will return an error code
#define VB_DI_BUFFEROVERFLOW 0x80040260
        

STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceData(            
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *deviceObjectDataArray,            
            /* [in] */ long flags,
			long *ret)

{
	HRESULT hr;
	
	if ((*deviceObjectDataArray)->cDims!=1) return E_INVALIDARG;
	if ((*deviceObjectDataArray)->cbElements!=sizeof(DIDEVICEOBJECTDATA)) return E_INVALIDARG;
	
	DWORD dwC= (*deviceObjectDataArray)->rgsabound[0].cElements;

	if (dwC==0) return E_INVALIDARG;
	
	LPDIDEVICEOBJECTDATA  pobjData=(LPDIDEVICEOBJECTDATA)((SAFEARRAY*)*deviceObjectDataArray)->pvData;
	hr=m__dxj_DirectInputDevice8->GetDeviceData(sizeof(DIDEVICEOBJECTDATA), pobjData, (DWORD*)&dwC,flags);		
	
	*ret=dwC;

	if (hr==DI_BUFFEROVERFLOW) hr= VB_DI_BUFFEROVERFLOW;
		

	return hr;
}


STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceInfo(        
            /* [out] */ I_dxj_DirectInputDeviceInstance8 __RPC_FAR **info)
{
	HRESULT hr;


	DIDEVICEINSTANCEW inst;
	ZeroMemory(&inst,sizeof(DIDEVICEINSTANCEW));
	inst.dwSize=sizeof(DIDEVICEINSTANCEW);

	hr=m__dxj_DirectInputDevice8->GetDeviceInfo(&inst);
	if FAILED(hr) return hr;

	hr=C_dxj_DIDeviceInstance8Object::create(&inst,info);
	return hr;


}

STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceStateKeyboard(        
            /* [out] */ DIKEYBOARDSTATE_CDESC __RPC_FAR *state)
{
	HRESULT hr;

	if ((nFormat!= dfDIKeyboard) && (nFormat!=-1)) return DIERR_NOTINITIALIZED    ;

	hr=m__dxj_DirectInputDevice8->GetDeviceState(256,(void*)state->key);	
	
	return hr;
}



        
STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceStateMouse( 
            /* [out] */ DIMOUSESTATE_CDESC __RPC_FAR *state)
{
	HRESULT hr;

	if ((nFormat!= dfDIMouse) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;

	hr=m__dxj_DirectInputDevice8->GetDeviceState(sizeof(DIMOUSESTATE),(void*)state);	
	return hr;
}


        
STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceStateMouse2( 
            /* [out] */ DIMOUSESTATE2_CDESC __RPC_FAR *state)
{
	HRESULT hr;

	if ((nFormat!= dfDIMouse2) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;

	hr=m__dxj_DirectInputDevice8->GetDeviceState(sizeof(DIMOUSESTATE2),(void*)state);	
	return hr;
}
        
STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceStateJoystick( 
            /* [out] */ DIJOYSTATE_CDESC __RPC_FAR *state)
{
	HRESULT hr;

	//note Joystick1 or Joystick2 are valid formats since
	//one is a superset of the other
	if ((nFormat!= dfDIJoystick)&&(nFormat!= dfDIJoystick2) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;
	hr=m__dxj_DirectInputDevice8->GetDeviceState(sizeof(DIJOYSTATE),(void*)state);	
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceStateJoystick2( 
            /* [out] */ DIJOYSTATE2_CDESC __RPC_FAR *state)
{
	HRESULT hr;

	//only for format2
	if ((nFormat!= dfDIJoystick2) && (nFormat!=-1)) return DIERR_NOTINITIALIZED;
	hr=m__dxj_DirectInputDevice8->GetDeviceState(sizeof(DIJOYSTATE2),(void*)state);	
	return hr;
}


STDMETHODIMP C_dxj_DirectInputDevice8Object::getDeviceState( 
            /* [in] */ long cb,
            /* [in] */ void *pFormat)

{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectInputDevice8->GetDeviceState((DWORD) cb,(void*)pFormat);	
	}
	__except(1,1){
		hr=E_INVALIDARG;
	}
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::getObjectInfo(                         
            /* [in] */ long obj,
            /* [in] */ long how,
				I_dxj_DirectInputDeviceObjectInstance **ret)
{
	

	DIDEVICEOBJECTINSTANCEW inst;
	ZeroMemory(&inst,sizeof(DIDEVICEOBJECTINSTANCEW));
	inst.dwSize=sizeof(DIDEVICEOBJECTINSTANCEW);

	HRESULT hr;
	hr=m__dxj_DirectInputDevice8->GetObjectInfo(&inst,(DWORD) obj,(DWORD)how);
	if FAILED(hr) return hr;
	
	hr=C_dxj_DIDeviceObjectInstanceObject::create(&inst,ret);

	return hr;

	/* DEAD

	//TODO - consider what is going on here carefully
	if (instCover->strGuidType) SysFreeString(instCover->strGuidType);
	if (instCover->strName) SysFreeString(instCover->strName);

	

	//TODO - consider localization	
	if (inst.tszName){
		instCover->strName=T2BSTR(inst.tszName);
	}

	instCover->strGuidType=DINPUTGUIDtoBSTR(&inst.guidType);
	instCover->lOfs=inst.dwOfs;
	instCover->lType=inst.dwType;
	instCover->lFlags=inst.dwFlags;
	
	instCover->lFFMaxForce=inst.dwFFMaxForce;
	instCover->lFFForceResolution=inst.dwFFForceResolution;
	instCover->nCollectionNumber=inst.wCollectionNumber;
	instCover->nDesignatorIndex=inst.wDesignatorIndex;
	instCover->nUsagePage=inst.wUsagePage;
	instCover->nUsage=inst.wUsage;
	instCover->lDimension=inst.dwDimension;
	instCover->nExponent=inst.wExponent;
	instCover->nReserved=inst.wReserved;
	
	return hr;
	*/
}


 
        
STDMETHODIMP C_dxj_DirectInputDevice8Object::runControlPanel( 
#ifdef _WIN64
									/* [in] */ HWND hwnd)
#else
									/* [in] */ long hwnd)
#endif
{
	HRESULT hr;
        hr=m__dxj_DirectInputDevice8->RunControlPanel((HWND) hwnd,(DWORD)0); 
	return hr;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::setCooperativeLevel( 
#ifdef _WIN64
            /* [in] */ HWND hwnd,
#else
            /* [in] */ long hwnd,
#endif
            /* [in] */ long flags)
{
	HRESULT hr;
        hr=m__dxj_DirectInputDevice8->SetCooperativeLevel((HWND) hwnd,(DWORD)flags); 
	return hr;
}
    
STDMETHODIMP C_dxj_DirectInputDevice8Object::poll()
{
	HRESULT hr;
	hr=m__dxj_DirectInputDevice8->Poll();	
	return hr;
}





    
STDMETHODIMP C_dxj_DirectInputDevice8Object::setCommonDataFormat( 
            /* [in] */ long format)
{
	//variant so that when structs can be packed in VARIANTS we can take care of it
	HRESULT hr;
	
	//	c_dfDIKeyboard 
	//	c_dfDIMouse 
	//	c_dfDIJoystick
	//	c_dfDIJoystick2
	nFormat=format;

	switch(format){
		case dfDIKeyboard:
			hr=m__dxj_DirectInputDevice8->SetDataFormat(&c_dfDIKeyboard);
			break;
		case dfDIMouse:
			hr=m__dxj_DirectInputDevice8->SetDataFormat(&c_dfDIMouse);
			break;
		case dfDIJoystick:
			hr=m__dxj_DirectInputDevice8->SetDataFormat(&c_dfDIJoystick);
			break;
		case dfDIJoystick2:
			hr=m__dxj_DirectInputDevice8->SetDataFormat(&c_dfDIJoystick2);
			break;
		case dfDIMouse2:
			hr=m__dxj_DirectInputDevice8->SetDataFormat(&c_dfDIMouse2);
			break;

		default:
			return E_INVALIDARG;
	}

		
	return hr;
}
        		

STDMETHODIMP C_dxj_DirectInputDevice8Object::setDataFormat( 
            /* [in] */ DIDATAFORMAT_CDESC __RPC_FAR *format,
            SAFEARRAY __RPC_FAR * __RPC_FAR *formatArray)
{
	HRESULT		   hr;
	LPDIDATAFORMAT pFormat=(LPDIDATAFORMAT)format;
	GUID		   *pGuid = NULL;
	GUID		   *pGuidArray = NULL;
	DIOBJECTDATAFORMAT_CDESC	*pDiDataFormat=NULL;


	if ((!format) || (!formatArray)) 
	{
		DPF(1,"------ DXVB: Nothing passed in.. \n");
		return E_INVALIDARG;
	}

	if  (((SAFEARRAY*)*formatArray)->cDims != 1)
	{
		return E_INVALIDARG;
	}
	if (((SAFEARRAY*)*formatArray)->rgsabound[0].cElements < pFormat->dwNumObjs)
	{
		return E_INVALIDARG;
	}

	__try {
		pFormat->dwSize=sizeof(DIDATAFORMAT);
		pFormat->rgodf = NULL;
		pFormat->rgodf = new DIOBJECTDATAFORMAT[pFormat->dwNumObjs];
		
		if (!pFormat->rgodf) 
		{
			DPF(1,"------ DXVB: Out of memory (pFormat->rgodf) \n");
			return E_OUTOFMEMORY;
		}

		pGuidArray=new GUID[pFormat->dwNumObjs];
		if (!pGuidArray){
			DPF(1,"------ DXVB: Out of memory (pGuidArray), Freeing pFormat->rgodf \n");
			SAFE_DELETE(pFormat->rgodf);
			return E_OUTOFMEMORY;
		}

		for (DWORD i=0; i< pFormat->dwNumObjs;i++){
			DPF1(1,"------ DXVB: Filling array item %d \n",i);
			pGuid=&(pGuidArray[i]);
			pDiDataFormat=&(((DIOBJECTDATAFORMAT_CDESC*)((SAFEARRAY*)*formatArray)->pvData)[i]);
			hr=DINPUTBSTRtoGUID(pGuid, pDiDataFormat->strGuid);
			if FAILED(hr) {
				DPF(1,"------ DXVB: DInputBstrToGuid Failed, free memory \n");
				SAFE_DELETE(pGuidArray);
				SAFE_DELETE(pFormat->rgodf);
				pFormat->rgodf=NULL;
				return hr;
			}		
			pFormat->rgodf[i].pguid=pGuid;
			pFormat->rgodf[i].dwOfs=pDiDataFormat->lOfs;
			pFormat->rgodf[i].dwType=pDiDataFormat->lType;
			pFormat->rgodf[i].dwFlags=pDiDataFormat->lFlags;
		}
		DPF(1,"------ DXVB: Call SetDataFormat \n");
		hr=m__dxj_DirectInputDevice8->SetDataFormat(pFormat);
		DPF(1,"------ DXVB: Free Memory \n");

		SAFE_DELETE(pGuidArray);
		SAFE_DELETE(pFormat->rgodf);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		SAFE_DELETE(pGuidArray);
		SAFE_DELETE(pFormat->rgodf);
		return E_INVALIDARG;
	}	


	//indicate we have a custom format
	nFormat=-1;

	return hr;

}
        

#ifdef _WIN64
STDMETHODIMP C_dxj_DirectInputDevice8Object::setEventNotification( 
            /* [in] */ HANDLE hEvent)
#else
STDMETHODIMP C_dxj_DirectInputDevice8Object::setEventNotification( 
            /* [in] */ long hEvent)
#endif
{

	HRESULT hr=m__dxj_DirectInputDevice8->SetEventNotification((HANDLE)hEvent);	
	return hr;
}










//  NOTE: - current working implemtation promotes
//			code bloat
//			might want to revist this and do it in a more
//			tidy fasion
//        
STDMETHODIMP C_dxj_DirectInputDevice8Object::getProperty( 
            /* [in] */ BSTR str,
            /* [out] */ void __RPC_FAR *propertyInfo)
{

	HRESULT hr;		


	if (!propertyInfo) return E_INVALIDARG;

	DIPROPDWORD dipdw;	
	DIPROPRANGE dipr;
	DIPROPSTRING dips;
	
	//For bug #41819
	DIPROPGUIDANDPATH	dipgap;
	DIPROPCPOINTS		dipcp;
	DIPROPPOINTER		dipp;
	//End bug #41819

	dipdw.diph.dwSize=sizeof(DIPROPDWORD);
	dipdw.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipdw.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipdw.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;

	dipr.diph.dwSize=sizeof(DIPROPRANGE);
	dipr.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipr.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipr.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;

	dips.diph.dwSize=sizeof(DIPROPSTRING);
	dips.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dips.diph.dwObj=((DIPROPSTRING_CDESC *)propertyInfo)->lObj;
	dips.diph.dwHow=((DIPROPSTRING_CDESC *)propertyInfo)->lHow;


	//For bug #41819
	dipgap.diph.dwSize=sizeof(DIPROPGUIDANDPATH);
	dipgap.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipgap.diph.dwObj=0;
	dipgap.diph.dwHow=((DIPROPLONG_CDESC *)propertyInfo)->lHow;
	
	dipcp.diph.dwSize=sizeof(DIPROPCPOINTS);
	dipcp.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipcp.diph.dwObj=((DIPROPLONG_CDESC *)propertyInfo)->lObj;
	dipcp.diph.dwHow=((DIPROPLONG_CDESC *)propertyInfo)->lHow;

	dipp.diph.dwSize=sizeof(DIPROPPOINTER);
	dipp.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipp.diph.dwObj=((DIPROPLONG_CDESC *)propertyInfo)->lObj;
	dipp.diph.dwHow=((DIPROPLONG_CDESC *)propertyInfo)->lHow;
	//End bug #41819

	
	if( 0==_wcsicmp(str,L"diprop_buffersize")){
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_BUFFERSIZE,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_axismode")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_AXISMODE,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_granularity")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_GRANULARITY,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;

	}

	//else if( 0==_wcsicmp(str,L"diprop_getlogicalrange")){			
	//		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_GETLOGICALRANGE,(DIPROPHEADER*)&dipr);
	//		((DIPROPRANGE_CDESC*)propertyInfo)->lMin=(long)dipdw.lMin;
	//		((DIPROPRANGE_CDESC*)propertyInfo)->lMax=(long)dipdw.lMax;
	//}

	//else if( 0==_wcsicmp(str,L"diprop_getlogicalrange")){			
	//		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_GETPHYSICALLRANGE,(DIPROPHEADER*)&dipr);
	//		((DIPROPRANGE_CDESC*)propertyInfo)->lMin=(long)dipdw.lMin;
	//		((DIPROPRANGE_CDESC*)propertyInfo)->lMax=(long)dipdw.lMax;
	//}

	else if( 0==_wcsicmp(str,L"diprop_range")){
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_RANGE,(DIPROPHEADER*)&dipr);
			((DIPROPRANGE_CDESC*)propertyInfo)->lMin=(long)dipr.lMin;
			((DIPROPRANGE_CDESC*)propertyInfo)->lMax=(long)dipr.lMax;
	}
	else if( 0==_wcsicmp(str,L"diprop_deadzone")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_DEADZONE,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_ffgain")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_FFGAIN,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_ffload")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_FFLOAD,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_getportdisplayname")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_GETPORTDISPLAYNAME,(DIPROPHEADER*)&dips);
			if FAILED(hr) return hr;
			((DIPROPSTRING_CDESC*)propertyInfo)->PropString=SysAllocString(dips.wsz);
	}
	else if( 0==_wcsicmp(str,L"diprop_instancename")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_INSTANCENAME,(DIPROPHEADER*)&dips);
			if FAILED(hr) return hr;
			((DIPROPSTRING_CDESC*)propertyInfo)->PropString=SysAllocString(dips.wsz);
	}
	else if( 0==_wcsicmp(str,L"diprop_keyname")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_KEYNAME,(DIPROPHEADER*)&dips);
			if FAILED(hr) return hr;
			((DIPROPSTRING_CDESC*)propertyInfo)->PropString=SysAllocString(dips.wsz);
	}
	else if( 0==_wcsicmp(str,L"diprop_productname")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_PRODUCTNAME,(DIPROPHEADER*)&dips);
			if FAILED(hr) return hr;
			((DIPROPSTRING_CDESC*)propertyInfo)->PropString=SysAllocString(dips.wsz);
	}
	else if( 0==_wcsicmp(str,L"diprop_username")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_USERNAME,(DIPROPHEADER*)&dips);
			if FAILED(hr) return hr;
			((DIPROPSTRING_CDESC*)propertyInfo)->PropString=SysAllocString(dips.wsz);
	}

	else if( 0==_wcsicmp(str,L"diprop_saturation")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_SATURATION,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_scancode")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_SCANCODE,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_autocenter")){		
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_AUTOCENTER,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if( 0==_wcsicmp(str,L"diprop_joystickid")){			
			hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_JOYSTICKID,(DIPROPHEADER*)&dipdw);
			((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	
	
//Added for bug #41819

	else if(0==_wcsicmp(str, L"diprop_calibration")){
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_CALIBRATION,(DIPROPHEADER*)&dipdw);
		if (hr == S_OK) ((DIPROPLONG_CDESC*)propertyInfo)->lData=(long)dipdw.dwData;
	}
	else if (0==_wcsicmp(str, L"diprop_guidandpath")){
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_GUIDANDPATH,(DIPROPHEADER*)&dipgap);
		if (hr == S_OK)
		{
			((DIPROPGUIDANDPATH_CDESC*)propertyInfo)->Guid=DINPUTGUIDtoBSTR(&dipgap.guidClass);
			((DIPROPGUIDANDPATH_CDESC*)propertyInfo)->Path=SysAllocString(dipgap.wszPath);
		}
	}
	else if (0==_wcsicmp(str, L"diprop_physicalrange")){
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_PHYSICALRANGE,(DIPROPHEADER*)&dipr);
		if (hr == S_OK)
		{
			((DIPROPRANGE_CDESC*)propertyInfo)->lMin=(long)dipr.lMin;
			((DIPROPRANGE_CDESC*)propertyInfo)->lMax=(long)dipr.lMax;
		}
	}
	else if( 0==_wcsicmp(str,L"diprop_logicalrange")){			
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_LOGICALRANGE,(DIPROPHEADER*)&dipr);
		if (hr == S_OK)
		{
			((DIPROPRANGE_CDESC*)propertyInfo)->lMin=(long)dipr.lMin;
			((DIPROPRANGE_CDESC*)propertyInfo)->lMax=(long)dipr.lMax;
		}
	}
	else if( 0==_wcsicmp(str,L"diprop_cpoints")){			
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_CPOINTS,(DIPROPHEADER*)&dipcp);
		if (hr == S_OK)
		{
			((DIPROPCPOINTS_CDESC*)propertyInfo)->dwCPointsNum=(long)dipcp.dwCPointsNum;			

			__try{
				memcpy( (void*) (((DIPROPCPOINTS_CDESC*)propertyInfo)->cp), (void*)dipcp.cp, sizeof(CPOINT_CDESC) * dipcp.dwCPointsNum);
			}
			__except(1,1){
				return E_INVALIDARG;
			}
		}
	}

	else if(0==_wcsicmp(str,L"diprop_appdata")){
		hr=m__dxj_DirectInputDevice8->GetProperty(DIPROP_APPDATA,(DIPROPHEADER*)&dipp);	
		if (hr == S_OK)
		{
			if FAILED(hr) return hr;
			((DIPROPPOINTER_CDESC*)propertyInfo)->uData=(long)dipp.uData;
		}
	}
	
//End bug #41819

	else { 
			DPF(1, "DXVB: Invalid arguments passed in.\n");
			return E_INVALIDARG;
	}

	/*
	__try{
		((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);	
		hr=m__dxj_DirectInputDevice8->GetProperty((REFGUID)g,(DIPROPHEADER*)propertyInfo);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	*/
	
	if (FAILED(hr))	{
		DPF1(1, "DXVB: GetProperty returned: %d \n", hr);
	}

	return hr;
}



STDMETHODIMP C_dxj_DirectInputDevice8Object::setProperty( 
            /* [in] */ BSTR __RPC_FAR str,
            /* [out] */ void __RPC_FAR *propertyInfo)
{

	if (!propertyInfo) return E_INVALIDARG;

	HRESULT hr;			
	DIPROPDWORD dipdw;
	dipdw.diph.dwSize=sizeof(DIPROPDWORD);
	dipdw.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipdw.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipdw.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;

	DIPROPSTRING dips;
	dips.diph.dwSize=sizeof(DIPROPSTRING);
	dips.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dips.diph.dwObj=((DIPROPSTRING_CDESC *)propertyInfo)->lObj;
	dips.diph.dwHow=((DIPROPSTRING_CDESC *)propertyInfo)->lHow;
		
	DIPROPRANGE dipr;
	dipr.diph.dwSize=sizeof(DIPROPRANGE);
	dipr.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipr.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipr.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;
	

//Added for bug #41819
	DIPROPPOINTER dipp;
	dipp.diph.dwSize=sizeof(DIPROPPOINTER);
	dipp.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipp.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipp.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;

	DIPROPCPOINTS dipcp;
	dipcp.diph.dwSize=sizeof(DIPROPCPOINTS);
	dipcp.diph.dwHeaderSize=sizeof(DIPROPHEADER);
	dipcp.diph.dwObj=((DIPROPLONG_CDESC*)propertyInfo)->lObj;
	dipcp.diph.dwHow=((DIPROPLONG_CDESC*)propertyInfo)->lHow;
//End bug #41819

	if( 0==_wcsicmp(str,L"diprop_buffersize")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_BUFFERSIZE,(DIPROPHEADER*)&dipdw);
	}
	else if( 0==_wcsicmp(str,L"diprop_axismode")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_AXISMODE,(DIPROPHEADER*)&dipdw);		
	}
	else if( 0==_wcsicmp(str,L"diprop_range")){
		dipr.lMin=((DIPROPRANGE_CDESC*)propertyInfo)->lMin;
		dipr.lMax=((DIPROPRANGE_CDESC*)propertyInfo)->lMax;

		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_RANGE,(DIPROPHEADER*)&dipr);		
	}
	else if( 0==_wcsicmp(str,L"diprop_deadzone")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_DEADZONE,(DIPROPHEADER*)&dipdw);		
	}
	else if( 0==_wcsicmp(str,L"diprop_ffgain")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_FFGAIN,(DIPROPHEADER*)&dipdw);		
	}
	else if( 0==_wcsicmp(str,L"diprop_saturation")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_SATURATION,(DIPROPHEADER*)&dipdw);		
	}
	else if( 0==_wcsicmp(str,L"diprop_autocenter")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_AUTOCENTER,(DIPROPHEADER*)&dipdw);		
	}
	else if( 0==_wcsicmp(str,L"diprop_calibrationmode")){
		dipdw.dwData=((DIPROPLONG_CDESC*)propertyInfo)->lData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_CALIBRATIONMODE,(DIPROPHEADER*)&dipdw);		
	}

//Added for bug #41819

	else if( 0==_wcsicmp(str,L"diprop_appdata")){
		dipp.uData=((DIPROPPOINTER_CDESC *)propertyInfo)->uData;
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_APPDATA,(DIPROPHEADER*)&dipp);		
	}
	else if( 0==_wcsicmp(str,L"diprop_instancename")){
		wcscpy(dips.wsz,((DIPROPSTRING_CDESC *)propertyInfo)->PropString);
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_INSTANCENAME,(DIPROPHEADER*)&dips);		
	}
	else if( 0==_wcsicmp(str,L"diprop_productname")){
		wcscpy(dips.wsz, ((DIPROPSTRING_CDESC *)propertyInfo)->PropString);
		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_PRODUCTNAME,(DIPROPHEADER*)&dips);		
	}
	else if( 0==_wcsicmp(str,L"diprop_cpoints")){
		dipcp.dwCPointsNum=((DIPROPCPOINTS_CDESC *)propertyInfo)->dwCPointsNum;
		__try{
			memcpy( (void*)dipcp.cp, (void*)((DIPROPCPOINTS_CDESC*)propertyInfo)->cp, sizeof(CPOINT_CDESC) * MAXCPOINTSNUM);
		}
		__except(1,1){
			DPF(1, "Invalid arguments passed in.\n");
			return E_INVALIDARG;
		}

		hr=m__dxj_DirectInputDevice8->SetProperty(DIPROP_CPOINTS,(DIPROPHEADER*)&dipcp);		
	}
//End bug #41819

	else { 
		DPF(1, "Invalid arguments passed in.\n");
		return E_INVALIDARG;		
	}

	/*
	__try {
		((DIPROPHEADER*)propertyInfo)->dwHeaderSize=sizeof(DIPROPHEADER);
		hr=m__dxj_DirectInputDevice8->SetProperty((REFGUID)g,(DIPROPHEADER*)propertyInfo);
	}
	__except (1,1){
		return E_INVALIDARG;
	}
	*/
	if (FAILED(hr))	{
		DPF1(1, "DXVB: SetProperty returned: %d \n", hr);
	}
	return hr;
}


STDMETHODIMP C_dxj_DirectInputDevice8Object::unacquire()
{
	HRESULT hr=m__dxj_DirectInputDevice8->Unacquire();	
	return hr;
}
        



STDMETHODIMP C_dxj_DirectInputDevice8Object::createEffect( 
            /* [in] */ BSTR effectGuid,
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectInfo,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	GUID g;
	
	DIEFFECT realEffect;
	LPDIRECTINPUTEFFECT pRealEffect=NULL;

	hr=DINPUTBSTRtoGUID(&g,effectGuid);
	if FAILED(hr) return hr;

	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

	hr=m__dxj_DirectInputDevice8->CreateEffect(g,&realEffect,&pRealEffect,NULL);
	if FAILED(hr) return hr;	

	INTERNAL_CREATE(_dxj_DirectInputEffect,pRealEffect,ret)

	return hr;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::createCustomEffect( 
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectInfo,
            /* [in] */ long channels,
            /* [in] */ long samplePeriod,
            /* [in] */ long nSamples,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *sampledata,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	GUID g=GUID_CustomForce;
	
	DIEFFECT realEffect;
	LPDIRECTINPUTEFFECT pRealEffect=NULL;

	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

	
	DICUSTOMFORCE customData;
	customData.cChannels =(DWORD)channels;
	customData.cSamples  =(DWORD)nSamples; 
	customData.dwSamplePeriod =(DWORD)samplePeriod;
	customData.rglForceData = (long*)(*sampledata)->pvData;
	
	realEffect.lpvTypeSpecificParams=&customData;
	realEffect.cbTypeSpecificParams=sizeof(DICUSTOMFORCE);
	
	__try {
		hr=m__dxj_DirectInputDevice8->CreateEffect(g,&realEffect,&pRealEffect,NULL);
	}
	__except(1,1){
		return E_INVALIDARG;
	}
	if FAILED(hr) return hr;	

	INTERNAL_CREATE(_dxj_DirectInputEffect,pRealEffect,ret)

	return hr;
}



        
STDMETHODIMP C_dxj_DirectInputDevice8Object::sendDeviceData( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *data,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *retcount)
{
	DWORD dwCount=count;
	HRESULT hr;
    __try {
		hr=m__dxj_DirectInputDevice8->SendDeviceData(
			sizeof(DIDEVICEOBJECTDATA),
			(DIDEVICEOBJECTDATA*)(*data)->pvData,
			&dwCount,
			(DWORD)flags);

	}
	__except(1,1){
		return E_INVALIDARG;
	}
	return hr;
}    

STDMETHODIMP C_dxj_DirectInputDevice8Object::sendForceFeedbackCommand( 
            /* [in] */ long flags) 
{
	HRESULT hr;
	hr=m__dxj_DirectInputDevice8->SendForceFeedbackCommand((DWORD)flags);
	return hr;
}
        
STDMETHODIMP C_dxj_DirectInputDevice8Object::getForceFeedbackState( 
            /* [retval][out] */ long __RPC_FAR *state)
{
	if (!state) return E_INVALIDARG;
	HRESULT hr;
	hr=m__dxj_DirectInputDevice8->GetForceFeedbackState((DWORD*)state);
	return hr;

}

STDMETHODIMP C_dxj_DirectInputDevice8Object::getEffectsEnum( long effType,
			I_dxj_DirectInputEnumEffects **ret)
{
	HRESULT hr=C_dxj_DirectInputEnumEffectsObject::create(m__dxj_DirectInputDevice8,effType,ret);
	return hr;
}



   
STDMETHODIMP C_dxj_DirectInputDevice8Object::BuildActionMap( 
            /* [out][in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
		BSTR userName,
            /* [in] */ long flags)

{
	HRESULT hr;
	DIACTIONFORMATW frmt;
	hr=FillRealActionFormat(&frmt, format, &(format->ActionArray), format->lActionCount);
	
	if FAILED(hr) return hr;

	hr=m__dxj_DirectInputDevice8->BuildActionMap(&frmt,(WCHAR*)userName,(DWORD) flags);
	return hr;

}
        
STDMETHODIMP C_dxj_DirectInputDevice8Object::SetActionMap( 
            /* [out][in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
            /* [in] */ BSTR username,
            /* [in] */ long flags) 
{
	HRESULT hr;
	DIACTIONFORMATW frmt;

	
	hr=FillRealActionFormat(&frmt, format, &(format->ActionArray), format->lActionCount);
	if FAILED(hr) return hr;

	hr=m__dxj_DirectInputDevice8->SetActionMap(&frmt,(LPWSTR) username,(DWORD) flags);
	return hr;

}


STDMETHODIMP C_dxj_DirectInputDevice8Object::GetImageInfoCount( 
		long *retCount)
{
	HRESULT hr;

	DIDEVICEIMAGEINFOHEADERW RealHeader;
	ZeroMemory(&RealHeader,sizeof(DIDEVICEIMAGEINFOHEADERW));
	RealHeader.dwSize= sizeof(DIDEVICEIMAGEINFOHEADERW);
	RealHeader.dwSizeImageInfo= sizeof(DIDEVICEIMAGEINFOW);

	//figure out how big to make our buffer
	hr=m__dxj_DirectInputDevice8->GetImageInfo(&RealHeader);
	if FAILED(hr) return hr;

	*retCount=RealHeader.dwBufferUsed / sizeof(DIDEVICEIMAGEINFOW);
	return S_OK;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::GetImageInfo( 
            /* [out] */ DIDEVICEIMAGEINFOHEADER_CDESC __RPC_FAR *info)
{
	HRESULT hr;

	if (!info) return E_INVALIDARG;
	DIDEVICEIMAGEINFOHEADERW RealHeader;
	ZeroMemory(&RealHeader,sizeof(DIDEVICEIMAGEINFOHEADERW));
	RealHeader.dwSize= sizeof(DIDEVICEIMAGEINFOHEADERW);
	RealHeader.dwSizeImageInfo= sizeof(DIDEVICEIMAGEINFOW);

	//figure out how big to make our buffer
	hr=m__dxj_DirectInputDevice8->GetImageInfo(&RealHeader);
	if FAILED(hr) return hr;
		
	//allocate the buffer
	RealHeader.lprgImageInfoArray =(DIDEVICEIMAGEINFOW*)malloc(RealHeader.dwBufferSize);
	if (!RealHeader.lprgImageInfoArray) return E_OUTOFMEMORY;	


	//TODO validate that the safe array passed to us is large enough

	info->ImageCount =RealHeader.dwBufferSize / sizeof(DIDEVICEIMAGEINFOW);

	if (info->Images->rgsabound[0].cElements <	(DWORD)info->ImageCount)
	{
		free(RealHeader.lprgImageInfoArray);
		return E_INVALIDARG;
	}
	for (long i =0 ;i<info->ImageCount;i++)
	{
		DIDEVICEIMAGEINFO_CDESC *pInfo=&( ( (DIDEVICEIMAGEINFO_CDESC*)  (info->Images->pvData) )[i]);
		DIDEVICEIMAGEINFOW 	*pRealInfo= &(RealHeader.lprgImageInfoArray[i]);
		pInfo->ImagePath=SysAllocString(pRealInfo->tszImagePath);
		pInfo->Flags=		(long)pRealInfo->dwFlags;
		pInfo->ViewID=		(long)pRealInfo->dwViewID;
		pInfo->ObjId=		(long)pRealInfo->dwObjID;
		pInfo->ValidPts=	(long)pRealInfo->dwcValidPts;
		pInfo->TextAlign=	(long)pRealInfo->dwTextAlign;
		

		memcpy(&(pInfo->OverlayRect),&(pRealInfo->rcOverlay),sizeof(RECT));
		memcpy(&(pInfo->CalloutLine[0]),&(pRealInfo->rgptCalloutLine[0]),sizeof(POINT)*5);
		memcpy(&(pInfo->CalloutRect),&(pRealInfo->rcCalloutRect),sizeof(RECT));
	}

	info->Views=RealHeader.dwcViews;
	info->Buttons=RealHeader.dwcButtons;
	info->Axes=RealHeader.dwcAxes;
	info->POVs=RealHeader.dwcPOVs;
			
	free(RealHeader.lprgImageInfoArray);

	return S_OK;
}



BOOL CALLBACK DIEnumEffectsInFileCallback( LPCDIFILEEFFECT lpDiFileEf, LPVOID pvRef)
{
	HRESULT hr;

	EFFECTSINFILE *pData=(EFFECTSINFILE*)pvRef;

	if (0==lstrcmp(lpDiFileEf->szFriendlyName,pData->szEffect))
	{
		pData->hr=pData->pDev->CreateEffect(
			lpDiFileEf->GuidEffect,
			lpDiFileEf->lpDiEffect,
			&pData->pEff,
			NULL);

		return DIENUM_STOP;
	}

	return DIENUM_CONTINUE;
}

STDMETHODIMP C_dxj_DirectInputDevice8Object::CreateEffectFromFile(
		BSTR filename,
		long flags,
		BSTR effectName,
		I_dxj_DirectInputEffect **ret)
{
	HRESULT hr;
	USES_CONVERSION;
	EFFECTSINFILE data;
	ZeroMemory(&data,sizeof(EFFECTSINFILE));

	data.hr=E_INVALIDARG;	//returned if we dont find the file
	data.pDev=m__dxj_DirectInputDevice8;
	
	if (!effectName) return E_INVALIDARG;
	if (effectName[0]==0) return E_INVALIDARG;

	ZeroMemory(data.szEffect,sizeof(MAX_PATH));
	char *szOut=W2T(effectName);
	strcpy (data.szEffect, szOut);

	hr=m__dxj_DirectInputDevice8->EnumEffectsInFile((WCHAR*)filename,DIEnumEffectsInFileCallback,(void*)&data ,(DWORD)flags);
	if FAILED(hr) return hr;
	if FAILED(data.hr) return data.hr;

	INTERNAL_CREATE(_dxj_DirectInputEffect,data.pEff,ret);

	return hr;
}

        
STDMETHODIMP C_dxj_DirectInputDevice8Object::WriteEffectToFile( 
		BSTR filename, long flags, BSTR guid,BSTR name, DIEFFECT_CDESC *CoverEffect)
{

	USES_CONVERSION;

	
	HRESULT hr;
	DIEFFECT RealEffect;
	DIFILEEFFECT FileEffect;

	if (!filename) return E_INVALIDARG;
	if (!guid) return E_INVALIDARG;
	if (!name) return E_INVALIDARG;
	
	FileEffect.dwSize=sizeof(DIFILEEFFECT);	
	FileEffect.lpDiEffect=&RealEffect;

	ZeroMemory(FileEffect.szFriendlyName,sizeof(MAX_PATH));
	char *szOut=W2T(name);
	strcpy (FileEffect.szFriendlyName, szOut);
	

	hr=DINPUTBSTRtoGUID(&FileEffect.GuidEffect,guid);
	if FAILED(hr) return hr;

	hr=FixUpRealEffect(FileEffect.GuidEffect,&RealEffect,CoverEffect);
	if FAILED(hr) return hr;

	hr=m__dxj_DirectInputDevice8->WriteEffectToFile(
		 (WCHAR*) filename,
		  1,
		  &FileEffect,
		  (DWORD) flags);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dinput1obj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinput1obj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawColorControlObject


#include "resource.h"       // main symbols

#define typedef__dxj_DirectInput8 LPDIRECTINPUT8W

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInput8Object : 
	public I_dxj_DirectInput8,
	public CComObjectRoot
{
public:
	C_dxj_DirectInput8Object() ;
	virtual ~C_dxj_DirectInput8Object();

BEGIN_COM_MAP(C_dxj_DirectInput8Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectInput8)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInput8Object)


public:
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        HRESULT STDMETHODCALLTYPE createDevice( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ I_dxj_DirectInputDevice8 __RPC_FAR *__RPC_FAR *dev);
        
        HRESULT STDMETHODCALLTYPE getDIDevices( 
            /* [in] */ long deviceType,
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDevices8 __RPC_FAR *__RPC_FAR *retVal);
        
        HRESULT STDMETHODCALLTYPE GetDeviceStatus( 
            /* [in] */ BSTR guid,
            /* [retval][out] */ VARIANT_BOOL *status);
        
#ifdef _WIN64
		HRESULT STDMETHODCALLTYPE RunControlPanel( 
            /* [in] */ HWND hwndOwner
            ///* [in] */ long flags
			);
#else
		HRESULT STDMETHODCALLTYPE RunControlPanel( 
            /* [in] */ LONG hwndOwner
            ///* [in] */ long flags
			);
#endif
                

	HRESULT STDMETHODCALLTYPE getDevicesBySemantics( 
        	/* [in] */ BSTR str1,
	        /* [in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
        	
	        /* [in] */ long flags,
        	/* [retval][out] */ I_dxj_DIEnumDevices8 __RPC_FAR *__RPC_FAR *ret);
		
	HRESULT STDMETHODCALLTYPE ConfigureDevices   (
#ifdef _WIN64
					HANDLE hEvent,
#else
					long hEvent,
#endif
				   DICONFIGUREDEVICESPARAMS_CDESC *CDParams,
				   long flags);   							


private:
    DECL_VARIABLE(_dxj_DirectInput8);

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInput8)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dinputdeviceobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dinputdeviceobj.h
//
//--------------------------------------------------------------------------

	// ddPaletteObj.h : Declaration of the C_dxj_DirectDrawColorControlObject
#include "direct.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectInputDevice8 LPDIRECTINPUTDEVICE8W

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInputDevice8Object : 
	public I_dxj_DirectInputDevice8,	
	public CComObjectRoot
{
public:
	C_dxj_DirectInputDevice8Object() ;
	~C_dxj_DirectInputDevice8Object();

BEGIN_COM_MAP(C_dxj_DirectInputDevice8Object)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputDevice8)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputDevice8Object)


public:
	/* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
        /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE acquire( void);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceObjectsEnum( 
            /* [in] */ long flags,
            /* [retval][out] */ I_dxj_DIEnumDeviceObjects __RPC_FAR *__RPC_FAR *ppret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getCapabilities( 
            /* [out][in] */ DIDEVCAPS_CDESC __RPC_FAR *caps);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceData( 
            /* [out][in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *deviceObjectDataArray,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *c);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceInfo( 
            /* [retval][out] */ I_dxj_DirectInputDeviceInstance8 __RPC_FAR *__RPC_FAR *deviceInstance);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceStateKeyboard( 
            /* [out][in] */ DIKEYBOARDSTATE_CDESC __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceStateMouse( 
            /* [out][in] */ DIMOUSESTATE_CDESC __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceStateMouse2( 
            /* [out][in] */ DIMOUSESTATE2_CDESC __RPC_FAR *state);

        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceStateJoystick( 
            /* [out][in] */ DIJOYSTATE_CDESC __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceStateJoystick2( 
            /* [out][in] */ DIJOYSTATE2_CDESC __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getDeviceState( 
            /* [in] */ long cb,
            /* [in] */ void __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getObjectInfo( 
            /* [in] */ long obj,
            /* [in] */ long how,
            /* [retval][out] */ I_dxj_DirectInputDeviceObjectInstance __RPC_FAR *__RPC_FAR *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR guid,
            /* [out] */ void __RPC_FAR *propertyInfo);
        
#ifdef _WIN64
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE runControlPanel( 
	    /* [in] */ HWND hwnd);

	    /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ HWND hwnd,
            /* [in] */ long flags);
#else
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE runControlPanel( 
	    /* [in] */ long hwnd);

	    /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setCooperativeLevel( 
            /* [in] */ long hwnd,
            /* [in] */ long flags);
#endif
        
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setCommonDataFormat( 
            /* [in] */ long format);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setDataFormat( 
            /* [in] */ DIDATAFORMAT_CDESC __RPC_FAR *format,
            SAFEARRAY __RPC_FAR * __RPC_FAR *formatArray);
        
#ifdef _WIN64
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setEventNotification( 
            /* [in] */ HANDLE hEvent);
#else
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setEventNotification( 
            /* [in] */ long hEvent);
#endif
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE setProperty( 
            /* [in] */ BSTR guid,
            /* [in] */ void __RPC_FAR *propertyInfo);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE unacquire( void);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE poll( void);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE createEffect( 
            /* [in] */ BSTR effectGuid,
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectinfo,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE createCustomEffect( 
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectinfo,
            /* [in] */ long channels,
            /* [in] */ long samplePeriod,
            /* [in] */ long nSamples,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *sampledata,
            /* [retval][out] */ I_dxj_DirectInputEffect __RPC_FAR *__RPC_FAR *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE sendDeviceData( 
            /* [in] */ long count,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *data,
            /* [in] */ long flags,
            /* [retval][out] */ long __RPC_FAR *retcount);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE sendForceFeedbackCommand( 
            /* [in] */ long flags);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getForceFeedbackState( 
            /* [retval][out] */ long __RPC_FAR *state);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE getEffectsEnum( 
            /* [in] */ long effType,
            /* [retval][out] */ I_dxj_DirectInputEnumEffects __RPC_FAR *__RPC_FAR *ret);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE BuildActionMap( 
            /* [out][in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
            /* [in] */ BSTR username,
            /* [in] */ long flags);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE SetActionMap( 
            /* [out][in] */ DIACTIONFORMAT_CDESC __RPC_FAR *format,
            /* [in] */ BSTR username,
            /* [in] */ long flags);
        
        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE GetImageInfo( 
            /* [out] */ DIDEVICEIMAGEINFOHEADER_CDESC __RPC_FAR *info);

        /* [helpcontext] */ HRESULT STDMETHODCALLTYPE GetImageInfoCount( 
			long *count);

        
	 HRESULT STDMETHODCALLTYPE WriteEffectToFile( 
		/*[in]*/ BSTR filename,
		/*[in]*/ long flags,
		/*[in]*/ BSTR guid, 
		/*[in]*/ BSTR name, 
		/*[in]*/ DIEFFECT_CDESC *CoverEffect);

	HRESULT STDMETHODCALLTYPE CreateEffectFromFile(
		/*[in]*/ BSTR filename, 
		/*[in]*/ long flags, 
		/*[in]*/ BSTR effectName,
		/*[out,retval]*/	I_dxj_DirectInputEffect **ret);
        

private:
        DECL_VARIABLE(_dxj_DirectInputDevice8);
	//IDirectInputDevice8 *m__dxj_DirectInputDevice8;	
	HRESULT cleanup();
	HRESULT init();
public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInputDevice8)
	DWORD	nFormat;
};

typedef struct EFFECTSINFILE
{
	char szEffect[MAX_PATH];
	IDirectInputDevice8W 	*pDev;
	IDirectInputEffect 	*pEff;
	HRESULT 		hr;	
} EFFECTSINFILE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dinputeffectobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dinputeffectobj.h
//
//--------------------------------------------------------------------------

	

#include "resource.h"       // main symbols
extern void* g_dxj_DirectInputEffect;

#define typedef__dxj_DirectInputEffect LPDIRECTINPUTEFFECT

/////////////////////////////////////////////////////////////////////////////
// Direct


class C_dxj_DirectInputEffectObject : 
	public I_dxj_DirectInputEffect,
	public CComObjectRoot
{
public:
	C_dxj_DirectInputEffectObject() ;
	virtual ~C_dxj_DirectInputEffectObject();

BEGIN_COM_MAP(C_dxj_DirectInputEffectObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectInputEffect)
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectInputEffectObject)


public:
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd) ;
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd) ;
        
         HRESULT STDMETHODCALLTYPE download( void) ;
        
         HRESULT STDMETHODCALLTYPE getEffectGuid( 
            /* [retval][out] */ BSTR *guid) ;
        
         HRESULT STDMETHODCALLTYPE getEffectStatus( 
            /* [retval][out] */ long __RPC_FAR *ret) ;
        
         HRESULT STDMETHODCALLTYPE start( 
            /* [in] */ long iterations,
            /* [in] */ long flags) ;
        
         HRESULT STDMETHODCALLTYPE stop( void) ;
        
         HRESULT STDMETHODCALLTYPE unload( void) ;
        
         HRESULT STDMETHODCALLTYPE setParameters( 
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectinfo, long flags) ;
        
         HRESULT STDMETHODCALLTYPE getParameters( 
            /* [out][in] */ DIEFFECT_CDESC __RPC_FAR *effectinfo) ;
        
   
             

private:
    DECL_VARIABLE(_dxj_DirectInputEffect);

public:
	DX3J_GLOBAL_LINKS(_dxj_DirectInputEffect);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmchordmapobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmchordmapobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"


extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicChordMap, {});
DESTRUCTOR(_dxj_DirectMusicChordMap, {});
GETSET_OBJECT(_dxj_DirectMusicChordMap);


	

HRESULT C_dxj_DirectMusicChordMapObject::getScale(long *scale)
{  
	HRESULT hr;				
	hr=m__dxj_DirectMusicChordMap->GetScale((DWORD*)scale);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dinputeffectobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dinputeffectobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dInputEffectObj.h"

extern HRESULT FixUpCoverEffect(GUID g, DIEFFECT_CDESC *cover,DIEFFECT *realEffect);
extern HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEFFECT_CDESC *cover);
extern BSTR DINPUTGUIDtoBSTR(LPGUID g);

CONSTRUCTOR(_dxj_DirectInputEffect, {});
DESTRUCTOR(_dxj_DirectInputEffect, {});
GETSET_OBJECT(_dxj_DirectInputEffect);
                                  
   
STDMETHODIMP C_dxj_DirectInputEffectObject::download()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Download();
	return hr;
}

STDMETHODIMP C_dxj_DirectInputEffectObject::getEffectGuid(BSTR *guid)
{
	HRESULT hr;
	GUID g;
	if (!guid) return E_INVALIDARG;
    hr=m__dxj_DirectInputEffect->GetEffectGuid(&g);
	*guid=DINPUTGUIDtoBSTR(&g);
	return hr;
}

   
STDMETHODIMP C_dxj_DirectInputEffectObject::getEffectStatus(long *ret)
{
	HRESULT hr;
	if (!ret) return E_INVALIDARG;
    hr=m__dxj_DirectInputEffect->GetEffectStatus((DWORD*)ret);
	return hr;
}

STDMETHODIMP C_dxj_DirectInputEffectObject::start(
			/* [in] */ long iterations,
            /* [in] */ long flags) 
     
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Start((DWORD)iterations,(DWORD)flags);
	return hr;
}


STDMETHODIMP C_dxj_DirectInputEffectObject::stop()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Stop();
	return hr;
}


STDMETHODIMP C_dxj_DirectInputEffectObject::unload()
{
	HRESULT hr;
    hr=m__dxj_DirectInputEffect->Unload();
	return hr;
}
         
STDMETHODIMP C_dxj_DirectInputEffectObject::setParameters( 
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectInfo, long flags) 
{
	DIEFFECT realEffect;
	HRESULT hr;
	GUID g;
	m__dxj_DirectInputEffect->GetEffectGuid(&g);
	
	hr=FixUpRealEffect(g,&realEffect,effectInfo);
	if FAILED(hr) return hr;

    hr=m__dxj_DirectInputEffect->SetParameters(&realEffect,(DWORD) flags);
	return hr;
}

#define DICONDITION_USE_BOTH_AXIS 1
#define DICONDITION_USE_DIRECTION 2


STDMETHODIMP C_dxj_DirectInputEffectObject::getParameters( 
            /* [in] */ DIEFFECT_CDESC __RPC_FAR *effectInfo) 
{
	
	HRESULT hr;
	GUID g;
	DIEFFECT *pRealEffect=(DIEFFECT*)effectInfo;
	DWORD dwFlags= DIEP_ALLPARAMS;
	
 
	if (!effectInfo) return E_INVALIDARG;



	ZeroMemory(pRealEffect,sizeof(DIEFFECT_CDESC));
	if (!pRealEffect->dwFlags) pRealEffect->dwFlags = DIEFF_OBJECTOFFSETS | DIEFF_POLAR;
	pRealEffect->dwSize =sizeof(DIEFFECT);
	pRealEffect->lpEnvelope =(DIENVELOPE*)&(effectInfo->envelope);
	pRealEffect->lpEnvelope->dwSize=sizeof(DIENVELOPE);
	pRealEffect->cAxes = 2;
	pRealEffect->rglDirection =(long*)&(effectInfo->x);
	
	hr=m__dxj_DirectInputEffect->GetEffectGuid(&g);
	if FAILED(hr) return hr;
			
	if (g==GUID_ConstantForce)
	{
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->constantForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DICONSTANTFORCE);		
	}		
	else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
	{
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->periodicForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DIPERIODIC);				
	}
	else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){		
			pRealEffect->cbTypeSpecificParams =sizeof(DICONDITION)*2;
			pRealEffect->lpvTypeSpecificParams =&(effectInfo->conditionX);
	}	
	else if (g==GUID_RampForce){		
		pRealEffect->lpvTypeSpecificParams =&(effectInfo->rampForce);
		pRealEffect->cbTypeSpecificParams =sizeof(DIRAMPFORCE);				
	}
	else {
		pRealEffect->lpvTypeSpecificParams =NULL;
		pRealEffect->cbTypeSpecificParams =0;
		dwFlags= dwFlags -DIEP_TYPESPECIFICPARAMS;
	}


	effectInfo->axisOffsets.x=DIJOFS_X;
	effectInfo->axisOffsets.y=DIJOFS_Y;
	pRealEffect->rgdwAxes=(DWORD*)&(effectInfo->axisOffsets);

	hr=m__dxj_DirectInputEffect->GetParameters(pRealEffect, dwFlags);

	if FAILED(hr) return hr;

	if (pRealEffect->cbTypeSpecificParams =sizeof(DICONDITION)*2)
		effectInfo->conditionFlags=DICONDITION_USE_BOTH_AXIS;
	else
		effectInfo->conditionFlags=DICONDITION_USE_DIRECTION;

	if (pRealEffect->lpEnvelope){
		effectInfo->bUseEnvelope=VARIANT_TRUE;
	}
	
	    
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmcollectionobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcollectionobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmCollectionObj.h"


extern void *g_dxj_DirectMusicCollection;


CONSTRUCTOR(_dxj_DirectMusicCollection, {});
DESTRUCTOR(_dxj_DirectMusicCollection, {});
GETSET_OBJECT(_dxj_DirectMusicCollection);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmcomposerobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcomposerobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"
#include "dmStyleObj.h"
#include "dmComposerObj.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicComposer;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicComposer, {});
DESTRUCTOR(_dxj_DirectMusicComposer, {});
GETSET_OBJECT(_dxj_DirectMusicComposer);

typedef IDirectMusicSegment*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance*	LPDIRECTMUSICPERFORMANCE;
typedef IDirectMusicChordMap*		LPDIRECTMUSICCHORDMAP;
typedef IDirectMusicStyle*			LPDIRECTMUSICSTYLE;

HRESULT C_dxj_DirectMusicComposerObject::autoTransition( 
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *Performance,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppTransSeg)
{
	HRESULT hr;			
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPERFORMANCE, pPerf,Performance);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pToSeg,ToSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->AutoTransition(pPerf,pToSeg,(WORD)lCommand,(DWORD)lFlags,pMap,&pNewSeg,NULL,NULL);
	if FAILED(hr) return hr;
	if (pNewSeg)	{
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,ppTransSeg);
	}
	else{
		*ppTransSeg=NULL;
	}

	return hr;
}

HRESULT C_dxj_DirectMusicComposerObject::composeSegmentFromTemplate( 
		/* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *TemplateSeg,
        /* [in] */ short activity,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSTYLE, pStyle,style);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pTemp,TemplateSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeSegmentFromTemplate(pStyle,pTemp,activity,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}

HRESULT C_dxj_DirectMusicComposerObject::composeSegmentFromShape( 
        /* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ short numberOfMeasures,
        /* [in] */ short shape,
        /* [in] */ short activity,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;	
	
	BOOL bi= (bIntro==VARIANT_TRUE);
	BOOL be= (bEnd==VARIANT_TRUE);

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSTYLE, pStyle,style);	
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeSegmentFromShape(pStyle,numberOfMeasures,shape,activity,bi,be,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}



HRESULT C_dxj_DirectMusicComposerObject::composeTransition( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *FromSeg,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long mtTime,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pFromSeg,FromSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pToSeg,ToSeg);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,chordmap);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeTransition(pFromSeg,pToSeg,(MUSIC_TIME)mtTime,(WORD)lCommand,(DWORD)lFlags,pMap,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,SectionSeg);

	return hr;
}
    


HRESULT C_dxj_DirectMusicComposerObject::composeTemplateFromShape( 
        /* [in] */ short numMeasures,
        /* [in] */ short shape,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ short endLength,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *TempSeg)
{
	HRESULT hr;		
	BOOL bi=(bIntro==VARIANT_TRUE);
	BOOL be=(bEnd==VARIANT_TRUE);
	LPDIRECTMUSICSEGMENT pNewSeg=NULL;
	
	hr=m__dxj_DirectMusicComposer->ComposeTemplateFromShape(numMeasures,shape,bi,be,endLength,&pNewSeg);
	if FAILED(hr) return hr;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pNewSeg,TempSeg);

	return hr;
}
        


HRESULT C_dxj_DirectMusicComposerObject::changeChordMap( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ VARIANT_BOOL trackScale,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR  *ChordMap)
{
	HRESULT hr;		
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT, pSeg,segment);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICCHORDMAP, pMap,ChordMap);
	BOOL bs=(trackScale==VARIANT_TRUE);	

	
	hr=m__dxj_DirectMusicComposer->ChangeChordMap(pSeg,bs,pMap);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\directxhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       directxhelp.h
//
//--------------------------------------------------------------------------

#ifndef __VBHELP_CAFD484C_C86F_11D2_A5A6_00C04FB92CC1_DEFINED__
#define __VBHELP_CAFD484C_C86F_11D2_A5A6_00C04FB92CC1_DEFINED__

#define _vbd3drm_Direct3DRMAnimation2 867001                                        //  Direct3DRMAnimation2
#define _vbd3drm_Direct3DRMAnimationArray 867002                                    //  Direct3DRMAnimationArray
#define _vbd3drm_Direct3DRMAnimationSet2 867003                                     //  Direct3DRMAnimationSet2
#define _vbd3drm_Visual_Basic_Callback_Interfaces 867004                            //  Visual Basic Callback Interfaces
#define _vbd3drm_Direct3DRMClippedVisual 867005                                     //  Direct3DRMClippedVisual
#define _vbd3drm_Direct3DRMDevice3 867006                                           //  Direct3DRMDevice3
#define _vbd3drm_Direct3DRMDeviceArray 867007                                       //  Direct3DRMDeviceArray
#define _vbd3drm_Visual_Basic_Enumerations 867008                                   //  Visual Basic Enumerations
#define _vbd3drm_Direct3DRMFace2 867009                                             //  Direct3DRMFace2
#define _vbd3drm_Direct3DRMFaceArray 867010                                         //  Direct3DRMFaceArray
#define _vbd3drm_Direct3DRMFrame3_Methods_A_to_M 867011                             //  Direct3DRMFrame3 Methods A to M
#define _vbd3drm_Direct3DRMFrame3_Methods_N_to_Z 867012                             //  Direct3DRMFrame3 Methods N to Z
#define _vbd3drm_Direct3DRMFrame3 867013                                            //  Direct3DRMFrame3
#define _vbd3drm_Direct3DRMFrameArray 867014                                        //  Direct3DRMFrameArray
#define _vbd3drm_Direct3DRMFrameInterpolator 867015                                 //  Direct3DRMFrameInterpolator
#define _vbd3drm_Further_Reading_for_Visual_Basic_Programmers 867016                //  Further Reading for Visual Basic Programmers
#define _vbd3drm_Direct3DRM3 867017                                                 //  Direct3DRM3
#define _vbd3drm_Visual_Basic_Interfaces 867018                                     //  Visual Basic Interfaces
#define _vbd3drm_Direct3DRMLight 867019                                             //  Direct3DRMLight
#define _vbd3drm_Direct3DRMLightArray 867020                                        //  Direct3DRMLightArray
#define _vbd3drm_Direct3DRMLightInterpolator 867021                                 //  Direct3DRMLightInterpolator
#define _vbd3drm_Direct3DRMMaterial2 867022                                         //  Direct3DRMMaterial2
#define _vbd3drm_Direct3DRMMaterialInterpolator 867023                              //  Direct3DRMMaterialInterpolator
#define _vbd3drm_Direct3DRMMesh 867024                                              //  Direct3DRMMesh
#define _vbd3drm_Direct3DRMMeshBuilder3 867025                                      //  Direct3DRMMeshBuilder3
#define _vbd3drm_Direct3DRMMeshInterpolator 867026                                  //  Direct3DRMMeshInterpolator
#define _vbd3drm_Direct3DRMObject 867027                                            //  Direct3DRMObject
#define _vbd3drm_Direct3DRMObjectArray 867028                                       //  Direct3DRMObjectArray
#define _vbd3drm_Direct3DRMPick2Array 867029                                        //  Direct3DRMPick2Array
#define _vbd3drm_Direct3DRMPickArray 867030                                         //  Direct3DRMPickArray
#define _vbd3drm_Direct3DRMProgressiveMesh 867031                                   //  Direct3DRMProgressiveMesh
#define _vbd3drm_Reference 867032                                                   //  Reference
#define _D3DRM_Error_Values 867033                                                  //  Visual Basic Error Values
#define _vbd3drm_Direct3DRMShadow2 867034                                           //  Direct3DRMShadow2
#define _vbd3drm_Visual_Basic_Types 867035                                          //  Visual Basic Types
#define _vbd3drm_Direct3DRMTexture3 867036                                          //  Direct3DRMTexture3
#define _vbd3drm_Direct3DRMTextureInterpolator 867037                               //  Direct3DRMTextureInterpolator
#define _vbd3drm_Direct3DRMUserVisual 867038                                        //  Direct3DRMUserVisual
#define _vbd3drm_Direct3DRMViewport2 867039                                         //  Direct3DRMViewport2
#define _vbd3drm_Direct3DRMViewportArray 867040                                     //  Direct3DRMViewportArray
#define _vbd3drm_Direct3DRMViewportInterpolator 867041                              //  Direct3DRMViewportInterpolator
#define _vbd3drm_Direct3DRMVisual 867042                                            //  Direct3DRMVisual
#define _vbd3drm_Direct3DRMVisualArray 867043                                       //  Direct3DRMVisualArray
#define _vbd3drm_Direct3DRMWrap 867044                                              //  Direct3DRMWrap
#define idh__dx_direct3d3_d3d_vb 867045                                             //  Direct3D3
#define idh__dx_direct3d3_createdevice_d3d_vb 867046                                //  Direct3D3.CreateDevice
#define idh__dx_direct3d3_createlight_d3d_vb 867047                                 //  Direct3D3.CreateLight
#define idh__dx_direct3d3_creatematerial_d3d_vb 867048                              //  Direct3D3.CreateMaterial
#define idh__dx_direct3d3_createvertexbuffer_d3d_vb 867049                          //  Direct3D3.CreateVertexBuffer
#define idh__dx_direct3d3_createviewport_d3d_vb 867050                              //  Direct3D3.CreateViewport
#define idh__dx_direct3d3_evictmanagedtextures_d3d_vb 867051                        //  Direct3D3.EvictManagedTextures
#define idh__dx_direct3d3_finddevice_d3d_vb 867052                                  //  Direct3D3.FindDevice
#define idh__dx_direct3d3_getdevicesenum_d3d_vb 867053                              //  Direct3D3.GetDevicesEnum
#define idh__dx_direct3d3_getdirectdraw_d3d_vb 867054                               //  Direct3D3.GetDirectDraw
#define idh__dx_direct3d3_getenumzbufferformats_d3d_vb 867055                       //  Direct3D3.GetEnumZBufferFormats
#define idh__dx_direct3ddevice3_d3d_vb 867056                                       //  Direct3DDevice3
#define idh__dx_direct3ddevice3_addviewport_d3d_vb 867057                           //  Direct3DDevice3.AddViewport
#define idh__dx_direct3ddevice3_begin_d3d_vb 867058                                 //  Direct3DDevice3.Begin
#define idh__dx_direct3ddevice3_beginindexed_d3d_vb 867059                          //  Direct3DDevice3.BeginIndexed
#define idh__dx_direct3ddevice3_beginscene_d3d_vb 867060                            //  Direct3DDevice3.BeginScene
#define idh__dx_direct3ddevice3_computespherevisibility_d3d_vb 867061               //  Direct3DDevice3.ComputeSphereVisibility
#define idh__dx_direct3ddevice3_deleteviewport_d3d_vb 867062                        //  Direct3DDevice3.DeleteViewport
#define idh__dx_direct3ddevice3_drawindexedprimitive_d3d_vb 867063                  //  Direct3DDevice3.DrawIndexedPrimitive
#define idh__dx_direct3ddevice3_drawindexedprimitivevb_d3d_vb 867064                //  Direct3DDevice3.DrawIndexedPrimitiveVB
#define idh__dx_direct3ddevice3_drawprimitive_d3d_vb 867065                         //  Direct3DDevice3.DrawPrimitive
#define idh__dx_direct3ddevice3_drawprimitivevb_d3d_vb 867066                       //  Direct3DDevice3.DrawPrimitiveVB
#define idh__dx_direct3ddevice3_end_d3d_vb 867067                                   //  Direct3DDevice3.End
#define idh__dx_direct3ddevice3_endscene_d3d_vb 867068                              //  Direct3DDevice3.EndScene
#define idh__dx_direct3ddevice3_getcaps_d3d_vb 867069                               //  Direct3DDevice3.GetCaps
#define idh__dx_direct3ddevice3_getclipstatus_d3d_vb 867070                         //  Direct3DDevice3.GetClipStatus
#define idh__dx_direct3ddevice3_getcurrentviewport_d3d_vb 867071                    //  Direct3DDevice3.GetCurrentViewport
#define idh__dx_direct3ddevice3_getdirect3d_d3d_vb 867072                           //  Direct3DDevice3.GetDirect3D
#define idh__dx_direct3ddevice3_getlightstate_d3d_vb 867073                         //  Direct3DDevice3.GetLightState
#define idh__dx_direct3ddevice3_getrenderstate_d3d_vb 867074                        //  Direct3DDevice3.GetRenderState
#define idh__dx_direct3ddevice3_getrendertarget_d3d_vb 867075                       //  Direct3DDevice3.GetRenderTarget
#define idh__dx_direct3ddevice3_getstats_d3d_vb 867076                              //  Direct3DDevice3.GetStats
#define idh__dx_direct3ddevice3_gettexture_d3d_vb 867077                            //  Direct3DDevice3.GetTexture
#define idh__dx_direct3ddevice3_gettextureformatsenum_d3d_vb 867078                 //  Direct3DDevice3.GetTextureFormatsEnum
#define idh__dx_direct3ddevice3_gettexturestagestate_d3d_vb 867079                  //  Direct3DDevice3.GetTextureStageState
#define idh__dx_direct3ddevice3_gettransform_d3d_vb 867080                          //  Direct3DDevice3.GetTransform
#define idh__dx_direct3ddevice3_index_d3d_vb 867081                                 //  Direct3DDevice3.Index
#define idh__dx_direct3ddevice3_multiplytransform_d3d_vb 867082                     //  Direct3DDevice3.MultiplyTransform
#define idh__dx_direct3ddevice3_nextviewport_d3d_vb 867083                          //  Direct3DDevice3.NextViewport
#define idh__dx_direct3ddevice3_setclipstatus_d3d_vb 867084                         //  Direct3DDevice3.SetClipStatus
#define idh__dx_direct3ddevice3_setcurrentviewport_d3d_vb 867085                    //  Direct3DDevice3.SetCurrentViewport
#define idh__dx_direct3ddevice3_setlightstate_d3d_vb 867086                         //  Direct3DDevice3.SetLightState
#define idh__dx_direct3ddevice3_setrenderstate_d3d_vb 867087                        //  Direct3DDevice3.SetRenderState
#define idh__dx_direct3ddevice3_setrendertarget_d3d_vb 867088                       //  Direct3DDevice3.SetRenderTarget
#define idh__dx_direct3ddevice3_settexture_d3d_vb 867089                            //  Direct3DDevice3.SetTexture
#define idh__dx_direct3ddevice3_settexturestagestate_d3d_vb 867090                  //  Direct3DDevice3.SetTextureStageState
#define idh__dx_direct3ddevice3_settransform_d3d_vb 867091                          //  Direct3DDevice3.SetTransform
#define idh__dx_direct3ddevice3_validatedevice_d3d_vb 867092                        //  Direct3DDevice3.ValidateDevice
#define idh__dx_direct3ddevice3_vertex_d3d_vb 867093                                //  Direct3DDevice3.Vertex
#define idh__dx_direct3denumdevices_d3d_vb 867094                                   //  Direct3DEnumDevices
#define idh__dx_direct3denumdevices_getcount_d3d_vb 867095                          //  Direct3DEnumDevices.GetCount
#define idh__dx_direct3denumdevices_getdescription_d3d_vb 867096                    //  Direct3DEnumDevices.GetDescription
#define idh__dx_direct3denumdevices_getguid_d3d_vb 867097                           //  Direct3DEnumDevices.GetGuid
#define idh__dx_direct3denumdevices_getheldesc_d3d_vb 867098                        //  Direct3DEnumDevices.GetHELDesc
#define idh__dx_direct3denumdevices_gethwdesc_d3d_vb 867099                         //  Direct3DEnumDevices.GetHWDesc
#define idh__dx_direct3denumdevices_getname_d3d_vb 867100                           //  Direct3DEnumDevices.GetName
#define idh__dx_direct3denumpixelformats_d3d_vb 867101                              //  Direct3DEnumPixelFormats
#define idh__dx_direct3denumpixelformats_getcount_d3d_vb 867102                     //  Direct3DEnumPixelFormats.GetCount
#define idh__dx_direct3denumpixelformats_getitem_d3d_vb 867103                      //  Direct3DEnumPixelFormats.GetItem
#define idh__dx_direct3dlight_d3d_vb 867104                                         //  Direct3DLight
#define idh__dx_direct3dlight_getlight_d3d_vb 867105                                //  Direct3DLight.GetLight
#define idh__dx_direct3dlight_setlight_d3d_vb 867106                                //  Direct3DLight.SetLight
#define idh__dx_direct3dmaterial3_d3d_vb 867107                                     //  Direct3DMaterial3
#define idh__dx_direct3dmaterial3_gethandle_d3d_vb 867108                           //  Direct3DMaterial3.GetHandle
#define idh__dx_direct3dmaterial3_getmaterial_d3d_vb 867109                         //  Direct3DMaterial3.GetMaterial
#define idh__dx_direct3dmaterial3_setmaterial_d3d_vb 867110                         //  Direct3DMaterial3.SetMaterial
#define idh__dx_direct3dtexture2_d3d_vb 867111                                      //  Direct3DTexture2
#define idh__dx_direct3dtexture2_gethandle_d3d_vb 867112                            //  Direct3DTexture2.GetHandle
#define idh__dx_direct3dtexture2_getsurface_d3d_vb 867113                           //  Direct3DTexture2.GetSurface
#define idh__dx_direct3dtexture2_load_d3d_vb 867114                                 //  Direct3DTexture2.Load
#define idh__dx_direct3dtexture2_palettechanged_d3d_vb 867115                       //  Direct3DTexture2.PaletteChanged
#define idh__dx_direct3dvertexbuffer_d3d_vb 867116                                  //  Direct3DVertexBuffer
#define idh__dx_direct3dvertexbuffer_getvertexbufferdesc_d3d_vb 867117              //  Direct3DVertexBuffer.GetVertexBufferDesc
#define idh__dx_direct3dvertexbuffer_getvertices_d3d_vb 867118                      //  Direct3DVertexBuffer.GetVertices
#define idh__dx_direct3dvertexbuffer_lock_d3d_vb 867119                             //  Direct3DVertexBuffer.Lock
#define idh__dx_direct3dvertexbuffer_optimize_d3d_vb 867120                         //  Direct3DVertexBuffer.Optimize
#define idh__dx_direct3dvertexbuffer_processvertices_d3d_vb 867121                  //  Direct3DVertexBuffer.ProcessVertices
#define idh__dx_direct3dvertexbuffer_setvertices_d3d_vb 867122                      //  Direct3DVertexBuffer.SetVertices
#define idh__dx_direct3dvertexbuffer_unlock_d3d_vb 867123                           //  Direct3DVertexBuffer.Unlock
#define idh__dx_direct3dviewport3_d3d_vb 867124                                     //  Direct3DViewport3
#define idh__dx_direct3dviewport3_addlight_d3d_vb 867125                            //  Direct3DViewport3.AddLight
#define idh__dx_direct3dviewport3_clear_d3d_vb 867126                               //  Direct3DViewport3.Clear
#define idh__dx_direct3dviewport3_clear2_d3d_vb 867127                              //  Direct3DViewport3.Clear2
#define idh__dx_direct3dviewport3_deletelight_d3d_vb 867128                         //  Direct3DViewport3.DeleteLight
#define idh__dx_direct3dviewport3_getbackground_d3d_vb 867129                       //  Direct3DViewport3.GetBackground
#define idh__dx_direct3dviewport3_getbackgrounddepth_d3d_vb 867130                  //  Direct3DViewport3.GetBackgroundDepth
#define idh__dx_direct3dviewport3_getviewport_d3d_vb 867131                         //  Direct3DViewport3.GetViewport
#define idh__dx_direct3dviewport3_getviewport2_d3d_vb 867132                        //  Direct3DViewport3.GetViewport2
#define idh__dx_direct3dviewport3_lightelements_d3d_vb 867133                       //  Direct3DViewport3.LightElements
#define idh__dx_direct3dviewport3_nextlight_d3d_vb 867134                           //  Direct3DViewport3.NextLight
#define idh__dx_direct3dviewport3_setbackground_d3d_vb 867135                       //  Direct3DViewport3.SetBackground
#define idh__dx_direct3dviewport3_setbackgrounddepth_d3d_vb 867136                  //  Direct3DViewport3.SetBackgroundDepth
#define idh__dx_direct3dviewport3_setviewport_d3d_vb 867137                         //  Direct3DViewport3.SetViewport
#define idh__dx_direct3dviewport3_setviewport2_d3d_vb 867138                        //  Direct3DViewport3.SetViewport2
#define idh__dx_direct3dviewport3_transformvertices_d3d_vb 867139                   //  Direct3DViewport3.TransformVertices
#define idh__dx_d3dclipstatus_d3d_vb 867140                                         //  D3DCLIPSTATUS
#define idh__dx_d3dcolorvalue_d3d_vb 867141                                         //  D3DCOLORVALUE
#define idh__dx_d3ddevicedesc_d3d_vb 867142                                         //  D3DDEVICEDESC
#define idh__dx_d3dfinddeviceresult2_d3d_vb 867143                                  //  D3DFINDDEVICERESULT2
#define idh__dx_d3dfinddevicesearch_d3d_vb 867144                                   //  D3DFINDDEVICESEARCH
#define idh__dx_d3dhvertex_d3d_vb 867145                                            //  D3DHVERTEX
#define idh__dx_d3dlight2_d3d_vb 867146                                             //  D3DLIGHT2
#define idh__dx_d3dlightdata_d3d_vb 867147                                          //  D3DLIGHTDATA
#define idh__dx_d3dlightingcaps_d3d_vb 867148                                       //  D3DLIGHTINGCAPS
#define idh__dx_d3dlvertex_d3d_vb 867149                                            //  D3DLVERTEX
#define idh__dx_d3dmaterial_d3d_vb 867150                                           //  D3DMATERIAL
#define idh__dx_d3dmatrix_d3d_vb 867151                                             //  D3DMATRIX
#define idh__dx_d3dprimcaps_d3d_vb 867152                                           //  D3DPRIMCAPS
#define idh__dx_d3drect_d3d_vb 867153                                               //  D3DRECT
#define idh__dx_d3drotation_d3d_vb 867154                                           //  D3DROTATION
#define idh__dx_d3dstats_d3d_vb 867155                                              //  D3DSTATS
#define idh__dx_d3dstatus_d3d_vb 867156                                             //  D3DSTATUS
#define idh__dx_d3dtlvertex_d3d_vb 867157                                           //  D3DTLVERTEX
#define idh__dx_d3dtransformdata_d3d_vb 867158                                      //  D3DTRANSFORMDATA
#define idh__dx_d3dvector_d3d_vb 867159                                             //  D3DVECTOR
#define idh__dx_d3dvertex_d3d_vb 867160                                             //  D3DVERTEX
#define idh__dx_d3dvertexbufferdesc_d3d_vb 867161                                   //  D3DVERTEXBUFFERDESC
#define idh__dx_d3dviewport_d3d_vb 867162                                           //  D3DVIEWPORT
#define idh__dx_d3dviewport2_d3d_vb 867163                                          //  D3DVIEWPORT2
#define idh__dx_dxdriverinfo_d3d_vb 867164                                          //  DXDRIVERINFO
#define idh__dx_const_d3d_d3d_vb 867165                                             //  CONST_D3D
#define idh__dx_const_d3dantialiasmode_d3d_vb 867166                                //  CONST_D3DANTIALIASMODE
#define idh__dx_const_d3dblend_d3d_vb 867167                                        //  CONST_D3DBLEND
#define idh__dx_const_d3dcapsblend_d3d_vb 867168                                    //  CONST_D3DCAPSBLEND
#define idh__dx_const_d3dcapscmp_d3d_vb 867169                                      //  CONST_D3DCAPSCMP
#define idh__dx_const_d3dcapsmisc_d3d_vb 867170                                     //  CONST_D3DCAPSMISC
#define idh__dx_const_d3dcapsraster_d3d_vb 867171                                   //  CONST_D3DCAPSRASTER
#define idh__dx_const_d3dcapsshade_d3d_vb 867172                                    //  CONST_D3DCAPSSHADE
#define idh__dx_const_d3dcapstexture_d3d_vb 867173                                  //  CONST_D3DCAPSTEXTURE
#define idh__dx_const_d3dcapstextureaddress_d3d_vb 867174                           //  CONST_D3DCAPSTEXTUREADDRESS
#define idh__dx_const_d3dcapstextureblend_d3d_vb 867175                             //  CONST_D3DCAPSTEXTUREBLEND
#define idh__dx_const_d3dcapstexturefilter_d3d_vb 867176                            //  CONST_D3DCAPSTEXTUREFILTER
#define idh__dx_const_d3dclearflags_d3d_vb 867177                                   //  CONST_D3DCLEARFLAGS
#define idh__dx_const_d3dclipflags_d3d_vb 867178                                    //  CONST_D3DCLIPFLAGS
#define idh__dx_const_d3dclipstatusflags_d3d_vb 867179                              //  CONST_D3DCLIPSTATUSFLAGS
#define idh__dx_const_d3dcmpfunc_d3d_vb 867180                                      //  CONST_D3DCMPFUNC
#define idh__dx_const_d3dcolormodel_d3d_vb 867181                                   //  CONST_D3DCOLORMODEL
#define idh__dx_const_d3dcull_d3d_vb 867182                                         //  CONST_D3DCULL
#define idh__dx_const_d3ddevicedesccaps_d3d_vb 867183                               //  CONST_D3DDEVICEDESCCAPS
#define idh__dx_const_d3ddevicedescflags_d3d_vb 867184                              //  CONST_D3DDEVICEDESCFLAGS
#define idh__dx_const_d3ddpflags_d3d_vb 867185                                      //  CONST_D3DDPFLAGS
#define idh__dx_const_d3dfillmode_d3d_vb 867186                                     //  CONST_D3DFILLMODE
#define idh__dx_const_d3dfinddevicesearchflags_d3d_vb 867187                        //  CONST_D3DFINDDEVICESEARCHFLAGS
#define idh__dx_const_d3dfogmode_d3d_vb 867188                                      //  CONST_D3DFOGMODE
#define idh__dx_const_d3dfvfcapsflags_d3d_vb 867189                                 //  CONST_D3DFVFCAPSFLAGS
#define idh__dx_const_d3dfvfflags_d3d_vb 867190                                     //  CONST_D3DFVFFLAGS
#define idh__dx_const_d3dimerr_d3d_vb 867191                                        //  CONST_D3DIMERR
#define idh__dx_const_d3dlight2flags_d3d_vb 867192                                  //  CONST_D3DLIGHT2FLAGS
#define idh__dx_const_d3dlightcapsflags_d3d_vb 867193                               //  CONST_D3DLIGHTCAPSFLAGS
#define idh__dx_const_d3dlightingmodelflags_d3d_vb 867194                           //  CONST_D3DLIGHTINGMODELFLAGS
#define idh__dx_const_d3dlightstatetype_d3d_vb 867195                               //  CONST_D3DLIGHTSTATETYPE
#define idh__dx_const_d3dlighttype_d3d_vb 867196                                    //  CONST_D3DLIGHTTYPE
#define idh__dx_const_d3dnextflags_d3d_vb 867197                                    //  CONST_D3DNEXTFLAGS
#define idh__dx_const_d3dpalflags_d3d_vb 867198                                     //  CONST_D3DPALFLAGS
#define idh__dx_const_d3dprimitivetype_d3d_vb 867199                                //  CONST_D3DPRIMITIVETYPE
#define idh__dx_const_d3drenderstatetype_d3d_vb 867200                              //  CONST_D3DRENDERSTATETYPE
#define idh__dx_const_d3dsetstatusflags_d3d_vb 867201                               //  CONST_D3DSETSTATUSFLAGS
#define idh__dx_const_d3dshademode_d3d_vb 867202                                    //  CONST_D3DSHADEMODE
#define idh__dx_const_d3dstencilcapsflags_d3d_vb 867203                             //  CONST_D3DSTENCILCAPSFLAGS
#define idh__dx_const_d3dstencilop_d3d_vb 867204                                    //  CONST_D3DSTENCILOP
#define idh__dx_const_d3dtaflags_d3d_vb 867205                                      //  CONST_D3DTAFLAGS
#define idh__dx_const_d3dtexopcapsflags_d3d_vb 867206                               //  CONST_D3DTEXOPCAPSFLAGS
#define idh__dx_const_d3dtextureaddress_d3d_vb 867207                               //  CONST_D3DTEXTUREADDRESS
#define idh__dx_const_d3dtextureblend_d3d_vb 867208                                 //  CONST_D3DTEXTUREBLEND
#define idh__dx_const_d3dtexturefilter_d3d_vb 867209                                //  CONST_D3DTEXTUREFILTER
#define idh__dx_const_d3dtexturemagfilter_d3d_vb 867210                             //  CONST_D3DTEXTUREMAGFILTER
#define idh__dx_const_d3dtextureminfilter_d3d_vb 867211                             //  CONST_D3DTEXTUREMINFILTER
#define idh__dx_const_d3dtexturemipfilter_d3d_vb 867212                             //  CONST_D3DTEXTUREMIPFILTER
#define idh__dx_const_d3dtextureop_d3d_vb 867213                                    //  CONST_D3DTEXTUREOP
#define idh__dx_const_d3dtexturestagestatetype_d3d_vb 867214                        //  CONST_D3DTEXTURESTAGESTATETYPE
#define idh__dx_const_d3dtransformcaps_d3d_vb 867215                                //  CONST_D3DTRANSFORMCAPS
#define idh__dx_const_d3dtransformflags_d3d_vb 867216                               //  CONST_D3DTRANSFORMFLAGS
#define idh__dx_const_d3dtransformstatetype_d3d_vb 867217                           //  CONST_D3DTRANSFORMSTATETYPE
#define idh__dx_const_d3dvbcapsflags_d3d_vb 867218                                  //  CONST_D3DVBCAPSFLAGS
#define idh__dx_const_d3dvertextype_d3d_vb 867219                                   //  CONST_D3DVERTEXTYPE
#define idh__dx_const_d3dvisflags_d3d_vb 867220                                     //  CONST_D3DVISFLAGS
#define idh__dx_const_d3dvopflags_d3d_vb 867221                                     //  CONST_D3DVOPFLAGS
#define idh__dx_const_d3dzbuffertype_d3d_vb 867222                                  //  CONST_D3DZBUFFERTYPE
#define idh__dx_directdraw4_ddraw_vb 867223                                         //  DirectDraw4
#define idh__dx_directdraw4_createclipper_ddraw_vb 867224                           //  DirectDraw4.CreateClipper
#define idh__dx_directdraw4_createpalette_ddraw_vb 867225                           //  DirectDraw4.CreatePalette
#define idh__dx_directdraw4_createsurface_ddraw_vb 867226                           //  DirectDraw4.CreateSurface
#define idh__dx_directdraw4_createsurfacefromfile_ddraw_vb 867227                   //  DirectDraw4.CreateSurfaceFromFile
#define idh__dx_directdraw4_createsurfacefromresource_ddraw_vb 867228               //  DirectDraw4.CreateSurfaceFromResource
#define idh__dx_directdraw4_duplicatesurface_ddraw_vb 867229                        //  DirectDraw4.DuplicateSurface
#define idh__dx_directdraw4_fliptogdisurface_ddraw_vb 867230                        //  DirectDraw4.FlipToGDISurface
#define idh__dx_directdraw4_getavailabletotalmem_ddraw_vb 867231                    //  DirectDraw4.GetAvailableTotalMem
#define idh__dx_directdraw4_getcaps_ddraw_vb 867232                                 //  DirectDraw4.GetCaps
#define idh__dx_directdraw4_getdirect3d_ddraw_vb 867233                             //  DirectDraw4.GetDirect3D
#define idh__dx_directdraw4_getdisplaymode_ddraw_vb 867234                          //  DirectDraw4.GetDisplayMode
#define idh__dx_directdraw4_getdisplaymodesenum_ddraw_vb 867235                     //  DirectDraw4.GetDisplayModesEnum
#define idh__dx_directdraw4_getfourcccodes_ddraw_vb 867236                          //  DirectDraw4.GetFourCCCodes
#define idh__dx_directdraw4_getfreemem_ddraw_vb 867237                              //  DirectDraw4.GetFreeMem
#define idh__dx_directdraw4_getgdisurface_ddraw_vb 867238                           //  DirectDraw4.GetGDISurface
#define idh__dx_directdraw4_getmonitorfrequency_ddraw_vb 867239                     //  DirectDraw4.GetMonitorFrequency
#define idh__dx_directdraw4_getnumfourcccodes_ddraw_vb 867240                       //  DirectDraw4.GetNumFourCCCodes
#define idh__dx_directdraw4_getscanline_ddraw_vb 867241                             //  DirectDraw4.GetScanLine
#define idh__dx_directdraw4_getsurfacefromdc_ddraw_vb 867242                        //  DirectDraw4.GetSurfaceFromDC
#define idh__dx_directdraw4_getsurfacesenum_ddraw_vb 867243                         //  DirectDraw4.GetSurfacesEnum
#define idh__dx_directdraw4_getverticalblankstatus_ddraw_vb 867244                  //  DirectDraw4.GetVerticalBlankStatus
#define idh__dx_directdraw4_loadpalettefrombitmap_ddraw_vb 867245                   //  DirectDraw4.LoadPaletteFromBitmap
#define idh__dx_directdraw4_restoreallsurfaces_ddraw_vb 867246                      //  DirectDraw4.RestoreAllSurfaces
#define idh__dx_directdraw4_restoredisplaymode_ddraw_vb 867247                      //  DirectDraw4.RestoreDisplayMode
#define idh__dx_directdraw4_setcooperativelevel_ddraw_vb 867248                     //  DirectDraw4.SetCooperativeLevel
#define idh__dx_directdraw4_setdisplaymode_ddraw_vb 867249                          //  DirectDraw4.SetDisplayMode
#define idh__dx_directdraw4_testcooperativelevel_ddraw_vb 867250                    //  DirectDraw4.TestCooperativeLevel
#define idh__dx_directdraw4_waitforverticalblank_ddraw_vb 867251                    //  DirectDraw4.WaitForVerticalBlank
#define idh__dx_directdrawclipper_ddraw_vb 867252                                   //  DirectDrawClipper
#define idh__dx_directdrawclipper_getcliplist_ddraw_vb 867253                       //  DirectDrawClipper.GetClipList
#define idh__dx_directdrawclipper_getcliplistsize_ddraw_vb 867254                   //  DirectDrawClipper.GetClipListSize
#define idh__dx_directdrawclipper_gethwnd_ddraw_vb 867255                           //  DirectDrawClipper.GetHWnd
#define idh__dx_directdrawclipper_iscliplistchanged_ddraw_vb 867256                 //  DirectDrawClipper.IsClipListChanged
#define idh__dx_directdrawclipper_setcliplist_ddraw_vb 867257                       //  DirectDrawClipper.SetClipList
#define idh__dx_directdrawclipper_sethwnd_ddraw_vb 867258                           //  DirectDrawClipper.SetHWnd
#define idh__dx_directdrawcolorcontrol_ddraw_vb 867259                              //  DirectDrawColorControl
#define idh__dx_directdrawcolorcontrol_getcolorcontrols_ddraw_vb 867260             //  DirectDrawColorControl.GetColorControls
#define idh__dx_directdrawcolorcontrol_setcolorcontrols_ddraw_vb 867261             //  DirectDrawColorControl.SetColorControls
#define idh__dx_directdrawenum_ddraw_vb 867262                                      //  DirectDrawEnum
#define idh__dx_directdrawenum_getcount_ddraw_vb 867263                             //  DirectDrawEnum.GetCount
#define idh__dx_directdrawenum_getdescription_ddraw_vb 867264                       //  DirectDrawEnum.GetDescription
#define idh__dx_directdrawenum_getguid_ddraw_vb 867265                              //  DirectDrawEnum.GetGuid
#define idh__dx_directdrawenum_getname_ddraw_vb 867266                              //  DirectDrawEnum.GetName
#define idh__dx_directdrawenummodes_ddraw_vb 867267                                 //  DirectDrawEnumModes
#define idh__dx_directdrawenummodes_getcount_ddraw_vb 867268                        //  DirectDrawEnumModes.GetCount
#define idh__dx_directdrawenummodes_getitem_ddraw_vb 867269                         //  DirectDrawEnumModes.GetItem
#define idh__dx_directdrawenumsurfaces_ddraw_vb 867270                              //  DirectDrawEnumSurfaces
#define idh__dx_directdrawenumsurfaces_getcount_ddraw_vb 867271                     //  DirectDrawEnumSurfaces.GetCount
#define idh__dx_directdrawenumsurfaces_getitem_ddraw_vb 867272                      //  DirectDrawEnumSurfaces.GetItem
#define idh__dx_directdrawgammacontrol_ddraw_vb 867273                              //  DirectDrawGammaControl
#define idh__dx_directdrawgammacontrol_getgammaramp_ddraw_vb 867274                 //  DirectDrawGammaControl.GetGammaRamp
#define idh__dx_directdrawgammacontrol_setgammaramp_ddraw_vb 867275                 //  DirectDrawGammaControl.SetGammaRamp
#define idh__dx_directdrawpalette_ddraw_vb 867276                                   //  DirectDrawPalette
#define idh__dx_directdrawpalette_getcaps_ddraw_vb 867277                           //  DirectDrawPalette.GetCaps
#define idh__dx_directdrawpalette_getentries_ddraw_vb 867278                        //  DirectDrawPalette.GetEntries
#define idh__dx_directdrawpalette_setentries_ddraw_vb 867279                        //  DirectDrawPalette.SetEntries
#define idh__dx_directdrawsurface4_ddraw_vb 867280                                  //  DirectDrawSurface4
#define idh__dx_directdrawsurface4_addattachedsurface_ddraw_vb 867281               //  DirectDrawSurface4.AddAttachedSurface
#define idh__dx_directdrawsurface4_addoverlaydirtyrect_ddraw_vb 867282              //  DirectDrawSurface4.AddOverlayDirtyRect
#define idh__dx_directdrawsurface4_blt_ddraw_vb 867283                              //  DirectDrawSurface4.Blt
#define idh__dx_directdrawsurface4_bltcolorfill_ddraw_vb 867284                     //  DirectDrawSurface4.BltColorFill
#define idh__dx_directdrawsurface4_bltfast_ddraw_vb 867285                          //  DirectDrawSurface4.BltFast
#define idh__dx_directdrawsurface4_bltfx_ddraw_vb 867286                            //  DirectDrawSurface4.BltFx
#define idh__dx_directdrawsurface4_changeuniquenessvalue_ddraw_vb 867287            //  DirectDrawSurface4.ChangeUniquenessValue
#define idh__dx_directdrawsurface4_deleteattachedsurface_ddraw_vb 867288            //  DirectDrawSurface4.DeleteAttachedSurface
#define idh__dx_directdrawsurface4_flip_ddraw_vb 867289                             //  DirectDrawSurface4.Flip
#define idh__dx_directdrawsurface4_freeprivatedata_ddraw_vb 867290                  //  DirectDrawSurface4.FreePrivateData
#define idh__dx_directdrawsurface4_getattachedsurface_ddraw_vb 867291               //  DirectDrawSurface4.GetAttachedSurface
#define idh__dx_directdrawsurface4_getattachedsurfaceenum_ddraw_vb 867292           //  DirectDrawSurface4.GetAttachedSurfaceEnum
#define idh__dx_directdrawsurface4_getbltstatus_ddraw_vb 867293                     //  DirectDrawSurface4.GetBltStatus
#define idh__dx_directdrawsurface4_getcaps_ddraw_vb 867294                          //  DirectDrawSurface4.GetCaps
#define idh__dx_directdrawsurface4_getclipper_ddraw_vb 867295                       //  DirectDrawSurface4.GetClipper
#define idh__dx_directdrawsurface4_getcolorkey_ddraw_vb 867296                      //  DirectDrawSurface4.GetColorKey
#define idh__dx_directdrawsurface4_getdc_ddraw_vb 867297                            //  DirectDrawSurface4.GetDC
#define idh__dx_directdrawsurface4_getdirectdraw_ddraw_vb 867298                    //  DirectDrawSurface4.GetDirectDraw
#define idh__dx_directdrawsurface4_getdirectdrawcolorcontrol_ddraw_vb 867299        //  DirectDrawSurface4.GetDirectDrawColorControl
#define idh__dx_directdrawsurface4_getdirectdrawgammacontrol_ddraw_vb 867300        //  DirectDrawSurface4.GetDirectDrawGammaControl
#define idh__dx_directdrawsurface4_getflipstatus_ddraw_vb 867301                    //  DirectDrawSurface4.GetFlipStatus
#define idh__dx_directdrawsurface4_getlockedpixel_ddraw_vb 867302                   //  DirectDrawSurface4.GetLockedPixel
#define idh__dx_directdrawsurface4_getlockedsurfacebits_ddraw_vb 867303             //  DirectDrawSurface4.GetLockedSurfaceBits
#define idh__dx_directdrawsurface4_getoverlaypositionx_ddraw_vb 867304              //  DirectDrawSurface4.GetOverlayPositionX
#define idh__dx_directdrawsurface4_getoverlaypositiony_ddraw_vb 867305              //  DirectDrawSurface4.GetOverlayPositionY
#define idh__dx_directdrawsurface4_getoverlayzordersenum_ddraw_vb 867306            //  DirectDrawSurface4.GetOverlayZOrdersEnum
#define idh__dx_directdrawsurface4_getpalette_ddraw_vb 867307                       //  DirectDrawSurface4.GetPalette
#define idh__dx_directdrawsurface4_getpixelformat_ddraw_vb 867308                   //  DirectDrawSurface4.GetPixelFormat
#define idh__dx_directdrawsurface4_getprivatedata_ddraw_vb 867309                   //  DirectDrawSurface4.GetPrivateData
#define idh__dx_directdrawsurface4_getprivatedatasize_ddraw_vb 867310               //  DirectDrawSurface4.GetPrivateDataSize
#define idh__dx_directdrawsurface4_getsurfacedesc_ddraw_vb 867311                   //  DirectDrawSurface4.GetSurfaceDesc
#define idh__dx_directdrawsurface4_gettexture_ddraw_vb 867312                       //  DirectDrawSurface4.GetTexture
#define idh__dx_directdrawsurface4_getuniquenessvalue_ddraw_vb 867313               //  DirectDrawSurface4.GetUniquenessValue
#define idh__dx_directdrawsurface4_islost_ddraw_vb 867314                           //  DirectDrawSurface4.IsLost
#define idh__dx_directdrawsurface4_lock_ddraw_vb 867315                             //  DirectDrawSurface4.Lock
#define idh__dx_directdrawsurface4_releasedc_ddraw_vb 867316                        //  DirectDrawSurface4.ReleaseDC
#define idh__dx_directdrawsurface4_restore_ddraw_vb 867317                          //  DirectDrawSurface4.Restore
#define idh__dx_directdrawsurface4_setclipper_ddraw_vb 867318                       //  DirectDrawSurface4.SetClipper
#define idh__dx_directdrawsurface4_setcolorkey_ddraw_vb 867319                      //  DirectDrawSurface4.SetColorKey
#define idh__dx_directdrawsurface4_setlockedpixel_ddraw_vb 867320                   //  DirectDrawSurface4.SetLockedPixel
#define idh__dx_directdrawsurface4_setlockedsurfacebits_ddraw_vb 867321             //  DirectDrawSurface4.SetLockedSurfaceBits
#define idh__dx_directdrawsurface4_setoverlayposition_ddraw_vb 867322               //  DirectDrawSurface4.SetOverlayPosition
#define idh__dx_directdrawsurface4_setpalette_ddraw_vb 867323                       //  DirectDrawSurface4.SetPalette
#define idh__dx_directdrawsurface4_setprivatedata_ddraw_vb 867324                   //  DirectDrawSurface4.SetPrivateData
#define idh__dx_directdrawsurface4_unlock_ddraw_vb 867325                           //  DirectDrawSurface4.Unlock
#define idh__dx_directdrawsurface4_updateoverlay_ddraw_vb 867326                    //  DirectDrawSurface4.UpdateOverlay
#define idh__dx_directdrawsurface4_updateoverlayzorder_ddraw_vb 867327              //  DirectDrawSurface4.UpdateOverlayZOrder
#define idh__dx_directx7_ddraw_vb 867328                                            //  DirectX7
#define idh__dx_ddbltfx_ddraw_vb 867329                                             //  DDBLTFX
#define idh__dx_ddcaps_ddraw_vb 867330                                              //  DDCAPS
#define idh__dx_ddcolorcontrol_ddraw_vb 867331                                      //  DDCOLORCONTROL
#define idh__dx_ddcolorkey_ddraw_vb 867332                                          //  DDCOLORKEY
#define idh__dx_ddgammaramp_ddraw_vb 867333                                         //  DDGAMMARAMP
#define idh__dx_ddoverlayfx_ddraw_vb 867334                                         //  DDOVERLAYFX
#define idh__dx_ddpixelformat_ddraw_vb 867335                                       //  DDPIXELFORMAT
#define idh__dx_ddscaps2_ddraw_vb 867336                                            //  DDSCAPS2
#define idh__dx_ddsurfacedesc2_ddraw_vb 867337                                      //  DDSURFACEDESC2
#define idh__dx_dxdriverinfo_ddraw_vb 867338                                        //  DXDRIVERINFO
#define idh__dx_paletteentry_ddraw_vb 867339                                        //  PALETTEENTRY
#define idh__dx_rect_ddraw_vb 867340                                                //  RECT
#define idh__dx_const_ddbitdepthflags_ddraw_vb 867341                               //  CONST_DDBITDEPTHFLAGS
#define idh__dx_const_ddbltfastflags_ddraw_vb 867342                                //  CONST_DDBLTFASTFLAGS
#define idh__dx_const_ddbltflags_ddraw_vb 867343                                    //  CONST_DDBLTFLAGS
#define idh__dx_const_ddbltfxflags_ddraw_vb 867344                                  //  CONST_DDBLTFXFLAGS
#define idh__dx_const_ddcaps1flags_ddraw_vb 867345                                  //  CONST_DDCAPS1FLAGS
#define idh__dx_const_ddcaps2flags_ddraw_vb 867346                                  //  CONST_DDCAPS2FLAGS
#define idh__dx_const_ddckeycapsflags_ddraw_vb 867347                               //  CONST_DDCKEYCAPSFLAGS
#define idh__dx_const_ddckeyflags_ddraw_vb 867348                                   //  CONST_DDCKEYFLAGS
#define idh__dx_const_ddcolorflags_ddraw_vb 867349                                  //  CONST_DDCOLORFLAGS
#define idh__dx_const_ddedmflags_ddraw_vb 867350                                    //  CONST_DDEDMFLAGS
#define idh__dx_const_ddenumoverlayzflags_ddraw_vb 867351                           //  CONST_DDENUMOVERLAYZFLAGS
#define idh__dx_const_ddenumsurfacesflags_ddraw_vb 867352                           //  CONST_DDENUMSURFACESFLAGS
#define idh__dx_const_ddflipflags_ddraw_vb 867353                                   //  CONST_DDFLIPFLAGS
#define idh__dx_const_ddfxalphacapsflags_ddraw_vb 867354                            //  CONST_DDFXALPHACAPSFLAGS
#define idh__dx_const_ddfxcapsflags_ddraw_vb 867355                                 //  CONST_DDFXCAPSFLAGS
#define idh__dx_const_ddgbsflags_ddraw_vb 867356                                    //  CONST_DDGBSFLAGS
#define idh__dx_const_ddgfsflags_ddraw_vb 867357                                    //  CONST_DDGFSFLAGS
#define idh__dx_const_ddlockflags_ddraw_vb 867358                                   //  CONST_DDLOCKFLAGS
#define idh__dx_const_ddoverflags_ddraw_vb 867359                                   //  CONST_DDOVERFLAGS
#define idh__dx_const_ddoverlayfxflags_ddraw_vb 867360                              //  CONST_DDOVERLAYFXFLAGS
#define idh__dx_const_ddoverzflags_ddraw_vb 867361                                  //  CONST_DDOVERZFLAGS
#define idh__dx_const_ddpcapsflags_ddraw_vb 867362                                  //  CONST_DDPCAPSFLAGS
#define idh__dx_const_ddpixelformatflags_ddraw_vb 867363                            //  CONST_DDPIXELFORMATFLAGS
#define idh__dx_const_ddraw_ddraw_vb 867364                                         //  CONST_DDRAW
#define idh__dx_const_ddsclflags_ddraw_vb 867365                                    //  CONST_DDSCLFLAGS
#define idh__dx_const_ddsdmflags_ddraw_vb 867366                                    //  CONST_DDSDMFLAGS
#define idh__dx_const_ddsgrflags_ddraw_vb 867367                                    //  CONST_DDSGRFLAGS
#define idh__dx_const_ddstereocapsflags_ddraw_vb 867368                             //  CONST_DDSTEREOCAPSFLAGS
#define idh__dx_const_ddsurfacecaps2flags_ddraw_vb 867369                           //  CONST_DDSURFACECAPS2FLAGS
#define idh__dx_const_ddsurfacecapsflags_ddraw_vb 867370                            //  CONST_DDSURFACECAPSFLAGS
#define idh__dx_const_ddsurfacedescflags_ddraw_vb 867371                            //  CONST_DDSURFACEDESCFLAGS
#define idh__dx_const_ddwaitvbflags_ddraw_vb 867372                                 //  CONST_DDWAITVBFLAGS
#define idh__dx_directinput_dinput_vb 867373                                        //  DirectInput
#define idh__dx_directinput_createdevice_dinput_vb 867374                           //  DirectInput.CreateDevice
#define idh__dx_directinput_getdevicestatus_dinput_vb 867375                        //  DirectInput.GetDeviceStatus
#define idh__dx_directinput_getdienumdevices_dinput_vb 867376                       //  DirectInput.GetDIEnumDevices
#define idh__dx_directinput_runcontrolpanel_dinput_vb 867377                        //  DirectInput.RunControlPanel
#define idh__dx_directinputdevice_dinput_vb 867378                                  //  DirectInputDevice
#define idh__dx_directinputdevice_acquire_dinput_vb 867379                          //  DirectInputDevice.Acquire
#define idh__dx_directinputdevice_getcapabilities_dinput_vb 867380                  //  DirectInputDevice.GetCapabilities
#define idh__dx_directinputdevice_getdevicedata_dinput_vb 867381                    //  DirectInputDevice.GetDeviceData
#define idh__dx_directinputdevice_getdeviceinfo_dinput_vb 867382                    //  DirectInputDevice.GetDeviceInfo
#define idh__dx_directinputdevice_getdienumdeviceobjects_dinput_vb 867383           //  DirectInputDevice.GetDeviceObjectsEnum
#define idh__dx_directinputdevice_getdevicestate_dinput_vb 867384                   //  DirectInputDevice.GetDeviceState
#define idh__dx_directinputdevice_getdevicestatejoystick_dinput_vb 867385           //  DirectInputDevice.GetDeviceStateJoystick
#define idh__dx_directinputdevice_getdevicestatejoystick2_dinput_vb 867386          //  DirectInputDevice.GetDeviceStateJoystick2
#define idh__dx_directinputdevice_getdevicestatekeyboard_dinput_vb 867387           //  DirectInputDevice.GetDeviceStateKeyboard
#define idh__dx_directinputdevice_getdevicestatemouse_dinput_vb 867388              //  DirectInputDevice.GetDeviceStateMouse
#define idh__dx_directinputdevice_getobjectinfo_dinput_vb 867389                    //  DirectInputDevice.GetObjectInfo
#define idh__dx_directinputdevice_getproperty_dinput_vb 867390                      //  DirectInputDevice.GetProperty
#define idh__dx_directinputdevice_poll_dinput_vb 867391                             //  DirectInputDevice.Poll
#define idh__dx_directinputdevice_runcontrolpanel_dinput_vb 867392                  //  DirectInputDevice.RunControlPanel
#define idh__dx_directinputdevice_setcooperativelevel_dinput_vb 867393              //  DirectInputDevice.SetCooperativeLevel
#define idh__dx_directinputdevice_setdataformat_dinput_vb 867394                    //  DirectInputDevice.SetDataFormat
#define idh__dx_directinputdevice_seteventnotification_dinput_vb 867395             //  DirectInputDevice.SetEventNotification
#define idh__dx_directinputdevice_setproperty_dinput_vb 867396                      //  DirectInputDevice.SetProperty
#define idh__dx_directinputdevice_unacquire_dinput_vb 867397                        //  DirectInputDevice.Unacquire
#define idh__dx_directinputenumdeviceobjects_dinput_vb 867398                       //  DirectInputEnumDeviceObjects
#define idh__dx_directinputenumdeviceobjects_getcount_dinput_vb 867399              //  DirectInputEnumDeviceObjects.GetCount
#define idh__dx_directinputenumdeviceobjects_getitem_dinput_vb 867400               //  DirectInputEnumDeviceObjects.GetItem
#define idh__dx_directinputenumdevices_dinput_vb 867401                             //  DirectInputEnumDevices
#define idh__dx_directinputenumdevices_getcount_dinput_vb 867402                    //  DirectInputEnumDevices.GetCount
#define idh__dx_directinputenumdevices_getitem_dinput_vb 867403                     //  DirectInputEnumDevices.GetItem
#define idh__dx_didataformat_dinput_vb 867404                                       //  DIDATAFORMAT
#define idh__dx_didevcaps_dinput_vb 867405                                          //  DIDEVCAPS
#define idh__dx_dideviceobjectdata_dinput_vb 867406                                 //  DIDEVICEOBJECTDATA
#define idh__dx_dijoystate_dinput_vb 867407                                         //  DIJOYSTATE
#define idh__dx_dijoystate2_desc_dinput_vb 867408                                   //  DIJOYSTATE2
#define idh__dx_dikeyboardstate_dinput_vb 867409                                    //  DIKEYBOARDSTATE
#define idh__dx_dimousestate_dinput_vb 867410                                       //  DIMOUSESTATE
#define idh__dx_diobjectdataformat_dinput_vb 867411                                 //  DIOBJECTDATAFORMAT
#define idh__dx_const_didataformatflags_dinput_vb 867412                            //  CONST_DIDATAFORMATFLAGS
#define idh__dx_const_didevcapsflags_dinput_vb 867413                               //  CONST_DIDEVCAPSFLAGS
#define idh__dx_const_dideviceobjinstaceflags_dinput_vb 867414                      //  CONST_DIDEVICEOBJINSTANCEFLAGS
#define idh__dx_const_didevicetype_dinput_vb 867415                                 //  CONST_DIDEVICETYPE
#define idh__dx_const_didftflags_dinput_vb 867416                                   //  CONST_DIDFTFLAGS
#define idh__dx_const_didgddflags_dinput_vb 867417                                  //  CONST_DIDGDDFLAGS
#define idh__dx_const_dienumdevicesflags_dinput_vb 867418                           //  CONST_DIENUMDEVICESFLAGS
#define idh__dx_const_dikeyflags_dinput_vb 867419                                   //  CONST_DIKEYFLAGS
#define idh__dx_const_dinputerr_dinput_vb 867420                                    //  CONST_DINPUTERR
#define idh__dx_const_diphflags_dinput_vb 867421                                    //  CONST_DIPHFLAGS
#define idh__dx_const_disclflags_dinput_vb 867422                                   //  CONST_DISCLFLAGS
#define idh__dx_keyboard_device_constants_dinput_vb 867423                          //  Keyboard Device Constants
#define idh__dx_directinput_and_japanese_keyboards_dinput_vb 867424                 //  DirectInput and Japanese Keyboards
#define idh__dx_mouse_device_constants_dinput_vb 867425                             //  Mouse Device Constants
#define idh__dx_joystick_device_constants_dinput_vb 867426                          //  Joystick Device Constants
#define idh__dx_directmusicband_dmusic_vb 867427                                    //  DirectMusicBand
#define idh__dx_directmusicband_createsegment_dmusic_vb 867428                      //  DirectMusicBand.CreateSegment
#define idh__dx_directmusicband_download_dmusic_vb 867429                           //  DirectMusicBand.Download
#define idh__dx_directmusicband_unload_dmusic_vb 867430                             //  DirectMusicBand.Unload
#define idh__dx_directmusicchordmap_dmusic_vb 867431                                //  DirectMusicChordMap
#define idh__dx_directmusiccollection_dmusic_vb 867432                              //  DirectMusicCollection
#define idh__dx_directmusiccomposer_dmusic_vb 867433                                //  DirectMusicComposer
#define idh__dx_directmusiccomposer_autotransition_dmusic_vb 867434                 //  DirectMusicComposer.AutoTransition
#define idh__dx_directmusiccomposer_changechordmap_dmusic_vb 867435                 //  DirectMusicComposer.ChangeChordMap
#define idh__dx_directmusiccomposer_composesegmentfromshape_dmusic_vb 867436        //  DirectMusicComposer.ComposeSegmentFromShape
#define idh__dx_directmusiccomposer_composesegmentfromtemplate_dmusic_vb 867437     //  DirectMusicComposer.ComposeSegmentFromTemplate
#define idh__dx_directmusiccomposer_composetemplatefromshape_dmusic_vb 867438       //  DirectMusicComposer.ComposeTemplateFromShape
#define idh__dx_directmusiccomposer_composetransition_dmusic_vb 867439              //  DirectMusicComposer.ComposeTransition
#define idh__dx_directmusicloader_dmusic_vb 867440                                  //  DirectMusicLoader
#define idh__dx_directmusicloader_loadband_dmusic_vb 867441                         //  DirectMusicLoader.LoadBand
#define idh__dx_directmusicloader_loadbandfromresource_dmusic_vb 867442             //  DirectMusicLoader.LoadBandFromResource
#define idh__dx_directmusicloader_loadcollection_dmusic_vb 867443                   //  DirectMusicLoader.LoadCollection
#define idh__dx_directmusicloader_loadcollectionfromresource_dmusic_vb 867444       //  DirectMusicLoader.LoadCollectionFromResource
#define idh__dx_directmusicloader_loadsegment_dmusic_vb 867445                      //  DirectMusicLoader.LoadSegment
#define idh__dx_directmusicloader_loadsegmentfromresource_dmusic_vb 867446          //  DirectMusicLoader.LoadSegmentFromResource
#define idh__dx_directmusicloader_loadstyle_dmusic_vb 867447                        //  DirectMusicLoader.LoadStyle
#define idh__dx_directmusicloader_loadstylefromresource_dmusic_vb 867448            //  DirectMusicLoader.LoadStyleFromResource
#define idh__dx_directmusicloader_setsearchdirectory_dmusic_vb 867449               //  DirectMusicLoader.SetSearchDirectory
#define idh__dx_directmusicperformance_dmusic_vb 867450                             //  DirectMusicPerformance
#define idh__dx_directmusicperformance_addnotificationtype_dmusic_vb 867451         //  DirectMusicPerformance.AddNotificationType
#define idh__dx_directmusicperformance_adjusttime_dmusic_vb 867452                  //  DirectMusicPerformance.AdjustTime
#define idh__dx_directmusicperformance_clocktomusictime_dmusic_vb 867453            //  DirectMusicPerformance.ClockToMusicTime
#define idh__dx_directmusicperformance_closedown_dmusic_vb 867454                   //  DirectMusicPerformance.CloseDown
#define idh__dx_directmusicperformance_getbumperlength_dmusic_vb 867455             //  DirectMusicPerformance.GetBumperLength
#define idh__dx_directmusicperformance_getchordmap_dmusic_vb 867456                 //  DirectMusicPerformance.GetChordmap
#define idh__dx_directmusicperformance_getclocktime_dmusic_vb 867457                //  DirectMusicPerformance.GetClockTime
#define idh__dx_directmusicperformance_getcommand_dmusic_vb 867458                  //  DirectMusicPerformance.GetCommand
#define idh__dx_directmusicperformance_getgroovelevel_dmusic_vb 867459              //  DirectMusicPerformance.GetGrooveLevel
#define idh__dx_directmusicperformance_getlatencytime_dmusic_vb 867460              //  DirectMusicPerformance.GetLatencyTime
#define idh__dx_directmusicperformance_getmasterautodownload_dmusic_vb 867461       //  DirectMusicPerformance.GetMasterAutoDownload
#define idh__dx_directmusicperformance_getmastergroovelevel_dmusic_vb 867462        //  DirectMusicPerformance.GetMasterGrooveLevel
#define idh__dx_directmusicperformance_getmastertempo_dmusic_vb 867463              //  DirectMusicPerformance.GetMasterTempo
#define idh__dx_directmusicperformance_getmastervolume_dmusic_vb 867464             //  DirectMusicPerformance.GetMasterVolume
#define idh__dx_directmusicperformance_getmusictime_dmusic_vb 867465                //  DirectMusicPerformance.GetMusicTime
#define idh__dx_directmusicperformance_getnotificationpmsg_dmusic_vb 867466         //  DirectMusicPerformance.GetNotificationPMsg
#define idh__dx_directmusicperformance_getportcaps_dmusic_vb 867467                 //  DirectMusicPerformance.GetPortCaps
#define idh__dx_directmusicperformance_getportcount_dmusic_vb 867468                //  DirectMusicPerformance.GetPortCount
#define idh__dx_directmusicperformance_getportname_dmusic_vb 867469                 //  DirectMusicPerformance.GetPortName
#define idh__dx_directmusicperformance_getpreparetime_dmusic_vb 867470              //  DirectMusicPerformance.GetPrepareTime
#define idh__dx_directmusicperformance_getqueuetime_dmusic_vb 867471                //  DirectMusicPerformance.GetQueueTime
#define idh__dx_directmusicperformance_getresolvedtime_dmusic_vb 867472             //  DirectMusicPerformance.GetResolvedTime
#define idh__dx_directmusicperformance_getsegmentstate_dmusic_vb 867473             //  DirectMusicPerformance.GetSegmentState
#define idh__dx_directmusicperformance_getstyle_dmusic_vb 867474                    //  DirectMusicPerformance.GetStyle
#define idh__dx_directmusicperformance_gettempo_dmusic_vb 867475                    //  DirectMusicPerformance.GetTempo
#define idh__dx_directmusicperformance_gettimesig_dmusic_vb 867476                  //  DirectMusicPerformance.GetTimeSig
#define idh__dx_directmusicperformance_gmreset_dmusic_vb 867477                     //  DirectMusicPerformance.GMReset
#define idh__dx_directmusicperformance_init_dmusic_vb 867478                        //  DirectMusicPerformance.Init
#define idh__dx_directmusicperformance_invalidate_dmusic_vb 867479                  //  DirectMusicPerformance.Invalidate
#define idh__dx_directmusicperformance_isplaying_dmusic_vb 867480                   //  DirectMusicPerformance.IsPlaying
#define idh__dx_directmusicperformance_musictoclocktime_dmusic_vb 867481            //  DirectMusicPerformance.MusicToClockTime
#define idh__dx_directmusicperformance_playsegment_dmusic_vb 867482                 //  DirectMusicPerformance.PlaySegment
#define idh__dx_directmusicperformance_removenotificationtype_dmusic_vb 867483      //  DirectMusicPerformance.RemoveNotificationType
#define idh__dx_directmusicperformance_sendcurvepmsg_dmusic_vb 867484               //  DirectMusicPerformance.SendCurvePMSG
#define idh__dx_directmusicperformance_sendmidipmsg_dmusic_vb 867485                //  DirectMusicPerformance.SendMIDIPMSG
#define idh__dx_directmusicperformance_sendnotepmsg_dmusic_vb 867486                //  DirectMusicPerformance.SendNotePMSG
#define idh__dx_directmusicperformance_sendpatchpmsg_dmusic_vb 867487               //  DirectMusicPerformance.SendPatchPMSG
#define idh__dx_directmusicperformance_sendtempopmsg_dmusic_vb 867488               //  DirectMusicPerformance.SendTempoPMSG
#define idh__dx_directmusicperformance_sendtimesigpmsg_dmusic_vb 867489             //  DirectMusicPerformance.SendTimeSigPMSG
#define idh__dx_directmusicperformance_sendtransposepmsg_dmusic_vb 867490           //  DirectMusicPerformance.SendTransposePMSG
#define idh__dx_directmusicperformance_setbumperlength_dmusic_vb 867491             //  DirectMusicPerformance.SetBumperLength
#define idh__dx_directmusicperformance_setmasterautodownload_dmusic_vb 867492       //  DirectMusicPerformance.SetMasterAutoDownload
#define idh__dx_directmusicperformance_setmastergroovelevel_dmusic_vb 867493        //  DirectMusicPerformance.SetMasterGrooveLevel
#define idh__dx_directmusicperformance_setmastertempo_dmusic_vb 867494              //  DirectMusicPerformance.SetMasterTempo
#define idh__dx_directmusicperformance_setmastervolume_dmusic_vb 867495             //  DirectMusicPerformance.SetMasterVolume
#define idh__dx_directmusicperformance_setnotificationhandle_dmusic_vb 867496       //  DirectMusicPerformance.SetNotificationHandle
#define idh__dx_directmusicperformance_setport_dmusic_vb 867497                     //  DirectMusicPerformance.SetPort
#define idh__dx_directmusicperformance_setpreparetime_dmusic_vb 867498              //  DirectMusicPerformance.SetPrepareTime
#define idh__dx_directmusicperformance_stop_dmusic_vb 867499                        //  DirectMusicPerformance.Stop
#define idh__dx_directmusicsegment_dmusic_vb 867500                                 //  DirectMusicSegment
#define idh__dx_directmusicsegment_clone_dmusic_vb 867501                           //  DirectMusicSegment.Clone
#define idh__dx_directmusicsegment_connecttocollection_dmusic_vb 867502             //  DirectMusicSegment.ConnectToCollection
#define idh__dx_directmusicsegment_download_dmusic_vb 867503                        //  DirectMusicSegment.Download
#define idh__dx_directmusicsegment_getlength_dmusic_vb 867504                       //  DirectMusicSegment.GetLength
#define idh__dx_directmusicsegment_getlooppointend_dmusic_vb 867505                 //  DirectMusicSegment.GetLoopPointEnd
#define idh__dx_directmusicsegment_getlooppointstart_dmusic_vb 867506               //  DirectMusicSegment.GetLoopPointStart
#define idh__dx_directmusicsegment_getrepeats_dmusic_vb 867507                      //  DirectMusicSegment.GetRepeats
#define idh__dx_directmusicsegment_getstartpoint_dmusic_vb 867508                   //  DirectMusicSegment.GetStartPoint
#define idh__dx_directmusicsegment_setautodownloadenable_dmusic_vb 867509           //  DirectMusicSegment.SetAutoDownloadEnable
#define idh__dx_directmusicsegment_setlength_dmusic_vb 867510                       //  DirectMusicSegment.SetLength
#define idh__dx_directmusicsegment_setlooppoints_dmusic_vb 867511                   //  DirectMusicSegment.SetLoopPoints
#define idh__dx_directmusicsegment_setrepeats_dmusic_vb 867512                      //  DirectMusicSegment.SetRepeats
#define idh__dx_directmusicsegment_setstandardmidifile_dmusic_vb 867513             //  DirectMusicSegment.SetStandardMidiFile
#define idh__dx_directmusicsegment_setstartpoint_dmusic_vb 867514                   //  DirectMusicSegment.SetStartPoint
#define idh__dx_directmusicsegment_settempoenable_dmusic_vb 867515                  //  DirectMusicSegment.SetTempoEnable
#define idh__dx_directmusicsegment_settimesigenable_dmusic_vb 867516                //  DirectMusicSegment.SetTimeSigEnable
#define idh__dx_directmusicsegment_unload_dmusic_vb 867517                          //  DirectMusicSegment.Unload
#define idh__dx_directmusicsegmentstate_dmusic_vb 867518                            //  DirectMusicSegmentState
#define idh__dx_directmusicsegmentstate_getrepeats_dmusic_vb 867519                 //  DirectMusicSegmentState.GetRepeats
#define idh__dx_directmusicsegmentstate_getseek_dmusic_vb 867520                    //  DirectMusicSegmentState.GetSeek
#define idh__dx_directmusicsegmentstate_getsegment_dmusic_vb 867521                 //  DirectMusicSegmentState.GetSegment
#define idh__dx_directmusicsegmentstate_getstartpoint_dmusic_vb 867522              //  DirectMusicSegmentState.GetStartPoint
#define idh__dx_directmusicsegmentstate_getstarttime_dmusic_vb 867523               //  DirectMusicSegmentState.GetStartTime
#define idh__dx_directmusicstyle_dmusic_vb 867524                                   //  DirectMusicStyle
#define idh__dx_directmusicstyle_getband_dmusic_vb 867525                           //  DirectMusicStyle.GetBand
#define idh__dx_directmusicstyle_getbandcount_dmusic_vb 867526                      //  DirectMusicStyle.GetBandCount
#define idh__dx_directmusicstyle_getbandname_dmusic_vb 867527                       //  DirectMusicStyle.GetBandName
#define idh__dx_directmusicstyle_getchordmap_dmusic_vb 867528                       //  DirectMusicStyle.GetChordmap
#define idh__dx_directmusicstyle_getchordmapcount_dmusic_vb 867529                  //  DirectMusicStyle.GetChordmapCount
#define idh__dx_directmusicstyle_getchordmapname_dmusic_vb 867530                   //  DirectMusicStyle.GetChordmapName
#define idh__dx_directmusicstyle_getdefaultband_dmusic_vb 867531                    //  DirectMusicStyle.GetDefaultBand
#define idh__dx_directmusicstyle_getdefaultchordmap_dmusic_vb 867532                //  DirectMusicStyle.GetDefaultChordMap
#define idh__dx_directmusicstyle_getmotif_dmusic_vb 867533                          //  DirectMusicStyle.GetMotif
#define idh__dx_directmusicstyle_getmotifcount_dmusic_vb 867534                     //  DirectMusicStyle.GetMotifCount
#define idh__dx_directmusicstyle_getmotifname_dmusic_vb 867535                      //  DirectMusicStyle.GetMotifName
#define idh__dx_directmusicstyle_gettempo_dmusic_vb 867536                          //  DirectMusicStyle.GetTempo
#define idh__dx_directmusicstyle_gettimesignature_dmusic_vb 867537                  //  DirectMusicStyle.GetTimeSignature
#define idh__dx_dmus_curve_pmsg_dmusic_vb 867538                                    //  DMUS_CURVE_PMSG
#define idh__dx_dmus_note_pmsg_dmusic_vb 867539                                     //  DMUS_NOTE_PMSG
#define idh__dx_dmus_notification_pmsg_dmusic_vb 867540                             //  DMUS_NOTIFICATION_PMSG
#define idh__dx_dmus_portcaps_dmusic_vb 867541                                      //  DMUS_PORTCAPS
#define idh__dx_dmus_timesignature_dmusic_vb 867542                                 //  DMUS_TIMESIGNATURE
#define idh__dx_const_dmus_notificationtype_dmusic_vb 867543                        //  CONST_DMUS_NOTIFICATIONTYPE
#define idh__dx_enumdmus_commandt_types_dmusic_vb 867544                            //  enumDMUS_COMMANDT_TYPES
#define idh__dx_enumdmus_composef_flags_dmusic_vb 867545                            //  enumDMUS_COMPOSEF_FLAGS
#define idh__dx_enumdmus_playmode_flags_dmusic_vb 867546                            //  enumDMUS_PLAYMODE_FLAGS
#define idh__dx_enumdmus_pmsgf_flags_dmusic_vb 867547                               //  enumDMUS_PMSGF_FLAGS
#define idh__dx_enumdmus_segf_flags_dmusic_vb 867548                                //  enumDMUS_SEGF_FLAGS
#define idh__dx_enumdmus_shapet_types_dmusic_vb 867549                              //  enumDMUS_SHAPET_TYPES
#define idh__dx_directplay4_dplay_vb 867550                                         //  DirectPlay4
#define idh__dx_directplay4_addgrouptogroup_dplay_vb 867551                         //  DirectPlay4.AddGroupToGroup
#define idh__dx_directplay4_addplayertogroup_dplay_vb 867552                        //  DirectPlay4.AddPlayerToGroup
#define idh__dx_directplay4_cancelmessage_dplay_vb 867553                           //  DirectPlay4.CancelMessage
#define idh__dx_directplay4_cancelpriority_dplay_vb 867554                          //  DirectPlay4.CancelPriority
#define idh__dx_directplay4_close_dplay_vb 867555                                   //  DirectPlay4.Close
#define idh__dx_directplay4_creategroup_dplay_vb 867556                             //  DirectPlay4.CreateGroup
#define idh__dx_directplay4_creategroupingroup_dplay_vb 867557                      //  DirectPlay4.CreateGroupInGroup
#define idh__dx_directplay4_createmessage_dplay_vb 867558                           //  DirectPlay4.CreateMessage
#define idh__dx_directplay4_createplayer_dplay_vb 867559                            //  DirectPlay4.CreatePlayer
#define idh__dx_directplay4_createsessiondata_dplay_vb 867560                       //  DirectPlay4.CreateSessionData
#define idh__dx_directplay4_deletegroupfromgroup_dplay_vb 867561                    //  DirectPlay4.DeleteGroupFromGroup
#define idh__dx_directplay4_deleteplayerfromgroup_dplay_vb 867562                   //  DirectPlay4.DeletePlayerFromGroup
#define idh__dx_directplay4_destroygroup_dplay_vb 867563                            //  DirectPlay4.DestroyGroup
#define idh__dx_directplay4_destroyplayer_dplay_vb 867564                           //  DirectPlay4.DestroyPlayer
#define idh__dx_directplay4_getcaps_dplay_vb 867565                                 //  DirectPlay4.GetCaps
#define idh__dx_directplay4_getdpenumconnections_dplay_vb 867566                    //  DirectPlay4.GetDPEnumConnections
#define idh__dx_directplay4_getdpenumgroupplayers_dplay_vb 867567                   //  DirectPlay4.GetDPEnumGroupPlayers
#define idh__dx_directplay4_getdpenumgroups_dplay_vb 867568                         //  DirectPlay4.GetDPEnumGroups
#define idh__dx_directplay4_getdpenumgroupsingroup_dplay_vb 867569                  //  DirectPlay4.GetDPEnumGroupsInGroup
#define idh__dx_directplay4_getdpenumplayers_dplay_vb 867570                        //  DirectPlay4.GetDPEnumPlayers
#define idh__dx_directplay4_getdpenumsessions_dplay_vb 867571                       //  DirectPlay4.GetDPEnumSessions
#define idh__dx_directplay4_getgroupdata_dplay_vb 867572                            //  DirectPlay4.GetGroupData
#define idh__dx_directplay4_getgroupflags_dplay_vb 867573                           //  DirectPlay4.GetGroupFlags
#define idh__dx_directplay4_getgrouplongname_dplay_vb 867574                        //  DirectPlay4.GetGroupLongName
#define idh__dx_directplay4_getgroupowner_dplay_vb 867575                           //  DirectPlay4.GetGroupOwner
#define idh__dx_directplay4_getgroupparent_dplay_vb 867576                          //  DirectPlay4.GetGroupParent
#define idh__dx_directplay4_getgroupshortname_dplay_vb 867577                       //  DirectPlay4.GetGroupShortName
#define idh__dx_directplay4_getmessagecount_dplay_vb 867578                         //  DirectPlay4.GetMessageCount
#define idh__dx_directplay4_getmessagequeue_dplay_vb 867579                         //  DirectPlay4.GetMessageQueue
#define idh__dx_directplay4_getplayeraccountid_dplay_vb 867580                      //  DirectPlay4.GetPlayerAccountId
#define idh__dx_directplay4_getplayeraddress_dplay_vb 867581                        //  DirectPlay4.GetPlayerAddress
#define idh__dx_directplay4_getplayercaps_dplay_vb 867582                           //  DirectPlay4.GetPlayerCaps
#define idh__dx_directplay4_getplayerdata_dplay_vb 867583                           //  DirectPlay4.GetPlayerData
#define idh__dx_directplay4_getplayerflags_dplay_vb 867584                          //  DirectPlay4.GetPlayerFlags
#define idh__dx_directplay4_getplayerformalname_dplay_vb 867585                     //  DirectPlay4.GetPlayerFormalName
#define idh__dx_directplay4_getplayerfriendlyname_dplay_vb 867586                   //  DirectPlay4.GetPlayerFriendlyName
#define idh__dx_directplay4_getsessiondesc_dplay_vb 867587                          //  DirectPlay4.GetSessionDesc
#define idh__dx_directplay4_initializeconnection_dplay_vb 867588                    //  DirectPlay4.InitializeConnection
#define idh__dx_directplay4_open_dplay_vb 867589                                    //  DirectPlay4.Open
#define idh__dx_directplay4_receive_dplay_vb 867590                                 //  DirectPlay4.Receive
#define idh__dx_directplay4_secureopen_dplay_vb 867591                              //  DirectPlay4.SecureOpen
#define idh__dx_directplay4_send_dplay_vb 867592                                    //  DirectPlay4.Send
#define idh__dx_directplay4_sendchatmessage_dplay_vb 867593                         //  DirectPlay4.SendChatMessage
#define idh__dx_directplay4_sendex_dplay_vb 867594                                  //  DirectPlay4.SendEx
#define idh__dx_directplay4_setgroupconnectionsettings_dplay_vb 867595              //  DirectPlay4.SetGroupConnectionSettings
#define idh__dx_directplay4_setgroupdata_dplay_vb 867596                            //  DirectPlay4.SetGroupData
#define idh__dx_directplay4_setgroupname_dplay_vb 867597                            //  DirectPlay4.SetGroupName
#define idh__dx_directplay4_setgroupowner_dplay_vb 867598                           //  DirectPlay4.SetGroupOwner
#define idh__dx_directplay4_setplayerdata_dplay_vb 867599                           //  DirectPlay4.SetPlayerData
#define idh__dx_directplay4_setplayername_dplay_vb 867600                           //  DirectPlay4.SetPlayerName
#define idh__dx_directplay4_setsessiondesc_dplay_vb 867601                          //  DirectPlay4.SetSessionDesc
#define idh__dx_directplay4_startsession_dplay_vb 867602                            //  DirectPlay4.StartSession
#define idh__dx_directplayaddress_dplay_vb 867603                                   //  DirectPlayAddress
#define idh__dx_directplayenumaddress_dplay_vb 867604                               //  DirectPlayEnumAddress
#define idh__dx_directplayenumaddress_getcount_dplay_vb 867605                      //  DirectPlayEnumAddress.GetCount
#define idh__dx_directplayenumaddress_getdata_dplay_vb 867606                       //  DirectPlayEnumAddress.GetData
#define idh__dx_directplayenumaddress_gettype_dplay_vb 867607                       //  DirectPlayEnumAddress.GetType
#define idh__dx_directplayenumaddresstypes_dplay_vb 867608                          //  DirectPlayEnumAddressTypes
#define idh__dx_directplayenumaddresstypes_getcount_dplay_vb 867609                 //  DirectPlayEnumAddressTypes.GetCount
#define idh__dx_directplayenumaddresstypes_gettype_dplay_vb 867610                  //  DirectPlayEnumAddressTypes.GetType
#define idh__dx_directplayenumconnections_dplay_vb 867611                           //  DirectPlayEnumConnections
#define idh__dx_directplayenumconnections_getaddress_dplay_vb 867612                //  DirectPlayEnumConnections.GetAddress
#define idh__dx_directplayenumconnections_getcount_dplay_vb 867613                  //  DirectPlayEnumConnections.GetCount
#define idh__dx_directplayenumconnections_getflags_dplay_vb 867614                  //  DirectPlayEnumConnections.GetFlags
#define idh__dx_directplayenumconnections_getguid_dplay_vb 867615                   //  DirectPlayEnumConnections.GetGuid
#define idh__dx_directplayenumconnections_getshortname_dplay_vb 867616              //  DirectPlayEnumConnections.GetName
#define idh__dx_directplayenumlocalapplications_dplay_vb 867617                     //  DirectPlayEnumLocalApplications
#define idh__dx_directplayenumlocalapplications_getcount_dplay_vb 867618            //  DirectPlayEnumLocalApplications.GetCount
#define idh__dx_directplayenumlocalapplications_getguid_dplay_vb 867619             //  DirectPlayEnumLocalApplications.GetGuid
#define idh__dx_directplayenumlocalapplications_getname_dplay_vb 867620             //  DirectPlayEnumLocalApplications.GetName
#define idh__dx_directplayenumplayers_dplay_vb 867621                               //  DirectPlayEnumPlayers
#define idh__dx_directplayenumplayers_getcount_dplay_vb 867622                      //  DirectPlayEnumPlayers.GetCount
#define idh__dx_directplayenumplayers_getdpid_dplay_vb 867623                       //  DirectPlayEnumPlayers.GetDPID
#define idh__dx_directplayenumplayers_getflags_dplay_vb 867624                      //  DirectPlayEnumPlayers.GetFlags
#define idh__dx_directplayenumplayers_getlongname_dplay_vb 867625                   //  DirectPlayEnumPlayers.GetLongName
#define idh__dx_directplayenumplayers_getshortname_dplay_vb 867626                  //  DirectPlayEnumPlayers.GetShortName
#define idh__dx_directplayenumplayers_gettype_dplay_vb 867627                       //  DirectPlayEnumPlayers.GetType
#define idh__dx_directplayenumserviceproviders_dplay_vb 867628                      //  DirectPlayEnumServiceProviders
#define idh__dx_directplayenumserviceproviders_getcount_dplay_vb 867629             //  DirectPlayEnumServiceProviders.GetCount
#define idh__dx_directplayenumserviceproviders_getguid_dplay_vb 867630              //  DirectPlayEnumServiceProviders.GetGuid
#define idh__dx_directplayenumserviceproviders_getname_dplay_vb 867631              //  DirectPlayEnumServiceProviders.GetName
#define idh__dx_directplayenumserviceproviders_getversion_dplay_vb 867632           //  DirectPlayEnumServiceProviders.GetVersion
#define idh__dx_directplayenumsessions_dplay_vb 867633                              //  DirectPlayEnumSessions
#define idh__dx_directplayenumsessions_getcount_dplay_vb 867634                     //  DirectPlayEnumSessions.GetCount
#define idh__dx_directplayenumsessions_getitem_dplay_vb 867635                      //  DirectPlayEnumSessions.GetItem
#define idh__dx_directplaylobby3_dplay_vb 867636                                    //  DirectPlayLobby3
#define idh__dx_directplaylobby3_connect_dplay_vb 867637                            //  DirectPlayLobby3.Connect
#define idh__dx_directplaylobby3_createaddress_dplay_vb 867638                      //  DirectPlayLobby3.CreateAddress
#define idh__dx_directplaylobby3_createcompoundaddress_dplay_vb 867639              //  DirectPlayLobby3.CreateCompoundAddress
#define idh__dx_directplaylobby3_createconnectiondata_dplay_vb 867640               //  DirectPlayLobby3.CreateConnectionData
#define idh__dx_directplaylobby3_createmessage_dplay_vb 867641                      //  DirectPlayLobby3.CreateMessage
#define idh__dx_directplaylobby3_getconnectionsettings_dplay_vb 867642              //  DirectPlayLobby3.GetConnectionSettings
#define idh__dx_directplaylobby3_getdpenumaddress_dplay_vb 867643                   //  DirectPlayLobby3.GetDPEnumAddress
#define idh__dx_directplaylobby3_getdpenumaddresstypes_dplay_vb 867644              //  DirectPlayLobby3.GetDPEnumAddressTypes
#define idh__dx_directplaylobby3_getdpenumlocalapplications_dplay_vb 867645         //  DirectPlayLobby3.GetDPEnumLocalApplications
#define idh__dx_directplaylobby3_receivelobbymessage_dplay_vb 867646                //  DirectPlayLobby3.ReceiveLobbyMessage
#define idh__dx_directplaylobby3_registerapplication_dplay_vb 867647                //  DirectPlayLobby3.RegisterApplication
#define idh__dx_directplaylobby3_runapplication_dplay_vb 867648                     //  DirectPlayLobby3.RunApplication
#define idh__dx_directplaylobby3_sendlobbymessage_dplay_vb 867649                   //  DirectPlayLobby3.SendLobbyMessage
#define idh__dx_directplaylobby3_setconnectionsettings_dplay_vb 867650              //  DirectPlayLobby3.SetConnectionSettings
#define idh__dx_directplaylobby3_setlobbymessageevent_dplay_vb 867651               //  DirectPlayLobby3.SetLobbyMessageEvent
#define idh__dx_directplaylobby3_unregisterapplication_dplay_vb 867652              //  DirectPlayLobby3.UnregisterApplication
#define idh__dx_directplaylobby3_waitforconnectionsettings_dplay_vb 867653          //  DirectPlayLobby3.WaitForConnectionSettings
#define idh__dx_directplaylobbyconnection_dplay_vb 867654                           //  DirectPlayLobbyConnection
#define idh__dx_directplaylobbyconnection_getaddress_dplay_vb 867655                //  DirectPlayLobbyConnection.GetAddress
#define idh__dx_directplaylobbyconnection_getflags_dplay_vb 867656                  //  DirectPlayLobbyConnection.GetFlags
#define idh__dx_directplaylobbyconnection_getguidsp_dplay_vb 867657                 //  DirectPlayLobbyConnection.GetGuidSP
#define idh__dx_directplaylobbyconnection_getplayerlongname_dplay_vb 867658         //  DirectPlayLobbyConnection.GetPlayerLongName
#define idh__dx_directplaylobbyconnection_getplayershortname_dplay_vb 867659        //  DirectPlayLobbyConnection.GetPlayerShortName
#define idh__dx_directplaylobbyconnection_getsessiondesc_dplay_vb 867660            //  DirectPlayLobbyConnection.GetSessionDesc
#define idh__dx_directplaylobbyconnection_setaddress_dplay_vb 867661                //  DirectPlayLobbyConnection.SetAddress
#define idh__dx_directplaylobbyconnection_setflags_dplay_vb 867662                  //  DirectPlayLobbyConnection.SetFlags
#define idh__dx_directplaylobbyconnection_setguidsp_dplay_vb 867663                 //  DirectPlayLobbyConnection.SetGuidSP
#define idh__dx_directplaylobbyconnection_setplayerlongname_dplay_vb 867664         //  DirectPlayLobbyConnection.SetPlayerLongName
#define idh__dx_directplaylobbyconnection_setplayershortname_dplay_vb 867665        //  DirectPlayLobbyConnection.SetPlayerShortName
#define idh__dx_directplaylobbyconnection_setsessiondesc_dplay_vb 867666            //  DirectPlayLobbyConnection.SetSessionDesc
#define idh__dx_directplaymessage_dplay_vb 867667                                   //  DirectPlayMessage
#define idh__dx_directplaymessage_clear_dplay_vb 867668                             //  DirectPlayMessage.Clear
#define idh__dx_directplaymessage_getmessagedata_dplay_vb 867669                    //  DirectPlayMessage.GetMessageData
#define idh__dx_directplaymessage_getmessagesize_dplay_vb 867670                    //  DirectPlayMessage.GetMessageSize
#define idh__dx_directplaymessage_movetotop_dplay_vb 867671                         //  DirectPlayMessage.MoveToTop
#define idh__dx_directplaymessage_readbyte_dplay_vb 867672                          //  DirectPlayMessage.ReadByte
#define idh__dx_directplaymessage_readdouble_dplay_vb 867673                        //  DirectPlayMessage.ReadDouble
#define idh__dx_directplaymessage_readguid_dplay_vb 867674                          //  DirectPlayMessage.ReadGuid
#define idh__dx_directplaymessage_readlong_dplay_vb 867675                          //  DirectPlayMessage.ReadLong
#define idh__dx_directplaymessage_readshort_dplay_vb 867676                         //  DirectPlayMessage.ReadShort
#define idh__dx_directplaymessage_readsingle_dplay_vb 867677                        //  DirectPlayMessage.ReadSingle
#define idh__dx_directplaymessage_readstring_dplay_vb 867678                        //  DirectPlayMessage.ReadString
#define idh__dx_directplaymessage_setmessagedata_dplay_vb 867679                    //  DirectPlayMessage.SetMessageData
#define idh__dx_directplaymessage_writebyte_dplay_vb 867680                         //  DirectPlayMessage.WriteByte
#define idh__dx_directplaymessage_writedouble_dplay_vb 867681                       //  DirectPlayMessage.WriteDouble
#define idh__dx_directplaymessage_writeguid_dplay_vb 867682                         //  DirectPlayMessage.WriteGuid
#define idh__dx_directplaymessage_writelong_dplay_vb 867683                         //  DirectPlayMessage.WriteLong
#define idh__dx_directplaymessage_writeshort_dplay_vb 867684                        //  DirectPlayMessage.WriteShort
#define idh__dx_directplaymessage_writesingle_dplay_vb 867685                       //  DirectPlayMessage.WriteSingle
#define idh__dx_directplaymessage_writestring_dplay_vb 867686                       //  DirectPlayMessage.WriteString
#define idh__dx_directplaysessiondata_dplay_vb 867687                               //  DirectPlaySessionData
#define idh__dx_directplaysessiondata_getcurrentplayers_dplay_vb 867688             //  DirectPlaySessionData.GetCurrentPlayers
#define idh__dx_directplaysessiondata_getflags_dplay_vb 867689                      //  DirectPlaySessionData.GetFlags
#define idh__dx_directplaysessiondata_getguidapplication_dplay_vb 867690            //  DirectPlaySessionData.GetGuidApplication
#define idh__dx_directplaysessiondata_getguidinstance_dplay_vb 867691               //  DirectPlaySessionData.GetGuidInstance
#define idh__dx_directplaysessiondata_getmaxplayers_dplay_vb 867692                 //  DirectPlaySessionData.GetMaxPlayers
#define idh__dx_directplaysessiondata_getsessionname_dplay_vb 867693                //  DirectPlaySessionData.GetSessionName
#define idh__dx_directplaysessiondata_getsessionpassword_dplay_vb 867694            //  DirectPlaySessionData.GetSessionPassword
#define idh__dx_directplaysessiondata_getuser_n__dplay_vb 867695                    //  DirectPlaySessionData.GetUser(n)
#define idh__dx_directplaysessiondata_setflags_dplay_vb 867696                      //  DirectPlaySessionData.SetFlags
#define idh__dx_directplaysessiondata_setguidapplication_dplay_vb 867697            //  DirectPlaySessionData.SetGuidApplication
#define idh__dx_directplaysessiondata_setguidinstance_dplay_vb 867698               //  DirectPlaySessionData.SetGuidInstance
#define idh__dx_directplaysessiondata_setmaxplayers_dplay_vb 867699                 //  DirectPlaySessionData.SetMaxPlayers
#define idh__dx_directplaysessiondata_setsessionname_dplay_vb 867700                //  DirectPlaySessionData.SetSessionName
#define idh__dx_directplaysessiondata_setsessionpassword_dplay_vb 867701            //  DirectPlaySessionData.SetSessionPassword
#define idh__dx_directplaysessiondata_setuser_n__dplay_vb 867702                    //  DirectPlaySessionData.SetUser(n)
#define idh__dx_dpapplicationdesc_dplay_vb 867703                                   //  DPAPPLICATIONDESC
#define idh__dx_dpcaps_dplay_vb 867704                                              //  DPCAPS
#define idh__dx_dpcompoundaddresselement_dplay_vb 867705                            //  DPCOMPOUNDADDRESSELEMENT
#define idh__dx_dpcredentials_dplay_vb 867706                                       //  DPCREDENTIALS
#define idh__dx_dpplayerids_dplay_vb 867707                                         //  DPPLAYERIDS
#define idh__dx_dpsecuritydesc_dplay_vb 867708                                      //  DPSECURITYDESC
#define idh__dx_const_dpcapsflags_dplay_vb 867709                                   //  CONST_DPCAPSFLAGS
#define idh__dx_const_dpconnectflags_dplay_vb 867710                                //  CONST_DPCONNECTFLAGS
#define idh__dx_const_dpenumconnectionflags_dplay_vb 867711                         //  CONST_DPENUMCONNECTIONFLAGS
#define idh__dx_const_dpenumgroupflags_dplay_vb 867712                              //  CONST_DPENUMGROUPFLAGS
#define idh__dx_const_dpenumplayerflags_dplay_vb 867713                             //  CONST_DPENUMPLAYERFLAGS
#define idh__dx_const_dpenumsessionflags_dplay_vb 867714                            //  CONST_DPENUMSESSIONFLAGS
#define idh__dx_const_dpgetcapsflags_dplay_vb 867715                                //  CONST_DPGETCAPSFLAGS
#define idh__dx_const_dpgetflags_dplay_vb 867716                                    //  CONST_DPGETFLAGS
#define idh__dx_const_dpgroupflags_dplay_vb 867717                                  //  CONST_DPGROUPFLAGS
#define idh__dx_const_dpidflags_dplay_vb 867718                                     //  CONST_DPIDFLAGS
#define idh__dx_const_dpplayerflags_dplay_vb 867719                                 //  CONST_DPPLAYERFLAGS
#define idh__dx_const_dpsessionflags_dplay_vb 867720                                //  CONST_DPSESSIONFLAGS
#define idh__dx_const_dpsetflags_dplay_vb 867721                                    //  CONST_DPSETFLAGS
#define idh__dx_directsound_dsound_vb 867722                                        //  DirectSound
#define idh__dx_directsound_compact_dsound_vb 867723                                //  DirectSound.Compact
#define idh__dx_directsound_createsoundbuffer_dsound_vb 867724                      //  DirectSound.CreateSoundBuffer
#define idh__dx_directsound_createsoundbufferfromfile_dsound_vb 867725              //  DirectSound.CreateSoundBufferFromFile
#define idh__dx_directsound_createsoundbufferfromresource_dsound_vb 867726          //  DirectSound.CreateSoundBufferFromResource
#define idh__dx_directsound_duplicatesoundbuffer_dsound_vb 867727                   //  DirectSound.DuplicateSoundBuffer
#define idh__dx_directsound_getcaps_dsound_vb 867728                                //  DirectSound.GetCaps
#define idh__dx_directsound_getspeakerconfig_dsound_vb 867729                       //  DirectSound.GetSpeakerConfig
#define idh__dx_directsound_setcooperativelevel_dsound_vb 867730                    //  DirectSound.SetCooperativeLevel
#define idh__dx_directsound_setspeakerconfig_dsound_vb 867731                       //  DirectSound.SetSpeakerConfig
#define idh__dx_directsound3dbuffer_dsound_vb 867732                                //  DirectSounD3DBuffer
#define idh__dx_directsound3dbuffer_getallparameters_dsound_vb 867733               //  DirectSounD3DBuffer.GetAllParameters
#define idh__dx_directsound3dbuffer_getconeangles_dsound_vb 867734                  //  DirectSounD3DBuffer.GetConeAngles
#define idh__dx_directsound3dbuffer_getconeorientation_dsound_vb 867735             //  DirectSounD3DBuffer.GetConeOrientation
#define idh__dx_directsound3dbuffer_getconeoutsidevolume_dsound_vb 867736           //  DirectSounD3DBuffer.GetConeOutsideVolume
#define idh__dx_directsound3dbuffer_getdirectsound3dlistener_dsound_vb 867737       //  DirectSounD3DBuffer.GetDirectSounD3DListener
#define idh__dx_directsound3dbuffer_getdirectsoundbuffer_dsound_vb 867738           //  DirectSounD3DBuffer.GetDirectSoundBuffer
#define idh__dx_directsound3dbuffer_getmaxdistance_dsound_vb 867739                 //  DirectSounD3DBuffer.GetMaxDistance
#define idh__dx_directsound3dbuffer_getmindistance_dsound_vb 867740                 //  DirectSounD3DBuffer.GetMinDistance
#define idh__dx_directsound3dbuffer_getmode_dsound_vb 867741                        //  DirectSounD3DBuffer.GetMode
#define idh__dx_directsound3dbuffer_getposition_dsound_vb 867742                    //  DirectSounD3DBuffer.GetPosition
#define idh__dx_directsound3dbuffer_getvelocity_dsound_vb 867743                    //  DirectSounD3DBuffer.GetVelocity
#define idh__dx_directsound3dbuffer_setallparameters_dsound_vb 867744               //  DirectSounD3DBuffer.SetAllParameters
#define idh__dx_directsound3dbuffer_setconeangles_dsound_vb 867745                  //  DirectSounD3DBuffer.SetConeAngles
#define idh__dx_directsound3dbuffer_setconeorientation_dsound_vb 867746             //  DirectSounD3DBuffer.SetConeOrientation
#define idh__dx_directsound3dbuffer_setconeoutsidevolume_dsound_vb 867747           //  DirectSounD3DBuffer.SetConeOutsideVolume
#define idh__dx_directsound3dbuffer_setmaxdistance_dsound_vb 867748                 //  DirectSounD3DBuffer.SetMaxDistance
#define idh__dx_directsound3dbuffer_setmindistance_dsound_vb 867749                 //  DirectSounD3DBuffer.SetMinDistance
#define idh__dx_directsound3dbuffer_setmode_dsound_vb 867750                        //  DirectSounD3DBuffer.SetMode
#define idh__dx_directsound3dbuffer_setposition_dsound_vb 867751                    //  DirectSounD3DBuffer.SetPosition
#define idh__dx_directsound3dbuffer_setvelocity_dsound_vb 867752                    //  DirectSounD3DBuffer.SetVelocity
#define idh__dx_directsound3dlistener_dsound_vb 867753                              //  DirectSounD3DListener
#define idh__dx_directsound3dlistener_commitdeferredsettings_dsound_vb 867754       //  DirectSounD3DListener.CommitDeferredSettings
#define idh__dx_directsound3dlistener_getallparameters_dsound_vb 867755             //  DirectSounD3DListener.GetAllParameters
#define idh__dx_directsound3dlistener_getdirectsoundbuffer_dsound_vb 867756         //  DirectSounD3DListener.GetDirectSoundBuffer
#define idh__dx_directsound3dlistener_getdistancefactor_dsound_vb 867757            //  DirectSounD3DListener.GetDistanceFactor
#define idh__dx_directsound3dlistener_getdopplerfactor_dsound_vb 867758             //  DirectSounD3DListener.GetDopplerFactor
#define idh__dx_directsound3dlistener_getorientation_dsound_vb 867759               //  DirectSounD3DListener.GetOrientation
#define idh__dx_directsound3dlistener_getposition_dsound_vb 867760                  //  DirectSounD3DListener.GetPosition
#define idh__dx_directsound3dlistener_getrollofffactor_dsound_vb 867761             //  DirectSounD3DListener.GetRolloffFactor
#define idh__dx_directsound3dlistener_getvelocity_dsound_vb 867762                  //  DirectSounD3DListener.GetVelocity
#define idh__dx_directsound3dlistener_setallparameters_dsound_vb 867763             //  DirectSounD3DListener.SetAllParameters
#define idh__dx_directsound3dlistener_setdistancefactor_dsound_vb 867764            //  DirectSounD3DListener.SetDistanceFactor
#define idh__dx_directsound3dlistener_setdopplerfactor_dsound_vb 867765             //  DirectSounD3DListener.SetDopplerFactor
#define idh__dx_directsound3dlistener_setorientation_dsound_vb 867766               //  DirectSounD3DListener.SetOrientation
#define idh__dx_directsound3dlistener_setposition_dsound_vb 867767                  //  DirectSounD3DListener.SetPosition
#define idh__dx_directsound3dlistener_setrollofffactor_dsound_vb 867768             //  DirectSounD3DListener.SetRolloffFactor
#define idh__dx_directsound3dlistener_setvelocity_dsound_vb 867769                  //  DirectSounD3DListener.SetVelocity
#define idh__dx_directsoundbuffer_dsound_vb 867770                                  //  DirectSoundBuffer
#define idh__dx_directsoundbuffer_getcaps_dsound_vb 867771                          //  DirectSoundBuffer.GetCaps
#define idh__dx_directsoundbuffer_getcurrentposition_dsound_vb 867772               //  DirectSoundBuffer.GetCurrentPosition
#define idh__dx_directsoundbuffer_getdirectsound3dbuffer_dsound_vb 867773           //  DirectSoundBuffer.GetDirectSounD3DBuffer
#define idh__dx_directsoundbuffer_getdirectsound3dlistener_dsound_vb 867774         //  DirectSoundBuffer.GetDirectSounD3DListener
#define idh__dx_directsoundbuffer_getformat_dsound_vb 867775                        //  DirectSoundBuffer.GetFormat
#define idh__dx_directsoundbuffer_getfrequency_dsound_vb 867776                     //  DirectSoundBuffer.GetFrequency
#define idh__dx_directsoundbuffer_getpan_dsound_vb 867777                           //  DirectSoundBuffer.GetPan
#define idh__dx_directsoundbuffer_getstatus_dsound_vb 867778                        //  DirectSoundBuffer.GetStatus
#define idh__dx_directsoundbuffer_getvolume_dsound_vb 867779                        //  DirectSoundBuffer.GetVolume
#define idh__dx_directsoundbuffer_play_dsound_vb 867780                             //  DirectSoundBuffer.Play
#define idh__dx_directsoundbuffer_readbuffer_dsound_vb 867781                       //  DirectSoundBuffer.ReadBuffer
#define idh__dx_directsoundbuffer_restore_dsound_vb 867782                          //  DirectSoundBuffer.Restore
#define idh__dx_directsoundbuffer_setcurrentposition_dsound_vb 867783               //  DirectSoundBuffer.SetCurrentPosition
#define idh__dx_directsoundbuffer_setformat_dsound_vb 867784                        //  DirectSoundBuffer.SetFormat
#define idh__dx_directsoundbuffer_setfrequency_dsound_vb 867785                     //  DirectSoundBuffer.SetFrequency
#define idh__dx_directsoundbuffer_setnotificationpositions_dsound_vb 867786         //  DirectSoundBuffer.SetNotificationPositions
#define idh__dx_directsoundbuffer_setpan_dsound_vb 867787                           //  DirectSoundBuffer.SetPan
#define idh__dx_directsoundbuffer_setvolume_dsound_vb 867788                        //  DirectSoundBuffer.SetVolume
#define idh__dx_directsoundbuffer_stop_dsound_vb 867789                             //  DirectSoundBuffer.Stop
#define idh__dx_directsoundbuffer_writebuffer_dsound_vb 867790                      //  DirectSoundBuffer.WriteBuffer
#define idh__dx_directsoundcapture_dsound_vb 867791                                 //  DirectSoundCapture
#define idh__dx_directsoundcapture_createcapturebuffer_dsound_vb 867792             //  DirectSoundCapture.CreateCaptureBuffer
#define idh__dx_directsoundcapture_getcaps_dsound_vb 867793                         //  DirectSoundCapture.GetCaps
#define idh__dx_directsoundcapturebuffer_dsound_vb 867794                           //  DirectSoundCaptureBuffer
#define idh__dx_directsoundcapturebuffer_getcaps_dsound_vb 867795                   //  DirectSoundCaptureBuffer.GetCaps
#define idh__dx_directsoundcapturebuffer_getcurrentposition_dsound_vb 867796        //  DirectSoundCaptureBuffer.GetCurrentPosition
#define idh__dx_directsoundcapturebuffer_getformat_dsound_vb 867797                 //  DirectSoundCaptureBuffer.GetFormat
#define idh__dx_directsoundcapturebuffer_getstatus_dsound_vb 867798                 //  DirectSoundCaptureBuffer.GetStatus
#define idh__dx_directsoundcapturebuffer_readbuffer_dsound_vb 867799                //  DirectSoundCaptureBuffer.ReadBuffer
#define idh__dx_directsoundcapturebuffer_setnotificationpositions_dsound_vb 867800  //  DirectSoundCaptureBuffer.SetNotificationPositions
#define idh__dx_directsoundcapturebuffer_start_dsound_vb 867801                     //  DirectSoundCaptureBuffer.Start
#define idh__dx_directsoundcapturebuffer_stop_dsound_vb 867802                      //  DirectSoundCaptureBuffer.Stop
#define idh__dx_directsoundcapturebuffer_writebuffer_dsound_vb 867803               //  DirectSoundCaptureBuffer.WriteBuffer
#define idh__dx_directsoundenum_dsound_vb 867804                                    //  DirectSoundEnum
#define idh__dx_directsoundenum_getcount_dsound_vb 867805                           //  DirectSoundEnum.GetCount
#define idh__dx_directsoundenum_getitem_dsound_vb 867806                            //  DirectSoundEnum.GetItem
#define idh__dx_directx7_dsound_vb 867807                                           //  DirectX7
#define idh__dx_ds3dbuffer_dsound_vb 867808                                         //  DS3DBUFFER
#define idh__dx_ds3dlistener_dsound_vb 867809                                       //  DS3DLISTENER
#define idh__dx_dsbcaps_dsound_vb 867810                                            //  DSBCAPS
#define idh__dx_dsbpositionnotify_dsound_vb 867811                                  //  DSBPOSITIONNOTIFY
#define idh__dx_dsbufferdesc_dsound_vb 867812                                       //  DSBUFFERDESC
#define idh__dx_dscaps_dsound_vb 867813                                             //  DSCAPS
#define idh__dx_dscbcaps_dsound_vb 867814                                           //  DSCBCAPS
#define idh__dx_dscbufferdesc_dsound_vb 867815                                      //  DSCBUFFERDESC
#define idh__dx_dsccaps_dsound_vb 867816                                            //  DSCCAPS
#define idh__dx_dscursors_dsound_vb 867817                                          //  DSCURSORS
#define idh__dx_dxdriverinfo_dsound_vb 867818                                       //  DXDRIVERINFO
#define idh__dx_waveformatex_dsound_vb 867819                                       //  WAVEFORMATEX
#define idh__dx_const_ds3dapplyflags_dsound_vb 867820                               //  CONST_DS3DAPPLYFLAGS
#define idh__dx_const_ds3dmodeflags_dsound_vb 867821                                //  CONST_DS3DMODEFLAGS
#define idh__dx_const_dsbcapsflags_dsound_vb 867822                                 //  CONST_DSBCAPSFLAGS
#define idh__dx_const_dsblockflags_dsound_vb 867823                                 //  CONST_DSBLOCKFLAGS
#define idh__dx_const_dsbplayflags_dsound_vb 867824                                 //  CONST_DSBPLAYFLAGS
#define idh__dx_const_dsbstatusflags_dsound_vb 867825                               //  CONST_DSBSTATUSFLAGS
#define idh__dx_const_dscapsflags_dsound_vb 867826                                  //  CONST_DSCAPSFLAGS
#define idh__dx_const_dscbcapsflags_dsound_vb 867827                                //  CONST_DSCBCAPSFLAGS
#define idh__dx_const_dscblockflags_dsound_vb 867828                                //  CONST_DSCBLOCKFLAGS
#define idh__dx_const_dscbstartflags_dsound_vb 867829                               //  CONST_DSCBSTARTFLAGS
#define idh__dx_const_dscbstatusflags_dsound_vb 867830                              //  CONST_DSCBSTATUSFLAGS
#define idh__dx_const_dsccapsflags_dsound_vb 867831                                 //  CONST_DSCCAPSFLAGS
#define idh__dx_const_dsound_dsound_vb 867832                                       //  CONST_DSOUND
#define idh__dx_const_dssclflags_dsound_vb 867833                                   //  CONST_DSSCLFLAGS
#define idh__dx_const_dsspeakerflags_dsound_vb 867834                               //  CONST_DSSPEAKERFLAGS
#define idh__dx_const_waveformatflags_dsound_vb 867835                              //  CONST_WAVEFORMATFLAGS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmbandobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmbandobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmSegmentObj.h"
#include "dmPerformanceObj.h"
#include "dmBandObj.h"


extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicBand;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicBand, {});
DESTRUCTOR(_dxj_DirectMusicBand, {});
GETSET_OBJECT(_dxj_DirectMusicBand);

typedef IDirectMusicSegment8*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance8*	LPDIRECTMUSICPERFORMANCE;


HRESULT C_dxj_DirectMusicBandObject::createSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{  
	HRESULT hr;			
	LPDIRECTMUSICSEGMENT pSeg=NULL;
	IDirectMusicSegment*	pSegment = NULL;

	hr=m__dxj_DirectMusicBand->CreateSegment(&pSegment);
	if FAILED(hr) return hr;

	if (!pSegment) return E_FAIL;

	hr = pSegment->QueryInterface(IID_IDirectMusicSegment8, (void**)&pSeg);
	pSegment->Release();
	if (FAILED (hr) ) return hr;

	if (!pSeg) return E_FAIL;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,ret);
	return hr;
}


HRESULT C_dxj_DirectMusicBandObject::download( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *downloadpath)
{  
	HRESULT hr;	

	IDirectMusicPerformance	*lpPerf = NULL;
	DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,downloadpath);

	hr = pPer->QueryInterface(IID_IDirectMusicPerformance,(void**)&lpPerf);
	if (FAILED(hr))
	{
		pPer->Release();
		return hr;
	}
	pPer->Release();

	hr=m__dxj_DirectMusicBand->Download(lpPerf);
	return hr;
}

HRESULT C_dxj_DirectMusicBandObject::unload( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *downloadpath)
{  
	HRESULT hr;	

	IDirectMusicPerformance	*lpPerf = NULL;
	DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,downloadpath);

	hr = pPer->QueryInterface(IID_IDirectMusicPerformance,(void**)&lpPerf);
	if (FAILED(hr))
	{
		pPer->Release();
		return hr;
	}
	pPer->Release();

	hr=m__dxj_DirectMusicBand->Unload(lpPerf);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\direct.cpp ===
// Direct.cpp : Implementation of DLL Exports.
    
    // To fully complete this project follow these steps
    
    // You will need the new MIDL compiler to build this project.  Additionally,
    // if you are building the proxy stub DLL, you will need new headers and libs.
    
    // 1) Add a custom build step to Direct.idl
    //		You can select all of the .IDL files by holding Ctrl and clicking on
    //		each of them.
    //
    //		Description
    //			Running MIDL
    //		Build Command(s)
    //			midl Direct.idl
    //		Outputs 
    //			Direct.tlb
    //			Direct.h
    //			Direct_i.c
    //
    // NOTE: You must use the MIDL compiler from NT 4.0,
    // preferably 3.00.15 or greater
    //
    // 2) Add a custom build step to the project to register the DLL
    //		For this, you can select all projects at once
    //		Description
    //			Registering OLE Server...
    //		Build Command(s)
    //			regsvr32 /s /c "$(TargetPath)"
    //			echo regsvr32 exec. time > "$(OutDir)\regsvr32.trg"
    //		Outputs
    //			$(OutDir)\regsvr32.trg
    
    // 3) To add UNICODE support, follow these steps
    //		Select Build|Configurations...
    //		Press Add...
    //		Change the configuration name to Unicode Release
    //		Change the "Copy Settings From" combo to Direct - Win32 Release
    //		Press OK
    //		Press Add...
    //		Change the configuration name to Unicode Debug
    //		Change the "Copy Settings From" combo to Direct - Win32 Debug
    //		Press OK
    //		Press "Close"
    //		Select Build|Settings...
    //		Select the two UNICODE projects and press the C++ tab.
    //		Select the "General" category
    //		Add _UNICODE to the Preprocessor definitions
    //		Select the Unicode Debug project
    //		Press the "General" tab
    //		Specify DebugU for the intermediate and output directories
    //		Select the Unicode Release project
    //		Press the "General" tab
    //		Specify ReleaseU for the intermediate and output directories
    
    // 4) Proxy stub DLL
    //		To build a separate proxy/stub DLL,
    //		run nmake -f ps.mak in the project directory.
    

    
    #include "stdafx.h"
    #include "d3d8.h"    

    #include "resource.h"
    #include "initguid.h"
    #include "Direct.h"
    #include "dms.h"
    
    #include "DxGlob7Obj.h"
    #include "d3dx8obj.h"	    
    #include "dSoundObj.h"
    #include "dSoundBufferObj.h"
    #include "dSound3DListener.h"
    #include "dSound3DBuffer.h"
    #include "dSoundCaptureObj.h"
    #include "dSoundCaptureBufferObj.h"


    #include "DPlayPeerObj.h"
    #include "dPlayVoiceClientObj.h"
    
    #include "dInput1Obj.h"
    #include "dInputDeviceObj.h"
    
    #define IID_DEFINED
    #include "Direct_i.c"
    
    // When floating-point types are used, the compiler emits a reference to
    // _fltused to initialize the CRT's floating-point package.  We're not
    // using any of that support and the OS is responsible for initializing
    // the FPU, so we'll link to the following _fltused instead to avoid CRT
    // bloat.
    //
    // win2k doesnt like this so its been removed
    // #ifdef NDEBUG
    // extern "C" int _fltused = 0;
    // #endif
    
    
    
    // ATL COM OBJECT MAP
    CComModule _Module;
    BEGIN_OBJECT_MAP(ObjectMap)
    	OBJECT_ENTRY(CLSID__dxj_DirectX8,				 C_dxj_DirectX7Object)
	OBJECT_ENTRY(CLSID_D3DX8,				 	 C_dxj_D3DX8Object)
    END_OBJECT_MAP()
    
    //
    // thanks to precompiled headers, we never get this properly!
    //
    #undef DEFINE_GUID
    #define __based(a)
    #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                        = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
    
    
    
    // MISC GLOBALS
    static const char	c_szWav[] = "WAVE";
    long				g_debuglevel=0;
    extern "C" int		nObjects = 0;
    BOOL				is4Bit = FALSE;
    int					g_creationcount=0;
    CRITICAL_SECTION	g_cbCriticalSection;
    OSVERSIONINFOW		sysinfo;
    
    // HANDLES TO DX DLLS
    HINSTANCE			g_hDSoundHandle=NULL;
    HINSTANCE			g_hDPlay=NULL;
    HINSTANCE			g_hInstDINPUTDLL=NULL;
    HINSTANCE			g_hInstD3DXOFDLL=NULL;
    HINSTANCE			g_hInst=NULL;
    HINSTANCE			g_hD3D8=NULL;
    
    
    
    void *g_dxj_DirectSound3dListener		= 0;
    void *g_dxj_DirectSoundBuffer			= 0;
    void *g_dxj_DirectSoundPrimaryBuffer	= 0;
    void *g_dxj_DirectSound3dBuffer			= 0;
    void *g_dxj_DirectSound					= 0;
    void *g_dxj_DirectSoundCapture			= 0;
    void *g_dxj_DirectSoundCaptureBuffer	= 0;
#if 0
    void *g_dxj_DirectMusic					= 0;
    void *g_dxj_DirectSoundWave				= 0;
    void *g_dxj_DirectSoundDownloadedWave	= 0;
    void *g_dxj_DirectSoundSink				= 0;
    void *g_dxj_DirectSoundSource			= 0;
	void *g_dxj_ReferenceClock				= 0;
    void *g_dxj_DirectMusicVoice			= 0;
    void *g_dxj_DirectMusicPort				= 0;
    void *g_dxj_DirectMusicBuffer			= 0;
#endif

	void *g_dxj_DirectSoundFXSend			= 0;
	void *g_dxj_DirectSoundFXChorus			= 0;
	void *g_dxj_DirectSoundFXFlanger		= 0;
	void *g_dxj_DirectSoundFXEcho			= 0;
	void *g_dxj_DirectSoundFXDistortion		= 0;
	void *g_dxj_DirectSoundFXGargle			= 0;
	void *g_dxj_DirectSoundFXCompressor		= 0;
	void *g_dxj_DirectSoundFXI3DL2Source	= 0;
	void *g_dxj_DirectSoundFXI3DL2Reverb	= 0;
	void *g_dxj_DirectSoundFXParamEQ		= 0;
    void *g_dxj_DirectSoundFXWavesReverb	= 0;
    
    void *g_dxj_DirectInput8				= 0;
    void *g_dxj_DirectInputDevice8			= 0;
    void *g_dxj_DirectInputEffect			= 0;
    
    void *g_dxj_DirectMusicLoader			= 0;
    void *g_dxj_DirectMusicPerformance		= 0;
    void *g_dxj_DirectMusicComposer			= 0;
    void *g_dxj_DirectMusicStyle			= 0;
    void *g_dxj_DirectMusicBand				= 0;
    void *g_dxj_DirectMusicChordMap			= 0;
    void *g_dxj_DirectMusicSegment			= 0;
    void *g_dxj_DirectMusicSegmentState		= 0;
    void *g_dxj_DirectMusicCollection		= 0;
	void *g_dxj_DirectMusicAudioPath		= 0;
	void *g_dxj_DirectMusicSong				= 0;

    void *g_dxj_DirectPlayVoiceClient		= 0;
    void *g_dxj_DirectPlayVoiceServer		= 0;
    void *g_dxj_DirectPlayVoiceSetup		= 0;
	void *g_dxj_DirectPlay					= 0;
	void *g_dxj_DirectPlayPeer				= 0;
	void *g_dxj_DirectPlayServer			= 0;
	void *g_dxj_DirectPlayClient			= 0;
	void *g_dxj_DirectPlayAddress			= 0;    
	void *g_dxj_DirectPlayLobbyClient		= 0;
	void *g_dxj_DirectPlayLobbiedApplication= 0;

    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    //
    // DLL LOADING
    //
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    
    HINSTANCE LoadD3DXOFDLL()
    {
    	//char  Path[MAX_PATH];
    	//if (!g_hInstD3DXOFDLL) 
    	//{
    	//	GetSystemDirectory( Path, MAX_PATH );
    	//	strcat(Path, "\\d3dXOF.dll" );
    	//	g_hInstD3DXOFDLL=LoadLibrary(Path);	
    	//}

	if (!g_hInstD3DXOFDLL) g_hInstD3DXOFDLL=LoadLibrary("d3dXOF.dll");
    	return g_hInstD3DXOFDLL;
    }

    
    HINSTANCE LoadD3D8DLL()
    {
    
	if (!g_hD3D8) g_hD3D8=LoadLibrary("d3d8.dll");
    	return g_hD3D8;
    }
    
    HINSTANCE LoadDSoundDLL()
    {
    	//char  Path[MAX_PATH];
    	//if (!g_hDSoundHandle) 
    	//{
    	//	GetSystemDirectory( Path, MAX_PATH );
    	//	strcat(Path, "\\dsound.dll" );
    	//	g_hDSoundHandle=LoadLibrary( Path );
    	//}
	if (!g_hDSoundHandle) g_hDSoundHandle=LoadLibrary("dsound.dll");
    	return g_hDSoundHandle;
    }
    
    HINSTANCE LoadDPlayDLL()
    {
    	//char  Path[MAX_PATH];
    	//if (!g_hDPlay)
    	//{
    	//	GetSystemDirectory( Path, MAX_PATH );
    	//	strcat(Path, "\\dplayx.dll" );
    	//	g_hDPlay=LoadLibrary( Path );
    	//}
	if (!g_hDPlay) g_hDPlay=LoadLibrary("dplayx.dll");
    	return g_hDPlay;
    }
    
    
    HINSTANCE LoadDINPUTDLL()
    {
    	//if (!g_hInstDINPUTDLL) {
    	//	char  Path[MAX_PATH];
    	//	GetSystemDirectory( Path, MAX_PATH );
    	//	strcat(Path, "\\dinput8.dll" );
    	//	g_hInstDINPUTDLL=LoadLibrary( Path );
    	//}
	if (!g_hInstDINPUTDLL) g_hInstDINPUTDLL=LoadLibrary("dinput8.dll");
    	return g_hInstDINPUTDLL;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    //
    // DLL ENTRY POINTS
    //
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    
    /////////////////////////////////////////////////////////////////////////////
    // DLL Entry Point
    extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
    {
    
    	g_hInst=hInstance;
    
    	if (dwReason == DLL_PROCESS_ATTACH)
    	{
    		//
    		// Get the current display pixel depth
    		// If it is 4-bit we are in trouble.
    		//
            HDC hDisplayIC;
            BOOL bPalette = FALSE;
            hDisplayIC = CreateIC("DISPLAY", NULL, NULL, NULL);
    		if (hDisplayIC)
            {
    			if (GetDeviceCaps(hDisplayIC, BITSPIXEL) < 8)
    				is4Bit = TRUE;
    			DeleteDC(hDisplayIC);
            }
    
    		_Module.Init(ObjectMap, hInstance);
    		DisableThreadLibraryCalls(hInstance);
    		InitializeCriticalSection(&g_cbCriticalSection);

			HKEY hk=0;
    		DWORD type=REG_DWORD;
			LONG res;
			DWORD cbSize = sizeof(DWORD);
			
    		res=RegOpenKey(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Directx\\DXVB",&hk);
			if (hk)
			{
	    		res=RegQueryValueEx(hk,"DebugLevel",NULL,&type,(LPBYTE)&g_debuglevel,&cbSize);
			}

    		RegCloseKey(hk);

    		nObjects = 0;
    		
    
    	}
    	else if (dwReason == DLL_PROCESS_DETACH)
    	{
    
		DeleteCriticalSection(&g_cbCriticalSection);    

    		//FREE DLLS
    		if ( g_hDPlay ) 
    			FreeLibrary(g_hDPlay);
    		if ( g_hDSoundHandle )
    			FreeLibrary(g_hDSoundHandle);
    		if ( g_hInstDINPUTDLL )
    			FreeLibrary(g_hInstDINPUTDLL);	
    		if (g_hInstD3DXOFDLL)
    			FreeLibrary(g_hInstD3DXOFDLL);	
    		if (g_hD3D8)
    			FreeLibrary(g_hD3D8);	
    		
    		_Module.Term();
    
    	}
    	return TRUE;    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Used to determine whether the DLL can be unloaded by OLE
    STDAPI DllCanUnloadNow(void)
    {
    	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // Returns a class factory to create an object of the requested type
    STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
    {
    	return _Module.GetClassObject(rclsid, riid, ppv);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // DllRegisterServer - Adds entries to the system registry
    STDAPI DllRegisterServer(void)
    {
    	HRESULT hRes = S_OK;
    	// registers object, typelib and all interfaces in typelib
    	hRes = _Module.RegisterServer(TRUE);
    	if(hRes == S_OK)
    	{
    		//hRes = RegSecurityClass();
    	}
    
    	//now look
    	HKEY hk=0;
    	char szDocPath[MAX_PATH];
    	DWORD cb=MAX_PATH;
    	LONG res;
    	DWORD type=REG_SZ;
    
    	ZeroMemory(szDocPath,MAX_PATH);
    	
    	res=RegOpenKey(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Directx",&hk);
    	if ((ERROR_SUCCESS!=res)||(hk==0) )
    		return hRes;
    
    	
    	
    	res=RegQueryValueEx(hk,"DX81SDK Doc Path",NULL,&type,(LPBYTE)szDocPath,&cb);
    	RegCloseKey(hk);
    
    	if (ERROR_SUCCESS!=res) return hRes;
    
    	hk=0;
    
    	res=RegOpenKey(HKEY_LOCAL_MACHINE,"Software\\CLASSES\\TypeLib\\{E1211242-8E94-11d1-8808-00C04FC2C603}\\1.0\\HELPDIR",&hk);
    	if (ERROR_SUCCESS!=res) return hRes;
    
    	RegSetValueEx(hk,NULL,0,REG_SZ,(LPBYTE)szDocPath,cb);
    	RegCloseKey(hk);
    
    
    	return hRes;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // DllUnregisterServer - Adds entries to the system registry
    STDAPI DllUnregisterServer(void)
    {
    	HRESULT hRes = S_OK;
    	hRes = _Module.UnregisterServer();
    	if(hRes == S_OK)
    	{
    		//hRes = UnRegSecurityClass();
    	}
    
    	return hRes;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    //
    // GUID CONVERSION FUNCTIONS
    //
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    
    /////////////////////////////////////////////////////////////////////////////
    // GUIDS_EQUAL - consider moving to dms.h
    
    #define GUIDS_EQUAL(g,g2) (\
    	(g.Data1==g2->Data1) && \
    	(g.Data2==g2->Data2) && \
    	(g.Data3==g2->Data3) && \
    	(g.Data4[0]==g2->Data4[0]) && \
    	(g.Data4[1]==g2->Data4[1]) && \
    	(g.Data4[2]==g2->Data4[2]) && \
    	(g.Data4[3]==g2->Data4[3]) && \
    	(g.Data4[4]==g2->Data4[4]) && \
    	(g.Data4[5]==g2->Data4[5]) && \
    	(g.Data4[6]==g2->Data4[6]) && \
    	(g.Data4[7]==g2->Data4[7]) )
    
    
    /////////////////////////////////////////////////////////////////////////////
    // GUIDtoBSTR - does conversion
    
    BSTR GUIDtoBSTR(LPGUID pGuid){
    	char  szOut[256];	
    	char  szTemp[10];
    	char  *pAt=NULL;
    	int	  i;
    	BSTR  bstrOut;
    
    	// 00000000001111111111222222222233333333
    	// 01234567890123456789012345678901234567
    	// {XXXXXXXX-XXXX-XXXX-X  XXX-XXXXXXXXXXXX}
    	if (pGuid!=NULL){
    
    		szOut[0]='{';
    		
    		wsprintf(&(szOut)[1],"%.8X",pGuid->Data1);
    		
    		szOut[9]='-';
    		
    		wsprintf(szTemp,"%.4X",pGuid->Data2);
    		memcpy(&(szOut[10]),szTemp,4);
    
    		szOut[14]='-';
    
    		wsprintf(szTemp,"%.4X",pGuid->Data3);
    		memcpy(&(szOut[15]),szTemp,4);
    
    		szOut[19]='-';
    
    		for (i=0;i<2;i++){
    			wsprintf(szTemp,"%.2X",pGuid->Data4[i]);
    			memcpy(&(szOut[20+i*2]),szTemp,2);
    			
    		}
    
    		szOut[24]='-';
    
    		for (i=2;i<8;i++){
    			wsprintf(szTemp,"%.2X",pGuid->Data4[i]);
    			memcpy(&(szOut[21+i*2]),szTemp,2);
    			
    		}
    
    		szOut[37]='}';
    		szOut[38]='\0';
    
    		USES_CONVERSION;
    		bstrOut = T2BSTR(szOut);
    
    	}
    	else {
    		bstrOut = T2BSTR("");
    	}
    		
    
    	
    	return bstrOut;
    }
    
    //////////////////////////////////////////////////////////////////////////////
    // convertChar
    // helper for GUIDtoBSTR
    HRESULT convertChar(char *szIn,int i,char *valOut){
    	int val[2];	//using int for easy out of bounds check
    	
    	char c;
    	int j;
    	
    	for (j=0;j<2;j++){
    	   c= szIn[i+j];
    	   switch (c)
    	   {
    		case 'a':
    		case 'A':
    			val[j]=10;
    			break;
    		case 'b':
    		case 'B':
    			val[j]=11;
    			break;
    		case 'c':
    		case 'C':
    			val[j]=12;
    			break;
    		case 'd':
    		case 'D':
    			val[j]=13;
    			break;
    
    		case 'e':
    		case 'E':
    			val[j]=14;
    			break;
    		case 'f':
    		case 'F':
    			val[j]=15;
    			break;
    		default:
    			val[j]=c-'0';
    			if (val[j]<0) return E_INVALIDARG;
    			if (val[j]>15) return E_INVALIDARG;
    			break;
    	   }
    	}
    
    
    	*valOut=(char)((val[0]<<4)|val[1]);
    	return S_OK;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // BSTRtoGUID - does conversion
    //
    HRESULT BSTRtoGUID(LPGUID pGuid, BSTR bstr){
    	HRESULT hr;
    	//byte
    	// 
    	// 
    	//char
    	//           1111111111222222222233333333
    	// 01234567890123456789012345678901234567
    	// {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}	
    	USES_CONVERSION;
    	if(!pGuid) return E_INVALIDARG;
    	ZeroMemory(pGuid,sizeof(GUID));	
    	if (!bstr) return S_OK;
    		
    	if (bstr[0]==0x00) return S_OK;
    
    	LPSTR szGuid=W2T(bstr);
    	
    	//first and last char should be { }
    	if ((szGuid[0]!='{')||(szGuid[37]!='}'))
    		return E_INVALIDARG;
    	if ((szGuid[9]!='-')||(szGuid[14]!='-')||(szGuid[19]!='-')||(szGuid[24]!='-'))
    		return E_INVALIDARG;
    	
    	char val;
    	char *pData=(char*)pGuid;
    	int j=0;
    	int i;
    	
    	//FIRST DWORD
    	for ( i=7;i>=1;i=i-2){
    		hr=convertChar(szGuid,i,&val);
    		if FAILED(hr) return hr;				
    		pData[j++]=val;
    	}
    
    	//FIRST WORD
    	for ( i=12;i>=10;i=i-2){
    		hr=convertChar(szGuid,i,&val);
    		if FAILED(hr) return hr;
    		pData[j++]=val;
    	}
    
    	//2nd WORD
    	for ( i=17;i>=15;i=i-2){
    		hr=convertChar(szGuid,i,&val);
    		if FAILED(hr) return hr;
    		pData[j++]=val;
    	}
    
    
    	//3rd DWORD - BYTE ARRAY
    	for ( i=20;i<24;i=i+2){
    		hr=convertChar(szGuid,i,&val);
    		if FAILED(hr) return hr;
    		pData[j++]=val;
    	}
    
    	//BYTE ARRAY
    	for ( i=25;i<37;i=i+2){
    		hr=convertChar(szGuid,i,&val);
    		if FAILED(hr) return hr;
    		pData[j++]=val;
    	}
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // 
    //
    HRESULT BSTRtoPPGUID(LPGUID *ppGuid, BSTR bstr){
    	if (!ppGuid) return E_INVALIDARG;
    	if ((bstr==NULL)||(bstr[0]=='\0')){
    		*ppGuid=NULL;
    		return S_OK;
    	}
    	return BSTRtoGUID(*ppGuid,bstr);
    
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // D3DBSTRtoGUID - does conversion
    //
    HRESULT D3DBSTRtoGUID(LPGUID pGuid,BSTR str){
    	HRESULT hr=S_OK;
    
    	if (!pGuid) return E_INVALIDARG;
    	if (!str) {
    		ZeroMemory(pGuid,sizeof(GUID));
    		return S_OK;
    	}
    	//if( 0==_wcsicmp(str,L"iid_idirect3drgbdevice")){
    	//		memcpy(pGuid,&IID_IDirect3DRGBDevice,sizeof(GUID));
    	//}
    	//else if( 0==_wcsicmp(str,L"iid_idirect3dhaldevice")){
    	//		memcpy(pGuid,&IID_IDirect3DHALDevice,sizeof(GUID));
    	//}
    	//else if( 0==_wcsicmp(str,L"iid_idirect3dmmxdevice")){
    	//		memcpy(pGuid,&IID_IDirect3DMMXDevice,sizeof(GUID));
    	//}
    	//else if( 0==_wcsicmp(str,L"iid_idirect3drefdevice")){
    	//		memcpy(pGuid,&IID_IDirect3DRefDevice,sizeof(GUID));
    	//}
    	//else if( 0==_wcsicmp(str,L"iid_idirect3dnulldevice")){
    	//		memcpy(pGuid,&IID_IDirect3DNullDevice,sizeof(GUID));
    	//}
    	//else {
    	//	hr = BSTRtoGUID(pGuid,str);
    	//}
    
    	return hr;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // D3DGUIDtoBSTR - does conversion
    //
    BSTR D3DGUIDtoBSTR(LPGUID pg){
    
    	HRESULT hr=S_OK;
    	WCHAR *pStr=NULL;
    
    	if (!pg)
    		return NULL;
    	//else if (GUIDS_EQUAL(IID_IDirect3DNullDevice,pg)){
    	//	pStr=L"IID_IDirect3DNullDevice";
    	//}
    	//else if (GUIDS_EQUAL(IID_IDirect3DRefDevice,pg)){
    	//	pStr=L"IID_IDirect3DRefDevice";
    	//}
    	//else if (GUIDS_EQUAL(IID_IDirect3DMMXDevice,pg)){
    	//	pStr=L"IID_IDirect3DMMXDevice";
    	//}
    	//
    	//else if (GUIDS_EQUAL(IID_IDirect3DHALDevice,pg)){
    	//	pStr=L"IID_IDirect3DHALDevice";
    	//}
    	//else if (GUIDS_EQUAL(IID_IDirect3DRGBDevice,pg)){
    	//	pStr=L"IID_IDirect3DRGBDevice";
    	//}
    	//

    	if (pStr){
    		return DXALLOCBSTR(pStr);
    	}
    	else {
    		return GUIDtoBSTR(pg);
    	}
    
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // DSOUNDEFFECTSBSTRtoGUID - does conversion
    //
    HRESULT AudioBSTRtoGUID(LPGUID pGuid,BSTR str){
    	HRESULT hr=S_OK;
    
    	if (!pGuid) return E_INVALIDARG;
    
    	if (!str) {
    		ZeroMemory(pGuid,sizeof(GUID));
    		return S_OK;
    	}
#if 0
    	if( 0==_wcsicmp(str,L"guid_dsfx_send")){
    			memcpy(pGuid,&GUID_DSFX_SEND,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxsend")){
    			memcpy(pGuid,&IID_IDirectSoundFXSend,sizeof(GUID));
    	}
#endif
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_chorus")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_CHORUS,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_flanger")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_FLANGER,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_echo")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_ECHO,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_distortion")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_DISTORTION,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_compressor")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_COMPRESSOR,sizeof(GUID));
    	}
#if 0
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_i3dl2source")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_I3DL2SOURCE,sizeof(GUID));
    	}
#endif
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_i3dl2reverb")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_I3DL2REVERB,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_gargle")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_GARGLE,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_standard_parameq")){
    			memcpy(pGuid,&GUID_DSFX_STANDARD_PARAMEQ,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_dsfx_waves_reverb")){
    			memcpy(pGuid,&GUID_DSFX_WAVES_REVERB,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxgargle")){
    			memcpy(pGuid,&IID_IDirectSoundFXGargle,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxchorus")){
    			memcpy(pGuid,&IID_IDirectSoundFXChorus,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxcompressor")){
    			memcpy(pGuid,&IID_IDirectSoundFXCompressor,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxdistortion")){
    			memcpy(pGuid,&IID_IDirectSoundFXDistortion,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxecho")){
    			memcpy(pGuid,&IID_IDirectSoundFXEcho,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxflanger")){
    			memcpy(pGuid,&IID_IDirectSoundFXFlanger,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxi3dl2reverb")){
    			memcpy(pGuid,&IID_IDirectSoundFXI3DL2Reverb,sizeof(GUID));
    	}
#if 0
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxi3dl2source")){
    			memcpy(pGuid,&IID_IDirectSoundFXI3DL2Source,sizeof(GUID));
    	}
#endif
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxparameq")){
    			memcpy(pGuid,&IID_IDirectSoundFXParamEq,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_directsoundfxwavesreverb")){
    			memcpy(pGuid,&IID_IDirectSoundFXWavesReverb,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"ds3dalg_default")){
    			memcpy(pGuid,&DS3DALG_DEFAULT,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"ds3dalg_no_virtualization")){
    			memcpy(pGuid,&DS3DALG_NO_VIRTUALIZATION,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"ds3dalg_hrtf_full")){
    			memcpy(pGuid,&DS3DALG_HRTF_FULL,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"ds3dalg_hrtf_light")){
    			memcpy(pGuid,&DS3DALG_HRTF_LIGHT,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultplayback")){
    			memcpy(pGuid,&DSDEVID_DefaultPlayback,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultcapture")){
    			memcpy(pGuid,&DSDEVID_DefaultCapture,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultvoiceplayback")){
    			memcpy(pGuid,&DSDEVID_DefaultVoicePlayback,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultvoicecapture")){
    			memcpy(pGuid,&DSDEVID_DefaultVoiceCapture,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_idirectsoundbuffer8")){
    			memcpy(pGuid,&IID_IDirectSoundBuffer8,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_idirectsoundbuffer")){
    			memcpy(pGuid,&IID_IDirectSoundBuffer,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_idirectsound3dlistener")){
    			memcpy(pGuid,&IID_IDirectSound3DListener,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_all_objects")){
    			memcpy(pGuid,&GUID_All_Objects,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"iid_idirectsound3dbuffer")){
    			memcpy(pGuid,&IID_IDirectSound3DBuffer,sizeof(GUID));
    	}
    	else {
    		hr = BSTRtoGUID(pGuid,str);
    	}
    
    	return hr;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // DPLAYBSTRtoGUID - does conversion
    //
    HRESULT DPLAYBSTRtoGUID(LPGUID pGuid,BSTR str){
    	HRESULT hr=S_OK;
    
    	if (!pGuid) return E_INVALIDARG;
    
    	if (!str) {
    		ZeroMemory(pGuid,sizeof(GUID));
    		return S_OK;
    	}
    	if( 0==_wcsicmp(str,L"clsid_dp8sp_tcpip")){
    			memcpy(pGuid,&CLSID_DP8SP_TCPIP,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"clsid_dp8sp_ipx")){
    			memcpy(pGuid,&CLSID_DP8SP_IPX,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"clsid_dp8sp_modem")){
    			memcpy(pGuid,&CLSID_DP8SP_MODEM,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"clsid_dp8sp_serial")){
    			memcpy(pGuid,&CLSID_DP8SP_SERIAL,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultplayback")){
    			memcpy(pGuid,&DSDEVID_DefaultPlayback,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultcapture")){
    			memcpy(pGuid,&DSDEVID_DefaultCapture,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultvoiceplayback")){
    			memcpy(pGuid,&DSDEVID_DefaultVoicePlayback,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"dsdevid_defaultvoicecapture")){
    			memcpy(pGuid,&DSDEVID_DefaultVoiceCapture,sizeof(GUID));
    	}
    	else {
    		hr = BSTRtoGUID(pGuid,str);
    	}
    
    	return hr;
    }

    /////////////////////////////////////////////////////////////////////////////
    // DINPUTGUIDtoBSTR
    //
    BSTR DINPUTGUIDtoBSTR(LPGUID pg){
    
    	HRESULT hr=S_OK;
    	WCHAR *pStr=NULL;
    
    	if (!pg)
    		return NULL;
    	else if (GUIDS_EQUAL(GUID_XAxis,pg)){
    		pStr=L"GUID_XAxis";
    	}
    	else if (GUIDS_EQUAL(GUID_YAxis,pg)){
    		pStr=L"GUID_YAxis";
    	}
    	else if (GUIDS_EQUAL(GUID_ZAxis,pg)){
    		pStr=L"GUID_ZAxis";
    	}
    	
    	else if (GUIDS_EQUAL(GUID_RxAxis,pg)){
    		pStr=L"GUID_RxAxis";
    	}
    	else if (GUIDS_EQUAL(GUID_RyAxis,pg)){
    		pStr=L"GUID_RyAxis";
    	}
    	else if (GUIDS_EQUAL(GUID_RzAxis,pg)){
    		pStr=L"GUID_RzAxis";
    	}
    
    	else if (GUIDS_EQUAL(GUID_Slider,pg)){
    		pStr=L"GUID_Slider";
    	}
    	else if (GUIDS_EQUAL(GUID_Button,pg)){
    		pStr=L"GUID_Button";
    	}
    	else if (GUIDS_EQUAL(GUID_Key,pg)){
    		pStr=L"GUID_Key";
    	}
    	else if (GUIDS_EQUAL(GUID_POV,pg)){
    		pStr=L"GUID_POV";
    	}
    	else if (GUIDS_EQUAL(GUID_Unknown,pg)){
    		pStr=L"GUID_Unknown";
    	}
    	else if (GUIDS_EQUAL(GUID_SysMouse,pg)){
    		pStr=L"GUID_SysMouse";
    	}
    	else if (GUIDS_EQUAL(GUID_SysKeyboard,pg)){
    		pStr=L"GUID_SysKeyboard";
    	}
    
    
    	else if (GUIDS_EQUAL(GUID_ConstantForce,pg)){
    		pStr=L"GUID_ConstantForce";
    	}
    	else if (GUIDS_EQUAL(GUID_Square,pg)){
    		pStr=L"GUID_Square";
    	}
    	else if (GUIDS_EQUAL(GUID_Sine,pg)){
    		pStr=L"GUID_Sine";
    	}
    	else if (GUIDS_EQUAL(GUID_Triangle,pg)){
    		pStr=L"GUID_Triangle";
    	}
    	else if (GUIDS_EQUAL(GUID_SawtoothUp,pg)){
    		pStr=L"GUID_SawtoothUp";
    	}
    	else if (GUIDS_EQUAL(GUID_SawtoothDown,pg)){
    		pStr=L"GUID_SawtoothDown";
    	}
    	else if (GUIDS_EQUAL(GUID_Spring,pg)){
    		pStr=L"GUID_Spring";
    	}
    	else if (GUIDS_EQUAL(GUID_Damper,pg)){
    		pStr=L"GUID_Damper";
    	}
    	else if (GUIDS_EQUAL(GUID_Inertia,pg)){
    		pStr=L"GUID_Inertia";
    	}
    	else if (GUIDS_EQUAL(GUID_Friction,pg)){
    		pStr=L"GUID_Friction";
    	}
    	else if (GUIDS_EQUAL(GUID_CustomForce,pg)){
    		pStr=L"GUID_CustomForce";
    	}
    	else if (GUIDS_EQUAL(GUID_RampForce,pg)){
    		pStr=L"GUID_RampForce";
    	}
    
    
    
    
    	//else if (GUIDS_EQUAL(GUID_Joystick,pg)){
    	//	pStr=L"GUID_JoyStick";
    	//}
    
    	if (pStr){
    		return DXALLOCBSTR(pStr);
    	}
    	else {
    		return GUIDtoBSTR(pg);
    	}
    
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    // DINPUTBSTRtoGUID
    //
    HRESULT DINPUTBSTRtoGUID(LPGUID pGuid,BSTR str){
    	HRESULT hr=S_OK;
    
    	if (!pGuid) return E_INVALIDARG;
    
    	if (!str) {
    		ZeroMemory(pGuid,sizeof(GUID));
    		return S_OK;
    	}
    	if( 0==_wcsicmp(str,L"guid_xaxis")){
    			memcpy(pGuid,&GUID_XAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_yaxis")){
    			memcpy(pGuid,&GUID_YAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_zaxis")){
    			memcpy(pGuid,&GUID_ZAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_rxaxis")){
    			memcpy(pGuid,&GUID_RxAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_ryaxis")){
    			memcpy(pGuid,&GUID_RyAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_rzaxis")){
    			memcpy(pGuid,&GUID_RzAxis,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_slider")){
    			memcpy(pGuid,&GUID_Slider,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_button")){
    			memcpy(pGuid,&GUID_Button,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_key")){
    			memcpy(pGuid,&GUID_Key,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_pov")){
    			memcpy(pGuid,&GUID_POV,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_unknown")){
    			memcpy(pGuid,&GUID_Unknown,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_sysmouse")){
    			memcpy(pGuid,&GUID_SysMouse,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_syskeyboard")){
    			memcpy(pGuid,&GUID_SysKeyboard,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_constantforce")){
    			memcpy(pGuid,&GUID_ConstantForce,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_square")){
    			memcpy(pGuid,&GUID_Square,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_sine")){
    			memcpy(pGuid,&GUID_Sine,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_triangle")){
    			memcpy(pGuid,&GUID_Triangle,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_sawtoothup")){
    			memcpy(pGuid,&GUID_SawtoothUp,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_sawtoothdown")){
    			memcpy(pGuid,&GUID_SawtoothDown,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_spring")){
    			memcpy(pGuid,&GUID_Spring,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_damper")){
    			memcpy(pGuid,&GUID_Damper,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_inertia")){
    			memcpy(pGuid,&GUID_Inertia,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_friction")){
    			memcpy(pGuid,&GUID_Friction,sizeof(GUID));
    	}
    	else if( 0==_wcsicmp(str,L"guid_customforce")){
    			memcpy(pGuid,&GUID_CustomForce,sizeof(GUID));
    	}
    
    	else if( 0==_wcsicmp(str,L"guid_rampforce")){
    			memcpy(pGuid,&GUID_RampForce,sizeof(GUID));
    	}
    
    	//else if( 0==_wcsicmp(str,L"guid_joystick")){
    	//		memcpy(pGuid,&GUID_Joystick,sizeof(GUID));
    	//}
    	else {
    		hr = BSTRtoGUID(pGuid,str);
    	}
    
    	return hr;
    }
    
    
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    //
    // GENERAL HELPER FUNCTIONS
    //
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////////
    
    
    /////////////////////////////////////////////////////////////////////////////
    // Given an ANSI string, pass back a UNICODE string
    // SysAllocString is your big friend here.
    //
    // CONSIDER finding all occerence of use and replacint with the
    // T2BSTR macro .. much cleaner
    //
    extern "C" void PassBackUnicode(LPSTR str, BSTR *Name, DWORD cnt)
    {
    	//docdoc: length header is required to be filled, but the BSTR pointer
    	//        points to the first character, not the length.
    	// note, the count can never be too small as we get that from the string
    	// before we pass it in!
    	USES_CONVERSION;
    	LPWSTR lpw = (LPWSTR)malloc((cnt+1)*2);
		if (!lpw)
			return;

    	void *l = (void *)lpw;
    	lpw = AtlA2WHelper(lpw, str, cnt);
    	lpw[cnt] = 0;
    	*Name = SysAllocString(lpw);
    	free(l);
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IsAllZeros
    //
    BOOL IsEmptyString(BSTR szString)
	{
		__try {
			if (*szString)
				return FALSE;
			else
				return TRUE;
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			return TRUE;
		}
	}

    
    /////////////////////////////////////////////////////////////////////////////
    // IsAllZeros
    //
    BOOL IsAllZeros(void *pStruct,DWORD size){
    	for (DWORD i=0;i<size;i++){
    		if (((char*)pStruct)[i]!='\0'){
    			return FALSE;
    		}
    	}
    	return TRUE;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // CopyFloats
    //
    extern "C" void CopyFloats(D3DVALUE *dst, D3DVALUE *src, DWORD count)
    {
    	D3DVALUE *ptr1 = dst, *ptr2 = src;
    
    	if (!count)		return;
    
    	for (; count; count--)  *ptr1++ = *ptr2++;
    	return;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // IsWin95
    //
    // no longer needed since we support w95 now
    #if 0
    BOOL IsWin95(void)
    {
    	return FALSE;
        
    
    
    	//We work on win95
        OSVERSIONINFO osvi;
        ZeroMemory(&osvi, sizeof(osvi));
        osvi.dwOSVersionInfoSize = sizeof(osvi);
        if (!GetVersionEx(&osvi))
        {
            DPF(1,"GetVersionEx failed - assuming Win95");
            return TRUE;
        }
    
        if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
        {
    
            if( ( osvi.dwMajorVersion > 4UL ) ||
                ( ( osvi.dwMajorVersion == 4UL ) &&
                  ( osvi.dwMinorVersion >= 10UL ) &&
                  ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
            {
                // is Win98
                DPF(2,"Detected Win98");
                return FALSE;
            }
            else
            {
                // is Win95
                DPF(2,"Detected Win95");
                return TRUE;
            }
        }
        else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
        {
            DPF(2,"Detected WinNT");
            return FALSE;
        }
        DPF(2,"OS Detection failed");
        return TRUE;
    
    }
    #endif
    
    #define DICONDITION_USE_BOTH_AXIS 1
    #define DICONDITION_USE_DIRECTION 2
    
    /////////////////////////////////////////////////////////////////////////////
    // FixUpRealEffect  cover->real
    //
    HRESULT FixUpRealEffect(GUID g,DIEFFECT *realEffect,DIEFFECT_CDESC *cover)
    {
    	if (!cover) return E_INVALIDARG;
    
    	
    	memcpy(realEffect,cover,sizeof(DIEFFECT));
    
    	realEffect->dwSize =sizeof(DIEFFECT);	
    	realEffect->lpEnvelope =NULL;
    	realEffect->cbTypeSpecificParams =0;
    	realEffect->lpvTypeSpecificParams =NULL;
    	realEffect->cAxes =2;
    	realEffect->dwFlags=realEffect->dwFlags | DIEFF_OBJECTOFFSETS ;
    	realEffect->rglDirection =(long*)&(cover->x);
    	realEffect->rgdwAxes =(DWORD*)&(cover->axisOffsets);	
    	
    	
    	if (cover->bUseEnvelope){
    		realEffect->lpEnvelope=(DIENVELOPE*)&(cover->envelope);
    		
    		((DIENVELOPE*)&(cover->envelope))->dwSize=sizeof(DIENVELOPE);
    	}
    	
    	if (!cover->lFlags)
    		realEffect->dwFlags= DIEFF_POLAR | DIEFF_OBJECTOFFSETS ;
    	
    	//constant
    	if (g==GUID_ConstantForce)
    	{
    		realEffect->cbTypeSpecificParams =sizeof (DICONSTANTFORCE);
    		realEffect->lpvTypeSpecificParams =&(cover->constantForce);
    	}
    	
    	//periodic
    	else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
    	{
    
    		realEffect->cbTypeSpecificParams =sizeof (DIPERIODIC);
    		realEffect->lpvTypeSpecificParams =&(cover->periodicForce);
    
    	}
    	else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){
    
    		if (cover->conditionFlags==DICONDITION_USE_BOTH_AXIS){
    			realEffect->cbTypeSpecificParams =sizeof(DICONDITION)*2;
    			realEffect->lpvTypeSpecificParams =&(cover->conditionX);			
    		}
    		else{
    			realEffect->cbTypeSpecificParams =sizeof(DICONDITION);
    			realEffect->lpvTypeSpecificParams =&(cover->conditionX);
    		}
    
    	}
    	else if (g==GUID_RampForce){
    		realEffect->cbTypeSpecificParams =sizeof(DIRAMPFORCE);
    		realEffect->lpvTypeSpecificParams =&(cover->rampForce);
    	}
    
    	cover->axisOffsets.x=DIJOFS_X;
    	cover->axisOffsets.y=DIJOFS_Y;
    	realEffect->rgdwAxes=(DWORD*)&(cover->axisOffsets);
    
    	return S_OK;
    }
    
    /////////////////////////////////////////////////////////////////////////////
    // FixUpCoverEffect  real->cover
    //
    HRESULT FixUpCoverEffect(GUID g, DIEFFECT_CDESC *cover,DIEFFECT *realEffect)
    {
    	
    
    	ZeroMemory(cover,sizeof(DIEFFECT_CDESC));
    	memcpy(cover,realEffect,sizeof(DIEFFECT));
    	
    	
    	if (realEffect->lpEnvelope){
    		memcpy(&cover->envelope,realEffect->lpEnvelope ,sizeof(DIENVELOPE));
    		cover->bUseEnvelope=VARIANT_TRUE;
    	}
    
    	if (realEffect->rglDirection){
    		cover->x=realEffect->rglDirection[0];
    		cover->y=realEffect->rglDirection[1];
    	}	
    	
    
    	
    	if (realEffect->lpvTypeSpecificParams){
    		
    		if (g==GUID_ConstantForce)
    		{
    			memcpy(&(cover->constantForce),realEffect->lpvTypeSpecificParams,sizeof(DICONSTANTFORCE));
    		}		
    		//periodic
    		else if ((g==GUID_Square)||(g==GUID_Triangle)||(g==GUID_SawtoothUp)||(g==GUID_SawtoothDown)||(g==GUID_Sine))
    		{
    			memcpy(&(cover->periodicForce),realEffect->lpvTypeSpecificParams,sizeof(DIPERIODIC));
    		}
    	
    		else if ((g==GUID_Spring)|| (g==GUID_Damper)|| (g==GUID_Inertia)|| (g==GUID_Friction)){
    			
    			if (realEffect->cbTypeSpecificParams ==sizeof(DICONDITION)*2){
    				memcpy(&(cover->conditionY),realEffect->lpvTypeSpecificParams,sizeof(DICONDITION)*2);
    				cover->conditionFlags=DICONDITION_USE_BOTH_AXIS;
    			}
    			else{
    				memcpy(&(cover->conditionX),realEffect->lpvTypeSpecificParams,sizeof(DICONDITION));
    				cover->conditionFlags=DICONDITION_USE_DIRECTION;
    			}
    
    		}
    		
    		else if (g==GUID_RampForce){
    			memcpy(&(cover->rampForce),realEffect->lpvTypeSpecificParams,sizeof(DIRAMPFORCE));			
    		}
    
    	}
    
    
    	return S_OK;
    }
    
    
    
    #define MYVARIANTINIT(inArg,puser) \
    	VariantInit(puser); \
    	user.vt=VT_UNKNOWN; \
    	user.punkVal = inArg; \
    	user.punkVal->AddRef();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmbandobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmbandobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicBandObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicBand IDirectMusicBand8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicBandObject : 
	public I_dxj_DirectMusicBand,
	//public CComCoClass<C_dxj_DirectMusicBandObject, &CLSID__dxj_DirectMusicBand>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicBandObject();
	virtual ~C_dxj_DirectMusicBandObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicBandObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicBand)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicBand,		"DIRECT.DirectMusicBand.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicBandObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	HRESULT STDMETHODCALLTYPE createSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	HRESULT STDMETHODCALLTYPE download( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *downloadpath);

	HRESULT STDMETHODCALLTYPE unload( 
		/* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *downloadpath);

  

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicBand);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicBand)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmchordmapobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmchordmapobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicChordMapObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicChordMap IDirectMusicChordMap8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicChordMapObject : 
	public I_dxj_DirectMusicChordMap,
	//public CComCoClass<C_dxj_DirectMusicChordMapObject, &CLSID__dxj_DirectMusicChordMap>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicChordMapObject();
	virtual ~C_dxj_DirectMusicChordMapObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicChordMapObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicChordMap)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicChordMap,		"DIRECT.DirectMusicChordMap.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicChordMapObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

  
    HRESULT STDMETHODCALLTYPE getScale(long *s); 
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicChordMap);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicChordMap)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmcollectionobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmcollectionobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicCollectionObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicCollection IDirectMusicCollection8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicCollectionObject : 
	public I_dxj_DirectMusicCollection,
	//public CComCoClass<C_dxj_DirectMusicCollectionObject, &CLSID__dxj_DirectMusicCollection>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicCollectionObject();
	virtual ~C_dxj_DirectMusicCollectionObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicCollectionObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicCollection)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicCollection,		"DIRECT.DirectMusicCollection.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicCollectionObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

      
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicCollection);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicCollection)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmcomposerobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmcomposerobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicComposerObject

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicComposer IDirectMusicComposer8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicComposerObject : 
	public I_dxj_DirectMusicComposer,
	//public CComCoClass<C_dxj_DirectMusicComposerObject, &CLSID__dxj_DirectMusicComposer>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicComposerObject();
	virtual ~C_dxj_DirectMusicComposerObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicComposerObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicComposer)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicComposer,		"DIRECT.DirectMusicComposer.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicComposerObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

    
	    HRESULT STDMETHODCALLTYPE autoTransition( 
        /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *Performance,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppTransSeg);
    
    HRESULT STDMETHODCALLTYPE composeSegmentFromTemplate( 
		/* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *TemplateSeg,
        /* [in] */ short Activity,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeSegmentFromShape( 
        /* [in] */ I_dxj_DirectMusicStyle __RPC_FAR *style,
        /* [in] */ short numberOfMeasures,
        /* [in] */ short shape,
        /* [in] */ short activity,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeTransition( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *pFromSeg,
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *ToSeg,
        /* [in] */ long mtTime,
        /* [in] */ long lCommand,
        /* [in] */ long lFlags,
        /* [in] */ I_dxj_DirectMusicChordMap __RPC_FAR *chordmap,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *SectionSeg);
    
    HRESULT STDMETHODCALLTYPE composeTemplateFromShape( 
        /* [in] */ short numMeasures,
        /* [in] */ short shape,
        /* [in] */ VARIANT_BOOL bIntro,
        /* [in] */ VARIANT_BOOL bEnd,
        /* [in] */ short endLength,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *TempSeg);
    
    HRESULT STDMETHODCALLTYPE changeChordMap( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ VARIANT_BOOL trackScale,
        /* [retval][out] */ I_dxj_DirectMusicChordMap  *ChordMap);
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicComposer);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicComposer)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmloaderobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmloaderobj.cpp
//
//--------------------------------------------------------------------------

// dmLoaderObj.cpp

#include "stdafx.h"
#include "Direct.h"
#include "dmusici.h"
#include "dms.h"
#include "dmLoaderObj.h"
#include "dmBandObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmCollectionObj.h"
#include "dmChordMapObj.h"
#if 0
#include "DMusSongObj.h"

extern void *g_dxj_DirectMusicSong;
#endif
extern void *g_dxj_DirectMusicLoader;
extern void *g_dxj_DirectMusicBand;
extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicCollection;
extern void *g_dxj_DirectMusicChordMap;
	

CONSTRUCTOR(_dxj_DirectMusicLoader, {});
DESTRUCTOR(_dxj_DirectMusicLoader, {});
GETSET_OBJECT(_dxj_DirectMusicLoader);


extern HRESULT CREATE_DMSEGMENT_NOADDREF(IDirectMusicSegment8 *pSeg,I_dxj_DirectMusicSegment **segment) ;
extern BOOL IsEmptyString(BSTR szString);


BOOL HasBackslash(BSTR b){
	
	DWORD cbLen=SysStringLen(b);
	
	for (DWORD i=0;i<cbLen;i++) 
	{
		if (b[i]==((unsigned short)'\\'))
			 return TRUE;
	}
	return FALSE;
}


HRESULT C_dxj_DirectMusicLoaderObject::loadSegment( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicSegment8 *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment8,wszFileName, (void**)&pOut) ) )
		return hr;
		
	hr=CREATE_DMSEGMENT_NOADDREF(pOut,ret);
	if FAILED(hr) return hr;

	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadStyle( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicStyle8 *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicStyle, IID_IDirectMusicStyle8,wszFileName, (void**)&pOut) ) )
		return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}
HRESULT C_dxj_DirectMusicLoaderObject::loadBand( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicBand8 *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicBand, IID_IDirectMusicBand8,wszFileName, (void**)&pOut) ) )
		return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadCollection( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicCollection8 *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicCollection, IID_IDirectMusicCollection8,wszFileName, (void**)&pOut) ) )
		return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicCollection,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

HRESULT C_dxj_DirectMusicLoaderObject::loadChordMap( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicChordMap8 *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicChordMap, IID_IDirectMusicChordMap8,wszFileName, (void**)&pOut) ) )
		return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}

#if 0
HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::LoadSong(BSTR filename, I_dxj_DirectMusicSong **ret)
{
	HRESULT hr;
	
	if (IsEmptyString(filename))	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

    WCHAR          wszFileName[DMUS_MAX_FILENAME];
	IDirectMusicSong *pOut=NULL;
	wcscpy(wszFileName, filename);	

	if (FAILED ( hr = m__dxj_DirectMusicLoader->LoadObjectFromFile(CLSID_DirectMusicSong, IID_IDirectMusicSong,wszFileName, (void**)&pOut) ) )
		return hr;
		
	INTERNAL_CREATE(_dxj_DirectMusicSong ,pOut,ret);

	if (!*ret)return E_OUTOFMEMORY;
	
	return S_OK;

}
#endif
HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadSegmentFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{

	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;
	

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		LPCTSTR pszName = W2T(moduleName);
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMSEG");
	if (!hres) return E_FAIL;
	

	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;


	dwSize=SizeofResource(hMod,hres); 
	
	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicSegment;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment8 *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicSegment8,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;	
	return hr;
}

HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadStyleFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{
    HRESULT hr;
	HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		LPCTSTR pszName = W2T(moduleName);
		hMod= GetModuleHandle(pszName);

	}

	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMSTYLE");


	if (!hres) return E_FAIL;


	pMem=(void*)LoadResource(hMod,hres);


	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicStyle;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment8 *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicStyle8,(void**)&pOut);	
	
	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
}

HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadBandFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		LPCTSTR pszName = W2T(moduleName);
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMBAND");
	if (!hres) return E_FAIL;
	
	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 
	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicBand;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment8 *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicBand8,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;

}


 HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadCollectionFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	USES_CONVERSION;
	
	
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		LPCTSTR pszName = W2T(moduleName);
		hMod= GetModuleHandle(pszName);
	}


	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMCOL");
	if (!hres) return E_FAIL;
	
	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem) return E_FAIL;

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicCollection;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment8 *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicCollection8,(void**)&pOut);	
	if FAILED(hr) return hr;

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicCollection,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
	

}

 
HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::loadChordMapFromResource( 
		/* [in] */ BSTR moduleName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;
    HRSRC   hres=NULL;
	HGLOBAL hglob=NULL;
	void	*pMem=NULL;
	DWORD   dwSize=0;

	if (!resourceName)	return E_INVALIDARG;
	if (!ret)		return E_INVALIDARG;

	HMODULE hMod=NULL;

	
	USES_CONVERSION;
		
	if  ((moduleName) &&(moduleName[0]!=0)){
		// NOTE: - 
		// seems that GetModuleHandleW is
		// always returning 0 on w98??			
		// hMod= GetModuleHandleW(moduleName);
		 LPCTSTR pszName = W2T(moduleName);
		 hMod= GetModuleHandle(pszName);
	}

	hres=FindResourceW(hMod,resourceName,(LPWSTR)L"DMCHORD");
	if (!hres) {
		//MessageBox(NULL,"FindResourceW Failed","test",MB_OK);
		return E_FAIL;
	}

	pMem=(void*)LoadResource(hMod,hres);
	if (!pMem){
		//MessageBox(NULL,"LoadResource Failed","test",MB_OK);
		return E_FAIL;
	}

	dwSize=SizeofResource(hMod,hres); 
 

	DMUS_OBJECTDESC objdesc;
	ZeroMemory(&objdesc,sizeof(DMUS_OBJECTDESC));
	objdesc.dwSize=sizeof(DMUS_OBJECTDESC);
	objdesc.dwValidData=DMUS_OBJ_MEMORY | DMUS_OBJ_CLASS  ;
	objdesc.guidClass=CLSID_DirectMusicChordMap;
	objdesc.llMemLength =(LONGLONG)dwSize;
	objdesc.pbMemData =(BYTE*)pMem;

	IDirectMusicSegment8 *pOut=NULL;
    
	hr=m__dxj_DirectMusicLoader->GetObject(&objdesc,IID_IDirectMusicChordMap8,(void**)&pOut);	
	if FAILED(hr) {
		//MessageBox(NULL,"GetObject Failed","test",MB_OK);
		return hr;
	}

	if (!pOut)return E_OUTOFMEMORY;
		
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pOut,ret);
	
	if (!*ret)return E_OUTOFMEMORY;
	
	return hr;
	

}


 HRESULT STDMETHODCALLTYPE C_dxj_DirectMusicLoaderObject::setSearchDirectory( BSTR dir)
 {
	HRESULT hr;
	hr=m__dxj_DirectMusicLoader->SetSearchDirectory(GUID_DirectMusicAllTypes,dir, TRUE);    //?
	return hr;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmloaderobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmloaderobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicLoaderObject

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicLoader IDirectMusicLoader8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicLoaderObject : 
	public I_dxj_DirectMusicLoader,
	//public CComCoClass<C_dxj_DirectMusicLoaderObject, &CLSID__dxj_DirectMusicLoader>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicLoaderObject();
	virtual ~C_dxj_DirectMusicLoaderObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicLoaderObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicLoader)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicLoader,		"DIRECT.DirectMusicLoader.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicLoaderObject)


// I_dxj_Direct3dRMLight
public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	 HRESULT STDMETHODCALLTYPE loadSegment( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadStyle( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadBand( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);

 	 HRESULT STDMETHODCALLTYPE loadCollection( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadSegmentFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadStyleFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadBandFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadCollectionFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicCollection __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE setSearchDirectory( BSTR path);

 	 HRESULT STDMETHODCALLTYPE loadChordMap( 
		/* [in] */ BSTR filename,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);

	 HRESULT STDMETHODCALLTYPE loadChordMapFromResource( 
		/* [in] */ BSTR modName,
		/* [in] */ BSTR resourceName,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);

#if 0
	HRESULT STDMETHODCALLTYPE LoadSong(BSTR filename, I_dxj_DirectMusicSong **ret);
#endif


////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicLoader);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicLoader)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmperformanceobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmperformanceobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmPerformanceObj.h"
#include "dmSegmentStateObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmChordMapObj.h"
#include "dMusAudioPathObj.h"					   
#include "dsoundobj.h"

extern void *g_dxj_DirectMusicPerformance;
extern void *g_dxj_DirectMusicSegmentState;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicAudioPath;
extern void *g_dxj_DirectMusicChordMap;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern CRITICAL_SECTION g_cbCriticalSection;
extern BOOL IsEmptyString(BSTR szString);
extern BSTR GUIDtoBSTR(LPGUID);

CONSTRUCTOR(_dxj_DirectMusicPerformance, {InternalInit();});
DESTRUCTOR(_dxj_DirectMusicPerformance, {InternalCleanup();});
GETSET_OBJECT(_dxj_DirectMusicPerformance);

typedef IDirectMusicSegment* LPDIRECTMUSICSEGMENT;
typedef IDirectMusicSegmentState* LPDIRECTMUSICSEGMENTSTATE ;

HRESULT C_dxj_DirectMusicPerformanceObject::InternalInit(){
	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::InternalCleanup(){	
	__try {
		m__dxj_DirectMusicPerformance->CloseDown();
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return S_OK;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::closeDown( )
{
	HRESULT hr;	
	__try {
		hr=m__dxj_DirectMusicPerformance->CloseDown();
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}
 

#define VBREF_TO_REALREFTIME(startTime) ((__int64)startTime*10000)
#define REALREF_TO_VBREFTIME(startTime) ((long)(startTime/10000))

HRESULT C_dxj_DirectMusicPerformanceObject::getSegmentState( 
		/* [in] */ long mtTime,
		/* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState)
{
	HRESULT hr;	

	__try {
		IDirectMusicSegmentState *pState=NULL;
		hr=m__dxj_DirectMusicPerformance->GetSegmentState(&pState,(MUSIC_TIME)mtTime);
		if FAILED(hr) return hr;
		if (!pState) return E_FAIL;

		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegmentState,pState,segmentState);
		if (*segmentState==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::invalidate( 
		/* [in] */ long mtTime,
		/* [in] */ long flags)

{
	HRESULT hr;		
	__try {
		hr=m__dxj_DirectMusicPerformance->Invalidate((MUSIC_TIME)mtTime,(DWORD)flags);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}



HRESULT C_dxj_DirectMusicPerformanceObject::isPlaying( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
		/* [retval][out] */ VARIANT_BOOL __RPC_FAR *b)
		
{
	HRESULT hr;	
	
	__try {
		DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT,pSeg,segment);
		DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENTSTATE,pSegState,segmentState);
				
		hr=m__dxj_DirectMusicPerformance->IsPlaying(pSeg,pSegState);	
		if (hr==S_FALSE){
			*b=VARIANT_FALSE;
		}
		else if (hr==S_OK){
			*b=VARIANT_TRUE;
		}
		else{
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}



HRESULT C_dxj_DirectMusicPerformanceObject::addNotificationType(CONST_DMUS_NOTIFICATION_TYPE t)		
{
	HRESULT hr;	
	GUID g;
	__try {
		switch (t){	
		 case DMUS_NOTIFY_ON_CHORD:
			g=GUID_NOTIFICATION_CHORD;
			break;

		 case DMUS_NOTIFY_ON_COMMAND:
			g=GUID_NOTIFICATION_COMMAND;
			break;
		 case DMUS_NOTIFY_ON_MEASUREANDBEAT:
			g=GUID_NOTIFICATION_MEASUREANDBEAT;
			break;
		 case DMUS_NOTIFY_ON_PERFORMANCE:
			g=GUID_NOTIFICATION_PERFORMANCE;
			break;
		 case DMUS_NOTIFY_ON_SEGMENT:
			g=GUID_NOTIFICATION_SEGMENT;
			break;
		 case DMUS_NOTIFY_ON_RECOMPOSE:
			 g=GUID_NOTIFICATION_RECOMPOSE;
		 default:
			return E_INVALIDARG;
		}
		
		hr=m__dxj_DirectMusicPerformance->AddNotificationType(g);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}


HRESULT C_dxj_DirectMusicPerformanceObject::removeNotificationType( /* [in] */CONST_DMUS_NOTIFICATION_TYPE t)		
{
	HRESULT hr;	
	GUID g;
	__try {
		switch (t){	
		 case DMUS_NOTIFY_ON_CHORD:
			g=GUID_NOTIFICATION_CHORD;
			break;

		 case DMUS_NOTIFY_ON_COMMAND:
			g=GUID_NOTIFICATION_COMMAND;
			break;
		 case DMUS_NOTIFY_ON_MEASUREANDBEAT:
			g=GUID_NOTIFICATION_MEASUREANDBEAT;
			break;
		 case DMUS_NOTIFY_ON_PERFORMANCE:
			g=GUID_NOTIFICATION_PERFORMANCE;
			break;
		 case DMUS_NOTIFY_ON_SEGMENT:
			g=GUID_NOTIFICATION_SEGMENT;
			break;
		 case DMUS_NOTIFY_ON_RECOMPOSE:
			 g=GUID_NOTIFICATION_RECOMPOSE;
		 default:
			return E_INVALIDARG;
		}
		hr=m__dxj_DirectMusicPerformance->RemoveNotificationType(g);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	


#ifdef _WIN64
HRESULT C_dxj_DirectMusicPerformanceObject::setNotificationHandle( 	/* [in] */ HWND hnd)		
#else
HRESULT C_dxj_DirectMusicPerformanceObject::setNotificationHandle( 	/* [in] */ long hnd)		
#endif
{
	HRESULT hr;	
	__try {
		hr=m__dxj_DirectMusicPerformance->SetNotificationHandle((HWND)hnd,0);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	
	

HRESULT C_dxj_DirectMusicPerformanceObject::getNotificationPMSG( DMUS_NOTIFICATION_PMSG_CDESC *pMsgOut, VARIANT_BOOL *bOut)				
{
	HRESULT hr;	
	DMUS_NOTIFICATION_PMSG *pMsg=NULL;
	IDirectMusicSegmentState	*lpState = NULL;
	
	__try {
		if (!pMsgOut) return E_INVALIDARG;
		if (!bOut) return E_INVALIDARG;

		hr=m__dxj_DirectMusicPerformance->GetNotificationPMsg(&pMsg);	
		if FAILED(hr) return hr;
		
		*bOut=VARIANT_FALSE;	

		if (!pMsg) 	return S_OK;

		if (hr!=S_FALSE) 	*bOut=VARIANT_TRUE;	
		

		pMsgOut->mtTime=(long)pMsg->mtTime;
		pMsgOut->ctTime=(long)REALREF_TO_VBREFTIME(pMsg->rtTime);
		pMsgOut->lFlags=(long)pMsg->dwFlags;
		
		pMsgOut->lNotificationOption =pMsg->dwNotificationOption;
		pMsgOut->lField1=pMsg->dwField1;
		pMsgOut->lField2=pMsg->dwField2;

		if (pMsg->punkUser)
		{
			if (SUCCEEDED( hr = pMsg->punkUser->QueryInterface(IID_IDirectMusicSegmentState, (void**)&lpState) ) )
			{
				// Create an instance of the segment state and return it to VB
				INTERNAL_CREATE(_dxj_DirectMusicSegmentState,lpState,&pMsgOut->User);
			}
		}

		if (0==memcmp(&GUID_NOTIFICATION_CHORD,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_CHORD;
		}
		else if (0==memcmp(&GUID_NOTIFICATION_COMMAND,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_COMMAND;
		}
		else if (0==memcmp(&GUID_NOTIFICATION_MEASUREANDBEAT,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_MEASUREANDBEAT;
		}
		else if (0==memcmp(&GUID_NOTIFICATION_PERFORMANCE,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_PERFORMANCE;
		}
		else if (0==memcmp(&GUID_NOTIFICATION_SEGMENT,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_SEGMENT;
		}
		else if (0==memcmp(&GUID_NOTIFICATION_RECOMPOSE,&pMsg->guidNotificationType,sizeof(GUID))){
			pMsgOut->lNotificationType=DMUS_NOTIFY_ON_RECOMPOSE;
		}
		else {
			pMsgOut->lNotificationType=0;		
		}

		m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG *)pMsg);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::musicToClockTime( /* [in] */ long mtTime,
		/* [retval][out] */ long __RPC_FAR *rtTime)				
{
	HRESULT hr;	
	__int64 outTime;
	__try {
		hr=m__dxj_DirectMusicPerformance->MusicToReferenceTime((MUSIC_TIME)mtTime,&outTime);
		if FAILED(hr) return hr;
		*rtTime=REALREF_TO_VBREFTIME(outTime);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::clockToMusicTime( 	/* [in] */ long rtTime,
		/* [retval][out] */ long __RPC_FAR *mtTime)				
{
	HRESULT hr;	
	__try {
		__int64 outTime=VBREF_TO_REALREFTIME(rtTime);;
		hr=m__dxj_DirectMusicPerformance->ReferenceToMusicTime(outTime,(MUSIC_TIME*)mtTime);		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	
	 


HRESULT C_dxj_DirectMusicPerformanceObject::getMusicTime( /* [retval][out] */ long __RPC_FAR *mtTime)		
{
	HRESULT hr;		

	__try {
		hr=m__dxj_DirectMusicPerformance->GetTime(NULL,(MUSIC_TIME*)mtTime);		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	
	 

HRESULT C_dxj_DirectMusicPerformanceObject::getClockTime( /* [retval][out] */ long __RPC_FAR *rtTime)		
{
	HRESULT hr;	
	__try {
		__int64 outTime=0;
		hr=m__dxj_DirectMusicPerformance->GetTime(&outTime,NULL);
		*rtTime=REALREF_TO_VBREFTIME(outTime);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	


HRESULT C_dxj_DirectMusicPerformanceObject::getPrepareTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__try {
		hr=m__dxj_DirectMusicPerformance->GetPrepareTime((DWORD*)pTime);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getBumperLength(/* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__try {
		hr=m__dxj_DirectMusicPerformance->GetBumperLength((DWORD*)pTime);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getLatencyTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__int64 t;
	__try {
		if (!pTime) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetLatencyTime(&t);	
		*pTime=REALREF_TO_VBREFTIME(t);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getQueueTime( /* [retval][out] */ long __RPC_FAR *pTime)		
{
	HRESULT hr;		
	__int64 t;

	__try {
		if (!pTime) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetQueueTime(&t);	
		*pTime=REALREF_TO_VBREFTIME(t);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::getResolvedTime( /* [in] */ long rtTime, /* [in] */ long flags,	/* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;		

	__try {
		__int64 outtime1= VBREF_TO_REALREFTIME(rtTime);
		__int64 outtime2=0;
		hr=m__dxj_DirectMusicPerformance->GetResolvedTime(outtime1,&outtime2,(DWORD)flags);	
		*ret=REALREF_TO_VBREFTIME(outtime2);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

	 

HRESULT C_dxj_DirectMusicPerformanceObject::setPrepareTime( /* [retval][out] */ long  t)		
{
	HRESULT hr;		
	__try {
		hr=m__dxj_DirectMusicPerformance->SetPrepareTime((DWORD)t);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::setBumperLength(/* [retval][out] */ long  t)		
{
	HRESULT hr;		

	__try {
		hr=m__dxj_DirectMusicPerformance->SetBumperLength((DWORD)t);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	



HRESULT C_dxj_DirectMusicPerformanceObject::adjustTime( 		
		/* [retval][out] */ long  t)		
{
	HRESULT hr;		
	
	__try {
		REFERENCE_TIME rt =(REFERENCE_TIME)t;
		hr=m__dxj_DirectMusicPerformance->AdjustTime(rt);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}	

HRESULT C_dxj_DirectMusicPerformanceObject::setMasterAutoDownload( /* [in] */ VARIANT_BOOL bval)
{
	HRESULT hr;
	
	__try {
		BOOL b=(BOOL)(bval==VARIANT_TRUE);

		hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfAutoDownload,(void*)&b,sizeof(BOOL));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterAutoDownload( /* [in] */ VARIANT_BOOL *bIn)
{
	HRESULT hr;
	BOOL	b;

	__try {
		hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfAutoDownload,(void*) &b,sizeof(BOOL));
		if (b){
			*bIn=VARIANT_TRUE;
		}
		else{
			*bIn=VARIANT_FALSE;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::setMasterTempo( /* [in] */ float tempo)
{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectMusicPerformance->SetGlobalParam( GUID_PerfMasterTempo ,(void*) &tempo,sizeof(float));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterTempo( /* [in] */ float *tempo)
{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectMusicPerformance->GetGlobalParam( GUID_PerfMasterTempo ,(void*) tempo,sizeof(float));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}


HRESULT C_dxj_DirectMusicPerformanceObject::setMasterVolume( /* [in] */ long vol)
{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfMasterVolume  ,(void*) &vol,sizeof(long));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterVolume( /* [in] */ long *vol)
{
	HRESULT hr;
	__try {
		hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfMasterVolume ,(void*) vol,sizeof(long));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}



HRESULT C_dxj_DirectMusicPerformanceObject::setMasterGrooveLevel( /* [in] */ short level)
{
	HRESULT hr;
	
	__try {
		char l=(char)level;

		hr=m__dxj_DirectMusicPerformance->SetGlobalParam(GUID_PerfMasterGrooveLevel  ,(void*) &l,sizeof(char));
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getMasterGrooveLevel( /* [in] */ short *level)
{
	HRESULT hr;

	__try {
		if (!level) return E_INVALIDARG;
		char l=0;

		hr=m__dxj_DirectMusicPerformance->GetGlobalParam(GUID_PerfMasterGrooveLevel ,(void*) &l,sizeof(char));
		*level=(short)l;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::Reset(long resetFlags)
{
    DMUS_SYSEX_PMSG     *pGMReset;
    BYTE                abGMReset[] = {0xF0,0x7E,0x7F,0x09,0x01,0xF7};
    DWORD               dwLen;
	HRESULT				hr=S_OK;

	__try {
		if (!resetFlags){
			dwLen = sizeof(abGMReset)/sizeof(abGMReset[0]);

			if(SUCCEEDED( m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_SYSEX_PMSG) + dwLen,
																	(DMUS_PMSG**)&pGMReset )))
			{
				ZeroMemory(pGMReset, sizeof(pGMReset));
				pGMReset->dwSize = sizeof(DMUS_SYSEX_PMSG);
				pGMReset->dwPChannel = 0;
				pGMReset->dwVirtualTrackID = 0;
				pGMReset->dwType = DMUS_PMSGT_SYSEX ;
				pGMReset->dwVoiceID = 0;
				pGMReset->dwGroupID = 0xFFFFFFFF;

				pGMReset->dwLen = dwLen;
				memcpy(pGMReset->abData, abGMReset, dwLen);

				if (SUCCEEDED(m__dxj_DirectMusicPerformance->GetTime(NULL, &pGMReset->mtTime)))
				{
					pGMReset->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_IMMEDIATE;
				}

				hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pGMReset);
				if (FAILED(hr))
					m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pGMReset);
			}
		}
		else if(resetFlags==1){

			//1) Find out what port we're playing through
			//2)  Close the port
			//3) Open the port back up.
			
			//hr=setPort(m_portid,m_number_of_groups);
		}
		else {
			hr=E_INVALIDARG;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getStyle( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{				
		HRESULT hr;	
		IDirectMusicStyle *pStyle=NULL;

	__try {
		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_IDirectMusicStyle,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&pStyle );	
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pStyle,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getChordMap( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
		HRESULT hr;	
		IDirectMusicChordMap *pMap=NULL;

	__try {
		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_IDirectMusicChordMap,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&pMap );	
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getCommand( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ Byte __RPC_FAR *command)
{
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;								
		
	__try {
		if (!command) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&cmd );	
		if FAILED(hr) return hr;		
		*command=cmd.bCommand;		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getGrooveLevel( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ Byte __RPC_FAR *level)
{
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;			
	__try {
		if (!level) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&cmd );	
		if FAILED(hr) return hr;		
		*level=cmd.bGrooveLevel;		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getTempo( 		
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ double __RPC_FAR *tempo)
{
	HRESULT hr;	
	DMUS_TEMPO_PARAM tmp;
	
	__try {
		if (!tempo) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_TempoParam,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&tmp );	
		if FAILED(hr) return hr;		
		*tempo=tmp.dblTempo;		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getTimeSig( 
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSig)
{
	
	HRESULT hr;	
	__try {
		if (!timeSig) return E_INVALIDARG;
		hr=m__dxj_DirectMusicPerformance->GetParam(GUID_TimeSignature,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,(DMUS_TIMESIGNATURE*)timeSig);		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendNotePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ DMUS_NOTE_PMSG_CDESC __RPC_FAR *msg)
{


	HRESULT		hr;
	DMUS_NOTE_PMSG	*pPMSG=NULL;
	__try {
		if (!msg) return E_INVALIDARG;
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG),(DMUS_PMSG**)&pPMSG);
		if FAILED(hr) return hr;

		//memcpy(pPMSG,msg,sizeof(DMUS_NOTE_PMSG));
		//depends on alignment settings
		//and how dll is compiled to work right.
		//copy member by member instead..
		ZeroMemory(pPMSG,sizeof(DMUS_NOTE_PMSG));
		pPMSG->dwSize=sizeof(DMUS_NOTE_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_NOTE;	
		pPMSG->dwPChannel =(DWORD)channel;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		
		
		pPMSG->mtDuration=(MUSIC_TIME)msg->mtDuration;
		pPMSG->wMusicValue=(WORD)msg->musicValue;
		pPMSG->wMeasure=(WORD)msg->measure;
		pPMSG->nOffset=(short)msg->offset;
		pPMSG->bBeat=(BYTE)msg->beat;
		pPMSG->bGrid=(BYTE)msg->grid;
		pPMSG->bVelocity=(BYTE)msg->velocity;
		pPMSG->bFlags=(BYTE)msg->flags;
		pPMSG->bTimeRange=(BYTE)msg->timeRange;
		pPMSG->bDurRange=(BYTE)msg->durRange;
		pPMSG->bVelRange=(BYTE)msg->velRange;
		pPMSG->bPlayModeFlags=(BYTE)msg->playModeFlags;
		pPMSG->bSubChordLevel=(BYTE)msg->subChordLevel;
		pPMSG->bMidiValue=(BYTE)msg->midiValue;
		pPMSG->cTranspose=(char)msg->transpose;


		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;

}

HRESULT C_dxj_DirectMusicPerformanceObject::sendCurvePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ DMUS_CURVE_PMSG_CDESC __RPC_FAR *msg)
{
	HRESULT		hr;
	DMUS_CURVE_PMSG	*pPMSG=NULL;
	if (!msg) return E_INVALIDARG;

	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG**)&pPMSG);

		
		pPMSG->dwSize=sizeof(DMUS_CURVE_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_CURVE;	
		pPMSG->dwPChannel =(DWORD)channel;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;

		pPMSG->mtDuration=msg->mtDuration;
		pPMSG->mtOriginalStart=msg->mtOriginalStart;
		pPMSG->mtResetDuration=msg->mtResetDuration;	
		pPMSG->nStartValue =(short)msg->startValue;
		pPMSG->nEndValue =(short)msg->endValue;
		pPMSG->nResetValue =(short)msg->resetValue;
		pPMSG->wMeasure =(short)msg->measure;
		pPMSG->nOffset =(short)msg->offset;
		pPMSG->bBeat =(Byte)msg->beat;
		pPMSG->bGrid =(Byte)msg->grid;
		pPMSG->bType =(Byte)msg->type;
		pPMSG->bCurveShape =(Byte)msg->curveShape;
		pPMSG->bCCData =(Byte)msg->ccData;
		pPMSG->bFlags =(Byte)msg->flags | DMUS_PMSGF_DX8;
		pPMSG->wParamType = (short) msg->ParamType;
		pPMSG->wMergeIndex = (short) msg->MergeIndex;

		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendMIDIPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ Byte status,
		/* [in] */ Byte byte1,
		/* [in] */ Byte byte2)
{
	HRESULT		hr;
	DMUS_MIDI_PMSG	*pPMSG=NULL;
	
	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG),(DMUS_PMSG**)&pPMSG);	
		ZeroMemory(pPMSG,sizeof(DMUS_MIDI_PMSG));
		pPMSG->dwSize=sizeof(DMUS_MIDI_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_MIDI;	
		pPMSG->dwPChannel =(DWORD)channel;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		pPMSG->bStatus=status;
		pPMSG->bByte1=byte1;
		pPMSG->bByte2=byte2;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendPatchPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ Byte instrument,
		/* [in] */ Byte byte1,
		/* [in] */ Byte byte2)
{
	HRESULT		hr;
	DMUS_PATCH_PMSG	*pPMSG=NULL; 
	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_PATCH_PMSG),(DMUS_PMSG**)&pPMSG);	
		ZeroMemory(pPMSG,sizeof(DMUS_PATCH_PMSG));
		pPMSG->dwSize=sizeof(DMUS_PATCH_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_PATCH;	
		pPMSG->dwPChannel =(DWORD)channel;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		pPMSG->byInstrument=instrument;
		pPMSG->byMSB=byte1;
		pPMSG->byLSB=byte2;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTempoPMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		///* [in] */ long channel,
		/* [in] */ double tempo)
{
	HRESULT		hr;
	DMUS_TEMPO_PMSG	*pPMSG=NULL;
	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),(DMUS_PMSG**)&pPMSG);	
		ZeroMemory(pPMSG,sizeof(DMUS_TEMPO_PMSG));
		pPMSG->dwSize=sizeof(DMUS_TEMPO_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_TEMPO;	
		pPMSG->dwPChannel =(DWORD)0;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		pPMSG->dblTempo=tempo;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG); 
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTransposePMSG( 
		/* [in] */ long mtTime,
		/* [in] */ long flags,
		/* [in] */ long channel,
		/* [in] */ short transpose)
{
	
	HRESULT		hr;
	DMUS_TRANSPOSE_PMSG	*pPMSG=NULL;
	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TRANSPOSE_PMSG),(DMUS_PMSG**)&pPMSG);	
		ZeroMemory(pPMSG,sizeof(DMUS_TRANSPOSE_PMSG));
		pPMSG->dwSize=sizeof(DMUS_TRANSPOSE_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_TRANSPOSE;	
		pPMSG->dwPChannel =(DWORD)channel;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		pPMSG->nTranspose=transpose;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;
		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG); 
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::sendTimeSigPMSG( 
		/* [in] */ long mtTime,		
		/* [in] */ long flags,
		/* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timesig)
{
	HRESULT		hr;
	DMUS_TIMESIG_PMSG	*pPMSG=NULL;
	if (!timesig) return E_INVALIDARG;

	__try {
		hr= m__dxj_DirectMusicPerformance->AllocPMsg( sizeof(DMUS_TIMESIG_PMSG),(DMUS_PMSG**)&pPMSG);
		ZeroMemory(pPMSG,sizeof(DMUS_TIMESIG_PMSG));
		pPMSG->dwSize=sizeof(DMUS_TIMESIG_PMSG);
		pPMSG->mtTime=(MUSIC_TIME)mtTime;	
		pPMSG->dwFlags=(DWORD)flags;
		pPMSG->dwType=DMUS_PMSGT_TIMESIG;	
		pPMSG->dwPChannel =(DWORD)0;
		pPMSG->dwVirtualTrackID  =(DWORD)0;
		pPMSG->dwGroupID=(DWORD)-1;
		if (!flags) pPMSG->dwFlags= DMUS_PMSGF_MUSICTIME;

		pPMSG->bBeatsPerMeasure   =timesig->beatsPerMeasure; 
		pPMSG->bBeat=timesig->beat;  
		pPMSG->wGridsPerBeat=timesig->gridsPerBeat;

		hr=m__dxj_DirectMusicPerformance->SendPMsg((DMUS_PMSG*)pPMSG);  
		if (FAILED(hr))
			m__dxj_DirectMusicPerformance->FreePMsg((DMUS_PMSG*)pPMSG);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

#ifdef _WIN64
HRESULT C_dxj_DirectMusicPerformanceObject::InitAudio(HWND hWnd,
										long lFlags,
										DMUS_AUDIOPARAMS_CDESC *AudioParams,
                                        I_dxj_DirectSound **DirectSound,  
                                        long lDefaultPathType,           
                                        long lPChannelCount)
#else
HRESULT C_dxj_DirectMusicPerformanceObject::InitAudio(long hWnd,
										long lFlags,
										DMUS_AUDIOPARAMS_CDESC *AudioParams,
                                        I_dxj_DirectSound **DirectSound,  
                                        long lDefaultPathType,           
                                        long lPChannelCount)
#endif
{
	HRESULT hr;
	IDirectSound8	*pDS8 = NULL;
	LPDIRECTSOUND	pSound = NULL;
	DMUS_AUDIOPARAMS *pAudioParams = NULL;

	__try {
		if (*DirectSound)
		{
			((I_dxj_DirectSound*)*DirectSound)->InternalGetObject((IUnknown **)(&pSound));
		}

		// Do we have any Audio params to use?
		if (AudioParams->lValidData)
		{
			pAudioParams = new DMUS_AUDIOPARAMS;
			if (!pAudioParams)
			{
				return E_OUTOFMEMORY;
			}
			ZeroMemory(pAudioParams, sizeof(pAudioParams));
			pAudioParams->dwSize = sizeof(pAudioParams);
			pAudioParams->fInitNow = (AudioParams->fInitNow == VARIANT_TRUE);
			pAudioParams->dwValidData = AudioParams->lValidData;
			pAudioParams->dwFeatures = AudioParams->lFeatures;
			pAudioParams->dwVoices = AudioParams->lVoices;
			pAudioParams->dwSampleRate = AudioParams->lSampleRate;
			if (FAILED ( hr = BSTRtoGUID(&pAudioParams->clsidDefaultSynth,AudioParams->clsidDefaultSynth) ) )
			{
				return hr;
			}
		}

		hr = m__dxj_DirectMusicPerformance->InitAudio(NULL, &pSound,(HWND) hWnd,(DWORD)	lDefaultPathType ,(DWORD) lPChannelCount,(DWORD)lFlags , pAudioParams);
		if FAILED(hr) {
			return hr;
		}

		//Now that we've finished, make sure our returned audio params struct is right
		if (pAudioParams)
		{
			AudioParams->fInitNow = pAudioParams->fInitNow ? VARIANT_TRUE : VARIANT_FALSE;

			AudioParams->lValidData = pAudioParams->dwValidData;
			AudioParams->lFeatures = pAudioParams->dwFeatures;
			AudioParams->lVoices = pAudioParams->dwVoices;
			AudioParams->lSampleRate = pAudioParams->dwSampleRate;
			AudioParams->clsidDefaultSynth = GUIDtoBSTR(&pAudioParams->clsidDefaultSynth);
		}

		if (FAILED( hr = pSound->QueryInterface(IID_IDirectSound8,(void**) &pDS8) ) )
			return hr;

		if (pDS8)
		{
			INTERNAL_CREATE(_dxj_DirectSound,pDS8,DirectSound);
		}

		if (pSound) pSound->Release();

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::PlaySegmentEx(IUnknown *Source,
											long lFlags,
											long StartTime,
											IUnknown *From,
											IUnknown *AudioPath,
#if 0
											BSTR SegmentName,
											IUnknown *Transition, 
#endif
											I_dxj_DirectMusicSegmentState **ppSegmentState)
{
	HRESULT hr;	
    WCHAR wszSegName[MAX_PATH];

	if (!Source) return E_INVALIDARG;
	if (!ppSegmentState) return E_INVALIDARG;

	__try {
		IDirectMusicSegmentState	*pState=NULL;
		I_dxj_DirectMusicAudioPath	*pAudio = NULL;
		I_dxj_DirectMusicAudioPath	*pFrom = NULL;
		I_dxj_DirectMusicSegment	*pSeg = NULL;
#if 0
		I_dxj_DirectMusicSong		*pSong = NULL;
		I_dxj_DirectMusicSegment	*pTrans = NULL;

		if (Transition)
			DO_GETOBJECT_NOTNULL(IDirectMusicSegment8*,Transition,pTrans);
		if (!IsEmptyString(SegmentName)) wcscpy(wszSegName, SegmentName);	
#endif

		if (AudioPath)
		{
			if (FAILED ( hr = AudioPath->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&pAudio) ) )
				return hr;
		}
		DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath8*,pPath,pAudio);

		if (From)
		{
			if (FAILED ( hr = From->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&pFrom) ) )
				return hr;
		}
		DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath8*,pFromPath,pFrom);


		__int64 outTime=(__int64)StartTime;
		if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(StartTime);
		

		//We need to determine if the source is a segment or a song
		// First check to see if it's a segment
		if (SUCCEEDED ( hr = Source->QueryInterface(IID_I_dxj_DirectMusicSegment, (void**)&pSeg) ) )
		{	
			if (!pSeg) return E_INVALIDARG;
			DO_GETOBJECT_NOTNULL(IDirectMusicSegment8*,pPlaySeg,pSeg);

			if (FAILED ( hr = m__dxj_DirectMusicPerformance->PlaySegmentEx(pPlaySeg,wszSegName, NULL, (DWORD)lFlags,outTime,&pState, pFromPath,pPath)) )
				return hr;
		} 
#if 0
		else
			// Next check to see if it's a song
			if (SUCCEEDED ( hr = Source->QueryInterface(IID_I_dxj_DirectMusicSong, (void**)&pSong) ) )
			{	
				if (!pSong) return E_INVALIDARG;
				DO_GETOBJECT_NOTNULL(IDirectMusicSong8*,pPlaySong,pSong);

				if (!IsEmptyString(SegmentName))
				{
					if (FAILED ( hr = m__dxj_DirectMusicPerformance->PlaySegmentEx(pPlaySong,wszSegName, pTrans, (DWORD)lFlags,outTime,&pState, pFromPath,pPath)) )
						return hr;
				}
				else
				{
					if (FAILED ( hr = m__dxj_DirectMusicPerformance->PlaySegmentEx(pPlaySong,NULL, pTrans, (DWORD)lFlags,outTime,&pState, pFromPath,pPath)) )
						return hr;
				}
			}
#endif
			else
				return E_INVALIDARG;

		if (!pState) return E_FAIL;

		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegmentState,pState,ppSegmentState);
		
		if (*ppSegmentState==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}


HRESULT C_dxj_DirectMusicPerformanceObject::StopEx(IUnknown *ObjectToStop,
										long lStopTime, 
										long lFlags)
{
	HRESULT hr;	
	if (!ObjectToStop) return E_INVALIDARG;
	I_dxj_DirectMusicSegment	*pSeg = NULL;
#if 0
	I_dxj_DirectMusicSong		*pSong = NULL;
#endif
	I_dxj_DirectMusicSegmentState	*pSegState = NULL;
	I_dxj_DirectMusicAudioPath	*pPath = NULL;
					     
	__try {
		//We need to determine if the source is a segment or a song
		__int64 outTime=(__int64)lStopTime;
		if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(lStopTime);
		
		if (SUCCEEDED ( hr = ObjectToStop->QueryInterface(IID_I_dxj_DirectMusicSegment, (void**)&pSeg) ) )
		{	
			if (!pSeg) return E_INVALIDARG;
			DO_GETOBJECT_NOTNULL(IDirectMusicSegment8*,pPlaySeg,pSeg);

			if (FAILED (hr = m__dxj_DirectMusicPerformance->StopEx(pPlaySeg, outTime, (DWORD) lFlags) ) )
				return hr;
		} 
#if 0
		else if (SUCCEEDED ( hr = ObjectToStop->QueryInterface(IID_I_dxj_DirectMusicSong, (void**)&pSong) ) )
		{	
			if (!pSong) return E_INVALIDARG;
			DO_GETOBJECT_NOTNULL(IDirectMusicSong8*,pPlaySong,pSong);

			if (FAILED (hr = m__dxj_DirectMusicPerformance->StopEx(pPlaySong, outTime, (DWORD) lFlags) ) )
				return hr;
		}
#endif
		else if (SUCCEEDED ( hr = ObjectToStop->QueryInterface(IID_I_dxj_DirectMusicSegmentState, (void**)&pSegState) ) )
		{	
			if (!pSegState) return E_INVALIDARG;
			DO_GETOBJECT_NOTNULL(IDirectMusicSegmentState8*,pPlayState,pSegState);

			if (FAILED (hr = m__dxj_DirectMusicPerformance->StopEx(pPlayState, outTime, (DWORD) lFlags) ) )
				return hr;
		}
		else if (SUCCEEDED ( hr = ObjectToStop->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&pPath) ) )
		{	
			if (!pPath) return E_INVALIDARG;
			DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath*,pPlayPath,pPath);

			if (FAILED (hr = m__dxj_DirectMusicPerformance->StopEx(pPlayPath, outTime, (DWORD) lFlags) ) )
				return hr;
		}
			else
				return E_INVALIDARG;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::CreateAudioPath(IUnknown *SourceConfig, VARIANT_BOOL fActive, 
                                           		I_dxj_DirectMusicAudioPath **ppNewPath)
{
	HRESULT hr;
	IDirectMusicAudioPath	*lpPath = NULL;
	BOOL					bActive = FALSE;

	__try {
		if (fActive = VARIANT_TRUE)
			bActive = TRUE;
		else
			bActive = FALSE;

		if (FAILED (hr = m__dxj_DirectMusicPerformance->CreateAudioPath(SourceConfig, bActive, &lpPath) ) )
			return hr;

		INTERNAL_CREATE(_dxj_DirectMusicAudioPath,lpPath,ppNewPath);
		if (!ppNewPath) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::CreateStandardAudioPath(long lType, long lPChannelCount, VARIANT_BOOL fActive, 
	                                           I_dxj_DirectMusicAudioPath **ppNewPath)
{
	HRESULT hr;
	IDirectMusicAudioPath	*lpPath = NULL;

	__try {
		//First let's create our standard path
		if (FAILED ( hr = m__dxj_DirectMusicPerformance->CreateStandardAudioPath((DWORD) lType, (DWORD) lPChannelCount, (BOOL) fActive, &lpPath) ) )
			return hr;

		INTERNAL_CREATE(_dxj_DirectMusicAudioPath,lpPath,ppNewPath);
		if (!ppNewPath) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::SetDefaultAudioPath(I_dxj_DirectMusicAudioPath *AudioPath)
{
	HRESULT hr;

	__try {
		DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath8*,pPath,AudioPath);
		
		if (FAILED(hr = m__dxj_DirectMusicPerformance->SetDefaultAudioPath(pPath) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::GetDefaultAudioPath(I_dxj_DirectMusicAudioPath **ppAudioPath)
{
	HRESULT hr;
	IDirectMusicAudioPath	*lpPath = NULL;

	__try {
		//First let's create our standard path
		if (FAILED ( hr = m__dxj_DirectMusicPerformance->GetDefaultAudioPath(&lpPath) ) )
			return hr;

		INTERNAL_CREATE(_dxj_DirectMusicAudioPath,lpPath,ppAudioPath);
		if (!ppAudioPath) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}


//DEAD CODE left here for reference
#if 0

	HRESULT C_dxj_DirectMusicPerformanceObject::addCommandParam( 
			/* [in] */ long trackIndex,
			/* [in] */ long mtTime,
			/* [in] */ Byte command,
			/* [in] */ Byte grooveLevel)
	{	
		HRESULT hr;	
		DMUS_COMMAND_PARAM cmd;
		cmd.bCommand=(BYTE)command;
		cmd.bGrooveLevel=(BYTE)grooveLevel;
		cmd.bGrooveRange=0;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_CommandParam,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,&cmd);	
		return hr;
	}


	HRESULT C_dxj_DirectMusicPerformanceObject::addBandChange(  /* [in] */ long trackIndex, /* [in] */ long mtTime, /* [in] */ I_dxj_DirectMusicBand __RPC_FAR *band)
	{
		if (!band) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicBand*,pBand,band);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_IDirectMusicBand,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,pBand);	
		return hr;
	}
 
	HRESULT C_dxj_DirectMusicPerformanceObject::addTempoChange( 
			/* [in] */ long trackIndex,
			/* [in] */ long mtTime,
			/* [in] */  double tempo)
	{
		HRESULT hr;	
		DMUS_TEMPO_PARAM tmp;
		tmp.dblTempo=tempo;
		tmp.mtTime=(MUSIC_TIME)mtTime;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_TempoParam,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,&tmp);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::addTimeSigChange( /* [in] */ long trackIndex,/* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSignature)
	{
		HRESULT hr;	
		if (!timeSignature) return E_INVALIDARG;
		MUSIC_TIME mtTime=((DMUS_TIMESIGNATURE*)timeSignature)->mtTime;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_TimeSignature,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)mtTime,(DMUS_TIMESIGNATURE*)timeSignature);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::setAutoDownloadEnable( /* [in] */ long trackIndex, /* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Disable_Auto_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Enable_Auto_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}

     
	HRESULT C_dxj_DirectMusicPerformanceObject::setTempoEnable( /* [in] */ long trackIndex,/* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_DisableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_EnableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}


	HRESULT C_dxj_DirectMusicPerformanceObject::setTimeSigEnable( /* [in] */ long trackIndex,/* [retval][out] */ VARIANT_BOOL b)
	{
		HRESULT hr;	
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_DisableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicPerformance->SetParam(GUID_EnableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::clearAllBands ()
	{
		HRESULT hr;
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Clear_All_Bands,0xFFFFFFFF,0,0,NULL);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::download(  /* [in] */ long trackIndex,    /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
	{
		if (!performance) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Download,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,pPerformance);	
		return hr;
	}

	HRESULT C_dxj_DirectMusicPerformanceObject::unload( /* [in] */ long trackIndex,   /* [in] */ I_dxj_DirectMusicPerformance __RPC_FAR *performance)
	{
		if (!performance) return E_INVALIDARG;	
		DO_GETOBJECT_NOTNULL(IDirectMusicPerformance*,pPerformance,performance);
		HRESULT hr;	
		hr=m__dxj_DirectMusicPerformance->SetParam(GUID_Unload,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,pPerformance);	
		return hr;
	}

HRESULT C_dxj_DirectMusicPerformanceObject::AddPort(I_dxj_DirectMusicPort *port)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPORT, lpPort, port);
	
	if (FAILED (hr = m__dxj_DirectMusicPerformance->AddPort(lpPort) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::RemovePort(I_dxj_DirectMusicPort *port)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPORT, lpPort, port);
	
	if (FAILED (hr = m__dxj_DirectMusicPerformance->RemovePort(lpPort) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::AssignPChannel(long lPChannel, I_dxj_DirectMusicPort *Port, long lGroup, long lMChannel)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPORT, lpPort, Port);
	
	if (FAILED (hr = m__dxj_DirectMusicPerformance->AssignPChannel((DWORD)lPChannel, lpPort, (DWORD)lGroup, (DWORD) lMChannel) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::AssignPChannelBlock(long lPChannel, I_dxj_DirectMusicPort *Port, long lGroup)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPORT, lpPort, Port);
	
	if (FAILED (hr = m__dxj_DirectMusicPerformance->AssignPChannelBlock((DWORD)lPChannel, lpPort, (DWORD)lGroup) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::PChannelInfo(long lPChannel, I_dxj_DirectMusicPort *Port, long *lGroup, long *lMChannel)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICPORT, lpPort, Port);
	
	if (FAILED (hr = m__dxj_DirectMusicPerformance->PChannelInfo((DWORD)lPChannel, &lpPort, (DWORD*)lGroup, (DWORD*) lMChannel) ) )
		return hr;

	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::init( 
		/* [in] */ I_dxj_DirectSound __RPC_FAR *DirectSound,
		/* [in] */ long hWnd,
					I_dxj_DirectMusic **ret)
{
	HRESULT hr;	
	IDirectMusic	*lpDMTemp = NULL;

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND,pSound,DirectSound);
    
	hr=m__dxj_DirectMusicPerformance->Init(&lpDMTemp,pSound,(HWND)hWnd);
	if FAILED(hr) return hr;

	if (FAILED( hr = lpDMTemp->QueryInterface(IID_IDirectMusic8,(void**) &m_pDM) ) )
		return hr;
	lpDMTemp->Release();

	m_pDM->AddRef();
	INTERNAL_CREATE(_dxj_DirectMusic,m_pDM,ret);
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::setPort( 
		/* [in] */ long portid,
		/* [in] */ long number_of_groups)
{
	if (!m_pDM) return DMUS_E_NOT_INIT;

	HRESULT             hr;
    DMUS_PORTPARAMS     dmos;
	GUID				guidSink;
	IDirectMusicPort	*port = NULL;
	DWORD				j=0;
	
    // Initialize the performance. Have the performance create the
    // DirectMusic object by setting pDM to NULL. It is needed to
    // create the port.

	// Set Port Params
    ZeroMemory( &dmos, sizeof(DMUS_PORTPARAMS) );
    dmos.dwSize = sizeof(DMUS_PORTPARAMS);  
    dmos.dwChannelGroups = number_of_groups;
    dmos.dwEffectFlags = DMUS_EFFECT_REVERB;
    dmos.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_EFFECTS;
	
	if (m_pPort){

		// We've already got this port, lets get rid of it
		
		hr = m_pPort->Release();

		if ( FAILED(hr= m__dxj_DirectMusicPerformance->RemovePort(m_pPort) ))
			return hr;
	}


	if (portid<=0) {
		guidSink = GUID_NULL;
	}
	else {
		DMUS_PORTCAPS       caps;

		ZeroMemory(&caps,sizeof(DMUS_PORTCAPS));
		caps.dwSize=sizeof(DMUS_PORTCAPS);

		hr=m_pDM->EnumPort(  (DWORD) portid-1,   &caps );
		if FAILED(hr) return hr;
		memcpy(&guidSink,&caps.guidPort,sizeof(GUID));
	}

	// Create the port
    if (FAILED(hr = m_pDM->CreatePort( guidSink, &dmos, &port, NULL )))
		return hr;

	//Now get our DirectMusicPort8
	hr = port->QueryInterface(IID_IDirectMusicPort8, (void **) &m_pPort );
	port->Release();
	if ( FAILED ( hr ) ) return hr;

	// Activate all ports
    if ( FAILED (hr = m_pDM->Activate( TRUE ) ) )
		return hr;

	// Add the port to the performance.
    if (FAILED (hr = m__dxj_DirectMusicPerformance->AddPort( m_pPort ) ))
		return hr;

	// Assign PChannel blocks for the number of groups we want.

	for( long i = 0; i < number_of_groups; i++ )
	{
		m__dxj_DirectMusicPerformance->AssignPChannelBlock( i, m_pPort, i+1 );
	}

	m_portid=portid;
	m_number_of_groups=number_of_groups;
	return S_OK;

}

HRESULT C_dxj_DirectMusicPerformanceObject::playSegment( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ long lFlags,
		/* [in] */ long startTime,
		/* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState)
{
	HRESULT hr;	
	if (!segment) return E_INVALIDARG;
	if (!segmentState) return E_INVALIDARG;
					     
	DO_GETOBJECT_NOTNULL(IDirectMusicSegment*,pSeg,segment);
	IDirectMusicSegmentState *pState=NULL;
	
	__int64 outTime=(__int64)startTime;
	if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(startTime);
	
	hr=m__dxj_DirectMusicPerformance->PlaySegment(pSeg,(DWORD)lFlags,outTime,&pState);
	if FAILED(hr) return hr;
	if (!pState) return E_FAIL;

	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegmentState,pState,segmentState);
	
	if (*segmentState==NULL) return E_OUTOFMEMORY;
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::stop( 
		/* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
		/* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,		
		/* [in] */ long endTime,
		/* [in] */ long lFlags)
		
{
	HRESULT hr;	
	
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENT,pSeg,segment);
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICSEGMENTSTATE,pSegState,segmentState);
	
	
	
	__int64 outTime=(__int64)endTime;
	if (lFlags & DMUS_SEGF_REFTIME)  outTime=VBREF_TO_REALREFTIME(endTime);
	
	hr=m__dxj_DirectMusicPerformance->Stop(pSeg,pSegState,(MUSIC_TIME)outTime,(DWORD)lFlags);	
	
	return hr;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getPortName( 
		/* [in] */ long i,
		/* [retval][out] */ BSTR __RPC_FAR *name)
{
	HRESULT hr;	
	DMUS_PORTCAPS caps;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (i<=0) return E_INVALIDARG;

	if (!name) return E_INVALIDARG;
	ZeroMemory(&caps,sizeof(DMUS_PORTCAPS));
	caps.dwSize=sizeof(DMUS_PORTCAPS);
	hr=m_pDM->EnumPort(  (DWORD) i-1,   &caps );
	
	if (hr!=S_OK) return E_INVALIDARG;	//happens when we are out of bounds
										//manbug23240
	if FAILED(hr) return hr;			//for other resason ?

	*name=SysAllocString(caps.wszDescription);
	return S_OK;
}

HRESULT C_dxj_DirectMusicPerformanceObject::getPortCount( 
		/* [retval][out] */ long __RPC_FAR *c)
{
	HRESULT hr=S_OK;	
	DMUS_PORTCAPS caps;
	DWORD i=0;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (!c) return E_INVALIDARG;
	while (hr==S_OK){
		caps.dwSize=sizeof(DMUS_PORTCAPS);
		hr=m_pDM->EnumPort(  i++,   &caps );
		if FAILED(hr) return hr;
	}
	*c=(long)i-1;
	return S_OK;
}
HRESULT C_dxj_DirectMusicPerformanceObject::getPortCaps( long i,
		/* [retval][out] */ DMUS_PORTCAPS_CDESC __RPC_FAR *c)
{
	HRESULT hr;		
	if (!c) return E_INVALIDARG;
	if (!m_pDM) return CO_E_NOTINITIALIZED;
	if (i<=0) return E_INVALIDARG;

	ZeroMemory(c,sizeof(DMUS_PORTCAPS));
	((DMUS_PORTCAPS*)c)->dwSize=sizeof(DMUS_PORTCAPS);
	hr=m_pDM->EnumPort(  (DWORD) i-1,   (DMUS_PORTCAPS*)c );
	if (hr==S_FALSE) return E_INVALIDARG;

	return hr;		
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmperformanceobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmperformanceobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicPerformanceObject

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicPerformance IDirectMusicPerformance8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicPerformanceObject : 
	public I_dxj_DirectMusicPerformance,
	//public CComCoClass<C_dxj_DirectMusicPerformanceObject, &CLSID__dxj_DirectMusicPerformance>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicPerformanceObject();
	virtual ~C_dxj_DirectMusicPerformanceObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicPerformanceObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicPerformance)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicPerformance,		"DIRECT.DirectMusicPerformance.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicPerformanceObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);



#if 0
    HRESULT STDMETHODCALLTYPE init( 
        /* [in] */ I_dxj_DirectSound __RPC_FAR *DirectSound,
        /* [in] */ long hWnd,
		I_dxj_DirectMusic **ret);
#endif
    
    HRESULT STDMETHODCALLTYPE closeDown( void);
    
    HRESULT STDMETHODCALLTYPE playSegment( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ long lFlags,
        /* [in] */ long startTime,
        /* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *segmentState);
    
    HRESULT STDMETHODCALLTYPE stop( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
        /* [in] */ long mtTime,
        /* [in] */ long lFlags);
    
    HRESULT STDMETHODCALLTYPE getSegmentState( 
        /* [in] */ long mtTime,
        /* [retval][out] */ I_dxj_DirectMusicSegmentState __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE invalidate( 
        /* [in] */ long mtTime,
        /* [in] */ long flags);
    
    HRESULT STDMETHODCALLTYPE isPlaying( 
        /* [in] */ I_dxj_DirectMusicSegment __RPC_FAR *segment,
        /* [in] */ I_dxj_DirectMusicSegmentState __RPC_FAR *segmentState,
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
    
    HRESULT STDMETHODCALLTYPE addNotificationType( 
        /* [in] */ CONST_DMUS_NOTIFICATION_TYPE type);
    
    HRESULT STDMETHODCALLTYPE removeNotificationType( 
        /* [in] */ CONST_DMUS_NOTIFICATION_TYPE type);
    
#ifdef _WIN64
	HRESULT STDMETHODCALLTYPE setNotificationHandle( 
        /* [in] */ HWND hnd);
#else
	HRESULT STDMETHODCALLTYPE setNotificationHandle( 
        /* [in] */ long hnd);
#endif
    
    HRESULT STDMETHODCALLTYPE getNotificationPMSG( 
        /* [out][in] */ DMUS_NOTIFICATION_PMSG_CDESC __RPC_FAR *message, VARIANT_BOOL *b);
    
    HRESULT STDMETHODCALLTYPE musicToClockTime( 
        /* [in] */ long mtTime,
        /* [retval][out] */ long __RPC_FAR *rtTime);
    
    HRESULT STDMETHODCALLTYPE clockToMusicTime( 
        /* [in] */ long rtTime,
        /* [retval][out] */ long __RPC_FAR *mtTime);
    
    HRESULT STDMETHODCALLTYPE getMusicTime( 
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getClockTime( 
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getPrepareTime( 
        /* [retval][out] */ long __RPC_FAR *lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE getBumperLength( 
        /* [retval][out] */ long __RPC_FAR *lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE getLatencyTime( 
        /* [retval][out] */ long __RPC_FAR *rtTime0);
    
    HRESULT STDMETHODCALLTYPE getQueueTime( 
        /* [retval][out] */ long __RPC_FAR *rtTime);
    
    HRESULT STDMETHODCALLTYPE getResolvedTime( 
        /* [in] */ long rtTime,
        /* [in] */ long flags,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE setPrepareTime( 
        /* [in] */ long lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE setBumperLength( 
        /* [in] */ long lMilliSeconds);
    
    HRESULT STDMETHODCALLTYPE adjustTime( 
        /* [in] */ long rtAmount);
    
    HRESULT STDMETHODCALLTYPE setMasterAutoDownload( 
        /* [in] */ VARIANT_BOOL b);
    
    HRESULT STDMETHODCALLTYPE getMasterAutoDownload( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *b);
    
    HRESULT STDMETHODCALLTYPE setMasterTempo( 
        /* [in] */ float tempo);
    
    HRESULT STDMETHODCALLTYPE getMasterTempo( 
        /* [retval][out] */ float __RPC_FAR *tempo);
    
    HRESULT STDMETHODCALLTYPE setMasterVolume( 
        /* [in] */ long vol);
    
    HRESULT STDMETHODCALLTYPE getMasterVolume( 
        /* [retval][out] */ long __RPC_FAR *v);
    
    HRESULT STDMETHODCALLTYPE setMasterGrooveLevel( 
        /* [in] */ short level);
    
    HRESULT STDMETHODCALLTYPE getMasterGrooveLevel( 
        /* [retval][out] */  __RPC_FAR short *level);
    
    HRESULT STDMETHODCALLTYPE Reset(long flags);
    
    HRESULT STDMETHODCALLTYPE getStyle( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getChordMap( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getCommand( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ Byte __RPC_FAR *command);
    
    HRESULT STDMETHODCALLTYPE getGrooveLevel( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ Byte __RPC_FAR *level);
    
    HRESULT STDMETHODCALLTYPE getTempo( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ double __RPC_FAR *tempo);
    
    HRESULT STDMETHODCALLTYPE getTimeSig( 
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timeSig);
    
    HRESULT STDMETHODCALLTYPE sendNotePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ DMUS_NOTE_PMSG_CDESC __RPC_FAR *msg);
    
    HRESULT STDMETHODCALLTYPE sendCurvePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ DMUS_CURVE_PMSG_CDESC __RPC_FAR *msg);
    
    HRESULT STDMETHODCALLTYPE sendMIDIPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ Byte status,
        /* [in] */ Byte byte1,
        /* [in] */ Byte byte2);
    
    HRESULT STDMETHODCALLTYPE sendPatchPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ Byte instrument,
        /* [in] */ Byte byte1,
        /* [in] */ Byte byte2);
    
    HRESULT STDMETHODCALLTYPE sendTempoPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
       // /* [in] */ long channel,
        /* [in] */ double tempo);
    
    HRESULT STDMETHODCALLTYPE sendTransposePMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ long channel,
        /* [in] */ short transpose);
    
    HRESULT STDMETHODCALLTYPE sendTimeSigPMSG( 
        /* [in] */ long mtTime,
        /* [in] */ long flags,
        /* [in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *timesig);
    
#if 0
	HRESULT STDMETHODCALLTYPE getPortName( 
        /* [in] */ long i,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getPortCount( 
        /* [retval][out] */ long __RPC_FAR *c);
    
    HRESULT STDMETHODCALLTYPE getPortCaps( long i,
        /* [out][in] */ DMUS_PORTCAPS_CDESC __RPC_FAR *caps);
    
    HRESULT STDMETHODCALLTYPE setPort( 
        /* [in] */ long portid,
        /* [in] */ long numGroups);
#endif
#ifdef _WIN64
    HRESULT STDMETHODCALLTYPE InitAudio(HWND hWnd,
										long lFlags,
										DMUS_AUDIOPARAMS_CDESC *AudioParams,
                                        I_dxj_DirectSound **DirectSound,  
                                        long lDefaultPathType,           
                                        long lPChannelCount);            
#else
    HRESULT STDMETHODCALLTYPE InitAudio(long hWnd,
										long lFlags,
										DMUS_AUDIOPARAMS_CDESC *AudioParams,
                                        I_dxj_DirectSound **DirectSound,  
                                        long lDefaultPathType,           
                                        long lPChannelCount);            
#endif
        
    HRESULT STDMETHODCALLTYPE PlaySegmentEx(IUnknown *Source,
											long lFlags,
											long StartTime,
											IUnknown *From,
											IUnknown *AudioPath,
#if 0
											BSTR SegmentName,
											IUnknown *Transition, 
#endif
											I_dxj_DirectMusicSegmentState **ppSegmentState); 

    HRESULT STDMETHODCALLTYPE StopEx(IUnknown *ObjectToStop,
										long lStopTime, 
										long lFlags);


    HRESULT STDMETHODCALLTYPE CreateAudioPath(IUnknown *SourceConfig, VARIANT_BOOL fActive, 
                                           		I_dxj_DirectMusicAudioPath **ppNewPath);

    HRESULT STDMETHODCALLTYPE CreateStandardAudioPath(long lType, long lPChannelCount, VARIANT_BOOL fActive, 
	                                           I_dxj_DirectMusicAudioPath **ppNewPath);

    HRESULT STDMETHODCALLTYPE SetDefaultAudioPath(I_dxj_DirectMusicAudioPath *AudioPath);
    HRESULT STDMETHODCALLTYPE GetDefaultAudioPath(I_dxj_DirectMusicAudioPath **ppAudioPath);

#if 0
	HRESULT STDMETHODCALLTYPE AddPort(I_dxj_DirectMusicPort *port);
    HRESULT STDMETHODCALLTYPE RemovePort(I_dxj_DirectMusicPort *port);
    HRESULT STDMETHODCALLTYPE AssignPChannel(long lPChannel, I_dxj_DirectMusicPort *Port, long lGroup, long lMChannel);
    HRESULT STDMETHODCALLTYPE AssignPChannelBlock(long lPChannel, I_dxj_DirectMusicPort *Port, long lGroup);
    HRESULT STDMETHODCALLTYPE PChannelInfo(long lPChannel, I_dxj_DirectMusicPort *Port, long *lGroup, long *lMChannel);
#endif

////////////////////////////////////////////////////////////////////////////////////
//
private:
	HRESULT InternalInit();
	HRESULT InternalCleanup();
	

	IDirectMusic8 *m_pDM;
	IDirectMusicPort8 *m_pPort;
    DECL_VARIABLE(_dxj_DirectMusicPerformance);
	long m_portid;
	long m_number_of_groups;


	

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicPerformance)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmstyleobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmstyleobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmChordMapObj.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmBandObj.h"

extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicChordMap;
extern void *g_dxj_DirectMusicBand;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicStyle, {});
DESTRUCTOR(_dxj_DirectMusicStyle, {});
GETSET_OBJECT(_dxj_DirectMusicStyle);

typedef IDirectMusicSegment*		LPDIRECTMUSICSEGMENT;
typedef IDirectMusicPerformance*	LPDIRECTMUSICPERFORMANCE;
typedef IDirectMusicChordMap*		LPDIRECTMUSICCHORDMAP;
typedef IDirectMusicStyle*			LPDIRECTMUSICSTYLE;

HRESULT C_dxj_DirectMusicStyleObject:: getBandName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{  
	HRESULT hr;			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumBand((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getBandCount( long *count)        
{    			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumBand((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getBand( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicBand *pBand=NULL;

	hr=m__dxj_DirectMusicStyle->GetBand(name,&pBand);
	if FAILED(hr) return hr;
	if (!pBand) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pBand,ret);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject::getDefaultBand( 
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicBand *pBand=NULL;
	*ret=NULL;
	hr=m__dxj_DirectMusicStyle->GetDefaultBand(&pBand);
	if FAILED(hr) return hr;
	if (hr==S_FALSE) return S_OK;
	if (!pBand) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicBand,pBand,ret);
	return hr;
}

    
HRESULT C_dxj_DirectMusicStyleObject:: getMotifName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{    
	HRESULT hr;
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumMotif((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getMotifCount( long *count)        
{    			
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumMotif((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getMotif( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicSegment *pSeg=NULL;

	hr=m__dxj_DirectMusicStyle->GetMotif(name,&pSeg);
	if FAILED(hr) return hr;
	if (!pSeg) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,ret);
	return hr;
}



HRESULT C_dxj_DirectMusicStyleObject:: getChordMapName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name)
{    	
	HRESULT hr;
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);

	hr=m__dxj_DirectMusicStyle->EnumChordMap((DWORD)index,wstring);
	if (hr!=S_OK) return hr;	
	*name=SysAllocString(wstring);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getChordMapCount( long *count)        
{ 
	WCHAR wstring[MAX_PATH];
	ZeroMemory(wstring,MAX_PATH);
	DWORD i=0;
	
	while (S_OK==m__dxj_DirectMusicStyle->EnumChordMap((DWORD)i++,wstring)){
		//make sure dmusic is doing what its docs say it does
		if (i>1000000) return E_FAIL;
	}
	*count=(long)i-1;
	
	return S_OK;
}


HRESULT C_dxj_DirectMusicStyleObject:: getChordMap( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicChordMap	*pMap=NULL;

	hr=m__dxj_DirectMusicStyle->GetChordMap(name,&pMap);
	if FAILED(hr) return hr;
	if (!pMap) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject:: getDefaultChordMap( 
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
	HRESULT hr;			
	IDirectMusicChordMap	*pMap=NULL;
	*ret=NULL;
	hr=m__dxj_DirectMusicStyle->GetDefaultChordMap(&pMap);
	if (hr==S_FALSE) return S_OK;

	if FAILED(hr) return hr;
	if (!pMap) return E_FAIL;
	INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
	return hr;
}


HRESULT C_dxj_DirectMusicStyleObject:: getEmbellishmentMinLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;			
	DWORD dwMin=0;
	DWORD dwMax=0;

	hr=m__dxj_DirectMusicStyle->GetEmbellishmentLength((DWORD)type,(DWORD)level,&dwMin,&dwMax);
	*ret=(long)dwMin;
	return hr;
}
		
HRESULT C_dxj_DirectMusicStyleObject:: getEmbellishmentMaxLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret)
{
	HRESULT hr;			
	DWORD dwMin=0;
	DWORD dwMax=0;

	hr=m__dxj_DirectMusicStyle->GetEmbellishmentLength((DWORD)type,(DWORD)level,&dwMin,&dwMax);	
	*ret=(long)dwMax;
	return hr;
}

HRESULT C_dxj_DirectMusicStyleObject::getTempo( 
        /* [retval][out] */ double __RPC_FAR *ret)
{
	HRESULT hr;			
	hr=m__dxj_DirectMusicStyle->GetTempo(ret);	
	return hr;
}

		

HRESULT C_dxj_DirectMusicStyleObject::getTimeSignature( 
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *pTimeSig)
{
	HRESULT hr;				
	if (!pTimeSig) return E_INVALIDARG;
	hr=m__dxj_DirectMusicStyle->GetTimeSignature((DMUS_TIMESIGNATURE*)pTimeSig);	
	return hr;
}
// GetDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dms.h ===
//+-------------------------------------------------------------------------
    //
    //  Microsoft Windows
    //
    //  Copyright (C) Microsoft Corporation, 1998 - 1999
    //
    //  File:       dms.h
    //
    //--------------------------------------------------------------------------
     
    
    //
    // dms.h : david's funky stuff
    //
    // CLONETO, QIOVERLOAD: see d3drmVisualObj.cpp
    //
    //
    //
    #include "basetsd.h"
extern long g_debuglevel;
    
    #ifdef DEBUG
	 #define DPF(n,o)		{if (g_debuglevel >= n) { OutputDebugString(o);}}
	 #define DPF1(n,o,p)		{if (g_debuglevel >= n) {char szOutN[1024]; wsprintf(szOutN,o,p);OutputDebugString(szOutN);}}
	 #define DPF2(n,o,p,e)	{if (g_debuglevel >= n) {char szOutN[1024]; wsprintf(szOutN,o,p,e);OutputDebugString(szOutN);}}
    #else
		#ifdef DBG
		 #define DPF(n,o)		{if (g_debuglevel >= n) { OutputDebugString(o);}}
		 #define DPF1(n,o,p)		{if (g_debuglevel >= n) {char szOutN[1024]; wsprintf(szOutN,o,p);OutputDebugString(szOutN);}}
		 #define DPF2(n,o,p,e)	{if (g_debuglevel >= n) {char szOutN[1024]; wsprintf(szOutN,o,p,e);OutputDebugString(szOutN);}}
		#else
		 #define DPF(n,o)		
		 #define DPF1(n,o,p)		
		 #define DPF2(n,o,p,e)
		#endif	
    #endif
    
    #define INTERNAL_CREATE_RETOBJ(objType,objOther,retval,classobj) \
    { 	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{	IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface; \
    			IUNK(ptr->pinterface)->AddRef(); \
    			IUNK(objOther)->Release(); \
    			classobj=ptr; \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{	C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    		c->parent = this; \
    		((I##objType *)this)->AddRef();  \
    		c->InternalSetObject(objOther); \
    		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) \
    			return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    		classobj=c; \
    } }
    
    
    
    #define INTERNAL_CREATE_STRUCT(objType,retval) { C##objType##Object *c=new CComObject<C##objType##Object>;\
    	if (c==NULL) return E_OUTOFMEMORY;\
    	if (FAILED(((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL;\
    	}
    
    
    #define INTERNAL_CREATE_NOADDREF(objType,objOther,retval) {C##objType##Object *prev=NULL; *retval = NULL; \
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj){IUnknown *unk=0;ptr->InternalGetObject(&unk); 	if(unk == objOther) { 	*retval = (I##objType*)ptr->pinterface;	IUNK(ptr->pinterface)->AddRef(); IUNK(objOther)->Release(); break;	} 	prev = ptr; } \
    	if(!ptr) { 	C##objType##Object *c=new CComObject<C##objType##Object>; if( c == NULL ) {	objOther->Release();return E_FAIL;}	c->InternalSetObject(objOther);  if FAILED(((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval)) 	return E_FAIL; c->pinterface = (void*)*retval; }}	
    		
    // Given a java interface (objtype), envoke InternalSetObject and set the given
    // DIRECTX pointer (objOther). Also envoke QueryInterface and set a ** interface
    // ptr to a DIRECTX object (retval). So we create a DIRECTX object.
    //#define INTERNAL_CREATE(objType,objOther,retval){C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    //c->parent = this; AddRef(); c->InternalSetObject(objOther);if (FAILED(c->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; }
    //			if (FAILED(ptr->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; 
    #ifdef _DEBUG
    #define INTERNAL_CREATE(objType,objOther,retval) \
    { \
    	DWORD refcount; char buffer[256]; wsprintf(buffer,"INTERNAL_CREATE %s \n",__FILE__); \
    	OutputDebugString(buffer); \
    	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{\
    		IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface;\
    			IUNK(ptr->pinterface)->AddRef();\
    			IUNK(objOther)->Release(); \
    			refcount = *(((DWORD*)ptr)+1); \
    			wsprintf(buffer,"		Retrived Object [%s] RefCount %d \n\r",__FILE__, refcount);\
    			OutputDebugString(buffer);\
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{ \
    		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    		c->parent = this; \
    		((I##objType *)this)->AddRef(); \
    		refcount = *(((DWORD*)this)+1); \
    		wsprintf(buffer,"Object [%s] RefCount[%d]\n\r",__FILE__, refcount);\
    		OutputDebugString(buffer);\
    		c->InternalSetObject(objOther);if (FAILED((	((I##objType *)c))->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    	} \
    }
    #else
    #define INTERNAL_CREATE(objType,objOther,retval) \
    { \
    	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{\
    		IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface; \
    			IUNK(ptr->pinterface)->AddRef(); \
    			IUNK(objOther)->Release(); \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{ \
    		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    		c->parent = this; \
    		((I##objType *)this)->AddRef();  \
    		c->InternalSetObject(objOther); \
    		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    	} \
    }
    #endif
    
    
    #define INTERNAL_CREATE_NO_PARENT(objType,objOther,retval) \
    { \
    	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{\
    		IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface; \
    			IUNK(ptr->pinterface)->AddRef(); \
    			IUNK(objOther)->Release(); \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{ \
    		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    		c->InternalSetObject(objOther); \
    		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    	} \
    }
    
    #define INTERNAL_CREATE_ADDRESS(objType,objOther,retval) \
    { \
    	C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    	c->InternalSetObject(objOther); \
    	if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    	c->pinterface = (void*)*retval; \
    }
    #define INTERNAL_CREATE_2REFS(objType,objParentType,objParent, objOther,retval) \
    {	 \
    	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{\
    		IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface; \
    			IUNK(ptr->pinterface)->AddRef(); \
    			IUNK(objOther)->Release(); \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{ \
    		C##objType##Object *c=new CComObject<C##objType##Object>;if( c == NULL ) { objOther->Release(); return E_FAIL;} \
    		c->parent = this; \
    		c->parent2 = IUNK(objParent); \
    		((I##objType *)this)->AddRef();  \
    		((I##objParentType*)objParent)->AddRef();  \
    		c->InternalSetObject(objOther); \
    		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    	} \
    }
    
    
    #define INTERNAL_CREATE_1REFS(objType,objParentType,objParent, objOther,retval) \
    {	 \
    	C##objType##Object *prev=NULL; \
    	*retval = NULL;	\
    	for(C##objType##Object *ptr=(C##objType##Object *)g##objType##; ptr; ptr=(C##objType##Object *)ptr->nextobj) \
    	{\
    		IUnknown *unk=0; \
    		ptr->InternalGetObject(&unk); \
    		if(unk == objOther) \
    		{ \
    			*retval = (I##objType*)ptr->pinterface; \
    			IUNK(ptr->pinterface)->AddRef(); \
    			IUNK(objOther)->Release(); \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(!ptr) \
    	{ \
    		C##objType##Object *c=new CComObject<C##objType##Object>; \
            if( c == NULL ) \
            { objOther->Release(); return E_FAIL;} \
    		c->parent = IUNK(objParent); \
    		((I##objParentType*)objParent)->AddRef();  \
    		c->InternalSetObject(objOther); \
    		if (FAILED(	((I##objType *)c)->QueryInterface(IID_I##objType, (void **)retval))) return E_FAIL; \
    		c->pinterface = (void*)*retval; \
    	} \
    }
    
    
    /////////////////////////////////////////////////////////////////////////
    #define MAX_INTERNAL_STR_LEN	256
    
    struct JavaString
    {
    	DWORD nBytes;
    	WCHAR Item[MAX_INTERNAL_STR_LEN];
    };
    
    /////////////////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////////////////
    // mod:dp helper macros for stuffing expanded unions in DirectX Structures
    
    #define IUNK(o) ((IUnknown*)(void*)(o))
    #define IS_NULLGUID(g) (\
    	(g->data1==0) && \
    	(g->data2==0) && \
    	(g->data3==0) && \
    	(g->data4[0]==0) && \
    	(g->data4[1]==0) && \
    	(g->data4[2]==0) && \
    	(g->data4[3]==0) && \
    	(g->data4[4]==0) && \
    	(g->data4[5]==0) && \
    	(g->data4[6]==0) && \
    	(g->data4[7]==0) )
    
     	
    
    
    
    /////////////////////////////////////////////////////////////////////////
    #define JAVASTRING(item) {sizeof(item)*2-2, L##item}
    
    #define PASS_THROUGH(cl,m) STDMETHODIMP C##cl##Object::m() { return m_##cl->m();}
    #define PASS_THROUGH1(c,m,t1) STDMETHODIMP C##c##Object::m(t1 v1) { return m_##c->m(v1);}
    #define PASS_THROUGH2(c,m,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2) { return m_##c->m(v1, v2);}
    #define PASS_THROUGH3(c,m,t1,t2,t3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,t3 v3) { return m_##c->m(v1, v2,v3);}
    #define PASS_THROUGH4(c,m,t1,t2,t3,t4) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4){return m_##c->m(v1, v2,v3,v4);}
    #define PASS_THROUGH5(c,m,t1,t2,t3,t4,t5) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){return m_##c->m(v1, v2,v3,v4,v5);}
    #define PASS_THROUGH6(c,m,t1,t2,t3,t4,t5,t6) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){return m_##c->m(v1, v2,v3,v4,v5,v6);}
    #define PASS_THROUGH7(c,m,t1,t2,t3,t4,t5,t6,t7) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){return m_##c->m(v1, v2,v3,v4,v5,v6,v7);}
    #define PASS_THROUGH8(c,m,t1,t2,t3,t4,t5,t6,t7,t8) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){return m_##c->m(v1,v2,v3,v4,v5,v6,v7,v8);}
    
    #define PASS_THROUGH_CAST_1(c,m,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1) { return m_##c->m(tt1 v1);}
    #define PASS_THROUGH_CAST_2(c,m,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2) { return m_##c->m(tt1 v1, tt2 v2);}
    #define PASS_THROUGH_CAST_3(c,m,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,t3 v3) { return m_##c->m(tt1 v1,tt2 v2,tt3 v3);}
    #define PASS_THROUGH_CAST_4(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4){return m_##c->m(tt1 v1, tt2 v2,tt3 v3,tt4 v4);}
    #define PASS_THROUGH_CAST_5(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5);}
    #define PASS_THROUGH_CAST_6(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6);}
    #define PASS_THROUGH_CAST_7(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7);}
    #define PASS_THROUGH_CAST_8(c,m,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7,t8,tt8) STDMETHODIMP C##c##Object::m(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){return m_##c->m(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7,tt8 v8);}
    
    //mod:dp additions due to renaming 
    #define PASS_THROUGH_R(c,m1,m2) STDMETHODIMP C##c##Object::m1() { if(m_##c==NULL)return E_FAIL; return m_##c->m2();}
    #define PASS_THROUGH1_R(c,m1,m2,t1) STDMETHODIMP C##c##Object::m1(t1 v1) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1);}
    #define PASS_THROUGH2_R(c,m1,m2,t1,t2) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2);}
    #define PASS_THROUGH3_R(c,m1,m2,t1,t2,t3) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2,t3 v3) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3);}
    #define PASS_THROUGH4_R(c,m1,m2,t1,t2,t3,t4) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4);}
    #define PASS_THROUGH5_R(c,m1,m2,t1,t2,t3,t4,t5) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5);}
    #define PASS_THROUGH6_R(c,m1,m2,t1,t2,t3,t4,t5,t6) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5,v6);}
    #define PASS_THROUGH7_R(c,m1,m2,t1,t2,t3,t4,t5,t6,t7) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1, v2,v3,v4,v5,v6,v7);}
    #define PASS_THROUGH8_R(c,m1,m2,t1,t2,t3,t4,t5,t6,t7,t8) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(v1,v2,v3,v4,v5,v6,v7,v8);}
    
    #define PASS_THROUGH_CAST_1_R(c,m1,m2,t1,tt1) STDMETHODIMP C##c##Object::m1(t1 v1) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1);}
    #define PASS_THROUGH_CAST_2_R(c,m1,m2,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1, tt2 v2);}
    #define PASS_THROUGH_CAST_3_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m1(t1 v1, t2 v2,t3 v3) { if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3);}
    #define PASS_THROUGH_CAST_4_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1, tt2 v2,tt3 v3,tt4 v4);}
    #define PASS_THROUGH_CAST_5_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5);}
    #define PASS_THROUGH_CAST_6_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6);}
    #define PASS_THROUGH_CAST_7_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7);}
    #define PASS_THROUGH_CAST_8_R(c,m1,m2,t1,tt1,t2,tt2,t3,tt3,t4,tt4,t5,tt5,t6,tt6,t7,tt7,t8,tt8) STDMETHODIMP C##c##Object::m1(t1 v1,t2 v2,t3 v3,t4 v4,t5 v5,t6 v6,t7 v7,t8 v8){ if(m_##c==NULL)return E_FAIL; return m_##c->m2(tt1 v1,tt2 v2,tt3 v3,tt4 v4,tt5 v5,tt6 v6,tt7 v7,tt8 v8);}
    
    #define COPY_OR_CLEAR(dest, src, si) {if(src) memcpy((void *)dest, (void *)src, si);else memset((void *)dest, si, 0);}
    #define COPY(dest, src, si) memcpy((void *)dest, (void *)src, si)
    
    // ??
    #define DECLSET_OBJECT(ifacevar, var, typ) {if(var) var->Release();	var = (typ)ifacevar;}
    #define DECLGET_OBJECT(ifacevar, var){*ifacevar = (IUnknown *)var;}
    
    
    #define ISEQUAL(c) \
    	STDMETHODIMP C##c##Object::isEqual(I##c *d, int *retval)\
    					{	IUnknown *IU1;\
    						IUnknown *IU2;\
    						if (d == NULL)\
    							return E_FAIL;	\
    						this->InternalGetObject((IUnknown **)(&IU1)); \
    						d->InternalGetObject((IUnknown **)(&IU2)); \
    						if (IU1 == IU2) \
    							*retval = TRUE; \
    						else \
    							*retval = FALSE; \
    						return S_OK;}
    
    #define DX3J_GLOBAL_LINKS( obj_type ) \
    int creationid;\
    void *parent; \
    void *pinterface; \
    void *nextobj; 
    
    /*STDMETHOD(isEqual)(IUnknown *pobj, int *ret)*/; 
    
    // Given a class (c)
    #define GETSET_OBJECT(c) \
    	STDMETHODIMP C##c##Object::InternalSetObject(IUnknown *l)\
    					{DECLSET_OBJECT(l,m_##c,typedef_##c);return S_OK;} \
    	STDMETHODIMP C##c##Object::InternalGetObject(IUnknown **l)\
    					{DECLGET_OBJECT(l,m_##c);return S_OK;} 
    	//ISEQUAL(c);
    
    // Given a java interface, go get a pointer_to_a_pointer to a DIRECTX object
    //pac DO_GETOBJECT_NOTNULL is too dangerous and is commented.  use DO_GETOBJECT_NOTNULL
    //#define DO_GETOBJECT(t,v,i) t v;i->InternalGetObject((IUnknown **)(&v));
    #define DO_GETOBJECT_NOTNULL(t,v,i) t v=NULL;if(i) i->InternalGetObject((IUnknown **)(&v));
    
    
    //
    extern int g_creationcount;
    
    
    #ifdef _DEBUG
    
    #define CONSTRUCTOR(c, o) C##c##Object::C##c##Object(){ \
    	 m_##c = NULL; parent = NULL; pinterface = NULL; \
    	 nextobj =  g##c##;\
    	 creationid = ++g_creationcount;\
    	 char buffer[256];\
    	 wsprintf(buffer,"Constructor Creation Id [%d] %s",g_creationcount,__FILE__);\
    	 OutputDebugString(buffer);\
    	 g##c## = (void *)this; o }
    
    #else
    #define CONSTRUCTOR(c, o) C##c##Object::C##c##Object(){ \
         m_##c = NULL; parent = NULL; pinterface = NULL; \
         nextobj = (void*)g##c##; \
         creationid = ++g_creationcount; \
         g##c## = (void*)this; o}
    #endif
    
    #ifdef _DEBUG
    
    #define DESTRUCTOR(c, o) C##c##Object::~C##c##Object(){o; \
    	char buffer[256]; \
    	wsprintf(buffer,"Destructor Id[%d] %s ",creationid,__FILE__); \
    	OutputDebugString(buffer); 	C##c##Object *prev=NULL; \
    	for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
    	{\
    		if(ptr == this) \
    		{ \
    			if(prev) \
    				prev->nextobj = ptr->nextobj; \
    			else \
    				g##c## = (void*)ptr->nextobj; \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(m_##c){ 	int count = IUNK(m_##c)->Release(); wsprintf(buffer,"DirectX %s Ref count [%d]",__FILE__,count); OutputDebugString(buffer); \
    		if(count==0){ char szOut[512];wsprintf(szOut,"\n Real %s released \n",__FILE__); OutputDebugString(szOut); m_##c = NULL; } \
    	} \
    	if(parent) IUNK(parent)->Release(); \
    }
    
    #else
    #define DESTRUCTOR(c, o) C##c##Object::~C##c##Object(){o; \
    	C##c##Object *prev=NULL; \
    	for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
    	{\
    		if(ptr == this) \
    		{ \
    			if(prev) \
    				prev->nextobj = ptr->nextobj; \
    			else \
    				g##c## = (void*)ptr->nextobj; \
    			break; \
    		} \
    		prev = ptr; \
    	} \
    	if(m_##c){ \
    		if (IUNK(m_##c)->Release()==0) m_##c = NULL; \
    	} \
    	if(parent) IUNK(parent)->Release();\
    }
    #endif 
    
    
    
    #define OBJCHECK(lable, c) { \
    	char buffer[256];\
    	if ( g##c ) \
    	{\
    		int count = 0; \
    		C##c##Object *prev=NULL; \
    		C##c##Object *ptr;\
    		for(ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
    		{\
    			DWORD refcount = *(((DWORD*)ptr)+1);\
    			wsprintf( buffer,"%s: Ref Count [%d] CreateId [%d]\n\r",lable,refcount,ptr->creationid);\
    			OutputDebugString(buffer);\
    			count++;\
    		}\
    		wsprintf(buffer,"%s: %d \n\r",lable,count);\
    		OutputDebugString(buffer);\
    	}\
    }
    
    
    
    
    #ifdef _DEBUG
    #define CONSTRUCTOR_STRUCT(c, o) C##c##Object::C##c##Object(){  nextobj = g##c##;\
    	 creationid = ++g_creationcount;\
    	char buffer[256];\
    	wsprintf(buffer,"Creation Id [%d]",g_creationcount);\
    	OutputDebugString(buffer);\
    	 g##c## = (void*)this;o}
    #else
    #define CONSTRUCTOR_STRUCT(c, o) C##c##Object::C##c##Object(){ \
     nextobj =(void*) g##c##; \
     creationid = ++g_creationcount; \
     g##c## = (void*)this; \
     o}
    #endif
    
    
    
    
    #define DESTRUCTOR_STRUCT(c, o) C##c##Object::~C##c##Object(){o; \
    C##c##Object *prev=NULL; \
    for(C##c##Object *ptr=(C##c##Object *)g##c##; ptr; ptr=(C##c##Object *)ptr->nextobj) \
    {\
    	if(ptr == this) \
    	{ \
    		if(prev) \
    			prev->nextobj = ptr->nextobj; \
    		else \
    			g##c## = (void*)ptr->nextobj; \
    		break; \
    	} \
    	prev = ptr; \
    } \
    }
    
    
    // Given a java class (c), create a DIRECTX object and an interface ** ptr to it.
    #define RETURN_NEW_ITEM(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST(c,m,oc, ty) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(ty &lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_NOREL(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE_NOREL(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM1(c,m,oc,t1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM2(c,m,oc,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(v1,v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_1(c,m,oc,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(tt1 v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_2(c,m,oc,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(tt1 v1,tt2 v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_3(c,m,oc,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2, t3 v3, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(tt1 v1,tt2 v2,tt3 v3,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    //mod:dp additions due to renaming 
    // Given a java class (c), create a DIRECTX object and an interface ** ptr to it.
    #define RETURN_NEW_ITEM_R(c,m,m2,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM1_R(c,m,m2,oc,t1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM2_R(c,m,m2,oc,t1,t2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(v1,v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_R(c,m,m2,oc,ty) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(ty &lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_1_R(c,m,m2,oc,t1,tt1) STDMETHODIMP C##c##Object::m(t1 v1, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(tt1 v1,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_2_R(c,m,m2,oc,t1,tt1,t2,tt2) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2,I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m2(tt1 v1,tt2 v2,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    
    #if 0 
    #define RETURN_NEW_ITEM_NOREL(c,m,oc) STDMETHODIMP C##c##Object::m(I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(&lp) != S_OK)return E_FAIL;INTERNAL_CREATE_NOREL(oc, lp, rv);\
    	return S_OK;}
    
    #define RETURN_NEW_ITEM_CAST_3(c,m,oc,t1,tt1,t2,tt2,t3,tt3) STDMETHODIMP C##c##Object::m(t1 v1, t2 v2, t3 v3, I##oc **rv){typedef_##oc lp;\
    	if( m_##c->m(tt1 v1,tt2 v2,tt3 v3,&lp) != S_OK)return E_FAIL;INTERNAL_CREATE(oc, lp, rv);\
    	return S_OK;}
    #endif
    
    // Return a primitive value by reference.
    #define GET_DIRECT(cl,met,t) STDMETHODIMP C##cl##Object::met(t *h){*h=(t)m_##cl->met();return S_OK;}
    #define GET_DIRECT1(cl,met,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t *h){*h=(t)m_##cl->met(v1);return S_OK;}
    #define GET_DIRECT2(cl,met,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t *h){*h=(t)m_##cl->met(v1,v2);return S_OK;}
    
    #define GET_DIRECT_R(cl,met,met2,t) STDMETHODIMP C##cl##Object::met(t *h){*h=(t)m_##cl->met2();return S_OK;}
    #define GET_DIRECT1_R(cl,met,met2,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t *h){*h=(t)m_##cl->met2(v1);return S_OK;}
    #define GET_DIRECT2_R(cl,met,met2,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t *h){*h=(t)m_##cl->met2(v1,v2);return S_OK;}
    
    
    // Return a pointer to a primitive value as a ** ptr.
    #define GET_DIRECTPTR(cl,met,t) STDMETHODIMP C##cl##Object::met(t **h){*h=(struct t*)m_##cl->met();return S_OK;}
    #define GET_DIRECTPTR1(cl,met,t,t1) STDMETHODIMP C##cl##Object::met(t1 v1,t **h){*h=(struct t*)m_##cl->met(v1);return S_OK;}
    #define GET_DIRECTPTR2(cl,met,t,t1,t2) STDMETHODIMP C##cl##Object::met(t1 v1, t2 v2, t **h){*h=(struct t*)m_##cl->met(v1,v2);return S_OK;}
    
    //Do a DO_GETOBJECT_NOTNULL and then call a method on the object
    #define DO_GETOBJECT_ANDUSEIT(cl,me,iface) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(lp); }
    
    #define DO_GETOBJECT_ANDUSEIT_CAST(cl,me,iface, t1) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me((t1)lp); }
    
    #define DO_GETOBJECT_ANDUSEIT1(cl,me,iface,t1) STDMETHODIMP C##cl##Object::me(t1 v1,I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(v1, lp); }
    
    #define DO_GETOBJECT_ANDUSEIT2(cl,me,iface,t1,t2) STDMETHODIMP C##cl##Object::me(t1 v1,t2 v2,I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->me(v1, v2, lp); }
    
    //mod:dp additions due to renaming 
    //Do a DO_GETOBJECT_NOTNULL and then call a method on the object
    #define DO_GETOBJECT_ANDUSEIT_R(cl,me, m2, iface) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(lp); }
    
    #define DO_GETOBJECT_ANDUSEIT_CAST_R(cl,me, m2, iface, t1) STDMETHODIMP C##cl##Object::me(I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2((t1)lp); }
    
    #define DO_GETOBJECT_ANDUSEIT1_R(cl,me, m2, iface,t1) STDMETHODIMP C##cl##Object::me(t1 v1,I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(v1, lp); }
    
    #define DO_GETOBJECT_ANDUSEIT2_R(cl,me, m2, iface,t1,t2) STDMETHODIMP C##cl##Object::me(t1 v1,t2 v2,I##iface *vis) \
    	{DO_GETOBJECT_NOTNULL( typedef_##iface, lp, vis); if ( m_##cl == NULL ) return E_FAIL; return m_##cl->m2(v1, v2, lp); }
    
    
    // Make a copy of an object!
    //#define CLONE(cl) STDMETHODIMP C##cl##Object::Clone(Id3drmObject **retval){typedef_##cl lp;\
    //	m_##cl->Clone(0,IID_I##cl,(void **)&lp);INTERNAL_CREATE(cl,lp,retval);return S_OK;}
    
    //#define CLONE(cl) STDMETHODIMP C##cl##Object::Clone(I##cl **retval){typedef_##cl lp;\
    //m_##cl->Clone(0,IID_I##cl,(void **)&lp);INTERNAL_CREATE(cl, lp, retval);	return S_OK;}
    
    //#define CLONE_R(cl,c2) STDMETHODIMP C##cl##Object::clone(I##cl **retval){typedef_##cl lp;\
    //m_##cl->Clone(0,IID_I##c2,(void **)&lp);INTERNAL_CREATE(cl, lp, retval);	return S_OK;}
    
    
    #define CLONE_R(cl,c2) STDMETHODIMP C##cl##Object::clone(IUnknown **retval){typedef_##cl lp;\
    m_##cl->Clone(0,IID_I##c2,(void **)&lp);INTERNAL_CREATE(cl, lp, (I##cl **)retval);	return S_OK;}
    
    
    
    #define GETNAME(cl) STDMETHODIMP C##cl##Object::GetName(BSTR *n){return _GetName(m_##cl, n, TRUE);}
    #define GETCLASSNAME(cl) STDMETHODIMP C##cl##Object::GetClassName(BSTR *n){return _GetName(m_##cl, n, FALSE);}
    
    #define SETNAME(cl) STDMETHODIMP C##cl##Object::SetName(BSTR Name){	\
    	USES_CONVERSION;\
    	LPSTR str = W2T(Name); return m_##cl->SetName( str );}
    
    #define GETNAME_R(cl) STDMETHODIMP C##cl##Object::getName(BSTR *n){return _GetName(m_##cl, n, TRUE);}
    #define GETCLASSNAME_R(cl) STDMETHODIMP C##cl##Object::getClassName(BSTR *n){return _GetName(m_##cl, n, FALSE);}
    
    #define SETNAME_R(cl) STDMETHODIMP C##cl##Object::setName(BSTR Name){	\
    	USES_CONVERSION;\
    	LPSTR str = W2T(Name); return m_##cl->SetName( str );}
    
    #define CLONETO(clMe, cl, ifaceThat) STDMETHODIMP C##clMe##Object::Get##cl(I##cl **retval) \
    { typedef_##cl lp; if (m_##clMe->QueryInterface(ifaceThat, (void **) &lp) != S_OK) return S_FALSE; \
    	INTERNAL_CREATE( cl, lp, retval); return S_OK; }
    
    
    #define ISSAFEARRAY1D(ppsa,count) ((*ppsa) &&  ( ((SAFEARRAY*)*ppsa)->cDims==1) && (((SAFEARRAY*)*ppsa)->rgsabound[0].cElements >= count))
    
    /**********************************************************************************************/
    extern "C" BOOL ParseWaveResource(void *pvRes, WAVEFORMATEX **ppWaveHeader,	BYTE **ppbWaveData, DWORD *pcbWaveSize);
    extern "C" BOOL GetWaveResource(HMODULE hModule, LPCTSTR lpName,
    			 WAVEFORMATEX **ppWaveHeader, BYTE **ppbWaveData, DWORD *pcbWaveSize);
    
    extern "C" DWORD bppToddbd(int bpp);
    
    
    extern "C" void PassBackUnicode(LPSTR str, BSTR *Name, DWORD cnt);
    extern "C" void ctojDSBufferDesc( LPDSBUFFERDESC lpdd,
    					DSBUFFERDESC_CDESC *ddsb, WAVEFORMATEX_CDESC *wave);
    extern "C" void jtocDSBufferDesc( LPDSBUFFERDESC lpdd, DSBUFFERDESC_CDESC *ddsb, WAVEFORMATEX_CDESC *wave);
    extern "C" void ctojWaveFormatEx( LPWAVEFORMATEX lpdd, WAVEFORMATEX_CDESC *wave);
    extern "C" void CopyFloats(D3DVALUE *mat1, D3DVALUE *mat2, DWORD count);
    

    
    extern "C" BOOL PASCAL myEnumSoundDriversCallback(GUID &SPGuid, LPSTR description, 
    													LPSTR module, void *lpArg);
    
    extern "C" BOOL CALLBACK myEnumDeviceObjectsCallback(  LPCDIDEVICEOBJECTINSTANCE pI,    LPVOID lpArg ) ;
    extern "C" BOOL CALLBACK myEnumCreatedEffectObjectsCallback(LPDIRECTINPUTEFFECT peff,    LPVOID lpArg );
    extern "C" BOOL CALLBACK myEnumEffectsCallback(  LPCDIEFFECTINFO pdei,    LPVOID lpArg   );
    extern "C" BOOL CALLBACK myEnumInputDevicesCallback(  LPDIDEVICEINSTANCE lpddi,    LPVOID pvRef   );
    
    //////////////////////////////////////////////////////////////////////////
    
    
    
    
    /*
     **********************************************************************
     * INTERNAL_CREATE(thisClass, var, retval)
     *		thisClass	class we are working on
     *		var			variable created in routine to get DirectX object
     *		retval		return value back to java
     *
     * wrap a DirectX object in one of ours and shove it in the return value
     ***********************************************************************
     * INTERNAL_CREATE_NOREL(thisClass, var, retval)
     *		thisClass	class we are working on
     *		var			variable created in routine to get DirectX object
     *		retval		return value back to java
     *
     * wrap a DirectX object in one of ours and shove it in the return value
     * If the layer obejct fails, DONT release the DirectX object
     ***********************************************************************
     * DO_GETOBJECT_NOTNULL(type,var,iface)
     *		type		type of variable we are creating
     *		var			variable we are creating
     *		iface		layer iface where we are getting the object from
     *
     * declare and get a DirectX object from a layer object
     ***********************************************************************
     * DO_GETOBJECT_NOTNULL(type,var,iface)
     *		type		type of variable we are creating
     *		var			variable we are creating
     *		iface		layer iface where we are getting the object from
     *
     * same as DO_GETOBJECT_NOTNULL except that we check for iface==NULL before calling
     ***********************************************************************
     * PASS_THROUGH[x](class,method,[...])
     *		class		this class
     *		method		method to call
     *
     * pass call straight through
     ***********************************************************************
     * PASS_THROUGH_CAST_[x](class,method,[...])
     *		class		this class
     *		method		method to call
     *
     * pass call straight through, casting the parameters to allow the call to pass
     ***********************************************************************
     * RETURN_NEW_ITEM(thisClass,method,OtherClass)
     *		thisClass	class being worked on
     *		method		method working on
     *		otherClass	class whose object we want
     *
     * call DirectX method to get the DirectX object, then wrap it in one of our layer
     * objects
     ***********************************************************************
     * RETURN_NEW_ITEM[1,2](thisClass,method,OtherClass,type)
     *		thisClass	class being worked on
     *		method		method working on
     *		otherClass	class whose object we want
     *		type		type of parameter
     *
     * Same as RETURN_NEWITEM except that there is an extra parameter (or two) BEFORE the
     * returned one
     ***********************************************************************
     * RETURN_NEW_ITEM_CAST_[1,2](thisClass,method,OtherClass,type)
     *		thisClass	class being worked on
     *		method		method working on
     *		otherClass	class whose object we want
     *		type		type of parameter
     *
     * Same as RETURN_NEW_ITEM[1,2] except that there the extra parameter(s) are type cast
     ******************************************************************************
     * RETURN_NEW_ITEM_NOREL(thisClass,method,OtherClass)
     *		thisClass	class being worked on
     *		method		method working on
     *		otherClass	class whose object we want
     *
     * same as RETURN_NEW_ITEM except that calls INTERNAL_CREATE_NOTREL instead of
     * INTERNAL_CREATE
     ******************************************************************************
     * GET_DIRECT(cl,met,t)
     *		class		class being worked on
     *		method		method being worked on
     *		t			type of the variable being returned
     *
     * DirectX returns value directly (no HRESULT), we get the value from Direct and
     * then return S_OK. (see CddSurfaceObject::Restore, may need to be added).
     * Note: the value is passed back via a pointer to that value.
     ******************************************************************************
     * GET_DIRECT[1,2](cl,met,t,t1)
     *		class		class being worked on
     *		method		method being worked on
     *		t			type of the variable being returned
     *      t1			type of extra variable(s) BEFORE retval
     *
     * same as GET_DIRECT but there is another parameter (or two) BEFORE the returned one
     ****************************************************************************************
     * GET_DIRECTPTR(cl,met,t)
     *		class		class being worked on
     *		method		method being worked on
     *		t			type of the variable being returned
     *
     * DirectX returns a pointer to a value directly (no HRESULT), we get the value from
     * Direct and then return S_OK. In this case it is a pointer to a pointer.
     ***************************************************************************************
     * GET_DIRECTPTR[1,2](cl,met,t,t1)
     *		class		class being worked on
     *		method		method being worked on
     *		t			type of the variable being returned
     *      t1			type of extra variable(s) BEFORE retval
     *
     * same as GET_DIRECTPTR but there is a parameter (or two) BEFORE the one returned.
     ***************************************************************************************
     * DO_GETOBJECT_ANDUSEIT(cl,me,iface)
     *		class		class being worked on
     *		method		method being worked on
     *		iface		secondary interface we are interested in
     *
     * get an internal object from iface and use it in the method. we return from the method
     ***************************************************************************************
     * DO_GETOBJECT_ANDUSEIT_CAST(cl,me,iface,type)
     *		class		class being worked on
     *		method		method being worked on
     *		iface		secondary interface we are interested in
     *		type		type to cast to in the actual call.
     * get an internal object from iface and use it in the method. we return from the method
     ***************************************************************************************
     * DO_GETOBJECT_ANDUSEIT[1,2](cl,me,iface,ty)
     *		class		class being worked on
     *		method		method being worked on
     *		iface		secondary interface we are interested in
     *		type		type of parameter BEFORE 2nd object
     *
     * same as DO_GETOBJECT_ANDUSEIT except there is another parameter (or two) BEFORE
     * the object one
     ************************************************************************************
     * CLONE(cl)
     *		class		class to clone
     *
     * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
     ************************************************************************************
     * GETNAME(cl)
     *		class		class to retive name of
     * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
     ************************************************************************************
     * GETCLASSNAME(cl)
     *		class		class to retive name of
     * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
     ************************************************************************************
     * DELETEDESTROYCALLBACK(cl)
     *		class		class to retive name of
     * >>>>>>> THIS IS A D3DRMOBJECT METHOD <<<<<<<<<<
     ************************************************************************************
     * QIOVERLOAD(cl, ifaceThat, clThat)
     *		class		class being worked on
     *		iface		iface of DIRECT object.  Should really typedef_## this!
     *		clThat		object we are going to create
     *
     * this is really bright - overloading QI to get new objects
     ************************************************************************************
     * CLONETO(cl, clThat, ifaceThat)
     *		class		class being worked on
     *		iface		iface of DIRECT object.  Should really typedef_## this!
     *		clThat		object we are going to create
     *
     * this is really bright - overloading QI to get new objects
     ************************************************************************************
     */
    
    
    extern void *g_dxj_DirectSound3dListener;
    extern void *g_dxj_DirectSoundBuffer;
    extern void *g_dxj_DirectSound3dBuffer;
    extern void *g_dxj_DirectSound;
    extern void *g_dxj_DirectSoundCapture;
    extern void *g_dxj_DirectSoundCaptureBuffer;
    extern void *g_dxj_DirectSoundNotify;

    extern void *g_dxj_DirectInput8;
    extern void *g_dxj_DirectInputDevice8;
    extern void *g_dxj_DirectInputEffect;
    
    extern void *g_dxj_DirectPlayVoiceClient;
    extern void *g_dxj_DirectPlayVoiceServer;
    extern void *g_dxj_DirectPlayVoiceSetup;
    
    #define DXHEAPALLOC malloc
    #define DXSTACKALLOC lalloc
    #define DXHEAPFREE free
    #define DXALLOCBSTR SysAllocString

    #define Byte unsigned char
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmsegmentobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicSegmentObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicSegment IDirectMusicSegment8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicSegmentObject : 
	public I_dxj_DirectMusicSegment,
	//public CComCoClass<C_dxj_DirectMusicSegmentObject, &CLSID__dxj_DirectMusicSegment>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicSegmentObject();
	virtual ~C_dxj_DirectMusicSegmentObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicSegmentObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicSegment)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicSegment,		"DIRECT.DirectMusicSegment.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicSegmentObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

        HRESULT STDMETHODCALLTYPE clone( 
            /* [in] */ long mtStart,
            /* [in] */ long mtEnd,
            /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppSegment);
        
        HRESULT STDMETHODCALLTYPE setStartPoint( 
            /* [in] */ long mtStart);
        
        HRESULT STDMETHODCALLTYPE getStartPoint( 
            /* [retval][out] */ long __RPC_FAR *pmtStart);
        
        HRESULT STDMETHODCALLTYPE setLoopPoints( 
            /* [in] */ long mtStart,
            /* [in] */ long mtEnd);
        
        HRESULT STDMETHODCALLTYPE getLoopPointStart( 
            /* [retval][out] */ long __RPC_FAR *pmtStart);
        
        HRESULT STDMETHODCALLTYPE getLoopPointEnd( 
            /* [retval][out] */ long __RPC_FAR *pmtEnd);
        
        HRESULT STDMETHODCALLTYPE getLength( 
            /* [retval][out] */ long __RPC_FAR *pmtLength);
        
        HRESULT STDMETHODCALLTYPE setLength( 
            /* [in] */ long mtLength);
        
        HRESULT STDMETHODCALLTYPE getRepeats( 
            /* [retval][out] */ long __RPC_FAR *lRepeats);
        
        HRESULT STDMETHODCALLTYPE setRepeats( 
            /* [in] */ long lRepeats);
        
        
        HRESULT STDMETHODCALLTYPE download( 
            /* [in] */ IUnknown __RPC_FAR *downloadpath);
        
        HRESULT STDMETHODCALLTYPE unload( 
            /* [in] */ IUnknown __RPC_FAR *downloadpath);
        
        
        HRESULT STDMETHODCALLTYPE setAutoDownloadEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setTempoEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setTimeSigEnable( 
            /* [in] */ VARIANT_BOOL b);
        
        HRESULT STDMETHODCALLTYPE setStandardMidiFile();
        
        HRESULT STDMETHODCALLTYPE connectToCollection( 
            /* [in] */ I_dxj_DirectMusicCollection __RPC_FAR *c);
	
        HRESULT STDMETHODCALLTYPE GetAudioPathConfig(IUnknown **ret);

		HRESULT STDMETHODCALLTYPE getStyle( 
        /* [in] */ long lTrack,
        /* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getChordMap( 
        /* [in] */ long lTrack,
        /* [in] */ long mtTime,
        /* [out][in] */ long __RPC_FAR *mtUntil,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);

    HRESULT STDMETHODCALLTYPE GetName(BSTR *ret);		
	////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicSegment);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicSegment)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmsegmentobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentobj.cpp
//
//--------------------------------------------------------------------------

// dmSegmentObj.cpp

#include "stdafx.h"
#include "Direct.h"
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "dms.h"
#include "dmSegmentObj.h"
#include "dmStyleObj.h"
#include "dmChordMapObj.h"

extern void *g_dxj_DirectMusicSegment;
extern void *g_dxj_DirectMusicStyle;
extern void *g_dxj_DirectMusicChordMap;

//CONSTRUCTOR(_dxj_DirectMusicSegment, {});

C_dxj_DirectMusicSegmentObject::C_dxj_DirectMusicSegmentObject()
{ 
     m__dxj_DirectMusicSegment = NULL;
	 parent = NULL; 
	 pinterface = NULL; 
     nextobj = (void*)g_dxj_DirectMusicSegment; 
     creationid = ++g_creationcount; 
     g_dxj_DirectMusicSegment = (void*)this; 

}

DESTRUCTOR(_dxj_DirectMusicSegment, {});
GETSET_OBJECT(_dxj_DirectMusicSegment);


HRESULT C_dxj_DirectMusicSegmentObject::clone( 
        /* [in] */ long mtStart,
        /* [in] */ long mtEnd,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ppSegment)
{
	HRESULT hr;	
	IDirectMusicSegment *pOut=NULL;    
	IDirectMusicSegment8 *pReal=NULL;    
	__try {

		if (FAILED (hr=m__dxj_DirectMusicSegment->Clone((MUSIC_TIME)mtStart,(MUSIC_TIME)mtEnd,&pOut) ) )
			return hr;

		if (!pOut)return E_OUTOFMEMORY;

		hr = pOut->QueryInterface(IID_IDirectMusicSegment8, (void**) &pReal);
		pOut->Release();
		if FAILED(hr) return hr;

		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pReal,ppSegment);
		if (!*ppSegment)return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;

}


HRESULT C_dxj_DirectMusicSegmentObject::setStartPoint(   /* [in] */ long mtStart)
{
	HRESULT hr;		

	__try {
		hr=m__dxj_DirectMusicSegment->SetStartPoint((MUSIC_TIME)mtStart);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}


HRESULT C_dxj_DirectMusicSegmentObject::getStartPoint(   /* [in] */ long *mtStart)
{
	HRESULT hr;			

	__try {
		hr=m__dxj_DirectMusicSegment->GetStartPoint((MUSIC_TIME*)mtStart);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setLoopPoints(   /* [in] */ long mtStart,   /* [in] */ long mtEnd)
{
	HRESULT hr;		
	
	__try {
		hr=m__dxj_DirectMusicSegment->SetLoopPoints((MUSIC_TIME)mtStart,(MUSIC_TIME)mtEnd);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLoopPointStart(   long *mtOut)
{
	HRESULT hr;		
	MUSIC_TIME mtStart =0;
	MUSIC_TIME mtEnd =0;	

	__try {
		hr=m__dxj_DirectMusicSegment->GetLoopPoints((MUSIC_TIME*)&mtStart,(MUSIC_TIME*)&mtEnd);
		*mtOut=(long)mtStart;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLoopPointEnd(   long *mtOut)
{
	HRESULT hr;		
	MUSIC_TIME mtStart =0;
	MUSIC_TIME mtEnd =0;	

	__try {
		hr=m__dxj_DirectMusicSegment->GetLoopPoints((MUSIC_TIME*)&mtStart,(MUSIC_TIME*)&mtEnd);
		*mtOut=(long)mtEnd;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setLength(   /* [in] */ long mtLength)
{
	HRESULT hr;			

	__try {
		hr=m__dxj_DirectMusicSegment->SetLength((MUSIC_TIME)mtLength);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getLength(   /* [in] */ long *mtLength)
{
	HRESULT hr;			

	__try {
		hr=m__dxj_DirectMusicSegment->GetLength((MUSIC_TIME*)mtLength);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}
   


HRESULT C_dxj_DirectMusicSegmentObject::setRepeats(   /* [in] */ long lrep)
{
	HRESULT hr;			
	
	__try {
		hr=m__dxj_DirectMusicSegment->SetRepeats((DWORD)lrep);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getRepeats(   /* [in] */ long *lrep)
{
	HRESULT hr;			

	__try {
		hr=m__dxj_DirectMusicSegment->GetRepeats((DWORD*)lrep);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}
     

HRESULT C_dxj_DirectMusicSegmentObject::download( 
        /* [in] */ IUnknown __RPC_FAR *downloadpath)
{
	if (!downloadpath) return E_INVALIDARG;	
	HRESULT hr;	
	
	__try {
		I_dxj_DirectMusicSegment	*lpSeg = NULL;
		I_dxj_DirectMusicAudioPath	*lpPath = NULL;

		hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicPerformance, (void**)&lpSeg);
		if (SUCCEEDED(hr) )
		{
			DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,lpSeg);
			hr=m__dxj_DirectMusicSegment->Download(pPer);
			return hr;
		}
		else
		{
			hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&lpPath);
			if (SUCCEEDED(hr) )
			{
				DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath*,pPer,lpPath);
				hr=m__dxj_DirectMusicSegment->Download(pPer);
				return hr;
			}
			else
				return E_INVALIDARG;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicSegmentObject::unload(         
        /* [in] */ IUnknown __RPC_FAR *downloadpath)
{
	if (!downloadpath) return E_INVALIDARG;	
	HRESULT hr;	
	I_dxj_DirectMusicSegment	*lpSeg = NULL;
	I_dxj_DirectMusicAudioPath	*lpPath = NULL;

	__try {
		hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicPerformance, (void**)&lpSeg);
		if (SUCCEEDED(hr) )
		{
			DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,lpSeg);
			hr=m__dxj_DirectMusicSegment->Unload(pPer);
			return hr;
		}
		else
		{
			hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&lpPath);
			if (SUCCEEDED(hr) )
			{
				DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath*,pPer,lpPath);
				hr=m__dxj_DirectMusicSegment->Unload(pPer);
				return hr;
			}
			else
				return E_INVALIDARG;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}



HRESULT C_dxj_DirectMusicSegmentObject::setAutoDownloadEnable(         
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	
	__try {
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_Disable_Auto_Download,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_Enable_Auto_Download,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
		}		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

     
HRESULT C_dxj_DirectMusicSegmentObject::setTempoEnable( 
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	DWORD trackIndex=0;

	__try {
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_DisableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_EnableTempo,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setTimeSigEnable(         
        /* [retval][out] */ VARIANT_BOOL b)
{
	HRESULT hr;	
	DWORD trackIndex=0;

	__try {
		if (b==VARIANT_FALSE){
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_DisableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}
		else {
			hr=m__dxj_DirectMusicSegment->SetParam(GUID_EnableTimeSig,0xFFFFFFFF,(DWORD)trackIndex,(MUSIC_TIME)0,NULL);	
		}		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::setStandardMidiFile()
{
	HRESULT hr;	

	__try {
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_StandardMIDIFile,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,NULL);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}
     

HRESULT C_dxj_DirectMusicSegmentObject:: connectToCollection( 
            /* [in] */ I_dxj_DirectMusicCollection __RPC_FAR *c)
{
	HRESULT hr;		

	__try {
		DO_GETOBJECT_NOTNULL(IDirectMusicCollection8*,pCol,c);
		hr=m__dxj_DirectMusicSegment->SetParam(GUID_ConnectToDLSCollection,0xFFFFFFFF,(DWORD)0,(MUSIC_TIME)0,(void*)pCol);	
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}
        

HRESULT C_dxj_DirectMusicSegmentObject:: GetAudioPathConfig(IUnknown **ret)
{
	HRESULT hr;

	__try {
		if (FAILED(hr = m__dxj_DirectMusicSegment->GetAudioPathConfig(ret) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicSegmentObject::getStyle( 
		/* [in] */ long lTrack,
		/* [retval][out] */ I_dxj_DirectMusicStyle __RPC_FAR *__RPC_FAR *ret)
{				
		HRESULT hr;	
		IDirectMusicStyle *pStyle=NULL;

	__try {
		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicSegment->GetParam( GUID_IDirectMusicStyle, 0xffffffff, (DWORD)lTrack, 
                                 0, NULL, (VOID*)&pStyle );
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicStyle,pStyle,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::getChordMap( 
		/* [in] */ long lTrack,
		/* [in] */ long mtTime,
		/* [in] */ long *mtUntil,
		/* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret)
{
		HRESULT hr;	
		IDirectMusicChordMap *pMap=NULL;

	__try {
		if (!ret) return E_INVALIDARG;
		*ret=NULL;
		
		hr=m__dxj_DirectMusicSegment->GetParam(GUID_IDirectMusicChordMap,0xFFFFFFFF,(DWORD)lTrack,(MUSIC_TIME)mtTime,(MUSIC_TIME*)mtUntil,&pMap );	
		if FAILED(hr) return hr;
				
		
		INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicChordMap,pMap,ret);
		if (*ret==NULL) return E_OUTOFMEMORY;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentObject::GetName(BSTR *ret)
{
	HRESULT					hr;	
	IDirectMusicObject8		*pObj = NULL;
	DMUS_OBJECTDESC			objDesc;

	__try {
		*ret=NULL;
		
		hr=m__dxj_DirectMusicSegment->QueryInterface(IID_IDirectMusicObject8, (void**) &pObj);	
		if FAILED(hr) return hr;

		ZeroMemory(&objDesc, sizeof(DMUS_OBJECTDESC));
		objDesc.dwSize = sizeof(DMUS_OBJECTDESC);
		pObj->GetDescriptor(&objDesc);
		if ((objDesc.dwValidData & DMUS_OBJ_NAME) == DMUS_OBJ_NAME)
		{
			//Return this name
			*ret = SysAllocString(objDesc.wszName);
		}
		else if ((objDesc.dwValidData & DMUS_OBJ_FILENAME) == DMUS_OBJ_FILENAME)
		{
			//Return this filename
			*ret = SysAllocString(objDesc.wszFileName);
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmsegmentstateobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentstateobj.cpp
//
//--------------------------------------------------------------------------

// dmPerformanceObj.cpp

#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmSegmentStateObj.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicSegmentState;
extern void *g_dxj_DirectMusicSegment;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);

CONSTRUCTOR(_dxj_DirectMusicSegmentState, {});
DESTRUCTOR(_dxj_DirectMusicSegmentState, {});
GETSET_OBJECT(_dxj_DirectMusicSegmentState);


HRESULT C_dxj_DirectMusicSegmentStateObject::getRepeats( long __RPC_FAR *repeats)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetRepeats((DWORD*)repeats);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getSeek( long __RPC_FAR *seek)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetSeek(seek);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getStartPoint( long __RPC_FAR *t)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetStartPoint(t);
	return hr;
}

HRESULT C_dxj_DirectMusicSegmentStateObject::getStartTime( long __RPC_FAR *t)
{
	HRESULT hr;		
	hr=m__dxj_DirectMusicSegmentState->GetStartTime(t);
	return hr;
}




HRESULT CREATE_DMSEGMENT_NOADDREF(IDirectMusicSegment8 *pSeg,I_dxj_DirectMusicSegment **segment) 
{
	C_dxj_DirectMusicSegmentObject *prev=NULL;
	*segment = NULL; 
	for(	
		C_dxj_DirectMusicSegmentObject 
			*ptr=(C_dxj_DirectMusicSegmentObject *)g_dxj_DirectMusicSegment;
			ptr;
			ptr=(C_dxj_DirectMusicSegmentObject *)ptr->nextobj
		)
	{
		IUnknown *unk=0;
		ptr->InternalGetObject(&unk); 
		if(unk == pSeg) 
		{ 
			*segment = (I_dxj_DirectMusicSegment*)ptr->pinterface;
			IUNK(ptr->pinterface)->AddRef();
			break;
		}
		prev = ptr;
	} 
	if(!ptr) 
	{
		C_dxj_DirectMusicSegmentObject *c=new CComObject<C_dxj_DirectMusicSegmentObject>;
		if( c == NULL ) 
		{
			pSeg->Release();
			return E_FAIL;
		}
		c->InternalSetObject(pSeg);  
		if FAILED(((I_dxj_DirectMusicSegment *)c)->QueryInterface(IID_I_dxj_DirectMusicSegment, (void **)segment)) 
		{
			return E_FAIL; 
		}
		if (!(*segment)) return E_FAIL;

		c->pinterface = (void*)*segment;
	}	
	return S_OK;
}



HRESULT C_dxj_DirectMusicSegmentStateObject::getSegment( 		
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *segment)
{
	HRESULT hr;	
	IDirectMusicSegment8 *pSeg=NULL;
	if(!segment) return E_INVALIDARG;

	hr=m__dxj_DirectMusicSegmentState->GetSegment((IDirectMusicSegment**)&pSeg);
	if FAILED(hr) return hr;	
	
		
	//INTERNAL_CREATE_NOADDREF(_dxj_DirectMusicSegment,pSeg,segment);
	hr= CREATE_DMSEGMENT_NOADDREF(pSeg,segment);
	if FAILED(hr) return hr;

	if (*segment==NULL) return E_OUTOFMEMORY;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmusaudiopathobj.h ===
#include "resource.h"       // main symbols
#include "dmusici.h"

#define typedef__dxj_DirectMusicAudioPath IDirectMusicAudioPath8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicAudioPathObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectMusicAudioPath, &IID_I_dxj_DirectMusicAudioPath, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectMusicAudioPath,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectMusicAudioPathObject() ;
	virtual ~C_dxj_DirectMusicAudioPathObject() ;

BEGIN_COM_MAP(C_dxj_DirectMusicAudioPathObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectMusicAudioPath)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectMusicAudioPathObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectMusicAudioPath
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

	HRESULT STDMETHODCALLTYPE GetObjectInPath(long lPChannel, long lStage, long lBuffer, BSTR guidObject, long lIndex, BSTR iidInterface, IUnknown **ppObject);
	HRESULT STDMETHODCALLTYPE Activate(VARIANT_BOOL fActive);
	HRESULT STDMETHODCALLTYPE SetVolume(long lVolume, long lDuration);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectMusicAudioPath);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectMusicAudioPath);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmstyleobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmstyleobj.h
//
//--------------------------------------------------------------------------

//: Declaration of the C_dxj_DirectMusicStyleObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicStyle IDirectMusicStyle8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicStyleObject : 
	public I_dxj_DirectMusicStyle,
	//public CComCoClass<C_dxj_DirectMusicStyleObject, &CLSID__dxj_DirectMusicStyle>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicStyleObject();
	virtual ~C_dxj_DirectMusicStyleObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicStyleObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicStyle)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicStyle,		"DIRECT.DirectMusicStyle.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicStyleObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

  
          
    HRESULT STDMETHODCALLTYPE getBandName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getBandCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getBand( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getDefaultBand( 
        /* [retval][out] */ I_dxj_DirectMusicBand __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getMotifName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getMotifCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getMotif( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getChordMapName( 
        /* [in] */ long index,
        /* [retval][out] */ BSTR __RPC_FAR *name);
    
    HRESULT STDMETHODCALLTYPE getChordMapCount( 
        /* [retval][out] */ long __RPC_FAR *count);
    
    HRESULT STDMETHODCALLTYPE getChordMap( 
        /* [in] */ BSTR name,
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getDefaultChordMap( 
        /* [retval][out] */ I_dxj_DirectMusicChordMap __RPC_FAR *__RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getEmbellishmentMinLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getEmbellishmentMaxLength( 
        /* [in] */ long type,
        /* [in] */ long level,
        /* [retval][out] */ long __RPC_FAR *ret);
    
    HRESULT STDMETHODCALLTYPE getTimeSignature( 
        /* [out][in] */ DMUS_TIMESIGNATURE_CDESC __RPC_FAR *pTimeSig);
    
    HRESULT STDMETHODCALLTYPE getTempo( 
        /* [retval][out] */ double __RPC_FAR *pTempo);
  

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicStyle);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicStyle)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmsegmentstateobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmsegmentstateobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicSegmentStateObject
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#include "resource.h"       // main symbols

#define typedef__dxj_DirectMusicSegmentState IDirectMusicSegmentState8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicSegmentStateObject : 
	public I_dxj_DirectMusicSegmentState,
	//public CComCoClass<C_dxj_DirectMusicSegmentStateObject, &CLSID__dxj_DirectMusicSegmentState>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicSegmentStateObject();
	virtual ~C_dxj_DirectMusicSegmentStateObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicSegmentStateObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicSegmentState)		
	END_COM_MAP()

	//DECLARE_REGISTRY(CLSID__dxj_DirectMusicSegmentState,		"DIRECT.DirectMusicSegmentState.1",			"DIRECT.Direct3dRMLight.3", IDS_D3DRMLIGHT_DESC, THREADFLAGS_BOTH)

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicSegmentStateObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

	HRESULT STDMETHODCALLTYPE getRepeats( 
		/* [retval][out] */ long __RPC_FAR *repeats);

	HRESULT STDMETHODCALLTYPE getSeek( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getStartPoint( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getStartTime( 
		/* [retval][out] */ long __RPC_FAR *seek);

	HRESULT STDMETHODCALLTYPE getSegment( 
		/* [retval][out] */ I_dxj_DirectMusicSegment __RPC_FAR *__RPC_FAR *segment);

	
////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicSegmentState);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicSegmentState)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmusbufferobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dMusBufferObj.h"					   

extern void *g_dxj_DirectMusicBuffer;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicBufferObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectMusicBuffer [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicBufferObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectMusicBuffer [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectMusicBufferObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicBufferObject::C_dxj_DirectMusicBufferObject(){ 
		
	DPF1(1,"Constructor Creation  DirectMusicBuffer Object[%d] \n ",g_creationcount);

	m__dxj_DirectMusicBuffer = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectMusicBuffer;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectMusicBuffer = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectMusicBufferObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicBufferObject::~C_dxj_DirectMusicBufferObject()
{

	DPF(1,"Entering ~C_dxj_DirectMusicBufferObject destructor \n");

     C_dxj_DirectMusicBufferObject *prev=NULL; 
	for(C_dxj_DirectMusicBufferObject *ptr=(C_dxj_DirectMusicBufferObject *)g_dxj_DirectMusicBuffer ; ptr; ptr=(C_dxj_DirectMusicBufferObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectMusicBuffer = (void*)ptr->nextobj; 
			
			DPF(1,"DirectMusicBufferObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectMusicBuffer){
		int count = IUNK(m__dxj_DirectMusicBuffer)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectMusicBuffer Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectMusicBuffer = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectMusicBufferObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectMusicBuffer;
	
	return S_OK;
}
HRESULT C_dxj_DirectMusicBufferObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectMusicBuffer=(LPDIRECTMUSICBUFFER8)pUnk;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmusaudiopathobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dMusAudioPathObj.h"					   
#include "dsound3dbuffer.h"
#include "dsoundbufferobj.h"
#include "dsoundprimarybufferobj.h"
#include "dsound3dlistener.h"
#include "dsoundFXGargleobj.h"
#include "dsoundFXEchoobj.h"
#include "dsoundFXChorusobj.h"
#include "dsoundFXCompressorobj.h"
#include "dsoundFXDistortionobj.h"
#include "dsoundFXFlangerobj.h"
#include "dsoundfxi3dl2reverbobj.h"
#if 0
#include "dsoundfxi3dl2sourceobj.h"
#include "dsoundfxsendobj.h"
#endif
#include "dsoundfxparameqobj.h"
#include "dsoundfxwavesreverbobj.h"

extern void *g_dxj_DirectSoundFXWavesReverb;
extern void *g_dxj_DirectSoundFXCompressor;
extern void *g_dxj_DirectSoundFXChorus;
extern void *g_dxj_DirectSoundFXGargle;
extern void *g_dxj_DirectSoundFXEcho;
extern void *g_dxj_DirectSoundFXSend;
extern void *g_dxj_DirectSoundFXDistortion;
extern void *g_dxj_DirectSoundFXFlanger;
extern void *g_dxj_DirectSoundFXParamEQ;
extern void *g_dxj_DirectSoundFXI3DL2Reverb;
#if 0
extern void *g_dxj_DirectSoundFXI3DL2Source;
#endif

extern HRESULT AudioBSTRtoGUID(LPGUID,BSTR);
extern void *g_dxj_DirectMusicAudioPath;
extern void *g_dxj_DirectSoundPrimaryBuffer;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicAudioPathObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectMusicAudioPath [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicAudioPathObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectMusicAudioPath [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectMusicAudioPathObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicAudioPathObject::C_dxj_DirectMusicAudioPathObject(){ 
		
	DPF1(1,"Constructor Creation  DirectMusicAudioPath Object[%d] \n ",g_creationcount);

	m__dxj_DirectMusicAudioPath = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectMusicAudioPath;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectMusicAudioPath = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectMusicAudioPathObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicAudioPathObject::~C_dxj_DirectMusicAudioPathObject()
{

	DPF(1,"Entering ~C_dxj_DirectMusicAudioPathObject destructor \n");

     C_dxj_DirectMusicAudioPathObject *prev=NULL; 
	for(C_dxj_DirectMusicAudioPathObject *ptr=(C_dxj_DirectMusicAudioPathObject *)g_dxj_DirectMusicAudioPath ; ptr; ptr=(C_dxj_DirectMusicAudioPathObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectMusicAudioPath = (void*)ptr->nextobj; 
			
			DPF(1,"DirectMusicAudioPathObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectMusicAudioPath){
		int count = IUNK(m__dxj_DirectMusicAudioPath)->Release();
		
		#ifdef DEBUG
		char AudioPath[256];
		wsprintf(AudioPath,"DirectX IDirectMusicAudioPath Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectMusicAudioPath = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectMusicAudioPathObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectMusicAudioPath;
	
	return S_OK;
}
HRESULT C_dxj_DirectMusicAudioPathObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectMusicAudioPath=(IDirectMusicAudioPath8*)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectMusicAudioPathObject::GetObjectInPath(long lPChannel, long lStage, long lBuffer, BSTR guidObject, long lIndex, BSTR iidInterface, IUnknown **ppObject)
{
	HRESULT hr;
	GUID guidObj;
	GUID guidIID;

	__try {
		if (FAILED (hr = AudioBSTRtoGUID(&guidObj, guidObject) ) )
			return hr;

		if (FAILED (hr = AudioBSTRtoGUID(&guidIID, iidInterface ) ) )
			return hr;


		if( 0==_wcsicmp(iidInterface,L"iid_idirectsound3dbuffer")){
			IDirectSound3DBuffer	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSound3dBuffer, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(iidInterface,L"iid_idirectsoundbuffer8")){
			IDirectSoundBuffer8	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundBuffer, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(iidInterface,L"iid_idirectsoundbuffer")){
			IDirectSoundBuffer	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundPrimaryBuffer, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(iidInterface,L"iid_idirectsound3dlistener")){
			IDirectSound3DListener	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSound3dListener, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_gargle")){
			IDirectSoundFXGargle	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXGargle, lpRetObj, ppObject);
		}
#if 0
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_send")){
			IDirectSoundFXSend	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXSend, lpRetObj, ppObject);
		}
#endif
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_echo")){
			IDirectSoundFXEcho	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXEcho, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_chorus")){
			IDirectSoundFXChorus	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXChorus, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_compressor")){
			IDirectSoundFXCompressor	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXCompressor, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_distortion")){
			IDirectSoundFXDistortion	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXDistortion, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_flanger")){
			IDirectSoundFXFlanger	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXFlanger, lpRetObj, ppObject);
		}
#if 0
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_i3dl2source")){
			IDirectSoundFXI3DL2Source	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXI3DL2Source, lpRetObj, ppObject);
		}
#endif
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_i3dl2reverb")){
			IDirectSoundFXI3DL2Reverb	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXI3DL2Reverb, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_standard_parameq")){
			IDirectSoundFXParamEq	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXParamEQ, lpRetObj, ppObject);
		}
		else if( 0==_wcsicmp(guidObject,L"guid_dsfx_waves_reverb")){
			IDirectSoundFXWavesReverb	*lpRetObj = NULL;

			if (FAILED ( hr= m__dxj_DirectMusicAudioPath->GetObjectInPath((DWORD) lPChannel, (DWORD) lStage, (DWORD) lBuffer, guidObj, (DWORD) lIndex, guidIID, (void**) &lpRetObj) ) )
				return hr;
			
			INTERNAL_CREATE(_dxj_DirectSoundFXWavesReverb, lpRetObj, ppObject);
		}
		else
			return E_INVALIDARG;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
HRESULT C_dxj_DirectMusicAudioPathObject::Activate(VARIANT_BOOL fActive)
{
	HRESULT hr;

	__try {
		if (FAILED (hr = m__dxj_DirectMusicAudioPath->Activate((BOOL) fActive) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicAudioPathObject::SetVolume(long lVolume, long lDuration)
{
	HRESULT hr;

	__try {
		if (FAILED (hr = m__dxj_DirectMusicAudioPath->SetVolume(lVolume, (DWORD) lDuration) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmusobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dMusObj.h"					   

extern void *g_dxj_DirectMusic;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectMusic [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectMusic [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectMusicObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicObject::C_dxj_DirectMusicObject(){ 
		
	DPF1(1,"Constructor Creation  DirectMusic Object[%d] \n ",g_creationcount);

	m__dxj_DirectMusic = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectMusic;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectMusic = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectMusicObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicObject::~C_dxj_DirectMusicObject()
{

	DPF(1,"Entering ~C_dxj_DirectMusicObject destructor \n");

     C_dxj_DirectMusicObject *prev=NULL; 
	for(C_dxj_DirectMusicObject *ptr=(C_dxj_DirectMusicObject *)g_dxj_DirectMusic ; ptr; ptr=(C_dxj_DirectMusicObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectMusic = (void*)ptr->nextobj; 
			
			DPF(1,"DirectMusicObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectMusic){
		int count = IUNK(m__dxj_DirectMusic)->Release();
		
		#ifdef DEBUG
		char Buffer[256];
		wsprintf(Buffer,"DirectX IDirectMusic Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectMusic = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectMusicObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectMusic;
	
	return S_OK;
}
HRESULT C_dxj_DirectMusicObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectMusic=(LPDIRECTMUSIC)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectMusicObject::Activate(VARIANT_BOOL fEnable)
{
	HRESULT hr;
	
	if (fEnable == VARIANT_FALSE)
	{
		if (FAILED (hr = m__dxj_DirectMusic->Activate(FALSE) ) )
			return hr;
	} else
	{
		if (FAILED (hr = m__dxj_DirectMusic->Activate(TRUE) ) )
			return hr;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicObject::SetDirectSound(I_dxj_DirectSound *DirectSound,long hWnd)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND, lpDSound, DirectSound);
	
	if (FAILED( hr = m__dxj_DirectMusic->SetDirectSound(lpDSound, (HWND)hWnd)) )
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmusbufferobj.h ===
#include "resource.h"       // main symbols
#include "dmusicc.h"

#define typedef__dxj_DirectMusicBuffer LPDIRECTMUSICBUFFER8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicBufferObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectMusicBuffer, &IID_I_dxj_DirectMusicBuffer, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectMusicBuffer,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectMusicBufferObject() ;
	virtual ~C_dxj_DirectMusicBufferObject() ;

BEGIN_COM_MAP(C_dxj_DirectMusicBufferObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectMusicBuffer)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectMusicBufferObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectMusicBuffer
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);


////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectMusicBuffer);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectMusicBuffer);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmusobj.h ===
#include "resource.h"       // main symbols
#include "dmusicc.h"

#define typedef__dxj_DirectMusic LPDIRECTMUSIC

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectMusic, &IID_I_dxj_DirectMusic, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectMusic,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectMusicObject() ;
	virtual ~C_dxj_DirectMusicObject() ;

BEGIN_COM_MAP(C_dxj_DirectMusicObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectMusic)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectMusicObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectMusic
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE Activate(VARIANT_BOOL fEnable);
		HRESULT STDMETHODCALLTYPE SetDirectSound(I_dxj_DirectSound *DirectSound,long hWnd);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectMusic);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectMusic);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmusportobj.h ===
#include "resource.h"       // main symbols
#include "dmusicc.h"

#define typedef__dxj_DirectMusicPort LPDIRECTMUSICPORT8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicPortObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectMusicPort, &IID_I_dxj_DirectMusicPort, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectMusicPort,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectMusicPortObject() ;
	virtual ~C_dxj_DirectMusicPortObject() ;

BEGIN_COM_MAP(C_dxj_DirectMusicPortObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectMusicPort)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectMusicPortObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectMusicPort
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

// Member functions

		HRESULT STDMETHODCALLTYPE PlayBuffer(I_dxj_DirectMusicBuffer *Buffer);
		HRESULT STDMETHODCALLTYPE SetReadNotificationHandle(long hEvent);
		HRESULT STDMETHODCALLTYPE Read(I_dxj_DirectMusicBuffer **Buffer);

//		[helpcontext(1)]			HRESULT DownloadInstrument(THIS_ IDirectMusicInstrument *pInstrument, 
//			                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
//			                                     DMUS_NOTERANGE *pNoteRanges,
//			                                     DWORD dwNumNoteRanges);
//		[helpcontext(1)]			HRESULT UnloadInstrument(THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument);

		HRESULT STDMETHODCALLTYPE GetLatencyClock(I_dxj_ReferenceClock **Clock);
		HRESULT STDMETHODCALLTYPE GetRunningStats(DMUS_SYNTHSTATS_CDESC *Stats);
		HRESULT STDMETHODCALLTYPE Compact();
		HRESULT STDMETHODCALLTYPE GetCaps(DMUS_PORTCAPS_CDESC *PortCaps);
		HRESULT STDMETHODCALLTYPE SetNumChannelGroups(long lChannelGroups);
		HRESULT STDMETHODCALLTYPE GetNumChannelGroups(long *ChannelGroups);
		HRESULT STDMETHODCALLTYPE Activate(VARIANT_BOOL fActive);
		HRESULT STDMETHODCALLTYPE SetChannelPriority(long lChannelGroup, long lChannel, long lPriority);
		HRESULT STDMETHODCALLTYPE GetChannelPriority(long lChannelGroup, long lChannel, long *lPriority);
		HRESULT STDMETHODCALLTYPE SetDirectSound(I_dxj_DirectSound *DirectSound, I_dxj_DirectSoundBuffer *DirectSoundBuffer);
		HRESULT STDMETHODCALLTYPE GetFormat(WAVEFORMATEX_CDESC *WaveFormatEx);
		
		// New for DMusPort8
		HRESULT STDMETHODCALLTYPE DownloadWave(I_dxj_DirectSoundWave *Wave,long lFlags,I_dxj_DirectSoundDownloadedWave **retWave);
		HRESULT STDMETHODCALLTYPE UnloadWave(I_dxj_DirectSoundDownloadedWave *Wave);
		HRESULT STDMETHODCALLTYPE AllocVoice(I_dxj_DirectSoundDownloadedWave *Wave,long lChannel,long lChannelGroup,long rtStart,long rtReadahead,I_dxj_DirectMusicVoice **Voice);
		HRESULT STDMETHODCALLTYPE AssignChannelToBuses(long lChannelGroup,long lChannel,SAFEARRAY **lBuses,long lBusCount); 
		HRESULT STDMETHODCALLTYPE SetSink(I_dxj_DirectSoundSink *Sink);
		HRESULT STDMETHODCALLTYPE GetSink(I_dxj_DirectSoundSink **Sink);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectMusicPort);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectMusicPort);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmusportobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dMusPortObj.h"					   
#include "dMusBufferObj.h"					   
#include "dsoundobj.h"
#include "dsoundbufferobj.h"
#include "dsounddownloadedwaveobj.h"
#include "dsoundsinkobj.h"

extern void *g_dxj_DirectMusicPort;
extern void *g_dxj_DirectSoundSink;
extern void *g_dxj_DirectMusicBuffer;
extern void *g_dxj_DirectSoundDownloadedWave;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicPortObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectMusicPort [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicPortObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectMusicPort [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectMusicPortObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicPortObject::C_dxj_DirectMusicPortObject(){ 
		
	DPF1(1,"Constructor Creation  DirectMusicPort Object[%d] \n ",g_creationcount);

	m__dxj_DirectMusicPort = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectMusicPort;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectMusicPort = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectMusicPortObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicPortObject::~C_dxj_DirectMusicPortObject()
{

	DPF(1,"Entering ~C_dxj_DirectMusicPortObject destructor \n");

     C_dxj_DirectMusicPortObject *prev=NULL; 
	for(C_dxj_DirectMusicPortObject *ptr=(C_dxj_DirectMusicPortObject *)g_dxj_DirectMusicPort ; ptr; ptr=(C_dxj_DirectMusicPortObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectMusicPort = (void*)ptr->nextobj; 
			
			DPF(1,"DirectMusicPortObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectMusicPort){
		int count = IUNK(m__dxj_DirectMusicPort)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectMusicPort Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectMusicPort = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectMusicPortObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectMusicPort;
	
	return S_OK;
}
HRESULT C_dxj_DirectMusicPortObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectMusicPort=(LPDIRECTMUSICPORT8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::PlayBuffer(I_dxj_DirectMusicBuffer *Buffer)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECTMUSICBUFFER, lpMusBuf, Buffer);

	if (FAILED(hr = m__dxj_DirectMusicPort->PlayBuffer(lpMusBuf) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::SetReadNotificationHandle(long hEvent)
{
	HRESULT hr;

	if (FAILED(hr = m__dxj_DirectMusicPort->SetReadNotificationHandle((HANDLE) hEvent) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::Read(I_dxj_DirectMusicBuffer **Buffer)
{
	HRESULT					hr;
	LPDIRECTMUSICBUFFER		lpBuf = NULL;

	if (FAILED(hr = m__dxj_DirectMusicPort->Read(lpBuf) ) )
		return hr;

	INTERNAL_CREATE(_dxj_DirectMusicBuffer, lpBuf, Buffer);
	return S_OK;
}

//		[helpcontext(1)]			HRESULT DownloadInstrument(THIS_ IDirectMusicInstrument *pInstrument, 
//			                                     IDirectMusicDownloadedInstrument **ppDownloadedInstrument,
//			                                     DMUS_NOTERANGE *pNoteRanges,
//			                                     DWORD dwNumNoteRanges);
//		[helpcontext(1)]			HRESULT UnloadInstrument(THIS_ IDirectMusicDownloadedInstrument *pDownloadedInstrument);

HRESULT C_dxj_DirectMusicPortObject::GetLatencyClock(I_dxj_ReferenceClock **Clock)
{
	HRESULT hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetRunningStats(DMUS_SYNTHSTATS_CDESC *Stats)
{
	HRESULT hr;

	if (FAILED(hr = m__dxj_DirectMusicPort->GetRunningStats((DMUS_SYNTHSTATS*)Stats) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::Compact()
{
	HRESULT hr;

	if (FAILED (hr = m__dxj_DirectMusicPort->Compact() ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetCaps(DMUS_PORTCAPS_CDESC *PortCaps)
{
	HRESULT hr;

	if (FAILED (hr = m__dxj_DirectMusicPort->GetCaps((DMUS_PORTCAPS*)PortCaps) ))
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::SetNumChannelGroups(long lChannelGroups)
{
	HRESULT hr;
	
	if (FAILED (hr = m__dxj_DirectMusicPort->SetNumChannelGroups((DWORD) lChannelGroups) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetNumChannelGroups(long *ChannelGroups)
{
	HRESULT hr;

	if (FAILED (hr = m__dxj_DirectMusicPort->GetNumChannelGroups((DWORD*) ChannelGroups) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::Activate(VARIANT_BOOL fActive)
{
	HRESULT hr;

	if (fActive == VARIANT_FALSE)
	{
		if (FAILED (hr = m__dxj_DirectMusicPort->Activate(FALSE) ) )
			return hr;
	} else
	{
		if (FAILED (hr = m__dxj_DirectMusicPort->Activate(TRUE) ) )
			return hr;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::SetChannelPriority(long lChannelGroup, long lChannel, long lPriority)
{
	HRESULT hr;
	
	if (FAILED (hr = m__dxj_DirectMusicPort->SetChannelPriority((DWORD) lChannelGroup, (DWORD) lChannel, (DWORD) lPriority) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetChannelPriority(long lChannelGroup, long lChannel, long *lPriority)
{
	HRESULT hr;

	if (FAILED (hr = m__dxj_DirectMusicPort->GetChannelPriority((DWORD) lChannelGroup, (DWORD) lChannel, (DWORD*) lPriority) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::SetDirectSound(I_dxj_DirectSound *DirectSound, I_dxj_DirectSoundBuffer *DirectSoundBuffer)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUND, lpDSound, DirectSound);
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDBUFFER, lpDSoundBuf, DirectSoundBuffer);

	if (FAILED ( hr = m__dxj_DirectMusicPort->SetDirectSound(lpDSound, lpDSoundBuf) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetFormat(WAVEFORMATEX_CDESC *WaveFormatEx)
{
	HRESULT hr;

	return S_OK;
}

		
// New for DMusPort8
HRESULT C_dxj_DirectMusicPortObject::DownloadWave(I_dxj_DirectSoundWave *Wave,long lFlags,I_dxj_DirectSoundDownloadedWave **retWave)
{
	HRESULT hr;
	LPDIRECTSOUNDDOWNLOADEDWAVE	lpDWave = NULL;
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDWAVE, lpWave, Wave);

	if (FAILED (hr = m__dxj_DirectMusicPort->DownloadWave(lpWave, (DWORD) lFlags, &lpDWave) ) )
		return hr;

	INTERNAL_CREATE(_dxj_DirectSoundDownloadedWave, lpDWave, retWave);

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::UnloadWave(I_dxj_DirectSoundDownloadedWave *Wave)
{
	HRESULT hr;
	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDDOWNLOADEDWAVE, lpWave, Wave);

	if (FAILED (hr = m__dxj_DirectMusicPort->UnloadWave(lpWave) ) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::AllocVoice(I_dxj_DirectSoundDownloadedWave *Wave,long lChannel,long lChannelGroup,long rtStart,long rtReadahead,I_dxj_DirectMusicVoice **Voice)
{
	HRESULT hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::AssignChannelToBuses(long lChannelGroup,long lChannel,SAFEARRAY **lBuses,long lBusCount)
{
	HRESULT hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::SetSink(I_dxj_DirectSoundSink *Sink)
{
	HRESULT hr;

	DO_GETOBJECT_NOTNULL(LPDIRECTSOUNDSINK8, lpSink, Sink);

	if (FAILED (hr = m__dxj_DirectMusicPort->SetSink(lpSink) ) )
		return hr;


	return S_OK;
}

HRESULT C_dxj_DirectMusicPortObject::GetSink(I_dxj_DirectSoundSink **Sink)
{
	HRESULT hr;
	LPDIRECTSOUNDSINK8 lpSink = NULL;

	if (FAILED (hr = m__dxj_DirectMusicPort->GetSink(&lpSink) ) )
		return hr;

	INTERNAL_CREATE(_dxj_DirectSoundSink, lpSink, Sink);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmusvoiceobj.h ===
#include "resource.h"       // main symbols
#include "dmusicc.h"

#define typedef__dxj_DirectMusicVoice LPDIRECTMUSICVOICE8

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicVoiceObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectMusicVoice, &IID_I_dxj_DirectMusicVoice, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectMusicVoice,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectMusicVoiceObject() ;
	virtual ~C_dxj_DirectMusicVoiceObject() ;

BEGIN_COM_MAP(C_dxj_DirectMusicVoiceObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectMusicVoice)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectMusicVoiceObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectMusicVoice
public:
		 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE Play(REFERENCE_TIME rtStart,long lPitch,long lVolume);
		HRESULT STDMETHODCALLTYPE Stop(REFERENCE_TIME rtStop);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectMusicVoice);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectMusicVoice);

	DWORD InternalAddRef();
	DWORD InternalRelease();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmussongobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dmussongobj.cpp
//
//--------------------------------------------------------------------------


#include "dmusici.h"

#include "stdafx.h"
#include "Direct.h"

#include "dms.h"
#include "dmusSongObj.h"
#include "dmSegmentObj.h"

extern void *g_dxj_DirectMusicSong;
extern void *g_dxj_DirectMusicSegment;

extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

CONSTRUCTOR(_dxj_DirectMusicSong, {});
DESTRUCTOR(_dxj_DirectMusicSong, {});
GETSET_OBJECT(_dxj_DirectMusicSong);

HRESULT C_dxj_DirectMusicSongObject::Compose()
{
	HRESULT hr;

	__try {
		if (FAILED (hr = m__dxj_DirectMusicSong->Compose() ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicSongObject::GetSegment(BSTR Name, I_dxj_DirectMusicSegment **ret)
{
    WCHAR wszSegName[MAX_PATH];
	HRESULT hr;
	IDirectMusicSegment		*lpOldSeg = NULL;
	IDirectMusicSegment8	*lpSeg = NULL;

	__try {
		if (!IsEmptyString(Name))
		{
			wcscpy(wszSegName, Name);	

			if (FAILED( hr = m__dxj_DirectMusicSong->GetSegment(wszSegName, &lpOldSeg) ) )
				return hr;
		}
		else
		{
			if (FAILED( hr = m__dxj_DirectMusicSong->GetSegment(NULL, &lpOldSeg) ) )
				return hr;
		}

		hr = lpOldSeg->QueryInterface(IID_IDirectMusicSegment8, (void**) &lpSeg);
		lpOldSeg->Release();
		if (FAILED(hr))
			return hr;

		INTERNAL_CREATE(_dxj_DirectMusicSegment, lpSeg, ret)
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicSongObject::GetAudioPathConfig(IUnknown **ret)
{
	HRESULT hr;

	__try {
		if (FAILED(hr = m__dxj_DirectMusicSong->GetAudioPathConfig(ret) ))
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectMusicSongObject::Download(IUnknown *downloadpath)
{
	if (!downloadpath) return E_INVALIDARG;	
	HRESULT hr;	
	I_dxj_DirectMusicSegment	*lpSeg = NULL;
	I_dxj_DirectMusicAudioPath	*lpPath = NULL;

	__try {
		hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicSegment, (void**)&lpSeg);
		if (SUCCEEDED(hr) )
		{
			DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,lpSeg);
			hr=m__dxj_DirectMusicSong->Download(pPer);
			return hr;
		}
		else
		{
			hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&lpPath);
			if (SUCCEEDED(hr) )
			{
				DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath*,pPer,lpPath);
				hr=m__dxj_DirectMusicSong->Download(pPer);
				return hr;
			}
			else
				return E_INVALIDARG;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicSongObject::Unload(IUnknown *downloadpath)
{
	if (!downloadpath) return E_INVALIDARG;	
	HRESULT hr;	
	I_dxj_DirectMusicSegment	*lpSeg = NULL;
	I_dxj_DirectMusicAudioPath	*lpPath = NULL;

	__try {
		hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicSegment, (void**)&lpSeg);
		if (SUCCEEDED(hr) )
		{
			DO_GETOBJECT_NOTNULL(IDirectMusicPerformance8*,pPer,lpSeg);
			hr=m__dxj_DirectMusicSong->Unload(pPer);
			return hr;
		}
		else
		{
			hr = downloadpath->QueryInterface(IID_I_dxj_DirectMusicAudioPath, (void**)&lpPath);
			if (SUCCEEDED(hr) )
			{
				DO_GETOBJECT_NOTNULL(IDirectMusicAudioPath*,pPer,lpPath);
				hr=m__dxj_DirectMusicSong->Unload(pPer);
				return hr;
			}
			else
				return E_INVALIDARG;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectMusicSongObject::EnumSegment(long lSegmentID, [out,retval] I_dxj_DirectMusicSegment **ret)
{
	HRESULT hr;
	IDirectMusicSegment		*lpOldSeg = NULL;
	IDirectMusicSegment8	*lpSeg = NULL;

	__try {
		if (FAILED( hr = m__dxj_DirectMusicSong->EnumSegment((DWORD) lSegmentID, &lpOldSeg) ) )
		hr = lpOldSeg->QueryInterface(IID_IDirectMusicSegment8, (void**) &lpSeg);
		lpOldSeg->Release();
		if (FAILED(hr))
			return hr;

		INTERNAL_CREATE(_dxj_DirectMusicSegment, lpSeg, ret)
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmussongobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dmSongobj.h
//
//--------------------------------------------------------------------------

// d3drmLightObj.h : Declaration of the C_dxj_DirectMusicSongObject

#include "resource.h"       // main symbols
#include "dmusici.h"
#include "dmusicc.h"
#include "dmusicf.h"

#define typedef__dxj_DirectMusicSong IDirectMusicSong8*

/////////////////////////////////////////////////////////////////////////////
// Direct

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectMusicSongObject : 
	public I_dxj_DirectMusicSong,
	//public CComCoClass<C_dxj_DirectMusicSongObject, &CLSID__dxj_DirectMusicSong>,
	public CComObjectRoot
{
public:
	C_dxj_DirectMusicSongObject();
	virtual ~C_dxj_DirectMusicSongObject();

	BEGIN_COM_MAP(C_dxj_DirectMusicSongObject)
		COM_INTERFACE_ENTRY(I_dxj_DirectMusicSong)		
	END_COM_MAP()

	DECLARE_AGGREGATABLE(C_dxj_DirectMusicSongObject)


public:
	STDMETHOD(InternalSetObject)(IUnknown *lpdd);
	STDMETHOD(InternalGetObject)(IUnknown **lpdd);

		HRESULT STDMETHODCALLTYPE Compose();
		HRESULT STDMETHODCALLTYPE GetSegment(BSTR Name, I_dxj_DirectMusicSegment **ret);
		//HRESULT STDMETHODCALLTYPE Clone(I_dxj_DirectMusicSong **ret);
		HRESULT STDMETHODCALLTYPE GetAudioPathConfig(IUnknown **ret);
		HRESULT STDMETHODCALLTYPE Download(IUnknown *downloadpath);
		HRESULT STDMETHODCALLTYPE Unload(IUnknown *downloadpath);
		HRESULT STDMETHODCALLTYPE EnumSegment(long lSegmentID, I_dxj_DirectMusicSegment **ret);
    

////////////////////////////////////////////////////////////////////////////////////
//
private:
    DECL_VARIABLE(_dxj_DirectMusicSong);

public:
	DX3J_GLOBAL_LINKS( _dxj_DirectMusicSong)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayaddressobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPlayAddressObj.h"					   

extern void *g_dxj_DirectPlayAddress;
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayAddress SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayAddressObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"------ DXVB: DirectPlayAddress8 [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayAddressObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"------ DXVB: DirectPlayAddress8 [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayAddressObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayAddressObject::C_dxj_DirectPlayAddressObject(){ 
		
	DPF1(1,"------ DXVB: Constructor Creation  DirectPlayAddress8 Object[%d] \n ",g_creationcount);

	m__dxj_DirectPlayAddress = NULL;

	m_pUserData = NULL;
	m_dwUserDataSize = 0;
	g_dxj_DirectPlayAddress = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayAddressObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayAddressObject::~C_dxj_DirectPlayAddressObject()
{

	DPF(1,"Entering ~C_dxj_DirectPlayAddressObject destructor \n");

	__try {
		SAFE_RELEASE(m__dxj_DirectPlayAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		m__dxj_DirectPlayAddress = NULL;
	}

	SAFE_DELETE(m_pUserData);
}

HRESULT C_dxj_DirectPlayAddressObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayAddress;
	
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayAddress=(IDirectPlay8Address*)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::BuildFromURL(BSTR SourceURL)
{
	HRESULT hr;

	__try {
		if (FAILED(hr = m__dxj_DirectPlayAddress->BuildFromURLW(SourceURL) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::Duplicate(I_dxj_DirectPlayAddress **NewAddress)
{
	HRESULT hr;
	IDirectPlay8Address		*lpDup = NULL;

	__try {
		if (FAILED (hr = m__dxj_DirectPlayAddress->Duplicate(&lpDup) ) )
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress, lpDup, NewAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::Clear()
{
	HRESULT hr;

	__try {
		if (FAILED ( hr = m__dxj_DirectPlayAddress->Clear() ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetURL(BSTR *URL)
{
	HRESULT hr;
	WCHAR	wszUrl[MAX_PATH];
	DWORD	dwNumChars = 0;
	
	__try {
		hr = m__dxj_DirectPlayAddress->GetURLW(NULL, &dwNumChars);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		if (FAILED (hr = m__dxj_DirectPlayAddress->GetURLW(&wszUrl[0],&dwNumChars) ) )
			return hr;

		*URL = SysAllocString(&wszUrl[0]);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetSP(BSTR *guidSP)
{
	HRESULT hr;
	GUID	guidDev;
	
	__try {
		if (FAILED (hr = m__dxj_DirectPlayAddress->GetSP(&guidDev ) ) )
			return hr;

		GUID* pGuid = new GUID; 
		if (!pGuid)
			return E_OUTOFMEMORY;

		memcpy( pGuid, &guidDev, sizeof(GUID) );
		*guidSP = GUIDtoBSTR(pGuid);
		SAFE_DELETE(pGuid);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetUserData(void *UserData, long *lBufferSize)
{
	__try {
		DPF(1,"-----Entering (DplayAddress) GetUserData call...\n");
		//Copy the memory over to our new variable
		memcpy(UserData,m_pUserData,m_dwUserDataSize);
		lBufferSize = (long*)&m_dwUserDataSize;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::SetSP(BSTR guidSP)
{
	HRESULT hr;
	GUID	guidDev;

	__try {
		if (guidSP)
		{
			if (FAILED( hr = DPLAYBSTRtoGUID(&guidDev, guidSP) ) )
				return hr;
		}
		else
			return E_INVALIDARG;

		if (FAILED ( hr = m__dxj_DirectPlayAddress->SetSP(&guidDev) ))
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::SetUserData(void *UserData, long lDataSize)
{
	__try {
		DPF(1,"-----Entering (DplayAddress) SetUserData call...\n");
		if (m_pUserData)
			SAFE_DELETE(m_pUserData);

		m_pUserData = (void*)new BYTE[lDataSize];
		if (!m_pUserData)
			return E_OUTOFMEMORY;

		memcpy((void*) m_pUserData, (void*)UserData, lDataSize);
		m_dwUserDataSize = (DWORD)lDataSize;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetNumComponents(long *lNumComponents)
{
	HRESULT hr;

	__try {
		if (FAILED (hr = m__dxj_DirectPlayAddress->GetNumComponents((DWORD*) lNumComponents) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetDevice(BSTR *guidDevice)
{
	HRESULT hr;
	GUID	guidDev;
	
	__try {
		if (FAILED (hr = m__dxj_DirectPlayAddress->GetDevice(&guidDev ) ) )
			return hr;

		GUID* pGuid = new GUID; 
		if (!pGuid)
			return E_OUTOFMEMORY;

		memcpy( pGuid, &guidDev, sizeof(GUID) );
		*guidDevice = GUIDtoBSTR(pGuid);
		SAFE_DELETE(pGuid);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::SetDevice(BSTR guidDevice)
{
	HRESULT hr;
	GUID	guidDev;

	__try {
		if (guidDevice)
		{
			if (FAILED( hr = DPLAYBSTRtoGUID(&guidDev, guidDevice) ) )
				return hr;
		}
		else
			return E_INVALIDARG;

		if (FAILED ( hr = m__dxj_DirectPlayAddress->SetDevice(&guidDev) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::SetEqual(I_dxj_DirectPlayAddress *Address)
{
	HRESULT hr;

	__try {
		DO_GETOBJECT_NOTNULL( IDirectPlay8Address*, lpAddress, Address);

		if (FAILED (hr = m__dxj_DirectPlayAddress->SetEqual( lpAddress) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::AddComponentLong(BSTR sComponent, long lValue)
{
	HRESULT hr;
    WCHAR wszComponent[MAX_PATH];

	__try {
		if (!IsEmptyString(sComponent)) wcscpy(wszComponent, sComponent);	

		if (FAILED (hr = m__dxj_DirectPlayAddress->AddComponent(wszComponent, (DWORD*) &lValue, sizeof(DWORD), DPNA_DATATYPE_DWORD ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayAddressObject::AddComponentString(BSTR sComponent, BSTR sValue)
{
	HRESULT hr;
    WCHAR wszComponent[MAX_PATH];
    WCHAR wszValue[MAX_PATH];

	__try {
		if (!IsEmptyString(sComponent)) wcscpy(wszComponent, sComponent);	
		if (!IsEmptyString(sValue)) wcscpy(wszValue, sValue);	

		if (FAILED (hr = m__dxj_DirectPlayAddress->AddComponent(wszComponent, (WCHAR*) &wszValue, (((DWORD*)sValue)[-1]) + sizeof(WCHAR), DPNA_DATATYPE_STRING ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetComponentLong(BSTR sComponent, long *lValue)
{
	HRESULT hr;
    WCHAR wszComponent[MAX_PATH];
    DWORD dwSize = 0;
	DWORD dwDataType = DPNA_DATATYPE_DWORD;
	DWORD dwData = 0;
	
	__try {
		if (!IsEmptyString(sComponent))
		{
			wcscpy(wszComponent, sComponent);	
		}
		else
			return E_INVALIDARG;

		hr = m__dxj_DirectPlayAddress->GetComponentByName(wszComponent, NULL, &dwSize, &dwDataType);
		if (FAILED(hr) && (hr != DPNERR_BUFFERTOOSMALL))	
			return hr;

		if (FAILED (hr = m__dxj_DirectPlayAddress->GetComponentByName(wszComponent, &dwData, &dwSize, &dwDataType) ) )
			return hr;

		*lValue = dwData;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayAddressObject::GetComponentString(BSTR sComponent, BSTR *sValue)
{
	HRESULT hr;
    WCHAR wszComponent[MAX_PATH];
    DWORD dwSize = 0;
	DWORD dwDataType = DPNA_DATATYPE_STRING;
	WCHAR *wszRet = NULL;
	
	__try {
		if (!IsEmptyString(sComponent))
		{
			wcscpy(wszComponent, sComponent);	
		}
		else
			return E_INVALIDARG;

		hr = m__dxj_DirectPlayAddress->GetComponentByName(wszComponent, NULL, &dwSize, &dwDataType);
		if (FAILED(hr) && (hr != DPNERR_BUFFERTOOSMALL))	
			return hr;

		wszRet = (WCHAR*)new BYTE[dwSize];
		if (!wszRet)
			return E_OUTOFMEMORY;

		hr = m__dxj_DirectPlayAddress->GetComponentByName(wszComponent, wszRet, &dwSize, &dwDataType);
		if (FAILED(hr))	
			return hr;

		*sValue = SysAllocString(wszRet);
		SAFE_DELETE(wszRet);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayaddressobj.h ===
#include "resource.h"       // main symbols
#include "dpaddr.h"

#define typedef__dxj_DirectPlayAddress IDirectPlay8Address*

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayAddressObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayAddress, &IID_I_dxj_DirectPlayAddress, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayAddress,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayAddressObject() ;
	virtual ~C_dxj_DirectPlayAddressObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayAddressObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayAddress)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayAddressObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayAddress
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE BuildFromURL(BSTR SourceURL);
		HRESULT STDMETHODCALLTYPE Duplicate(I_dxj_DirectPlayAddress **NewAddress);
		HRESULT STDMETHODCALLTYPE Clear();
		HRESULT STDMETHODCALLTYPE GetURL(BSTR *URL);
		HRESULT STDMETHODCALLTYPE GetSP(BSTR *guidSP);
		HRESULT STDMETHODCALLTYPE GetUserData(void *UserData, long *lBufferSize);
		HRESULT STDMETHODCALLTYPE SetSP(BSTR guidSP);
		HRESULT STDMETHODCALLTYPE SetUserData(void *UserData, long lDataSize);
		HRESULT STDMETHODCALLTYPE GetNumComponents(long *lNumComponents);
		HRESULT STDMETHODCALLTYPE GetDevice(BSTR *guidDevice);
		HRESULT STDMETHODCALLTYPE SetDevice(BSTR guidDevice);
		HRESULT STDMETHODCALLTYPE SetEqual(I_dxj_DirectPlayAddress *Address);
		HRESULT STDMETHODCALLTYPE AddComponentLong(BSTR sComponent, long lValue);
		HRESULT STDMETHODCALLTYPE AddComponentString(BSTR sComponent, BSTR sValue);
		HRESULT STDMETHODCALLTYPE GetComponentLong(BSTR sComponent, long *lValue);
		HRESULT STDMETHODCALLTYPE GetComponentString(BSTR sComponent, BSTR *sValue);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayAddress);

private:

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayAddress);

	DWORD InternalAddRef();
	DWORD InternalRelease();
	void	*m_pUserData;
	DWORD	m_dwUserDataSize;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dmusvoiceobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dMusVoiceObj.h"					   

extern void *g_dxj_DirectMusicVoice;

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicVoiceObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF2(1,"DirectMusicVoice [%d] AddRef %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectMusicVoiceObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF2(1,"DirectMusicVoice [%d] Release %d \n",creationid,i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectMusicVoiceObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicVoiceObject::C_dxj_DirectMusicVoiceObject(){ 
		
	DPF1(1,"Constructor Creation  DirectMusicVoice Object[%d] \n ",g_creationcount);

	m__dxj_DirectMusicVoice = NULL;
	parent = NULL;
	pinterface = NULL; 
	nextobj =  g_dxj_DirectMusicVoice;
	creationid = ++g_creationcount;
	 	
	g_dxj_DirectMusicVoice = (void *)this; 
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectMusicVoiceObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectMusicVoiceObject::~C_dxj_DirectMusicVoiceObject()
{

	DPF(1,"Entering ~C_dxj_DirectMusicVoiceObject destructor \n");

     C_dxj_DirectMusicVoiceObject *prev=NULL; 
	for(C_dxj_DirectMusicVoiceObject *ptr=(C_dxj_DirectMusicVoiceObject *)g_dxj_DirectMusicVoice ; ptr; ptr=(C_dxj_DirectMusicVoiceObject *)ptr->nextobj) 
	{
		if(ptr == this) 
		{ 
			if(prev) 
				prev->nextobj = ptr->nextobj; 
			else 
				g_dxj_DirectMusicVoice = (void*)ptr->nextobj; 
			
			DPF(1,"DirectMusicVoiceObject found in g_dxj list now removed\n");

			break; 
		} 
		prev = ptr; 
	} 
	if(m__dxj_DirectMusicVoice){
		int count = IUNK(m__dxj_DirectMusicVoice)->Release();
		
		#ifdef DEBUG
		char buffer[256];
		wsprintf(buffer,"DirectX IDirectMusicVoice Ref count [%d] \n",count);
		#endif

		if(count==0)	m__dxj_DirectMusicVoice = NULL;
		
	} 

	if(parent) IUNK(parent)->Release();

}

HRESULT C_dxj_DirectMusicVoiceObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectMusicVoice;
	
	return S_OK;
}
HRESULT C_dxj_DirectMusicVoiceObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectMusicVoice=(LPDIRECTMUSICVOICE8)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectMusicVoiceObject::Play(REFERENCE_TIME rtStart,long lPitch,long lVolume)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectMusicVoice->Play(rtStart, (DWORD)lPitch, (DWORD)lVolume )) )
		return hr;

	return S_OK;
}

HRESULT C_dxj_DirectMusicVoiceObject::Stop(REFERENCE_TIME rtStop)
{
	HRESULT hr;

	if (FAILED( hr = m__dxj_DirectMusicVoice->Stop(rtStop) ))
		return hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplaybufhelp.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:       DplayBufHelp.cpp
//  Content:    Helper functions for DPlay Buffers (Byte arrays)
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Direct.h"

#define SAFE_FREE(p)       { if(p) { free (p); p=NULL; } }
#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }

#define INITIAL_BUFFER_SIZE 20

HRESULT WINAPI VB_GrowBuffer(SAFEARRAY **Buffer, DWORD dwGrowSize);
HRESULT WINAPI VB_NewBuffer(SAFEARRAY **Buffer, long *lOffSet);
HRESULT WINAPI VB_AddDataToBuffer(SAFEARRAY **Buffer, void *lData, DWORD lSize, long *lOffSet);
HRESULT WINAPI VB_AddStringToBuffer(SAFEARRAY **Buffer, BSTR StringData, long *lOffSet);
HRESULT WINAPI VB_GetDataFromBuffer(SAFEARRAY **Buffer, void *lData, DWORD lSize, long *lOffSet);
HRESULT WINAPI VB_GetStringFromBuffer(SAFEARRAY **Buffer, long *lOffSet, BSTR *sData);

// Functions for writing a buffer
HRESULT WINAPI VB_AddStringToBuffer(SAFEARRAY **Buffer, BSTR StringData, long *lOffSet)
{
	HRESULT hr;
	// For strings we will first write out a DWORD 
	// containging the length of the string.  Then we
	// will write the actual data to the string.

	DWORD dwStrLen= (((DWORD*)StringData)[-1]);
	DWORD dwDataSize = sizeof(DWORD) + dwStrLen;
	
	if (!StringData)
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer))
	{
		// We need to create this buffer, it doesn't exist
		SAFEARRAY					*lpData = NULL;
		SAFEARRAYBOUND				rgsabound[1];

		// Let's create our SafeArray
		rgsabound[0].lLbound = 0; // A single dimension array that is zero based
		rgsabound[0].cElements = dwDataSize; //Set the initial size
		// Create this data
		lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (!lpData)
			return E_OUTOFMEMORY;

		(SAFEARRAY*)*Buffer = lpData;
	}

	if (!((SAFEARRAY*)*Buffer)->pvData)
		return E_INVALIDARG;

	// Do we have enough memory for this string right now?
	if (*lOffSet + dwDataSize > ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements)
		if (FAILED( hr = VB_GrowBuffer(Buffer, dwDataSize) ) )
			return hr;

	// Ok, now we' ve got our memory, copy it over
	// First the length
	BYTE  *lPtr = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;
	__try {

		memcpy(lPtr + *lOffSet, &dwStrLen, sizeof(DWORD));
		*lOffSet += sizeof(DWORD);
		// Now the actual string
		memcpy(lPtr + *lOffSet, StringData, dwStrLen);
		*lOffSet += dwStrLen;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_INVALIDARG;
	}

	return S_OK;

}

HRESULT WINAPI VB_AddDataToBuffer(SAFEARRAY **Buffer, void *lData, DWORD lSize, long *lOffSet)
{
	HRESULT hr;
	
	if (!lData)
		return E_INVALIDARG;

	if (!lSize)
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer))
	{
		// We need to create this buffer, it doesn't exist
		SAFEARRAY					*lpData = NULL;
		SAFEARRAYBOUND				rgsabound[1];

		// Let's create our SafeArray
		rgsabound[0].lLbound = 0; // A single dimension array that is zero based
		rgsabound[0].cElements = lSize; //Set the initial size
		// Create this data
		lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (!lpData)
			return E_OUTOFMEMORY;

		(SAFEARRAY*)*Buffer = lpData;
	}

	if (!((SAFEARRAY*)*Buffer)->pvData)
		return E_INVALIDARG;

	// Do we have enough memory for this string right now?
	if (*lOffSet + lSize > ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements)
		if (FAILED( hr = VB_GrowBuffer(Buffer, lSize) ) )
			return hr;

	BYTE  *lPtr = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

	__try {
		memcpy(lPtr + *lOffSet, lData, lSize);
		*lOffSet += lSize;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_INVALIDARG;
	}
	return S_OK;
}

HRESULT WINAPI VB_NewBuffer(SAFEARRAY **Buffer, long *lOffSet)
{
	// Set up with a 20 byte msg at first
	SAFEARRAY					*lpData = NULL;
	SAFEARRAYBOUND				rgsabound[1];

	// Let's create our SafeArray
	rgsabound[0].lLbound = 0; // A single dimension array that is zero based
	rgsabound[0].cElements = INITIAL_BUFFER_SIZE; //Set the initial size
	// Create this data
	lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

	if (!lpData)
		return E_OUTOFMEMORY;

	(SAFEARRAY*)*Buffer = lpData;

	*lOffSet = 0;
	return S_OK;
}

HRESULT WINAPI VB_GrowBuffer(SAFEARRAY **Buffer, DWORD dwGrowSize)
{
	SAFEARRAY					*lpData = NULL;
	SAFEARRAYBOUND				rgsabound[1];
	DWORD						dwCurSize = 0;

	if (!dwGrowSize)
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer))
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer)->pvData)
		return E_INVALIDARG;

	dwCurSize = ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements;

	// Let's create a new SafeArray
	rgsabound[0].lLbound = 0; // A single dimension array that is zero based
	rgsabound[0].cElements = dwCurSize + dwGrowSize; //Set the size
	// Create this data
	lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

	if (!lpData)
		return E_OUTOFMEMORY;

	__try {
		memcpy(lpData->pvData, ((SAFEARRAY*)*Buffer)->pvData, dwCurSize);
		SafeArrayDestroy((SAFEARRAY*)*Buffer);

		(SAFEARRAY*)*Buffer = lpData;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT WINAPI VB_GetDataFromBuffer(SAFEARRAY **Buffer, void *lData, DWORD lSize, long *lOffSet)
{
	// Simply copy the memory from the offset to the new data

	if (!lData)
		return E_INVALIDARG;

	if (!lSize)
		return E_INVALIDARG;

	if (!(SAFEARRAY*)*Buffer)
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer)->pvData)
		return E_INVALIDARG;

	if (*lOffSet + lSize > ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements)
		return E_INVALIDARG;

	BYTE  *lPtr = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

	__try {
		memcpy(lData, lPtr + *lOffSet, lSize);
		*lOffSet += lSize;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_INVALIDARG;
	}

	return S_OK;
}

HRESULT WINAPI VB_GetStringFromBuffer(SAFEARRAY **Buffer, long *lOffSet, BSTR *sData)
{
	DWORD		dwStrLen = 0;
	WCHAR		*sNewString = NULL;

	// Simply copy the memory from the offset to the new data
	if (!(SAFEARRAY*)*Buffer)
		return E_INVALIDARG;

	if (!((SAFEARRAY*)*Buffer)->pvData)
		return E_INVALIDARG;

	if (*lOffSet + sizeof(DWORD) > ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements)
		return E_INVALIDARG;

	BYTE  *lPtr = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

	__try {
		// First read the size of the string
		dwStrLen = *(DWORD*)(lPtr + *lOffSet);
		*lOffSet += sizeof(DWORD);

		if (*lOffSet + dwStrLen  > ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements)
			return E_INVALIDARG;

		sNewString = (WCHAR*)new BYTE[dwStrLen+2];
		if (!sNewString)
			return E_OUTOFMEMORY;

		ZeroMemory(sNewString, dwStrLen+2);
		memcpy(sNewString, lPtr + *lOffSet, dwStrLen);
		*sData = SysAllocString(sNewString);

		*lOffSet += (dwStrLen);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_INVALIDARG;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayclientobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPlayClientObj.h"					   
#include "DPlayAddressObj.h"

extern void *g_dxj_DirectPlayAddress;
extern void *g_dxj_DirectPlayClient;
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayClient SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

DWORD WINAPI CloseClientThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayClientObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"----- DXVB: DirectPlayClient8 AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayClientObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"------ DXVB: DirectPlayClient8 Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayClientObject::C_dxj_DirectPlayClientObject(){ 
		
	DPF(1,"---- DXVB: Constructor Creation  DirectPlayClient8 Object\n ");

	m__dxj_DirectPlayClient = NULL;

	m_SPInfo = NULL;
	m_dwSPCount = 0;
	
	m_fInit = FALSE;
	m_fHandleEvents = FALSE;

	m_pUserData = NULL;
	m_dwUserDataSize = 0;
	m_pReplyData = NULL;
	m_dwReplyDataSize = 0;

	m_pEventStream=NULL;
	m_dwMsgCount = 0;

}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayClientObject::~C_dxj_DirectPlayClientObject()
{

	DPF(1,"---- Entering ~C_dxj_DirectPlayClientObject destructor \n");

	 //We still have messages to process get rid of them
	m_fHandleEvents = FALSE;
	FlushBuffer(0);
	SAFE_RELEASE(m__dxj_DirectPlayClient);
	SAFE_DELETE(m_SPInfo);

	m_fHandleEvents = FALSE;
	if (m_pEventStream) 
		m_pEventStream->Release();


}

HRESULT C_dxj_DirectPlayClientObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayClient;
	
	return S_OK;
}
HRESULT C_dxj_DirectPlayClientObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayClient=(IDirectPlay8Client*)pUnk;
	return S_OK;
}

HRESULT WINAPI DirectPlayClientMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
	HRESULT					hr=S_OK;
	LPUNKNOWN			    lpUnk=NULL;
	BOOL					fCallCoUninit = FALSE;
	VARIANT_BOOL							fRejectMsg = VARIANT_FALSE;
	
	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayClientObject	*lpPeer = (C_dxj_DirectPlayClientObject*)pvUserContext;

	if (!lpPeer) 
		return S_OK; //Object must be gone

	DPF2(1,"-----Entering (DPlayClient) MessageHandler call... (Current msg count=%d) MSGID = %d\n", lpPeer->m_dwMsgCount, dwMessageId );
	//Increment the msg count
	InterlockedIncrement(&lpPeer->m_dwMsgCount);

	if (!lpPeer->m_fHandleEvents)
	{
		DPF(1,"-----Leaving (DPlayClient) MessageHandler call (*Not Handling Events*)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	if (!lpPeer->m_pEventStream) 
	{
		DPF(1,"-----Leaving (DPlayClient) MessageHandler call (Stream Not Present)...\n");
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		return S_OK;
	}

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
	
	I_dxj_DirectPlayEvent	*lpEvent = NULL;
	__try {
		LARGE_INTEGER l;
		l.QuadPart = 0;
		lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

		hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);

		if (hr == CO_E_NOTINITIALIZED) // Call CoInit so we can unmarshal
		{
			CoInitializeEx(NULL,COINIT_MULTITHREADED);
			hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
			fCallCoUninit = TRUE;
		}

		if (!lpEvent) 
		{
			DPF1(1,"-----Leaving (DPlayClient) MessageHandler call (No event interface) - (Hresult) = %d...\n", hr);
			InterlockedDecrement(&lpPeer->m_dwMsgCount);
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (DPlayClient) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

    switch( dwMessageId )
	{
	//Receive
	case DPN_MSGID_RECEIVE:
		{
			DPF(1,"-----DirectPlayClient8 Callback Receive\n");
			DPNMSG_RECEIVE				*pMsgReceive = (DPNMSG_RECEIVE*)pMsgBuffer;
			DPNMSG_RECEIVE_CDESC		m_dpReceive;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpReceive, sizeof(DPNMSG_RECEIVE_CDESC));
			m_dpReceive.idSender = pMsgReceive->dpnidSender;
			
			// Let's load our SafeArray

			if (pMsgReceive->dwReceiveDataSize) 
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = pMsgReceive->dwReceiveDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = pMsgReceive->pReceiveData;
				m_dpReceive.lDataSize = pMsgReceive->dwReceiveDataSize;
				m_dpReceive.ReceivedData = lpData;
			}

			lpEvent->Receive(&m_dpReceive, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
			
			break;
		}

	//Send complete
	case DPN_MSGID_SEND_COMPLETE:
		{
			DPF(1,"-----DirectPlayClient8 Callback SendComplete\n");
			DPNMSG_SEND_COMPLETE				*msg = (DPNMSG_SEND_COMPLETE*)pMsgBuffer;
			DPNMSG_SEND_COMPLETE_CDESC			m_dpSend;

			ZeroMemory(&m_dpSend, sizeof(DPNMSG_SEND_COMPLETE_CDESC));
			m_dpSend.AsyncOpHandle = (long)msg->hAsyncOp;
			m_dpSend.hResultCode = (long)msg->hResultCode;
			m_dpSend.lSendTime = (long)msg->dwSendTime;

			lpEvent->SendComplete(&m_dpSend, &fRejectMsg);
			break;
		}

	//Async Op complete
	case DPN_MSGID_ASYNC_OP_COMPLETE:
		{
			DPF(1,"-----DirectPlayClient8 Callback AsyncOpComplete\n");
			DPNMSG_ASYNC_OP_COMPLETE				*msg = (DPNMSG_ASYNC_OP_COMPLETE*)pMsgBuffer;
			DPNMSG_ASYNC_OP_COMPLETE_CDESC			m_dpAsynOp;
			
			ZeroMemory(&m_dpAsynOp, sizeof(DPNMSG_ASYNC_OP_COMPLETE_CDESC));
			m_dpAsynOp.AsyncOpHandle = (long) msg->hAsyncOp;
			m_dpAsynOp.hResultCode = (long) msg->hResultCode;

			lpEvent->AsyncOpComplete(&m_dpAsynOp, &fRejectMsg);
			break;
		}

	// Add/Remove players from groups
	case DPN_MSGID_ADD_PLAYER_TO_GROUP:
	case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
		{
			DPF(1,"-----DirectPlayClient8 Callback Add/Remove Group\n");
			DPNMSG_ADD_PLAYER_TO_GROUP				*msg = (DPNMSG_ADD_PLAYER_TO_GROUP*)pMsgBuffer;
			DPNID									m_dpnidAddRemoveGroupID = 0;
			DPNID									m_dpnidAddRemovePlayerID = 0;

			m_dpnidAddRemoveGroupID = msg->dpnidGroup;
			m_dpnidAddRemovePlayerID = msg->dpnidPlayer;

			lpEvent->AddRemovePlayerGroup(dwMessageId, m_dpnidAddRemovePlayerID, m_dpnidAddRemoveGroupID, &fRejectMsg);
			break;
		}

	// App Desc
	case DPN_MSGID_APPLICATION_DESC:
		{
			DPF(1,"-----DirectPlayClient8 Callback App desc\n");
			lpEvent->AppDesc(&fRejectMsg);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATE_CONNECT:
		{
			DPF(1,"-----DirectPlayClient8 Callback Indicate Connect\n");
			DPNMSG_INDICATE_CONNECT				*msg = (DPNMSG_INDICATE_CONNECT*)pMsgBuffer;
			DPNMSG_INDICATE_CONNECT_CDESC		m_dpIndConnect;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];
			DWORD									dwNumChars = 0;


			ZeroMemory(&m_dpIndConnect, sizeof(DPNMSG_INDICATE_CONNECT_CDESC));
			lpPeer->m_pUserData = msg->pvUserConnectData;
			lpPeer->m_dwUserDataSize = msg->dwUserConnectDataSize;

			__try {
				if (msg->pAddressPlayer)
				{
					hr = msg->pAddressPlayer->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						if (FAILED (hr = msg->pAddressPlayer->GetURLW(&wszAddress[0],&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpIndConnect.AddressPlayerUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
						DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
					if (FAILED (hr = msg->pAddressDevice->GetURLW(&wszDevice[0],&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpIndConnect.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (Indicate Connect -  Part2)...\n");
			}

			lpEvent->IndicateConnect(&m_dpIndConnect, &fRejectMsg);
			msg->pvReplyData = lpPeer->m_pReplyData;
			msg->dwReplyDataSize = lpPeer->m_dwReplyDataSize;
			// Get rid of these addresses
			if (m_dpIndConnect.AddressPlayerUrl)
				SysFreeString(m_dpIndConnect.AddressPlayerUrl);

			if (m_dpIndConnect.AddressDeviceUrl)
				SysFreeString(m_dpIndConnect.AddressDeviceUrl);
		break;
		}

	// Connect complete
	case DPN_MSGID_CONNECT_COMPLETE:
		{
			DPF(1,"-----DirectPlayClient8 Callback ConnectComplete\n");
			DPNMSG_CONNECT_COMPLETE				*msg = (DPNMSG_CONNECT_COMPLETE*)pMsgBuffer;
			DPNMSG_CONNECT_COMPLETE_CDESC		m_dpConnectComp;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpConnectComp, sizeof(DPNMSG_CONNECT_COMPLETE_CDESC));
			m_dpConnectComp.hResultCode = (long) msg->hResultCode;
			m_dpConnectComp.AsyncOpHandle =(long) msg->hAsyncOp;
			// Let's load our SafeArray

			if (msg->dwApplicationReplyDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwApplicationReplyDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvApplicationReplyData;
				m_dpConnectComp.ReplyData = lpData;
			}

			lpEvent->ConnectComplete(&m_dpConnectComp, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
		break;
		}

	// Host migrated
	case DPN_MSGID_HOST_MIGRATE:
		{
			DPF(1,"-----DirectPlayClient8 Callback HostMigrate\n");
			DPNMSG_HOST_MIGRATE				*msg = (DPNMSG_HOST_MIGRATE*)pMsgBuffer;
			DPNID							m_dpnidNewHostID = 0;

			m_dpnidNewHostID = msg->dpnidNewHost;

			lpEvent->HostMigrate(m_dpnidNewHostID, &fRejectMsg);
	
			break;
		}

	// Terminate Session
	case DPN_MSGID_TERMINATE_SESSION:
		{
			DPF(1,"-----DirectPlayClient8 Callback TerminateSession\n");
			DPNMSG_TERMINATE_SESSION		*msg = (DPNMSG_TERMINATE_SESSION*)pMsgBuffer;
			DPNMSG_TERMINATE_SESSION_CDESC			m_dpTerm;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpTerm, sizeof(DPNMSG_TERMINATE_SESSION_CDESC));
			m_dpTerm.hResultCode = msg->hResultCode;

			// Let's load our SafeArray

			if (msg->dwTerminateDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwTerminateDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvTerminateData;
				m_dpTerm.TerminateData = lpData;
			}

			lpEvent->TerminateSession(&m_dpTerm,&fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}

		break;
		}

	// Enum Host query
	case DPN_MSGID_ENUM_HOSTS_QUERY:
		{
			DPF(1,"-----DirectPlayClient8 Callback EnumHostQuery\n");
			DPNMSG_ENUM_HOSTS_QUERY				*msg = (DPNMSG_ENUM_HOSTS_QUERY*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_QUERY_CDESC			m_dpEnumHostQuery;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];
			DWORD									dwNumChars = 0;

			
			ZeroMemory(&m_dpEnumHostQuery, sizeof(DPNMSG_ENUM_HOSTS_QUERY_CDESC));

			__try {
				hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
					if (FAILED (hr = msg->pAddressSender->GetURLW(&wszAddress[0],&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressSenderUrl = SysAllocString(wszAddress);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				{
					DPF1(1,"-----Failed... hr = %d\n",hr);
				}
				else
				{
					if (FAILED (hr = msg->pAddressDevice->GetURLW(&wszDevice[0],&dwNumChars) ) )
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						m_dpEnumHostQuery.AddressDeviceUrl = SysAllocString(wszDevice);
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumQuery Connect - Part2)...\n");
			}
			lpEvent->EnumHostsQuery(&m_dpEnumHostQuery, &fRejectMsg);

			// Get rid of these addresses
			if (m_dpEnumHostQuery.AddressSenderUrl)
				SysFreeString(m_dpEnumHostQuery.AddressSenderUrl);

			if (m_dpEnumHostQuery.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostQuery.AddressDeviceUrl);

			break;
		}
	
	// Create Player
	case DPN_MSGID_CREATE_PLAYER:
		{
			DPF(1,"-----DirectPlayClient8 Callback CreatePlayer\n");
			DPNMSG_CREATE_PLAYER	*msg = (DPNMSG_CREATE_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;

			lpEvent->CreatePlayer(m_dpnidPlayerID, &fRejectMsg);
			
		break;
		}

	// Destroy Player
	case DPN_MSGID_DESTROY_PLAYER:
		{
			DPF(1,"-----DirectPlayClient8 Callback DestroyPlayer\n");
			DPNMSG_DESTROY_PLAYER	*msg = (DPNMSG_DESTROY_PLAYER*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidPlayer;
			m_dwReason = msg->dwReason;
			
			lpEvent->DestroyPlayer(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}

	// Create Group
	case DPN_MSGID_CREATE_GROUP:
		{
			DPF(1,"-----DirectPlayClient8 Callback CreateGroup\n");
			DPNMSG_CREATE_GROUP	*msg = (DPNMSG_CREATE_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DPNID									m_dpnidOwnerID = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dpnidOwnerID = msg->dpnidOwner;
			
			lpEvent->CreateGroup(m_dpnidPlayerID, m_dpnidOwnerID, &fRejectMsg);
		break;
		}

	//Destroy Group
	case DPN_MSGID_DESTROY_GROUP:
		{
			DPF(1,"-----DirectPlayClient8 Callback DestroyGroup\n");
			DPNMSG_DESTROY_GROUP	*msg = (DPNMSG_DESTROY_GROUP*)pMsgBuffer;
			DPNID									m_dpnidPlayerID = 0;
			DWORD									m_dwReason = 0;
			
			m_dpnidPlayerID = msg->dpnidGroup;
			m_dwReason = msg->dwReason;
			

			lpEvent->DestroyGroup(m_dpnidPlayerID, m_dwReason, &fRejectMsg);
		break;
		}


	// Info
	case DPN_MSGID_PEER_INFO:
	case DPN_MSGID_CLIENT_INFO:
	case DPN_MSGID_SERVER_INFO:
	case DPN_MSGID_GROUP_INFO:
		{
			DPF(1,"-----DirectPlayClient8 Callback Info\n");
			DPNMSG_PEER_INFO	*msg = (DPNMSG_PEER_INFO*)pMsgBuffer;
			DPNID									m_dpnidInfoID = 0;
			
			m_dpnidInfoID = msg->dpnidPeer;

			lpEvent->InfoNotify(dwMessageId, m_dpnidInfoID, &fRejectMsg);
			break;
		}

	// EnumHostRes
	case DPN_MSGID_ENUM_HOSTS_RESPONSE:
		{
			DPF(1,"-----DirectPlayClient8 Callback EnumHostResponse\n");
			DPNMSG_ENUM_HOSTS_RESPONSE	*msg = (DPNMSG_ENUM_HOSTS_RESPONSE*)pMsgBuffer;
			DPNMSG_ENUM_HOSTS_RESPONSE_CDESC		m_dpEnumHostRes;
			DWORD									dwNumChars = 0;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];

			
			ZeroMemory(&m_dpEnumHostRes, sizeof(DPNMSG_ENUM_HOSTS_RESPONSE_CDESC));

			m_dpEnumHostRes.ApplicationDescription.lSize = (long)msg->pApplicationDescription->dwSize;
			m_dpEnumHostRes.ApplicationDescription.lFlags = msg->pApplicationDescription->dwFlags;
			m_dpEnumHostRes.ApplicationDescription.guidInstance = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidInstance);
			m_dpEnumHostRes.ApplicationDescription.guidApplication = GUIDtoBSTR((GUID*)&msg->pApplicationDescription->guidApplication);
			m_dpEnumHostRes.ApplicationDescription.lMaxPlayers = (long)msg->pApplicationDescription->dwMaxPlayers;
			m_dpEnumHostRes.ApplicationDescription.lCurrentPlayers = (long)msg->pApplicationDescription->dwCurrentPlayers;
			m_dpEnumHostRes.ApplicationDescription.SessionName = SysAllocString(msg->pApplicationDescription->pwszSessionName);
			m_dpEnumHostRes.ApplicationDescription.Password = SysAllocString(msg->pApplicationDescription->pwszPassword);
			m_dpEnumHostRes.lRoundTripLatencyMS = (long) msg->dwRoundTripLatencyMS;

			__try {
				if (msg->pAddressSender)
				{
					DPF(1,"-----About to get AdressSender...\n");
					hr = msg->pAddressSender->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else
					{
						if (FAILED (hr = msg->pAddressSender->GetURLW(&wszAddress[0],&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressSenderUrl = SysAllocString(wszAddress);
						}
					}
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}

			__try {
				dwNumChars = 0;
				if (msg->pAddressDevice)
				{
					DPF(1,"-----About to get AdressDevice...\n");
					hr = msg->pAddressDevice->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					{
						DPF1(1,"-----Failed... hr = %d\n",hr);
					}
					else {
						if (FAILED (hr = msg->pAddressDevice->GetURLW(&wszDevice[0],&dwNumChars) ) )
						{
							DPF1(1,"-----Failed... hr = %d\n",hr);
						}
						else
						{
							m_dpEnumHostRes.AddressDeviceUrl = SysAllocString(wszDevice);
						}
					}
				}
			
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				InterlockedDecrement(&lpPeer->m_dwMsgCount);
				DPF(1,"-----Exception (EnumRes Connect - Part1)...\n");
			}
			lpEvent->EnumHostsResponse(&m_dpEnumHostRes, &fRejectMsg);
			if (m_dpEnumHostRes.AddressSenderUrl)
				SysFreeString(m_dpEnumHostRes.AddressSenderUrl);

			if (m_dpEnumHostRes.AddressDeviceUrl)
				SysFreeString(m_dpEnumHostRes.AddressDeviceUrl);
		break;
		}

	// Indicate Connect
	case DPN_MSGID_INDICATED_CONNECT_ABORTED:
		{
			DPF(1,"-----DirectPlayServer8 Callback Indicated Connect Abort\n");

			lpEvent->IndicatedConnectAborted(&fRejectMsg);

		break;
		}
	}

	__try {
		if (lpPeer->m_pEventStream)
				// clean up marshaled packet
			CoReleaseMarshalData(lpPeer->m_pEventStream);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		InterlockedDecrement(&lpPeer->m_dwMsgCount);
		DPF(1,"-----Leaving (DPlayClient) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

	if (fCallCoUninit)
		CoUninitialize();

	InterlockedDecrement(&lpPeer->m_dwMsgCount);
	DPF(1,"-----Leaving (DPlayClient) MessageHandler call...\n");

	if (fRejectMsg != VARIANT_FALSE)
		return E_FAIL;

	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::EnumHosts(DPN_APPLICATION_DESC_CDESC *ApplicationDesc,I_dxj_DirectPlayAddress *AddrHost,I_dxj_DirectPlayAddress *DeviceInfo,long lRetryCount, long lRetryInterval, long lTimeOut,long lFlags, void *UserData, long UserDataSize, long *lAsync)
{
	HRESULT					hr;
	DPN_APPLICATION_DESC	desc;
	GUID					guidApp;
	GUID					guidInst;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];
	DPNHANDLE				*dpAsync = NULL;

	__try {
		DPF(1,"-----Entering (DPlayClient) EnumHosts call...\n");

		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		if (!IsEmptyString(ApplicationDesc->SessionName)) wcscpy(wszSessionName,ApplicationDesc->SessionName);
		if (!IsEmptyString(ApplicationDesc->Password)) wcscpy(wszPassword,ApplicationDesc->Password);
		ZeroMemory(&desc, sizeof(desc));

		// Set up our Desc
		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = ApplicationDesc->lFlags;

		desc.dwMaxPlayers = ApplicationDesc->lMaxPlayers;
		desc.dwCurrentPlayers = ApplicationDesc->lCurrentPlayers;
		if (!IsEmptyString(ApplicationDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(ApplicationDesc->Password))
			desc.pwszPassword = wszPassword;

		if (ApplicationDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, ApplicationDesc->guidApplication) ) )
				return hr;
			desc.guidApplication = guidApp;
		}

		if (ApplicationDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&guidInst, ApplicationDesc->guidInstance) ) )
				return hr;
			desc.guidInstance = guidInst;
		}

		// Get our host and device address
		IDirectPlay8Address	*lpHost = NULL;
		IDirectPlay8Address	*lpDevice = NULL;

		if(AddrHost) AddrHost->InternalGetObject((IUnknown **)(&lpHost));
		if(DeviceInfo) DeviceInfo->InternalGetObject((IUnknown **)(&lpDevice));

		hr = m__dxj_DirectPlayClient->EnumHosts(&desc, lpHost, lpDevice, UserData, UserDataSize, (DWORD) lRetryCount, (DWORD) lRetryInterval, (DWORD) lTimeOut, NULL,  dpAsync, (DWORD) lFlags);
		// This should return E_PENDING

		if (dpAsync)
		{
			*lAsync = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if( hr != E_PENDING && FAILED(hr) )
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::CancelAsyncOperation(long lAsyncHandle, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) CancelAsyncOperation call...\n");
		if (FAILED( hr= m__dxj_DirectPlayClient->CancelAsyncOperation((DPNHANDLE) lAsyncHandle, (DWORD) lFlags) ) ) 
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::Connect(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address,I_dxj_DirectPlayAddress *DeviceInfo, long lFlags, void *UserData, long UserDataSize, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_APPLICATION_DESC	desc;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];
	DPNHANDLE				*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayClient) Connect call...\n");
		if (!IsEmptyString(AppDesc->SessionName)) wcscpy(wszSessionName,AppDesc->SessionName);
		if (!IsEmptyString(AppDesc->Password)) wcscpy(wszPassword,AppDesc->Password);

		ZeroMemory(&desc, sizeof(desc));

		// Set up our Desc
		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = AppDesc->lFlags;

		desc.dwMaxPlayers = AppDesc->lMaxPlayers;
		desc.dwCurrentPlayers = AppDesc->lCurrentPlayers;
		if (!IsEmptyString(AppDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(AppDesc->Password))
			desc.pwszPassword = wszPassword;

		if (AppDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidApplication, AppDesc->guidApplication) ) )
				return hr;
		}

		if (AppDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidInstance , AppDesc->guidInstance) ) )
				return hr;
		}

		// Get our host and device address
		IDirectPlay8Address	*lpAddress = NULL;
		IDirectPlay8Address	*lpDevice = NULL;

		if(Address) 
		{ 
			IUnknown *lpTemp = NULL;

			Address->InternalGetObject((IUnknown **)(&lpTemp));
			lpTemp->QueryInterface(IID_IDirectPlay8Address, (void**)&lpAddress);
			lpTemp->Release();
		}

		if(DeviceInfo) 
		{
			IUnknown *lpTemp = NULL;

			DeviceInfo->InternalGetObject((IUnknown **)(&lpTemp));
			lpTemp->QueryInterface(IID_IDirectPlay8Address, (void**)&lpDevice);
			lpTemp->Release();
		}

		// Time to connect
		hr = m__dxj_DirectPlayClient->Connect(&desc, lpAddress, lpDevice, NULL, NULL, UserData, (DWORD)UserDataSize, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::Send(SAFEARRAY **Buffer, long lTimeOut,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_BUFFER_DESC		lpBuf;
	DWORD				dwBufSize = ((SAFEARRAY*)*Buffer)->rgsabound[0].cElements;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		DPF(1,"-----Entering (DPlayClient) SendTo call...\n");

		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}
			
		lpBuf.dwBufferSize = dwBufSize;
		lpBuf.pBufferData  = (BYTE*)((SAFEARRAY*)*Buffer)->pvData;

		hr = m__dxj_DirectPlayClient->Send(&lpBuf, 1, (DWORD) lTimeOut, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetSendQueueInfo(long *lNumMsgs, long *lNumBytes, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetSendQueueInfo call...\n");
		if (FAILED (hr = m__dxj_DirectPlayClient->GetSendQueueInfo((DWORD*)lNumMsgs, (DWORD*)lNumBytes, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC *ret)
{
	HRESULT					hr;
	DWORD					dwSize = 0;
	DPN_APPLICATION_DESC	*desc = NULL;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetApplicationDesc call...\n");
		hr= m__dxj_DirectPlayClient->GetApplicationDesc(NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		desc = (DPN_APPLICATION_DESC*)new BYTE[dwSize];
		if (!desc)
			return E_OUTOFMEMORY;

		if (!dwSize)
			return E_FAIL;

		desc->dwSize = sizeof(DPN_APPLICATION_DESC);

		hr= m__dxj_DirectPlayClient->GetApplicationDesc(desc, &dwSize, (DWORD) lFlags);
		if( FAILED(hr))
			return hr;

		// Now return the vals 
		ret->lSize = dwSize;
		ret->lFlags = desc->dwFlags;
		ret->guidInstance = GUIDtoBSTR(&desc->guidInstance);
		ret->guidApplication = GUIDtoBSTR(&desc->guidApplication);
		ret->lMaxPlayers = desc->dwMaxPlayers;
		ret->lCurrentPlayers = desc->dwCurrentPlayers;
		ret->SessionName = SysAllocString(desc->pwszSessionName);
		ret->Password = SysAllocString(desc->pwszPassword);

		SAFE_DELETE(desc);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::SetClientInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_PLAYER_INFO dpInfo;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DPlayClient) SetClientInfo call...\n");
		ZeroMemory(&dpInfo, sizeof(DPN_PLAYER_INFO) );

		dpInfo.dwSize = sizeof(DPN_PLAYER_INFO);
		dpInfo.dwInfoFlags = PlayerInfo->lInfoFlags;
		dpInfo.pwszName = PlayerInfo->Name;
		dpInfo.dwPlayerFlags = PlayerInfo->lPlayerFlags;

		hr = m__dxj_DirectPlayClient->SetClientInfo(&dpInfo, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetServerInfo(long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo)
{
	HRESULT				hr;
    DWORD				dwSize = 0;
    DPN_PLAYER_INFO		*PlayerInfo = NULL;
    
	__try {
		DPF(1,"-----Entering (DPlayClient) GetServerInfo call...\n");
		hr = m__dxj_DirectPlayClient->GetServerInfo( NULL, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		PlayerInfo = (DPN_PLAYER_INFO*) new BYTE[ dwSize ];
		if (!PlayerInfo)
			return E_OUTOFMEMORY;

		if (!dwSize)
			return E_FAIL;

		ZeroMemory( PlayerInfo, dwSize );
		PlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
		hr = m__dxj_DirectPlayClient->GetServerInfo(PlayerInfo, &dwSize, (DWORD) lFlags );
		if( FAILED(hr) )
			return hr;

		layerInfo->lSize = sizeof(DPN_PLAYER_INFO_CDESC);
		layerInfo->lInfoFlags = PlayerInfo->dwInfoFlags;
		layerInfo->Name = SysAllocString(PlayerInfo->pwszName);
		layerInfo->lPlayerFlags = PlayerInfo->dwPlayerFlags;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::Close(long lFlags)
{
	HRESULT hr;
	BOOL bGotMsg = FALSE;
	BOOL bWait = FALSE;
	DWORD dwObj = 0;
	int i=0;
	MSG msg;

	__try {
		DPF(1,"-----Entering (DPlayClient) Close call...\n");
		FlushBuffer(0);

		HANDLE hThread = NULL;
		DWORD dwThread = 0;

		hThread = CreateThread(NULL, 0, &CloseClientThreadProc, this->m__dxj_DirectPlayClient, 0, &dwThread);
		msg.message = WM_NULL;

		while ((WM_QUIT != msg.message) && (!bWait))
		{
			bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
			i++;
			if ((!bGotMsg) || (i>10))
			{
				dwObj = WaitForSingleObject(hThread, 10);
				bWait = (dwObj == WAIT_OBJECT_0);
				i = 0;
			}
			if (bGotMsg)
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}
			bGotMsg = FALSE;
		}


	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::ReturnBuffer(long lBufferHandle)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) ReturnBuffer call...\n");
		if (FAILED(hr = m__dxj_DirectPlayClient->ReturnBuffer( (DPNHANDLE) lBufferHandle, 0 ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetCaps(long lFlags, DPNCAPS_CDESC *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetCaps call...\n");
		ret->lSize = sizeof(DPN_CAPS);
		if (FAILED (hr=m__dxj_DirectPlayClient->GetCaps( (DPN_CAPS*) ret, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::SetCaps(DPNCAPS_CDESC *Caps, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) SetCaps call...\n");
		if (FAILED( hr = m__dxj_DirectPlayClient->SetCaps((DPN_CAPS*)Caps, (DWORD)lFlags)))
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetCountServiceProviders(long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetCountServiceProviders call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(lFlags) ) )
				return hr;
		
		*ret = (long)m_dwSPCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetServiceProvider call...\n");
		if (!m_SPInfo)
			if (FAILED (hr=GetSP(0) ) )
				return hr;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwSPCount))
			return E_INVALIDARG;

		// Fill out our structure
		ret->lFlags = (long) m_SPInfo[lIndex-1].dwFlags;
		ret->Name = SysAllocString(m_SPInfo[lIndex-1].pwszName);
		ret->Guid = GUIDtoBSTR(&m_SPInfo[lIndex-1].guid);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetSP(long lFlags)
{
    // Enumerate all DirectPlay sevice providers
    
	HRESULT		hr;
	DWORD		dwSize=0;
	DWORD		dwItems=0;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetSP call...\n");
		SAFE_DELETE(m_SPInfo);
		hr = m__dxj_DirectPlayClient->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags );
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_SPInfo = (DPN_SERVICE_PROVIDER_INFO*) new BYTE[dwSize];
		if (!m_SPInfo)
			return E_OUTOFMEMORY;

		if( FAILED( hr = m__dxj_DirectPlayClient->EnumServiceProviders( NULL, NULL, m_SPInfo, &dwSize, 
										  &dwItems, (DWORD) lFlags) ) )
			return hr;

		m_dwSPCount = dwItems;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) RegisterLobby call...\n");
		DO_GETOBJECT_NOTNULL( IDirectPlay8LobbiedApplication*, lpLobby, LobbyApp);

		if (FAILED( hr = m__dxj_DirectPlayClient->RegisterLobby((DPNHANDLE) dpnHandle, lpLobby,(DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetConnectionInfo(long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetConnectionInfo call...\n");
		pdpConnectionInfo->lSize = sizeof(DPN_CONNECTION_INFO);
		if (FAILED( hr = m__dxj_DirectPlayClient->GetConnectionInfo((DPN_CONNECTION_INFO*)pdpConnectionInfo, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetServerAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress)
{
	IDirectPlay8Address	*lpAdd = NULL;
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetServerAddress call...\n");
		if (FAILED (hr = m__dxj_DirectPlayClient->GetServerAddress( &lpAdd, (DWORD) lFlags) ) )
			return hr;

		INTERNAL_CREATE_ADDRESS(_dxj_DirectPlayAddress,lpAdd, pAddress);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DPlayClient) SetSPCaps call...\n");
		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		spCaps->lSize = sizeof(DPN_SP_CAPS);
		//
		//	MiNara: Added 0 for dwFlags parameter
		//
		if (FAILED(hr = m__dxj_DirectPlayClient->SetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps,(DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps)
{
	HRESULT hr;
	GUID guidServiceProvider;

	__try {
		DPF(1,"-----Entering (DPlayClient) GetSPCaps call...\n");
		spCaps->lSize = sizeof(DPN_SP_CAPS);

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidServiceProvider, guidSP) ) )
			return hr;

		if (FAILED(hr = m__dxj_DirectPlayClient->GetSPCaps(&guidServiceProvider,(DPN_SP_CAPS*)spCaps, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::RegisterMessageHandler(I_dxj_DirectPlayEvent *event)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;

	DPF(1,"-----Entering (DPlayClient) RegisterMessageHandler call...\n");
	if (!event) return E_INVALIDARG;
    
    if (!m_fHandleEvents)
	{
		DPF(1,"-----(DPlayClient) RegisterMessageHandler call (We are not handling events currently)...\n");
		if (m_pEventStream) 
			m_pEventStream->Release();

		DPF(1,"-----(DPlayClient) RegisterMessageHandler call (CreateStream)...\n");
		hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
		if FAILED(hr) return hr;

		DPF(1,"-----(DPlayClient) RegisterMessageHandler call (Marshall VB Event interface)...\n");
		hr = CoMarshalInterface(pStm, IID_I_dxj_DirectPlayEvent, event, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
		if FAILED(hr) return hr;

		// Now we need to set the seek location of the stream to the beginning
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
		m_pEventStream=pStm;

		DPF(1,"-----(DPlayClient) RegisterMessageHandler call (Call DPlayInit)...\n");
		if (!m_fInit)
		{
			if (FAILED ( hr = m__dxj_DirectPlayClient->Initialize( this, DirectPlayClientMessageHandler, 0 ) ) )
				return hr;
			m_fInit = TRUE;
		}
		m_fHandleEvents = TRUE;
	}
	else
		return DPNERR_ALREADYINITIALIZED;

	return hr;
}

HRESULT C_dxj_DirectPlayClientObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (DPlayClient) UnregisterMessageHandler call...\n");
	m_fHandleEvents = FALSE;
	//Clear out the messages currently waiting
	FlushBuffer(0);
	return S_OK;
}

HRESULT C_dxj_DirectPlayClientObject::FlushBuffer(LONG dwNumMessagesLeft)
{
	
	DWORD dwTime = GetTickCount();

	DPF(1,"-----Entering (DPlayClient) FlushBuffer call...\n");
	//Clear out the messages currently waiting
	while (m_dwMsgCount > dwNumMessagesLeft)
	{
		if (GetTickCount() - dwTime > 5000)
		{
			// Don't let FlushBuffer wait more than 5 seconds
			DPF1(1,"-----Leaving (DPlayClient) FlushBuffer call (All messages *not* flushed - %d remained)...\n", m_dwMsgCount);
			return S_OK;
		}
	}
	DPF(1,"-----Leaving (DPlayClient) FlushBuffer call (All messages flushed)...\n");
	return S_OK;
}

DWORD WINAPI CloseClientThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8Client	*lpPeer = (IDirectPlay8Client*)lpParam;

	DPF(1,"-----Entering (DplayPeer) CloseClientThreadProc call...\n");
	lpPeer->Close(0);
	DPF(1,"-----Leaving (DplayPeer) CloseClientThreadProc call ...\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplayclientobj.h ===
#include "resource.h"       // main symbols
#include "dplay8.h"

#define typedef__dxj_DirectPlayClient IDirectPlay8Client*
//Forward declare the class
class C_dxj_DirectPlayClientObject;

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayClientObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayClient, &IID_I_dxj_DirectPlayClient, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayClient,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayClientObject() ;
	virtual ~C_dxj_DirectPlayClientObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayClientObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayClient)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayClientObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayClient
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);


		HRESULT STDMETHODCALLTYPE RegisterMessageHandler(I_dxj_DirectPlayEvent *event);
		HRESULT STDMETHODCALLTYPE EnumHosts(DPN_APPLICATION_DESC_CDESC *ApplicationDesc,I_dxj_DirectPlayAddress *AddrHost,I_dxj_DirectPlayAddress *DeviceInfo,long lRetryCount, long lRetryInterval, long lTimeOut,long lFlags, void *UserData, long UserDataSize, long *lAsync);
		HRESULT STDMETHODCALLTYPE GetCountServiceProviders(long lFlags, long *ret);
		HRESULT STDMETHODCALLTYPE GetServiceProvider(long lIndex, DPN_SERVICE_PROVIDER_INFO_CDESC *ret);
		HRESULT STDMETHODCALLTYPE CancelAsyncOperation(long lAsyncHandle, long lFlags);
		HRESULT STDMETHODCALLTYPE Connect(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address,I_dxj_DirectPlayAddress *DeviceInfo, long lFlags, void *UserData, long UserDataSize, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE Send(SAFEARRAY **Buffer, long lTimeOut,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetSendQueueInfo(long *lNumMsgs, long *lNumBytes, long lFlags);
		HRESULT STDMETHODCALLTYPE GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC *ret);
		HRESULT STDMETHODCALLTYPE SetClientInfo(DPN_PLAYER_INFO_CDESC *PlayerInfo,long lFlags, long *hAsyncHandle);
		HRESULT STDMETHODCALLTYPE GetServerInfo(long lFlags, DPN_PLAYER_INFO_CDESC *layerInfo);
		HRESULT STDMETHODCALLTYPE Close(long lFlags);
		HRESULT STDMETHODCALLTYPE ReturnBuffer(long lBufferHandle);
		HRESULT STDMETHODCALLTYPE GetCaps(long lFlags, DPNCAPS_CDESC *ret);
		HRESULT STDMETHODCALLTYPE SetCaps(DPNCAPS_CDESC *Caps, long lFlags);
		HRESULT STDMETHODCALLTYPE RegisterLobby(long dpnHandle, I_dxj_DirectPlayLobbiedApplication *LobbyApp, long lFlags);
		HRESULT STDMETHODCALLTYPE GetConnectionInfo(long lFlags, DPN_CONNECTION_INFO_CDESC *pdpConnectionInfo);

		HRESULT STDMETHODCALLTYPE GetServerAddress(long lFlags, I_dxj_DirectPlayAddress **pAddress);
		HRESULT STDMETHODCALLTYPE SetSPCaps(BSTR guidSP, DPN_SP_CAPS_CDESC *spCaps, long lFlags);
		HRESULT STDMETHODCALLTYPE GetSPCaps(BSTR guidSP, long lFlags, DPN_SP_CAPS_CDESC *spCaps);
		HRESULT STDMETHODCALLTYPE GetUserData(void *UserData, long *UserDataSize);
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();
////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayClient);

private:
    DPN_SERVICE_PROVIDER_INFO	*m_SPInfo;
	DWORD						m_dwSPCount;
	BOOL						m_fInit;

	HRESULT STDMETHODCALLTYPE GetSP(long lFlags);
	HRESULT STDMETHODCALLTYPE	FlushBuffer(LONG dwNumMessagesLeft);

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayClient);

	DWORD InternalAddRef();
	DWORD InternalRelease();

	// We need these for our user data vars
	void			*m_pUserData;
	DWORD			m_dwUserDataSize;
	// For our reply data
	void			*m_pReplyData;
	DWORD			m_dwReplyDataSize;

	BOOL									m_fHandleEvents;
	IStream									*m_pEventStream;

	//We need to keep a count of the messages
	LONG									m_dwMsgCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplaylobbyclientobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPlayLobbyClientObj.h"					   
#include "DplayAddressObj.h"

extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern void *g_dxj_DirectPlayLobbyClient;
extern void *g_dxj_DirectPlayAddress;

extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { (p)->Release(); (p)=NULL;} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

DWORD WINAPI CloseLobbyClientThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayLobbyClientObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"------ DXVB: DirectPlayLobbyClient8 AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayLobbyClientObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"------ DXVB: DirectPlayLobbyClient8 Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayLobbyClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayLobbyClientObject::C_dxj_DirectPlayLobbyClientObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation  DirectPlayLobbyClient8 Object \n ");

	m__dxj_DirectPlayLobbyClient = NULL;
    m_ProgInfo = NULL;
	m_dwAppCount = 0;
	 	
	m_fInit = FALSE;

	m_pUserData = NULL;
	m_dwUserDataSize = 0;
	m_fHandleEvents = FALSE;

	m_pEventStream=NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayLobbyClientObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayLobbyClientObject::~C_dxj_DirectPlayLobbyClientObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectPlayLobbyClientObject destructor \n");
	SAFE_RELEASE(m__dxj_DirectPlayLobbyClient);
    SAFE_DELETE(m_ProgInfo)
	m_fHandleEvents = FALSE;

	if (m_pEventStream) 
		m_pEventStream->Release();

}

HRESULT C_dxj_DirectPlayLobbyClientObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayLobbyClient;
	
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayLobbyClient=(IDirectPlay8LobbyClient*)pUnk;
	return S_OK;
}

HRESULT WINAPI DirectPlayLobbyClientMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
	HRESULT					hr=S_OK;
	BOOL					fCallCoUninit = FALSE;
	VARIANT_BOOL			fRejectMsg = VARIANT_FALSE;

	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayLobbyClientObject	*lpPeer = (C_dxj_DirectPlayLobbyClientObject*)pvUserContext;
	DPF(1,"-----Entering (DPlayLobbyClient) MessageHandler call...\n");
	
	if (!lpPeer) return E_FAIL;
	if (!lpPeer->m_pEventStream) return E_FAIL;

	if (!lpPeer->m_fHandleEvents)
		return S_OK;

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
		I_dxj_DirectPlayLobbyEvent	*lpEvent = NULL;
	__try {
		LARGE_INTEGER l;
		l.QuadPart = 0;
		lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

		hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
		if (hr == CO_E_NOTINITIALIZED) // Call CoInit so we can unmarshal
		{
			CoInitialize(NULL);
			hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
			fCallCoUninit = TRUE;
		}

		if (!lpEvent) 
		{
			DPF(1,"-----Leaving (DplayLobbyClient) MessageHandler call (No event interface)...\n");
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		DPF(1,"-----Leaving (DplayLobbyClient) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

    switch( dwMessageId )
	{
	//Receive
	case DPL_MSGID_RECEIVE:
		{
			DPL_MESSAGE_RECEIVE			*msg = (DPL_MESSAGE_RECEIVE*)pMsgBuffer;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			DPL_MESSAGE_RECEIVE_CDESC	m_dpReceive;
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpReceive, sizeof(DPL_MESSAGE_RECEIVE));
			m_dpReceive.Sender = (long)msg->hSender;
			
			// Let's load our SafeArray

			if (msg->dwBufferSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwBufferSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pBuffer;
				m_dpReceive.lBufferSize = msg->dwBufferSize;
				m_dpReceive.Buffer = lpData;
			}

			lpEvent->Receive(&m_dpReceive, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
			
			break;
		}

	//Connect
	case DPL_MSGID_CONNECT:
		{
			DPL_MESSAGE_CONNECT				*msg = (DPL_MESSAGE_CONNECT*)pMsgBuffer;
			DPNHANDLE						m_hConnectID;
			DPL_MESSAGE_CONNECT_CDESC		m_dpConnection;
			SAFEARRAY						*lpData = NULL;
			SAFEARRAYBOUND					rgsabound[1];
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];
			DWORD									dwNumChars = 0;
			BYTE						*lpTemp = NULL;

			m_dpConnection.ConnectId = (long)msg->hConnectId;
			// Let's load our SafeArray

			if (msg->dwLobbyConnectDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwLobbyConnectDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvLobbyConnectData;
				m_dpConnection.LobbyConnectData = lpData;
			}

			lpPeer->GetVBConnSettings(msg->pdplConnectionSettings, &m_dpConnection.dplMsgCon);

			__try {
				hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					return hr;

				if (FAILED (hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(&wszAddress[0],&dwNumChars) ) )
					return hr;

				m_dpConnection.dplMsgCon.AddressSenderUrl = SysAllocString(wszAddress);
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			__try {
				dwNumChars = 0;
				hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					return hr;

				if (FAILED (hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(&wszDevice[0],&dwNumChars) ) )
					return hr;

				m_dpConnection.dplMsgCon.AddressDeviceUrl = SysAllocString(wszDevice);
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			lpEvent->Connect(&m_dpConnection, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}

			// Get rid of these addresses
			if (m_dpConnection.dplMsgCon.AddressSenderUrl)
				SysFreeString(m_dpConnection.dplMsgCon.AddressSenderUrl);

			if (m_dpConnection.dplMsgCon.AddressDeviceUrl)
				SysFreeString(m_dpConnection.dplMsgCon.AddressDeviceUrl);
			
		break;
		}

	//Disconnect
	case DPL_MSGID_DISCONNECT:
		{
			DPL_MESSAGE_DISCONNECT				*msg = (DPL_MESSAGE_DISCONNECT*)pMsgBuffer;
			DPNHANDLE								m_hDisconnectID;
			HRESULT									m_hDisconnectReason;

			m_hDisconnectID = (long)msg->hDisconnectId;
			m_hDisconnectReason = (long) msg->hrReason;

			lpEvent->Disconnect(m_hDisconnectID, m_hDisconnectReason);
			
			break;
		}

	//Status
	case DPL_MSGID_SESSION_STATUS:
		{
			DPL_MESSAGE_SESSION_STATUS			*msg = (DPL_MESSAGE_SESSION_STATUS*)pMsgBuffer;
			DPNHANDLE								m_hSender;
			DWORD									m_dwSessionStatus;

			m_dwSessionStatus = (long)msg->dwStatus;
			m_hSender = (long)msg->hSender;
	
			lpEvent->SessionStatus(m_dwSessionStatus,m_hSender);

		break;
		}

	//ConnectionSettings
	case DPL_MSGID_CONNECTION_SETTINGS:
		{
			DPL_MESSAGE_CONNECTION_SETTINGS			*msg = (DPL_MESSAGE_CONNECTION_SETTINGS*)pMsgBuffer;
			DPL_MESSAGE_CONNECTION_SETTINGS_CDESC	dpCon;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];
			DWORD									dwNumChars = 0;

			ZeroMemory(&dpCon, sizeof(DPL_MESSAGE_CONNECTION_SETTINGS_CDESC));

			lpPeer->GetVBConnSettings(msg->pdplConnectionSettings, &dpCon.dplConnectionSettings);
			dpCon.hSender = (long)msg->hSender;
			__try {
				hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					return hr;

				if (FAILED (hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(&wszAddress[0],&dwNumChars) ) )
					return hr;

				dpCon.dplConnectionSettings.AddressSenderUrl = SysAllocString(wszAddress);
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			__try {
				dwNumChars = 0;
				hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
				if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
					return hr;

				if (FAILED (hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(&wszDevice[0],&dwNumChars) ) )
					return hr;

				dpCon.dplConnectionSettings.AddressDeviceUrl = SysAllocString(wszDevice);
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}
			lpEvent->ConnectionSettings(&dpCon);
			// Get rid of these addresses
			if (dpCon.dplConnectionSettings.AddressSenderUrl)
				SysFreeString(dpCon.dplConnectionSettings.AddressSenderUrl);

			if (dpCon.dplConnectionSettings.AddressDeviceUrl)
				SysFreeString(dpCon.dplConnectionSettings.AddressDeviceUrl);

		break;
		}
	}

	__try {
		if (lpPeer->m_pEventStream)
				// clean up marshaled packet
			CoReleaseMarshalData(lpPeer->m_pEventStream);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		return S_OK;
	}

	if (fCallCoUninit)
		CoUninitialize();

	DPF(1,"-----Leaving (DPlayLobbyClient) MessageHandler call...\n");

	if (fRejectMsg != VARIANT_FALSE)
		return E_FAIL;

	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::RegisterMessageHandler(I_dxj_DirectPlayLobbyEvent *lobbyEvent)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;

	DPF(1,"-----Entering (DPlayLobbyClient) RegisterMessageHandler call...\n");
	if (!lobbyEvent) return E_INVALIDARG;
    
    if (!m_fHandleEvents)
	{
		if (m_pEventStream) 
			m_pEventStream->Release();


		// Create a global stream.  The stream needs to be global so we can 
		// marshal once, and unmarshal as many times as necessary
		hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
		if FAILED(hr) return hr;

		// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
		// so we can unmarshal any number of times
		hr = CoMarshalInterface(pStm, IID_I_dxj_DirectPlayLobbyEvent, lobbyEvent, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
		if FAILED(hr) return hr;

		// Now we need to set the seek location of the stream to the beginning
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
		m_pEventStream=pStm;

		if (!m_fInit)
		{
			if (FAILED ( hr = m__dxj_DirectPlayLobbyClient->Initialize( this, DirectPlayLobbyClientMessageHandler, 0 ) ) )
				return hr;
			m_fInit = TRUE;
		}
		m_fHandleEvents = TRUE;
	}
	else
		return DPNERR_ALREADYINITIALIZED;

	return hr;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::GetCountLocalPrograms(BSTR GuidApplication,long *lCount)
{
	GUID *guidApp = NULL;
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) GetCountLocalPrograms call...\n");
		if (!IsEmptyString(GuidApplication))
		{
			guidApp = new GUID;
			if (FAILED (hr = BSTRtoGUID(guidApp,GuidApplication) ) )
				return hr;
		}

		if (FAILED (hr = GetProgs(guidApp) ) )
			return hr;

		if (guidApp)
			SAFE_DELETE(guidApp);

		*lCount = (long)m_dwAppCount;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::GetLocalProgram(long lProgID, DPL_APPLICATION_INFO_CDESC *app)
{
	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) GetLocalProgram call...\n");
		if (!m_ProgInfo)
			return E_INVALIDARG;

		if ((lProgID < 1 ) || ((DWORD)lProgID > m_dwAppCount))
			return E_INVALIDARG;

		// Now we've got to fill our DPL_PROGRAM_DESC_CDESC structure
		//app->lSize = m_ProgInfo[lProgID - 1].dwSize;
		app->lFlags = m_ProgInfo[lProgID - 1].dwFlags;
		app->ApplicationName = SysAllocString(m_ProgInfo[lProgID - 1].pwszApplicationName);
		app->guidApplication = GUIDtoBSTR(&m_ProgInfo[lProgID - 1].guidApplication);
		app->lNumRunning = m_ProgInfo[lProgID - 1].dwNumRunning;
		app->lNumWaiting = m_ProgInfo[lProgID - 1].dwNumWaiting;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::ConnectApplication(DPL_CONNECT_INFO_CDESC *ConnectionInfo,long lTimeOut,long lFlags, long *hApplication)
{
	HRESULT				hr;
	DPL_CONNECT_INFO	dplConnect;
	DPNHANDLE			hApp = NULL;

	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) ConnectApplication call...\n");
		ZeroMemory(&dplConnect,sizeof(DPL_CONNECT_INFO));
		// Fill out our connection structure

		dplConnect.dwSize = sizeof(DPL_CONNECT_INFO);
		dplConnect.dwFlags = ConnectionInfo->lFlags;
		if (FAILED (hr = BSTRtoGUID(&dplConnect.guidApplication,ConnectionInfo->guidApplication) ) )
			return hr;

		if (FAILED (hr = m__dxj_DirectPlayLobbyClient->ConnectApplication(&dplConnect,NULL, &hApp, (DWORD) lTimeOut, (DWORD) lFlags) ) )
			return hr;

		*hApplication = (long)hApp;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::Send(long Target,SAFEARRAY **Buffer,long lBufferSize,long lFlags)
{
	HRESULT hr;
	BYTE				*lpBuf = NULL;
	DWORD				dwBufferSize = 0;

	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) Send call...\n");
		dwBufferSize = (DWORD)lBufferSize;

		hr = m__dxj_DirectPlayLobbyClient->Send((DPNHANDLE) Target, (BYTE*) ((SAFEARRAY*)*Buffer)->pvData, dwBufferSize, (DWORD) lFlags);
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::ReleaseApplication(long Application)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) ReleaseApplication call...\n");
		if (FAILED (hr = m__dxj_DirectPlayLobbyClient->ReleaseApplication( (DPNHANDLE) Application, 0 ) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::Close()
{
	HRESULT hr;
	BOOL bGotMsg = FALSE;
	BOOL bWait = FALSE;
	DWORD dwObj = 0;
	int i=0;
	MSG msg;

	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) Close call...\n");
		HANDLE hThread = NULL;
		DWORD dwThread = 0;

		hThread = CreateThread(NULL, 0, &CloseLobbyClientThreadProc, this->m__dxj_DirectPlayLobbyClient, 0, &dwThread);
		msg.message = WM_NULL;

		while ((WM_QUIT != msg.message) && (!bWait))
		{
			bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
			i++;
			if ((!bGotMsg) || (i>10))
			{
				dwObj = WaitForSingleObject(hThread, 10);
				bWait = (dwObj == WAIT_OBJECT_0);
				i = 0;
			}
			if (bGotMsg)
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}
			bGotMsg = FALSE;
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::GetProgs(GUID *guidApp)
{
    // Enumerate all DirectPlay Local Progs
    
	HRESULT		hr;
	DWORD		dwSize=0;
	DWORD		dwItems=0;
	
	__try {
		DPF(1,"-----Entering (DPlayLobbyClient) GetProgs call...\n");
		hr = m__dxj_DirectPlayLobbyClient->EnumLocalPrograms( guidApp, (BYTE*)m_ProgInfo, &dwSize, &dwItems, 0);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		m_ProgInfo = (DPL_APPLICATION_INFO*) new BYTE[dwSize];
		if( FAILED( hr = m__dxj_DirectPlayLobbyClient->EnumLocalPrograms( guidApp, (BYTE*)m_ProgInfo, &dwSize, &dwItems, 0) ) )
			return hr;

		m_dwAppCount = dwItems;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayLobbyClientObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (DPlayLobbyClient) UnregisterMessageHandler call...\n");
	m_fHandleEvents = FALSE;
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::GetConnectionSettings(long hLobbyClient, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings)
{
	DPL_CONNECTION_SETTINGS	*desc = NULL;
	DWORD					dwSize = 0;
	HRESULT					hr = S_OK;
	WCHAR									wszAddress[MAX_PATH];
	WCHAR									wszDevice[MAX_PATH];
	DWORD									dwNumChars = 0;

	__try {
		hr= m__dxj_DirectPlayLobbyClient->GetConnectionSettings((DPNHANDLE) hLobbyClient, NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		desc = (DPL_CONNECTION_SETTINGS*)new BYTE[dwSize];
		desc->dwSize = sizeof(DPL_CONNECTION_SETTINGS);

		hr= m__dxj_DirectPlayLobbyClient->GetConnectionSettings((DPNHANDLE) hLobbyClient, desc, &dwSize, (DWORD) lFlags);
		if( FAILED(hr))
			return hr;

		__try {
			hr = desc->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
			if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				return hr;

			if (FAILED (hr = desc->pdp8HostAddress->GetURLW(&wszAddress[0],&dwNumChars) ) )
				return hr;

			ConnectionSettings->AddressSenderUrl = SysAllocString(wszAddress);
		}	
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			// Just skip this part
		}

		__try {
			dwNumChars = 0;
			hr = ((IDirectPlay8Address*)*desc->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
			if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				return hr;

			if (FAILED (hr = ((IDirectPlay8Address*)*desc->ppdp8DeviceAddresses)->GetURLW(&wszDevice[0],&dwNumChars) ) )
				return hr;

			ConnectionSettings->AddressDeviceUrl = SysAllocString(wszDevice);
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			// Just skip this part
		}

		GetVBConnSettings(desc, ConnectionSettings);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::SetConnectionSettings(long hTarget, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings, I_dxj_DirectPlayAddress *HostAddress, I_dxj_DirectPlayAddress *Device)
{
	DPL_CONNECTION_SETTINGS	desc;
	HRESULT					hr = S_OK;
	GUID					guidApp;
	GUID					guidInst;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];

	__try {
		ZeroMemory(&desc, sizeof(DPL_CONNECTION_SETTINGS));
		desc.dwSize = sizeof(DPL_CONNECTION_SETTINGS);
		desc.dwFlags = ConnectionSettings->lFlags;
		HostAddress->InternalGetObject((IUnknown**)&desc.pdp8HostAddress);
		Device->InternalGetObject((IUnknown**)desc.ppdp8DeviceAddresses);

		ZeroMemory(&desc.dpnAppDesc, sizeof(DPN_APPLICATION_DESC));

		// Set up our Desc
		desc.dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);

		if (!IsEmptyString(ConnectionSettings->ApplicationDescription.SessionName)) 
		{
			wcscpy(wszSessionName,ConnectionSettings->ApplicationDescription.SessionName);
			desc.dpnAppDesc.pwszSessionName = wszSessionName;
		}
		if (!IsEmptyString(ConnectionSettings->ApplicationDescription.Password)) 
		{
			wcscpy(wszPassword,ConnectionSettings->ApplicationDescription.Password);
			desc.dpnAppDesc.pwszPassword = wszPassword;
		}

		desc.dpnAppDesc.dwFlags = ConnectionSettings->ApplicationDescription.lFlags;

		desc.dpnAppDesc.dwMaxPlayers = ConnectionSettings->ApplicationDescription.lMaxPlayers;
		desc.dpnAppDesc.dwCurrentPlayers = ConnectionSettings->ApplicationDescription.lCurrentPlayers;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, ConnectionSettings->ApplicationDescription.guidApplication) ) )
			return hr;
		desc.dpnAppDesc.guidApplication = guidApp;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidInst, ConnectionSettings->ApplicationDescription.guidInstance) ) )
			return hr;
		desc.dpnAppDesc.guidInstance = guidInst;
		
		hr= m__dxj_DirectPlayLobbyClient->SetConnectionSettings((DPNHANDLE) hTarget, &desc, (DWORD) lFlags);
		if( FAILED(hr))
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbyClientObject::GetVBConnSettings(DPL_CONNECTION_SETTINGS *OldCon, DPL_CONNECTION_SETTINGS_CDESC *NewCon)
{
	IDirectPlay8Address *dpAdd = NULL;
	HRESULT hr;

	__try {
		NewCon->lSize = OldCon->dwSize;
		NewCon->lFlags = OldCon->dwFlags;
		NewCon->PlayerName = SysAllocString(OldCon->pwszPlayerName);

		ZeroMemory(&NewCon->ApplicationDescription, sizeof(DPN_APPLICATION_DESC_CDESC));

		// Set up our Desc
		NewCon->ApplicationDescription.lSize = OldCon->dpnAppDesc.dwSize;
		NewCon->ApplicationDescription.SessionName = SysAllocString(OldCon->dpnAppDesc.pwszSessionName);
		NewCon->ApplicationDescription.Password = SysAllocString(OldCon->dpnAppDesc.pwszPassword);
		NewCon->ApplicationDescription.lFlags = OldCon->dpnAppDesc.dwFlags;
		NewCon->ApplicationDescription.lMaxPlayers = OldCon->dpnAppDesc.dwMaxPlayers;
		NewCon->ApplicationDescription.lCurrentPlayers = OldCon->dpnAppDesc.dwCurrentPlayers;
		NewCon->ApplicationDescription.guidApplication = GUIDtoBSTR(&OldCon->dpnAppDesc.guidApplication);
		NewCon->ApplicationDescription.guidInstance = GUIDtoBSTR(&OldCon->dpnAppDesc.guidInstance);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

DWORD WINAPI CloseLobbyClientThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8LobbyClient	*lpPeer = (IDirectPlay8LobbyClient*)lpParam;

	DPF(1,"-----Entering (DPlayLobbiedApp) ClosePeerThreadProc call...\n");
	lpPeer->Close(0);
	DPF(1,"-----Leaving (DPlayLobbiedApp) ClosePeerThreadProc call ...\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplaylobbiedappobj.h ===
#include "resource.h"       // main symbols
#include "dplobby8.h"

#define typedef__dxj_DirectPlayLobbiedApplication IDirectPlay8LobbiedApplication*

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayLobbiedApplicationObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayLobbiedApplication, &IID_I_dxj_DirectPlayLobbiedApplication, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayLobbiedApplication,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayLobbiedApplicationObject() ;
	virtual ~C_dxj_DirectPlayLobbiedApplicationObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayLobbiedApplicationObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayLobbiedApplication)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayLobbiedApplicationObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayLobbiedApplication
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE RegisterMessageHandler(I_dxj_DirectPlayLobbyEvent *lobbyEvent, long *lDPNHandle);
		HRESULT STDMETHODCALLTYPE RegisterProgram(DPL_PROGRAM_DESC_CDESC *ProgramDesc,long lFlags);
		HRESULT STDMETHODCALLTYPE UnRegisterProgram(BSTR guidApplication,long lFlags);
		HRESULT STDMETHODCALLTYPE Send(long Target,SAFEARRAY **Buffer,long lBufferSize,long lFlags);
		HRESULT STDMETHODCALLTYPE SetAppAvailable(VARIANT_BOOL fAvailable, long lFlags);
		HRESULT STDMETHODCALLTYPE UpdateStatus(long LobbyClient, long lStatus);
		HRESULT STDMETHODCALLTYPE Close();
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();
		HRESULT STDMETHODCALLTYPE GetConnectionSettings(long hLobbyClient, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings);	
		HRESULT STDMETHODCALLTYPE SetConnectionSettings(long hTarget, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings, I_dxj_DirectPlayAddress *HostAddress, I_dxj_DirectPlayAddress *Device);
		HRESULT STDMETHODCALLTYPE GetVBConnSettings(DPL_CONNECTION_SETTINGS *OldCon, DPL_CONNECTION_SETTINGS_CDESC *NewCon);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayLobbiedApplication);

private:
	BOOL						m_fInit;

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayLobbiedApplication);

	DWORD InternalAddRef();
	DWORD InternalRelease();

	BOOL									m_fHandleEvents;
	IStream									*m_pEventStream;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplaylobbyclientobj.h ===
#include "resource.h"       // main symbols
#include "dplobby8.h"

#define typedef__dxj_DirectPlayLobbyClient IDirectPlay8LobbyClient*

/////////////////////////////////////////////////////////////////////////////
// Direct Net Peer

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class C_dxj_DirectPlayLobbyClientObject : 

#ifdef USING_IDISPATCH
	public CComDualImpl<I_dxj_DirectPlayLobbyClient, &IID_I_dxj_DirectPlayLobbyClient, &LIBID_DIRECTLib>, 
	public ISupportErrorInfo,
#else
	public I_dxj_DirectPlayLobbyClient,
#endif

	public CComObjectRoot
{
public:
	C_dxj_DirectPlayLobbyClientObject() ;
	virtual ~C_dxj_DirectPlayLobbyClientObject() ;

BEGIN_COM_MAP(C_dxj_DirectPlayLobbyClientObject)
	COM_INTERFACE_ENTRY(I_dxj_DirectPlayLobbyClient)
#ifdef USING_IDISPATCH
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
#endif
END_COM_MAP()

DECLARE_AGGREGATABLE(C_dxj_DirectPlayLobbyClientObject)

#ifdef USING_IDISPATCH
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
#endif

// I_dxj_DirectPlayLobbyClient
public:
	 /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalSetObject( 
            /* [in] */ IUnknown __RPC_FAR *lpdd);
        
         /* [hidden] */ HRESULT STDMETHODCALLTYPE InternalGetObject( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *lpdd);

		HRESULT STDMETHODCALLTYPE RegisterMessageHandler(I_dxj_DirectPlayLobbyEvent *lobbyEvent);
		HRESULT STDMETHODCALLTYPE GetCountLocalPrograms(BSTR GuidApplication,long *lCount);
		HRESULT STDMETHODCALLTYPE GetLocalProgram(long lProgID, DPL_APPLICATION_INFO_CDESC *app);
		HRESULT STDMETHODCALLTYPE ConnectApplication(DPL_CONNECT_INFO_CDESC *ConnectionInfo,long lTimeOut,long lFlags, long *hApplication);
		HRESULT STDMETHODCALLTYPE Send(long Target,SAFEARRAY **Buffer,long lBufferSize,long lFlags);
		HRESULT STDMETHODCALLTYPE ReleaseApplication(long Application);
		HRESULT STDMETHODCALLTYPE Close();
		HRESULT STDMETHODCALLTYPE UnRegisterMessageHandler();
		HRESULT STDMETHODCALLTYPE GetConnectionSettings(long hLobbyClient, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings);	
		HRESULT STDMETHODCALLTYPE SetConnectionSettings(long hTarget, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings, I_dxj_DirectPlayAddress *HostAddress, I_dxj_DirectPlayAddress *Device);
		HRESULT STDMETHODCALLTYPE GetVBConnSettings(DPL_CONNECTION_SETTINGS *OldCon, DPL_CONNECTION_SETTINGS_CDESC *NewCon);

////////////////////////////////////////////////////////////////////////
//
	// note: this is public for the callbacks
    DECL_VARIABLE(_dxj_DirectPlayLobbyClient);

private:
    DPL_APPLICATION_INFO		*m_ProgInfo;
	DWORD						m_dwAppCount;
	BOOL						m_fInit;

	HRESULT STDMETHODCALLTYPE	GetProgs(GUID *guidApp);

public:

	DX3J_GLOBAL_LINKS(_dxj_DirectPlayLobbyClient);

	DWORD InternalAddRef();
	DWORD InternalRelease();

	// We need these for our user data vars
	void			*m_pUserData;
	DWORD			m_dwUserDataSize;

	BOOL									m_fHandleEvents;
	IStream									*m_pEventStream;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplaylobbiedappobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "DPlayLobbiedAppObj.h"					   
#include "DplayAddressObj.h"

extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT BSTRtoGUID(LPGUID,BSTR);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

extern void *g_dxj_DirectPlayLobbiedApplication;
extern void *g_dxj_DirectPlayAddress;

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { (p)->Release(); (p)=NULL;} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

DWORD WINAPI CloseLobbiedAppThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayLobbiedApplicationObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"------ DXVB: DirectPlayLobbiedApplication8 AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayLobbiedApplicationObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"------ DXVB: DirectPlayLobbiedApplication8 Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayLobbiedApplicationObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayLobbiedApplicationObject::C_dxj_DirectPlayLobbiedApplicationObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation DirectPlayLobbiedApplication8 \n ");

	m__dxj_DirectPlayLobbiedApplication = NULL;
	m_fInit = FALSE;

	m_fHandleEvents = FALSE;
	m_pEventStream=NULL;
}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayLobbiedApplicationObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayLobbiedApplicationObject::~C_dxj_DirectPlayLobbiedApplicationObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectPlayLobbiedApplicationObject destructor \n");

	SAFE_RELEASE(m__dxj_DirectPlayLobbiedApplication);

	m_fHandleEvents = FALSE;

	if (m_pEventStream) 
		m_pEventStream->Release();
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayLobbiedApplication;
	
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayLobbiedApplication=(IDirectPlay8LobbiedApplication*)pUnk;
	return S_OK;
}

HRESULT WINAPI DirectPlayLobbiedAppMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer )
{
	HRESULT					hr=S_OK;
	BOOL					fCallCoUninit = FALSE;
	VARIANT_BOOL			fRejectMsg = VARIANT_FALSE;

	// User context for the message handler is a pointer to our class module.
	C_dxj_DirectPlayLobbiedApplicationObject	*lpPeer = (C_dxj_DirectPlayLobbiedApplicationObject*)pvUserContext;
	DPF(1,"-----Entering (DPlayLobbiedApp) MessageHandler call...\n");
	
	if (!lpPeer) return E_FAIL;
	if (!lpPeer->m_pEventStream) return E_FAIL;

	if (!lpPeer->m_fHandleEvents)
		return S_OK;

	// First we need to set our stream seek back to the beginning
	// We will do this every time we enter this function since we don't know if
	// we are on the same thread or not...
		I_dxj_DirectPlayLobbyEvent	*lpEvent = NULL;
	__try {
		LARGE_INTEGER l;
		l.QuadPart = 0;
		lpPeer->m_pEventStream->Seek(l, STREAM_SEEK_SET, NULL);

		hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
		if (hr == CO_E_NOTINITIALIZED) // Call CoInit so we can unmarshal
		{
			CoInitialize(NULL);
			hr = CoUnmarshalInterface(lpPeer->m_pEventStream, IID_I_dxj_DirectPlayEvent, (void**)&lpEvent);
			fCallCoUninit = TRUE;
		}

		if (!lpEvent) 
		{
			DPF(1,"-----Leaving (DplayLobbyClient) MessageHandler call (No event interface)...\n");
			return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		DPF(1,"-----Leaving (DplayLobbyClient) MessageHandler call (Stream Gone)...\n");
		return S_OK;
	}

    switch( dwMessageId )
	{
	//Receive
	case DPL_MSGID_RECEIVE:
		{
			DPL_MESSAGE_RECEIVE			*msg = (DPL_MESSAGE_RECEIVE*)pMsgBuffer;
			SAFEARRAY					*lpData = NULL;
			SAFEARRAYBOUND				rgsabound[1];
			DPL_MESSAGE_RECEIVE_CDESC	m_dpReceive;
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpReceive, sizeof(DPL_MESSAGE_RECEIVE));
			m_dpReceive.Sender = (long)msg->hSender;
			
			// Let's load our SafeArray

			if (msg->dwBufferSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwBufferSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pBuffer;
				m_dpReceive.lBufferSize = msg->dwBufferSize;
				m_dpReceive.Buffer = lpData;
			}

			lpEvent->Receive(&m_dpReceive, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}
			
			break;
		}

	//Connect
	case DPL_MSGID_CONNECT:
		{
			DPL_MESSAGE_CONNECT				*msg = (DPL_MESSAGE_CONNECT*)pMsgBuffer;
			DPNHANDLE						m_hConnectID;
			DPL_MESSAGE_CONNECT_CDESC		m_dpConnection;
			SAFEARRAY						*lpData = NULL;
			SAFEARRAYBOUND					rgsabound[1];
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];
			DWORD									dwNumChars = 0;
			BYTE						*lpTemp = NULL;

			ZeroMemory(&m_dpConnection, sizeof(DPL_MESSAGE_CONNECT_CDESC));
			m_dpConnection.ConnectId = (long)msg->hConnectId;
			// Let's load our SafeArray

			if (msg->dwLobbyConnectDataSize)
			{
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = msg->dwLobbyConnectDataSize;
				
				lpData = SafeArrayCreate(VT_UI1, 1, rgsabound);

				lpTemp = (BYTE*)lpData->pvData;
				lpData->pvData = msg->pvLobbyConnectData;
				
				m_dpConnection.LobbyConnectData = lpData;
			}

			lpPeer->GetVBConnSettings(msg->pdplConnectionSettings, &m_dpConnection.dplMsgCon);

			__try {
				if (msg->pdplConnectionSettings->pdp8HostAddress)
				{
					hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
						return hr;

					if (FAILED (hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(&wszAddress[0],&dwNumChars) ) )
						return hr;

					m_dpConnection.dplMsgCon.AddressSenderUrl = SysAllocString(wszAddress);
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			__try {
				dwNumChars = 0;
				if ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)
				{
					hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
						return hr;

					if (FAILED (hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(&wszDevice[0],&dwNumChars) ) )
						return hr;

					m_dpConnection.dplMsgCon.AddressDeviceUrl = SysAllocString(wszDevice);
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			lpEvent->Connect(&m_dpConnection, &fRejectMsg);

			if (lpData) //Get rid of the safearray
			{
				lpData->pvData = lpTemp;
				SafeArrayDestroy(lpData);
			}

			// Get rid of these addresses
			if (m_dpConnection.dplMsgCon.AddressSenderUrl)
				SysFreeString(m_dpConnection.dplMsgCon.AddressSenderUrl);

			if (m_dpConnection.dplMsgCon.AddressDeviceUrl)
				SysFreeString(m_dpConnection.dplMsgCon.AddressDeviceUrl);
			
		break;
		}

	//Disconnect
	case DPL_MSGID_DISCONNECT:
		{
			DPL_MESSAGE_DISCONNECT				*msg = (DPL_MESSAGE_DISCONNECT*)pMsgBuffer;
			DPNHANDLE								m_hDisconnectID;
			HRESULT									m_hDisconnectReason;

			m_hDisconnectID = (long)msg->hDisconnectId;
			m_hDisconnectReason = (long) msg->hrReason;

			lpEvent->Disconnect(m_hDisconnectID, m_hDisconnectReason);
			
			break;
		}

	//Status
	case DPL_MSGID_SESSION_STATUS:
		{
			DPL_MESSAGE_SESSION_STATUS			*msg = (DPL_MESSAGE_SESSION_STATUS*)pMsgBuffer;
			DPNHANDLE								m_hSender;
			DWORD									m_dwSessionStatus;

			m_dwSessionStatus = (long)msg->dwStatus;
			m_hSender = (long)msg->hSender;
	
			lpEvent->SessionStatus(m_dwSessionStatus,m_hSender);

		break;
		}

	//ConnectionSettings
	case DPL_MSGID_CONNECTION_SETTINGS:
		{
			DPL_MESSAGE_CONNECTION_SETTINGS			*msg = (DPL_MESSAGE_CONNECTION_SETTINGS*)pMsgBuffer;
			DPL_MESSAGE_CONNECTION_SETTINGS_CDESC	dpCon;
			WCHAR									wszAddress[MAX_PATH];
			WCHAR									wszDevice[MAX_PATH];
			DWORD									dwNumChars = 0;

			ZeroMemory(&dpCon, sizeof(DPL_MESSAGE_CONNECTION_SETTINGS_CDESC));

			lpPeer->GetVBConnSettings(msg->pdplConnectionSettings, &dpCon.dplConnectionSettings);
			dpCon.hSender = (long)msg->hSender;
			__try {
				if (msg->pdplConnectionSettings->pdp8HostAddress)
				{
					hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
						return hr;

					if (FAILED (hr = msg->pdplConnectionSettings->pdp8HostAddress->GetURLW(&wszAddress[0],&dwNumChars) ) )
						return hr;

					dpCon.dplConnectionSettings.AddressSenderUrl = SysAllocString(wszAddress);
				}
			}	
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}

			__try {
				dwNumChars = 0;
				if ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)
				{
					hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
					if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
						return hr;

					if (FAILED (hr = ((IDirectPlay8Address*)*msg->pdplConnectionSettings->ppdp8DeviceAddresses)->GetURLW(&wszDevice[0],&dwNumChars) ) )
						return hr;

					dpCon.dplConnectionSettings.AddressDeviceUrl = SysAllocString(wszDevice);
				}
			}
			__except(EXCEPTION_EXECUTE_HANDLER)
			{
				// Just skip this part
			}
			lpEvent->ConnectionSettings(&dpCon);
			// Get rid of these addresses
			if (dpCon.dplConnectionSettings.AddressSenderUrl)
				SysFreeString(dpCon.dplConnectionSettings.AddressSenderUrl);

			if (dpCon.dplConnectionSettings.AddressDeviceUrl)
				SysFreeString(dpCon.dplConnectionSettings.AddressDeviceUrl);

		break;
		}
	}

	__try {
		if (lpPeer->m_pEventStream)
				// clean up marshaled packet
			CoReleaseMarshalData(lpPeer->m_pEventStream);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		lpPeer->m_fHandleEvents = FALSE;
		return S_OK;
	}

	if (fCallCoUninit)
		CoUninitialize();

	DPF(1,"-----Leaving (DPlayLobbiedApp) MessageHandler call...\n");

	if (fRejectMsg != VARIANT_FALSE)
		return E_FAIL;

	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::RegisterMessageHandler(I_dxj_DirectPlayLobbyEvent *lobbyEvent, long *lDPNHandle)
{
    HRESULT	  hr=S_OK;
    LPSTREAM  pStm=NULL;
    IUnknown *pUnk=NULL;

	DPF(1,"-----Entering (DPlayLobbiedApp) RegisterMessageHandler call...\n");
	if (!lobbyEvent) return E_INVALIDARG;
    
    if (!m_fHandleEvents)
	{
		if (m_pEventStream) 
			m_pEventStream->Release();

    
		// Create a global stream.  The stream needs to be global so we can 
		// marshal once, and unmarshal as many times as necessary
		hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);
		if FAILED(hr) return hr;

		// Now we can marshal our IUnknown interface.  We use MSHLFLAGS_TABLEWEAK 
		// so we can unmarshal any number of times
		hr = CoMarshalInterface(pStm, IID_I_dxj_DirectPlayLobbyEvent, lobbyEvent, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLEWEAK);
		if FAILED(hr) return hr;

		// Now we need to set the seek location of the stream to the beginning
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStm->Seek(l, STREAM_SEEK_SET, NULL);
    
		m_pEventStream=pStm;

		if (!m_fInit)
		{
			if (FAILED ( hr = m__dxj_DirectPlayLobbiedApplication->Initialize( this, DirectPlayLobbiedAppMessageHandler, (DPNHANDLE*) lDPNHandle, 0 ) ) )
				return hr;
			m_fInit = TRUE;
		}
		m_fHandleEvents = TRUE;
	}
	else
		return DPNERR_ALREADYINITIALIZED;

	return hr;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::RegisterProgram(DPL_PROGRAM_DESC_CDESC *ProgramDesc,long lFlags)
{
	HRESULT hr;
	DPL_PROGRAM_DESC dpProg;
	GUID guidApp;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) RegisterProgram call...\n");
		ZeroMemory(&guidApp, sizeof(GUID));
		if (FAILED (hr = BSTRtoGUID(&guidApp, ProgramDesc->guidApplication) ) )
			return hr;

		ZeroMemory(&dpProg, sizeof(DPL_PROGRAM_DESC) );
		// Fill out our struct
		dpProg.dwSize = sizeof(DPL_PROGRAM_DESC);
		dpProg.dwFlags = ProgramDesc->lFlags;
		dpProg.guidApplication = guidApp;
		dpProg.pwszApplicationName = ProgramDesc->ApplicationName;
		dpProg.pwszCommandLine = ProgramDesc->CommandLine;
		dpProg.pwszCurrentDirectory = ProgramDesc->CurrentDirectory;
		dpProg.pwszDescription = ProgramDesc->Description;
		dpProg.pwszExecutableFilename = ProgramDesc->ExecutableFilename;
		dpProg.pwszExecutablePath = ProgramDesc->ExecutablePath;
		dpProg.pwszLauncherFilename = ProgramDesc->LauncherFilename;
		dpProg.pwszLauncherPath = ProgramDesc->LauncherPath;

		if (FAILED( hr = m__dxj_DirectPlayLobbiedApplication->RegisterProgram(&dpProg, (DWORD) lFlags) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::UnRegisterProgram(BSTR guidApplication,long lFlags)
{
	HRESULT hr;
	GUID guidApp;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) UnregisterProgram call...\n");
		ZeroMemory(&guidApp, sizeof(GUID));
		if (FAILED (hr = BSTRtoGUID(&guidApp, guidApplication) ) )
			return hr;

		if (FAILED (hr = m__dxj_DirectPlayLobbiedApplication->UnRegisterProgram(&guidApp,(DWORD) lFlags) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::Send(long Target,SAFEARRAY **Buffer,long lBufferSize,long lFlags)
{
	HRESULT hr;
	DWORD				dwBufferSize = 0;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) Send call...\n");
		dwBufferSize = (DWORD)lBufferSize;

		hr = m__dxj_DirectPlayLobbiedApplication->Send((DPNHANDLE) Target, (BYTE*)((SAFEARRAY*)*Buffer)->pvData, dwBufferSize, (DWORD) lFlags);
		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::SetAppAvailable(VARIANT_BOOL fAvailable, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) SetAppAvailable call...\n");
		if (fAvailable == VARIANT_TRUE)
		{
			if (FAILED (hr = m__dxj_DirectPlayLobbiedApplication->SetAppAvailable(TRUE, (DWORD) lFlags) ) )
				return hr;
		}
		else
		{
			if (FAILED (hr = m__dxj_DirectPlayLobbiedApplication->SetAppAvailable(FALSE, (DWORD) lFlags) ) )
				return hr;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

#if 0
HRESULT C_dxj_DirectPlayLobbiedApplicationObject::WaitForConnection(long lMilliseconds)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) WaitForConnection call...\n");
		if (FAILED (hr = m__dxj_DirectPlayLobbiedApplication->WaitForConnection((DWORD) lMilliseconds, 0 ) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}
#endif
HRESULT C_dxj_DirectPlayLobbiedApplicationObject::UpdateStatus(long LobbyClient, long lStatus)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) UpdateStatus call...\n");
		if (FAILED (hr = m__dxj_DirectPlayLobbiedApplication->UpdateStatus((DPNHANDLE) LobbyClient, (DWORD) lStatus, 0 ) ) )
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::Close()
{
	HRESULT hr; 
	BOOL bGotMsg = FALSE;
	BOOL bWait = FALSE;
	DWORD dwObj = 0;
	int i=0;
	MSG msg;

	__try {
		DPF(1,"-----Entering (DPlayLobbiedApp) Close call...\n");
		HANDLE hThread = NULL;
		DWORD dwThread = 0;

		hThread = CreateThread(NULL, 0, &CloseLobbiedAppThreadProc, this->m__dxj_DirectPlayLobbiedApplication, 0, &dwThread);
		msg.message = WM_NULL;

		while ((WM_QUIT != msg.message) && (!bWait))
		{
			bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
			i++;
			if ((!bGotMsg) || (i>10))
			{
				dwObj = WaitForSingleObject(hThread, 10);
				bWait = (dwObj == WAIT_OBJECT_0);
				i = 0;
			}
			if (bGotMsg)
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}
			bGotMsg = FALSE;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}

	return S_OK;
}


HRESULT C_dxj_DirectPlayLobbiedApplicationObject::UnRegisterMessageHandler()
{
	DPF(1,"-----Entering (DPlayLobbiedApp) UnregisterMessageHandler call...\n");
	m_fHandleEvents = FALSE;
	return S_OK;
}


HRESULT C_dxj_DirectPlayLobbiedApplicationObject::GetConnectionSettings(long hLobbyClient, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings)
{
	DPL_CONNECTION_SETTINGS	*desc = NULL;
	DWORD					dwSize = 0;
	HRESULT					hr = S_OK;
	WCHAR									wszAddress[MAX_PATH];
	WCHAR									wszDevice[MAX_PATH];
	DWORD									dwNumChars = 0;

	__try {
		hr= m__dxj_DirectPlayLobbiedApplication->GetConnectionSettings((DPNHANDLE) hLobbyClient, NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		desc = (DPL_CONNECTION_SETTINGS*)new BYTE[dwSize];
		desc->dwSize = sizeof(DPL_CONNECTION_SETTINGS);

		hr= m__dxj_DirectPlayLobbiedApplication->GetConnectionSettings((DPNHANDLE) hLobbyClient, desc, &dwSize, (DWORD) lFlags);
		if( FAILED(hr))
			return hr;
		__try {
			hr = desc->pdp8HostAddress->GetURLW(NULL, &dwNumChars);
			if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				return hr;

			if (FAILED (hr = desc->pdp8HostAddress->GetURLW(&wszAddress[0],&dwNumChars) ) )
				return hr;

			ConnectionSettings->AddressSenderUrl = SysAllocString(wszAddress);
		}	
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			// Just skip this part
		}

		__try {
			dwNumChars = 0;
			hr = ((IDirectPlay8Address*)*desc->ppdp8DeviceAddresses)->GetURLW(NULL, &dwNumChars);
			if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
				return hr;

			if (FAILED (hr = ((IDirectPlay8Address*)*desc->ppdp8DeviceAddresses)->GetURLW(&wszDevice[0],&dwNumChars) ) )
				return hr;

			ConnectionSettings->AddressDeviceUrl = SysAllocString(wszDevice);
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			// Just skip this part
		}
		GetVBConnSettings(desc, ConnectionSettings);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::SetConnectionSettings(long hTarget, long lFlags, DPL_CONNECTION_SETTINGS_CDESC *ConnectionSettings, I_dxj_DirectPlayAddress *HostAddress, I_dxj_DirectPlayAddress *Device)
{
	DPL_CONNECTION_SETTINGS	desc;
	HRESULT					hr = S_OK;
	GUID					guidApp;
	GUID					guidInst;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];

	__try {
		ZeroMemory(&desc, sizeof(DPL_CONNECTION_SETTINGS));
		desc.dwSize = sizeof(DPL_CONNECTION_SETTINGS);
		desc.dwFlags = ConnectionSettings->lFlags;
		HostAddress->InternalGetObject((IUnknown**)&desc.pdp8HostAddress);
		Device->InternalGetObject((IUnknown**)desc.ppdp8DeviceAddresses);

		ZeroMemory(&desc.dpnAppDesc, sizeof(DPN_APPLICATION_DESC));

		// Set up our Desc
		desc.dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);

		if (!IsEmptyString(ConnectionSettings->ApplicationDescription.SessionName)) 
		{
			wcscpy(wszSessionName,ConnectionSettings->ApplicationDescription.SessionName);
			desc.dpnAppDesc.pwszSessionName = wszSessionName;
		}
		if (!IsEmptyString(ConnectionSettings->ApplicationDescription.Password)) 
		{
			wcscpy(wszPassword,ConnectionSettings->ApplicationDescription.Password);
			desc.dpnAppDesc.pwszPassword = wszPassword;
		}

		desc.dpnAppDesc.dwFlags = ConnectionSettings->ApplicationDescription.lFlags;

		desc.dpnAppDesc.dwMaxPlayers = ConnectionSettings->ApplicationDescription.lMaxPlayers;
		desc.dpnAppDesc.dwCurrentPlayers = ConnectionSettings->ApplicationDescription.lCurrentPlayers;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, ConnectionSettings->ApplicationDescription.guidApplication) ) )
			return hr;
		desc.dpnAppDesc.guidApplication = guidApp;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidInst, ConnectionSettings->ApplicationDescription.guidInstance) ) )
			return hr;
		desc.dpnAppDesc.guidInstance = guidInst;
		
		hr= m__dxj_DirectPlayLobbiedApplication->SetConnectionSettings((DPNHANDLE) hTarget, &desc, (DWORD) lFlags);
		if( FAILED(hr))
			return hr;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayLobbiedApplicationObject::GetVBConnSettings(DPL_CONNECTION_SETTINGS *OldCon, DPL_CONNECTION_SETTINGS_CDESC *NewCon)
{
	IDirectPlay8Address *dpAdd = NULL;
	HRESULT hr;

	__try {
		NewCon->lSize = OldCon->dwSize;
		NewCon->lFlags = OldCon->dwFlags;
		NewCon->PlayerName = SysAllocString(OldCon->pwszPlayerName);

		ZeroMemory(&NewCon->ApplicationDescription, sizeof(DPN_APPLICATION_DESC_CDESC));

		// Set up our Desc
		NewCon->ApplicationDescription.lSize = OldCon->dpnAppDesc.dwSize;
		NewCon->ApplicationDescription.SessionName = SysAllocString(OldCon->dpnAppDesc.pwszSessionName);
		NewCon->ApplicationDescription.Password = SysAllocString(OldCon->dpnAppDesc.pwszPassword);
		NewCon->ApplicationDescription.lFlags = OldCon->dpnAppDesc.dwFlags;
		NewCon->ApplicationDescription.lMaxPlayers = OldCon->dpnAppDesc.dwMaxPlayers;
		NewCon->ApplicationDescription.lCurrentPlayers = OldCon->dpnAppDesc.dwCurrentPlayers;
		NewCon->ApplicationDescription.guidApplication = GUIDtoBSTR(&OldCon->dpnAppDesc.guidApplication);
		NewCon->ApplicationDescription.guidInstance = GUIDtoBSTR(&OldCon->dpnAppDesc.guidInstance);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

DWORD WINAPI CloseLobbiedAppThreadProc(void* lpParam)
{
	// User context for the message handler is a pointer to our class module.
	IDirectPlay8LobbiedApplication	*lpPeer = (IDirectPlay8LobbiedApplication*)lpParam;

	DPF(1,"-----Entering (DPlayLobbiedApp) ClosePeerThreadProc call...\n");
	lpPeer->Close(0);
	DPF(1,"-----Leaving (DPlayLobbiedApp) ClosePeerThreadProc call ...\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxvb\dx8vb\dplaypeerobj.cpp ===
#include "stdafx.h"
#include "Direct.h"
#include "dms.h"
#include "dplayaddressobj.h"
#include "DPlayPeerObj.h"					   

extern void *g_dxj_DirectPlayPeer;
extern void *g_dxj_DirectPlayAddress;
extern BSTR GUIDtoBSTR(LPGUID);
extern HRESULT DPLAYBSTRtoGUID(LPGUID,BSTR);
extern BOOL IsEmptyString(BSTR szString);

#define SAFE_DELETE(p)       { if(p) { delete (p); p=NULL; } }
#define SAFE_RELEASE(p)      { __try { if(p) { int i = 0; i = (p)->Release(); DPF1(1,"--DirectPlayPeer SafeRelease (RefCount = %d)\n",i); if (!i) { (p)=NULL;}} 	}	__except(EXCEPTION_EXECUTE_HANDLER) { (p) = NULL;} } 

HRESULT WINAPI DirectPlayMessageHandler( PVOID pvUserContext, 
                                         DWORD dwMessageId, 
                                         PVOID pMsgBuffer );

DWORD WINAPI ClosePeerThreadProc(void* lpParam);

///////////////////////////////////////////////////////////////////
// InternalAddRef
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayPeerObject::InternalAddRef(){
	DWORD i;
	i=CComObjectRoot::InternalAddRef();
	DPF1(1,"------ DXVB: DirectPlayPeer8 AddRef %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// InternalRelease
///////////////////////////////////////////////////////////////////
DWORD C_dxj_DirectPlayPeerObject::InternalRelease(){
	DWORD i;
	i=CComObjectRoot::InternalRelease();
	DPF1(1,"------ DXVB: DirectPlayPeer8 Release %d \n",i);
	return i;
}

///////////////////////////////////////////////////////////////////
// C_dxj_DirectPlayPeerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayPeerObject::C_dxj_DirectPlayPeerObject(){ 
		
	DPF(1,"------ DXVB: Constructor Creation  DirectPlayPeer8 Object\n ");

	m__dxj_DirectPlayPeer = NULL;
	m_SPInfo = NULL;
	m_dwSPCount = 0;
	m_ClientsGroups = NULL;
	m_GroupMembers = NULL;
	m_dwGroupID = 0;
	m_dwClientCount = 0;
	m_dwGroupMemberCount = 0;
	m_fInit = FALSE;

	m_pUserData = NULL;
	m_fHandleEvents = FALSE;
	m_dwUserDataSize = 0;
	m_pReplyData = NULL;
	m_dwReplyDataSize = 0;

	m_pEventStream=NULL;
	m_dwMsgCount = 0;

}

///////////////////////////////////////////////////////////////////
// ~C_dxj_DirectPlayPeerObject
///////////////////////////////////////////////////////////////////
C_dxj_DirectPlayPeerObject::~C_dxj_DirectPlayPeerObject()
{

	DPF(1,"------ DXVB: Entering ~C_dxj_DirectPlayPeerObject destructor \n");

	//We still have messages to process get rid of them
	m_fHandleEvents = FALSE;
	FlushBuffer(0);

	SAFE_RELEASE(m__dxj_DirectPlayPeer);
	SAFE_RELEASE(m_pEventStream);
	SAFE_DELETE(m_SPInfo);
	SAFE_DELETE(m_ClientsGroups);
	SAFE_DELETE(m_GroupMembers);
	SAFE_DELETE(m_pReplyData);

	
}

HRESULT C_dxj_DirectPlayPeerObject::InternalGetObject(IUnknown **pUnk){	
	*pUnk=(IUnknown*)m__dxj_DirectPlayPeer;
	
	return S_OK;
}
HRESULT C_dxj_DirectPlayPeerObject::InternalSetObject(IUnknown *pUnk){
	m__dxj_DirectPlayPeer=(IDirectPlay8Peer*)pUnk;
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::CancelAsyncOperation(long lAsyncHandle, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) CancelAsyncOp call...\n");
		if (FAILED( hr= m__dxj_DirectPlayPeer->CancelAsyncOperation((DPNHANDLE) lAsyncHandle, (DWORD) lFlags) ) ) 
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetApplicationDesc(long lFlags, DPN_APPLICATION_DESC_CDESC *ret)
{
	HRESULT					hr;
	DWORD					dwSize = 0;
	DPN_APPLICATION_DESC	*desc = NULL;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetAppDesc call...\n");
		//First get the size
		hr = m__dxj_DirectPlayPeer->GetApplicationDesc(NULL, &dwSize, (DWORD) lFlags);
		if( FAILED(hr) && hr != DPNERR_BUFFERTOOSMALL)
			return hr;

		desc = (DPN_APPLICATION_DESC*) new BYTE[dwSize];
		if (!desc)
			return E_OUTOFMEMORY;

		ZeroMemory(desc, dwSize);

		desc->dwSize = sizeof(DPN_APPLICATION_DESC);
		if (FAILED( hr= m__dxj_DirectPlayPeer->GetApplicationDesc(desc, &dwSize, (DWORD) lFlags) ) )
			return hr;

		// Now return the vals 
		ret->lSize = dwSize;
		ret->lFlags = desc->dwFlags;
		ret->guidInstance = GUIDtoBSTR(&desc->guidInstance);
		ret->guidApplication = GUIDtoBSTR(&desc->guidApplication);
		ret->lMaxPlayers = desc->dwMaxPlayers;
		ret->lCurrentPlayers = desc->dwCurrentPlayers;
		ret->SessionName = SysAllocString(desc->pwszSessionName);
		ret->Password = SysAllocString(desc->pwszPassword);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}


HRESULT C_dxj_DirectPlayPeerObject::SetApplicationDesc(DPN_APPLICATION_DESC_CDESC *AppDesc, long lFlags)
{
	HRESULT					hr;
	DPN_APPLICATION_DESC	*desc = NULL;
	GUID					guidApp;
	GUID					guidInst;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];

	__try {
		DPF(1,"-----Entering (DplayPeer) SetAppDesc call...\n");
	
		desc = (DPN_APPLICATION_DESC*) new BYTE[AppDesc->lSize];
		if (!desc)
			return E_OUTOFMEMORY;

		ZeroMemory(desc, AppDesc->lSize);

		// Set up our Desc
		desc->dwSize = sizeof(DPN_APPLICATION_DESC);

		if (!IsEmptyString(AppDesc->SessionName))
		{
			wcscpy(wszSessionName,AppDesc->SessionName);
			desc->pwszSessionName = wszSessionName;
		}
		if (!IsEmptyString(AppDesc->Password))
		{
			wcscpy(wszPassword,AppDesc->Password);
			desc->pwszPassword = wszPassword;
		}

		desc->dwFlags = AppDesc->lFlags;

		desc->dwMaxPlayers = AppDesc->lMaxPlayers;
		desc->dwCurrentPlayers = AppDesc->lCurrentPlayers;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidApp, AppDesc->guidApplication) ) )
			return hr;
		desc->guidApplication = guidApp;

		if (FAILED(hr = DPLAYBSTRtoGUID(&guidInst, AppDesc->guidInstance) ) )
			return hr;
		desc->guidInstance = guidInst;
		
		if (FAILED( hr= m__dxj_DirectPlayPeer->SetApplicationDesc(desc, (DWORD) lFlags) ) )
			return hr;

		SAFE_DELETE(desc);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::Close(long lFlags)
{
	HRESULT hr;
	BOOL bGotMsg = FALSE;
	BOOL bWait = FALSE;
	DWORD dwObj = 0;
	int i=0;
	MSG msg;


	__try {
		DPF(1,"-----Entering (DplayPeer) Close call...\n");
		FlushBuffer(0);

		HANDLE hThread = NULL;
		DWORD dwThread = 0;

		hThread = CreateThread(NULL, 0, &ClosePeerThreadProc, this->m__dxj_DirectPlayPeer, 0, &dwThread);
		msg.message = WM_NULL;

		while ((WM_QUIT != msg.message) && (!bWait))
		{
			bGotMsg = PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE);
			i++;
			if ((!bGotMsg) || (i>10))
			{
				dwObj = WaitForSingleObject(hThread, 10);
				bWait = (dwObj == WAIT_OBJECT_0);
				i = 0;
			}
			if (bGotMsg)
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}
			bGotMsg = FALSE;
		}

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	DPF(1,"-----Leaving (DplayPeer) Close call...\n");
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetCaps(long lFlags, DPNCAPS_CDESC *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetCaps call...\n");
		ret->lSize = sizeof(DPN_CAPS);
		if (FAILED (hr=m__dxj_DirectPlayPeer->GetCaps( (DPN_CAPS*) ret, (DWORD) lFlags) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::SetCaps(DPNCAPS_CDESC *Caps, long lFlags)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) SetCaps call...\n");
		if (FAILED( hr = m__dxj_DirectPlayPeer->SetCaps((DPN_CAPS*)Caps, (DWORD)lFlags)))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::DestroyGroup(long idGroup,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) DestroyGroup call...\n");
		hr= m__dxj_DirectPlayPeer->DestroyGroup((DPNID) idGroup, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::RemovePlayerFromGroup(long idGroup, long idClient,long lFlags, long *hAsyncHandle)
{
	HRESULT hr;
	DPNHANDLE			*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) RemovePlayerFromGroup call...\n");
		hr = m__dxj_DirectPlayPeer->RemovePlayerFromGroup( (DPNID) idGroup,
						(DPNID) idClient, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::DestroyPeer(long idClient, long lFlags, void *UserData, long UserDataSize)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) DestroyPeer call...\n");
		if (FAILED( hr= m__dxj_DirectPlayPeer->DestroyPeer((DPNID) idClient, UserData, UserDataSize, (DWORD) lFlags) ))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::Connect(DPN_APPLICATION_DESC_CDESC *AppDesc,I_dxj_DirectPlayAddress *Address,I_dxj_DirectPlayAddress *DeviceInfo, long lFlags, void *UserData, long UserDataSize, long *hAsyncHandle)
{
	HRESULT hr;
	DPN_APPLICATION_DESC	desc;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];
	DPNHANDLE				*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) Connect call...\n");
		if (!IsEmptyString(AppDesc->SessionName)) wcscpy(wszSessionName,AppDesc->SessionName);
		if (!IsEmptyString(AppDesc->Password)) wcscpy(wszPassword,AppDesc->Password);

		ZeroMemory(&desc, sizeof(desc));

		// Set up our Desc
		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = AppDesc->lFlags;

		desc.dwMaxPlayers = AppDesc->lMaxPlayers;
		desc.dwCurrentPlayers = AppDesc->lCurrentPlayers;
		if (!IsEmptyString(AppDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(AppDesc->Password))
			desc.pwszPassword = wszPassword;

		if (AppDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidApplication, AppDesc->guidApplication) ) )
				return hr;
		}

		if (AppDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidInstance , AppDesc->guidInstance) ) )
				return hr;
		}

		// Get our host and device address
		IDirectPlay8Address	*lpAddress = NULL;
		IDirectPlay8Address	*lpDevice = NULL;

		if(Address) 
		{ 
			Address->InternalGetObject((IUnknown **)(&lpAddress));
		}

		if(DeviceInfo) 
		{
			DeviceInfo->InternalGetObject((IUnknown **)(&lpDevice));
		}

		// Time to connect
		hr = m__dxj_DirectPlayPeer->Connect(&desc, lpAddress, lpDevice, NULL, NULL, UserData, (DWORD)UserDataSize, NULL, NULL, dpAsync, (DWORD) lFlags);

		if (dpAsync)
		{
			*hAsyncHandle = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}

		if ((hr != DPNERR_PENDING) && FAILED(hr))
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetCountPlayersAndGroups(long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetCountPlayersAndGroups call...\n");
		// On the GetCount call we will always get the latest info
		if (FAILED ( hr = GetClientsAndGroups(lFlags) ) )
			return hr;
		
		*ret = m_dwClientCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetPlayerOrGroup(long lIndex, long *ret)
{
	__try {
		DPF(1,"-----Entering (DplayPeer) GetPlayerOrGroup call...\n");
		if (!m_ClientsGroups)
			return E_INVALIDARG;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwClientCount))
			return E_INVALIDARG;

		// Fill out our structure
		*ret = m_ClientsGroups[lIndex - 1];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetCountGroupMembers(long dpid,long lFlags, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetCountGroupMembers call...\n");
		// On the GetCount call we will always get the latest info
		if (FAILED ( hr = GetGroupMembers(lFlags, (DPNID) dpid) ) )
			return hr;
		
		*ret = m_dwGroupMemberCount;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::GetGroupMember(long lIndex,long dpid, long *ret)
{
	HRESULT hr;

	__try {
		DPF(1,"-----Entering (DplayPeer) GetGroupMember call...\n");
		if ((!m_GroupMembers) || ((DPNID)dpid != m_dwGroupID) )
			if (FAILED (hr = GetGroupMembers(0, (DPNID) dpid) ) )
				return hr;

		if ((lIndex < 1 ) || ((DWORD)lIndex > m_dwGroupMemberCount))
			return E_INVALIDARG;

		if (!m_GroupMembers)
			return E_INVALIDARG;

		// Fill out our structure
		*ret = m_GroupMembers[lIndex - 1];
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::EnumHosts(DPN_APPLICATION_DESC_CDESC *ApplicationDesc,I_dxj_DirectPlayAddress *AddrHost,I_dxj_DirectPlayAddress *DeviceInfo,long lRetryCount, long lRetryInterval, long lTimeOut,long lFlags, void *UserData, long UserDataSize, long *lAsync)
{
	HRESULT					hr;
	DPN_APPLICATION_DESC	desc;
    WCHAR					wszSessionName[MAX_PATH];
    WCHAR					wszPassword[MAX_PATH];
	DPNHANDLE				*dpAsync = NULL;

	__try {
		if (!(lFlags & DPNSEND_SYNC))
		{
			dpAsync = new DPNHANDLE;
			if (!dpAsync)
				return E_OUTOFMEMORY;
		}

		DPF(1,"-----Entering (DplayPeer) EnumHosts call...\n");
		if (!IsEmptyString(ApplicationDesc->SessionName)) wcscpy(wszSessionName,ApplicationDesc->SessionName);
		if (!IsEmptyString(ApplicationDesc->Password)) wcscpy(wszPassword,ApplicationDesc->Password);

		ZeroMemory(&desc, sizeof(desc));

		// Set up our Desc
		desc.dwSize = sizeof(DPN_APPLICATION_DESC);
		desc.dwFlags = ApplicationDesc->lFlags;

		desc.dwMaxPlayers = ApplicationDesc->lMaxPlayers;
		desc.dwCurrentPlayers = ApplicationDesc->lCurrentPlayers;
		if (!IsEmptyString(ApplicationDesc->SessionName))
			desc.pwszSessionName = wszSessionName;
		if (!IsEmptyString(ApplicationDesc->Password))
			desc.pwszPassword = wszPassword;

		if (ApplicationDesc->guidApplication)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidApplication, ApplicationDesc->guidApplication) ) )
				return hr;
		}

		if (ApplicationDesc->guidInstance)
		{
			if (FAILED(hr = DPLAYBSTRtoGUID(&desc.guidInstance, ApplicationDesc->guidInstance) ) )
				return hr;
		}

		// Get our host and device address
		DO_GETOBJECT_NOTNULL( IDirectPlay8Address*, lpHost, AddrHost);
		DO_GETOBJECT_NOTNULL( IDirectPlay8Address*, lpDevice, DeviceInfo);

		hr = m__dxj_DirectPlayPeer->EnumHosts(&desc, lpHost, lpDevice, UserData, UserDataSize, (DWORD) lRetryCount, (DWORD) lRetryInterval, (DWORD) lTimeOut, NULL,  dpAsync, (DWORD) lFlags);
		// This should return E_PENDING

		if (dpAsync)
		{
			*lAsync = (long)*dpAsync;
			SAFE_DELETE(dpAsync);
		}
		
		if( hr != E_PENDING && FAILED(hr) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL;
	}
	return S_OK;
}

HRESULT C_dxj_DirectPlayPeerObject::ReturnBuffer(long lBufferHandle)
{
	HRESULT hr;

	__try {
		//We should actually never get here since this is hidden, but just in case
		DPF(1,"-----Entering (DplayPeer) ReturnBuffer call...\n");
		if (FAILED(hr = m__dxj_DirectPlayPeer->ReturnBuffer( (DPNHANDLE) lBufferHandle, 0 ) ) )
			return hr;

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return E_FAIL