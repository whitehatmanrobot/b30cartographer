rt|fCBSTATReplace) ) && 		\
	( (pfucb)->levelPrep <= (pfucb)->ppib->level ) )
#define FFUCBRetPrepared( pfucb )									\
	( (pfucb)->cbstat & (fCBSTATInsert|fCBSTATReplace) )
#define FFUCBUpdatePreparedLevel( pfucb, levelT ) 					\
	( ( (pfucb)->cbstat & (fCBSTATInsert|fCBSTATReplace) ) &&		\
		(pfucb)->levelPrep > (levelT) )

#define FFUCBUpdatePrepared( pfucb )								\
	( (pfucb)->cbstat & (fCBSTATInsert|fCBSTATReplace) )

#define	FUCBResetCbstat( pfucb )  									\
	( (pfucb)->cbstat = fCBSTATNull )

#define FFUCBAtPrepareLevel( pfucb )		   						\
	( (pfucb)->levelPrep == (pfucb)->ppib->level )
#define FUCBDeferUpdate( pfucb )							  		\
	( (pfucb)->cbstatPrev = (pfucb)->cbstat,						\
	  (pfucb)->cbstat = fCBSTATDeferredUpdate )
#define FFUCBDeferredUpdate( pfucb )								\
	( (pfucb)->cbstat == fCBSTATDeferredUpdate )
#define FUCBRollbackDeferredUpdate( pfucb )							\
	( (pfucb)->cbstat = (pfucb)->cbstatPrev )

		
typedef INT		KS;

#define ksNull						0
#define ksPrepared					(1<<0)
#define ksTooBig					(1<<1)

#define	KSReset( pfucb )			( (pfucb)->ks = ksNull )
#define	KSSetPrepare( pfucb )		( (pfucb)->ks |= ksPrepared )
#define KSSetTooBig( pfucb ) 		( (pfucb)->ks |= ksTooBig )
#define	FKSPrepared( pfucb ) 		( (pfucb)->ks & ksPrepared )
#define	FKSTooBig( pfucb )	  		( (pfucb)->ks & ksTooBig )

/*	Setup vdbid back pointer.
**/
#define FUCBSetVdbid( pfucb )										\
	if ( (pfucb)->dbid == dbidTemp )								\
		(pfucb)->vdbid = NULL;										\
	else {															\
		for ( (pfucb)->vdbid = (pfucb)->ppib->pdabList;				\
			  (pfucb)->vdbid != NULL &&								\
				(pfucb)->vdbid->dbid != (pfucb)->dbid;				\
			  (pfucb)->vdbid = (pfucb)->vdbid->pdabNext ) 	 		\
				; /* NULL */										\
		}

#define FUCBStore( pfucb )											\
	{																\
	(pfucb)->csrstatStore = PcsrCurrent( pfucb )->csrstat;			\
	(pfucb)->bmStore = PcsrCurrent( pfucb )->bm;			 		\
	(pfucb)->itemStore = PcsrCurrent( pfucb )->item; 		 		\
	}

#define FUCBResetStore( pfucb )										\
	{																\
	(pfucb)->bmStore = 0;										 	\
	}

#define FUCBRestore( pfucb )										\
	{																\
	if ( (pfucb)->bmStore != isridNull && (pfucb)->bmStore != sridNull )	\
		{															\
		PcsrCurrent( pfucb )->csrstat = (pfucb)->csrstatStore;		\
		Assert( (pfucb)->csrstatStore == csrstatOnDataRoot ||		\
				(pfucb)->csrstatStore == csrstatDeferMoveFirst ||	\
				(pfucb)->csrstatStore == csrstatBeforeFirst ||		\
				(pfucb)->csrstatStore == csrstatAfterLast ||		\
				(pfucb)->bmStore != sridNull );						\
		PcsrCurrent( pfucb )->bm = (pfucb)->bmStore;				\
		PcsrCurrent( pfucb )->item = (pfucb)->itemStore;	  		\
		PcsrCurrent( pfucb )->qwDBTime = qwDBTimeNull; 			 	\
		}															\
	}

#ifdef PREREAD

/*	Preread flag
/**/
#define FFUCBPreread( pfucb ) 			( (pfucb)->fPreread )
#define FUCBSetPreread( pfucb )			( (pfucb)->fPreread = 1 )
#define FUCBResetPreread( pfucb )		( (pfucb)->fPreread = 0 )

/*	Preread direction flag
/**/
#define FFUCBPrereadDir( pfucb )		( (pfucb)->fPrereadDir )
/*	a bit field is not guaranteed to be signed or unsigned. we use double negation
/*	to ensure that we will get a '1' or a '0'
/**/
#define FFUCBPrereadForward( pfucb )	( !!(pfucb)->fPrereadDir)
#define FFUCBPrereadBackward( pfucb )	( (pfucb)->fPrereadDir == 0)
#define FUCBSetPrereadForward( pfucb )	( (pfucb)->fPrereadDir = 1 )
#define FUCBSetPrereadBackward( pfucb )	( (pfucb)->fPrereadDir = 0 )

/*	Preread counter
/**/
#define IFUCBPrereadCount( pfucb )		( (pfucb)->cbPrereadCount )
#define FUCBResetPrereadCount( pfucb )	( (pfucb)->cbPrereadCount = 0, (pfucb)->cpgnoLastPreread = 0 )
#define FUCBIncrementPrereadCount( pfucb, cb ) 	( ((pfucb)->cbPrereadCount) += cb )

#endif	// PREREAD

/*	navigate level support
/**/
#define LevelFUCBNavigate( pfucbT )	((pfucbT)->levelNavigate)
#define FUCBSetLevelNavigate( pfucbT, levelT )						\
	{																\
	Assert( fRecovering || ( (levelT) >= levelMin && 				\
		(levelT) <= (pfucbT)->ppib->level ) );	 	 				\
	Assert( fRecovering || ( (pfucbT)->levelNavigate >= levelMin && \
		(pfucbT)->levelNavigate <= (pfucbT)->ppib->level + 1 ) );  	\
	(pfucbT)->levelNavigate = (levelT);								\
	}


typedef struct tagLVBuf
	{
	LONG	lid;
	BYTE	*pLV;
	LONG	cbLVSize;
	struct tagLVBuf	*pLVBufNext;
	} LVBUF;


/* file use control block
/**/
struct _fucb
	{
	// ===== chaining fields =====
	struct _pib		*ppib;				// user that opened this FUCB
	struct _fucb 	*pfucbNext;			// Next FUCB of this user
	union
		{
		FCB			*pfcb;				// if wFlags & fFUCBIndex
		struct _scb	*pscb;				// if wFlags & fFUCBSort
		} u;
	struct _fucb *pfucbNextInstance;	// Next Instance of this file

	// ===== currency =====
	struct _csr	*pcsr;

	// ===== stored currency =====
	SRID			bmStore;  			 	//	stored bookmark
	SRID			itemStore;		 	 	//	stored item
	SRID 			sridFather;			 	// SRID of visible father

	LONG			ispairCurr;				//  (SORT) current record
	ULONG			ulChecksum;			 	//	checksum of record -- used only for optimistic locking
	KEY  			keyNode;	 		 	//	key of current node
	LINE			lineData;			 	//	current data pointed in pcsr
	CSRSTAT	  		csrstatStore;  		 	//	stored CSR status
	LEVEL			levelOpen;			   	//	transaction level of open
	LEVEL			levelNavigate;			//	transaction level of navigation

	// ===== interface to Storage System =====
	SSIB			ssib;					// SSIB associated with this FUCB
	struct _bf		*pbfEmpty;		 		// write latched empty page
	INT				cpgnoLastPreread;		//	last read-ahead number of pages
	PGNO			pgnoLastPreread;		//	last read-ahead pn

	// ===== maintained by rec man =====
	JET_TABLEID		tableid;			// JET tableid for dispatched cursors
	struct _fucb 	*pfucbCurIndex; 	// current secondary index
	struct _bf		*pbfWorkBuf;	 	// working buffer for Insert/Replace
	LINE			lineWorkBuf;	 	// working buffer for Insert/Replace
	BYTE			rgbitSet[32];
	CBSTAT			cbstat;			 	// copy buffer status
	LEVEL			levelPrep;		 	// level copy buffer prepared
	CBSTAT			cbstatPrev;	  	 	// previous copy buffer status for rollback
	LVBUF			*pLVBuf;

	// ====== space manager work area =======
	PGNO			pgnoLast;			// last page of extent
	CPG 			cpgAvail;			// number of remaining pages
	INT				fExtent;			// work area flag

	// ===== flags for FUCB =====
	/*
	/*	fFUCBDeferClose is set by cursor DIRClose and reset by ErrDIROpen.
	/*
	/*	fFUCBDeferGotoBookmark is set by non-clustered index navigation and
	/*	reset by record status, ErrIsamMove( 0 ), and column retrieval.
	/*
	/*	fFUCBGetBookmark is set by get bookmark and is reset by ErrFUCBOpen.
	/**/
	union {
	ULONG			ulFlags;
	struct {
		INT			fIndex:1;			// FUCB is for index
		INT			fNonClustered:1;	// FUCB for nonclustered index
		INT			fSort:1;			// FUCB is for sort
		INT			fSystemTable:1;		// System table cursor
		INT			fWrite:1;			// cursor can write
		INT			fDenyRead:1;		// deny read flag
		INT			fDenyWrite:1;		// deny write flag
		INT			fUnused:1;			// no longer used
		INT			fDeferClose:1;		// FUCB is awaiting close
		INT			fDeferGotoBookmark:1;	// clustered cursor position
		INT			fGetBookmark:1;		// cursor got bookmark
		INT			fLimstat:1;			// range limit
		INT			fInclusive:1;		// inclusive range
		INT			fUpper:1;			// upper range limit
		INT			fFull:1;			// all CSRs including invisible CSRs
		INT			fUpdateSeparateLV:1;// long value updated
		INT			fDeferredChecksum:1;// checksum calculation deferred.
		INT			fSequential:1;		// will traverse sequentially

#ifdef PREREAD
		INT			fPreread:1;			// we are currently reading ahead
		INT			fPrereadDir:1;		// TRUE if we are prereading forward, FALSE if we are prereading backwards
#endif	// PREREAD

		};
	};
	
	// ===== maintained by dir man =====
	BYTE			*pbKey;			   	// search key buffer
	DBID			dbid;				// database id
#ifdef DISPATCHING
	VDBID			vdbid;				// Virtual DBID back pointer.
#endif
	KS 				ks;					// search key buffer status
	UINT  			cbKey;				// key size
	
	INT				fVtid : 1;		 	// persistant flag cursor has vtid
	INT				fVersioned : 1;  	// persistant falg cursor made version

#ifdef PREREAD
	ULONG			cbPrereadCount;		// count of bytes read sequentially
#endif PREREAD

#ifdef PCACHE_OPTIMIZATION
	/*	pad to multiple of 32 bytes
	/**/
#ifdef PREREAD
	BYTE				rgbFiller[16];
#else	// !PREREAD
	BYTE				rgbFiller[20];
#endif	// PREREAD

#endif
	};

#define PfucbMEMAlloc()				(FUCB*)PbMEMAlloc(iresFUCB)

#ifdef DEBUG /*  Debug check for illegal use of freed fucb  */
#define MEMReleasePfucb(pfucb)		{ MEMRelease(iresFUCB, (BYTE*)(pfucb)); pfucb = pfucbNil; }
#else
#define MEMReleasePfucb(pfucb)		{ MEMRelease(iresFUCB, (BYTE*)(pfucb)); }
#endif

#ifdef	DEBUG
#define	CheckTable( ppibT, pfucb )		   					\
	{														\
	Assert( pfucb->ppib == ppibT );		   					\
	Assert( fRecovering || FFUCBIndex( pfucb ) );	 		\
	Assert( !( FFUCBSort( pfucb ) ) );						\
	Assert( pfucb->u.pfcb != NULL );						\
	}
#define	CheckSort( ppibT, pfucb )		   					\
	{									   					\
	Assert( pfucb->ppib == ppibT );		   					\
	Assert( FFUCBSort( pfucb ) );							\
	Assert( !( FFUCBIndex( pfucb ) ) );						\
	Assert( pfucb->u.pscb != NULL );						\
	}
#define	CheckFUCB( ppibT, pfucb )		   					\
	{														\
	Assert( pfucb->ppib == ppibT );		   					\
	Assert( pfucb->u.pfcb != NULL );						\
	}

#define CheckNonClustered( pfucb )							\
	{											   			\
	Assert( (pfucb)->pfucbCurIndex == pfucbNil ||			\
		FFUCBNonClustered( (pfucb)->pfucbCurIndex ) );		\
	}

#else	/* !DEBUG */
#define	CheckSort( ppib, pfucb )
#define	CheckTable( ppib, pfucb )
#define	CheckFUCB( ppib, pfucb )
#define	CheckNonClustered( pfucb )
#endif	/* !DEBUG */

#define PcsrCurrent( pfucb )		( (pfucb)->pcsr )
#define BmOfPfucb( pfucb )			( (pfucb)->pcsr->bm )
#define FUCBCheckUpdatable( pfucb )					\
	( FFUCBUpdatable( pfucb ) ? JET_errSuccess : 	\
		ErrERRCheck( JET_errPermissionDenied ) )

/*	set column bit array macros	
/**/

#define FUCBResetColumnSet( pfucb )					\
	memset( pfucb->rgbitSet, 0x00, 32 ) 

STATIC INLINE VOID FUCBSetColumnSet( FUCB * pfucb, FID fid )
	{
	pfucb->rgbitSet[IbFromFid( fid )] |= IbitFromFid( fid );
	}

STATIC INLINE BOOL FFUCBColumnSet( const FUCB * pfucb, FID fid )
	{
	return (pfucb->rgbitSet[IbFromFid( fid )] & IbitFromFid( fid ));
	}

STATIC INLINE BOOL FFUCBTaggedColumnSet( const FUCB * pfucb )
	{
	INT	 ib;

	for ( ib = cbitFixedVariable/8 ; ib < (cbitTagged+cbitFixedVariable)/8; ib++ )
		{
		if ( pfucb->rgbitSet[ib] )
			return fTrue;
		}
	return fFalse;
	}
		
ERR ErrFUCBAllocCSR( CSR **ppcsr );
ERR ErrFUCBNewCSR( FUCB *pfucb );
VOID FUCBFreeCSR( FUCB *pfucb );
VOID FUCBFreePath( CSR **ppcsr, CSR *pcsrMark );
ERR ErrFUCBOpen( PIB *ppib, DBID dbid, FUCB **ppfucb );
VOID FUCBClose( FUCB *pfucb );
VOID FUCBRemoveInvisible(CSR **ppcsr);

VOID FUCBSetIndexRange( FUCB *pfucb, JET_GRBIT grbit );
VOID FUCBResetIndexRange( FUCB *pfucb );
ERR ErrFUCBCheckIndexRange( FUCB *pfucb );



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\isamapi.h ===
#ifndef ISAMAPI_H
#define ISAMAPI_H

#define ISAMAPI

typedef struct
	{
	JET_COLUMNID columnidSrc;
	JET_COLUMNID columnidDest;
	} CPCOL;

#define columnidBookmark 0xFFFFFFFF

typedef struct tagSTATUSINFO
	{
	JET_SESID		sesid;
	JET_PFNSTATUS	pfnStatus;				// address of status notification function
	JET_SNP			snp;					// status notification process
	JET_SNT			snt;					// status notification type
	ULONG			cunitTotal;				// total units of work
	ULONG			cunitDone;				// units of work completed
	ULONG			cunitPerProgression;	// units of work per unit of progression

	// Detailed statistics:
	BOOL			fDumpStats;				// dump compaction statistics (DEBUG only)
	struct _iobuf	*hfCompactStats;		// handle to compaction statistics file
	ULONG			timerInitDB;
	ULONG			timerCopyDB;
	ULONG			timerInitTable;
	ULONG			timerCopyRecords;
	ULONG			timerRebuildIndexes;
	ULONG			timerCopyTable;

	ULONG			cDBPagesOwned;			// OwnExt of source DB
	ULONG			cDBPagesAvail;			// AvailExt of source DB 
	char			*szTableName;			// Name of current table
	ULONG			cTableFixedVarColumns;	// Number of fixed and variable columns in current dest. table
	ULONG			cTableTaggedColumns;	// Number of tagged columns in current dest. table
	ULONG			cTableInitialPages;		// Pages initially allocated to current dest. table
	ULONG			cTablePagesOwned;		// OwnExt of current source table
	ULONG			cTablePagesAvail;		// AvailExt of current source table
	ULONG			cbRawData;				// Bytes of non-LV raw data copied
	ULONG			cbRawDataLV;			// Bytes of LV raw data copied
	ULONG			cLeafPagesTraversed;	// Number of leaf pages traversed in current source table
	ULONG			cLVPagesTraversed;		// Number of long value pages traversed in current source table
	ULONG			cNCIndexes;				// Number of non-clustered indexes in current source table
	} STATUSINFO;


	/* Typedefs for dispatched APIs. */
	/* Please keep in alphabetical order */

typedef ERR ISAMAPI ISAMFNAttachDatabase(JET_VSESID sesid, const char  *szFileName, JET_GRBIT grbit );

typedef ERR ISAMAPI ISAMFNBeginExternalBackup( JET_GRBIT grbit );

typedef ERR ISAMAPI ISAMFNBackup( const char  *szBackupPath,
	JET_GRBIT grbit, JET_PFNSTATUS pfnStatus );

typedef ERR ISAMAPI ISAMFNBeginSession(JET_VSESID  *pvsesid);

typedef	ERR	ISAMAPI	ISAMFNInvalidateCursors( JET_VSESID sesid );

typedef ERR ISAMAPI ISAMFNCloseFile( JET_HANDLE hfFile );

typedef ERR ISAMAPI ISAMFNGetSessionInfo( JET_VSESID sesid, JET_GRBIT *pgrbit );

typedef ERR ISAMAPI ISAMFNSetSessionInfo( JET_VSESID sesid, JET_GRBIT grbit );

typedef ERR ISAMAPI ISAMFNBeginTransaction(JET_VSESID sesid);

typedef ERR ISAMAPI ISAMFNCommitTransaction(JET_VSESID sesid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNCopyRecords(JET_VSESID sesid, JET_TABLEID tableidSrc,
		JET_TABLEID tableidDest, CPCOL  *rgcpcol, unsigned long ccpcolMax,
		long crecMax, unsigned long  *pcrowCopy, unsigned long  *precidLast,
		JET_COLUMNID *mpcolumnidcolumnidTagged, STATUSINFO *pstatus );

typedef ERR ISAMAPI ISAMFNCreateDatabase(JET_VSESID sesid,
	const char  *szDatabase, const char  *szConnect,
	JET_DBID  *pdbid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNDetachDatabase(JET_VSESID sesid, const char  *szFileName);

typedef ERR ISAMAPI ISAMFNEndExternalBackup( void );

typedef ERR ISAMAPI ISAMFNEndSession(JET_VSESID sesid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNExternalRestore( char *szCheckpointFilePath, char *szLogPath, JET_RSTMAP *rgstmap, int crstfilemap, char *szBackupLogPath, long genLow, long genHigh, JET_PFNSTATUS pfn );

typedef ERR ISAMAPI ISAMFNGetAttachInfo( void *pv, unsigned long cbMax, unsigned long *pcbActual );

typedef ERR ISAMAPI ISAMFNGetLogInfo( void *pv, unsigned long cbMax, unsigned long *pcbActual );

typedef ERR ISAMAPI ISAMFNIdle(JET_VSESID sesid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long  *pcrec, unsigned long crecMax);

typedef ERR ISAMAPI ISAMFNInit( unsigned long itib );

typedef ERR ISAMAPI ISAMFNLoggingOn(JET_VSESID sesid);

typedef ERR ISAMAPI ISAMFNLoggingOff(JET_VSESID sesid);

typedef ERR ISAMAPI ISAMFNOpenDatabase(JET_VSESID sesid,
	const char  *szDatabase, const char  *szConnect,
	JET_DBID  *pdbid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNOpenFile( const char *szFileName,
	JET_HANDLE	*phfFile,
	unsigned long *pulFileSizeLow,
	unsigned long *pulFileSizeHigh );

typedef ERR ISAMAPI ISAMFNOpenTempTable( JET_VSESID sesid,
	const JET_COLUMNDEF *prgcolumndef,
	unsigned long ccolumn,
	unsigned long langid,
	JET_GRBIT grbit,
	JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid );

typedef ERR ISAMAPI ISAMFNReadFile( JET_HANDLE hfFile, void *pv, unsigned long cbMax, unsigned long *pcbActual );

typedef ERR ISAMAPI ISAMFNRepairDatabase(JET_VSESID sesid, const char  *szFilename,
	JET_PFNSTATUS pfnStatus);

typedef ERR ISAMAPI ISAMFNRestore(	char *szRestoreFromPath, JET_PFNSTATUS pfn );
typedef ERR ISAMAPI ISAMFNRestore2(	char *szRestoreFromPath, char *szDestPath, JET_PFNSTATUS pfn );

typedef ERR ISAMAPI ISAMFNRollback(JET_VSESID sesid, JET_GRBIT grbit);

typedef ERR ISAMAPI ISAMFNSetSystemParameter(JET_VSESID sesid,
	unsigned long paramid, unsigned long l, const void  *sz);

typedef ERR ISAMAPI ISAMFNSetWaitLogFlush( JET_VSESID sesid, long lmsec );
typedef ERR ISAMAPI ISAMFNResetCounter( JET_SESID sesid, int CounterType );
typedef ERR ISAMAPI ISAMFNGetCounter( JET_SESID sesid, int CounterType, long *plValue );

typedef ERR ISAMAPI ISAMFNSetCommitDefault( JET_VSESID sesid, long lmsec );

typedef ERR ISAMAPI ISAMFNTerm( JET_GRBIT grbit );

typedef ERR ISAMAPI ISAMFNTruncateLog( void );

typedef ERR ISAMAPI FNDeleteFile(const char  *szFilename);

typedef ERR ISAMAPI ISAMFNCompact( JET_SESID sesid, const char *szDatabaseSrc,
									const char *szDatabaseDest, JET_PFNSTATUS pfnStatus,
									JET_CONVERT *pconvert, JET_GRBIT grbit );
									
typedef ERR ISAMAPI ISAMFNDBUtilities( JET_SESID sesid, JET_DBUTIL *pdbutil );


typedef struct ISAMDEF {
   ISAMFNAttachDatabase 		*pfnAttachDatabase;
   ISAMFNBackup 				*pfnBackup;
   ISAMFNBeginSession			*pfnBeginSession;
   ISAMFNBeginTransaction		*pfnBeginTransaction;
   ISAMFNCommitTransaction		*pfnCommitTransaction;
   ISAMFNCreateDatabase 		*pfnCreateDatabase;
   ISAMFNDetachDatabase 		*pfnDetachDatabase;
   ISAMFNEndSession				*pfnEndSession;
   ISAMFNIdle					*pfnIdle;
   ISAMFNInit					*pfnInit;
   ISAMFNLoggingOn				*pfnLoggingOn;
   ISAMFNLoggingOff				*pfnLoggingOff;
   ISAMFNOpenDatabase			*pfnOpenDatabase;
   ISAMFNOpenTempTable			*pfnOpenTempTable;
   ISAMFNRepairDatabase 		*pfnRepairDatabase;
   ISAMFNRestore				*pfnRestore;
   ISAMFNRollback				*pfnRollback;
   ISAMFNSetSystemParameter		*pfnSetSystemParameter;
   ISAMFNTerm					*pfnTerm;
} ISAMDEF;


	/* The following ISAM APIs are not dispatched */

typedef ERR ISAMAPI ISAMFNLoad(ISAMDEF  *  *ppisamdef);


	/* Declarations for the built-in ISAM which is called directly. */

extern ISAMFNAttachDatabase			ErrIsamAttachDatabase;
extern ISAMFNBackup					ErrIsamBackup;
extern ISAMFNBeginSession			ErrIsamBeginSession;
extern ISAMFNBeginExternalBackup	ErrIsamBeginExternalBackup;
extern ISAMFNBeginTransaction		ErrIsamBeginTransaction;
extern ISAMFNCloseFile				ErrIsamCloseFile;
extern ISAMFNCommitTransaction		ErrIsamCommitTransaction;
extern ISAMFNCopyRecords			ErrIsamCopyRecords;
extern ISAMFNCreateDatabase			ErrIsamCreateDatabase;
extern ISAMFNDetachDatabase			ErrIsamDetachDatabase;
extern ISAMFNEndExternalBackup		ErrIsamEndExternalBackup;
extern ISAMFNEndSession 			ErrIsamEndSession;
extern ISAMFNExternalRestore		ErrIsamExternalRestore;
extern ISAMFNGetAttachInfo			ErrIsamGetAttachInfo;
extern ISAMFNGetLogInfo				ErrIsamGetLogInfo;
extern ISAMFNIdle					ErrIsamIdle;
extern ISAMFNIndexRecordCount		ErrIsamIndexRecordCount;
extern ISAMFNInit					ErrIsamInit;
extern ISAMFNLoggingOn				ErrIsamLoggingOn;
extern ISAMFNLoggingOff 			ErrIsamLoggingOff;
extern ISAMFNOpenDatabase			ErrIsamOpenDatabase;
extern ISAMFNOpenFile				ErrIsamOpenFile;
extern ISAMFNOpenTempTable			ErrIsamOpenTempTable;
extern ISAMFNReadFile				ErrIsamReadFile;
extern ISAMFNRepairDatabase			ErrIsamRepairDatabase;
extern ISAMFNRestore				ErrIsamRestore;
extern ISAMFNRestore2				ErrIsamRestore2;
extern ISAMFNRollback				ErrIsamRollback;
extern ISAMFNSetSessionInfo			ErrIsamSetSessionInfo;
extern ISAMFNGetSessionInfo			ErrIsamGetSessionInfo;
extern ISAMFNSetSystemParameter 	ErrIsamSetSystemParameter;
extern ISAMFNSetWaitLogFlush		ErrIsamSetWaitLogFlush;
extern ISAMFNResetCounter			ErrIsamResetCounter;
extern ISAMFNGetCounter				ErrIsamGetCounter;
extern ISAMFNSetCommitDefault		ErrIsamSetCommitDefault;
extern ISAMFNTerm					ErrIsamTerm;
extern ISAMFNTruncateLog			ErrIsamTruncateLog;
extern ISAMFNCompact				ErrIsamCompact;
extern ISAMFNInvalidateCursors		ErrIsamInvalidateCursors;
extern ISAMFNDBUtilities			ErrIsamDBUtilities;

extern FNDeleteFile					ErrDeleteFile;

#endif	/* !ISAMAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\log.h ===
#include <stdlib.h>						/* for _MAX_PATH */
#include <time.h>

#pragma pack(1)

extern	BOOL	fLGIgnoreVersion;
extern	BOOL	fBackupInProgress;

extern	CHAR	szDrive[];
extern	CHAR	szDir[];
extern	CHAR	szExt[];
extern	CHAR	szFName[];
extern	CHAR	szLogName[];

extern	CHAR	*szLogCurrent;
extern	CHAR	szLogFilePath[];
//extern	BOOL	fDoNotOverWriteLogFilePath;	/* do not load log file path from log file */
extern	CHAR	szRestorePath[];
extern	CHAR	szRecovery[];
extern	CHAR	szNewDestination[];
	
extern	LONG	cbSec; 	 	//	minimum disk Read/Write unit.
extern	LONG	csecHeader;

#define cbMaxLogFileName	(8 + 1 + 3 + 1) /* null at the end */

#define PbSecAligned(pb)	((((pb)-pbLGBufMin) / cbSec) * cbSec + pbLGBufMin)


//------ types ----------------------------------------------------------

#define FSameTime( ptm1, ptm2 ) (memcmp((ptm1), (ptm2), sizeof(LOGTIME)) == 0)
VOID LGGetDateTime( LOGTIME *plogtm );

//	UNDONE:	allow larger attach sizes to support greater number of
//			attached databases.

#define	cbLogFileHeader	4096			// big enough to hold cbAttach
#define	cbCheckpoint	4096			// big enough to hold cbAttach
#define cbAttach		2048

#define cbLGMSOverhead ( sizeof( LRMS ) + sizeof( LRTYP ) )


/*	log file header
/**/
typedef struct
	{
	ULONG			ulChecksum;			//	must be the first 4 bytes
	LONG			lGeneration;		//	current log generation.
	
	/*	log consistency check
	/**/
	LOGTIME			tmCreate;			//	date time log file creation
	LOGTIME			tmPrevGen;			//	date time prev log file creation
	ULONG			ulMajor;			//	major version number
	ULONG			ulMinor;			//	minor version number
	ULONG			ulUpdate;		  	//	update version number

	LONG			cbSec;
	LONG			csecLGFile;			//	log file size.

	SIGNATURE		signLog;			//	log gene

	/*	run-time evironment
	/**/
	DBMS_PARAM		dbms_param;
	} LGFILEHDR_FIXED;


typedef struct
	{
	LGFILEHDR_FIXED;
	/*	run-time environment
	/**/
	BYTE			rgbAttach[cbAttach];
	/*	padding to cbSec
	/**/
	BYTE			rgb[cbLogFileHeader - sizeof(LGFILEHDR_FIXED) - cbAttach];
	} LGFILEHDR;


typedef struct
	{
	ULONG			ulChecksum;
	LGPOS			lgposLastFullBackupCheckpoint;	// checkpoint of last full backup
	LGPOS			lgposCheckpoint;
	
	SIGNATURE		signLog;			//	log gene

	DBMS_PARAM	 	dbms_param;

	/*	debug fields
	/**/
	LGPOS			lgposFullBackup;
	LOGTIME			logtimeFullBackup;
	LGPOS			lgposIncBackup;
	LOGTIME			logtimeIncBackup;
	} CHECKPOINT_FIXED;

typedef struct
	{
	CHECKPOINT_FIXED;
	/*	run-time environment
	/**/
	BYTE			rgbAttach[cbAttach];
	/*	padding to cbSec
	/**/
	BYTE			rgb[cbCheckpoint - sizeof(CHECKPOINT_FIXED) - cbAttach];
	} CHECKPOINT;

typedef struct tagLGSTATUSINFO
{
	ULONG			cSectorsSoFar;		// Sectors already processed in current gen.
	ULONG			cSectorsExpected;		// Sectors expected in current generation.
	ULONG			cGensSoFar;			// Generations already processed.
	ULONG			cGensExpected;		// Generations expected.
	BOOL			fCountingSectors;		// Are we counting bytes as well as generations?
	JET_PFNSTATUS	pfnStatus;			// Status callback function.
	JET_SNPROG		snprog;				// Progress notification structure.
} LGSTATUSINFO;


typedef struct _rstmap
	{
	CHAR		*szDatabaseName;
	CHAR		*szNewDatabaseName;
	CHAR		*szGenericName;
	CHAR		*szPatchPath;
	BOOL		fPatched;
	BOOL		fDestDBReady;			/*	non-ext-restore, dest db copied?	*/
	} RSTMAP;

#pragma pack()

//------ variables ----------------------------------------------------------

/****** globals declared in log.c, shared by logapi.c redo.c *******/
	
/*** checkpoint file infor ***/
extern CHECKPOINT	*pcheckpointGlobal;

/*** log file infor ***/
extern HANDLE		hfLog;			/* logfile handle */
extern INT			csecLGFile;
extern LGFILEHDR	*plgfilehdrGlobal;		/* cached current log file header */
extern LGFILEHDR	*plgfilehdrGlobalT;		/* read cached of log file header */

/*** in memory log buffer ***/
extern INT	csecLGBuf;		/* available buffer, exclude the shadow sec */
extern CHAR	*pbLGBufMin;
extern CHAR	*pbLGBufMax;
extern BYTE *pbLGFileEnd;
extern LONG isecLGFileEnd;
extern CHAR	*pbLastMSFlush;	/* to LGBuf where last multi-sec flush LogRec sit*/
extern LGPOS lgposLastMSFlush;

extern BYTE			*pbEntry;
extern BYTE			*pbWrite;
extern INT			isecWrite;		/* next disk to write. */

extern BYTE			*pbNext;
extern BYTE			*pbRead;
extern INT			isecRead;		/* next disk to Read. */

extern LGPOS		lgposLastRec;	/* setinal for last log record for redo */

/*** log record position ***/
extern LGPOS lgposLogRec;	/* last log record entry, updated by ErrLGLogRec */
extern LGPOS lgposToFlush;	/* next point starting the flush. Right after */
							/* lgposLogRec. */
extern LGPOS lgposRedo;		/* redo log record entry */

extern LGPOS	lgposFullBackup;
extern LOGTIME	logtimeFullBackup;

extern LGPOS	lgposIncBackup;
extern LOGTIME	logtimeIncBackup;

extern RSTMAP	*rgrstmapGlobal;
extern INT		irstmapGlobalMac;

extern LGPOS lgposStart;	/* last log start position */

// logging MUTEX
extern CRIT  critLGFlush;
extern CRIT  critLGBuf;
extern CRIT	 critCheckpoint;
extern CRIT  critLGWaitQ;
extern SIG	 sigLogFlush;

// logging EVENT
extern SIG  sigLGFlush;


//------ log.c --------------------------------------------------------------

ERR ErrLGOpenJetLog( VOID );
ERR ErrLGWrite(	int isecOffset,	BYTE *pbData, int csecData );
ERR ErrLGRead( HANDLE hfLog, int ibOffset, BYTE *pbData, int csec );
#define fCheckLogID		fTrue
#define fNoCheckLogID	fFalse
ERR ErrLGReadFileHdr( HANDLE hfLog, LGFILEHDR *plgfilehdr, BOOL fNeedToCheckLogID );
VOID LGSzFromLogId( CHAR *rgbLogFileName, LONG lgen );

#define fLGOldLogExists		(1<<0)
#define fLGOldLogNotExists	(1<<1)
#define fLGOldLogInBackup	(1<<2)
#define fLGReserveLogs		(1<<3)
ERR ErrLGNewLogFile( LONG lgen, BOOL fLGFlags );

ULONG LGFlushLog( VOID );
#ifdef PERFCNT
ERR ErrLGFlushLog( int tidCaller );
#else
ERR ErrLGFlushLog( );
#endif

STATIC INLINE QWORD CbOffsetLgpos( LGPOS lgpos1, LGPOS lgpos2 )
	{
	//  take difference of byte offsets, then
	//  log sectors, and finally generations

	return	(QWORD) ( lgpos1.ib - lgpos2.ib )
			+ cbSec * (QWORD) ( lgpos1.isec - lgpos2.isec )
			+ csecLGFile * cbSec * (QWORD) ( lgpos1.lGeneration - lgpos2.lGeneration );
	}


//------ redo.c -------------------------------------------------------------

/*	corresponding pointer to process information block
/**/
typedef struct
	{
	PROCID	procid;
	PIB		*ppib;
	FUCB	*rgpfucbOpen[dbidMax];		
	} CPPIB;
extern CPPIB *rgcppib;		/* array of pibs-procids during Redo */

/*	Patch in-memory structure.
 */
#define cppatchlstHash 577
#define IppatchlstHash( pn )	( (pn) % cppatchlstHash )

typedef struct _patch {
	DBID	dbid;
	QWORD	qwDBTime;
	INT		ipage;
	struct	_patch *ppatch;
	} PATCH;

typedef struct _patchlst {
	PN		pn;
	PATCH	*ppatch;
	struct _patchlst *ppatchlst;
	} PATCHLST;

PATCH *PpatchLGSearch( QWORD qwDBTimeRedo, PN pn );
ERR ErrLGPatchPage( PIB *ppib, PN pn, PATCH *ppatch );
ERR ErrLGPatchDatabase( DBID dbid, INT irstmap );

//------ debug code --------------------------------------------------------

#ifdef	DEBUG
#define FlagUsed( pb, cb )	memset( pb, 'x', cb )
#else	/* !DEBUG */
#define FlagUsed( pb, cb )
#endif	/* !DEBUG */

//------ function headers ---------------------------------------------------
VOID LGFirstGeneration( CHAR *szSearchPath, LONG *plgen );
ERR ErrLGRedoable( PIB *ppib, PN pn, QWORD qwDBTime, BF **ppbf, BOOL *pfRedoable );

INT IrstmapLGGetRstMapEntry( CHAR *szName );
ERR ErrLGGetDestDatabaseName( CHAR *szDatabaseName, INT *pirstmap, LGSTATUSINFO *plgstat );

ERR ErrLGRedo( CHECKPOINT *pcheckpoint, LGSTATUSINFO *plgstat );
ERR ErrLGRedoOperations( LGPOS *plgposRedoFrom, LGSTATUSINFO *plgstat );

INT CbLGSizeOfRec( LR * );
ERR ErrLGCheckReadLastLogRecord( BOOL *pfCloseNormally );
ERR ErrLGLocateFirstRedoLogRec( LGPOS *plgposRedo, BYTE **ppbLR );
ERR ErrLGGetNextRec( BYTE ** );
VOID LGLastGeneration( CHAR *szSearchPath, LONG *plgen );

VOID AddLogRec(	BYTE *pb, INT cb, BYTE **ppbET);
VOID GetLgpos( BYTE *pb, LGPOS *plgpos );
#define GetLgposOfPbEntry( plgpos ) GetLgpos( pbEntry, plgpos )
VOID GetLgposOfPbNext(LGPOS *plgpos);

VOID LGFullNameCheckpoint( CHAR *szFullName );
ERR ErrLGIReadCheckpoint( CHAR *szCheckpointFile, CHECKPOINT *pcheckpoint );
ERR ErrLGIWriteCheckpoint( CHAR *szCheckpointFile, CHECKPOINT *pcheckpoint );
VOID LGUpdateCheckpointFile( BOOL fUpdatedAttachment );
VOID LGLoadAttachmentsFromFMP( BYTE *pbBuf, INT cb );
ERR ErrLGLoadFMPFromAttachments( BYTE *pbAttach );

#define fNoProperLogFile	1
#define fRedoLogFile		2
#define fNormalClose		3
ERR ErrLGOpenRedoLogFile( LGPOS *plgposRedoFrom, int *pfStatus );
ERR ErrLGWriteFileHdr(LGFILEHDR *plgfilehdr);
ULONG UlLGHdrChecksum( LGFILEHDR *plgfilehdr );

#ifdef	DEBUG
BOOL FLGDebugLogRec( LR *plr );
VOID ShowData( BYTE *pbData, INT cbData );
VOID PrintLgposReadLR(VOID);
VOID ShowLR( LR	*plr );
#else
#define ShowLR(	plr )			0
#endif	/* !DEBUG */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\logapi.h ===
#include <stdlib.h>						/* for _MAX_PATH */

typedef enum
	{
	lsNormal,
	lsQuiesce,
	lsOutOfDiskSpace
	} LS;

//------------------------ system parameters ---------------------------

extern long lMaxSessions;
extern long lMaxOpenTables;
extern long lMaxVerPages;
extern long lMaxCursors;
extern long lMaxBuffers;
extern long lLogBuffers;
extern long lLogFileSize;
extern long lLogFlushThreshold;
extern long lLGCheckPointPeriod;
extern long lWaitLogFlush;
extern long lCommitDefault;
extern long lLogFlushPeriod;
extern long lLGWaitingUserMax;
extern BOOL fLGGlobalCircularLog;
	
//------ log.c --------------------------------------------------------------

/*	flags controlling logging behavior
/**/
extern BOOL fLogDisabled;			/* to turn off logging by environment variable */
extern BOOL fFreezeCheckpoint;		/* freeze checkpoint when backup occurs. */
extern BOOL fNewLogGeneration;
extern BOOL	fNewLogRecordAdded;
extern BOOL fBackupActive;
extern BOOL fLGNoMoreLogWrite;
extern LS	lsGlobal;

extern PIB *ppibLGFlushQHead;
extern PIB *ppibLGFlushQTail;

extern INT csecLGThreshold;
extern INT csecLGCheckpointCount;
extern INT csecLGCheckpointPeriod;
extern INT cmsLGFlushPeriod;
extern INT cmsLGFlushStep;

/*	flags controlling recovery behavior
/**/
extern BOOL fGlobalExternalRestore;
extern BOOL fHardRestore;
extern ERR	errGlobalRedoError;
extern LGPOS lgposRedoShutDownMarkGlobal;

#ifdef DEBUG
extern DWORD dwBMThreadId;
extern DWORD dwLogThreadId;
extern BOOL	fDBGTraceLog;
extern BOOL	fDBGTraceLogWrite;
extern BOOL	fDBGFreezeCheckpoint;
extern BOOL	fDBGTraceRedo;
extern BOOL	fDBGTraceBR;
#endif

extern LONG cXactPerFlush;

#ifdef PERFCNT
extern BOOL  fPERFEnabled;
extern ULONG rgcCommitByUser[10];
extern ULONG rgcCommitByLG[10];
#endif

#pragma pack(1)

typedef struct
	{	
	BYTE			szSystemPath[_MAX_PATH + 1];
	BYTE			szLogFilePath[_MAX_PATH + 1];
	
	ULONG			ulMaxSessions;
	ULONG			ulMaxOpenTables;
	ULONG			ulMaxVerPages;
	ULONG			ulMaxCursors;
	ULONG			ulLogBuffers;
	ULONG			ulcsecLGFile;
	ULONG			ulMaxBuffers;		/* not used, for ref only */
	} DBMS_PARAM;

VOID LGSetDBMSParam( DBMS_PARAM *pdbms_param );
VOID LGRestoreDBMSParam( DBMS_PARAM *pdbms_param );

VOID LGReportEvent( DWORD IDEvent, ERR err );

typedef struct {
	WORD	ibOffset:12;				/* offset to old record. */
	WORD	f2BytesLength:1;			/* if length is 2 bytes? */
	WORD	fInsert:1;					/* insertion or replace */

	/*	the following 2 bits are mutual exclusive.
	 */	
	WORD	fInsertWithFill:1;			/* insert with junks filled? */
	WORD	fReplaceWithSameLength:1;	/* replace with same length? */
	} DIFFHDR;

#ifdef DEBUG
VOID LGDumpDiff( BYTE *pbDiff, INT cb );
#endif

VOID LGSetDiffs( FUCB *pfucb, BYTE *pbDiff, INT *pcbDiff );
VOID LGGetAfterImage( BYTE *pbDiff, INT cbDiff, BYTE *pbOld, INT cbOld, BYTE *pbNew, INT *pcbNew );
BOOL FLGAppendDiff( BYTE **ppbCur, BYTE *pbMax, INT ibOffsetOld, INT cbDataOld, INT cbDataNew,
	BYTE *pbDataNew );

extern SIGNATURE signLogGlobal;
extern BOOL fSignLogSetGlobal;
VOID SIGGetSignature( SIGNATURE *psign );

/*
 * NOTE: Whenever a new log record type is added or changed, the following
 * NOTE: should be udpated too: mplrtypsz in logapi.c, new print function for
 * NOTE: the new lrtyp in logapi.c, and mplrtypcb and CbLGSizeOfRec in
 * NOTE: redut.c.
 */
typedef BYTE LRTYP;

#define lrtypNOP				((LRTYP)  0 )	/* NOP null operation */
#define lrtypInit				((LRTYP)  1 )
#define lrtypTerm				((LRTYP)  2 )
#define lrtypMS					((LRTYP)  3 )	/* mutilsec flush */
#define lrtypEnd				((LRTYP)  4 )	/* end of log generation */

#define lrtypBegin				((LRTYP)  5 )
#define lrtypCommit				((LRTYP)  6 )
#define lrtypRollback 			((LRTYP)  7 )

#define lrtypCreateDB			((LRTYP)  8 )
#define lrtypAttachDB			((LRTYP)  9 )
#define lrtypDetachDB			((LRTYP) 10 )

#define lrtypInitFDP			((LRTYP) 11 )

#define lrtypSplit				((LRTYP) 12 )
#define lrtypEmptyPage			((LRTYP) 13 )
#define lrtypMerge				((LRTYP) 14 )

#define lrtypInsertNode			((LRTYP) 15 )
#define lrtypInsertItemList		((LRTYP) 16 )
#define lrtypFlagDelete			((LRTYP) 17 )
#define lrtypReplace			((LRTYP) 18 )		/* replace with full after image */
#define lrtypReplaceD			((LRTYP) 19 )		/* replace with delta'ed after image */

#define lrtypLockBI				((LRTYP) 20 )		/* replace with lock */
#define lrtypDeferredBI			((LRTYP) 21 )		/* deferred before image. */

#define lrtypUpdateHeader		((LRTYP) 22 )
#define lrtypInsertItem			((LRTYP) 23 )
#define lrtypInsertItems		((LRTYP) 24 )
#define lrtypFlagDeleteItem		((LRTYP) 25 )
#define lrtypFlagInsertItem		((LRTYP) 26 )
#define lrtypDeleteItem			((LRTYP) 27 )
#define lrtypSplitItemListNode	((LRTYP) 28 )

#define lrtypDelta				((LRTYP) 29 )

#define lrtypDelete				((LRTYP) 30 )
#define lrtypELC				((LRTYP) 31 )

#define lrtypFreeSpace			((LRTYP) 32 )
#define lrtypUndo				((LRTYP) 33 )

#define lrtypPrecommit			((LRTYP) 34 )
#define lrtypBegin0				((LRTYP) 35 )
#define lrtypCommit0			((LRTYP) 36 )
#define	lrtypRefresh			((LRTYP) 37 )

/*	debug log records
/**/
#define lrtypRecoveryUndo		((LRTYP) 38 )
#define lrtypRecoveryQuit		((LRTYP) 39 )

#define lrtypFullBackup			((LRTYP) 40 )
#define lrtypIncBackup			((LRTYP) 41 )

#define lrtypCheckPage			((LRTYP) 42 )
#define lrtypJetOp				((LRTYP) 43 )
#define lrtypTrace				((LRTYP) 44 )

#define lrtypShutDownMark		((LRTYP) 45 )

#define lrtypMacroBegin			((LRTYP) 46 )
#define lrtypMacroCommit		((LRTYP) 47 )
#define lrtypMacroAbort			((LRTYP) 48 )

#define lrtypMax				((LRTYP) 49 )


/* log record structure ( fixed size portion of log entry )
/**/

typedef struct
	{
	LRTYP	lrtyp;
	} LR;

typedef LR LRSHUTDOWNMARK;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itagSon;		/* itag of node, used only for verification */
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of DB operations */
	PN		pn:27;			/* DBTimeHigh + dbid + pgno */
	ULONG	ulDBTimeHigh:5;
	BYTE	itagFather;	 	/* itag of father node */
	BYTE	ibSon;	 		/* position to insert in father son table */
	BYTE	bHeader;		/* node header */
	BYTE 	cbKey;			/* key size */
	USHORT	fDirVersion:1;	/* fDIRVersion for insert item list */
	USHORT	cbData:15;		/* data size */
	CHAR	szKey[0];		/* key and data follow */
	} LRINSERTNODE;

typedef struct	/* for lrtypReplace lrtypReplaceC lrtypReplaceD */
	{
	LRTYP	lrtyp;

	BYTE	itag;			/* wherereplace occurs */
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	PN		pn:27;
	ULONG	ulDBTimeHigh:5;
	SRID	bm;				/* bookmark of this replace node */
	USHORT	fDirVersion:1;	/* flags used in original DIR call */
	USHORT	cb:15;	 			/* data size/diff info */
	USHORT	cbOldData;	 	/* before image data size, may be 0 */
	USHORT	cbNewData;		/* after image data size, == cb if not replaceC */
	CHAR	szData[0];		/* made line data for after image follow */
	} LRREPLACE;

typedef struct	/* for lrtypDeferredBI */
	{
	LRTYP	lrtyp;

	BYTE	bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	procid; 		/* user id of this log record */
	SRID	bm;				/* entry key to version store */
	DBID	dbid;
	USHORT	level:4;
	USHORT	cbData:12;		/* data size/diff info */
	CHAR	rgbData[0];		/* made line data for new record follow */
	} LRDEFERREDBI;

typedef	struct
	{
	LRTYP	lrtyp;

	BYTE	itag;
	USHORT	procid;			/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	PN		pn:27;
	ULONG	ulDBTimeHigh:5;
	SRID	bm;
	USHORT	cbOldData;
	} LRLOCKBI;
	
typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itag;
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	PN		pn:27;
	ULONG	ulDBTimeHigh:5;
	SRID	bm;				/* bookmark of this delete node */
	BYTE	fDirVersion;	/* flags used in original DIR call */
	} LRFLAGDELETE;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itag;
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	PN		pn:27;
	ULONG	ulDBTimeHigh:5;
	} LRDELETE;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	SRID	bm;
	SRID	bmTarget;		/* page being updated during undo operation */
	WORD	dbid:3;
	WORD	wDBTimeHigh:5;
	WORD	wFiller:8;
	USHORT	level:4;
	USHORT	cbDelta:12;
	} LRFREESPACE;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	level;
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	SRID	bm;
	WORD	dbid:3;
	WORD	wDBTimeHigh:5;
	WORD	wFiller:8;
	USHORT	oper;			/*	no DDL */
	SRID	item;
	SRID	bmTarget;		/* the page being updated during undo operation */
	} LRUNDO;

/*	expunge link commit log record
/**/
typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itag;
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	PN		pn:27;
	ULONG	ulDBTimeHigh:5;
	SRID	sridSrc;
	} LRELC;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itag;
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	PN		pn:27;
	ULONG	ulDBTimeHigh:5;
	SRID	bm;				/* bookmark of this udpated node */
	BYTE	bHeader;
	} LRUPDATEHEADER;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itag;			/* of item list node */
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of DB operations */
	PN		pn:27;			/* dbid + pgno */
	ULONG	ulDBTimeHigh:5;
	SRID	srid;			/* item to insert */
	SRID	sridItemList;	/* bookmark of first item list node */
	BYTE	fDirVersion;		/* so far only one bit is used - fDIRVersion */
	} LRINSERTITEM;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itag;			/* item list */
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of DB operations */
	PN		pn:27;			/* ulDBTimeHigh + dbid + pgno */
	ULONG	ulDBTimeHigh:5;
	WORD	citem;			/* number of items to append */
	SRID	rgitem[0];
	} LRINSERTITEMS;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itag;			/* of item list node */
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	PN		pn:27;
	ULONG	ulDBTimeHigh:5;
	SRID	srid;			/* item to insert */
	SRID	sridItemList;	/* bookmark of first item list node */
	} LRFLAGITEM;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itagToSplit;	/* used only for verification!	*/
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of DB operations */
	PN		pn:27;			/* ulDBTimeHigh + dbid + pgno */
	ULONG	ulDBTimeHigh:5;
	WORD	cItem;
	BYTE	itagFather;	 	/* itag of father */
	BYTE	ibSon;	 		/* Position to insert in father's son table	*/
	BYTE	fDirAppendItem;	/* flag to indicate if it is append item */
	} LRSPLITITEMLISTNODE;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itag;			/* item list */
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of DB operations */
	PN		pn:27;			/* dbid + pgno */
	ULONG	ulDBTimeHigh:5;
	SRID	srid;			/* item to insert */
	SRID	sridItemList;	/* bookmark of first item list node */
	} LRDELETEITEM;
	
typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itag;			/* wherereplace occurs */
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	PN		pn:27;
	ULONG	ulDBTimeHigh:5;
	SRID	bm;				/* bookmark of this replace node */
	LONG	lDelta;
	BYTE	fDirVersion;	/* flags used in original DIR call */
	} LRDELTA;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	procid; 		/* user id of this log record */
	ULONG	ulDBTimeLow;	/* current flush counter of page */
	PN		pn:27;
	ULONG	ulDBTimeHigh:5;
	PGNO	pgnoFDP;
	SHORT	cbFree;
	SHORT	cbUncommitted;
	SHORT	itagNext;
	} LRCHECKPAGE;
	
typedef struct
	{
	LRTYP	lrtyp;
	
	BYTE	levelBegin:4;		/* begin transaction level */
	BYTE	level:4;			/* transaction levels */
	USHORT	procid;				/* user id of this log record */
	} LRBEGIN;

typedef struct
	{
	LRBEGIN;
	TRX			trxBegin0;
	} LRBEGIN0;
	
typedef struct
	{
	LRTYP		lrtyp;
	BYTE		bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT		procid;
	TRX			trxBegin0;
	} LRREFRESH;

typedef struct
	{
	LRTYP	lrtyp;
	BYTE	bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	procid;
	} LRPRECOMMIT;

typedef struct
	{
	LRTYP	lrtyp;
	
	BYTE	level;			/* transaction levels */
	USHORT	procid; 		/* user id of this log record */
	} LRCOMMIT;

typedef struct
	{
	LRCOMMIT;
	TRX			trxCommit0;
	} LRCOMMIT0;

typedef struct
	{
	LRTYP	lrtyp;
	
	LEVEL	levelRollback; 		/* transaction level */
	USHORT	procid; 			/* user id of this log record */
	} LRROLLBACK;

typedef struct
	{
	LRTYP	lrtyp;
	BYTE	bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	procid;
	} LRMACROBEGIN;

typedef struct
	{
	LRTYP	lrtyp;
	BYTE	bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	procid;
	} LRMACROEND;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	dbid;
	USHORT	procid;			/* user id of this log record, unused in V15 */
	JET_GRBIT grbit;
	SIGNATURE signDb;
	USHORT	fLogOn:1;
	USHORT	cbPath:15;			/* data size */
	CHAR	rgb[0];			/* path name and signiture follows */
	} LRCREATEDB;

typedef struct
	{
	LRTYP		lrtyp;

	BYTE		bFiller;			//	UNDONE:	remove this when PPC compiler bug fix
	USHORT		procid;
	SIGNATURE	signDb;
	SIGNATURE	signLog;
	LGPOS		lgposConsistent;	/* earliest acceptable database consistent time */
	DBID		dbid;
	USHORT		fLogOn:1;
	USHORT		fReadOnly:1;
	USHORT		fVersioningOff:1;
	USHORT		cbPath:12;			/* data size */
	CHAR		rgb[0];				/* path name follows */
	} LRATTACHDB;

typedef struct
	{
	LRTYP	lrtyp;
	
	BYTE	bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	procid;			/* user id of this log record, unused in V15 */
	DBID	dbid;
	USHORT	cbPath:15;
	USHORT	cbDbSig;
	CHAR	rgb[0];			/* path name follows */
	} LRDETACHDB;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	splitt;			/* split type */
	USHORT	procid;			/* user id of this log record */
	ULONG	ulDBTimeLow;	/* flush counter of page being split */
	PN		pn:27;			/* page (focus) being split, includes dbid */
	ULONG	ulDBTimeHigh:5;
	PGNO	pgnoNew;		/* newly-allocated page no */
	PGNO	pgnoNew2;		/* newly-allocated page no */
	PGNO	pgnoNew3;		/* newly-allocated page no */
	PGNO	pgnoSibling;	/* newly-allocated page no */
	BYTE	fLeaf:1;		/* split on leaf node */
	BYTE	pgtyp:7;		/* page type of new page */
	BYTE	itagSplit;		/* node at which page is being split */
	SHORT	ibSonSplit;		/* ibSon at which node is being split */
	PGNO	pgnoFather;		/* pgno of father node */
	SHORT	itagFather;		/* itag of father node, could be itagNil (3 bytes) */
	SHORT	itagGrandFather;/* itag of Grand father node, could be itagNil (3 bytes) */
	SHORT	cbklnk;			/* number of back links */
	BYTE	ibSonFather;
	BYTE	cbKey;
	BYTE	cbKeyMac;
	BYTE	rgb[0];
	} LRSPLIT;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	itagFather;		/* itag of father of page pointer */
	USHORT	procid;			/* user id of this log record */
	ULONG	ulDBTimeLow;	/* flush counter of page being split */
	PN		pn:27;				/* page pointer of empty page */
	ULONG	ulDBTimeHigh:5;
	PGNO	pgnoFather;
	PGNO	pgnoLeft;
	PGNO	pgnoRight;
	USHORT	itag;			/* itag of page pointer, could be Nil (itagNil is 3 bytes) */
	BYTE	ibSon;
	} LREMPTYPAGE;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	procid;
	PN		pn:27;			/* page pointer of merged page */
	ULONG	ulDBTimeHigh:5;
	PGNO	pgnoRight;		/* page appended to */
	PGNO	pgnoParent;
	ULONG	ulDBTimeLow;
	SHORT	itagPagePtr;
	SHORT 	cbKey;
	SHORT	cbklnk;
	BYTE	rgb[0];
	} LRMERGE;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE	bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	procid;			/* user id of this log record */
	ULONG	ulDBTimeLow;	/* flush counter of father FDP page */
	PN		pn:27;			/* FDP page */
	ULONG	ulDBTimeHigh:5;
	PGNO	pgnoFDPParent;	/* parent FDP */
	USHORT	cpgGot;			/* returned number of pages */
	USHORT	cpgWish;		/* request pages */
	} LRINITFDP;
	
typedef struct
	{
	LRTYP	lrtyp;
	
	BYTE	bFiller;			//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	ibForwardLink;
	ULONG	ulCheckSum;
	USHORT	isecForwardLink;
	} LRMS;

typedef struct
	{
	LRTYP		lrtyp;

	BYTE		rgbFiller[3];	//	UNDONE:	remove this when PPC compiler bug fix
	DBMS_PARAM	dbms_param;
	} LRINIT;
	
typedef struct
	{
	LRTYP	lrtyp;

	BYTE	fHard;
	BYTE 	rgbFiller[2];		//	UNDONE:	remove this when PPC compiler bug fix
	LGPOS	lgpos;				/* point back to last beginning of undo */
	LGPOS	lgposRedoFrom;
	} LRTERMREC;
	
typedef struct
	{
	LRTYP	lrtyp;

	BYTE 	bFiller;			//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	cbPath;				/* backup path/restore path */
	BYTE	szData[0];
	} LRLOGRESTORE;
	
typedef struct
	{
	LRTYP	lrtyp;
	
	BYTE	op;				/* jet operation */
	USHORT	procid; 		/* user id of this log record */
	} LRJETOP;

typedef struct
	{
	LRTYP	lrtyp;

	BYTE 	bFiller;		//	UNDONE:	remove this when PPC compiler bug fix
	USHORT	procid; 		/* user id of this log record */
	USHORT 	cb;
	BYTE	sz[0];
	} LRTRACE;
	
#pragma pack()
	

#ifdef NOLOG

#define LGDepend( pbf, lgpos )
#define LGDepend2( pbf, lgpos )

#define ErrLGInsert( pfucb, fHeader, pkey, plineData, fDIRFlags )	0
#define ErrLGInsertItemList( pfucb, fHeader, pkey, plineData )	0
#define ErrLGReplace( pfucb, plineNew, fDIRFlags, cbOldData, plineDiff ) 0
#define ErrLGDeferredBIWithoutRetry( prce ) 0
#define ErrLGDeferredBI( prce ) 0
#define ErrLGFlagDelete( pfucb, fFlags )	0
#deinfe ErrLGUpdateHeader( pfucb, bHeader ) 0
#define ErrLGInsertItem( pfucb, fDIRFlags )	0
#define ErrLGInsertItems( pfucb, rgitem, citem )	0
#define ErrLGFlagDeleteItem( pfucb )	0
#define ErrLGSplitItemListNode(	pfucb, cItem, itagFather, ibSon, itagToSplit, fFlags) 0
#define ErrLGDeleteItem( pfucb ) 		0
#define ErrLGDelta( pfucb, lDelta, fDIRFlags ) 0
#define ErrLGLockBI( pfucb, cbData ) 0

#define ErrLGBeginTransaction( ppib, levelBeginFrom ) 0
#define ErrLGPrecommitTransaction( ppib, &lgposPrecommitRec ) 0
#define ErrLGCommitTransaction( ppib, levelCommitTo ) 0
#define ErrLGRefreshTransaction( ppib ) 0
#define ErrLGRollback( ppib,levelsRollback ) 0
#define ErrLGMacroBegin( ppib ) 0
#define ErrLGMacroCommit( ppib ) 0
#define ErrLGMacroAbort( ppib ) 0
#define ErrLGUndo( prce ) 0
#define ErrLGFreeSpace( pfucb, bm, cbDelta ) 0

#define ErrLGCreateDB( ppib, dbid, grbit, sz, cch, psign, plgposRec ) 0
#define ErrLGAttachDB( ppib, dbid, sz, cch, psign, psignLog, plgposConsistent, plgposRec ) 0
#define ErrLGDetachDB( ppib, dbid, sz, cch, plgposRec ) 0

#define	ErrLGMerge( pfucb, psplit ) 0
#define ErrLGSplit( splitt, pfucb, pcsrPagePointer, psplit, pgtypNew ) 0
#define	ErrLGEmptyPage(	pfucbFather, prmpage ) 0
#define ErrLGInitFDP( pfucb, pgnoFDPParent, pnFDP, cpgGot, cpgWish) 0
#define ErrLGFlagInsertItem(pfucb) 0

#define ErrLGStart() 0
#define ErrLGQuit( plgposRecoveryUndo )	0
#define ErrLGShutDownMark( plgposLogRec ) 0
#define ErrLGRecoveryQuit( plgposRecoveryUndo ) 0
#define ErrLGRecoveryUndo( szRestorePath ) 0
#define ErrLGFullBackup(szRestorePath, plgposLogRec ) 0
#define ErrLGIncBackup(szRestorePath ) 0

#define ErrLGCheckPage( pfucb, cbFree, cbUncommitted, itagNext, pgnoFDP ) 0
#define ErrLGCheckPage2( ppib, pbf, cbFree, cbUncommited, itagNext, pgnoFDP ) 0
#define ErrLGTrace( ppib, sz ) 0
#define ErrLGTrace2( ppib, sz ) 0

#else	/* !NOLOG */

#define ErrLGInsert( pfucb, fHeader, pkey, plineData, fFlags)		\
	ErrLGInsertNode( lrtypInsertNode, pfucb, fHeader, pkey, plineData, fFlags)
#define ErrLGInsertItemList( pfucb, fHeader, pkey, plineData, fFlags)		\
	ErrLGInsertNode( lrtypInsertItemList, pfucb, fHeader, pkey, plineData, fFlags)
ERR ErrLGInsertNode( LRTYP lrtyp,
 	FUCB *pfucb, INT fHeader, KEY *pkey, LINE *plineData, INT fFlags);
ERR ErrLGReplace( FUCB *pfucb, LINE *plineNew, INT fDIRFlags, INT cbOldData, BYTE *pbDiff, INT cbDiff );
ERR ErrLGDeferredBIWithoutRetry( RCE *prce );
ERR ErrLGDeferredBI( RCE *prce );
ERR ErrLGFlagDelete( FUCB *pfucb, INT fFlags);
ERR ErrLGUpdateHeader( FUCB *pfucb, INT bHeader );
ERR ErrLGInsertItem( FUCB *pfucb, INT fDIRFlags );
ERR ErrLGInsertItems( FUCB *pfucb, SRID *rgitem, INT citem );
ERR ErrLGFlagDeleteItem( FUCB *pfucb );
ERR ErrLGSplitItemListNode( FUCB *pfucb, INT cItem, INT itagFather,
 	INT ibSon, INT itagToSplit, INT fFlags );
ERR ErrLGDelta( FUCB *pfucb, LONG lDelta, INT fDIRFlags );
ERR ErrLGLockBI( FUCB *pfucb, INT cbData );

ERR ErrLGBeginTransaction( PIB *ppib, INT levelBeginFrom );
ERR ErrLGRefreshTransaction( PIB *ppib );
ERR ErrLGPrecommitTransaction( PIB *ppib, LGPOS *plgposRec );
ERR ErrLGCommitTransaction( PIB *ppib, INT levelCommitTo );
ERR ErrLGRollback( PIB *ppib, INT levelsRollback );
ERR ErrLGUndo( RCE *prce );
ERR ErrLGFreeSpace( FUCB *pfucb, SRID bm, INT cbDelta );

ERR ErrLGMacroBegin( PIB *ppib );
ERR ErrLGMacroEnd( PIB *ppib, LRTYP lrtyp );
#define ErrLGMacroCommit( ppib ) ErrLGMacroEnd( ppib, lrtypMacroCommit )
#define ErrLGMacroAbort( ppib ) ErrLGMacroEnd( ppib, lrtypMacroAbort )

ERR ErrLGCreateDB( PIB *ppib, DBID dbid, JET_GRBIT grbit, CHAR *sz, INT cch, SIGNATURE *psignDb, LGPOS *plgposRec );
ERR ErrLGAttachDB( PIB *ppib, DBID dbid, CHAR *sz, INT cch, SIGNATURE *psignDb, SIGNATURE *psignLog, LGPOS *plgposConsistent, LGPOS *plgposRec );
ERR ErrLGDetachDB( PIB *ppib, DBID dbid, CHAR *sz, INT cch, LGPOS *plgposRec );

ERR ErrLGMerge( FUCB *pfucb, struct _split *psplit );
ERR ErrLGSplit( SPLITT splitt, FUCB *pfucb, CSR *pcsrPagePointer,
 	struct _split *psplit, PGTYP pgtypNew );

ERR ErrLGEmptyPage( FUCB *pfucbFather, RMPAGE *prmpage );
ERR ErrLGInitFDP( FUCB *pfucb, PGNO pgnoFDPParent,
 	PN pnFDP, INT cpgGot, INT cpgWish);

#define ErrLGFlagDeleteItem(pfucb) ErrLGFlagItem(pfucb, lrtypFlagDeleteItem)
#define ErrLGFlagInsertItem(pfucb) ErrLGFlagItem(pfucb, lrtypFlagInsertItem)
ERR ErrLGFlagItem(FUCB *pfucb, LRTYP lrtyp);
ERR	ErrLGDeleteItem( FUCB *pfucb );

ERR ErrLGDelete( FUCB *pfucb );
ERR ErrLGExpungeLinkCommit( FUCB *pfucb, SSIB *pssibSrc, SRID sridSrc );

ERR ErrLGStart();
ERR ErrLGShutDownMark( LGPOS *plgposShutDownMark );

#define ErrLGRecoveryQuit( plgposRecoveryUndo, plgposRedoFrom, fHard )		\
 	ErrLGQuitRec( lrtypRecoveryQuit, plgposRecoveryUndo, plgposRedoFrom, fHard )
#define ErrLGQuit( plgposStart )						\
 	ErrLGQuitRec( lrtypTerm, plgposStart, pNil, 0 )
ERR ErrLGQuitRec( LRTYP lrtyp, LGPOS *plgposQuit, LGPOS *plgposRedoFrom, BOOL fHard);

#define ErrLGRecoveryUndo(szRestorePath)			\
 	ErrLGLogRestore(lrtypRecoveryUndo, szRestorePath, fNoNewGen, pNil )
#define ErrLGFullBackup(szRestorePath, plgposLogRec)				\
 	ErrLGLogRestore(lrtypFullBackup, szRestorePath, fCreateNewGen, plgposLogRec )
#define ErrLGIncBackup(szRestorePath, plgposLogRec)				\
 	ErrLGLogRestore(lrtypIncBackup, szRestorePath, fCreateNewGen, plgposLogRec )
ERR ErrLGLogRestore( LRTYP lrtyp, CHAR * szLogRestorePath, BOOL fNewGen, LGPOS *plgposLogRec );

ERR ErrLGCheckPage( FUCB *pfucb, SHORT cbFree, SHORT cbUncommitted, SHORT itagNext, PGNO pgnoFDP );
ERR ErrLGCheckPage2( PIB *ppib, BF *pbf, SHORT cbFree, SHORT cbUncommited, SHORT itagNext, PGNO pgnoFDP );

ERR ErrLGTrace( PIB *ppib, CHAR *sz );
ERR ErrLGTrace2( PIB *ppib, CHAR *sz );

#endif			/* logging enabled	*/


ERR ErrLGSoftStart( BOOL fAllowNoJetLog, BOOL fNewCheckpointFile, BOOL *pfJetLogGeneratedDuringSoftStart );

ERR ErrLGInit( BOOL *pfNewCheckpointFile );
ERR ErrLGTerm( ERR err );
#define	fCreateNewGen	fTrue
#define fNoNewGen		fFalse
ERR ErrLGLogRec( LINE *rgline, INT cline, BOOL fNewGen, LGPOS *plgposLogRec );
ERR ErrLGWaitPrecommit0Flush( PIB *ppib );

#define szAssertFilename	__FILE__
STATIC INLINE ErrLGWaitForFlush( PIB *ppib, LGPOS *plgposLogRec )
	{
	extern SIG sigLogFlush;
	ERR err;

	AssertCriticalSection( critJet );

	if ( fLogDisabled || ( fRecovering && fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	ppib->lgposPrecommit0 = *plgposLogRec;

	LeaveCriticalSection( critJet );
	SignalSend( sigLogFlush );
	err = ErrLGWaitPrecommit0Flush( ppib );
	EnterCriticalSection( critJet );

	Assert( err >= 0 || ( fLGNoMoreLogWrite  &&  err == JET_errLogWriteFail ) );
	return err;
	}
#undef szAssertFilename

ERR ErrLGInitLogBuffers( LONG lIntendLogBuffers );
ULONG UlLGMSCheckSum( CHAR *pbLrmsNew );

#define ErrLGCheckState()	( lsGlobal != lsNormal ? \
							  ErrLGNewReservedLogFile() : \
							  JET_errSuccess )
							
#define FLGOn()					(!fLogDisabled)
#define FLGOff()				(fLogDisabled)

BOOL FIsNullLgpos( LGPOS *plgpos );
VOID LGMakeLogName( CHAR *szLogName, CHAR *szFName );
ERR ErrLGPatchAttachedDB( DBID dbid, JET_RSTMAP *rgrstmap, INT crstmap );

ERR	ErrLGNewReservedLogFile();

STATIC INLINE INT CmpLgpos( LGPOS *plgpos1, LGPOS *plgpos2 )
	{
	BYTE	*rgb1	= (BYTE *) plgpos1;
	BYTE	*rgb2	= (BYTE *) plgpos2;

	//  perform comparison on LGPOS as if it were a 64 bit integer
#ifdef _X86_
	//  bytes 7 - 4
	if ( *( (DWORD UNALIGNED *) ( rgb1 + 4 ) ) < *( (DWORD UNALIGNED *) ( rgb2 + 4 ) ) )
		return -1;
	if ( *( (DWORD UNALIGNED *) ( rgb1 + 4 ) ) > *( (DWORD UNALIGNED *) ( rgb2 + 4 ) ) )
		return 1;

	//  bytes 3 - 0
	if ( *( (DWORD UNALIGNED *) ( rgb1 + 0 ) ) < *( (DWORD UNALIGNED *) ( rgb2 + 0 ) ) )
		return -1;
	if ( *( (DWORD UNALIGNED *) ( rgb1 + 0 ) ) > *( (DWORD UNALIGNED *) ( rgb2 + 0 ) ) )
		return 1;
#else
	//  bytes 7 - 0
	if ( *( (QWORD UNALIGNED *) ( rgb1 + 0 ) ) < *( (QWORD UNALIGNED *) ( rgb2 + 0 ) ) )
		return -1;
	if ( *( (QWORD UNALIGNED *) ( rgb1 + 0 ) ) > *( (QWORD UNALIGNED *) ( rgb2 + 0 ) ) )
		return 1;
#endif

	return 0;
	}


/*	log checkpoint support
/**/
ERR ErrLGCheckpointInit( BOOL *pfNewCheckpointFile );
VOID LGCheckpointTerm( VOID );

/*	database attachments
/**/
ERR ErrLGInitAttachment( VOID );
VOID LGTermAttachment( VOID );
ERR ErrLGLoadAttachmentsFromFMP( VOID );
ERR ErrLGInsertAttachment( DBID dbid, CHAR *szFullPath );
ERR ErrLGDeleteAttachment( DBID dbid );
VOID LGCopyAttachment( BYTE *rgbAttach );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\node.h ===
#ifndef NODE_INCLUDED
#define NODE_INCLUDED

typedef SRID ITEM;

#define	citemMost		   		300
#define	citemMax		   		301
#define	citagSonMax				ctagMax
#define	cbFOPNoSon				( sizeof(TAG) + 1 + 1 )		// 6
#define	cbFOPOneSon				( cbFOPNoSon + 1 + 1 )		// 8
/*	most bytes available for page subtree not including FOP son
/**/
#define	cbAvailMost				( cbPage - sizeof(PGHDR) - sizeof(PGTRLR) - cbFOPNoSon - 1 )
								// 4096 - 28 - 4 - 6 - 1 /* for FOP son count */  = 4057
/*	most bytes for node key and data, backlink included.
/**/
#define	cbNodeMost				( cbAvailMost - 1 - 1 - sizeof(TAG) - sizeof(SRID) )
								// 4057 - 1 /* FOP son */ - 1 - 4 - 4 = 4047
/*	bytes for Null key and no data, backlink excluded.
/**/
#define	cbNullKeyData			( cbFOPOneSon - cbFOPNoSon + sizeof(TAG) + 1 + 1 )
								//  8 - 6 + 4 + 1 + 1 = 8
								//	cbNullKeyData is for inserted nodes and
								//	does not have backlink
/*	most bytes for long value chunk with 4 byte key.
/**/
#define	cbChunkMost 			( cbNodeMost - cbNullKeyData - sizeof(LONG) )
								// 4047 - 8 /* node null key data */ - 4 /* key */ = 4035
#define	cbItemNodeMost			( 1 + 1 + JET_cbKeyMost + 0 + 0 + sizeof(SRID) + (citemMax * sizeof(SRID)) )
								// 261 + 300 * 4 = 1461
#define	cbHalfItemNodeMost 		( 1 + 1 + JET_cbKeyMost + 0 + 0 + sizeof(SRID) + ((((citemMax + 1) / 2) + 1 ) * sizeof(SRID)) )
								//  261 + 151 * 4 = 865
#define	cbFirstPagePointer		( 1 + sizeof(PGNO) )

//	node header bits
#define fNDVersion		  		0x80
#define fNDDeleted		  		0x40
#define fNDBackLink		  		0x20
#define fNDReserved				0x10	// Reserved for future use (formerly fNDFDPPtr)
#define fNDSon					0x08
#define fNDVisibleSon	  		0x04
#define fNDFirstItem  	  		0x02
#define fNDLastItem	  	  		0x01

#define	FNDDeleted(b)	 		( (b) & fNDDeleted )
#define	FNDVersion(b)	 		( (b) & fNDVersion )
#define	FNDVerDel(b)			( (b) & (fNDDeleted | fNDVersion) )

#define	FNDBackLink(b)	 		( (b) & fNDBackLink )
#define	FNDNullSon(b)	 		( !( (b) & fNDSon ) )
#define	FNDSon(b)	 			( (b) & fNDSon )

#define FNDReserved(b)			( (b) & fNDReserved )
#define	FNDFDPPtr(b) 			FNDReserved(b)
#define	FNDVisibleSons(b)		( (b) & fNDVisibleSon )
#define	FNDInvisibleSons(b) 	( !( (b) & fNDVisibleSon ) )

#define	FNDFirstItem(b)		   	( (b) & fNDFirstItem )
#define	FNDLastItem(b)		   	( (b) & fNDLastItem )

//	node flag toggle macros

#define	NDSetDeleted(b) 	   	( (b) |= fNDDeleted )
#define	NDResetDeleted(b)	   	( (b) &= ~fNDDeleted )

#define	NDSetVersion(b) 	   	( (b) |= fNDVersion )
#define	NDResetVersion(b)	   	( (b) &= ~fNDVersion )

#define	NDSetSon(b)			   	( (b) |= fNDSon )
#define	NDResetSon(b)		   	( (b) &= ~fNDSon )

#define	NDSetKeyLength(pb, cb) 	( *(pb) = cb )

#define	NDSetVisibleSons(b)	   	( (b) |= fNDVisibleSon )
#define	NDSetInvisibleSons(b)  	( (b) &= ~fNDVisibleSon )

#define	NDSetBackLink(b)   	   	( (b) |= fNDBackLink )
#define	NDResetBackLink(b) 	   	( (b) &= ~fNDBackLink )

#define	NDSetFirstItem(b)	   	( (b) |= fNDFirstItem )
#define	NDResetFirstItem(b)	   	( (b) &= ~fNDFirstItem )

#define	NDSetLastItem(b)	   	( (b) |= fNDLastItem )
#define	NDResetLastItem(b)	   	( (b) &= ~fNDLastItem )

//	macros
#define StNDKey(pb)					( (pb) + 1 )
#define PbNDKeyCb(pb)		  		( (pb) + 1 )
#define PbNDKey(pb)					( (pb) + 2 )
#define CbNDKey(pb)					( *( (pb) + 1 ) )
#define PbNDSonTable(pb)	  		( (pb) + 1 + 1 + *(pb + 1) )
#define PbNDSon(pb)			  		( (BYTE *)PbNDSonTable(pb) + 1 )
#define CbNDSonTable(pbSonTable)  	( *(BYTE *)(pbSonTable) )
#define CbNDSon(pbNode) \
	( FNDNullSon(*(pbNode)) ? 0 : *PbNDSonTable(pbNode) )
#define PgnoNDOfPbSon(pb) 		 	( *(PGNO UNALIGNED *)PbNDSon(pb) )
#define FNDNonIntrinsicSons(pbNode)	( !FNDNullSon(*pbNode) && ( FNDVisibleSons(*pbNode) || CbNDSon(pbNode) > 1 ) )
#define FNDIntrinsicSons(pbNode)	( !FNDNullSon(*pbNode) && !FNDVisibleSons(*pbNode) && CbNDSon(pbNode) == 1 )
#define PbNDBackLink(pb)											\
	( PbNDSonTable(pb) + ( FNDNullSon( *(pb) ) ? 0 :				\
	( ( ( *PbNDSonTable(pb) == 1 ) && FNDInvisibleSons( *(pb) ) ) ?	\
	sizeof(PGNO) + 1 : *PbNDSonTable(pb) + 1 ) ) )
#define PbNDData(pb) \
	( PbNDBackLink(pb) + ( FNDBackLink( *(pb) ) ? sizeof(SRID) : 0 ) )
#define CbNDData( pbNode, cbNode )	( (cbNode) - (INT)( PbNDData(pbNode) - (pbNode) ) )
#define ItagSonOfPbND(pb,ib)		( PbNDSonTable(pb)[ib] )
#define ItagSonOfPbSonTable(pb,ib) 	( pb[ib+1] )
#define ItagSonOfPbSon(pb,ib)		( pb[ib] )

#define NDGet( pfucb, itagT )		PMGet( &(pfucb)->ssib, itagT )

#ifdef DEBUG

#define AssertNDIntrinsicSon( pbNode, cbNode )							\
		{																\
		Assert( ( PbNDData( (pbNode) )) - (pbNode) <=					\
			(INT)(cbNode) ); 											\
		Assert( ( PgnoNDOfPbSon( pbNode ) & 0xff000000 ) == 0 );		\
		}																				

#define AssertNDGet( pfucb, itagT )										\
		{																\
		AssertPMGet( &(pfucb)->ssib, itagT ); 							\
		}

VOID AssertNDGetKey( FUCB *pfucb, INT itag );

VOID AssertNDGetNode( FUCB *pfucb, INT itag );

#else

#define AssertNDIntrinsicSon( pbNode, cbNode )
#define AssertNDGet( pfucb, itag )
#define AssertNDGetKey( pfucb, itag )
#define AssertNDGetNode( pfucb, itag )

#endif

#define NDIGetBookmarkFromCSR( pfucb, pcsr, psrid )												\
	{																							\
	if ( FNDBackLink( *((pfucb)->ssib.line.pb) ) )								\
		{																						\
		*(SRID *)(psrid) = *(SRID UNALIGNED *)PbNDBackLink((pfucb)->ssib.line.pb);	\
		Assert( PgnoOfPn(*(SRID *)psrid) != pgnoNull );							\
		}																						\
	else																						\
		{																						\
		*(psrid) = SridOfPgnoItag( (pcsr)->pgno, (pcsr)->itag );		 										\
		}																						\
	}

#define NDIGetBookmark( pfucb, psrid ) 		NDIGetBookmarkFromCSR( pfucb, \
													PcsrCurrent( pfucb ), \
													psrid )

#define NDGetBookmark( pfucb, psrid ) 		NDGetBookmarkFromCSR( pfucb,	\
													PcsrCurrent( pfucb ),	\
													psrid )

/*	item bits and macros.
/**/
#define fNDItemDelete					0x40000000
#define fNDItemVersion					0x80000000

#define FNDItemVersion( item )		( (item) & fNDItemVersion )
#define ITEMSetVersion( item )		( (item) |= fNDItemVersion )
#define ITEMResetVersion( item )		( (item) &= ~(fNDItemVersion) )

#define FNDItemDelete( item ) 		( (item) & fNDItemDelete )
#define ITEMSetDelete( item )			( (item) |= fNDItemDelete )
#define ITEMResetDelete( item )		( (item) &= ~(fNDItemDelete) )

#define BmNDOfItem( item )				((item) & ~( fNDItemVersion | fNDItemDelete ) )

#define	CitemND(pb, cb) \
	( ( cb - ( PbNDData(pb) - pb ) ) / sizeof(ITEM) )

#define	CitemNDData(pb, cb, pbData)	\
	( ( cb - ( (pbData) - pb ) ) / sizeof(ITEM) )

#define FNDSingleItem( pfucb )											\
	( ( (pfucb)->ssib.line.cb -		 									\
	( PbNDData( (pfucb)->ssib.line.pb ) - (pfucb)->ssib.line.pb ) )  	\
	/ sizeof(ITEM) == 1	)

//	LSridCmp
//	========================================================================
//	LONG LSridCmp( SRID *psrid1, SRID *psrid2 )
//
//	Compare the srids.
//
//	PARAMETERS	psrid1		   pointer to a item;
//					psrid2		   pointer to a item;
//
//	RETURNS		< 0, then the first srid is less than the second.
//					= 0, then the first srid is equal to the the second.
//					> 0, then the first srid is greater than the second.
//-
#define LSridCmp( srid1, srid2 )										\
	((LONG) ((SRID) BmNDOfItem( srid1 ) - (SRID) BmNDOfItem( srid2 )))

#ifdef DEBUG
	VOID NDCheckTreeInPage( PAGE *ppage, INT itagFather );
	#define	NDCheckPage( pssib )		NDCheckTreeInPage( (pssib)->pbf->ppage, itagFOP )
#else
	#define NDCheckTreeInPage( ppage, itagFather )
	#define NDCheckPage( pssib )
#endif

#define NDGetKey( pfucb )												\
	{																	\
	AssertNDGet( pfucb, PcsrCurrent(pfucb)->itag );	   					\
	(pfucb)->keyNode.cb = (INT)*((BYTE *)(pfucb)->ssib.line.pb + 1);	\
	(pfucb)->keyNode.pb = ( (BYTE *)(pfucb)->ssib.line.pb + 2 );		\
	}

//	node prototypes
ERR ErrNDNewPage( FUCB *pfucb, PGNO pgno, PGNO pgnoFDP, PGTYP pgtyp, BOOL fVisibleSons );
ERR ErrNDSetNodeHeader( FUCB *pfucb, BYTE bHeader );
VOID NDSeekSon( FUCB *pfucb, CSR *pcsr, KEY const *pkey, INT fFlags );
VOID NDMoveFirstSon( FUCB *pfucb, CSR *pcsr );
VOID NDMoveLastSon( FUCB *pfucb, CSR *pcsr );
ERR ErrNDMoveSon( FUCB *pfucb, CSR *pcsr );
VOID NDGetNode( FUCB *pfucb );
VOID NDGetBookmarkFromCSR( FUCB *pfucb, CSR *pcsr, SRID *psrid );

ERR ErrNDInsertNode( FUCB *pfucb, KEY const *pkey, LINE *plineData, INT fHeader, INT fFlags );
ERR ErrNDDeleteNode( FUCB *pfucb );
ERR ErrNDReplaceWithLink( FUCB *pfucb, SRID sridLink );
ERR ErrNDDeleteInvisibleSon(
		FUCB  	*pfucb,
		RMPAGE	*prmpage,
		BOOL  	fCheckRemoveParentOnly,
		BOOL  	*pfRmParent );
ERR ErrNDFlagDeleteNode( FUCB *pfucb, INT fFlags );
ERR ErrNDReplaceNodeData( FUCB *pfucb, LINE *pline, INT fFlags );
VOID NDResetNodeVersion( FUCB *pfucb );
VOID NDDeferResetNodeVersion( FUCB *pfucb );
VOID NDResetNodeDeleted( FUCB *pfucb );

ERR ErrNDGetItem( FUCB *pfucb );
ERR ErrNDFirstItem( FUCB *pfucb );
ERR ErrNDLastItem( FUCB *pfucb );
ERR ErrNDNextItem( FUCB *pfucb );
ERR ErrNDPrevItem( FUCB *pfucb );
ERR ErrNDSeekItem( FUCB *pfucb, SRID srid );

#define fNDCitemAll			(1<<0)
#define fNDCitemFromIsrid	(1<<1)
#define fNDCitemToIsrid		(1<<2)
INT CitemNDThere( FUCB *pfucb, BYTE fNDCitem, INT isrid );

ERR ErrNDInsertItemList( FUCB *pfucb, KEY *pkey, SRID srid, INT fFlags );
ERR ErrNDInsertItem( FUCB *pfucb, ITEM item, INT fFlags );
ERR ErrNDInsertItems( FUCB *pfucb, ITEM *rgitem, INT citem );
ERR ErrNDFlagInsertItem( FUCB *pfucb );											
ERR ErrNDDeleteItem( FUCB *pfucb );
ERR ErrNDFlagDeleteItem( FUCB *pfucb, BOOL fNoMPLRegister );
VOID NDSetItemDelete( FUCB *pfucb );
VOID NDResetItemVersion( FUCB *pfucb );
VOID NDResetItemDelete( FUCB *pfucb );
ERR ErrNDSplitItemListNode( FUCB *pfucb, INT fFlags );
ERR ErrNDDelta( FUCB *pfucb, LONG lDelta, INT fFlags );
ERR ErrNDDeltaNoCheckLog( FUCB *pfucb, LONG lDelta, INT fFlags );
ERR	ErrNDLockRecord( FUCB *pfucb );

ERR ErrNDInsertWithBackLink( FUCB *pfucb, BYTE bFlags, KEY const *pkey,
	LINE *plineSonTable, SRID sridBackLink, LINE *plineData );
VOID NDGetBackLink( FUCB *pfucb, PGNO *ppgno, INT *pitag );
ERR ErrNDExpungeBackLink( FUCB *pfucb );
ERR ErrNDExpungeLinkCommit( FUCB *pfucb, FUCB *pfucbSrc );
VOID NDGetItagFatherIbSon( INT *pitagFather, INT *pibSon, PAGE *ppage, INT itag );

#define FNDFreePageSpace( pssib, cbT )							\
		( ((INT)(pssib)->pbf->ppage->cbFree) < cbT ?		\
		fFalse :												\
		FVERCheckUncommittedFreedSpace( (pssib)->pbf, cbT ) )
INT CbNDFreePageSpace( BF *pbf );

BOOL FNDMaxKeyInPage( FUCB *pfucb );

#endif		// NODE_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\nver.h ===
/*	node status returned from VERAccess*
/**/
typedef enum
	{
	nsVersion,
	nsVerInDB,
	nsDatabase,
	nsInvalid
	} NS;

/*	version status returned from VERCheck
/**/
typedef enum
	{
	vsCommitted,
	vsUncommittedByCaller,
	vsUncommittedByOther
	} VS;

// ===========================================================================
// RCE (Revision Control Entry)

/*	operation type
/**/
typedef UINT OPER;

#define	operReplace					0
#define	operInsert					1
#define	operFlagDelete				2
#define	operNull					3	// to void an RCE

#define	operExpungeLink				4
#define	operExpungeBackLink			5
#define	operWriteLock				6
#define	operAllocExt				7
#define	operDeferFreeExt			8
#define	operDelete					9	// a real delete

#define	operReplaceWithDeferredBI	10	// recovery only, replace deferred before image.

#define	operDelta				0x0010

#define	operMaskItem			0x0020
#define	operInsertItem			0x0020
#define	operFlagInsertItem		0x0060
#define	operFlagDeleteItem		0x00a0

#define	operMaskDDL				0x0100
#define	operCreateTable	 		0x0100
#define	operDeleteTable			0x0300
#define	operRenameTable			0x0500
#define	operAddColumn			0x0700
#define	operDeleteColumn		0x0900
#define	operRenameColumn		0x0b00
#define	operCreateIndex	 		0x0d00
#define	operDeleteIndex	 		0x0f00
#define	operRenameIndex			0x1100

/*	create table:	table pgnoFDP
/*	rename table:	before image table name
/*	add column:		before image pfdb, NULL if not first DDL at level
/*	delete column:	before image pfdb, NULL if not first DDL at level
/*	rename column:	before image column name
/*	create index:	index pgnoFDP
/*	delete index:	index pfcb
/*	rename index:	before image index name
/**/

#define FOperDDL( oper )	 	( (oper) & operMaskDDL )
#define FOperItem( oper )	 	( (oper) & operMaskItem )

typedef struct _rce
	{
	struct _rce		*prceHashOverflow;		// hash over flow RCE chain
	struct _rce		*prcePrevOfNode;		// previous versions for same node, lower trx
	struct _rce		*prcePrevOfSession;		// previous RCE of same session
	struct _rce		*prceNextOfSession;		// next RCE of same session
	
	USHORT			ibPrev;					// index to prev RCE in bucket
	//	UNDONE:	DBID->BYTE and put with level
	LEVEL			level;					// current level of RCE, can change
	BYTE			bReserved;				// make it aligned.

	SRID			bm;						// bookmark of node
	TRX				trxPrev;				// time when previous RCE is committed
	TRX				trxCommitted; 			// time when this RCE is committed
	FUCB			*pfucb;					// for undo

	//	UNDONE:	OPER should be UINT16 and put with cbData
	OPER			oper;					// operation that causes creation of RCE

	DBID			dbid;  					// database id of node
	WORD			cbData;					// length of data portion of node

	//	UNDONE:	remove pfcb after unified bucket chain allows 
	//			presynchronized version clean up.
	FCB				*pfcb;					// for clean up
	//	UNDONE:	remove bmTarget and ulDBTime after VR bookmark implementation.
	//			These fields should not be necessary, since version store
	//			will be aware of node movements.
	SRID			bmTarget;			 	// for recovery of undo
	QWORD			qwDBTime;				// for recovery of undo

	struct	_bf		*pbfDeferredBI;			// which page deferred before image is on.
	struct	_rce	*prceDeferredBINext;	// link list for deferred before image.

#ifdef DEBUG
	QWORD			qwDBTimeDeferredBIRemoved;
#endif

	BYTE			rgbData[0];			 	// storing the data portion of a node
	} RCE;

/* first 2 SHORTs of rgbData are used to remember cbMax and cbAdjust for
 * each replace operation.
 */
#define cbReplaceRCEOverhead    (2 * sizeof(SHORT))


//============================================================================
// bucket

#define cbBucketHeader \
		( 2 * sizeof(struct _bucket *) + sizeof(UINT) )

#define cbBucket				16384	// number of bytes in a bucket

typedef struct _bucket
	{
	struct _bucket	*pbucketPrev;		// prev bucket for same user
	struct _bucket	*pbucketNext;		// next bucket for same user
 	UINT			ibNewestRCE;		// newest RCE within bucket
	BYTE 			rgb[ cbBucket - cbBucketHeader ];
	// space for storing RCEs
	} BUCKET;

/*	free extent parameter block
/**/
typedef struct {
	PGNO	pgnoFDP;
	PGNO	pgnoChildFDP;
	PGNO	pgnoFirst;
	CPG		cpgSize;
	} VEREXT;

/*	rename rollback parameter block
/**/
typedef struct {
	CHAR	szName[ JET_cbNameMost + 1 ];
	CHAR	szNameNew[ JET_cbNameMost + 1 ];
	} VERRENAME;


/* delete column rollback parameter block
/**/
typedef struct tagVERCOLUMN
	{
	JET_COLTYP	coltyp;				// column type
	FID			fid;				// field id
	} VERCOLUMN;


/*	ErrRCEClean flags
/**/
#define	fRCECleanSession	(1<<0)

ERR ErrVERInit( VOID );
VOID VERTerm( BOOL fNormal );
VS VsVERCheck( FUCB *pfucb, SRID bm );
NS NsVERAccessNode( FUCB *pfucb, SRID bm );
NS NsVERAccessItem( FUCB *pfucb, SRID bm );
ERR FVERUncommittedVersion( FUCB *pfucb, SRID bm );
ERR FVERDelta( FUCB *pfucb, SRID bm );
ERR ErrVERCreate( FUCB *pfucb, SRID bm, OPER oper, RCE **pprce );
ERR ErrVERModify( FUCB *pfucb, SRID bm, OPER oper, RCE **pprce);
BOOL FVERNoVersion( DBID dbid, SRID bm );
ERR ErrRCEClean( PIB *ppib, INT fCleanSession );
ERR ErrVERBeginTransaction( PIB *ppib );
VOID VERPrecommitTransaction( PIB *ppib );
VOID VERCommitTransaction( PIB *ppib, BOOL fCleanSession );
ERR ErrVERRollback(PIB *ppib);
RCE *PrceRCEGet( DBID dbid, SRID bm );
#define fDoNotUpdatePage	fFalse
#define fDoUpdatePage		fTrue
VOID VERSetCbAdjust(FUCB *pfucb, RCE *prce, INT cbDataNew, INT cbData, BOOL fNotUpdatePage );
INT CbVERGetNodeMax( DBID dbid, SRID bm );
INT CbVERGetNodeReserve( PIB *ppib, DBID dbid, SRID bm, INT cbCurrentData );
INT CbVERUncommittedFreed( BF *pbf );
BOOL FVERCheckUncommittedFreedSpace( BF *pbf, INT cbReq );
BOOL FVERItemVersion( DBID dbid, SRID bm, ITEM item );
BOOL FVERMostRecent( FUCB *pfucb, SRID bm );
VOID VERDeleteFromDeferredBIChain( RCE *prce );

#define ErrVERReplace( pfucb, srid, pprce ) 	ErrVERModify( pfucb, srid, operReplace, pprce )
#define ErrVERInsert( pfucb, srid )				ErrVERCreate( pfucb, srid, operInsert, pNil )
#define ErrVERFlagDelete( pfucb, srid ) 	 	ErrVERModify( pfucb, srid, operFlagDelete, pNil )
#define ErrVERInsertItem( pfucb, srid ) 		ErrVERCreate( pfucb, srid, operInsertItem, pNil )
#define ErrVERFlagInsertItem( pfucb, srid ) 	ErrVERModify( pfucb, srid, operFlagInsertItem, pNil )
#define ErrVERFlagDeleteItem( pfucb, srid ) 	ErrVERModify( pfucb, srid, operFlagDeleteItem, pNil )
#define ErrVERDelta( pfucb, srid )			 	ErrVERModify( pfucb, srid, operDelta, pNil )

#define ErrRCECleanAllPIB( )					ErrRCEClean( ppibNil, 0 )

#define	FVERPotThere( vs, fDelete )						  		\
	( ( (vs) != vsUncommittedByOther && !(fDelete) ) ||	  		\
		(vs) == vsUncommittedByOther )

ERR ErrVERFlag( FUCB *pfucb, OPER oper, VOID *pv, INT cb );
VOID VERDeleteRce( RCE *prce );

#define FVERUndoLoggedOper( prce )								\
		( prce->oper == operReplace ||							\
		  prce->oper == operInsert ||							\
		  prce->oper == operFlagDelete ||						\
		  prce->oper == operInsertItem ||						\
		  prce->oper == operFlagInsertItem ||					\
		  prce->oper == operFlagDeleteItem ||					\
		  prce->oper == operDelta )
ERR ErrVERUndo( RCE *prce );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\page.h ===
//
//------ Page Structure ---------------------------------------------------
//
										  	
#define cbPage	 		4096	 	// database logical page size

#define ctagMax		 	256 	 	// default limit on number of tags
										 	
typedef BYTE	PGTYP;

// the pragma is bad for efficiency, but we need it here so that the
// THREEBYTES will not be aligned on 4-byte boundary
#pragma pack(1)


typedef struct _pghdr
	{
	ULONG		ulChecksum;	  		//	checksum of page, always 1st byte
	ULONG		ulDBTimeLow;  		//	database time page dirtied
	PGNO		pgnoFDP;	  		//	pgno of FDP which owns this page
	SHORT		cbFree;  			//	count free bytes
	SHORT		ibMic;	  			//	minimum used byte
	SHORT		ctagMac; 	  		//	count tags used
	SHORT		itagFree;	  		//	itag of first free tag
	SHORT		cbUncommittedFreed;	//	bytes freed from this page, but *possibly*
									//	  uncommitted (this number will always be
									//	  a subset of cbFree)
	THREEBYTES	pgnoPrev;	  		//	pgno of previous page
	THREEBYTES	pgnoNext;	  		//	pgno of next page
	} PGHDR;

typedef struct _pgtrlr
	{
	PGTYP	   	pgtyp:3;
	BYTE		bDBTimeHigh:4;
	BYTE		bitModified:1;
	THREEBYTES 	pgnoThisPage;
	} PGTRLR;

typedef struct _tag
	{
	SHORT		cb;
	SHORT		ib;
	} TAG;

/* tag status
/**/
typedef enum { tsLine, tsVacant, tsLink } TS;

typedef struct _page
	{
	PGHDR;
	TAG  	   	rgtag[1];
	BYTE	   	rgbFiller[ cbPage -
					sizeof(PGHDR) -			// pghdr
					sizeof(TAG) -			// rgtag[1]
					sizeof(BYTE) -			// rgbData[1]
					sizeof(PGTRLR) ];		// pgtyp and pgnoThisPage
	BYTE	   	rgbData[1];

	PGTRLR;
	} PAGE;

#pragma pack()

STATIC INLINE VOID PMSetDBTime( PAGE *ppage, QWORD qwDBTime )
	{
	QWORDX qwx;
	qwx.qw = qwDBTime;
	ppage->bDBTimeHigh = (BYTE) qwx.h;
	ppage->ulDBTimeLow = qwx.l;
	}

STATIC INLINE QWORD QwPMDBTime( PAGE *ppage )
	{
	QWORDX qwx;
	qwx.l = ppage->ulDBTimeLow;
	qwx.h = (ULONG) ppage->bDBTimeHigh;
	return qwx.qw;
	}

STATIC INLINE VOID PMIncDBTime( PAGE *ppage )
	{
	QWORDX qwx;
	qwx.qw = QwPMDBTime( ppage );
	qwx.qw++;
	PMSetDBTime( ppage, qwx.qw );
	}

#define bitLink				(1L<<31)

#define pgtypFDP			((PGTYP) 0)
#define pgtypRecord			((PGTYP) 1)
#define	pgtypIndexNC		((PGTYP) 2)
#define pgtypSort			((PGTYP) 4)

#define PMSetPageType( ppage, pgtypT )	( (ppage)->pgtyp = pgtypT )
#define PMPageTypeOfPage( ppage )	( (PGTYP)( (ppage)->pgtyp) )

#ifdef DEBUG
VOID PMSetModified( SSIB *ssib );
VOID PMResetModified( SSIB *pssib );
VOID CheckPgno( PAGE *ppage, PN pn );
#else
#define CheckPgno( ppage, pn )
#define PMSetModified( pssib )			( (pssib)->pbf->ppage->bitModified = 1 )
#define PMResetModified( pssib ) 		( (pssib)->pbf->ppage->bitModified = 0 )
#endif

#define PMPageSetModified( ppage )		( (ppage)->bitModified = 1 )
#define PMPageResetModified( ppage )	( (ppage)->bitModified = 0 )
#define FPMPageModified( ppage )		( (ppage)->bitModified )

#define PMSetPgnoFDP( ppage, pgnoT )	( (ppage)->pgnoFDP = pgnoT )
#define PgnoPMPgnoFDPOfPage( ppage )  	( (ppage)->pgnoFDP )

#define SetPgno( ppage, pgno )					\
			ThreeBytesFromL( &(ppage)->pgnoThisPage, (pgno) )
#define SetPgnoNext( ppage, pgno )				\
			ThreeBytesFromL( &(ppage)->pgnoNext, (pgno) )
#define SetPgnoPrev( ppage, pgno )				\
			ThreeBytesFromL( &(ppage)->pgnoPrev, (pgno) )

#define PgnoFromPage( ppage, ppgno )			\
			LFromThreeBytes( ppgno, &(ppage)->pgnoThisPage )
	
#ifdef DEBUG	
#define PgnoNextFromPage( pssib, ppgno )		\
			{ CheckSSIB( pssib ); LFromThreeBytes( ppgno, &(pssib)->pbf->ppage->pgnoNext ); }
#define PgnoPrevFromPage( pssib, ppgno )		\
			{ CheckSSIB( (pssib) ); LFromThreeBytes( ppgno, &(pssib)->pbf->ppage->pgnoPrev ); }
#else
#define PgnoNextFromPage( pssib, ppgno )		\
			LFromThreeBytes( ppgno, &(pssib)->pbf->ppage->pgnoNext )
#define PgnoPrevFromPage( pssib, ppgno )		\
			LFromThreeBytes( ppgno, &(pssib)->pbf->ppage->pgnoPrev )
#endif

#define absdiff( x, y )	( (x) > (y)  ? (x)-(y) : (y)-(x) )
#define pgdiscont( pgno1, pgno2 ) \
	( ( (pgno1) == 0 ) || ( (pgno2) == 0 ) ? 0 \
	: absdiff( (pgno1), (pgno2) ) /  cpgDiscont )

#define ibPgnoPrevPage	( (INT) (ULONG_PTR)&((PAGE *)0)->pgnoPrev )
#define ibPgnoNextPage	( (INT) (ULONG_PTR)&((PAGE *)0)->pgnoNext )
#define ibCbFreeTotal	( (INT) (ULONG_PTR)&((PAGE *)0)->cbFree )
#define ibCtagMac	   	( (INT) (ULONG_PTR)&((PAGE *)0)->ctagMac )
#define ibPgtyp			( (INT) (ULONG_PTR)&((PAGE *)0)->pgtyp )

#define CbLastFreeSpace(ppage)							 		\
	( (ppage)->ibMic								 		\
		- sizeof(PGHDR)									 		\
		- ( sizeof(TAG) * (ppage)->ctagMac ) )

#define IbCbFromPtag( ibP, cbP, ptagP )							\
			{	TAG *_ptagT = ptagP;					 		\
			(ibP) = _ptagT->ib;							 		\
			(cbP) = _ptagT->cb;							 		\
			}

#define PtagFromIbCb( ptagP, ibP, cbP )	  						\
			{	TAG *_ptagT = ptagP;							\
			_ptagT->ib = (SHORT)(ibP);  						\
			_ptagT->cb = (SHORT)(cbP);							\
			}

#ifdef DEBUG
#define	PMGet( pssib, itagT )	CallS( ErrPMGet( pssib, itagT ) )
#else
#define PMGet( pssib, itagT ) 									\
	{															\
	PAGE *ppageT_ = (pssib)->pbf->ppage;						\
	TAG *ptagT_ = &(ppageT_->rgtag[itagT]);						\
	Assert( itagT >= 0 ); 										\
	Assert( itagT < (pssib)->pbf->ppage->ctagMac );		 		\
	(pssib)->line.pb = (BYTE *)ppageT_ + ptagT_->ib;			\
	(pssib)->line.cb = ptagT_->cb;								\
	}
#endif

#define	ItagPMMost( ppage )	((ppage)->ctagMac - 1)

BOOL FPMFreeTag( SSIB *pssib, INT citagReq );


#ifdef DEBUG
// This call does not guarantee the accuracy of cbUncommittedFree.
// If accuracy is needed, call CbNDFreePageSpace() instead.
#define CbPMFreeSpace( pssib )	( CheckSSIB(pssib),				\
	((INT)( (pssib)->pbf->ppage->cbFree - (pssib)->pbf->ppage->cbUncommittedFreed ) ) )
#else
#define CbPMFreeSpace( pssib )									\
	((INT)( (pssib)->pbf->ppage->cbFree - (pssib)->pbf->ppage->cbUncommittedFreed ) )
#endif


#if 0	// No longer needed with uncommitted freed page space count
#define	PMAllocFreeSpace( pssib, cb ) 					 						\
	{																							\
	Assert( (INT)(pssib)->pbf->ppage->cbFree >= cb );   	\
	(pssib)->pbf->ppage->cbFree -= cb;					\
	}

#define	PMFreeFreeSpace( pssib, cb ) 							\
	{															\
	Assert( (INT)(pssib)->pbf->ppage->cbFree >= 0 );  	\
	(pssib)->pbf->ppage->cbFree += cb;					\
	Assert( (INT)(pssib)->pbf->ppage->cbFree < cbPage ); 	\
	}
#endif

#ifdef DEBUG
#define AssertBTFOP(pssib)																\
	Assert( PMPageTypeOfPage((pssib)->pbf->ppage) == pgtypSort ||	\
		    PMPageTypeOfPage((pssib)->pbf->ppage) == pgtypFDP ||		\
			(pssib)->itag != 0 ||															\
			( CbNDKey( (pssib)->line.pb ) == 0 &&										\
			!FNDBackLink( *(pssib)->line.pb ) )											\
		  )
#else
#define AssertBTFOP( pssib )
#endif

#define PbPMGetChunk(pssib, ib)	 &(((BYTE *)((pssib)->pbf->ppage))[ib])	

INT CbPMLinkSpace( SSIB *pssib );
TS TsPMTagstatus( PAGE *ppage, INT itag );
VOID PMInitPage( PAGE *ppage, PGNO pgno, PGTYP pgtyp, PGNO pgnoFDP );
INT ItagPMQueryNextItag( SSIB *pssib );
ERR ErrPMInsert( SSIB *pssib, LINE *rgline, INT cline );
VOID PMDelete( SSIB *ssib );
ERR ErrPMReplace( SSIB *pssib, LINE *rgline, INT cline );
ERR ErrPMGet( SSIB *pssib, INT itag );
VOID PMGetLink( SSIB *pssib, INT itag, LINK *plink );
VOID PMExpungeLink( SSIB *pssib );
VOID PMReplaceWithLink( SSIB *pssib, SRID srid );
VOID PMReplaceLink( SSIB *pssib, SRID srid );
INT CPMIFreeTag( PAGE *ppage );
BOOL FPMEmptyPage( SSIB *pssib );
BOOL FPMLastNode( SSIB *pssib );
BOOL FPMLastNodeWithLinks( SSIB *pssib );

VOID PMDirty( SSIB *pssib );
VOID PMReadAsync( PIB *ppib, PN pn );
ERR  ErrPMAccessPage( FUCB *pfucb, PGNO pgno );

#ifdef DEBUG
VOID PageConsistent( PAGE *ppage );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\pib.h ===
/*	JET API flags
/**/
#define	FPIBVersion( ppib )	 					(!((ppib)->grbit & (JET_bitCIMCommitted | JET_bitCIMDirty)))
#define	FPIBCommitted( ppib ) 					((ppib)->grbit & JET_bitCIMCommitted)
#define	FPIBDirty( ppib ) 						((ppib)->grbit & JET_bitCIMDirty)
#define	FPIBAggregateTransaction( ppib )	 	((ppib)->grbit & JET_bitAggregateTransaction)
#define FPIBBMClean( ppib )						((ppib)->fBMCleanProc )
#define PIBSetBMClean( ppib ) 					((ppib)->fBMCleanProc = 1 )
#define PIBResetBMClean( ppib ) 				((ppib)->fBMCleanProc = 0 )

//
// Process Information Block
//
struct _pib
	{
	/*	most used field has offset 0
	/**/
	TRX					trxBegin0;				// trx id
	TRX					trxCommit0;

	/*	JET API fields
	/**/
	JET_SESID			sesid;					// JET session id
	JET_GRBIT			grbit;					// session flags
	
	struct _pib			*ppibNext;				// PIB list
	LEVEL			 	level;				 	// transaction level of this session
	LEVEL				levelRollback;			// transaction level which must be rolled back
	struct _dab			*pdabList;				// list of open DAB's of this thread
	USHORT				rgcdbOpen[dbidMax];		// counter for open databases
	struct _fucb		*pfucb;	 				// list of active fucb of this thread

	/*	logging/recovery fields
	/**/
	PROCID  		 	procid;				 	// thread id
	LGPOS			 	lgposStart;				// log time
	LEVEL			 	levelBegin;				// transaction level when first begin transaction operation
	LEVEL			 	levelDeferBegin;  		// count of deferred open transactions
	SIG				 	sigWaitLogFlush;
	LONG				lWaitLogFlush;
	LONG				grbitsCommitDefault;
	struct _pib			*ppibNextWaitFlush;
	struct _pib			*ppibPrevWaitFlush;
	LGPOS				lgposPrecommit0;		// level 0 precommit record position.

	/*	flags
	/**/
	BOOL				fUserSession:1;			// user session
	BOOL			 	fAfterFirstBT:1;  		// for redo only
	BOOL			 	fLGWaiting:1;	 		// waiting for log to flush
	BOOL				fBMCleanProc:1;			// session is for doing BMCleanup
//	BOOL				fDeferFreeNodeSpace:1;	// session has deferred node free space
	BOOL				fPrecommit:1;			// in precommit state? Recovery only
	BOOL				fBegin0Logged:1;		// begin transaction has logged
	BOOL				fSetAttachDB:1;			// set up attachdb.

	BOOL				fMacroGoing:1;
	BOOL				levelMacro:4;

	/*	version store fields
	/**/
	RCE					*prceNewest;			// newest RCE of session
	
#ifdef DEBUG
	DWORD				dwLogThreadId;
#endif
	
	/*	counters for the session.
	 */
	LONG				cAccessPage;			// counter of page access.
	LONG				cLatchConflict;			// counter of page latch conflicts.
	LONG				cSplitRetry;			// counter of split retries.
	LONG				cNeighborPageScanned;	// counter of neighboring page scanned.

	union {
	struct {									// Redo only.
		BYTE			*rgbLogRec;
		WORD			cbLogRecMac;
		WORD			ibLogRecAvail;
		};

	struct {									// Do only
		/*	array for internal macro operations.
		 */
		struct _bf		**rgpbfLatched;			// dynamically allocated array
		WORD			cpbfLatchedMac;			// for macro operations.
		WORD			ipbfLatchedAvail;		// for macro operations.
		};
	};

#ifdef PCACHE_OPTIMIZATION
	/*	pad to multiple of 32 bytes
	/**/
#ifdef DEBUG
	BYTE				rgbFiller[0];
#else
	BYTE				rgbFiller[4];
#endif
#endif
	};

#define PpibMEMAlloc()			(PIB*)PbMEMAlloc(iresPIB)

#ifdef DEBUG /*  Debug check for illegal use of freed pib  */
#define MEMReleasePpib(ppib)	{ MEMRelease(iresPIB, (BYTE*)(ppib)); ppib = ppibNil; }
#else
#define MEMReleasePpib(ppib)	{ MEMRelease(iresPIB, (BYTE*)(ppib)); }
#endif

extern PIB	*ppibGlobal;
extern PIB	*ppibGlobalMin;
extern PIB	*ppibGlobalMax;

PROCID ProcidPIBOfPpib( PIB *ppib );

STATIC INLINE PROCID ProcidPIBOfPpib( PIB *ppib )
	{
	return (PROCID)(((BYTE *)ppib - (BYTE *)ppibGlobalMin)/sizeof(PIB));
	}

STATIC INLINE PIB *PpibOfProcid( PROCID procid )
	{
	return ppibGlobalMin + procid;
	}

/*	PIB validation
/**/
#define ErrPIBCheck( ppib )												\
	( ( ppib >= ppibGlobalMin											\
	&& ppib < ppibGlobalMax												\
	&& ( ( (BYTE *)ppib - (BYTE *)ppibGlobalMin ) % sizeof(PIB) ) == 0	\
	&& ppib->procid == ProcidPIBOfPpib( ppib ) )						\
	? JET_errSuccess : JET_errInvalidSesid )

#define CheckPIB( ppib ) 											\
	Assert( ErrPIBCheck( ppib ) == JET_errSuccess					\
		&& (ppib)->level < levelMax )

#if 0
#define	FPIBDeferFreeNodeSpace( ppib )			( (ppib)->fDeferFreeNodeSpace )
#define	PIBSetDeferFreeNodeSpace( ppib )		( (ppib)->fDeferFreeNodeSpace = fTrue )
#define	PIBResetDeferFreeNodeSpace( ppib )		( (ppib)->fDeferFreeNodeSpace = fFalse )
#endif

#define FPIBActive( ppib )						( (ppib)->level != levelNil )

#define	SesidOfPib( ppib )						( (ppib)->sesid )

/*	prototypes
/**/
LONG CppibPIBUserSessions( VOID );
VOID RecalcTrxOldest( );
ERR ErrPIBBeginSession( PIB **pppib, PROCID procid );
VOID PIBEndSession( PIB *ppib );
#ifdef DEBUG
VOID PIBPurge( VOID );
#else
#define PIBPurge()
#endif

#define PIBUpdatePrceNewest( ppib, prce )				\
	{													\
	if ( (ppib)->prceNewest == (prce) )					\
		{												\
		Assert( (prce)->prceNextOfSession == prceNil );	\
		(ppib)->prceNewest = prceNil;					\
		}												\
	}

#define PIBSetPrceNewest( ppib, prce )					\
	{													\
	(ppib)->prceNewest = (prce);						\
	}


#define	PIBSetLevelRollback( ppib, levelT )				\
	{													\
	Assert( (levelT) > levelMin &&						\
		(levelT) < levelMax );							\
	Assert( (ppib)->levelRollback >= levelMin && 		\
		(ppib)->levelRollback < levelMax );				\
	if ( levelT < (ppib)->levelRollback ) 				\
		(ppib)->levelRollback = (levelT);				\
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\perfutil.h ===
#include <stdio.h>

#include "winperf.h"
#include "winreg.h"


extern void PerfUtilLogEvent( DWORD evncat, WORD evntyp, const char *szDescription );

extern HANDLE hOurEventSource;


	/*  Registry Support  */

extern DWORD DwPerfUtilRegOpenKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey,PHKEY phkResult);
extern DWORD DwPerfUtilRegCloseKeyEx(HKEY hkey);
extern DWORD DwPerfUtilRegCreateKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey,PHKEY phkResult,LPDWORD lpdwDisposition);
extern DWORD DwPerfUtilRegDeleteKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey);
extern DWORD DwPerfUtilRegDeleteValueEx(HKEY hkey,LPTSTR lpszValue);
extern DWORD DwPerfUtilRegSetValueEx(HKEY hkey,LPCTSTR lpszValue,DWORD fdwType,CONST BYTE *lpbData,DWORD cbData);
extern DWORD DwPerfUtilRegQueryValueEx(HKEY hkey,LPTSTR lpszValue,LPDWORD lpdwType,LPBYTE *lplpbData);


	/*  Init/Term  */

extern DWORD DwPerfUtilInit( VOID );
extern VOID PerfUtilTerm( VOID );


	//  pointer to shared data area and Mutex used to access the process name table.

extern void * pvPERFSharedData;
extern HANDLE hPERFSharedDataMutex;
extern HANDLE hPERFInstanceMutex;
extern HANDLE hPERFCollectSem;
extern HANDLE hPERFDoneEvent;
extern HANDLE hPERFProcCountSem;
extern HANDLE hPERFNewProcMutex;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\recapi.h ===
/*	hooks for efficient functioning of comapct
/**/
ERR ErrREClinkLid( FUCB *pfucb,
	FID		fid,
	LONG	lid,
	ULONG	itagSequence );	

/*	key extraction/normalization
/**/
ERR ErrRECNormExtKey(
	FUCB   		*pfucb,
	FDB			*pfdb,
	IDB			*pidb,
	LINE	 	*plineRec,
	LINE	 	*plineValues,
	KEY			*pkey,
	ULONG	 	itagSequence );

#define ErrRECRetrieveKeyFromCopyBuffer( pfucb, pfdb, pidb, pkey, itagSequence, fRetrieveBeforeImg ) \
		ErrRECIRetrieveKey( pfucb, pfdb, pidb, fTrue, pkey, itagSequence, fRetrieveBeforeImg )

#define ErrRECRetrieveKeyFromRecord( pfucb, pfdb, pidb, pkey, itagSequence, fRetrieveBeforeImg ) \
		ErrRECIRetrieveKey( pfucb, pfdb, pidb, fFalse, pkey, itagSequence, fRetrieveBeforeImg )

ERR ErrRECIRetrieveKey( 
	FUCB	 	*pfucb,
	FDB		 	*pfdb,
	IDB			*pidb, 
	BOOL		fCopyBuf,
	KEY			*pkey,
	ULONG		itagSequence,
	BOOL		fRetrieveBeforeImg );
	
ERR ErrRECIRetrieveColumnFromKey( FDB *pfdb, IDB *pidb, KEY *pkey, FID fid, LINE *plineValues );

/*	field extraction
/**/
ERR ErrRECIRetrieveColumn(
	FDB		*pfdb,
	LINE  	*plineRec,
	FID		*pfid,
	ULONG  	*pitagSequence,
	ULONG  	itagSequence,
	LINE   	*plineField,
	ULONG	grbit );

VOID RECDeferMoveFirst( PIB *ppib, FUCB *pfucb );

// ===================== EXPOSED CLIENT API ======================


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\recint.h ===
#define cbLVIntrinsicMost		1024
#define cbRECRecordMin			(sizeof(RECHDR) + sizeof(WORD))
								// 2 + 2 (for offset to tagged fields) = 4
#define cbRECRecordMost			(cbNodeMost - cbNullKeyData - JET_cbKeyMost)
								// 4047 - 8 - 255 = 3784

// For fixed columns, if null bit is 0, then column is null.  If null bit is 1,
// then column is non-null (opposite is true for variable columns -- great design!).
// Note that the fid passed in should already be converted to an index (ie. should
// subtract fidFixedLeast first).
#define FixedNullBit( ifid )	( 1 << ( (ifid) % 8 ) )
#define FFixedNullBit( pbitNullity, ifid )						\
		( !( *(pbitNullity) & FixedNullBit( ifid ) ) )			// True if NULL
#define SetFixedNullBit( pbitNullity, ifid )					\
		( *(pbitNullity) &= ~FixedNullBit( ifid ) )				// Set to 0 (null).
#define ResetFixedNullBit( pbitNullity, ifid )					\
		( *(pbitNullity) |= FixedNullBit( ifid ) )				// Set to 1 (non-null)



// Used to get offset from 2-byte VarOffset which includes null-bit.
// For variable columns, if null bit is 0, then column is non-null.  If null bit is 1,
// then column is null (opposite is true for variable columns -- great design!).
#define ibVarOffset(ibVarOffs)		( (ibVarOffs) & 0x0fff)
#define FVarNullBit(ibVarOffs)		( (ibVarOffs) & 0x8000)		// True if NULL
#define SetVarNullBit(ibVarOffs)  	( (ibVarOffs) |= 0x8000)	// Set to 1 (null)
#define ResetVarNullBit(ibVarOffs)	( (ibVarOffs) &= 0x7fff)	// Set to 0 (non-null)

// Used to flip highest bit of signed fields when transforming.
#define maskByteHighBit			(1 << (sizeof(BYTE)*8-1))
#define maskWordHighBit			(1 << (sizeof(WORD)*8-1))
#define maskDWordHighBit		(1L << (sizeof(ULONG)*8-1))
#define bFlipHighBit(b)			((BYTE)((b) ^ maskByteHighBit))
#define wFlipHighBit(w)			((WORD)((w) ^ maskWordHighBit))
#define ulFlipHighBit(ul)		((ULONG)((ul) ^ maskDWordHighBit))


/* The following are disk structures -- so pack 'em
/**/
#pragma pack(1)

/*	long column id is big-endian long
/**/
typedef LONG	LID;

/*	long value column in record format
/**/
typedef struct
	{
	BYTE	fSeparated;
	union
		{
		LID		lid;
		BYTE	rgb[];
		};
	} LV;

/*	long value root data format
/**/
typedef struct
	{
	ULONG		ulReference;
	ULONG		ulSize;
	} LVROOT;

#pragma pack()

#define	fIntrinsic				(BYTE)0
#define	fSeparate				(BYTE)1
#define	FFieldIsSLong( pb )		( ((LV *)(pb))->fSeparated )
#define	LidOfLV( pb ) 			( ((LV *)(pb))->lid )
#define	FlagIntrinsic( pb )		( ((LV *)(pb))->fSeparated = fIntrinsic )
#define	FlagSeparate( pb )		( ((LV *)(pb))->fSeparated = fSeparate )

#define	fLVReference			0
#define	fLVDereference			1

/* The following are disk structures -- so pack 'em
/**/
#pragma pack(1)

// Record header (beginning of every data record)
typedef struct _rechdr
	{
	BYTE	fidFixedLastInRec;	// highest fixed fid represented in record
	BYTE	fidVarLastInRec;	// highest var fid represented in record
	} RECHDR;

// Structure imposed upon a tagged field occurance in a record
typedef struct _tagfld
	{
	FID  	fid;				// field id of occurance

	union
		{
		WORD	cbData;			// length of data, including null bit
		struct
			{
			WORD	cb:15;		// length of following data (null bit stripped)
			WORD	fNull:1;	// Null instance (only occurs if default value set)
			};
		};

	BYTE	rgb[];				// data (extends off the end of the structure)
	} TAGFLD;

#pragma pack()

ULONG UlChecksum( BYTE *pb, ULONG cb );
ERR ErrRECSetCurrentIndex( FUCB *pfucb, CHAR *szIndex );
BOOL FRECIIllegalNulls( FDB *pfdb, LINE *plineRec );
ERR ErrRECRetrieveColumn( FUCB *pfucb, FID *pfid, ULONG itagSequence, LINE *plineField, ULONG grbit );
ERR ErrRECSetColumn( FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField );
VOID FLDFreeLVBuf( FUCB *pfucb );

ERR ErrRECSetLongField(
	FUCB 		*pfucb,
	FID 		fid,
	ULONG		itagSequence,
	LINE		*plineField,
	JET_GRBIT	grbit,
	LONG		ibOffset,
	ULONG		ulMax );
ERR ErrRECRetrieveSLongField(
	FUCB		*pfucb,
	LID			lid,
	ULONG		ibGraphic,
	BYTE		*pb,
	ULONG		cbMax,
	ULONG		*pcbActual );
ERR ErrRECDeleteLongFields( FUCB *pfucb, LINE *plineRecord );
ERR ErrRECAffectLongFields( FUCB *pfucb, LINE *plineRecord, INT fAll );
ERR ErrRECSeparateLV( FUCB *pfucb, LINE *plineField, LID *plid, FUCB **ppfucb );
ERR ErrRECAOSeparateLV( FUCB *pfucb, LID *plid, LINE *plineField, JET_GRBIT grbit, LONG ibLongValue, ULONG ulMax );
ERR ErrRECAffectSeparateLV( FUCB *pfucb, LID *plid, ULONG fLVAffect );
ERR ErrRECAOIntrinsicLV(
	FUCB		*pfucb,
	FID			fid,
	ULONG		itagSequence,
	LINE		*pline,
	LINE		*plineField,
	JET_GRBIT	grbit,
	LONG		ibLongValue );



#define	fSeparateAll				(INT)0
#define	fReference					(INT)1
#define	fDereference				(INT)2
#define	fDereferenceRemoved	 		(INT)3
#define	fDereferenceAdded	 		(INT)4

#define PtagfldNext( ptagfld )	( (TAGFLD UNALIGNED *)( (BYTE *)( (ptagfld) + 1 ) + (ptagfld)->cb ) )
#define FRECLastTaggedInstance( fidCurr, ptagfld, pbRecMax )		\
	( (BYTE *)PtagfldNext( (ptagfld) ) == (pbRecMax)  ||  			\
		PtagfldNext( (ptagfld) )->fid > (fidCurr) )


#define PibRECVarOffsets( pbRec, pibFixOffs )				\
	( (WORD UNALIGNED *)( (pbRec) + 						\
	(pibFixOffs)[((RECHDR *)(pbRec))->fidFixedLastInRec] +	\
	( ((RECHDR *)(pbRec))->fidFixedLastInRec + 7 ) / 8 ) )


#define ibTaggedOffset( pbRec, pibFixOffs )		\
	( PibRECVarOffsets( pbRec, pibFixOffs )[((RECHDR *)(pbRec))->fidVarLastInRec+1-fidVarLeast] )

#define ErrRECIRetrieveDefaultValue( pfdb, pfid, plineField )	\
	ErrRECIRetrieveColumn( pfdb, &(pfdb)->lineDefaultRecord, pfid, NULL, 1, plineField, 0 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\regenv.h ===
#ifndef _REGENV_H
#define _REGENV_H

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winreg.h>
#include <tchar.h>

#include <stdlib.h>

#include "jet.h"
#include "version.h"

#ifdef	__cplusplus
extern "C" {
#endif


DWORD LoadRegistryEnvironment( TCHAR *lpszApplication );


#ifdef	__cplusplus
}
#endif

#endif  // _REGENV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\perfdata.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1993 Microsoft Corporation.
*
* Component:
*
* File: perfdata.h
*
* File Comments:
*
*     Public header file for use with performance monitoring.
*
* Revision History:
*
*    [0]  13-Jul-94  t-andyg	Added this header
*
***********************************************************************/

#ifndef __PERFDATA_H__
#define __PERFDATA_H__


//
//  ADDING A PERFORMANCE OBJECT OR COUNTER
//
//  In order to add an object or counter to a translation unit, you must
//  perform the following steps:
//
//      o  add the object/counter's information to the performance
//         database in perfdata.txt (see this file for details)
//      o  add the object/counter's name and help text macros to
//         perfdata.src (see this file for an example)
//      o  add the object/counter's actual name and help text to
//         lang\???\perfdata.tok in the respective tokens (all languages)
//      o  define all data/functions referenced by the object/counter's
//         information in the database
//


//
//  NOTE:  some macros in this file require the inclusion of winperf.h
//


	//  Default detail level

#define PERF_DETAIL_DEFAULT		PERF_DETAIL_NOVICE

		
	//  Instance Catalog Function (typedef)
	//
	//  Returns a Unicode MultiSz containing all instances of the given object.
	//  This list can be static or dynamic and is reevaluated every time
	//  CollectPerformanceData() is called.  If no instances are returned,
	//  the Counter Evaluation Function will not be called.
	//
	//  Action codes for the passed long:
	//
	//      ICFData:  Pass pointer to string in *(void **) and return # instances
	//      ICFInit:  Perform any required initialization (return 0 on success)
	//      ICFTerm:  Perform any required termination (return 0 on success)
	//
	//  NOTE:  The caller is NOT responsible for freeing the string's buffer.
	//         The caller is also not permitted to modify the buffer.

typedef long (PM_ICF_PROC) ( long, void const ** );

#define ICFData		( 0 )
#define ICFInit		( 1 )
#define ICFTerm		( 2 )


	//  Counter Evaluation Function (typedef)
	//
	//  The function is given the index of the Instance that
	//  we need counter data for and a pointer to the location
	//  to store that data.
	//
	//  If the pointer is NULL, the passed long has the following
	//  special meanings:
	//
	//      CEFInit:  Initialize counter for all instances (return 0 on success)
	//      CEFTerm:  Terminate counter for all instances (return 0 on success)

typedef long (PM_CEF_PROC) ( long, void * );

#define CEFInit		( 1 )
#define CEFTerm		( 2 )


	//  Calculate the true size of a counter, accounting for DWORD padding

#define PerfSize( _x )			( ( _x ) &0x300 )
#define DWORD_MULTIPLE( _x )	( ( ( ( _x ) + sizeof( unsigned long ) - 1 )	\
								/ sizeof( unsigned long ) )						\
								* sizeof( unsigned long ) )
#define CntrSize( _a, _b )		( PerfSize( _a ) == 0x000 ? 4					\
								: ( PerfSize( _a ) == 0x100 ? 8					\
								: ( PerfSize( _a ) == 0x200 ? 0					\
								: ( DWORD_MULTIPLE( _b ) ) ) ) )


	//  initial count for inst count semaphore

#define PERF_INIT_INST_COUNT		0x7FFFFFFF


	//  shared data area

#define PERF_SIZEOF_SHARED_DATA		0x10000

#pragma pack( 4 )

typedef struct _SDA {
	unsigned long cCollect;				//  collect count (collect signal ID)
	unsigned long dwProcCount;			//  # Processes signaled to write data
	unsigned long iNextBlock;			//  Index of next free block
	unsigned long cbAvail;				//  Available bytes
	unsigned long ibTop;				//  Top of the allocation stack
	unsigned long ibBlockOffset[];		//  Offset to each block
} SDA, *PSDA;

#pragma pack()

	//  extern pointing to generated PERF_DATA_TEMPLATE in perfdata.c
	//
	//  NOTE:  the PerformanceData functions access this structure using
	//  its self contained offset tree, NOT using any declaration

extern void * const pvPERFDataTemplate;

	//  performance data version string (used to correctly match edb.dll
	//  and edbperf.dll versions as the name of the file mapping)

extern char szPERFVersion[];

	//  ICF/CEF tables in perfdata.c

extern PM_ICF_PROC* rgpicfPERFICF[];
extern PM_CEF_PROC* rgpcefPERFCEF[];

	//  # objects in perfdata.c

extern const unsigned long dwPERFNumObjects;

	//  object instance data tables in perfdata.c

extern long rglPERFNumInstances[];
extern wchar_t *rgwszPERFInstanceList[];

	//  # counters in perfdata.c

extern const unsigned long dwPERFNumCounters;

	//  maximum index used for name/help text in perfdata.c

extern const unsigned long dwPERFMaxIndex;

#endif /* __PERFDATA_H__  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\spaceint.h ===
/* Space Manager constants
*/
#define cSecFrac			4			// divider of primary extent to get secondary
										// extent size, =cpgPrimary/cpgSecondary
#define pgnoSysMax 			(1<<22)		// maximum page number allowed in database
extern LONG cpgSESysMin;				// minimum secondary extent size, default is 16
#define cpgSmallFDP			16			// count of owned pages below which an FDP
										// is considered small
#define cpgSmallGrow		3			// minimum count of pages to grow a small FDP

/* FUCB work area flags
*/
#define fNone				0
#define fSecondary			1
#define fFreed				2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\spaceapi.h ===
typedef struct tagEXTENTLIST
	{
	PGNO	pgnoLastInExtent;
	CPG		cpgExtent;
	} EXTENTINFO;

#define	fSPOwnedExtent	(1<<0)
#define	fSPAvailExtent	(1<<1)
#define fSPExtentLists	(1<<2)

#define FSPOwnedExtent( fSPExtents )	( (fSPExtents) & fSPOwnedExtent )
#define FSPAvailExtent( fSPExtents )	( (fSPExtents) & fSPAvailExtent )
#define FSPExtentLists( fSPExtents )	( (fSPExtents) & fSPExtentLists )


ERR ErrSPInitFDPWithoutExt( FUCB *pfucb, PGNO pgnoFDP );
ERR ErrSPInitFDPWithExt( FUCB *pfucb, PGNO pgnoFDPFrom, PGNO pgnoFirst, INT cpgReqRet, INT cpgReqWish );
ERR ErrSPGetExt( FUCB *pfucb,	PGNO pgnoFDP, CPG *pcpgReq,
	CPG cpgMin, PGNO *ppgnoFirst, BOOL fNewFDP );
ERR ErrSPGetPage( FUCB *pfucb, PGNO *ppgnoLast, BOOL fContig );
ERR ErrSPFreeExt( FUCB *pfucb, PGNO pgnoFDP, PGNO pgnoFirst,
	CPG cpgSize );
ERR ErrSPFreeFDP( FUCB *pfucb, PGNO pgnoFDP );
ERR ErrSPGetInfo( PIB *ppib, DBID dbid, FUCB *pfucb, BYTE *pbResult, INT cbMax, BYTE fSPExtents );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\scb.h ===
#ifndef _SCB_H
#define _SCB_H


//  Redirect Asserts in inline code to seem to fire from this file

#define szAssertFilename	__FILE__


//  includes

#include <stddef.h>


//  tune these constants for optimal performance

//  maximum amount of fast memory (cache) to use for sorting
#define cbSortMemFast					( 16 * ( 4088 + 1 ) )

//  maximum amount of normal memory to use for sorting
#define cbSortMemNorm					( 1024 * 1024L )

//  maximum size for memory resident Temp Table
#define cbResidentTTMax					( 64 * 1024L )

//  minimum count of sort pairs effectively sorted by Quicksort
//  NOTE:  must be greater than 2!
#define cspairQSortMin					( 32 )

//  maximum partition stack depth for Quicksort
#define cpartQSortMax					( 16 )

//  maximum count of runs to merge at once (fan-in)
#define crunFanInMax					( 16 )

//  I/O cluster size (in pages)
#define cpgClusterSize					( 2 )

//  define to use predictive preread instead of prereading all runs
//#define PRED_PREREAD


//  Sort Page structure
//
//  This is a custom page layout for use in the temporary database by sorting
//  only.  Sufficient structure still remains so that other page reading code
//  can recognize that they do not know this format and can continue on their
//  merry way.

#pragma pack(1)

typedef struct _spage
	{
	ULONG		ulChecksum;						//  page checksum
#ifdef PRED_PREREAD
	USHORT		ibLastSREC;						//  offset to last unbroken SREC
#endif  //  PRED_PREREAD
	BYTE		rgbData[						//  free data space =
						cbPage						//  page size
						- sizeof( ULONG )			//  - ulChecksum
#ifdef PRED_PREREAD
						- sizeof( USHORT )			//  - ibLastSREC
#endif  //  PRED_PREREAD
						- sizeof( PGTYP )			//  - pgtyp
						- sizeof( THREEBYTES )		//  - pgnoThisPage
					   ];
	PGTYP		pgtyp;							//  page type (== pgtypSort)
	THREEBYTES	pgnoThisPage;					//  this page's page number
	} SPAGE;
	
#pragma pack()

//  returns start of free data area in a sort page
STATIC INLINE BYTE *PbDataStartPspage( SPAGE *pspage )
	{
	return (BYTE *)( &pspage->rgbData);
	}

//  returns end of free data area in a sort page + 1
STATIC INLINE BYTE *PbDataEndPspage( SPAGE *pspage )
	{
	return (BYTE *)( &pspage->pgtyp );
	}

//  free data space per SPAGE
#define cbFreeSPAGE 				( offsetof( SPAGE, pgtyp ) - offsetof( SPAGE, rgbData ) )

//  maximum count of SPAGEs' data that can be stored in normal sort memory
#define cspageSortMax				( cbSortMemNorm / cbFreeSPAGE )

//  amount of normal memory actually used for sorting
//  (designed to make original runs fill pages exactly)
#define cbSortMemNormUsed			( cspageSortMax * cbFreeSPAGE )


//  Sort Pair in fast sort memory
//
//  (key prefix, index) pairs are sorted so that most of the data that needs
//  to be examined during a sort will be loaded into cache memory, allowing
//  the sort to run very fast.  If two key prefixes are equal, we must go out
//  to slower memory to compare the remainder of the keys (if any) to determine
//  the proper sort order.  This makes it important for the prefixes to be as
//  discriminatory as possible for each record.
//
//  CONSIDER:  adding a flag to indicate that the entire key is present
//
//  Indexes are compressed pointers that describe the record's position in
//  the slow memory sort buffer.  Each record's position can only be known to
//  a granularity designated by the size of the normal sort memory.  For
//  example, if you specify 128KB of normal memory, the granularity is 2
//  because the index can only take on 65536 values:
//      ceil( ( 128 * 1024 ) / 65536 ) = 2.

//  size of key prefix (in bytes)
#define cbKeyPrefix				( 14 )

#pragma pack(1)

//  NOTE:  sizeof(SPAIR) must be a power of 2 >= 8
typedef struct _spair
	{
	USHORT		irec;					//  record index
	BYTE		rgbKey[cbKeyPrefix];	//  key prefix
	} SPAIR;

#pragma pack()

//  addressing granularity of record indexes (fit indexes into USHORT)
//      (run disk usage is optimal for cbIndexGran == 1)
#define cbIndexGran						( ( cbSortMemNormUsed + 0xFFFFL ) / 0x10000L )

//  maximum index of records that can be stored in normal memory
#define irecSortMax						( cbSortMemNormUsed / cbIndexGran )

//  maximum count of SPAIRs' data that can be stored in fast sort memory
//  NOTE:  we are reserving one for temporary sort key storage (at cspairSortMax)
#define cspairSortMax					( cbSortMemFast / sizeof( SPAIR ) - 1 )

//  amount of fast memory actually used for sorting (counting reserve SPAIR)
#define cbSortMemFastUsed				( ( cspairSortMax + 1 ) * sizeof( SPAIR ) )

//  count of "Sort Record indexes" required to store count bytes of data
//      (This is fast if numbers are chosen to make cbIndexGran a power of 2
//      (especially 1) due to compiler optimizations)
STATIC INLINE LONG CirecToStoreCb( LONG cb )
	{
	return ( cb + cbIndexGran - 1 ) / cbIndexGran;
	}


//  generalized Sort Record type (encompasses all types)
//  NOTE:  using void blocks illegal declarations, pointer math, etc

typedef VOID SREC;


//  Unique run identifier (first page of run = run id)

typedef PGNO		RUN;

#define runNull		( (RUN) pgnoNull )
#define crunAll		( 0x7FFFFFFFL )


//  Run Information structure

typedef struct _runinfo
	{
	RUN		run;			//  this run
	CPG		cpg;			//  count of pages in run
	LONG	cb;				//  count of bytes of data in run
	LONG	crec;			//  count of records in each run
	CPG		cpgUsed;		//  count of pages actually used
	} RUNINFO;


//  Run Link structure (used in RUNLIST)

typedef struct _runlink
	{
	struct _runlink		*prunlinkNext;	//  next run
	RUNINFO				runinfo;		//  runinfo for this run
	} RUNLINK;

#define prunlinkNil		( (RUNLINK *) 0 )


//  RUNLINK allocation operators

#define PrunlinkRUNLINKAlloc()			( (RUNLINK *) LAlloc( 1, sizeof( RUNLINK ) ) )

#ifdef DEBUG					/*  Debug check for illegal use of freed runlink  */
#define RUNLINKReleasePrcb(prunlink)	{ LFree( prunlink ); prunlink = prunlinkNil; }
#else
#define RUNLINKReleasePrcb(prunlink)	{ LFree( prunlink ); }
#endif


//  Run List structure

typedef struct _runlist
	{
	RUNLINK			*prunlinkHead;		//  head of runlist
	LONG			crun;				//  count of runs in list
	} RUNLIST;


//  Merge Tree Node
//
//  These nodes are used in the replacement-selection sort tree that merges
//  the incoming runs into one large run.  Due to the way the tree is set up,
//  each node acts as both an internal (loser) node and as an external (input)
//  node, with the exception of node 0, which keeps the last winner instead
//  of a loser.

typedef struct _mtnode
	{
	//  external node
	struct _rcb		*prcb;				//  input run
	struct _mtnode	*pmtnodeExtUp;		//  pointer to father node
	
	//  internal node
	SREC			*psrec;				//  current record
	struct _mtnode	*pmtnodeSrc;		//  record's source node
	struct _mtnode	*pmtnodeIntUp;		//  pointer to father node
	} MTNODE;

//  Special values for psrec for replacement-selection sort.  psrecNegInf is a
//  sentinel value less than any possible key and is used for merge tree
//  initialization.  psrecInf is a sentinel value greater than any possible key
//  and is used to indicate the end of the input stream.
#define psrecNegInf					( (SREC *) -1L )
#define psrecInf					( (SREC *) NULL )


//  Optimized Tree Merge Node
//
//  These nodes are used to build the merge plan for the depth first merge of
//  an optimized tree merge.  This tree is built so that we perform the merges
//  from the smaller side of the tree to the larger side of the tree, all in
//  the interest of increasing our cache locality during the merge process.

typedef struct _otnode
	{
	RUNLIST			runlist;					//  list of runs for this node
	struct _otnode	*rgpotnode[crunFanInMax];	//  subtrees for this node
	struct _otnode	*potnodeAllocNext;			//  next node (allocation)
	struct _otnode	*potnodeLevelNext;			//  next node (level)
	} OTNODE;

#define potnodeNil		( (OTNODE *) 0 )

//  Special value for potnode for the optimized tree merge tree build routine.
//  potnodeLevel0 means that the current level is comprised of original runs,
//  not of other merge nodes.
#define potnodeLevel0	( (OTNODE *) -1L )


//  OTNODE allocation operators

#define PotnodeOTNODEAlloc()			( (OTNODE *) LAlloc( 1, sizeof( OTNODE ) ) )

#ifdef DEBUG					/*  Debug check for illegal use of freed otnode  */
#define OTNODEReleasePotnode(potnode)	{ LFree( potnode ); potnode = potnodeNil; }
#else
#define OTNODEReleasePotnode(potnode)	{ LFree( potnode ); }
#endif


//  Sort Control Block (SCB)

typedef struct _scb
	{
	FCB			fcb;						//  FCB MUST BE FIRST FIELD IN STRUCTURE
	JET_GRBIT	grbit;		 				//  sort grbit
	INT			fFlags;						//  sort flags

	LONG		cRecords;					//  count of records in sort
	
	//  memory-resident sorting
	SPAIR		*rgspair;					//  sort pair buffer
	LONG		ispairMac;					//  next available sort pair

	BYTE		*rgbRec;					//  record buffer
	LONG		cbCommit;					//  amount of committed buffer space
	LONG		irecMac;					//  next available record index
	LONG		crecBuf;					//  count of records in buffer
	LONG		cbData;						//  total record data size (actual)

	//  disk-resident sorting
	LONG		crun;						//  count of original runs generated
	RUNLIST		runlist;					//  list of runs to be merged

	//  sort/merge run output
	PGNO		pgnoNext;					//  next page in output run
	struct _bf	*pbfOut;					//  current output buffer
	BYTE		*pbOutMac;					//  next available byte in page
	BYTE		*pbOutMax;					//  end of available page

	//  merge (replacement-selection sort)
	LONG		crunMerge;					//  count of runs being read/merged
	MTNODE		rgmtnode[crunFanInMax];		//  merge tree

	//  merge duplicate removal
	BOOL		fUnique;					//  remove duplicates during merge
	struct _bf	*pbfLast;					//  last used read ahead buffer
	struct _bf	*pbfAssyLast;				//  last used assembly buffer

#ifdef PCACHE_OPTIMIZATION
	/*	pad to multiple of 32 bytes
	/**/
	BYTE				rgbFiller[12];
#endif
	} SCB;


//  SCB allocation operators

#define PscbMEMAlloc()			(SCB *)PbMEMAlloc( iresSCB )

#ifdef DEBUG					/*  Debug check for illegal use of freed scb  */
#define MEMReleasePscb(pscb)	{ MEMRelease( iresSCB, (BYTE *) ( pscb ) );  pscb = pscbNil; }
#else
#define MEMReleasePscb(pscb)	{ MEMRelease( iresSCB, (BYTE *) ( pscb ) ); }
#endif


//  SCB fFlags

#define	fSCBInsert	 	(1<<0)
#define	fSCBIndex	 	(1<<1)
#define	fSCBUnique	 	(1<<2)

//  SCB fFlags operators

STATIC INLINE VOID SCBSetInsert( SCB *pscb )	{ pscb->fFlags |= fSCBInsert; }
STATIC INLINE VOID SCBResetInsert( SCB *pscb )	{ pscb->fFlags &= ~fSCBInsert; }
STATIC INLINE BOOL FSCBInsert( SCB *pscb )		{ return pscb->fFlags & fSCBInsert; }

STATIC INLINE VOID SCBSetIndex( SCB *pscb )		{ pscb->fFlags |= fSCBIndex; }
STATIC INLINE VOID SCBResetIndex( SCB *pscb )	{ pscb->fFlags &= ~fSCBIndex; }
STATIC INLINE BOOL FSCBIndex( SCB *pscb )		{ return pscb->fFlags & fSCBIndex; }

STATIC INLINE VOID SCBSetUnique( SCB *pscb )	{ pscb->fFlags |= fSCBUnique; }
STATIC INLINE VOID SCBResetUnique( SCB *pscb )	{ pscb->fFlags &= ~fSCBUnique; }
STATIC INLINE BOOL FSCBUnique( SCB *pscb )		{ return pscb->fFlags & fSCBUnique; }


//  Sort Record in normal sort memory
//
//  There are two types of Sort Records.  One type, SRECD, is used for general
//  sort records and can have an abitrary record data field.  The second type,
//  SRECI, is used when we know we are sorting Key/SRID records during index
//  creation.  SRECI is more compact and therefore allows more records to fit
//  in each run in this special (and common) case.

#pragma pack(1)

typedef struct _srecd
	{
	USHORT		cbRec;			//  record size
	BYTE		cbKey;			//  key size
	BYTE		rgbKey[];		//  key
//	BYTE		rgbData[];		//  data (just for illustration)
	} UNALIGNED SRECD;

typedef struct _sreci
	{
	BYTE		cbKey;			//  key size
	BYTE		rgbKey[];		//  key
//  SRID		srid;			//  srid (just for illistration)
	} UNALIGNED SRECI;

#pragma pack()

//  minimum amount of record that must be read in order to retrieve its size
#define cbSRECReadMin							( offsetof( SRECD, cbKey ) )

//  the following functions abstract different operations on a sort record pointer
//  to perform the appropriate operations, depending on the flags set in the SCB

//  returns size of an existing sort record
STATIC INLINE LONG CbSRECSizePscbPsrec( SCB *pscb, SREC *psrec )
	{
	if ( FSCBIndex( pscb ) )
		return sizeof( SRECI ) + ( (SRECI *) psrec )->cbKey + sizeof( SRID );
	return ( (SRECD * ) psrec )->cbRec;
	}

//  calculates size of a potential sort record
STATIC INLINE LONG CbSRECSizePscbCbCb( SCB *pscb, LONG cbKey, LONG cbData )
	{
	if ( FSCBIndex( pscb ) )
		return sizeof( SRECI ) + cbKey + sizeof( SRID );
	return sizeof( SRECD ) + cbKey + cbData;
	}

//  sets size of sort record
STATIC INLINE VOID SRECSizePscbPsrecCb( SCB *pscb, SREC *psrec, LONG cb )
	{
	if ( !FSCBIndex( pscb ) )
		( (SRECD * ) psrec )->cbRec = (USHORT) cb;
	}

//  returns size of sort record key
STATIC INLINE LONG CbSRECKeyPscbPsrec( SCB *pscb, SREC *psrec )
	{
	if ( FSCBIndex( pscb ) )
		return ( (SRECI *) psrec )->cbKey;
	return ( (SRECD * ) psrec )->cbKey;
	}

//  sets size of sort record key
STATIC INLINE VOID SRECKeySizePscbPsrecCb( SCB *pscb, SREC *psrec, LONG cb )
	{
	if ( FSCBIndex( pscb ) )
		( (SRECI *) psrec )->cbKey = (BYTE) cb;
	else
		( (SRECD *) psrec )->cbKey = (BYTE) cb;
	}

//  returns sort record key buffer pointer
STATIC INLINE BYTE *PbSRECKeyPscbPsrec( SCB *pscb, SREC *psrec )
	{
	if ( FSCBIndex( pscb ) )
		return ( (SRECI *) psrec )->rgbKey;
	return ( (SRECD *) psrec )->rgbKey;
	}

//  returns sort record key as a Pascal string
STATIC INLINE BYTE *StSRECKeyPscbPsrec( SCB *pscb, SREC *psrec )
	{
	if ( FSCBIndex( pscb ) )
		return &( (SRECI *) psrec )->cbKey;
	return &( (SRECD *) psrec )->cbKey;
	}

//  returns size of sort record data
STATIC INLINE LONG CbSRECDataPscbPsrec( SCB *pscb, SREC *psrec )
	{
	if ( FSCBIndex( pscb ) )
		return sizeof( SRID );
	return ( (SRECD *) psrec )->cbRec - ( (SRECD *) psrec )->cbKey - sizeof( SRECD );
	}

//  returns sort record data buffer pointer
STATIC INLINE BYTE *PbSRECDataPscbPsrec( SCB *pscb, SREC *psrec )
	{
	if ( FSCBIndex( pscb ) )
		return ( (SRECI *) psrec )->rgbKey + ( (SRECI *) psrec )->cbKey;
	return ( (SRECD * ) psrec )->rgbKey + ( (SRECD * ) psrec )->cbKey;
	}

//  returns pointer to a sort record given a base address and a Sort Record Index
STATIC INLINE SREC *PsrecFromPbIrec( BYTE *pb, LONG irec )
	{
	return (SREC *) ( pb + irec * cbIndexGran );
	}


//  Run Control Block
//
//  This control block is used for multiple instance use of the run input
//  functions ErrSORTIRunOpen, ErrSORTIRunNext, and ErrSORTIRunClose.

typedef struct _rcb
	{
	SCB				*pscb;					//  associated SCB
	RUNINFO			runinfo;				//  run information
	struct _bf		*rgpbf[cpgClusterSize];	//  pinned read ahead buffers
	LONG			ipbf;					//  current buffer
	BYTE			*pbInMac;				//  next byte in page data
	BYTE			*pbInMax;				//  end of page data
	LONG			cbRemaining;			//  remaining bytes of data in run
#ifdef PRED_PREREAD
	SREC			*psrecPred;				//  SREC used for predictive preread
#endif  //  PRED_PREREAD
	struct _bf		*pbfAssy;				//  record assembly buffer
	} RCB;

#define prcbNil		( (RCB *) 0 )


//  RCB allocation operators

#define PrcbRCBAlloc()			( (RCB *) LAlloc( 1, sizeof( RCB ) ) )

#ifdef DEBUG					/*  Debug check for illegal use of freed rcb  */
#define RCBReleasePrcb(prcb)	{ LFree( prcb ); prcb = prcbNil; }
#else
#define RCBReleasePrcb(prcb)	{ LFree( prcb ); }
#endif


//#define UtilPerfDumpStats( a )	( 0 )


//  End Assert redirection

#undef szAssertFilename

#endif  // _SCB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\taskmgr.h ===
/*	bogus include file for jet compatibility
/**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\sortapi.h ===
ERR ErrSORTInsert( FUCB *pfucb, LINE rglineKeyRec[] );
ERR ErrSORTEndInsert( FUCB *pfucb );
ERR ErrSORTFirst( FUCB *pfucb );
ERR ErrSORTNext( FUCB *pfucb );
ERR ErrSORTPrev( FUCB *pfucb );
ERR ErrSORTSeek( FUCB *pfucb, KEY *pkey, BOOL fGT );
ERR ErrSORTOpen( PIB *ppib, FUCB **ppfucb, INT fFlags );
ERR ErrSORTClose( FUCB *pfucb );
VOID SORTClosePscb( SCB *pscb );
ERR ErrSORTCheckIndexRange( FUCB *pfucb );

// ======================== API ============================

ERR VTAPI ErrIsamSortOpen(
	PIB 			*ppib,
	JET_COLUMNDEF	*rgcolumndef,
	ULONG 			ccolumndef,
	ULONG			langid,
	JET_GRBIT		grbit,
	FUCB			**ppfucb,
	JET_COLUMNID	*rgcolumnid );

ERR VTAPI ErrIsamSortMove(
	PIB				*ppib,
	FUCB			*pfucb,
	long			crow,
	JET_GRBIT		grbit );

ERR VTAPI ErrIsamSortSetIndexRange( 
	PIB				*ppib,
	FUCB			*pfucb,
	JET_GRBIT		grbit );

ERR VTAPI ErrIsamSortInsert(
	PIB				*ppib,
	FUCB			*pfucb,
	BYTE			*pb,
	ULONG			cbMax,
	ULONG			*pcbActual );

ERR VTAPI ErrIsamSortSeek( 
	PIB				*ppib,
	FUCB			*pfucb,
	JET_GRBIT		grbit );

ERR VTAPI ErrIsamSortDupCursor( 
	PIB				*ppib,
	FUCB			*pfucb,
	JET_TABLEID		*tableid,
	JET_GRBIT		ulFlags);

ERR VTAPI ErrIsamSortClose(
	PIB				*ppib,
	FUCB			*pfucb );

ERR VTAPI ErrIsamSortGotoBookmark( 
	PIB				*ppib,
	FUCB			*pfucb,
	void 			*pv,
	unsigned long	cbBookmark );

ERR VTAPI ErrIsamSortGetTableInfo(
	PIB				*ppib,
	FUCB			*pfucb,
	void			*pv,
	unsigned long	cbOutMax,
	unsigned long	lInfoLevel );

ERR VTAPI ErrIsamCopyBookmarks( 
	PIB				*ppib,
	FUCB			*pfucbSrc,
	FUCB			*pfucbDest,
	JET_COLUMNID	columnidDest, 
	unsigned long	crecMax,
	unsigned long	*pcrowCopied,
	unsigned long	*precidLast );

ERR VTAPI ErrIsamSortRetrieveKey( 
	PIB				*ppib,
	FUCB			*pfucb,
	void			*pb, 
	unsigned long	cbMax, 
	unsigned long	*pcbActual, 
	JET_GRBIT 		grbit );

ERR VTAPI ErrIsamSortGetBookmark( 
	PIB				*ppib,
	FUCB			*pfucb,
	void			*pb, 
	unsigned long	cbMax, 
	unsigned long	*pcbActual );

ERR VTAPI ErrIsamSortMaterialize(
	PIB				*ppib,
	FUCB			*pfucb,
	BOOL			fIndex );
	
ERR VTAPI ErrIsamSortEndInsert(
	PIB				*ppib,
	FUCB			*pfucb,
	JET_GRBIT 		*pgrbit );
	
typedef struct _vl
	{
	short	vlt;
	union
		{
		BYTE rgb[8];
		short int	 i2;
		unsigned long sd;
		};
	} VL;


ERR VTAPI ErrIsamGetVL(
	PIB				*ppib,
	JET_TABLEID		tableid,
	int				itib,
	JET_COLUMNID	columnid,
	VL				*pvl );

ERR VTAPI ErrIsamSetVL(
	PIB				*ppib,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	VL				*pvl );



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\valtag.h ===
#define HardType	0x8000

#ifndef FV_VALUE
#define FV_VALUE 1		       /* Default ON */
#endif	/* !FV_VALUE */

#ifndef FV_CURRENCY
#define FV_CURRENCY -1		       /* Default ON */
#endif	/* !FV_CURRENCY */

enum {
#if	FV_VALUE
	tagEmpty,		       /* Uninitialized */
	tagNull,		       /* Database NULL */
#endif	/* FV_VALUE */
	tagI2,
	tagI4,
	tagR4,
	tagR8,
#if	FV_CURRENCY
	tagCY,
#endif	/* FV_CURRENCY */
#if	FV_VALUE
	tagDT,			       /* Date */
#endif	/* FV_VALUE */
	tagSD,			       /* String */
	tagOB,			       /* Object */
	tagR10, 		       /* Intermediate FP value */

	tagMaxNum = tagSD-1,
	tagMax = tagSD, 	       /* Max standard tag */
	tagMaxExt =tagR10	       /* Max extended tag */
};


	/* Operator constants for users of EB's expression service */

enum {
	operUMi = 0,
	operNot = 2,
	operAdd = 4,
	operSub = 6,
	operMul = 8,
	operDiv = 10,
	operPwr = 12,
	operMod = 14,
	operIDv = 16,
	operXor = 18,
	operEqv = 20,
	operComp= 22,
	operLike= 24,
	operConcat= 26
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\ssib.h ===
//
// Storage System Interface Block
//

struct _ssib
	{
	struct _pib		*ppib;				// process using this SSIB
	struct _bf		*pbf;				// ptr to page that cusr on, or pbcbNil
	LINE		 	line;				// cb/pb of current record
	INT				itag;				// current line
	};


#define SetupSSIB( pssibT, ppibUser )  	 	\
	{								  	 	\
	(pssibT)->pbf = pbfNil; 			 	\
	(pssibT)->ppib = ppibUser;		   	 	\
	}

#define SSIBSetDbid( pssib, dbid )
#define SSIBSetPgno( pssib, pgno )

#ifdef DEBUG
#define	CheckSSIB( pssib )				 	\
		Assert( pssib->pbf != pbfNil )
#else
#define CheckSSIB( pssib )	((VOID) 0)
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\stats.h ===
#pragma pack(1)
typedef struct
	{
	ULONG				cItems;
	ULONG				cKeys;
	ULONG				cPages;
	JET_DATESERIAL	dtWhenRun;
	} SR;
#pragma pack()

ERR ErrSTATSComputeIndexStats( PIB *ppib, FCB *pfcbIdx, FUCB *pfucb );

ERR ErrSTATSRetrieveTableStats( 
	PIB		*ppib,				
	DBID  	dbid, 			 	
	char  	*szTable,
	long  	*pcRecord,
	long  	*pcKey,
	long  	*pcPage );

ERR ErrSTATSRetrieveIndexStats(
	FUCB		*pfucbTable,
	char		*szIndex,
	BOOL		fClustered,
	long		*pcItem,
	long		*pcKey,
	long		*pcPage );


// This actually belongs in systab.h, but then we'd have a cyclic dependency
// on SR.
ERR ErrCATStats(PIB *ppib, DBID dbid, OBJID objidTable, CHAR *sz2ndIdxName,
	SR *psr, BOOL fWrite);;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\std.h ===
#include "config.h"		       /* Build configuration file */

#include "jet.h"		       /* Public JET API definitions */
#include "_jet.h"		       /* Private JET definitions */

#include "utilw32.h"           /* Win32 Utility functions */

#include "taskmgr.h"
#include "vtmgr.h"
#include "_vtmgr.h"

#include "isamapi.h"           /* Direct ISAM APIs */
#include "vtapi.h"		       /* Dispatched table APIs */

#include "disp.h"		       /* ErrDisp prototypes */
#include "jetord.h"
#include "_jetstr.h"


#include "perfdata.h"          /*  JET performance data collection  */


#include <stdlib.h>
#include <string.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\stapi.h ===
#ifndef _STAPI_H
#define _STAPI_H


//  Redirect Asserts in inline code to seem to fire from this file

#define szAssertFilename	__FILE__


//---- externs -------------------------------------------------------------

extern CRIT	 critBuf;
extern TRX  trxOldest;
extern TRX  trxNewest;
extern CRIT  critCommit0;

extern SIG  sigBFCleanProc;

//---- IO (io.c) ----------------------------------------------------------

ERR ErrIOInit( VOID );
ERR ErrIOTerm( BOOL fNormal );

/*	Reserve first 2 pages of a database.
 */
#define	cpageDBReserved 2
STATIC INLINE LONG LOffsetOfPgnoLow( PGNO pgno )	{ return ( pgno -1 + cpageDBReserved ) << 12; }
STATIC INLINE LONG LOffsetOfPgnoHigh( PGNO pgno )	{ return ( pgno -1 + cpageDBReserved ) >> 20; }

VOID IOCloseFile( HANDLE hf );
ERR ErrIONewSize( DBID dbid, CPG cpg );

BOOL FIOFileExists( CHAR *szFileName );
ERR ErrIOLockDbidByNameSz( CHAR *szFileName, DBID *pdbid );
ERR ErrIOLockDbidByDbid( DBID dbid );
ERR ErrIOLockNewDbid( DBID *pdbid, CHAR *szDatabaseName );
ERR ErrIOSetDbid( DBID dbid, CHAR *szDatabaseName );
VOID IOFreeDbid( DBID dbid );
void BFOldestLgpos( LGPOS *plgposCheckPoint );
VOID BFPurge( DBID dbid );

STATIC INLINE BOOL FIODatabaseOpen ( DBID dbid )
	{
	AssertCriticalSection( critJet );
	return rgfmp[dbid].hf != handleNil;
	}

ERR ErrIOOpenDatabase( DBID dbid, CHAR *szDatabaseName, CPG cpg );
VOID IOCloseDatabase( DBID dbid );
ERR ErrIODeleteDatabase( DBID dbid );
BOOL FIODatabaseInUse( DBID dbid );
BOOL FIODatabaseAvailable( DBID dbid );

STATIC INLINE VOID IOUnlockDbid( DBID dbid )
	{
	SgEnterCriticalSection( critBuf );
	Assert( FDBIDWait( dbid ) );
	DBIDResetWait( dbid );
	SgLeaveCriticalSection( critBuf );
	}

STATIC INLINE BOOL FIOExclusiveByAnotherSession( DBID dbid, PIB *ppib )
	{
	Assert( FDBIDWait( dbid ) );
	return FDBIDExclusiveByAnotherSession( dbid, ppib );
	}

STATIC INLINE VOID IOSetExclusive( DBID dbid, PIB *ppib )
	{
	Assert( FDBIDWait( dbid ) );
	Assert( !( FDBIDExclusive( dbid ) ) );
	DBIDSetExclusive( dbid, ppib );
	}

STATIC INLINE VOID IOResetExclusive( DBID dbid )
	{
	Assert( FDBIDWait( dbid ) );
	DBIDResetExclusive( dbid );
	}

STATIC INLINE BOOL FIOReadOnly( DBID dbid )
	{
	Assert( FDBIDWait( dbid ) );
	return FDBIDReadOnly( dbid );
	}

STATIC INLINE VOID IOSetReadOnly( DBID dbid )
	{
	Assert( FDBIDWait( dbid ) );
	DBIDSetReadOnly( dbid );
	}

STATIC INLINE VOID IOResetReadOnly( DBID dbid )
	{
	Assert( FDBIDWait( dbid ) );
	DBIDResetReadOnly( dbid );
	}

STATIC INLINE BOOL FIOAttached( DBID dbid )
	{
	Assert( FDBIDWait( dbid ) );
	return FDBIDAttached( dbid );
	}

STATIC INLINE VOID IOSetAttached( DBID dbid )
	{
	Assert( FDBIDWait( dbid ) );
	Assert( !( FDBIDAttached( dbid ) ) );
	DBIDSetAttached( dbid );
	}

STATIC INLINE VOID IOResetAttached( DBID dbid )
	{
	Assert( FDBIDWait( dbid ) );
	Assert( FDBIDAttached( dbid ) );
	DBIDResetAttached( dbid );
	}


//---- BUF (buf.c) ----------------------------------------------------------

typedef struct _lru						// LRU List
	{
	LONG			cbfAvail;			// clean available buffers in LRU list
	struct	_bf		*pbfLRU;			// Least Recently Used buffer
	struct	_bf		*pbfMRU;			// Most Recently Used buffer
	} LRULIST;
	
typedef struct _bgcb	  	   			// Buffer Group Control Block
	{
	struct	_bgcb	*pbgcbNext;  		// pointer to the next BCGB
	struct	_bf		*rgbf;		 		// buffer control blocks for group
	struct	_page	*rgpage;	 		// buffer control blocks for group
	LONG			cbfGroup;			// number of bfs in this group
	LONG			cbfThresholdLow; 	// threshold to start cleaning buffers
	LONG			cbfThresholdHigh;	// threshold to stop cleaning buffers

	LRULIST lrulist;
	} BGCB;

#define pbgcbNil ((BGCB*)0)

#define PbgcbMEMAlloc() 			(BGCB*)PbMEMAlloc(iresBGCB)

#ifdef DEBUG /*  Debug check for illegal use of freed bgcb  */
#define MEMReleasePbgcb(pbgcb)	{ MEMRelease(iresBGCB, (BYTE*)(pbgcb)); pbgcb = pbgcbNil; }
#else
#define MEMReleasePbgcb(pbgcb)	{ MEMRelease(iresBGCB, (BYTE*)(pbgcb)); }
#endif

#define BUT	INT
#define butBuffer	0
#define butHistory	1
	
#define ibfNotUsed	-1

typedef	struct _he
	{
	BUT		but:2;			// must use 2 bits to avoid sign extension when converting to int
	INT		ibfHashNext:30;	// hash table overflow
	} HE;

typedef struct _hist
	{
	ULONG	ulBFTime;
	PN		pn;
	INT		ipbfHISTHeap;
	} HIST;

typedef struct _bf
	{
	struct	_page	*ppage; 				// pointer to page buffer

#if defined( _X86_ ) && defined( X86_USE_SEM )
	LONG volatile	lLock;					// num of locks being asked
	LONG			cSemWait;				// num of user waiting for on semaphore
	SEM				sem;
#endif  // defined( _X86_ ) && defined( X86_USE_SEM )

	PN	   			pn;					  	// physical pn of cached page
	ULONG  			fDirty:1;	  			// indicates page needs to be flushed
			  		   						// the following flags are mutual exclusive:
	ULONG  			fDirectRead:1;			// buffer is being direct read
	ULONG  			fAsyncRead:1;			// buffer is being async read
	ULONG  			fSyncRead:1;   			// buffer is being sync read
	ULONG  			fAsyncWrite:1;			// buffer is being async written
	ULONG  			fSyncWrite:1;  			// buffer is being sync written
	ULONG  			fHold:1;   				// buffer is in transient state
	ULONG  			fIOError:1;				// indicates read/write error
#ifdef DEBUG
	ULONG  			fInHash:1;				// BF is currently in hash table
#endif  //  DEBUG
	ULONG			fInLRUK:1;				// BF is in LRUK heap or LRUK list
	ULONG		  	fVeryOld:1;				// BF is very old relative to last check point
	ULONG			fPatch:1;				// BF is being written to the patch file
	ULONG			fNeedPatch:1;			// BF need to write patch file after regular write.
	LONG			ipbfHeap;				// index in heap
	LONG  			cWriteLatch; 		 	// if cWriteLatch > 0, page cannot be updated by other
	LONG  			cWaitLatch;
	LONG  			cPin;				  	// if cPin > 0 then buf cannot be overlayed

#ifdef READ_LATCH
	LONG  			cReadLatch; 		 	// if cReadLatch > 0, page cannot be updated
#endif  //  READ_LATCH
	PIB				*ppibWriteLatch; 		// thread with write latch
	PIB				*ppibWaitLatch;  		// thread with wait latch

	struct	_bf  	*pbfLRU;				// pointer to less recently used buffer
	struct	_bf  	*pbfMRU;				// pointer to more recently used buffer

	TRX				trxLastRef;				// last transaction that referenced us
	ULONG  			ulBFTime1;				// last reference time
	ULONG  			ulBFTime2;				// previous to last reference time

	struct	_bf		*pbfNextBatchIO;		// next BF in BatchIO list
	LONG			ipageBatchIO;
	
	ERR				err;	   				// error code for err occurs during the IO
	SIG				sigIOComplete;			// set (if valid) when IO on BF is completed
	SIG				sigSyncIOComplete;		// set (if valid) when sync IO on BF is completed
	
	union
		{
		ULONG  		cpageDirectRead; 		// count of prior BFs to be flushed
		ULONG  		cDepend; 				// count of prior BFs to be flushed
		};
	union
		{
		PAGE		*ppageDirectRead;
		struct _bf	*pbfDepend;				// BF to be flushed after this one
		};
	LGPOS  			lgposRC;				// log ptr to BeginT of oldest modifying xact
	LGPOS			lgposModify;			// log ptr of entry for last page modify

	struct	_rce	*prceDeferredBINext;	// dbl link list for deferred before image.

#ifdef COSTLY_PERF
	LONG			lClass;					// Table Class of which this BF is a member
#endif  //  COSTLY_PERF

	HE				rghe[2];				// 0 for buffer, 1 for history.
	HIST			hist;					// borrow the space in bf structure to keep HIST.

#ifdef PCACHE_OPTIMIZATION
//#if !defined( _X86_ ) || !defined( X86_USE_SEM )
//	BYTE			rgbFiller[32];
//#endif
#ifndef COSTLY_PERF
	BYTE			rgbFiller2[4];			// pad BF to 32 byte boundary
#endif  //  !COSTLY_PERF
#endif  //  PCACHE_OPTIMIZATION
	} BF;
#define pbfNil	((BF *) 0)

ERR ErrBFInit( VOID );
VOID BFTerm( BOOL fNormal );

#if defined( _X86_ ) && defined( X86_USE_SEM )

VOID BFIEnterCriticalSection( BF *pbf );
VOID BFILeaveCriticalSection( BF *pbf );

STATIC INLINE VOID BFEnterCriticalSection( BF *pbf )
	{
	LONG volatile *plLock = &pbf->lLock;

	//	use bit test and set instruction
	_asm
		{
	    mov eax, plLock
	    lock inc [eax]
		// If already set go to busy, otherwise return TRUE
	    jnz  busy
		} ;
	return;
busy:
	BFIEnterCriticalSection( pbf );
	}


STATIC INLINE VOID BFLeaveCriticalSection( BF *pbf )
	{
	LONG volatile *plLock = &pbf->lLock;

	_asm
		{
	    mov eax, plLock
	    lock dec [eax]
	    jge  wake
		}
	return;
wake:
	BFILeaveCriticalSection( pbf );
	}

#else

extern int ccritBF;
extern int critBFHashConst;
extern CRIT *rgcritBF;
#define IcritHash( ibf )	((ibf) & critBFHashConst )
#define BFEnterCriticalSection( pbf )	UtilEnterCriticalSection( rgcritBF[ IcritHash((ULONG)((ULONG_PTR)pbf) / sizeof(BF) ) ])
#define BFLeaveCriticalSection( pbf )	UtilLeaveCriticalSection( rgcritBF[ IcritHash((ULONG)((ULONG_PTR)pbf) / sizeof(BF) ) ])

#endif


ERR ErrBFAccessPage( PIB *ppib, BF **ppbf, PN pn );
ERR ErrBFReadAccessPage( FUCB *pfucb, PGNO pgno );
ERR ErrBFWriteAccessPage( FUCB *pfucb, PGNO pgno );
VOID BFAbandon( PIB *ppib, BF *pbf );
VOID BFTossImmediate( PIB *ppib, BF *pbf );
ERR ErrBFAllocPageBuffer( PIB *ppib, BF **ppbf, PN pn, LGPOS lgposRC, BYTE pgtyp );
ERR ErrBFAllocTempBuffer( BF **ppbf );
VOID BFFree( BF *pbf );
VOID BFPreread( PN pn, CPG cpg, CPG *pcpgActual );
VOID BFPrereadList( PN * rgpnPages, CPG *pcpgActual );
ERR ErrBFDirectRead( DBID dbid, PGNO pgnoStart, PAGE *ppage, INT cpage );
VOID BFDeferRemoveDependence( BF *pbf );
#define fBFWait		fFalse
#define fBFNoWait	fTrue
ERR ErrBFRemoveDependence( PIB *ppib, BF *pbf, BOOL fNoWait );
BOOL FBFCheckDependencyChain( BF *pbf );

/*	buffer flush prototype and flags
/**/
#define	fBFFlushSome 0
#define	fBFFlushAll	1
ERR ErrBFFlushBuffers( DBID dbid, LONG fBFFlush );

STATIC INLINE VOID BFSFree( BF *pbf )
	{
	SgEnterCriticalSection( critBuf );
	BFFree( pbf );
	SgLeaveCriticalSection( critBuf );
	}

/* the following small functions are called too often, */
/* make it as a macros
/**/
DBID DbidOfPn( PN pn );
PGNO PgnoOfPn( PN pn );

#ifdef COSTLY_PERF
extern unsigned long cBFClean[];
extern unsigned long cBFNewDirties[];
#else  //  !COSTLY_PERF
extern unsigned long cBFClean;
extern unsigned long cBFNewDirties;
#endif  //  COSTLY_PERF

#ifdef DEBUG
VOID	BFSetDirtyBit( BF *pbf );
#else
STATIC INLINE VOID BFSetDirtyBit( BF *pbf )
	{
	QWORD qwDBTime = QwPMDBTime( pbf->ppage );
	BFEnterCriticalSection( pbf );
	if ( !fRecovering && qwDBTime > QwDBHDRDBTime( rgfmp[ DbidOfPn(pbf->pn) ].pdbfilehdr ) )
		DBHDRSetDBTime( rgfmp[ DbidOfPn(pbf->pn) ].pdbfilehdr, qwDBTime );
	if ( !pbf->fDirty )
		{
#ifdef COSTLY_PERF
		cBFClean[pbf->lClass]--;
		cBFNewDirties[pbf->lClass]++;
#else  //  !COSTLY_PERF
		cBFClean--;
		cBFNewDirties++;
#endif  //  COSTLY_PERF
		pbf->fDirty = fTrue;
		}
	BFLeaveCriticalSection( pbf );
	}
#endif


/*  resets a BFs dirty flag
/**/

extern BOOL fLogDisabled;

STATIC INLINE VOID BFResetDirtyBit( BF *pbf )
	{
	BFEnterCriticalSection( pbf );
	Assert(	fRecovering ||
			pbf->fSyncWrite ||
			pbf->cWriteLatch == 0 );
	pbf->fVeryOld = fFalse;
	
	Assert( fLogDisabled || fRecovering || !rgfmp[DbidOfPn( pbf->pn )].fLogOn ||
			memcmp( &pbf->lgposRC, &lgposMax, sizeof( LGPOS ) ) != 0 );

	pbf->lgposRC = lgposMax;
	if ( pbf->fDirty )
		{
#ifdef COSTLY_PERF
		cBFClean[pbf->lClass]++;
#else  //  !COSTLY_PERF
		cBFClean++;
#endif  //  COSTLY_PERF
		pbf->fDirty = fFalse;
		}
	BFLeaveCriticalSection( pbf );
	}


STATIC INLINE VOID BFDirty( BF *pbf )
	{
	DBID dbid = DbidOfPn( pbf->pn );

	Assert( !pbf->fHold );

	BFSetDirtyBit( pbf );

	/*	set ulDBTime for logging and also for multiple cursor
	/*	maintenance, so that cursors can detect a change.
	/**/
	Assert( fRecovering ||
		dbid == dbidTemp ||
		QwPMDBTime( pbf->ppage ) <= QwDBHDRDBTime( rgfmp[dbid].pdbfilehdr ) );

	DBHDRIncDBTime( rgfmp[dbid].pdbfilehdr );
	PMSetDBTime( pbf->ppage, QwDBHDRDBTime( rgfmp[dbid].pdbfilehdr ) );
	}


/*  check if a page is dirty. If it is allocated for temp buffer, whose
 *  pn must be Null, then no need to check if it is dirty since it will
 *  not be written out.
 */
#define AssertBFDirty( pbf )							\
	Assert( (pbf)->pn == pnNull	|| 				   		\
		(pbf) != pbfNil && (pbf)->fDirty == fTrue )

#define AssertBFPin( pbf )		Assert( (pbf)->cPin > 0 )

#define AssertBFWaitLatched( pbf, ppib )				\
	Assert( (pbf)->cWaitLatch > 0 						\
			&& (pbf)->cPin > 0 							\
			&& (pbf)->ppibWaitLatch == (ppib) );

STATIC INLINE VOID BFPin( BF *pbf )
	{
#ifdef DEBUG
	BFEnterCriticalSection( pbf );
	Assert( pbf != pbfNil );
	Assert( !pbf->fSyncRead );
	Assert( !pbf->fAsyncRead );
	Assert( pbf->cPin >= 0 );
	pbf->cPin++;
	BFLeaveCriticalSection( pbf );
#else  //  !DEBUG
	UtilInterlockedIncrement( &pbf->cPin );
#endif  //  DEBUG
	}

STATIC INLINE VOID BFUnpin( BF *pbf )
	{
#ifdef DEBUG
	BFEnterCriticalSection( pbf );
	Assert( pbf != pbfNil );
	Assert( !pbf->fSyncRead );
	Assert( !pbf->fAsyncRead );
	Assert( pbf->cPin > 0 );
	pbf->cPin--;
	BFLeaveCriticalSection( pbf );
#else  //  !DEBUG
	UtilInterlockedDecrement( &pbf->cPin );
#endif  //  DEBUG
	}


STATIC INLINE VOID BFSetReadLatch( BF *pbf, PIB *ppib )
	{
#ifdef READ_LATCH
	BFPin( pbf );
	Assert( pbf->cWriteLatch == 0 || pbf->ppibWriteLatch == ppib );
	pbf->cReadLatch++;
#endif  //  READ_LATCH
	}

STATIC INLINE VOID BFResetReadLatch( BF *pbf, PIB *ppib )
	{
#ifdef READ_LATCH
	Assert( pbf->cReadLatch > 0 );
	Assert( pbf->cWriteLatch == 0 || pbf->ppibWriteLatch == ppib );
	pbf->cReadLatch--;
	BFUnpin( pbf );
#endif  //  READ_LATCH
	}

STATIC INLINE BOOL FBFReadLatchConflict( PIB *ppib, BF *pbf )
	{
#ifdef READ_LATCH
	return pbf->cWriteLatch > 0 && pbf->ppibWriteLatch != ppib;
#else  //  !READ_LATCH
	return fFalse;
#endif  //  READ_LATCH
	}


STATIC INLINE VOID BFSetWriteLatch( BF *pbf, PIB *ppib )
	{
	BFPin( pbf );
#ifdef READ_LATCH
	Assert( pbf->cReadLatch == 0 );
#endif  //  READ_LATCH
	Assert( pbf->cWriteLatch == 0 || pbf->ppibWriteLatch == ppib );
	pbf->cWriteLatch++;
	pbf->ppibWriteLatch = ppib;
	}

STATIC INLINE VOID BFResetWriteLatch( BF *pbf, PIB *ppib )
	{
#ifdef READ_LATCH
	Assert( pbf->cReadLatch == 0 );
#endif  //  READ_LATCH
	Assert( pbf->cWriteLatch > 0 );
	Assert( pbf->ppibWriteLatch == ppib );
	pbf->cWriteLatch--;
	BFUnpin( pbf );
	}

STATIC INLINE BOOL FBFWriteLatchConflict( PIB *ppib, BF *pbf )
	{
	return
#ifdef READ_LATCH
			pbf->cReadLatch > 0 ||
#endif  //  READ_LATCH
			( pbf->cWriteLatch > 0 && pbf->ppibWriteLatch != ppib );
	}

STATIC INLINE BOOL FBFWriteLatch( PIB *ppib, BF *pbf )
	{
	return pbf->cWriteLatch > 0 && pbf->ppibWriteLatch == ppib;
	}


STATIC INLINE VOID BFSetWaitLatch( BF *pbf, PIB *ppib )
	{
	AssertCriticalSection( critJet );
	BFSetWriteLatch( pbf, ppib );
	Assert( pbf->cWaitLatch == 0 ||
		pbf->ppibWaitLatch == ppib );
	pbf->cWaitLatch++;
	pbf->ppibWaitLatch = ppib;
	}

STATIC INLINE VOID BFResetWaitLatch( BF *pbf, PIB *ppib )
	{
	AssertCriticalSection( critJet );
	Assert( pbf->cWaitLatch > 0 );
	Assert( pbf->ppibWaitLatch == ppib );
	pbf->cWaitLatch--;
	BFResetWriteLatch( pbf, ppib );
	}

ERR ErrBFDepend( BF *pbf, BF *pbfD );

#ifdef DEBUG
extern ERR ErrLGTrace( PIB *ppib, CHAR *sz );
extern BOOL fDBGTraceBR;
#endif

STATIC INLINE VOID BFUndepend( BF *pbf )
	{
	if ( pbf->pbfDepend != pbfNil )
		{
		BF *pbfD = pbf->pbfDepend;
#ifdef DEBUG
		if ( fDBGTraceBR )
			{
			char sz[256];
			sprintf( sz, "UD %ld:%ld->%ld:%ld(%lu)",
						DbidOfPn( pbf->pn ), PgnoOfPn( pbf->pn ),
						DbidOfPn( pbf->pbfDepend->pn), PgnoOfPn( pbf->pbfDepend->pn ),
						pbf->pbfDepend->cDepend );
			CallS( ErrLGTrace( ppibNil, sz ) );
			}
#endif		
		Assert( pbfD->cDepend > 0 );
		BFEnterCriticalSection( pbfD );
		pbfD->cDepend--;
		pbf->pbfDepend = pbfNil;
		BFLeaveCriticalSection( pbfD );
		}
	}

/*
 *  When ppib is not Nil and check if a page is in use by checking if it is
 *  Accessible to this PIB. Note that a page is accessible even it is overlay
 *  latched (cPin != 0). This checking accessible is mainly used by BFAccess.
 *  If ppib is nil, basically it is used for freeing a buffer. This is used
 *  by BFClean and BFIAlloc.
 */

STATIC INLINE BOOL FBFNotAccessible( PIB *ppib, BF *pbf )
	{
	return	pbf->fAsyncRead ||
			pbf->fSyncRead ||
			pbf->fAsyncWrite ||
			pbf->fSyncWrite ||
			pbf->fHold ||
			( pbf->cWaitLatch != 0 && ppib != pbf->ppibWaitLatch );
	}

STATIC INLINE BOOL FBFNotAvail( BF *pbf )
	{
	return	pbf->fAsyncRead ||
			pbf->fSyncRead ||
			pbf->fAsyncWrite ||
			pbf->fSyncWrite ||
			pbf->fHold ||
			pbf->cPin != 0;
	}

STATIC INLINE BOOL FBFInUse( PIB *ppib, BF *pbf )
	{
	return ppib != ppibNil ? FBFNotAccessible( ppib, pbf ) : FBFNotAvail( pbf );
	}

STATIC INLINE BOOL FBFInUseByOthers( PIB *ppib, BF *pbf )
	{
	return	pbf->fAsyncRead ||
			pbf->fSyncRead ||
			pbf->fAsyncWrite ||
			pbf->fSyncWrite ||
			pbf->fHold ||
			pbf->cPin > 1 ||
			( pbf->cWaitLatch != 0 && ppib != pbf->ppibWaitLatch ) ||
			( pbf->cWriteLatch != 0 && ppib != pbf->ppibWriteLatch );
	}

//---- STORAGE (storage.c) -------------------------------------------------

ERR ErrFMPSetDatabases( PIB *ppib );
extern BOOL fGlobalFMPLoaded;
ERR ErrFMPInit( VOID );
VOID FMPTerm( );

#ifdef DEBUG
VOID ITDBGSetConstants();
#endif
ERR ErrITSetConstants( VOID );
ERR ErrITInit( VOID );

#define	fTermCleanUp	0x00000001		/*	Termination with OLC, Version clean up etc  */
#define fTermNoCleanUp	0x00000002		/*	Termination without any clean up */

#define fTermError		0x00000004		/*	Terminate with error, no OLC clean up, */
										/*	no flush buffers, db header */

ERR ErrITTerm( INT fTerm );

ERR ErrBFNewPage( FUCB *pfucb, PGNO pgno, PGTYP pgtyp, PGNO pgnoFDP );
VOID BFSleep( unsigned long ulMSecs );

STATIC INLINE PN PnOfDbidPgno( DBID dbid, PGNO pgno )
	{
	return (PN) ( ( (PN) dbid << 24 ) | (PN) pgno );
	}

STATIC INLINE DBID DbidOfPn( PN pn )
	{
	return (DBID) ( ( (BYTE *) &pn )[3] );
	}

STATIC INLINE PGNO PgnoOfPn( PN pn )
	{
	return (PGNO) ( pn & 0x00FFFFFF );
	}


VOID BFReference( BF *pbf, PIB *ppib );

#define FBFReadAccessPage		  		FBFAccessPage
#define FBFWriteAccessPage 				FBFAccessPage

STATIC INLINE BOOL FBFAccessPage( FUCB *pfucb, PGNO pgno )
	{
	BOOL	fAccessible;
	BF		*pbf = pfucb->ssib.pbf;

	AssertCriticalSection( critJet );
	Assert( pfucb->ppib != ppibNil );
	
	if ( pbf == pbfNil )
		return fFalse;

	/*  if the cached BF's PN is the same and it is accessible and it is in
	/*  the LRUK heap or list, we can access the page
	/**/
	BFEnterCriticalSection( pbf );
	fAccessible = (	pbf->pn == PnOfDbidPgno( pfucb->dbid, pgno ) &&
					!FBFNotAccessible( pfucb->ppib, pbf ) &&
					pbf->fInLRUK );
	BFLeaveCriticalSection( pbf );

#ifdef LRU1
	BFReference( pbf, pfucb->ppib );
#else  //  !LRU1
	/*  if this is not a correlated access, this counts as a BF reference
	/**/
	if ( fAccessible && pbf->trxLastRef != pfucb->ppib->trxBegin0 )
		BFReference( pbf, pfucb->ppib );
#endif  //  LRU1

	return fAccessible;
	}


#ifdef DEBUG

#define AssertFBFReadAccessPage			AssertFBFAccessPage
#define AssertFBFWriteAccessPage		AssertFBFAccessPage

STATIC VOID AssertFBFAccessPage( FUCB *pfucb, PGNO pgno )
	{
	BF		*pbf = pfucb->ssib.pbf;

	AssertCriticalSection( critJet );
	Assert( pfucb->ppib != ppibNil );
	
	Assert( pbf != pbfNil );

	/*  if the cached BF's PN is the same and it is accessible and it is in
	/*  the LRUK heap or list, we can access the page
	/**/
	BFEnterCriticalSection( pbf );

	Assert( pbf->pn == PnOfDbidPgno( pfucb->dbid, pgno ) );
	Assert( !FBFNotAccessible( pfucb->ppib, pbf ) );
	Assert( pbf->fInLRUK );

	BFLeaveCriticalSection( pbf );
	}

#else  //  !DEBUG

#define AssertFBFReadAccessPage( pfucbX, pgnoX )
#define AssertFBFWriteAccessPage( pfucbX, pgnoX )

#endif  //  DEBUG

//---- PAGE (page.c) --------------------------------------------------------

STATIC INLINE QWORD QwSTDBTimePssib( SSIB *pssib )
	{
	return QwPMDBTime( pssib->pbf->ppage );
	}
	
STATIC INLINE VOID PMSetQwDBTime( SSIB *pssib, QWORD qw )
	{
	Assert( qw <= QwDBHDRDBTime( rgfmp[DbidOfPn( pssib->pbf->pn )].pdbfilehdr ) );
	PMSetDBTime( pssib->pbf->ppage, qw );
	}

STATIC INLINE VOID BFSetQwDBTime( BF *pbf, QWORD qw )
	{
	Assert( qw <= QwDBHDRDBTime( rgfmp[DbidOfPn( pbf->pn )].pdbfilehdr ) );
	PMSetDBTime( pbf->ppage, qw );
	}

#ifdef DEBUG
VOID AssertPMGet( SSIB *pssib, LONG itag );
#else
#define AssertPMGet( pssib, itag )
#endif


//  End Assert redirection

#undef szAssertFilename

#endif  // _STAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\util.h ===
#ifndef	UTIL_H					/* Allow this file to be included at will */
#define UTIL_H

#ifndef _FILE_DEFINED
#include <stdio.h>		       /* Needed for FPrintF2 prototype */
#endif	/* !_FILE_DEFINED */

/*	system node keys
/**/
extern const KEY rgkeySTATIC[7];
#define pkeyNull				((KEY *)(rgkeySTATIC+0))
#define pkeyOwnExt				((KEY *)(rgkeySTATIC+1))
#define pkeyAvailExt			((KEY *)(rgkeySTATIC+2))
#define pkeyData				((KEY *)(rgkeySTATIC+3))
#define pkeyLong				((KEY *)(rgkeySTATIC+4))
#define pkeyAutoInc				((KEY *)(rgkeySTATIC+5))
#define pkeyDatabases			((KEY *)(rgkeySTATIC+6))

extern RES	 rgres[];

/* NOTE: whenever this is changed, also update the rgres[] in sysinit.c */

#define iresCSR						0
#define iresFCB						1
#define iresFUCB 					2
#define iresIDB						3
#define iresPIB						4
#define iresSCB						5
#define iresDAB						6
#define iresLinkedMax		   		7		// the last linked ires + 1

#define iresVER				   		7
#define iresBF 						8
#define iresMax						9		// max all category

/**************** function prototypes *********************
/**********************************************************
/**/
ERR ErrMEMInit( VOID );
BYTE *PbMEMAlloc( int ires);
VOID MEMRelease( int ires, BYTE *pb );
VOID MEMTerm( VOID );
#define PbMEMPreferredThreshold( ires )	( rgres[ires].pbPreferredThreshold )
#define PbMEMMax( ires )				( rgres[ires].pbAlloc + ( rgres[ires].cblockAlloc * rgres[ires].cbSize ) )

#ifdef MEM_CHECK
VOID MEMCheck( VOID );
#else
#define MEMCheck()
#endif

#ifdef	DEBUG
void VARARG PrintF2(const char * fmt, ...);
void VARARG FPrintF2(const char * fmt, ...);
VOID MEMPrintStat( VOID );
#define PrintF	PrintF2
#else
#define PrintF()
#endif

STATIC INLINE INT CmpStKey( BYTE *stKey, const KEY *pkey )
	{
	INT		s;
	INT		sDiff;

	sDiff = *stKey - pkey->cb;
	s = memcmp( stKey + 1, pkey->pb, sDiff < 0 ? (INT)*stKey : pkey->cb );
	return s ? s : sDiff;
	}

INT CmpPartialKeyKey( KEY *pkey1, KEY *pkey2 );

#endif	/* !UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\version.h ===
#define rmj		4
#define rmm		909
#define rup		0
#define szVerName	"EDB"
#define szVerUser	"IANJO1"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\utilw32.h ===
#ifndef _UTILW32_H
#define _UTILW32_H


//  Redirect Asserts in inline code to seem to fire from this file

#define szAssertFilename	__FILE__


#ifdef DEBUG
ERR ErrERRCheck( ERR err );
#else
#define ErrERRCheck( err )	( err )
#endif


//  Init / Term

ERR ErrUtilInit(void);
VOID UtilTerm(void);


//  Miscellaneous

STATIC INLINE DWORD DwUtilGetLastError( void )		{ return GetLastError(); }
	
STATIC INLINE ULONG UlUtilGetTickCount( VOID )		{ return GetTickCount(); }

STATIC INLINE QWORD QwUtilPerfCount( VOID )
	{
	QWORDX qwx;
	
	if ( !QueryPerformanceCounter( (LARGE_INTEGER *) &qwx.qw ) )
		{
		qwx.h = GetTickCount();
		qwx.l = 0;
		}
	return qwx.qw;
	}

STATIC INLINE QWORD QwUtilPerfCountFrq( VOID )
	{
	QWORDX qwx;

	if ( !QueryPerformanceFrequency( (LARGE_INTEGER *) &qwx.qw ) )
		{
		qwx.h = 1000;
		qwx.l = 0;
		}
	return qwx.qw;
	}

STATIC INLINE double DblUtilPerfElapsedTime( QWORD qwStartCount )
	{
	return	(signed __int64) ( QwUtilPerfCount() - qwStartCount )
			/ (double) (signed __int64) QwUtilPerfCountFrq();
	}

STATIC INLINE double DblUtilPerfElapsedTime2( QWORD qwStartCount, QWORD qwEndCount )
	{
	return	(signed __int64) ( qwEndCount - qwStartCount )
			/ (double) (signed __int64) QwUtilPerfCountFrq();
	}


CHAR *GetDebugEnvValue( CHAR *szEnvVar );

ERR ErrUtilCloseHandle( HANDLE hf );

//  for system information such as virtual page size and malloc granularity
extern SYSTEM_INFO siSystemConfig;


//  Event Logging

typedef unsigned long MessageId;
#include "jetmsg.h"

extern int fNoWriteAssertEvent;

VOID UtilReportEvent( WORD fwEventType, WORD fwCategory, DWORD IDEvent, WORD cStrings, LPCTSTR *plpszStrings );
VOID UtilReportEventOfError( WORD fwCategory, DWORD IDEvent, ERR err );


//  Registry Support

ERR ErrUtilRegInit(void);
ERR ErrUtilRegTerm(void);
ERR ErrUtilRegReadConfig(void);

extern HKEY hkeyHiveRoot;

ERR ErrUtilRegOpenKeyEx( HKEY hkeyRoot, LPCTSTR lpszSubKey, PHKEY phkResult );
ERR ErrUtilRegCloseKeyEx( HKEY hkey );
ERR ErrUtilRegCreateKeyEx( HKEY hkeyRoot,
	LPCTSTR lpszSubKey,
	PHKEY phkResult,
	LPDWORD lpdwDisposition );
ERR ErrUtilRegDeleteKeyEx( HKEY hkeyRoot, LPCTSTR lpszSubKey );
ERR ErrUtilRegDeleteValueEx( HKEY hkey, LPTSTR lpszValue );
ERR ErrUtilRegSetValueEx( HKEY hkey,
	LPCTSTR lpszValue,
	DWORD fdwType,
	CONST BYTE *lpbData,
	DWORD cbData );
ERR ErrUtilRegQueryValueEx( HKEY hkey,
	LPTSTR lpszValue,
	LPDWORD lpdwType,
	LPBYTE *lplpbData );


//  DLL Support

STATIC INLINE BOOL FUtilLoadLibrary(const char *pszLibrary, ULONG_PTR *phmod)
	{
	HANDLE hmod;

	hmod = LoadLibrary((LPTSTR) pszLibrary);

	//  restore original error mode
	*phmod = (ULONG_PTR) hmod;

	return(hmod != NULL);
	}

STATIC INLINE PFN PfnUtilGetProcAddress(ULONG_PTR hmod, unsigned ordinal)
	{
	return((PFN) GetProcAddress((HANDLE) hmod, MAKEINTRESOURCE(ordinal)));
	}

STATIC INLINE void UtilFreeLibrary( unsigned hmod )		{ FreeLibrary( LongToHandle(hmod)); }


//  Date and Time

void UtilGetDateTime(DATESERIAL *pdt);
void UtilGetDateTime2(_JET_DATETIME *pdt);
char *SzUtilSerialToDate(JET_DATESERIAL dt);


//  File Operations

typedef OVERLAPPED OLP;

ERR ErrUtilCreateDirectory( char *szDirName );
ERR ErrUtilRemoveDirectory( char *szDirName );

ERR ErrUtilGetFileAttributes( CHAR *szFileName, BOOL *pfReadOnly );
ERR ErrUtilFindFirstFile( CHAR *szFind, HANDLE *phandleFind, CHAR *szFound );
ERR ErrUtilFindNextFile( HANDLE handleFind, CHAR *szFound );
VOID UtilFindClose( HANDLE handleFind );
BOOL FUtilFileExists( CHAR *szFilePathName );

ERR ErrUtilOpenFile( char *szFileName, HANDLE *phf, ULONG ulFileSize, BOOL fReadOnly, BOOL fOverlapped );
ERR ErrUtilOpenReadFile( char *szFileName, HANDLE *phf );

ERR ErrUtilDeleteFile( char *szFileName );
ERR ErrUtilNewSize( HANDLE hf, ULONG ulFileSize, ULONG ulFileSizeHigh, BOOL fOverlapped );
ERR ErrUtilMove( char *szFrom, char *szTo );
ERR ErrUtilCopy( char *szFrom, char *szTo, BOOL fFailIfExists );

ERR ErrUtilReadFile( HANDLE hf, VOID *pvBuf, UINT cbBuf, UINT *pcbRead );
ERR ErrUtilReadBlock( HANDLE hf, VOID *pvBuf, UINT cbBuf, UINT *pcbRead );
ERR ErrUtilReadBlockOverlapped( HANDLE hf, VOID *pvBuf, UINT cbBuf,
		DWORD *pcbRead,	OLP *polp );
ERR ErrUtilReadBlockEx(	HANDLE hf, VOID *pvBuf, UINT cbBuf, OLP *polp, VOID *pfnCompletion);
ERR ErrUtilWriteBlock( HANDLE hf, VOID *pvBuf, UINT cbBuf, UINT *pcbWritten );
ERR ErrUtilWriteBlockOverlapped( HANDLE hf, VOID *pvBuf, UINT cbBuf,
		DWORD *pcbWrite, OLP *polp );
ERR ErrUtilWriteBlockEx(	HANDLE hf, VOID *pvBuf, UINT cbBuf, OLP *polp, VOID *pfnCompletion);

ERR ErrUtilGetOverlappedResult( HANDLE hf, OLP *polp, UINT *pcb,
		BOOL fWait );

STATIC INLINE ERR ErrUtilCloseFile( HANDLE hf ) { return ErrUtilCloseHandle( hf ); }

ERR ErrUtilReadShadowedHeader( CHAR *szFileName, BYTE *pbHeader, INT cbHeader );
ERR ErrUtilWriteShadowedHeader( CHAR *szFileName, BYTE *pbHeader, INT cbHeader );
#define ulChecksumMagicNumber 0x89abcdef
ULONG UlUtilChecksum( const BYTE *pb, INT cb );

//+api------------------------------------------------------
//
// VOID UtilChgFilePtr( HANDLE hf, LONG lRel, LONG *plRelHigh, ULONG ulRef, ULONG *pul )
// =========================================================
//
//      Changes file hf pointer to position lRef relative to position :
//
//      wRef    FILE_BEGIN   file beginnging
//
//----------------------------------------------------------
STATIC INLINE VOID UtilChgFilePtr( HANDLE hf, LONG lRel, LONG *plRelHigh, ULONG ulRef, ULONG *pul )
	{
	Assert( sizeof(HANDLE) == sizeof(HFILE) );
	*pul = SetFilePointer( (HANDLE)hf, lRel, plRelHigh, ulRef );
	Assert( ulRef != FILE_BEGIN || *pul == (ULONG)lRel );
	return;
	}

STATIC INLINE ERR ErrUtilGetDiskFreeSpace(	char *szRoot,
											ULONG *pSecPerClust,
											ULONG *pcbSec,
											ULONG *pcFreeClust,
											ULONG *pcTotClust )
	{
	if ( GetDiskFreeSpace( szRoot, pSecPerClust, pcbSec, pcFreeClust, pcTotClust ) )
		return JET_errSuccess;
	else
		return ErrERRCheck( JET_errDiskIO );
	}


VOID UtilDebugBreak();

//  Physical Memory Allocation

#if defined( DEBUG ) || defined( RFS2 )

void	*SAlloc( unsigned long );
void	OSSFree( void * );
void	*LAlloc( unsigned long, unsigned short );
void	OSLFree( void * );

STATIC INLINE VOID SFree( void *pv )	{ OSSFree( pv ); }
STATIC INLINE VOID LFree( void *pv )	{ OSLFree( pv ); }

#else  //  !DEBUG && !RFS2

#include <stdlib.h>

STATIC INLINE VOID *SAlloc( ULONG cb )				{ return GlobalAlloc( 0, cb ); }
STATIC INLINE VOID SFree( VOID *pv )				{ GlobalFree( pv ); }
STATIC INLINE VOID *LAlloc( ULONG c, USHORT cb )	{ return GlobalAlloc( 0, c * cb ); }
STATIC INLINE VOID LFree( VOID *pv )				{ GlobalFree( pv ); }

#endif  //  DEBUG || RFS2


//  Virtual Memory Allocation

#if defined( DEBUG ) || defined( RFS2 )

VOID *PvUtilAlloc( ULONG dwSize );
VOID *PvUtilCommit( VOID *pv, ULONG dwSize );
VOID UtilFree( VOID *pv );
VOID UtilDecommit( VOID *pv, ULONG dwSize );

#else  //  !DEBUG && !RFS2

STATIC INLINE VOID *PvUtilAlloc( ULONG dwSize )
	{
	return VirtualAlloc( NULL, dwSize, MEM_RESERVE, PAGE_READWRITE );
	}

STATIC INLINE VOID *PvUtilCommit( VOID *pv, ULONG ulSize )
	{
	return VirtualAlloc( pv, ulSize, MEM_COMMIT, PAGE_READWRITE );
	}

STATIC INLINE VOID UtilFree( VOID *pv )		{ VirtualFree( pv, 0, MEM_RELEASE ); }

STATIC INLINE VOID UtilDecommit( VOID *pv, ULONG dwSize )	{ VirtualFree( pv, dwSize, MEM_DECOMMIT ); }

#endif  //  DEBUG || RFS2

VOID *PvUtilAllocAndCommit( ULONG dwSize );


//  Critical Sections

#ifdef SPIN_LOCK
void UtilEnterNestableCriticalSection(void  *pv);
void UtilLeaveNestableCriticalSection(void  *pv);
void UtilEnterCriticalSection(void  *pv);
void UtilLeaveCriticalSection(void  *pv);
ERR ErrUtilInitializeCriticalSection(void  **ppv);
void UtilDeleteCriticalSection(void  *pv);
#else  //  !SPIN_LOCK
#ifdef DEBUG
void UtilEnterNestableCriticalSection(void  *pv);
void UtilLeaveNestableCriticalSection(void  *pv);
void UtilEnterCriticalSection(void  *pv);
void UtilLeaveCriticalSection(void  *pv);
ERR ErrUtilInitializeCriticalSection(void  **ppv);
void UtilDeleteCriticalSection(void  *pv);
#else  //  !DEBUG
STATIC INLINE ERR ErrUtilInitializeCriticalSection(void  **ppv)
	{
	if ( !( *ppv = SAlloc( sizeof( CRITICAL_SECTION ) ) ) )
		return ErrERRCheck( JET_errOutOfMemory );
	InitializeCriticalSection( (LPCRITICAL_SECTION) *ppv );
	return JET_errSuccess;
	}

STATIC INLINE VOID UtilDeleteCriticalSection(void  *pv)
	{
	DeleteCriticalSection( (LPCRITICAL_SECTION) pv );
	SFree( pv );
	}
	
STATIC INLINE VOID UtilEnterCriticalSection(void  *pv)
	{
	EnterCriticalSection( (LPCRITICAL_SECTION) pv );
	}
	
STATIC INLINE VOID UtilLeaveCriticalSection(void  *pv)
	{
	LeaveCriticalSection( (LPCRITICAL_SECTION) pv );
	}
	
STATIC INLINE VOID UtilEnterNestableCriticalSection( void *pv )	{ UtilEnterCriticalSection( pv ); }
STATIC INLINE VOID UtilLeaveNestableCriticalSection( void *pv )	{ UtilLeaveCriticalSection( pv ); }
#endif  //  !DEBUG
#endif  //  !SPIN_LOCK

#ifdef RETAIL
#define UtilAssertCrit( pv )	0
#define UtilAssertNotInCrit( pv )	0
#define UtilHoldCriticalSection( pv ) 	0
#define UtilReleaseCriticalSection( pv )	0
#else  //  !RETAIL
void UtilAssertCrit(void  *pv);
void UtilAssertNotInCrit(void  *pv);
void UtilHoldCriticalSection(void  *pv);
void UtilReleaseCriticalSection(void  *pv);
#endif	//  !RETAIL


//  Signals

typedef HANDLE SIG;

#define sigNil ( (SIG) 0 )

STATIC INLINE ERR ErrUtilSignalCreate( void **ppv, const char *szSig )
	{
	*((SIG *) ppv) = CreateEvent( NULL, fTrue, fFalse, szSig );
	return ( *ppv == sigNil ) ? ErrERRCheck( JET_errOutOfMemory ) : JET_errSuccess;
	}

STATIC INLINE ERR ErrUtilSignalCreateAutoReset( void **ppv, const char *szSig )
	{
	*((SIG *) ppv) = CreateEvent( NULL, fFalse, fFalse, szSig );
	return ( *ppv == sigNil ) ? ErrERRCheck( JET_errOutOfMemory ) : JET_errSuccess;
	}

STATIC INLINE void UtilSignalReset( void *pv )
	{
	BOOL    rc;
	rc = ResetEvent( (SIG) pv );
	Assert( rc != FALSE );
	}

STATIC INLINE void UtilSignalSend( void *pv )
	{
	BOOL    rc;
	rc = SetEvent( (SIG) pv );
	Assert( rc != FALSE );
	}

STATIC INLINE DWORD UtilSignalWait( void *pv, long lTimeOut )
	{
	DWORD   rc;
	UtilAssertNotInCrit( critJet );
	rc = WaitForSingleObject( (SIG) pv, lTimeOut < 0 ? -1L : lTimeOut );
	return rc;
	}

STATIC INLINE DWORD UtilSignalWaitEx( void *pv, long lTimeOut, BOOL fAlertable )
	{
	DWORD   rc;
	UtilAssertNotInCrit( critJet );
	rc = WaitForSingleObjectEx( (SIG) pv, lTimeOut < 0 ? -1L : lTimeOut, fAlertable );
	return rc;
	}

STATIC INLINE void UtilMultipleSignalWait( int csig, void *pv, BOOL fWaitAll, long lTimeOut )
	{
	DWORD   rc;
	UtilAssertNotInCrit( critJet );
	rc = WaitForMultipleObjects( csig, (SIG*) pv, fWaitAll, lTimeOut < 0 ? -1L : lTimeOut );
	}

void UtilCloseSignal(void *pv);


//  Semaphore

typedef HANDLE SEM;

#define semNil ( (SEM) 0 )

STATIC INLINE ERR ErrUtilSemaphoreCreate( SEM *psem, LONG lInitialCount, LONG lMaximumCount )
	{
	*psem = ( SEM ) CreateSemaphore( NULL, lInitialCount, lMaximumCount, NULL );
	return ( *psem == semNil ) ? ErrERRCheck( JET_errOutOfMemory ) : JET_errSuccess;
	}

STATIC INLINE DWORD UtilSemaphoreWait( SEM sem, long lTimeOut )
	{
	DWORD   rc;
	rc = WaitForSingleObject( (HANDLE) sem, lTimeOut < 0 ? -1L : lTimeOut );
	return rc;
	}

STATIC INLINE DWORD UtilSemaphoreRelease( SEM sem, LONG cReleaseCount )
	{
	DWORD   rc;
	rc = ReleaseSemaphore( (HANDLE) sem, cReleaseCount, NULL );
	Assert( rc != 0 );
	return rc;
	}

void UtilCloseSemaphore(void *pv);


//  Threads and Processes
#define cmsecSleepMax		(60*1000)
VOID UtilSleepEx( ULONG ulTime, BOOL fAlert );
VOID UtilSleep( ULONG ulTime );

ERR ErrUtilCreateThread( ULONG (*pulfn)(), ULONG cbStack, LONG lThreadPriority, HANDLE *phandle );
ULONG UtilEndThread( HANDLE hThread, SIG sigEnd );
#define lThreadPriorityNormal		0
#define lThreadPriorityHigh			1
void UtilSetThreadPriority( HANDLE hThread, LONG lThreadPriority );

STATIC INLINE HANDLE UtilGetCurrentTask( VOID )				{ return LongToHandle(GetCurrentProcessId()); }
STATIC INLINE DWORD DwUtilGetCurrentThreadId( VOID )		{ return GetCurrentThreadId(); }

//	text normalization

ERR ErrUtilCheckLangid( LANGID *plangid );
VOID UtilNormText( char *rgchText, INT cchText, BYTE *rgchNorm, INT cbNorm, INT *pbNorm );
ERR ErrUtilNormText(
	const BYTE *pbField,
	INT cbField,
	INT cbKeyBufLeft,
	BYTE *pbSeg,
	INT *pcbSeg );

#define BINARY_NAMES	1
#ifdef BINARY_NAMES
#define UtilCmpName( sz1, sz2 ) 		\
	( _stricmp( sz1, sz2 ) )
#define UtilStringCompare( pb1, cb1, pb2, cb2, sort, plResult )		\
	{																\
	*plResult = strncmp( pb1, pb2, min( cb1, cb2 ) );				\
	if ( !*plResult )												\
		*plResult = cb1 > cb2;										\
	}
#else
INT UtilCmpName( const char *sz1, const char *sz2 );
VOID UtilStringCompare( char *pb1, unsigned long cb1,
	char *pb2, unsigned long cb2, unsigned long sort,
	long *plResult );
#endif

//  Unicode Support

ERR ErrUtilMapString(LANGID	langid, BYTE *pbField, INT cbField, BYTE *rgbSeg,
	int cbBufLeft, int *cbSeg);
ERR ErrUtilWideCharToMultiByte(LPCWSTR lpcwStr, LPSTR *lplpOutStr);


//  RFS functions

#ifdef RFS2
int UtilRFSAlloc( const char  *szType, int Type );
int UtilRFSLog(const char  *szType,int fPermitscritted);
void UtilRFSLogJETCall(const char  *szFunc,ERR err,const char  *szFile,unsigned Line);
void UtilRFSLogJETErr(ERR err,const char  *szLabel,const char  *szFile,unsigned szLine);
#endif /*  RFS2  */


/*
** UtilInterlockedIncrement and UtilInterlockedDecrement are wrapper functions
** to increment or decrement a value in a thread-safe manner.
**
** Return values are:
**
**              > 0             if resulting value > 0
**              = 0             if resulting value = 0
**              < 0             if resulting value < 0
**
** Note that the return value isn't necessary the resulting value; it may be
** different than the resulting value, but sign is guarenteed to be the same.
*/

STATIC INLINE long UtilInterlockedIncrement( long *lpValue )
	{
	return InterlockedIncrement( lpValue );
	}

STATIC INLINE long UtilInterlockedDecrement( long *lpValue )
	{
	return InterlockedDecrement( lpValue );
	}


/*
** UtilInterlockedExchange is a wrapper function to assign a value to a
** variable in a thread-safe manner.
**
** This function returns the prior value of the variable (before the
** assignment was done).
*/

STATIC INLINE long UtilInterlockedExchange( long *lpValue1, long lValue2 )
	{
	return InterlockedExchange( lpValue1, lValue2 );
	}


//  Debug output

#ifdef DEBUG
extern void  *  critDBGPrint;
VOID JET_API DBGFPrintF( char *sz );
void VARARG DebugWriteString(BOOL fHeader, const char  *szFormat, ...);
#else
#define DBGFPrintF( sz )  0
#endif

void UtilPerfDumpStats(char *szText);

//  End Assert redirection

#undef szAssertFilename

#endif  // _UTILW32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\vtmgr.h ===
/* C6BUG: The EXPORTs are in this file only because QJET */
	/* C6BUG: fails when compiled with __fastcall under C 6.00A. */

ERR ErrVtmgrInit(void);

ERR EXPORT ErrAllocateTableid(JET_TABLEID  *ptableid, JET_VTID vtid, const struct tagVTFNDEF  *pvtfndef);

ERR EXPORT ErrGetPvtfndefTableid(JET_SESID sesid, JET_TABLEID tableid, const struct tagVTFNDEF  *  *ppvtfndef);

ERR EXPORT ErrSetPvtfndefTableid(JET_SESID sesid, JET_TABLEID tableid, const struct tagVTFNDEF  *pvtfndef);

ERR EXPORT ErrGetVtidTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID  *pvtid);

ERR EXPORT ErrSetVtidTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID vtid);

	/* CONSIDER: Replace the following with the ErrGet/Set routines above */

ERR EXPORT ErrUpdateTableid(JET_TABLEID tableid, JET_VTID vtid, const struct tagVTFNDEF  *pvtfndef);

void EXPORT ReleaseTableid(JET_TABLEID tableid);

BOOL EXPORT FValidateTableidFromVtid( JET_VTID vtid, JET_TABLEID tableid, const struct tagVTFNDEF	**ppvtfndef );

void NotifyBeginTransaction(JET_SESID sesid);
void NotifyCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);
void NotifyRollbackTransaction(JET_SESID sesid, JET_GRBIT grbit);
void NotifyUpdateUserFunctions(JET_SESID sesid);

#ifndef RETAIL
void DebugListOpenTables(void);
#endif	/* RETAIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\_edbutil.h ===
typedef enum
	{
	dbNormal,			// Non-Exchange
	dbISPriv,
	dbISPub,
	dbDS
	} EXCHANGEDB;


typedef struct tagUTILOPTS
	{
	char		*szSourceDB;
	char		*szLogfilePath;
	char		*szSystemPath;
	char		*szTempDB;
	char		*szBackup;
	char		*szRestore;
	void		*pv;					// Points to mode-specific structures.
		
	INT			mode;
	INT			fUTILOPTSFlags;

	BOOL		fUseRegistry;
	long		cpageBuffers;
	long		cpageBatchIO;
	long		cpageDbExtension;

	EXCHANGEDB	db;						// Exchange-specific flag.
	}
	UTILOPTS;

// Modes:
#define modeConsistency				1
#define modeDefragment				2
#define modeRecovery				3
#define modeBackup					4
#define modeUpgrade					5
#define modeDump					6

// Flags:
#define fUTILOPTSSuppressLogo		0x00000001
#define fUTILOPTSDefragRepair		0x00000002		// Defrag mode only.
#define fUTILOPTSPreserveTempDB		0x00000004		// Defrag and upgrade modes.
#define fUTILOPTSDefragInfo			0x00000008		// Defrag and upgrade modes.
#define fUTILOPTSIncrBackup			0x00000010		// Backup only.

#define FUTILOPTSSuppressLogo( fFlags )			( (fFlags) & fUTILOPTSSuppressLogo )
#define UTILOPTSSetSuppressLogo( fFlags )		( (fFlags) |= fUTILOPTSSuppressLogo )
#define UTILOPTSResetSuppressLogo( fFlags )		( (fFlags) &= ~fUTILOPTSSuppressLogo )

#define FUTILOPTSDefragRepair( fFlags )			( (fFlags) & fUTILOPTSDefragRepair )
#define UTILOPTSSetDefragRepair( fFlags )		( (fFlags) |= fUTILOPTSDefragRepair )
#define UTILOPTSResetDefragRepair( fFlags )		( (fFlags) &= ~fUTILOPTSDefragRepair )

#define FUTILOPTSPreserveTempDB( fFlags )		( (fFlags) & fUTILOPTSPreserveTempDB )
#define UTILOPTSSetPreserveTempDB( fFlags )		( (fFlags) |= fUTILOPTSPreserveTempDB )
#define UTILOPTSResetPreserveTempDB( fFlags )	( (fFlags) &= ~fUTILOPTSPreserveTempDB )

#define FUTILOPTSDefragInfo( fFlags )			( (fFlags) & fUTILOPTSDefragInfo )
#define UTILOPTSSetDefragInfo( fFlags )			( (fFlags) |= fUTILOPTSDefragInfo )
#define UTILOPTSResetDefragInfo( fFlags )		( (fFlags) &= ~fUTILOPTSDefragInfo )

#define FUTILOPTSIncrBackup( fFlags )			( (fFlags) & fUTILOPTSIncrBackup )
#define UTILOPTSSetIncrBackup( fFlags )			( (fFlags) |= fUTILOPTSIncrBackup )
#define UTILOPTSResetIncrBackup( fFlags )		( (fFlags) &= ~fUTILOPTSIncrBackup )



#define CallJ( func, label )	{if ((err = (func)) < 0) {goto label;}}
#define Call( func )			CallJ( func, HandleError )
#define fFalse		0
#define fTrue		1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\verstamp.h ===
#include "version.h"		       /* SLM maintained version file */

#include <winver.h>

#if	(rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#if	(rup == 0)

#define VERSION_STR1(a,b,c)	    #a "." rmmpad #b

#else	/* !(rup == 0) */

#define VERSION_STR1(a,b,c)	    #a "." rmmpad #b "." ruppad #c

#if	(rup < 10)
#define ruppad "000"
#elif	(rup < 100)
#define ruppad "00"
#elif	(rup < 1000)
#define ruppad "0"
#else
#define ruppad
#endif

#endif	/* !(rup == 0) */

#define VERSION_STR2(a,b,c)		VERSION_STR1(a,b,c)
#define VER_PRODUCTVERSION_STR	VERSION_STR2(rmj,rmm,rup)
#define VER_PRODUCTVERSION		rmj,rmm,0,rup

/*--------------------------------------------------------------*/
/* the following section defines values used in the version	    */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

#ifdef	RETAIL
#define VER_DEBUG		    0
#else
#define VER_DEBUG		    VS_FF_DEBUG
#endif

#if	(rup == 0)		    /* CONSIDER */
#define VER_PRIVATEBUILD	    0
#else
#define VER_PRIVATEBUILD	    VS_FF_PRIVATEBUILD
#endif

#if	(rup == 0)
#define VER_PRERELEASE		    0
#else
#define VER_PRERELEASE		    VS_FF_PRERELEASE
#endif

#define VER_FILEFLAGSMASK	    VS_FFI_FILEFLAGSMASK
#define VER_FILEOS		    VOS_DOS_WINDOWS16
#define VER_FILEFLAGS		    (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR	    "Microsoft Corporation"
#define VER_PRODUCTNAME_STR	    "Microsoft\256 Exchange Database Engine"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation."

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\vtapi.h ===
#ifndef VTAPI_H
#define VTAPI_H

#define VTAPI

	/* Typedefs for dispatched APIs. */
	/* Please keep in alphabetical order */

typedef ERR VTAPI VTFNAddColumn(JET_VSESID sesid, JET_VTID vtid,
	const char  *szColumn, const JET_COLUMNDEF  *pcolumndef,
	const void  *pvDefault, unsigned long cbDefault,
	JET_COLUMNID  *pcolumnid);

typedef ERR VTAPI VTFNCloseTable(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNComputeStats(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNCopyBookmarks(JET_SESID sesid, JET_VTID vtidSrc, 
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest,
	unsigned long crecMax);

typedef ERR VTAPI VTFNCreateIndex(JET_VSESID sesid, JET_VTID vtid,
	const char  *szIndexName, JET_GRBIT grbit,
	const char  *szKey, unsigned long cbKey, unsigned long lDensity);

typedef ERR VTAPI VTFNCreateReference(JET_VSESID sesid, JET_VTID vtid,
	const char  *szReferenceName, const char  *szColumns,
	const char  *szReferencedTable,
	const char  *szReferencedColumns, JET_GRBIT grbit);

typedef ERR VTAPI VTFNDelete(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNDeleteColumn(JET_VSESID sesid, JET_VTID vtid,
	const char  *szColumn);

typedef ERR VTAPI VTFNDeleteIndex(JET_VSESID sesid, JET_VTID vtid,
	const char  *szIndexName);

typedef ERR VTAPI VTFNDeleteReference(JET_VSESID sesid, JET_VTID vtid,
	const char  *szReferenceName);

typedef ERR VTAPI VTFNDupCursor(JET_VSESID sesid, JET_VTID vtid,
	JET_TABLEID  *ptableid, JET_GRBIT grbit);

typedef ERR VTAPI VTFNEmptyTable(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNGetBookmark(JET_VSESID sesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbMax,
	unsigned long  *pcbActual);

typedef ERR VTAPI VTFNGetChecksum(JET_VSESID sesid, JET_VTID vtid,
	unsigned long  *pChecksum);

typedef ERR VTAPI VTFNGetCurrentIndex(JET_VSESID sesid, JET_VTID vtid,
	char  *szIndexName, unsigned long cchIndexName);

typedef ERR VTAPI VTFNGetCursorInfo(JET_VSESID sesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VTAPI VTFNGetRecordPosition(JET_VSESID sesid, JET_VTID vtid,
	JET_RECPOS  *pkeypos, unsigned long cbKeypos);

typedef ERR VTAPI VTFNGetTableColumnInfo(JET_VSESID sesid, JET_VTID vtid,
	const char  *szColumnName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VTAPI VTFNGetTableIndexInfo(JET_VSESID sesid, JET_VTID vtid,
	const char  *szIndexName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VTAPI VTFNGetTableReferenceInfo(JET_VSESID sesid, JET_VTID vtid,
	const char  *szReferenceName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VTAPI VTFNGetTableInfo(JET_VSESID sesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel);

typedef ERR VTAPI VTFNGotoBookmark(JET_VSESID sesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbBookmark);

typedef ERR VTAPI VTFNGotoPosition(JET_VSESID sesid, JET_VTID vtid,
	JET_RECPOS *precpos);

typedef ERR VTAPI VTFNVtIdle(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNMakeKey(JET_VSESID sesid, JET_VTID vtid,
	const void  *pvData, unsigned long cbData, JET_GRBIT grbit);

typedef ERR VTAPI VTFNMove(JET_VSESID sesid, JET_VTID vtid,
	long cRow, JET_GRBIT grbit);

typedef ERR VTAPI VTFNNotifyBeginTrans(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNNotifyCommitTrans(JET_VSESID sesid, JET_VTID vtid,
	JET_GRBIT grbit);

typedef ERR VTAPI VTFNNotifyRollback(JET_VSESID sesid, JET_VTID vtid,
	JET_GRBIT grbit);

typedef ERR VTAPI VTFNNotifyUpdateUfn(JET_VSESID sesid, JET_VTID vtid);

typedef ERR VTAPI VTFNPrepareUpdate(JET_VSESID sesid, JET_VTID vtid,
	unsigned long prep);

typedef ERR VTAPI VTFNRenameColumn(JET_VSESID sesid, JET_VTID vtid,
	const char  *szColumn, const char  *szColumnNew);

typedef ERR VTAPI VTFNRenameIndex(JET_VSESID sesid, JET_VTID vtid,
	const char  *szIndex, const char  *szIndexNew);

typedef ERR VTAPI VTFNRenameReference(JET_VSESID sesid, JET_VTID vtid,
	const char  *szReference, const char  *szReferenceNew);

typedef ERR VTAPI VTFNRetrieveColumn(JET_VSESID sesid, JET_VTID vtid,
	JET_COLUMNID columnid, void  *pvData, unsigned long cbData,
	unsigned long  *pcbActual, JET_GRBIT grbit,
	JET_RETINFO  *pretinfo);

typedef ERR VTAPI VTFNRetrieveKey(JET_VSESID sesid, JET_VTID vtid,
	void  *pvKey, unsigned long cbMax,
	unsigned long  *pcbActual, JET_GRBIT grbit);

typedef ERR VTAPI VTFNSeek(JET_VSESID sesid, JET_VTID vtid, JET_GRBIT grbit);

typedef ERR VTAPI VTFNSetCurrentIndex(JET_VSESID sesid, JET_VTID vtid,
	const char  *szIndexName);

typedef ERR VTAPI VTFNSetColumn(JET_VSESID sesid, JET_VTID vtid,
	JET_COLUMNID columnid, const void  *pvData,
	unsigned long cbData, JET_GRBIT grbit, JET_SETINFO  *psetinfo);

typedef ERR VTAPI VTFNSetIndexRange(JET_VSESID sesid, JET_VTID vtid,
	JET_GRBIT grbit);

typedef ERR VTAPI VTFNUpdate(JET_VSESID sesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbBookmark,
	unsigned long  *pcbActual);


	/* The following structure is that used to allow dispatching to */
	/* a VT provider.  Each VT provider must create an instance of */
	/* this structure and give the pointer to this instance when */
	/* allocating a table id. */

typedef struct VTDBGDEF {
	unsigned short			cbStruct;
	unsigned short			filler;
	char				szName[32];
	unsigned long			dwRFS;
	unsigned long			dwRFSMask[4];
} VTDBGDEF;

	/* Please add to the end of the table */

typedef struct tagVTFNDEF {
	unsigned short			cbStruct;
	unsigned short			filler;
	const VTDBGDEF 		*pvtdbgdef;
	VTFNAddColumn			*pfnAddColumn;
	VTFNCloseTable			*pfnCloseTable;
	VTFNComputeStats		*pfnComputeStats;
	VTFNCopyBookmarks		*pfnCopyBookmarks;
	VTFNCreateIndex 		*pfnCreateIndex;
	VTFNCreateReference		*pfnCreateReference;
	VTFNDelete			*pfnDelete;
	VTFNDeleteColumn		*pfnDeleteColumn;
	VTFNDeleteIndex 		*pfnDeleteIndex;
	VTFNDeleteReference		*pfnDeleteReference;
	VTFNDupCursor			*pfnDupCursor;
	VTFNGetBookmark 		*pfnGetBookmark;
	VTFNGetChecksum 		*pfnGetChecksum;
	VTFNGetCurrentIndex		*pfnGetCurrentIndex;
	VTFNGetCursorInfo		*pfnGetCursorInfo;
	VTFNGetRecordPosition		*pfnGetRecordPosition;
	VTFNGetTableColumnInfo		*pfnGetTableColumnInfo;
	VTFNGetTableIndexInfo		*pfnGetTableIndexInfo;
	VTFNGetTableInfo		*pfnGetTableInfo;
	VTFNGetTableReferenceInfo	*pfnGetTableReferenceInfo;
	VTFNGotoBookmark		*pfnGotoBookmark;
	VTFNGotoPosition		*pfnGotoPosition;
	VTFNVtIdle			*pfnVtIdle;
	VTFNMakeKey			*pfnMakeKey;
	VTFNMove			*pfnMove;
	VTFNNotifyBeginTrans		*pfnNotifyBeginTrans;
	VTFNNotifyCommitTrans		*pfnNotifyCommitTrans;
	VTFNNotifyRollback		*pfnNotifyRollback;
	VTFNNotifyUpdateUfn		*pfnNotifyUpdateUfn;
	VTFNPrepareUpdate		*pfnPrepareUpdate;
	VTFNRenameColumn		*pfnRenameColumn;
	VTFNRenameIndex 		*pfnRenameIndex;
	VTFNRenameReference		*pfnRenameReference;
	VTFNRetrieveColumn		*pfnRetrieveColumn;
	VTFNRetrieveKey 		*pfnRetrieveKey;
	VTFNSeek			*pfnSeek;
	VTFNSetCurrentIndex		*pfnSetCurrentIndex;
	VTFNSetColumn			*pfnSetColumn;
	VTFNSetIndexRange		*pfnSetIndexRange;
	VTFNUpdate			*pfnUpdate;
	VTFNEmptyTable		*pfnEmptyTable;
} VTFNDEF;


	/* The following entry points are to be used by VT providers */
	/* in their VTFNDEF structures for any function that is not */
	/* provided.  This functions return JET_errIllegalOperation */


extern VTFNAddColumn			ErrIllegalAddColumn;
extern VTFNCloseTable			ErrIllegalCloseTable;
extern VTFNComputeStats 		ErrIllegalComputeStats;
extern VTFNCopyBookmarks		ErrIllegalCopyBookmarks;
extern VTFNCreateIndex			ErrIllegalCreateIndex;
extern VTFNCreateReference		ErrIllegalCreateReference;
extern VTFNDelete			ErrIllegalDelete;
extern VTFNDeleteColumn 		ErrIllegalDeleteColumn;
extern VTFNDeleteIndex			ErrIllegalDeleteIndex;
extern VTFNDeleteReference		ErrIllegalDeleteReference;
extern VTFNDupCursor			ErrIllegalDupCursor;
extern VTFNEmptyTable			ErrIllegalEmptyTable;
extern VTFNGetBookmark			ErrIllegalGetBookmark;
extern VTFNGetChecksum			ErrIllegalGetChecksum;
extern VTFNGetCurrentIndex		ErrIllegalGetCurrentIndex;
extern VTFNGetCursorInfo		ErrIllegalGetCursorInfo;
extern VTFNGetRecordPosition		ErrIllegalGetRecordPosition;
extern VTFNGetTableColumnInfo		ErrIllegalGetTableColumnInfo;
extern VTFNGetTableIndexInfo		ErrIllegalGetTableIndexInfo;
extern VTFNGetTableInfo 		ErrIllegalGetTableInfo;
extern VTFNGetTableReferenceInfo	ErrIllegalGetTableReferenceInfo;
extern VTFNGotoBookmark 		ErrIllegalGotoBookmark;
extern VTFNGotoPosition			ErrIllegalGotoPosition;
extern VTFNVtIdle			ErrIllegalVtIdle;
extern VTFNMakeKey			ErrIllegalMakeKey;
extern VTFNMove 			ErrIllegalMove;
extern VTFNNotifyBeginTrans		ErrIllegalNotifyBeginTrans;
extern VTFNNotifyCommitTrans		ErrIllegalNotifyCommitTrans;
extern VTFNNotifyRollback		ErrIllegalNotifyRollback;
extern VTFNNotifyUpdateUfn		ErrIllegalNotifyUpdateUfn;
extern VTFNPrepareUpdate		ErrIllegalPrepareUpdate;
extern VTFNRenameColumn 		ErrIllegalRenameColumn;
extern VTFNRenameIndex			ErrIllegalRenameIndex;
extern VTFNRenameReference		ErrIllegalRenameReference;
extern VTFNRetrieveColumn		ErrIllegalRetrieveColumn;
extern VTFNRetrieveKey			ErrIllegalRetrieveKey;
extern VTFNSeek 			ErrIllegalSeek;
extern VTFNSetCurrentIndex		ErrIllegalSetCurrentIndex;
extern VTFNSetColumn			ErrIllegalSetColumn;
extern VTFNSetIndexRange		ErrIllegalSetIndexRange;
extern VTFNUpdate			ErrIllegalUpdate;

#endif	/* !VTAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\_jet.h ===
#ifndef _JET_H
#define _JET_H

#include <string.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>

#undef SPIN_LOCK		/* disable SPIN_LOCK even if defined in config.h */
//#define MEM_CHECK		/* check for memory leakage */
//#define COSTLY_PERF		/* enable costly performance counters */

#define handleNil			((HANDLE)(-1))


#define EXPORT			       /* Called from assembly code */
#define VARARG		_cdecl      /* Variable number of arguments */

#ifndef UNALIGNED
#if defined(_MIPS_) || defined(_ALPHA_) || defined(_M_PPC)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

#define PUBLIC	  extern
#define STATIC	  static

#ifdef DEBUG
#define INLINE
#else
#define INLINE __inline
#endif

#define CODECONST(type) type const

typedef unsigned __int64 QWORD;

typedef union _QWORDX
	{
	QWORD	qw;
	struct
		{
		DWORD l;
		DWORD h;
		};
	} QWORDX;


#define fFalse 0
#define fTrue  (!0)

typedef int ERR;
typedef double DATESERIAL;
typedef ULONG OBJID;
typedef unsigned short OBJTYP;
typedef unsigned short COLTYP;
typedef int BOOL;
typedef int (*PFN)();


typedef struct
	{
	int month;
	int day;
	int year;
	int hour;
	int minute;
	int second;
	} _JET_DATETIME;
	

	/* cbFilenameMost includes the trailing null terminator */

#define cbFilenameMost		260		/* Windows NT limit */

	/*** Global system initialization variables ***/

extern BOOL	fJetInitialized;
extern BOOL	fBackupAllowed;
extern BOOL	fTermInProgress;
extern int	cSessionInJetAPI;

extern BOOL fGlobalRepair;		/* if this is for repair or not */
extern BOOL fGlobalSimulatedRestore;

/*	Engine OBJIDs:

	0..0x10000000 reserved for engine use, divided as follows:

	0x00000000..0x0000FFFF	reserved for TBLIDs under RED
	0x00000000..0x0EFFFFFF	reserved for TBLIDs under BLUE
	0x0F000000..0x0FFFFFFF	reserved for container IDs
	0x10000000		reserved for ObjectId of DbObject

	Client OBJIDs begin at 0x10000001 and go up from there.
*/
#define objidNil				((OBJID) 0x00000000)
#define objidRoot				((OBJID) 0x0F000000)
#define objidTblContainer 		((OBJID) 0x0F000001)
#define objidDbContainer 		((OBJID) 0x0F000002)
#define objidDbObject			((OBJID) 0x10000000)

	/* Start of RELEASE vs DEBUG build definitions */

#define DISPATCHING	1

#ifdef DEBUG
#define PARAMFILL	1
#define RFS2		1
#endif

#ifdef	RETAIL

#ifdef RFS2
#define DeclAssertFile static CODECONST(char) szAssertFilename[] = __FILE__
#else
#define DeclAssertFile
#endif

#define Assert(exp)				((void)1)
#define ExpAssert(exp)			((void)1)
#define AssertSz(exp, sz)		((void)1)
#define AssertConst(exp)		((void)1)

#define AssertEq(exp, exp2)		(exp)
#define AssertGe(exp, exp2)		(exp)
#define AssertNe(exp, exp2)		(exp)

#define MarkTableidExported(err,tableid)
#define CheckTableidExported(tableid)

#define AssertValidSesid(sesid) ((void) 1)

#define	DebugLogJetOp( sesid, op )		0

#else	/* !RETAIL */

#define DeclAssertFile static CODECONST(char) szAssertFilename[] = __FILE__

#define AssertSz(exp, sz) { \
		static CODECONST(char) szMsg[] = sz; \
		(exp) ? (void) 0 : AssertFail( szMsg, szAssertFilename, __LINE__ ); \
	}

#define Assert( exp ) \
	( (exp) ? (void) 0 : AssertFail( #exp, szAssertFilename, __LINE__) )
#define ExpAssert(exp)		Assert(exp)

#define AssertConst(exp)	Assert(*szAssertFilename != '\0' && (exp))

#define AssertEq(exp, exp2)	Assert((exp) == (exp2))
#define AssertGe(exp, exp2)	Assert((exp) >= (exp2))
#define AssertNe(exp, exp2)	Assert((exp) != (exp2))

#define AssertValidSesid(sesid) AssertValidSesid(sesid)

BOOL FTableidExported(JET_TABLEID tableid);
void MarkTableidExportedR(JET_TABLEID tableid);
#define MarkTableidExported(err,tableid)		\
		if (err >= 0)							\
			MarkTableidExportedR(tableid)
#define CheckTableidExported(tableid)			\
		if (!FTableidExported(tableid))			\
			APIReturn(JET_errInvalidTableId)

void DebugLogJetOp( JET_SESID sesid, int op );

#endif	/* !RETAIL */

	/* End of RELEASE vs DEBUG build definitions */


#ifdef PARAMFILL
#define FillClientBuffer( pv, cb )	( (pv) ? memset( (pv), 0x52, (cb) ) : 0 )
#else
#define FillClientBuffer( pv, cb )	( (void)1 )
#endif

	/* apirare.c */

PUBLIC ERR ErrOpenDatabase(JET_SESID sesid, const char  *szDatabase,
	const char  *szConnect, JET_DBID  *pdbid, JET_GRBIT grbit);
JET_ERR JET_API ErrGetSystemParameter(JET_SESID sesid, unsigned long paramid,
	ULONG_PTR *plParam, char  *sz, unsigned long cbMax);
JET_ERR JET_API ErrSetSystemParameter(JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char  *sz);


	/* initterm.c */

extern void  *  critJet;

JET_ERR JET_API ErrInit(BOOL fSkipIsamInit);

#ifdef RFS2
extern unsigned long  fLogJETCall;
extern unsigned long  fLogRFS;
extern unsigned long  cRFSAlloc;
extern unsigned long  cRFSIO;
extern unsigned long  fDisableRFS;
extern unsigned long  fAuxDisableRFS;
#endif /*  RFS2  */

#ifndef RETAIL
extern unsigned  EXPORT wAssertAction;
extern unsigned  EXPORT fAssertActionSet;
#endif	/* !RETAIL */


	/* util.c */

ERR ErrUTILCheckName( char *szNewName, const char *szName, int cchName );


#ifndef RETAIL

PUBLIC void EXPORT AssertFail( const char *szExpr, const char *szFilename, unsigned Line );

PUBLIC void VARARG DebugPrintf(const char  *szFmt, ...);

#endif	/* !RETAIL */

#define opIdle					1
#define opGetTableIndexInfo		2
#define opGetIndexInfo			3
#define opGetObjectInfo			4
#define opGetTableInfo			5
#define opCreateObject			6
#define opDeleteObject			7
#define opRenameObject			8
#define opBeginTransaction		9
#define opCommitTransaction		10
#define opRollback				11
#define opOpenTable				12
#define opDupCursor				13
#define opCloseTable			14
#define opGetTableColumnInfo	15
#define opGetColumnInfo			16
#define opRetrieveColumn		17
#define opRetrieveColumns		18
#define opSetColumn				19
#define opSetColumns			20
#define opPrepareUpdate			21
#define opUpdate				22
#define opDelete				23
#define opGetCursorInfo			24
#define opGetCurrentIndex		25
#define opSetCurrentIndex		26
#define opMove					27
#define opMakeKey				28
#define opSeek					29
#define opGetBookmark			30
#define opGotoBookmark			31
#define opGetRecordPosition		32
#define opGotoPosition			33
#define opRetrieveKey			34
#define opCreateDatabase		35
#define opOpenDatabase			36
#define opGetDatabaseInfo		37
#define opCloseDatabase			38
#define opCapability			39
#define opCreateTable			40
#define opRenameTable			41
#define opDeleteTable			42
#define opAddColumn				43
#define opRenameColumn			44
#define opDeleteColumn			45
#define opCreateIndex			46
#define opRenameIndex			47
#define opDeleteIndex			48
#define opComputeStats			49
#define opAttachDatabase		50
#define opDetachDatabase		51
#define opOpenTempTable			52
#define opSetIndexRange			53
#define opIndexRecordCount		54
#define opGetChecksum			55
#define opGetObjidFromName		56
#define opMax					57

extern long lAPICallLogLevel;


	/*  RFS macros  */

#ifdef RFS2

/*  RFS/JET call logging
/*
/*	RFS allocator:  returns 0 if allocation is disallowed.  Also handles RFS logging.
/*	cRFSAlloc is the global allocation counter.  A value of -1 disables RFS in debug mode.
/**/

#define RFSAlloc(type) 				( UtilRFSAlloc( #type ,type ) )

/*  RFS allocation types
/*
/*      Type 0:  general allocation
/*           1:  IO
/**/
#define CSRAllocResource			0
#define FCBAllocResource			0
#define FUCBAllocResource			0
#define IDBAllocResource			0
#define PIBAllocResource			0
#define SCBAllocResource			0
#define VERAllocResource			0
#define DABAllocResource 			0
#define UnknownAllocResource 		0

#define SAllocMemory				0
#define LAllocMemory				0
#define PvUtilAllocMemory			0

#define IOOpenReadFile				1
#define IOOpenFile					1
#define IODeleteFile				1
#define IONewFileSize				1
#define IOReadBlock					1
#define IOWriteBlock				1
#define IOReadBlockOverlapped		1
#define IOWriteBlockOverlapped		1
#define IOReadBlockEx				1
#define IOWriteBlockEx				1
#define IOMoveFile					1
#define IOCopyFile					1

/*  RFS disable/enable macros  */

#define RFSDisable()				(fAuxDisableRFS = 1)
#define RFSEnable()					(fAuxDisableRFS = 0)

/*  JET call logging (log on failure)
/**/

// Do not print out function name because it takes too much string resource
//#define LogJETCall(func,err)		(UtilRFSLogJETCall(#func,err,szAssertFilename,__LINE__))
#define LogJETCall(func,err)		(UtilRFSLogJETCall("",err,szAssertFilename,__LINE__))

/*  JET call macros
/**/
	
#define Call(func)					{LogJETCall(func,err = (func)); if (err < 0) {goto HandleError;}}
#define CallR(func)					{LogJETCall(func,err = (func)); if (err < 0) {return err;}}
#define CallJ(func,label)			{LogJETCall(func,err = (func)); if (err < 0) {goto label;}}
#define CallS(func)					{ERR errT; LogJETCall(func,errT = (func)); Assert(errT == JET_errSuccess);}

/*  JET inline error logging (logging controlled by JET call flags)
/**/

#define LogJETErr(err,label)		(UtilRFSLogJETErr(err,#label,szAssertFilename,__LINE__))

/*  JET inline error macros
/**/

#define Error(errRet,label)			{LogJETErr(errRet,label); err = (errRet); goto label;}

#else  // !RFS2

#define RFSAlloc(type)				(1)
#define RFSDisable()				(1)
#define RFSEnable()					(0)
#define Call(func)					{if ((err = (func)) < 0) {goto HandleError;}}
#define CallR(func)					{if ((err = (func)) < 0) {return err;}}
#define CallJ( func, label )		{if ((err = (func)) < 0) goto label;}
#define Error( errRet, label )		{err = errRet; goto label;}

#ifdef DEBUG

#define CallS(func)					{ ERR errT; Assert( (errT = (func)) == JET_errSuccess ); }

#else  //  !DEBUG

#define CallS(func)					{ERR errT; errT = (func);}

#endif  //  DEBUG
#endif  //  RFS2

	/*  API Enter/Leave macros assuming that critJet has been initialized  */

#define APIEnter()						{					\
	if ( fTermInProgress ) return JET_errTermInProgress;	\
	if ( !fJetInitialized ) return JET_errNotInitialized;	\
	Assert(critJet != NULL);								\
	UtilEnterCriticalSection(critJet);						\
	Assert( cSessionInJetAPI >= 0 );						\
	cSessionInJetAPI++;					}
	
#define APIReturn(err)					{	\
	ERR errT = (err);						\
	Assert(critJet != NULL);				\
	Assert( cSessionInJetAPI >= 1 );		\
	cSessionInJetAPI--;						\
	Assert( cSessionInJetAPI >= 0 );		\
	UtilLeaveCriticalSection(critJet);		\
	return errT;						}

	/*  APIInitEnter inits critJet (if necessary) on an initializing API call  */

#define APIInitEnter()					{					\
	if ( fTermInProgress ) return JET_errTermInProgress;	\
	if ( critJet == NULL )									\
		{													\
		ERR errT =											\
			ErrUtilInitializeCriticalSection( &critJet );	\
		if ( errT < 0 )										\
			return errT;									\
		Assert( cSessionInJetAPI == 0 );					\
		}													\
	UtilEnterCriticalSection( critJet );  					\
	Assert( cSessionInJetAPI >= 0 );						\
	cSessionInJetAPI++;					}

	/*  APITermReturn frees critJet on return from a terminating API call  */

#define APITermReturn(err)				{	\
	ERR errT = (err);						\
	Assert( critJet != NULL );				\
	Assert( cSessionInJetAPI == 1 );		\
	cSessionInJetAPI = 0;					\
	UtilLeaveCriticalSection( critJet );	\
	UtilDeleteCriticalSection( critJet ); 	\
	critJet = NULL;							\
	return errT;						}

#define APIForceTermReturn( err ) 		{	\
	ERR errT = (err);						\
	Assert( critJet != NULL );				\
	cSessionInJetAPI = 0;					\
	UtilLeaveCriticalSection( critJet );  	\
	UtilDeleteCriticalSection( critJet ); 	\
	critJet = NULL;							\
	return errT;						}

#include "isam.h"

#endif /* !_JET_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\_vtmgr.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component: VT Dispatcher
*
* File: _vtmgr.h
*
* File Comments:
*
*     Internal header file for VT dispatcher.
*
* Revision History:
*
*    [0]  10-Nov-90  richards	Added this header
*
***********************************************************************/

#ifndef _VTMGR_H
#define _VTMGR_H

#include "vtapi.h"

#ifdef DAYTONA
#define tableidMax	2048
#else
#define tableidMax	8192
#endif

typedef struct _VTDEF
	{
	JET_VSESID		vsesid;			/* Session id for VT provider. */
	JET_VTID		vtid;			/* Tableid for VT provider. */
	const VTFNDEF  *pvtfndef;	/* VT function dispatch table. */
#ifdef DEBUG
	BOOL			fExported;     /* Returned by an API call? */
#endif
	} VTDEF;


extern VTDEF  EXPORT rgvtdef[tableidMax];

#endif	/* !_VTMGR_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\inc\_jetstr.h ===
/*** Constant Strings (made into static variables to save space) ***/

/*** System object names (non-table) ***/

extern const char  szTcObject[];
extern const char  szDcObject[];
extern const char  szDbObject[];

/*** System table names ***/

extern const char  szSoTable[];
extern const char  szScTable[];
extern const char  szSiTable[];
extern const char  szSqTable[];
extern const char  szSrTable[];

/*** System table index names ***/

extern const char  szSoNameIndex[];
extern const char  szSoIdIndex[];
extern const char  szScObjectIdNameIndex[];
extern const char  szSiObjectIdNameIndex[];

/*** System table Column names ***/

extern const char  szSoIdColumn[];
extern const char  szSoParentIdColumn[];
extern const char  szSoObjectNameColumn[];
extern const char  szSoObjectTypeColumn[];
extern const char  szSoDateUpdateColumn[];
extern const char  szSoDateCreateColumn[];
extern const char  szSoLvColumn[];
extern const char  szSoDatabaseColumn[];
extern const char  szSoConnectColumn[];
extern const char  szSoForeignNameColumn[];
extern const char  szSoFlagsColumn[];
extern const char  szSoPresentationOrder[];

extern const char  szSiObjectNameColumn[];
extern const char  szSiIdColumn[];
extern const char  szSiIndexIdColumn[];	


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\apicore.c ===
#include "std.h"

DeclAssertFile;


/***********************************************************************/
/***********************  JET API FUNCTIONS  ***************************/
/***********************************************************************/


/*=================================================================
JetIdle

Description:
  Performs idle time processing.

Parameters:
  sesid			uniquely identifies session
  grbit			processing options

Return Value:
  Error code

Errors/Warnings:
  JET_errSuccess		some idle processing occurred
  JET_wrnNoIdleActivity no idle processing occurred
=================================================================*/

JET_ERR JET_API JetIdle(JET_SESID sesid, JET_GRBIT grbit)
	{
	ERR	err;

	APIEnter();
	DebugLogJetOp( sesid, opIdle );

	/* Let the built-in ISAM do some idle processing */
	err = ErrIsamIdle(sesid, grbit);

	APIReturn(err);
	}


/*=================================================================
JetGetLastErrorInfo

Description:
  Returns extended error info to the user.

Parameters:
  sesid			uniquely identifies session
  pexterr		pointer to JET_EXTERR structure (NULL if not desired)
  cbexterrMax	size of buffer pointed to by pexterr
  sz1			pointer to buffer for error string #1 (NULL if not desired)
  cch1Max		size of buffer pointed to by sz1
  sz2			pointer to buffer for error string #2 (NULL if not desired)
  cch2Max		size of buffer pointed to by sz2

Return Value:
  JET error code

Errors/Warnings:
  JET_errSuccess		if error info was retrieved.
  JET_wrnNoErrorInfo	if there was no error info to retrieve.  In this case,
					    none of the output parameters are filled in.
=================================================================*/
JET_ERR JET_API JetGetLastErrorInfo( JET_SESID sesid,
	JET_EXTERR *pexterr, unsigned long cbexterrMax,
	char  *sz1, unsigned long cch1Max,
	char  *sz2, unsigned long cch2Max,
	char  *sz3, unsigned long cch3Max,
	unsigned long *pcch3Actual )
	{
	APIEnter();

	FillClientBuffer(pexterr, cbexterrMax);
	FillClientBuffer(sz1, cch1Max);
	FillClientBuffer(sz2, cch2Max);
	FillClientBuffer(sz3, cch3Max);

	pexterr->cbStruct = 0;
	APIReturn(JET_wrnNoErrorInfo);
	}


JET_ERR JET_API JetGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szIndexName, void  *pvResult,
	unsigned long cbResult, unsigned long InfoLevel)
	{
	ERR err;

	APIEnter();
	DebugLogJetOp( sesid, opGetTableIndexInfo );

	FillClientBuffer(pvResult, cbResult);

	CheckTableidExported(tableid);

	err = JET_errBufferTooSmall;

	switch (InfoLevel)
		{
		case JET_IdxInfo :
		case JET_IdxInfoList :
			if ( cbResult < sizeof(JET_INDEXLIST) )
				goto HandleError;
			break;
		case JET_IdxInfoSysTabCursor :
			if ( cbResult < sizeof(JET_TABLEID) )
				goto HandleError;
			break;
		case JET_IdxInfoOLC :
			if ( cbResult < sizeof(JET_OLCSTAT) )
				goto HandleError;
			break;
		case JET_IdxInfoResetOLC :
			break;
		case JET_IdxInfoSpaceAlloc :
			if ( cbResult < sizeof(unsigned long) )
				goto HandleError;
			break;
		case JET_IdxInfoLangid :
			if ( cbResult < sizeof(unsigned short) )
				goto HandleError;
			break;
		case JET_IdxInfoCount:
			if ( cbResult < sizeof( INT ) )
				goto HandleError;
			break;
		}

	err = ErrDispGetTableIndexInfo(sesid, tableid, szIndexName, pvResult, cbResult, InfoLevel);
#ifdef DEBUG
	switch (InfoLevel)
		{
	case JET_IdxInfo :
	case JET_IdxInfoList :
		MarkTableidExported(err, ((JET_INDEXLIST*)pvResult)->tableid);
		break;
	case JET_IdxInfoSysTabCursor :
		MarkTableidExported(err, *(JET_TABLEID*)pvResult);
		break;
		}
#endif

HandleError:
	APIReturn(err);
	}


JET_ERR JET_API JetGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char  *szTableName, const char  *szIndexName,
	void  *pvResult, unsigned long cbResult,
	unsigned long InfoLevel)
	{
	ERR	err;

	APIEnter();
	DebugLogJetOp( sesid, opGetIndexInfo );

	FillClientBuffer(pvResult, cbResult);

	err = JET_errBufferTooSmall;

	switch (InfoLevel)
		{
		case JET_IdxInfo :
		case JET_IdxInfoList :
			if (cbResult < sizeof(JET_INDEXLIST))
				goto HandleError;
			break;
		case JET_IdxInfoSysTabCursor :
			if (cbResult < sizeof(JET_TABLEID))
				goto HandleError;
			break;
		case JET_IdxInfoOLC :
			if ( cbResult < sizeof(JET_OLCSTAT) )
				goto HandleError;
			break;
		case JET_IdxInfoResetOLC :
			break;
		case JET_IdxInfoSpaceAlloc :
			if (cbResult < sizeof(unsigned long))
				goto HandleError;
			break;
		case JET_IdxInfoLangid :
			if (cbResult < sizeof(unsigned short))
				goto HandleError;
			break;
		case JET_IdxInfoCount:
			if ( cbResult < sizeof( INT ) )
				goto HandleError;
			break;
		}

	err = ErrIsamGetIndexInfo( sesid,
		(JET_VDBID)dbid,
		szTableName,
		szIndexName,
		pvResult,
		cbResult,
		InfoLevel );

#ifdef DEBUG
	switch (InfoLevel)
		{
	case JET_IdxInfo :
	case JET_IdxInfoList :
		MarkTableidExported(err, ((JET_INDEXLIST*)pvResult)->tableid);
		break;
	case JET_IdxInfoSysTabCursor :
		MarkTableidExported(err, *(JET_TABLEID*)pvResult);
		break;
		}
#endif

HandleError:
	APIReturn(err);
	}


JET_ERR JET_API JetGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp, const char  *szContainerName,
	const char  *szObjectName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	JET_ERR err;

	APIEnter();
	DebugLogJetOp( sesid, opGetObjectInfo );

	FillClientBuffer(pvResult, cbMax);

	err = JET_errBufferTooSmall;

	switch (InfoLevel)
		{
		case JET_ObjInfo :
		case JET_ObjInfoNoStats :
			if (cbMax < sizeof(JET_OBJECTINFO))
				goto HandleError;
			break;
		case JET_ObjInfoListNoStats :
		case JET_ObjInfoList :
			if (cbMax < sizeof(JET_OBJECTLIST))
				goto HandleError;
			break;
		case JET_ObjInfoSysTabCursor :
		case JET_ObjInfoSysTabReadOnly:
			if (cbMax < sizeof(JET_TABLEID))
				goto HandleError;
			break;

		default:
			err = JET_errInvalidParameter;
			goto HandleError;
		}

	err = ErrIsamGetObjectInfo( sesid,
		(JET_VDBID)dbid,
		objtyp,
		szContainerName,
		szObjectName,
		pvResult,
		cbMax,
		InfoLevel );

#ifdef DEBUG
	switch (InfoLevel)
		{
	case JET_ObjInfoListNoStats :
	case JET_ObjInfoList :
		MarkTableidExported(err, ((JET_OBJECTLIST*)pvResult)->tableid);
		break;
	case JET_ObjInfoSysTabCursor :
	case JET_ObjInfoSysTabReadOnly:
		MarkTableidExported(err, *(JET_TABLEID*)pvResult);
		break;
		}
#endif

HandleError:
	APIReturn(err);
	}


JET_ERR JET_API JetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	APIEnter();
	DebugLogJetOp( sesid, opGetTableInfo );

	FillClientBuffer(pvResult, cbMax);

	CheckTableidExported(tableid);

	APIReturn(ErrDispGetTableInfo(sesid, tableid, pvResult, cbMax, InfoLevel));
	}

JET_ERR JET_API JetBeginTransaction(JET_SESID sesid)
	{
	ERR	err;

	APIEnter();
	DebugLogJetOp( sesid, opBeginTransaction );

	err = ErrIsamBeginTransaction(sesid);

	APIReturn(err);
	}


JET_ERR JET_API JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit)
	{
	ERR	err;

	APIEnter();
	DebugLogJetOp( sesid, opCommitTransaction );

	if ( grbit & ~(JET_bitCommitLazyFlush | JET_bitCommitFlush | JET_bitWaitLastLevel0Commit) )
		{
		err = JET_errInvalidParameter;
		}
	else
		{
		err = ErrIsamCommitTransaction( sesid, grbit );
		}

	APIReturn( err );
	}


JET_ERR JET_API JetRollback(JET_SESID sesid, JET_GRBIT grbit)
	{
	ERR	err;
 
	APIEnter();
	DebugLogJetOp( sesid, opRollback );

	if (grbit & ~JET_bitRollbackAll)
		{
		err = JET_errInvalidParameter;
		}
	else
		{
		err = ErrIsamRollback(sesid, grbit);
		}

	APIReturn( err );
	}


JET_ERR JET_API JetOpenTable( JET_SESID sesid, JET_DBID dbid,
	const char  *szTableName, const void  *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit,
	JET_TABLEID  *ptableid )
	{
	ERR err;

	APIEnter();
	DebugLogJetOp( sesid, opOpenTable );

	err = ErrIsamOpenTable( sesid, (JET_VDBID)dbid, ptableid, (char *)szTableName, grbit );

/*AllDone:*/
#ifdef DEBUG
	if (!(grbit & JET_bitTableBulk))
		MarkTableidExported(err, *ptableid);
#endif
	APIReturn(err);
	}


JET_ERR JET_API JetDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID *ptableid, JET_GRBIT grbit)
	{
	ERR	err;

	APIEnter();
	DebugLogJetOp( sesid, opDupCursor );

	CheckTableidExported(tableid);

	err = ErrDispDupCursor(sesid, tableid, ptableid, grbit);

	MarkTableidExported(err, *ptableid);
	APIReturn(err);
	}


JET_ERR JET_API JetCloseTable(JET_SESID sesid, JET_TABLEID tableid)
	{
	APIEnter();
	DebugLogJetOp( sesid, opCloseTable );

	CheckTableidExported(tableid);

	APIReturn(ErrDispCloseTable(sesid, tableid));
	}


JET_ERR JET_API JetGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szColumnName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	ERR err;

	APIEnter();
	DebugLogJetOp( sesid, opGetTableColumnInfo );

	FillClientBuffer(pvResult, cbMax);

	CheckTableidExported(tableid);

	err = JET_errBufferTooSmall;

	switch (InfoLevel)
		{
		case JET_ColInfo :
			if (cbMax < sizeof(JET_COLUMNDEF))
				goto HandleError;
			break;
		case JET_ColInfoList :
		case 2 :
			if (cbMax < sizeof(JET_COLUMNLIST))
				goto HandleError;
			break;
		case JET_ColInfoSysTabCursor :
			if (cbMax < sizeof(JET_TABLEID))
				goto HandleError;
			break;

		case JET_ColInfoBase :
			if (cbMax < sizeof(JET_COLUMNBASE))
				goto HandleError;
			break;
		}

	err = ErrDispGetTableColumnInfo(sesid, tableid, szColumnName,
		pvResult, cbMax, InfoLevel);
#ifdef DEBUG
	switch (InfoLevel)
		{
	case JET_ColInfoList :
	case 2 :
	case JET_ColInfoListCompact :
		MarkTableidExported(err, ((JET_COLUMNLIST*)pvResult)->tableid);
		break;
	case JET_ColInfoSysTabCursor :
		MarkTableidExported(err, *(JET_TABLEID*)pvResult);
		break;
		}
#endif

HandleError:
	APIReturn(err);
	}


JET_ERR JET_API JetGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char  *szTableName, const char  *szColumnName,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	ERR	err;

	APIEnter();
	DebugLogJetOp( sesid, opGetColumnInfo );

	FillClientBuffer(pvResult, cbMax);

	err = JET_errBufferTooSmall;

	switch (InfoLevel)
		{
		case JET_ColInfo :
			if (cbMax < sizeof(JET_COLUMNDEF))
				goto HandleError;
			break;
		case JET_ColInfoList :
		case 2 :
			if (cbMax < sizeof(JET_COLUMNLIST))
				goto HandleError;
			break;
		case JET_ColInfoSysTabCursor :
			if (cbMax < sizeof(JET_TABLEID))
				goto HandleError;
			break;
		case JET_ColInfoBase :
			if (cbMax < sizeof(JET_COLUMNBASE))
				goto HandleError;
			break;
		}

	err = ErrIsamGetColumnInfo( sesid,
		(JET_VDBID)dbid,
		szTableName,
		szColumnName,
		pvResult,
		cbMax,
		InfoLevel );

	Assert( err != JET_errSQLLinkNotSupported );

#ifdef DEBUG
	switch (InfoLevel)
		{
	case JET_ColInfoList :
	case 2 :
		MarkTableidExported(err, ((JET_COLUMNLIST*)pvResult)->tableid);
		break;
	case JET_ColInfoSysTabCursor :
		MarkTableidExported(err, *(JET_TABLEID*)pvResult);
		break;
		}
#endif

HandleError:
	APIReturn(err);
	}


JET_ERR JET_API JetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void  *pvData, unsigned long cbData,
	unsigned long  *pcbActual, JET_GRBIT grbit,
	JET_RETINFO  *pretinfo)
	{
	APIEnter();
	DebugLogJetOp( sesid, opRetrieveColumn );

	CheckTableidExported(tableid);

	APIReturn(ErrDispRetrieveColumn(sesid, tableid, columnid, pvData,
		cbData, pcbActual, grbit, pretinfo));
	}


JET_ERR JET_API JetRetrieveColumns( JET_SESID sesid, JET_TABLEID tableid,
	JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn )
	{
	JET_ERR	  			err = JET_errSuccess;
	JET_RETRIEVECOLUMN	*pretrievecolumnMax = pretrievecolumn + cretrievecolumn;
	JET_VSESID			vsesid; 
	JET_VTID  			vtid;

	APIEnter();
	DebugLogJetOp( sesid, opRetrieveColumns );

	CheckTableidExported(tableid);

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		APIReturn( JET_errInvalidTableId );

	err = ErrIsamRetrieveColumns( vsesid, vtid, pretrievecolumn, cretrievecolumn );

	APIReturn( err );
	}


JET_ERR JET_API JetSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void  *pvData, unsigned long cbData,
	JET_GRBIT grbit, JET_SETINFO  *psetinfo)
	{
	APIEnter();
	DebugLogJetOp( sesid, opSetColumn );

	CheckTableidExported(tableid);

	APIReturn(ErrDispSetColumn(sesid, tableid, columnid, pvData, cbData,
		grbit, psetinfo));
	}


JET_ERR JET_API JetSetColumns(JET_SESID sesid, JET_TABLEID tableid,
	JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn )
	{
	JET_ERR	  			err = JET_errSuccess;
	JET_SETCOLUMN		*psetcolumnMax = psetcolumn + csetcolumn;
	JET_VSESID			vsesid; 
	JET_VTID  			vtid;

	APIEnter();
	DebugLogJetOp( sesid, opSetColumns );

	CheckTableidExported(tableid);

	vsesid = rgvtdef[tableid].vsesid;
	if (vsesid == (JET_VSESID) 0xFFFFFFFF)
		vsesid = (JET_VSESID) sesid;

	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		APIReturn( JET_errInvalidTableId );

	err = ErrIsamSetColumns( vsesid, vtid, psetcolumn, csetcolumn );

	APIReturn( err );
	}


JET_ERR JET_API JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep)
	{
	APIEnter();
	DebugLogJetOp( sesid, opPrepareUpdate );

	CheckTableidExported(tableid);

	APIReturn( ErrDispPrepareUpdate( sesid, tableid, prep ) );
	}


JET_ERR JET_API JetUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvBookmark, unsigned long cbMax,
	unsigned long  *pcbActual)
	{
	APIEnter();
	DebugLogJetOp( sesid, opUpdate );

	CheckTableidExported(tableid);

	APIReturn(ErrDispUpdate(sesid, tableid, pvBookmark, cbMax, pcbActual));
	}


JET_ERR JET_API JetDelete(JET_SESID sesid, JET_TABLEID tableid)
	{
	APIEnter();
	DebugLogJetOp( sesid, opDelete );

	CheckTableidExported(tableid);

	APIReturn(ErrDispDelete(sesid, tableid));
	}


JET_ERR JET_API JetGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	APIEnter();
	DebugLogJetOp( sesid, opGetCursorInfo );

	CheckTableidExported(tableid);

	APIReturn(ErrDispGetCursorInfo(sesid, tableid, pvResult, cbMax, InfoLevel));
	}


JET_ERR JET_API JetGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char  *szIndexName, unsigned long cchIndexName)
	{
	APIEnter();
	DebugLogJetOp( sesid, opGetCurrentIndex );

	CheckTableidExported(tableid);

	APIReturn(ErrDispGetCurrentIndex(sesid, tableid, szIndexName, cchIndexName));
	}


JET_ERR JET_API JetSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szIndexName)
	{
	APIEnter();
	DebugLogJetOp( sesid, opSetCurrentIndex );

	CheckTableidExported(tableid);

	APIReturn(ErrDispSetCurrentIndex(sesid, tableid, szIndexName));
	}


JET_ERR JET_API JetSetCurrentIndex2(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szIndexName, JET_GRBIT grbit )
	{
	JET_VSESID			vsesid; 
	JET_VTID  			vtid;

	APIEnter();
	DebugLogJetOp( sesid, opSetCurrentIndex );

	CheckTableidExported(tableid);

	/*	validate grbit
	/**/
	if ( grbit & ~(JET_bitMoveFirst|JET_bitNoMove) )
		return JET_errInvalidParameter;

	vsesid = rgvtdef[tableid].vsesid;
	if ( vsesid == (JET_VSESID) 0xFFFFFFFF )
		vsesid = (JET_VSESID) sesid;
	vtid = rgvtdef[tableid].vtid;
	if ( vtid == 0 )
		APIReturn( JET_errInvalidTableId );

	APIReturn( ErrIsamSetCurrentIndex2( vsesid, vtid, szIndexName, grbit ) );
	}


JET_ERR JET_API JetMove(JET_SESID sesid, JET_TABLEID tableid,
	signed long cRow, JET_GRBIT grbit)
	{
	APIEnter();
	DebugLogJetOp( sesid, opMove );

	CheckTableidExported(tableid);

	APIReturn(ErrDispMove(sesid, tableid, cRow, grbit));
	}


JET_ERR JET_API JetMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void  *pvData, unsigned long cbData, JET_GRBIT grbit)
	{
	APIEnter();
	DebugLogJetOp( sesid, opMakeKey );

	CheckTableidExported(tableid);

	APIReturn(ErrDispMakeKey(sesid, tableid, pvData, cbData, grbit));
	}


JET_ERR JET_API JetSeek(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit)
	{
	APIEnter();
	DebugLogJetOp( sesid, opSeek );

	CheckTableidExported(tableid);

	APIReturn(ErrDispSeek(sesid, tableid, grbit));
	}


JET_ERR JET_API JetGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvBookmark, unsigned long cbMax,
	unsigned long  *pcbActual)
	{
	APIEnter();
	DebugLogJetOp( sesid, opGetBookmark );

	CheckTableidExported(tableid);

	APIReturn(ErrDispGetBookmark(sesid, tableid, pvBookmark, cbMax, pcbActual));
	}


JET_ERR JET_API JetGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvBookmark, unsigned long cbBookmark)
	{
	APIEnter();
	DebugLogJetOp( sesid, opGotoBookmark );

	CheckTableidExported(tableid);

	APIReturn(ErrDispGotoBookmark(sesid, tableid, pvBookmark, cbBookmark));
	}


JET_ERR JET_API JetGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS  *precpos, unsigned long cbKeypos)
	{
	APIEnter();
	DebugLogJetOp( sesid, opGetRecordPosition );

	CheckTableidExported(tableid);

	APIReturn(ErrDispGetRecordPosition(sesid, tableid, precpos, cbKeypos));
	}


JET_ERR JET_API JetGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos)
	{
	APIEnter();
	DebugLogJetOp( sesid, opGotoPosition );

	CheckTableidExported(tableid);

	APIReturn(ErrDispGotoPosition(sesid, tableid, precpos));
	}


JET_ERR JET_API JetRetrieveKey(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvKey, unsigned long cbMax,
	unsigned long  *pcbActual, JET_GRBIT grbit)
	{
	APIEnter();
	DebugLogJetOp( sesid, opRetrieveKey );

	CheckTableidExported(tableid);

	APIReturn(ErrDispRetrieveKey(sesid, tableid, pvKey, cbMax, pcbActual, grbit));
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\bf.c ===
#include "daestd.h"

DeclAssertFile;         /* Declare file name for assert macros */

/*******************************************************************

  The buffer manager maintains a LRU-K heap to keep track of referenced
  page, and order the page's buffer in LRU-K order. The buffer manager
  also maintains an avail lru list. When number of available buffer is
  lower than a threshold, then buffer manager will activate BFClean
  thread to take out the writable buffers from lru-k heap and put them
  into BFWrite heap. When there are enough buffers are put into BFWrite heap,
  the BFWrite thread will be activated and begin to take out the buffers
  from BFWrite heap and issue an assynchronous write.

  If two references are too close, then we said the two references are
  correlated and we treat them as one reference. LRU-K weight is the
  interval of two non-correlated references.

  BFWrite process will issue IO to a certain number (controled by a system
  parameter), and then stop issuing and sleepEx. When one write is complete
  and its completion routine is called, it will then issue another write.
  This mechanism allow us to make sure no too much writes are issued and
  not saturate disk for writes only.

  When BFWrite taking out buffers to write, it check next buffer in the
  BFWrite heap to see if it can combine the two (or more) writes as one.
  A continuous batch write buffers are used for this purpose. As long as
  batch write buffers are available we will combine the writes whenever
  page number is contiguous.

  A buffer can be in one of the following states:
	  pre/read/write - the buffer is being used for IO's.
	  held - temporarily taken out from a heap and put to another heap.
  A buffer in one of above state is said the buffer is in use.
  If a buffer is in use, the requester has to wait until it become available.
  A buffer state must be checked within critBF so that no thread will see
  the transit state of a buffer.

/*******************************************************************/


/*  true when BF subsystem is initialized
/**/
BOOL fBFInitialized = fFalse;


/*
 *  Buffer hash table.
 */

HE	rgheHash[ ipbfMax ];


/*
 *  buffer group control block.
 */

BGCB	bgcb;
//	UNDONE:	rename pbgcb to pbgcbGlobal
BGCB    *pbgcb = NULL;


/*
 *  A buffer can be in one of the 4 groups
 *   1) LRU-K heap and temp list.
 *      regulated by critLRUK.
 *      a) in LRU-K heap. ( 0 <= ipbf < ipbfLRUKHeapMac )
 *      b) temporary clean cache list. ( ipbfInLRUKList == -2 )
 *         The head of the list is lrulistLRUK.pbLRU.
 *
 *   2) BFIO heap.
 *      regulated by critBFIO. ( ipbfBFIOHeapMic <= ipbf < ipbfHeapMax )
 *
 *   3) Available lru list
 *      regulated by critAvail. ( ipbfInAvailList == -3 )
 *      The head of the list is pbgcb->lrulist.pbfLRU.
 *
 *   4) dangling buffers. ( ipbfDangling == -1 ).
 *
 *  A buffer is being pre/read/written/hold, its pre/read/write/hold flag
 *  will be set. During buffer clean up, if a buffer is in LRU-K heap and
 *  is latched, it will be put into a temporay lru list, and then be put
 *  back to LRU-K heap at the end of clean_up process issuing IO (it does
 *  not wait for IOs).
 *
 *  Both LRU-K and BFIO heaps are sharing one heap (rgpbfHeap), the LRU-K
 *  heap is growing from 0 to higher numbers, and BFIO heap is growing from
 *  higher number (ipbfHeapMax - 1) to lower number.
 */

BF **rgpbfHeap = NULL;
INT ipbfHeapMax;

INT ipbfLRUKHeapMac;
INT ipbfBFIOHeapMic;

LRULIST lrulistLRUK;		/* -2 */

#define ipbfDangling		-1
#define ipbfInLRUKList		-2
#define ipbfInAvailList		-3

/*
 *  History heap
 */

BF **rgpbfHISTHeap = NULL;
INT ipbfHISTHeapMax;
INT ipbfHISTHeapMac;

/*
 *  critical section order
 *  critJet --> (critLRUK, critBFIO, critAvail ) --> critHIST --> critHash --> critBF
 */

//CRIT	critHASH;		/* for accessing hash table */
CRIT	critHIST;		/* for accessing history heap */
CRIT	critLRUK;		/* for accessing LRU-K heap */
CRIT	critBFIO;		/* for accessing BFIO heap */
CRIT	critAvail;		/* for accessing avail lru-list */


/*
 *  Batch IO buffers. Used by BFIO to write contigous pages, or by preread
 *  to read contiguous pages. Allocation of contiguous batch IO buffers
 *  must be done in critBatch. If a batch IO buffer is allocated, the
 *  corresponding use flag will be set.
 */

CRIT	critBatchIO;
LONG	ipageBatchIOMax;
PAGE	*rgpageBatchIO = NULL;
BYTE	*rgbBatchIOUsed = NULL;

/*
 *  BFClean process - take the heaviest buffer out of LRUK heap and put
 *  into BFIO process.
 */

HANDLE	handleBFCleanProcess = 0;
BOOL	fBFCleanProcessTerm = 0;
SIG		sigBFCleanProc;
LOCAL ULONG BFCleanProcess( VOID );

/*
 *  BFIO process - take the buffer out of BFIO heap and issue IO's
 */

HANDLE	handleBFIOProcess = 0;
BOOL	fBFIOProcessTerm = 0;
SIG		sigBFIOProc;
LOCAL ULONG BFIOProcess( VOID );

#define fSync				fTrue
#define fAsync				fFalse
LOCAL ERR ErrBFIAlloc( BF **ppbf, BOOL fSyncMode );

INLINE BOOL FBFIWritable(BF *pbf, BOOL fSkipBufferWithDeferredBI, PIB *ppibAllowedWriteLatch );
LOCAL ERR ErrBFClean();
LOCAL ERR ErrBFIRemoveDependence( PIB *ppib, BF *pbf, BOOL fNoWait );

INLINE LOCAL BF * PbfBFISrchHashTable( PN pn, BUT but );
INLINE LOCAL VOID BFIInsertHashTable( BF *pbf, BUT but );
INLINE LOCAL VOID BFIDeleteHashTable( BF *pbf, BUT but );

LOCAL VOID __stdcall BFIOComplete( LONG err, LONG cb, OLP *polp );


/*
 *  system parameters
 */
extern long lBufThresholdLowPercent;
extern long lBufThresholdHighPercent;
extern long lBufGenAge;

extern long lBufBatchIOMax;
extern long lAsynchIOMax;

extern LONG lPageReadAheadMax;


//  perfmon statistics

//  LRUKRefInt distribution object for COSTLY_PERF

#ifdef COSTLY_PERF

PM_ICF_PROC LLRUKIntervalsICFLPpv;

STATIC DWORD cmsecRefIntBase = 0;
STATIC DWORD cmsecRefIntDeltaT = 1000;
STATIC DWORD cRefIntInterval = 100;
STATIC DWORD cRefIntInstance;

long LLRUKIntervalsICFLPpv( long lAction, void **ppvMultiSz )
	{
	STATIC HKEY hkeyLRUKDist = NULL;
	STATIC WCHAR *pwszIntervals = NULL;
	
	/*  init
	/**/
	if ( lAction == ICFInit )
		{
		ERR err;
		DWORD Disposition;
		
		/*  open / create registry key
		/**/
		CallR( ErrUtilRegCreateKeyEx(	hkeyHiveRoot,
										"LRUK Reference Interval Distribution",
										&hkeyLRUKDist,
										&Disposition ) );

		return 0;
		}
	
	/*  return our catalog string, if requested
	/**/
	if ( lAction == ICFData )
		{
		DWORD Type;
		LPBYTE lpbData;
		BOOL fUpdateString = !pwszIntervals;

		/*  retrieve current registry settings, noting changes
		/**/
		if ( ErrUtilRegQueryValueEx( hkeyLRUKDist, "cmsecBase", &Type, &lpbData ) < 0 )
			{
			(VOID)ErrUtilRegSetValueEx(	hkeyLRUKDist,
										"cmsecBase",
										REG_DWORD,
										(CONST BYTE *)&cmsecRefIntBase,
										sizeof( cmsecRefIntBase ) );
			}
		else if ( *( (DWORD*)lpbData ) != cmsecRefIntBase )
			{
			fUpdateString = TRUE;
			cmsecRefIntBase = *( (DWORD*)lpbData );
			SFree( lpbData );
			}
		if ( ErrUtilRegQueryValueEx( hkeyLRUKDist, "cmsecDeltaT", &Type, &lpbData ) < 0 )
			{
			(VOID)ErrUtilRegSetValueEx(	hkeyLRUKDist,
										"cmsecDeltaT",
										REG_DWORD,
										(CONST BYTE *)&cmsecRefIntDeltaT,
										sizeof( cmsecRefIntDeltaT ) );
			}
		else if ( *( (DWORD*)lpbData ) != cmsecRefIntDeltaT )
			{
			fUpdateString = TRUE;
			cmsecRefIntDeltaT = *( (DWORD*)lpbData );
			SFree( lpbData );
			}
		if ( ErrUtilRegQueryValueEx( hkeyLRUKDist, "cInterval", &Type, &lpbData ) < 0 )
			{
			(VOID)ErrUtilRegSetValueEx(	hkeyLRUKDist,
										"cInterval",
										REG_DWORD,
										(CONST BYTE *)&cRefIntInterval,
										sizeof( cRefIntInterval ) );
			}
		else if ( *( (DWORD*)lpbData ) != cRefIntInterval )
			{
			fUpdateString = TRUE;
			cRefIntInterval = *( (DWORD*)lpbData );
			SFree( lpbData );
			}
		
		/*  if the settings have changed, rebuild interval string
		/**/
		if ( fUpdateString )
			{
			DWORD iInterval;
			DWORD iwch;

			cRefIntInstance = cRefIntInterval + 3 + ( cmsecRefIntBase ? 1 : 0 );

			SFree( pwszIntervals );
			pwszIntervals = SAlloc( ( cRefIntInstance * 32 ) * sizeof( WCHAR ) );
			if ( !pwszIntervals )
				{
				*ppvMultiSz = NULL;
				return 0;
				}
			iwch = 0;
			if ( cmsecRefIntBase != 0 )
				{
				swprintf(	pwszIntervals + iwch,
							L"< %3g seconds",
							( cmsecRefIntBase ) / (float)1000 );
				iwch += wcslen( pwszIntervals + iwch ) + 1;
				}
			for ( iInterval = 0; iInterval < cRefIntInterval; iInterval++ )
				{
				swprintf(	pwszIntervals + iwch,
							L"< %3g seconds",
							( cmsecRefIntBase + ( iInterval + 1 ) * cmsecRefIntDeltaT ) / (float)1000 );
				iwch += wcslen( pwszIntervals + iwch ) + 1;
				}
			swprintf(	pwszIntervals + iwch,
						L"> %3g seconds",
						( cmsecRefIntBase + cRefIntInterval * cmsecRefIntDeltaT ) / (float)1000 );
			iwch += wcslen( pwszIntervals + iwch ) + 1;
			swprintf( pwszIntervals + iwch, L"Infinite" );
			iwch += wcslen( pwszIntervals + iwch ) + 1;
			swprintf( pwszIntervals + iwch, L"Never Touched\0" );
			}
		
		/*  return interval string on success
		/**/
		*ppvMultiSz = pwszIntervals;
		return cRefIntInstance;
		}

	/*  term
	/**/
	if ( lAction == ICFTerm )
		{
		/*  close registry
		/**/
		(VOID)ErrUtilRegCloseKeyEx( hkeyLRUKDist );
		hkeyLRUKDist = NULL;

		/*  free resources
		/**/
		SFree( pwszIntervals );
		pwszIntervals = NULL;
		
		return 0;
		}
	
	return 0;
	}


PM_CEF_PROC LLRUKRefIntDistCEFLPpv;

long LLRUKRefIntDistCEFLPpv( long iInstance, void *pvBuf )
	{
	STATIC DWORD cInstanceData = 0;
	STATIC LONG *prglInstanceData = NULL;

	if ( pvBuf )
		{
		/*  if BF is not initialized, return 0
		/**/
		if ( !fBFInitialized )
			{
			*( (unsigned long *) pvBuf ) = 0;
			return 0;
			}
			
		/*  if we are collecting instance 0 data, compute data
		/*  for all instances in one pass
		/**/
		if ( !iInstance )
			{
			BF *pbf;
			BOOL fUseLessThan;
			DWORD cmsecMin;
			DWORD cmsecMax;
			DWORD iInstanceLessThan;
			DWORD iInstanceFirstInterval;
			DWORD iInstanceGreaterThan;
			DWORD iInstanceInfinite;
			DWORD iInstanceNeverTouched;
			DWORD cmsecTime;
			DWORD cmsecMeanRefPeriod;
			DWORD iInterval;
			
			/*  if we have no instance data storage or the number of
			/*  instances has grown, allocate instance storage
			/**/
			if ( !prglInstanceData || cRefIntInstance > cInstanceData )
				{
				SFree( prglInstanceData );
				prglInstanceData = SAlloc( cRefIntInstance * sizeof( LONG ) );
				if ( !prglInstanceData )
					{
					/*  error, return 0 for all instances
					/**/
					cInstanceData = 0;
					*( (unsigned long *) pvBuf ) = 0;
					return 0;
					}
				cInstanceData = cRefIntInstance;
				}

			/*  setup for collection
			/**/
			fUseLessThan = cmsecRefIntBase != 0;
			cmsecMin = cmsecRefIntBase;
			cmsecMax = cmsecRefIntBase + cRefIntInterval * cmsecRefIntDeltaT;
			iInstanceLessThan = 0;
			iInstanceFirstInterval = fUseLessThan ? 1 : 0;
			iInstanceGreaterThan = cRefIntInstance - 3;
			iInstanceInfinite = cRefIntInstance - 2;
			iInstanceNeverTouched = cRefIntInstance - 1;
			memset( prglInstanceData, 0, cRefIntInstance * sizeof( LONG ) );
			cmsecTime = UlUtilGetTickCount();

			/*  collect all instance data by scanning all BF structures
			/**/
			for ( pbf = pbgcb->rgbf; pbf < pbgcb->rgbf + pbgcb->cbfGroup; pbf++ )
				{
				/*  never touched
				/**/
				if ( !pbf->ulBFTime1 )
					{
					prglInstanceData[iInstanceNeverTouched]++;
					continue;
					}
					
				/*  infinite
				/**/
				if ( !pbf->ulBFTime2 )
					{
					prglInstanceData[iInstanceInfinite]++;
					continue;
					}

				/*  compute estimated mean reference period as of cmsecTime
				/**/
				cmsecMeanRefPeriod = ( cmsecTime - pbf->ulBFTime2 ) / 2;

				/*  less than
				/**/
				if ( fUseLessThan && cmsecMeanRefPeriod < cmsecMin )
					{
					prglInstanceData[iInstanceLessThan]++;
					continue;
					}

				/*  greater than
				/**/
				if ( cmsecMeanRefPeriod > cmsecMax )
					{
					prglInstanceData[iInstanceGreaterThan]++;
					continue;
					}

				/*  interval range
				/**/
				iInterval = ( cmsecMeanRefPeriod - cmsecMin ) / cmsecRefIntDeltaT;
				prglInstanceData[iInstanceFirstInterval + iInterval]++;
				}

			/*  integrate intervals to get distribution
			/**/
			for ( iInterval = ( cmsecRefIntBase ? 0 : 1 ); iInterval < cRefIntInterval; iInterval++ )
				{
				prglInstanceData[iInstanceFirstInterval + iInterval] +=
					prglInstanceData[iInstanceFirstInterval + iInterval - 1];
				}
				
			/*  return instance data
			/**/
			*( (unsigned long *) pvBuf ) = prglInstanceData[iInstance];
			}

		/*  return data computed during instance 0 collection for
		/*  all other instances
		/**/
		else
			{
			/*  if there is no instance data, return 0
			/**/
			if ( !cInstanceData )
				{
				*( (unsigned long *) pvBuf ) = 0;
				return 0;
				}

			/*  return instance data
			/**/
			*( (unsigned long *) pvBuf ) = prglInstanceData[iInstance];
			}
		}
		
	return 0;
	}


#endif  //  COSTLY_PERF


//  LRUKDeltaT distribution object for COSTLY_PERF

#ifdef COSTLY_PERF

PM_ICF_PROC LLRUKRawIntervalsICFLPpv;

STATIC DWORD cmsecDeltaTBase = 0;
STATIC DWORD cmsecDeltaTDeltaT = 1000;
STATIC DWORD cDeltaTInterval = 100;
STATIC DWORD cDeltaTInstance;

long LLRUKRawIntervalsICFLPpv( long lAction, void **ppvMultiSz )
	{
	STATIC HKEY hkeyLRUKDist = NULL;
	STATIC WCHAR *pwszIntervals = NULL;
	
	/*  init
	/**/
	if ( lAction == ICFInit )
		{
		ERR err;
		DWORD Disposition;
		
		/*  open / create registry key
		/**/
		CallR( ErrUtilRegCreateKeyEx(	hkeyHiveRoot,
										"LRUK Reference dT Distribution",
										&hkeyLRUKDist,
										&Disposition ) );

		return 0;
		}
	
	/*  return our catalog string, if requested
	/**/
	if ( lAction == ICFData )
		{
		DWORD Type;
		LPBYTE lpbData;
		BOOL fUpdateString = !pwszIntervals;

		/*  retrieve current registry settings, noting changes
		/**/
		if ( ErrUtilRegQueryValueEx( hkeyLRUKDist, "cmsecBase", &Type, &lpbData ) < 0 )
			{
			(VOID)ErrUtilRegSetValueEx(	hkeyLRUKDist,
										"cmsecBase",
										REG_DWORD,
										(CONST BYTE *)&cmsecDeltaTBase,
										sizeof( cmsecDeltaTBase ) );
			}
		else if ( *( (DWORD*)lpbData ) != cmsecDeltaTBase )
			{
			fUpdateString = TRUE;
			cmsecDeltaTBase = *( (DWORD*)lpbData );
			SFree( lpbData );
			}
		if ( ErrUtilRegQueryValueEx( hkeyLRUKDist, "cmsecDeltaT", &Type, &lpbData ) < 0 )
			{
			(VOID)ErrUtilRegSetValueEx(	hkeyLRUKDist,
										"cmsecDeltaT",
										REG_DWORD,
										(CONST BYTE *)&cmsecDeltaTDeltaT,
										sizeof( cmsecDeltaTDeltaT ) );
			}
		else if ( *( (DWORD*)lpbData ) != cmsecDeltaTDeltaT )
			{
			fUpdateString = TRUE;
			cmsecDeltaTDeltaT = *( (DWORD*)lpbData );
			SFree( lpbData );
			}
		if ( ErrUtilRegQueryValueEx( hkeyLRUKDist, "cInterval", &Type, &lpbData ) < 0 )
			{
			(VOID)ErrUtilRegSetValueEx(	hkeyLRUKDist,
										"cInterval",
										REG_DWORD,
										(CONST BYTE *)&cDeltaTInterval,
										sizeof( cDeltaTInterval ) );
			}
		else if ( *( (DWORD*)lpbData ) != cDeltaTInterval )
			{
			fUpdateString = TRUE;
			cDeltaTInterval = *( (DWORD*)lpbData );
			SFree( lpbData );
			}
		
		/*  if the settings have changed, rebuild interval string
		/**/
		if ( fUpdateString )
			{
			DWORD iInterval;
			DWORD iwch;

			cDeltaTInstance = cDeltaTInterval + 3 + ( cmsecDeltaTBase ? 1 : 0 );

			SFree( pwszIntervals );
			pwszIntervals = SAlloc( ( cDeltaTInstance * 32 ) * sizeof( WCHAR ) );
			if ( !pwszIntervals )
				{
				*ppvMultiSz = NULL;
				return 0;
				}
			iwch = 0;
			if ( cmsecDeltaTBase != 0 )
				{
				swprintf(	pwszIntervals + iwch,
							L"< %3g seconds",
							( cmsecDeltaTBase ) / (float)1000 );
				iwch += wcslen( pwszIntervals + iwch ) + 1;
				}
			for ( iInterval = 0; iInterval < cDeltaTInterval; iInterval++ )
				{
				swprintf(	pwszIntervals + iwch,
							L"%= %3g - %3g seconds",
							( cmsecDeltaTBase + iInterval * cmsecDeltaTDeltaT ) / (float)1000,
							( cmsecDeltaTBase + ( iInterval + 1 ) * cmsecDeltaTDeltaT ) / (float)1000 );
				iwch += wcslen( pwszIntervals + iwch ) + 1;
				}
			swprintf(	pwszIntervals + iwch,
						L"> %3g seconds",
						( cmsecDeltaTBase + cDeltaTInterval * cmsecDeltaTDeltaT ) / (float)1000 );
			iwch += wcslen( pwszIntervals + iwch ) + 1;
			swprintf( pwszIntervals + iwch, L"Infinite" );
			iwch += wcslen( pwszIntervals + iwch ) + 1;
			swprintf( pwszIntervals + iwch, L"Never Touched\0" );
			}
		
		/*  return interval string on success
		/**/
		*ppvMultiSz = pwszIntervals;
		return cDeltaTInstance;
		}

	/*  term
	/**/
	if ( lAction == ICFTerm )
		{
		/*  close registry
		/**/
		(VOID)ErrUtilRegCloseKeyEx( hkeyLRUKDist );
		hkeyLRUKDist = NULL;

		/*  free resources
		/**/
		SFree( pwszIntervals );
		pwszIntervals = NULL;
		
		return 0;
		}
	
	return 0;
	}


PM_CEF_PROC LLRUKDeltaTDistCEFLPpv;

long LLRUKDeltaTDistCEFLPpv( long iInstance, void *pvBuf )
	{
	STATIC DWORD cInstanceData = 0;
	STATIC LONG *prglInstanceData = NULL;

	if ( pvBuf )
		{
		/*  if BF is not initialized, return 0
		/**/
		if ( !fBFInitialized )
			{
			*( (unsigned long *) pvBuf ) = 0;
			return 0;
			}
			
		/*  if we are collecting instance 0 data, compute data
		/*  for all instances in one pass
		/**/
		if ( !iInstance )
			{
			BF *pbf;
			BOOL fUseLessThan;
			DWORD cmsecMin;
			DWORD cmsecMax;
			DWORD iInstanceLessThan;
			DWORD iInstanceFirstInterval;
			DWORD iInstanceGreaterThan;
			DWORD iInstanceInfinite;
			DWORD iInstanceNeverTouched;
			DWORD cmsecRefdT;
			DWORD iInterval;
			
			/*  if we have no instance data storage or the number of
			/*  instances has grown, allocate instance storage
			/**/
			if ( !prglInstanceData || cDeltaTInstance > cInstanceData )
				{
				SFree( prglInstanceData );
				prglInstanceData = SAlloc( cDeltaTInstance * sizeof( LONG ) );
				if ( !prglInstanceData )
					{
					/*  error, return 0 for all instances
					/**/
					cInstanceData = 0;
					*( (unsigned long *) pvBuf ) = 0;
					return 0;
					}
				cInstanceData = cDeltaTInstance;
				}

			/*  setup for collection
			/**/
			fUseLessThan = cmsecDeltaTBase != 0;
			cmsecMin = cmsecDeltaTBase;
			cmsecMax = cmsecDeltaTBase + cDeltaTInterval * cmsecDeltaTDeltaT;
			iInstanceLessThan = 0;
			iInstanceFirstInterval = fUseLessThan ? 1 : 0;
			iInstanceGreaterThan = cDeltaTInstance - 3;
			iInstanceInfinite = cDeltaTInstance - 2;
			iInstanceNeverTouched = cDeltaTInstance - 1;
			memset( prglInstanceData, 0, cDeltaTInstance * sizeof( LONG ) );

			/*  collect all instance data by scanning all BF structures
			/**/
			for ( pbf = pbgcb->rgbf; pbf < pbgcb->rgbf + pbgcb->cbfGroup; pbf++ )
				{
				/*  never touched
				/**/
				if ( !pbf->ulBFTime1 )
					{
					prglInstanceData[iInstanceNeverTouched]++;
					continue;
					}
					
				/*  infinite
				/**/
				if ( !pbf->ulBFTime2 )
					{
					prglInstanceData[iInstanceInfinite]++;
					continue;
					}

				/*  compute reference period dT
				/**/
				cmsecRefdT = pbf->ulBFTime1 - pbf->ulBFTime2;

				/*  less than
				/**/
				if ( fUseLessThan && cmsecRefdT < cmsecMin )
					{
					prglInstanceData[iInstanceLessThan]++;
					continue;
					}

				/*  greater than
				/**/
				if ( cmsecRefdT > cmsecMax )
					{
					prglInstanceData[iInstanceGreaterThan]++;
					continue;
					}

				/*  interval range
				/**/
				iInterval = ( cmsecRefdT - cmsecMin ) / cmsecDeltaTDeltaT;
				prglInstanceData[iInstanceFirstInterval + iInterval]++;
				}

			/*  return instance data
			/**/
			*( (unsigned long *) pvBuf ) = prglInstanceData[iInstance];
			}

		/*  return data computed during instance 0 collection for
		/*  all other instances
		/**/
		else
			{
			/*  if there is no instance data, return 0
			/**/
			if ( !cInstanceData )
				{
				*( (unsigned long *) pvBuf ) = 0;
				return 0;
				}

			/*  return instance data
			/**/
			*( (unsigned long *) pvBuf ) = prglInstanceData[iInstance];
			}
		}
		
	return 0;
	}


#endif  //  COSTLY_PERF


//  table classes for COSTLY_PERF (we always allow these to be set)

#define cTableClass				16
#define cwchTableClassNameMax	32
LOCAL WCHAR wszTableClassName[cTableClass][cwchTableClassNameMax] =
	{
	L"Other",		L"Class  1",	L"Class  2",	L"Class  3",
	L"Class  4",	L"Class  5",	L"Class  6",	L"Class  7",
	L"Class  8",	L"Class  9",	L"Class 10",	L"Class 11",
	L"Class 12",	L"Class 13",	L"Class 14",	L"Class 15",
	};
LOCAL LONG lTableClassNameSetMax = -1;

VOID SetTableClassName( LONG lClass, BYTE *szName )
	{
	Assert( lClass > 0 && lClass < cTableClass );
	swprintf( wszTableClassName[lClass], L"%.*S", cwchTableClassNameMax - 1, szName );
	lTableClassNameSetMax = max( lTableClassNameSetMax, lClass );
	}

VOID GetTableClassName( LONG lClass, BYTE *szName, LONG cbMax )
	{
	Assert( lClass > 0 && lClass < cTableClass );
	sprintf( szName, "%.*S", cbMax - 1, wszTableClassName[lClass] );
	}


	/*  ICF used by Tables object  */

PM_ICF_PROC LTableClassNamesICFLPpv;

long LTableClassNamesICFLPpv( long lAction, void **ppvMultiSz )
	{
	STATIC WCHAR wszTableClassNames[( cTableClass + 1 ) * cwchTableClassNameMax + 1];

	/*  if we are initializing, build our string
	/**/
	if ( lAction == ICFInit )
		{
		LONG	lPos = 0;

#ifdef COSTLY_PERF

		LONG	lClass;

		for ( lClass = 0; lClass <= lTableClassNameSetMax; lClass++ )
			{
			lstrcpyW(	(LPWSTR) ( wszTableClassNames + lPos ),
						(LPCWSTR) wszTableClassName[lClass] );
			lPos += lstrlenW( (LPCWSTR) wszTableClassName[lClass] ) + 1;
			}

#endif  //  COSTLY_PERF

		lstrcpyW(	(LPWSTR) ( wszTableClassNames + lPos ),
					(LPCWSTR) L"Global\0" );
		}

	/*  return our catalog string, if requested
	/**/
	if ( lAction == ICFData )
		{
		*ppvMultiSz = wszTableClassNames;
		return lTableClassNameSetMax + 2;
		}
	
	return 0;
	}


#ifdef COSTLY_PERF

//  Table Class BF statistics

//  Table Class aware counters

unsigned long cBFCacheHits[cTableClass] = { 0 };

PM_CEF_PROC LBFCacheHitsCEFLPpv;

long LBFCacheHitsCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		if ( iInstance <= lTableClassNameSetMax || !iInstance )
			*( (unsigned long *) pvBuf ) = cBFCacheHits[iInstance];
		else
			{
			long iInstT;
			
			for ( iInstT = 0; iInstT <= lTableClassNameSetMax; iInstT++ )
				*( (unsigned long *) pvBuf ) += cBFCacheHits[iInstT];
			}
		}
		
	return 0;
	}

unsigned long cBFCacheReqs[cTableClass] = { 0 };

PM_CEF_PROC LBFCacheReqsCEFLPpv;

long LBFCacheReqsCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		if ( iInstance <= lTableClassNameSetMax || !iInstance )
			*( (unsigned long *) pvBuf ) = cBFCacheReqs[iInstance];
		else
			{
			long iInstT;
			
			for ( iInstT = 0; iInstT <= lTableClassNameSetMax; iInstT++ )
				*( (unsigned long *) pvBuf ) += cBFCacheReqs[iInstT];
			}
		}
		
	return 0;
	}

unsigned long cBFUsed[cTableClass] = { 0 };

PM_CEF_PROC LBFUsedBuffersCEFLPpv;

long LBFUsedBuffersCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		if ( iInstance <= lTableClassNameSetMax || !iInstance )
			*( (unsigned long *) pvBuf ) = cBFUsed[iInstance];
		else
			{
			long iInstT;
			
			for ( iInstT = 0; iInstT <= lTableClassNameSetMax; iInstT++ )
				*( (unsigned long *) pvBuf ) += cBFUsed[iInstT];
			}
		}
		
	return 0;
	}

unsigned long cBFClean[cTableClass] = { 0 };

PM_CEF_PROC LBFCleanBuffersCEFLPpv;

long LBFCleanBuffersCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		if ( iInstance <= lTableClassNameSetMax || !iInstance )
			*( (unsigned long *) pvBuf ) = cBFClean[iInstance];
		else
			{
			long iInstT;
			
			for ( iInstT = 0; iInstT <= lTableClassNameSetMax; iInstT++ )
				*( (unsigned long *) pvBuf ) += cBFClean[iInstT];
			}
		}
		
	return 0;
	}

unsigned long cBFAvail[cTableClass] = { 0 };

PM_CEF_PROC LBFAvailBuffersCEFLPpv;

long LBFAvailBuffersCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		if ( iInstance <= lTableClassNameSetMax || !iInstance )
			*( (unsigned long *) pvBuf ) = cBFAvail[iInstance];
		else
			{
			long iInstT;
			
			for ( iInstT = 0; iInstT <= lTableClassNameSetMax; iInstT++ )
				*( (unsigned long *) pvBuf ) += cBFAvail[iInstT];
			}
		}
		
	return 0;
	}

unsigned long cBFTotal;

PM_CEF_PROC LBFTotalBuffersCEFLPpv;

long LBFTotalBuffersCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long *) pvBuf ) = cBFTotal ? cBFTotal : 1;
		
	return 0;
	}

unsigned long cBFPagesRead[cTableClass] = { 0 };

PM_CEF_PROC LBFPagesReadCEFLPpv;

long LBFPagesReadCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		if ( iInstance <= lTableClassNameSetMax || !iInstance )
			*( (unsigned long *) pvBuf ) = cBFPagesRead[iInstance];
		else
			{
			long iInstT;
			
			for ( iInstT = 0; iInstT <= lTableClassNameSetMax; iInstT++ )
				*( (unsigned long *) pvBuf ) += cBFPagesRead[iInstT];
			}
		}
		
	return 0;
	}

unsigned long cBFPagesWritten[cTableClass] = { 0 };

PM_CEF_PROC LBFPagesWrittenCEFLPpv;

long LBFPagesWrittenCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		if ( iInstance <= lTableClassNameSetMax || !iInstance )
			*( (unsigned long *) pvBuf ) = cBFPagesWritten[iInstance];
		else
			{
			long iInstT;
			
			for ( iInstT = 0; iInstT <= lTableClassNameSetMax; iInstT++ )
				*( (unsigned long *) pvBuf ) += cBFPagesWritten[iInstT];
			}
		}
		
	return 0;
	}

PM_CEF_PROC LBFPagesTransferredCEFLPpv;

long LBFPagesTransferredCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		if ( iInstance <= lTableClassNameSetMax || !iInstance )
			*( (unsigned long *) pvBuf ) = cBFPagesRead[iInstance] + cBFPagesWritten[iInstance];
		else
			{
			long iInstT;
			
			for ( iInstT = 0; iInstT <= lTableClassNameSetMax; iInstT++ )
				*( (unsigned long *) pvBuf ) += cBFPagesRead[iInstT] + cBFPagesWritten[iInstT];
			}
		}
		
	return 0;
	}

unsigned long cBFNewDirties[cTableClass] = { 0 };

PM_CEF_PROC LBFNewDirtiesCEFLPpv;

long LBFNewDirtiesCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		if ( iInstance <= lTableClassNameSetMax || !iInstance )
			*( (unsigned long *) pvBuf ) = cBFNewDirties[iInstance];
		else
			{
			long iInstT;
			
			for ( iInstT = 0; iInstT <= lTableClassNameSetMax; iInstT++ )
				*( (unsigned long *) pvBuf ) += cBFNewDirties[iInstT];
			}
		}
		
	return 0;
	}

//  BFSetTableClass:  This function must manipulate the following Table Class
//  aware counters such that the statistics are maintained when we move a BF
//  from one class to another.  For example, for "% buffers used by class," we
//  would have to decrement the count for the old class and increment the count
//  for the new class in order to keep the total at 100%.

VOID BFSetTableClass( BF *pbf, long lClassNew )
	{
	//  this routine is protected by critJet now, but should be protected by a
	//  read latch on the BF in question in the future

	AssertCriticalSection( critJet );
	
	//  if the new class is the same as the current class, we're done

	if ( lClassNew == pbf->lClass )
		return;

	//  update all counter data (that needs updating here)

	//  cBFUsed

	cBFUsed[pbf->lClass]--;
	cBFUsed[lClassNew]++;

	//  cBFClean

	BFEnterCriticalSection( pbf );
	if ( !pbf->fDirty )
		{
		cBFClean[pbf->lClass]--;
		cBFClean[lClassNew]++;
		}
	BFLeaveCriticalSection( pbf );

	//  cBFAvail

	EnterCriticalSection( critAvail );
	if ( pbf->ipbfHeap == ipbfInAvailList )
		{
		cBFAvail[pbf->lClass]--;
		cBFAvail[lClassNew]++;
		}
	LeaveCriticalSection( critAvail );

	//  update BF's class

	pbf->lClass = lClassNew;
	}


#else  //  !COSTLY_PERF

//  above counters, but for use without table classes

unsigned long cBFCacheHits = 0;

PM_CEF_PROC LBFCacheHitsCEFLPpv;

long LBFCacheHitsCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFCacheHits;
		
	return 0;
}

unsigned long cBFCacheReqs = 0;

PM_CEF_PROC LBFCacheReqsCEFLPpv;

long LBFCacheReqsCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFCacheReqs ? cBFCacheReqs : 1;
		
	return 0;
}

unsigned long cBFUsed = 0;

PM_CEF_PROC LBFUsedBuffersCEFLPpv;

long LBFUsedBuffersCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFUsed;
		
	return 0;
}

unsigned long cBFClean = 0;

PM_CEF_PROC LBFCleanBuffersCEFLPpv;

long LBFCleanBuffersCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFClean;
		
	return 0;
}

unsigned long cBFAvail = 0;

PM_CEF_PROC LBFAvailBuffersCEFLPpv;

long LBFAvailBuffersCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFAvail;
		
	return 0;
}

unsigned long cBFTotal = 0;

PM_CEF_PROC LBFTotalBuffersCEFLPpv;

long LBFTotalBuffersCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFTotal ? cBFTotal : 1;
		
	return 0;
}

unsigned long cBFPagesRead = 0;

PM_CEF_PROC LBFPagesReadCEFLPpv;

long LBFPagesReadCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFPagesRead;
		
	return 0;
}

unsigned long cBFPagesWritten = 0;

PM_CEF_PROC LBFPagesWrittenCEFLPpv;

long LBFPagesWrittenCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFPagesWritten;
		
	return 0;
}

PM_CEF_PROC LBFPagesTransferredCEFLPpv;

long LBFPagesTransferredCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFPagesRead + cBFPagesWritten;
		
	return 0;
}

unsigned long cBFNewDirties = 0;

PM_CEF_PROC LBFNewDirtiesCEFLPpv;

long LBFNewDirtiesCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFNewDirties;
		
	return 0;
}

#endif  //  COSTLY_PERF

//  global BF statistics

unsigned long cBFSyncReads = 0;

PM_CEF_PROC LBFSyncReadsCEFLPpv;

long LBFSyncReadsCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFSyncReads;
		
	return 0;
}

unsigned long cBFAsyncReads = 0;

PM_CEF_PROC LBFAsyncReadsCEFLPpv;

long LBFAsyncReadsCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFAsyncReads;
		
	return 0;
}

DWORD cbBFRead = 0;

PM_CEF_PROC LBFBytesReadCEFLPpv;

long LBFBytesReadCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
	{
		*((DWORD *)((char *)pvBuf)) = cbBFRead;
	}
		
	return 0;
}

unsigned long cBFSyncWrites = 0;

PM_CEF_PROC LBFSyncWritesCEFLPpv;

long LBFSyncWritesCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFSyncWrites;
		
	return 0;
}

unsigned long cBFAsyncWrites = 0;

PM_CEF_PROC LBFAsyncWritesCEFLPpv;

long LBFAsyncWritesCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFAsyncWrites;
		
	return 0;
}

DWORD cbBFWritten = 0;

PM_CEF_PROC LBFBytesWrittenCEFLPpv;

long LBFBytesWrittenCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
	{
		*((DWORD *)((char *)pvBuf)) = cbBFWritten;
	}
		
	return 0;
}

PM_CEF_PROC LBFOutstandingReadsCEFLPpv;

unsigned long cBFOutstandingReads = 0;

long LBFOutstandingReadsCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFOutstandingReads;
		
	return 0;
}

PM_CEF_PROC LBFOutstandingWritesCEFLPpv;

unsigned long cBFOutstandingWrites = 0;

long LBFOutstandingWritesCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFOutstandingWrites;
		
	return 0;
}

PM_CEF_PROC LBFOutstandingIOsCEFLPpv;

long LBFOutstandingIOsCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBFOutstandingReads + cBFOutstandingWrites;
		
	return 0;
}

PM_CEF_PROC LBFIOQueueLengthCEFLPpv;

LOCAL INLINE LONG CbfBFIOHeap( VOID );

long LBFIOQueueLengthCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = (unsigned long) CbfBFIOHeap();
		
	return 0;
}

PM_CEF_PROC LBFIOsCEFLPpv;

long LBFIOsCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		* ( (DWORD *) pvBuf ) = cBFAsyncReads + cBFSyncReads + cBFAsyncWrites + cBFSyncWrites;

	return 0;
	}

//unsigned long cBFHashEntries;
//
//PM_CEF_PROC LBFHashEntriesCEFLPpv;
//
//long LBFHashEntriesCEFLPpv(long iInstance,void *pvBuf)
//{
//	if (pvBuf)
//		*((unsigned long *)pvBuf) = cBFHashEntries;
//		
//	return 0;
//}

//unsigned long rgcBFHashChainLengths[ipbfMax];
//
//PM_CEF_PROC LBFMaxHashChainCEFLPpv;
//
//long LBFMaxHashChainCEFLPpv(long iInstance,void *pvBuf)
//{
//	unsigned long ipbf;
//	unsigned long cMaxLen = 0;
//	
//	if (pvBuf)
//	{
//			/*  find max hash chain length  */
//
//		for (ipbf = 0; ipbf < ipbfMax; ipbf++)
//			cMaxLen = max(cMaxLen,rgcBFHashChainLengths[ipbf]);
//
//			/*  return max chain length * table size  */
//			
//		*((unsigned long *)pvBuf) = cMaxLen * ipbfMax;
//	}
//		
//	return 0;
//}

#ifdef DEBUG
//#define DEBUGGING				1
#endif  //  DEBUG


/*********************************************************
 *
 *  Signal Pool  (limit one per thread, please!)
 *
 *********************************************************/

extern LONG lMaxSessions;

LOCAL CRIT	critSIG		= NULL;
LOCAL LONG	isigMax		= 0;
LOCAL LONG	isigMac		= 0;
LOCAL SIG	*rgsig		= NULL;


/*  term signal pool
/**/
LOCAL VOID BFSIGTerm( VOID )
	{
	if ( rgsig != NULL )
		{
		if ( isigMac > 0 )
			{
			do	{
				UtilCloseSignal( rgsig[--isigMac] );
				}
			while ( isigMac > 0 );
			}
		LFree( rgsig );
		rgsig = NULL;
		}
	if ( critSIG != NULL )
		{
		DeleteCriticalSection( critSIG );
		critSIG = NULL;
		}
	}


/*  init signal pool
/**/
LOCAL ERR ErrBFSIGInit( VOID )
	{
	ERR		err;

	/*  we need one signal per PIB and one per engine thread max
	/**/
	isigMax = lMaxSessions + 6;
	
	Call( ErrInitializeCriticalSection( &critSIG ) );
	if ( !( rgsig = LAlloc( isigMax, sizeof( SIG ) ) ) )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}
	for ( isigMac = 0; isigMac < isigMax; isigMac++ )
		Call( ErrUtilSignalCreate( &rgsig[isigMac], NULL ) );

	return JET_errSuccess;
	
HandleError:
	BFSIGTerm();
	return err;
	}

/*  allocate a signal
/**/
LOCAL INLINE ERR ErrBFSIGAlloc( SIG *psig )
	{
	ERR		err = JET_errSuccess;

	EnterCriticalSection( critSIG );
	Assert( isigMac >= 0 && isigMac <= isigMax );
	if ( !isigMac )
		{
		*psig = NULL;
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	else
		*psig = rgsig[--isigMac];
	LeaveCriticalSection( critSIG );

	return err;
	}


/*  deallocate a signal
/**/
LOCAL INLINE VOID BFSIGFree( SIG sig )
	{
	EnterCriticalSection( critSIG );
	Assert( isigMac >= 0 && isigMac < isigMax );
	rgsig[isigMac++] = sig;
	LeaveCriticalSection( critSIG );
	}


/*********************************************************
 *
 *  OLP Pool
 *
 *********************************************************/

extern LONG lAsynchIOMax;

LOCAL CRIT	critOLP		= NULL;
LOCAL LONG	ipolpMax	= 0;
LOCAL LONG	ipolpMac	= 0;
LOCAL OLP	**rgpolp	= NULL;


/*  term OLP pool
/**/
LOCAL VOID BFOLPTerm( BOOL fNormal )
	{
	if ( rgpolp != NULL )
		{
		// Only time ipolpMac != ipolpMax should be if we're terminating due to
		// an error encountered during recovering
		Assert( ipolpMac == ipolpMax  ||  ( !fNormal  &&  fRecovering ) );
		LFree( rgpolp );
		rgpolp = NULL;
		ipolpMac = 0;
		}
	if ( critOLP != NULL )
		{
		DeleteCriticalSection( critOLP );
		critOLP = NULL;
		}
	}


/*  init OLP pool
/**/
LOCAL ERR ErrBFOLPInit( VOID )
	{
	ERR		err;

	/*  we need one OLP per issuable IO max
	/**/
	ipolpMax = lAsynchIOMax;
	
	Call( ErrInitializeCriticalSection( &critOLP ) );
	if ( !( rgpolp = LAlloc( ipolpMax, sizeof( OLP * ) + sizeof( OLP ) ) ) )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}
	for ( ipolpMac = 0; ipolpMac < ipolpMax; ipolpMac++ )
		rgpolp[ipolpMac] = (OLP *) ( rgpolp + ipolpMax ) + ipolpMac;

	return JET_errSuccess;
	
HandleError:
	BFOLPTerm( fTrue );
	return err;
	}

/*  allocate an OLP
/**/
LOCAL INLINE ERR ErrBFOLPAlloc( OLP **ppolp )
	{
	ERR		err = JET_errSuccess;

	EnterCriticalSection( critOLP );
	Assert( ipolpMac >= 0 && ipolpMac <= ipolpMax );
	if ( !ipolpMac )
		{
		*ppolp = NULL;
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	else
		*ppolp = rgpolp[--ipolpMac];
	LeaveCriticalSection( critOLP );

	return err;
	}


/*  deallocate an OLP
/**/
LOCAL INLINE VOID BFOLPFree( OLP *polp )
	{
	EnterCriticalSection( critOLP );
	Assert( ipolpMac >= 0 && ipolpMac < ipolpMax );
	rgpolp[ipolpMac++] = polp;
	LeaveCriticalSection( critOLP );
	}


#if defined( _X86_ ) && defined( X86_USE_SEM )

/*********************************************************
 *
 *  SEM Pool
 *
 *********************************************************/

LOCAL CRIT	critSEM		= NULL;
LOCAL LONG	isemMax	= 0;
LOCAL LONG	isemMac	= 0;
LOCAL SEM	*rgsem	= NULL;


/*  term SEM pool
/**/
LOCAL VOID BFSEMTerm( VOID )
	{
	if ( rgsem != NULL )
		{
		Assert( isemMac == isemMax );
		for ( isemMac = 0; isemMac < isemMax; isemMac++ )
			{
			UtilCloseSemaphore( rgsem[isemMac] );
			}
		LFree( rgsem );
		rgsem = NULL;
		isemMac = 0;
		}
	if ( critSEM != NULL )
		{
		DeleteCriticalSection( critSEM );
		critSEM = NULL;
		}
	}


/*  init SEM pool
/**/
LOCAL ERR ErrBFSEMInit( VOID )
	{
	ERR		err;

	/*  we need one SEM per thread => maximum number of sessions + number of jet thread
	/**/
	isemMax = rgres[iresPIB].cblockAlloc + 6;
	for ( isemMac = 1 << 5; isemMac < isemMax; isemMac <<= 1 );
	isemMax = isemMac;
	
	Call( ErrInitializeCriticalSection( &critSEM ) );
	if ( !( rgsem = LAlloc( isemMax, sizeof( SEM ) ) ) )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	for ( isemMac = 0; isemMac < isemMax; isemMac++ )
		{
		Call( ErrUtilSemaphoreCreate( &rgsem[isemMac], 0, isemMax ) );
		}

	return JET_errSuccess;
	
HandleError:
	BFSEMTerm();
	return err;
	}


/*********************************************************
 *
 *  BF Critical Section
 *
 *********************************************************/

VOID BFIEnterCriticalSection( BF *pbf )
	{
	EnterCriticalSection( critSEM );
	if ( pbf->sem == semNil )
		{
		/*	allocate one semiphore for this buffer
		/**/
		Assert( pbf->cSemWait == 0 );
		pbf->sem = rgsem[ --isemMac ];
		Assert( isemMac >= 0 );
		}
	pbf->cSemWait++;
	LeaveCriticalSection( critSEM );

	UtilSemaphoreWait( pbf->sem, INFINITE );

	/*	check if last to use it
	/**/
	EnterCriticalSection( critSEM );
	if ( pbf->cSemWait == 1 )
		{
		Assert( pbf->sem != semNil );
		rgsem[ isemMac++ ] = pbf->sem;
		pbf->sem = semNil;
		}
	pbf->cSemWait--;
	LeaveCriticalSection( critSEM );
	}


VOID BFILeaveCriticalSection( BF *pbf )
	{
	EnterCriticalSection( critSEM );
	if ( pbf->sem == semNil )
		{
		/*	allocate one semiphore for this buffer
		/**/
		pbf->sem = rgsem[ --isemMac ];
		}
	UtilSemaphoreRelease( pbf->sem, 1 );
	LeaveCriticalSection( critSEM );
	}

#else

int	ccritBF = 0;
int critBFHashConst = 0;
CRIT *rgcritBF = NULL;

LOCAL VOID BFCritTerm( VOID )
	{
	if ( rgcritBF != NULL )
		{
		int icrit;
		for ( icrit = 0; icrit < ccritBF; icrit++ )
			{
			if ( rgcritBF[icrit] )
				{
				DeleteCriticalSection( rgcritBF[icrit] );
				}
			else
				{
				break;
				}
			}
		LFree( rgcritBF );
		rgcritBF = NULL;
		ccritBF = 0;
		critBFHashConst = 0;
		}
	}

LOCAL ERR ErrBFCritInit( VOID )
	{
	ERR	err;
	int ccritBFCandidate = 1;
	int icrit;

	ccritBF = rgres[iresPIB].cblockAlloc + 6;

	forever
		{
		ccritBFCandidate <<= 1;
		if ( ccritBFCandidate > ccritBF * 2 )
			break;
		}
	ccritBF = ccritBFCandidate;
	//  NOTE:  assumes critBFCandidate is a power of two!
	critBFHashConst = ccritBFCandidate - 1;

	if ( !( rgcritBF = LAlloc( ccritBF, sizeof( CRIT ) ) ) )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	for ( icrit = 0; icrit < ccritBF; icrit++ )
		{
		rgcritBF[icrit] = NULL;
		Call( ErrInitializeCriticalSection( rgcritBF + icrit ) );
		}

	return JET_errSuccess;

HandleError:
	BFCritTerm();
	return err;
	}

#endif

/*  releases hold on a BF
/**/
LOCAL INLINE VOID BFUnhold( BF *pbf )
	{
	BFEnterCriticalSection( pbf );
	Assert( pbf->fHold );
	pbf->fHold = fFalse;
	BFLeaveCriticalSection( pbf );
	}


/*********************************************************
 *
 *  Heap functions for History heap
 *
 *********************************************************/

#ifdef DEBUG
//ULONG ulBFTimeHISTLastTop = 0;
#endif

/*
 *  History heap will try to prioritize the page reference history according to its
 *  last reference. The earlier the higher priority to be taken out.
 */
LOCAL INLINE BOOL FBFHISTGreater(BF *pbf1, BF *pbf2)
	{
	Assert( pbf1->hist.ulBFTime );
	Assert( pbf2->hist.ulBFTime );
	return pbf1->hist.ulBFTime < pbf2->hist.ulBFTime;
	}


/*  true if HIST heap is empty
/**/
LOCAL INLINE BOOL FBFHISTHeapEmpty( VOID )
	{
	AssertCriticalSection( critHIST );
	return !ipbfHISTHeapMac;
	}


/*  true if HIST heap is empty
/**/
LOCAL INLINE BOOL FBFHISTHeapFull( VOID )
	{
	AssertCriticalSection( critHIST );
	return ipbfHISTHeapMac == ipbfHISTHeapMax;
	}


/*  returns value at the top of HIST heap, but does not remove it from the heap
/**/
LOCAL INLINE BF *PbfBFHISTTopOfHeap( VOID )
	{
	AssertCriticalSection( critHIST );
	return rgpbfHISTHeap[0];
	}


/*  returns index to parent of the specified index in the HIST heap
/*  NOTE:  no range checks are performed
/**/
LOCAL INLINE LONG IpbfBFHISTParent( LONG ipbf )
	{
	AssertCriticalSection( critHIST );
	return ( ipbf - 1 ) / 2;
	}


/*  returns index to left child of the specified index in the HIST heap
/*  NOTE:  no range checks are performed
/**/
LOCAL INLINE LONG IpbfBFHISTLeftChild( LONG ipbf )
	{
	AssertCriticalSection( critHIST );
	return 2 * ipbf + 1;
	}


/*  true if BF is in the LRUK heap
/**/
LOCAL INLINE BOOL FBFInHISTHeap( BF *pbf )
	{
	AssertCriticalSection( critHIST );
	return pbf->hist.ipbfHISTHeap >= 0 && pbf->hist.ipbfHISTHeap < ipbfHISTHeapMac;
	}


/*  Updates the position of the specifed buffer in the LRUK heap.  This is usually
/*  called when one of the criteria for this buffer's weight may have been modified.
/**/
LOCAL VOID BFHISTUpdateHeap( BF *pbf )
	{
	LONG	ipbf;
	LONG	ipbfChild;
	
	AssertCriticalSection( critHIST );

	/*  get the specified buffer's position
	/**/
	Assert( !FBFHISTHeapEmpty() );
	Assert( FBFInHISTHeap( pbf ) );
	ipbf = pbf->hist.ipbfHISTHeap;
	Assert( rgpbfHISTHeap[ipbf] == pbf );
	
	/*	pbf is left alone. We do not use it in the following heap adjust code.
	 */

	/*  percolate buffer up the heap
	/**/
	while (	ipbf > 0 &&
			FBFHISTGreater( pbf, rgpbfHISTHeap[IpbfBFHISTParent( ipbf )] ) )
		{
		Assert( rgpbfHISTHeap[IpbfBFHISTParent( ipbf )]->hist.ipbfHISTHeap == IpbfBFHISTParent( ipbf ) );
		rgpbfHISTHeap[ipbf] = rgpbfHISTHeap[IpbfBFHISTParent( ipbf )];
		rgpbfHISTHeap[ipbf]->hist.ipbfHISTHeap = ipbf;
		ipbf = IpbfBFHISTParent( ipbf );
		}

	/*  percolate buffer down the heap
	/**/
	while ( ipbf < ipbfHISTHeapMac )
		{
		ipbfChild = IpbfBFHISTLeftChild( ipbf );

		/*  if we have no children, stop here
		/**/
		if ( ipbfChild >= ipbfHISTHeapMac )
			break;

		/*  set child to greater child
		/**/
		if (	ipbfChild + 1 < ipbfHISTHeapMac &&
				FBFHISTGreater( rgpbfHISTHeap[ipbfChild + 1], rgpbfHISTHeap[ipbfChild] ) )
			ipbfChild++;

		/*  if we are greater than the greatest child, stop here
		/**/
		if ( FBFHISTGreater( pbf, rgpbfHISTHeap[ipbfChild] ) )
			break;

		/*  trade places with greatest child and continue down
		/**/
		Assert( rgpbfHISTHeap[ipbfChild]->hist.ipbfHISTHeap == ipbfChild );
		rgpbfHISTHeap[ipbf] = rgpbfHISTHeap[ipbfChild];
		rgpbfHISTHeap[ipbf]->hist.ipbfHISTHeap = ipbf;
		ipbf = ipbfChild;
		}
	Assert( ipbf < ipbfHISTHeapMac );

	/*  put buffer in its designated spot
	/**/
	rgpbfHISTHeap[ipbf] = pbf;
	pbf->hist.ipbfHISTHeap = ipbf;

	Assert( FBFInHISTHeap( pbf ) );
	Assert( PbfBFISrchHashTable( pbf->hist.pn, butHistory ) == pbf );
	}


/*  Removes the specified buffer from the LRUK heap
/**/
LOCAL VOID BFHISTTakeOutOfHeap( BF *pbf )
	{
	LONG	ipbf;
	
	AssertCriticalSection( critHIST );

	/*  remove the specified history from the heap
	/**/
	Assert( !FBFHISTHeapEmpty() );
	Assert( FBFInHISTHeap( pbf ) );
	Assert( rgpbfHISTHeap[ipbfHISTHeapMac - 1]->hist.ipbfHISTHeap == ipbfHISTHeapMac - 1 );

	ipbf = pbf->hist.ipbfHISTHeap;
#ifdef DEBUG
//	if ( ipbf == 0 )
//		{
//		Assert( rgpbfHISTHeap[0]->hist.ulBFTime >= ulBFTimeHISTLastTop );
//		ulBFTimeHISTLastTop = rgpbfHISTHeap[0]->hist.ulBFTime;
//		}
#endif
	pbf->hist.ipbfHISTHeap = ipbfDangling;

	/*  if this buffer was at the end of the heap, we're done
	/**/
	if ( ipbf == ipbfHISTHeapMac - 1 )
		{
#ifdef DEBUG
		rgpbfHISTHeap[ipbfHISTHeapMac - 1] = (BF *) ULongToPtr(0xBAADF00D);
#endif
		ipbfHISTHeapMac--;
		return;
		}

	/*  copy buffer from end of heap to fill removed buffers vacancy and
	/*  adjust heap to the correct order
	/**/
	rgpbfHISTHeap[ipbf] = rgpbfHISTHeap[ipbfHISTHeapMac - 1];
	rgpbfHISTHeap[ipbf]->hist.ipbfHISTHeap = ipbf;
#ifdef DEBUG
	rgpbfHISTHeap[ipbfHISTHeapMac - 1] = (BF *) ULongToPtr(0xBAADF00D);
#endif
	ipbfHISTHeapMac--;
	BFHISTUpdateHeap( rgpbfHISTHeap[ipbf] );
	}


/*********************************************************
 *
 *  Heap functions for buffer IO heap
 *
 *********************************************************/

/*  sort IOs by ascending PN as they are requested (unpredictable)
/**/
//#define BFIO_SIMPLE
/*  sort IOs in sequential ascending fashion by PN (low=>high, low=>high, ...)
/**/
//#define BFIO_SEQA
/*  sort IOs in sequential descending fashion by PN (high=>low, high=>low, ...)
/**/
//#define BFIO_SEQD
/*  sort IOs in bucket-brigade fashion by PN (low=>high, high=>low, ...)
/**/
#define BFIO_BBG

/*  reference values for sorting the heap
/**/
PN		pnLastIO		= pnNull;
LONG	iDirIO			= 1;

/*  heap sort comparison function (choose method above)
/*
/*  NOTE:  "greater" means higher in the heap (i.e. IO performed sooner)
/**/
LOCAL INLINE BOOL FBFIOGreater( BF *pbf1, BF *pbf2 )
	{
	PN		pnL	= pnLastIO;
	LONG	iD	= iDirIO;
	PN		pn1	= pbf1->pn;
	PN		pn2	= pbf2->pn;
	BOOL	fGT;

//	Bogus assert: May go off if asynchronous write occurs while ExternalBackup.
//	Assert( pn1 != pn2 );

#if defined( BFIO_SIMPLE )
	fGT = pn1 < pn2;
#elif defined( BFIO_SEQA )
	if ( pn1 > pnL )
		{
		if ( pn2 > pnL )
			fGT = pn1 < pn2;
		else
			fGT = fTrue;
		}
	else
		{
		if ( pn2 > pnL )
			fGT = fFalse;
		else
			fGT = pn1 < pn2;
		}
#elif defined( BFIO_SEQD )
	if ( pn1 < pnL )
		{
		if ( pn2 < pnL )
			fGT = pn1 > pn2;
		else
			fGT = fTrue;
		}
	else
		{
		if ( pn2 < pnL )
			fGT = fFalse;
		else
			fGT = pn1 > pn2;
		}
#elif defined( BFIO_BBG )
	Assert( iD != 0 );
	
	if ( iD > 0 )
		{
		if ( pn1 > pnL )
			{
			if ( pn2 > pnL )
				fGT = pn1 < pn2;
			else
				fGT = fTrue;
			}
		else
			{
			if ( pn2 > pnL )
				fGT = fFalse;
			else
				fGT = pn1 > pn2;
			}
		}
	else
		{
		if ( pn1 < pnL )
			{
			if ( pn2 < pnL )
				fGT = pn1 > pn2;
			else
				fGT = fTrue;
			}
		else
			{
			if ( pn2 < pnL )
				fGT = fFalse;
			else
				fGT = pn1 < pn2;
			}
		}
#endif

	return fGT;
	}


/*  true if IO heap is empty
/**/
LOCAL INLINE BOOL FBFIOHeapEmpty( VOID )
	{
	AssertCriticalSection( critBFIO );
	return ipbfBFIOHeapMic == ipbfHeapMax;
	}


/*  returns count of BFs in IO heap
/**/
LOCAL INLINE LONG CbfBFIOHeap( VOID )
	{
	return (LONG) ( ipbfHeapMax - ipbfBFIOHeapMic );
	}


/*  returns value at the top of IO heap, but does not remove it from the heap
/**/
LOCAL INLINE BF *PbfBFIOTopOfHeap( VOID )
	{
	AssertCriticalSection( critBFIO );
	return rgpbfHeap[ipbfHeapMax - 1];
	}


/*  returns index to parent of the specified index in the IO heap
/*  NOTE:  no range checks are performed
/**/
LOCAL INLINE LONG IpbfBFIOParent( LONG ipbf )
	{
	AssertCriticalSection( critBFIO );
	return ipbfHeapMax - 1 - ( ipbfHeapMax - 1 - ipbf - 1 ) / 2;
	}


/*  returns index to left child of the specified index in the IO heap
/*  NOTE:  no range checks are performed
/**/
LOCAL INLINE LONG IpbfBFIOLeftChild( LONG ipbf )
	{
	AssertCriticalSection( critBFIO );
	return ipbfHeapMax - 1 - ( 2 * ( ipbfHeapMax - 1 - ipbf ) + 1 );
	}


/*  true if BF is in the BFIO heap
/**/
LOCAL INLINE BOOL FBFInBFIOHeap( BF *pbf )
	{
	AssertCriticalSection( critBFIO );
	return pbf->ipbfHeap >= ipbfBFIOHeapMic && pbf->ipbfHeap < ipbfHeapMax;
	}


/*  Inserts the specified buffer into the IO heap
/**/
LOCAL VOID BFIOAddToHeap( BF *pbf )
	{
	LONG	ipbf;
	
	AssertCriticalSection( critBFIO );

	Assert( pbf->prceDeferredBINext == prceNil );

	/*  new value starts at bottom of heap
	/**/
	Assert( ipbfBFIOHeapMic > ipbfLRUKHeapMac );
	Assert( (!pbf->fSyncRead && !pbf->fAsyncRead) || pbf->ulBFTime2 == 0 );
	Assert( pbf->fHold );
	Assert( pbf->ipbfHeap == ipbfDangling );
	Assert( pbf->fDirectRead || pbf->cDepend == 0 );
	ipbf = --ipbfBFIOHeapMic;

	/*  percolate new value up the heap
	/**/
	while (	ipbf < ipbfHeapMax - 1 &&
			FBFIOGreater( pbf, rgpbfHeap[IpbfBFIOParent( ipbf )] ) )
		{
		Assert( rgpbfHeap[IpbfBFIOParent( ipbf )]->ipbfHeap == IpbfBFIOParent( ipbf ) );
		rgpbfHeap[ipbf] = rgpbfHeap[IpbfBFIOParent( ipbf )];
		rgpbfHeap[ipbf]->ipbfHeap = ipbf;
		ipbf = IpbfBFIOParent( ipbf );
		}

	/*  put new value in its designated spot
	/**/
	Assert( pbf->ipbfHeap == ipbfDangling );
	rgpbfHeap[ipbf] = pbf;
	pbf->ipbfHeap = ipbf;
	BFUnhold( pbf );
	Assert( FBFInBFIOHeap( pbf ) );
	}


/*  Updates the position of the specifed buffer in the IO heap.  This is usually
/*  called when one of the criteria for this buffer's weight may have been modified.
/**/
LOCAL VOID BFIOUpdateHeap( BF *pbf )
	{
	LONG	ipbf;
	LONG	ipbfChild;
	
	AssertCriticalSection( critBFIO );

	Assert( pbf->prceDeferredBINext == prceNil );

	/*  get the specified buffer's position
	/**/
	Assert( !FBFIOHeapEmpty() );
	Assert( FBFInBFIOHeap( pbf ) );
	ipbf = pbf->ipbfHeap;
	Assert( rgpbfHeap[ipbf] == pbf );

	/*	pbf is left alone. We do not use it in the following heap adjust code.
	 */

	/*  percolate buffer up the heap
	/**/
	while (	ipbf < ipbfHeapMax - 1 &&
			FBFIOGreater( pbf, rgpbfHeap[IpbfBFIOParent( ipbf )] ) )
		{
		Assert( rgpbfHeap[IpbfBFIOParent( ipbf )]->ipbfHeap == IpbfBFIOParent( ipbf ) );
		rgpbfHeap[ipbf] = rgpbfHeap[IpbfBFIOParent( ipbf )];
		rgpbfHeap[ipbf]->ipbfHeap = ipbf;
		ipbf = IpbfBFIOParent( ipbf );
		}

	/*  percolate buffer down the heap
	/**/
	while ( ipbf >= ipbfBFIOHeapMic )
		{
		ipbfChild = IpbfBFIOLeftChild( ipbf );

		/*  if we have no children, stop here
		/**/
		if ( ipbfChild < ipbfBFIOHeapMic )
			break;

		/*  set child to greater child
		/**/
		if (	ipbfChild - 1 >= ipbfBFIOHeapMic &&
				FBFIOGreater( rgpbfHeap[ipbfChild - 1], rgpbfHeap[ipbfChild] ) )
			ipbfChild--;

		/*  if we are greater than the greatest child, stop here
		/**/
		if ( FBFIOGreater( pbf, rgpbfHeap[ipbfChild] ) )
			break;

		/*  trade places with greatest child and continue down
		/**/
		Assert( rgpbfHeap[ipbfChild]->ipbfHeap == ipbfChild );
		rgpbfHeap[ipbf] = rgpbfHeap[ipbfChild];
		rgpbfHeap[ipbf]->ipbfHeap = ipbf;
		ipbf = ipbfChild;
		}
	Assert( ipbf >= ipbfBFIOHeapMic );

	/*  put buffer in its designated spot
	/**/
	rgpbfHeap[ipbf] = pbf;
	pbf->ipbfHeap = ipbf;
	Assert( FBFInBFIOHeap( pbf ) );
	}


/*  Removes the specified buffer from the IO heap
/**/
LOCAL VOID BFIOTakeOutOfHeap( BF *pbf )
	{
	LONG	ipbf;
	
	AssertCriticalSection( critBFIO );
	Assert( pbf->fHold );

	/*  remove the specified buffer from the heap
	/**/
	Assert( !FBFIOHeapEmpty() );
	Assert( FBFInBFIOHeap( pbf ) );
	Assert( rgpbfHeap[ipbfBFIOHeapMic]->ipbfHeap == ipbfBFIOHeapMic );
	
	ipbf = pbf->ipbfHeap;
	pbf->ipbfHeap = ipbfDangling;

	/*  if this buffer was at the end of the heap, we're done
	/**/
	if ( ipbf == ipbfBFIOHeapMic )
		{
#ifdef DEBUG
		rgpbfHeap[ipbfBFIOHeapMic] = (BF *) ULongToPtr(0xBAADF00D);
#endif
		ipbfBFIOHeapMic++;
		return;
		}

	/*  copy buffer from end of heap to fill removed buffers vacancy and
	/*  adjust heap to the correct order
	/**/
	rgpbfHeap[ipbf] = rgpbfHeap[ipbfBFIOHeapMic];
	rgpbfHeap[ipbf]->ipbfHeap = ipbf;
#ifdef DEBUG
	rgpbfHeap[ipbfBFIOHeapMic] = (BF *) ULongToPtr(0xBAADF00D);
#endif
	ipbfBFIOHeapMic++;
	BFIOUpdateHeap( rgpbfHeap[ipbf] );
	}


/*  sets bit that indicates that BF is in LRUK heap or list
/**/
LOCAL INLINE VOID BFSetInLRUKBit( BF *pbf )
	{
	AssertCriticalSection( critLRUK );
	
	BFEnterCriticalSection( pbf );
	pbf->fInLRUK = fTrue;
	BFLeaveCriticalSection( pbf );
	}


/*  resets bit that indicates that BF is in LRUK heap or list
/**/
LOCAL INLINE VOID BFResetInLRUKBit( BF *pbf )
	{
	AssertCriticalSection( critLRUK );
	
	BFEnterCriticalSection( pbf );
	pbf->fInLRUK = fFalse;
	BFLeaveCriticalSection( pbf );
	}


/*********************************************************
 *
 *  Heap functions for LRU-K heap
 *
 *********************************************************/

/*
 *  LRU-K will try to prioritize the buffer according to their buffer
 *  reference intervals. The longer the higher priority to be taken out.
 *	If one of the buffer is very old, the one should have higher priority
 *	to be taken out.
 */

extern CRIT critLGBuf;
extern LGPOS lgposLogRec;

LOCAL INLINE BOOL FBFLRUKGreater(BF *pbf1, BF *pbf2)
	{
	LGPOS lgposLG;
	LGPOS lgpos1;
	LGPOS lgpos2;
	
	if ( pbf1->fVeryOld )
		{
		if ( pbf2->fVeryOld )
			{
			/*  if both BFs are very old, sort by lgposRC (checkpoint depth, oldest first)
			/**/
			Assert( !fLogDisabled );

			EnterCriticalSection( critLGBuf );
			lgposLG = lgposLogRec;
			LeaveCriticalSection( critLGBuf );

			BFEnterCriticalSection( pbf1 );
			lgpos1 = pbf1->lgposRC;
			BFLeaveCriticalSection( pbf1 );

			BFEnterCriticalSection( pbf2 );
			lgpos2 = pbf2->lgposRC;
			BFLeaveCriticalSection( pbf2 );
			
			return CbOffsetLgpos( lgposLG, lgpos1 ) > CbOffsetLgpos( lgposLG, lgpos2 );
			}
		else
			{
			return fTrue;
			}
		}
	else
		{
		if ( pbf2->fVeryOld )
			{
			return fFalse;
			}
		}

	if ( pbf1->ulBFTime2 == 0 )
		{
		if ( pbf2->ulBFTime2 == 0 )
			{
			/*	both buffers are referred once only. reduced to LRU-1 comparison.
			 */
			return pbf1->ulBFTime1 < pbf2->ulBFTime1;
			}
		else
			{
			/*	pbf1 is referred once and pbf2 is referred more than once,
			 *	pbf1 should have greater likelihood be overlayed.
			 */
			return fTrue;
			}
		}
	else
		{
		if ( pbf2->ulBFTime2 == 0 )
			{
			/*	pbf1 is referred more than once and pbf2 is referred only once,
			 *	pbf2 should have greater likelihood be overlayed.
			 */
			return fFalse;
			}
		else
			return pbf1->ulBFTime2 < pbf2->ulBFTime2;
		}
	}


/*  true if LRUK heap is empty
/**/
LOCAL INLINE BOOL FBFLRUKHeapEmpty( VOID )
	{
	AssertCriticalSection( critLRUK );
	return !ipbfLRUKHeapMac;
	}


/*  returns value at the top of LRUK heap, but does not remove it from the heap
/**/
LOCAL INLINE BF *PbfBFLRUKTopOfHeap( VOID )
	{
	AssertCriticalSection( critLRUK );
	return rgpbfHeap[0];
	}


/*  returns index to parent of the specified index in the LRUK heap
/*  NOTE:  no range checks are performed
/**/
LOCAL INLINE LONG IpbfBFLRUKParent( LONG ipbf )
	{
	AssertCriticalSection( critLRUK );
	return ( ipbf - 1 ) / 2;
	}


/*  returns index to left child of the specified index in the LRUK heap
/*  NOTE:  no range checks are performed
/**/
LOCAL INLINE LONG IpbfBFLRUKLeftChild( LONG ipbf )
	{
	AssertCriticalSection( critLRUK );
	return 2 * ipbf + 1;
	}


/*  true if BF is in the LRUK heap
/**/
LOCAL INLINE BOOL FBFInLRUKHeap( BF *pbf )
	{
	AssertCriticalSection( critLRUK );
	return pbf->ipbfHeap >= 0 && pbf->ipbfHeap < ipbfLRUKHeapMac;
	}


/*  Inserts the specified buffer into the IO heap
/**/
LOCAL VOID BFLRUKAddToHeap( BF *pbf )
	{
	LONG	ipbf;
	
	AssertCriticalSection( critLRUK );

	/*  new value starts at bottom of heap
	/**/
	Assert( ipbfLRUKHeapMac < ipbfBFIOHeapMic );
	Assert( pbf->fHold );
	Assert( pbf->ipbfHeap == ipbfDangling );
	ipbf = ipbfLRUKHeapMac++;

	/*  percolate new value up the heap
	/**/
	while (	ipbf > 0 &&
			FBFLRUKGreater( pbf, rgpbfHeap[IpbfBFLRUKParent( ipbf )] ) )
		{
		Assert( rgpbfHeap[IpbfBFLRUKParent( ipbf )]->ipbfHeap == IpbfBFLRUKParent( ipbf ) );
		rgpbfHeap[ipbf] = rgpbfHeap[IpbfBFLRUKParent( ipbf )];
		rgpbfHeap[ipbf]->ipbfHeap = ipbf;
		ipbf = IpbfBFLRUKParent( ipbf );
		}

	/*  put new value in its designated spot
	/**/
	Assert( pbf->ipbfHeap == ipbfDangling );
	rgpbfHeap[ipbf] = pbf;
	pbf->ipbfHeap = ipbf;
	Assert( FBFInLRUKHeap( pbf ) );
	BFSetInLRUKBit( pbf );
	BFUnhold( pbf );
	}


/*  Updates the position of the specifed buffer in the LRUK heap.  This is usually
/*  called when one of the criteria for this buffer's weight may have been modified.
/**/
LOCAL VOID BFLRUKUpdateHeap( BF *pbf )
	{
	LONG	ipbf;
	LONG	ipbfChild;
	
	AssertCriticalSection( critLRUK );
	
	Assert( pbf->pn != 0 );
	Assert( pbf->fInHash );

	/*  get the specified buffer's position
	/**/
	Assert( !FBFLRUKHeapEmpty() );
	Assert( FBFInLRUKHeap( pbf ) );
	ipbf = pbf->ipbfHeap;
	Assert( rgpbfHeap[ipbf] == pbf );
	
	/*	pbf is left alone. We do not use it in the following heap adjust code.
	 */

	/*  percolate buffer up the heap
	/**/
	while (	ipbf > 0 &&
			FBFLRUKGreater( pbf, rgpbfHeap[IpbfBFLRUKParent( ipbf )] ) )
		{
		Assert( rgpbfHeap[IpbfBFLRUKParent( ipbf )]->ipbfHeap == IpbfBFLRUKParent( ipbf ) );
		rgpbfHeap[ipbf] = rgpbfHeap[IpbfBFLRUKParent( ipbf )];
		rgpbfHeap[ipbf]->ipbfHeap = ipbf;
		ipbf = IpbfBFLRUKParent( ipbf );
		}

	/*  percolate buffer down the heap
	/**/
	while ( ipbf < ipbfLRUKHeapMac )
		{
		ipbfChild = IpbfBFLRUKLeftChild( ipbf );

		/*  if we have no children, stop here
		/**/
		if ( ipbfChild >= ipbfLRUKHeapMac )
			break;

		/*  set child to greater child
		/**/
		if (	ipbfChild + 1 < ipbfLRUKHeapMac &&
				FBFLRUKGreater( rgpbfHeap[ipbfChild + 1], rgpbfHeap[ipbfChild] ) )
			ipbfChild++;

		/*  if we are greater than the greatest child, stop here
		/**/
		if ( FBFLRUKGreater( pbf, rgpbfHeap[ipbfChild] ) )
			break;

		/*  trade places with greatest child and continue down
		/**/
		Assert( rgpbfHeap[ipbfChild]->ipbfHeap == ipbfChild );
		rgpbfHeap[ipbf] = rgpbfHeap[ipbfChild];
		rgpbfHeap[ipbf]->ipbfHeap = ipbf;
		ipbf = ipbfChild;
		}
	Assert( ipbf < ipbfLRUKHeapMac );

	/*  put buffer in its designated spot
	/**/
	rgpbfHeap[ipbf] = pbf;
	pbf->ipbfHeap = ipbf;
	Assert( FBFInLRUKHeap( pbf ) );
	}


/*  Removes the specified buffer from the LRUK heap
/**/
LOCAL VOID BFLRUKTakeOutOfHeap( BF *pbf )
	{
	LONG	ipbf;
	
	AssertCriticalSection( critJet );
	AssertCriticalSection( critLRUK );
	Assert( pbf->fHold );

	Assert( pbf->pn != 0 );
	Assert( pbf->fInHash );

	/*  remove the specified buffer from the heap
	/**/
	Assert( !FBFLRUKHeapEmpty() );
	Assert( FBFInLRUKHeap( pbf ) );
	Assert( rgpbfHeap[ipbfLRUKHeapMac - 1]->ipbfHeap == ipbfLRUKHeapMac - 1 );

	ipbf = pbf->ipbfHeap;
	pbf->ipbfHeap = ipbfDangling;

	/*  if this buffer was at the end of the heap, we're done
	/**/
	if ( ipbf == ipbfLRUKHeapMac - 1 )
		{
#ifdef DEBUG
		rgpbfHeap[ipbfLRUKHeapMac - 1] = (BF *) ULongToPtr(0xBAADF00D);
#endif
		ipbfLRUKHeapMac--;
		BFResetInLRUKBit( pbf );
		return;
		}

	/*  copy buffer from end of heap to fill removed buffers vacancy and
	/*  adjust heap to the correct order
	/**/
	rgpbfHeap[ipbf] = rgpbfHeap[ipbfLRUKHeapMac - 1];
	rgpbfHeap[ipbf]->ipbfHeap = ipbf;
#ifdef DEBUG
	rgpbfHeap[ipbfLRUKHeapMac - 1] = (BF *) ULongToPtr(0xBAADF00D);
#endif
	ipbfLRUKHeapMac--;
	BFLRUKUpdateHeap( rgpbfHeap[ipbf] );
	BFResetInLRUKBit( pbf );
	}


/*********************************************************
 *
 *  Functions for Avail list
 *
 *********************************************************/

#if 0
//#ifdef DEBUG

LOCAL VOID CheckLRU( LRULIST *plrulist )
	{
	BF		*pbfLRU = plrulist->pbfLRU;
	BF		*pbfMRU = plrulist->pbfMRU;
	BF		*pbfT;
	INT		cbfAvailMRU = 0;
	INT		cbfAvailLRU = 0;
			

	Assert( ( pbfMRU == pbfNil && pbfLRU == pbfNil ) ||
		( pbfMRU != pbfNil && pbfLRU != pbfNil ) );

	Assert( pbfMRU == pbfNil || pbfMRU->pbfLRU == pbfNil );
	Assert( pbfMRU == pbfNil || pbfMRU->pbfMRU == pbfNil ||
		( pbfMRU->pbfMRU->pbfLRU == pbfMRU ) );
	
	Assert( pbfLRU == pbfNil || pbfLRU->pbfMRU == pbfNil );
	Assert( pbfLRU == pbfNil || pbfLRU->pbfLRU == pbfNil ||
		( pbfLRU->pbfLRU->pbfMRU == pbfLRU ) );

	for ( pbfT = plrulist->pbfMRU; pbfT != pbfNil; pbfT = pbfT->pbfMRU )
		{
		Assert( pbfT->pn == 0 || pbfT->fInHash );

		Assert( pbfT->pbfMRU == pbfNil || pbfT->pbfMRU->pbfLRU == pbfT );
		if (plrulist == &lrulistLRUK)
			Assert( pbfT->ipbfHeap == ipbfInLRUKList );
		else
			Assert( pbfT->ipbfHeap == ipbfInAvailList );
		cbfAvailMRU++;
		}
	for ( pbfT = plrulist->pbfLRU; pbfT != pbfNil; pbfT = pbfT->pbfLRU )
		{
		Assert( pbfT->pbfLRU == pbfNil || pbfT->pbfLRU->pbfMRU == pbfT );
		if (plrulist == &lrulistLRUK)
			Assert( pbfT->ipbfHeap == ipbfInLRUKList );
		else
			Assert( pbfT->ipbfHeap == ipbfInAvailList );
		cbfAvailLRU++;
		}
	Assert( cbfAvailMRU == cbfAvailLRU );
	Assert( cbfAvailMRU == plrulist->cbfAvail );
	}
#else

#define	CheckLRU( pbgcb )

#endif


/*	Insert into LRU list at MRU End
/**/
INLINE LOCAL VOID BFAddToListAtMRUEnd( BF *pbf, LRULIST *plrulist )
	{
	BF	*pbfT;
	
#ifdef DEBUG
	Assert( pbf->fHold );
	Assert( pbf->ipbfHeap == ipbfDangling );
	Assert( pbf->pn != 0 );
	Assert( pbf->fInHash );
	if (plrulist == &lrulistLRUK)
		AssertCriticalSection( critLRUK );
	else
		{
		AssertCriticalSection( critAvail );
		Assert( !pbf->fDirty );
		Assert( !pbf->fVeryOld );
		Assert( !pbf->cPin );
		}
#endif
		
	Assert( pbf != pbfNil );

	CheckLRU( plrulist );

	/*	set pbfT to first buffer with smaller current weight from MRU end
	/**/
	pbfT = plrulist->pbfMRU;

	if ( pbfT != pbfNil )
		{
		/*	insert before pbfT
		/**/
		Assert(pbfT->pbfLRU == pbfNil);
		pbfT->pbfLRU = pbf;
		pbf->pbfMRU = pbfT;
		pbf->pbfLRU = pbfNil;
		plrulist->pbfMRU = pbf;
		}
	else
		{
		pbf->pbfMRU = pbfNil;
		pbf->pbfLRU = pbfNil;
		plrulist->pbfMRU = pbf;
		plrulist->pbfLRU = pbf;
		}

	if (plrulist == &lrulistLRUK)
		{
		pbf->ipbfHeap = ipbfInLRUKList;
		BFSetInLRUKBit( pbf );
		}
	else
		{
		pbf->ipbfHeap = ipbfInAvailList;
#ifdef COSTLY_PERF
		cBFAvail[pbf->lClass]++;
#else  //  !COSTLY_PERF
		cBFAvail++;
#endif  //  COSTLY_PERF
		}

	BFUnhold( pbf );
	plrulist->cbfAvail++;

	CheckLRU( plrulist );
	}

INLINE LOCAL VOID BFAddToListAtLRUEnd( BF *pbf, LRULIST *plrulist )
	{
	BF	*pbfT;
	
#ifdef DEBUG
	Assert( pbf->fHold );
	Assert( pbf->ipbfHeap == ipbfDangling );
	if (plrulist == &lrulistLRUK)
		{
		AssertCriticalSection( critLRUK );
		Assert( pbf->pn );
		Assert( pbf->fInHash );
		}
	else
		{
		AssertCriticalSection( critAvail );
		Assert( pbf->pn == 0 || pbf->fInHash );
		Assert( !pbf->fDirty );
		Assert( !pbf->fVeryOld );
		Assert( !pbf->cPin );
		}
#endif

	Assert( pbf != pbfNil );

	CheckLRU( plrulist );

	/*	add pbf to LRU end of LRU queue
	/**/
	pbfT = plrulist->pbfLRU;
	if ( pbfT != pbfNil )
		{
		Assert(pbfT->pbfMRU == pbfNil);
		pbfT->pbfMRU = pbf;
		pbf->pbfLRU = pbfT;
		pbf->pbfMRU = pbfNil;
		plrulist->pbfLRU = pbf;
		}
	else
		{
		pbf->pbfMRU = pbfNil;
		pbf->pbfLRU = pbfNil;
		plrulist->pbfMRU = pbf;
		plrulist->pbfLRU = pbf;
		}

	if (plrulist == &lrulistLRUK)
		{
		pbf->ipbfHeap = ipbfInLRUKList;
		BFSetInLRUKBit( pbf );
		}
	else
		{
		pbf->ipbfHeap = ipbfInAvailList;
#ifdef COSTLY_PERF
		cBFAvail[pbf->lClass]++;
#else  //  !COSTLY_PERF
		cBFAvail++;
#endif  //  COSTLY_PERF
		}

	BFUnhold( pbf );
	plrulist->cbfAvail++;

	CheckLRU( plrulist );
	}


INLINE LOCAL VOID BFTakeOutOfList( BF *pbf, LRULIST *plrulist )
	{
#ifdef DEBUG
	if (plrulist == &lrulistLRUK)
		{
		AssertCriticalSection( critLRUK );
		Assert( pbf->ipbfHeap == ipbfInLRUKList );
		Assert( pbf->pn );
		Assert( pbf->fInHash );
		}
	else
		{
		AssertCriticalSection( critAvail );
		Assert( pbf->pn == 0 || pbf->fInHash );
		Assert( pbf->ipbfHeap == ipbfInAvailList );
		Assert( !pbf->fDirty );
		}
#endif
	
	Assert( pbf->fHold );
	Assert( pbf != pbfNil );

	CheckLRU( plrulist );
	
	if ( pbf->pbfMRU != pbfNil )
		{
		pbf->pbfMRU->pbfLRU = pbf->pbfLRU;
		if (plrulist->pbfMRU == pbf)
			plrulist->pbfMRU = pbf->pbfMRU;
		}
	else
		{
		Assert( plrulist->pbfLRU == pbf );
		plrulist->pbfLRU = pbf->pbfLRU;
		}
	
	if ( pbf->pbfLRU != pbfNil )
		{
		pbf->pbfLRU->pbfMRU = pbf->pbfMRU;
		if (plrulist->pbfLRU == pbf)
			plrulist->pbfLRU = pbf->pbfLRU;
		}
	else
		{
		Assert( plrulist->pbfMRU == pbf || pbf->pbfMRU );
		plrulist->pbfMRU = pbf->pbfMRU;
		}
	
	--plrulist->cbfAvail;

	if ( pbf->ipbfHeap == ipbfInLRUKList )
		{
		BFResetInLRUKBit( pbf );
		}
	else
		{
#ifdef COSTLY_PERF
		cBFAvail[pbf->lClass]--;
#else  //  !COSTLY_PERF
		cBFAvail--;
#endif  //  COSTLY_PERF
		}
	pbf->ipbfHeap = ipbfDangling;
	
	CheckLRU( plrulist );
	}


#ifdef DEBUG

VOID BFSetDirtyBit( BF *pbf )
	{
	BFEnterCriticalSection( pbf );
	
	Assert( pbf != pbfNil );
	Assert( pbf->fSyncRead == fFalse );
	Assert( pbf->fAsyncRead == fFalse );
	Assert( pbf->fSyncWrite == fFalse );
	Assert( pbf->fAsyncWrite == fFalse );
	
	Assert( pbf->fInLRUK || pbf->ipbfHeap == ipbfDangling );

	Assert( !FDBIDReadOnly( DbidOfPn( pbf->pn ) ) );
	Assert( !FDBIDFlush( DbidOfPn( pbf->pn ) ) );

	Assert( fLogDisabled || fRecovering || !FDBIDLogOn(DbidOfPn( pbf->pn )) ||
			CmpLgpos( &pbf->lgposRC, &lgposMax ) != 0 );

	if ( !fRecovering &&
		QwPMDBTime( pbf->ppage ) > QwDBHDRDBTime( rgfmp[ DbidOfPn(pbf->pn) ].pdbfilehdr ) )
		{
		DBHDRSetDBTime( rgfmp[ DbidOfPn(pbf->pn) ].pdbfilehdr, QwPMDBTime( pbf->ppage ) );
		}
 		
	if ( DbidOfPn(pbf->pn) != dbidTemp )
		{
		CheckPgno( pbf->ppage, pbf->pn );
		}

	if ( !pbf->fDirty )
		{
#ifdef COSTLY_PERF
		cBFClean[pbf->lClass]--;
		cBFNewDirties[pbf->lClass]++;
#else  //  !COSTLY_PERF
		cBFClean--;
		cBFNewDirties++;
#endif  //  COSTLY_PERF
		}

	pbf->fDirty = fTrue;

	BFLeaveCriticalSection( pbf );
	}

#endif

LOCAL INLINE BOOL FBFIRangeLocked( FMP *pfmp, PGNO pgno )
	{
	RANGELOCK *prangelock;

	prangelock = pfmp->prangelock;
	while ( prangelock )
		{
		if ( prangelock->pgnoStart <= pgno && pgno <= prangelock->pgnoEnd )
			{
			return fTrue;
			}
		prangelock = prangelock->prangelockNext;
		}
	return fFalse;
	}

LOCAL INLINE BOOL FBFRangeLocked( FMP *pfmp, PGNO pgno )
	{
	BOOL f;

	EnterCriticalSection( pfmp->critCheckPatch );
	f = FBFIRangeLocked( pfmp, pgno );
	LeaveCriticalSection( pfmp->critCheckPatch );
	return f;
	}

/*  sets the AsyncRead bit of a BF
/**/
LOCAL INLINE VOID BFSetAsyncReadBit( BF *pbf )
	{
	BFEnterCriticalSection( pbf );
	
	Assert( pbf->fHold );
	Assert( !pbf->fAsyncRead );
	Assert( !pbf->fSyncRead );
	Assert( !pbf->fAsyncWrite );
	Assert( !pbf->fSyncWrite );
	
	pbf->fAsyncRead = fTrue;
	
	BFLeaveCriticalSection( pbf );
	}

/*  resets the AsyncRead bit of a BF, optionally holding the BF
/**/
LOCAL INLINE VOID BFResetAsyncReadBit( BF *pbf )
	{
	BFEnterCriticalSection( pbf );
	
	Assert( pbf->fHold );
	Assert( pbf->fAsyncRead );
	Assert( !pbf->fSyncRead );
	Assert( !pbf->fAsyncWrite );
	Assert( !pbf->fSyncWrite );
	
	pbf->fAsyncRead = fFalse;

	/*  if someone is waiting on this BF, signal them
	/**/
	if ( pbf->sigIOComplete != sigNil )
		SignalSend( pbf->sigIOComplete );
	
	BFLeaveCriticalSection( pbf );
	}


/*  sets the Read bit of a BF
/**/
LOCAL INLINE VOID BFSetSyncReadBit( BF *pbf )
	{
	BFEnterCriticalSection( pbf );
	
	Assert( pbf->fHold );
	Assert( !pbf->fAsyncRead );
	Assert( !pbf->fSyncRead );
	Assert( !pbf->fAsyncWrite );
	Assert( !pbf->fSyncWrite );
	Assert( pbf->ipbfHeap == ipbfDangling );
	
	pbf->fSyncRead = fTrue;
	
	BFLeaveCriticalSection( pbf );
	}


/*  resets the Read bit of a BF, optionally holding the BF
/**/
LOCAL INLINE VOID BFResetSyncReadBit( BF *pbf )
	{
	BFEnterCriticalSection( pbf );
	
	Assert( pbf->fHold );
	Assert( !pbf->fAsyncRead );
	Assert( pbf->fSyncRead );
	Assert( !pbf->fAsyncWrite );
	Assert( !pbf->fSyncWrite );
	
	pbf->fSyncRead = fFalse;
	
	/*  if someone is waiting on this BF, signal them
	/**/
	if ( pbf->sigIOComplete != sigNil )
		SignalSend( pbf->sigIOComplete );
	
	BFLeaveCriticalSection( pbf );
	}


/*  sets the AsyncWrite bit of a BF
/**/
LOCAL INLINE VOID BFSetAsyncWriteBit( BF *pbf )
	{
	DBID dbid = DbidOfPn( pbf->pn );
	FMP *pfmp = &rgfmp[dbid];
	PGNO pgno = PgnoOfPn( pbf->pn );

	AssertCriticalSection(critBFIO);

	BFEnterCriticalSection( pbf );
	
	Assert( pbf->fHold );
	Assert( !pbf->fAsyncRead );
	Assert( !pbf->fSyncRead );
	Assert( !pbf->fAsyncWrite );
	Assert( !pbf->fSyncWrite );
	Assert( !FDBIDReadOnly(DbidOfPn( pbf->pn ) ) );
//	Assert( !FBFRangeLocked( pfmp, pgno ) );

	pbf->fAsyncWrite = fTrue;
	
	BFLeaveCriticalSection( pbf );
	}


/*  resets the AsyncWrite bit of a BF, optionally holding the BF
/**/
LOCAL INLINE VOID BFResetAsyncWriteBit( BF *pbf )
	{
	BFEnterCriticalSection( pbf );
	
	Assert( pbf->fHold );
	Assert( !pbf->fAsyncRead );
	Assert( !pbf->fSyncRead );
	Assert( pbf->fAsyncWrite );
	Assert( !pbf->fSyncWrite );
	
	pbf->fAsyncWrite = fFalse;
	
	/*  if someone is waiting on this BF, signal them
	/**/
	if ( pbf->sigIOComplete != sigNil )
		SignalSend( pbf->sigIOComplete );
	
	BFLeaveCriticalSection( pbf );
	}


/*  sets the SyncWrite bit of a BF
/**/
LOCAL INLINE VOID BFSetSyncWriteBit( BF *pbf )
	{
	DBID dbid = DbidOfPn( pbf->pn );
	FMP *pfmp = &rgfmp[dbid];
	PGNO pgno = PgnoOfPn( pbf->pn );

	Assert( pbf->fHold );
	Assert( !pbf->fAsyncRead );
	Assert( !pbf->fSyncRead );
	Assert( !pbf->fAsyncWrite );
	Assert( !pbf->fSyncWrite );
	Assert( !FDBIDReadOnly(DbidOfPn( pbf->pn ) ) );
	
	forever
		{
		/*	if backup is copying the page, then wait till copy is done.
		 */
		EnterCriticalSection( pfmp->critCheckPatch );
		if ( FBFIRangeLocked( pfmp, pgno ) )
			{
			LeaveCriticalSection( pfmp->critCheckPatch );
			BFSleep( cmsecWaitIOComplete );
			}
		else
			{
			BFEnterCriticalSection( pbf );
			pbf->fSyncWrite = fTrue;
			BFLeaveCriticalSection( pbf );

			LeaveCriticalSection( pfmp->critCheckPatch );
			break;
			}
		}
	}


/*  resets the SyncWrite bit of a BF, optionally holding the BF
/**/
LOCAL INLINE VOID BFResetSyncWriteBit( BF *pbf )
	{
	BFEnterCriticalSection( pbf );
	
	Assert( pbf->fHold );
	Assert( !pbf->fAsyncRead );
	Assert( !pbf->fSyncRead );
	Assert( !pbf->fAsyncWrite );
	Assert( pbf->fSyncWrite );
	
	pbf->fSyncWrite = fFalse;
	
	/*  if someone is waiting on this BF, signal them
	/**/
	if ( pbf->sigIOComplete != sigNil )
		SignalSend( pbf->sigIOComplete );
	
	BFLeaveCriticalSection( pbf );
	}


/*  sets IO error condition for a BF
/**/
LOCAL INLINE VOID BFSetIOError( BF *pbf, ERR err )
	{
	Assert( err < 0 );

	BFEnterCriticalSection( pbf );
	pbf->fIOError = fTrue;
	pbf->err = ErrERRCheck( err );
	BFLeaveCriticalSection( pbf );
	}


/*  resets IO error condition for a BF
/**/
LOCAL INLINE VOID BFResetIOError( BF *pbf )
	{
	BFEnterCriticalSection( pbf );
	pbf->fIOError = fFalse;
	pbf->err = JET_errSuccess;
	BFLeaveCriticalSection( pbf );
	}


/*  sets very old condition for a BF (but only if its dirty!)
/**/
LOCAL INLINE VOID BFSetVeryOldBit( BF *pbf )
	{
	if ( pbf->fVeryOld )
		return;

	BFEnterCriticalSection( pbf );
	pbf->fVeryOld = pbf->fDirty;
	BFLeaveCriticalSection( pbf );
	}

	
/*  resets very old condition for a BF
/**/
LOCAL INLINE VOID BFResetVeryOldBit( BF *pbf )
	{
	if ( !pbf->fVeryOld )
		return;

	BFEnterCriticalSection( pbf );
	pbf->fVeryOld = fFalse;
	BFLeaveCriticalSection( pbf );
	}


/*  determines if the given BF is considered Very Old
/**/
extern CRIT critLGBuf;
extern LGPOS lgposLogRec;

LOCAL INLINE BOOL FBFIsVeryOld( BF *pbf )
	{
	BOOL	fVeryOld;
	LGPOS	lgpos;
	
	/*	if logging/recovery disabled, then no checkpoint and no
	/*	enforcement of buffer aging for checkpoint advancement.
	/**/
	if ( fLogDisabled )
		return fFalse;

	AssertCriticalSection( critJet );
	
	/*  if the cached flag is set, we are old
	/**/
	if ( pbf->fVeryOld )
		return fTrue;

	/*  this BF is old if we are holding up the checkpoint
	/**/
	EnterCriticalSection( critLGBuf );
	lgpos = lgposLogRec;
	LeaveCriticalSection( critLGBuf );
	
	BFEnterCriticalSection( pbf );
	fVeryOld =	FDBIDLogOn(DbidOfPn( pbf->pn )) &&
				!fRecovering &&
				pbf->fDirty &&
				CbOffsetLgpos( lgpos, pbf->lgposRC ) >= (QWORD) ( lBufGenAge * lLogFileSize * 1024 );
	BFLeaveCriticalSection( pbf );
				
	return fVeryOld;
	}

	
/*  If ppib is Nil, then we check if the buffer is free (cPin == 0 and
/*  no IO is going on. If ppib is not Nil, we check if the buffer is
/*  accessible. I.e. No IO is going on, but the buffer may be latched
/*  by the ppib and is accessible by this ppib.
/**/
BOOL FBFHold( PIB *ppib, BF *pbf )
	{
	/*	Make sure we have a read latch (critJet to prevent others to read) on
	 *	this buffer before we upgrade it.
	 */
	AssertCriticalSection( critJet );

	BFEnterCriticalSection( pbf );
	if ( FBFInUse( ppib, pbf ) )
		{
		BFLeaveCriticalSection( pbf );
		return fFalse;
		}
	else
		{
		pbf->fHold = fTrue;
		BFLeaveCriticalSection( pbf );
		}

	EnterCriticalSection( critLRUK );
	if ( pbf->fInLRUK )
		{
		if ( pbf->ipbfHeap == ipbfInLRUKList )
			BFTakeOutOfList( pbf, &lrulistLRUK );
		else
			BFLRUKTakeOutOfHeap( pbf );
		LeaveCriticalSection(critLRUK);
		return fTrue;
		}
	LeaveCriticalSection(critLRUK);
	
	EnterCriticalSection( critAvail );
	if ( pbf->ipbfHeap == ipbfInAvailList )
		{
		BFTakeOutOfList( pbf, &pbgcb->lrulist );
		LeaveCriticalSection(critAvail);
		return fTrue;
		}
	LeaveCriticalSection( critAvail );
	
	EnterCriticalSection(critBFIO);
	if ( FBFInBFIOHeap( pbf ) )
		{
		/*	if the buffer is very old, do not take it out. Let
		 *	write thread finish it!
		 */
		if ( pbf->fVeryOld )
			{
			BFUnhold( pbf );
			LeaveCriticalSection(critBFIO);
			return fFalse;
			}
		else
			{
			BFIOTakeOutOfHeap( pbf );
			LeaveCriticalSection(critBFIO);
			return fTrue;
			}
		}
	LeaveCriticalSection(critBFIO);

	return fFalse;	
	}

BOOL FBFHoldByMe( PIB *ppib, BF *pbf )
	{
	/*	Make sure we have a read latch (critJet to prevent others to read) on
	 *	this buffer before we upgrade it.
	 */
	AssertCriticalSection( critJet );

	BFEnterCriticalSection( pbf );
	if ( FBFInUseByOthers( ppib, pbf ) )
		{
		BFLeaveCriticalSection( pbf );
		return fFalse;
		}
	else
		{
		pbf->fHold = fTrue;
		BFLeaveCriticalSection( pbf );
		}

	EnterCriticalSection( critLRUK );
	if ( pbf->fInLRUK )
		{
		if ( pbf->ipbfHeap == ipbfInLRUKList )
			BFTakeOutOfList( pbf, &lrulistLRUK );
		else
			BFLRUKTakeOutOfHeap( pbf );
		LeaveCriticalSection(critLRUK);
		return fTrue;
		}
	LeaveCriticalSection(critLRUK);
	
	EnterCriticalSection( critAvail );
	if ( pbf->ipbfHeap == ipbfInAvailList )
		{
		BFTakeOutOfList( pbf, &pbgcb->lrulist );
		LeaveCriticalSection(critAvail);
		return fTrue;
		}
	LeaveCriticalSection( critAvail );
	
	EnterCriticalSection(critBFIO);
	if ( FBFInBFIOHeap( pbf ) )
		{
		/*	if the buffer is very old, do not take it out. Let
		 *	write thread finish it!
		 */
		if ( pbf->fVeryOld )
			{
			BFUnhold( pbf );
			LeaveCriticalSection(critBFIO);
			return fFalse;
			}
		else
			{
			BFIOTakeOutOfHeap( pbf );
			LeaveCriticalSection(critBFIO);
			return fTrue;
			}
		}
	LeaveCriticalSection(critBFIO);

	return fFalse;	
	}

/*  waits to get a hold of a BF using the given hold function
/**/

typedef BOOL BF_HOLD_FN( PIB *ppib, BF *pbf );

LOCAL ERR ErrBFIHold( PIB *ppib, PN pn, BF *pbf, BF_HOLD_FN *pbhfn )
	{
	ERR		err = JET_errSuccess;
	BOOL	fWaitOnIO;
	BOOL	fFreeSig;

	/*  wait forever until we can hold this BF
	/**/
	forever
		{
		AssertCriticalSection( critJet );

		/* check if not being read/written
		/**/
		if ( pbhfn( ppib, pbf ) )
			{
			Assert( pbf->fHold == fTrue );
			break;
			}

		/*  if the BF is held for IO, prepare to wait until complete
		/**/
		BFEnterCriticalSection( pbf );
		if ( pbf->fAsyncRead || pbf->fSyncRead || pbf->fAsyncWrite || pbf->fSyncWrite )
			{
			/*  allocate IO completion signal, if one doesn't already exist
			/**/
			if ( pbf->sigIOComplete == sigNil )
				{
				CallS( ErrBFSIGAlloc( &pbf->sigIOComplete ) );
				SignalReset( pbf->sigIOComplete );
				fFreeSig = fTrue;
				}
			else
				fFreeSig = fFalse;

			fWaitOnIO = fTrue;
			err = wrnBFCacheMiss;
			}
		else
			fWaitOnIO = fFalse;
		BFLeaveCriticalSection( pbf );

		/*  if we are waiting on IO, signal IO thread and wait until the
		/*  IO operation on this BF is complete
		/**/
		if ( fWaitOnIO )
			{
			/*  Wait for IO to complete.  If someone else allocated the signal,
			/*  we may end up trying to wait on a NULL signal.  Since this can
			/*  only mean the IO has already completed, we will pretend we
			/*  waited successfully.
			/**/
			LgLeaveCriticalSection( critJet );
			SignalSend( sigBFIOProc );
			SignalWait( pbf->sigIOComplete, INFINITE );
			LgEnterCriticalSection( critJet );

			/*  free signal if we allocated it
			/**/
			if ( fFreeSig )
				{
				BFEnterCriticalSection( pbf );
				Assert( pbf->sigIOComplete != sigNil );
				BFSIGFree( pbf->sigIOComplete );
				pbf->sigIOComplete = sigNil;
				BFLeaveCriticalSection( pbf );
				}
			}

		/*  if we are not waiting on IO, sleep to see if BF state changes
		 *	Note that we have the check the page number again since we
		 *	are not holding the buffer yet!
		/**/
		else
			{
			BOOL fStolen = fFalse;
			BFSleep( 1 );
			BFEnterCriticalSection( pbf );
			fStolen = ( pbf->pn != pn );
			BFLeaveCriticalSection( pbf );
			if ( fStolen )
				return wrnBFNotSynchronous;
			}
		}

	/*  by the time we get a hold of it, it may be cleaned or stolen
	/**/
	Assert( pbf->fHold );
	if ( pbf->pn != pn )
		{
		/*  buffer was stolen
		/**/
		if ( pbf->pn != pnNull )
			{
			/*  return stolen buffer to LRUK heap
			/**/
			EnterCriticalSection( critLRUK );
			BFLRUKAddToHeap( pbf );
			LeaveCriticalSection( critLRUK );
			}

		/*  buffer was cleaned
		/**/
		else
			{
			/*  if the BF is pinned, send back to LRUK heap, otherwise
			/*  put the cleaned BF in the avail list
			/**/
			if ( pbf->cPin )
				{
				EnterCriticalSection( critLRUK );
				BFLRUKAddToHeap( pbf );
				LeaveCriticalSection( critLRUK );
				}
			else
				{
				EnterCriticalSection( critAvail );
				BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
				LeaveCriticalSection( critAvail );
				}
			}
		err = wrnBFNotSynchronous;
		}

	return err;
	}

	
/*  waits to get a hold on a BF
/**/
LOCAL INLINE ERR ErrBFHold( PIB *ppib, PN pn, BF *pbf )
	{
	return ErrBFIHold( ppib, pn, pbf, FBFHold );
	}

	
LOCAL INLINE ERR ErrBFHoldByMe( PIB *ppib, PN pn, BF *pbf )
	{
	return ErrBFIHold( ppib, pn, pbf, FBFHoldByMe );
	}


/*  kills all buffer threads
/**/
LOCAL VOID BFKillThreads( VOID )
	{
	/*  terminate BFCleanProcess.
	/*  Set termination flag, signal process
	/*  and busy wait for thread termination code.
	/**/
	if ( handleBFCleanProcess != 0 )
		{
		fBFCleanProcessTerm = fTrue;
		LgLeaveCriticalSection(critJet);
		UtilEndThread( handleBFCleanProcess, sigBFCleanProc );
		LgEnterCriticalSection(critJet);
		CallS( ErrUtilCloseHandle( handleBFCleanProcess ) );
		handleBFCleanProcess = 0;
		SignalClose(sigBFCleanProc);
		}
		
	if ( handleBFIOProcess != 0 )
		{
		fBFIOProcessTerm = fTrue;
		LgLeaveCriticalSection(critJet);
		UtilEndThread( handleBFIOProcess, sigBFIOProc );
		LgEnterCriticalSection(critJet);
		CallS( ErrUtilCloseHandle( handleBFIOProcess ) );
		handleBFIOProcess = 0;
		SignalClose(sigBFIOProc);
		}
	}


/*
 *  Allocates and initializes buffer management data structures, including
 *  one buffer group (BGCB) with cbfInit pages and buffer control
 *  blocks (BF).  Currently only one BGCB is ever used by the buffer manager.
 *  RETURNS     JET_errSuccess, JET_OutOfMemory
 *
 *  COMMENTS
 *         Most of the current BUF code assumes there is EXACTLY ONE BGCB.
 *         This can be changed later if a use for multiple buffer groups is
 *         seen.
 */
ERR ErrBFInit( VOID )
	{
	ERR     err;
	BF      *rgbf = NULL;
	BF      *pbf;
	PAGE	*rgpage = NULL;
	int     ibf;
	int     cbfInit = rgres[iresBF].cblockAlloc;
	int		ihe;

	Assert( pbfNil == 0 );
	Assert( cbfInit > 0 );

	/* initialize buffer hash table
	/**/
//	memset( (BYTE *)rgheHash, -1, sizeof(rgheHash));
	for ( ihe = 0; ihe < ipbfMax; ihe++ )
		rgheHash[ ihe ].ibfHashNext = ibfNotUsed;

//	cBFHashEntries = 0;
//	memset((void *)rgcBFHashChainLengths,0,sizeof(rgcBFHashChainLengths));

	/* get memory for BF's
	/**/
	rgbf = (BF *)PvUtilAllocAndCommit( cbfInit * sizeof(BF) );
	if ( rgbf == NULL )
		goto HandleError;
	memset( rgbf, 0, cbfInit * sizeof(BF) );

	/* get memory for pbgcb
	/**/
	pbgcb = &bgcb;
	memset( (BYTE *)pbgcb, '\0', sizeof(BGCB) );

	/* get memory for page buffers
	/**/
	rgpage = (PAGE *)PvUtilAllocAndCommit( cbfInit * cbPage );
	if ( rgpage == NULL )
		goto HandleError;

	/* allocate a heap array for LRUK and IO heaps
	/**/
	rgpbfHeap = (BF **)PvUtilAllocAndCommit( cbfInit * sizeof(BF *) );
	if ( rgpbfHeap == NULL )
		goto HandleError;
	ipbfHeapMax = cbfInit;

	/* initially both lruk and BFIO heaps are empty
	/**/
	ipbfLRUKHeapMac = 0;
	ipbfBFIOHeapMic = ipbfHeapMax;

	/* initialize lruk temp list as empty list
	/**/
	memset( &lrulistLRUK, 0, sizeof(lrulistLRUK));

	/* allocate a heap array for HIST
	/**/
#ifdef DEBUG
//	ulBFTimeHISTLastTop = 0;
#endif
	rgpbfHISTHeap = (BF **)PvUtilAllocAndCommit( cbfInit * sizeof(BF *) );
	if ( rgpbfHISTHeap == NULL )
		goto HandleError;
	ipbfHISTHeapMax = cbfInit;

	/* initially history heaps are empty
	/**/
	ipbfHISTHeapMac = 0;

	/* initialize batch IO buffers
	/**/	
	ipageBatchIOMax = lBufBatchIOMax;
	rgpageBatchIO = (PAGE *) PvUtilAllocAndCommit( ipageBatchIOMax * cbPage );
	if ( rgpageBatchIO == NULL )
		goto HandleError;

	rgbBatchIOUsed = (BYTE *)LAlloc( (long) ( ipageBatchIOMax + 1 ), sizeof(BYTE) );
	if ( rgbBatchIOUsed == NULL )
		goto HandleError;
	memset( rgbBatchIOUsed, 0, ipageBatchIOMax * sizeof(BYTE) );
	rgbBatchIOUsed[ ipageBatchIOMax ] = 1; /* sentinal */

#if defined( _X86_ ) && defined( X86_USE_SEM )
	/* allocate sem for critBF
	/**/
	Call( ErrBFSEMInit( ) );
#else
	/*	Allocate a group of critical section to share.
	 */
	Call( ErrBFCritInit( ) );
#endif

//	Call( ErrInitializeCriticalSection( &critHASH ) );
	Call( ErrInitializeCriticalSection( &critHIST ) );
	Call( ErrInitializeCriticalSection( &critLRUK ) );
	Call( ErrInitializeCriticalSection( &critBFIO ) );
	Call( ErrInitializeCriticalSection( &critAvail ) );
	Call( ErrInitializeCriticalSection( &critBatchIO ) );

	/*  initialize the group buffer
	/*  lBufThresholdLowPercent and lBufThresholdHighPercent are system
	/*  parameters note AddLRU will increment cbfAvail.
	/**/
	pbgcb->cbfGroup         	= cbfInit;
	if ( !lBufThresholdLowPercent )
		pbgcb->cbfThresholdLow	= min( cbfInit, lAsynchIOMax );
	else
		pbgcb->cbfThresholdLow	= ( cbfInit * lBufThresholdLowPercent ) / 100;
	if ( lBufThresholdHighPercent > lBufThresholdLowPercent )
		pbgcb->cbfThresholdHigh = ( cbfInit * lBufThresholdHighPercent ) / 100;
	else
		pbgcb->cbfThresholdHigh	= min( cbfInit, pbgcb->cbfThresholdLow + lAsynchIOMax );
	pbgcb->rgbf             = rgbf;
	pbgcb->rgpage           = rgpage;
	pbgcb->lrulist.cbfAvail = 0;
	pbgcb->lrulist.pbfMRU   = pbfNil;
	pbgcb->lrulist.pbfLRU   = pbfNil;

	/* initialize perfmon statistics
	/**/
#ifdef COSTLY_PERF
	cBFUsed[0] = cbfInit;
#else  //  !COSTLY_PERF
	cBFUsed = cbfInit;
#endif  //  COSTLY_PERF
#ifdef COSTLY_PERF
	cBFClean[0] = cbfInit;
#else  //  !COSTLY_PERF
	cBFClean = cbfInit;
#endif  //  COSTLY_PERF
	cBFTotal = cbfInit;

	/* initialize the BF's of this group
	/**/
	pbf = rgbf;
	for ( ibf = 0; ibf < cbfInit; ibf++ )
		{
		pbf->ppage = rgpage + ibf;
		pbf->rghe[0].ibfHashNext = ibfNotUsed;
		pbf->rghe[1].ibfHashNext = ibfNotUsed;

		Assert( pbf->pbfLRU == pbfNil );
		Assert( pbf->pbfMRU == pbfNil );
		Assert( pbf->pn == pnNull );
		Assert( pbf->cPin == 0 );
		Assert( pbf->fDirty == fFalse );
		Assert( pbf->fVeryOld == fFalse );
		Assert( pbf->fAsyncRead == fFalse );
		Assert( pbf->fSyncRead == fFalse );
		Assert( pbf->fAsyncWrite == fFalse );
		Assert( pbf->fSyncWrite == fFalse );
		Assert( pbf->fHold == fFalse );
		Assert( pbf->fPatch == fFalse );
		Assert( pbf->fIOError == fFalse );

		Assert( pbf->cDepend == 0 );
		Assert( pbf->pbfDepend == pbfNil );

		Assert( pbf->sigIOComplete == sigNil );
		Assert( pbf->sigSyncIOComplete == sigNil );

		pbf->trxLastRef = trxMax;
		Assert( pbf->ulBFTime1 == 0 );
		Assert( pbf->ulBFTime2 == 0 );
		
		pbf->lgposRC = lgposMax;
		Assert( CmpLgpos(&pbf->lgposModify, &lgposMin) == 0 );

#ifdef COSTLY_PERF
		Assert( pbf->lClass == 0 );
#endif  //  COSTLY_PERF

//		Call( ErrInitializeCriticalSection( &pbf->critBF ) );
#if defined( _X86_ ) && defined( X86_USE_SEM )
		pbf->lLock = -1;
#endif

		/* make a list of available buffers
		/**/
		Assert( pbf->cPin == 0 );
		EnterCriticalSection( critAvail );
		pbf->fHold = fTrue;
		pbf->ipbfHeap = ipbfDangling;	/* make it dangling */
		BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
		LeaveCriticalSection( critAvail );

		Assert( pbf->ipbfHeap == ipbfInAvailList );

		/*	initialize History heap such that all free hist is put in
		 *	the history heap array.
		 */
		rgpbfHISTHeap[ ibf ] = pbf;

		pbf++;
		}
	Assert( (INT) pbgcb->lrulist.cbfAvail == cbfInit );

	/* allocate overlapped IO signal pool
	/**/
	Call( ErrBFSIGInit() );

	/* allocate async overlapped IO OLP pool
	/**/
	Call( ErrBFOLPInit() );

	Call( ErrSignalCreate( &sigBFCleanProc, NULL ) );
	Call( ErrSignalCreateAutoReset( &sigBFIOProc, NULL ) );

	fBFCleanProcessTerm = fFalse;
	Call( ErrUtilCreateThread( BFCleanProcess,
		cbBFCleanStack,
		THREAD_PRIORITY_NORMAL,
		&handleBFCleanProcess ) );

	fBFIOProcessTerm = fFalse;
	CallJ( ErrUtilCreateThread( BFIOProcess,
		cbBFCleanStack,
		THREAD_PRIORITY_TIME_CRITICAL,
		&handleBFIOProcess ), KillThreads );

	fBFInitialized = fTrue;

	return JET_errSuccess;

KillThreads:
	BFKillThreads();

HandleError:
	BFOLPTerm( fTrue );
	BFSIGTerm();
		
	if ( rgbBatchIOUsed != NULL )
		{
		LFree( rgbBatchIOUsed );
		rgbBatchIOUsed = NULL;
		}
		
	if ( rgpageBatchIO != NULL )
		{
		UtilFree( rgpageBatchIO );
		rgpageBatchIO = NULL;
		}
		
#if defined( _X86_ ) && defined( X86_USE_SEM )
	BFSEMTerm();
#else
	BFCritTerm();
#endif

	if ( rgpbfHeap != NULL )
		UtilFree( rgpbfHeap );
	
	if ( rgpage != NULL )
		UtilFree( rgpage );
	
	if ( rgbf != NULL )
		UtilFree( rgbf );
	
	return ErrERRCheck( JET_errOutOfMemory );
	}


VOID BFSleep( unsigned long ulMSecs )
	{
	Assert( ulMSecs <= ulMaxTimeOutPeriod );
	LgLeaveCriticalSection( critJet );
	UtilSleep( ulMSecs );
	LgEnterCriticalSection( critJet );
	return;
	}


VOID BFTerm( BOOL fNormal )
	{
	BF  *pbf, *pbfMax;

	fBFInitialized = fFalse;

	/*  kill threads
	/**/
	BFKillThreads();

	/*  release async overlapped IO OLP pool
	/**/
	BFOLPTerm( fNormal );
	
	/*  release OLP signal pool
	/**/
	BFSIGTerm();
	
	/* release memory
	/**/
	pbf = pbgcb->rgbf;
	pbfMax = pbf + pbgcb->cbfGroup;

//	for ( ; pbf < pbfMax; pbf++ )
//		{
//		DeleteCriticalSection( pbf->critBF );
//		}

//	DeleteCriticalSection( critHASH );
	DeleteCriticalSection( critHIST );
	DeleteCriticalSection( critLRUK );
	DeleteCriticalSection( critBFIO );
	DeleteCriticalSection( critAvail );
	DeleteCriticalSection( critBatchIO );

	/*  release semaphore
	/**/
#if defined( _X86_ ) && defined( X86_USE_SEM )
	BFSEMTerm();
#else
	BFCritTerm();
#endif

	if ( rgpbfHISTHeap != NULL )
		{
		UtilFree( rgpbfHISTHeap );
		rgpbfHISTHeap = NULL;
		}
		
	if ( rgpbfHeap != NULL )
		{
		UtilFree( rgpbfHeap );
		rgpbfHeap = NULL;
		}
		
	if ( pbgcb != NULL )
		{
		UtilFree( pbgcb->rgpage );
		UtilFree( pbgcb->rgbf );
		pbgcb = NULL;
		}
	
	if ( rgbBatchIOUsed != NULL )
		{
		LFree( rgbBatchIOUsed );
		rgbBatchIOUsed = NULL;
		}
		
	if ( rgpageBatchIO != NULL )
		{
		UtilFree( rgpageBatchIO );
		rgpageBatchIO = NULL;
		}
	}


BOOL FBFIPatch( FMP *pfmp, BF *pbf )
	{
	BOOL fPatch;

	AssertCriticalSection( pfmp->critCheckPatch );

		/*	if page written successfully and one of the following two cases
		 *
		 *	case 1: new page in split is a reuse of old page. contents of
		 *	        old page will be moved to new page, but new page is copied
		 *			already, so we have to recopy the new page with new data
		 *			again.
		 *	1) this page must be written before another page, and
		 *	2) backup in progress, and
		 *	3) page number is less than last copied page number,
		 *	then write page to patch file.
		 *
		 *	case 2: similar to above, but new page is greater than the database
		 *	        that will be copied. So the new page will not be able to be
		 *			copied. We need to patch it.
		 *
		 *	Note that if all dependent pages were also before copy
		 *	page then write to patch file would not be necessary.
		 **/

	fPatch =
			 /*	backup is going on and no error.
			  */
			 pfmp->pgnoMost && pfmp->hfPatch != handleNil && pfmp->errPatch == JET_errSuccess;

	if ( fPatch )
		{
		BOOL fOldPageWillBeCopied = fFalse;
		BF *pbfDepend = pbf->pbfDepend;

		/*	check if the page is a new page of a split
		 *	check if any of its old page (depend list) will be copied for backup.
		 */
		while( pbfDepend )
			{
			/*	check if the old page hasn't been copied and will be copied.
			 *	check it againt the last page being copied (including itself, pgnoCopyMost).
			 */
			if ( pfmp->pgnoCopyMost <= PgnoOfPn( pbfDepend->pn ) &&
				 pfmp->pgnoMost >= PgnoOfPn( pbfDepend->pn ) )
				{
				fOldPageWillBeCopied = fTrue;
				break;
				}

			pbfDepend = pbfDepend->pbfDepend;
			}

		fPatch = fOldPageWillBeCopied;
		}

	if ( fPatch )
		{
		fPatch =

			(
			/*	case 1: new page number is less than the page number being copied
			 *	        while old page is not copied yet. If we flush new page,
			 *	        and later old page is flushed and copied, then the old
			 *			contents of old page is on new page and not copied. So we
			 *			have to patch the new page for backup.
			 */
			pfmp->pgnoCopyMost >= PgnoOfPn( pbf->pn )
			||
			/* case 2: new page is beyond the last page that will be copied and old
			 *	        page is not copied. If we flush the new page, old page, and
			 *	        copied the old page, then we lost the old contents of old page.
			 *	        patch the new page for backup.
			 */
			pfmp->pgnoMost < PgnoOfPn( pbf->pn )
			);
		}

	return fPatch;
	}


ERR ErrBFIRemoveDeferredBI( BF *pbf )
	{
	ERR err;

	/*	hold critical section such that the session(ppib) of the deferred
	 *	BI rce list can not commit. The sessions have to either get into the
	 *	critical section to take the rce out of the list or wait for the
	 *	following code to use the RCE's and take them out.
	 */

	/*	make sure the prce we update will be in consistent state.
	 *	it should be critVer instead.
	 */
	AssertCriticalSection( critJet );
	
	BFEnterCriticalSection( pbf );
	while ( pbf->prceDeferredBINext != prceNil )
		{
		RCE *prceT;

		Assert( pbf->prceDeferredBINext->pbfDeferredBI == pbf );
		Assert( pbf->fSyncRead == fFalse );
		Assert( pbf->fAsyncRead == fFalse );
//		Assert( pbf->fSyncWrite == fFalse );
		Assert( pbf->fAsyncWrite == fFalse );
		Assert(	pbf->fDirty );

		/*	take out of RCE list.
		 */
		prceT = pbf->prceDeferredBINext;
		Assert( prceT->pbfDeferredBI == pbf );
		
		if ( ( err = ErrLGDeferredBIWithoutRetry( prceT ) ) != JET_errSuccess )
			{
			BFLeaveCriticalSection( pbf );
			return err;
			}
		pbf->prceDeferredBINext = prceT->prceDeferredBINext;
		prceT->prceDeferredBINext = prceNil;
		prceT->pbfDeferredBI = pbfNil;
#ifdef DEBUG
		prceT->qwDBTimeDeferredBIRemoved = QwPMDBTime( pbf->ppage );
#endif
		}
	
#ifdef DEBUG
	{
	RCE **pprceNext = &pbf->prceDeferredBINext;
	while( *pprceNext != prceNil )
		{
		Assert( (*pprceNext)->pbfDeferredBI == pbf );
		pprceNext = &(*pprceNext)->prceDeferredBINext;
		}
	}
#endif

	BFLeaveCriticalSection( pbf );

	return JET_errSuccess;
	}


/*
 *  This function issue a read/write. The caller must have setup the buffer
 *  with fSyncRead/fSyncWrite flag set so that no other can access it. The buffer
 *  must be dangling.
 **/
VOID BFIOSync( BF *pbf )
	{
	ERR		err;
	LGPOS	lgposModify;

	AssertCriticalSection( critJet );

	/*  this had better be a SyncRead or SyncWrite of a dangling buffer!
	/**/
	Assert( pbf->fHold );
	Assert( pbf->fSyncRead || pbf->fSyncWrite );
	Assert( !pbf->fAsyncRead );
	Assert( !pbf->fAsyncWrite );
	Assert( pbf->ipbfHeap == ipbfDangling );
	
#ifndef NO_LOG

	/*  if this BF is a SyncWrite, handle deferred BI
	/**/
	if ( pbf->fSyncWrite )
		{
CheckWritable:
		Assert( pbf->pn != pnNull );
		Assert(	pbf->fDirty );
		Assert(	!pbf->fAsyncRead );
		Assert(	!pbf->fSyncRead );
		Assert(	!pbf->fAsyncWrite );
		Assert(	pbf->fSyncWrite );
		Assert(	pbf->cDepend == 0 );
//		Assert( !pbf->cWriteLatch );

		/*	if log is on, check log record of last
		/*	operation on the page has flushed
		/**/
		if ( !fLogDisabled &&
			 FDBIDLogOn(DbidOfPn( pbf->pn )) )
			{
			/*	must be called before lgposToFlush is checked
			/**/
			err = ErrBFIRemoveDeferredBI( pbf );

			if ( err == JET_errLogWriteFail )
				{
				BFSetIOError( pbf, err );
				return;
				}
			
			else if ( err != JET_errSuccess )
				{
				BFSleep( cmsecWaitGeneric );
				goto CheckWritable;
				}

			BFEnterCriticalSection( pbf );
			lgposModify = pbf->lgposModify;
			BFLeaveCriticalSection( pbf );

			EnterCriticalSection( critLGBuf );
			if ( ( !fRecovering || fRecoveringMode == fRecoveringUndo )  &&
				CmpLgpos( &lgposModify, &lgposToFlush ) >= 0 )
				{
				if ( fLGNoMoreLogWrite )
					{
					// Log has fallen behind, but we are out of disk space, so it
					// will never catch up.  Therefore, abort with an error.
					LeaveCriticalSection( critLGBuf );
					BFSetIOError( pbf, JET_errLogWriteFail );
					return;
					}
				else
					{
					// Let the log file catch up.
					LeaveCriticalSection( critLGBuf );
					Assert( !fLogDisabled );
					SignalSend( sigLogFlush );
					BFSleep( cmsecWaitIOComplete );
					goto CheckWritable;
					}
				}
			LeaveCriticalSection( critLGBuf );
			}
		}

#endif  //  !NO_LOG

	LeaveCriticalSection( critJet );
					
	/*  allocate sync IO completion signal
	/**/
	BFEnterCriticalSection( pbf );
	
	Assert( pbf->prceDeferredBINext == prceNil );
	Assert( pbf->sigSyncIOComplete == sigNil );
	
	CallS( ErrBFSIGAlloc( &pbf->sigSyncIOComplete ) );
	SignalReset( pbf->sigSyncIOComplete );
	
	BFLeaveCriticalSection( pbf );

	BFResetIOError( pbf );
	
	/*  push buffer onto IO heap
	/**/
	EnterCriticalSection( critBFIO );
	BFIOAddToHeap( pbf );
	LeaveCriticalSection( critBFIO );

	/*  signal IO process to perform read / write and wait for it's completion
	/**/
	SignalSend( sigBFIOProc );
	SignalWait( pbf->sigSyncIOComplete, INFINITE );

	BFEnterCriticalSection( pbf );
	Assert( pbf->sigSyncIOComplete != sigNil );
	BFSIGFree( pbf->sigSyncIOComplete );
	pbf->sigSyncIOComplete = sigNil;
	BFLeaveCriticalSection( pbf );
	
	EnterCriticalSection( critJet );
	}


INLINE VOID BFIReturnBuffers( BF *pbf )
	{
	Assert( pbf->ipbfHeap == ipbfDangling );

	Assert( !( pbf->fInHash ) );
	Assert( pbf->cPin == 0 );
	Assert( pbf->fDirty == fFalse );
	Assert( pbf->fVeryOld == fFalse );
	Assert( pbf->fAsyncRead == fFalse );
	Assert( pbf->fSyncRead == fFalse );
	Assert( pbf->fAsyncWrite == fFalse );
	Assert( pbf->fSyncWrite == fFalse );
	Assert( pbf->fIOError == fFalse );

	Assert( pbf->cDepend == 0 );
	Assert( pbf->pbfDepend == pbfNil );
	
	pbf->pn = pnNull;
	
	/* release the buffer and return the found buffer
	/**/
	EnterCriticalSection( critAvail );
	BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
	LeaveCriticalSection( critAvail );
	}


/*  Find BF for pn in hash table (see PbfBFISrchHashTable).
/*  If the page is being READ/WRITE from/to disk, we can still find
/*  the BF, but we must wait until the read is complete.
/*
/*  RETURNS         NULL if BF is not found.
/**/
ERR ErrBFIFindPage( PIB *ppib, PN pn, BF **ppbf )
	{
	ERR		err;
	BF		*pbf;

	/*  wait until we can successfully hold a BF with the required PN
	/*  or until we know that page is not present in the cache
	/**/
	do	{
		/* if the page isn't in the hash table, return that
		/* we can't find it
		/**/
		pbf = PbfBFISrchHashTable( pn, butBuffer );
		*ppbf = pbf;
		if ( pbf == pbfNil )
			return ErrERRCheck( wrnBFPageNotFound );
		}
	while ( ( err = ErrBFHold( ppib, pn, pbf ) ) == wrnBFNotSynchronous );

	/*  if the BF is in an IO error state, end
	/**/
	if ( pbf->fIOError )
		{
		Assert( pbf->fHold );
		return pbf->err;
		}

#ifdef DEBUG
	{
	PGNO	pgnoThisPage;

	LFromThreeBytes( &pgnoThisPage, &pbf->ppage->pgnoThisPage );
	Assert( PgnoOfPn(pbf->pn) == pgnoThisPage );
	}
#endif

	Assert( pbf->pn != pnNull );

	/*  check for Very Old page
	/**/
	if ( FBFIsVeryOld( pbf ) )
		{
		/*  ensure Very Old bit is set
		/**/
		BFSetVeryOldBit( pbf );

		/*  if there is no write/wait latch on this BF and the page is writable,
		/*  SyncWrite it to disk to help advance the checkpoint
		/**/
		if ( FBFIWritable( pbf, fFalse, ppibNil ) )
			{
			BFSetSyncWriteBit( pbf );
			BFIOSync( pbf );
			BFResetSyncWriteBit( pbf );
			}
		}

	/*  renew BF by updating its access time and moving it to the LRUK heap
	/**/
#ifdef LRU1
		pbf->ulBFTime2 = 0;
		pbf->ulBFTime1 = UlUtilGetTickCount();
#else  //  !LRU1
	if ( pbf->trxLastRef != ppib->trxBegin0 )
		{
		ULONG	ulNow = UlUtilGetTickCount();
		
		if ( pbf->ulBFTime1 + 10 < ulNow )
			{
			pbf->trxLastRef = ppib->trxBegin0;
			Assert( !pbf->fSyncRead && !pbf->fAsyncRead );
			pbf->ulBFTime2 = pbf->ulBFTime1;
			pbf->ulBFTime1 = ulNow;
			}
		}
#endif  //  LRU1
	
	return err;
	}


/*  references a BF with respect to the LRUK algorithm
/**/
VOID BFReference( BF *pbf, PIB *ppib )
	{
#ifndef LRU1
	ULONG ulNow = UlUtilGetTickCount();

	if ( pbf->ulBFTime1 + 10 >= ulNow )
		{
		/*	too short to change reference time. Just change trxLastRef.
		 */
		pbf->trxLastRef = ppib->trxBegin0;
		return;
		}
#endif  //  !LRU1

	EnterCriticalSection( critLRUK );

#ifdef LRU1
		pbf->ulBFTime2 = 0;
		pbf->ulBFTime1 = UlUtilGetTickCount();
#else  //  !LRU1
	/*  shouldn't be a correlated reference (same trx)
	/**/
	Assert( pbf->trxLastRef != ppib->trxBegin0 );

	/*  update referencing trx and reference time
	/**/
	pbf->trxLastRef = ppib->trxBegin0;
	Assert( !pbf->fSyncRead && !pbf->fAsyncRead );
	pbf->ulBFTime2 = pbf->ulBFTime1;
	pbf->ulBFTime1 = ulNow;
#endif  //  LRU1

	/*  if BF is in LRUK heap, update its position
	/**/
	if ( FBFInLRUKHeap( pbf ) )
		BFLRUKUpdateHeap( pbf );
	
	LeaveCriticalSection( critLRUK );
	}


/*	set ulBFTime1 and ulBFTime2 to be 0. If there were history of this page,
 *	then delete history entry of this page and set ulBFTime1 as the last
 *	reference time in the history entry.
 */
VOID BFIInitializeUlBFTime( BF *pbf )
	{
	BF *pbfH;

	Assert( pbf->pn );
	Assert( pbf->rghe[ butBuffer ].ibfHashNext == ibfNotUsed );
	
	EnterCriticalSection( critHIST );
	if ( ( pbfH = PbfBFISrchHashTable( pbf->pn, butHistory ) ) != pbfNil )
		{
		pbf->ulBFTime1 = pbfH->hist.ulBFTime;

		BFIDeleteHashTable( pbfH, butHistory );
		BFHISTTakeOutOfHeap( pbfH );
			
		/*	put pbfH to the entry which we just released in TakeOufOfHeap
		 */
		rgpbfHISTHeap[ ipbfHISTHeapMac ] = pbfH;
		pbfH->hist.ipbfHISTHeap = ipbfDangling;
		
		// UNDONE: debug only?
		pbfH->rghe[ butHistory ].ibfHashNext = ibfNotUsed;
		}
	else
		pbf->ulBFTime1 = 0;
	LeaveCriticalSection( critHIST );

	pbf->ulBFTime2 = 0;
	}


#ifdef DEBUG

/*  Check that the given page is in the addressable area of its
/*  respective database
/**/
LOCAL BOOL FBFValidExtent( PN pnMin, PN pnMax )
	{
	QWORDX cbOffsetDbMin;
	QWORDX cbOffsetDbMac;
	QWORDX cbOffsetExtentMin;
	QWORDX cbOffsetExtentMac;
	
	DBID dbid = DbidOfPn( pnMin );
	PGNO pgnoMin = PgnoOfPn( pnMin );
	PGNO pgnoMax = PgnoOfPn( pnMax );

	Assert( DbidOfPn( pnMin ) == DbidOfPn( pnMax ) );
	Assert( pgnoMin <= pgnoMax );

	/*  get current database min and mac
	/**/
	EnterCriticalSection( rgfmp[dbid].critExtendDB );
	cbOffsetDbMin.l = LOffsetOfPgnoLow( 1 );
	cbOffsetDbMin.h = LOffsetOfPgnoHigh( 1 );
	cbOffsetDbMac.l = rgfmp[dbid].ulFileSizeLow;
	cbOffsetDbMac.h = rgfmp[dbid].ulFileSizeHigh;
	//  UNDONE:  must adjust cbOffsetDbMac for cpageDBReserved
	cbOffsetDbMac.qw += cpageDBReserved * cbPage;
	LeaveCriticalSection( rgfmp[dbid].critExtendDB );

	/*  get min and mac of extent to read
	/**/
	cbOffsetExtentMin.l = LOffsetOfPgnoLow( pgnoMin );
	cbOffsetExtentMin.h = LOffsetOfPgnoHigh( pgnoMin );
	cbOffsetExtentMac.l = LOffsetOfPgnoLow( pgnoMax + 1 );
	cbOffsetExtentMac.h = LOffsetOfPgnoHigh( pgnoMax + 1 );

	/*  extent should be inside addressable database
	/**/
	if ( cbOffsetExtentMin.qw < cbOffsetDbMin.qw )
		return fFalse;
	if ( cbOffsetExtentMac.qw > cbOffsetDbMac.qw )
		return fFalse;
	return fTrue;
	}

#endif


/*  ErrBFIAccessPage is used to make any physical page (pn) accessible to
/*  the caller (returns pbf).
/*  RETURNS JET_errSuccess
/*          JET_errOutOfMemory      no buffer available, request not granted
/*			                        fatal io errors
/*          wrnBFNewIO				Buffer access caused a new IO (cache miss)
/*          wrnBFCacheMiss			Buffer access was a cache miss but didn't
/*									cause a new IO
/**/
ERR ErrBFIAccessPage( PIB *ppib, BF **ppbf, PN pn )
	{
	ERR     err = JET_errSuccess;
	BF      *pbf;
	
	BOOL	fNewIO = fFalse;
	BOOL	fCacheHit = fTrue;

	AssertNotInCriticalSection( critLRUK );

	/*  verify that this is a legal page in the database if we are not recovering
	/*  and not currently attaching to this database
	/**/
	Assert( fRecovering || ppib->fSetAttachDB || FBFValidExtent( pn, pn ) );

	AssertCriticalSection( critJet );

	/*  try to find page in cache
	/**/
SearchPage:
	err = ErrBFIFindPage( ppib, pn, &pbf );

	/*  we found the page!
	/**/
	if ( err != wrnBFPageNotFound )
		{
		if ( err == wrnBFCacheMiss || err == wrnBFNewIO )
			fCacheHit = fFalse;

		EnterCriticalSection( critLRUK );
		BFLRUKAddToHeap( pbf );
		LeaveCriticalSection( critLRUK );

		CallR( err );		// Once we've added the page to the heap, check for error.
		}

	/*  we did not find page, so we will read it in
	/**/
	else
		{
		/*  allocate a buffer for this new page
		/**/
		fCacheHit = fFalse;

		CallR ( ErrBFIAlloc( &pbf, fSync ) );
		if ( err == wrnBFNotSynchronous )
			{
			/* we did not find a buffer, let's see if other user
			/* bring in this page by checking BFIFindPage again.
			/**/
			Assert( pbf == pbfNil );
			// release critJet and sleep in BFIFindPage or BFIAlloc
			goto SearchPage;
			}
		Assert( pbf->ipbfHeap == ipbfDangling );

		/* now we got a buffer for page pn
		/**/
		if ( PbfBFISrchHashTable( pn, butBuffer ) != NULL )
			{
			/* someone has add one,
			 * release the buffer and return the newly found buffer
			 */
			BFIReturnBuffers( pbf );
			goto SearchPage;
			}

		/*  setup buffer for read and perform read
		/**/
		pbf->pn = pn;

		BFIInitializeUlBFTime( pbf );
		BFIInsertHashTable( pbf, butBuffer );
#ifdef COSTLY_PERF
		BFSetTableClass( pbf, 0 );
#endif  //  COSTLY_PERF
		
		fNewIO = fTrue;
		BFSetSyncReadBit( pbf );
		BFIOSync( pbf );
		BFResetSyncReadBit( pbf );

		/*  if there was an error, return it
		/**/
		if ( pbf->fIOError )
			{
			err = pbf->err;
			BFResetIOError( pbf );

			/*  return to avail list
			/**/
			EnterCriticalSection( critAvail );
			BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
			LeaveCriticalSection( critAvail );
			
			return err;
			}
		else
			{
			EnterCriticalSection(critLRUK);
			BFLRUKAddToHeap( pbf );
			LeaveCriticalSection(critLRUK);
			}
		}

	/*  buffer can not be stolen
	/**/
	Assert(	pbf->pn == pn &&
			!pbf->fSyncRead && !pbf->fSyncWrite &&
			!pbf->fAsyncRead && !pbf->fAsyncWrite );

	/*  set this session as last reference to BF
	/**/
	pbf->trxLastRef = ppib->trxBegin0;

	*ppbf = pbf;

#ifdef DEBUG
	{
	PGNO	pgnoThisPage;

	LFromThreeBytes( &pgnoThisPage, &pbf->ppage->pgnoThisPage );
	Assert( PgnoOfPn( pbf->pn ) == pgnoThisPage );
	}
#endif

		//  wrnBFNewIO:  Buffer access caused a new IO (cache miss)
		
	if ( fNewIO )
		err = ErrERRCheck( wrnBFNewIO );

		//  wrnBFCacheMiss:  Buffer access was a cache miss but didn't
		//  cause a new IO
		
	else if ( !fCacheHit )
		err = ErrERRCheck( wrnBFCacheMiss );

//	Assert( CmpLgpos( &pbf->lgposModify, &lgposLogRec ) <= 0 );
	return err;
	}


/*  get generic access to a page
/**/
ERR ErrBFAccessPage( PIB *ppib, BF **ppbf, PN pn )
	{
	ERR		err;
	
	/*  access the page
	/**/
	CallR( ErrBFIAccessPage( ppib, ppbf, pn ) );

	/*  monitor statistics
	/**/
	ppib->cAccessPage++;

#ifdef COSTLY_PERF
	Assert( !(*ppbf)->lClass );
	cBFCacheReqs[0]++;
	if ( err != wrnBFCacheMiss && err != wrnBFNewIO )
		cBFCacheHits[0]++;
	if ( err == wrnBFNewIO )
		cBFPagesRead[0]++;
#else  //  !COSTLY_PERF
	cBFCacheReqs++;
	if ( err != wrnBFCacheMiss && err != wrnBFNewIO )
		cBFCacheHits++;
	if ( err == wrnBFNewIO )
		cBFPagesRead++;
#endif  //  COSTLY_PERF

	return err;
	}


/*  get read accesss to a page
/**/
ERR ErrBFReadAccessPage( FUCB *pfucb, PGNO pgno )
	{
	ERR		err;

	//	if page to access is invalid, then B-tree parent page must be corrupt
	if ( pgno > pgnoSysMax )
		{
		return JET_errReadVerifyFailure;
		}

	CallR( ErrBFIAccessPage(	pfucb->ppib,
								&pfucb->ssib.pbf,
								PnOfDbidPgno( pfucb->dbid, pgno ) ) );

	/*  monitor statistics
	/**/
	pfucb->ppib->cAccessPage++;

#ifdef COSTLY_PERF
	BFSetTableClass( pfucb->ssib.pbf, pfucb->u.pfcb->lClass );
	cBFCacheReqs[pfucb->ssib.pbf->lClass]++;
	if ( err != wrnBFCacheMiss && err != wrnBFNewIO )
		cBFCacheHits[pfucb->ssib.pbf->lClass]++;
	if ( err == wrnBFNewIO )
		cBFPagesRead[pfucb->ssib.pbf->lClass]++;
#else  //  !COSTLY_PERF
	cBFCacheReqs++;
	if ( err != wrnBFCacheMiss && err != wrnBFNewIO )
		cBFCacheHits++;
	if ( err == wrnBFNewIO )
		cBFPagesRead++;
#endif  //  COSTLY_PERF

	return err;
	}


/*  get write accesss to a page
/**/
ERR ErrBFWriteAccessPage( FUCB *pfucb, PGNO pgno )
	{
	ERR		err;
	
	//	if page to access is invalid, then B-tree parent page must be corrupt
	if ( pgno > pgnoSysMax )
		{
		return JET_errReadVerifyFailure;
		}

	CallR( ErrBFIAccessPage(	pfucb->ppib,
								&pfucb->ssib.pbf,
								PnOfDbidPgno( pfucb->dbid, pgno ) ) );

	/*  monitor statistics
	/**/
	pfucb->ppib->cAccessPage++;

#ifdef COSTLY_PERF
	BFSetTableClass( pfucb->ssib.pbf, pfucb->u.pfcb->lClass );
	cBFCacheReqs[pfucb->ssib.pbf->lClass]++;
	if ( err != wrnBFCacheMiss && err != wrnBFNewIO )
		cBFCacheHits[pfucb->ssib.pbf->lClass]++;
	if ( err == wrnBFNewIO )
		cBFPagesRead[pfucb->ssib.pbf->lClass]++;
#else  //  !COSTLY_PERF
	cBFCacheReqs++;
	if ( err != wrnBFCacheMiss && err != wrnBFNewIO )
		cBFCacheHits++;
	if ( err == wrnBFNewIO )
		cBFPagesRead++;
#endif  //  COSTLY_PERF

	return err;
	}


/*
 *  Allocate a buffer and initialize it for a given (new) page.
 */
ERR ErrBFNewPage( FUCB *pfucb, PGNO pgno, PGTYP pgtyp, PGNO pgnoFDP )
	{
	ERR  err;
	PN   pn;

	SgEnterCriticalSection( critBuf );
	pn = PnOfDbidPgno( pfucb->dbid, pgno );
	Call( ErrBFAllocPageBuffer( pfucb->ppib, &pfucb->ssib.pbf, pn,
		pfucb->ppib->lgposStart, pgtyp ) );

	PMInitPage( pfucb->ssib.pbf->ppage, pgno, pgtyp, pgnoFDP );
	PMDirty( &pfucb->ssib );

#ifdef COSTLY_PERF
	BFSetTableClass( pfucb->ssib.pbf, pfucb->u.pfcb->lClass );
#endif  //  COSTLY_PERF

HandleError:
	SgLeaveCriticalSection( critBuf );
	return err;
	}


/*  Allocates an extent of batch IO buffers from the batch IO buffer pool.
/*  We use the usual memory management algorithm to ensure that we do not
/*  fragment the buffer pool and as a result decrease our average batch IO
/*  size.  Only extents of 2 buffers or larger are returned.
/**/
VOID BFIOAllocBatchIOBuffers( LONG *pipage, LONG *pcpg )
	{
	CPG		cpg = min( *pcpg, ipageBatchIOMax );
	LONG	ipage;
	LONG	ipageCur;
	LONG	ipageMax;
	CPG		cpgCur;
	
	/*  initialize return values for failure
	/**/
	*pipage = -1;
	*pcpg = 0;

	/*  fail if the caller wants less than two pages
	/**/
	if ( cpg < 2 )
		return;

	/*  find a contiguous free block of batch buffers that is either as small
	/*  as possible but greater than or equal to the requested size, or as
	/*  close to the requested size as possible
	/*
	/*  NOTE:  there is a sentinel at the end of the array to end the last
	/*  free zone explicitly, simplifying the algorithm
	/**/
	EnterCriticalSection( critBatchIO );
	Assert( rgbBatchIOUsed[ipageBatchIOMax] );  //  sentinel
	for ( ipage = 0, ipageCur = -1; ipage <= ipageBatchIOMax; ipage++ )
		{
		/*  remember the first page of the new free zone
		/**/
		if ( !rgbBatchIOUsed[ipage] && ipageCur == -1 )
			ipageCur = ipage;

		/*  we have just left a free zone
		/**/
		else if ( rgbBatchIOUsed[ipage] && ipageCur != -1 )
			{
			/*  get last free zone's size
			/**/
			cpgCur = ipage - ipageCur;

			/*  if the last free zone was closer to our ideal run size than
			/*  our current choice, we have a new winner
			/**/
			if (	cpgCur > 1 &&
					(	( cpgCur > *pcpg && *pcpg < cpg ) ||
						( cpgCur < *pcpg && *pcpg > cpg && cpgCur >= cpg ) ) )
				{
				*pipage = ipageCur;
				*pcpg = cpgCur;
				}

			/*  reset to find the next run
			/**/
			ipageCur = -1;
			}
		}

	/*  allocate the chosen free zone
	/**/
	*pcpg = min( cpg, *pcpg );
	ipageMax = *pipage + *pcpg;
	Assert(	( *pcpg == 0 && *pipage == -1 ) ||
			( *pcpg >= 2 && *pcpg <= ipageBatchIOMax &&
			  *pipage >= 0 && ipageMax <= ipageBatchIOMax ) );
	for ( ipage = *pipage; ipage < ipageMax; ipage++ )
		{
		Assert( rgbBatchIOUsed[ipage] == 0 );
		rgbBatchIOUsed[ipage] = 1;
		}
	LeaveCriticalSection( critBatchIO );

	/*  print debugging info
	/**/
#ifdef DEBUGGING
	printf("Get   %2d - %2d,%4d\n", *pcpg, *pipage, *pipage + *pcpg - 1 );
#endif
	}


/*  free batch IO buffers
/**/
VOID BFIOFreeBatchIOBuffers( LONG ipageFirst, LONG cpg )
	{
	LONG	ipage;
	LONG	ipageMax = ipageFirst + cpg;

	Assert( ipageFirst >= 0 );
	Assert( cpg > 1 );
	Assert( cpg <= ipageBatchIOMax );
	Assert( ipageMax <= ipageBatchIOMax );

	EnterCriticalSection( critBatchIO );
	for ( ipage = ipageFirst; ipage < ipageMax; ipage++ )
		{
		Assert( rgbBatchIOUsed[ipage] == 1 );
		rgbBatchIOUsed[ipage] = 0;
		}
	LeaveCriticalSection( critBatchIO );
	
#ifdef DEBUGGING
	printf("Free  %2d - %2d,%4d\n",	cpage, ipage - cpage, ipage - 1 );
#endif
	}


/*  returns buffers allocated for a read to the avail list after an error
/**/
VOID BFIOReturnReadBuffers( BF *pbf, LONG cpbf, ERR err )
	{
	BF		*pbfT = pbf;
	BF		*pbfNextBatchIO;
	LONG	cpbfT;
	
	AssertCriticalSection( critJet );
	
	for ( cpbfT = 0; cpbfT < cpbf; pbfT = pbfNextBatchIO, cpbfT++ )
		{
		pbfNextBatchIO = pbfT->pbfNextBatchIO;
		
		Assert( pbfT->pn );
		Assert( !pbfT->fDirty );
		Assert( pbfT->fAsyncRead || pbfT->fSyncRead || pbfT->fDirectRead );
		Assert( !pbfT->fAsyncWrite );
		Assert( !pbfT->fSyncWrite );
		Assert( pbfT->ipbfHeap == ipbfDangling );

		if ( pbfT->fDirectRead )
			{
			Assert( cpbf == 1 );
			}
		else
			BFIDeleteHashTable( pbfT, butBuffer );

		pbfT->pn = pnNull;

		pbfT->trxLastRef = trxMax;
		pbfT->ulBFTime2 = 0;
		pbfT->ulBFTime1 = 0;

		/*  If this is an AsyncRead, reset any IO error and free the held BF.
		/**/
		if ( pbfT->fAsyncRead )
			{
			BFResetIOError( pbfT );
			BFResetAsyncReadBit( pbfT );
			
			/*  return to avail list
			/**/
			EnterCriticalSection( critAvail );
			BFAddToListAtLRUEnd( pbfT, &pbgcb->lrulist );
			LeaveCriticalSection( critAvail );
			}

		/*  If this is a SyncRead/DirectRead, we will set the IO error, leave the BF
		/*  held, and signal that the IO is complete.
		/**/
		else
			{
			BFSetIOError( pbfT, err );
			SignalSend( pbfT->sigSyncIOComplete );
			}

		}
	}


/*  returns buffers allocated for a write to the LRUK heap after an error
/**/
VOID BFIOReturnWriteBuffers( BF *pbf, LONG cpbf, ERR err )
	{
	BF		*pbfT = pbf;
	BF		*pbfNextBatchIO;
	LONG	cpbfT;
	
	for ( cpbfT = 0; cpbfT < cpbf; pbfT = pbfNextBatchIO, cpbfT++ )
		{
		pbfNextBatchIO = pbfT->pbfNextBatchIO;

		Assert( pbfT->pn );
		Assert( pbfT->fHold );
		Assert( pbfT->fDirty );
		Assert( pbfT->fAsyncWrite || pbfT->fSyncWrite );
		Assert( !pbfT->fAsyncRead );
		Assert( !pbfT->fSyncRead );
		Assert( pbfT->ipbfHeap == ipbfDangling );

		/*  set the IO error
		/**/
		BFSetIOError( pbfT, err );

		/*  If this is an AsyncWrite, put BF in LRUK heap and free the write hold.
		/**/
		if ( pbfT->fAsyncWrite )
			{
			BFResetAsyncWriteBit( pbfT );
			EnterCriticalSection( critLRUK );
			BFLRUKAddToHeap( pbfT );
			LeaveCriticalSection( critLRUK );
			}

		/*  If this is a SyncWrite, leave the BF held and signal that the
		/*  IO is complete.  Also, leave the BF dangling.
		/**/
		else
			SignalSend( pbfT->sigSyncIOComplete );
		}
	}


/*********************************************************************************
/*	Issues an async IO request to preread for the pages passed to it in the array
/*	The actual number of pages read is placed in pcpgActual. A page is not read if
/*	it is already in memory. The array of pages should be terminated with pgnoNull
/**/
VOID BFPrereadList( PN * rgpnPages, CPG *pcpgActual )
	{
	BF		*pbf 	= 0;
	PN		pn		= pnNull;
	INT		cpbf 	= 0;
	PN		*ppnT 	= 0;
	CPG		cpgT	= -1;	

	Assert( rgpnPages );
	Assert( pcpgActual );

	AssertCriticalSection( critJet );

	ppnT = rgpnPages;
	*pcpgActual = 0;

	/*  preread all pages in array
	/**/
	while ( ((pn = *ppnT++) != pnNull) )
		{
		Assert( PgnoOfPn( pn ) != pgnoNull );
		BFPreread( pn, 1, &cpgT );
		Assert( cpgT <= 1 && cpgT >= 0 );	
		if ( cpgT <= 0 )
			{
			return;
			}
		*pcpgActual += cpgT;
		}
	return;
	}

/*********************************************************************************
/*  Issues an async IO request to preread cpg pages either forwards from pnFirst
/*  (if cpg > 0) or backwards from pnFirst (if cpg < 0).  The actual number of
/*  pages for which prereads were issued is returned (we will not issue a preread
/*  for a page that is already in memory).
/**/
VOID BFPreread( PN pnFirst, CPG cpg, CPG *pcpgActual )
	{
	LONG	iDir;
	BF		*pbf;
	PN		pn;
	INT		cpbf;
	
	AssertCriticalSection( critJet );
	Assert( pnFirst );
	Assert( cpg != 0 );

	*pcpgActual = 0;

	if ( cpg > 0 )
		iDir = 1;
	else
		iDir = -1;

	/*  verify that this is a legal page in the database
	/**/
#ifdef DEBUG
	{
	PN pnLast = pnFirst + cpg - iDir;
	PN pnMin = min( pnFirst, pnLast );
	PN pnMax = max( pnFirst, pnLast );
	
	Assert( FBFValidExtent( pnMin, pnMax ) );
	}
#endif  //  DEBUG
	
	/*  push all pages to be read onto IO heap
	/**/
	for ( pn = pnFirst, cpbf = 0; pn != pnFirst + cpg; pn += iDir )
		{
		if ( PgnoOfPn( pn ) == pgnoNull )
			{
			break;
			}

		/*  if this page is already present, don't preread it
		/**/
		if ( PbfBFISrchHashTable( pn, butBuffer ) )
			continue;

		/*  Allocate a buffer for this new page.  If we get an error during
		/*  alloc, skip this PN and keep on going
		/**/
		if ( ErrBFIAlloc( &pbf, fAsync ) != JET_errSuccess )
			continue;

		/*  setup buffer for preread
		/**/
		Assert( pbf->ipbfHeap == ipbfDangling );
		BFSetAsyncReadBit( pbf );
		pbf->pn = pn;
		BFIInitializeUlBFTime( pbf );
		BFIInsertHashTable( pbf, butBuffer );
		cpbf++;
#ifdef COSTLY_PERF
		BFSetTableClass( pbf, 0 );
#endif  //  COSTLY_PERF
		
		/*  push buffer into IO heap
		/**/
		EnterCriticalSection( critBFIO );
		BFIOAddToHeap( pbf );
		LeaveCriticalSection( critBFIO );
		}

	/*  signal IO process to perform preread before we're done
	/**/
	if ( cpbf )
		SignalSend( sigBFIOProc );
	*pcpgActual = cpbf * iDir;
	return;
	}


/*  Allocate a buffer for the physical page identified by pn.
/*  No data is read in for this page.
/*
/*  PARAMETERS      ppbf    pointer to BF is returned in *ppbf
/*
/*  RETURNS         JET_errSuccess
/*                  errBFNoFreeBuffers
/**/
ERR ErrBFAllocPageBuffer( PIB *ppib, BF **ppbf, PN pn, LGPOS lgposRC, PGTYP pgtyp )
	{
	ERR     err = JET_errSuccess;
	BF		*pbf;
	BOOL    fFound;

	/*  verify that this is a valid page in the database
	/**/
	Assert( fRecovering || FBFValidExtent( pn, pn ) );
	
Begin:
	do
		{
		AssertCriticalSection( critJet );
		CallR( ErrBFIFindPage( ppib, pn, &pbf ) );

		if ( fFound = ( pbf != NULL ) )
			{
			Assert( err == JET_errSuccess || err == wrnBFCacheMiss );
			Assert( pbf->fHold );

			/* need to remove dependency before returned for overwrite
			/**/
			CallR( ErrBFIRemoveDependence( ppib, pbf, fBFWait ) );
			Assert( pbf->pbfDepend == pbfNil );
			}
		else if ( err == wrnBFPageNotFound )
			{
			CallR( ErrBFIAlloc( &pbf, fSync ) );
			}
		}
	while ( err == wrnBFNotSynchronous );
	
	AssertCriticalSection( critJet );
	if ( fFound )
		{
		Assert( pbf->fSyncRead == fFalse );
		Assert( pbf->fAsyncRead == fFalse );
		Assert( pbf->fSyncWrite == fFalse );
		Assert( pbf->fAsyncWrite == fFalse );
		/*  make sure no residue effects
		/**/
		BFResetIOError( pbf );

		BFEnterCriticalSection( pbf );
		if ( CmpLgpos( &pbf->lgposRC, &lgposRC ) > 0 )
			{
			Assert( pbf->fDirty || CmpLgpos( &pbf->lgposRC, &lgposMax ) == 0 );
			pbf->lgposRC = lgposRC;
			}
		BFLeaveCriticalSection( pbf );
		}
	else
		{
		if ( PbfBFISrchHashTable( pn, butBuffer ) != NULL )
			{
			/* release the buffer and return the found buffer */
			BFIReturnBuffers( pbf );
			goto Begin;
			}
		pbf->pn = pn;
		BFIInitializeUlBFTime( pbf );
		BFIInsertHashTable( pbf, butBuffer );
		Assert( pbf->fIOError == fFalse );

		BFEnterCriticalSection( pbf );
		Assert( CmpLgpos( &pbf->lgposRC, &lgposMax ) == 0 );
		pbf->lgposRC = lgposRC;
		BFLeaveCriticalSection( pbf );
		}

	/*  put allocated BF in LRUK heap
	/**/
	EnterCriticalSection(critLRUK);
	pbf->trxLastRef = ppib->trxBegin0;
	pbf->ulBFTime2 = 0;
	pbf->ulBFTime1 = UlUtilGetTickCount();
	BFLRUKAddToHeap( pbf );
	LeaveCriticalSection(critLRUK);

	Assert( fLogDisabled || fRecovering || !FDBIDLogOn(DbidOfPn( pn )) ||
			PgnoOfPn( pn ) == 0x01 ||
			CmpLgpos( &lgposRC, &lgposMax ) != 0 );

#ifdef COSTLY_PERF
	BFSetTableClass( pbf, 0 );
#endif  //  COSTLY_PERF

	AssertNotInCriticalSection( critLRUK );
	
	*ppbf = pbf;
	return err;
	}


/* paired with BFFree
/**/
ERR ErrBFAllocTempBuffer( BF **ppbf )
	{
	ERR     err = JET_errSuccess;
	BF      *pbf;

	AssertCriticalSection( critJet );

	while ( ( err = ErrBFIAlloc( &pbf, fSync ) ) == wrnBFNotSynchronous );
	if ( err < 0 )
		goto HandleError;
	Assert( pbf->pn == pnNull );

#ifdef COSTLY_PERF
		BFSetTableClass( pbf, 0 );
#endif  //  COSTLY_PERF

	*ppbf = pbf;

HandleError:
	AssertNotInCriticalSection( critLRUK );
	AssertCriticalSection( critJet );
	return err;
	}


/*  Discard a working buffer without saving contents.  BFFree makes the buffer
/*  immediately available to be reused.
/**/
VOID BFFree( BF *pbf )
	{
	AssertCriticalSection( critJet );

	Assert( pbf );
	Assert( pbf->pn == pnNull );
	Assert( pbf->fAsyncRead == fFalse );
	Assert( pbf->fSyncRead == fFalse );
	Assert( pbf->fAsyncWrite == fFalse );
	Assert( pbf->fSyncWrite == fFalse );
	Assert( pbf->fIOError == fFalse );

	/* take out from list
	/**/
	Assert( pbf->ipbfHeap == ipbfDangling );
	Assert( pbf->cDepend == 0 );
	Assert( pbf->pbfDepend == pbfNil );
#ifdef DEBUG
	BFEnterCriticalSection( pbf );
	Assert( CmpLgpos( &pbf->lgposRC, &lgposMax ) == 0 );
	BFLeaveCriticalSection( pbf );
#endif  //  DEBUG
	Assert( pbf->cPin == 0 );

	BFResetDirtyBit( pbf );
	EnterCriticalSection( critAvail );
	pbf->trxLastRef = trxMax;
	pbf->ulBFTime2 = 0;
	pbf->ulBFTime1 = 0;
	BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
	LeaveCriticalSection( critAvail );
	}


//  Maximum dependency chain length (preferred)
#define cBFDependencyChainLengthMax		( 8 )

ERR ErrBFDepend( BF *pbf, BF *pbfD )
	{
	BF		*pbfT;
	LONG	cDepend;

	AssertCriticalSection( critJet );

	/*  dependencies unnecessary for unlogged databases
	/**/
	if ( fLogDisabled || !FDBIDLogOn(DbidOfPn( pbf->pn )) )
		return JET_errSuccess;

	/*  already exists, this may happen after hardrestore, such
	/*  dependency is set, then when we redo soft restore, we will
	/*  see the dependcy exists.
	/**/
	if ( pbf->pbfDepend == pbfD )
		{
		Assert( pbfD->cDepend > 0 );
		return JET_errSuccess;
		}

	/*	pbfDepend will depend on us, it will not be flushed until after
	/*	pbf is flushed.
	/**/

	/*  check for dependency creating cycle.  Cycle will be created
	/*	if pbf already depends directly or indirectly on pbfD.
	/**/
	for( pbfT = pbfD, cDepend = 0; pbfT != pbfNil; pbfT = pbfT->pbfDepend, cDepend++ )
		{
		Assert( errDIRNotSynchronous < 0 );
		Assert( pbfT->pbfDepend != pbfD );
		if ( pbfT == pbf )
			return ErrERRCheck( errDIRNotSynchronous );
		}
		
	if ( pbf->pbfDepend )
		{
		/* depend on others already
		/**/
		return ErrERRCheck( errDIRNotSynchronous );
		}

	/*	set dependency
	/**/
	Assert( pbf->cWriteLatch );
	Assert( pbfD->cWriteLatch );
	pbf->pbfDepend = pbfD;
	UtilInterlockedIncrement( &pbfD->cDepend );

	/*  if this dependency chain is too long, mark head (this BF) as Very Old
	/*  so that if someone tries to add another BF, the read access will
	/*  break the chain
	/**/
	if ( cDepend > cBFDependencyChainLengthMax )
		{
		BFSetVeryOldBit( pbf );
		EnterCriticalSection( critLRUK );
		if ( FBFInLRUKHeap( pbf ) )
			BFLRUKUpdateHeap( pbf );
		LeaveCriticalSection( critLRUK );
		}

	return JET_errSuccess;
	}


/*  Lazily remove the dependencies of a BF, simply by queueing the heads of the
/*  dependency chains for write (if we can hold them).
/*
/*  NOTE:  There is no guarantee that calling this function will remove all the
/*         dependencies for a given BF, it merely attempts to do this lazily.
/**/
VOID BFDeferRemoveDependence( BF *pbf )
	{
	LONG	ibf;
	BF		*pbfT;
	ULONG	cDepend;
	
	AssertCriticalSection( critJet );
	Assert( pbf->cDepend );

	/*  loop through all BFs looking for heads to our dependency chain
	/**/
	for ( ibf = 0, cDepend = 0; ibf < pbgcb->cbfGroup; ibf++ )
		{
		/*  if we have already found all our heads, we're done
		/**/
		if ( cDepend == pbf->cDepend )
			break;
			
		/*  if this BF isn't the head of a chain, next
		/*
		/*  NOTE:  excludes BF from which we are removing the dependence
		/**/
		pbfT = pbgcb->rgbf + ibf;
		if ( pbfT->cDepend || pbfT->pbfDepend == pbfNil )
			continue;

		/*  if this BF isn't at the head of our chain, next
		/**/
		while( pbfT != pbf && pbfT != pbfNil )
			pbfT = pbfT->pbfDepend;
		if ( pbfT != pbf )
			continue;

		/*  we've found the head of one of our chains, so mark it as Very Old
		/**/
		pbfT = pbgcb->rgbf + ibf;
		BFSetVeryOldBit ( pbfT );
		cDepend++;
		
		/*  if we can't hold the BF, pass on this one
		/**/
		if ( !FBFHold( ppibNil, pbfT ) )
			continue;

		/*  if we can't write this BF, skip it
		/**/
		if ( !FBFIWritable( pbfT, fFalse, ppibNil ) )
			{
			EnterCriticalSection( critLRUK );
			BFLRUKAddToHeap( pbfT );
			LeaveCriticalSection( critLRUK );
			continue;
			}

		/*  AsyncWrite the very old BF.  BFIOComplete will follow the dependency
		/*  chain, removing all dependencies for this BF (eventually).  Note that
		/*  the Very Old flag will not allow this BF to be stolen before it is
		/*  cleaned.
		/**/
		EnterCriticalSection( critBFIO );
		BFIOAddToHeap(pbfT);
		LeaveCriticalSection( critBFIO );
		}
	}


ERR ErrBFRemoveDependence( PIB *ppib, BF *pbf, BOOL fNoWait )
	{
	ERR err;
	
	Assert( pbf->pn != pnNull );

	if ( ErrBFHoldByMe( ppib, pbf->pn, pbf ) == wrnBFNotSynchronous )
		return JET_errSuccess;
	
	err = ErrBFIRemoveDependence( ppib, pbf, fNoWait );
	Assert( pbf->fHold );

	/* put into lruk heap
	/**/
//	pbf->trxLastRef = ppib->trxBegin0;
//	pbf->ulBFTime2 = 0;
//	pbf->ulBFTime1 = UlUtilGetTickCount();
	EnterCriticalSection( critLRUK );
	BFLRUKAddToHeap( pbf );
	LeaveCriticalSection( critLRUK );

	return err;
	}

	
LOCAL ERR ErrBFIRemoveDependence( PIB *ppib, BF *pbf, BOOL fNoWaitBI )
	{
	ERR err = JET_errSuccess;
	INT cRemoveDependts = 0;
	INT cLoop = 0;
	BF *pbfSave = pbf;

	Assert( pbf->fHold );
	Assert( pbf->ipbfHeap == ipbfDangling );

RemoveDependents:
	cRemoveDependts++;

	/*  remove dependencies from buffers which depend upon pbf
	/**/
	cLoop = 0;
	Assert( err == JET_errSuccess );
	while ( pbf->cDepend > 0 && err == JET_errSuccess && cLoop < 100 )
		{
		BF  *pbfT;
		BF  *pbfTMax;

		cLoop++;

		AssertCriticalSection( critJet );

		for ( pbfT = pbgcb->rgbf, pbfTMax = pbgcb->rgbf + pbgcb->cbfGroup;
			  pbfT < pbfTMax;
			  pbfT++ )
			{
			INT	cGetDependedPage = 0;
			INT cmsec = 1;

GetDependedPage:
			if ( pbfT->pbfDepend != pbf )
				continue;

			/* make sure no one can move me after leave critLRU
			/**/
			BFEnterCriticalSection( pbfT );

			if ( fNoWaitBI && pbfT->prceDeferredBINext )
				{
				BFLeaveCriticalSection( pbfT);
				return wrnBFNotSynchronous;
				}

			if ( FBFInUse( ppib, pbfT ) )
				{
				BFLeaveCriticalSection( pbfT);

				cmsec <<= 1;
				if ( cmsec > ulMaxTimeOutPeriod )
					{
					if ( cGetDependedPage > 100 )
						return wrnBFNotSynchronous;
					else
						cmsec = ulMaxTimeOutPeriod;
					}
				BFSleep( cmsec - 1 );
				cGetDependedPage++;
				goto GetDependedPage;
				}
			BFLeaveCriticalSection( pbfT );

			if ( pbfT->pbfDepend != pbf )
				continue;

			Assert( pbfT->fDirty == fTrue );

			if ( ErrBFHold( ppib, pbfT->pn, pbfT ) == wrnBFNotSynchronous )
				continue;

			/* buffer may be clean when we hold it
			/**/
			if ( !pbfT->fDirty )
				{
				Assert( pbfT->fHold == fTrue );

				EnterCriticalSection( critAvail );
				BFAddToListAtMRUEnd(pbfT, &pbgcb->lrulist);
				LeaveCriticalSection( critAvail );

				continue;
				}

			/* if this page is writable
			/**/
			if ( !FBFIWritable( pbfT, fFalse, ppib ) )
				{
				if ( fLGNoMoreLogWrite )
					return JET_errLogWriteFail;

				/* can not write it now, lets flush pbfT dependent
				/* pages first.  Assign pbfT to pbf and start the
				/* remove dependency from begining of the loop.
				/**/
				pbf = pbfT;

				EnterCriticalSection(critLRUK);
				BFLRUKAddToHeap(pbfT);
				LeaveCriticalSection(critLRUK);

				if ( cRemoveDependts % 3 == 0 )
					SignalSend(sigLogFlush);
					
				/* remove all pbf dependents
				/**/
				BFSleep( cmsecWaitIOComplete );
				goto RemoveDependents;
				}

			/*  sync write buffer
			/**/
			BFSetSyncWriteBit( pbfT );
			BFIOSync( pbfT );
			BFResetSyncWriteBit( pbfT );

			if ( pbfT->fIOError || pbfT->cPin )
				{
				EnterCriticalSection( critLRUK );
				BFLRUKAddToHeap( pbfT );
				LeaveCriticalSection( critLRUK );
				if ( pbfT->fIOError )
					{
					err = pbfT->err;
					Assert( err < 0 );
					return err;
					}
				}
			else
				{
				EnterCriticalSection( critAvail );
				BFAddToListAtMRUEnd(pbfT, &pbgcb->lrulist);
				LeaveCriticalSection( critAvail );
				}
			}
		}

	if ( cLoop >= 100 )
		return wrnBFNotSynchronous;

	if ( pbf != pbfSave )
		{
		/* try again to remove all pbf dependents
		/**/
		pbf = pbfSave;
		goto RemoveDependents;
		}

	if ( err != JET_errSuccess )		
		return err;

	Assert( pbf->cDepend == 0 );
	Assert( pbf->pbfDepend == pbfNil || pbf->fDirty == fTrue );
	
//	Assert( CmpLgpos( &pbf->lgposModify, &lgposToFlush ) < 0 );

	/*	To do merge, we might need to merge the new page with split page. This
	 *	may cause cycle dependency. To reduce the possibility of rollback due to
	 *	cycle dependency, we simply write the page out if possible.
	 */
	while( fNoWaitBI ? pbf->fDirty : pbf->pbfDepend != pbfNil )
		{
		Assert( !pbf->fIOError );
		Assert( pbf->fDirty );

		BFEnterCriticalSection( pbf);
		if ( fNoWaitBI && pbf->prceDeferredBINext )
			{
			BFLeaveCriticalSection( pbf);
			return wrnBFNotSynchronous;
			}
		BFLeaveCriticalSection( pbf);

		if ( FBFIWritable( pbf, fFalse, ppib ) )
			{
			if ( fLGNoMoreLogWrite )
				return JET_errLogWriteFail;

			/* write the page out and remove dependency.
			/**/
			BFSetSyncWriteBit( pbf );
			BFIOSync( pbf );
			BFResetSyncWriteBit( pbf );

			Assert( pbf->fIOError || pbf->pbfDepend == pbfNil );

			if ( pbf->fIOError )
				err = pbf->err;
			break;
			}
		else if ( pbf->fIOError )
			{
			err = pbf->err;
			break;
			}

		/*	We must be waiting for BI log to be flushed. Signal log flush.
		 */
		if ( fNoWaitBI )
			return wrnBFNotSynchronous;

		if ( !fLogDisabled )
			{
			SignalSend(sigLogFlush);
			BFSleep( cmsecWaitGeneric );
			}
		}

	return err;
	}


/*	check if there is a chain of dependency on this page.
 *	If there is a long chain, then flush this page first.
 */
BOOL FBFCheckDependencyChain( BF *pbf )
	{
	BF *pbfT;
	INT cbfThreshold;
	INT cpbf;
	
	if ( !pbf->fDirty )
		return fFalse;
	
	/* check the dependency chain.
	 */
	cbfThreshold = rgres[iresBF].cblockAlloc - pbgcb->cbfThresholdLow;
	pbfT = pbf;
	cpbf = 0;
	while ( pbfT->pbfDepend && cpbf < cbfThreshold )
		{
		pbfT = pbfT->pbfDepend;
		cpbf++;
		}
		
	if ( cpbf == cbfThreshold )
		{
		/*	tell caller that he needs to wait till this page is flushed
		 */
		SignalSend( sigBFCleanProc );
		BFSleep( cmsecWaitGeneric );
		return fTrue;
		}

	return fFalse;
	}


/*	discard any page buffer associated with pn without saving contents.
/*	If pn is cached its buffer is made available to be reused.
/**/
VOID BFAbandon( PIB *ppib, BF *pbf )
	{
	DBID    dbid = DbidOfPn(pbf->pn);

	Assert( pbf->pn != pnNull );

	if ( ErrBFHoldByMe( ppib, pbf->pn, pbf ) == wrnBFNotSynchronous )
		return;

	AssertCriticalSection( critJet );
	BFIDeleteHashTable( pbf, butBuffer );
	pbf->pn = pnNull;

	Assert( pbf->cPin == 0 );
	Assert( pbf->fHold == fTrue );
	Assert( pbf->fSyncRead == fFalse );
	Assert( pbf->fSyncWrite == fFalse );

	Assert( pbf->ipbfHeap == ipbfDangling );

	Assert( pbf->cDepend == 0 );
	Assert( pbf->pbfDepend == pbfNil );
	
	BFResetDirtyBit( pbf );
	BFResetIOError( pbf );
	Assert( fRecovering || pbf->cWriteLatch == 0 );

	EnterCriticalSection( critAvail );
	pbf->trxLastRef = trxMax;
	pbf->ulBFTime2 = 0;
	pbf->ulBFTime1 = 0;
	BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
	LeaveCriticalSection( critAvail );

#ifdef COSTLY_PERF
	BFSetTableClass( pbf, 0 );
#endif  //  COSTLY_PERF

	AssertNotInCriticalSection( critLRUK );
	return;
	}


//  This function purges buffers belonging to a dbid

VOID BFPurge( DBID dbid )
	{
	BF     *pbfT;
	BF     *pbfMax;

	AssertCriticalSection( critJet );

	/*	check if BFPurge is called after buffer manager is terminated.
	 */
	if ( pbgcb == NULL )
		return;

	pbfT = pbgcb->rgbf;
	pbfMax = pbgcb->rgbf + pbgcb->cbfGroup;
	for ( ; pbfT < pbfMax; pbfT++ )
		{
		Assert( pbfT->pn != pnNull || pbfT->cDepend == 0 );

		/*  do not purge dirty BFs information if logging is enabled. We still
		 *	need to flush the buffer for recovery to redo, and keep lgposRC for
		 *	checkpoint calculation.
		 */
		
		if ( !fLogDisabled && FDBIDLogOn(DbidOfPn( pbfT->pn ) ) && pbfT->fDirty )
			{
			/*	UNDONE: Set high priority for replacement.
			 */
			continue;
			}
			
		if ( pbfT->pn != pnNull && DbidOfPn( pbfT->pn ) == dbid )
			{
			BFAbandon( ppibNil, pbfT );
			}
		}

	AssertCriticalSection( critJet );
	}


//  Reprioritizes the given BF for immediate overlay.  Will not change the
//  priority of a BF when it is dirty or in use.

VOID BFTossImmediate( PIB *ppib, BF *pbf )
	{
	Assert( pbf != pbfNil );
	AssertCriticalSection( critJet );

	//  if this BF is dirty or in use do not change its priority

	if ( pbf->fDirty || pbf->cWriteLatch || !FBFHold( ppib, pbf ) )
		return;

	//  Move BF to the avail list, making it available for immediate
	//  overlay.  We DO NOT change the BFs access history so that if
	//  we access it again before it is overlayed, we will still have
	//  stats on its mean reference interval.

	EnterCriticalSection( critAvail );
	BFAddToListAtMRUEnd( pbf, &pbgcb->lrulist );
	LeaveCriticalSection( critAvail );

	AssertCriticalSection( critJet );
	}


/*      This function returns a free buffer.
/*      Scans LRU list (leading part) for clean buffer. If none available,
/*      clean up LRU list, and return errBFNotsynchronous if some pages are
/*      cleaned and available, or return out of memory if all buffers are
/*      used up. If caller got errBFNotSychronous, it will try to alloca again.
/**/
LOCAL ERR ErrBFIAlloc( BF **ppbf, BOOL fSyncMode )
	{
	BF		*pbf;
#define ierrbfcleanMax	100
	INT		ierrbfclean = 0;

Start:
	AssertCriticalSection( critJet );

	if ( pbgcb->lrulist.cbfAvail < pbgcb->cbfThresholdLow )
		{
		SignalSend( sigBFCleanProc );
//		if ( fSyncMode != fAsync )
//			{
//			/*	Give BFClean a chance to clean.
//			 */
//			BFSleep( 0 );
//			}
		}

	/*      look for clean buffers on LRU list
	/**/
	EnterCriticalSection( critAvail );
	for ( pbf = pbgcb->lrulist.pbfLRU; pbf != pbfNil; pbf = pbf->pbfLRU )
		{
		Assert( pbf->cDepend == 0 );

		BFEnterCriticalSection( pbf );
		if ( !FBFInUse( ppibNil, pbf ) )
			{
			pbf->fHold = fTrue;
			
			Assert( pbf->fDirty == fFalse );
			Assert( pbf->fVeryOld == fFalse );
			Assert( pbf->fAsyncRead == fFalse );
			Assert( pbf->fSyncRead == fFalse );
			Assert( pbf->fAsyncWrite == fFalse );
			Assert( pbf->fSyncWrite == fFalse );
			Assert( pbf->fIOError == fFalse );
			Assert( pbf->cPin == 0 );
			Assert( pbf->cDepend == 0 );
			Assert( pbf->pbfDepend == pbfNil );
			pbf->lgposRC = lgposMax;
			pbf->lgposModify = lgposMin;
			BFLeaveCriticalSection( pbf );

			*ppbf = pbf;
			
			if ( pbf->pn != pnNull )
				{
				/*	put the buffer's history to HISTORY heap.
				 */

				BF *pbfH;

				BFIDeleteHashTable( pbf, butBuffer );
				
				EnterCriticalSection( critHIST );

				if ( FBFHISTHeapFull() )
					{
					/*	delete the one on the top and replace it with
					 *	this pbf and adjust the heap.
					 */
					if ( pbf->ulBFTime1 <= rgpbfHISTHeap[0]->hist.ulBFTime )
						{
						/*	This is an old buffer! throw away the history.
						 */
						goto EndOfUpdateHistory;
						}
#ifdef DEBUG
//					Assert( rgpbfHISTHeap[0]->hist.ulBFTime >= ulBFTimeHISTLastTop );
//					ulBFTimeHISTLastTop = rgpbfHISTHeap[0]->hist.ulBFTime;
#endif
					pbfH = PbfBFHISTTopOfHeap( );
					BFIDeleteHashTable( pbfH, butHistory );
					pbfH->hist.ipbfHISTHeap = 0;
					}
				else
					{
					/*	get next free hist entry.
					 */
					pbfH = rgpbfHISTHeap[ ipbfHISTHeapMac ];
					pbfH->hist.ipbfHISTHeap = ipbfHISTHeapMac;
					ipbfHISTHeapMac++;
					}
				
				pbfH->hist.pn = pbf->pn;
				pbfH->hist.ulBFTime = pbf->ulBFTime1;

				BFIInsertHashTable( pbfH, butHistory );
				BFHISTUpdateHeap( pbfH );

EndOfUpdateHistory:
				LeaveCriticalSection( critHIST );

				pbf->pn = pnNull;
				}

			BFTakeOutOfList( pbf, &pbgcb->lrulist );
			LeaveCriticalSection( critAvail );
			
			return JET_errSuccess;
			}
		BFLeaveCriticalSection( pbf );
		}
	LeaveCriticalSection( critAvail );

	if ( fSyncMode == fAsync )
		return ErrERRCheck( wrnBFNoBufAvailable );

	/*	There is no buffer for us, do async clean up and
	/*	retry 100 times. If still fail, we treat it as out of memory!
	/**/
	SignalSend( sigBFCleanProc );
	BFSleep( cmsecWaitGeneric );
	ierrbfclean++;
		
	if ( ierrbfclean < ierrbfcleanMax )
		goto Start;

	return JET_errOutOfMemory;
	}


/* conditions to Write a buffer
/**/
INLINE BOOL FBFIWritable( BF *pbf, BOOL fSkipBufferWithDeferredBI, PIB *ppibAllowedWriteLatch )
	{
	BOOL f;

	Assert( pbf->fHold );

	/* no one is depending on it
	/**/
	BFEnterCriticalSection( pbf );
	Assert( !FDBIDReadOnly(DbidOfPn( pbf->pn ) ) );
	f = (	( pbf->cWriteLatch == 0 || pbf->ppibWriteLatch == ppibAllowedWriteLatch ) &&
			pbf->pn != pnNull &&		/* valid page number */
			pbf->fDirty &&				/* being dirtied */
			pbf->cDepend == 0 &&
			
			/*	if not very old and skip buffer with DeferredBI, then just check
			 *	BI chain exist or not, otherwise RemoveDeferredBI later.
			 */
			( ( !fSkipBufferWithDeferredBI || pbf->fVeryOld ) || !pbf->prceDeferredBINext )
		);
	BFLeaveCriticalSection( pbf );
	
#ifndef NO_LOG
	if ( f &&
		!fLogDisabled &&
		FDBIDLogOn(DbidOfPn( pbf->pn )) &&
		!FDBIDReadOnly(DbidOfPn( pbf->pn ) ) )
		{
		/*	put as many before image there as possible. If Log IO needed, abort it.
		 *	Must be called before lgposToFlush is checked.
		 */
		if ( !fSkipBufferWithDeferredBI || pbf->fVeryOld )
			f = ( ErrBFIRemoveDeferredBI( pbf ) == JET_errSuccess );

		/*	if log is on, make sure log record of last
		 *	operation on the page has flushed. This is for both regular run and
		 *	recovery's undo phase.
		 */
		if ( f && ( !fRecovering || fRecoveringMode == fRecoveringUndo ) )
			{
			LGPOS lgposModify;

			BFEnterCriticalSection( pbf );
			lgposModify = pbf->lgposModify;
			BFLeaveCriticalSection( pbf );
			
			EnterCriticalSection( critLGBuf );
			f = ( CmpLgpos( &lgposModify, &lgposToFlush ) < 0 );
			LeaveCriticalSection( critLGBuf );
			if ( !f  &&  fLGNoMoreLogWrite )
				{
				BFSetIOError( pbf, JET_errLogWriteFail );
				}
			}
		}

#ifdef DEBUG
	BFEnterCriticalSection( pbf );
	Assert( !f ||
			fLogDisabled || fRecovering || !FDBIDLogOn(DbidOfPn( pbf->pn )) ||
			PgnoOfPn( pbf->pn ) == 0x01 ||
			CmpLgpos( &pbf->lgposRC, &lgposMax ) != 0 );
	BFLeaveCriticalSection( pbf );
#endif  //  DEBUG
#endif  //  !NO_LOG

	return f;
	}


/*  Issues reads or writes for buffers in the IO Heap.  The buffer will be
/*  written to page pn if it is dirty or will be read from page pn if it is clean.
/**/
VOID BFIOIssueIO( VOID )
	{
	ERR		err;
	BOOL	fTooManyIOs = fFalse;
	BOOL	fIOIssued = fFalse;
	BOOL	fWrite;
	CPG		cpgRun;
	BF		*pbfTail;
	BF		*pbfIOTail;
	BF		*pbf;
	BOOL	fMember;
	BF		*pbfHead;
	BF		*pbfNextHead;
	BF		*pbfT;
	OLP		*polp;
	CPG		cpgIO;
	LONG	ipageBatchIO;
	LONG	cmsec;
	LONG	ipage;
	HANDLE	hf;
	BYTE	*pb;
	LONG	cb;
	PGNO	pgnoT;

	/*  Issue the specified number of Async IOs from the IO heap
	/**/
	while ( !fTooManyIOs )
		{
		BOOL fRangeLocked = fFalse;

		EnterCriticalSection( critBFIO );
		if ( FBFIOHeapEmpty() )
			{
			LeaveCriticalSection( critBFIO );
			break;
			}
		
		/*  collect a run of BFs with continuous PNs that are the same IO type
		/*  (read vs write) into a linked list ( dirty == write, !dirty == read )
		/*
		/*  NOTE:  We do not need to verify that a run is only in one DBID because
		/*         pgnoNull breaks any runs that could form between PNs with different
		/*         DBIDs (i.e. 0x02FFFFFF - 0x03000001 is not a run as 0x03000000 is
		/*         an invalid PN and will never exist).
		/**/
		cpgRun = 0;
		pbfTail = pbfNil;
		do	{
			pbf = PbfBFIOTopOfHeap();

			BFEnterCriticalSection( pbf );

			/*	must check if someone (AccessPage) trying to steal the buffer
			 *	from BFIO Heap. The check fHold instead fBFInUse since the
			 *	buffer may have fSyncRead/Write flag set already.
			 */
			if ( pbf->fHold )
				{
				BFLeaveCriticalSection( pbf );
				fMember = fFalse;
				}
			else
				{
				fMember = fTrue;
				
				if ( pbf->fDirty && !pbf->fSyncWrite )
					{
					pbf->fHold = fTrue;
					BFLeaveCriticalSection( pbf );

					if ( FBFRangeLocked( &rgfmp[ DbidOfPn( pbf->pn ) ], PgnoOfPn( pbf->pn ) ) )
						{
						/*	can not do asynch write on this page yet. Put it back to
						 *	LRUK Heap
						 */
						BFIOTakeOutOfHeap( pbf );

						LeaveCriticalSection( critBFIO );
						EnterCriticalSection(critLRUK);
						BFLRUKAddToHeap( pbf );
						LeaveCriticalSection(critLRUK);
						EnterCriticalSection( critBFIO );
				
						fMember = fFalse;
						}
						
					else
						{
						// Reclain critical section and reset hold.
						BFEnterCriticalSection( pbf );
						pbf->fHold = fFalse;
						}
					}
					
				if ( fMember )
					{
					//  set IO direction
					if ( pbf->pn != pnLastIO )
						iDirIO = pbf->pn - pnLastIO;
			
					Assert( pbf->pn );
					Assert( !pbf->fHold );
					Assert( pbf->fDirectRead || !pbf->cDepend );
					Assert( PgnoOfPn( pbf->pn ) != pgnoNull );

					/*	DirectRead should be issued alone. Break away if head is direct read
					 *	or the next is entry is direct read.
					 */
					fMember =	( pbfTail == pbfNil ||
								  ( !pbfHead->fDirectRead &&
									!pbf->fDirectRead &&
									( pbf->pn == pbfTail->pn + 1 || pbf->pn == pbfTail->pn - 1 ) &&
									pbf->fDirty == pbfTail->fDirty
								  )
								);
					if ( fMember )
						{
						pbf->fHold = fTrue;
						BFLeaveCriticalSection( pbf );
						
						/*  take member BF out of heap and set flags for IO
						/**/
						BFIOTakeOutOfHeap( pbf );
						if ( pbf->fDirty && !pbf->fSyncWrite )
							BFSetAsyncWriteBit( pbf );

						/*  add BF to run
						/**/
						if ( pbfTail == pbfNil )
							pbfHead = pbf;
						else
							pbfTail->pbfNextBatchIO = pbf;
						pbfTail = pbf;
						pbfTail->pbfNextBatchIO = pbfNil;
						cpgRun++;
						}
					else
						{
						BFLeaveCriticalSection( pbf );
						}
					}
				}
			
			}
		while ( fMember && !FBFIOHeapEmpty() && cpgRun < ipageBatchIOMax / 4 );
		LeaveCriticalSection( critBFIO );

		if ( cpgRun == 0 )
			{
			/*	The top element is being stolen by other thread. Sleep as short
			 *	as possible, but long enough for the buffer taken out by the thread.
			 */
			UtilSleepEx(1, fTrue);
			continue;
			}

		/*  loop to perform IO on current run in as many chunks as is necessary
		/**/
		do	{
			/*  Allocate an OLP for Async IO.  If none are available, we will not
			/*  issue another IO.
			/**/
			if ( ErrBFOLPAlloc( &polp ) != JET_errSuccess )
				{
				fTooManyIOs = fTrue;
				break;
				}

			/*  if we have more than one buffer, try to allocate batch IO buffers
			/*  for as many continuous pages as possible
			/**/
			ipageBatchIO = -1;
			cpgIO = cpgRun;
			if ( cpgRun > 1 )
				{
				BFIOAllocBatchIOBuffers( &ipageBatchIO, &cpgIO );
				
				/*  we are out of batch IO buffers, so stop issuing IOs
				/**/
				if ( ipageBatchIO == -1 )
					{
					BFOLPFree( polp );
					fTooManyIOs = fTrue;
					break;
					}
				}

			/*  prepare all BFs for IO
			/**/
			pbf = pbfHead;
			for ( ipage = 0; ipage < cpgIO; ipage++ )
				{
				Assert( pbf->prceDeferredBINext == prceNil );
				Assert( (!pbf->fSyncRead && !pbf->fAsyncRead) || pbf->ulBFTime2 == 0 );

				/*  prepare dirty BF for write
				/**/
				if ( pbf->fDirty )
					{
					/*  update the page checksum
					/**/
					Assert( QwPMDBTime( pbf->ppage ) != qwDBTimeNull );
#ifdef  CHECKSUM
					pbf->ppage->ulChecksum = UlUtilChecksum( (BYTE *)pbf->ppage, sizeof(PAGE) );
					Assert( fRecovering ||
						DbidOfPn( (pbf)->pn ) == dbidTemp ||
						QwPMDBTime( pbf->ppage ) );
				
					CheckPgno( pbf->ppage, pbf->pn ) ;
#endif  //  CHECKSUM
					}
				
				/*  handle batch IO
				/**/
				if ( ipageBatchIO != -1 )
					{
					/*  set batch IO page
					/**/
					Assert( pbfHead->pn != pbfTail->pn );
					if ( pbfHead->pn < pbfTail->pn )
						pbf->ipageBatchIO = ipageBatchIO + ipage;
					else
						pbf->ipageBatchIO = ipageBatchIO + ( cpgIO - 1 ) - ipage;
					Assert( pbf->ipageBatchIO >= 0 );
					Assert( pbf->ipageBatchIO < ipageBatchIOMax );

					/*  copy dirty BF to batch IO buffer
					/**/
					if ( pbf->fDirty )
						memcpy( rgpageBatchIO + pbf->ipageBatchIO, pbf->ppage, cbPage );
					}

				/*  for non-batch IO, set page to -1
				/**/
				else
					pbf->ipageBatchIO = -1;

				/*  get head of next sub-run
				/**/
				if ( ipage + 1 == cpgIO )
					{
					pbfIOTail = pbf;
					pbfNextHead = pbf->pbfNextBatchIO;
					pbf->pbfNextBatchIO = pbfNil;
					}

				pbf = pbf->pbfNextBatchIO;
				}

			/*  set last IO reference for the IO heap while still in critBFIO
			/**/
			pnLastIO = pbfIOTail->pn;
			
			/*  determine if we need to perform a patch write later
			/**/
			if ( pbfHead->fAsyncWrite || pbfHead->fSyncWrite )
				{
				BOOL fAppendPatchFile = fFalse;
				FMP *pfmp = &rgfmp[DbidOfPn( pbfHead->pn )];
				
				EnterCriticalSection( pfmp->critCheckPatch );
				
				for ( pbf = pbfHead; pbf != pbfNil; pbf = pbf->pbfNextBatchIO )
					{
					Assert( pbf->fDirty );
					Assert( pbf->cDepend == 0 );
					Assert(	!FBFIRangeLocked( &rgfmp[ DbidOfPn(pbf->pn) ], PgnoOfPn(pbf->pn) ) );

					/*  this write wasn't to the patch file, so we need to determine if
					/*  we need to reissue this write to the patch file
					/**/
					if ( FBFIPatch( pfmp, pbf ) )
						{
						fAppendPatchFile = fTrue;
						}
					
#ifdef DEBUG
					if ( fDBGTraceBR &&
						 pfmp->hfPatch != handleNil &&
						 pbf->pbfDepend )
						{
						char sz[256];
						sprintf( sz, "CP %s %ld:%ld->%ld:%ld(%lu) %X(%lu) %X(%lu)",
								fAppendPatchFile ? "Patch" : "NoPatch",
								DbidOfPn( pbf->pn ), PgnoOfPn( pbf->pn ),
								DbidOfPn( pbf->pbfDepend->pn), PgnoOfPn( pbf->pbfDepend->pn ),
								pbf->pbfDepend->cDepend,
								pfmp->pgnoMost,
								pfmp->pgnoMost,
								pfmp->pgnoCopyMost,
								pfmp->pgnoCopyMost);
						CallS( ErrLGTrace2( ppibNil, sz ) );
						}
#endif
					}

				BFEnterCriticalSection( pbfHead );
				pbfHead->fNeedPatch = fAppendPatchFile;
				BFLeaveCriticalSection( pbfHead );
				if ( fAppendPatchFile )
					{
					pfmp->cPatchIO++;
					}
				
				LeaveCriticalSection( pfmp->critCheckPatch );
				}

			/*  issue Async IO
			/**/
			fWrite				= pbfHead->fDirty;
			hf					= rgfmp[DbidOfPn( pbfHead->pn )].hf;
			if ( pbfHead->fDirectRead )
				{
				/*	Set direct read to read into user's buffer.
				 */
				pb = (BYTE *)pbfHead->ppageDirectRead;
				cb = cbPage * pbfHead->cpageDirectRead;
				pgnoT = PgnoOfPn( pbfHead->pn );
				}
			else
				{
				pb				= (BYTE *) (	ipageBatchIO == -1 ?
												pbfHead->ppage :
												rgpageBatchIO + ipageBatchIO );
				cb				= cbPage * cpgIO;
				pgnoT			= min( PgnoOfPn( pbfHead->pn ), PgnoOfPn( pbfIOTail->pn ) );
				}
			polp->Offset		= LOffsetOfPgnoLow( pgnoT );
			polp->OffsetHigh	= LOffsetOfPgnoHigh( pgnoT );
			//  save pointer to buffer for use in callback function
			polp->hEvent		= (HANDLE) pbfHead;

			cmsec = 1 << 3;
			while ( ( err = fWrite ?
					ErrUtilWriteBlockEx( hf, pb, cb, polp, BFIOComplete ) :
					ErrUtilReadBlockEx( hf, pb, cb, polp, BFIOComplete ) ) < 0 )
				{
				/*  issue failed but we haven't issued an IO yet this call, so
				/*  we must try again
				/**/
				if ( !fIOIssued && err == JET_errTooManyIO )
					{
					cmsec <<= 1;
					if ( cmsec > ulMaxTimeOutPeriod )
						cmsec = ulMaxTimeOutPeriod;
					UtilSleepEx( cmsec - 1, fTrue );
					}

				/*  issue failed for good
				/**/
				else
					{
					/*  free resources
					/**/
					if ( ipageBatchIO != -1 )
						BFIOFreeBatchIOBuffers( ipageBatchIO, cpgIO );
					BFOLPFree( polp );

					/*  if we failed due to too many IO, stop issuing
					/**/
					if ( err == JET_errTooManyIO )
						{
						fTooManyIOs = fTrue;
						goto ReturnRun;
						}

					/*  if this was to be a read, put the destination buffers
					/*  back into the Avail list
					/**/
					if ( !fWrite )
						{
						EnterCriticalSection( critJet );
						BFIOReturnReadBuffers( pbfHead, cpgIO, err );
						LeaveCriticalSection( critJet );
						}

					/*  if this was to be a write, put the dirty buffers back
					/*  into the LRUK heap
					/**/
					else
						{
						Assert( !pbfHead->fPatch || pbfHead->fNeedPatch );
						if ( pbfHead->fNeedPatch )
							{
							FMP *pfmp = &rgfmp[DbidOfPn( pbfHead->pn )];

							BFEnterCriticalSection( pbfHead );
							pbfHead->fNeedPatch = fFalse;
							pbfHead->fPatch = fFalse;
							BFLeaveCriticalSection( pbfHead );

							// UNDONE: log event to indicate it is DB write fail or
							// UNDONE: patch write fail (fPatch is true)
							EnterCriticalSection( pfmp->critCheckPatch );
							pfmp->errPatch = err;
							pfmp->cPatchIO--;
							LeaveCriticalSection( pfmp->critCheckPatch );
							}
						/*  put dirty buffers back in LRUK heap
						/**/
						BFIOReturnWriteBuffers( pbfHead, cpgIO, err );
						}

					/*  we're done with this IO
					/**/
					break;
					}
				}

			/*  keep track of IO issue stats
			/**/
			if ( err == JET_errSuccess )
				{
				if ( fWrite )
					cBFOutstandingWrites++;
				else
					cBFOutstandingReads++;
				fIOIssued = fTrue;
				}

			/*  advance head of run list by amount of IO just processed
			/**/
			cpgRun -= cpgIO;
			pbfHead = pbfNextHead;
			}
		while ( cpgRun > 0 );

		/*  if there is any of this run left over, put it back in the IO heap
		/*  because we can't issue any more IOs
		/**/
ReturnRun:
		Assert( !cpgRun || fTooManyIOs );
		
		EnterCriticalSection( critBFIO );
		while ( cpgRun-- )
			{
			pbfT = pbfHead;
			pbfHead = pbfHead->pbfNextBatchIO;

			if ( pbfT->fAsyncWrite )
				BFResetAsyncWriteBit( pbfT );
			BFIOAddToHeap( pbfT );
			}
		Assert( pbfHead == pbfNil );
		LeaveCriticalSection( critBFIO );
		}
	}


/*  Async IO callback routine (called when IO has been processed)
/**/
LOCAL VOID __stdcall BFIOComplete( LONG error, LONG cb, OLP *polp )
	{
	ERR		err;
	//  recover buffer pointer saved in OLP
	BF      *pbfHead = (BF *) polp->hEvent;
	BF		*pbfTail;
	FMP		*pfmp = rgfmp + DbidOfPn( pbfHead->pn );
	BF		*pbfNextBatchIO;
	LONG	ipageBatchIO;
	CPG		cpgIO;
	BF		*pbf;
	PAGE	*ppage;
	BOOL	fAppendPatchFile;
	BOOL	fVeryOld;
#if defined( DEBUG ) || defined( PERFDUMP )
	char	szT[64];
#endif

	/*  keep track of IO issue stats
	/**/
	if ( pbfHead->fDirty )
		cBFOutstandingWrites--;
	else
		cBFOutstandingReads--;

	/*  free OLP and issue more IO immediately
	/**/
	BFOLPFree( polp );
	if ( !pbfHead->fNeedPatch )
		{
		BFIOIssueIO();
		}

	/*  calculate batch IO size and dump debug info
	/**/
	cpgIO = 0;
	for ( pbf = pbfHead; pbf != pbfNil; pbf = pbf->pbfNextBatchIO )
		{
		pbfTail = pbf;
		cpgIO++;
		
#ifdef DEBUG
		Assert( (!pbf->fSyncRead && !pbf->fAsyncRead) || pbf->ulBFTime2 == 0 );

		BFEnterCriticalSection( pbf );
		Assert( pbf->pn );
		Assert(	pbf->pbfNextBatchIO == pbfNil ||
				pbf->pn + 1 == pbf->pbfNextBatchIO->pn ||
				pbf->pn - 1 == pbf->pbfNextBatchIO->pn );
		Assert(	pbf->pbfNextBatchIO == pbfNil ||
				pbf->fDirty == pbf->pbfNextBatchIO->fDirty );
		BFLeaveCriticalSection( pbf );
#endif

#if defined( DEBUG ) || defined( PERFDUMP )
		sprintf(	szT,
					"   IO:  type %s  pn %ld.%ld",
					pbf->fDirty ? "AW" : "AR",
					DbidOfPn(pbf->pn),
					PgnoOfPn(pbf->pn) );
		UtilPerfDumpStats( szT );
#endif

#ifdef DEBUGGING
		FPrintF2(" (%d,%d) ", DbidOfPn(pbf->pn), PgnoOfPn(pbf->pn));
#endif
		}

#ifdef DEBUGGING
		FPrintF2(" -- %d\n", cpgIO );
#endif

#if defined( DEBUG ) || defined( PERFDUMP )
	sprintf(	szT,
				"   IO:  type %s  cpg %ld",
				pbfHead->fDirty ? "AW" : "AR",
				cpgIO );
	UtilPerfDumpStats( szT );
#endif

	ipageBatchIO = min( pbfHead->ipageBatchIO, pbfTail->ipageBatchIO );

	/*  check if IO was successful. If direct read, check the direct read buffer size.
	/**/
	if ( error ||
		 ( !pbfHead->fDirectRead ?
				( cb != (INT) cbPage * cpgIO ) : ( cb != (INT) ( cbPage * pbfHead->cpageDirectRead ) )
		 )
	   )
	    {
		BYTE	sz1T[256];
		BYTE	sz2T[256];
		char	*rgszT[3];

		rgszT[0] = rgfmp[DbidOfPn(pbfHead->pn)].szDatabaseName;

		/*	log information for win32 errors.
		 */
		err = ErrERRCheck( JET_errDiskIO );

		if ( error )
			{
			/*	during redo time, we may read out of EOF */
			if ( !( pbfHead->fSyncRead && fRecovering && fRecoveringMode == fRecoveringRedo ) )
				{
				sprintf( sz1T, "%d", error );
				rgszT[1] = sz1T;
				UtilReportEvent( EVENTLOG_ERROR_TYPE, BUFFER_MANAGER_CATEGORY,
							 DB_FILE_SYS_ERROR_ID, 2, rgszT );
				}
			}
		else
			{
			sprintf( sz1T, "%d", !pbfHead->fDirectRead ?
					 ((INT) cbPage * cpgIO) : ((INT) ( cbPage * pbfHead->cpageDirectRead )) );
			sprintf( sz2T, "%d", cb );
			rgszT[1] = sz1T;
			rgszT[2] = sz2T;
			UtilReportEvent( EVENTLOG_ERROR_TYPE, BUFFER_MANAGER_CATEGORY,
							 DB_IO_SIZE_ERROR_ID, 3, rgszT );

			if ( pbfHead->fDirectRead )
				{
				err = ErrERRCheck( wrnBFNotSynchronous );
				goto ReadIssueFailed;
				}
			}
	    }
	else
		err = JET_errSuccess;

	/*  IO was successful
	/**/
	if ( err >= 0 )
		{
		/*  successful read
		/**/
		if ( !pbfHead->fDirty )
			{
			/*  monitor statistics. Direct read is a sync read.
			/**/
			if ( pbfHead->fSyncRead || pbfHead->fDirectRead )
				cBFSyncReads++;
			else
				cBFAsyncReads++;
			cbBFRead += cb;

			/*	if DirectRead, validate data here.
			 */
			if ( pbfHead->fDirectRead )
				{
//#ifdef DEBUG
#ifdef CHECKSUM
				/*	For each read page, check the checksum.
				 */
				PGNO pgnoCur = PgnoOfPn( pbfHead->pn );
				PAGE *ppageCur = pbfHead->ppageDirectRead;
				PAGE *ppageMax = ppageCur + pbfHead->cpageDirectRead;

				for ( ; ppageCur < ppageMax; ppageCur++, pgnoCur++ )
					{
					ULONG ulChecksum;
					ULONG ulPgno;

					LFromThreeBytes( &ulPgno, &ppageCur->pgnoThisPage );
					ulChecksum = UlUtilChecksum( (BYTE*)ppageCur, sizeof(PAGE) );
					if ( ulPgno == pgnoNull && ulChecksum == ulChecksumMagicNumber )
						{
						/*	Read an uninitialized page.
						 */
						continue;
						}

					if ( ulPgno != pgnoCur || ulChecksum != ppageCur->ulChecksum )
						{
						QWORDX qwx;
						BYTE	szT[256];
						char	*rgszT[1];

						err = ErrERRCheck( JET_errReadVerifyFailure );

						qwx.qw = QwPMDBTime( ppageCur );
						sprintf( szT,
								 "%d ((%d:%lu) (%lu-%lu), %lu %lu %lu )",
								 err,
								 DbidOfPn(pbfHead->pn),
								 pgnoCur,
								 qwx.h,
								 qwx.l,
								 ulPgno,
								 ppageCur->ulChecksum,
								 ulChecksum );

						rgszT[0] = szT;
						UtilReportEvent( EVENTLOG_ERROR_TYPE, BUFFER_MANAGER_CATEGORY,
							A_DIRECT_READ_PAGE_CORRUPTTED_ERROR_ID, 1, rgszT );

						EnterCriticalSection( critJet );
						BFIOReturnReadBuffers( pbfHead, 1, err );
						LeaveCriticalSection( critJet );
						break;
						}
					}
#endif  /* CHECKSUM */

				/*	Signal the waiting DirectRead function.
				 */
				SignalSend( pbfHead->sigSyncIOComplete );
				}

			else
				{
				/*  validate data between BF and batch IO buffers (if used)
				/**/
#ifdef DEBUG
				for ( pbf = pbfHead; pbf != pbfNil; pbf = pbf->pbfNextBatchIO )
					{
					PGNO	pgno;

					Assert( pbf->fAsyncRead || pbf->fSyncRead || pbf->fDirectRead );
					Assert( !pbf->fAsyncWrite );
					Assert( !pbf->fSyncWrite );
					Assert( !pbf->fDirty );
					
					Assert( pbf->prceDeferredBINext == prceNil );
				
					if ( pbf->ipageBatchIO != -1 )
						{
						LFromThreeBytes( &pgno, &( rgpageBatchIO[pbf->ipageBatchIO].pgnoThisPage ) );
						Assert( pgno == pgnoNull || pgno == PgnoOfPn( pbf->pn ) );
						}
					}
#endif

				/*  move data to destination buffers
				/**/
				for ( pbf = pbfHead; pbf != pbfNil; pbf = pbfNextBatchIO )
					{
					pbfNextBatchIO = pbf->pbfNextBatchIO;

					/*  Monitor statistics for AsyncReads only.  Sync Read stats are
					/*  kept via ErrBFIAccessPage.
					/**/
					if ( pbf->fAsyncRead )
						{
#ifdef COSTLY_PERF
						cBFPagesRead[pbf->lClass]++;
#else  //  !COSTLY_PERF
						cBFPagesRead++;
#endif  //  COSTLY_PERF
						}

					/*  get pointer to page data
					/**/
					if ( ipageBatchIO == -1 )
						{
						ppage = pbf->ppage;
						Assert( pbf->ipageBatchIO == -1 );
						Assert( pbfNextBatchIO == pbfNil );
						}
					else
						{
						Assert( pbf->ipageBatchIO >= 0 );
						Assert( pbf->ipageBatchIO < ipageBatchIOMax );
						ppage = rgpageBatchIO + pbf->ipageBatchIO;
						}

#ifdef DEBUG
					BFEnterCriticalSection( pbf );
					Assert( pbf->fDirty == fFalse );
					Assert( pbf->ipbfHeap == ipbfDangling );
					BFLeaveCriticalSection( pbf );
#endif

					/*	validate page data
					/**/
#ifdef CHECKSUM
					{
					ULONG ulChecksum = UlUtilChecksum( (BYTE*)ppage, sizeof(PAGE) );
					ULONG ulPgno;

					LFromThreeBytes( &ulPgno, &ppage->pgnoThisPage );
					if ( ulChecksum != ppage->ulChecksum ||
						 ulPgno != PgnoOfPn( pbf->pn ) )
						{
						err = ErrERRCheck( JET_errReadVerifyFailure );
//						AssertSz( ulPgno == pgnoNull, "Read Verify Failure" );
						EnterCriticalSection( critJet );
						BFIOReturnReadBuffers( pbf, 1, err );
						LeaveCriticalSection( critJet );
						continue;
						}
					}
#endif  //  CHECKSUM
					Assert( QwPMDBTime( ppage ) != qwDBTimeNull );

					/*  validate page time
					/**/
					if ( !fRecovering &&
						 DbidOfPn( pbf->pn ) != dbidTemp &&
						 QwPMDBTime( ppage ) == 0 )
						{
						/*	during redo time, we may read bad pages */
						if ( !( pbfHead->fSyncRead && fRecovering && fRecoveringMode == fRecoveringRedo ) )
							{
							BYTE	szT[256];
							char	*rgszT[1];
							QWORDX	qwxPM;
							QWORDX	qwxDH;
						
							qwxPM.qw = QwPMDBTime( ppage );
							qwxDH.qw = QwDBHDRDBTime( rgfmp[DbidOfPn(pbf->pn)].pdbfilehdr );

							sprintf( szT, "%d ((%d:%lu) (%lu-%lu) (%lu-%lu))",
								 err,
								 DbidOfPn(pbf->pn),
								 PgnoOfPn(pbf->pn),
								 qwxPM.h, qwxPM.l,
								 qwxDH.h, qwxDH.l );
							rgszT[0] = szT;
							UtilReportEvent( EVENTLOG_ERROR_TYPE, BUFFER_MANAGER_CATEGORY,
								A_READ_PAGE_TIME_ERROR_ID, 1, rgszT );
							}

						err = ErrERRCheck( JET_errDiskIO );
						EnterCriticalSection( critJet );
						BFIOReturnReadBuffers( pbf, 1, err );
						LeaveCriticalSection( critJet );
						continue;
						}

					/*  copy read data to destination buffer, if batch IO
					/**/
					if ( ipageBatchIO != -1 )
						{
						memcpy( pbf->ppage, ppage, cbPage );
						}
	
					/*  dump debugging info
					/**/				
#ifdef DEBUGGING
					{
					ULONG ulNext, ulPrev, ulThisPage;
					QWORDX qwxPM, qwxDH;
					
					qwxPM.qw = QwPMDBTime( pbf->ppage );
					qwxDH.qw = QwDBHDRDBTime( rgfmp[DbidOfPn(pbf->pn)].pdbfilehdr );
					
					LFromThreeBytes( &ulPrev, &pbf->ppage->pgnoPrev );
					LFromThreeBytes( &ulNext, &pbf->ppage->pgnoNext );
					LFromThreeBytes( &ulThisPage, &pbf->ppage->pgnoThisPage );
					
					printf("Pread %2d - %2d,%4d - %2d <%lu-%lu %lu-%lu> (%lu, %lu, %lu)\n",
							cpageTotal, DbidOfPn(pbf->pn), PgnoOfPn(pbf->pn),
							pbf->ipageBatchIO,
							qwxDH.h, qwxDH.l,
							qwxPM.h, qwxPM.l,
							ulPrev, ulNext, ulThisPage);
					}
#endif

					pbf->trxLastRef = trxMax;
					Assert( pbf->ulBFTime2 == 0 );

					/*	free the held buffer if AsyncRead, signal done if SyncRead
					/**/
					if ( pbf->fAsyncRead )
						{
						if ( pbf->ulBFTime1 == 0 )
							pbf->ulBFTime1 = UlUtilGetTickCount();
					
						BFResetAsyncReadBit( pbf );

						/*	put buffer into LRUK heap
						/**/
						EnterCriticalSection(critLRUK);
						BFLRUKAddToHeap( pbf );
						LeaveCriticalSection(critLRUK);
						}
					else
						{
						Assert( pbf->fSyncRead );
						/*	the ulBFTime must have been set to a time recorded
						 *	in history or null if no entry for it.
						 */
#ifdef LRU1
						pbf->ulBFTime2 = 0;
						pbf->ulBFTime1 = UlUtilGetTickCount();
#else  //  !LRU1
						pbf->ulBFTime2 = pbf->ulBFTime1;
						pbf->ulBFTime1 = UlUtilGetTickCount();
#endif  //  LRU1

						SignalSend( pbf->sigSyncIOComplete );
						}
					}
				}
			}

		/*  successful write
		/**/
		else
			{
			/*  monitor statistics
			/**/
			if ( pbfHead->fSyncWrite )
				cBFSyncWrites++;
			else
				cBFAsyncWrites++;
			cbBFWritten += cb;

#ifdef COSTLY_PERF
			for ( pbf = pbfHead; pbf != pbfNil; pbf = pbf->pbfNextBatchIO )
				cBFPagesWritten[pbf->lClass]++;
#else  //  !COSTLY_PERF
			cBFPagesWritten += cpgIO;
#endif  //  COSTLY_PERF


			/*  validate data between BF, BF->ppage, and batch IO buffers (if used)
			/**/
#ifdef DEBUG
			for ( pbf = pbfHead; pbf != pbfNil; pbf = pbf->pbfNextBatchIO )
				{
				PGNO	pgno;

				Assert( pbf->fAsyncWrite || pbf->fSyncWrite );
				Assert( !pbf->fAsyncRead );
				Assert( !pbf->fSyncRead );
				Assert( pbf->fDirty );
				
				LFromThreeBytes( &pgno, &pbf->ppage->pgnoThisPage );
				Assert( pgno == PgnoOfPn( pbf->pn ) );
				if ( pbf->ipageBatchIO != -1 )
					{
					LFromThreeBytes( &pgno, &( rgpageBatchIO[pbf->ipageBatchIO].pgnoThisPage ) );
					Assert( pgno == PgnoOfPn( pbf->pn ) );
					}
				}
#endif

			/*  this write was to the patch file, so we must not try and write
			/*  to there again
			/**/
			fAppendPatchFile = fFalse;
			if ( pbfHead->fPatch )
				{
				BFEnterCriticalSection( pbfHead );
				pbfHead->fPatch = fFalse;
				pbfHead->fNeedPatch = fFalse;
				BFLeaveCriticalSection( pbfHead );
				EnterCriticalSection( pfmp->critCheckPatch );
				pfmp->cPatchIO--;
				LeaveCriticalSection( pfmp->critCheckPatch );
				}

			/*  do we reissue this write to the patch file?
			/**/
			if ( pbfHead->fNeedPatch )
				{
				OLP		*polp;
				LONG	cmsec;
				HANDLE	hf;
				BYTE	*pb;
				LONG	cb;

				Assert( pbfHead->fDirty );

				/*  protect access to patchfile size (from filemap) via critJet
				/**/
				EnterCriticalSection( critJet );
				
				/*  allocate and initialize OLP to point into patch file
				/**/
				CallS( ErrBFOLPAlloc( &polp ) );
				polp->Offset = LOffsetOfPgnoLow( pfmp->cpage + 1 );
				polp->OffsetHigh = LOffsetOfPgnoHigh( pfmp->cpage + 1 );
				//  save pointer to buffer for use in callback function
				polp->hEvent = (HANDLE) pbfHead;

				/*  this is a patch file write
				/**/
				BFEnterCriticalSection( pbfHead );
				pbfHead->fPatch = fTrue;
				BFLeaveCriticalSection( pbfHead );

				/*  update patch file size
				/**/
				pfmp->cpage += cpgIO;

				/*  end filemap protection
				/**/
				LeaveCriticalSection( critJet );

				/* set it as ready for repeated write to patch file
				/**/
				BFEnterCriticalSection( pbfHead );
				Assert( pbfHead->fDirty );

				/*  issue Async IO
				/**/
				cmsec = 1 << 3;
				hf = pfmp->hfPatch;
				Assert( hf != handleNil );
				pb = (BYTE *) (	pbfHead->ipageBatchIO == -1 ?
									pbfHead->ppage :
									rgpageBatchIO + ipageBatchIO );
				cb = cbPage * cpgIO;
				
				while ( ( err = ErrUtilWriteBlockEx( hf, pb, cb, polp, BFIOComplete ) ) < 0 )
					{
					/*  if there are too many IO, sleep and try again
					/**/
					if ( err == JET_errTooManyIO )
						{
						cmsec <<= 1;
						if ( cmsec > ulMaxTimeOutPeriod )
							cmsec = ulMaxTimeOutPeriod;
						BFLeaveCriticalSection( pbfHead );
						UtilSleepEx( cmsec - 1, fTrue );
						BFEnterCriticalSection( pbfHead );
						}

					/*  issue failed for good
					/**/
					else if ( err < 0 )
						{
						BFLeaveCriticalSection( pbfHead );
						BFOLPFree( polp );
						goto WriteIssueFailed;
						}	
					}
				BFLeaveCriticalSection( pbfHead );

				/*  keep track of IO issue stats
				/**/
				cBFOutstandingWrites++;

				/*  we can't release resources yet, so return immediately
				/**/
				return;
				}

			/*  move the now clean buffers into the Avail List
			/**/
			for ( pbf = pbfHead; pbf != pbfNil; pbf = pbfNextBatchIO )
				{
				pbfNextBatchIO = pbf->pbfNextBatchIO;

				fVeryOld = pbf->fVeryOld;
				
				/*  set buffer to "cleaned" status
				/**/
				BFResetDirtyBit( pbf );
				BFResetIOError( pbf );
				Assert( pbf->cDepend == 0 );

				/*  if we have a dependent, try to write it to disk now that we're clean
				/**/
				if ( pbf->pbfDepend != pbfNil )
					{
					BF		*pbfDepend = pbf->pbfDepend;
					BOOL	fHoldDependent;

					EnterCriticalSection( critJet );
					
					/*  if the BF that was written was old, then mark its dependent old
					/**/
					if ( fVeryOld )
						BFSetVeryOldBit( pbfDepend );

					fHoldDependent = FBFHold( ppibNil, pbfDepend );

//					Assert( pbf->cWriteLatch == 0 );
					BFUndepend( pbf );

					if ( fHoldDependent )
						{
						/*  if we can write it, move it to the write heap
						/**/

						/*	Assert for writable
						 */
						Assert( pbfDepend->pn != pnNull );
						Assert( pbfDepend->fDirty );
						Assert( pbfDepend->fHold );
						Assert(	!pbfDepend->fAsyncRead );
						Assert(	!pbfDepend->fSyncRead );

						if ( FBFIWritable( pbfDepend, fFalse, ppibNil ) )
							{
							EnterCriticalSection( critBFIO );
							BFIOAddToHeap(pbfDepend);
							LeaveCriticalSection( critBFIO );
							}
							
						/*  we can't write it, so return it to LRUK heap
						/**/
						else
							{
							EnterCriticalSection( critLRUK );
							Assert( pbfDepend->fHold );
							BFLRUKAddToHeap( pbfDepend );
							LeaveCriticalSection( critLRUK );
							}
						}

					LeaveCriticalSection( critJet );
					}
				Assert( pbf->pbfDepend == pbfNil );

				/*  output debugging info
				/**/
#ifdef DEBUGGING
				{
				ULONG ulNext, ulPrev, ulThisPage;
				QWORDX qwxPM, qwxDH;
					
				qwxPM.qw = QwPMDBTime( pbf->ppage );
				qwxDH.qw = QwDBHDRDBTime( rgfmp[DbidOfPn(pbf->pn)].pdbfilehdr );
									
				LFromThreeBytes( &ulPrev, &pbf->ppage->pgnoPrev );
				LFromThreeBytes( &ulNext, &pbf->ppage->pgnoNext );
				LFromThreeBytes( &ulThisPage, &pbf->ppage->pgnoThisPage );

				printf("Write %2d - %2d,%4d - %2d <%lu-%lu %lu-%lu> (%lu, %lu, %lu)\n",
					cpageTotal, DbidOfPn(pbf->pn), PgnoOfPn(pbf->pn),
					ipage++,
					qwxDH.h, qwxDH.l,
					qwxPM.h, qwxPM.l,
					ulPrev, ulNext, ulThisPage);
				}
#endif  //  DEBUGGING
				
				/*  if AsyncWrite, send to avail list and release hold on BF
				/**/
				if ( pbf->fAsyncWrite )
					{
					BFResetAsyncWriteBit( pbf );

					/*  if the BF is pinned, send back to LRUK heap, otherwise
					/*  put the cleaned BF in the avail list
					/**/
					if ( pbf->cPin )
						{
						EnterCriticalSection( critLRUK );
						BFLRUKAddToHeap( pbf );
						LeaveCriticalSection( critLRUK );
						}
					else
						{
						EnterCriticalSection( critAvail );
						BFAddToListAtMRUEnd( pbf, &pbgcb->lrulist );
						LeaveCriticalSection( critAvail );
						}
					}

				/*  if SyncWrite, signal that it is done, but keep hold
				/**/
				else
					SignalSend( pbf->sigSyncIOComplete );
				}
			}
		}

	/*  IO was not successful
	/**/
	else
		{
		/*  unsuccessful read
		/**/
		if ( !pbfHead->fDirty )
			{
ReadIssueFailed:
			/*  put read buffers back in Avail List
			/**/
			EnterCriticalSection( critJet );
			BFIOReturnReadBuffers( pbfHead, cpgIO, err );
			LeaveCriticalSection( critJet );
			}

		/*  unsuccessful write
		/**/
		else
			{
WriteIssueFailed:
			Assert( !pbfHead->fPatch || pbfHead->fNeedPatch );
			if ( pbfHead->fNeedPatch )
				{
				BFEnterCriticalSection( pbfHead );
				pbfHead->fPatch = fFalse;
				pbfHead->fNeedPatch = fFalse;
				BFLeaveCriticalSection( pbfHead );

				// UNDONE: log event to indicate it is DB write fail or
				// UNDONE: patch write fail (fPatch is true)
				EnterCriticalSection( pfmp->critCheckPatch );
				pfmp->errPatch = err;
				pfmp->cPatchIO--;
				LeaveCriticalSection( pfmp->critCheckPatch );
				}
			/*  put dirty buffers back in LRUK heap
			/**/
			BFIOReturnWriteBuffers( pbfHead, cpgIO, err );
			}
		}

	/*  free batch IO buffers, if used
	/**/
	if ( ipageBatchIO != -1 )
		BFIOFreeBatchIOBuffers( ipageBatchIO, cpgIO );

	/*  issue another IO from heap, if necessary
	/**/
	BFIOIssueIO();
}


LOCAL INLINE VOID BFIEnableRangeLock( FMP *pfmp, RANGELOCK *prangelock )
	{
	EnterCriticalSection( pfmp->critCheckPatch );
	prangelock->prangelockNext = pfmp->prangelock;
	pfmp->prangelock = prangelock;
	LeaveCriticalSection( pfmp->critCheckPatch );
	}


LOCAL INLINE VOID BFIDisableRangeLock( FMP *pfmp, RANGELOCK *prangelock )
	{
	RANGELOCK **pprangelock;

	EnterCriticalSection( pfmp->critCheckPatch );
	pprangelock = &pfmp->prangelock;
	while( *pprangelock != prangelock )
		pprangelock = &(*pprangelock)->prangelockNext;
	*pprangelock = prangelock->prangelockNext;
	LeaveCriticalSection( pfmp->critCheckPatch );
	}


/*	BF support for direct read.
 */	
ERR ErrBFDirectRead( DBID dbid, PGNO pgnoStart, PAGE *ppage, INT cpage )
	{
	ERR err;
	BF *pbf;
	PGNO pgno;
	PGNO pgnoMac = pgnoStart + cpage;
	RANGELOCK *prangelock;
	FMP *pfmp = &rgfmp[dbid];
#define cTriesDirectReadMax	10
	INT	cTries = 0;

Start:
	AssertCriticalSection( critJet );
	Assert( pfmp->pgnoCopyMost );

	/*	Go through all the pbf and check if any write IO is going on.
	 */
	if ( ( prangelock = SAlloc( sizeof( RANGELOCK ) ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );

	prangelock->pgnoStart = pgnoStart;
	prangelock->pgnoEnd = pgnoStart + cpage -1;
	prangelock->prangelockNext = NULL;

	BFIEnableRangeLock( pfmp, prangelock );

LockAllPages:
	for ( pgno = pgnoStart; pgno < pgnoMac; pgno++ )
		{
		BOOL fBeingWritten;
		PN pn = PnOfDbidPgno( dbid, pgno );
		
		pbf = PbfBFISrchHashTable( pn, butBuffer );
		if ( pbf == pbfNil )
			continue;

		EnterCriticalSection( critBFIO );
		Assert( !pbf->fDirectRead );

		BFEnterCriticalSection( pbf );
		fBeingWritten = pbf->fSyncWrite ||			// sync written
						pbf->fAsyncWrite;			// being async written
		BFLeaveCriticalSection( pbf );

		fBeingWritten = fBeingWritten ||			// going to be async written
			( FBFInBFIOHeap( pbf ) && (!pbf->fSyncRead && !pbf->fAsyncRead) );
		LeaveCriticalSection( critBFIO );

		if ( fBeingWritten )
			{
			BFIDisableRangeLock( pfmp, prangelock );
			
			SignalSend( sigBFIOProc );
			BFSleep( cmsecWaitIOComplete );

			BFIEnableRangeLock( pfmp, prangelock );

			goto LockAllPages;
			}
		}

	/*	Alloc a bf first.
	 */
	while ( ( err = ErrBFIAlloc( &pbf, fSync ) ) == wrnBFNotSynchronous );
	if ( err < 0 )
		{
		BFIDisableRangeLock( pfmp, prangelock );
		goto HandleError;
		}
	Assert( pbf->pn == pnNull );

	LeaveCriticalSection( critJet );
					
	/*  allocate sync IO completion signal
	/**/
	BFEnterCriticalSection( pbf );
	
	/*	Alloc sync IO signal.
	 */
	Assert( pbf->prceDeferredBINext == prceNil );
	Assert( pbf->sigSyncIOComplete == sigNil );
	
	CallS( ErrBFSIGAlloc( &pbf->sigSyncIOComplete ) );
	SignalReset( pbf->sigSyncIOComplete );
	
	pbf->fDirectRead = fTrue;

	BFLeaveCriticalSection( pbf );

	/*	Fix up the pn for direct read.
	 */
	pbf->pn = PnOfDbidPgno( dbid, pgnoStart );
	pbf->ppageDirectRead = ppage;
	pbf->cpageDirectRead = cpage;
	BFResetIOError( pbf );
	
	/*  push buffer onto IO heap
	/**/
	EnterCriticalSection( critBFIO );
	BFIOAddToHeap( pbf );
	LeaveCriticalSection( critBFIO );

	/*  signal IO process to perform read / write and wait for it's completion
	/**/
	SignalSend( sigBFIOProc );
	SignalWait( pbf->sigSyncIOComplete, INFINITE );

	BFIDisableRangeLock( pfmp, prangelock );
			
	/*	Reset the direct read settings.
	 */
	pbf->pn = pnNull;
	pbf->cDepend = 0;
	pbf->pbfDepend = pbfNil;

	BFEnterCriticalSection( pbf );
	Assert( pbf->sigSyncIOComplete != sigNil );
	BFSIGFree( pbf->sigSyncIOComplete );
	pbf->sigSyncIOComplete = sigNil;
	
	pbf->fDirectRead = fFalse;
	BFLeaveCriticalSection( pbf );

	err = pbf->err;

	/*	if we did not read all the pages by FileSystem, we will get wrnBFNotSynchronous
	 */
	Assert( err < 0 || err == JET_errSuccess || err == ErrERRCheck( wrnBFNotSynchronous ) );

	BFResetIOError( pbf );
	EnterCriticalSection( critJet );

	/*	free the buffer.
	 */
	EnterCriticalSection( critAvail );
	BFAddToListAtLRUEnd( pbf, &pbgcb->lrulist );
	LeaveCriticalSection( critAvail );

HandleError:
	SFree( prangelock );
	AssertNotInCriticalSection( critLRUK );
	AssertCriticalSection( critJet );

	/*	did not read all the pages, try to read again.
	 */
	if ( err == wrnBFNotSynchronous )
		{
		if ( cTries++ < cTriesDirectReadMax )
			{
			BFSleep( cmsecWaitIOComplete );
			goto Start;
			}
		else
			err = JET_errDiskIO;
		}

	return err;
	}


//+api------------------------------------------------------------------------
//
//	ErrBFFlushBuffers
//	=======================================================================
//
//	VOID ErrBFFlushBuffers( DBID dbidToFlush, LONG fBFFlush )
//
//	Write all dirty database pages to the disk.  0 flushes ALL dbids.
//
//	fBFFlushAll - flush all the buffers specified in dbidToFlush.
//	fBFFlushSome - flush as many buffers specified in dbidToFlush as possible.
//
//	Must attempt to flush buffers repetatively since dependencies
//	may prevent flushable buffers from being written on the first
//	iteration.  If any buffers can not be flushed, we MUST return
//  an error in order to prevent checkpoint corruption!
//----------------------------------------------------------------------------

ERR ErrBFFlushBuffers( DBID dbidToFlush, LONG fBFFlush )
	{
	ERR		err;
	BF		*pbf;
	DBID	dbid;
	BOOL	fRetryFlush;

	AssertCriticalSection( critJet );

#ifndef NO_LOG

	/*	flush log first
	/**/
	if ( !fLogDisabled && fBFFlush == fBFFlushAll )
		{
		SignalSend( sigLogFlush );
		}

#endif  //  !NO_LOG

#ifdef DEBUG

	/*  set flush flags in filemap
	/**/
	if ( fBFFlush == fBFFlushAll )
		{
		if ( dbidToFlush )
			{
			DBIDSetFlush( dbidToFlush );
			}
		else
			{
			for ( dbid = dbidMin; dbid < dbidMax; dbid++ )
				{
				DBIDSetFlush( dbid );
				}
			}
		}

#endif  //  DEBUG

StartToFlush:

	/*  try to flush buffers forever or until there are only buffers left that
	/*  can not be written due to an IO error
	/**/
	forever
		{
		err = JET_errSuccess;
		fRetryFlush = fFalse;

		/*  try to schedule all remaining dirty buffers for write, as permitted
		/**/
		for ( pbf = pbgcb->rgbf; pbf < pbgcb->rgbf + pbgcb->cbfGroup; pbf++ )
			{
			/*  if this buffer isn't dirty, forget it
			/**/
			BFEnterCriticalSection( pbf );
			if ( !pbf->fDirty )
				{
				BFLeaveCriticalSection( pbf );
				continue;
				}
				
			/*  if this buffer is not in one of the dbids to flush, skip it
			/**/
			dbid = DbidOfPn( pbf->pn );
			if ( dbid == dbidTemp || ( dbidToFlush && dbid != dbidToFlush ) )
				{
				BFLeaveCriticalSection( pbf );
				continue;
				}
			BFLeaveCriticalSection( pbf );

			/*  if the buffer is already scheduled for write, skip it
			/**/
			EnterCriticalSection( critBFIO );
			if ( FBFInBFIOHeap( pbf ) )
				{
				LeaveCriticalSection( critBFIO );
				continue;
				}
			LeaveCriticalSection( critBFIO );

			/*  if we can't hold the buffer, skip it but we must try again later
			/**/
			if ( !FBFHold( ppibNil, pbf ) )
				{
				fRetryFlush = fTrue;
				continue;
				}

			/*  this buffer is writable
			/**/
			if ( FBFIWritable( pbf, fFalse/*SkipBufferWithDeferredBI*/, ppibNil ) )
				{
				/*  if this buffer is in an error state, skip it
				/**/
				if ( pbf->fIOError )
					{
					/*  return buffer to LRUK heap
					/**/
					EnterCriticalSection( critLRUK );
					Assert( pbf->fHold );
					BFLRUKAddToHeap( pbf );
					LeaveCriticalSection( critLRUK );

					/*  grab error code for return code
					/**/
					err = pbf->err;

					continue;
					}

				/*  schedule this buffer for write
				/**/
				EnterCriticalSection( critBFIO );
				BFIOAddToHeap( pbf );
				LeaveCriticalSection( critBFIO );
				}

			/*  this buffer is not writable
			/**/
			else
				{
				/*	Assume we need to retry, except for the following unwritable reason:
				 *		NoMoreLogWrite.
				 */
				BOOL fNeedToRetryThisPage = fTrue;

#ifndef NO_LOG
				/*  Retry only one exception: log is dead, fLGNoMoreLogWrite is true.
				/**/
				if (	!fLogDisabled &&
						fLGNoMoreLogWrite &&
						FDBIDLogOn(DbidOfPn( pbf->pn )) &&
						CmpLgpos( &pbf->lgposModify, &lgposToFlush ) >= 0
					)
					{
					fNeedToRetryThisPage = fFalse;
					}

#endif  //  !NO_LOG
				
				fRetryFlush = fRetryFlush || fNeedToRetryThisPage;

				/* return buffer to LRUK heap
				/**/
				EnterCriticalSection( critLRUK );
				Assert( pbf->fHold );
				BFLRUKAddToHeap( pbf );
				LeaveCriticalSection( critLRUK );
				}
			}  //  for ( pbf )

		/*  signal IO process to start flushing buffers
		/**/
		LeaveCriticalSection( critJet );
		SignalSend( sigBFIOProc );
		EnterCriticalSection( critJet );

		/*  allow other threads to release buffers we couldn't flush
		/*  and make sure the log is flushed
		/**/
		if ( fRetryFlush )
			{
			if ( !fLogDisabled )
				{
				SignalSend( sigLogFlush );
				BFSleep( cmsecWaitIOComplete );
				}
			}
		else
			break;

		}	// forever

	/*  wait for all writes to complete
	/**/
	LeaveCriticalSection( critJet );
	
	forever
		{
		BOOL fIOGoing;
		
		EnterCriticalSection( critBFIO );
		fIOGoing = ( CbfBFIOHeap() != 0 );
		LeaveCriticalSection( critBFIO );

		EnterCriticalSection( critOLP );
		fIOGoing = fIOGoing || ( ipolpMac < ipolpMax );
		LeaveCriticalSection( critOLP );
		
		if ( fIOGoing )
			{
			SignalSend( sigBFIOProc );
			UtilSleep( cmsecWaitIOComplete );
			}
		else
			break;
		}
		
	EnterCriticalSection( critJet );
	
	/*	Check if all flush are done, also check the error code during flush.
	 */
	if ( fBFFlush == fBFFlushAll )
		{
		/*  verify that all specified buffers were flushed (if possible)
		 *	The if statements in the following for loop should be the same
		 *	as those in the for loop above.
		 */
		for ( pbf = pbgcb->rgbf; pbf < pbgcb->rgbf + pbgcb->cbfGroup; pbf++ )
			{
			/*  if this buffer isn't dirty, forget it
			/**/
			if ( !pbf->fDirty )
				{
				continue;
				}

			/*  if this buffer is not in one of the dbids to flush, skip it
			/**/
			dbid = DbidOfPn( pbf->pn );
			if ( dbid == dbidTemp || ( dbidToFlush && dbid != dbidToFlush ) )
				{
				continue;
				}

			if ( pbf->fIOError )
				{
				if ( err == JET_errSuccess )
					{
					/* no error code set yet, set it
					/**/
					err = pbf->err;
					}
				}
			else
				{
				/*	No error and not flushed. Check if it is cause by any unwritable
				 *	reasons. The unwritable reasons should be also checked in the
				 *	for loop above. Currently the only reason is NoMoreLogWrite.
				 */

				BOOL fBFFlushed = fFalse;
#ifndef NO_LOG
				fBFFlushed =
					!(	!fLogDisabled &&
						fLGNoMoreLogWrite &&
						FDBIDLogOn(DbidOfPn( pbf->pn )) &&
						CmpLgpos( &pbf->lgposModify, &lgposToFlush ) >= 0
					);
#endif  //  !NO_LOG

				/*	This should never got hit!
				 */
				Assert( fBFFlushed );
				if ( !fBFFlushed )
					{
					/*	Not being flushed for unknown reason? Start again.
					 */
					goto StartToFlush;
					}
				}
			}

#ifdef DEBUG
		/*  reset flush flags in filemap
		/**/
		if ( dbidToFlush )
			{
			DBIDResetFlush( dbidToFlush );
			}
		else
			{
			for ( dbid = dbidMin; dbid < dbidMax; dbid++ )
				{
				DBIDResetFlush( dbid );
				}
			}
#endif  //  DEBUG
		}

	/*  return any IO error that we may have encountered
	/**/

#ifndef NO_LOG

	if ( fLGNoMoreLogWrite && err >= 0 )
		{
		err = JET_errLogWriteFail;
		}

#endif  //  !NO_LOG

	return err;
	}


/*
/*	RETURNS         JET_errOutOfMemory              no flushable buffers
/*					wrnBFNotSynchronous             buffer flushed
/**/

LOCAL ERR ErrBFClean( )
	{
	ERR     err = JET_errSuccess;
	INT		cpbf;
	BF      *pbf;
	INT     cIOReady;
	INT		cbfAvailPossible;
	BOOL	fFirstLoop = fTrue;
	INT		cmsec;

	AssertCriticalSection( critJet );
	AssertCriticalSection( critLRUK );

	Assert( pbgcb->cbfThresholdLow < pbgcb->cbfThresholdHigh );

	cmsec = 1 << 4;
Start:
	cIOReady = 0;
	cbfAvailPossible = pbgcb->lrulist.cbfAvail + CbfBFIOHeap();

	/*	if errBFClean is called for BFCleanProcess, then do
	 *	not enter critical section again since BFCleanProcess did not
	 *	leave LRUK critical section.
	 */
	if ( fFirstLoop )
		fFirstLoop = fFalse;

	cpbf = 0;
	while ( !FBFLRUKHeapEmpty() && cbfAvailPossible < pbgcb->cbfThresholdHigh )
		{
		/*  take BF off top of LRUK heap
		/**/
		pbf = PbfBFLRUKTopOfHeap();

		/*  try to hold the buffer
		/*  if buffer has been latched, then continue to next buffer.
		/**/
		BFEnterCriticalSection( pbf );
		
		if ( !pbf->fHold )
			{
			pbf->fHold = fTrue;
			BFLeaveCriticalSection( pbf );
			}
		else
			{
			BFLeaveCriticalSection( pbf );
			LeaveCriticalSection( critLRUK );
			BFSleep( 1 );
			EnterCriticalSection( critLRUK );
			continue;
			}
		
		BFLRUKTakeOutOfHeap( pbf );
		cpbf++;

		if ( !pbf->fDirty && !pbf->cPin )
			{
			/* put into a available list */
			LeaveCriticalSection( critLRUK );
			EnterCriticalSection( critAvail );
			BFAddToListAtMRUEnd(pbf, &pbgcb->lrulist);
			LeaveCriticalSection( critAvail );
			EnterCriticalSection( critLRUK );

			cbfAvailPossible++;
			
			continue;
			}
		else if (
				/*	not using BFHold to hold it. Instead, just check write latch.
				 */
#if 1
				!FBFIWritable( pbf, fFalse, ppibNil )
#else
				!FBFIWritable( pbf, fFirstLoop/*SkipBufferWithDeferredBI*/, ppibNil )
#endif
				)
			{
			/*  if the unwritable BF is dependent on another BF, lazily remove its
			/*  dependency so that it might be written next clean
			/**/
			if ( pbf->cDepend )
				{
				LeaveCriticalSection( critLRUK );
				BFDeferRemoveDependence( pbf );
				EnterCriticalSection( critLRUK );

				cbfAvailPossible++;
				cIOReady++;
				}

			/*  put BF in LRUK list for now
			/**/
			BFAddToListAtMRUEnd(pbf, &lrulistLRUK );
			}
		else
			{
			/*  since pbf is just taken from LRUK heap and we are still in
			/*  the same critical section and hold it, no one can be doing
			/*  IO on this buffer.
			/**/

			LeaveCriticalSection( critLRUK );
			EnterCriticalSection( critBFIO );
			BFIOAddToHeap(pbf);
			LeaveCriticalSection( critBFIO );
			EnterCriticalSection( critLRUK );
				
			cbfAvailPossible++;
			cIOReady++;
			}
		}

	if ( cIOReady )
		SignalSend( sigBFIOProc );

	/*  put back the temp list */
	while ( ( pbf = lrulistLRUK.pbfLRU ) != pbfNil )
		{
		BFEnterCriticalSection( pbf );
		/*  try to hold the buffer
		/*  if buffer has been latched, then continue to next buffer.
		/**/
		if ( !pbf->fHold )
			pbf->fHold = fTrue;
		else
			{
			BFLeaveCriticalSection( pbf );
			LeaveCriticalSection( critLRUK );
			BFSleep( 1 );
			EnterCriticalSection( critLRUK );
			continue;
			}
		BFLeaveCriticalSection( pbf );

		BFTakeOutOfList( pbf, &lrulistLRUK );
		BFLRUKAddToHeap( pbf );
		}

	/*  set return code */
	if ( cbfAvailPossible == 0 && pbgcb->lrulist.cbfAvail == 0 )
		{
		if ( cpbf == pbgcb->cbfGroup )
			{
			/*	no IO is going on, all pages are in heap and non of them
			 *	are writable. return out of memory.
			 */
			err = ErrERRCheck( JET_errOutOfMemory );
			}
		else
			goto TryAgain;
		}
	else
		{
		if ( pbgcb->lrulist.cbfAvail <
			( pbgcb->cbfThresholdLow + ( pbgcb->cbfThresholdHigh -
			pbgcb->cbfThresholdLow ) / 4 ) )
			{
TryAgain:
			/* give it one more chance to see if all IO are done */
			cmsec <<= 1;
			if ( cmsec > ulMaxTimeOutPeriod )
				cmsec = ulMaxTimeOutPeriod;
			LeaveCriticalSection( critLRUK );
			BFSleep( cmsec - 1 );
			EnterCriticalSection( critLRUK );
			goto Start;
			}
		else
			{
			/*	successfully clean up, warn the user to retry to get buffer.
			 */
			err = ErrERRCheck( wrnBFNotSynchronous );
			}
		}	

	AssertCriticalSection( critLRUK );
	AssertCriticalSection( critJet );

	return err;
	}


#define lBFCleanTimeout	( 30 * 1000 )

/*      BFClean runs in its own thread moving pages to the free list.   This
/*      helps insure that user requests for free buffers are handled quickly
/*      and synchonously.  The process tries to keep at least
/*      pbgcb->cbfThresholdLow buffers on the free list.
/**/
LOCAL ULONG BFCleanProcess( VOID )
	{
	DWORD	dw;
	BOOL	fUpdateCheckpoint;

	forever
		{
		SignalReset( sigBFCleanProc );

		dw = SignalWait( sigBFCleanProc, lBFCleanTimeout );

		EnterCriticalSection( critJet );
		EnterCriticalSection( critLRUK );

		/*  we haven't flushed for a while, so we'll flush now to ensure that most
		/*  changes are on disk in case of a crash
		/**/
		if ( dw == WAIT_TIMEOUT )
			{
//			pbgcb->cbfThresholdHigh = 1 + 3 * ( pbgcb->lrulist.cbfAvail + CbfBFIOHeap() ) / 2;
//			pbgcb->cbfThresholdHigh = pbgcb->lrulist.cbfAvail + CbfBFIOHeap() + lAsynchIOMax;
			pbgcb->cbfThresholdHigh = pbgcb->lrulist.cbfAvail + pbgcb->cbfGroup / 30;
			pbgcb->cbfThresholdHigh = max( pbgcb->cbfThresholdLow + 1, pbgcb->cbfThresholdHigh );
			pbgcb->cbfThresholdHigh = min( pbgcb->cbfGroup, pbgcb->cbfThresholdHigh );

			fUpdateCheckpoint = !fRecovering;
			}

		/*  we were signaled, so perform normal clean
		/**/
		else
			{
			Assert( dw == WAIT_OBJECT_0 );
			
			if ( lBufThresholdHighPercent > lBufThresholdLowPercent )
				pbgcb->cbfThresholdHigh = ( pbgcb->cbfGroup * lBufThresholdHighPercent ) / 100;
			else
				pbgcb->cbfThresholdHigh	= min( pbgcb->cbfGroup, pbgcb->cbfThresholdLow + lAsynchIOMax );
				
			fUpdateCheckpoint = fFalse;
			}
			
		(VOID)ErrBFClean( );

		LeaveCriticalSection( critLRUK );
		LeaveCriticalSection( critJet );

		/*  try to update the checkpoint
		/**/
		if ( fUpdateCheckpoint )
			LGUpdateCheckpointFile( fFalse );

		if ( fBFCleanProcessTerm )
			break;
		}

	return 0;
	}


/*  BFIOProcess runs in its own thread writing/reading pages that are in IOReady
/*  state.
/**/
LOCAL ULONG BFIOProcess( VOID )
	{
	forever
		{
		SignalWaitEx( sigBFIOProc, INFINITE, fTrue );
		
MoreIO:
		BFIOIssueIO();

		if ( fBFIOProcessTerm )
			{
			/* check if any page is still in read / write state
			/* after this point, no one should ever continue putting
			/* pages for IO.
			/**/
			BF	*pbf = pbgcb->rgbf;
			BF	*pbfMax = pbf + pbgcb->cbfGroup;

			for ( ; pbf < pbfMax; pbf++ )
				{
				DBID	dbid = DbidOfPn( pbf->pn );
				BOOL	f;
				
				BFEnterCriticalSection( pbf );
				f = FBFInUse( ppibNil, pbf );
				f = f && ( pbf->fAsyncRead || pbf->fSyncRead || pbf->fAsyncWrite || pbf->fSyncWrite );
				BFLeaveCriticalSection( pbf );
				if ( f )
					{
					/* let the on-going IO have a chance to complete
					/**/
					UtilSleepEx( cmsecWaitIOComplete, fTrue );
					goto MoreIO;
					}

				if ( pbf->fIOError )
					{
					UtilReportEventOfError( BUFFER_MANAGER_CATEGORY, BFIO_TERM_ID, pbf->err );
					AssertSz( !pbf->fIOError,
						"IO event encountered during BFIOProcess() shutdown and logged to the Event Log.  "
						"Press OK to continue normal operation." );
					break;
					}
				}

			break; /* forever */
			}
		}

	return 0;
	}


LOCAL INLINE LONG IheHashPn( PN pn )
	{
	return (LONG) ( pn + ( pn >> 18 ) ) % ipbfMax;
	}


//+private---------------------------------------------------------------------
//
//	PbfBFISrchHashTable
//	===========================================================================
//	BF *PbfBFISrchHashTable( PN pn )
//
//	Search the buffer hash table for BF associated with PN.
//	Returns NULL if page is not found.
//
//	For efficiency, the Hash table functions might reasonably be
//	made into macros.
//
//-----------------------------------------------------------------------------

INLINE LOCAL BF *PbfBFISrchHashTable( PN pn, BUT but )
	{
	HE		*phePrev;
	BF      *pbfCur;

	AssertCriticalSection( critJet );
	Assert( pn );

//	EnterCriticalSection( critHASH );
	phePrev = &rgheHash[ IheHashPn( pn ) ];
	forever {
		if ( phePrev->ibfHashNext == ibfNotUsed )
			{
			pbfCur = NULL;
			break;
			}
		
		pbfCur = &pbgcb->rgbf[ phePrev->ibfHashNext ];

		if ( phePrev->but == but )
			{
			if ( but == butHistory )
				{
				if ( pbfCur->hist.pn == pn )
					break;
				}
			else
				{
				if ( pbfCur->pn == pn )
					break;
				}
			}
		phePrev = &pbfCur->rghe[ phePrev->but ];
		}
				
//	LeaveCriticalSection( critHASH );
	return pbfCur;
	}


//+private----------------------------------------------------------------------
//	BFIInsertHashTable
//	===========================================================================
//
//	VOID BFIInsertHashTable( BF *pbf )
//
//	Add BF to hash table.
//----------------------------------------------------------------------------

INLINE LOCAL VOID BFIInsertHashTable( BF *pbf, BUT but )
	{
	INT     ihe;
	PN		pn = but == butHistory ? pbf->hist.pn : pbf->pn;

	AssertCriticalSection( critJet );

	Assert( pn );
	Assert( !PbfBFISrchHashTable( pn, butHistory ) );
	Assert( !PbfBFISrchHashTable( pn, butBuffer ) );
	Assert(	but == butHistory || FBFInUse( ppibNil, pbf ) );

	ihe = IheHashPn( pn );
	
//	EnterCriticalSection( critHASH );

	pbf->rghe[ but ] = rgheHash[ihe];

	rgheHash[ihe].but = but;
	rgheHash[ihe].ibfHashNext = (INT)( pbf - pbgcb->rgbf );

	/*  monitor statistics  */

//	cBFHashEntries++;
//	rgcBFHashChainLengths[ipbf]++;

#ifdef DEBUG
	BFEnterCriticalSection( pbf );
	if ( but == butBuffer )
		{
		Assert( !( pbf->fInHash ) );
		pbf->fInHash = fTrue;
		}
	BFLeaveCriticalSection( pbf );
#endif

//	LeaveCriticalSection( critHASH );
	}


//+private----------------------------------------------------------------------
//
// BFIDeleteHashTable
// ===========================================================================
//
//      VOID BFIDeleteHashTable( BF *pbf )
//
// Delete pbf from hash table.  Currently functions searches for pbf and
// then deletes it.      Alternately a doubly-linked overflow list could be used.
//
//----------------------------------------------------------------------------

INLINE LOCAL VOID BFIDeleteHashTable( BF *pbf, BUT but )
	{
	HE      *phePrev;
	INT     ihe;
	PN		pn = but == butBuffer ? pbf->pn : pbf->hist.pn;

#ifdef DEBUG
	BFEnterCriticalSection( pbf );
	if ( but == butBuffer )
		{
		Assert( pbf->fInHash );
		pbf->fInHash = fFalse;
		}
	BFLeaveCriticalSection( pbf );
#endif

	AssertCriticalSection( critJet );

	Assert( pn );
	Assert(	but == butHistory || FBFInUse( ppibNil, pbf ) );

	ihe = IheHashPn( pn );
	phePrev = &rgheHash[ihe];

//	EnterCriticalSection( critHASH );

	Assert( phePrev->ibfHashNext != ibfNotUsed );
	forever {
		BF *pbfT = &pbgcb->rgbf[ phePrev->ibfHashNext ];
		if ( pbfT == pbf && phePrev->but == but )
			{
			*phePrev = pbf->rghe[ but ];
			pbf->rghe[ but ].ibfHashNext = ibfNotUsed;
			break;
			}
		phePrev = &pbfT->rghe[ phePrev->but ];
		Assert( phePrev->ibfHashNext != ibfNotUsed );
		}
	
//	LeaveCriticalSection( critHASH );
	
	/*  monitor statistics  */

//	cBFHashEntries--;
//	rgcBFHashChainLengths[ipbf]--;
	}


/*  Returns the LGPOS of the oldest modification to any buffer.  This time is
/*  used to advance the checkpoint.
/**/

BF *pbfOldestGlobal = pbfNil;

VOID BFOldestLgpos( LGPOS *plgpos )
	{
	LGPOS   lgpos = lgposMax;
	BF		*pbf;
	BF		*pbfMax;
	BF		*pbfT = pbfNil;
	
	/*	guard against logging asking for check point before
	/*	buffer manager initialized, after termination.
	/**/
	if ( fSTInit == fSTInitDone )
		{
		pbf = pbgcb->rgbf;
		pbfMax = pbf + pbgcb->cbfGroup;

		for( ; pbf < pbfMax; pbf++ )
			{
			BFEnterCriticalSection( pbf );
			Assert( fLogDisabled || fRecovering || !FDBIDLogOn(DbidOfPn( pbf->pn )) ||
					PgnoOfPn( pbf->pn ) == 0x01 ||
					CmpLgpos( &pbf->lgposRC, &lgposMax ) == 0 ||
					pbf->fDirty );

			if ( pbf->fDirty &&
				 FDBIDLogOn(DbidOfPn( pbf->pn )) && CmpLgpos( &pbf->lgposRC, &lgpos ) < 0 )
				{
				lgpos = pbf->lgposRC;
				pbfT = pbf;
				}
			BFLeaveCriticalSection( pbf );
			}
		}

	*plgpos = lgpos;
	pbfOldestGlobal = pbfT;

	/*  make sure that the oldest BF is marked as very old if it is very old
	/**/
	if ( pbfOldestGlobal != pbfNil && FBFIsVeryOld( pbfOldestGlobal ) )
		{
		BFSetVeryOldBit( pbfOldestGlobal );
		EnterCriticalSection( critLRUK );
		if ( FBFInLRUKHeap( pbfOldestGlobal ) )
			BFLRUKUpdateHeap( pbfOldestGlobal );
		LeaveCriticalSection( critLRUK );
		}
		
	return;
	}


#ifdef DEBUG

/* The following is for debugging purpose to flush a buffer
/**/
INT ForceBuf( PGNO pgno )
	{
	ERR             err;
	ULONG           pn;
	CHAR            filename[20];
	FILE            *pf;
	HE				he;
	BF				*pbf;

	sprintf(filename, "c:\\#fb%x", pgno);
	pn = 0x2000000 + pgno;
	pf = fopen(filename, "w+b");
	if (pf == NULL)
		return -1;
	he = rgheHash[ IheHashPn( pn ) ];
	if ( he.ibfHashNext == ibfNotUsed )
		return -2;

	pbf = &pbgcb->rgbf[ he.ibfHashNext ];
	if ( pbf->ppage == NULL )
		return -3;

	err =  (INT) fwrite((void*) pbf->ppage, 1, cbPage, pf);
	fclose(pf);
	return err;
	}

#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\apirare.c ===
#include "std.h"
#include "version.h"
#include "daeconst.h"

#ifdef DEBUG
extern ERR ISAMAPI ErrIsamGetTransaction( JET_VSESID vsesid, unsigned long *plevel );
#endif

/*	blue only system parameter variables
/**/
/*	JET Blue only system parameter constants
/**/
extern long	cpgSESysMin;
extern long lBufThresholdHighPercent;
extern long lBufThresholdLowPercent;
extern long lBufGenAge;
extern long	lMaxBuffers;
extern long	lMaxSessions;
extern long	lMaxOpenTables;
extern long	lPreferredMaxOpenTables;
extern long	lMaxOpenTableIndexes;
extern long	lMaxTemporaryTables;
extern long	lMaxCursors;
extern long	lMaxVerPages;
extern long	lLogBuffers;
extern long	lLogFileSize;
extern long	lLogFlushThreshold;
extern long lLGCheckPointPeriod;
extern long	lWaitLogFlush;
extern long	lCommitDefault;
extern long	lLogFlushPeriod;
extern long lLGWaitingUserMax;
extern char	szLogFilePath[];
extern char	szRecovery[];
extern long lPageFragment;
extern long	lMaxDatabaseOpen;
extern BOOL fOLCompact;
extern BOOL	fLGGlobalCircularLog;

char szEventSource[JET_cbFullNameMost] = "";

extern long lBufBatchIOMax;
extern long lPageReadAheadMax;
extern long lAsynchIOMax;
extern long cpageTempDBMin;

extern char szBaseName[];
extern char szBaseExt[];
extern char szSystemPath[];
extern int fTempPathSet;
extern char szTempPath[];
extern char szJet[];
extern char szJetLog[];
extern char szJetLogNameTemplate[];
extern char szJetTmp[];
extern char szJetTmpLog[];
extern char szMdbExt[];
extern char szJetTxt[];

DeclAssertFile;

ERR VTAPI ErrIsamSetSessionInfo( JET_SESID sesid, JET_GRBIT grbit );
ERR VTAPI ErrIsamGetSessionInfo( JET_SESID sesid, JET_GRBIT *pgrbit );

/*	make global variable so that it can be inspected from debugger
/**/
unsigned long	ulVersion = ((unsigned long) rmj << 24) + ((unsigned long) rmm << 8) + rup;

JET_ERR JET_API JetGetVersion(JET_SESID sesid, unsigned long  *pVersion)
	{
	APIEnter();

	/*	assert no aliasing of version information
	/**/
	Assert( rmj < 1<<8 );
	Assert( rmm < 1<<16 );
	Assert( rup < 1<<8 );

	/* rmm and rup are defined in version.h maintained by SLM
	/**/
	*pVersion = ulVersion;

	APIReturn(JET_errSuccess);
	}


/*=================================================================
ErrSetSystemParameter

Description:
  This function sets system parameter values.  It calls ErrSetGlobalParameter
  to set global system parameters and ErrSetSessionParameter to set dynamic
  system parameters.

Parameters:
  sesid 		is the optional session identifier for dynamic parameters.
  sysParameter	is the system parameter code identifying the parameter.
  lParam		is the parameter value.
  sz			is the zero terminated string parameter.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidParameter:
    Invalid parameter code.
  JET_errAlreadyInitialized:
    Initialization parameter cannot be set after the system is initialized.
  JET_errInvalidSesid:
    Dynamic parameters require a valid session id.

Side Effects: None
=================================================================*/

#ifdef RFS2
extern DWORD cRFSAlloc;
extern DWORD cRFSIO;
extern DWORD fDisableRFS;
#endif

extern VOID SetTableClassName( LONG lClass, BYTE *szName );

JET_ERR JET_API ErrSetSystemParameter(
	JET_SESID sesid,
	unsigned long paramid,
	ULONG_PTR lParam,
	const char  *sz )
	{
	/*	size of string argument
	/**/
	unsigned	cch;

	switch ( paramid )
		{
	//	UNDONE:	remove these unused parameters
	case JET_paramPfnStatus:
	case JET_paramEventId:
	case JET_paramEventCategory:
	case JET_paramFullQJet:
		break;
	case JET_paramIniPath:
	case JET_paramPageTimeout:
		return JET_errFeatureNotAvailable;

	case JET_paramSystemPath:		/* Path to the system database */
		if ( fJetInitialized )
			{
			return JET_errAlreadyInitialized;
			}
		else if ( ( cch = strlen(sz) ) >= _MAX_PATH + 1 )
			{
			return JET_errInvalidParameter;
			}
		else
			{
			CHAR	szDriveT[_MAX_DRIVE + 1];
			CHAR	szDirT[_MAX_DIR + 1];
			CHAR	szFNameT[_MAX_FNAME + 1];
			CHAR	szExtT[_MAX_EXT + 1];
			CHAR	szPathFull[_MAX_PATH + 1];

			// UNDONE:  Remove the filespec check when support for
			// JET_paramSysDbPath is removed.

			_splitpath( sz, szDriveT, szDirT, szFNameT, szExtT );

			if ( UtilCmpName( szFNameT, "system" ) == 0  &&
				strlen( szExtT ) > 0  &&
				UtilCmpName( szExtT + 1, szBaseExt ) == 0 )
				{
				CHAR	szPathT[_MAX_PATH + 1];

				/*	remove sysdb filespec if one was specified
				/**/
				_makepath( szPathT, szDriveT, szDirT, NULL, NULL );

				// Verify validity of path.
				if ( _fullpath( szPathFull, szPathT, JET_cbFullNameMost ) == NULL )
					{
					return JET_errInvalidPath;
					}

				strcpy( szSystemPath, szPathT );
				}
			else
				{
				// Verify validity of path.
				if ( _fullpath( szPathFull, sz, JET_cbFullNameMost ) == NULL )
					{
					return JET_errInvalidPath;
					}
				memcpy( szSystemPath, sz, cch + 1 );
				}
			}

		break;

	case JET_paramTempPath:			/* Path to the temporary file directory */
		if ( fJetInitialized )
			return JET_errAlreadyInitialized;
		if ( ( cch = strlen(sz) ) >= cbFilenameMost )
			return JET_errInvalidParameter;
		memcpy( szTempPath, sz, cch + 1 );
		break;

	case JET_paramDbExtensionSize:				/* database expansion steps, default is 16 pages */
		cpgSESysMin = (long)lParam;
		break;

	case JET_paramBfThrshldLowPrcnt: 			/* low threshold for page buffers */
		if ( lParam > 100 )
			return JET_errInvalidParameter;
		lBufThresholdLowPercent = (long)lParam;
		break;

	case JET_paramBfThrshldHighPrcnt: 			/* high threshold for page buffers */
		if ( lParam > 100 )
			return JET_errInvalidParameter;
		lBufThresholdHighPercent = (long)lParam;
		break;

	case JET_paramBufLogGenAgeThreshold:		/* old threshold in terms of log generation */
		lBufGenAge = (long)lParam;
		break;

	case JET_paramMaxBuffers:					/* number of page buffers */
		lMaxBuffers = (long)lParam;
		if ( lMaxBuffers < lMaxBuffersMin )
			lMaxBuffers = lMaxBuffersMin;
		break;

	case JET_paramBufBatchIOMax:
		lBufBatchIOMax = (long)lParam;
		break;
			
	case JET_paramPageReadAheadMax:
		if ( lParam > lPrereadMost )
			return JET_errInvalidParameter;
		lPageReadAheadMax = (long)lParam;
		break;
			
	case JET_paramAsynchIOMax:
		lAsynchIOMax = (long)lParam;
		if ( lAsynchIOMax < lAsynchIOMaxMin )
			lAsynchIOMax = lAsynchIOMaxMin;
		break;
			
	case JET_paramPageTempDBMin:
		cpageTempDBMin = (long)lParam;
		break;
			
	case JET_paramMaxSessions:					/* Maximum number of sessions */
		lMaxSessions = (long)lParam;
		break;

	case JET_paramMaxOpenTables:				/* Maximum number of open tables */
		lMaxOpenTables = (long)lParam;
		break;

	case JET_paramPreferredMaxOpenTables: 		/* Maximum number of open tables */
		lPreferredMaxOpenTables = (long)lParam;
		break;

	case JET_paramMaxOpenTableIndexes:			/* Maximum number of open tables */
		lMaxOpenTableIndexes = (long)lParam;
		break;

	case JET_paramMaxTemporaryTables:
		lMaxTemporaryTables = (long)lParam;
		break;

	case JET_paramMaxCursors:					/* maximum number of open cursors */
		lMaxCursors = (long)lParam;
		break;

	case JET_paramMaxVerPages:					/* Maximum number of modified pages */
		lMaxVerPages = (long)lParam;
		break;

	case JET_paramLogBuffers:
		lLogBuffers = (long)lParam;
		if ( lLogBuffers < lLogBufferMin )
			lLogBuffers = lLogBufferMin;
		break;

	case JET_paramLogFileSize:
		lLogFileSize = (long)lParam;
		if ( lLogFileSize < lLogFileSizeMin )
			lLogFileSize = lLogFileSizeMin;
		break;

	case JET_paramLogFlushThreshold:
		lLogFlushThreshold = (long)lParam;
		break;

	case JET_paramLogCheckpointPeriod:
		lLGCheckPointPeriod = (long)lParam;
		break;

	case JET_paramWaitLogFlush:
		if ( sesid == 0 )
			{
			lWaitLogFlush = (long)lParam;
			}
		else
			{
#ifdef DEBUG
			Assert( ErrIsamSetWaitLogFlush( sesid, (long)lParam ) >= 0 );
#else
			(void) ErrIsamSetWaitLogFlush( sesid, (long)lParam );
#endif
			}
		break;

	case JET_paramCommitDefault:
		if ( sesid == 0 )
			{
			lCommitDefault = (long)lParam;
			}
		else
			{
#ifdef DEBUG
			Assert( ErrIsamSetCommitDefault( sesid, (long)lParam ) >= 0 );
#else
			(void) ErrIsamSetCommitDefault( sesid, (long)lParam );
#endif
			}
		break;

	case JET_paramLogFlushPeriod:
		lLogFlushPeriod = (long)lParam;
		break;

	case JET_paramLogWaitingUserMax:
		lLGWaitingUserMax = (long)lParam;
		break;

 	case JET_paramLogFilePath:		/* Path to the log file directory */
 		if ( ( cch = strlen( sz ) ) >= cbFilenameMost )
 			return JET_errInvalidParameter;
 		memcpy( szLogFilePath, sz, cch + 1 );
		break;

 	case JET_paramRecovery:			/* Switch for recovery on/off */
 		if ( ( cch = strlen( sz ) ) >= cbFilenameMost )
 			return JET_errInvalidParameter;
 		memcpy( szRecovery, sz, cch + 1 );
		break;

	case JET_paramSessionInfo:
		{
#ifdef DEBUG
		Assert( ErrIsamSetSessionInfo( sesid, (JET_GRBIT)lParam ) >= 0 );
#else
		(void) ErrIsamSetSessionInfo( sesid, (JET_GRBIT)lParam );
#endif
		break;
		}

	case JET_paramPageFragment:
		lPageFragment = (long)lParam;
		break;

	case JET_paramMaxOpenDatabases:
		lMaxDatabaseOpen = (long)lParam;
		break;

	case JET_paramOnLineCompact:
		if ( lParam != 0 && lParam != JET_bitCompactOn )
			return JET_errInvalidParameter;
		fOLCompact = (BOOL)lParam;
		break;

	case JET_paramAssertAction:
		if ( lParam != JET_AssertExit &&
			lParam != JET_AssertBreak &&
			lParam != JET_AssertMsgBox &&
			lParam != JET_AssertStop )
			{
			return JET_errInvalidParameter;
			}
#ifdef DEBUG
		wAssertAction = (unsigned)lParam;
#endif
		break;

	case JET_paramEventSource:
		if ( fJetInitialized )
			return JET_errAlreadyInitialized;
		if ( ( cch = strlen( sz ) ) >= cbFilenameMost )
			return JET_errInvalidParameter;
		memcpy( szEventSource, sz, cch + 1 );
		break;

	case JET_paramCircularLog:
		fLGGlobalCircularLog = (BOOL)lParam;
		break;

#ifdef RFS2
	case JET_paramRFS2AllocsPermitted:
		fDisableRFS = fFalse;
		cRFSAlloc = (unsigned long)lParam;
		break;

	case JET_paramRFS2IOsPermitted:
		fDisableRFS = fFalse;
		cRFSIO = (unsigned long)lParam;
		break;
#endif

	case JET_paramBaseName:
		{
		if ( strlen(sz) != 3 )
			return JET_errInvalidParameter;

		strcpy( szBaseName, sz );

		strcpy( szJet, sz );

		strcpy( szJetLog, sz );
		strcat( szJetLog, ".log" );

		strcpy( szJetLogNameTemplate, sz );
		strcat( szJetLogNameTemplate, "00000" );

		strcpy( szJetTmp, sz );
		strcat( szJetTmp, "tmp" );

		strcpy( szJetTmpLog, szJetTmp );
		strcat( szJetTmpLog, ".log" );

		strcpy( szJetTxt, sz );
		strcat( szJetTxt, ".txt" );		
		break;
		}

	case JET_paramBaseExtension:
		{
		if ( strlen(sz) != 3 )
			return JET_errInvalidParameter;

		strcpy( szBaseExt, sz );

		if ( !fTempPathSet )
			{
			strcpy( szTempPath, "temp." );
			strcat( szTempPath, sz );
			}
	
		strcpy( szMdbExt, "." );
		strcat( szMdbExt, sz );
		break;
		}

	case JET_paramTableClassName:
		if ( fJetInitialized )
			return JET_errAlreadyInitialized;
		if ( lParam < 1 || lParam > 15 )
			return JET_errInvalidParameter;
		if ( !sz || !strlen( sz ) )
			return JET_errInvalidParameter;
		SetTableClassName( (LONG)lParam, (BYTE *) sz );
		break;

	default:
		return JET_errInvalidParameter;
		}

	return JET_errSuccess;
	}


extern VOID GetTableClassName( LONG lClass, BYTE *szName, LONG cbMax );

JET_ERR JET_API ErrGetSystemParameter(JET_SESID sesid, unsigned long paramid,
	ULONG_PTR *plParam, char  *sz, unsigned long cbMax)
	{
	int	cch;
	
	switch ( paramid )
		{
	case JET_paramPfnStatus:
	case JET_paramEventId:
	case JET_paramEventCategory:
	case JET_paramFullQJet:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = 0;
		break;

	case JET_paramSystemPath:		/* Path to the system database */
		cch = strlen(szSystemPath) + 1;
		if (cch > (int)cbMax)
			cch = (int)cbMax;
		memcpy( sz, szSystemPath, cch );
		sz[cch-1] = '\0';
		break;

	case JET_paramTempPath:			/* Path to the temporary file directory */
		cch = strlen(szTempPath) + 1;
		if (cch > (int)cbMax)
			cch = (int)cbMax;
		memcpy( sz, szTempPath, cch );
		sz[cch-1] = '\0';
		break;

	case JET_paramIniPath:			/* Path to the ini file */
		return(JET_errFeatureNotAvailable);

	case JET_paramPageTimeout:		/* Red ISAM data page timeout */
		return(JET_errFeatureNotAvailable);

#ifdef LATER
	case JET_paramPfnError:			/* Error callback function */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = 0;
		break;
#endif /* LATER */

	case JET_paramDbExtensionSize:		/* database expansion steps, default is 16 pages */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = cpgSESysMin;
		break;
			
	case JET_paramBfThrshldLowPrcnt: /* Low threshold for page buffers */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lBufThresholdLowPercent;
		break;

	case JET_paramBfThrshldHighPrcnt: /* High threshold for page buffers */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lBufThresholdHighPercent;
		break;

	case JET_paramBufLogGenAgeThreshold:		 /* Old threshold in terms of log generation */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lBufGenAge;
		break;

	case JET_paramMaxBuffers:      /* Bytes to use for page buffers */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lMaxBuffers;
		break;

	case JET_paramBufBatchIOMax:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lBufBatchIOMax;
		break;
			
	case JET_paramPageReadAheadMax:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lPageReadAheadMax;
		break;
			
	case JET_paramAsynchIOMax:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lAsynchIOMax;
		break;
			
	case JET_paramPageTempDBMin:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = cpageTempDBMin;
		break;
			
	case JET_paramMaxSessions:     /* Maximum number of sessions */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lMaxSessions;
		break;

	case JET_paramMaxOpenTables:   /* Maximum number of open tables */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lMaxOpenTables;
		break;

	case JET_paramPreferredMaxOpenTables:   /* Maximum number of open tables */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lPreferredMaxOpenTables;
		break;

	case JET_paramMaxOpenTableIndexes:	/* Maximum number of open table indexes */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lMaxOpenTableIndexes;
		break;

	case JET_paramMaxTemporaryTables:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lMaxTemporaryTables;
		break;

	case JET_paramSessionInfo:
		{
        JET_GRBIT grbit;
#ifdef DEBUG
		Assert( ErrIsamGetSessionInfo( sesid, &grbit ) >= 0 );
#else
		(void) ErrIsamGetSessionInfo( sesid, &grbit );
#endif
        *plParam = grbit;
		break;
		}
			
	case JET_paramMaxVerPages:     /* Maximum number of modified pages */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lMaxVerPages;
		break;

	case JET_paramMaxCursors:      /* maximum number of open cursors */
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lMaxCursors;
		break;

	case JET_paramLogBuffers:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lLogBuffers;
		break;

	case JET_paramLogFileSize:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lLogFileSize;
		break;

	case JET_paramLogFlushThreshold:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lLogFlushThreshold;
		break;

	case JET_paramLogFilePath:     /* Path to the log file directory */
		cch = strlen(szLogFilePath) + 1;
		if ( cch > (int)cbMax )
			cch = (int)cbMax;
		memcpy( sz,  szLogFilePath, cch  );
		sz[cch-1] = '\0';
		break;

	case JET_paramRecovery:
		cch = strlen(szRecovery) + 1;
		if ( cch > (int)cbMax )
			cch = (int)cbMax;
		memcpy( sz,  szRecovery, cch  );
		sz[cch-1] = '\0';
		break;

#ifdef DEBUG
    case JET_paramTransactionLevel:
        {
            unsigned long level;
     		ErrIsamGetTransaction( sesid, &level );
            *plParam = level;
        }
		break;
	
	case JET_paramPrintFunction:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = (ULONG_PTR)&DBGFPrintF;
		break;
#endif

	case JET_paramPageFragment:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lPageFragment;
		break;

	case JET_paramMaxOpenDatabases:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = lMaxDatabaseOpen;
		break;

	case JET_paramOnLineCompact:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		Assert( fOLCompact == 0 ||
		fOLCompact == JET_bitCompactOn );
		*plParam = fOLCompact;
		break;

	case JET_paramEventSource:
		cch = strlen(szEventSource) + 1;
		if (cch > (int)cbMax)
			cch = (int)cbMax;
		memcpy( sz, szEventSource, cch );
		sz[cch-1] = '\0';
		break;

	case JET_paramCircularLog:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = fLGGlobalCircularLog;
		break;

#ifdef RFS2
	case JET_paramRFS2AllocsPermitted:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = cRFSAlloc;
		break;

	case JET_paramRFS2IOsPermitted:
		if (plParam == NULL)
			return(JET_errInvalidParameter);
		*plParam = cRFSIO;
		break;
#endif

	case JET_paramBaseName:
		cch = strlen(szBaseName) + 1;
		if (cch > (int)cbMax)
			cch = (int)cbMax;
		memcpy( sz, szBaseName, cch );
		sz[cch-1] = '\0';
		break;

	case JET_paramBaseExtension:
		cch = strlen(szBaseExt) + 1;
		if (cch > (int)cbMax)
			cch = (int)cbMax;
		memcpy( sz, szBaseExt, cch );
		sz[cch-1] = '\0';
		break;

	case JET_paramTableClassName:
		if ( *plParam > 15 )
			return JET_errInvalidParameter;
		if ( !sz || cbMax < 2 )
			return JET_errInvalidParameter;
		GetTableClassName( (LONG)*plParam, (BYTE *) sz, cbMax );
		break;

	default:
		return JET_errInvalidParameter;
		}

	return JET_errSuccess;
	}


/*=================================================================
JetGetSystemParameter

Description:
  This function returns the current settings of the system parameters.

Parameters:
  sesid 		is the optional session identifier for dynamic parameters.
  paramid		is the system parameter code identifying the parameter.
  plParam		is the returned parameter value.
  sz			is the zero terminated string parameter buffer.
  cbMax			is the size of the string parameter buffer.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidParameter:
    Invalid parameter code.
  JET_errInvalidSesid:
    Dynamic parameters require a valid session id.

Side Effects:
  None.
=================================================================*/
JET_ERR JET_API JetGetSystemParameter(JET_INSTANCE instance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR *plParam, char  *sz, unsigned long cbMax)
	{
	JET_ERR err;
	int fReleaseCritJet = 0;

	if (critJet == NULL)
		fReleaseCritJet = 1;
	APIInitEnter();

	err = ErrGetSystemParameter(sesid,paramid,plParam,sz,cbMax);

	if (fReleaseCritJet)
		{
		APITermReturn( err );
		}

	APIReturn( err );
	}


/*=================================================================
JetBeginSession

Description:
  This function signals the start of a session for a given user.  It must
  be the first function called by the application on behalf of that user.

  The username and password supplied must correctly identify a user account
  in the security accounts subsystem of the engine for which this session
  is being started.  Upon proper identification and authentication, a SESID
  is allocated for the session, a user token is created for the security
  subject, and that user token is specifically associated with the SESID
  of this new session for the life of that SESID (until JetEndSession is
  called).

Parameters:
  psesid		is the unique session identifier returned by the system.
  szUsername	is the username of the user account for logon purposes.
  szPassword	is the password of the user account for logon purposes.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:

Side Effects:
  * Allocates resources which must be freed by JetEndSession().
=================================================================*/

JET_ERR JET_API JetBeginSession(JET_INSTANCE instance, JET_SESID  *psesid,
	const char  *szUsername, const char  *szPassword)
	{
	ERR			err;
	JET_SESID	sesid = JET_sesidNil;

	APIEnter();

	/*	tell the ISAM to start a new session
	/**/
	err = ErrIsamBeginSession(&sesid);
	if ( err < 0 )
		goto ErrorHandler;

	*psesid = sesid;

	err = JET_errSuccess;

ErrorHandler:
	APIReturn( err );
	}


JET_ERR JET_API JetDupSession( JET_SESID sesid, JET_SESID *psesid )
	{
	ERR			err;
	JET_SESID	sesidDup;
	JET_GRBIT	grbit;

	APIEnter();

	err = ErrIsamGetSessionInfo( sesid, &grbit );
	if ( err < 0 )
		{
		goto ErrorHandler;
		}

	/*	begin ISAM session
	/**/
	err = ErrIsamBeginSession( &sesidDup );
	if ( err < 0 )
		{
		goto ErrorHandler;
		}

	*psesid = sesidDup;

	err = JET_errSuccess;

ErrorHandler:
	APIReturn( err );
	}

JET_ERR JET_API	JetInvalidateCursors( JET_SESID sesid )
	{
	ERR		err;

	APIEnter();

	err = ErrIsamInvalidateCursors( sesid );

	APIReturn( err );
	}
	

/*=================================================================
JetEndSession

Description:
  This routine ends a session with a Jet engine.

Parameters:
  sesid 		identifies the session uniquely

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidSesid:
    The SESID supplied is invalid.

Side Effects:
=================================================================*/
JET_ERR JET_API JetEndSession(JET_SESID sesid, JET_GRBIT grbit)
	{
	ERR err;

	APIEnter();

	err = ErrIsamRollback( sesid, JET_bitRollbackAll );
	Assert( err >= 0 || err == JET_errInvalidSesid || err == JET_errNotInTransaction );
	err = ErrIsamEndSession( sesid, grbit );
	APIReturn( err );
	}


JET_ERR JET_API JetCreateDatabase(JET_SESID sesid,
	const char  *szFilename, const char  *szConnect,
	JET_DBID  *pdbid, JET_GRBIT grbit)
	{
	APIEnter();
	DebugLogJetOp( sesid, opCreateDatabase );

	APIReturn( ErrIsamCreateDatabase( sesid, szFilename, szConnect, pdbid, grbit ) );
	}


JET_ERR JET_API JetOpenDatabase(JET_SESID sesid, const char  *szDatabase,
	const char  *szConnect, JET_DBID  *pdbid, JET_GRBIT grbit)
	{
	APIEnter();
	DebugLogJetOp( sesid, opOpenDatabase );

	APIReturn( ErrIsamOpenDatabase( sesid, szDatabase, szConnect, pdbid, grbit ) );
	}


JET_ERR JET_API JetGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	APIEnter();
	DebugLogJetOp( sesid, opGetDatabaseInfo );

	APIReturn( ErrIsamGetDatabaseInfo( sesid, (JET_VDBID)dbid, pvResult, cbMax, InfoLevel ) );
	}


JET_ERR JET_API JetCloseDatabase( JET_SESID sesid, JET_DBID dbid, JET_GRBIT grbit )
	{
	APIEnter();
	DebugLogJetOp( sesid, opCloseDatabase );		

	APIReturn( ErrIsamCloseDatabase( sesid, (JET_VDBID)dbid, grbit ) );
	}


JET_ERR JET_API JetCreateTable(JET_SESID sesid, JET_DBID dbid,
	const char  *szTableName, unsigned long lPage, unsigned long lDensity,
	JET_TABLEID  *ptableid)
	{
	ERR				err;
	JET_TABLECREATE tablecreate =
		{	sizeof(JET_TABLECREATE),
			(CHAR *)szTableName,
			lPage,
			lDensity,
			NULL,
			0,
			NULL,
			0,	// No columns/indexes
			0,	// grbit
			0,	// returned tableid
			0	// returned count of objects created
			};

	APIEnter();
	DebugLogJetOp( sesid, opCreateTable );

#ifdef	LATER
	/*	validate the szTableName...
	/**/
	if ( szTableName == NULL )
		APIReturn( JET_errInvalidParameter );
#endif	/* LATER */

	err = ErrIsamCreateTable( sesid, (JET_VDBID)dbid, &tablecreate );
	MarkTableidExported( err, tablecreate.tableid );
	/*	set to zero on error
	/**/
	*ptableid = tablecreate.tableid;

	/*	either the table was created or it was not
	/**/
	Assert( tablecreate.cCreated == 0  ||  tablecreate.cCreated == 1 );

	APIReturn( err );
	}


JET_ERR JET_API JetCreateTableColumnIndex( JET_SESID sesid, JET_DBID dbid, JET_TABLECREATE *ptablecreate )
	{
	ERR err;

	APIEnter();
//	DebugLogJetOp( sesid, opCreateTableColumnIndex );

	if ( ptablecreate == NULL
		||  ptablecreate->cbStruct != sizeof(JET_TABLECREATE)
		||  ( ptablecreate->grbit &
				(JET_bitTableCreateCompaction|JET_bitTableCreateSystemTable) )	// Internal grbits
#ifdef LATER
		|| szTableName == NULL
#endif
		)
		{
		err = JET_errInvalidParameter;
		}
	else
		{
		err = ErrIsamCreateTable( sesid, (JET_VDBID)dbid, ptablecreate );

		MarkTableidExported( err, ptablecreate->tableid );
		}

	APIReturn( err );
	}


JET_ERR JET_API JetDeleteTable(JET_SESID sesid, JET_DBID dbid,
	const char  *szName)
	{
	APIEnter();
	DebugLogJetOp( sesid, opDeleteTable );

	APIReturn( ErrIsamDeleteTable( sesid, (JET_VDBID)dbid, (char *)szName ) );
	}


JET_ERR JET_API JetAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szColumn, const JET_COLUMNDEF  *pcolumndef,
	const void  *pvDefault, unsigned long cbDefault,
	JET_COLUMNID  *pcolumnid)
	{
	APIEnter();
	DebugLogJetOp( sesid, opAddColumn );

	APIReturn(ErrDispAddColumn(sesid, tableid, szColumn, pcolumndef,
		pvDefault, cbDefault, pcolumnid));
	}


JET_ERR JET_API JetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szColumn)
	{
	APIEnter();
	DebugLogJetOp( sesid, opDeleteColumn );

	APIReturn(ErrDispDeleteColumn(sesid, tableid, szColumn));
	}


JET_ERR JET_API JetCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szIndexName, JET_GRBIT grbit,
	const char  *szKey, unsigned long cbKey, unsigned long lDensity)
	{
	APIEnter();
	DebugLogJetOp( sesid, opCreateIndex );

	APIReturn(ErrDispCreateIndex(sesid, tableid, szIndexName, grbit,
		szKey, cbKey, lDensity));
	}


JET_ERR JET_API JetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szIndexName)
	{
	APIEnter();
	DebugLogJetOp( sesid, opDeleteIndex );

	APIReturn(ErrDispDeleteIndex(sesid, tableid, szIndexName));
	}


JET_ERR JET_API JetComputeStats(JET_SESID sesid, JET_TABLEID tableid)
	{
	APIEnter();
	DebugLogJetOp( sesid, opComputeStats );

	CheckTableidExported(tableid);

	APIReturn(ErrDispComputeStats(sesid, tableid));
	}


JET_ERR JET_API JetAttachDatabase(JET_SESID sesid, const char  *szFilename, JET_GRBIT grbit )
	{
	APIEnter();
	DebugLogJetOp( sesid, opAttachDatabase );

	APIReturn(ErrIsamAttachDatabase(sesid, szFilename, grbit));
	}


JET_ERR JET_API JetDetachDatabase(JET_SESID sesid, const char  *szFilename)
	{
	APIEnter();
	DebugLogJetOp( sesid, opDetachDatabase );

	APIReturn(ErrIsamDetachDatabase(sesid, szFilename));
	}


JET_ERR JET_API JetBackup( const char  *szBackupPath, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus )
	{
	APIEnter();
	APIReturn( fBackupAllowed ?
		ErrIsamBackup( szBackupPath, grbit, pfnStatus ) :
		JET_errBackupNotAllowedYet );
	}


JET_ERR JET_API JetRestore(	const char  *sz, JET_PFNSTATUS pfn)
	{
	ERR err;

	if ( fJetInitialized )
		{
		return JET_errAlreadyInitialized;
		}
	
	APIInitEnter();

	/*	initialize Jet without initializing Isam
	/**/
	err = ErrInit( fTrue );
	Assert( err != JET_errAlreadyInitialized );
	if ( err >= 0 )
		{
		err = ErrIsamRestore( (char  *)sz, pfn );

		/*  shut down util layer
		/**/
		UtilTerm();
	
		fJetInitialized = fFalse;
		}
	
	APITermReturn( err );
	}


JET_ERR JET_API JetRestore2( const char *sz, const char *szDest, JET_PFNSTATUS pfn)
	{
	ERR err;

	if ( fJetInitialized )
		{
		return JET_errAlreadyInitialized;
		}
	
	APIInitEnter();

	/*	initialize Jet without initializing Isam
	/**/
	err = ErrInit( fTrue );
	Assert( err != JET_errAlreadyInitialized );
	if ( err >= 0 )
		{
		err = ErrIsamRestore2( (char *)sz, (char *) szDest, pfn );

		/*  shut down util layer
		/**/
		UtilTerm();
	
		fJetInitialized = fFalse;
		}
	
	APITermReturn( err );
	}


JET_ERR JET_API JetOpenTempTable( JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef,
	unsigned long ccolumn,
	JET_GRBIT grbit,
	JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid )
	{
	ERR err;

	APIEnter();
	DebugLogJetOp( sesid, opOpenTempTable );

	err = ErrIsamOpenTempTable(
		sesid,
		prgcolumndef,
		ccolumn,
		0,
		grbit,
		ptableid,
		prgcolumnid );
	MarkTableidExported( err, *ptableid );
	APIReturn( err );
	}


JET_ERR JET_API JetOpenTempTable2( JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef,
	unsigned long ccolumn,
	unsigned long langid,
	JET_GRBIT grbit,
	JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid )
	{
	ERR err;

	APIEnter();
	DebugLogJetOp( sesid, opOpenTempTable );

	err = ErrIsamOpenTempTable(
		sesid,
		prgcolumndef,
		ccolumn,
		langid,
		grbit,
		ptableid,
		prgcolumnid );
	MarkTableidExported( err, *ptableid );
	APIReturn( err );
	}


JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit)
	{
	APIEnter();
	DebugLogJetOp( sesid, opSetIndexRange );

	APIReturn(ErrDispSetIndexRange(sesid, tableidSrc, grbit));
	}


JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long  *pcrec, unsigned long crecMax)
	{
	ERR err;

	APIEnter();
	DebugLogJetOp( sesid, opIndexRecordCount );

 	err = ErrIsamIndexRecordCount(sesid, tableid, pcrec, crecMax);
	APIReturn(err);
	}


JET_ERR JET_API JetGetObjidFromName(JET_SESID sesid,
	JET_DBID dbid, const char  *szContainerName,
	const char  *szObjectName,
	ULONG_PTR  *pulObjectId )
	{
	ERR err;
    ULONG_PTR ulptrObjId;
    OBJID ObjId;
    
	APIEnter();
	DebugLogJetOp( sesid, opGetObjidFromName );

    ulptrObjId = (*pulObjectId);
    ObjId = (ULONG)ulptrObjId;
    Assert( ObjId == ulptrObjId);
    
	err = ErrIsamGetObjidFromName( sesid, (JET_VDBID)dbid,
		szContainerName, szObjectName, &ObjId );

	APIReturn(err);
	}


//	UNDONE:	remove API
JET_ERR JET_API JetGetChecksum(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long  *pulChecksum )
	{
	ERR err;

	APIEnter();
	DebugLogJetOp( sesid, opGetChecksum );

#if 0
	err = ErrDispGetChecksum(sesid, tableid, pulChecksum );
#else
	err = JET_errFeatureNotAvailable;
#endif

	APIReturn(err);
	}


/***********************************************************
/************* EXTERNAL BACKUP JET API *********************
/*****/
JET_ERR JET_API JetBeginExternalBackup( JET_GRBIT grbit )
	{
	APIEnter();
	APIReturn( fBackupAllowed ?
		ErrIsamBeginExternalBackup( grbit ) :
		JET_errBackupNotAllowedYet );
	}


JET_ERR JET_API JetGetAttachInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual )
	{
	APIEnter();
	APIReturn( ErrIsamGetAttachInfo( pv, cbMax, pcbActual ) );
	}	
		

JET_ERR JET_API JetOpenFile( const char *szFileName,
	JET_HANDLE	*phfFile,
	unsigned long *pulFileSizeLow,
	unsigned long *pulFileSizeHigh )
	{
	APIEnter();
	APIReturn( ErrIsamOpenFile( szFileName, phfFile, pulFileSizeLow, pulFileSizeHigh ) );
	}


JET_ERR JET_API JetReadFile( JET_HANDLE hfFile,
	void *pv,
	unsigned long cb,
	unsigned long *pcbActual )
	{
	APIEnter();
	APIReturn( ErrIsamReadFile( hfFile, pv, cb, pcbActual ) );
	}


JET_ERR JET_API JetCloseFile( JET_HANDLE hfFile )
	{
	APIEnter();
	APIReturn( ErrIsamCloseFile( hfFile ) );
	}


JET_ERR JET_API JetGetLogInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual )
	{
	APIEnter();
	APIReturn( ErrIsamGetLogInfo( pv, cbMax, pcbActual ) );
	}


JET_ERR JET_API JetTruncateLog( void )
	{
	APIEnter();
	APIReturn( ErrIsamTruncateLog( ) );
	}


JET_ERR JET_API JetEndExternalBackup( void )
	{
	APIEnter();
	APIReturn( ErrIsamEndExternalBackup() );
	}


JET_ERR JET_API JetExternalRestore( char *szCheckpointFilePath, char *szLogPath, JET_RSTMAP *rgstmap, long crstfilemap, char *szBackupLogPath, long genLow, long genHigh, JET_PFNSTATUS pfn )
	{
	ERR err;

	if ( fJetInitialized )
		{
		return JET_errAlreadyInitialized;
		}
	
	APIInitEnter();

	/* initJet without init Isam */
	err = ErrInit( fTrue );
	Assert( err != JET_errAlreadyInitialized );
	if ( err >= 0 )
		{
		err = ErrIsamExternalRestore( szCheckpointFilePath, szLogPath,
			rgstmap, crstfilemap, szBackupLogPath, genLow, genHigh, pfn );

		/*  shut down util layer  */
		UtilTerm();
	
		fJetInitialized = fFalse;
		}
	
	APITermReturn( err );
	}

JET_ERR JET_API JetResetCounter( JET_SESID sesid, long CounterType )
	{
	APIEnter();
	APIReturn( ErrIsamResetCounter( sesid, CounterType ) );
	}

JET_ERR JET_API JetGetCounter( JET_SESID sesid, long CounterType, long *plValue )
	{
	APIEnter();
	APIReturn( ErrIsamGetCounter( sesid, CounterType, plValue ) );
	}

JET_ERR JET_API JetCompact(
	JET_SESID		sesid,
	const char		*szDatabaseSrc,
	const char		*szDatabaseDest,
	JET_PFNSTATUS	pfnStatus,
	JET_CONVERT		*pconvert,
	JET_GRBIT		grbit )
	{
	APIEnter();
	APIReturn( ErrIsamCompact( sesid, szDatabaseSrc, szDatabaseDest, pfnStatus, pconvert, grbit ) );
	}

STATIC INLINE JET_ERR JetIUtilities( JET_SESID sesid, JET_DBUTIL *pdbutil )
	{
	APIEnter();
	APIReturn( ErrIsamDBUtilities( sesid, pdbutil ) );
	}	

JET_ERR JET_API JetDBUtilities( JET_DBUTIL *pdbutil )
	{
	JET_ERR			err = JET_errSuccess;
	JET_INSTANCE	instance = 0;
	JET_SESID		sesid = 0;
	BOOL			fInit = fFalse;

	if ( pdbutil->cbStruct != sizeof(JET_DBUTIL) )
		return ErrERRCheck( JET_errInvalidParameter );

	// Don't init if we're only dumping the logfile/checkpoint/DB header.
	switch ( pdbutil->op )
		{
		case opDBUTILDumpHeader:
		case opDBUTILDumpLogfile:
		case opDBUTILDumpCheckpoint:
			Call( ErrIsamDBUtilities( 0, pdbutil ) );
			break;

		default:
			Call( JetInit( &instance ) );
			fInit = fTrue;
			Call( JetBeginSession( instance, &sesid, "user", "" ) );

			Call( JetIUtilities( sesid, pdbutil ) );
		}

HandleError:				
	if ( fInit )
		{
		if ( sesid != 0 )
			{
			JetEndSession( sesid, 0 );
			}

		JetTerm2( instance, err < 0 ? JET_bitTermAbrupt : JET_bitTermComplete );
		}

	return err;		
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\bt.c ===
#include "daestd.h"
#include "util.h"

DeclAssertFile;					/* Declare file name for assert macros */

extern CRIT  critSplit;
extern ULONG cOLCSplitsAvoided;

LOCAL BOOL FBTThere( FUCB *pfucb );
LOCAL INT IbsonBTFrac( FUCB *pfucb, CSR *pcsr, DIB *pdib );


/*	returns fTrue if node is potentially there and fFalse if
/*	node is not potentially there.  A node is potentially there
/*	if it can be there as a result of a transaction committ or
/*	a transaction rollback.
/**/
LOCAL BOOL FBTPotThere( FUCB *pfucb )
	{
	SSIB	*pssib = &pfucb->ssib;
	BOOL	fDelete = FNDDeleted( *pssib->line.pb );
	VS		vs;
	SRID	srid;
	BOOL	fPotThere;

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	if session cursor isolation model is not dirty and node
	/*	has version, then call version store for appropriate version.
	/**/
	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		NDGetBookmark( pfucb, &srid );
		vs = VsVERCheck( pfucb, srid );
		fPotThere = FVERPotThere( vs, fDelete );
		
		return fPotThere;
		}

	return !fDelete;
	}

		
LOCAL BOOL FBTThere( FUCB *pfucb )
	{
	SSIB	*pssib = &pfucb->ssib;

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	if session cursor isolation model is not dirty and node
	/*	has version, then call version store for appropriate version.
	/**/
	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS		ns;
		SRID	srid;

		NDGetBookmark( pfucb, &srid );
		ns = NsVERAccessNode( pfucb, srid );
		return ( ns == nsVersion || ns == nsVerInDB || ns == nsDatabase && !FNDDeleted( *pssib->line.pb ) );
		}

	return !FNDDeleted( *pssib->line.pb );
	}


/*	return fTrue this session can modify current node with out write conflict.
/**/
BOOL FBTMostRecent( FUCB *pfucb )
	{
	SSIB	*pssib = &pfucb->ssib;

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		SRID	srid;
		BOOL	fMostRecent;

		NDGetBookmark( pfucb, &srid );
		fMostRecent = FVERMostRecent( pfucb, srid );
		return fMostRecent;
		}
	Assert( !FNDDeleted( *pssib->line.pb ) );
	return fTrue;
	}


/*	ErrBTGet returns an error is the current node
/*	is not there for the caller, and caches the line.
/**/
ERR ErrBTGet( FUCB *pfucb, CSR *pcsr )
	{
	ERR		err;
	SSIB		*pssib = &pfucb->ssib;

	if ( !FBFReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallR( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
		}
	NDGet( pfucb, pcsr->itag );

	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS		ns;
		SRID	srid;

		NDGetBookmark( pfucb, &srid );
		ns = NsVERAccessNode( pfucb, srid );
		if ( ns == nsDatabase )
			{
			if ( FNDDeleted( *(pfucb->ssib.line.pb) ) )
				return ErrERRCheck( JET_errRecordDeleted );
			}
		else if ( ns == nsInvalid )
			{
			return ErrERRCheck( JET_errRecordDeleted );
			}
		else
			return JET_errSuccess;
		}

	if ( FNDDeleted( *(pfucb->ssib.line.pb) ) )
		return ErrERRCheck( JET_errRecordDeleted );
	return JET_errSuccess;
	}


/*	ErrBTGetNode returns an error if the current node is not there for
/*	the caller, and otherwise caches the line, data and key for the
/*	verion of the node for the caller.
/**/
ERR ErrBTGetNode( FUCB *pfucb, CSR *pcsr )
	{
	ERR		err;
	SSIB  	*pssib = &pfucb->ssib;

	Assert( pcsr->csrstat == csrstatOnCurNode ||
		pcsr->csrstat == csrstatOnFDPNode ||
		pcsr->csrstat == csrstatOnDataRoot ||
		pcsr->csrstat == csrstatBeforeCurNode ||
		pcsr->csrstat == csrstatAfterCurNode );

	if ( !FBFReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallR( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
		}
	NDGet( pfucb, pcsr->itag );

	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS		ns;
		SRID	srid;

		NDGetBookmark( pfucb, &srid );
		ns = NsVERAccessNode( pfucb, srid );
		if ( ns == nsVersion )
			{
			/*	got data but must now get key.
			/**/
			NDGetKey( pfucb );
			}
		else if ( ns == nsDatabase )
			{
			if ( FNDDeleted( *(pfucb->ssib.line.pb) ) )
				return ErrERRCheck( JET_errRecordDeleted );
			NDGetNode( pfucb );
			}
		else if ( ns == nsInvalid )
			{
			return ErrERRCheck( JET_errRecordDeleted );
			}
		else
			{
			Assert( ns == nsVerInDB );
			NDGetNode( pfucb );
			}
		}
	else
		{
		if ( FNDDeleted( *pssib->line.pb ) )
			return ErrERRCheck( JET_errRecordDeleted );
		NDGetNode( pfucb );
		}

	return JET_errSuccess;
	}


#ifdef DEBUG
VOID AssertBTGetNode( FUCB *pfucb, CSR *pcsr )
	{
	SSIB		*pssib = &pfucb->ssib;
	NS			ns;
	SRID		srid;

	AssertFBFReadAccessPage( pfucb, pcsr->pgno );
	AssertNDGet( pfucb, pcsr->itag );

	Assert( CbNDKey( pssib->line.pb ) == pfucb->keyNode.cb );
	Assert( CbNDKey( pssib->line.pb ) == 0 ||
		PbNDKey( pssib->line.pb ) == pfucb->keyNode.pb );

	Assert( FNDVerDel( *pssib->line.pb ) ||
		CbNDData( pssib->line.pb, pssib->line.cb ) == pfucb->lineData.cb );
	Assert( FNDVerDel( *pssib->line.pb ) ||
		pfucb->lineData.cb == 0 ||
		PbNDData( pssib->line.pb ) == pfucb->lineData.pb );

	if ( FNDVersion( *pssib->line.pb ) && !FPIBDirty( pfucb->ppib ) )
		{
		LINE	lineData;

		lineData.pb = pfucb->lineData.pb;
		lineData.cb = pfucb->lineData.cb;

		NDGetBookmark( pfucb, &srid );
		Assert( pcsr->bm == srid );

		ns = NsVERAccessNode( pfucb, srid );
		Assert( ns != nsDatabase || !FNDDeleted( *(pfucb->ssib.line.pb) ) );
		Assert( ns != nsInvalid );
		if ( ns == nsDatabase )
			NDGetNode( pfucb );

//		Assert( lineData.pb == pfucb->lineData.pb );
  		Assert( lineData.cb == pfucb->lineData.cb );
		}
	else
		{
		Assert( !FNDDeleted( *(pfucb->ssib.line.pb) ) );
		}

	return;
	}
#endif


INLINE LOCAL ERR ErrBTIMoveToFather( FUCB *pfucb )
	{
	ERR		err;

	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	/*	allocate new CSR
	/**/
	CallR( ErrFUCBNewCSR( pfucb ) );
	PcsrCurrent( pfucb )->pgno = PcsrCurrent( pfucb )->pcsrPath->pgno;
	PcsrCurrent( pfucb )->itagFather = PcsrCurrent( pfucb )->pcsrPath->itag;
	NDGet( pfucb, PcsrCurrent( pfucb )->itagFather );
	return err;
	}


/*	if a seek land on the first node of a page with a key larger
/*	than the search key or on the last node of a page with the key
/*	smaller than the search key, then we must move to previous or
/*	next pages, respectively, to look for the search key node.
/*	If found equal or less or greater respectively, then done.
/**/
INLINE LOCAL ERR ErrBTIMoveToSeek( FUCB *pfucb, DIB *pdib, BOOL fNext )
	{
	ERR		err;
	INT		s = fNext ? -1 : 1;
	INT		sLimit = fNext ? 1 : -1;
	INT		ctimes = 0;
	PGNO	pgnoPrev = PcsrCurrent( pfucb )->pgno;

	forever
		{
		if ( pgnoPrev != PcsrCurrent( pfucb )->pgno )
			{
			ctimes++;
			pfucb->ppib->cNeighborPageScanned++;
			pgnoPrev = PcsrCurrent( pfucb )->pgno;
			}

		err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fNext, pdib, NULL );
		if ( err < 0 )
			{
			if ( err == JET_errNoCurrentRecord )
				{
				Call( ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), !fNext, pdib, NULL ) );
				break;
				}
			goto HandleError;
			}
		s = CmpStKey( StNDKey( pfucb->ssib.line.pb ), pdib->pkey );
		if ( s == 0 )
			{
			err = JET_errSuccess;
			goto HandleError;
			}
		/*	if s is same sign as limit then break
		/**/
		if ( s * sLimit > 0 )
			{
			Assert( s < 0 && sLimit == -1 || s > 0 && sLimit == 1 );
			break;
			}
		}

	Assert( s != 0 );
	err = ErrERRCheck( s < 0 ? wrnNDFoundLess : wrnNDFoundGreater );


HandleError:
	return err;
	}


INLINE LOCAL ERR ErrBTIMoveToReplace( FUCB *pfucb, KEY *pkey, PGNO pgno, INT itag )
	{
	ERR		err;
	INT		s;
	SSIB	*pssib = &pfucb->ssib;
	CSR		*pcsr = PcsrCurrent( pfucb );
	DIB		dibT = { 0, NULL, fDIRAllNode };
	INT		ctimes = 0;
	PGNO	pgnoPrev = PcsrCurrent( pfucb )->pgno;

	Assert( itag >= 0 && itag < ctagMax );
	Assert( pgno != pgnoNull );

	/*	determine if we seeked high of key, low of key or in key range.
	/**/
	s = CmpStKey( StNDKey( pssib->line.pb ), pkey );

	/*	if not found greater then move forward in key range looking
	/*	for node to replace.  Stop searching forward if keys greater
	/*	than seek key.
	/**/
	if ( s <= 0 )
		{
		do
			{
			if ( pgnoPrev != PcsrCurrent( pfucb )->pgno )
				{
				ctimes++;
				pfucb->ppib->cNeighborPageScanned++;
				pgnoPrev = PcsrCurrent( pfucb )->pgno;
				}

			err = ErrBTNextPrev( pfucb, pcsr, fTrue, &dibT, NULL );
			if ( err < 0 )
				{
				if ( err != JET_errNoCurrentRecord )
					goto HandleError;
				break;
				}
			if ( pcsr->pgno == pgno && pcsr->itag == itag )
				{
				return JET_errSuccess;
				}
			s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
			}
		while ( s <= 0 );
		}

	/*	found greater or ran out of nodes.  Now move previous until
	/*	node to replace found.  Since node was not found greater, it
	/*	must be found on move previous.
	/**/
	do
		{
		if ( pgnoPrev != PcsrCurrent( pfucb )->pgno )
			{
			ctimes++;
			pfucb->ppib->cNeighborPageScanned++;
			pgnoPrev = PcsrCurrent( pfucb )->pgno;
			}

		Call( ErrBTNextPrev( pfucb, pcsr, fFalse, &dibT, NULL ) );
		Assert( CmpStKey( StNDKey( pssib->line.pb ), pkey ) >= 0 );
		}
	while ( pcsr->pgno != pgno || pcsr->itag != itag );

	err = JET_errSuccess;
HandleError:
	return err;
	}


/*	moves to next/prev node which is equal to or greater/less than the
/*	given key.  The only flag read is fDIRReplaceDuplicate which
/*	causes currency to held on a duplicate key if found.
/**/
INLINE LOCAL ERR ErrBTIMoveToInsert( FUCB *pfucb, KEY *pkey, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	INT		s;
	PGNO	pgno;
	DIB		dib;
	BOOL	fDuplicate;
	BOOL	fEmptyPage = fFalse;
	INT		ctimes = 0;
	PGNO	pgnoPrev = PcsrCurrent( pfucb )->pgno;

	/*	if tree is empty then pcsr->itag will be itagNil, and correct
	/*	insert position has been found.
	/**/
	if ( pcsr->itag == itagNil )
		{
		return JET_errSuccess;
		}

	AssertNDGet( pfucb, pcsr->itag );
	s = CmpStKey( StNDKey( pssib->line.pb ), pkey );

	/*	The common case for insert, is inserting a new largest node.  This
	/*	case is shown by a seek to the last node, of the last page, where
	/*	the key found is less than the insert key.  Since this case is the
	/*	most common, it must be handled the most efficiently.
	/**/
	if ( s < 0 )
		{
		PgnoNextFromPage( pssib, &pgno );
		if ( pgno == pgnoNull )
			{
			NDGet( pfucb, pcsr->itagFather );
			if ( pcsr->ibSon == CbNDSon( pssib->line.pb ) - 1 )
				{
				/*	node found has key less than insert key, so move
				/*	to next virtual greater node for insert.
				/**/
				pcsr->ibSon++;
				err = ErrERRCheck( wrnNDFoundGreater );
				return err;
				}
			}
		}

#if 0
	/*	the next most common case is that we landed in the middle of
	/*	a page in a correct position.  We found greater and are not
	/*	on the last son or first son.
	/**/
	if ( s > 0 && pcsr->ibSon > 0 )
		{
		NDGet( pfucb, itagFOP );
		if ( pcsr->ibSon < CbNDSon( pssib->line.pb ) )
			{
			err = ErrERRCheck( wrnNDFoundGreater );
			return err;
			}
		}
#endif

	/*	set DIB for movement over potential nodes.
	/**/
	dib.fFlags = fDIRPotentialNode;

	/*	if found greater or equal, then move previous until found equal
	/*	or less. This must be done to check for any nodes with insert key.
	/*	Only potential nodes need be considered.
	/*
	/*	Note that even if we land via seek on a duplicate, the node
	/*	is not necessarily there.
	/**/
	if ( s >= 0 )
		{
		do
			{
			if ( pgnoPrev != PcsrCurrent( pfucb )->pgno )
				{
				ctimes++;
				pfucb->ppib->cNeighborPageScanned++;
				pgnoPrev = PcsrCurrent( pfucb )->pgno;
				}

			err = ErrBTNextPrev( pfucb, pcsr, fFalse, &dib, NULL );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					{
					s = -1;
					break;
					}
				goto HandleError;
				}
			s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
			}
		while ( s > 0 );
		}

	/*	initialize fDuplicate
	/**/
	fDuplicate = ( s == 0 );

	/*	set DIB for movement over all nodes
	/**/
	dib.fFlags = fDIRAllNode;

	/*	move next until find greater
	/**/
	Assert( fEmptyPage == fFalse );
	do
		{
		if ( pgnoPrev != PcsrCurrent( pfucb )->pgno )
			{
			ctimes++;
			pfucb->ppib->cNeighborPageScanned++;
			pgnoPrev = PcsrCurrent( pfucb )->pgno;
			}

		err = ErrBTNextPrev( pfucb, pcsr, fTrue, &dib, &fEmptyPage );
		if ( err < 0 )
			{
			if ( err == JET_errNoCurrentRecord )
				{
				/*	may have moved to empty page.
				/**/
				s = 1;
				break;
				}
			goto HandleError;
			}
		s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
		if ( s == 0 && FBTPotThere( pfucb ) )
			{
			fDuplicate = fTrue;
			}
		}
	while ( s <= 0 );
	Assert( s > 0 );

	/*	Need to move previous to duplicate if fDIRReplaceDuplicate
	/*	flag set.
	/**/
	if ( ( fDuplicate && ( fFlags & fDIRReplaceDuplicate ) ) )
		{
		/*	set DIB for movement over potential nodes.
		/**/
		dib.fFlags = fDIRPotentialNode;
		err = ErrBTNextPrev( pfucb, pcsr, fFalse, &dib, NULL );

		// May have had to traverse an empty page to find the node we want.
		Assert( err == JET_errSuccess  ||  err == wrnDIREmptyPage );
		Assert( CmpStKey( StNDKey( pssib->line.pb ), pkey ) == 0 );
		s = 0;
		}
	else if ( fEmptyPage )
		{
		if ( err == JET_errNoCurrentRecord )
			{
			Assert( pcsr->csrstat == csrstatAfterLast );
			Assert( pcsr->bmRefresh == sridNull );
			Assert( pcsr->ibSon == 0 );
			pcsr->csrstat = csrstatOnCurNode;
			}
		else
			{
			/*	on first node of the page next to empty page.
			 */
			Assert( err == wrnDIREmptyPage );
			Assert( pcsr->ibSon == 0 );
			Assert( pcsr->csrstat == csrstatOnCurNode );

			/*	set fDIRAllPage to land on empty page.
			 */
			dib.fFlags = fDIRAllNode | fDIRAllPage;
			err = ErrBTNextPrev( pfucb, pcsr, fFalse, &dib, &fEmptyPage );
			Assert( err == wrnDIREmptyPage  &&  fEmptyPage );
			Assert( pcsr->csrstat == csrstatOnCurNode );
			Assert( pcsr->bmRefresh == sridNull );
			Assert( pcsr->ibSon == 0 );
			}

		if ( pfucb->ssib.pbf != pfucb->pbfEmpty )
			{
			/*	interfered by other ppib's split.
			 */
			pfucb->ppib->cLatchConflict++;

			err = ErrERRCheck( errDIRNotSynchronous );
			goto HandleError;
			}
		Assert( pfucb->ssib.pbf->cWriteLatch > 0 &&
			pfucb->ssib.pbf->ppibWriteLatch == pfucb->ppib );


		/*	node may have been inserted.  If found then check for
		/*	duplicate.
		/**/
/*		if ( fEmptyPage )
			{
			s = 1;
			}
		else
			{
			s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
			if ( s == 0 && FBTPotThere( pfucb ) )
				{
				fDuplicate = fTrue;
				}
			}
*/
		// UNDONE:  Remove "if ( EmptyPage )" construct above, because
		// fEmptyPage is always TRUE.
		Assert( fEmptyPage );
		s = 1;
		}

	Assert( s >= 0 );
	Assert( ( fFlags & fDIRReplaceDuplicate ) || s > 0 );
	if ( s == 0 )
		err = JET_errSuccess;
	else
		err = ErrERRCheck( wrnNDFoundGreater );

	/*	check for illegal duplicate key.
	/**/
	if ( fDuplicate && !( fFlags & fDIRDuplicate ) )
		err = ErrERRCheck( JET_errKeyDuplicate );
HandleError:
	return err;
	}


ERR ErrBTDown( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	ERR		errPos;
	CSR		*pcsr;
	SSIB	*pssib = &pfucb->ssib;
	INT		s;
	INT		ctagSon = 0;
	BOOL	fMoveToSeek = fFalse;

#ifdef DEBUG
#define TRACK	DEBUG
#endif	// DEBUG

#ifdef	TRACK
	/* added for tracking index bug
	/**/
	BOOL	fTrack = fFalse;
	ULONG	cInvNodes = 0;
	PGNO	pgno = pgnoNull;
#endif

	/*	search down the tree from father
	/**/
	CallR( ErrBTIMoveToFather( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	tree may be empty
	/**/
	if ( FNDNullSon( *pssib->line.pb ) )
		{
		err = ErrERRCheck( JET_errRecordNotFound );
		goto HandleError;
		}

	/*	search down the tree from father.
	/*	set pssib->itag for invisible son traversal.
	/**/
	if ( !FNDVisibleSons( *pssib->line.pb ) )
		{
		/*	seek through invisible sons.
		/**/
		do
			{
#ifdef TRACK
			cInvNodes++;
#endif
			/*	get child page from intrisic page pointer
			/*	if son count is 1 or from page pointer node
			/**/
			if ( pcsr->itagFather != itagFOP && CbNDSon( pssib->line.pb ) == 1 )
				{
				/*	if non-FDP page, SonTable of Intrinsic son FOP must be four bytes
				/**/
				AssertNDIntrinsicSon( pssib->line.pb, pssib->line.cb );
				CSRInvalidate( pcsr );
				pcsr->pgno = PgnoNDOfPbSon( pssib->line.pb );
				}
			else
				{
				switch ( pdib->pos )
					{
					case posDown:
						NDSeekSon( pfucb, pcsr, pdib->pkey, fDIRReplace );
						break;
					case posFirst:
						NDMoveFirstSon( pfucb, pcsr );
						break;
					case posLast:
						NDMoveLastSon( pfucb, pcsr );
						break;
					default:
						{
						Assert( pdib->pos ==  posFrac );
						pcsr->ibSon = (SHORT)IbsonBTFrac( pfucb, pcsr, pdib );
						CallS( ErrNDMoveSon( pfucb, pcsr ) );
						}
					}
				CSRInvalidate( pcsr );
				pcsr->pgno = *(PGNO UNALIGNED *)PbNDData( pssib->line.pb );
				}

			/*	get child page father node
			/**/
			Call( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
			NDGet( pfucb, itagFOP );
			pcsr->itagFather = itagFOP;
			}
		while ( !FNDVisibleSons( *pssib->line.pb ) );
		}

	/*	down to visible son
	/**/
	if ( FNDSon( *pssib->line.pb ) )
		{
		ctagSon = CbNDSon( pssib->line.pb );
	
#ifdef TRACK
		fTrack |= 0x00000010;
#endif

		switch ( pdib->pos )
			{
			case posDown:
				NDSeekSon( pfucb, pcsr, pdib->pkey, fDIRReplace );
				break;
			case posFirst:
				NDMoveFirstSon( pfucb, pcsr );
				break;
			case posLast:
				NDMoveLastSon( pfucb, pcsr );
				break;
			default:
				{
				Assert( pdib->pos ==  posFrac );
				pcsr->ibSon = (SHORT)IbsonBTFrac( pfucb, pcsr, pdib );
				CallS( ErrNDMoveSon( pfucb, pcsr ) );
				}
			}
		}
	else
		{
		/*	must move to seek
		/**/
		fMoveToSeek = fTrue;
#ifdef TRACK
		fTrack |=  0x00000008;
#endif

		/*	if we land on an empty page and there are no next previous
		/*	nodes.  What if the tree is empty.  We must first reverse
		/*	direction and if no node is found then return an empty tree
		/*	error code.  The empty tree error code should be the same
		/*	regardless of the size of the tree.
		/**/
		err = ErrBTNextPrev( pfucb, pcsr, pdib->pos != posLast, pdib, NULL );
		if ( err == JET_errNoCurrentRecord )
			Call( ErrBTNextPrev( pfucb, pcsr, pdib->pos == posLast, pdib, NULL ) );
		NDGet( pfucb, itagFOP );
		/* get right ctagSon */
		ctagSon = CbNDSon( pssib->line.pb );
		/* adjust pssib line back to the landed node */
		NDGet( pfucb, PcsrCurrent( pfucb )->itag );
		}

	/*	we have landed on a visible node
	/**/
	if ( pdib->pos == posDown )
		{
		s = CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey );
		if ( s == 0 )
			errPos = JET_errSuccess;
		else
			{
#ifdef	TRACK
			fTrack |= s < 0 ? 0x00000002 : 0x00000004;
#endif

			errPos = ErrERRCheck( s < 0 ? wrnNDFoundLess : wrnNDFoundGreater );

			/*	if on last node in page and found less, or if landed on
			/*	first node in page and found greater, move next or previous
			/*	to look for node with search key.  These anomalies can
			/*	occur during update seek normally, and during read seek
			/*	when partial split pages are encountered.
			/**/
			Assert( pcsr->ibSon >= 0 && pcsr->ibSon < ctagSon );
			Assert( errPos == wrnNDFoundGreater &&
				pcsr->ibSon == 0 || pcsr->ibSon <= ( ctagSon - 1 ) );
			if ( fMoveToSeek ||
				( errPos == wrnNDFoundLess && pcsr->ibSon == ( ctagSon - 1 ) ) ||
				( pcsr->ibSon == 0 ) )
				{
				Call( ErrBTIMoveToSeek( pfucb, pdib, errPos == wrnNDFoundLess ) );
				errPos = err;
				}
			}
		}
	else
		{
		errPos = JET_errSuccess;
		}

	if ( !( pdib->fFlags & fDIRAllNode )  &&  !FBTThere( pfucb ) )
		{
#ifdef TRACK
		fTrack |= 0x00000001;
#endif

		if ( pdib->pos == posDown )
			{
			/*	if current node is not there for us then move to next node.
			/*	if no next node then move to previous node.
			/*	if no previous node then return error.
			/**/
			err = ErrBTNextPrev( pfucb, pcsr, fTrue, pdib, NULL );
			if ( err < 0 && err != JET_errNoCurrentRecord )
				goto HandleError;
			if ( err == JET_errNoCurrentRecord )
				{
#ifdef TRACK
				fTrack |= 0x80000000;
#endif
				Call( ErrBTNextPrev( pfucb, pcsr, fFalse, pdib, NULL ) );
				}

			/*	preferentially land on lesser key value node
			/**/
			if ( CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey ) > 0 )
				{
#ifdef TRACK
				fTrack |= 0x40000000;
#endif
				err = ErrBTNextPrev( pfucb, pcsr, fFalse, pdib, NULL );
				if ( err == JET_errNoCurrentRecord )
					{
#ifdef TRACK
					fTrack |= 0x20000000;
#endif
					CallS( ErrBTNextPrev( pfucb, pcsr, fTrue, pdib, NULL ) );
					err = JET_errSuccess;
					}
				}

			/*	reset errPos for new node location
			/**/
			if ( FKeyNull( pdib->pkey ) )
				{
				errPos = JET_errSuccess;
				}
			else
				{
#ifdef TRACK
				fTrack |= 0x10000000;
#endif
				s = CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey );
				if ( s == 0 )
					errPos = JET_errSuccess;
				else
					errPos = ErrERRCheck( s < 0 ? wrnNDFoundLess : wrnNDFoundGreater );
				Assert( s != 0 || errPos == JET_errSuccess );
				}

			Assert( err != JET_errKeyBoundary && err != JET_errPageBoundary );
			if ( err == JET_errNoCurrentRecord )
				{
#ifdef TRACK
				fTrack |= 0x08000000;
#endif
				/*	move previous
				/**/
				Call( ErrBTNextPrev( pfucb, pcsr, fFalse, pdib, NULL ) );
				errPos = ErrERRCheck( wrnNDFoundLess );
				}
			else if ( err < 0 )
				goto HandleError;
			}
		else
			{
			err = ErrBTNextPrev( pfucb, pcsr, pdib->pos != posLast, pdib, NULL );
			if ( err == JET_errNoCurrentRecord )
				{
				/*	if fractional positioning, then try to
				/*	move previous to valid node.
				/**/
				if ( pdib->pos == posFrac )
					{
					err = ErrBTNextPrev( pfucb, pcsr, fFalse, pdib, NULL );
					}
				else
					err = JET_errRecordNotFound;
				}
			if ( err < 0 )
				goto HandleError;
			}
		}
	
	Assert( errPos >= 0 );
	FUCBResetStore( pfucb );
	return errPos;

HandleError:
	BTUp( pfucb );
	if ( err == JET_errNoCurrentRecord )
		err = ErrERRCheck( JET_errRecordNotFound );
	return err;
	}


ERR ErrBTDownFromDATA( FUCB *pfucb, KEY *pkey )
	{
	ERR		err;
	ERR		errPos;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB 	*pssib = &pfucb->ssib;
	INT		s;
	INT		ctagSon = 0;
	BOOL 	fMoveToSeek = fFalse;

	/*	cache initial currency in case seek fails.
	/**/
	FUCBStore( pfucb );

	/*	set father currency to DATA root
	/**/
	pcsr->csrstat = csrstatOnCurNode;

	/*	read access page and check for valid time stamp
	/**/
	CSRInvalidate( pcsr );
	pcsr->pgno = PgnoRootOfPfucb( pfucb );
	while ( !FBFReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallR( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
		pcsr->pgno = PgnoRootOfPfucb( pfucb );
		}
	pcsr->itagFather = ItagRootOfPfucb( pfucb );

	NDGet( pfucb, pcsr->itagFather );

	/* save current node as visible father
	/**/
	if ( FNDBackLink( *((pfucb)->ssib.line.pb) ) )
		{
		pfucb->sridFather = *(SRID UNALIGNED *)PbNDBackLink((pfucb)->ssib.line.pb);
		}
	else																						
		{
		pfucb->sridFather = SridOfPgnoItag( pcsr->pgno, pcsr->itagFather );
		}
	Assert( pfucb->sridFather != sridNull );
	Assert( pfucb->sridFather != sridNullLink );

	/*	tree may be empty
	/**/
	if ( FNDNullSon( *pssib->line.pb ) )
		{
		err = ErrERRCheck( JET_errRecordNotFound );
		return err;
		}

	/*	search down the tree from father.
	/*	set pssib->itag for invisible son traversal.
	/**/
	if ( !FNDVisibleSons( *pssib->line.pb ) )
		{
		/*	seek through invisible sons.
		/**/
		do
			{
			/*	get child page from intrisic page pointer
			/*	if son count is 1 or from page pointer node
			/**/
			if (  pcsr->itagFather != itagFOP && CbNDSon( pssib->line.pb ) == 1 )
				{
				/*	If non-FDP page, SonTable of Intrinsic son FOP must be four bytes
				/**/
				AssertNDIntrinsicSon( pssib->line.pb, pssib->line.cb );
//				CSRInvalidate( pcsr );
				pcsr->pgno = PgnoNDOfPbSon( pssib->line.pb );
				}
			else
				{
				NDSeekSon( pfucb, pcsr, pkey, fDIRReplace );
//				CSRInvalidate( pcsr );
				pcsr->pgno = *(PGNO UNALIGNED *)PbNDData( pssib->line.pb );
				}

			/*	get child page father node
			/**/
			Call( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
			NDGet( pfucb, itagFOP );
			pcsr->itagFather = itagFOP;
			}
		while ( !FNDVisibleSons( *pssib->line.pb ) );
		}

	/*	down to visible son
	/**/
	if ( FNDSon( *pssib->line.pb ) )
		{
		ctagSon = CbNDSon( pssib->line.pb );
		NDSeekSon( pfucb, pcsr, pkey, fDIRReplace );
		}
	else
		{
		DIB	dibT;

		/*	must move to seek
		/**/
		fMoveToSeek = fTrue;

		/*	If we land on an empty page and there are no next previous
		/*	nodes.  What if the tree is empty.  We must first reverse
		/*	direction and if no node is found then return an empty tree
		/*	error code.  The empty tree error code should be the same
		/*	regardless of the size of the tree.
		/**/
		dibT.fFlags = fDIRNull;
		err = ErrBTNextPrev( pfucb, pcsr, fTrue, &dibT, NULL );
		if ( err == JET_errNoCurrentRecord )
			Call( ErrBTNextPrev( pfucb, pcsr, fFalse, &dibT, NULL ) );

		/*	determine number of sons in FOP for this page
		/**/
		NDGet( pfucb, itagFOP );
		ctagSon = CbNDSon( pssib->line.pb );

		/*	recache son node.
		/**/
		NDGet( pfucb, pcsr->itag );
		}

	/*	we have landed on a visible node
	/**/
	s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
	if ( s == 0 )
		errPos = JET_errSuccess;
	else
		{
		errPos = ErrERRCheck( s < 0 ? wrnNDFoundLess : wrnNDFoundGreater );

		/*	if on last node in page and found less, or if landed on
		/*	first node in page and found greater, move next or previous
		/*	to look for node with search key.  These anomalies can
		/*	occur during update seek normally, and during read seek
		/*	when partial split pages are encountered.
		/**/
		Assert( ( ctagSon == 0 && pcsr->ibSon == 0 ) ||
			pcsr->ibSon < ctagSon );
		Assert( errPos == wrnNDFoundGreater &&
			pcsr->ibSon == 0 ||
			ctagSon == 0 ||
			pcsr->ibSon <= ( ctagSon - 1 ) );
		if ( fMoveToSeek ||
			( errPos == wrnNDFoundLess && pcsr->ibSon == ( ctagSon - 1 ) ) ||
			( errPos == wrnNDFoundGreater && pcsr->ibSon == 0 ) )
			{
			DIB	dibT;

			dibT.fFlags = fDIRNull;
			dibT.pkey = pkey;

			Call( ErrBTIMoveToSeek( pfucb, &dibT, errPos == wrnNDFoundLess ) );
			errPos = err;
			}
		}

	if ( !FBTThere( pfucb ) )
		{
		DIB		dibT;

		dibT.fFlags = fDIRNull;

		/*	if current node is not there for us then move to next node.
		/*	if no next node then move to previous node.
		/*	if no previous node then return error.
		/**/
		err = ErrBTNextPrev( pfucb, pcsr, fTrue, &dibT, NULL );
		if ( err < 0 && err != JET_errNoCurrentRecord )
			goto HandleError;
		if ( err == JET_errNoCurrentRecord )
			{
			Call( ErrBTNextPrev( pfucb, pcsr, fFalse, &dibT, NULL ) );
			}

		/*	preferentially land on lesser key value node
		/**/
		if ( CmpStKey( StNDKey( pssib->line.pb ), pkey ) > 0 )
			{
			err = ErrBTNextPrev( pfucb, pcsr, fFalse, &dibT, NULL );
			if ( err == JET_errNoCurrentRecord )
				{
				/*	cannot assume will find node since all nodes
				/*	may not be there for this session.
				/**/
				Call( ErrBTNextPrev( pfucb, pcsr, fTrue, &dibT, NULL ) );
				}
			}

		/*	reset errPos for new node location
		/**/
		s = CmpStKey( StNDKey( pssib->line.pb ), pkey );
		if ( s > 0 )
			errPos = ErrERRCheck( wrnNDFoundGreater );
		else if ( s < 0 )
			errPos = ErrERRCheck( wrnNDFoundLess );
		Assert( s != 0 || errPos == JET_errSuccess );

		Assert( err != JET_errKeyBoundary && err != JET_errPageBoundary );
		if ( err == JET_errNoCurrentRecord )
			{
			DIB	dibT;
			dibT.fFlags = fDIRNull;

			/*	move previous
			/**/
			Call( ErrBTNextPrev( pfucb, pcsr, fFalse, &dibT, NULL ) );
			errPos = ErrERRCheck( wrnNDFoundLess );
			}
		else if ( err < 0 )
			goto HandleError;
		}

	Assert( errPos >= 0 );
	return errPos;

HandleError:
	FUCBRestore( pfucb );
	if ( err == JET_errNoCurrentRecord )
		err = ErrERRCheck( JET_errRecordNotFound );
	return err;
	}


//+private------------------------------------------------------------------------
//	ErrBTNextPrev
// ===========================================================================
//	ERR ErrBTNextPrev( FUCB *pfucb, CSR *pcsr INT fNext, const DIB *pdib, BOOL *pfEmptyPage  )
//
//	Given pcsr may be to any CSR in FUCB stack.  We may be moving on
//	non-current CSR when updating CSR stack for split.
//
// RETURNS		JET_errSuccess
//				JET_errNoCurrentRecord
//				JET_errPageBoundary
//				JET_errKeyBoundary
//				wrnDIREmptyPage
//				error from called routine
//----------------------------------------------------------------------------

extern LONG	lPageReadAheadMax;

// #ifdef REPAIR

/**************************************************************
	Reads the next page using the parent node
/**/
ERR ErrBTNextPrevFromParent(
		FUCB *pfucb,
		CSR *pcsr,
		INT cpgnoNextPrev,
		PGNO *ppgnoNextPrev )
	{
	/*	get next page(s) from parent page
	/**/
	ERR		err;
	KEY		keyT;
	INT		itagT;
	PGNO	pgnoT;
	DIB		dibT = { 0, NULL, fDIRAllNode };
	CSR   	**ppcsr = &PcsrCurrent( pfucb );
	BF		*pbfT = NULL;
	CSR		*pcsrRoot = pcsrNil;
	CSR		*pcsrSav = pcsrNil;
	BOOL	fNext;

	Assert( pfucb );
	Assert( pcsr );
	Assert( cpgnoNextPrev != 0 );
	Assert( ppgnoNextPrev );

	/*	unhandled cases
	/**/
	if ( FFUCBFull( pfucb ) )
		{
		return JET_errSuccess;
		}

	Assert( pcsr->bmRefresh != sridNull );
	if ( ItagOfSrid( pcsr->bmRefresh ) == 0 )
		{
		return ErrERRCheck( JET_errNoCurrentRecord );
		}

  	Call( ErrBTGotoBookmark( pfucb, pcsr->bmRefresh ) );
	err = ErrBTGet( pfucb, pfucb->pcsr );
	if ( err < 0 && err != JET_errRecordDeleted )
		{
		goto HandleError;
		}
	pbfT = pfucb->ssib.pbf;
	BFPin( pbfT );
	NDGetNode( pfucb );
	keyT.cb = pfucb->keyNode.cb;
	keyT.pb = pfucb->keyNode.pb;
	itagT = pfucb->pcsr->itag;
	pgnoT = pfucb->pcsr->pgno;
	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection( critJet );
	FUCBSetFull( pfucb );
	pcsrSav = PcsrCurrent( pfucb );
	/*	perform	BTUp( pfucb ); explicitly and save
	/*	CSR for error handling.  This must be done since
	/*	assumptions made at other BT/DIR functions that
	/*	CSR is present on error.
	/**/
	pfucb->pcsr = pcsrSav->pcsrPath;
	pcsrRoot = PcsrCurrent( pfucb );
	if ( PcsrCurrent( pfucb ) == pcsrNil )
		{
		Assert( FFUCBIndex( pfucb ) );
		Call( ErrFUCBNewCSR( pfucb ) );

		/*	goto DATA root
		/**/
		PcsrCurrent( pfucb )->csrstat = csrstatOnDataRoot;
		Assert( pfucb->u.pfcb->pgnoFDP != pgnoSystemRoot );
		PcsrCurrent( pfucb )->bm = SridOfPgnoItag( pfucb->u.pfcb->pgnoFDP, itagDATA );
		PcsrCurrent( pfucb )->itagFather = itagNull;
		PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
		if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
			{
			Call( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
			}

		Assert( PcsrCurrent( pfucb )->pgno == PgnoRootOfPfucb( pfucb ) );
		PcsrCurrent( pfucb )->itag = ItagRootOfPfucb( pfucb );
		}
	else
		{
		if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
			{
			Call( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
			}
		}
	err = ErrBTSeekForUpdate( pfucb,
		&keyT,
		pgnoT,
		itagT,
		fDIRDuplicate | fDIRReplace );
	Assert( err != errDIRNotSynchronous );		// No DIRNotSynchronous on Replace.
	LeaveNestableCriticalSection( critSplit );
	if ( err < 0 )
		{
		Assert( pcsrSav->pcsrPath == pfucb->pcsr );
		pfucb->pcsr = pcsrSav;
		}
	else
		{
		MEMReleasePcsr( pcsrSav );
		pcsrSav = pcsrNil;
		}
	Call( err );

	Assert( cpgnoNextPrev != 0 );
	fNext = (cpgnoNextPrev > 0) ? fTrue : fFalse;

	if ( cpgnoNextPrev < 0 )
		{
		/*	this will only fail is cpgnoNextPrev = -MAXINT
		/**/
		Assert( (cpgnoNextPrev + -cpgnoNextPrev) == 0 );
		cpgnoNextPrev = -cpgnoNextPrev;
		}

	/*	position to the first page to be read
	/**/
	while ( cpgnoNextPrev-- > 0 )
		{
		Call( ErrBTNextPrev( pfucb,
			pfucb->pcsr->pcsrPath,
			fNext,
			&dibT,
			NULL ) );
		}

	Call( ErrBTGet( pfucb, pfucb->pcsr->pcsrPath ) );
	*ppgnoNextPrev = *(PGNO UNALIGNED *)PbNDData( pfucb->ssib.line.pb );
	Assert( *ppgnoNextPrev != pgnoNull );

HandleError:
	if ( PcsrCurrent( pfucb) != pcsrRoot )
		{
		FUCBFreePath( &(*ppcsr)->pcsrPath, pcsrRoot );
		}
	FUCBRemoveInvisible( ppcsr );
	FUCBResetFull( pfucb );
	if ( pbfT != NULL )
		{
		BFUnpin( pbfT );
		}
	return err;
	}
// #endif

/**************************************************************
/*	Fills an array of pn's with the given number of pages
/*	starting from the given location and continuing in that direction
/*	the array will be terminated with pnNull
/**/
ERR ErrBTChildListFromParent(
		FUCB *pfucb,
		INT cpgnoNextPrev,		// where to start reading (positive forward, negative backward)
		INT cpgnoNumPages,		// number of pages to read
		PN  *rgpnNextPrev,		// array of pages to read
		INT cpgnoPgnoSize )		// size of the page array
	{
	ERR		err;
	FUCB	*pfucbT		= pfucbNil;
	BYTE   	*pbSonTable = pbNil;	
	INT		ibSonT 		= 0;
	INT		itagT		= itagNull;
	INT		ipnT		= 0;
	PGNO	pgnoT		= pgnoNull;
	INT		itagParent	= itagNull;
	KEY		keyT;
	INT		fCritSplit	= 0;		// are we in critSplit

	BYTE	rgbKeyValue[JET_cbKeyMost];

	AssertCriticalSection( critJet );
	Assert( pfucb );
	Assert( cpgnoNextPrev != 0 );
	Assert( cpgnoNumPages > 0 );
	Assert( rgpnNextPrev );
	/*	we must have enough space to store the pages and a NULL terminator
	/**/
	Assert( cpgnoPgnoSize >= (cpgnoNumPages+1) );

	rgpnNextPrev[0] = pnNull;
	rgpnNextPrev[cpgnoNumPages] = pnNull;

	/*	later code depends on this initially being NULL
	/**/
	Assert( !pfucbT );

	/*	if we are not on a record we cannot preread its siblings
	/**/
	if ( ItagOfSrid( PcsrCurrent( pfucb )->bmRefresh ) == 0 )
		{
		return ErrERRCheck( JET_errNoCurrentRecord );
		}

	/*	we don't handle the case where our visible father is not known
	/**/
	if ( pfucb->sridFather == sridNull )
		{
		return JET_errSuccess;
		}

	/*	if my visible parent is on the same page as me don't do preread
	/**/
	if ( PgnoOfSrid( pfucb->sridFather ) == PcsrCurrent( pfucb )->pgno )
		{	
		return JET_errSuccess;
		}

	/*	get the page we are on. we have to make sure the node is valid
	/**/
	if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
		{
		Call( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		}
	NDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	save the key of the current node so we can seek to it. the value of the
	/*	key cached in the fucb may change when we lose critJet so we must cache it
	/**/
	keyT.cb = CbNDKey( pfucb->ssib.line.pb );
	keyT.pb = rgbKeyValue;
	Assert( keyT.cb <= JET_cbKeyMost );
	memcpy( keyT.pb, PbNDKey( pfucb->ssib.line.pb ), keyT.cb );
	itagT = PcsrCurrent( pfucb )->itag;
	pgnoT = PcsrCurrent( pfucb )->pgno;

	/*	create a new FUCB
	/**/
	Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	FUCBSetIndex( pfucbT );
	Assert( PcsrCurrent( pfucbT ) != pcsrNil );

	/*	get into critJet and critSplit
	/*	release critJet first to avoid deadlock
	/*	ONCE WE ARE IN CRITJET WE MUST NOT RETURN DIRECTLY
	/*	critJet must always be released. this is done by HandleError
	/**/
	LeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );	fCritSplit = 1;
	EnterCriticalSection( critJet );

	AssertCriticalSection( critJet );
	AssertCriticalSection( critSplit );

	/*	set the new FUCB to the visible parent of the old fucb
	/**/
	FUCBSetFull( pfucbT );
	Call( ErrBTGotoBookmark( pfucbT, pfucb->sridFather ) );

/*	we shouldn't access the old pfucb until the end of the routine
/*	REMEMBER TO UNDEF THIS AT THE END OF THE ROUTINE
/**/
#define pfucb USE_pfucbT_NOT_pfucb

	if ( !FBFReadAccessPage( pfucbT, PcsrCurrent( pfucbT )->pgno ) )
		{
		Call( ErrBFReadAccessPage( pfucbT, PcsrCurrent( pfucbT )->pgno ) );
		}
	NDGet( pfucbT, PcsrCurrent( pfucbT )->itag );

	Call ( ErrBTSeekForUpdate( pfucbT, &keyT, pgnoT, itagT, fDIRDuplicate | fDIRReplace ) );

	/*	we should have a parent (we can't be the root)
	/**/
	Assert( PcsrCurrent( pfucbT )->pcsrPath != pcsrNil );

	/*	the parent should be on a different page, and thus invisible
	/**/
	if( PcsrCurrent( pfucbT )->pcsrPath->pgno == PcsrCurrent( pfucbT )->pgno )
		{
		goto HandleError;
		}

	/*	we have the full path. find the parent and get the array of children
	/*	as our parent is invisible we must have a grandparent
	/**/
	Assert( PcsrCurrent( pfucbT ) != pcsrNil );
	Assert( PcsrCurrent( pfucbT )->pcsrPath != pcsrNil );
	Assert( PcsrCurrent( pfucbT )->pcsrPath->pgno != pgnoNull );
	Assert( PcsrCurrent( pfucbT )->pcsrPath->itag != itagNull );
	Assert( PcsrCurrent( pfucbT )->pcsrPath->itagFather != itagNull );

	BTUp( pfucbT );

	itagParent = PcsrCurrent( pfucbT )->itag;

	Assert( PcsrCurrent( pfucbT )->pgno != pgnoNull );
	Assert( PcsrCurrent( pfucbT )->itag != itagNull );
		
 	/*	get the father node. the children should be invisible
	/**/
	if ( !FBFReadAccessPage( pfucbT, PcsrCurrent( pfucbT )->pgno ) )
		{
		Call( ErrBFReadAccessPage( pfucbT, PcsrCurrent( pfucbT )->pgno ) );
		}
	NDGet( pfucbT, PcsrCurrent( pfucbT )->itagFather );
	
	Assert( FNDSon( *(pfucbT->ssib.line.pb) ) );
	Assert( FNDInvisibleSons( *(pfucbT->ssib.line.pb) ) );

	/*	get the table of son nodes
	/**/
	pbSonTable = PbNDSonTable( pfucbT->ssib.line.pb );

	/*	find my entry in the array of children.
	/*	use the entry to go to the starting spot
	/**/
	Assert( itagParent != itagNull );
	for ( ibSonT = 1; ; ibSonT++)
		{
		Assert( ibSonT <= *pbSonTable );
		if ( itagParent == (INT)pbSonTable[ ibSonT ] )
			{
			break;
			}
		}
			
	Assert( ibSonT >= 1 && ibSonT <= *pbSonTable );
	ibSonT += cpgnoNextPrev;

	for ( ipnT = 0; ; ipnT++ )
		{
		Assert( ipnT <= cpgnoNumPages && ipnT >= 0 );

		/*	we can not read off the end of the table or read too many pages
		/**/
		if ( (ibSonT >= *pbSonTable) || (ibSonT < 1) || (ipnT >= cpgnoNumPages) )
			{
			rgpnNextPrev[ipnT] = pnNull;
			break;
			}			
	
		PcsrCurrent( pfucbT )->itag = (INT)pbSonTable[ibSonT];
		NDGet( pfucbT, PcsrCurrent( pfucbT )->itag );

		/*	if the node is deleted skip it
		/**/
		if ( FNDDeleted( *(pfucbT->ssib.line.pb) ) )
			{
			continue;
			}

		/*	internal nodes should never be versioned
		/**/
		Assert( !FNDDeleted( *(pfucbT->ssib.line.pb) ) );
		Assert( !FNDVersion( *(pfucbT->ssib.line.pb) ) );
		
		/*	put the page number of the node into the array
		/**/
		Assert( CbNDData( pfucbT->ssib.line.pb, pfucbT->ssib.line.cb ) == sizeof(PGNO) );
		Assert( *(PGNO UNALIGNED *)PbNDData( pfucbT->ssib.line.pb ) != pgnoNull );
		Assert( *(PGNO UNALIGNED *)PbNDData( pfucbT->ssib.line.pb ) != PcsrCurrent( pfucbT )->pgno );
		rgpnNextPrev[ipnT] = PnOfDbidPgno( pfucbT->dbid, *(PGNO UNALIGNED *)PbNDData( pfucbT->ssib.line.pb ) );
		Assert( rgpnNextPrev[ipnT] != pnNull );

#ifdef DEBUG
		/*	each child should be on a different page
		/**/
		if ( ipnT > 0 )
			{
			Assert( rgpnNextPrev[ipnT-1] != rgpnNextPrev[ipnT] );
			}
		/*	make sure the page is within the limits of the database
		/**/
			{
			PN		pnLast	= ( (LONG) DbidOfPn( rgpnNextPrev[ipnT] ) << 24 )
							+ ( rgfmp[DbidOfPn( rgpnNextPrev[ipnT] )].ulFileSizeHigh << 20 )
							+ ( rgfmp[DbidOfPn( rgpnNextPrev[ipnT] )].ulFileSizeLow >> 12 );

			Assert( rgpnNextPrev[ipnT] <= pnLast );
			}
#endif	// DEBUG

		/*	increment or decrement the counter
		/**/
		if ( cpgnoNextPrev >= 0 )
			{
			ibSonT++;
			}
		else
			{
			ibSonT--;
			}
		}
#undef pfucb		// IMPORTANT!!

	/*	see if we wrote past the end of the array
	/**/
	Assert( rgpnNextPrev[cpgnoNumPages] == pnNull );
	Assert( rgpnNextPrev[0] == pnNull || DbidOfPn( rgpnNextPrev[0] ) == pfucb->dbid );

	/*	make sure the array is null terminated
	/**/
	rgpnNextPrev[cpgnoNumPages] = pnNull;

HandleError:
	if ( pfucbT )
		{
		FUCBResetFull( pfucbT );
		DIRClose( pfucbT );	
		pfucbT = NULL;
		}

	if ( fCritSplit )
		{
		LeaveNestableCriticalSection( critSplit ); fCritSplit = 0;
		}
	AssertCriticalSection( critJet );
	return err;
	}


ERR ErrBTNextPrev( FUCB *pfucb, CSR *pcsr, INT fNext, DIB *pdib, BOOL *pfEmptyPage )
	{
	ERR 	err;
	SSIB	*pssib = &pfucb->ssib;
	PGNO	pgnoSource;
	PGNO	pgnoT;
	ERR		wrn = JET_errSuccess;
	ULONG	crepeat = 0;
#ifdef DEBUG
	SRID	bmT = sridNull;
	PGNO	pgnoLastPageRegistered = pgnoNull;
#endif
	BOOL	fPageAllDeleted = fFalse;

	/*	initialise return value
	/**/
	if ( pfEmptyPage )
		*pfEmptyPage = fFalse;

	/*	make current page accessible
	/**/
	if ( !FBFReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallJ( ErrBFReadAccessPage( pfucb, pcsr->pgno ), ResetRefresh );
		}

	Assert( pcsr->bmRefresh == sridNull );

	/*	get father node
	/**/
Start:
		
#ifdef PREREAD
	/*	should we be prereading?
	/**/
#if 0
	//	UNDONE:	turn on full preread
	if ( ( lPageReadAheadMax != 0 )
		&& !FFUCBPreread( pfucb )		
		&& ( FFUCBSequential( pfucb ) || ( IFUCBPrereadCount( pfucb ) >= (ULONG)cbPrereadThresh ) ) )
#else
	/*	Now we only preread if we are in sequential mode
	/**/
	if ( ( lPageReadAheadMax > 0 ) && FFUCBSequential( pfucb ) )
#endif
		{
		PGNO	pgnoNext = pgnoNull;
		FUCBSetPreread( pfucb );	// stops recursive calls

		Assert( lPageReadAheadMax <= lPrereadMost );
		Assert( lPageReadAheadMax >= 0 );
		
		/*	Forward or backward?
		/**/					
		if ( fNext )
			{
			PgnoNextFromPage( pssib, &pgnoNext );
			}
		else
			{
			PgnoPrevFromPage( pssib, &pgnoNext );
			}

		if ( pgnoNext == pgnoNull )
			{
			/*	reset read-ahead counter when reach end of index.
			/**/
			pfucb->cpgnoLastPreread = 0;
			}
		else
			{
			/*	do preread if this is first time to do it or
		 	/*	half of last preread are passed.
			/**/
			Assert( pfucb->cpgnoLastPreread >= 0 );
			if ( pfucb->cpgnoLastPreread <= (lPageReadAheadMax/2) )
				{
				CPG cpgPagesRead = 0;
				CPG cpgStart;
				PN	rgpnPrereadPage[lPrereadMost + 1];

				AssertFBFReadAccessPage( pfucb, pcsr->pgno );

				/*	if no pages read, arrange to start reading one ahead or behind, depending on fNext
				/**/
				(pfucb->cpgnoLastPreread)--;
				if ( pfucb->cpgnoLastPreread <= 0 )
					{
					cpgStart = 1;
					pfucb->cpgnoLastPreread = 0;
					}
				else
					{
					cpgStart = pfucb->cpgnoLastPreread;
					}

				if ( !fNext )
					{
					cpgStart = -cpgStart;
					}

				/*	starting at last preread location preread ahead the required number of pages
				/*	if we try to read past the end BTChildListFromParent will put a null page in the
				/*	array
				/**/
				if ( ErrBTChildListFromParent( 	pfucb,
												cpgStart,
												lPageReadAheadMax, rgpnPrereadPage,
								  				sizeof(rgpnPrereadPage)/sizeof(PN) ) == JET_errSuccess )
					{
					/*	store the number of pages we read
					/**/
					(pfucb->cpgnoLastPreread) += lPageReadAheadMax;
			
					BFPrereadList( rgpnPrereadPage, &cpgPagesRead );
			
					Assert( cpgPagesRead >= 0 && cpgPagesRead <= sizeof(rgpnPrereadPage)/sizeof(PN) );
					}
			
				/*	make current page accessible again
				/**/
				if ( !FBFReadAccessPage( pfucb, pcsr->pgno ) )
					{
					CallJ( ErrBFReadAccessPage( pfucb, pcsr->pgno ), ResetRefresh );
					}
				}
			else
				{
				/*	decrement the number of pages we have now gotten from preread
				/**/
				(pfucb->cpgnoLastPreread)--;
				}
			}

		FUCBResetPreread( pfucb );
		}
#endif	// PREREAD

	/*	make current page accessible
	/**/
	if ( !FBFReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallR( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
		}

	NDGet( pfucb, pcsr->itagFather );

	pcsr->ibSon += ( fNext ? 1 : -1 );
	err = ErrNDMoveSon( pfucb, pcsr );
	if ( err < 0 )
		{
		Assert( err == errNDOutSonRange );

		/*	if tree interior to page, then there is no page to move
		/*	to and return end code.
		/**/
		if ( pcsr->itagFather != itagFOP )
			{
			pcsr->csrstat = fNext ? csrstatAfterCurNode : csrstatBeforeCurNode;
			err = ErrERRCheck( JET_errNoCurrentRecord );
			goto HandleError;
			}

		pgnoSource = pcsr->pgno;

		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itagFather );
		if ( FNDSon( *pssib->line.pb ) )
			{
			/*	store bookmark for current node
			/**/
			NDGet( pfucb, pcsr->itag );
			NDGetBookmarkFromCSR( pfucb, pcsr, &pcsr->bmRefresh );
			}
		else
			{
			/*	store currency for refresh, when cursor
			/*	is on page with no sons.
			/**/
			pcsr->bmRefresh = SridOfPgnoItag( pcsr->pgno, itagFOP );

			/*	if  page is write latched by this cursor via
			/*	split then return wrnDIREmptyPage.  In most cases, this is
			/*	set below when we move onto the page.  However, if we come
			/*	into BTNextPrev() already sitting on an empty page, we won't
			/*	catch this in the code below.
			/**/
			if ( pfucb->ssib.pbf->cWriteLatch > 0 )
				{
				Assert( !FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) );

				if ( pfEmptyPage )
					*pfEmptyPage = fTrue;

				/*	for compatibility, return warning code as well
				/*	to satisfy those calls to ErrBTNextPrev wrapped in
				/*	CallS()
				/**/
				wrn = ErrERRCheck( wrnDIREmptyPage );
				}
			}

#ifdef DEBUG
		bmT = pcsr->bmRefresh;
#endif

		/*	move to next or previous page until node found
		/**/
		forever
			{
			PGNO pgnoBeforeMoveNextPrev = pcsr->pgno;
#ifdef DEBUG
			PGNO pgnoPageRegisteredThisIteration = pgnoNull;
#endif			

			/*	there may not be a next page
			/**/
	 		Assert( FBFReadAccessPage( pfucb, pcsr->pgno ) );
			LFromThreeBytes( &pgnoT, (THREEBYTES *)PbPMGetChunk( pssib, fNext ? ibPgnoNextPage : ibPgnoPrevPage ) );
			if ( pgnoT == pgnoNull )
				{
				pcsr->csrstat = fNext ? csrstatAfterLast : csrstatBeforeFirst;
				err = ErrERRCheck( JET_errNoCurrentRecord );
				goto HandleError;
				}

			/*	if parent CSR points to invisible node, then correct to next page.
			/*	Check all node flag, since it is always set on movement for
			/*	update, and when moving not for update, parent CSR may not be CSR
			/*	of parent invisible node.
			/**/
			if ( FFUCBFull( pfucb ) )
				{
				CSR	*pcsrT = pcsr->pcsrPath;
				DIB	dibT = { 0, NULL, fDIRAllNode };

				Assert( pcsrT != pcsrNil );

				/*	go to parent node, and
				/*	if sons are invisible, then increment son count
				/*	by cpageTraversed.
				/**/
				Call( ErrBFReadAccessPage( pfucb, pcsrT->pgno ) );
				NDGet( pfucb, pcsrT->itagFather );

				if ( FNDInvisibleSons( *pssib->line.pb ) )
					{
					err = ErrBTNextPrev( pfucb, pcsrT, fNext, &dibT, NULL );
					Assert( err != JET_errNoCurrentRecord );
					Call( err );
					}
				}

			if ( fGlobalRepair )
				{
				/*	access new page
				/**/
				err = ErrBFReadAccessPage( pfucb, pgnoT );
				if ( err == JET_errDiskIO  ||  err == JET_errReadVerifyFailure )
					{
					/*	access next to next, or prev to prev, page
					/*	and pretend next/prev page was prev/next page.
					/**/
					pgnoBeforeMoveNextPrev = pgnoT;

					Call( ErrBTNextPrevFromParent(
								pfucb,
								pcsr,
								fNext ? 2 : -2,
								&pgnoT) );
					pcsr = pfucb->pcsr;
					Call( ErrBFReadAccessPage( pfucb, pgnoT ) );

					/*	log event
					/**/
					UtilReportEvent(
						EVENTLOG_WARNING_TYPE,
						REPAIR_CATEGORY,
						REPAIR_BAD_PAGE_ID,
						0, NULL );
					}
				else
					{
					Assert( err >= JET_errSuccess );
					}
				pcsr->pgno = pgnoT;
				}
			else
				{
				/*  if FUCB is in sequential mode, hint buffer manager to use
				/*  Toss Immediate buffer algorithm on old page (if present)
				/**/
				if ( FFUCBSequential( pfucb ) )
					{
					AssertFBFReadAccessPage( pfucb, pcsr->pgno );
					BFTossImmediate( pfucb->ppib, pfucb->ssib.pbf );
					}
				
				/*	access new page
				/**/
				CSRInvalidate( pcsr );
				pcsr->pgno = pgnoT;		// Prevents BM cleanup from acting on
										// the page we're about to move to.
				
				if ( fPageAllDeleted )
					{
					// Sequential mode only used by defrag, so no need to
					// register page.
					if ( !FFUCBSequential( pfucb ) && pfucb->sridFather != sridNull )
						{
						/*	register page in MPL
				 		/**/
				 		Call( ErrBFReadAccessPage( pfucb, pgnoBeforeMoveNextPrev ) );
						MPLRegister( pfucb->u.pfcb,
							pssib,
							PnOfDbidPgno( pfucb->dbid, pgnoBeforeMoveNextPrev ),
							pfucb->sridFather );
#ifdef DEBUG						
				 		pgnoPageRegisteredThisIteration = pgnoBeforeMoveNextPrev;
				 		pgnoLastPageRegistered = pgnoPageRegisteredThisIteration;
#endif			 		
						}
					
					fPageAllDeleted = fFalse;
   					}

				Call( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
				}

			UtilHoldCriticalSection( critJet );

			/*	if destination page was split, such that data may have
			/*	been erroneously skipped, goto bookmark of last valid
			/*	postion and move again.
			/**/
			if ( fNext )
				{
				PgnoPrevFromPage( pssib, &pgnoT );
				}
			else
				{
				PgnoNextFromPage( pssib, &pgnoT );
				}

			if ( fGlobalRepair )
				{
				if ( pgnoBeforeMoveNextPrev != pgnoT )
					{
					PGNO	pgnoNextPrev;

					UtilReleaseCriticalSection( critJet );
					Call( ErrBTNextPrevFromParent(
								pfucb,
								pcsr,
								fNext ? 1 : -1,
								&pgnoNextPrev) );
					pcsr = pfucb->pcsr;
					pcsr->pgno = pgnoNextPrev;
					Call( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
					UtilHoldCriticalSection( critJet );
	
					/*	log event
					/**/
					UtilReportEvent(
						EVENTLOG_WARNING_TYPE,
						REPAIR_CATEGORY,
						REPAIR_PAGE_LINK_ID,
						0, NULL );
					}
				}
			else
				{
				if ( pgnoBeforeMoveNextPrev != pgnoT )
					{
					UtilReleaseCriticalSection( critJet );
					BFSleep( cmsecWaitGeneric );

					Call( ErrBTGotoBookmark( pfucb, pcsr->bmRefresh ) );
					Assert( pcsr->bmRefresh == bmT );

					/*	crepeat is number of iterations found bad page link,
					/*	which could be transient effect of split.  If number
					/*	of loops exceeds threshold, then return error, as
					/*	page link is likely bad.
					/**/
					crepeat++;
					Assert( crepeat < 100 );
					if ( crepeat == 100 )
						{
						/*	log event
						/**/
						UtilReportEvent(
							EVENTLOG_WARNING_TYPE,
							GENERAL_CATEGORY,
							BAD_PAGE,
							0,
							NULL );
						Error( JET_errBadPageLink, HandleError );
						}

					continue;
					}
				}

			AssertFBFReadAccessPage( pfucb, pcsr->pgno );

#ifdef PREREAD
	/*	UNDONE: eventually remove this and and option to turn it on in compact.c
	/**/
	if ( (lPageReadAheadMax < 0) 	&& FFUCBSequential( pfucb ) )
		{
		LONG	lPageReadAheadAbs = lPageReadAheadMax * -1;
		PGNO	pgnoNext;
		INT 	cpagePreread;

		if ( fNext )
			{
			PgnoNextFromPage( pssib, &pgnoNext );
			if ( pgnoNext == pgnoNull )
				{
				/*	reset read-ahead counter when reach end of index.
				/**/
				pfucb->cpgnoLastPreread = 0;
				}
			else
				{
				/*	do preread if this is first time to do it or
				 *	half of last preread are passed.
				 */
				if ( pfucb->cpgnoLastPreread <= 0 )
					{
					/*	check if last preread is reading backward,
					 *	reset it.
					 */
					pfucb->cpgnoLastPreread = 0;
					pfucb->pgnoLastPreread = pgnoNext;
					}

				Assert( pfucb->cpgnoLastPreread >= 0 );
				if ( pfucb->cpgnoLastPreread == 0 ||
					 pgnoNext > ( pfucb->pgnoLastPreread + ( pfucb->cpgnoLastPreread / 2 ) ) )
					{
					FMP *pfmpT = &rgfmp[ pfucb->dbid ];
					PN pnNext, pnLast;

					pnNext = ((LONG)pfucb->dbid)<<24;
					pnNext += pfucb->pgnoLastPreread + pfucb->cpgnoLastPreread;

					/*	cannot read-ahead off end of database.
					/**/
					pnLast = ((LONG)pfucb->dbid)<<24;
					pnLast += pfmpT->ulFileSizeHigh << 20;
					pnLast += pfmpT->ulFileSizeLow >> 12;
					if ( pnNext + lPageReadAheadAbs - 1 <= pnLast )
						{
						BFPreread( pnNext, lPageReadAheadAbs, &cpagePreread );
						}
					else
						{
						if ( pnNext > pnLast )
							{
							/* last preread reach end of database.
							 */
							Assert( pnNext == pnLast + 1 );
							cpagePreread = 0;
							}
						else
							{
							BFPreread( pnNext, pnLast - pnNext + 1, &cpagePreread );
							}
						}
					Assert( cpagePreread >= 0 && cpagePreread <= (LONG) ( pnLast - pnNext + 1 ) );
					pfucb->cpgnoLastPreread = cpagePreread;
					pfucb->pgnoLastPreread = PgnoOfPn(pnNext);
					AssertFBFReadAccessPage( pfucb, pcsr->pgno );
					}
				}
			}
		else
			{
			PgnoPrevFromPage( pssib, &pgnoNext );
			if ( pgnoNext == pgnoNull )
				{
				/*	reset read-ahead counter when reach end of index.
				/**/
				pfucb->cpgnoLastPreread = 0;
				}
			else
				{
				/*	do preread if this is first time to do it or
				 *	half of last preread are passed.
				 */
				if ( pfucb->cpgnoLastPreread >= 0 )
					{
					/*	check if last preread is reading forward,
					 *	reset it.
					 */
					pfucb->cpgnoLastPreread = 0;
					pfucb->pgnoLastPreread = pgnoNext;
					}
				Assert( pfucb->cpgnoLastPreread <= 0 );
				if ( pfucb->cpgnoLastPreread == 0 ||
					 pgnoNext < ( pfucb->pgnoLastPreread + ( pfucb->cpgnoLastPreread / 2 ) ) )
					{
					PN pnNext;
					pnNext = ((LONG)pfucb->dbid)<<24;
					pnNext += pfucb->pgnoLastPreread + pfucb->cpgnoLastPreread;
	
					/*	cannot read-ahead off begining of database.
					/**/
					if ( pnNext - lPageReadAheadAbs + 1 > 0 )
						{
						BFPreread( pnNext, lPageReadAheadAbs * (-1), &cpagePreread );
						}
					else
						{
						if ( PgnoOfPn(pnNext) < 1 )
							{
							/* last preread reach beginning of database.
							 */
							Assert( PgnoOfPn(pnNext) == 0 );
							cpagePreread = 0;
							}
						else
							BFPreread( pnNext, PgnoOfPn(pnNext) * (-1), &cpagePreread );
						}
					Assert( cpagePreread >= (LONG) PgnoOfPn( pnNext ) * (-1) && cpagePreread <= 0 );
					pfucb->cpgnoLastPreread = cpagePreread;
					pfucb->pgnoLastPreread = PgnoOfPn( pnNext );
					AssertFBFReadAccessPage( pfucb, pcsr->pgno );
					}
				}
			}	
		}
#endif	// PREREAD

			/*	did not lose critJet, since buffer access
			/**/
			AssertCriticalSection( critJet );
			UtilReleaseCriticalSection( critJet );
			AssertFBFReadAccessPage( pfucb, pcsr->pgno );

			/*	get father node
			/**/
			AssertFBFReadAccessPage( pfucb, pcsr->pgno );
			pcsr->itagFather = itagFOP;
			NDGet( pfucb, pcsr->itagFather );

			/*	if moving to next/prev son, then stop if found node.
			/**/
			if ( FNDSon( *pssib->line.pb ) )
				{
				if ( fNext )
					NDMoveFirstSon( pfucb, pcsr );
				else
					NDMoveLastSon( pfucb, pcsr );
				break;
				}
			else
				{
				/*	set ibSon for insertion
				/**/
				pcsr->ibSon = 0;

				/*	if  page is write latched by this cursor via
				/*	split then return wrnDIREmptyPage as insertion point
				/**/
				if ( pfucb->ssib.pbf->cWriteLatch > 0 )
					{
					/*	The assert may be wrong. One thread may finish split
					 *	and leave critJet to log, and this thread is access the
					 *	empty page generated by that split.
					 */
//					Assert( !FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) );

					if ( pfEmptyPage )
						*pfEmptyPage = fTrue;

					// For compatibility, return warning code as well
					// (to satisfy those calls to BTNextPrev() wrapped in
					// CallS()).
					wrn = ErrERRCheck( wrnDIREmptyPage );
					}

				if ( pdib->fFlags & fDIRAllPage )
					{
					err = JET_errSuccess;
					goto HandleError;
					}
				}

			/*	update pgnoSource to new source page.
			/**/
			pgnoSource = pcsr->pgno;
			
			}	// forever

		fPageAllDeleted = fTrue;
		}

	/*	get current node
	/**/
	NDGet( pfucb, pcsr->itag );

	/*	move again if fDIRNeighborKey set and next node has same key
	/**/
	if ( pdib->fFlags & fDIRNeighborKey )
		{
		if ( CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey ) == 0 )
			goto Start;
		}

	if ( !( pdib->fFlags & fDIRAllNode ) )
		{
		if ( !FNDDeleted(*(pfucb->ssib.line.pb)) )
			fPageAllDeleted = fFalse;

		if ( !FBTThere( pfucb ) )
			{
#ifdef OLC_DEBUG
			Assert( FMPLLookupPN( PnOfDbidPgno( pfucb->dbid, pcsr->pgno ) ) ||
					FNDMaxKeyInPage( pfucb ) ||
					pcsr->pgno == 0xb );
#endif

			if ( ( pdib->fFlags & fDIRPotentialNode ) != 0 )
				{
				VS		vs;
				BOOL	fDelete = FNDDeleted( *pssib->line.pb );
				SRID	srid;

				NDGetBookmark( pfucb, &srid );
				vs = VsVERCheck( pfucb, srid );
				if ( !( FVERPotThere( vs, fDelete ) ) )
					{
					goto Start;
					}
				}
			else
				goto Start;
			}
		}

	pcsr->csrstat = csrstatOnCurNode;
	err = JET_errSuccess;

HandleError:
	if ( err == JET_errSuccess )
		{
		Assert( wrn == JET_errSuccess  ||  wrn == wrnDIREmptyPage );
		/*	return empty page warning
		/**/
		err = wrn;
		}

ResetRefresh:
	// During GlobalRepair, pcsr (and thus bmRefresh) may have been reset in
	// BTNextPrevFromParent().
	Assert( pcsr->bmRefresh == bmT  ||
		( fGlobalRepair  &&  pcsr->bmRefresh == sridNull ) );
	pcsr->bmRefresh = sridNull;
	return err;
	}


ERR ErrBTSeekForUpdate( FUCB *pfucb, KEY *pkey, PGNO pgno, INT itag, INT fFlags )
	{
	ERR		err;
	CSR		**ppcsr = &PcsrCurrent( pfucb );
	CSR		*pcsrRoot = *ppcsr;
	SSIB 	*pssib = &pfucb->ssib;
	ERR		errPos = JET_errSuccess;

	Assert( ( fFlags & fDIRReplace ) || pgno == pgnoNull );

#ifdef DEBUG
	if ( FFUCBFull( pfucb ) )
		{
		AssertCriticalSection( critSplit );
		}
#endif

	// UNDONE: we need to hold critSplit here
	// so that ( pgno, itag ) doesn't move due to merge, while we are seeking
	// AssertCriticalSection( critSplit );

	/* search down the tree from the father
	/**/
	Call( ErrBTIMoveToFather( pfucb ) );

	if ( FNDNullSon( *pssib->line.pb ) )
		{
		(*ppcsr)->ibSon = 0;
		errPos = ErrERRCheck( wrnNDFoundGreater );
		goto Done;
		}

	while ( !FNDVisibleSons(*pssib->line.pb) )
		{
		PGNO	pgno;

		if (  (*ppcsr)->itagFather != itagFOP && CbNDSon( pssib->line.pb ) == 1 )
			{
			/* if non-FDP page, SonTable of Intrinsic son FOP must be four bytes
			/**/
			(*ppcsr)->ibSon = 0;
			(*ppcsr)->itag = itagNil;
			(*ppcsr)->csrstat = csrstatOnCurNode;
			AssertNDIntrinsicSon( pssib->line.pb, pssib->line.cb );
			pgno = PgnoNDOfPbSon( pssib->line.pb );
			Assert( (pgno & 0xff000000) == 0 );
			}
		else
			{
			NDSeekSon( pfucb, *ppcsr, pkey, fFlags );
			(*ppcsr)->csrstat = csrstatOnCurNode;
			pgno = *(PGNO UNALIGNED *)PbNDData( pssib->line.pb );
			Assert( (pgno & 0xff000000) == 0 );
			}

		/*	only preserve invisible CSR stack for splits
		/**/
		if ( FFUCBFull( pfucb ) )
			{
			CSRSetInvisible( *ppcsr );
			Call( ErrFUCBNewCSR( pfucb ) );
			}

		CSRInvalidate( *ppcsr );
		(*ppcsr)->pgno = pgno;
		Call( ErrBFReadAccessPage( pfucb, (*ppcsr)->pgno ) );
		(*ppcsr)->itagFather = itagFOP;
		NDGet( pfucb, (*ppcsr)->itagFather );
		}

	/*	seek to son or move to next son if no nodes on this page.
	/**/
	if ( FNDSon( *pssib->line.pb ) )
		{
		NDSeekSon( pfucb, *ppcsr, pkey, fFlags );
		(*ppcsr)->csrstat = csrstatOnCurNode;

		/*	no current record indicates no sons so must ensure
		/*	not this error value here.
		/**/
		Assert( err != JET_errNoCurrentRecord );
		}
	else if ( !( fFlags & fDIRReplace )  &&
		FBFWriteLatchConflict( pfucb->ppib, pssib->pbf ) )
		{
		// Trying to insert, but we landed on a write-latched (not by us) leaf page,
		// likely because its currently empty.
		pfucb->ppib->cLatchConflict++;
		err = ErrERRCheck( errDIRNotSynchronous );
		goto HandleError;
		}
	else
		{
		DIB	dib;
		dib.fFlags = fDIRAllNode;
		err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib, NULL );
		if ( err == JET_errNoCurrentRecord )
			{
			err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fFalse, &dib, NULL );
			Assert( err >= JET_errSuccess || PcsrCurrent( pfucb )->ibSon == 0 );
			}
		}

	/*	if no leaf sons then ibSon must be 0
	/**/
	Assert( err != JET_errNoCurrentRecord || PcsrCurrent( pfucb )->ibSon == 0 );

	/*	now we must be on a node, but it may not be the node to replace
	/*	or the correct location to insert.  If we are replacing a node
	/*	and we are not on the correct pgno:itag, then move to node to
	/*	replace.  If we are inserting, then move to correct insert location.
	/**/
	if ( err != JET_errNoCurrentRecord )
		{
		if ( fFlags & fDIRReplace )
			{
			if ( ( (*ppcsr)->pgno != pgno || (*ppcsr)->itag != itag ) )
				{
				Call( ErrBTIMoveToReplace( pfucb, pkey, pgno, itag ) );
				Assert( (*ppcsr)->itag == itag && (*ppcsr)->pgno == pgno );
				}
			errPos = JET_errSuccess;
			(*ppcsr)->csrstat = csrstatOnCurNode;
			}
		else
			{
			Call( ErrBTIMoveToInsert( pfucb, pkey, fFlags ) );
			errPos = err;
			(*ppcsr)->csrstat = csrstatBeforeCurNode;
			}
		}
	else
		{
		/*	if we are attempting a replace, cursor must get current record
		/**/
		Assert( !( fFlags & fDIRReplace ) );
		}

Done:
	FUCBResetStore( pfucb );
	return errPos;

HandleError:
	FUCBFreePath( ppcsr, pcsrRoot );
	return err;
	}


/*	Caller seeks to insert location, prior to calling ErrBTInsert.
/*	If sufficient page space is available for insertion
/*	then insert takes place.  Otherwise, split page and return error
/*	code.  Caller may reseek in order to avoid duplicate keys, merge
/*	into existing item, etc..
/**/
ERR ErrBTInsert(
		FUCB	*pfucb,
		INT 	fHeader,
		KEY 	*pkey,
		LINE	*pline,
		INT		fFlags,
		BOOL	*pfCleaned )
	{
	ERR		err;
	SSIB	*pssib = &pfucb->ssib;
	CSR	  	**ppcsr = &PcsrCurrent( pfucb );
	INT	  	cbReq;
	BOOL	fAppendNextPage;
	
	/* insert a new son into the page and insert the son entry
	/* to the father node located by the currency
	/**/

	Assert( !pfucb->pbfEmpty || PgnoOfPn( pfucb->pbfEmpty->pn ) == (*ppcsr)->pgno );

	cbReq = cbNullKeyData + CbKey( pkey ) + CbLine( pline );
	fAppendNextPage = FBTAppendPage( pfucb, *ppcsr, cbReq, 0, CbFreeDensity( pfucb ), 1 );
	if ( fAppendNextPage || FBTSplit( pssib, cbReq, 1 ) )
		{
		if ( !*pfCleaned )
			{
			/*	attempt to clean page to release space
			/**/
			if ( !FFCBDeletePending( pfucb->u.pfcb ) )
				{
				/*	error code ignored
				/**/
				err = ErrBMCleanBeforeSplit(
					pfucb->ppib,
					pfucb->u.pfcb,
					PnOfDbidPgno( pfucb->dbid, PcsrCurrent( pfucb )->pgno ) );
				}
			*pfCleaned = fTrue;

			if ( !( FBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) ) )
				{
				Call( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
				}
			}
		else
			{
			Call( ErrBTSplit( pfucb, 0, cbReq, pkey, fFlags ) );
//			*pfCleaned = fFalse;
			}
			
		err = ErrERRCheck( errDIRNotSynchronous );
		goto HandleError;
		}
	else if ( *pfCleaned )
		{
		cOLCSplitsAvoided++;
		}

	/*	must not give up critical section during insert, since
	/*	other thread could also insert node with same key.
	/**/
	AssertFBFWriteAccessPage( pfucb, (*ppcsr)->pgno );

	/*	add visible son flag to node header
	/**/
	NDSetVisibleSons( fHeader );
	if ( ( fFlags & fDIRVersion )  &&  !FDBIDVersioningOff( pfucb->dbid ) )
		NDSetVersion( fHeader);
	Call( ErrNDInsertNode( pfucb, pkey, pline, fHeader, fFlags ) );
	PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
HandleError:
	return err;
	}


ERR ErrBTReplace( FUCB *pfucb, LINE *pline, INT fFlags, BOOL *pfCleaned )
	{
	ERR		err;
	
	/*	replace data
	/**/
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	err = ErrNDReplaceNodeData( pfucb, pline, fFlags );

	/*	new data could not fit on page so split page
	/**/
	if ( err == errPMOutOfPageSpace )
		{
		if ( *pfCleaned )
			{
			SSIB	*pssib;
			INT		cbNode;
			INT		cbReq;
			INT		cbReserved = 0;

			AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
			pssib = &pfucb->ssib;

			if ( FNDVersion( *pfucb->ssib.line.pb ) )
				{
				VS	vs = VsVERCheck( pfucb, PcsrCurrent( pfucb )->bm );

				switch ( vs )
					{
					default:
						Assert( vs == vsCommitted );
						break;
					case vsUncommittedByCaller:
						pssib->itag = PcsrCurrent( pfucb )->itag;
						cbReserved = CbVERGetNodeReserve(
							pfucb->ppib,
							pfucb->dbid,
							PcsrCurrent( pfucb )->bm,
							CbNDData( pfucb->ssib.line.pb, pfucb->ssib.line.cb ) );
						Assert( cbReserved >= 0 );
						break;
					case vsUncommittedByOther:
						// Don't bother trying the split if the operation
						// is going to fail anyway.
						err = ErrERRCheck( JET_errWriteConflict );
						return err;
					}
				}

			cbNode = pfucb->ssib.line.cb;
			cbReq = pline->cb - CbNDData( pssib->line.pb, pssib->line.cb );
			Assert( cbReserved >= 0 && cbReq - cbReserved > 0 );
			cbReq -= cbReserved;
			Assert( cbReq > 0 );
			Assert( pfucb->pbfEmpty == pbfNil );
			Call( ErrBTSplit( pfucb, cbNode, cbReq, NULL, fFlags | fDIRDuplicate | fDIRReplace ) );
			Assert( pfucb->pbfEmpty == pbfNil );
			err = ErrERRCheck( errDIRNotSynchronous );
			}
		else
			{
			/*	attempt to clean page to release space
			/**/
			err = ErrBMCleanBeforeSplit(
						pfucb->ppib,
						pfucb->u.pfcb,
						PnOfDbidPgno( pfucb->dbid, PcsrCurrent( pfucb )->pgno ) );
			*pfCleaned = fTrue;
		
			err = ErrERRCheck( errDIRNotSynchronous );
			}
		}
	else if ( *pfCleaned )
		{
		/*	the cleanup paid off
		/**/
		cOLCSplitsAvoided++;
		}

HandleError:
	return err;
	}


ERR ErrBTDelete( FUCB *pfucb, INT fFlags )
	{
	ERR		err;

	/*	write access current node
	/**/
	if ( !( FBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) ) )
		{
		Call( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		}

	Call( ErrNDFlagDeleteNode( pfucb, fFlags ) );

	Assert( err == JET_errSuccess );
HandleError:
	return err;
	}


/* Gets the invisible csrPath to this page
/* using BTSeekForUpdate from sridFather
/**/
ERR ErrBTGetInvisiblePagePtr( FUCB *pfucb, SRID sridFather )
	{
	ERR		err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	CSR  	**ppcsr = &PcsrCurrent( pfucb );
	/*	store currency for split path construction
	/**/
	BYTE	rgb[JET_cbKeyMost];
	KEY		key;
	PGNO	pgno;
	INT		itag;

	/*	cache pgno, itag and key of current node
	/*	for subsequent seek for update
	/**/
	pgno = (*ppcsr)->pgno;
	itag = (*ppcsr)->itag;
	key.pb = rgb;
	NDGet( pfucb, (*ppcsr)->itag );
	key.cb = CbNDKey( pssib->line.pb );
	Assert( sizeof(rgb) >= key.cb );
	memcpy( rgb, PbNDKey( pssib->line.pb ), key.cb );

	/*	move to visible father and seek for update.
	/**/
	FUCBStore( pfucb );
	Call( ErrBTGotoBookmark( pfucb, sridFather ) );
	if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
		{
		CallR( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		}
	/*	if sridFather is of node in same page to free then
	/*	return error.
	/**/
	if ( PcsrCurrent( pfucb )->pgno == pgno )
		return ErrERRCheck( errDIRInPageFather );
	FUCBSetFull( pfucb );
	err = ErrBTSeekForUpdate( pfucb, &key, pgno, itag, fDIRReplace );
	Assert( err != errDIRNotSynchronous );		// No DIRNotSynchronous on replace.

	FUCBResetFull( pfucb );
	Call( err );
	Assert( err == JET_errSuccess );

	Assert( (*ppcsr)->pgno == pgno && (*ppcsr)->itag == itag );
	Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );
	FUCBResetStore( pfucb );
	return err;

HandleError:
	FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrNil );
	FUCBRestore( pfucb ) ;
	return err;
	}


#ifdef DEBUG
/*	checks the invisible csrPath to this page
/*	using BTSeekForUpdate from sridFather
/**/
ERR ErrBTCheckInvisiblePagePtr( FUCB *pfucb, SRID sridFather )
	{
	ERR		err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	CSR  	**ppcsr = &PcsrCurrent( pfucb );
	/*	store currency for split path construction
	/**/
	BYTE	rgb[JET_cbKeyMost];
	KEY		key;
	PGNO	pgno;
	INT		itag;

	/*	cache pgno, itag and key of current node
	/*	for subsequent seek for update
	/**/
	pgno = (*ppcsr)->pgno;
	itag = (*ppcsr)->itag;
	key.pb = rgb;
	NDGet( pfucb, (*ppcsr)->itag );
	key.cb = CbNDKey( pssib->line.pb );
	Assert( sizeof(rgb) >= key.cb );
	memcpy( rgb, PbNDKey( pssib->line.pb ), key.cb );

	/*	move to visible father and seek for update.
	/**/
	FUCBStore( pfucb );
	Call( ErrBTGotoBookmark( pfucb, sridFather ) );

	if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
		{
		CallR( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		}
	
	err = ErrBTSeekForUpdate( pfucb, &key, pgno, itag, fDIRReplace );
	Assert( err != errDIRNotSynchronous );		// No DIRNotSynchronous on replace.

	Call( err );
	Assert( err == JET_errSuccess );

	Assert( (*ppcsr)->pgno == pgno && (*ppcsr)->itag == itag );
	Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );
	FUCBResetStore( pfucb );
	return err;

HandleError:
	FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrNil );
	FUCBRestore( pfucb ) ;
	return err;
	}
#endif


ERR ErrBTGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal )
	{
	ERR 	 	err;
	CSR			*pcsrRoot = PcsrCurrent( pfucb );
	CSR			*pcsrT;
	SSIB	 	*pssib = &pfucb->ssib;
	BYTE	 	rgb[JET_cbKeyMost];
	KEY			key;
	ULONG	 	ulTotal;
	ULONG	 	ulLT;
	PGNO	 	pgno = PcsrCurrent( pfucb )->pgno;
	INT			itag = PcsrCurrent( pfucb )->itag;

	/*	ErrBTGetPosition returns the position of the current leaf node
	/*	with respect to its siblings in the current tree.  The position
	/*	is returned in the form of an estimated total tree leaf nodes,
	/*	at the leaf level, and an estimated number
	/*	of nodes at the same level, occurring previous in key order to
	/*	the current node.
	/*
	/*	create full path from parent to node.  Calculate estimates
	/*	from path page information.  Free invisable path.
	/**/

	/*	this function only supports index leaf nodes
	/**/
	Assert( FFUCBIndex( pfucb ) );

	/*	cache key of current node
	/**/
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	key.cb = CbNDKey( pssib->line.pb );
	memcpy( rgb, PbNDKey( pssib->line.pb ), key.cb );
	key.pb = rgb;

	CallR( ErrFUCBNewCSR( pfucb ) );

	/*	goto data root
	/**/
	Assert( pfucb->u.pfcb->pgnoFDP != pgnoSystemRoot );
	PcsrCurrent( pfucb )->bm = SridOfPgnoItag( pfucb->u.pfcb->pgnoFDP, itagDATA );
	PcsrCurrent( pfucb )->itagFather = itagNull;
	PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
	while( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
		{
		CallR( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
		PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
		}
	PcsrCurrent( pfucb )->itag = ItagRootOfPfucb( pfucb );

	/*	invisible path is NOT MUTEX guarded, and may be invalid.  However,
	/*	since it is only being read for position calculation and discarded
	/*	immediately after, it need not be valid.
	/**/
	FUCBSetFull( pfucb );
	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Call( ErrBTSeekForUpdate( pfucb, &key, pgno, itag, fDIRDuplicate | fDIRReplace ) );
	Assert( err != errDIRNotSynchronous );		// No DIRNotSynchronous on replace.
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode );
	Assert( PcsrCurrent( pfucb )->pgno == pgno &&
		PcsrCurrent( pfucb )->itag == itag );

	/*	now follow path from root down to current node, to estimate
	/*	total and number nodes less than current node.
	/**/
	ulTotal = 1;
	ulLT = 0;
	for ( pcsrT = PcsrCurrent( pfucb ); pcsrT->pcsrPath != pcsrRoot; pcsrT = pcsrT->pcsrPath )
		{
		INT	cbSon;
		INT	cbSonAv;
		INT	ibSonT;

		Call( ErrBFReadAccessPage( pfucb, pcsrT->pgno ) );
		NDGet( pfucb, pcsrT->itagFather );

		cbSon = CbNDSon( pssib->line.pb );
		cbSonAv = cbSon;

//#define SAMPLING_IMPROVED_POSITION	1
#ifdef SAMPLING_IMPROVED_POSITION
		/*	improve sampling by averaging page fan-out with
		/*	with sibling pages, if any exist.
		/**/
#define ibfPositionAverageMax	2
		if ( pcsrT->itagFather == itagFOP )
			{
			INT		ibf = 0;

			for ( ; ibf < ibfPositionAverageMax; ibf++ )
				{
				PGNO	pgnoNext;

				PgnoNextFromPage( pssib, &pgnoNext );
				if ( pgnoNext == pgnoNull )
					break;
				Call( ErrBFReadAccessPage( pfucb, pgnoNext ) );
				NDGet( pfucb, itagFOP );
				/*	cbSonAv may equal 0 since this page was not on the seek path
				/**/
				cbSonAv += CbNDSon( pssib->line.pb );
				}

			/*	if tree end reached before sampling complete, then sample
			/*	in previous pages.
			/**/
			if ( ibf < ibfPositionAverageMax )
				{
				Call( ErrBFReadAccessPage( pfucb, pcsrT->pgno ) );

				for ( ; ibf < ibfPositionAverageMax; ibf++ )
					{
					PGNO	pgnoPrev;

					PgnoPrevFromPage( pssib, &pgnoPrev );
					if ( pgnoPrev == pgnoNull )
						break;
					Call( ErrBFReadAccessPage( pfucb, pgnoPrev ) );
					NDGet( pfucb, itagFOP );
					/*	cbSonAv may equal 0 since this page was not on the seek path
					/**/
					cbSonAv += CbNDSon( pssib->line.pb );
	   				}
				}

			cbSonAv = cbSonAv / ( ibf + 1 );
			if ( cbSonAv == 0 )
				cbSonAv = 1;
			}
#endif

		/*	calculate fractional position in B-tree
		/**/
        ibSonT = cbSon ? pcsrT->ibSon * cbSonAv / cbSon : 0;
		ulLT += ibSonT * ulTotal;
		ulTotal *= cbSonAv;
		}

	/*	return results
	/**/
	*pulLT = ulLT;
	*pulTotal = ulTotal;

HandleError:
	FUCBFreePath( &pfucb->pcsr, pcsrRoot );
	FUCBResetFull( pfucb );
	return err;
	}


LOCAL INT IbsonBTFrac( FUCB *pfucb, CSR *pcsr, DIB *pdib )
	{
	SSIB	*pssib = &pfucb->ssib;
	INT		ibSon;
	INT		cbSon;
	FRAC	*pfrac = (FRAC *)pdib->pkey;
	ULONG	ulT;

	Assert( pdib->pos == posFrac );

	NDGet( pfucb, pcsr->itagFather );
	cbSon = CbNDSon( pssib->line.pb );
	/*	effect fractional in page positioning such that overflow and
	/*	underflow are avoided.
	/**/
	if ( pfrac->ulTotal / cbSonMax ==  0 )
		{
		ibSon = ( ( pfrac->ulLT * cbSon ) / pfrac->ulTotal );
		}
	else
		{
		ibSon = ( cbSon * ( pfrac->ulLT / ( pfrac->ulTotal / cbSonMax ) ) ) / cbSonMax;
		}
	if ( ibSon >= cbSon )
		ibSon = cbSon - 1;

	/*	preseve fractional information by avoiding underflow
	/**/
	if ( cbSon && pfrac->ulTotal / cbSon == 0 )
		{
		pfrac->ulTotal *= cbSonMax;
		pfrac->ulLT *= cbSonMax;
		}

	/*	prepare fraction for next lower B-tree level
	/**/
	pfrac->ulTotal /= cbSon;
	Assert( pfrac->ulTotal > 0 );
	ulT = ibSon * pfrac->ulTotal;
	if ( ulT > pfrac->ulLT )
		pfrac->ulLT = 0;
	else
		pfrac->ulLT -= ulT;
	return ibSon;
	}


ERR ErrBTGotoBookmark( FUCB *pfucb, SRID srid )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	SRID	sridT;
	PGNO	pgno;
	INT		itag = itagFOP;
	INT		ibSon;
	ULONG	crepeat = 0;

Start:
	crepeat++;
	Assert( crepeat < 100 );
	if ( crepeat == 100 )
		{
		/*	log event
		/**/
		UtilReportEvent(
			EVENTLOG_WARNING_TYPE,
			GENERAL_CATEGORY,
			BAD_PAGE,
			0,
			NULL );
		Error( JET_errBadBookmark, HandleError );
		}

	sridT = srid;
	Assert( sridT != sridNull );
	pcsr->pgno = PgnoOfSrid( sridT );
	pcsr->itag = ItagOfSrid( sridT );
	Assert( pcsr->pgno != pgnoNull );
	Assert( pcsr->itag >= 0 && pcsr->itag < ctagMax );

	if ( !FBFReadAccessPage( pfucb, pcsr->pgno ) )
		{
		CallR( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
		}
	if ( TsPMTagstatus( pfucb->ssib.pbf->ppage, pcsr->itag ) == tsVacant )
		{
		/*	node has probably moved from under us -- retry
		/**/
		BFSleep( cmsecWaitGeneric );
		goto Start;
		}
	else if ( TsPMTagstatus( pfucb->ssib.pbf->ppage, pcsr->itag ) == tsLink )
		{
		PMGetLink( &pfucb->ssib, pcsr->itag, &sridT );
		pgno = PgnoOfSrid( sridT );
		Assert( pgno != pgnoNull );
		pcsr->pgno = pgno;
		pcsr->itag = ItagOfSrid( sridT );
		Assert( pcsr->itag > 0 && pcsr->itag < ctagMax );
		CallR( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
		if ( TsPMTagstatus( pfucb->ssib.pbf->ppage, pcsr->itag ) != tsLine )
			{
			/* might have been merged into adjacent page
			/* go back to link and check
			/**/
			BFSleep( cmsecWaitGeneric );
			goto Start;
			}

		/*	get line and check if backlink is what we expected
		/**/
		NDGet( pfucb, PcsrCurrent( pfucb )->itag );
		sridT = *(SRID UNALIGNED *)PbNDBackLink( pfucb->ssib.line.pb );
		if ( sridT != srid && pcsr->itag != 0 )
			{
			BFSleep( cmsecWaitGeneric );
			goto Start;
			}
		}

	/*	search all node son tables for tag of node.
	/**/
	Assert( pcsr == PcsrCurrent( pfucb ) );
	if ( pcsr->itag == 0 )
		{
		/*	this is for case where cursor is on FDP root or page with no
		/*	sons and stores page currency.
		/**/
		ibSon = 0;
		}
	else
		{
		NDGetItagFatherIbSon(
					&itag,
					&ibSon,
					pssib->pbf->ppage,
					pcsr->itag );
		}

	/*	set itagFather and ibSon
	/**/
	pcsr->itagFather = (SHORT)itag;
	pcsr->ibSon = (SHORT)ibSon;

	/* get line -- UNDONE: optimize -- line may have already been got
	/**/
	NDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	bookmark must be on node for this table
	/**/
//	UNDONE:	cannot assert this since space manager cursors
//		 	traverse domains, as do database cursors
//	Assert( pfucb->u.pfcb->pgnoFDP == PgnoPMPgnoFDPOfPage( pfucb->ssib.pbf->ppage ) );

HandleError:
	return JET_errSuccess;
	}


ERR ErrBTAbandonEmptyPage( FUCB *pfucb, KEY *pkey )
	{
	ERR		err;
	BYTE	*pbFOPNode;
	LINE	lineNull = { 0, NULL };

	Assert( pfucb->pbfEmpty != pbfNil );
	Assert( FBFWriteLatch( pfucb->ppib, pfucb->pbfEmpty ) );
	
	PcsrCurrent( pfucb )->pgno = PgnoOfPn( pfucb->pbfEmpty->pn );
	PcsrCurrent( pfucb )->itag = itagFOP;
	PcsrCurrent( pfucb )->itagFather = itagFOP;
	
	// Page is write latched, so this should not fail.
	err = ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( err == JET_errSuccess );
	CallR( err );
	
	NDGet( pfucb, itagFOP );
	pbFOPNode = pfucb->ssib.line.pb;

	Assert( FNDVisibleSons( *pbFOPNode ) );
	if ( FNDSon( *pbFOPNode ) )
		{
		// Managed to insert a node.  No need to insert the dummy node.
		Assert( CbNDSon( pbFOPNode ) == 1 );
		}
	else
		{
		// Insert a dummy/deleted node into the empty page to avoid
		// split anomalies caused when the parent key is greater than
		// the greatest node on the page.
		err = ErrNDInsertNode( pfucb, pkey, &lineNull, fNDDeleted, fDIRNoVersion );
		Assert( err != errDIRNotSynchronous );
		}

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\bm.c ===
#include "daestd.h"

#define FLAG_DISCARD		1

#ifdef DEBUG
//#define DEBUGGING			1
#endif
#define IDX_OLC				1
#define cMPLMaxConflicts 	10000

#ifdef OLC_DEBUG
//	to get the latest operations flushed
#undef JET_bitCommitLazyFlush
#define	JET_bitCommitLazyFlush 0
#endif

DeclAssertFile;					/* Declare file name for assert macros */

/*	critBMClean -> critSplit -> critRCEClean -> critMPL -> critJet
/**/
extern CRIT  critBMClean;
extern CRIT  critRCEClean;
extern CRIT  critSplit;

SIG		sigDoneFCB;
SIG		sigBMCleanProcess;
PIB		*ppibBMClean = ppibNil;
PIB		*ppibSyncOLC = ppibNil;

extern BOOL fOLCompact;
BOOL fEnableBMClean = fTrue;

/*	thread control variables.
/**/
HANDLE	handleBMClean = 0;
BOOL  	fBMCleanTerm;
LONG	lBMCleanThreadPriority = lThreadPriorityNormal;
#define cmpeNormalPriorityMax	cmpeMax>>4
#define cmpeHighPriorityMin		cmpeMax>>5
#define cmpePerEvent			cmpeMax>>3
LONG	cmpeLost = 0;

LOCAL BOOL FPMGetMinKey( FUCB *pfucb, KEY *pkeyMin );

LOCAL ULONG BMCleanProcess( VOID );
ERR ErrBMClean( PIB *ppib );

	/*  monitoring statistics  */

unsigned long cOLCConflicts = 0;

PM_CEF_PROC LOLCConflictsCEFLPpv;

long LOLCConflictsCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cOLCConflicts;
		
	return 0;
}

unsigned long cOLCPagesProcessed = 0;

PM_CEF_PROC LOLCPagesProcessedCEFLPpv;

long LOLCPagesProcessedCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cOLCPagesProcessed;
		
	return 0;
}

unsigned long cOLCSplitsAvoided = 0;

PM_CEF_PROC LOLCSplitsAvoidedCEFLPpv;

long LOLCSplitsAvoidedCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cOLCSplitsAvoided;
		
	return 0;
}

unsigned long cMPLTotalEntries = 0;

PM_CEF_PROC LMPLTotalEntriesCEFLPpv;

long LMPLTotalEntriesCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cMPLTotalEntries;
		
	return 0;
}

/*	flags for BMCleanPage
/**/
struct BMCleanFlags
	{
	INT		fPageRemoved:1;
	INT		fTableClosed:1;
	INT		fUrgent:1;
	};

typedef struct BMCleanFlags BMCF;

/**********************************************************
/*****	MESSY PAGE LIST
/**********************************************************
/**/
#define		pmpeNil	NULL

struct _mpe
	{
	PGNO		pgnoFDP;	  			/*	for finding FCB */
	PN	 		pn;						/*	of page to be cleaned */
	SRID		sridFather;				/*	visible father for page free */
	struct _mpe	*pmpeNextPN;			/*	next mpe that has same hash for pn */
	struct _mpe	*pmpeNextPgnoFDP;		/*	same for pgnoFDP */
	struct _mpe	*pmpeNextSridFather;	/*	same for sridFather */
	PGNO		pgnoFDPIdx;				/*	pgnoFDP of index */
	INT			cConflicts;				/*	# of times conflicted */
	INT			fFlagIdx:1;				/*  mpe is for index page */
#ifdef FLAG_DISCARD
	INT			fFlagDiscard:1;			/*	set to fTrue to flag discard */
#endif
	};

#define FMPEDiscard( pmpe )		( pmpe->fFlagDiscard != 0 )
#define	MPESetDiscard( pmpe )	( pmpe->fFlagDiscard = 1 )
#define	MPEResetDiscard( pmpe )	( pmpe->fFlagDiscard = 0 )

#define FMPEIdx( pmpe )		( pmpe->fFlagIdx != 0 )
#define	MPESetIdx( pmpe )	( pmpe->fFlagIdx = 1 )
#define	MPEResetIdx( pmpe )	( pmpe->fFlagIdx = 0 )

typedef struct _mpe MPE;

typedef MPE *PMPE;

typedef struct
	{
	MPE	*pmpeHead;
	MPE	*pmpeTail;
	MPE	rgmpe[cmpeMax];
	} MPL;

static MPL mpl;
static CRIT critMPL;

PMPE	mplHashOnPN[cmpeMax - 1];	   		/* for hashing on pn of mpe */
PMPE	mplHashOnSridFather[cmpeMax - 1]; 	/* for hashing on sridFather of mpe */
PMPE 	mplHashOnPgnoFDP[cmpeMax - 1];		/* for hashing on pgnoFDP */

LOCAL BOOL FMPLEmpty( VOID );
LOCAL BOOL FMPLFull( VOID );
LOCAL MPE *PmpeMPLGet( VOID );
LOCAL VOID FMPLDefer( VOID );
LOCAL VOID MPLDiscard( VOID );
LOCAL VOID MPLFlagDiscard( MPE *pmpe );
LOCAL MPE *PmpeMPLNextFromHead( VOID );
LOCAL MPE *PmpeMPLNextFromTail( VOID );
LOCAL VOID MPLIRegister( PN pn,
						 PGNO pgnoFDP,
						 SRID sridFather,
						 BOOL fIndex,
						 PGNO pgnoFDPIdx,
						 INT  cConflicts );

#ifdef DEBUG
VOID AssertBMNoConflict( PIB *ppib, DBID dbid, SRID bm );
#else
#define AssertBMNoConflict( ppib, dbid, bm )
#endif


ERR ErrMPLInit( VOID )
	{
	ERR		err = JET_errSuccess;

	Call( SgErrInitializeCriticalSection( &critMPL ) );
	mpl.pmpeHead = mpl.pmpeTail = mpl.rgmpe;

	Call( ErrSignalCreate( &sigDoneFCB, NULL ) );
	Call( ErrSignalCreate( &sigBMCleanProcess, NULL ) );

HandleError:
	return err;
	}


VOID MPLTerm( VOID )
	{
	while ( !FMPLEmpty() )
		{
		MPLDiscard();
		}

	SignalClose( sigDoneFCB );
	SignalClose(sigBMCleanProcess);
	}


LOCAL INLINE BOOL FMPLEmpty( VOID )
	{
	return ( mpl.pmpeHead == mpl.pmpeTail );
	}


LOCAL INLINE BOOL FMPLFull( VOID )
	{
	return ( PmpeMPLNextFromTail() == mpl.pmpeHead );
	}


LOCAL INLINE MPE *PmpeMPLGet( VOID )
	{
	SgEnterCriticalSection( critMPL );
	if ( !FMPLEmpty() )
		{
		SgLeaveCriticalSection( critMPL );
		return mpl.pmpeHead;
		}
	else
		{
		SgLeaveCriticalSection( critMPL );
		return NULL;
		}
	}


LOCAL INLINE MPE *PmpeMPLNextFromTail( VOID )
	{
	if ( mpl.pmpeTail != mpl.rgmpe + cmpeMax - 1 )
		return mpl.pmpeTail + 1;
	else
		return mpl.rgmpe;
	}


LOCAL INLINE MPE *PmpeMPLNextFromHead( VOID )
	{
	if ( mpl.pmpeHead != mpl.rgmpe + cmpeMax - 1 )
		return mpl.pmpeHead + 1;
	else
		return mpl.rgmpe;
	}


LOCAL INLINE MPE *PmpeMPLNext( MPE *pmpe )
	{
	if ( pmpe == mpl.pmpeTail )
		return NULL;
	if ( pmpe == mpl.rgmpe + cmpeMax - 1 )
		return mpl.rgmpe;
	return pmpe + 1;
	}


LOCAL INLINE UINT UiHashOnPN( PN pn )
	{
	return ( pn % ( cmpeMax - 1 ) );
	}


LOCAL INLINE UINT UiHashOnPgnoFDP( PGNO pgnoFDP )
	{
	return ( pgnoFDP % ( cmpeMax - 1 ) );
	}


LOCAL INLINE UINT UiHashOnSridFather( SRID srid )
	{
	return ( srid % (cmpeMax-1) );
	}

LOCAL MPE* PmpeMPLLookupPN( PN pn )
	{
	MPE	*pmpehash;

	for	( pmpehash = mplHashOnPN[ UiHashOnPN( pn ) ];
		pmpehash != NULL;
		pmpehash = pmpehash->pmpeNextPN )
		{
		if ( pmpehash->pn == pn )
			return( pmpehash );
		}

	return NULL;
	}

#ifdef OLC_DEBUG
BOOL FMPLLookupPN( PN pn )
	{
	MPE		*pmpe = PmpeMPLLookupPN( pn );
#ifdef FLAG_DISCARD
	return !( pmpe == NULL || FMPEDiscard( pmpe ) );
#else
	return ( pmpe != NULL );
#endif
	}
#endif

LOCAL MPE* PmpeMPLLookupPgnoFDP( PGNO pgnoFDP, DBID dbid )
	{
	MPE	*pmpehash;

	for	( pmpehash = mplHashOnPgnoFDP[ UiHashOnPgnoFDP( pgnoFDP ) ];
		pmpehash != NULL;
		pmpehash = pmpehash->pmpeNextPgnoFDP )
		{
		if ( pmpehash->pgnoFDP == pgnoFDP && DbidOfPn( pmpehash->pn ) == dbid )
			return( pmpehash );
		}

	return NULL;
	}


LOCAL MPE* PmpeMPLLookupSridFather( SRID srid, DBID dbid )
	{
	MPE	*pmpehash;

	for	( pmpehash = mplHashOnSridFather[ UiHashOnSridFather( srid ) ];
		pmpehash != NULL;
		pmpehash = pmpehash->pmpeNextSridFather )
		{
		if ( pmpehash->sridFather == srid && DbidOfPn( pmpehash->pn ) == dbid )
			return( pmpehash );
		}

	return NULL;
	}


LOCAL INLINE BOOL FMPLLookupSridFather( SRID srid, DBID dbid )
	{
	MPE		*pmpe = PmpeMPLLookupSridFather( srid, dbid );
#ifdef FLAG_DISCARD
	return !( pmpe == NULL || FMPEDiscard( pmpe ) );
#else
	return ( pmpe != NULL );
#endif

	}

	
LOCAL INLINE VOID MPLRegisterPN( MPE *pmpe )
	{
	UINT 	iHashIndex = UiHashOnPN( pmpe->pn );

	Assert( PmpeMPLLookupPN( pmpe->pn ) == NULL );
	pmpe->pmpeNextPN = ( mplHashOnPN[ iHashIndex ] );
	mplHashOnPN[iHashIndex] = pmpe;
	return;
	}


LOCAL INLINE VOID MPLRegisterPgnoFDP( MPE *pmpe )
	{
	UINT	iHashIndex = UiHashOnPgnoFDP( pmpe->pgnoFDP );

	pmpe->pmpeNextPgnoFDP = ( mplHashOnPgnoFDP[ iHashIndex ] );
	mplHashOnPgnoFDP[iHashIndex] = pmpe;
	return;
	}


LOCAL INLINE VOID MPLRegisterSridFather( MPE *pmpe )
	{
	UINT 	iHashIndex = UiHashOnSridFather( pmpe->sridFather );

	pmpe->pmpeNextSridFather = ( mplHashOnSridFather[ iHashIndex ] );
	mplHashOnSridFather[iHashIndex] = pmpe;
	return;
	}


LOCAL VOID MPLDiscardPN( MPE *pmpe )
	{
	UINT  	iHashIndex = UiHashOnPN( pmpe->pn );
	MPE	  	*pmpehash;
	MPE	  	**ppmpePrev;

	Assert( PmpeMPLLookupPN( pmpe->pn ) != NULL );
	pmpehash = mplHashOnPN[iHashIndex];
	ppmpePrev = &mplHashOnPN[iHashIndex];
	for ( ; pmpehash != NULL;
		ppmpePrev = &pmpehash->pmpeNextPN, pmpehash = *ppmpePrev )
		{
		if ( pmpehash == pmpe )
			{
			*ppmpePrev = pmpe->pmpeNextPN;
			return;
			}
		}
	Assert( fFalse );
	}


LOCAL VOID MPLDiscardPgnoFDP( MPE *pmpe)
	{
	UINT 	iHashIndex = UiHashOnPgnoFDP( pmpe->pgnoFDP );
	MPE		*pmpehash;
	MPE	   	**ppmpePrev;

	Assert( PmpeMPLLookupPgnoFDP( pmpe->pgnoFDP, DbidOfPn( pmpe->pn ) ) != NULL );
	pmpehash = mplHashOnPgnoFDP[iHashIndex];
	ppmpePrev = &mplHashOnPgnoFDP[iHashIndex];
	for ( ; pmpehash != NULL;
			ppmpePrev = &pmpehash->pmpeNextPgnoFDP, pmpehash = *ppmpePrev )
		{
		if ( pmpehash == pmpe )
			{
			*ppmpePrev = pmpe->pmpeNextPgnoFDP;
			return;
			}
		}
	Assert( fFalse );
	}


LOCAL VOID MPLDiscardSridFather( MPE *pmpe)
	{
	UINT	iHashIndex = UiHashOnSridFather( pmpe->sridFather );
	MPE	   	*pmpehash;
	MPE	   	**ppmpePrev;

	Assert( PmpeMPLLookupSridFather( pmpe->sridFather, DbidOfPn( pmpe->pn ) ) != NULL );
	pmpehash = mplHashOnSridFather[iHashIndex];
	ppmpePrev = &mplHashOnSridFather[iHashIndex];
	for ( ; pmpehash != NULL;
			ppmpePrev = &pmpehash->pmpeNextSridFather, pmpehash = *ppmpePrev )
		{
		if ( pmpehash == pmpe )
			{
			*ppmpePrev = pmpe->pmpeNextSridFather;
			return;
			}
		}
	Assert( fFalse );
	}


LOCAL VOID MPLDiscard( VOID )
	{
	SgEnterCriticalSection( critMPL );
	Assert( !FMPLEmpty() );
	MPLDiscardPN( mpl.pmpeHead );
	MPLDiscardSridFather( mpl.pmpeHead );
	MPLDiscardPgnoFDP( mpl.pmpeHead );
	mpl.pmpeHead = PmpeMPLNextFromHead();
	SgLeaveCriticalSection( critMPL );
	
	cMPLTotalEntries--;
	
	return;
	}


#ifdef FLAG_DISCARD
LOCAL VOID MPLFlagDiscard( MPE *pmpe )
	{
	SgEnterCriticalSection( critMPL );
	Assert( !FMPLEmpty() );
	/*	note that MPE may already been set to flag discard
	/**/
	MPESetDiscard( pmpe );
	SgLeaveCriticalSection( critMPL );
	return;
	}
#endif


VOID MPLIRegister(
		PN pn,
		PGNO pgnoFDP,
		SRID sridFather,
		BOOL fIndex,
		PGNO pgnoFDPIdx,
		INT cConflicts )
	{
	MPE	*pmpe = PmpeMPLLookupPN( pn );

#ifdef OLC_DEBUG
	Assert( !FMPLFull() );
#endif
	if ( pmpe == NULL && !FMPLFull() )
		{
		mpl.pmpeTail->pn = pn;
		mpl.pmpeTail->pgnoFDP = pgnoFDP;
		mpl.pmpeTail->sridFather = sridFather;
		mpl.pmpeTail->cConflicts = cConflicts;
		if (fIndex)
			{
			MPESetIdx( mpl.pmpeTail );
			mpl.pmpeTail->pgnoFDPIdx = pgnoFDPIdx;
			}
		else
			{
			MPEResetIdx( mpl.pmpeTail );
			Assert( pgnoFDPIdx == pgnoFDP );
			mpl.pmpeTail->pgnoFDPIdx = pgnoFDP;
			}
			
#ifdef FLAG_DISCARD
		MPEResetDiscard( mpl.pmpeTail );
#endif
		MPLRegisterPN( mpl.pmpeTail );
		MPLRegisterSridFather( mpl.pmpeTail );
		MPLRegisterPgnoFDP( mpl.pmpeTail );
		mpl.pmpeTail = PmpeMPLNextFromTail();
	
		cMPLTotalEntries++;
		}
	else if ( pmpe != NULL )
		{
		/*	correct conflict number
		/**/
		pmpe->cConflicts = cConflicts;

		if ( sridFather != pmpe->sridFather
#ifdef FLAG_DISCARD
			&& !FMPEDiscard( pmpe )
#endif
			)
			{
			if ( ( pmpe->sridFather == sridNull || pmpe->sridFather == sridNullLink ) &&
					 sridFather != sridNull && sridFather != sridNullLink )
				{
				/* update if we have better info on sridFather
				/**/
				Assert( PgnoOfSrid( sridFather ) != PgnoOfPn( pn ) );
				Assert( pmpe->pgnoFDP == pgnoFDP );
				Assert( pmpe->pn == pn );
				MPLDiscardSridFather( pmpe );
				pmpe->sridFather = sridFather;
				MPLRegisterSridFather( pmpe );
				}
			}
#if OLC_DEBUG
		else if ( FMPEDiscard( pmpe ) )
			{
			Assert( fFalse );
			}
#endif
		}
	else
		{
		Assert( pmpe == NULL && FMPLFull() );

		if ( (++cmpeLost % cmpePerEvent ) == 0 )
			{
			/*	log event
			/**/
			UtilReportEvent(
				EVENTLOG_WARNING_TYPE,
				GENERAL_CATEGORY,
				MANY_LOST_COMPACTION_ID,
				0,
				NULL );
			}
		}
	}


VOID MPLRegister( FCB *pfcbT, SSIB *pssib, PN pn, SRID sridFather )
	{
	BOOL	fIndex = pfcbT->pfcbTable != pfcbNil;
	FCB		*pfcbTable = fIndex ? pfcbT->pfcbTable : pfcbT;
	
	Assert( !fRecovering );

	if ( DbidOfPn( pn ) == dbidTemp ||
		 FDBIDWait( DbidOfPn( pn ) ) ||
		 FDBIDCreate( DbidOfPn( pn ) ) )
		{
		return;
		}

	/*	database must be writable
	/**/
	Assert( PMPageTypeOfPage( pssib->pbf->ppage ) != pgtypIndexNC || fIndex );
	Assert( !( PMPageTypeOfPage( pssib->pbf->ppage ) == pgtypRecord && fIndex ) );
	Assert( pfcbTable != pfcbNil );
	Assert( !FDBIDReadOnly( DbidOfPn( pn ) ) );
	Assert( pssib->pbf->pn == pn );
	Assert( !FFCBSentinel( pfcbTable ) );
//	Assert( sridFather != sridNull );
//	Assert( sridFather != sridNullLink );
		
	/*	do  not register empty pages
	/**/
	if ( FPMEmptyPage( pssib ) )
		return;
	
	/*	do not register when domain is pending delete
	/**/
	if ( FFCBDeletePending( pfcbTable ) )
		return;

	SgEnterCriticalSection( critMPL );
#ifdef PAGE_MODIFIED
	if ( !FPMPageModified( pssib->pbf->ppage ) )
		{
		PMSetModified( pssib );
		pfcbTable->olc_data.cUnfixedMessyPage++;
		FCBSetOLCStatsChange( pfcbTable );
		}
#endif

#if 0
	// this code is deffed out because we can't call ErrBTSeekForUpdate
	// without critSplit
	/*	check if sridFather registered is correct
	/**/
	if ( sridFather != sridNull && sridFather != sridNullLink )
		{
		ERR		err;
		FUCB	*pfucb = pfucbNil;
		SSIB	*pssibT;

		CallJ( ErrDIROpen( pssib->ppib, pfcbTable, 0, &pfucb ), SkipCheck );
		
		pssibT = &pfucb->ssib;
		CallJ( ErrBTGotoBookmark( pfucb, sridFather ), CloseDir );
		if ( PgnoOfPn( pn ) == PcsrCurrent( pfucb )->pgno )
			{
			Assert( !FNDNullSon( *pssibT->line.pb ) );
			//	UNDONE: check for visible descendants in same page
			}
		else
			{
			/*	access register page
			/**/
			PcsrCurrent( pfucb )->pgno = PgnoOfPn( pn );
			err = ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
			if ( err >= JET_errSuccess )
				{
				PcsrCurrent( pfucb )->itagFather = itagFOP;
				NDGet( pfucb, PcsrCurrent( pfucb )->itagFather );
				Assert( !FNDNullSon( *pssibT->line.pb ) );
				NDMoveFirstSon( pfucb, PcsrCurrent( pfucb ) );
				CallS( ErrBTCheckInvisiblePagePtr( pfucb, sridFather ) );
				}
			}
CloseDir:
		DIRClose( pfucb );
		pfucb = pfucbNil;
SkipCheck:
		;
		}
#endif

	/* if sridFather is in same page -- it is not useful for page recovery
	/**/
	if ( PgnoOfSrid( sridFather ) == PgnoOfPn( pn ) )
		sridFather = sridNull;

	if ( sridFather != sridNull && sridFather != sridNullLink )
		{
		ERR		err;
		FUCB	*pfucb = pfucbNil;

		Call( ErrDIROpen( pssib->ppib, pfcbTable, 0, &pfucb ) );

		CallJ( ErrBTGotoBookmark( pfucb, sridFather ), Close );
		if ( PgnoOfPn( pn ) == PcsrCurrent( pfucb )->pgno )
			{
			sridFather = sridNull;
			}
Close:
		DIRClose( pfucb );
		pfucb = pfucbNil;
HandleError:
		if ( err < 0 )
			{
#if OLC_DEBUG
			Assert( fFalse );
#endif
			sridFather = sridNull;
			}
		}
		
	MPLIRegister( pn, pfcbTable->pgnoFDP, sridFather, fIndex, pfcbT->pgnoFDP, 0 );
	SgLeaveCriticalSection( critMPL );

	//	UNDONE:	hysteresis of clean up
	/*	wake up BM thread
	/**/
	SignalSend( sigBMCleanProcess );

	return;
	}


LOCAL VOID MPLDefer( VOID )
	{
	MPE *pmpe = mpl.pmpeHead;

	SgEnterCriticalSection( critMPL );
	Assert( !FMPLEmpty() );
	// UNDONE: to optimize
	MPLDiscard( );

	/*	discard MPE if numbre of conflicts > cMPLMaxConflicts
	/**/
	if ( pmpe->cConflicts < cMPLMaxConflicts )
		{
		MPLIRegister(
			pmpe->pn,
			pmpe->pgnoFDP,
			pmpe->sridFather,
			pmpe->fFlagIdx,
			pmpe->pgnoFDPIdx,
			pmpe->cConflicts );
		}
#ifdef OLC_DEBUG
	else
		{
		Assert( fFalse );
		}
#endif

//	*mpl.pmpeTail = *mpl.pmpeHead;
//	mpl.pmpeTail = PmpeMPLNextFromTail();
//	mpl.pmpeHead = PmpeMPLNextFromHead();
	SgLeaveCriticalSection( critMPL );
	return;
	}


VOID MPLPurgePgno( DBID dbid, PGNO pgnoFirst, PGNO pgnoLast )
	{
	MPE		*pmpe;
#ifndef FLAG_DISCARD
	MPE		*pmpeEnd;
#endif

	Assert( pgnoFirst <= pgnoLast );

	/*	synchronize with bookmark clean up
	/**/
	LgLeaveCriticalSection( critJet );
	LgEnterNestableCriticalSection( critMPL );
	LgEnterCriticalSection( critJet );
	SgEnterCriticalSection( critMPL );

#ifdef FLAG_DISCARD
	/*	go through MPL discarding offending entries
	/**/
	if ( !FMPLEmpty() )
		{
		for ( pmpe = mpl.pmpeHead; pmpe != NULL; pmpe = PmpeMPLNext( pmpe ) )
			{
			if ( ( pmpe->pn >= PnOfDbidPgno ( dbid, pgnoFirst ) &&
					pmpe->pn <= PnOfDbidPgno( dbid, pgnoLast ) ) ||
				( DbidOfPn( pmpe->pn ) == dbid &&
					( ( PgnoOfSrid( pmpe->sridFather ) >= pgnoFirst &&
					PgnoOfSrid( pmpe->sridFather ) <= pgnoLast ) ||
					( pmpe->pgnoFDP >= pgnoFirst &&
					pmpe->pgnoFDP <= pgnoLast ) ) ) )
				{
				MPLFlagDiscard( pmpe );
				}
			}
		}
#else
	/*	go through MPL discarding offending entries
	/**/
	if ( !FMPLEmpty() )
		{
		pmpe = mpl.pmpeHead;
		pmpeEnd = mpl.pmpeTail;
		for ( ; pmpe != pmpeEnd; pmpe = mpl.pmpeHead )
			{
			if ( ( pmpe->pn >= PnOfDbidPgno ( dbid, pgnoFirst ) &&
					pmpe->pn <= PnOfDbidPgno( dbid, pgnoLast ) ) ||
				( DbidOfPn( pmpe->pn ) == dbid &&
					( ( PgnoOfSrid( pmpe->sridFather ) >= pgnoFirst &&
					PgnoOfSrid( pmpe->sridFather ) <= pgnoLast ) ||
					( pmpe->pgnoFDP >= pgnoFirst &&
					pmpe->pgnoFDP <= pgnoLast ) ) ) )
				{
				MPLDiscard( );
				}
			else
				{
				MPLDefer( );
				}
			}
		}
#endif

	SgLeaveCriticalSection( critMPL );
	LgLeaveNestableCriticalSection( critMPL );
	return;
	}


VOID MPLPurgeFDP( DBID dbid, PGNO pgnoFDP )
	{
	MPE	*pmpe;
#ifndef FLAG_DISCARD
	MPE	*pmpeEnd;
#endif

	/*	synchronize with bookmark clean up
	/**/
	LgLeaveCriticalSection( critJet );
	LgEnterNestableCriticalSection( critMPL );
	LgEnterCriticalSection( critJet );

	SgEnterCriticalSection( critMPL );

#ifdef FLAG_DISCARD
	// CONSIDER: using the pgnoFDP hash
	if ( !FMPLEmpty() )
		{
		for ( pmpe = mpl.pmpeHead; pmpe != NULL; pmpe = PmpeMPLNext( pmpe ) )
			{
			if ( DbidOfPn( pmpe->pn ) == dbid &&
				 ( pmpe->pgnoFDP == pgnoFDP ||
				   FMPEIdx( pmpe ) && pmpe->pgnoFDPIdx == pgnoFDP
				 )
			   )
				{
				MPLFlagDiscard( pmpe );
				}
			}
		}
#else
	// CONSIDER: using the pgnoFDP hash
	if ( !FMPLEmpty() )
		{
		pmpe = mpl.pmpeHead;
		pmpeEnd = mpl.pmpeTail;
		for ( ; pmpe != pmpeEnd; pmpe = mpl.pmpeHead )
			{
			if ( DbidOfPn( pmpe->pn ) == dbid &&
				 ( pmpe->pgnoFDP == pgnoFDP ||
				   FMPEIdx( pmpe ) && pmpe->pgnoFDPIdx == pgnoFDP
				 )
			   )
				{
				MPLDiscard( );
				}
			else
				{
				MPLDefer( );
				}
			}
		}
#endif

	SgLeaveCriticalSection( critMPL );

	LgLeaveNestableCriticalSection(critMPL);
	return;
	}


/* purge mpl entries of dbid
/**/
VOID MPLPurge( DBID dbid )
	{
	MPE *pmpe;
#ifndef FLAG_DISCARD
	MPE *pmpeEnd;
#endif

	/*	synchronize with bookmark clean up
	/**/
	LgLeaveCriticalSection( critJet );
	LgEnterNestableCriticalSection( critBMClean );
	LgEnterNestableCriticalSection( critMPL );
	LgEnterCriticalSection( critJet );

	SgEnterCriticalSection( critMPL );

#ifdef FLAG_DISCARD
	if ( !FMPLEmpty() )
		{
		for ( pmpe = mpl.pmpeHead; pmpe != NULL; pmpe = PmpeMPLNext( pmpe ) )
			{
			if ( DbidOfPn( pmpe->pn ) == dbid )
				{
				MPLFlagDiscard( pmpe );
				}
			}
		}
#else
	if ( !FMPLEmpty() )
		{
		pmpe = mpl.pmpeHead;
		pmpeEnd = mpl.pmpeTail;
		for ( ; pmpe != pmpeEnd; pmpe = mpl.pmpeHead )
			{
			if ( DbidOfPn( pmpe->pn ) == dbid )
				{
				MPLDiscard( );
				}
			else
				{
				MPLDefer( );
				}
			}
		}
#endif

	SgLeaveCriticalSection( critMPL );

	LgLeaveNestableCriticalSection( critMPL );
	LgLeaveNestableCriticalSection( critBMClean );
	return;
	}


ERR ErrMPLStatus( VOID )
	{
	ERR		err = JET_errSuccess;

	//	if MPL more than half full, return JET_wrnIdleFull
	//	for bulk deleters to stand off.
	if ( cMPLTotalEntries > ( cmpeMax / 2 ) )
		{
		err = JET_wrnIdleFull;
		SignalSend( sigBMCleanProcess );
		}

	return err;
	}


/**********************************************************
/***** BOOKMARK CLEAN UP
/**********************************************************
/**/

ERR  ErrBMInit( VOID )
	{
	ERR		err = JET_errSuccess;

#ifdef DEBUG
	CHAR	*sz;

	if ( ( sz = GetDebugEnvValue( "OLCENABLED" ) ) != NULL )
		{
		fOLCompact = JET_bitCompactOn;
		SFree(sz);
		}
		
	if ( ( sz = GetDebugEnvValue ( "BMDISABLED" ) ) != NULL )
		{
		fEnableBMClean = fFalse;
		SFree(sz);
		}
	else
		{
		Assert( fOLCompact == 0 || fOLCompact == JET_bitCompactOn );
		fEnableBMClean = ( fOLCompact == JET_bitCompactOn );
		}
#else
	fEnableBMClean = ( fOLCompact == JET_bitCompactOn );
#endif


	CallR( ErrInitializeCriticalSection( &critMPL ) );

	/*	begin sesion for page cleanning.
	/**/
	LgAssertCriticalSection( critJet );
	Assert( ppibBMClean == ppibNil );
	if ( !fRecovering )
		{
		Assert( fBMCleanTerm == fFalse );
		
		fBMCleanTerm = fFalse;

		err = ErrPIBBeginSession( &ppibBMClean, procidNil );

#ifdef RFS2
		if ( err == JET_errOutOfSessions )
			{
			Assert( ppibBMClean == ppibNil );
			return err;
			}
#endif
		err = ErrPIBBeginSession( &ppibSyncOLC, procidNil );

#ifdef RFS2
		if ( err == JET_errOutOfSessions )
			{
			Assert( ppibSyncOLC == ppibNil );
			return err;
			}
#endif
		// Should never fail allocation of PIB for BMClean, except in RFS testing.
		Assert( err == JET_errSuccess );

		PIBSetBMClean( ppibBMClean );

		Assert( lBMCleanThreadPriority == lThreadPriorityNormal );
		err = ErrUtilCreateThread( BMCleanProcess, cbBMCleanStack, THREAD_PRIORITY_NORMAL, &handleBMClean );
		}

	return err;
	}


ERR	ErrBMTerm( VOID )
	{
	if ( handleBMClean != 0 )
		{
		/*	terminate BMCleanProcess.
		/**/
		fBMCleanTerm = fTrue;
		LgLeaveCriticalSection(critJet);
		UtilEndThread( handleBMClean, sigBMCleanProcess );
		LgEnterCriticalSection(critJet);
		CallS( ErrUtilCloseHandle( handleBMClean ) );
		handleBMClean = 0;
		fBMCleanTerm = fFalse;
		}

	if ( ppibBMClean != ppibNil )
		{
		Assert( ppibBMClean->level == 0 );
		LgAssertCriticalSection( critJet );
		PIBEndSession( ppibBMClean );

		// Don't release the memory allocated to ppibBMClean, just set ppibBMClean
		// to ppibNil.  This is because it must remain in the global chain (we don't
		// currently provide support for reusing ppib's and assume they remain in
		// the global chain until termination.
		ppibBMClean = ppibNil;
		}

	if ( ppibSyncOLC != ppibNil )
		{
		Assert( ppibSyncOLC->level == 0 );
		LgAssertCriticalSection( critJet );
		PIBEndSession( ppibSyncOLC );

		// Don't release the memory allocated to ppibBMClean, just set ppibBMClean
		// to ppibNil.  This is because it must remain in the global chain (we don't
		// currently provide support for reusing ppib's and assume they remain in
		// the global chain until termination.
		ppibSyncOLC = ppibNil;
		}

	DeleteCriticalSection( critMPL );

	return JET_errSuccess;
	}


LOCAL ERR ErrBMAddToWaitLatchedBFList( BMFIX *pbmfix, BF *pbfLatched )
	{
#define cpbfBlock	10
	ULONG	cpbf;

	if ( FBFWriteLatchConflict( pbmfix->ppib, pbfLatched ) )
		{
		return ErrERRCheck( JET_errWriteConflict );
		}
	
	cpbf = pbmfix->cpbf++;

	if ( pbmfix->cpbfMax <= pbmfix->cpbf )
		{
		BF		**ppbf;

		/* run out of space, get more buffers
		/**/
		pbmfix->cpbfMax += cpbfBlock;
		ppbf = SAlloc( sizeof(BF*) * (pbmfix->cpbfMax) );
		if ( ppbf == NULL )
			return ErrERRCheck( JET_errOutOfMemory );
		memcpy( ppbf, pbmfix->rgpbf, sizeof(BF*) * cpbf);
		if ( pbmfix->rgpbf )
			SFree(pbmfix->rgpbf);
		pbmfix->rgpbf = ppbf;
		}
	*(pbmfix->rgpbf + cpbf) = pbfLatched;
	BFSetWaitLatch( pbfLatched, pbmfix->ppib );

	return JET_errSuccess;
	}


LOCAL VOID BMReleaseBmfixBfs( BMFIX *pbmfix )
	{
	/* release latches
	/**/
	while ( pbmfix->cpbf > 0 )
		{
		pbmfix->cpbf--;
		BFResetWaitLatch( *( pbmfix->rgpbf + pbmfix->cpbf ), pbmfix->ppib );
		}

	if ( pbmfix->rgpbf )
		{
		SFree( pbmfix->rgpbf );
		pbmfix->rgpbf = NULL;
		}

	Assert( pbmfix->cpbf == 0 );
	return;
	}


LOCAL ERR ErrBMFixIndexes(
	BMFIX	*pbmfix,
	BOOL	fAllocBuf )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucbIdx = pfucbNil;
	FCB		*pfcbIdx;
	BYTE	rgbKey[ JET_cbKeyMost ];
	KEY		key;
	LINE	lineSRID;
	ULONG	itagSequence;

	/*	key buffer.
	/**/
	key.pb = rgbKey;
	lineSRID.pb = (BYTE *)&pbmfix->sridNew;
	lineSRID.cb = sizeof(SRID);

	/*	for each non-clustered index
	/**/
	for ( pfcbIdx = pbmfix->pfucb->u.pfcb->pfcbNextIndex;
		pfcbIdx != pfcbNil;
		pfcbIdx = pfcbIdx->pfcbNextIndex )
		{
		BOOL	fHasMultivalue;
		BOOL	fNullKey = fFalse;

		/*	table open
		/**/
		Call( ErrDIROpen( pbmfix->ppib, pfcbIdx, 0, &pfucbIdx ) );
		FUCBSetIndex( pfucbIdx );
		FUCBSetNonClustered( pfucbIdx );
		pfcbIdx->pfcbTable = pbmfix->pfucb->u.pfcb;

		fHasMultivalue = pfcbIdx->pidb->fidb & fidbHasMultivalue;

		/*	for each key extracted from record
		/**/
		for ( itagSequence = 1; ; itagSequence++ )
			{
			Call( ErrRECRetrieveKeyFromRecord(
				pbmfix->pfucb,
				(FDB *)pfcbIdx->pfcbTable->pfdb,
				pfcbIdx->pidb,
				&key,
				itagSequence,
				fFalse ) );
			Assert( err == wrnFLDOutOfKeys ||
				err == wrnFLDNullKey ||
				err == wrnFLDNullFirstSeg ||
				err == wrnFLDNullSeg ||
				err == JET_errSuccess );

			/*	if warning, check for special key behavior
			/**/
			if ( err > 0 )
				{
				/*	if NULL key and null keys not allowed, break as
				/*	key entry not in index, else updated index and break,
				/*	as no additional keys can exist.
				/**/
				if ( err == wrnFLDNullKey )
					{
					if ( ( pfcbIdx->pidb->fidb & fidbAllowAllNulls ) == 0 )
						break;
					else
						fNullKey = fTrue;
					}
				else if ( err == wrnFLDNullFirstSeg && !( pfcbIdx->pidb->fidb & fidbAllowFirstNull ) )
					{
					break;
					}
				else if ( err == wrnFLDNullSeg && !( pfcbIdx->pidb->fidb & fidbAllowSomeNulls ) )
					break;
			}

			/*	break if out of keys.
			/**/
			if ( itagSequence > 1 && err == wrnFLDOutOfKeys )
				break;

			DIRGotoDataRoot( pfucbIdx );
			Call( ErrDIRDownKeyBookmark( pfucbIdx, &key, pbmfix->sridOld ) );
			AssertFBFReadAccessPage( pfucbIdx, PcsrCurrent( pfucbIdx )->pgno );

			if ( fAllocBuf )
				{
				/*	latchWait buffer for index page
				/**/
				Call( ErrBMAddToWaitLatchedBFList( pbmfix, pfucbIdx->ssib.pbf ) );
				}
			else
				{
				AssertBFWaitLatched( pfucbIdx->ssib.pbf, pbmfix->ppib );

				/*	delete reference to record in old page
				/**/
				Call( ErrDIRDelete( pfucbIdx, fDIRVersion | fDIRNoMPLRegister ) );

				/*	add reference to record in new page
				/*	allow duplicates here, since any illegal
				/*	duplicates were rejected during Insert or Replace
				/**/
				DIRGotoDataRoot( pfucbIdx );
				Call( ErrDIRInsert( pfucbIdx,
					&lineSRID,
					&key,
					fDIRVersion | fDIRDuplicate | fDIRPurgeParent ) );
				}

			if ( !fHasMultivalue || fNullKey )
				break;
			}

		DIRClose( pfucbIdx );
		pfucbIdx = pfucbNil;
		}

	err = JET_errSuccess;

HandleError:
#ifdef OLC_DEBUG
	Assert( err >= 0 );
#endif

	Assert( err != JET_errKeyDuplicate );
	Assert( err != wrnNDFoundLess );

	/*	free fucb if allocated
	/**/
	if ( pfucbIdx != pfucbNil )
		DIRClose( pfucbIdx );
	return err;
	}

LOCAL BOOL FBMIConflict( FUCB *pfucb, PIB *ppib, SRID bm )
	{
	CSR		*pcsr;
	
	if ( pfucb->bmStore == bm ||
		 pfucb->itemStore == bm ||
		 pfucb->sridFather == bm )
		{
		return fTrue;
		}
		
	for ( pcsr = PcsrCurrent( pfucb );	pcsr != pcsrNil; pcsr = pcsr->pcsrPath )
		{
		if ( pfucb->ppib != ppib &&
			( pcsr->bm == bm ||
			  pcsr->item == bm ||
			  pcsr->bmRefresh == bm ||
			  SridOfPgnoItag( pcsr->pgno, pcsr->itag ) == bm ||
			  ( pcsr->itagFather != 0 && pcsr->itagFather != itagNull &&
			  	SridOfPgnoItag( pcsr->pgno, pcsr->itagFather ) == bm ) ) )
			{
			return fTrue;
			}
		}

	return fFalse;
	}

	
LOCAL BOOL FBMConflict(
	PIB		*ppib,
	FCB 	*pfcb,
	DBID	dbid,
	SRID	bm,
	PGTYP	pgtyp )
	{
	ERR	   	err = JET_errSuccess;
	BOOL   	fConflict = fFalse;
	FUCB   	*pfucb = pfucbNil;
	FCB	   	*pfcbT = pfcb->pfcbTable == pfcbNil ? pfcb : pfcb->pfcbTable;
	BOOL   	fRecordPage	= ( pgtyp == pgtypRecord || pgtyp == pgtypFDP );

	Assert( FPIBBMClean( ppib ) );

	/*	if database page, check for all fucb's for sridFather
	/**/
	if ( pfcb->pgnoFDP == pgnoSystemRoot )
		 {
		 PIB 	*ppibT = ppibGlobal;
		
		 for ( ; ppibT != ppibNil; ppibT = ppibT->ppibNext )
		 	{
			pfucb = ppibT->pfucb;

			for ( ; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
				{
				if ( FBMIConflict( pfucb, ppib, bm ) )
					{
					fConflict = fTrue;
					goto Done;
					}
	 		 	}
	 		}
	 		
	 	 goto Done;
		 }
		
	/*  go through all cursors for this table
	/**/
	for ( pfucb = pfcbT->pfucb;
		pfucb != pfucbNil;
		pfucb = pfucb->pfucbNextInstance )
		{
		if ( fRecordPage && FFUCBGetBookmark( pfucb ) ||
			FBMIConflict( pfucb, ppib, bm ) )
			{
			fConflict = fTrue;
			goto Done;
			}
		}

	/*	go through all index cursors for this table
	/**/
	for ( pfcbT = pfcbT->pfcbNextIndex;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		for ( pfucb = pfcbT->pfucb;
			pfucb != pfucbNil;
			pfucb = pfucb->pfucbNextInstance )
			{
			Assert( !FFUCBGetBookmark( pfucb ) );
			if ( FBMIConflict( pfucb, ppib, bm ) )
				{
				fConflict = fTrue;
				goto Done;
				}
			}
		}

	/*	go through all cursors for the database
	/**/
	pfcbT = PfcbFCBGet( dbid, pgnoSystemRoot );
	Assert( pfcbT != pfcbNil );
	for ( pfucb = pfcbT->pfucb;
		pfucb != pfucbNil ;
		pfucb = pfucb->pfucbNextInstance )
		{
		Assert( !FFUCBGetBookmark( pfucb ) );
		if ( FBMIConflict( pfucb, ppib, bm ) )
			{
			fConflict = fTrue;
			goto Done;
			}
		}

	Assert( pfcbT->pfcbNextIndex == pfcbNil );

Done:
	/* switch on for debugging purposes only
	/**/
	if ( !fConflict )
		{
		AssertBMNoConflict( ppib, dbid, bm );
		}

	return fConflict;
	}


LOCAL BOOL FBMPageConflict( FUCB *pfucbIn, PGNO pgno )
	{
	FCB 	*pfcbT = pfucbIn->u.pfcb;
	FUCB	*pfucb;
	BOOL 	fConflict = fFalse;

	/*	go through all cursors for this table
	/**/
	for ( pfucb = pfcbT->pfucb;	pfucb != pfucbNil;
		pfucb = pfucb->pfucbNextInstance )
		{
		CSR		*pcsr = PcsrCurrent( pfucb );
		
		if ( PgnoOfSrid( pfucb->bmStore ) == pgno ||
			 PgnoOfSrid( pfucb->itemStore ) == pgno ||
			 PgnoOfSrid( pfucb->sridFather ) == pgno )
			{
			fConflict = fTrue;
			goto Done;
			}

		// Need to check all CSR's even when we're merging because of
		// the case where we could be merging onto a page from which
		// another CSR is traversing backwards.
		while( pcsr != pcsrNil )
			{
			if ( pfucb != pfucbIn
				&& ( pcsr->pgno == pgno ||
					PgnoOfSrid( pcsr->bm ) == pgno  ||
					PgnoOfSrid( pcsr->bmRefresh ) == pgno )
				)
		    	{
				fConflict = fTrue;
				goto Done;
		    	}

			pcsr = pcsr->pcsrPath;
			}
		}

	/*	go through all index cursors for this table
	/**/
	for ( pfcbT = pfcbT->pfcbNextIndex;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		for ( pfucb = pfcbT->pfucb;
			pfucb != pfucbNil;
			pfucb = pfucb->pfucbNextInstance )
			{
			CSR		*pcsr = PcsrCurrent( pfucb );

			if ( PgnoOfSrid( pfucb->bmStore ) == pgno ||
				 PgnoOfSrid( pfucb->itemStore ) == pgno ||
				 PgnoOfSrid( pfucb->sridFather ) == pgno )
				{
				fConflict = fTrue;
				goto Done;
				}
			
			if ( pcsr != pcsrNil && pfucb != pfucbIn &&
				 ( pcsr->pgno == pgno ||
				   PgnoOfSrid( pcsr->bm ) == pgno ||
				   PgnoOfSrid( pcsr->bmRefresh ) == pgno
				 )
			   )
				{
				fConflict = fTrue;
				goto Done;
				}
#ifdef DEBUG
				{
				/* the stack can not this page [due to wait latches on children]
				/**/
				for ( ; pcsr != pcsrNil; pcsr = pcsr->pcsrPath )
					{
					Assert( PgnoOfSrid( pcsr->bm ) != pgno || pfucb == pfucbIn );
					Assert( PgnoOfSrid( pcsr->bmRefresh ) != pgno || pfucb == pfucbIn );
					Assert( pcsr->pgno != pgno || pfucb == pfucbIn );
					}
				}
#endif
			}
		}

	/*	go through all cursors for the database
	/**/
	pfcbT = PfcbFCBGet( pfucbIn->dbid, pgnoSystemRoot );
	Assert( pfcbT != pfcbNil );
	for ( pfucb = pfcbT->pfucb;
		pfucb != pfucbNil ;
		pfucb = pfucb->pfucbNextInstance )
		{
		CSR		*pcsr = PcsrCurrent( pfucb );

		if ( PgnoOfSrid( pfucb->bmStore ) == pgno ||
			 PgnoOfSrid( pfucb->itemStore ) == pgno ||
			 PgnoOfSrid( pfucb->sridFather ) == pgno )
			{
			fConflict = fTrue;
			goto Done;
			}
			
		if ( pcsr != pcsrNil && pfucb != pfucbIn &&
			 ( pcsr->pgno == pgno ||
			   PgnoOfSrid( pcsr->bmRefresh ) == pgno ||
			   PgnoOfSrid( pcsr->bm ) == pgno
			 )
		   )
			{
			fConflict = fTrue;
			goto Done;
			}
#ifdef DEBUG
			{
			/* the stack can not this page [due to wait latches on children]
			/**/
			for ( ; pcsr != pcsrNil; pcsr = pcsr->pcsrPath )
				{
				Assert( PgnoOfSrid( pcsr->bm ) != pgno || pfucb == pfucbIn );
				Assert( PgnoOfSrid( pcsr->bmRefresh ) != pgno || pfucb == pfucbIn );
				Assert( pcsr->pgno != pgno || pfucb == pfucbIn );
				}
			}
#endif
		}

Done:
	return 	fConflict;
	}


LOCAL ERR ErrBMIExpungeBacklink( BMFIX *pbmfix, BOOL fAlloc )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib = pbmfix->ppib;
	FUCB	*pfucb = pbmfix->pfucb;
	FUCB	*pfucbSrc = pbmfix->pfucbSrc;

		// UNDONE: cleanup for FDP record pages

	if ( PMPageTypeOfPage( pfucb->ssib.pbf->ppage ) != pgtypRecord )
		return err;

	Assert( PMPageTypeOfPage( pfucb->ssib.pbf->ppage ) == pgtypRecord );
	Assert( ppib == pfucb->ppib );

	/*	check if the node is deleted already. If it is, then all its index
	/*	should have been marked as deleted. So simply delete the backlink node.
	/**/
	if ( !FNDDeleted( *pfucb->ssib.line.pb ) )
		{
		/*	clean non-clustered indexes.
		/*	Latch current buffers in memory.
		/**/
		Assert( PMPageTypeOfPage( pfucb->ssib.pbf->ppage ) == pgtypRecord );
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
		Assert( pbmfix->sridNew == SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
			PcsrCurrent( pfucb )->itag ) );

		NDGetNode( pfucb );

		/*	fix indexes
		/**/
		Call( ErrBMFixIndexes( pbmfix, fAlloc ) );
		}

HandleError:
	return err;
	}


LOCAL ERR ErrBMExpungeBacklink( FUCB *pfucb, BOOL fTableClosed, SRID sridFather )
	{
	ERR		err = JET_errSuccess;
	PIB 	*ppib = pfucb->ppib;
	PGNO	pgnoSrc;
	INT		itagSrc;
	FUCB	*pfucbSrc;
	CSR		*pcsr = PcsrCurrent( pfucb );
	BOOL	fConflict = !fTableClosed;
	BOOL	fBeginTrx = fFalse;
	BMFIX	bmfix;

	Assert( pfucb->ppib->level == 0 );

	/*	access source page of moved node
	/**/
	AssertNDGet( pfucb, pcsr->itag );
	NDGetBackLink( pfucb, &pgnoSrc, &itagSrc );

	CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbSrc ) );

	/*	latch both buffers in memory for index update, hold the key
	/**/
	BFPin( pfucb->ssib.pbf );
	while( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		}
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	BFUnpin( pfucb->ssib.pbf );

	PcsrCurrent( pfucbSrc )->pgno = pgnoSrc;
	Call( ErrBFWriteAccessPage( pfucbSrc, PcsrCurrent( pfucbSrc )->pgno ) );
	Assert( pfucb->u.pfcb->pgnoFDP == pfucbSrc->ssib.pbf->ppage->pgnoFDP );

#ifdef DEBUG
	{
	PGTYP	pgtyp = PMPageTypeOfPage( pfucb->ssib.pbf->ppage );

	Assert( pgtyp == pgtypRecord ||
		pgtyp == pgtypFDP ||
		pgtyp == pgtypSort ||
		pgtyp == pgtypIndexNC );
	}
#endif

	//	UNDONE: cleanup of record nodes in FDP
	memset( &bmfix, 0, sizeof( BMFIX ) );
	bmfix.pfucb = pfucb;
	bmfix.pfucbSrc = pfucbSrc;
	bmfix.ppib = pfucb->ppib;
	bmfix.sridOld = SridOfPgnoItag( pgnoSrc, itagSrc );
	bmfix.sridNew = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
  		PcsrCurrent( pfucb )->itag );
	Call( ErrBMAddToWaitLatchedBFList( &bmfix, pfucbSrc->ssib.pbf ) );
		
	Assert( PcsrCurrent( pfucbSrc )->pgno == PgnoOfSrid( bmfix.sridOld ) );
	PcsrCurrent( pfucbSrc )->itag = ItagOfSrid( bmfix.sridOld );

	Assert( bmfix.sridOld != SridOfPgnoItag( PgnoRootOfPfucb( pfucb ), ItagRootOfPfucb( pfucb ) ) ||
			pfucb->u.pfcb->pgnoFDP == pgnoSystemRoot );

	/*	check if any cursors are on bm/item
	/*	this check is redundant -- and is used to avoid
	/*	index accesses in the fBufAllocOnly phase
	/**/
	if ( !fTableClosed || pfucb->u.pfcb->pgnoFDP == pgnoSystemRoot )
		{
		Assert( bmfix.ppib == ppib );
		Assert( bmfix.pfucbSrc->dbid == pfucb->dbid );
		Assert( bmfix.pfucbSrc->u.pfcb == pfucb->u.pfcb );
		fConflict = FBMConflict( ppib,
				pfucb->u.pfcb,
				pfucb->dbid,
				bmfix.sridOld,
				PMPageTypeOfPage( bmfix.pfucbSrc->ssib.pbf->ppage ) )
			|| FBMConflict( ppib,
				pfucb->u.pfcb,
				pfucb->dbid,
				bmfix.sridNew,
				PMPageTypeOfPage( bmfix.pfucb->ssib.pbf->ppage ) );

		if ( fConflict )
			{
			Assert( fConflict );
			err = ErrERRCheck( wrnBMConflict );
			goto ReleaseBufs;
			}
		}
#ifdef DEBUG
	else
		{
		Assert( !FBMConflict( ppib,
							  pfucb->u.pfcb,
							  pfucb->dbid,
							  bmfix.sridOld,
							  PMPageTypeOfPage( bmfix.pfucbSrc->ssib.pbf->ppage ) ) &&
				!FBMConflict( ppib,
							  pfucb->u.pfcb,
							  pfucb->dbid,
							  bmfix.sridNew,
							  PMPageTypeOfPage( bmfix.pfucb->ssib.pbf->ppage ) ) );
		Assert( !fConflict );
		}
#endif

	/*	allocate buffers and wait latch buffers
	/**/
	err = ErrBMIExpungeBacklink( &bmfix, fAllocBufOnly );
	if ( err == JET_errWriteConflict )
		{
		err = ErrERRCheck( wrnBMConflict );
		goto ReleaseBufs;
		}

	/*	begin transaction to rollback changes on failure
	/**/
	if ( ppib->level == 0 )
		{
		CallJ( ErrDIRBeginTransaction( ppib ), ReleaseBufs );
		fBeginTrx = fTrue;
		}
	else
		{
		Assert( fFalse );
		}
	
	/*	check if any cursors are on bm/item
	/**/
	if ( !fTableClosed || pfucb->u.pfcb->pgnoFDP == pgnoSystemRoot )
		{
		Assert( bmfix.ppib == ppib );
		Assert( bmfix.pfucbSrc->dbid == pfucb->dbid );
		Assert( bmfix.pfucbSrc->u.pfcb == pfucb->u.pfcb );
		fConflict = FBMConflict( ppib,
				pfucb->u.pfcb,
				pfucb->dbid,
				bmfix.sridOld,
				PMPageTypeOfPage( bmfix.pfucbSrc->ssib.pbf->ppage ) )
			|| FBMConflict( ppib,
				pfucb->u.pfcb,
				pfucb->dbid,
				bmfix.sridNew,
				PMPageTypeOfPage( bmfix.pfucb->ssib.pbf->ppage ) );
		}
#ifdef DEBUG
	else
		{
		Assert( !FBMConflict( ppib,
							  pfucb->u.pfcb,
							  pfucb->dbid,
							  bmfix.sridOld,
							  PMPageTypeOfPage( bmfix.pfucbSrc->ssib.pbf->ppage ) ) &&
				!FBMConflict( ppib,
							  pfucb->u.pfcb,
							  pfucb->dbid,
							  bmfix.sridNew,
							  PMPageTypeOfPage( bmfix.pfucb->ssib.pbf->ppage ) ) );
		Assert( !fConflict );
		}
#endif

	/*	there should be no version on node
	/**/
	fConflict = fConflict || !FVERNoVersion( pfucb->dbid, bmfix.sridOld );
	fConflict = fConflict || FMPLLookupSridFather( bmfix.sridOld, pfucb->dbid );
	
	Assert( FVERNoVersion( pfucb->dbid, bmfix.sridNew ) );

	/*	fix indexes atomically
	/**/
	if ( !fConflict )
		{
		CallJ( ErrBMIExpungeBacklink( &bmfix, fDoMove ), Rollback );

		/*	expunge backlink and redirector. If it is done successfully, then
		/*	write a special ELC log record right away. ELC implies a commit.
		/*	Call DIRPurge to close deferred closed cursors not closed since
		/*	VERCommitTransaction was called instead of ErrDIRCommitTransaction.
		/**/
		Assert( !FMPLLookupSridFather( bmfix.sridOld, pfucb->dbid ) );
#ifdef	OLC_DEBUG
		Assert( !FBMConflict( ppib,
							  pfucb->u.pfcb,
							  pfucb->dbid,
							  bmfix.sridOld,
							  PMPageTypeOfPage( bmfix.pfucbSrc->ssib.pbf->ppage ) ) &&
				!FBMConflict( ppib,
							  pfucb->u.pfcb,
							  pfucb->dbid,
							  bmfix.sridNew,
							  PMPageTypeOfPage( bmfix.pfucb->ssib.pbf->ppage ) ) );
		Assert( FVERNoVersion( pfucb->dbid, bmfix.sridOld ) );
#endif

		if ( fBeginTrx )
			{
			CallJ( ErrNDExpungeLinkCommit( pfucb, pfucbSrc ), Rollback );
			VERPrecommitTransaction( ppib );
			VERCommitTransaction( ppib, fRCECleanSession );
			Assert( ppib->level == 0 );
			DIRPurge( ppib );

			fBeginTrx = fFalse;
			}
#ifdef DEBUG
		Assert( ppib->dwLogThreadId == DwUtilGetCurrentThreadId() );
		ppib->dwLogThreadId = 0;
#endif

		/*	force ErrRCEClean to clean all versions so that
		/*	bookmark aliasing does not occur in indexes.
		/**/
//		CallS( ErrRCEClean( ppib, fRCECleanSession ) );

		goto ReleaseBufs;
		}
	else
		{
		Assert( fConflict );
		err = ErrERRCheck( wrnBMConflict );
		}

Rollback:
	if ( fBeginTrx )
		{
		CallS( ErrDIRRollback( ppib ) );
		}

ReleaseBufs:
	Assert( !fBeginTrx || ppib->level == 0 );
	BMReleaseBmfixBfs( &bmfix );

HandleError:
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	Assert( pfucbSrc != pfucbNil );
	DIRClose( pfucbSrc );
	Assert( !fBeginTrx || pfucb->ppib->level == 0 );

	return err;
	}


ERR ErrBMDoEmptyPage(
	FUCB	*pfucb,
	RMPAGE	*prmpage,
	BOOL	fAllocBuf,
	BOOL	*pfRmParent,
	BOOL	fSkipDelete )
	{
	ERR		err = JET_errSuccess;

	if ( !fSkipDelete )
		{
		/*	access page from which page pointer is deleted
		/**/
		CallR( ErrBFWriteAccessPage( pfucb, prmpage->pgnoFather ) );
		Assert( pfucb->ssib.pbf == prmpage->pbfFather );
		AssertBFPin( pfucb->ssib.pbf );

		/* 	delete invisble parent pointer node and mark parent dirty
		/**/
		CallR( ErrNDDeleteInvisibleSon( pfucb, prmpage, fAllocBuf, pfRmParent ) );
		if ( fAllocBuf )
			{
			return err;
			}
		}

	Assert( fLogDisabled || !FDBIDLogOn( pfucb->dbid ) ||
			CmpLgpos( &pfucb->ppib->lgposStart, &lgposMax ) != 0 );

	/*	adjust sibling pointers and mark sibling dirty
	/**/
	if ( prmpage->pbfLeft != pbfNil )
		{
		if ( !fLogDisabled && !fRecovering && FDBIDLogOn( pfucb->dbid ) )
			{
			SSIB ssib;

			ssib.ppib = pfucb->ppib;
			ssib.pbf = prmpage->pbfLeft;
			PMDirty( &ssib );
			}
		else
			{
			BF *pbfT = prmpage->pbfLeft;
			DBHDRIncDBTime( rgfmp[ DbidOfPn( pbfT->pn ) ].pdbfilehdr );
			PMSetDBTime( pbfT->ppage, QwDBHDRDBTime( rgfmp[ DbidOfPn( pbfT->pn ) ].pdbfilehdr ) );
			BFSetDirtyBit( prmpage->pbfLeft );
			}

		SetPgnoNext( prmpage->pbfLeft->ppage, prmpage->pgnoRight );
		}

	if ( prmpage->pbfRight != pbfNil )
		{
		if ( !fLogDisabled && !fRecovering && FDBIDLogOn( pfucb->dbid ) )
			{
			SSIB ssib;

			ssib.ppib = pfucb->ppib;
			ssib.pbf = prmpage->pbfRight;
			PMDirty( &ssib );
			}
		else
			{
			BF *pbfT = prmpage->pbfRight;
			DBHDRIncDBTime( rgfmp[ DbidOfPn( pbfT->pn ) ].pdbfilehdr );
			PMSetDBTime( pbfT->ppage, QwDBHDRDBTime( rgfmp[ DbidOfPn( pbfT->pn ) ].pdbfilehdr ) );
			BFSetDirtyBit( prmpage->pbfRight );
			}
		
		SetPgnoPrev( prmpage->pbfRight->ppage, prmpage->pgnoLeft );
		}

	return err;
	}


/* checks if page can be merged with following page
/* without violating density constraints
/**/
LOCAL VOID BMMergeablePage( FUCB *pfucb, FUCB *pfucbRight, BOOL *pfMergeable )
	{
	SSIB	*pssib = &pfucb->ssib;
	SSIB	*pssibRight = &pfucbRight->ssib;
	INT		cUsedTags;
	ULONG	cbReq;
	ULONG	cbFree;
	INT		cFreeTagsRight;

	if ( fBackupInProgress &&
		 PgnoOfPn( pssib->pbf->pn ) > PgnoOfPn( pssibRight->pbf->pn ) )
		{
		*pfMergeable = fFalse;
		return;
		}
	
	cUsedTags = ctagMax - CPMIFreeTag( pssib->pbf->ppage );
	/* current space + space for backlinks
	/**/
	cbReq = cbAvailMost - CbNDFreePageSpace( pssib->pbf ) -
				CbPMLinkSpace( pssib ) + cUsedTags * sizeof(SRID);
	cbFree = CbBTFree( pfucbRight, CbFreeDensity( pfucbRight ) );
	cFreeTagsRight = CPMIFreeTag( pssibRight->pbf->ppage );

	/* look for available space without violating density constraint,
	/* in next page
	/* also check if tag space available in right page is sufficient
	/**/
	// UNDONE: this is a conservative estimate -- we can merge if the space
	// is enough for all descendants of FOP [which may be less than cUsedTags]
	if ( cbFree >= cbReq && cFreeTagsRight >= cUsedTags )
		{
		*pfMergeable = fTrue;
		}
	else
		{
		*pfMergeable = fFalse;
		}

	return;
	}


ERR	ErrBMDoMergeParentPageUpdate( FUCB *pfucb, SPLIT *psplit )
	{
//	UNDONE: get rid of need to save ssib
	ERR		err;
	INT		cline = 0;
	LINE	rgline[4];
	SSIB	*pssib = &pfucb->ssib;			
	SSIB	ssibSav = *pssib;
	CSR		csrSav = *PcsrCurrent( pfucb );
	KEY		*pkeyMin = &psplit->key;
	BYTE 	*pbNode;

#ifdef DEBUG
	INT		itagFather;
	INT		ibSon;

	Assert( psplit->pbfPagePtr != pbfNil );
	Assert( pkeyMin->cb != 0 );

	// Verify that path to father is intact.
	if ( fRecovering )
		{
		NDGetItagFatherIbSon(
			&itagFather,
			&ibSon,
			psplit->pbfPagePtr->ppage,
			psplit->itagPagePointer );
		}
	else
		{
		Assert( csrSav.pcsrPath  &&
			csrSav.pcsrPath->pgno == PgnoOfPn( psplit->pbfPagePtr->pn )  &&
			csrSav.pcsrPath->itag == psplit->itagPagePointer );

		itagFather = csrSav.pcsrPath->itagFather;
		ibSon = csrSav.pcsrPath->ibSon;
		}
	Assert( itagFather != itagNil  &&  ibSon != ibSonNull );
	Assert( PbNDSon( (BYTE*)psplit->pbfPagePtr->ppage +
		psplit->pbfPagePtr->ppage->rgtag[itagFather].ib )[ ibSon ] == psplit->itagPagePointer );
#endif

	pssib->pbf = psplit->pbfPagePtr;
	pssib->itag = PcsrCurrent( pfucb )->itag = (SHORT)psplit->itagPagePointer;
	PcsrCurrent( pfucb )->pgno = PgnoOfPn( psplit->pbfPagePtr->pn );

	Assert( pssib->itag != itagFOP &&
			pssib->itag != itagNull &&
			pssib->itag != itagNil );

	if ( FNDMaxKeyInPage( pfucb ) )
		{
		/*	can't merge -- since we need to update grand parent
		/**/
		return errBMMaxKeyInPage;
		}
		
	AssertNDGet( pfucb, psplit->itagPagePointer );

	pbNode = pssib->line.pb;
	cline = 0;
	rgline[cline].pb = pbNode;
	rgline[cline++].cb = 1;

	rgline[cline].pb = (BYTE *) &pkeyMin->cb;
	rgline[cline++].cb = 1;

	rgline[cline].pb = pkeyMin->pb;
	rgline[cline++].cb = pkeyMin->cb;

	rgline[cline].pb = PbNDSonTable( pbNode );
	rgline[cline++].cb = pssib->line.cb - (ULONG)( PbNDSonTable( pbNode ) - pbNode );
	Assert( (INT)(pssib->line.cb - ( PbNDSonTable( pbNode ) - pbNode )) >= 0 );
	
	PMDirty( pssib );
	err = ErrPMReplace( pssib, rgline, cline );
	Assert( !fRecovering || err == JET_errSuccess );
	
	NDCheckPage( pssib );

	*pssib = ssibSav;
	*PcsrCurrent( pfucb ) = csrSav;

	return err;
	}


ERR ErrBMDoMerge( FUCB *pfucb, FUCB *pfucbRight, SPLIT *psplit, LRMERGE *plrmerge )
	{
	ERR 		err;
	BF			*pbf = pbfNil;
	BYTE		*rgb;
	SSIB		*pssib = &pfucb->ssib;
	SSIB		*pssibRight = pfucbRight == NULL ? NULL : &pfucbRight->ssib;
	BOOL		fVisibleSons;
	LINE		rgline[5];
	INT 		cline;
	BYTE		cbSonMerged;
	BYTE		cbSonRight;
	BYTE		*pbNode;
	ULONG		cbNode;
	BYTE		*pbSonRight;
	ULONG		ibSonMerged;

	/*	if pfucbRight is NULL, then plrmerge must be set.
	 */
	Assert( pfucbRight || ( fRecovering && plrmerge ) );

	/*	allocate temporary page buffer
	/**/
	Call( ErrBFAllocTempBuffer( &pbf ) );
	rgb = (BYTE *)pbf->ppage;

	/*	check if sons of split page are visible
	/*	move sons
	/*	update sibling FOP
	/*	update merged FOP
	/**/

	/*	Merge is done on level 0, set ppib->fBegin0Logged and logposStart
	 *	to fake begin transaction state so that Checkpoint calculation will
	 *	take the faked lgposStart into account.
	 */
	if ( !fLogDisabled && FDBIDLogOn( pfucb->dbid ) )
		{
		EnterCriticalSection(critLGBuf);
		if ( !fRecovering )
			GetLgposOfPbEntry( &pfucb->ppib->lgposStart );
		else
			pfucb->ppib->lgposStart = lgposRedo;
		LeaveCriticalSection(critLGBuf);
		pfucb->ppib->fBegin0Logged = fTrue;
		}

	/*	check if sons of split page are visible
	/*	cache split page son table
	/**/
	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );

	fVisibleSons = FNDVisibleSons( *pssib->line.pb );

	/* allocate buffers only, do not move nodes
	/**/
	err = ErrBTMoveSons( psplit,
		pfucb,
		pfucbRight,
		itagFOP,
		psplit->rgbSonNew,
		fVisibleSons,
		fAllocBufOnly,
		plrmerge ? (BKLNK *) ( plrmerge->rgb + plrmerge->cbKey )
				 : (BKLNK *) NULL,
		plrmerge ? plrmerge->cbklnk : 0 );
	if ( err == errDIRNotSynchronous )
		{
		err = ErrERRCheck( wrnBMConflict );
		goto HandleError;
		}	
	Call( err );

	/* if buffer dependencies cause a cycle/violation,
	/* mask error to warning -- handled at caller
	/**/
	if ( pfucbRight == NULL )
		Assert( psplit->pbfSibling == pbfNil );
	else
		{
		err = ErrBFDepend( psplit->pbfSibling, psplit->pbfSplit );
		if ( err == errDIRNotSynchronous )
			{
			err = ErrERRCheck( wrnBMConflict );
			goto HandleError;
			}
		Call( err );
		}

	/*	flag pages dirty
	/**/
	PMDirty( pssib );

	if ( pfucbRight )
		PMDirty( pssibRight );

	/*	check if there is a page conflict
	/**/
	if ( !fRecovering && FBMPageConflict( pfucb, psplit->pgnoSplit ) )
		{
		err = ErrERRCheck( wrnBMConflict );
		goto HandleError;
		}
		
	/*	update page pointer key
	/**/
	if ( psplit->pbfPagePtr != pbfNil )
		{
		Call( ErrBMDoMergeParentPageUpdate( pfucb, psplit ) );
		}
	else
		{
		Assert( fRecovering );
		}
		
	/* move nodes atomically
	/**/
	pssib->itag = itagFOP;
	Assert( psplit->ibSon == 0 );
	Assert( psplit->splitt == splittRight );
	Assert( pssib->itag == itagFOP );
	LgHoldCriticalSection( critJet );
	CallS( ErrBTMoveSons( psplit,
		pfucb,
		pfucbRight,
		itagFOP,
		psplit->rgbSonNew,
		fVisibleSons,
		fDoMove,
		plrmerge ? (BKLNK *) ( plrmerge->rgb + plrmerge->cbKey )
				 : (BKLNK *) NULL,
		plrmerge ? plrmerge->cbklnk : 0 ) );
	LgReleaseCriticalSection( critJet );

	/*	update new FOP
	/*	prepend son table
	/**/
	if ( pfucbRight )
		{
		pssibRight->itag = itagFOP;
		PMGet( pssibRight, pssibRight->itag );
		cline = 0;
		rgb[0] = *pssibRight->line.pb;
		Assert( *(pssibRight->line.pb + 1) == 0 );
		rgb[1] = 0;
		rgline[cline].pb = rgb;
		rgline[cline++].cb = 2;
		/* left page might have no sons of FOP, but only tags
		/* and hence not an empty page.
		/**/
		cbSonMerged = psplit->rgbSonNew[0];

		/* prepend new son table to already existing son table
		/**/
		pbNode = pssibRight->line.pb;
		cbNode = pssibRight->line.cb;
		pbSonRight = PbNDSon( pbNode );
		ibSonMerged = cbSonMerged;
		
		cbSonRight = CbNDSon( pbNode );
		if ( cbSonMerged )
			NDSetSon( rgb[0] );
		psplit->rgbSonNew[0] += cbSonRight;
		rgline[cline].pb = psplit->rgbSonNew;
		rgline[cline++].cb = psplit->rgbSonNew[0] + 1;
		for ( ; ibSonMerged < psplit->rgbSonNew[0];  )
			{
			psplit->rgbSonNew[++ibSonMerged] = *pbSonRight++;
			Assert( ibSonMerged <= cbSonMax );
			}

		if ( fVisibleSons )
			NDSetVisibleSons( rgb[0] );
		Assert( pssibRight->itag == itagFOP );
		Assert( cline == 2 );
		Assert( PgnoOfPn( pssibRight->pbf->pn ) == psplit->pgnoSibling );
		CallS( ErrPMReplace( pssibRight, rgline, cline ) );
		AssertBTFOP( pssibRight );

		AssertNDGet( pfucbRight, itagFOP );
		Assert( pssibRight == &pfucbRight->ssib );
		NDCheckPage( pssibRight );
		}

	/*	update split FOP -- leave one deleted node in page
	/*	so BMCleanup can later retrieve page
	/**/
	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );
	AssertBTFOP( pssib );
	pbNode = pssib->line.pb;
	Assert( !pfucbRight || CbNDSon( pbNode ) == cbSonMerged );
	rgb[0] = *pbNode;
	rgb[1] = 0;

	NDResetSon( rgb[0] );
	Assert( FNDVisibleSons( rgb[0] ) );
	rgline[0].pb = rgb;
	Assert( psplit->ibSon == 0 );
	rgline[0].cb = 2 + psplit->ibSon;
	Assert( PgnoOfPn(pssib->pbf->pn) == psplit->pgnoSplit );
	CallS( ErrPMReplace( pssib, rgline, 1 ) );

	Call( ErrLGMerge( pfucb, psplit ) );

#ifdef DEBUG
	if ( !fRecovering )
		{
		SSIB ssibT = pfucb->ssib;
		ssibT.pbf = psplit->pbfSplit;

		(VOID) ErrLGCheckPage2( pfucb->ppib, ssibT.pbf,
				ssibT.pbf->ppage->cbFree,
				ssibT.pbf->ppage->cbUncommittedFreed,
				(SHORT)ItagPMQueryNextItag( &ssibT ),
				ssibT.pbf->ppage->pgnoFDP );
	
		ssibT.pbf = psplit->pbfSibling;
		(VOID) ErrLGCheckPage2( pfucb->ppib, ssibT.pbf,
				ssibT.pbf->ppage->cbFree,
				ssibT.pbf->ppage->cbUncommittedFreed,
				(SHORT)ItagPMQueryNextItag( &ssibT ),
				ssibT.pbf->ppage->pgnoFDP );
		}

	CallS( ErrPMGet( pssib, itagFOP ) );
	Assert( FNDNullSon( *pssib->line.pb ) );
#endif

HandleError:
	if ( pbf != pbfNil )
		BFSFree( pbf );

	/*	Reset the faked begin transaction effect.
	 */
	if ( !fLogDisabled && FDBIDLogOn( pfucb->dbid ) )
		{
		pfucb->ppib->lgposStart = lgposMax;
		pfucb->ppib->fBegin0Logged = fFalse;
		}

	return err;
	}


/* merge current page with the following page
/**/
LOCAL ERR ErrBMMergePage( FUCB *pfucb, FUCB *pfucbRight, KEY *pkeyMin, SRID sridFather )
	{
	ERR		err = JET_errSuccess;
	SPLIT	*psplit = NULL;
	SSIB	*pssibRight = &pfucbRight->ssib;
	SSIB	*pssib = &pfucb->ssib;
	LINE	lineNull = { 0, NULL };
	BF		*pbfParent = pbfNil;
	BOOL	fMinKeyAvailable = FPMGetMinKey( pfucb, pkeyMin );
	
	AssertCriticalSection( critSplit );
//	Assert( pkeyMin->cb != 0 );
//	Assert( fFalse );
	Assert( pfucbRight != pfucbNil );
	Assert( fMinKeyAvailable );

	if ( FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}

	CallR( ErrBTGetInvisiblePagePtr( pfucb, sridFather ) );
	Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );
	Assert( PcsrCurrent( pfucb )->pcsrPath->pgno != PcsrCurrent( pfucb )->pgno );

	Call( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pcsrPath->pgno ) );
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		return ErrERRCheck( JET_errWriteConflict );
		}
	pbfParent = pfucb->ssib.pbf;
	BFSetWaitLatch( pbfParent, pfucb->ppib );
				
	/* current and right page must already be latched
	/**/
	Call( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );

	/*	initialize local variables and allocate split resources
	/*  pin the buffers even though they are already pinned --
	/*  BTReleaseSplitBufs unpins them.
	/**/
	psplit = SAlloc( sizeof(SPLIT) );
	if ( psplit == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}
	memset( (BYTE *)psplit, 0, sizeof(SPLIT) );
	psplit->ppib = pfucb->ppib;
	psplit->pgnoSplit = PcsrCurrent( pfucb )->pgno;
	psplit->pbfSplit = pfucb->ssib.pbf;
	AssertBFPin( psplit->pbfSplit );
	AssertBFWaitLatched( psplit->pbfSplit, pfucb->ppib );
	BFSetWriteLatch( psplit->pbfSplit, pfucb->ppib  );

	psplit->pgnoSibling = pfucbRight->pcsr->pgno;
	psplit->pbfSibling = pssibRight->pbf;
	AssertBFPin( psplit->pbfSibling );
	AssertBFWaitLatched( psplit->pbfSibling, pfucbRight->ppib );
	BFSetWriteLatch( psplit->pbfSibling, pfucb->ppib );
	psplit->ibSon = 0;
	psplit->splitt = splittRight;

	if ( PcsrCurrent( pfucb )->pcsrPath->itag == itagNil )
		{
		/*	intrinsic page pointer
		/**/
		psplit->itagPagePointer = PcsrCurrent( pfucb )->pcsrPath->itagFather;
		}
	else
		{
		psplit->itagPagePointer = PcsrCurrent( pfucb )->pcsrPath->itag;
		}
	Assert( psplit->itagPagePointer != itagNil );
	
	psplit->pbfPagePtr = pbfParent;
	AssertBFPin( psplit->pbfPagePtr );
	AssertBFWaitLatched( psplit->pbfPagePtr, pfucb->ppib );
	BFSetWriteLatch( psplit->pbfPagePtr, pfucb->ppib );
	
	Assert( pkeyMin->cb <= JET_cbKeyMost );
	memcpy( psplit->rgbKey, pkeyMin->pb, pkeyMin->cb );
	psplit->key.pb = psplit->rgbKey;
	psplit->key.cb = pkeyMin->cb;

	Call( ErrBMDoMerge( pfucb, pfucbRight, psplit, NULL ) );

#ifdef DEBUGGING
	BTCheckSplit( pfucb, PcsrCurrent( pfucb )->pcsrPath );
#endif
	
	/* if already exisitng buffer dependencies cause cycle/violation,
	/* abort
	/**/
	Assert( err == JET_errSuccess || err == wrnBMConflict );
	if ( err == wrnBMConflict )
		{
		goto HandleError;
		}

	/* insert delete-flagged node in page
	/* so that BMCleanPage has a node to search for
	/* when it gets to remove the empty page
	/**/
	CallS( ErrDIRBeginTransaction( pfucb->ppib ) );
	Assert( PcsrCurrent( pfucb )->pgno == psplit->pgnoSplit );
	PcsrCurrent( pfucb )->itagFather = itagFOP;

	do
		{
		if ( err == errDIRNotSynchronous )
			{
			BFSleep( cmsecWaitGeneric );
			}
		err = ErrNDInsertNode( pfucb, pkeyMin, &lineNull, fNDDeleted, fDIRNoVersion );
		} while( err == errDIRNotSynchronous );
	
	if ( err >= JET_errSuccess )
		err = ErrDIRCommitTransaction( pfucb->ppib, JET_bitCommitLazyFlush );
	if ( err < 0 )
		{
#ifdef OLC_DEBUG
		Assert( fFalse );
#endif
		CallS( ErrDIRRollback( pfucb->ppib ) );
		}
	Call( err );

	/*	register page in MPL
	/**/
	Assert( sridFather != sridNull && sridFather != sridNullLink );
	MPLRegister( pfucb->u.pfcb,
		pssib,
		PnOfDbidPgno( pfucb->dbid, PcsrCurrent( pfucb )->pgno ),
		sridFather );

#ifdef DEBUG
	/*	source page should have at least one son
	/**/
	NDGet( pfucb, itagFOP );
	Assert( !FNDNullSon( *pssib->line.pb ) );
#endif

	//	UNDONE:	review conditional registry by B. Sriram
	//	UNDONE:	avoid case of fully depopulated page
	/*	a case exists where a page is fully depopulated as a result
	/*	of regular clean up finding a conflict after all nodes have
	/*	been deleted but before the min key can be inserted.  Handle
	/*	this case by not registering empty page.
	/**/
	AssertFBFWriteAccessPage( pfucbRight, PcsrCurrent( pfucbRight )->pgno );
	NDGet( pfucbRight, itagFOP );
	if ( !FNDNullSon( *pssibRight->line.pb ) )
		{
		MPLRegister( pfucbRight->u.pfcb,
			pssibRight,
			PnOfDbidPgno( pfucb->dbid, psplit->pgnoSibling ),
			sridFather );
		}
	else
		{
		Assert( fFalse );
		}

HandleError:
	/* release allocated buffers and memory
	/**/
	if ( psplit != NULL )
		{
		BTReleaseSplitBfs( fFalse, psplit, err );
		SFree( psplit );
		}

	if ( pbfParent != pbfNil )
		{
		BFResetWaitLatch( pbfParent, pfucb->ppib );
		}

	return err;
	}


/*	latches buffer and adds it to list of latched buffers in rmpage
/**/
ERR ErrBMAddToLatchedBFList( RMPAGE	*prmpage, BF *pbfLatched )
	{
#define cpbfBlock	10
	ULONG	cpbf = prmpage->cpbf;

	if ( FBFWriteLatchConflict( prmpage->ppib, pbfLatched ) )
		{
		return ErrERRCheck( JET_errWriteConflict );
		}
		
	if ( prmpage->cpbfMax <= prmpage->cpbf + 1 )
		{
		BF		**ppbf;

		/* run out of space, get more buffers
		/**/
		prmpage->cpbfMax += cpbfBlock;
		ppbf = SAlloc( sizeof(BF*) * (prmpage->cpbfMax) );
		if ( ppbf == NULL )
			return ErrERRCheck( JET_errOutOfMemory );
		memcpy( ppbf, prmpage->rgpbf, sizeof(BF*) * cpbf);
		if ( prmpage->rgpbf )
			{
			SFree(prmpage->rgpbf);
			}
		prmpage->rgpbf = ppbf;
		}
	
	prmpage->cpbf++;
	*(prmpage->rgpbf + cpbf) = pbfLatched;
	BFSetWaitLatch( pbfLatched, prmpage->ppib );

	return JET_errSuccess;
	}


//	UNDONE:	handle error from log write fail in ErrBMIEmptyPage
//			when actually removing pages.  We should be able to ignore
//			error since buffers will not be flushed as a result of
//			WAL.  Thus OLC will not be done.  We may discontinue OLC
//			when log fails to mitigate all buffers dirty.
/* removes a page and adjusts pointers at parent and sibling pages
/* called only at do-time
/**/
LOCAL ERR ErrBMIRemovePage(
	FUCB		*pfucb,
	CSR			*pcsr,
	RMPAGE		*prmpage,
	BOOL 		fAllocBuf )
	{
	ERR  		err;
	PIB  		*ppib = pfucb->ppib;
	SSIB		*pssib = &pfucb->ssib;
	BOOL		fRmParent = fFalse;
#ifdef PAGE_MODIFIED
	PGDISCONT	pgdiscontOrig;
	PGDISCONT	pgdiscontFinal;
#endif

	AssertCriticalSection( critSplit );
	Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );
	Assert( prmpage->pgnoFather != pgnoNull );
	Assert( pfucb->ppib->level == 1 );

	if ( FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
	
	/* seek removed page, get left and right pgno
	/**/
	Call( ErrBFWriteAccessPage( pfucb, prmpage->pgnoRemoved ) );
	AssertBFWaitLatched( pssib->pbf, pfucb->ppib );

	if ( fAllocBuf && FBMPageConflict( pfucb, prmpage->pgnoRemoved ) )
		{
		err = ErrERRCheck( wrnBMConflict );
		goto HandleError;
		}

#ifdef DEBUG
	NDGet( pfucb, itagFOP );
	Assert( fAllocBuf || FPMEmptyPage( pssib ) || FPMLastNode( pssib ) );
#endif
	PgnoPrevFromPage( pssib, &prmpage->pgnoLeft );
	PgnoNextFromPage( pssib, &prmpage->pgnoRight );

	/* seek and latch parent and sibling pages iff fAllocBuf
	/**/
	Call( ErrBFWriteAccessPage( pfucb, prmpage->pgnoFather ) );
	prmpage->pbfFather = pfucb->ssib.pbf;
	if ( fAllocBuf )
		{
		Call( ErrBMAddToLatchedBFList( prmpage, prmpage->pbfFather ) );
		}
	else
		{
		AssertBFWaitLatched( prmpage->pbfFather, pfucb->ppib );
		}

	if ( prmpage->pgnoLeft != pgnoNull )
		{
		Call( ErrBFWriteAccessPage( pfucb, prmpage->pgnoLeft ) );
		prmpage->pbfLeft = pfucb->ssib.pbf;
		if ( fAllocBuf )
			{
			Call( ErrBMAddToLatchedBFList( prmpage, prmpage->pbfLeft ) );
			}
		else
			{
			AssertBFWaitLatched( prmpage->pbfLeft, pfucb->ppib );
			}
		}

	if ( prmpage->pgnoRight != pgnoNull )
		{
		Call( ErrBFWriteAccessPage( pfucb, prmpage->pgnoRight ) );
		prmpage->pbfRight = pfucb->ssib.pbf;
		if ( fAllocBuf )
			{
			Call( ErrBMAddToLatchedBFList( prmpage, prmpage->pbfRight ) );
			}
		else
			{
			AssertBFWaitLatched( prmpage->pbfRight, pfucb->ppib );
			}
		}

	Call( ErrBMDoEmptyPage( pfucb, prmpage, fAllocBuf, &fRmParent, fFalse ) );

	if ( !fAllocBuf )
		{
#undef BUG_FIX
#ifdef BUG_FIX
		err = ErrLGEmptyPage( pfucb, prmpage );
		Assert( err >= JET_errSuccess || fLogDisabled );
		err = JET_errSuccess;
#else
		Call( ErrLGEmptyPage( pfucb, prmpage ) );
#endif

#ifdef PAGE_MODIFIED
		/* adjust the OLCstat info for fcb
		/**/
		pfucb->u.pfcb->cpgCompactFreed++;
		pgdiscontOrig = pgdiscont( prmpage->pgnoLeft, prmpage->pgnoRemoved )
	  		+ pgdiscont( prmpage->pgnoRight, prmpage->pgnoRemoved );
		pgdiscontFinal = pgdiscont( prmpage->pgnoLeft, prmpage->pgnoRight );
		pfucb->u.pfcb->olc_data.cDiscont += pgdiscontFinal - pgdiscontOrig;
		FCBSetOLCStatsChange( pfucb->u.pfcb );
#endif
		}

	/* call next level of remove page if required
	/**/
	if ( fRmParent )
		{
		/* cache rmpage info
		/**/
		PGNO	pgnoFather = prmpage->pgnoFather;
		PGNO	pgnoRemoved = prmpage->pgnoRemoved;
		INT		itagPgptr = prmpage->itagPgptr;
		INT		itagFather = prmpage->itagFather;
		INT		ibSon = prmpage->ibSon;
		CSR		*pcsrFather = pcsr->pcsrPath;

			//	access parent page to free and remove buffer dependencies
		if ( fAllocBuf )
			{
			forever
				{
				Call( ErrBFWriteAccessPage( pfucb, prmpage->pgnoFather ) );

				Assert( pfucb->u.pfcb->pgnoFDP == pssib->pbf->ppage->pgnoFDP );

					//	if no dependencies, then break
		
				if ( pfucb->ssib.pbf->cDepend == 0 )
					{
					break;
					}

					//	remove dependencies on buffer of page to be removed, to
					//	prevent buffer anomalies after buffer is reused.
		
				if ( ErrBFRemoveDependence( pfucb->ppib, pfucb->ssib.pbf, fBFWait ) != JET_errSuccess )
					{
					err = ErrERRCheck( wrnBMConflict );
					goto HandleError;
					}
				}
			}

		Assert( pcsrFather != pcsrNil );

		/* set up prmpage for the next level
		/**/
		prmpage->pgnoFather = pcsrFather->pgno;
		prmpage->pgnoRemoved = pcsr->pgno;
		prmpage->itagPgptr = pcsrFather->itag;
		prmpage->itagFather = pcsrFather->itagFather;
		prmpage->ibSon = pcsrFather->ibSon;

		/* tail recursion
		/**/
		err = ErrBMIRemovePage( pfucb, pcsr->pcsrPath, prmpage, fAllocBuf );

		/* reset rmpage to cached values
		/**/
		prmpage->pgnoFather = pgnoFather;
		prmpage->pgnoRemoved = pgnoRemoved;
		prmpage->itagPgptr = itagPgptr;
		prmpage->itagFather = itagFather;
		prmpage->ibSon = ibSon;

		Call( err );
		}

	if ( !fAllocBuf )
		{
		/* release page to parentFDP
		/**/
		CallS( ErrDIRBeginTransaction( pfucb->ppib ) );
		err = ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, prmpage->pgnoRemoved, 1 );
#ifdef BUG_FIX
		/*	ignore error from ErrSPFreeExt
		/**/
		err = ErrDIRCommitTransaction( pfucb->ppib, JET_bitCommitLazyFlush );
		Assert( err >= JET_errSuccess || fLogDisabled );
		err = JET_errSuccess;
#else
		if ( err >= JET_errSuccess )
			{
			err = ErrDIRCommitTransaction( pfucb->ppib, JET_bitCommitLazyFlush );
			}
		if ( err < 0 )
			{
			CallS( ErrDIRRollback( pfucb->ppib ) );
			goto HandleError;
			}
#endif
		}

	Assert( err >= JET_errSuccess );
	return err;

HandleError:
	BTReleaseRmpageBfs( fFalse, prmpage );
	return err;
	}


BOOL FPMGetMinKey( FUCB *pfucb, KEY *pkeyMin )
	{
	SSIB	*pssib = &pfucb->ssib;
	
	PcsrCurrent( pfucb )->itagFather = itagFOP;
	NDGet( pfucb, itagFOP );
	if ( !FNDNullSon( *( pssib->line.pb ) ) )
		{
		//	NOTE: pkeyMin->cb == 0 for pages with the bmRoot
		
		NDMoveFirstSon( pfucb, PcsrCurrent( pfucb ) );
		pkeyMin->cb = CbNDKey( pssib->line.pb );
		Assert( pkeyMin->cb <= JET_cbKeyMost );
		memcpy( pkeyMin->pb, PbNDKey( pssib->line.pb ), pkeyMin->cb );
		return fTrue;
		}
	else
		{
		pkeyMin->cb = 0;
		return fFalse;
		}
	}
	
	// 	set up rmpage
	//	call ErrBMRemovePage twice (once to latch buffers and once to remove)

ERR	ErrBMRemovePage( BMDELNODE *pbmdelnode, FUCB *pfucb )
	{
	ERR		err;
	RMPAGE	*prmpage = prmpageNil;
	SSIB	*pssib = &pfucb->ssib;
	
	Assert( FPMLastNode( pssib ) );
	Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );

		// allocate and initialize rmpage struct
	
	prmpage = (RMPAGE *) SAlloc( sizeof(RMPAGE) );
	if ( prmpage == prmpageNil )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}
	memset( (BYTE *)prmpage, 0, sizeof(RMPAGE) );
	prmpage->ppib = pfucb->ppib;
	prmpage->pgnoRemoved = PcsrCurrent(pfucb)->pgno;
	prmpage->dbid = pfucb->dbid;
	prmpage->pgnoFather = PcsrCurrent( pfucb )->pcsrPath->pgno;
	prmpage->itagPgptr = PcsrCurrent( pfucb )->pcsrPath->itag;
	prmpage->itagFather = PcsrCurrent( pfucb )->pcsrPath->itagFather;
	prmpage->ibSon = PcsrCurrent( pfucb )->pcsrPath->ibSon;

		// allocate rmpage resources
	
	Call( ErrBMIRemovePage(
					pfucb,
					PcsrCurrent( pfucb )->pcsrPath,
					prmpage,
					fAllocBufOnly ) );
	Assert ( err == JET_errSuccess || err == wrnBMConflict );
	if ( err == wrnBMConflict )
		{
		Assert( !pbmdelnode->fPageRemoved );
		goto HandleError;
		}

		//	check for conflict again after all buffers latched
		
	if ( FBMPageConflict( pfucb, prmpage->pgnoRemoved ) )
		{
		Assert( !pbmdelnode->fPageRemoved );
		err = ErrERRCheck( wrnBMConflict );
		goto HandleError;
		}
				
	Assert( prmpage->dbid == pfucb->dbid );
	Assert( prmpage->pgnoFather == PcsrCurrent( pfucb )->pcsrPath->pgno );
	Assert( prmpage->itagFather == PcsrCurrent( pfucb )->pcsrPath->itagFather );
	Assert( prmpage->itagPgptr == PcsrCurrent( pfucb )->pcsrPath->itag );
	Assert( prmpage->ibSon == PcsrCurrent( pfucb )->pcsrPath->ibSon );

	/*	this call should not release critJet till the first call to SPFreeExt
	/*	by then, all the page pointers will be fixed [atomically]
	/**/
	err = ErrBMIRemovePage(
				pfucb,
				PcsrCurrent( pfucb )->pcsrPath,
				prmpage,
				fDoMove );
	Assert( err != wrnBMConflict );
	Call( err );
	pbmdelnode->fPageRemoved = 1;

HandleError:
	Assert( pbmdelnode->fLastNode );
	Assert( pbmdelnode->fPageRemoved || err == wrnBMConflict || err < 0 );

	if ( prmpage != prmpageNil )
		{
		BTReleaseRmpageBfs( fFalse, prmpage );
		SFree( prmpage );
		}
	
	return err;
}


#if 0
	// UNDONE: register pages pointed to by links in this page
	
VOID BMRegisterLinkPages( FUCB *pfucbT )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucb = pfucbNil;
	
	for ( )
		{
		
		MPLRegister( FCB *pfcbT, SSIB *pssib, PN pn, sridNull );
		}

HandleError:
	Assert( err >= 0 );
	if ( pfucb != pfucbNil )
		DIRClose( pfucb );
	return;
	}
#else
#define	BMRegisterLinkPages( pfucbT ) 0
#endif

	
/*	delete associated index entries,
/*	delete node
/*	retrieve page if it is empty
/**/
ERR	ErrBMDeleteNode( BMDELNODE *pbmdelnode, FUCB *pfucb )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	BOOL	fPageEmpty = fFalse;
	
	/*	goto bookmark and call ErrDIRGet to set correct ibSon
	/*	in CSR for node deletion.
	/**/
	DIRGotoBookmark( pfucb,
		SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
		PcsrCurrent( pfucb )->itag ) );
	err = ErrDIRGet( pfucb );
	if ( err != JET_errRecordDeleted )
		{
		Assert( err < 0 );
		return err;
		}

	Assert( !FNDVersion( *pssib->line.pb ) );

	/*	delete associated items
	/*	call low level delete to bypass version store and
	/*	expunge deleted node from page.
	/*	if last node to be deleted from page, remove page.
	/**/
	CallR( ErrDIRBeginTransaction( pfucb->ppib ) );
		
	if ( !pbmdelnode->fUndeletableNodeSeen )
		{
		pbmdelnode->fLastNode = FPMLastNode( &pfucb->ssib );
		pbmdelnode->fLastNodeWithLinks = FPMLastNodeWithLinks( &pfucb->ssib );
		}

	if ( pbmdelnode->fLastNodeWithLinks )
		{
		/*	delete node only after removing links
		/*	register the other pages and return conflict for now
		/**/
		BMRegisterLinkPages( &pfucb->ssib );
		wrn = ErrERRCheck( wrnBMConflict );
		goto HandleError;
		}
		
	fPageEmpty = pbmdelnode->fLastNode &&
		pbmdelnode->sridFather != sridNull &&
		pbmdelnode->sridFather != sridNullLink;

#ifdef OLC_DEBUG
	if( fOLCompact && pbmdelnode->fLastNode && !fPageEmpty )
 		{
 		/*	pages lost because of lack of sridFather
		/**/
 		Assert( fFalse );
 		}
#endif
 		
	if( fOLCompact && fPageEmpty )
		{
		/*	cache invisible page pointer
		/**/
		Assert( fOLCompact );
		AssertCriticalSection( critSplit );
		Assert( PcsrCurrent( pfucb )->pgno == PgnoOfPn( pbmdelnode->pn ) );
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
		Call( ErrBTGetInvisiblePagePtr( pfucb, pbmdelnode->sridFather ) );
		Assert( PcsrCurrent( pfucb )->pcsrPath != pcsrNil );
		}

	//	UNDONE:	improve performance by deleting whole subtree

	/*	if node is page pointer, then discontinue
	/*	clean up on page until this node is deleted
	/*	when the page it points to is deleted.
	/**/
	if ( PcsrCurrent( pfucb )->itagFather != itagFOP )
		{
		NDGet( pfucb, PcsrCurrent( pfucb )->itagFather );
		
		if ( FNDSon( *pfucb->ssib.line.pb ) &&
			FNDInvisibleSons( *pfucb->ssib.line.pb ) )
			{
			wrn = ErrERRCheck( wrnBMConflict );
			goto HandleError;
			}

		NDGet( pfucb, PcsrCurrent( pfucb )->itag );
		NDIGetBookmark( pfucb, &PcsrCurrent( pfucb)->bm );
		Assert( PgnoOfSrid( PcsrCurrent( pfucb )->bm ) != pgnoNull );
		}

	if ( !pbmdelnode->fLastNode )
		{
		if ( FNDMaxKeyInPage( pfucb ) )
			{
			pbmdelnode->fAttemptToDeleteMaxKey = 1;
			goto HandleError;
			}
	 	
 		/*	regular delete -- no fancy OLC stuff
 		/*	check for conflict again
 		/*	[somone else might have moved on to the node, when we lost critJet]
		/**/
	 	Assert( !FMPLLookupSridFather(
	 				SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,	
	 								PcsrCurrent( pfucb )->itag ),
	 				pfucb->dbid ) );
		Assert( FVERNoVersion( pfucb->dbid, SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
		   PcsrCurrent( pfucb )->itag ) ) );

		if ( FBMConflict( pfucb->ppib,
			pfucb->u.pfcb,
			pfucb->dbid,
			SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
				PcsrCurrent( pfucb )->itag ),
				PMPageTypeOfPage( pfucb->ssib.pbf->ppage ) ) ||
			!FVERNoVersion( pfucb->dbid,
				SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
				PcsrCurrent( pfucb )->itag ) ) )
			{
			wrn = ErrERRCheck( wrnBMConflict );
			goto HandleError;
			}
		
		Call( ErrNDDeleteNode( pfucb ) );

		AssertBMNoConflict( pfucb->ppib,
			pfucb->dbid,
			SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
			PcsrCurrent( pfucb )->itag ) );
		Assert( !FPMEmptyPage( pssib ) );
		pbmdelnode->fNodeDeleted = 1;
		}
	else if ( fOLCompact && fPageEmpty )
		{
		Assert( pbmdelnode->fLastNode );

		/*	remove page
		/**/
		Call( ErrBMRemovePage( pbmdelnode, pfucb ) );
		if ( err == wrnBMConflict )
			{
			wrn = err;
			}
		}
		
	Call( ErrDIRCommitTransaction( pfucb->ppib, JET_bitCommitLazyFlush ) );

	err = err < 0 ? err : wrn;
	Assert( !fPageEmpty ||
		!fOLCompact ||
		pbmdelnode->fPageRemoved ||
		err == wrnBMConflict );
	return err;

HandleError:
	CallS( ErrDIRRollback( pfucb->ppib ) );

	/*	error or warning must have occurred in order to get here
	/**/
	Assert( err < 0  ||
			wrn == wrnBMConflict ||
			pbmdelnode->fAttemptToDeleteMaxKey );

	err = err < 0 ? err : wrn;
	Assert( !fPageEmpty || !fOLCompact || pbmdelnode->fPageRemoved || err == wrnBMConflict || err < 0 );
	return err;
	}


LOCAL ERR ErrBMCleanPage(
	PIB 		*ppib,
	PN   		pn,
	SRID 		sridFather,
	FCB 		*pfcb,
	BMCF		*pbmcflags )
	{
	ERR  		err = JET_errSuccess;
	ERR  		wrn1 = JET_errSuccess;
	ERR			wrn2 = JET_errSuccess;
	FUCB		*pfucb;
	BF   		*pbfLatched;
	SSIB		*pssib;
	INT  		itag;
	INT  		itagMost;
	BOOL		fDeleteParents;
	RMPAGE		*prmpage = prmpageNil;
	BYTE		rgbKey[ JET_cbKeyMost ];
	KEY			keyMin;
	BOOL		fKeyAvail = fFalse;
//	ULONG		cPass = 0;
	BMDELNODE	bmdelnode;

	AssertCriticalSection( critSplit );
	Assert( !FFCBDeletePending( pfcb ) );

		//	initialize
		
	pbmcflags->fPageRemoved = fFalse;
	memset( (BYTE*) &bmdelnode, 0, sizeof( bmdelnode ) );
	bmdelnode.sridFather = sridFather;
	bmdelnode.pn = pn;
	
		//	open FUCB and access page to be cleaned.
	
	CallR( ErrDIROpen( ppib, pfcb, 0, &pfucb ) );
	pssib = &pfucb->ssib;
	PcsrCurrent( pfucb )->pgno = PgnoOfPn( pn );

		//	increment performance counter
	if ( !pbmcflags->fUrgent )
		{
		cOLCPagesProcessed++;
		}
	
		//	access page to free and remove buffer dependencies
	
	forever
		{
		CallJ( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ), FUCBClose );
		if ( pbmcflags->fUrgent )
			{
			break;
			}

#ifdef PAGE_MODIFIED
		Assert( pbmcflags->fUrgent || FPMPageModified( pssib->pbf->ppage ) );
#endif
		
		if ( pfcb->pgnoFDP != pssib->pbf->ppage->pgnoFDP )
			{
			err = JET_errSuccess;
			goto FUCBClose;
			}
		Assert( pfcb->pgnoFDP == pssib->pbf->ppage->pgnoFDP );

			//	if no dependencies, then break
		
		if ( pssib->pbf->cDepend == 0 )
			{
			break;
			}

			//	remove dependencies on buffer of page to be removed, to
			//	prevent buffer anomalies after buffer is reused.
		
		if ( ErrBFRemoveDependence( pfucb->ppib, pssib->pbf, fBFWait ) != JET_errSuccess )
			{
			wrn1 = ErrERRCheck( wrnBMConflict );
			goto FUCBClose;
			}
		}

		//	cache buffer since same cursor is used in RemovePage to get neighbor and parent pages

	pbfLatched = pssib->pbf;
	if ( FBFWriteLatchConflict( ppib, pbfLatched ) )
		{
		wrn1 = ErrERRCheck( wrnBMConflict );
		goto FUCBClose;
		}

	Assert( pbmcflags->fUrgent || pbfLatched->cDepend == 0 );

	/*	wait latch the page, so no one else can look at it
	/**/
	BFSetWaitLatch( pbfLatched, ppib );

		// get minimum key in this page to use later for dummy node insertion.
	
	keyMin.pb = rgbKey;
	fKeyAvail = FPMGetMinKey( pfucb, &keyMin );
	
		//	set itagMost to last tag on page for tag loops
	
	itagMost = ItagPMMost( pssib->pbf->ppage );

	/*	delete node trees from bottom up.  Loop once for each level
	/*	in deleted tree of nodes.
	/**/
	do
		{
#if 0
		if ( fDeleteParents && bmdelnode.fNodeDeleted )
			{
			/* reset pass count, since iteration was caused by
			/* deleted child
			/**/
			cPass = 0;
			}
			
		cPass++;
#endif
		fDeleteParents = fFalse;
		bmdelnode.fUndeletableNodeSeen = 0;
		bmdelnode.fNodeDeleted = 0;
		bmdelnode.fAttemptToDeleteMaxKey = 0;
		Assert( !bmdelnode.fLastNode );
		Assert( !bmdelnode.fPageRemoved );
		Assert( pbfLatched == pfucb->ssib.pbf );
		
		/*	for each tag in page check for deleted node.
		/**/
		for ( itag = 0; itag <= itagMost ; itag++ )
			{
			BOOL	fConflict = !pbmcflags->fTableClosed;

			Assert( !bmdelnode.fPageRemoved );
			PcsrCurrent( pfucb )->itag = (SHORT)itag;
			err = ErrPMGet( pssib, PcsrCurrent( pfucb )->itag );
			Assert( err == JET_errSuccess || err == errPMRecDeleted );

			if ( itag == itagFOP )
				{
					//	is page type internal or leaf-level?
					
				if ( FNDInvisibleSons( *pssib->line.pb ) )
					{
					bmdelnode.fInternalPage = 1;
					}
				else
					{
					Assert( bmdelnode.fInternalPage == 0 );
					}
				}

				//	CONSIDER: registering destination page in MPL
			if ( err != JET_errSuccess )
				continue;

#if 0
			/* check if there is any cursor open on this node
			/**/
			if ( !pbmcflags->fTableClosed )
				{
				fConflict = FBMConflict( ppib,
										 pfcb,
										 pfucb->dbid,
										 SridOfPgnoItag( PcsrCurrent( pfucb )->pgno, itag ),
										 PMPageTypeOfPage( pfucb->ssib.pbf->ppage ) );
				if ( fConflict )
					{
					/* some other user on this bm -- can't clean
					/* move on to next itag
					/**/
					Assert( !bmdelnode.fPageRemoved );
					wrn1 = ErrERRCheck( wrnBMConflict );
					continue;
					}
				}

			Assert( !fConflict );
#endif

			NDIGetBookmark( pfucb, &PcsrCurrent( pfucb )->bm );

			/*	first check if version bit is set, but no version remains
			/*	for node.
			/**/
			if ( FNDVersion( *pssib->line.pb ) ||
				FNDFirstItem( *pssib->line.pb ) )
				{
				if ( FVERNoVersion( pfucb->dbid, PcsrCurrent( pfucb )->bm ) )
					{
					/*	although this implmentation could be more efficient
					/*	by using lower level reset bit call, it occurs so
					/*	rarely, that this is not necessary.
					/**/
					NDResetNodeVersion( pfucb );
					}
				else
					{
					/*	versioned nodes cannot be cleaned.  Move to next itag.
					/**/
					bmdelnode.fVersionedNodeSeen = 1;
					wrn1 = ErrERRCheck( wrnBMConflict );
					continue;
					}
				}

			Assert( !FNDVersion( *pssib->line.pb ) );
			Assert( pbfLatched == pfucb->ssib.pbf );
			
			/*	if node has back link
			/*	and back link is not in sridFather list of PME's,
			/*	then fix indexes if necessary,
			/*	remove redirector and remove back link.
			/**/
			if ( FNDBackLink( *pssib->line.pb ) &&
				 ( !pbmcflags->fUrgent ||
				   FNDDeleted( *pssib->line.pb )  )
				)
				{
				Assert( PgnoOfSrid( PcsrCurrent( pfucb )->bm ) != pgnoNull );

				if ( PmpeMPLLookupSridFather( PcsrCurrent( pfucb )->bm,
					pfucb->dbid ) == NULL )
					{
					/*	we did not lose critJet from the time we checked for conflict
					/**/
					Call( ErrBMExpungeBacklink( pfucb, pbmcflags->fTableClosed, sridFather ) );
					if ( err == wrnBMConflict )
						wrn1 = err;
					Assert( pbfLatched == pfucb->ssib.pbf );
					}
#ifdef BMSTAT
				else
					{
					BMCannotExpunge( srid );
					}
#endif
				}

			Assert( PcsrCurrent( pfucb )->pgno == PgnoOfPn( pn ) );
			AssertNDGet( pfucb, itag );

			/*	if index page, do item cleanup
			/**/
			//	UNDONE: children of itagOwnext and itagAvailExt of the index should be excluded
#ifdef IDX_OLC
			if ( fOLCompact && itag != itagFOP && !FNDDeleted( *pssib->line.pb ) &&
				 ( PMPageTypeOfPage( pssib->pbf->ppage ) == pgtypIndexNC &&
				   !bmdelnode.fInternalPage ||
				   PMPageTypeOfPage( pssib->pbf->ppage ) == pgtypFDP &&
				   ( FNDFirstItem( *pssib->line.pb ) || FNDLastItem( *pssib->line.pb ) )
				 )
			   )
				{
					//	access every item,
					//	delete item if flagged deleted and no version and no conflict
					//	and not only item in node
					// CONSIDER: logging all delete items per node together
					
				ITEM	*pitem;
				ITEM	item;
				INT		citems;
				SRID	bmItemList;
				BOOL	fFirstItem = FNDFirstItem( *pssib->line.pb ) ? fTrue : fFalse;
				BOOL	fLastItem = FNDLastItem( *pssib->line.pb ) ? fTrue : fFalse;

				DIRGotoBookmark( pfucb,
					 SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
					 PcsrCurrent( pfucb )->itag ) );
				Assert( pfucb->u.pfcb->pgnoFDP != pgnoSystemRoot );
				if ( sridFather == sridNull )
					pfucb->sridFather = SridOfPgnoItag( pfucb->u.pfcb->pgnoFDP, itagDATA );
				else
					pfucb->sridFather = sridFather;
				Assert( pfucb->sridFather != sridNull );

				err = ErrDIRGet( pfucb );
				if ( err < 0 && err != JET_errRecordDeleted )
					{
					CallS( err );
					}

				Call( ErrDIRGetBMOfItemList( pfucb, &bmItemList ) );
				PcsrCurrent( pfucb )->bm = bmItemList;
				
				PcsrCurrent( pfucb )->isrid = 0;

				Call( ErrDIRBeginTransaction( pfucb->ppib ) );

				for ( ; ; PcsrCurrent( pfucb )->isrid++ )
					{
					NDGetNode( pfucb );
					Assert( pfucb->lineData.cb % sizeof( ITEM ) == 0 );
					Assert( pfucb->lineData.cb != 0 );
					citems = pfucb->lineData.cb / sizeof( ITEM );
					if ( PcsrCurrent( pfucb )->isrid + 1 > citems )
						break;

					pitem = (ITEM *) pfucb->lineData.pb + PcsrCurrent( pfucb )->isrid;
					item = *(ITEM UNALIGNED *) pitem;
					PcsrCurrent( pfucb )->item = BmNDOfItem( item );
						
					if ( !FNDItemDelete( item ) )
						continue;

					if ( FNDItemVersion( item ) )
						{
							//	check if any version corresponding to item
							
						if ( FVERItemVersion( pfucb->dbid, bmItemList, item ) )
							{
							wrn1 = ErrERRCheck( wrnBMConflict );
							continue;
							}

						PcsrCurrent( pfucb )->isrid = (SHORT)(pitem - (SRID *) pfucb->lineData.pb);
						NDResetItemVersion( pfucb );
						}

					if ( !pbmcflags->fTableClosed || pfucb->u.pfcb->pgnoFDP == pgnoSystemRoot )
						{
						fConflict = FBMConflict( ppib,
												 pfcb,
												 pfucb->dbid,
												 SridOfPgnoItag( PcsrCurrent( pfucb )->pgno, itag ),
												 PMPageTypeOfPage( pfucb->ssib.pbf->ppage ) );
						if ( fConflict )
							{
							/* some other user on this node -- can't clean
							/* move on to next itag
							/**/
							Assert( !bmdelnode.fPageRemoved );
							wrn1 = ErrERRCheck( wrnBMConflict );
							goto Rollback;
							}
						}
#ifdef DEBUG
					else
						{
						Assert( !FBMConflict( ppib,
											  pfcb,
											  pfucb->dbid,
											  SridOfPgnoItag( PcsrCurrent( pfucb )->pgno, itag ),
											  PMPageTypeOfPage( pfucb->ssib.pbf->ppage ) ) );
						}
#endif

					Assert( !FNDItemVersion( *(ITEM UNALIGNED *) pitem ) );
					if ( citems > 1 )
						{
							//	delete item
						Assert( !FBMConflict( ppib,
											  pfcb,
											  pfucb->dbid,
											  SridOfPgnoItag( PcsrCurrent( pfucb )->pgno, itag ),
											  PMPageTypeOfPage( pfucb->ssib.pbf->ppage ) ) );
											
						CallJ( err = ErrNDDeleteItem( pfucb ), Rollback );
						}
					else if ( !( fFirstItem ^ fLastItem ) )
						{
							//	only node in item list or internal node -- flag delete node
							//	node will be deleted later and page recvered if possible
							//	UNDONE: atomicity of this operation with delete-node

						Assert( !FBMConflict( ppib,
											  pfcb,
											  pfucb->dbid,
											  SridOfPgnoItag( PcsrCurrent( pfucb )->pgno, itag ),
											  PMPageTypeOfPage( pfucb->ssib.pbf->ppage ) ) );
						
						CallJ( ErrNDFlagDeleteNode( pfucb, fDIRNoVersion ), Rollback );
						break;
						}
					else
						{
						}
					}

				CallJ( ErrDIRCommitTransaction( pfucb->ppib, JET_bitCommitLazyFlush ), Rollback );
				
		
				if ( err < 0 )
					{
Rollback:
#ifdef OLC_DEBUG
//					Assert( fFalse );
#endif
					CallS( ErrDIRRollback( pfucb->ppib ) );
					}
					
				Call( err );
				}
#endif				

			/*	back links may not have been removable.  If no backlink
			/*	and node flagged deleted, then remove node.
			/**/
			if( !FNDBackLink( *pssib->line.pb ) )
				{
				/*	expunge deleted nodes.
				/**/
				if ( FNDDeleted( *pssib->line.pb ) )
					{
					if ( FNDSon( *pssib->line.pb ) )
						{
						/*	if it has visible sons, then the sons must
						/*	have been marked as deleted. Otherwise do
						/*	nothing, let on-line compact to free the pointed
						/*	page, and then clean up the node.
						/**/
						if ( FNDVisibleSons( *pssib->line.pb ) )
							fDeleteParents = fTrue;
						continue;
						}

						//	delete the node, its index items
						//	and the page if empty
					Assert( !FMPLLookupSridFather(
								SridOfPgnoItag( PgnoOfPn( pn ), itag ),
								pfucb->dbid ) );

					Call( ErrBMDeleteNode( &bmdelnode, pfucb ) );

					if ( err == wrnBMConflict )
						{
						wrn2 = ErrERRCheck( wrnBMConflict );
						goto HandleError;
						}

					if ( bmdelnode.fPageRemoved )
						{
						goto ResetModified;
						}
					}
				else
					{
					bmdelnode.fUndeletableNodeSeen |= itag != itagFOP;
					}
				}
			else
				{
				bmdelnode.fUndeletableNodeSeen |= itag != itagFOP;
				}
			}

		Assert( pbfLatched == pfucb->ssib.pbf );
		}
	while ( ( bmdelnode.fNodeDeleted &&
			  fDeleteParents ) &&
//			  ||
//			  bmdelnode.fAttemptToDeleteMaxKey &&
//			  cPass == 1 ) &&
			!bmdelnode.fLastNode &&
			!bmdelnode.fLastNodeWithLinks &&
			!bmdelnode.fPageRemoved );

	Assert( pfucb->ssib.pbf == pbfLatched );
	
	if ( !bmdelnode.fNodeDeleted && err != errPMRecDeleted )
		{
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
		}
	
	/* reset err [assumes successfully exit the loop]
	/**/
	Assert( err == JET_errSuccess ||
		err == errPMRecDeleted ||
		err == wrnBFNewIO ||
		err == wrnBMConflict );

#ifdef OLC_DEBUG
	Assert( err != wrnBMConflict ||
			wrn1 == wrnBMConflict ||
			wrn2 == wrnBMConflict );
#endif

	err = JET_errSuccess;

	if ( fOLCompact &&
		sridFather != sridNull &&
		sridFather != sridNullLink )
		{
			//	merge the page if possible
			
		if ( fKeyAvail )
			{
			FUCB 	*pfucbRight = pfucbNil;
			PGNO 	pgnoRight;

			/* get page next to current page
			/* if last page, no merge
			/**/
			PgnoNextFromPage( pssib, &pgnoRight );

			if ( pgnoRight != pgnoNull )
				{
				BOOL		fMerge;

				/* access right page, latch and perform merge, if possible
				/**/
				Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbRight ) );
				PcsrCurrent( pfucbRight )->pgno = pgnoRight;
				CallJ( ErrBFWriteAccessPage( pfucbRight, PcsrCurrent( pfucbRight )->pgno ), CloseFUCB );
				if ( FBFWriteLatchConflict( pfucbRight->ppib, pfucbRight->ssib.pbf ) )
					{
					Assert( !bmdelnode.fPageRemoved );
					wrn2 = ErrERRCheck( wrnBMConflict );
					goto CloseFUCB;
					}
				BFSetWaitLatch( pfucbRight->ssib.pbf, pfucbRight->ppib );

				BMMergeablePage( pfucb, pfucbRight, &fMerge );
				
				if ( fMerge )
					{
					Assert( FBFWriteLatch( pfucb->ppib, pssib->pbf ) );
					Assert( pssib->pbf->cDepend == 0 );
					if ( pssib->pbf->pbfDepend != pbfNil )
						{
						err = ErrBFRemoveDependence( pfucb->ppib, pssib->pbf, fBFWait );
						if ( err != JET_errSuccess )
							{
							wrn1 = ErrERRCheck( wrnBMConflict );
							goto UnlatchPage;
							}
						}
					CallJ( ErrBMMergePage( pfucb, pfucbRight, &keyMin, sridFather ), UnlatchPage );
					wrn2 = wrnBMConflict;
					Assert( err != wrnBMConflict || !bmdelnode.fPageRemoved );
					}
UnlatchPage:
				Assert( pfucbRight != pfucbNil );
				AssertBFWaitLatched( pfucbRight->ssib.pbf, pfucbRight->ppib );
				Assert( PgnoOfPn( pfucbRight->ssib.pbf->pn ) == pgnoRight );
				BFResetWaitLatch( pfucbRight->ssib.pbf, pfucbRight->ppib );
CloseFUCB:
				Assert( pfucbRight != pfucbNil );
				DIRClose( pfucbRight );
				Call( err );
				}
			}
			
		else
			{
				// perf-mon
			}
		}

//	UNDONE: move free page to latching function
	/*	after the page has been freed, we can make no assumptions
	/*	about the state of the page buffer.  Further the page
	/*	should be freed only when the page buffer has been returned
	/*	to an inactive state with no page latches.
	/**/
//	AssertBFDirty( pbfLatched );

ResetModified:
		// reset modified it in page

	if ( !pbmcflags->fUrgent &&
		 wrn1 != wrnBMConflict &&
		 wrn2 != wrnBMConflict &&
		 !bmdelnode.fAttemptToDeleteMaxKey )
		{
		//	reaccess page, since cursor might have been moved by OLC

		CallS( ErrBFWriteAccessPage( pfucb, PgnoOfPn( pn ) ) );
		Assert( pbfLatched == pfucb->ssib.pbf );

#ifdef PAGE_MODIFIED
		FCBSetOLCStatsChange( pfucb->u.pfcb );
		pfucb->u.pfcb->olc_data.cUnfixedMessyPage--;
		PMResetModified( &pfucb->ssib );
#endif
		}

HandleError:
	/* never leave an empty page
	/**/
	Assert( bmdelnode.fPageRemoved || !FPMEmptyPage( pssib ) );
	
	BFResetWaitLatch( pbfLatched, ppib );

FUCBClose:
	DIRClose( pfucb );
	Assert( !bmdelnode.fPageRemoved || wrn2 != wrnBMConflict );
	if ( err >= JET_errSuccess && !bmdelnode.fPageRemoved )
		err = wrn1 == wrnBMConflict ? wrn1 : wrn2;
	Assert( !( bmdelnode.fPageRemoved && err == wrnBMConflict ) );

	if ( bmdelnode.fAttemptToDeleteMaxKey && err != wrnBMConflict && err >= 0 )
		{
		err = errBMMaxKeyInPage;
		}

	pbmcflags->fPageRemoved = bmdelnode.fPageRemoved ? fTrue : fFalse;
#ifdef OLC_DEBUG
 	Assert( !bmdelnode.fLastNode ||
			bmdelnode.fPageRemoved ||
			err == wrnBMConflict );

	Assert( err >= 0 || err == errBMMaxKeyInPage );
#endif

		//	increment performance counter
	if ( err == wrnBMConflict && !pbmcflags->fUrgent )
		cOLCConflicts++;
		
	return err;
	}


ERR	ErrBMCleanBeforeSplit( PIB *ppibUser, FCB *pfcb, PN pn )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib;
	BOOL	fPIBNew = fFalse;
	DBID	dbid = DbidOfPn( pn );
	BMCF	bmcflags;

	
	/*	enter critBMClean and critRCEClean
	/**/
	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	EnterNestableCriticalSection( critRCEClean );
	LgEnterCriticalSection(critJet);

	/*	start a new session if not already a BMClean Session
	/**/
	if ( !FPIBBMClean( ppibUser ) )
		{
		ppib = ppibSyncOLC;
		PIBSetBMClean( ppib );
		fPIBNew = fTrue;
		err = ErrDBOpenDatabaseByDbid( ppib, dbid );
		if ( err < 0 )
			{
			err = wrnBMConflict;
			goto CloseSession;
			}
		}
	else
		{
		/*	CONSIDER: recursively cleaning up
		/**/
		Assert( ppibUser == ppibBMClean );
		ppib = ppibUser;
		goto HandleError;
		}
	
	Assert( ppib->level == 0 );

	if ( FFCBWriteLatch( pfcb->pfcbTable == pfcbNil ? pfcb : pfcb->pfcbTable, ppib ) )
		{
		err = wrnBMConflict;
		goto HandleError;
		}

	FCBSetReadLatch( pfcb->pfcbTable == pfcbNil ? pfcb : pfcb->pfcbTable );

	bmcflags.fTableClosed = fFalse;
	bmcflags.fUrgent = fTrue;
	
	err = ErrBMCleanPage(
			ppib,
			pn,
			sridNull,
			pfcb,
			&bmcflags );

	Assert( !bmcflags.fPageRemoved );
	FCBResetReadLatch( pfcb->pfcbTable == pfcbNil ? pfcb : pfcb->pfcbTable );

HandleError:
	if ( fPIBNew )
		{
		DBCloseDatabaseByDbid( ppib, dbid );
CloseSession:
		Assert( fPIBNew );
		PIBResetBMClean( ppib );
		}

	LeaveNestableCriticalSection( critRCEClean );
	LeaveNestableCriticalSection( critSplit );

	return err;
	}


ERR ErrBMClean( PIB *ppib )
	{
	ERR		err = JET_errSuccess;
	MPE		*pmpe;
	FCB		*pfcb;
	PN		pn;
	DBID	dbid;

	/*	if ppibBMClean == ppibNIL, we ran out of memory
	/**/
	if ( ppibBMClean == ppibNil )
		return ErrERRCheck( JET_errOutOfMemory );

	/*	enter critBMClean and critRCEClean
	/**/
	LgLeaveCriticalSection( critJet );
	LgEnterNestableCriticalSection( critBMClean );
	EnterNestableCriticalSection( critSplit );
	EnterNestableCriticalSection( critRCEClean );
	LgEnterNestableCriticalSection( critMPL );
	LgEnterCriticalSection(critJet);
	Assert( ppibBMClean->level == 0 );

	SgEnterCriticalSection( critMPL );
	pmpe = PmpeMPLGet();
	SgLeaveCriticalSection( critMPL );

	/*	if no more MPL entries, then return no idle activity.
	/**/
	if ( pmpe == pmpeNil )
		{
		err = ErrERRCheck( JET_wrnNoIdleActivity );
		goto HandleError;
		}

#ifdef FLAG_DISCARD
	/*	if MPE has been flagged for discard, then discard MPE now
	/**/
	if ( FMPEDiscard( pmpe ) )
		{
		MPLDiscard();
		goto HandleError;
		}
#endif

	pn = pmpe->pn;
	dbid = DbidOfPn( pmpe->pn );

	/*	open database for session.  If database has been detached then
	/*	open will fail.
	/**/
	err = ErrDBOpenDatabaseByDbid( ppib, dbid );
	if ( err < 0 )
		{
		MPLDiscard();
		goto HandleError;
		}

	SgEnterCriticalSection( critGlobalFCBList );
	pfcb = PfcbFCBGet( DbidOfPn( pmpe->pn ), pmpe->pgnoFDP );
	Assert( pfcb == pfcbNil || pfcb->pgnoFDP == pmpe->pgnoFDP );

	/*	find FCB for table.  If FCB not found then discard MPE.  If FCB
	/*	reference count is 0, or if no bookmarks have been retrieved,
	/*	then process MPE.  Also discard if database can no longer be
	/*	written, which may happen through detach and attach since
	/*	MPL is not flushed on Detach.
	/**/
	if ( pfcb == pfcbNil || FDBIDReadOnly( DbidOfPn( pmpe->pn ) ) )
		{
		MPLDiscard();
		SgLeaveCriticalSection( critGlobalFCBList );
		}
	else if ( pfcb->wRefCnt > 0 && !fOLCompact )
		{
		MPLDefer();
		SgLeaveCriticalSection( critGlobalFCBList );
		}
	else if ( FFCBWriteLatch( pfcb, ppib ) )
		{
		/*	if uncommitted create index or DDL or other BMClean is going
		/*	on, we must defer clean up on table, since case of write conflict
		/*	on index entry only, is not handled.
		/**/
		MPLDefer();
		SgLeaveCriticalSection( critGlobalFCBList );
		}
	else if ( FFCBDeletePending( pfcb ) )
		{
		/*	Also, discard if table is being deleted.
		/**/
		MPLDiscard();
		SgLeaveCriticalSection( critGlobalFCBList );
		}
	else
		{
		/* if there are no cursors on this FDP, then we can do compaction
		/* And we need to block out all openTables till we are done
		/**/
		BMCF bmcflags;
		FCB	 *pfcbIdx;

		bmcflags.fTableClosed = ( pfcb->wRefCnt <= 0 && !pmpe->fFlagIdx );
		bmcflags.fUrgent = fFalse;

		if ( bmcflags.fTableClosed )
			{
			SignalReset( sigDoneFCB );
			FCBSetWait( pfcb );
			}
		Assert( pfcb == PfcbFCBGet( DbidOfPn( pmpe->pn ), pmpe->pgnoFDP ) );
		Assert( pfcb != pfcbNil );
		Assert( !bmcflags.fTableClosed || FFCBWait( pfcb ) );
		SgLeaveCriticalSection( critGlobalFCBList );

		/* latch fcb to block index creation that might mess up expunge backlinks
		/**/
		Assert( !FFCBWriteLatch( pfcb, ppib ) );
		FCBSetReadLatch( pfcb );

		if ( pmpe->fFlagIdx )
			{
			for ( pfcbIdx = pfcb->pfcbNextIndex;
				  pfcbIdx != pfcbNil && pfcbIdx->pgnoFDP != pmpe->pgnoFDPIdx;
				  pfcbIdx = pfcbIdx->pfcbNextIndex )
				  {
				  }
			Assert( pfcbIdx != pfcbNil );
			}
		
		err = ErrBMCleanPage( ppib,
			pmpe->pn,
			pmpe->sridFather,
			pmpe->fFlagIdx ? pfcbIdx : pfcb,
			&bmcflags );

		Assert( !bmcflags.fTableClosed || FFCBWait( pfcb ) );
		Assert( !( bmcflags.fPageRemoved && err == wrnBMConflict ) );

		FCBResetReadLatch( pfcb );

		if ( !bmcflags.fPageRemoved )
			{
//			if ( err == wrnBMConflict || err == errBMMaxKeyInPage )
			if ( err == wrnBMConflict )
				{
				pmpe->cConflicts++;
				MPLDefer();
				}
			else
				{
#ifdef OLC_DEBUG
				Assert( err == 0 );
#endif
				Assert( pmpe == PmpeMPLGet( ) && pmpe->pn == pn);
				Assert( pfcb == PfcbFCBGet( DbidOfPn( pmpe->pn ), pmpe->pgnoFDP ) );
				MPLDiscard();
				}
			}
		else
			{
#ifdef OLC_DEBUG
			Assert( err == 0 );
			Assert( pmpe == PmpeMPLGet() );
#endif
			MPLDiscard();
			}

		Assert( pfcb != pfcbNil );
		if ( bmcflags.fTableClosed )
			{
			FCBResetWait( pfcb );
			SignalSend( sigDoneFCB );
			}
		}

	DBCloseDatabaseByDbid( ppib, dbid );

	/*	set success code
	/**/
	if ( err == errBMMaxKeyInPage )
		{
		err = wrnBMCleanNullOp;
		}
	else
		{
		err = JET_errSuccess;
		}

HandleError:
	LgLeaveNestableCriticalSection( critMPL );
	LeaveNestableCriticalSection( critRCEClean );
	LeaveNestableCriticalSection( critSplit );
	LgLeaveNestableCriticalSection( critBMClean );
	return err;
	}


/*	number of MPE to attempt to process per synchronous call of
/*	BMCleanProcess.
/**/
#define cmpeCleanMax			256
#define cmsecOLCWaitPeriod		( 60 * 1000 )

#ifdef DEBUG
DWORD dwBMThreadId;
#endif

TRX trxOldestLastSeen = trxMax;

LOCAL ULONG BMCleanProcess( VOID )
	{
	INT	cmpe;
	ERR	err;

#ifdef DEBUG
	dwBMThreadId = DwUtilGetCurrentThreadId();
#endif

	forever
		{
		SignalReset( sigBMCleanProcess );
		SignalWait( sigBMCleanProcess, cmsecOLCWaitPeriod );

		/*	the following is a fix for long transactions in DS
		/**/
		if ( trxOldestLastSeen == trxOldest &&
			trxOldest != trxMax )
			{
			continue;
			}
		trxOldestLastSeen = trxOldest;
		
		/*	assert also checks that both values are not 0
		/**/
		Assert( cmpeNormalPriorityMax > cmpeHighPriorityMin );
		if ( lBMCleanThreadPriority == lThreadPriorityNormal
			&& cMPLTotalEntries > cmpeNormalPriorityMax )
			{
			UtilSetThreadPriority( handleBMClean, lThreadPriorityHigh );
			lBMCleanThreadPriority = lThreadPriorityHigh;
			}
		else if ( lBMCleanThreadPriority == lThreadPriorityHigh
			&& cMPLTotalEntries < cmpeHighPriorityMin )
			{
			UtilSetThreadPriority( handleBMClean, lThreadPriorityNormal );
			lBMCleanThreadPriority = lThreadPriorityNormal;
			}

		if ( fEnableBMClean )
			{
			INT		cmpeClean = cmpeCleanMax > cMPLTotalEntries ?
									cMPLTotalEntries :
									cmpeCleanMax;
									
			LgEnterCriticalSection(critJet);
			for ( cmpe = 0; cmpe < cmpeClean; cmpe++ )
				{
				if ( fBMCleanTerm )
					{
					break;
					}
				err = ErrBMClean( ppibBMClean );
				if ( err == JET_wrnNoIdleActivity )
					break;
				}
			LgLeaveCriticalSection(critJet);
			}

		if ( fBMCleanTerm )
			break;
		}

	Assert( ppibBMClean != ppibNil && ppibBMClean->level == 0 );

	return 0;

	}


#ifdef DEBUG
VOID AssertBMNoConflict( PIB *ppib, DBID dbid, SRID bm )
	{
	PIB		*ppibT;

	Assert( BmNDOfItem( bm ) == bm );

	for ( ppibT = ppibGlobal; ppibT != ppibNil; ppibT = ppibT->ppibNext )
		{
		FUCB	*pfucb = ppibT->pfucb;

		for ( ; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
			{
			CSR *pcsr = PcsrCurrent( pfucb );

			Assert( pfucb->ppib == ppibT );
			if ( pfucb->dbid != dbid )
				continue;

			if ( ppibT == ppib )
				{
//				Assert( ppib == ppibBMClean );
				continue;
				}

			Assert( pfucb->bmStore != bm );
			Assert( pfucb->itemStore != bm );
			Assert( pfucb->sridFather != bm );
			for ( ; pcsr != pcsrNil; pcsr = pcsr->pcsrPath )
				{
				Assert( pcsr->bm != bm );
				Assert( pcsr->bmRefresh != bm );
				Assert( BmNDOfItem( pcsr->item ) != bm );
				Assert( pcsr->item != bm );
				Assert( SridOfPgnoItag( pcsr->pgno, pcsr->itag ) != bm );
				Assert( pcsr->itagFather == 0 || pcsr->itagFather == itagNull ||
						SridOfPgnoItag( pcsr->pgno, pcsr->itagFather ) != bm );
				}
			}
		}
	}


VOID AssertNotInMPL( DBID dbid, PGNO pgnoFirst, PGNO pgnoLast )
	{
	PN		pn = PnOfDbidPgno( dbid, pgnoFirst );
#ifdef FLAG_DISCARD
	MPE		*pmpe;
#endif

	for( ; pn <= PnOfDbidPgno( dbid, pgnoLast ); pn++ )
		{
		ULONG	itag;
		for ( itag = 0; itag < cbSonMax; itag++ )
			{
			Assert( !FMPLLookupSridFather(
						SridOfPgnoItag( PgnoOfPn( pn ), itag ),
						dbid ) );
			}
#ifdef FLAG_DISCARD
		pmpe = PmpeMPLLookupPN( pn );
		Assert( pmpe == NULL || FMPEDiscard( pmpe ) );
		pmpe = PmpeMPLLookupPgnoFDP( PgnoOfPn( pn ), dbid );
		Assert( pmpe == NULL || FMPEDiscard( pmpe ) );
#else
		Assert( PmpeMPLLookupPN( pn ) == NULL );
		Assert( PmpeMPLLookupPgnoFDP( PgnoOfPn( pn ), dbid ) == NULL );
#endif
		}
	}


VOID AssertMPLPurgeFDP( DBID dbid, PGNO pgnoFDP )
	{
#ifdef FLAG_DISCARD
	MPE		*pmpe;
	pmpe = PmpeMPLLookupPgnoFDP( pgnoFDP, dbid );
	Assert( pmpe == NULL || FMPEDiscard( pmpe ) );
#else
	Assert( PmpeMPLLookupPgnoFDP( pgnoFDP, dbid ) == NULL );
#endif
	}
#endif





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\btsplit.c ===
#include "daestd.h"

#include <ctype.h>
#include <io.h>
#include <stdarg.h>

#define memcpy memmove

DeclAssertFile;					/* Declare file name for assert macros */

#ifdef DEBUG
//#define	DEBUGGING	1
#endif

CRIT  critSplit;
static	INT		itagVSplit;
static	INT		cbVSplit;
static	INT		clineVSplit;
static	INT		clineVSplitTotal;


	/*  monitoring statistics  */

unsigned long cBTSplits = 0;

PM_CEF_PROC LBTSplitsCEFLPpv;

long LBTSplitsCEFLPpv(long iInstance,void *pvBuf)
	{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBTSplits;
		
	return 0;
	}

unsigned long cBTAppends = 0;

PM_CEF_PROC LBTAppendsCEFLPpv;

long LBTAppendsCEFLPpv(long iInstance,void *pvBuf)
	{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cBTAppends;
		
	return 0;
	}

/*	split trace enable flag
/**/
#ifdef DEBUG
//#define SPLIT_TRACE
#endif

/*	size of space extent =
/*	4 for tag
/*	1 for son in father's son table
/*	1 for node header
/*	1 for key length
/*	3 for key
/*	3 for data
/*	17 for luck ( fudge factor for future node expansion )
/**/
#define cbSPExt	30

#ifdef DEBUG
static INT iSplit = 0;
static INT cbfEmpty = 0;
#endif

/*	split global comments
/*
/*	split physically logs split and new pages.  Operations on split
/*	and new pages must be below storeage API, as logging is performed
/*	at storage API.  Operations on non-split non-new pages must be at
/*	or above storage API to ensure logging occurs.
/**/
LOCAL ERR ErrBTSelectSplit( FUCB *pfucb, CSR *pcsr, SSIB *pssib, KEY key, INT cbNode, INT cbReq, BOOL fAppendPage, BOOL fDIRFlags, SPLIT *psplit, BOOL *pfAppend );
LOCAL ERR ErrBTMoveNode( SPLIT *psplit, FUCB *pfucb, FUCB *pfucbNew, INT itagNode, BYTE *rgbSonNew, BOOL fVisibleNode, BOOL fNoMove, BKLNK *pbklnk, INT cbklnk );
LOCAL ULONG UsBTWeight( FUCB *pfucb, INT itag );
LOCAL VOID BTVSplit( FUCB *pfucb, INT itag, INT cbReq, BOOL fSummingUp );
LOCAL VOID BTIVSplit( FUCB *pfucb, INT itag, INT cbReq, INT *pcb, INT *pclineTotal, BOOL fSummingUp );
LOCAL VOID BTDoubleVSplit( FUCB *pfucb, INT itagSplit, INT cbReq, INT cbTotal, INT *pibSon, KEY *pkey );
LOCAL VOID BTHSplit( FUCB *pfucb, INT cbReq, BOOL fAppendPage, BOOL fReplace, BOOL fDIRFlags, INT *pibSon, KEY *pkeyMac, KEY *pkeySplit, BOOL *pfRight, BOOL *pfAppend, SPLIT *psplit);
LOCAL ERR ErrBTSetIntermediatePage( FUCB *pfucb, SPLIT *psplit, BYTE *rgb );

#if 0
LOCAL VOID BTCheckPage( BF *pbf )
	{
	SSIB	ssib;
	INT		itag;
	INT		cbSon = 0;
	INT		ctag = 0;

	ssib.pbf = pbf;

	for ( itag = 0; itag <= ItagPMMost( pbf->ppage ); itag++ )
		{
		if ( TsPMTagstatus( pbf->ppage, itag ) == tsLine )
			{
			ctag++;
			PMGet( &ssib, itag );
			if ( ( itag == itagFOP && FNDSon( *(ssib.line.pb) ) ) ||
				FNDNonIntrinsicSons( ssib.line.pb ) )
				{
				cbSon += *(BYTE *)(PbNDSonTable( ssib.line.pb ));
				}
			}
		}

	/*	one tag has no parent, FOP, so number of sons + 1 == number
	/*	of tags.
	/**/
	Assert( cbSon + 1 == ctag );

	return;
	}
#endif


#ifdef DEBUGGING
/*	pcsr must hold pgno of page to be checked
/**/
VOID BTCheckSplit( FUCB *pfucb, CSR *pcsr )
	{
	ERR		err;
	PGNO	pgnoSav = PgnoOfPn( pfucb->ssib.pbf->pn );
	SSIB	*pssib = &pfucb->ssib;
	/*	pgno cannot change since this routine is only called within
	/*	split MUTEX
	/**/
	PGNO	pgno = pcsr->pgno;
	PGNO	pgnoCurrent;
	KEY		keyParent;
	BYTE	rgb[JET_cbKeyMost];
	PGNO	pgnoPrev;
	KEY		keyPrev;
	BYTE	rgbPrev[JET_cbKeyMost];
	BYTE	rgitag[cbSonMax];
	INT		ibSonMax;
	INT		ibSon;
	char	*pb;

	/*	check parent page
	/**/
	err = ErrBFReadAccessPage( pfucb, pcsr->pgno );
	Assert( err == JET_errSuccess || err == wrnBFNewIO || err == wrnBFCacheMiss );
	NDGet( pfucb, itagFOP );
	NDCheckPage( pssib );

	/*	initialize variables
	/**/
	keyParent.pb = rgb;
	keyParent.cb = 0;
	pgnoPrev = pgnoNull;
	keyPrev.pb = rgbPrev;
	keyPrev.cb = 0;

	/*	if father is intrinsic page pointer
	/*	then return.
	/**/
	if ( pcsr->itagFather == itagNull )
		goto Done;

	/*	get son table of parent node
	/**/
	err = ErrBFReadAccessPage( pfucb, pcsr->pgno );
	Assert( err == JET_errSuccess || err == wrnBFNewIO || err == wrnBFCacheMiss );

	NDGet( pfucb, itagFOP );
	Assert( pssib == &pfucb->ssib );
	NDCheckPage( pssib );

	pssib->itag = pcsr->itagFather;
	PMGet( pssib, pssib->itag );
	Assert( pssib == &pfucb->ssib );
	Assert( !FNDNullSon( *pssib->line.pb ) );

	/*	may be multiple level visible tree, and not valid for check
	/**/
	if ( FNDVisibleSons( *pssib->line.pb ) )
		goto Done;

	/*	copy all son itags to rgitag
	/**/
	ibSonMax = CbNDSon( pssib->line.pb );
	pb = PbNDSon( pssib->line.pb );
	memcpy( rgitag, pb, ibSonMax );

	for ( ibSon = 0; ibSon < ibSonMax - 1; ibSon++ )
		{
		/*	for each invisible son, cache key and go to page pointed
		/*	to and assert that greatest key in page pointed to is
		/*	less than page pointer node key.
		/**/
		pssib->itag = rgitag[ibSon];
		PMGet( pssib, pssib->itag );

		if ( ibSon > 0 )
			{
			Assert( CmpStKey( StNDKey( pssib->line.pb ), &keyParent ) >= 0 );
			}
		keyParent.cb = CbNDKey( pssib->line.pb );
		memcpy( keyParent.pb, PbNDKey( pssib->line.pb ), keyParent.cb );

		pgnoCurrent = *(PGNO UNALIGNED *)PbNDData( pssib->line.pb );
		/*	assert data is page
		/**/
		Assert( CbNDData( pssib->line.pb, pssib->line.cb ) == sizeof(PGNO) );

		/*	check previous page link
		/**/
		if ( pgnoPrev != pgnoNull )
			{
			PGNO	pgnoT;

			err = ErrBFReadAccessPage( pfucb, pgnoCurrent );
			Assert( err == JET_errSuccess || err == wrnBFNewIO || err == wrnBFCacheMiss );
			LFromThreeBytes( &pgnoT, &pssib->pbf->ppage->pgnoPrev );
			Assert( pgnoPrev == pgnoT );
			err = ErrBFReadAccessPage( pfucb, pgnoPrev );
			Assert( err == JET_errSuccess || err == wrnBFNewIO || err == wrnBFCacheMiss );
			LFromThreeBytes( &pgnoT, &pssib->pbf->ppage->pgnoNext );
			Assert( pgnoCurrent == pgnoT );
			}
		pgnoPrev = pgnoCurrent;

		/*	access current page
		/**/
		err = ErrBFReadAccessPage( pfucb, pgnoCurrent );
		Assert( err == JET_errSuccess || err == wrnBFNewIO || err == wrnBFCacheMiss );

		pssib->itag = 0;
		PMGet( pssib, pssib->itag );
		if ( FNDSon( *pssib->line.pb ) )
			{
			NDGet( pfucb, itagFOP );
			Assert( pssib == &pfucb->ssib );
			NDCheckPage( pssib );

			/*	assert keyPrev less than or equal to least key on page
			/**/
			pssib->itag = 0;
			PMGet( pssib, pssib->itag );
			pssib->itag = *( PbNDSon( pssib->line.pb ) );
			PMGet( pssib, pssib->itag );
			Assert( CmpStKey( StNDKey( pssib->line.pb ), &keyPrev ) >= 0 );

			/*	assert key greater tahn or equal to greatest key on page.
			/**/
			pssib->itag = 0;
			PMGet( pssib, pssib->itag );
			pssib->itag = *( PbNDSon( pssib->line.pb ) + CbNDSon( pssib->line.pb ) - 1 );
			PMGet( pssib, pssib->itag );
			Assert( CmpStKey( StNDKey( pssib->line.pb ), &keyParent ) <= 0 );

			/*	make key into keyPrev for next iteration
			/**/
			keyPrev.cb = CbNDKey( pssib->line.pb );
			memcpy( keyPrev.pb, PbNDKey( pssib->line.pb ), keyPrev.cb );
			}

		/*	prepare for next page pointer check
		/**/
		err = ErrBFReadAccessPage( pfucb, pgno );
		Assert( err == JET_errSuccess || err == wrnBFNewIO || err == wrnBFCacheMiss );
		}

	Assert( ibSon == ibSonMax - 1 );

	PgnoNextFromPage( pssib, &pgno );
	if ( pgno == pgnoNull && ibSonMax > 1 )
		{
		/*	key of last page pointer must be Null
		/**/
		pssib->itag = rgitag[ibSon];
		PMGet( pssib, pssib->itag );
		Assert( CbNDKey( pssib->line.pb ) == 0 );
		}

Done:
	/*	restore page currency
	/**/
	err = ErrBFReadAccessPage( pfucb, pgnoSav );
	Assert( err == JET_errSuccess || err == wrnBFNewIO || err == wrnBFCacheMiss );
	return;
	}
#else /* !DEBUGGING */
	#define	BTCheckSplit( pfucb, pcsr )
#endif /* DEBUGGING */


INLINE LOCAL VOID BTIStoreLeafSplitKey( SPLIT *psplit, SSIB *pssib )
	{
//	LFINFO *plfinfo = &psplit->lfinfo;

	Assert( FBFWriteLatch( psplit->ppib, pssib->pbf ) );
//	plfinfo->pn = pssib->pbf->pn;
//	plfinfo->ulDBTime = pssib->pbf->ppage->ulDBTime;
	}


ERR ErrBTRefresh( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );

	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatBeforeCurNode:
		case csrstatAfterCurNode:
		case csrstatOnFDPNode:
		  	Call( ErrBTGotoBookmark( pfucb, PcsrCurrent( pfucb )->bm ) );
			break;
		default:
			{
			Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnDataRoot );
			Assert( PcsrCurrent( pfucb )->itagFather == itagNull );
			PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
			while( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
				{
				Call( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
				PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
				}
			PcsrCurrent( pfucb )->itag = ItagRootOfPfucb( pfucb );
			NDGet( pfucb, PcsrCurrent( pfucb )->itag );
			}
		}

HandleError:
	return err;
	}

	
/*	split is used to make more space available for insert or replace
/*	enlargment operations.  Parent currency must be visible father.
/**/
ERR ErrBTSplit( FUCB *pfucb, INT cbNode, INT cbReq, KEY *pkey, INT fDIRFlags )
	{
	ERR		err = JET_errSuccess;
	SSIB   	*pssib = &pfucb->ssib;
	CSR		*pcsrT;
	CSR   	**ppcsr = &PcsrCurrent( pfucb );
	CSR		*pcsrRoot = pcsrNil;
	CSR		*pcsrLongId;
	INT		citag;
	INT		cbSon;

	/*	store currency for split path construction
	/**/
	BYTE  	rgb[JET_cbKeyMost];
	KEY		key;
	SRID  	bm;
	PGNO  	pgno;
	INT		itag;
	SRID  	item;
	QWORD 	qwDBTime;

	BOOL  	fAppend;
	BOOL  	fInPageParent = fFalse;
	BOOL  	fOutPageParent = fFalse;
	BOOL  	fTwoLevelSplit = fFalse;

	BF		*pbfSplit = pbfNil;

#ifdef DEBUG
	PGNO  	pgnoT;
	INT		itagT;
	INT		csplit = 0;
#define csplitMax		15
#endif	/* DEBUG */

	Assert( pfucb->pbfEmpty == pbfNil );

	/*	store currency, and request split MUTEX, and refresh currency
	/*	in case split occurred on same page will jet MUTEX
	/*	was given up.  We must request split MUTEX to maintain
	/*	validity of invisible CSR stack.  Also, we must store and
	/*	refresh so that the pgno itag retrieved from currency will
	/*	exist when seek looks for them.
	/**/
	if ( fDIRFlags & fDIRReplace )
		{
		NDGetBookmark( pfucb, &PcsrCurrent( pfucb )->bmRefresh );
		}

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection( critJet );

	if ( fDIRFlags & fDIRReplace )
		{
		Call( ErrBTGotoBookmark( pfucb, PcsrCurrent( pfucb )->bmRefresh ) );
		}

	/*	no more use for bmRefresh
	/**/
	PcsrCurrent( pfucb )->bmRefresh = sridNull;
	
	/*	We would expect to set citag to 0 if replace and to 1 if insert,
	/*	however, citag is set to 1 to cover case of item list split
	/*	which is called as fDIRReplace
	/**/
	citag = 1;

	if ( PcsrCurrent( pfucb )->csrstat != csrstatOnFDPNode )
		{
		/*	get key, pgno and itag for subsequent seek for update
		/**/
		bm = (*ppcsr)->bm;
		item = (*ppcsr)->item;
		qwDBTime = (*ppcsr)->qwDBTime;

		if ( fDIRFlags & fDIRReplace )
			{
			/*	in the case of replace item list, the current node has
			/*	not been cached.
			/**/
			pgno = (*ppcsr)->pgno;
			itag = (*ppcsr)->itag;
			key.pb = rgb;
			Assert( pgno == PcsrCurrent( pfucb )->pgno );
			if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
				{
				Call( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
				}
			NDGet( pfucb, (*ppcsr)->itag );
			key.cb = CbNDKey( pssib->line.pb );
			Assert( sizeof(rgb) >= key.cb );
			memcpy( rgb, PbNDKey( pssib->line.pb ), key.cb );
			pkey = &key;
			}
		else
			{
			pgno = pgnoNull;
			itag = itagNil;
			key = *pkey;
			}

		/*	move to parent and remember parent CSR as root.
		/*	cache pgno, itag for subsequent seek for update.
		/**/
#ifdef DEBUG
		pgnoT = pfucb->pcsr->pgno;
		itagT = pfucb->pcsr->itag;
#endif

		/*	if leaf page is NOT FDP and visible parent in same page,
		/*	then handle as two level.  This allows split to H-Split any
		/*	page.  FDP page is excluded both because it cannot be H-Split
		/*	and because it typically has multiple visible levels.  This
		/*	code only handles two visible levels below the FOP.
		/**/
		Assert( PcsrCurrent( pfucb ) != pcsrNil );
		pcsrT = PcsrCurrent( pfucb )->pcsrPath;
		fInPageParent = fFalse;

		if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
			{
			Call( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
			}
		NDGet( pfucb, itagFOP );
		cbSon = CbNDSon( pfucb->ssib.line.pb );
		if ( cbSon > 1 )
			{
			if ( pcsrT != pcsrNil && PcsrCurrent( pfucb )->pgno != PgnoFDPOfPfucb( pfucb ) )
				{
				while ( pcsrT->pgno == PcsrCurrent( pfucb )->pgno )
					{
					if ( !FCSRInvisible( pcsrT ) )
						{
						fInPageParent = fTrue;
						/*	we currently only support a two level, and not an n-level in
						/*	page tree.
						/**/
						Assert( pcsrT->itagFather == itagFOP ||
							pcsrT->itagFather == itagNull );
						break;
						}
					}

				if ( fInPageParent )
					{
					/*	go to CSR above page
					/**/
					while ( pcsrT != pcsrNil &&
						pcsrT->pgno == PcsrCurrent( pfucb )->pgno )
						{
						pcsrT = pcsrT->pcsrPath;
						}

					/*	now look for visible parent above the page
					/**/
					while ( pcsrT != pcsrNil )
						{
						if ( !FCSRInvisible( pcsrT ) )
							{
							fOutPageParent = fTrue;
							Assert( pcsrT->itagFather == itagFOP ||
								pcsrT->itagFather == itagNull );
							break;
							}
						}

					fTwoLevelSplit = fInPageParent && fOutPageParent;
					}
				}
			}

		if ( fTwoLevelSplit )
			{
			ULONG	ulLongId;
			KEY		keyLongId;
			SRID	bmLong;
			PGNO	pgnoLong;
			INT		itagLong;
			SRID	itemLong;
			QWORD	qwDBTimeLong;

			/*  go to LongID
			/**/
			FUCBStore( pfucb );
			BTUp( pfucb );
			Assert ( PcsrCurrent( pfucb )->itag != itagNil);
			Call( ErrBTRefresh( pfucb ) );
			Call( ErrBTGet( pfucb, pfucb->pcsr ) );
			Assert( CbNDKey( pfucb->ssib.line.pb ) == sizeof(ULONG) );

			ulLongId = *(ULONG UNALIGNED *)PbNDKey(pfucb->ssib.line.pb);

			/*  go to LONG
			/**/
			bmLong = PcsrCurrent( pfucb )->bm;
			pgnoLong = PcsrCurrent( pfucb )->pgno;
			itagLong = PcsrCurrent( pfucb )->itag;
			itemLong = PcsrCurrent( pfucb )->item;
			qwDBTimeLong = PcsrCurrent( pfucb )->qwDBTime;

			BTUp( pfucb );
			pcsrRoot = PcsrCurrent( pfucb );
			Call( ErrBTRefresh( pfucb ) );
			Assert( PcsrCurrent( pfucb ) == pcsrRoot );
			Assert( PcsrCurrent( pfucb )->itag != itagNil );

			/*	seek to LongID
			/**/
			keyLongId.pb = (BYTE *)&ulLongId;
			keyLongId.cb = sizeof( ULONG );

			/*	must be replace so as to seek exact
			/**/
			if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
				{
				Call( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
				}

			FUCBSetFull( pfucb );
			err = ErrBTSeekForUpdate( pfucb, &keyLongId, pgnoLong, itagLong, fDIRFlags | fDIRDuplicate | fDIRReplace ) ;
			Assert ( err >= 0 );
			pcsrLongId = PcsrCurrent( pfucb );

			/*	preserve currency of Long.
			/**/
			PcsrCurrent( pfucb )->bm = bmLong;
			Assert( PcsrCurrent( pfucb )->pgno == pgnoLong );
			Assert( PcsrCurrent( pfucb )->itag == itagLong );
			PcsrCurrent( pfucb )->item = itemLong;
			PcsrCurrent( pfucb )->qwDBTime = qwDBTimeLong;
			}
		else
			{
			FUCBStore( pfucb );
			BTUp( pfucb );
			pcsrRoot = PcsrCurrent( pfucb );
			if ( PcsrCurrent( pfucb ) != pcsrNil )
				{
				Call( ErrBTRefresh( pfucb ) );
				Assert( PcsrCurrent( pfucb ) == pcsrRoot );
				}
			}

		/*	inserting cursors, are already located on the root node.  Replace
		/*	cursors must be moved to their visible fathers prior to split.
		/*	Note that visible father is father of node in keep.
		/**/
		if ( PcsrCurrent( pfucb ) == pcsrNil )
			{
			Assert( FFUCBIndex( pfucb ) );
			Assert( fDIRFlags & fDIRReplace );
			Call( ErrFUCBNewCSR( pfucb ) );

			/*	goto DATA root
			/**/
			PcsrCurrent( pfucb )->csrstat = csrstatOnDataRoot;
			Assert( pfucb->u.pfcb->pgnoFDP != pgnoSystemRoot );
			PcsrCurrent( pfucb )->bm = SridOfPgnoItag( pfucb->u.pfcb->pgnoFDP, itagDATA );
			PcsrCurrent( pfucb )->itagFather = itagNull;
			PcsrCurrent( pfucb )->pgno = PgnoRootOfPfucb( pfucb );
			if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
				{
				Call( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
				}

			Assert( PcsrCurrent( pfucb )->pgno == PgnoRootOfPfucb( pfucb ) );
			PcsrCurrent( pfucb )->itag = ItagRootOfPfucb( pfucb );
			}

		/*	currency must be on visible father before calling seek for update.
		/**/
		if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
			{
			Call( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
			}
		
		FUCBSetFull( pfucb );
		err = ErrBTSeekForUpdate( pfucb, pkey, pgno, itag, fDIRFlags | fDIRDuplicate );
		if ( err < 0 )
			{
			FUCBRestore( pfucb );
			goto HandleError;
			}

		/*	preserve currency
		/**/
		(*ppcsr)->bm = bm;
		(*ppcsr)->item = item;
		(*ppcsr)->qwDBTime = qwDBTime;

		Assert( !(fDIRFlags & fDIRReplace) || (*ppcsr)->csrstat == csrstatOnCurNode );
		Assert( !(fDIRFlags & fDIRReplace) || (*ppcsr)->pgno == pgno && (*ppcsr)->itag == itag );
		}

	/*	split page as necessary to make requested space available.  Note that
	/*	page may already have been split by another user inserting/enlarging
	/*	on same page.
	/**/

	forever
		{
		/*	write latch current page for split, and return not synchronous if
		/*	write latch contention.
		/**/
		if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
			{
			pfucb->ppib->cLatchConflict++;
		
			CallJ( ErrERRCheck( errDIRNotSynchronous ), RestoreCurrency );
			}

		if ( pbfSplit != pbfNil )
			{
			BFResetWriteLatch( pbfSplit, pfucb->ppib );
			}

		pbfSplit = pfucb->ssib.pbf;
		BFSetWriteLatch( pbfSplit, pfucb->ppib );
		
		fAppend = ( !( fDIRFlags & fDIRReplace )  &&
				FBTAppendPage( pfucb, *ppcsr, cbReq, 0, CbFreeDensity( pfucb ), citag ) );
		if ( !fAppend  &&  !FBTSplit( pssib, cbReq, citag ) )
			{
			// Get out when there's no more need to append or split.
			break;
			}

		pfucb->ppib->cSplitRetry++;

		CallJ( ErrBTSplitPage(
			pfucb,
			*ppcsr,
			pcsrRoot,
			key,
			cbNode,
			cbReq,
			fDIRFlags,
			fAppend ), RestoreCurrency );

		/*	must access current page so that while macros can
		/*	check page for available space.
		/**/
		if ( !FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
			{
			CallJ( ErrBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ), RestoreCurrency );
			}
		
		Assert( ++csplit < csplitMax );
		}

RestoreCurrency:
	if ( PcsrCurrent( pfucb )->csrstat != csrstatOnFDPNode )
		{
		/*	if error occurred then refresh currency to that at function
		/*	start, else remove invisible CSR stack and former current
		/*	CSR, leaving new currency as current.
		/**/
		if ( fTwoLevelSplit )
			{
			FUCBFreePath( &(*ppcsr)->pcsrPath, pcsrLongId );
			FUCBFreePath( &pcsrLongId->pcsrPath, pcsrRoot );
			}
		else
			{
			FUCBFreePath( &(*ppcsr)->pcsrPath, pcsrRoot );
			}

		FUCBRemoveInvisible( ppcsr );
		}

HandleError:
	if ( pbfSplit != pbfNil )
		BFResetWriteLatch( pbfSplit, pfucb->ppib );

	/*	reset full flag
	/**/
	FUCBResetFull( pfucb );

	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	if ( PcsrCurrent( pfucb )->csrstat != csrstatAfterLast  &&
		PcsrCurrent( pfucb )->csrstat != csrstatBeforeFirst )
		{
		DIRSetRefresh( pfucb );		// Ensure csr is resync'd with ssib
		}

	LeaveNestableCriticalSection( critSplit );

	//	UNDONE:	find a better way to MUTEX.  Can per domain
	//			MUTEX solve this deadlock problem when waiters
	//			hold critJet and are waiting for write latch
	//			holders waiting for critSplit.  If we
	//			critJet on domain basis then this problem
	//			should be avoided.
	/*	not sychronous to JET_errSuccess.  May have contended
	/*	on page lock so yeild to other waiter to avoid
	/*	future contension.
	/**/
	if ( err == errDIRNotSynchronous )
		{
		err = JET_errSuccess;
		BFSleep( cmsecWaitWriteLatch );
		}

	return err;
	}


ERR ErrBTSetUpSplitPages( FUCB *pfucb, FUCB *pfucbNew, FUCB *pfucbNew2, FUCB *pfucbNew3, SPLIT *psplit, PGTYP pgtyp, BOOL fAppend, BOOL fSkipMove )
	{
	ERR		err;
	BOOL 	fDoubleVertical = ( psplit->splitt == splittDoubleVertical );
	SSIB 	*pssib  = &pfucb->ssib;
	SSIB 	*pssibNew  = &pfucbNew->ssib;
	SSIB 	*pssibNew2;
	SSIB 	*pssibNew3;
	QWORD	qwDBTimeT;

	AssertFBFReadAccessPage( pfucb, psplit->pgnoSplit );

	/*	make sure no updates occur while we leave critJet
	 */
	qwDBTimeT = QwPMDBTime( pfucb->ssib.pbf->ppage );

AccessPage:
	if ( !( FBFWriteAccessPage( pfucb, psplit->pgnoSplit ) ) )
		{
		CallR( ErrBFWriteAccessPage( pfucb, psplit->pgnoSplit ) );
		}

CheckDependencyChain:
	if ( FBFCheckDependencyChain( pssib->pbf ) )
		{
		/* check if buffer stays the same */
		if ( pssib->pbf->pn == PnOfDbidPgno( pfucb->dbid, psplit->pgnoSplit ) )
			goto CheckDependencyChain;
		else
			goto AccessPage;
		}

	/*	Access and latch new page now.
	 */
	if ( fDoubleVertical )
		{
		pssibNew2  = &pfucbNew2->ssib;
		pssibNew3  = &pfucbNew3->ssib;
		}

	PcsrCurrent( pfucbNew )->pgno = psplit->pgnoNew;
	Assert( PcsrCurrent( pfucbNew )->pgno != pgnoNull );
	PcsrCurrent( pfucbNew )->itag = itagFOP;

	/*	in redo, we may redo the appended page, but we have to set
	/*	right bit if it is for leaf node when initialize FOP node.
	/*	for regular case, fLeaf is not set until MoveNodes are called.
	/**/
	Assert( !( fAppend && psplit->fLeaf ) || fRecovering );

	if ( fRecovering )
		{
		BF		*pbf;
		BOOL	fRedoNeeded;
		PN		pn = PnOfDbidPgno( pfucb->dbid, psplit->pgnoNew );

		/*	if need to redo or not.
		 */
		err = ErrLGRedoable(
				pfucb->ppib,
				pn,
				psplit->qwDBTimeRedo,
				&pbf,
				&fRedoNeeded );
		if ( err == JET_errOutOfMemory )
			return err;
		psplit->fNoRedoNew = ( err == JET_errSuccess && fRedoNeeded == fFalse );
		}

	CallR( ErrNDNewPage( pfucbNew,
		PcsrCurrent( pfucbNew )->pgno,
		pfucbNew->u.pfcb->pgnoFDP,
		pgtyp,
		fAppend && psplit->fLeaf ) )
		
 	/* lock it till split log rec is generated
	/**/
	if ( FBFWriteLatchConflict( pssibNew->ppib, pssibNew->pbf ) )
		{
		/*	yeild after release split resources
		/**/
		pfucb->ppib->cLatchConflict++;
		return ErrERRCheck( errDIRNotSynchronous );
		}
	BFSetWriteLatch( pssibNew->pbf, pssibNew->ppib );
	Assert( psplit->pbfNew == pbfNil );
 	psplit->pbfNew = pssibNew->pbf;

	if ( fDoubleVertical )
		{
		PcsrCurrent( pfucbNew2 )->pgno = psplit->pgnoNew2;
		Assert( PcsrCurrent( pfucbNew2 )->pgno != pgnoNull );
		PcsrCurrent( pfucbNew2 )->itag = 0;
		
		if ( fRecovering )
			{
			BF		*pbf;
			BOOL	fRedoNeeded;

			/* if need to redo or not
			/**/
			err = ErrLGRedoable(
				pfucb->ppib,
				PnOfDbidPgno( pfucb->dbid, psplit->pgnoNew2 ),
				psplit->qwDBTimeRedo,
				&pbf, &fRedoNeeded );
			if ( err == JET_errOutOfMemory )
				return err;

			psplit->fNoRedoNew2 = ( err == JET_errSuccess && fRedoNeeded == fFalse );
			}
		
		CallR( ErrNDNewPage( pfucbNew2, PcsrCurrent( pfucbNew2 )->pgno, pfucbNew2->u.pfcb->pgnoFDP, pgtyp, fFalse ) );
		
		if ( FBFWriteLatchConflict( pssibNew2->ppib, pssibNew2->pbf ) )
			{
			/*	yeild after release split resources
			/**/
			pfucb->ppib->cLatchConflict++;
			return ErrERRCheck( errDIRNotSynchronous );
			}

		BFSetWriteLatch( pssibNew2->pbf, pssibNew2->ppib );
		Assert( psplit->pbfNew2 == pbfNil );
 		psplit->pbfNew2 = pssibNew2->pbf;

		PcsrCurrent( pfucbNew3 )->pgno = psplit->pgnoNew3;
		Assert( PcsrCurrent( pfucbNew3 )->pgno != pgnoNull );
		PcsrCurrent( pfucbNew3 )->itag = 0;

		if ( fRecovering )
			{
			BF		*pbf;
			BOOL	fRedoNeeded;

			/* if need to redo or not
			/**/
			err = ErrLGRedoable(
				pfucb->ppib,
				PnOfDbidPgno( pfucb->dbid, psplit->pgnoNew3 ),
				psplit->qwDBTimeRedo,
				&pbf,
				&fRedoNeeded );
			if ( err == JET_errOutOfMemory )
				return err;
			psplit->fNoRedoNew3 = ( err == JET_errSuccess && fRedoNeeded == fFalse );
			}
		
		CallR( ErrNDNewPage( pfucbNew3, PcsrCurrent( pfucbNew3 )->pgno, pfucbNew3->u.pfcb->pgnoFDP, pgtyp, fFalse ) );
		
		if ( FBFWriteLatchConflict( pssibNew3->ppib, pssibNew3->pbf ) )
			{
			/*	yeild after release split resources
			/**/
			pfucb->ppib->cLatchConflict++;
			return ErrERRCheck( errDIRNotSynchronous );
			}
		BFSetWriteLatch( pssibNew3->pbf, pssibNew3->ppib );
		Assert( psplit->pbfNew3 == pbfNil );
		psplit->pbfNew3 = pssibNew3->pbf;
		}

	if ( fRecovering && fSkipMove )
		{
		/* if it is skip move, no need to touch the split page
		/**/
		Assert( psplit->pbfSplit == pbfNil );
		return JET_errSuccess;
		}
		
	/*	some other thread updates the page. Abort split.
	 */
	if ( qwDBTimeT != QwPMDBTime( pfucb->ssib.pbf->ppage ) )
		return ErrERRCheck( errDIRNotSynchronous );

	/*	latch the split page now.
	 */
	if ( !( FBFWriteAccessPage( pfucb, psplit->pgnoSplit ) ) )
		{
		CallR( ErrBFWriteAccessPage( pfucb, psplit->pgnoSplit ) );
		}

	if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
		{
		/*	yeild after release split resources
		/**/
		pfucb->ppib->cLatchConflict++;
		return ErrERRCheck( errDIRNotSynchronous );
		}
	BFSetWriteLatch( pssib->pbf, pssib->ppib );
	Assert( psplit->pbfSplit == pbfNil );
	psplit->pbfSplit = pssib->pbf;

	/*	make split page depend on new page
	/*	append page has no data from src page and hence there
	/*	is no dependency.
	/*	Also bookmark all visible (leaf) nodes.
	/**/
	PMGet( pssib, pssib->itag );

	/*	if split not append then set buffer dependency
	/**/
	if ( psplit->splitt == splittAppend )
		{
		Assert( fAppend );
		}
	else
		{
		Assert( !fAppend );
		CallR( ErrBFDepend( pssibNew->pbf, pssib->pbf ));

		if ( fDoubleVertical )
			{
			CallR( ErrBFDepend( pssibNew2->pbf, pssib->pbf ));
			CallR( ErrBFDepend( pssibNew3->pbf, pssib->pbf ));
			}
		}

	return JET_errSuccess;
	}

	
/*	Move Nodes for Vertical split.
/*	This function only touches the split page and new page.
/**/
ERR ErrBTSplitVMoveNodes(
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	SPLIT	*psplit,
	CSR		*pcsr,
	BYTE	*rgb,
	BOOL	fNoMove )
	{
	SSIB	*pssib  = &pfucb->ssib;
	SSIB	*pssibNew  = &pfucbNew->ssib;
	LINE	rgline[6];
	INT 	cline;
	BYTE	bTmp;
	INT 	cbSon;
	INT 	ibSon;
	BYTE	*pbSon;
	BYTE	*pbNode;
	BYTE	*pbData;
	BOOL	fVisibleSons;
	ERR 	err;
	BYTE	rgbT[1 + sizeof(PGNO)];

	/*	set new page type and pgnoFDP
	/*	cache split node son table
	/*	move sons
	/*	update split node
	/*	insert page pointer in split page to new page
	/**/

	/*	cache split node son table
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );

	fVisibleSons = FNDVisibleSons( *pssib->line.pb );
	if ( !fNoMove )
		{
		/* do not change anything before real move
		/**/
		if ( fVisibleSons != 0 )
			psplit->fLeaf = fTrue;
		}

	pbSon = PbNDSon( pssib->line.pb );
	Assert( psplit->itagSplit != itagFOP );
	if ( FNDNullSon( *pssib->line.pb ) || FNDNonIntrinsicSons( pssib->line.pb ) )
		{
		cbSon = CbNDSon( pssib->line.pb );
		Assert( cbSon < cbSonMax );
		psplit->rgbSonSplit[0] = (BYTE)cbSon;
		for ( ibSon = 0; ibSon < cbSon; ibSon++ )
			{
			psplit->rgbSonSplit[ibSon + 1] = pbSon[ibSon];
			}

		/*	move sons
		/**/
		CallR( ErrBTMoveSons( psplit, pfucb, pfucbNew, pssib->itag,
			psplit->rgbSonNew, fVisibleSons, fNoMove, NULL, 0 ) );

		if ( fNoMove )
			return err;
		}
	else
		{
		/*	if split node contained intrinsic page pointer,
		/*	split page pointer to new page.  Correct page
		/*	pointer CSR to new page.  Since there may be another
		/*	full cursor, must call MCMCorrectIntrinsic to
		/*	change position.
		/**/
		Assert( pssib->itag != itagNull );

		if ( fNoMove )
			return JET_errSuccess;

		cline = 0;
		rgb[0] = 0;
		rgb[1] = 0;
		rgline[cline].pb = (BYTE *)rgb;
		rgline[cline++].cb = 2;
		rgline[cline].pb = (BYTE *)pbSon;
		rgline[cline++].cb = sizeof(PGNO);
		Assert( cline <= 6 );
		CallS( ErrPMInsert( pssibNew, rgline, cline ) );
		Assert( pssibNew->itag == 1 );

		if ( !fRecovering )
			{
			/*	correct parent CSR to split page
			/**/
			MCMBurstIntrinsic( pfucb, pcsr->pgno,
				pcsr->itagFather, psplit->pgnoNew, pssibNew->itag );
			Assert( pcsr->pgno == psplit->pgnoNew );
			Assert( pcsr->itag == pssibNew->itag );
			Assert( pcsr->itagFather == itagFOP );
			Assert( pcsr->csrstat == csrstatOnCurNode );
			}

		/*	show moved one son to itag 1
		/**/
		psplit->rgbSonNew[0] = 1;
		psplit->rgbSonNew[1] = 1;
		}

	/*	update FOP of new page
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );
	bTmp = *(pssib->line.pb);
	rgb[0] = 0;
	if ( fVisibleSons )
		{
		NDSetVisibleSons( rgb[0] );
		}
	rgb[1] = 0;
	cline = 0;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = 2;
	if ( psplit->rgbSonNew[0] != 0 )
		{
		NDSetSon( rgb[0] );
		rgline[cline].pb = psplit->rgbSonNew;
		rgline[cline++].cb = psplit->rgbSonNew[0] + 1;
		}
	else
		{
		NDResetSon( rgb[0] );
		Assert( FNDVisibleSons( rgb[0] ) );
		}
	pssibNew->itag = 0;
	Assert(cline <= 6);
	Assert( PgnoOfPn(pssibNew->pbf->pn) == psplit->pgnoNew );
	CallS( ErrPMReplace( pssibNew, rgline, cline ) );

	AssertNDGet( pfucbNew, itagFOP );
	Assert( pssibNew == &pfucbNew->ssib );
	NDCheckPage( pssibNew );

	/*	update split node with intrinsic page pointer
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );
	memcpy( rgb, pssib->line.pb, pssib->line.cb );
	pbNode = rgb;
	Assert( bTmp == *(pbNode) );
	NDSetSon( bTmp );
	NDSetInvisibleSons( bTmp );
	cline = 0;
	rgline[cline].pb = &bTmp;
	rgline[cline++].cb = 1;
	rgline[cline].pb = StNDKey( pbNode );
	rgline[cline++].cb = CbNDKey( pbNode ) + 1;
	rgbT[0] = 1;
	*(PGNO UNALIGNED *)&rgbT[1] = psplit->pgnoNew;
	rgline[cline].pb = rgbT;
	rgline[cline++].cb = 1 + sizeof(PGNO);

	/*	copy back link
	/**/
	if ( FNDBackLink( *pbNode ) )
		{
		rgline[cline].pb = PbNDBackLink( pbNode );
		rgline[cline++].cb = sizeof(SRID);
		}
	pbData = PbNDData( pbNode );
	rgline[cline].pb = pbData;
	rgline[cline++].cb = pssib->line.cb - (ULONG) ( pbData - pbNode );
	Assert( cline <= 6 );
	Assert( PgnoOfPn(pssib->pbf->pn) == psplit->pgnoSplit );
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	return JET_errSuccess;
	}


/*  Move Nodes for Double Vertical split.
/*  This function only touches the split page and new page.
/**/
ERR ErrBTSplitDoubleVMoveNodes(
	FUCB		*pfucb,
	FUCB		*pfucbNew,
	FUCB		*pfucbNew2,
	FUCB		*pfucbNew3,
	SPLIT		*psplit,
	CSR		  	*pcsr,
	BYTE		*rgb,
	BOOL		fNoMove )
	{
	SSIB		*pssib  = &pfucb->ssib;
	SSIB		*pssibNew2  = &pfucbNew2->ssib;
	SSIB		*pssibNew3  = &pfucbNew3->ssib;
	LINE		rgline[6];
	INT	  		cline;
	BYTE		bTmp;
	INT	  		cbSon;
	INT	  		ibSon;
	BYTE		*pbSon;
	BYTE		*pbNode;
	BYTE		*pbData;
	BYTE		*pbSonNew = psplit->rgbSonNew;
	THREEBYTES	tbNew2;
	THREEBYTES	tbNew3;
	BOOL		fVisibleSons;
	ERR			err;

	/*	set new page type and pgnoFDP
	/*	cache split node son table
	/*	move sons
	/*	update split node
	/*	insert page pointer in split page to new page
	/**/

	/*	cache split node son table
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );

	fVisibleSons = FNDVisibleSons( *pssib->line.pb );
	if ( !fNoMove )
		{
		/* do not change anything before real move
		/**/
		if ( fVisibleSons != 0 )
			psplit->fLeaf = fTrue;
		}

	pbSon = PbNDSon( pssib->line.pb );

	/*	we shall never Double VSplit a node with no son or with an
	/*	intrinsic son.  A normal VSplit should be performed instead.
	/**/
	Assert( FNDNullSon( *pssib->line.pb ) || FNDNonIntrinsicSons( pssib->line.pb ) );

	cbSon = CbNDSon( pssib->line.pb );
	Assert( cbSon < cbSonMax );
	psplit->rgbSonSplit[0] = (BYTE)cbSon;
	for ( ibSon = 0; ibSon < cbSon; ibSon++ )
		{
		psplit->rgbSonSplit[ibSon + 1] = pbSon[ibSon];
		}

	/*	move sons from 0th son to ibSon
	/**/
	psplit->splitt = splittLeft;
	CallR( ErrBTMoveSons( psplit,
		pfucb,
		pfucbNew2,
		pssib->itag,
		pbSonNew,
		fVisibleSons,
		fNoMove,
		NULL, 0 ) );

	if ( !fNoMove )
		{
		/*	update FOP of new page
		/**/
		pssib->itag = psplit->itagSplit;
		PMGet( pssib, pssib->itag );
		bTmp = *(pssib->line.pb);
		rgb[0] = 0;
		if ( FNDVisibleSons( bTmp ) )
			{
			NDSetVisibleSons( rgb[0] );
			}
		rgb[1] = 0;
		cline = 0;
		rgline[cline].pb = rgb;
		rgline[cline++].cb = 2;
		if ( *pbSonNew != 0 )
			{
			NDSetSon( rgb[0] );
			rgline[cline].pb = pbSonNew;
			rgline[cline++].cb = *pbSonNew + 1;
			}
		else
			{
			NDResetSon( rgb[0] );
			Assert( FNDVisibleSons( rgb[0] ) );
			}
		pssibNew2->itag = 0;
		Assert( cline <= 6 );
		Assert( PgnoOfPn(pssibNew2->pbf->pn) == psplit->pgnoNew2 );
		CallS( ErrPMReplace( pssibNew2, rgline, cline ) );

		AssertNDGet( pfucbNew2, itagFOP );
		Assert( pssibNew2 == &pfucbNew2->ssib );
		NDCheckPage( pssibNew2 );
		}

	/*	cache split node son table
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );

	/*	adjust to point to second set of sons (their itags)
	/**/
	pbSonNew += ( *pbSonNew + 1 );
	Assert( pbSonNew == psplit->rgbSonNew + *psplit->rgbSonNew + 1 );

	/* move sons from ibSon + 1 to end
	/**/
	psplit->splitt = splittRight;
	psplit->ibSon++;
	Assert( cbSon - psplit->ibSon > 0 );
	CallR( ErrBTMoveSons( psplit,
		pfucb,
		pfucbNew3,
		pssib->itag,
		pbSonNew,
		fVisibleSons,
		fNoMove,
		NULL, 0 ) );

	psplit->splitt = splittDoubleVertical;
	psplit->ibSon--;

	if ( fNoMove )
		{
		return JET_errSuccess;
		}

	/*	update FOP of new page
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );
	bTmp = *(pssib->line.pb);
	rgb[0] = 0;
	if ( FNDVisibleSons( bTmp ) )
		{
		NDSetVisibleSons( rgb[0] );
		}
	rgb[1] = 0;
	cline = 0;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = 2;
	if ( *pbSonNew != 0 )
		{
		NDSetSon( rgb[0] );
		rgline[cline].pb = pbSonNew;
		rgline[cline++].cb = *pbSonNew + 1;
		}
	else
		{
		NDResetSon( rgb[0] );
		Assert( FNDVisibleSons( rgb[0] ) );
		}
	pssibNew3->itag = 0;
	Assert( cline <= 6 );
	Assert( PgnoOfPn(pssibNew3->pbf->pn) == psplit->pgnoNew3 );
	CallS( ErrPMReplace( pssibNew3, rgline, cline ) );

	AssertNDGet( pfucbNew3, itagFOP );
	Assert( pssibNew3 == &pfucbNew3->ssib );
	NDCheckPage( pssibNew3 );


	/*	update split node with intrinsic page pointer
	/**/
	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );
	pbNode = pssib->line.pb;
	Assert( bTmp == *(pbNode) );
	NDSetSon( bTmp );
	NDSetInvisibleSons( bTmp );
	cline = 0;
	rgline[cline].pb = &bTmp;
	rgline[cline++].cb = 1;
	rgline[cline].pb = StNDKey( pbNode );
	rgline[cline++].cb = CbNDKey( pbNode ) + 1;
	rgb[0] = 1;
	*(PGNO UNALIGNED *)&rgb[1] = psplit->pgnoNew;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = 1 + sizeof(PGNO);
	/*	copy back link
	/**/
	if ( FNDBackLink( *pbNode ) )
		{
		rgline[cline].pb = PbNDBackLink( pbNode );
		rgline[cline++].cb = sizeof(SRID);
		}
	pbData = PbNDData( pbNode );
	rgline[cline].pb = pbData;
	rgline[cline++].cb = pssib->line.cb - (ULONG) ( pbData - pbNode );
	Assert( cline <= 6 );
	Assert( PgnoOfPn(pssib->pbf->pn) == psplit->pgnoSplit );
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	/*	set the links
	/**/
	ThreeBytesFromL( &tbNew2, pfucbNew2->pcsr->pgno );
	ThreeBytesFromL( &tbNew3, pfucbNew3->pcsr->pgno );
	pssibNew2->pbf->ppage->pgnoNext = tbNew3;
	pssibNew3->pbf->ppage->pgnoPrev = tbNew2;

	CallS( ErrBTSetIntermediatePage( pfucbNew, psplit, rgb ) );
	return JET_errSuccess;
	}


/*  Move Nodes for Horizontal split.
/*  This function only touches the split page and new page.
/**/
ERR ErrBTSplitHMoveNodes(
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	SPLIT	*psplit,
	BYTE	*rgb,
	BOOL	fNoMove)
	{
	ERR			err;
	SSIB		*pssib  = &pfucb->ssib;
	SSIB		*pssibNew  = &pfucbNew->ssib;
	LINE		rgline[2];
	INT 		cline;
	INT 		cbSon;
	INT 		ibSon;
	BYTE		*pbSon;
	BYTE		*pbNode;
	BOOL		fLeftSplit = (psplit->splitt == splittLeft);
	BOOL		fVisibleSons;

	/*	check if sons of split page are visible
	/*	move sons
	/*	update new FOP
	/*	update split FOP
	/*	correct page links
	/**/
	Assert( PgnoOfPn( pssib->pbf->pn ) == psplit->pgnoSplit );
	
	/*	check if sons of split page are visible
	/*	cache split page son table
	/**/
	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );

	fVisibleSons = FNDVisibleSons( *pssib->line.pb );
	if ( !fNoMove )
		{
		/* do not change anything before real move
		/**/
		if ( fVisibleSons != 0 )
			psplit->fLeaf = fTrue;
		}

	AssertBTFOP( pssib );
	pbSon = PbNDSon( pssib->line.pb );
	cbSon = CbNDSon( pssib->line.pb );
	Assert( cbSon < cbSonMax );
	psplit->rgbSonSplit[0] = (BYTE)cbSon;
	for ( ibSon = 0; ibSon < cbSon; ibSon++ )
		psplit->rgbSonSplit[ibSon + 1] = pbSon[ibSon];

	if ( !fNoMove )
		{
		AssertBFDirty( pssib->pbf );
		}

	/*	move sons
	/**/
	CallR( ErrBTMoveSons( psplit, pfucb, pfucbNew, pssib->itag,
		psplit->rgbSonNew, fVisibleSons, fNoMove, NULL, 0 ) );

	if ( fNoMove )
		return err;

	/*	update new FOP
	/**/
	pssibNew->itag = itagFOP;
	PMGet( pssibNew, pssibNew->itag );
	cline = 0;
	rgb[0] = *pssibNew->line.pb;
	rgb[1] = 0;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = 2;
	if ( psplit->rgbSonNew[0] > 0 )
		{
		NDSetSon( rgb[0] );
		rgline[cline].pb = psplit->rgbSonNew;
		rgline[cline++].cb = psplit->rgbSonNew[0] + 1;
		}
	else
		{
		Assert( psplit->ibSon == ibSonNull ||
			psplit->ibSon == (INT)psplit->rgbSonSplit[0] );
		Assert( FNDNullSon( rgb[0] ) );
		}

	if ( fVisibleSons )
		NDSetVisibleSons( rgb[0] );
	Assert( pssibNew->itag == 0 );
	Assert(cline <= 2);
	Assert( PgnoOfPn( pssibNew->pbf->pn ) == psplit->pgnoNew );
	CallS( ErrPMReplace( pssibNew, rgline, cline ) );
	AssertBTFOP( pssibNew );

	AssertNDGet( pfucbNew, itagFOP );
	Assert( pssibNew == &pfucbNew->ssib );
	NDCheckPage( pssibNew );


	/*	update split FOP
	/**/
	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );
	AssertBTFOP( pssib );
	pbNode = pssib->line.pb;
	rgb[0] = *pbNode;
	rgb[1] = 0;

	if ( psplit->ibSon != ibSonNull )
		{
		/*	if split all sons out of page, then must reset FOP to have
		/*	no sons.  Split all nodes if left and ibSon == cbSon - 1 or
		/*	if right and ibSon == 0.
		/**/
		if ( ( fLeftSplit && psplit->ibSon == (INT)psplit->rgbSonSplit[0] - 1 ) ||
			( !fLeftSplit && psplit->ibSon == 0 ) )
			{
			NDResetSon( rgb[0] );
			Assert( FNDVisibleSons( rgb[0] ) );
			if ( fLeftSplit )
				rgline[0].cb = 2 + psplit->rgbSonSplit[0] - psplit->ibSon - 1;
			else
				rgline[0].cb = 2 + psplit->ibSon;
			}
		else
			{
			Assert( FNDSon( rgb[0] ) );
			pbSon = PbNDSon( pbNode );
			Assert( psplit->ibSon < cbSonMax );
			if ( fLeftSplit )
				{
				rgb[2] = psplit->rgbSonSplit[0] - (BYTE)psplit->ibSon - 1;
				memcpy( &rgb[3], pbSon + (BYTE)psplit->ibSon + 1, rgb[2] );
				rgline[0].cb = 3 + psplit->rgbSonSplit[0] - psplit->ibSon - 1;
				}
			else
				{
				rgb[2] = (BYTE)psplit->ibSon;
				memcpy( &rgb[3], pbSon, psplit->ibSon );
				rgline[0].cb = 3 + psplit->ibSon;
				}
			}
		rgline[0].pb = rgb;
		Assert( PgnoOfPn(pssib->pbf->pn) == psplit->pgnoSplit );
		CallS( ErrPMReplace( pssib, rgline, 1 ) );
		}

#ifdef DEBUG
	CallS( ErrPMGet( pssib, itagFOP ) );
	Assert( FNDNullSon( *pssib->line.pb ) || CbNDSon( pssib->line.pb ) != 0 );
#endif

	return JET_errSuccess;
	}


/*  Assume that pssib and pssibNew is pointing to split page and newpage
/*  respectively.
/**/
ERR ErrBTPrepareCorrectLinks( SPLIT *psplit, FUCB *pfucb, SSIB *pssib, SSIB *pssibNew )
	{
	ERR		err;
	BOOL	fLeftSplit = (psplit->splitt == splittLeft);

	Assert( pssib == &pfucb->ssib );
	if ( fLeftSplit )
		{
		PGNO   		pgnoPrev;

		LFromThreeBytes( &pgnoPrev, &pssib->pbf->ppage->pgnoPrev );
		if ( pgnoPrev != pgnoNull )
			{
			CallR( ErrBFWriteAccessPage( pfucb, pgnoPrev ) );
			psplit->pgnoSibling = pgnoPrev;

			/* lock it till split log rec is generated
			/**/
			if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
				{
				/*	yeild after release split resources
				/**/
				pfucb->ppib->cLatchConflict++;
				return ErrERRCheck( errDIRNotSynchronous );
				}
			BFSetWriteLatch( pssib->pbf, pssib->ppib );
			Assert( psplit->pbfSibling == pbfNil );
			psplit->pbfSibling = pssib->pbf;
			}
		}
	else
		{
		PGNO   		pgnoNext;

		LFromThreeBytes( &pgnoNext, &pssib->pbf->ppage->pgnoNext );
		if ( pgnoNext != pgnoNull )
			{
			CallR( ErrBFWriteAccessPage( pfucb, pgnoNext ) );
			psplit->pgnoSibling = pgnoNext;
			/* lock it till split log rec is generated
			/**/
			if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
				{
				/*	yeild after release split resources
				/**/
				pfucb->ppib->cLatchConflict++;
				return ErrERRCheck( errDIRNotSynchronous );
				}
			BFSetWriteLatch( pssib->pbf, pssib->ppib );
			Assert( psplit->pbfSibling == pbfNil );
			psplit->pbfSibling = pssib->pbf;
			}
		}

	return JET_errSuccess;
	}


VOID BTCorrectLinks( SPLIT *psplit, FUCB *pfucb, SSIB *pssib, SSIB *pssibNew )
	{
	BOOL		fLeftSplit = (psplit->splitt == splittLeft);
	THREEBYTES	tbNew;
	THREEBYTES	tbSplit;

	/*	correct page links
	 *		new to split next
	 *		split to new
	 *		split next to new
	 *		new to split
	 */

	Assert( pssib == &pfucb->ssib );

	ThreeBytesFromL( &tbNew, psplit->pgnoNew );
	ThreeBytesFromL( &tbSplit, psplit->pgnoSplit );

	if ( fLeftSplit )
		{
		PGNO   		pgnoPrev = psplit->pgnoSibling;

		pssibNew->pbf->ppage->pgnoPrev =
			pssib->pbf->ppage->pgnoPrev;
		pssib->pbf->ppage->pgnoPrev = tbNew;
		pssibNew->pbf->ppage->pgnoNext = tbSplit;

		if ( pgnoPrev != pgnoNull )
			{
			CallS( ErrBFWriteAccessPage( pfucb, pgnoPrev ) );

			pssib->pbf->ppage->pgnoNext = tbNew;
			PMDirty( &pfucb->ssib );
			}
		}
	else
		{
		PGNO   		pgnoNext = psplit->pgnoSibling;

		pssibNew->pbf->ppage->pgnoNext =
			pssib->pbf->ppage->pgnoNext;
		pssib->pbf->ppage->pgnoNext = tbNew;
		pssibNew->pbf->ppage->pgnoPrev = tbSplit;

		if ( pgnoNext != pgnoNull )
			{
			CallS( ErrBFWriteAccessPage( pfucb, pgnoNext ) );

			pssib->pbf->ppage->pgnoPrev = tbNew;
			PMDirty( &pfucb->ssib );
			}
		}
	}


#pragma optimize("g",off)

/*  Make sure parent page has enough space to insert page pointer.
/**/
LOCAL ERR ErrBTPrepareInsertParentPage(
	FUCB	*pfucb,
	CSR		*pcsr,
	CSR		*pcsrRoot,
	CSR		**ppcsrPagePointer,
	SPLIT	*psplit )
	{
	ERR		err;
	CSR		*pcsrPagePointer;
	INT		cbReqFather;
	BOOL  	fAppendPageFather;
	SSIB  	*pssib = &pfucb->ssib;
	BOOL  	fSplitDone = fFalse;
	CSR		*pcsrRevert = pcsrNil;
	INT		ibSonRevert;

	/*	find page pointer CSR.  Note that CSR stack may span multiple nested
	/*	trees on page.  The page pointer must be the first CSR on
	/*	a different page.
	/**/
	for (	pcsrPagePointer = pcsr;
			pcsrPagePointer->pgno == psplit->pgnoNew ||
			pcsrPagePointer->pgno == psplit->pgnoSplit;
			pcsrPagePointer = pcsrPagePointer->pcsrPath );

	*ppcsrPagePointer = pcsrPagePointer;

	CallR( ErrBFWriteAccessPage( pfucb, pcsrPagePointer->pgno ) );

	/* lock it till split log rec is generated
	/**/
	if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
		{
		/*	yeild after release split resources
		/**/
		pfucb->ppib->cLatchConflict++;
		return ErrERRCheck( errDIRNotSynchronous );
		}

	if ( !( psplit->splitt == splittLeft ) )
		{
		/*	prepare to undo ibSon change if errDIRNotSynchronous
		/**/
		pcsrRevert = pcsrPagePointer;
		ibSonRevert = pcsrRevert->ibSon;

		/* correct ibSon to point to the new entry so that split page
		/* will choose the right split spot.
		/**/
		if ( pcsrPagePointer->ibSon == ibSonNull )
			{
			/* father page is an intrinsic pointer, which as 1 son only
			/**/
			pcsrPagePointer->ibSon = 1;
			}
		else
			{
			pcsrPagePointer->ibSon++;
			}
		pcsrPagePointer->csrstat = csrstatBeforeCurNode;
		}

	/*	space needed is most of:
	/*
	/*	case 1 : intrinsic father node
	/*		TAG				sizeof(TAG)
	/*		header			1
	/*		cbKey 			1
	/*		key				JET_cbKeyMost
	/*		pgno			sizeof(PGNO)
	/*		son in father	1
	/*		burst TAG		sizeof(TAG)
	/*		header			1
	/*		cbKey	  		1
	/*		NULL key  		0
	/*		pgno	  		sizeof(PGNO)
	/*		son in father	1
	/**/
	cbReqFather = sizeof(TAG) + 1 + 1 + JET_cbKeyMost + sizeof(PGNO) + sizeof(PGNO ) + 1 +
		sizeof(TAG) + 1 + 1 + sizeof(PGNO) + 1;

	forever
		{
		//	UNDONE:	allow specification of a number of tags
		//			to be freed as well as a number of bytes
		//			for bursting of intrisic page pointers
#if DEBUGGING
		PAGE *ppageT = pssib->pbf->ppage;
#endif

		fAppendPageFather = FBTAppendPage( pfucb, pcsrPagePointer, cbReqFather, 0, CbFreeDensity( pfucb ), 2 );
		if ( !fAppendPageFather  &&  !FBTSplit( pssib, cbReqFather, 2 ) )
			{
			// Get out when there's no more need to append or split.
			break;
			}

		fSplitDone = fTrue;

		CallR( ErrBTSplitPage(
			pfucb,
			pcsrPagePointer,
			pcsrRoot,
			psplit->key,
			0, /* no existing node since inserting */			
			cbReqFather,
			0,
			fAppendPageFather ) );

		#if DEBUGGING
			PageConsistent( ppageT );
		#endif

		CallR( ErrBFWriteAccessPage( pfucb, pcsrPagePointer->pgno ) );
		}

	/* lock it till split log rec is generated
	/**/
	if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
		{
		/*	yeild after release split resources
		/**/
		pfucb->ppib->cLatchConflict++;
		return ErrERRCheck( errDIRNotSynchronous );
		}
	
	BFSetWriteLatch( pssib->pbf, pssib->ppib );
	Assert( psplit->pbfPagePtr == pbfNil );
	psplit->pbfPagePtr = pssib->pbf;
	
	return JET_errSuccess;
	}


/*	this function is used by the split. Split has checked that there must
/*  be enough space to insert this new page pointer node.
/*  This function only touches the pointer page.
/**/
ERR ErrBTInsertPagePointer( FUCB *pfucb, CSR *pcsrPagePointer, SPLIT *psplit, BYTE *rgb )
	{
	ERR		err;
	SSIB  	*pssib  = &pfucb->ssib;
	LINE  	rgline[4];
	INT		cline;
	ULONG 	cb;
	BYTE  	bTmp;
	BYTE  	*pbSon;
	BOOL  	fLeftSplit = (psplit->splitt == splittLeft);
	INT		cbSon;
	INT		itagIntrinsic = itagNull;

	/*	burst intrinsic page pointer if exists
	/*	insert new page pointer node with split key
	/*	link into father son table before split page
	/**/
	CallR( ErrBFWriteAccessPage( pfucb, pcsrPagePointer->pgno ) );
	Assert( !FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) );
	Assert( FBFWriteLatch( pssib->ppib, pssib->pbf ) );

	/*	burst intrisic page pointer if exists
	/**/
	pssib->itag = pcsrPagePointer->itagFather;
	PMGet( pssib, pssib->itag );
	PMDirty( pssib );
	NDCheckPage( pssib );

	Assert( FNDInvisibleSons( *pssib->line.pb ) );
	cbSon = CbNDSon( pssib->line.pb );
	if ( pcsrPagePointer->itagFather != itagFOP && cbSon == 1 )
		{
		/*	can not be FOP sine FOP do not have intrinsic sons
		/**/
		Assert( pcsrPagePointer->itagFather != itagFOP );

		/*	if only one son, an intrinsic pointer,
		/*	insert discrete page pointer node.
		/**/
		rgb[0] = 0;
		rgb[1] = 0;
		/* null key
		/**/
		AssertNDIntrinsicSon( pssib->line.pb, pssib->line.cb );
		*(PGNO UNALIGNED *)&rgb[2] = PgnoNDOfPbSon( pssib->line.pb );
		rgline[0].pb = rgb;
		rgline[0].cb = 2 + sizeof(PGNO);
		CallS( ErrPMInsert( pssib, rgline, 1 ) );

		/*	save itag of burst page pointer node for MCM.
		/**/
		itagIntrinsic = pssib->itag;

		/*	remember itag of bursted page pointer node
		/**/
		Assert( pcsrPagePointer->itag == itagNil );
		pcsrPagePointer->itag = (SHORT)pssib->itag;
		bTmp = (BYTE)pssib->itag;

		/*	update father node with son itag of discrete
		/*	page pointer node
		/**/
		pssib->itag = pcsrPagePointer->itagFather;
		PMGet( pssib, pssib->itag );
		memcpy( rgb, pssib->line.pb, pssib->line.cb );
		Assert( FNDSon( rgb[0] ) );

		pbSon = PbNDSon( rgb );
		*pbSon = bTmp;

		memcpy( pbSon + sizeof(BYTE),
			pbSon + sizeof(PGNO),
			pssib->line.cb - (ULONG) (pbSon - rgb) - sizeof(PGNO) );
		rgline[0].pb = rgb;
		rgline[0].cb = pssib->line.cb - sizeof(PGNO) + sizeof(BYTE);
		Assert( PgnoOfPn(pssib->pbf->pn) == pcsrPagePointer->pgno );
		CallS( ErrPMReplace( pssib, rgline, 1 ) );
		}

	// We always drag at least one page pointer node with us when
	// inserting/appending a new one (see BTHSplit()).
	Assert( cbSon > 0 );

	/*	insert new page pointer node with split key
	/**/
	if ( fLeftSplit )
		{
		rgb[0] = 0;
		Assert( psplit->key.cb <= JET_cbKeyMost );

		// UNDONE: This can actually occur if there are many NULL keys, so
		// remove this assert. -- JL
		Assert( psplit->key.cb > 0 );

		rgb[1] = (BYTE)psplit->key.cb;
		memcpy( &rgb[2], psplit->key.pb, psplit->key.cb );
		*(PGNO UNALIGNED *)&rgb[2 + psplit->key.cb] = psplit->pgnoNew;
		rgline[0].pb = rgb;
		rgline[0].cb = 2 + psplit->key.cb + sizeof(PGNO);
		PMDirty( pssib );
		CallS( ErrPMInsert( pssib, rgline, 1 ) );
		}
	else
		{
		ULONG		cbNode;
		BYTE		*pbData;

		/*	if not left split, then do the followings:
		/*	copy the current page pointer
		/*	replace the current page pointer with split key
		/*	insert a new page pointer node with new key
		/*	insert son into father
		/**/
		pssib->itag = pcsrPagePointer->itag;
		PMGet( pssib, pssib->itag );
		memcpy( rgb, pssib->line.pb, pssib->line.cb );
		Assert( FNDNullSon( rgb[0] ) );
		cbNode = pssib->line.cb;
		pbData = PbNDData( rgb );

		cline = 0;
		rgline[cline].pb = rgb;
		rgline[cline++].cb = 1;
		/*	key may be NULL if many NULL keys in tree
		/**/
		bTmp = (BYTE)psplit->key.cb;

		// UNDONE: This can actually occur if there are many NULL keys, so
		// remove this assert.  -- JL
		Assert( bTmp > 0 );

		rgline[cline].pb = &bTmp;
		rgline[cline++].cb = 1;
		rgline[cline].pb = psplit->key.pb;
		rgline[cline++].cb = psplit->key.cb;
		rgline[cline].pb = pbData;
		rgline[cline++].cb = sizeof(PGNO);
		Assert( pssib->itag == pcsrPagePointer->itag );
		Assert( PgnoOfPn(pssib->pbf->pn) == pcsrPagePointer->pgno );
		CallS( ErrPMReplace( pssib, rgline, cline ) );

		/*	replace page pointer to point to new page
		/**/
		Assert( PbNDData( rgb ) == pbData );
		*(PGNO UNALIGNED *)pbData = psplit->pgnoNew;
		cline = 0;
		rgline[cline].pb = rgb;
		rgline[cline++].cb = cbNode;
		CallS( ErrPMInsert( pssib, rgline, cline ) );
		}

	/*	set itagPagePointer in SPLIT structure.
	/**/
	psplit->itagPagePointer = pssib->itag;

	/*	update father node with new page pointer node son
	/**/
	pssib->itag = pcsrPagePointer->itagFather;
	PMGet( pssib, pssib->itag );
	memcpy( rgb, pssib->line.pb, pssib->line.cb );
	Assert( !FNDNullSon( rgb[0] ) );
	pbSon = PbNDSonTable( rgb );

	/*	increase number of sons by one for inserted son
	/**/
	(*pbSon)++;

	/*	move to son insertion point
	/**/
	pbSon += 1 + pcsrPagePointer->ibSon;

	cline = 0;
	rgline[cline].pb = rgb;
	cb = (ULONG)(pbSon - rgb);
	rgline[cline++].cb = cb;
	bTmp = (BYTE)psplit->itagPagePointer;
	rgline[cline].pb = &bTmp;
	rgline[cline++].cb = 1;
	rgline[cline].pb = pbSon;
	rgline[cline++].cb = pssib->line.cb - cb;
	Assert( pssib->line.cb >= cb );
	Assert( PgnoOfPn(pssib->pbf->pn) == pcsrPagePointer->pgno );
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	if ( !fRecovering )
		{
		MCMInsertPagePointer( pfucb,
			pcsrPagePointer->pgno,
			pcsrPagePointer->itagFather );
		}

	Assert( pssib == &pfucb->ssib );
	NDCheckPage( pssib );

	return JET_errSuccess;
	}


/*	This function is used by Double Vertical split. It sets two page pointer
/*	nodes in the intermediate page.
/**/
ERR ErrBTSetIntermediatePage( FUCB *pfucb, SPLIT *psplit, BYTE *rgb )
	{
	ERR    	err;
	SSIB   	*pssib  = &pfucb->ssib;
	LINE   	rgline[4];
	INT		cline;
	BYTE   	*pbSon;
	BOOL   	fLeftSplit = ( psplit->splitt == splittLeft );
	BYTE   	bItag2;
	BYTE   	bItag3;

	/*	burst intrinsic page pointer if exists
	/*	insert new page pointer node with split key
	/*	link into father son table before split page
	/**/
	CallR( ErrBFWriteAccessPage( pfucb, psplit->pgnoNew ) );
// UNDONE: 	Check the next line pbfPagePtr what for.
// Not for VSplit but for HSplit.
//	psplit->pbfPagePtr = pssib->pbf;

	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );

	Assert( FNDNullSon( *pssib->line.pb ) );

	/*	insert new page pointer nodes with split key.
	/**/
	rgb[0] = 0;
	Assert( psplit->key.cb <= JET_cbKeyMost );
	rgb[1] = (BYTE)psplit->key.cb;
	memcpy( &rgb[2], psplit->key.pb, psplit->key.cb );
	*(PGNO UNALIGNED *)&rgb[2 + psplit->key.cb] = psplit->pgnoNew2;
	rgline[0].pb = rgb;
	rgline[0].cb = 2 + psplit->key.cb + sizeof(PGNO);
	CallS( ErrPMInsert( pssib, rgline, 1 ) );
	Assert( pssib->itag == itagDIRDVSplitL );
	bItag2 = (BYTE) pssib->itag;

	rgb[0] = 0;
	Assert( psplit->key.cb <= JET_cbKeyMost );

	/*	key is null
	/**/
	rgb[1] = 0;
	*(PGNO UNALIGNED *)&rgb[2] = psplit->pgnoNew3;
	rgline[0].pb = rgb;
	rgline[0].cb = 2 + sizeof(PGNO);
	CallS( ErrPMInsert( pssib, rgline, 1 ) );
	Assert( pssib->itag == itagDIRDVSplitR );
	bItag3 = (BYTE) pssib->itag;

	/*	update father node with new page pointer node sons
	/**/
	pssib->itag = itagFOP;
	PMGet( pssib, pssib->itag );
	memcpy( rgb, pssib->line.pb, pssib->line.cb );

	pbSon = PbNDSonTable( rgb );

	/*	set number of sons to two for inserted PPNs
	/**/
	*pbSon++ = 2;
	NDSetSon( *rgb );

	cline = 0;
	rgline[cline].pb = rgb;
	rgline[cline++].cb = (ULONG)(pbSon - rgb);

	rgline[cline].pb = &bItag2;
	rgline[cline++].cb = 1;
	rgline[cline].pb = &bItag3;
	rgline[cline++].cb = 1;

	Assert( PgnoOfPn(pssib->pbf->pn) == psplit->pgnoNew );
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	return JET_errSuccess;
	}


VOID BTReleaseRmpageBfs( BOOL fRedo, RMPAGE *prmpage )
	{
	QWORD	qwDBTime =prmpage->qwDBTimeRedo;
	
	/* release latches
	/**/
	while ( prmpage->cpbf > 0 )
		{
		BF *pbf;
		
		prmpage->cpbf--;
		pbf = *( prmpage->rgpbf + prmpage->cpbf );
		if ( fRedo )
			{
			AssertBFDirty( pbf );
//			Assert( pbf->ppage->ulDBTime < ulDBTime );
			PMSetDBTime( pbf->ppage, qwDBTime );
			}
		BFResetWaitLatch( pbf, prmpage->ppib );
		}

	if ( prmpage->rgpbf )
		{
		SFree( prmpage->rgpbf );
		prmpage->rgpbf = NULL;
		}

	Assert( prmpage->cpbf == 0 );
	return;
	}


/*	release split resources
/**/
VOID BTReleaseSplitBfs( BOOL fRedo, SPLIT *psplit, ERR err )
	{
	QWORD	qwDBTime = psplit->qwDBTimeRedo;

	if ( psplit->pbfNew )
		{
		if ( err < 0 )
			{
//			Assert( psplit->pbfNew->pbfDepend == psplit->pbfSplit );
			if ( psplit->pbfNew->pbfDepend != pbfNil )
				{
				BFUndepend( psplit->pbfNew );
				}
			}
			
		/* in recovery, if we did not have to redo the new page because the
		 * new page is more up to date, but we still do new page and redo
		 * the split. At the end of split, we simply abandon the changes
		 * that we made on the buffer since we know that the page on disk
		 * is more up to date than the split.
		 */
		if ( psplit->fNoRedoNew )
			{
			Assert( fRedo );
			/* abandon the buffer while in critJet */
			if ( psplit->pbfNew->pbfDepend != pbfNil )
				{
				BFUndepend( psplit->pbfNew );
				}
			BFResetDirtyBit( psplit->pbfNew );
			BFResetWriteLatch( psplit->pbfNew, psplit->ppib );
			BFAbandon( psplit->ppib, psplit->pbfNew );
			psplit->pbfNew = pbfNil;
			}
		else
			{
			if ( fRedo )
				{
				AssertBFDirty( psplit->pbfNew );
//				Assert( psplit->pbfNew->ppage->ulDBTime < ulDBTime );
				PMSetDBTime( psplit->pbfNew->ppage, qwDBTime );
				}

			BFResetWriteLatch( psplit->pbfNew, psplit->ppib );
			}
		}

	if ( psplit->pbfNew2 )
		{
		Assert ( psplit->pbfNew3 );

		if ( err < 0 )
			{
//			Assert( psplit->pbfNew2->pbfDepend == psplit->pbfSplit );
			if ( psplit->pbfNew2->pbfDepend != pbfNil )
				{
				BFUndepend( psplit->pbfNew2 );
				}
			if ( psplit->pbfNew3->pbfDepend != pbfNil )
				{
				BFUndepend( psplit->pbfNew3 );
				}
			}

		if ( psplit->fNoRedoNew2 )
			{
			Assert( fRedo );
			/* abandon the buffer while in critJet
			/**/
			if ( psplit->pbfNew2->pbfDepend != pbfNil )
				{
				BFUndepend( psplit->pbfNew2 );
				}
			
			BFResetDirtyBit( psplit->pbfNew2 );
			BFResetWriteLatch( psplit->pbfNew2, psplit->ppib );
			BFAbandon( psplit->ppib, psplit->pbfNew2 );
			psplit->pbfNew2 = pbfNil;
			}
		else
			{
			if ( fRedo )
				{
				AssertBFDirty( psplit->pbfNew2 );
//				Assert( psplit->pbfNew2->ppage->ulDBTime < ulDBTime );
				PMSetDBTime( psplit->pbfNew2->ppage, qwDBTime );
				}
			BFResetWriteLatch( psplit->pbfNew2, psplit->ppib );
			}

		if ( psplit->fNoRedoNew3 )
			{
			Assert( fRedo );
			/* abandon the buffer while in critJet
			/**/
			if ( psplit->pbfNew3->pbfDepend != pbfNil )
				{
				BFUndepend( psplit->pbfNew3 );
				}
			
			BFResetDirtyBit( psplit->pbfNew3 );
			BFResetWriteLatch( psplit->pbfNew3, psplit->ppib );
			BFAbandon( psplit->ppib, psplit->pbfNew3 );
			psplit->pbfNew3 = pbfNil;
			}
		else
			{
			if ( fRedo )
				{
				AssertBFDirty( psplit->pbfNew3 );
//				Assert( psplit->pbfNew3->ppage->ulDBTime < ulDBTime );
				PMSetDBTime( psplit->pbfNew3->ppage, qwDBTime );
				}
			BFResetWriteLatch( psplit->pbfNew3, psplit->ppib );
			}
		}

	if ( psplit->pbfSibling )
		{
		if ( fRedo )
			{
			AssertBFDirty( psplit->pbfSibling );
//			Assert( psplit->pbfSibling->ppage->ulDBTime < ulDBTime );
			PMSetDBTime( psplit->pbfSibling->ppage, qwDBTime );
			}

		BFResetWriteLatch( psplit->pbfSibling, psplit->ppib );
		}

	if ( psplit->pbfPagePtr )
		{
		if ( fRedo )
			{
			AssertBFDirty( psplit->pbfPagePtr );
//			Assert( psplit->pbfPagePtr->ppage->ulDBTime < ulDBTime );
			PMSetDBTime( psplit->pbfPagePtr->ppage, qwDBTime );
			}
		BFResetWriteLatch( psplit->pbfPagePtr, psplit->ppib );
		}

	if ( psplit->cpbf )
		{
		BF	**ppbf = psplit->rgpbf;
		BF	**ppbfMax = ppbf + psplit->cpbf;

		for (; ppbf < ppbfMax; ppbf++)
			{
			if ( fRedo )
				{
				AssertBFDirty( *ppbf );
//				Assert( (*ppbf)->ppage->ulDBTime < ulDBTime );
				PMSetDBTime( (*ppbf)->ppage, qwDBTime );
				}

			BFResetWriteLatch( *ppbf, psplit->ppib );
			}
		//	UNDONE:	use rgpbf
		if ( psplit->rgpbf )
			{
			SFree( psplit->rgpbf );
			psplit->rgpbf = NULL;
			}
		}
		
	if ( psplit->rgbklnk != NULL )
		{
		SFree( psplit->rgbklnk );
		psplit->rgbklnk = NULL;
		}

	/* when redo an append, we always redo it even ulDBTime
	/* of the split page is greater than ulDBTime of split
	/* log record. In this case, we do not want to change
	/* the ulDBTime of the page. So we can not rely on the buffer
	/* dependency to assume that when a split is redo, all the dependent
	/* buffer must have smaller ulDBTime.
	/**/
	if ( psplit->pbfSplit )
		{
		if ( fRedo )
			{
			AssertBFDirty( psplit->pbfSplit );
			/*	ulDBTime may have been set equal to ulDBTime by above
			/*	link page ulDBTime correction, during page merge.
			/**/
//			Assert( psplit->pbfSplit->ppage->ulDBTime <= ulDBTime );
			PMSetDBTime( psplit->pbfSplit->ppage, qwDBTime );
			}

		BFResetWriteLatch( psplit->pbfSplit, psplit->ppib );
		}
	}


//+private----------------------------------------------------------------------
//
//	ErrBTSplitPage
//	============================================================================
//
//	ERR ErrBTSplitPage(
//		FUCB			*pfucb,
//		CSR				*pcsr,
//		CSR				*pcsrRoot,
//		KEY				keySplit,
//		INT				cbNode,
//		INT				cbReq,
//		INT				fDIRFlags,
//		BOOL			fAppendPage )
//
//		pfucb			cursor
//		pcsr			location of insert or replace
//		pcsrRoot		root of tree, i.e. <record data root>
//		pssib			cursor ssib
//		keySplit		key of insert or replace node
//		cbReq			required cb
//		fReplace		fDIRReplace bit set if operation is replace
//		fAppendPage		insert at end
//
//------------------------------------------------------------------------------
ERR ErrBTSplitPage(
	FUCB		*pfucb,
	CSR  		*pcsr,
	CSR  		*pcsrRoot,
	KEY  		keySplit,
	INT			cbNode,
	INT 		cbReq,
	BOOL		fDIRFlags,
	BOOL		fAppendPage )
	{
	ERR	  		err = JET_errSuccess;
	SPLIT		*psplit = NULL;

	FUCB		*pfucbNew = pfucbNil;
	FUCB		*pfucbNew2 = pfucbNil;
	FUCB		*pfucbNew3 = pfucbNil;
	SSIB		*pssib = &pfucb->ssib;

	SSIB 		*pssibNew;
	SSIB 		*pssibNew2;
	SSIB 		*pssibNew3;
	BOOL		fAppend = fFalse;

//	BF			*pbf = NULL;
//	BYTE		*rgb;
//	UNDONE:	fix this
	static		BYTE rgb[cbPage];

	PGTYP		pgtyp;

	PIB			*ppib = pfucb->ppib;
	SPLITT	 	splittOrig = splittNull;
	INT			itagSplitOrig;

	BOOL		fSplit = fFalse;
	INT	 		ipcsrMac;
	INT	 		ipcsr;
	BOOL		fCleanupDoubleVerticalSplit = fFalse;

#ifdef DEBUGGING
	INT			cTrack = 0; 	// to track where split fails
#endif

	AssertFBFReadAccessPage( pfucb, pcsr->pgno );
	Assert( cbReq > 0 );
	if ( cbReq > cbNodeMost )
		return ErrERRCheck( JET_errRecordTooBig );

	/*	enter split critical section
	/**/
	/*	check page key order
	/**/
	BTCheckSplit( pfucb, pcsr->pcsrPath );

	/******************************************************
	/*	initialize local variables and allocate split resources
	/**/
	psplit = SAlloc( sizeof(SPLIT) );
	if ( psplit == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		return err;
		}
	memset( (BYTE *)psplit, 0, sizeof(SPLIT) );
	psplit->ppib = pfucb->ppib;

	if ( fDIRFlags & fDIRReplace )
		psplit->op = opReplace;
	else
		psplit->op = opInsert;

	psplit->dbid = pfucb->dbid;
	psplit->pgnoSplit = pcsr->pgno;

	/* no logging for this particular function
	/**/
	err = ErrBTSelectSplit( pfucb, pcsr, pssib, keySplit, cbNode, cbReq,
		fAppendPage, ( fDIRFlags & fDIRAppendItem ), psplit, &fAppend );
	Call( err );

	/* if appending then attempt to get next page in contiguous order
	/**/
	Assert( psplit->pgnoNew == pgnoNull );
	psplit->pgnoNew = pcsr->pgno;
	err = ErrSPGetPage( pfucb, &psplit->pgnoNew, fAppendPage );
	if ( err < 0 )
		{
		psplit->pgnoNew = pgnoNull;
		goto HandleError;
		}
	Assert( psplit->pgnoNew != pcsr->pgno );

	if ( psplit->splitt == splittDoubleVertical )
		{
		/*	preallocate pages for double vertical split. Release them if
		/*	it is not a double vertical split.
		/**/
		Assert( psplit->pgnoNew2 == pgnoNull );
		psplit->pgnoNew2 = pcsr->pgno;
		err = ErrSPGetPage( pfucb, &psplit->pgnoNew2, fAppendPage );
		if ( err < 0 )
			{
			psplit->pgnoNew2 = pgnoNull;
			goto HandleError;
			}
		
		Assert( psplit->pgnoNew2 != psplit->pgnoNew &&
			psplit->pgnoNew2 != psplit->pgnoSplit );
		Assert( psplit->pgnoNew3 == pgnoNull );

		psplit->pgnoNew3 = pcsr->pgno;
		err = ErrSPGetPage( pfucb, &psplit->pgnoNew3, fAppendPage );
		if ( err < 0 )
			{
			psplit->pgnoNew3 = pgnoNull;
			goto HandleError;
			}

		Assert( psplit->pgnoNew3 != psplit->pgnoNew2 &&
			psplit->pgnoNew3 != psplit->pgnoNew &&
			psplit->pgnoNew3 != psplit->pgnoSplit );
		}

	/*	space management may have caused indirect recursion of
	/*	split an already split this page.  Check if split of this
	/*	page still required.  Must adjust cbReq for artificial space
	/*	savings as a result of get page deleting a space extent.  Free
	/*	extent would consume same space.
	/**/

	/*	csr may have been changed adjust (by MCM) during GetPage.
	 */
	if ( pcsr->pgno != psplit->pgnoSplit )
		{
		err = ErrERRCheck( errDIRNotSynchronous );
		goto ReleasePages;
		}
		
	if ( !( FBFReadAccessPage( pfucb, pcsr->pgno ) ) )
		{
		Call( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
		}

	
	if ( !( ( ( fDIRFlags & fDIRReplace ) ? 0 :
		FBTAppendPage( pfucb, pcsr, cbReq, cbSPExt, CbFreeDensity( pfucb ), 2 ) ) ||
		FBTSplit( pssib, cbReq + cbSPExt, 2 ) ) )
		{
ReleasePages:
		/*	release page and done
		/**/
		Call( ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew, 1 ) );
		psplit->pgnoNew = pgnoNull;
		
		if ( psplit->splitt == splittDoubleVertical )
			{
			Call( ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew2, 1 ) );
			psplit->pgnoNew2 = pgnoNull;
			Call( ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew3, 1 ) );
			psplit->pgnoNew3 = pgnoNull;
			}

		/*	the following assert is invalid since another thread could
		/*	modify the page during loss of critJet during free space.
		/*	This is naturally handled by retry.
		/**/
//		Assert( !( ( fDIRFlags & fDIRReplace ) ? 0 : FBTAppendPage( pfucb, pcsr, cbReq, cbSPExt, CbFreeDensity(pfucb), 1 ) ) ||
//			FBTSplit( pssib, cbReq + cbSPExt, 1 ) );
		goto HandleError;
		}

	/*	store intial state of FUCB for restoration after split node
	/*	movement and before split MCM.  Note, that we can cache CSR
	/*	only because we are inside critSplit and bookmark clean up
	/*	is prevented.
	/*
	/*	Be careful to cache CSR after space management requests, since
	/*	they may cause CSR to change via MCM.
	/**/
	fSplit = fTrue;

	/*	access new page with pgtyp and pgnoFDP
	/**/
	Assert( !( psplit->pgnoSplit == pgnoSystemRoot  &&  psplit->itagSplit == itagSystemRoot ) );
	if ( ( psplit->splitt == splittVertical  ||
		psplit->splitt == splittDoubleVertical )  &&
		psplit->pgnoSplit == pfucb->u.pfcb->pgnoFDP  &&
		psplit->itagSplit == itagDATA )
		{
		pgtyp = ( FFUCBNonClustered( pfucb ) || pfucb->u.pfcb->pfcbTable != pfcbNil ?
					pgtypIndexNC : pgtypRecord );
		}
	else
		{
		pgtyp = PMPageTypeOfPage( pssib->pbf->ppage );
		}

	Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew ) );
	pssibNew = &pfucbNew->ssib;
	SetupSSIB( pssibNew, pfucb->ppib );
	SSIBSetDbid( pssibNew, pfucb->dbid );

	if ( psplit->splitt == splittDoubleVertical )
		{
		/*	allocate additional cursor
		/**/
		Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew2 ) );
		pssibNew2 = &pfucbNew2->ssib;
		SetupSSIB( pssibNew2, pfucb->ppib );
		SSIBSetDbid( pssibNew2, pfucb->dbid );

		Call( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, 0, &pfucbNew3 ) );
		pssibNew3 = &pfucbNew3->ssib;
		SetupSSIB( pssibNew3, pfucb->ppib );
		SSIBSetDbid( pssibNew3, pfucb->dbid );
		}

	/*  Access new page, and set it up. Then latch the new page.
	/*  Also set up the buffer dependency between the two pages.
	/**/
	Call( ErrBTSetUpSplitPages( pfucb, pfucbNew, pfucbNew2, pfucbNew3, psplit, pgtyp, fAppend, fFalse ) );

	/******************************************************
	/*	select split again. psplit may be changed by space manager.
	/**/
	splittOrig = psplit->splitt;
	itagSplitOrig = psplit->itagSplit;

	Call( ErrBTSelectSplit( pfucb, pcsr, pssib, keySplit, cbNode, cbReq,
		fAppendPage, ( fDIRFlags & fDIRAppendItem ), psplit, &fAppend ) );

	if ( psplit->splitt != splittOrig  ||  psplit->itagSplit != itagSplitOrig )
		{
		if ( splittOrig == splittDoubleVertical )
			fCleanupDoubleVerticalSplit = fTrue;
			
		/* return to caller and retry
		/**/
		goto HandleError;
		}

	/* preallocate CSR resources
	/**/
	if ( psplit->splitt == splittVertical )
		ipcsrMac = 2;
	else if ( psplit->splitt == splittDoubleVertical )
		ipcsrMac = 4;
	else
		ipcsrMac = 0;

	Assert( psplit->ipcsrMac == 0 );
	if ( ipcsrMac )
		{
		for ( ipcsr = 0; ipcsr < ipcsrMac; ipcsr++ )
			{
			Call( ErrFUCBAllocCSR( &psplit->rgpcsr[ipcsr] ) );
			psplit->ipcsrMac++;
			}
		}

#ifdef	DEBUGGING
	cTrack++;
	Assert( cTrack == 1 );
#endif
	/******************************************************
	/*	perform split
	/**/

	switch ( psplit->splitt )
		{
		case splittVertical:
			{
			/*	set new page type and pgnoFDP
			/*	cache split node son table
			/*	move sons
			/*	update split node
			/*	insert page pointer in split page to new page
			/*	vertical split MCM
			/**/
			Call( ErrBTSplitVMoveNodes( pfucb, pfucbNew, psplit, pcsr, rgb, fAllocBufOnly ) );

			/*	while allocating buffers, page may have changed and if
			/*	less space than min vsplit, terminate split and retry
			/**/
			if ( !FNDFreePageSpace( pssib, cbFirstPagePointer ) )
				{
				NDGet( pfucb, psplit->itagSplit );
				if ( !FNDSon( *(pfucb->ssib.line.pb) ) )
					{
					Error( ErrERRCheck( errDIRNotSynchronous ), HandleError );
					}
				}

			LgHoldCriticalSection( critJet );
			PMDirty( &pfucb->ssib );
			PMDirty( &pfucbNew->ssib );
			err = ErrBTSplitVMoveNodes( pfucb, pfucbNew, psplit, pcsr, rgb, fDoMove );
			LgReleaseCriticalSection( critJet );
			Call( err );


			/*	vertical split MCM
			/**/
			MCMVerticalPageSplit( pfucb,
				(BYTE *)(psplit->mpitag),
				psplit->pgnoSplit,
				psplit->itagSplit,
				psplit->pgnoNew,
				psplit );

//			BTCheckSplit( pfucbNew, PcsrCurrent( pfucb ) );

			Call( ErrLGSplit( splittVertical, pfucb, pcsrNil, psplit, pgtyp ) );

			cBTSplits++;

			break;
			}

		case splittDoubleVertical:
			{
			/*	set new page type and pgnoFDP
			/*	cache split node son table
			/*	move sons
			/*	update split node
			/*	insert page pointer in split page to new page
			/*	vertical split MCM
			/**/
			Call( ErrBTSplitDoubleVMoveNodes(
				pfucb, pfucbNew, pfucbNew2, pfucbNew3,
				psplit, pcsr, rgb, fAllocBufOnly ) );

			LgHoldCriticalSection( critJet );
			PMDirty( &pfucb->ssib );
			PMDirty( &pfucbNew->ssib );
			PMDirty( &pfucbNew2->ssib );
			PMDirty( &pfucbNew3->ssib );
			err = ErrBTSplitDoubleVMoveNodes(
				pfucb, pfucbNew, pfucbNew2, pfucbNew3,
				psplit, pcsr, rgb, fDoMove );
			LgReleaseCriticalSection( critJet );
			Call( err );

			/*	vertical split MCM
			/**/
			MCMDoubleVerticalPageSplit( pfucb,
				(BYTE *)psplit->mpitag,
				psplit->pgnoSplit,
				psplit->itagSplit,
				psplit->ibSon,
				psplit->pgnoNew,
				psplit->pgnoNew2,
				psplit->pgnoNew3,
				psplit );

			Call( ErrLGSplit( splittDoubleVertical, pfucb, pcsrNil, psplit, pgtyp ) );

			cBTSplits++;

			break;
			}

		default:
			{
			CSR		csrPagePointerSave;
			CSR		*pcsrPagePointer;
			BOOL	fSplitLeft;

			if ( psplit->splitt == splittLeft )
				{
				fSplitLeft = fTrue;
				}
			else
				{
				Assert( psplit->splitt == splittRight ||
						psplit->splitt == splittAppend );
				fSplitLeft = fFalse;
				}

			/*	check if sons of split page are visible
			/*	move sons
			/*	update new FOP
			/*	update split FOP
			/*	correct page links
			/**/

			/*  allocate buffers that will be used in adjusting back links.
			/*  Do not do the realy move yet.
			/**/
			Call( ErrBTSplitHMoveNodes( pfucb, pfucbNew, psplit, rgb, fAllocBufOnly));
#ifdef	DEBUGGING
			cTrack++;
			Assert( cTrack == 2 );
#endif

			Call( ErrBTPrepareCorrectLinks( psplit, pfucb, pssib, pssibNew ) );

#ifdef	DEBUGGING
			cTrack++;
			Assert( cTrack == 3 );
#endif
			/*	add new page pointer node to parent page
			/*		set pcsrPagePointer to first CSR above
			/*	   	FOP CSR
			/*		split parent page is not enough space/tags
			/*		add page pointer node
			/*		add son to parent node
			/**/
			Call( ErrBTPrepareInsertParentPage(
				pfucb,
				pcsr,
				pcsrRoot,
				&pcsrPagePointer,
				psplit ) );

#ifdef	DEBUGGING
			cTrack++;
			Assert( cTrack == 4 );
#endif
			/*  do the real move here
			/**/
			LgHoldCriticalSection( critJet );
			Call( ErrBFWriteAccessPage( pfucb, psplit->pgnoSplit ) );
			PMDirty( &pfucb->ssib );
			PMDirty( &pfucbNew->ssib );
			CallS( ErrBTSplitHMoveNodes( pfucb, pfucbNew, psplit, rgb, fDoMove));
			LgReleaseCriticalSection( critJet );

			Assert( pssib == &pfucb->ssib );
			Assert( pssibNew == &pfucbNew->ssib );
			BTCorrectLinks( psplit, pfucb, pssib, pssibNew );

			/*	left split MCM
			/**/
			if ( fSplitLeft )
				{
				MCMLeftHorizontalPageSplit(
					pfucb,
					psplit->pgnoSplit,
					psplit->pgnoNew,
					psplit->ibSon,
					(BYTE *)psplit->mpitag );
				}
			else
				{
				MCMRightHorizontalPageSplit(
					pfucb,
					psplit->pgnoSplit,
					psplit->pgnoNew,
					psplit->ibSon,
					(BYTE *)psplit->mpitag );
				}

			/*	at this point there is sufficient space/tags in the father
			/*	page to allow the page pointer node to be inserted since
			/*  there can be only one split occurs.
			/**/

			/*   pcsrPagePointer's itag may be bursted, save it.
			/**/
			csrPagePointerSave = *pcsrPagePointer;
			Call( ErrBTInsertPagePointer( pfucb, pcsrPagePointer, psplit, rgb));

#ifdef	DEBUGGING
			cTrack++;
			Assert( cTrack == 5 );
#endif
			/*	log operation.  If append, then no need for dependency.
			/**/

			if ( fSplitLeft )
				{
				Call( ErrLGSplit( splittLeft, pfucb, &csrPagePointerSave, psplit, pgtyp) );
				
				cBTSplits++;
				}
			else
				{
				Assert( psplit->splitt == splittRight ||
						psplit->splitt == splittAppend );
				Call( ErrLGSplit( psplit->splitt,
					pfucb,
					&csrPagePointerSave,
					psplit,
					pgtyp ) );

				if ( psplit->splitt == splittAppend )
					cBTAppends++;
				else
					cBTSplits++;
				}

			/*	check page key order
			/**/
			BTCheckSplit( pfucb, pcsrPagePointer );

			break;
			}
		}

		{
		BF *pbfT = psplit->pbfSplit;
		DBHDRIncDBTime( rgfmp[ DbidOfPn( pbfT->pn ) ].pdbfilehdr );
		PMSetDBTime( pbfT->ppage, QwDBHDRDBTime( rgfmp[ DbidOfPn( pbfT->pn ) ].pdbfilehdr ) );
		}

#ifdef DEBUG
	if ( !fRecovering )
		{
		SSIB ssibT = pfucb->ssib;
		ssibT.pbf = psplit->pbfSplit;

		(VOID) ErrLGCheckPage2( pfucb->ppib, ssibT.pbf,
				ssibT.pbf->ppage->cbFree,
				ssibT.pbf->ppage->cbUncommittedFreed,
				(SHORT)ItagPMQueryNextItag( &ssibT ),
				ssibT.pbf->ppage->pgnoFDP );
	
		ssibT.pbf = psplit->pbfNew;
		(VOID) ErrLGCheckPage2( pfucb->ppib, ssibT.pbf,
				ssibT.pbf->ppage->cbFree,
				ssibT.pbf->ppage->cbUncommittedFreed,
				(SHORT)ItagPMQueryNextItag( &ssibT ),
				ssibT.pbf->ppage->pgnoFDP );

		if ( psplit->pbfNew2 )
			{
			ssibT.pbf = psplit->pbfNew2;
			(VOID) ErrLGCheckPage2( pfucb->ppib, ssibT.pbf,
				ssibT.pbf->ppage->cbFree,
				ssibT.pbf->ppage->cbUncommittedFreed,
				(SHORT)ItagPMQueryNextItag( &ssibT ),
				ssibT.pbf->ppage->pgnoFDP );
			}
		if ( psplit->pbfNew3 )
			{
			ssibT.pbf = psplit->pbfNew3;
			(VOID) ErrLGCheckPage2( pfucb->ppib, ssibT.pbf,
				ssibT.pbf->ppage->cbFree,
				ssibT.pbf->ppage->cbUncommittedFreed,
				(SHORT)ItagPMQueryNextItag( &ssibT ),
				ssibT.pbf->ppage->pgnoFDP );
			}
		if ( psplit->pbfPagePtr )
			{
			ssibT.pbf = psplit->pbfPagePtr;
			(VOID) ErrLGCheckPage2( pfucb->ppib, ssibT.pbf,
				ssibT.pbf->ppage->cbFree,
				ssibT.pbf->ppage->cbUncommittedFreed,
				(SHORT)ItagPMQueryNextItag( &ssibT ),
				ssibT.pbf->ppage->pgnoFDP );
			}
		if ( psplit->pbfSibling )
			{
			ssibT.pbf = psplit->pbfSibling;
			(VOID) ErrLGCheckPage2( pfucb->ppib, ssibT.pbf,
				ssibT.pbf->ppage->cbFree,
				ssibT.pbf->ppage->cbUncommittedFreed,
				(SHORT)ItagPMQueryNextItag( &ssibT ),
				ssibT.pbf->ppage->pgnoFDP );
			}
		}
#endif

	/*	setup physical currency for output
	/**/
	if ( !( FBFReadAccessPage( pfucb, pcsr->pgno ) ) )
		{
		Call( ErrBFWriteAccessPage( pfucb, pcsr->pgno ) );
		}

	/*	check page key order
	/**/
	BTCheckSplit( pfucb, pcsr->pcsrPath );

	if ( fRecovering )
		{
		goto EndOfMPLRegister;
		}

	if ( psplit->fLeaf )
		{
		if ( psplit->splitt == splittDoubleVertical )
			{
			MPLRegister( pfucbNew2->u.pfcb,
				pssibNew2,
				PnOfDbidPgno( pfucbNew2->dbid, psplit->pgnoNew2 ),
				pfucbNew2->sridFather );
			MPLRegister( pfucbNew3->u.pfcb,
				pssibNew3,
				PnOfDbidPgno( pfucbNew3->dbid, psplit->pgnoNew3 ),
				pfucbNew3->sridFather );
			}
		else
			{
			if ( !fAppend )
				{
				MPLRegister( pfucbNew->u.pfcb,
							 pssibNew,
							 PnOfDbidPgno( pfucbNew->dbid, psplit->pgnoNew ),
							 pfucbNew->sridFather );
				}
			pfucb->u.pfcb->olc_data.cDiscont +=
				pgdiscont( psplit->pgnoNew, psplit->pgnoSplit )
				+ pgdiscont( psplit->pgnoNew, psplit->pgnoSibling )
				- pgdiscont( psplit->pgnoSplit, psplit->pgnoSibling );
			}
		}

EndOfMPLRegister:

HandleError:
	#ifdef SPLIT_TRACE
		PrintF2( "Split............................... %d\n", iSplit++);
		switch ( psplit->splitt )
			{
			case splittNull:
				PrintF2( "split split type = null\n" );
				break;
			case splittVertical:
				PrintF2( "split split type = vertical\n" );
				break;
			case splittRight:
				if	( fAppend )
					PrintF2( "split split type = Append\n" );
				else
					PrintF2( "split split type = right\n" );
				break;
			case splittLeft:
				PrintF2( "split split type = left\n" );
			};
		PrintF2( "split page = %lu\n", psplit->pgnoSplit );
		PrintF2( "dbid = %u\n", psplit->dbid );
		PrintF2( "fFDP = %d\n", psplit->fFDP );
		PrintF2( "fLeaf = %d\n", psplit->fLeaf );
		PrintF2( "split itag = %d\n", psplit->itagSplit );
		PrintF2( "split ibSon = %d\n", psplit->ibSon );
		PrintF2( "new page = %lu\n", psplit->pgnoNew );
		PrintF2( "\n" );
	#endif

	/*	release split resources
	/**/
	if ( fCleanupDoubleVerticalSplit || err < 0 )
		{
		if ( psplit->pgnoNew != pgnoNull )
			{
#ifdef DEBUGGING
			if ( psplit->pbfSplit != pbfNil )
				{			
				PGNO 	pgnoNextT, pgnoPrevT;
				
				LFromThreeBytes( &pgnoNextT, &psplit->pbfSplit->ppage->pgnoNext );
				LFromThreeBytes( &pgnoPrevT, &psplit->pbfSplit->ppage->pgnoPrev );
				Assert( pgnoNextT != psplit->pgnoNew );
				Assert( pgnoPrevT != psplit->pgnoNew );
				}
#endif
			if ( psplit->pbfNew )
				{
				BFResetWriteLatch( psplit->pbfNew, psplit->ppib );
				BFUndepend( psplit->pbfNew );
				BFResetDirtyBit( psplit->pbfNew );
				BFAbandon( psplit->ppib, psplit->pbfNew );
				psplit->pbfNew = pbfNil;
				}
			(VOID)ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew, 1 );
			psplit->pgnoNew = pgnoNull;
			}
		
		if ( psplit->pgnoNew2 != pgnoNull )
			{
			if ( psplit->pbfNew2 )
				{
				BFResetWriteLatch( psplit->pbfNew2, psplit->ppib );
				BFUndepend( psplit->pbfNew2 );
				BFResetDirtyBit( psplit->pbfNew2 );
				BFAbandon( psplit->ppib, psplit->pbfNew2 );
				psplit->pbfNew2 = pbfNil;
				}
			(VOID)ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew2, 1 );
			psplit->pgnoNew2 = pgnoNull;
			}

		if ( psplit->pgnoNew3 != pgnoNull )
			{
			if ( psplit->pbfNew3 )
				{
				BFResetWriteLatch( psplit->pbfNew3, psplit->ppib );
				BFUndepend( psplit->pbfNew3 );
				BFResetDirtyBit( psplit->pbfNew3 );
				BFAbandon( psplit->ppib, psplit->pbfNew3 );
				psplit->pbfNew3 = pbfNil;
				}
			(VOID)ErrSPFreeExt( pfucb, pfucb->u.pfcb->pgnoFDP, psplit->pgnoNew3, 1 );
			psplit->pgnoNew3 = pgnoNull;
			}
		}
		
	//	UNDONE:	this is a hack to fix empty page
	//			unknown key space bug
	/*	if split 0 nodes to new page, i.e. empty page, then
	/*	flag FUCB as owning empty page for its next insert.
	/*	Note if FUCB is already owner of empty page then this
	/*	must not be leaf page, so do not make FUCB owner.
	/**/
	if ( err >= 0 &&
		psplit->rgbSonNew[0] == 0 &&
		psplit->fLeaf &&
		pfucb->pbfEmpty == pbfNil &&
		psplit->pbfNew != pbfNil )
		{
#ifdef DEBUG
		cbfEmpty++;
#endif
		Assert( ( fDIRFlags & fDIRReplace ) == 0 );
		pfucb->pbfEmpty = psplit->pbfNew;
		BFSetWriteLatch( pfucb->pbfEmpty, pfucb->ppib );
		}

	Assert( psplit != NULL );
	BTReleaseSplitBfs( fFalse, psplit, err );

	if ( pfucbNew != pfucbNil )
		DIRClose( pfucbNew );
	if ( pfucbNew2 != pfucbNil )
		DIRClose( pfucbNew2 );
	if ( pfucbNew3 != pfucbNil )
		DIRClose( pfucbNew3 );

	/* release the left unused CSR
	/**/
	for ( ipcsr = 0; ipcsr < psplit->ipcsrMac; ipcsr++ )
		{
		MEMReleasePcsr( psplit->rgpcsr[ipcsr] );
		}

	SFree( psplit );

	Assert( err != errDIRCannotSplit );

	return err;
	}


//+private--------------------------------------------------------------------
//
//	ErrBTSelectSplit
//	==========================================================================
//
//	LOCAL ERR ErrBTSelectSplit( FUCB *pfucb, CSR *pcsr, SSIB *pssib,
//		KEY key, INT cbReq, BOOL fAppendPage, BOOL fAppendItem, SPLIT *psplit, BOOL *pfAppend )
//
//	PARAMETERS
//
//	pfucb  		pointer to fucb of split requester, split along CSR stack
//	pcsr   		pointer to node below split location, i.e. pointer to node
//		   		being enlarged causing split.  Siblings of pcsr are moved.
//	key			key of node enlarged or inserted causing split
//	splitinfo 	split information output
//----------------------------------------------------------------------------

	LOCAL ERR
ErrBTSelectSplit(
	FUCB	*pfucb,
	CSR  	*pcsr,
	SSIB	*pssib,
	KEY  	key,
	INT  	cbNode,
	INT  	cbReq,
	BOOL	fAppendPage,
	BOOL	fAppendItem,
	SPLIT	*psplit,
	BOOL	*pfAppend )
	{
	BOOL	fFreeTag = FPMFreeTag( pssib, 1 );
	INT  	cbFreeSpace = CbNDFreePageSpace( pssib->pbf );
	BOOL	fFatherHasSons;

	Assert( psplit->op == opInsert || psplit->op == opReplace );

	/*	initialize variables
	/**/
	psplit->splitt = splittNull;
	psplit->key.pb = pbNil;
	psplit->key.cb = 0;
	psplit->itagSplit = 0;
	psplit->ibSon = 0;
	psplit->fLeaf = fFalse;

	/*	determine if split page is FDP.  Space management pfucbs
	/*	do not have pfcbs set.
	/**/
	psplit->fFDP = ( pcsr->pgno == pfucb->u.pfcb->pgnoFDP ||
		pcsr->csrstat == csrstatOnFDPNode );

	/*	get father node
	/**/
	NDGet( pfucb, pcsr->itagFather );

	fFatherHasSons = FNDSon( *(pfucb->ssib.line.pb) );

//	UNDONE:
//		this code is a patch to handle the case where the only V split
//		is of an empty tree above the insert.  However, this patch
//		will split the DATA node which is currently fixed, so it disable
//		for FDPs except where father is Ownext, Availext or DATA.  Fix this
//		patch by making DATA node movable.

//	UNDONE:	must esitmate size of parent and parent sibling nodes to infer
//			limits of H-split and V-split when H-split cannot free space
//			required by node and requirement.
	if ( pcsr->itagFather != itagFOP &&
		 ( fFatherHasSons || ( cbFreeSpace > cbFirstPagePointer ) ) )
		{
SplitFather:
		Assert( FNDIntrinsicSons( pfucb->ssib.line.pb ) ||
			fFatherHasSons ||
			cbFreeSpace > cbFirstPagePointer );
		psplit->itagSplit = pcsr->itagFather;
		psplit->splitt = splittVertical;

		/*	if space required is greater than page, then
		/*	double vertical split.  Call BTVSplit to get weight.
		/**/
	 	BTVSplit( pfucb, pcsr->itagFather, cbReq, fTrue );

		if ( cbVSplit > cbAvailMost )
			{
			INT		ibSon = pcsr->ibSon;
			KEY		keyT;

			/*	check division point
			/**/
			keyT = key;
			BTDoubleVSplit( pfucb, psplit->itagSplit, cbReq, cbVSplit, &ibSon, &keyT );

			psplit->splitt = splittDoubleVertical;
			Assert( psplit->itagSplit == pcsr->itagFather );
			psplit->ibSon = ibSon;
			psplit->key.cb = keyT.cb;
			psplit->key.pb = psplit->rgbKey;
			memcpy( psplit->rgbKey, keyT.pb, keyT.cb );
			}
		}
	else
		{
		/*	try any split in page
		/**/
		BTVSplit( pfucb, itagFOP, cbReq, fFalse );

		/*	if pssib->itag is root or benefit of vertical split is
		/*	zero, no benefit from veritcal split.
		/*	Since FDP cannot be horizontally split, if fFDP
		/*	cannot split this page.
		/**/
		if ( itagVSplit != itagFOP && ( cbVSplit > cbVSplitMin || psplit->fFDP && cbVSplit != 0 ) )
			{
			/*	vertical split
			/**/
			if ( cbVSplit > cbAvailMost )
				{
				INT		ibSon = pcsr->ibSon;
				KEY		keyT;

				Assert( clineVSplit > 1 );

				/*	check division point
				/**/
				keyT = key;
				BTDoubleVSplit( pfucb, itagVSplit, cbReq, cbVSplit, &ibSon, &keyT );
				psplit->splitt = splittDoubleVertical;
				psplit->itagSplit = itagVSplit;
				psplit->ibSon = ibSon;
				psplit->key.cb = keyT.cb;
				psplit->key.pb = psplit->rgbKey;
				memcpy( psplit->rgbKey, keyT.pb, keyT.cb );
				}
			else
				{
				psplit->splitt = splittVertical;
				psplit->itagSplit = itagVSplit;
				Assert( itagVSplit != itagFOP );
				psplit->key.pb = pbNil;
				psplit->key.cb = 0;
				}
			}
		else
			{
			INT		ibSon;
			KEY		keyMac;
			KEY		keyT;
			BOOL	fRight;
			CSR		*pcsrT;
			
#ifdef DEBUG
			BOOL	fVisibleSons;
			INT		cbSon;
#endif

			/*	choose ibSon of the son of FOP
			/**/
			for ( pcsrT = pcsr; pcsrT != pcsrNil; pcsrT = pcsrT->pcsrPath )
				{
				if ( pcsrT->itagFather == itagFOP )
					{
					ibSon = pcsrT->ibSon;
					break;
					}
				}

			Assert( psplit->op == opInsert || psplit->op == opReplace );

			/*	if no part of CSR stack has itagFOP as father, then we
			/*	must split father node.
			/**/
			/*	if page is FDP or non-FDP with fixed nodes resulting
			/*	in no benneficial vertical split, return error cannot
			/*	split.
			/**/
			if ( pcsrT == pcsrNil || psplit->fFDP )
				{
				/*	if we are going to split the father, then the
				/*	father should not be the father of page.  This
				/*	is especially true if the pscrT == pcsrNil which
				/*	indicates that no CSR had an FOP father.
				/**/
				Assert( pcsr->itagFather != itagFOP );
				NDGet( pfucb, pcsr->itagFather );
				goto SplitFather;
				}

			/*	horizontal split
			/**/
			keyT = key;
#ifdef DEBUG		// Debug code to aid debugging of appending of invisible sons
			NDGet( pfucb, itagFOP );
			fVisibleSons = FNDVisibleSons( *( pfucb->ssib.line.pb ) );
			Assert( !FNDNullSon( *( pfucb->ssib.line.pb ) ) );
			cbSon = CbNDSon( pfucb->ssib.line.pb );
#endif
				
			BTHSplit( pfucb, cbReq, fAppendPage, psplit->op == opReplace, fAppendItem,
		  		&ibSon, &keyMac, &keyT, &fRight, pfAppend, psplit );

#ifdef DEBUG		// Debug code to aid debugging of appending of invisible sons
			if ( !fVisibleSons )
				{
				Assert( !(*pfAppend) );
				Assert( fAppendPage ? ibSon == cbSon - 1 : ibSon < cbSon );
				}
#endif

			if ( *pfAppend )
				{
				Assert( fRight );
				psplit->splitt = splittAppend;
				}
			else
				psplit->splitt = fRight ? splittRight : splittLeft;

			psplit->itagSplit = itagFOP;
			psplit->ibSon = ibSon;

			/*	store split key, key for new page
			/**/
			psplit->key.cb = keyT.cb;
			psplit->key.pb = psplit->rgbKey;
			memcpy( psplit->rgbKey, keyT.pb, keyT.cb );

			/*	store new key for page being split
			/**/
			psplit->keyMac.cb = keyMac.cb;
			psplit->keyMac.pb = psplit->rgbkeyMac;
			memcpy( psplit->rgbkeyMac, keyMac.pb, keyMac.cb );
			}
		}

	pssib->itag = psplit->itagSplit;
	PMGet( pssib, pssib->itag );

#ifdef DEBUG
	{
	BYTE *pbSon = PbNDSonTable( pssib->line.pb );
	INT cbSon = CbNDSonTable( pbSon );
	if ( psplit->splitt == splittAppend )
		{
		if ( FNDVisibleSons( *pssib->line.pb ) )
			{
			Assert( psplit->ibSon == cbSon );
			}
		else
			{
			// On appends of invisible sons, we always take the last one with us.
			Assert( psplit->ibSon == cbSon - 1 );
			}
		}
	}
#endif

	return JET_errSuccess;
	}


//+private----------------------------------------------------------------------
//
//	BTVSplit
//	============================================================================
//
//	LOCAL VOID BTVSplit( FUCB *pfucb, INT itag, INT cbReq )
//
//	PARAMETERS
//
//	Selects a node to vertically split.  Search begins at
//	itag.  By initializing *pf to fFalse, starting
//	node candidate is disqualified.  Fixed nodes disqualify
//	parent and ancestor nodes.
//
//	Select node with largest weight of children ( not including
//	weight of node ) to vertical split, i.e. large nodes with no
//	sons have weight of 0.
//
//	itag	candidate splittable node
//	*pf == fTrue if candidate splittable.  Will be false
//		if fixed node descendant.
//	*pcb is number of bytes freed as a result of the split
//
//------------------------------------------------------------------------------
LOCAL VOID BTVSplit( FUCB *pfucb, INT itag, INT cbReq, BOOL fSummingUp )
	{
	INT	 	cbT;
	INT  	clineT;

	//	UNDONE:	move these into split structure
	/*	reset output variables.
	/**/
	itagVSplit = itagFOP;
	cbVSplit = 0;
	clineVSplit = 0;
	clineVSplitTotal = 0;

	/*	cache root node.
	/**/
	NDGet( pfucb, itag );

	BTIVSplit( pfucb, itag, cbReq, &cbT, &clineT, fSummingUp );

	return;
	}


/*	this function return implicit parameters: itagVSplit, cbVSplit, clineVSplit,
 *	and clineVSplitTotal.
 */
LOCAL VOID BTIVSplit(
	FUCB *pfucb,
	INT itag,			/* starting node of vertical split search */
	INT cbReq,
	INT *pcb,			/* total weight of the subtree, exclude the search node itself */
	INT *pclineTotal,	/* total # of lines to move */
	BOOL fSummingUp		/* if this call is to get total weight of */
	)					/* the subtree including search node? */
	{
	SSIB   	*pssib = &pfucb->ssib;
	INT	  	cbThis = 0;
	INT	  	clineTotalThis = 0;
	BOOL   	fVisibleSons;
  	INT   	cbSon = 1;
	BYTE 	*pbSon;
	BYTE 	*pbSonMax;

	/*	assert current current node cached
	/**/
	AssertNDGet( pfucb, itag );

	fVisibleSons = FNDVisibleSons( *pssib->line.pb );

	/*	pssib must be set to current node
	/**/
	Assert( !( PgnoOfPn( pssib->pbf->pn ) == pgnoSystemRoot  &&  itag == itagSystemRoot ) );
	Assert( itag != itagFOP || FNDNonIntrinsicSons( pssib->line.pb ) );
	if ( FNDNonIntrinsicSons( pssib->line.pb ) )
		{
		pbSon = PbNDSonTable( pssib->line.pb );
		cbSon = CbNDSonTable( pbSon );
		pbSon++;
		pbSonMax = pbSon + cbSon;
		for( ;pbSon < pbSonMax; pbSon++ )
			{
			INT		itagT = (INT)*(BYTE *)pbSon;
			BOOL 	fT = fTrue;
			INT		cbT = 0;
			INT		clineT = 0;
			SRID	srid;

			NDGet( pfucb, itagT );

			/*	add the number of bytes required in the new page for son
			/*		node
			/*		tag
			/*		backlink if node is visible and does not already have one
			/**/
			cbThis += pssib->line.cb + sizeof(TAG);
			if ( fVisibleSons && !FNDBackLink( *pssib->line.pb ) )
				{
				cbThis += sizeof(SRID);
				srid = SridOfPgnoItag( PgnoOfPn( pssib->pbf->pn ), itagT );
				}
			else
				srid = *(SRID UNALIGNED *)PbNDBackLink(pssib->line.pb);

			/*	adjust weight for reserved space
			/**/
			if ( FNDVersion( *pssib->line.pb ) )
				{
				UINT	cbMax;

				cbMax = CbVERGetNodeMax( pfucb->dbid, srid );
				if ( cbMax > 0 && cbMax > CbNDData( pssib->line.pb, pssib->line.cb ) )
					cbThis += ( cbMax - CbNDData( pssib->line.pb, pssib->line.cb ) );
				}

			clineTotalThis++;
			BTIVSplit( pfucb, itagT, cbReq, &cbT, &clineT, fFalse );

			cbThis += cbT;
			clineTotalThis += clineT;
			}
		}

	/*	return information for this level of tree
	/**/
	*pcb = cbThis;
	*pclineTotal = clineTotalThis;

	/*	add weight of sons if split at this node
	/**/
	cbThis += cbSon;

	if ( fSummingUp )
		{
		/*	return total weight, including the search node's son table.
		 *	When fSummingUp is set, we are using the itagFather of the root of
		 *	the vertical split. We only need to know if the total weight too big
		 *	and need double vertical split.
		 */
		cbVSplit = cbThis;
		}
	/*	choose new split iff mobile and this is the first candidate
	/*	or if this is a subsequent candidate and it is
	/*	better than the previous by cbVSplitThreshold.
	/*
	/*	Note, only choose double vertical split if necessary to satisfy
	/*	requested space.  Selectively vertical split for better
	/*	utilization of intermediate page space.
	/**/
	else if ( itag != itagFOP &&
			  ( ( cbSon > 1 ) || ( cbThis <= cbAvailMost ) ) &&
			  ( ( ( cbThis <= cbAvailMost ) &&
			  	  ( cbThis > ( cbVSplit + ( cbVSplit == 0 ? 0 : cbVSplitThreshold ) ) ) ) ||
			  ( cbThis > cbReq && cbVSplit < cbReq ) ) )
		{
		Assert( itag != itagFOP );
		itagVSplit = itag;
		cbVSplit = cbThis;
		clineVSplit = cbSon;
		clineVSplitTotal = clineTotalThis;
		Assert( clineVSplit != 1 || cbVSplit <= cbAvailMost );
		}

	return;
	}


//+private----------------------------------------------------------------------
//
//	BTHSplit
//	============================================================================
//
//	LOCAL VOID BTHSplit( FUCB *pfucb, INT cbReq, BOOL fAppendPage,
//		BOOL fReplace, BOOL fAppendItem, INT *pibSon, KEY *pkeyMac, KEY *pkey,
//		BOOL *pf, BOOL *pfAppend )
//
//	Selects ri1ght or left horizontal split and location of split.
//
//	If required additional space greater than space currently used in
//	page, then split at key or node requiring additional space.
//	Otherwise, determine
//
//	Note, BTHSplit also supports the concept that an operation may
//	be and update ibSon - 1 and insert ibSon, as occurrs with
//	insertion of page pointer nodes.  This can be distinguished
//	when the page is not visible sons, and the selection algorithm is
//	adjusted not to split at ibSon.
//
//------------------------------------------------------------------------------
LOCAL VOID BTHSplit(
	FUCB   	*pfucb,
	INT		cbReq,
	BOOL   	fAppendPage,
	BOOL   	fReplace,
	BOOL   	fAppendItem,
	INT		*pibSon,
	KEY		*pkeyMac,
	KEY		*pkey,
	BOOL   	*pfRight,
	BOOL   	*pfAppend,
	SPLIT  	*psplit )
	{
	SSIB   	*pssib = &pfucb->ssib;
	INT		ibSon;
	BYTE   	*pbSon;
	BYTE   	*rgitagSon;
	BYTE   	*pbSonMax;
	INT		cbSon;
	INT		cbT;
	INT		ibSonT;
	INT		cbTotal = cbAvailMost - CbNDFreePageSpace( pssib->pbf ) - CbPMLinkSpace( pssib ) + cbReq;
	BOOL   	fInsertLeftPage;
	BOOL   	fVisibleSons;

	/*	set pbSon to point to first son and cbSon to number of sons
	/**/
	NDGet( pfucb, itagFOP );
	fVisibleSons = FNDVisibleSons( *pssib->line.pb );

	Assert ( CbNDSon(pssib->line.pb) != 0 );
	pbSon = PbNDSonTable( pssib->line.pb );
	cbSon = CbNDSonTable( pbSon );
	pbSon++;
	rgitagSon = pbSon;

	/*	get greatest key in page for new key for page pointer to this page
	/**/
	NDGet( pfucb, pbSon[cbSon - 1] );
	pkeyMac->pb = PbNDKey( pssib->line.pb );
	pkeyMac->cb = CbNDKey( pssib->line.pb );

	/************** SPECIAL CASE SPLITS ********************
	/*****/
	/*	append when updating last node in non-clustered index
	/**/
	if ( fAppendItem && ( *pibSon == cbSon - 1 ) )
		{
		/*	split right and move one node right for further item list insertion
		/**/
		*pfRight = fTrue;

		/*	get the right split key.  Since inserted node always
		/*	goes in new page, old page key pointer must come
		/*	from node in page.
		/**/
		if ( cbSon > 1 )
			{
			NDGet( pfucb, rgitagSon[*pibSon - 1] );
			pkey->pb = PbNDKey(pssib->line.pb);
			pkey->cb = CbNDKey(pssib->line.pb);
			}
		else
			{
			// UNDONE:  Should never get here if there's only one node on the
			// page.  Remove this case and add "Assert( cbSon > 1 )".
			Assert( fFalse );
			*pkey = *pkeyMac;
			}

		Assert( fVisibleSons );
		BTIStoreLeafSplitKey( psplit, pssib );
		*pfAppend = fFalse;
		return;
		}

	/*	append when no next page and inserting node at end of page
	/**/
	if ( fAppendPage )
		{
		/*	inserted nodes are ALWAYS inserted on new page, but replaced
		/*	nodes may or may not be moved.  If split is for replacement
		/*	then a child split of this split, may have a parent CSR that
		/*	will not move, but it must move to support the insertion of
		/*	the new page pointer node.  Thus, split avoids MCM
		/*	inconsistencies	by forcing the page pointer for current
		/*	page to be moved to the new page.
		/**/
		Assert( !fReplace );			// Append only on insert
		Assert( *pibSon == cbSon );		// Append only when at the end.
		*pfRight = fTrue;
		if ( fVisibleSons )
			{
			*pkey = *pkeyMac;
			*pfAppend = fTrue;
			BTIStoreLeafSplitKey( psplit, pssib );
			}
		else
			{
			/*	get the right split key.  Since inserted node always
			/*	goes in new page, old page key pointer must come
			/*	from node in page.
			/**/
			Assert( cbSon > 1 );
			NDGet( pfucb, rgitagSon[cbSon - 2] );
			pkey->pb = PbNDKey( pssib->line.pb );
			pkey->cb = CbNDKey( pssib->line.pb );
			if ( fVisibleSons )
				{
				BTIStoreLeafSplitKey( psplit, pssib );
				}

			// Treat the append as a right split, because we're bringing the current
			// page pointer with us to the new page.
			*pfAppend = fFalse;

			/*	adjust split point to keep current page pointer
			/*	on same page with inserted page pointer, since
			/*	both nodes must be modified and MCMed together.
			/**/
			Assert( *pibSon > 1 );
			(*pibSon)--;
			}
		return;
		}


	if ( fVisibleSons )
		{
		if ( fReplace )
			{
			if ( cbSon == 1 )
				{
				/*	only way to get here is if we're replacing single-node page
				/*  and page cannot hold node due to link overhead.  Split the only
				/*	node to the next page.
				/**/
				Assert( !FNDFreePageSpace( pssib, cbReq ) );
				*pfRight = fTrue;
				*pkey = *pkeyMac;
				BTIStoreLeafSplitKey( psplit, pssib );
				*pfAppend = fFalse;
				return;
				}
			}

		else	// !fReplace
			{
			if ( cbReq >- ( cbTotal / 2 ) )
				{
				if ( *pibSon == (INT)cbSon )
					{
					/*	append when inserting node larger than half of total space
					/*	at end of page, same effect as append page, except it is leaf only
					/**/
					*pfRight = fTrue;
					Assert( memcmp( pkey->pb, PbNDKey( pssib->line.pb ),
						min( CbNDKey( pssib->line.pb ), pkey->cb ) ) >= 0 );
					*pkey = *pkeyMac;
					BTIStoreLeafSplitKey( psplit, pssib );
					*pfAppend = fTrue;
					return;
					}

				else if ( *pibSon == 0 )
					{
					/*	prepend when inserting node larger than half of total space
					/*	at start of page.  Get split key from key of first node
					/*	on this page.  Note that the key of the inserted node cannot
					/*	be used as a result of the BT key conflict search algorithm!
					/*	NOTE: pkey is already set properly, i.e. to insert key
					/**/
					*pfRight = fFalse;
					Assert( memcmp( pkey->pb, PbNDKey( pssib->line.pb ),
						min( CbNDKey( pssib->line.pb ), pkey->cb ) ) < 0 );
					BTIStoreLeafSplitKey( psplit, pssib );
					*pibSon = ibSonNull;	// set to ibSonNull as a flag to move no nodes
					*pfAppend = fFalse;
					return;
					}
				}

			if ( cbSon == 1 )
				{
				/*	if only one node on page, and inserting before then prepend
				/**/
				Assert( memcmp( pkey->pb, pkeyMac->pb, min( pkey->cb, pkeyMac->cb ) ) < 0 );
				*pfRight = fFalse;
				*pibSon = ibSonNull;
				BTIStoreLeafSplitKey( psplit, pssib );
				*pfAppend = fFalse;
				return;
				}

			}	// !fReplace

		}	// fVisibleSons

	// All single-node pages should have been taken care of above.
	Assert( cbSon > 1 );


	/***************** COMMON CASE SPLITS ******************
	/*****/
	/*	select split point to have equal free space in both pages.
	/**/
	if ( !fReplace && *pibSon == cbSon )
		{
		pbSonMax = pbSon + cbSon + 1;
		}
	else
		{
		pbSonMax = pbSon + cbSon;
		}
	cbT = 0;
	fInsertLeftPage = fFalse;
	for ( ibSon = 0; pbSon < pbSonMax; ibSon++, pbSon++ )
		{
		/*	if traversing inserted/replaced node add cbReq
		/**/
		if ( ibSon == (INT)*pibSon )
			{
			cbT += cbReq;
			}

		if ( !fReplace && ibSon == cbSon )
			break;

		/*	if this is the inserting spot, then split on this ibSon, and
		/*	insert the new node into the left page.
		/**/
		if ( !fReplace && cbT >= ( cbTotal / 2 ) )
			{
			fInsertLeftPage = fTrue;
			break;
			}

		cbT += UsBTWeight( pfucb, (INT)*pbSon );
		if ( cbT >= ( cbTotal / 2 ) )
			break;
		}

	/*	if cannot select on size, i.e when no tags left,
	/*	then just split page into halves.
	/**/
	Assert( pbSon <= pbSonMax );
	if ( pbSon == pbSonMax )
		ibSon = cbSon / 2;

	Assert( cbSon > 1 );

	/*	regular rule for split right
	/**/
	if ( ( ibSon != 0 && *pibSon >= ibSon ) ||
		( ibSon == 0 && *pibSon > ibSon ) )
		{
		*pfRight = fTrue;
		if ( ibSon == 0 )
			ibSon++;

		/*	since we did not compute the space required in the right split,
		/*	compute the space from right most to ibSon, and shunt if greater
		/*	than available page space.
		/**/
		cbT = 0;
		for ( ibSonT = cbSon - 1; ibSonT > ibSon; ibSonT-- )
			{
			if ( ibSonT == (INT)*pibSon - 1 )
				cbT += cbReq;

			cbT += UsBTWeight( pfucb, (INT)rgitagSon[ibSonT] );
			if ( cbT > cbAvailMost )
				break;
			}
		if ( ibSonT > ibSon )
			ibSon = ibSonT;
		if ( !fVisibleSons && ibSon == *pibSon )
			{
			Assert( cbSon > 1 );
			/*	adjust split point to keep current page pointer
			/*	on same page with inserted page pointer, since
			/*	both nodes must be modified and MCMed together.
			/**/
			Assert( ibSon > 1 );
			ibSon--;
			}
		}
	else
		{
		/*	since splitting left is inclusive of ibSon, reduce ibSon by
		/*	one if splitting all nodes left.
		/**/
		if ( ibSon == cbSon - 1 )
			ibSon--;
		if ( !fVisibleSons && ibSon == *pibSon )
			{
			Assert( cbSon > 1 );
			/*	adjust split point to keep current page pointer
			/*	on same page with inserted page pointer, since
			/*	both nodes must be modified and MCMed together.
			/**/
			Assert( ibSon < cbSon - 2 );
			ibSon++;
			}

		*pfRight = fFalse;
		}

	/*	ensure that we do not split update and insert page pointer
	/*	nodes during recursive split, since both nodes must be
	/*	updated together.
	/**/
	Assert( fVisibleSons || ibSon != *pibSon );

	/*	choose split key
	/**/
	if ( *pfRight )
		{
		Assert( ibSon >= 1 && ibSon <= cbSon );
		/*	split empty right page for replace should never happen
		/*	so if ibSon == cbSon, and append, can not be for update.
		/**/
		Assert( ibSon != cbSon || !fReplace );

		/*	get the right split key.  Since inserted node always
		/*	goes in new page, old page key pointer must come
		/*	from node in page.
		/**/
		NDGet( pfucb, rgitagSon[ibSon - 1] );
		pkey->pb = PbNDKey(pssib->line.pb);
		pkey->cb = CbNDKey(pssib->line.pb);
		if ( fVisibleSons )
			{
			BTIStoreLeafSplitKey( psplit, pssib );
			}
		}
	else
		{
		/*	if prepend, move no nodes, then split key is key of
		/*	inserted node.  Otherwise, split key is key of last node
		/*	in new page.
		/**/
		if ( !fReplace
			&& ibSon == 0
			&& *pibSon == 0
			&& fInsertLeftPage )
			{
			ibSon = ibSonNull;
			}
		else
			{
			NDGet( pfucb, rgitagSon[ibSon] );
			pkey->pb = PbNDKey(pssib->line.pb);
			pkey->cb = CbNDKey(pssib->line.pb);
			}
		if ( fVisibleSons )
			{
			BTIStoreLeafSplitKey( psplit, pssib );
			}
		}

	*pibSon = ibSon;
	*pfAppend = fFalse;
	return;
	}


LOCAL VOID BTDoubleVSplit( FUCB *pfucb, INT itagSplit, INT cbReq, INT cbTotal, INT *pibSon, KEY *pkey )
	{
	SSIB	*pssib = &pfucb->ssib;
	INT		ibSon, ibSonCandidate;
	BYTE	*pbSon;
	BYTE	*pbSonCandidate;
	BYTE	*pbSonSplit;
	BYTE	*pbSonMax;
	INT		cbSon;
	INT		cb;
	BOOL	fOverflowLeftPage;

	/*	set pbSon to point to first son and cbSon to number of sons.
	/**/
	NDGet( pfucb, itagSplit );

	Assert( CbNDSon(pssib->line.pb) > 1 );
	pbSon = PbNDSonTable( pssib->line.pb );
	cbSon = CbNDSonTable( pbSon );
	pbSon++;
	pbSonSplit = pbSon;

	pbSonMax = pbSon + cbSon;
	cb = 0;
	for ( ibSon = 0; pbSon < pbSonMax; ibSon++, pbSon++ )
		{
		if ( ibSon == (INT)*pibSon )
			{
			// Optimisation: Try to avoid another split by choosing
			// a double-vertical split point that will also accommodate
			// the forthcoming insert/replace.
			Assert( cbReq <= cbAvailMost );
			cb += cbReq;
			}
		cb += UsBTWeight( pfucb, (INT)*pbSon );
		if ( cb >= ( cbTotal / 2 ) )
			break;
		}

	fOverflowLeftPage = ( cb > cbAvailMost );

	// If our split point will result in overflowing the left page,
	// then move the split point back one.  However, there's
	// a special case where we're inserting as the first son
	// (ie. *pibSon == 0 ), but no other nodes would fit on the page.
	// In this case, to avoid split anomalies, drag one son onto the
	// left page (ie. leave ibSon at 0) and move the rest of the sons
	// onto the right page.  A left-split will subsequently occur
	// on the left page when the node is actually inserted.
	Assert( !fOverflowLeftPage
		|| ibSon > 0
		|| *pibSon == 0 );

	Assert( ibSon < cbSon );
	if ( ibSon >= cbSon - 1
		|| ( fOverflowLeftPage && ibSon > 0 ) )
		{
		ibSon--;
		}
	ibSonCandidate = ibSon;
	Assert( ibSonCandidate >= 0 );

	/*	check if the total weight of moved sons are too much.
	 *	We need this checking just like HSplit. If request is too big (4k), typically
	 *	we will do 2 contigous split. First one is this double vertical split on a fixed
	 *	node, and then a vertical split. If cbRequest (4k) is too big, then ib derived
	 *	above is most likely bogus. So let's check the moved node.
	 */
	pbSonCandidate = pbSon;
	cb = 0;
	for ( ibSon = cbSon - 1, pbSon = pbSonMax - 1; pbSon > pbSonCandidate; ibSon--, pbSon-- )
		{
		// NOTE: Ignore the space required by the node to be
		// inserted/replaced.  If we have to, we'll horizontally
		// split later on to accommodate it.

		cb += UsBTWeight( pfucb, (INT)*pbSon );
		if ( cb > cbAvailMost )
			break;
		}

	if ( pbSon > pbSonCandidate )
		{
		/*	too much moved right.
		 */
		ibSonCandidate = ibSon;
		}

	/*	at least move one node to right.
	 */
	Assert( ibSonCandidate < cbSon - 1 );

#ifdef DEBUG
	// Verify the sons moved to the left page will fit.  For this check,
	// we disregard the node to be inserted/replaced, because in the
	// worst case, we will simply split again to accommodate the update.
	cb = 0;
	pbSon = pbSonSplit;
	for ( ibSon = 0; ibSon <= ibSonCandidate; ibSon++, pbSon++ )
		{
		// NOTE: Ignore the space required by the node to be
		// inserted/replaced.  If we have to, we'll horizontally
		// split later on to accommodate it.

		Assert( pbSon < pbSonMax );
		cb += UsBTWeight( pfucb, (INT)*pbSon );
		Assert( cb <= cbAvailMost );
		}
#endif

	NDGet( pfucb, pbSonSplit[ ibSonCandidate ] );
	pkey->pb = PbNDKey(pssib->line.pb);
	pkey->cb = CbNDKey(pssib->line.pb);

	/*	set return split ibSon
	/**/
	*pibSon = ibSonCandidate;
	return;
	}


//+private----------------------------------------------------------------------
//
//	UsBTWeight
//	============================================================================
//
//	LOCAL ULONG UsBTWeight( FUCB *pfucb, INT itag )
//
//	Only used for horizontal split.
//	Recursively calculates weight, i.e space freed by moving node and
//	node descendants.
//
//------------------------------------------------------------------------------
LOCAL ULONG UsBTWeight( FUCB *pfucb, INT itag )
	{
	SSIB   	*pssib = &pfucb->ssib;
	BYTE   	*pbSon;
	INT		cbSon;
	INT		ibSon;
	ULONG  	cbWeight;
	SRID	srid;

	/*	keep SSIB in ssync with current tag for bookmark computation
	/**/
	pssib->itag = itag;

	NDGet( pfucb, itag );

	/*	total length is data length + tag size + son entry + backlink
	/**/
	cbWeight = pssib->line.cb + sizeof(TAG) + 1;
	if ( !FNDBackLink( *pssib->line.pb ) )
		{
		cbWeight += sizeof(SRID);
		srid = SridOfPgnoItag( PgnoOfPn( pssib->pbf->pn ), itag );
		}
	else
		srid = *(SRID UNALIGNED *)PbNDBackLink(pssib->line.pb);

	Assert( itag != itagFOP || FNDNonIntrinsicSons( pssib->line.pb ) );

	/*	adjust weight for reserved space
	/**/
	if ( FNDVersion( *pssib->line.pb ) )
		{
		UINT	cbMax;

		cbMax = CbVERGetNodeMax( pfucb->dbid, srid );
		if ( cbMax > 0 && cbMax > CbNDData( pssib->line.pb, pssib->line.cb ) )
			cbWeight += ( cbMax - CbNDData( pssib->line.pb, pssib->line.cb ) );
		}

	if ( FNDNonIntrinsicSons( pssib->line.pb ) )
		{
		/*	add weight of sons
		/**/
		pbSon = PbNDSonTable( pssib->line.pb );
		cbSon = *pbSon++;
		for ( ibSon = 0; ibSon < cbSon; ibSon++ )
			{
			cbWeight += UsBTWeight( pfucb, (INT)pbSon[ibSon] );
			}
		}
	return cbWeight;
	}


//+private---------------------------------------------------------------------
//
//	ErrBTMoveSons
//	===========================================================================
//
//	LOCAL ERR ErrBTMoveSons( SPLIT *psplit,
//	  FUCB *pfucb, FUCB *pfucbNew, BYTE *rgbSon,
//	  BOOL fVisibleSons, BOOL fNoMove )
//
//	PARAMETERS
//
//	move a tree rooted at pssib to pssibNew
//	pssib.line.pb must point to the source root line
//
//	When fVisibleSons is set, indicate this node is a leaf node.
//	When fNoMove is set, no real update will be done, only buffers involved
//	in the backlink updates will be collected.
//
//------------------------------------------------------------------------------
ERR ErrBTMoveSons(
	SPLIT	*psplit,
	FUCB	*pfucb,
	FUCB	*pfucbNew,
	INT 	itagSonTable,
	BYTE	*rgbSon,
	BOOL	fVisibleSons,
	BOOL	fNoMove,
	BKLNK	*pbklnk,
	INT		cbklnk )
	{
	ERR  	err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	BYTE	*pbSon;
	INT  	cbSon;
	INT  	ibSon;
	INT  	ibSonMax;

	CallR( ErrBFWriteAccessPage( pfucb, psplit->pgnoSplit ) );
	Assert( pfucb->ssib.pbf == psplit->pbfSplit );

	/*	since splitter write latched split page there can be no
	/*	conflict and no updater can change split nodes during split.
	/**/
	Assert( FBFWriteLatch( psplit->ppib, psplit->pbfSplit ) );

	NDGet( pfucb, itagSonTable );

	rgbSon[0] = 0;

	if ( FNDNullSon( *pssib->line.pb ) )
		{
		Assert( err == JET_errSuccess );
		goto HandleError;
		}

	Assert( !FNDNullSon( *pssib->line.pb ) );

	pbSon = PbNDSonTable( pssib->line.pb );
	cbSon = CbNDSonTable( pbSon );
	pbSon++;

	if ( psplit->ibSon != ibSonNull )
		{
		switch ( psplit->splitt )
			{
			case splittVertical:
				ibSon = 0;
				ibSonMax = cbSon;
				break;
			case splittLeft:
				Assert( psplit->ibSon < cbSon );
				ibSon = 0;
				ibSonMax = psplit->ibSon + 1;
				break;
			default:
				Assert( psplit->ibSon <= cbSon );
				Assert( psplit->splitt == splittRight ||
						psplit->splitt == splittAppend );
				ibSon = psplit->ibSon;
				ibSonMax = cbSon;

				/*	append should move no visible nodes, but should move exactly
				/*	one invisible node.
				 */
#ifdef DEBUG
				if ( psplit->splitt == splittAppend )
					{
					if ( FNDVisibleSons( *pssib->line.pb ) )
						{
						Assert( ibSon == ibSonMax );
						}
					else
						{
						// On appends of invisible sons, we always take the last one with us.
						Assert( ibSon == ibSonMax - 1 );
						}
					}
#endif
			}

		for ( ; ibSon < ibSonMax; ibSon++ )
			{
			Call( ErrBTMoveNode( psplit, pfucb, pfucbNew,
				(INT)pbSon[ibSon],	rgbSon, fVisibleSons, fNoMove, pbklnk, cbklnk ) );
			}
		}

	/*	if success then should have split buffer access
	/**/
	Assert( pfucb->ssib.pbf == psplit->pbfSplit );

HandleError:
	return err;
	}


/*	forward node deferred free space to new page, allocating space from
/*	new page and releasing to split page.
/**/
INLINE LOCAL VOID BTIForwardDeferFreedNodeSpace( FUCB *pfucb, PAGE *ppageOld, PAGE *ppageNew, SRID bm )
	{
	INT	cbReserved;

	Assert( FNDVersion( *pfucb->ssib.line.pb ) );
	cbReserved = CbVERGetNodeReserve(
		ppibNil,
		pfucb->dbid,
		bm,
		CbNDData( pfucb->ssib.line.pb, pfucb->ssib.line.cb ) );

	Assert( cbReserved >= 0 );
	if ( cbReserved > 0 )
		{
		ppageOld->cbUncommittedFreed -= (SHORT)cbReserved;
		Assert( ppageOld->cbUncommittedFreed >= 0  &&
			ppageOld->cbUncommittedFreed <= ppageOld->cbFree );

		ppageNew->cbUncommittedFreed += (SHORT)cbReserved;
		Assert( ppageNew->cbUncommittedFreed >= 0  &&
			ppageNew->cbUncommittedFreed <= ppageNew->cbFree );
		}

	return;
	}

	
ERR ErrBTStoreBackLinkBuffer( SPLIT *psplit, BF *pbf, BOOL *pfAlreadyStored )
	{
	INT		cpbf;
	
	/*	check if the page is back linked in previous backlink
	/**/
	if ( psplit->cpbf )
		{
		BF	**ppbf = psplit->rgpbf;
		BF	**ppbfMax = ppbf + psplit->cpbf;

		for (; ppbf < ppbfMax; ppbf++)
			{
			if ( *ppbf == pbf )
				{
				*pfAlreadyStored = fTrue;
				return JET_errSuccess;
				}
			}
		}

	*pfAlreadyStored = fFalse;

	/*	keep the backlink into the psplit backlink table rgpbf
	/**/
	cpbf = psplit->cpbf++;
	if ( psplit->cpbf > psplit->cpbfMax )
		{
		BF **ppbf;

		/*	run out of space, get more buffers
		/**/
		psplit->cpbfMax += 10;
		ppbf = SAlloc( sizeof(BF *) * psplit->cpbfMax );
		if ( ppbf == NULL )
			return ErrERRCheck( JET_errOutOfMemory );
		
		memcpy( ppbf, psplit->rgpbf, sizeof(BF *) * cpbf );
		if ( psplit->rgpbf )
			{
			SFree( psplit->rgpbf );
			}
		psplit->rgpbf = ppbf;
		}

	*( psplit->rgpbf + cpbf ) = pbf;

	return JET_errSuccess;
	}

	
/* store the operations of the merge page:
/*  sridBackLink != pgnoSplit
/*      ==> a regular backlink
/*  sridBackLink == pgnoSplit && sridNew == sridNull
/*      ==> move the node from old page to new page. Deletion on old page.
/*  sridBackLink == pgnoSplit && sridNew != sridNull.
/*      ==> a new link among the old page and the new page,
/*          replace an entry with link on old page.
/**/
ERR ErrBTStoreBackLink(
		SPLIT	*psplit,
		SRID	sridNew,
		SRID	sridBackLink,
		BOOL	fNoMove )
	{
	BKLNK	*pbklnk;
	INT		cbklnk;
	
	if ( fNoMove )
		{
		psplit->cbklnkAlloc++;
		
		if ( psplit->cbklnkAlloc > psplit->cbklnkMax )
			{
			/* run out of space, get more buffers
			/**/
			psplit->cbklnkMax += 10;
			pbklnk = SAlloc( sizeof(BKLNK) * (psplit->cbklnkMax) );
			if ( pbklnk == NULL )
				{
				/*	restore cbklnk
				/**/
				psplit->cbklnkAlloc--;
				return ErrERRCheck( JET_errOutOfMemory );
				}
								
			if ( psplit->rgbklnk )
				{
				SFree( psplit->rgbklnk );
				}
			psplit->rgbklnk = pbklnk;
			}
		}
	else
		{
		Assert( sridNew == sridNull ||
			PgnoOfSrid( sridNew ) != pgnoNull );
		Assert( sridNew == sridNull ||
			(UINT) ItagOfSrid( sridNew ) > 0 &&
			(UINT) ItagOfSrid( sridNew ) < (UINT) ctagMax );
		Assert( sridBackLink != sridNull );
		Assert( PgnoOfSrid( sridBackLink ) != pgnoNull );

		/* log the back link
		/**/
		cbklnk = psplit->cbklnk++;

		/* assert cbklnk less then max.  Note that we may store
		/*	two entries per record.
		/**/
		Assert( cbklnk <= psplit->cbklnkAlloc );
		Assert( cbklnk < ctagMax * 2 );

		pbklnk = psplit->rgbklnk + cbklnk;
		pbklnk->sridNew = sridNew;
		pbklnk->sridBackLink = sridBackLink;
		}
	
	return JET_errSuccess;
	}
	

//+private---------------------------------------------------------------------
//
//	ErrBTMoveNode
//	===========================================================================
//
//	LOCAL ERR ErrBTMoveNode( SPLIT *psplit, FUCB *pfucb, FUCB *pfucbNew,
// 	  BYTE *rgbSon, BOOL fVisibleNode, BOOL fNoMove )
//
//	PARAMETERS
//
//	moves node and any decendants of node.  Increments rgbSonNew count
//	and sets new itag in rgbSonNew array.
//  When fVisibleSons is set, indicate this node is a leaf node.
//  if fNoMove is set, no delete or insert is done, only backlinked buffers
//  are collected.
//
//-----------------------------------------------------------------------------
LOCAL ERR ErrBTMoveNode(
	SPLIT		*psplit,
	FUCB		*pfucb,
	FUCB		*pfucbNew,
	INT  		itagNode,
	BYTE		*rgbSon,
	BOOL		fVisibleNode,
	BOOL		fNoMove,
	BKLNK		*pbklnk,
	INT			cbklnk )
	{
	ERR			err;
	/*	used as index into tag mapping
	/**/
	INT  		itagOld = itagNode;
	SSIB		*pssib = &pfucb->ssib;
	SSIB		*pssibNew = pfucbNew ? &pfucbNew->ssib : pssibNil;
	INT  		cline = 1;
	LINE		rgline[3];
	BYTE		*pb;
	BYTE		*pbNode;
	ULONG		cb;
	SRID		sridNew;
	SRID		sridBackLink;
	BYTE		rgbT[citagSonMax];

	/*	get node to move.
	/**/
	pssib->itag = itagOld;
	NDGet( pfucb, itagOld );

	rgline[0] = pssib->line;
	pbNode = pb = pssib->line.pb;
	cb = pssib->line.cb;
	Assert( cb < cbPage );

	Assert( itagOld != itagFOP || FNDNonIntrinsicSons( pssib->line.pb ) );
	if ( FNDNonIntrinsicSons( pssib->line.pb ) )
		{
		INT		itagT = itagOld;
		SPLITT	splittT;
		BOOL	fVisibleSons = FNDVisibleSons( *pssib->line.pb );

		if ( fVisibleSons != 0 )
			psplit->fLeaf = fTrue;

		/*	call move tree to move all its sons
		/**/
		rgbT[0] = 0;

		/*	movement of subtrees must include whole tree, hence,
		/*	move as though vertical split
		/**/
		splittT = psplit->splitt;
		psplit->splitt = splittVertical;
		CallR( ErrBTMoveSons(
				psplit, pfucb, pfucbNew, itagOld, rgbT, fVisibleSons, fNoMove, pbklnk, cbklnk ) );
		psplit->splitt = splittT;

		/*	can be done by copying the new rgbSon into the pssib page
		/*	directly, pb should be still effective.  Must remember
		/*	to copy back link as well.
		/**/
		pb = PbNDSonTable( pb );
		rgline[0].cb = (ULONG)(pb - pbNode);
		rgline[1].pb = rgbT;
		rgline[1].cb = rgbT[0] + 1;
		rgline[2].pb = pb + *pb + 1;
		rgline[2].cb = cb - rgline[0].cb - rgline[1].cb;
		cline = 3;

		/*	restore cursor state
		/**/
		pfucb->ssib.itag = itagOld;
		NDGet( pfucb, itagOld );
		}

	/*	assert current node cached
	/**/
	AssertNDGet( pfucb, itagOld );

	/*	if node is linked, it must be a leaf node, adjust links
	/*	to new location else replace with new link to new location.
	/**/
	if ( !fVisibleNode )
		{
		if ( fNoMove )
			{
			CallR( ErrBTStoreBackLink( psplit, sridNull, sridNull, fNoMove ) );
			return JET_errSuccess;
			}
			
		if ( pfucbNew != pfucbNil )
			{
			CallS( ErrPMInsert( pssibNew, rgline, cline ) );

			/*	store backlink such that the source node will be
			/*	deleted during recovery.
			/**/
			sridNew = sridNull;
			sridBackLink = SridOfPgnoItag( psplit->pgnoSplit, itagOld );
			CallS( ErrBTStoreBackLink( psplit, sridNew, sridBackLink, fNoMove ) );
			}
		Assert( !FNDBackLink( *pssib->line.pb ) );
		PMDelete( pssib );
		}
	else
		{
		if ( FNDBackLink( *pbNode ) )
			{
			PGNO	pgnoBackLink;
			INT		itagBackLink;
			BOOL	fLatched;

#ifdef DEBUG
			{
			INT itagT = PcsrCurrent(pfucb)->itag;

			PcsrCurrent(pfucb)->itag = (SHORT)pssib->itag;
			NDGetBackLink( pfucb, &pgnoBackLink, &itagBackLink );
			PcsrCurrent(pfucb)->itag = (SHORT)itagT;
			}
#else
			NDGetBackLink( pfucb, &pgnoBackLink, &itagBackLink );
#endif
			sridBackLink = SridOfPgnoItag( pgnoBackLink, itagBackLink );

			if ( fNoMove )
				sridNew = sridNull;
			else
				{
				if ( pfucbNew == pfucbNil )
					{
					BKLNK *pbklnkCur, *pbklnkMax;
					
					Assert( cbklnk > 0 ) ;
					pbklnkCur = pbklnk;
					pbklnkMax = pbklnkCur + cbklnk;
					for ( ; pbklnkCur < pbklnkMax; pbklnkCur++ )
						if ( ( (UNALIGNED BKLNK *) pbklnkCur )->sridBackLink == sridBackLink )
							break;
					Assert( pbklnkCur < pbklnkMax );
					sridNew = ( (UNALIGNED BKLNK *) pbklnkCur )->sridNew;
					}
				else
					{
					if ( FNDVersion( *pssib->line.pb ) )
						{
						BTIForwardDeferFreedNodeSpace(
							pfucb,
							pssib->pbf->ppage,
							pssibNew->pbf->ppage,
							sridBackLink );
						}
					CallS( ErrPMInsert( pssibNew, rgline, cline ) );
					sridNew = SridOfPgnoItag( PcsrCurrent( pfucbNew )->pgno, pssibNew->itag );
					}
				PMDelete( pssib );
				}

			CallR( ErrBFWriteAccessPage( pfucb, pgnoBackLink ) );
			if ( fRecovering && QwPMDBTime( pssib->pbf->ppage ) >= psplit->qwDBTimeRedo )
				goto EndOfUpdateLinks;
											
			if ( !fNoMove )
				{
				pssib->itag = itagBackLink;
				PMDirty( pssib );
				PMReplaceLink( pssib, sridNew );
				}

#if 0
			/*	For redo, we do not call this function with fNoMove to hold buffer.
			 *	We simply access the buffer as we go. So we have to check if buffer
			 *	need to be stored. Check if the page is back linked in previous backlink
			 **/
			if ( fRecovering )
				{
				CallR( ErrBTStoreBackLinkBuffer( psplit, pssib->pbf, &fLatched ) );
				if ( !fLatched )
					{
					BFSetWriteLatch( pssib->pbf, pssib->ppib );
					}
				}
#endif
#ifdef DEBUG
			if ( !fNoMove )
				{
				BF		**ppbf = psplit->rgpbf;
				BF		**ppbfMax = ppbf + psplit->cpbf;
				BOOL	fBufferFound = fFalse;

				Assert( psplit->cpbf );

				for ( ; ppbf < ppbfMax; ppbf++ )
					{
					if ( *ppbf == pssib->pbf )
						{
						fBufferFound = fTrue;
						break;
						}
					}
					Assert( fBufferFound );
				}
#endif

			if ( pfucbNew != pfucbNil )
				{
				Assert( sridNew != sridNull || fNoMove );
				Assert( sridBackLink != sridNull );
				CallR( ErrBTStoreBackLink( psplit,
							sridNew,
							sridBackLink,
							fNoMove ) );
			
				/*	store backlink such that the source node will be
				/*	deleted during recovery.
				/**/
				CallR( ErrBTStoreBackLink( psplit,
							sridNull,
							SridOfPgnoItag( psplit->pgnoSplit, itagOld ),
							fNoMove ) );
				}

			if ( !fNoMove )
				{
				goto EndOfUpdateLinks;
				}

			if ( FBFWriteLatchConflict( pssib->ppib, pssib->pbf ) )
				{
				/*	yeild after release split resources
				/**/
				pfucb->ppib->cLatchConflict++;
				return ErrERRCheck( errDIRNotSynchronous );
				}

			/*	check if the page is back linked in previous backlink
			/**/
			CallR( ErrBTStoreBackLinkBuffer( psplit, pssib->pbf, &fLatched ) );
			if ( !fLatched )
				{
				BFSetWriteLatch( pssib->pbf, pssib->ppib );
				}

EndOfUpdateLinks:

			CallR( ErrBFWriteAccessPage( pfucb, psplit->pgnoSplit ) );

			if ( fNoMove )
				return JET_errSuccess;
			}
		else
			{
			BYTE	bFlags;
			KEY 	key;
			LINE	lineSonTable;
			LINE	lineData;

			if ( fNoMove )
				{
				CallR( ErrBTStoreBackLink(
									psplit,
									sridNull,
									sridNull,
									fNoMove ) );
				return JET_errSuccess;
				}

			sridBackLink = SridOfPgnoItag( psplit->pgnoSplit, itagNode );

			if ( pfucbNew == pfucbNil )
				{
				BKLNK *pbklnkCur, *pbklnkMax;

				Assert( fRecovering );

// The assert below is only true during DO time, but this code will never be
// hit during DO time (pfucbNew is only NULL during REDO time, as asserted
// above).  The assert below would go off if replaying a merge when the
// source page never got flushed.
//				/*	there should be no version when doing merge.
//				 */
//				Assert( !FNDVersion( *pssib->line.pb ) ||
//						CbVERGetNodeReserve( ppibNil, pfucb->dbid,  sridBackLink,
//							CbNDData( pssib->line.pb, pssib->line.cb ) ) == 0 );

				Assert( cbklnk > 0 ) ;
				pbklnkCur = pbklnk;
				pbklnkMax = pbklnkCur + cbklnk;
				for ( ; pbklnkCur < pbklnkMax; pbklnkCur++ )
					if ( ( (UNALIGNED BKLNK *) pbklnkCur )->sridBackLink == sridBackLink )
						break;
				Assert( pbklnkCur < pbklnkMax );
				sridNew = ( (UNALIGNED BKLNK *) pbklnkCur )->sridNew;
				}
			else
				{
				if ( FNDVersion( *pssib->line.pb ) )
					{
					BTIForwardDeferFreedNodeSpace(
						pfucb,
						pssib->pbf->ppage,
						pssibNew->pbf->ppage,
						sridBackLink );
					}

				Assert( psplit->pgnoSplit != pgnoSystemRoot  ||  itagNode != itagSystemRoot );
				Assert( psplit->pgnoSplit != pfucb->u.pfcb->pgnoFDP ||
					itagNode != itagDATA  ||
					psplit->pgnoSplit == pgnoSystemRoot );

				//	UNDONE:	clean this up
				bFlags = *pbNode;
				key.cb = CbNDKey( pbNode );
				if ( key.cb > 0 )
					key.pb = PbNDKey( pbNode );
				if ( FNDSon( *pbNode ) )
					{
					if ( cline == 1 )
						{
						/*	must be intrinsic son
						/**/
						Assert( FNDSon( *pbNode ) && FNDInvisibleSons( *pbNode ) &&
								CbNDSon( pbNode ) == 1 );
						lineSonTable.cb = 1 + sizeof(PGNO);
						lineSonTable.pb = PbNDSonTable( pbNode );
						}
					else
						{
						Assert( cline == 3 );
						lineSonTable.cb = rgline[1].cb;
						lineSonTable.pb = rgline[1].pb;
						}
					}
				else
					{
					lineSonTable.cb = 0;
					lineSonTable.pb = NULL;
					}
				Assert( !FNDBackLink( *pbNode ) );
				lineData.pb = PbNDData( pbNode );
				lineData.cb = cb - (ULONG)( lineData.pb - pbNode );
				CallS( ErrNDInsertWithBackLink(
						pfucbNew, bFlags, &key, &lineSonTable, sridBackLink, &lineData ) );
				Assert( PcsrCurrent( pfucbNew )->itag != itagFOP );
				sridNew = SridOfPgnoItag(
						PcsrCurrent( pfucbNew )->pgno, PcsrCurrent( pfucbNew )->itag );
				}
			PMReplaceWithLink( pssib, sridNew );

			Assert( sridBackLink == SridOfPgnoItag( psplit->pgnoSplit, itagOld ) );
			CallS( ErrBTStoreBackLink( psplit, sridNew, sridBackLink, fNoMove ) );
			}
		}

	if ( pfucbNew != pfucbNil )
		{
		rgbSon[++rgbSon[0]] = (BYTE) pssibNew->itag;

		/*	record tag mapping in SPLIT.  Note that some new itags will
		/*	be duplicated during double split, however, since source itags
		/*	are unique, there is no aliasing.
		/**/
		Assert( itagOld != 0 );
		Assert( psplit->mpitag[itagOld] == 0 );
		psplit->mpitag[itagOld] = (BYTE)pssibNew->itag;
		}

	return JET_errSuccess;
	}


//+private----------------------------------------------------------------------
//
//	FBTSplit
//	============================================================================
//
//	BOOL FBTSplit( SSIB *pssib, INT cbReq, INT citagReq )
//
//	PARAMETERS
//
//	determine whether split is required.  Split is required if less than
//	required space is free in page or if no page tags are free.  cbReq
//	must include all space required including that space for the tag.
//
//------------------------------------------------------------------------------
// UNDONE:  Any problem with making this function a #define, or at the very
// least inline??
BOOL FBTSplit( SSIB *pssib, INT cbReq, INT citagReq )
	{
	BOOL fEnoughPageSpace = FNDFreePageSpace( pssib, cbReq );

	Assert( citagReq < ctagMax );
	return ( !fEnoughPageSpace  ||  !FPMFreeTag( pssib, (INT) citagReq ) );
	}



//+private----------------------------------------------------------------------
//
//	FBTAppendPage
//	============================================================================
//
//	LOCAL BOOL FBTAppendPage( CSR *pcsr, SSIB *pssib, INT cbReq, INT cbPageAdjust, INT cbFreeDensity, INT citagReq )
//
//	PARAMETERS
//
//	node should be inserted into appended page when node is last son of FOP, page to be inserted in
//	is last page in b-tree, not FDP page and density contraint would be
//	violated if node were inserted on current page.
//
//------------------------------------------------------------------------------
BOOL FBTAppendPage( FUCB *pfucb, CSR *pcsr, INT cbReq, INT cbPageAdjust, INT cbFreeDensity, INT citagReq )
	{
	BOOL	fAppendPage = fFalse;
	PGNO	pgno;
	INT		cbSon;
	SSIB	*pssib = &pfucb->ssib;

	PgnoNextFromPage( pssib, &pgno );

	/*	itagFather == 0 for non-FDP page
	/*	pgno == pgnoNull for last B-tree page
	/*	cbFree - cbReq < cbFreeDensity violates density contraint
	/*	disable density contraint when required space is too large
	/*	to satisfy density
	/**/
	if ( pcsr->itagFather == itagFOP &&
		pgno == pgnoNull &&
		!FNDFreePageSpace( pssib, cbPageAdjust + cbReq + cbFreeDensity ) )
		{
		LINE	lineSav = pfucb->ssib.line;

		/*	get number of sons of FOP to check if current node is last of FOP's sons */
		/**/
		NDGet( pfucb, itagFOP );
		cbSon = CbNDSonTable( PbNDSonTable( pssib->line.pb ) );
		fAppendPage = ( pcsr->ibSon == cbSon );

		if ( fAppendPage &&
			cbReq >= (INT)cbAvailMost - cbFreeDensity )
			{
			fAppendPage = FBTSplit( pssib, cbReq, citagReq );
			}


		/*	restore line
		/**/
		pfucb->ssib.line = lineSav;
		}

	return fAppendPage;
	}


#pragma optimize("g",on)


//+private----------------------------------------------------------------------
//
//	CbBTFree
//	============================================================================
//
//	Returns free space until density or page constraint met.
//
//------------------------------------------------------------------------------
// UNDONE:  Is there any problem with making this function a #define, or inline??
INT CbBTFree( FUCB *pfucb, INT cbFreeDensity )
	{
	SSIB *pssib = &pfucb->ssib;

	// Can simply call CbPMFreeSpace() (which doesn't consult the version store)
	// here because initial call to FNDFreePageSpace() DOES consult the version
	// store to reconcile cbUncommittedFreed.
	return ( FNDFreePageSpace( pssib, cbFreeDensity ) ?
		CbPMFreeSpace( pssib ) - cbFreeDensity : 0 );
	}

/*************************** MCM ***************************
/***********************************************************
/**/
#define	FPMValidItag( itag )	( itag >= itagFOP && itag < ctagMax )
			
#define	FMCMRequired( pfucb, pfucbT )							\
	( FFUCBFull( pfucbT ) && pfucbT->dbid == pfucb->dbid && !( FFUCBSort( pfucbT ) ) )

LOCAL VOID MCMMapItag( PGNO pgnoSplit, CSR *pcsr, CSR *pcsrUpdated, BYTE *mpitag );



VOID MCMRightHorizontalPageSplit( FUCB *pfucb, PGNO pgnoSplit, PGNO pgnoRight, INT ibSonSplit, BYTE *mpitag )
	{
	FUCB 	*pfucbT;

	if ( ibSonSplit == ibSonNull )
		{
		pfucb->pcsr->pgno = pgnoRight;
		pfucb->pcsr->ibSon = 0;
		return;
		}
	
	for (	pfucbT = pfucb->u.pfcb->pfucb;
		pfucbT != pfucbNil;
		pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR		*pcsrT;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );
		Assert( PcsrCurrent( pfucbT ) != pcsrNil );

		for (	pcsrT = PcsrCurrent( pfucbT );
			pcsrT != pcsrNil;
			pcsrT = pcsrT->pcsrPath )
			{
			if ( pcsrT->pgno == pgnoSplit &&
				pcsrT->itagFather == itagFOP &&
				pcsrT->ibSon >= ibSonSplit )
				{
				Assert( pcsrT->csrstat == csrstatOnCurNode ||
					pcsrT->csrstat == csrstatBeforeCurNode ||
					pcsrT->csrstat == csrstatAfterCurNode );

				pcsrT->pgno = pgnoRight;
				pcsrT->ibSon -= (SHORT)ibSonSplit;
				Assert( pcsrT->itagFather == itagFOP );

				if ( pcsrT->itag != itagNil && pcsrT->itag != itagNull )
					{
					Assert( FPMValidItag( pcsrT->itag ) );
					/*	node may not have been moved if CSR was before
					/*	current node and node was first son or if CSR was
					/*	after node and node was last son.
					/**/
					Assert( mpitag[pcsrT->itag] != itagFOP ||
						( pcsrT->csrstat == csrstatBeforeCurNode && pcsrT->ibSon == 0 ) ||
						( pcsrT->csrstat == csrstatAfterCurNode ) );
					if ( mpitag[pcsrT->itag] != itagFOP )
						pcsrT->itag = mpitag[pcsrT->itag];
					}

				/*	adjust lower level CSRs that may be on subtrees
				/*	in this page.  Their ibSon is correct but their itags
				/*	must be corrected 'top down'.
				/**/
				if ( PcsrCurrent( pfucbT ) != pcsrT )
					MCMMapItag( pgnoSplit, PcsrCurrent( pfucbT ), pcsrT, mpitag );

				break;
				}
			}
		}

	return;
	}


VOID MCMLeftHorizontalPageSplit( FUCB *pfucb, PGNO pgnoSplit, PGNO pgnoNew, INT ibSonSplit, BYTE *mpitag )
	{
	FUCB 	*pfucbT;

	if ( ibSonSplit == ibSonNull )
		{
		pfucb->pcsr->pgno = pgnoNew;
		pfucb->pcsr->ibSon = 0;
		return;
		}
	
	for (	pfucbT = pfucb->u.pfcb->pfucb;
			pfucbT != pfucbNil;
			pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR		*pcsrT;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );
		Assert( PcsrCurrent( pfucbT ) != pcsrNil );

		for (	pcsrT = PcsrCurrent( pfucbT );
	  		pcsrT != pcsrNil;
	  		pcsrT = pcsrT->pcsrPath )
			{
			if ( pcsrT->pgno == pgnoSplit && pcsrT->itagFather == itagFOP )
				{
				Assert( pcsrT->csrstat == csrstatOnCurNode ||
					pcsrT->csrstat == csrstatBeforeCurNode ||
					pcsrT->csrstat == csrstatAfterCurNode );

				if ( pcsrT->ibSon <= ibSonSplit )
					{
			   	pcsrT->pgno = pgnoNew;
					Assert( pcsrT->itagFather == itagFOP );

					if ( pcsrT->itag != itagNil && pcsrT->itag != itagNull )
						{
						Assert( FPMValidItag( pcsrT->itag ) );
						/*	node may not have been moved if CSR was before
						/*	current node and node was first son or if CSR was
						/*	after node and node was last son.
						/**/
						Assert( mpitag[pcsrT->itag] != itagFOP ||
							( pcsrT->csrstat == csrstatBeforeCurNode && pcsrT->ibSon == 0 ) ||
							( pcsrT->csrstat == csrstatAfterCurNode ) );
						if ( mpitag[pcsrT->itag] != itagFOP )
							pcsrT->itag = mpitag[pcsrT->itag];
						}

					/*	Adjust lower level CSRs that may be on subtrees
					/*	in this page.  Their ibSon is correct but their itags
					/*	must be corrected 'top down'.
					/**/
					if ( PcsrCurrent( pfucbT ) != pcsrT )
						MCMMapItag( pgnoSplit, PcsrCurrent( pfucbT ), pcsrT, mpitag );

					break;
					}
				else
					{
					/*	adjust ibSons for those sons moved to new page
					/**/
			   	pcsrT->ibSon -= ( ibSonSplit + 1 );
					Assert( pcsrT->itagFather == itagFOP );
					break;
					}
				}
			}
		}

	return;
	}


/*	MCMBurstIntrinsic corrects CSRs for burst intrinsic page pointer.
/**/
VOID MCMBurstIntrinsic( FUCB *pfucb,
	PGNO	pgnoFather,
	INT	itagFather,
	PGNO	pgnoNew,
	INT	itagNew )
	{
	FUCB 	*pfucbT;

	for (	pfucbT = pfucb->u.pfcb->pfucb;
		pfucbT != pfucbNil;
		pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR		*pcsrT;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		/*	only one session can split one domain at a time.
		/**/
		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );
		Assert( PcsrCurrent( pfucbT ) != pcsrNil );

		/*	initialize pcsrT
		/**/
		pcsrT = PcsrCurrent( pfucbT );

		for (	; pcsrT != pcsrNil; pcsrT = pcsrT->pcsrPath )
			{
			Assert( pcsrT->csrstat == csrstatBeforeFirst ||
				pcsrT->csrstat == csrstatOnCurNode ||
				pcsrT->csrstat == csrstatOnFDPNode ||
				pcsrT->csrstat == csrstatBeforeCurNode ||
				pcsrT->csrstat == csrstatAfterCurNode ||
				pcsrT->csrstat == csrstatOnDataRoot );

			if ( pcsrT->pgno == pgnoFather && pcsrT->itagFather == itagFather )
				{
				pcsrT->pgno = pgnoNew;
				pcsrT->itag = (SHORT)itagNew;
				pcsrT->itagFather = itagFOP;
				pcsrT->csrstat = csrstatOnCurNode;

				break;
				}
			}
		}

	return;
	}


/*	MCM cursors to inserted page pointer nodes.  Must also handle case where
/*	original page pointer node was intrinsic.
/**/
VOID MCMInsertPagePointer( FUCB *pfucb, PGNO pgnoFather, INT itagFather )
	{
	FUCB 	*pfucbT;
	INT	cbSon;
	BYTE	*rgbSon;

	/*	cache father son table.
	/**/
	AssertFBFReadAccessPage( pfucb, pgnoFather );
	NDGet( pfucb, itagFather );
	cbSon = CbNDSon( pfucb->ssib.line.pb );
	rgbSon = PbNDSon( pfucb->ssib.line.pb );

	for (	pfucbT = pfucb->u.pfcb->pfucb;
		pfucbT != pfucbNil;
		pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR		*pcsrT;
		/*	pgno from lower level CSR to be used to determine which
		/*	page pointer to locate on.
		/**/
		PGNO		pgno = pgnoNull;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		/*	only one session can split one domain at a time.
		/**/
		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );
		Assert( PcsrCurrent( pfucbT ) != pcsrNil );

		/*	initialize pcsrT and set pgno to current page if
		/*	this page is pointed to by a page pointer node.
		/**/
		pcsrT = PcsrCurrent( pfucbT );
		if ( pcsrT->itagFather == itagFOP )
			pgno = pcsrT->pgno;

		for (	; pcsrT != pcsrNil; pcsrT = pcsrT->pcsrPath )
			{
			Assert( pcsrT->csrstat == csrstatBeforeFirst ||
				pcsrT->csrstat == csrstatOnCurNode ||
				pcsrT->csrstat == csrstatOnFDPNode ||
				pcsrT->csrstat == csrstatBeforeCurNode ||
				pcsrT->csrstat == csrstatAfterCurNode ||
				pcsrT->csrstat == csrstatOnDataRoot );

			if ( pcsrT->pgno == pgnoFather && pcsrT->itagFather == itagFather )
				{
				INT	ibSon;

				/*	find pgno in father page pointer sons and set itag
				/*	and ibSon when found.
				/**/
				for ( ibSon = 0;; ibSon++ )
					{
					Assert( ibSon < cbSon );
					NDGet( pfucb, rgbSon[ibSon] );
					if ( pgno == *((PGNO UNALIGNED *)PbNDData( pfucb->ssib.line.pb)) )
						{
						pcsrT->ibSon = (SHORT)ibSon;
						pcsrT->itag = rgbSon[ibSon];
						break;
						}
					}
				break;
				}

			/*	set pgno to current page if
			/*	this page is pointed to by a page pointer node.
			/**/
			if ( pcsrT->itagFather == itagFOP )
				pgno = pcsrT->pgno;
			}
		}

	return;
	}


VOID MCMVerticalPageSplit(
	FUCB	*pfucb,
	BYTE	*mpitag,
	PGNO	pgnoSplit,
	INT		itagSplit,
	PGNO	pgnoNew,
	SPLIT	*psplit )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	FUCB	*pfucbT;
	CSR		*pcsrT;
	CSR		*pcsrNew = pcsrNil;

	for ( pfucbT = pfucb->u.pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextInstance )
		{
		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );

		for ( pcsrT = PcsrCurrent( pfucbT );
			pcsrT != pcsrNil;
			pcsrT = pcsrT->pcsrPath )
			{
			if ( pcsrT->pgno != pgnoSplit )
				continue;

			if ( pcsrT->itag == itagSplit )
				break;

			Assert( pcsrT->csrstat == csrstatBeforeFirst ||
				pcsrT->csrstat == csrstatOnCurNode ||
				pcsrT->csrstat == csrstatOnFDPNode ||
				pcsrT->csrstat == csrstatBeforeCurNode ||
				pcsrT->csrstat == csrstatAfterCurNode ||
				pcsrT->csrstat == csrstatAfterLast ||
				pcsrT->csrstat == csrstatOnDataRoot );

			Assert( pcsrT->itagFather == itagNull ||
				pcsrT->itagFather == itagNil ||
				pcsrT->itag != itagNull ||
				pcsrT->itag != itagNil );

			Assert( pcsrT->itagFather != itagNil );

			if ( pcsrT->itagFather == itagNull )
				{
				/*	we should be on bottom of csr stack.
				 */
				Assert( pcsrT->pcsrPath == pcsrNil );

				/*	csr must be set and valid.
				 */
				Assert( pcsrT->itag != itagNil && pcsrT->itag != itagNull );
				Assert( FPMValidItag( pcsrT->itag ) );

				/*	the csr is not on a moved node. ignore it.
				 */
				if ( mpitag[pcsrT->itag] == 0  )
					{
					continue;
					}

				/*	continue adjust itag etc.
				 */
				}
			else
				{
				/*	If itag Father is not part of the vertical split subtree.
				 *	Then the csr from here is not part of the vertical split.
				 *	Ignore it.
				 */
				if ( pcsrT->itagFather != itagSplit &&
					 mpitag[pcsrT->itagFather] == 0  )
					continue;

				/*	insert a CSR for new B-Tree level, for cursors
				/**/
				Assert( FFUCBFull( pfucbT ) );
				if ( pcsrT->itagFather == itagSplit )
					{
					Assert( pcsrT->pcsrPath != pcsrNil );
//					Assert( pcsrT->pcsrPath->itag == itagSplit );

					Assert( psplit->ipcsrMac > 0 );
					psplit->ipcsrMac--;
					Assert( psplit->rgpcsr[psplit->ipcsrMac] );
					pcsrNew = psplit->rgpcsr[psplit->ipcsrMac];
#ifdef DEBUG
					psplit->rgpcsr[psplit->ipcsrMac] = pcsrNil;
#endif

					/*	the new csr will be the intrinsic page pointer
					/**/
					pcsrNew->csrstat = csrstatOnCurNode;
					pcsrNew->pgno = pcsrT->pgno;
					pcsrNew->itag = itagNil;
					pcsrNew->ibSon = 0;
					Assert( pcsrNew->item == sridNull );
					CSRSetInvisible( pcsrNew );
					Assert( pcsrNew->isrid == isridNull );
					pcsrNew->itagFather = pcsrT->itagFather;
					pcsrNew->pcsrPath = pcsrT->pcsrPath;

					pcsrT->pcsrPath = pcsrNew;

					/*	father is FOP
					/**/
					pcsrT->itagFather = itagFOP;
					}
				else
					{
					Assert( pcsrT->itagFather != itagNull );
					pcsrT->itagFather = mpitag[pcsrT->itagFather];
					}
				}

			pcsrT->pgno = pgnoNew;

			/*	update itag if valid.  The itag may be itagNil if
			/*	inserting first son of father node.
			/**/
			if ( pcsrT->itag != itagNil && pcsrT->itag != itagNull )
				{
				Assert( mpitag[pcsrT->itag] != itagFOP ||
					( pcsrT->csrstat == csrstatBeforeCurNode && pcsrT->ibSon == 0 ) ||
					( pcsrT->csrstat == csrstatAfterCurNode ) );
				if ( mpitag[pcsrT->itag] != itagFOP )
					pcsrT->itag = mpitag[pcsrT->itag];
				}

			/*	isrid unchanged
			/**/

			/*	ibSon unchanged
			/**/
	
			/*	adjust lower level CSRs that may be on subtrees
			/*	in this page.  Their ibSon is correct but their itags
			/*	must be corrected 'top down'.
			/**/
			if ( pcsrNew != pcsrNil )
				{
				Assert( pcsrNew->pgno == pgnoSplit &&
					pcsrNew->itagFather == itagSplit );
				if ( PcsrCurrent( pfucbT ) != pcsrT )
					MCMMapItag( pgnoSplit, PcsrCurrent( pfucbT ), pcsrT, mpitag );
				break;
				}
			}
		}

	return;
	}


VOID MCMDoubleVerticalPageSplit(
	FUCB	*pfucb,
	BYTE	*mpitag,
	PGNO	pgnoSplit,
	INT  	itagSplit,
	INT	ibSonDivision,
	PGNO	pgnoNew,
	PGNO	pgnoNew2,
	PGNO	pgnoNew3,
	SPLIT	*psplit ) 	
	{
	CSR	*pcsr = PcsrCurrent( pfucb );
	FUCB	*pfucbT;

	for ( pfucbT = pfucb->u.pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextInstance )
		{
		CSR	*pcsrT;
		CSR	*pcsrNew;
		CSR	*pcsrRoot;

		if ( !( FMCMRequired( pfucb, pfucbT ) ) )
			continue;

		Assert( pfucbT->ppib == pfucb->ppib );
		Assert( !( FFUCBSort( pfucbT ) ) );

		for (	pcsrT = PcsrCurrent( pfucbT );
			pcsrT != pcsrNil;
			pcsrT = pcsrT->pcsrPath )
			{
			if ( pcsrT->pgno != pgnoSplit )
				continue;

			Assert( pcsrT->csrstat == csrstatBeforeFirst ||
				pcsrT->csrstat == csrstatOnCurNode ||
				pcsrT->csrstat == csrstatOnFDPNode ||
				pcsrT->csrstat == csrstatBeforeCurNode ||
				pcsrT->csrstat == csrstatAfterCurNode ||
				pcsrT->csrstat == csrstatAfterLast ||
				pcsrT->csrstat == csrstatOnDataRoot );

			if ( pcsrT->itag == itagSplit )
				break;

			Assert( pcsrT->itagFather == itagNull ||
				pcsrT->itagFather == itagNil ||
				pcsrT->itag != itagNull ||
				pcsrT->itag != itagNil );

			Assert( pcsrT->itagFather != itagNil );
			if ( pcsrT->itagFather == itagNull )
				{
				Assert( pcsrT->itag != itagNil && pcsrT->itag != itagNull );
				if ( mpitag[pcsrT->itag] == 0  )
					{
					continue;
					}
				}
			else
				{
				if ( pcsrT->itagFather != itagSplit )
					continue;
				}

			pcsrRoot = pcsrT;

			/*	insert CSR for new B-Tree level, for cursors
			/**/
			Assert( FFUCBFull( pfucbT ) );
			if ( pcsrT->pcsrPath != pcsrNil )
				{
				/*	insert CSR for intrinsic page pointer node
				/**/
				Assert( psplit->ipcsrMac > 0 );
				psplit->ipcsrMac--;
				Assert( psplit->rgpcsr[psplit->ipcsrMac] );
				pcsrNew = psplit->rgpcsr[psplit->ipcsrMac];
#ifdef DEBUG
				psplit->rgpcsr[psplit->ipcsrMac] = pcsrNil;
#endif

				/*	the new csr will be son of the root
				/**/
				pcsrNew->csrstat = csrstatOnCurNode;
				pcsrNew->pgno = pgnoSplit;
				pcsrNew->itag = itagNil;
				Assert( pcsrNew->item == sridNull );
				CSRSetInvisible( pcsrNew );
				Assert( pcsrNew->isrid == isridNull );
				pcsrNew->itagFather = (SHORT)itagSplit;
				pcsrNew->ibSon = 0;
				pcsrNew->pcsrPath = pcsrT->pcsrPath;

				pcsrT->pcsrPath = pcsrNew;


				/*	insert CSR for intermediate page
				/**/
				Assert( psplit->ipcsrMac > 0 );
				psplit->ipcsrMac--;
				Assert( psplit->rgpcsr[psplit->ipcsrMac] );
				pcsrNew = psplit->rgpcsr[psplit->ipcsrMac];
#ifdef DEBUG
				psplit->rgpcsr[psplit->ipcsrMac] = pcsrNil;
#endif

				/*	the new csr will be the new intermediat node
				/**/
				pcsrNew->csrstat = csrstatOnCurNode;
				pcsrNew->pgno = pgnoNew;
				if ( pcsrT->ibSon <= ibSonDivision )
					{
					pcsrNew->itag = itagDIRDVSplitL;
					pcsrNew->ibSon = 0;
					}
				else
					{
					pcsrNew->itag = itagDIRDVSplitR;
					pcsrNew->ibSon = 1;
					}
				Assert( pcsrNew->item == sridNull );
				CSRSetInvisible( pcsrNew );
				Assert( pcsrNew->isrid == isridNull );
				pcsrNew->itagFather = itagFOP;
				pcsrNew->pcsrPath = pcsrT->pcsrPath;

				pcsrT->pcsrPath = pcsrNew;
				}

			/*	update itag independant of which page node was
			/*	moved to via mpitag.  Only update itag if valid.
			/*	The itag may be itagNil if inserting first son
			/*	of father node.
			/**/
			if ( pcsrT->itag != itagNil && pcsrT->itag != itagNull )
				{
				Assert( mpitag[pcsrT->itag] != itagFOP ||
					( pcsrT->csrstat == csrstatBeforeCurNode && pcsrT->ibSon == 0 ) ||
					( pcsrT->csrstat == csrstatAfterCurNode ) );
				if ( mpitag[pcsrT->itag] != itagFOP )
					pcsrT->itag = mpitag[pcsrT->itag];
				}

			if ( pcsrT->ibSon <= ibSonDivision )
				{
				pcsrT->pgno = pgnoNew2;
				}
			else
				{
				pcsrT->pgno = pgnoNew3;
				pcsrT->ibSon = pcsrT->ibSon - ibSonDivision -1 ;
				}
				
			/*	father is FOP
			/**/
			pcsrT->itagFather = itagFOP;

			/*	adjust lower level CSRs that may be on subtrees
			/*	in this page.  Their ibSon is correct but their itags
			/*	must be corrected 'top down'.
			/**/
			if ( PcsrCurrent( pfucbT ) != pcsrT )
				MCMMapItag( pgnoSplit, PcsrCurrent( pfucbT ), pcsrRoot, mpitag );

			break;
			}
		}

	return;
	}


VOID MCMMapItag( PGNO pgnoSplit, CSR *pcsr, CSR *pcsrUpdated, BYTE *mpitag )
	{
	/*	assert trivial case is not called for
	/**/
	Assert( pcsr != pcsrUpdated );

	/*	advance pcsr to lowest level in vertical split new page
	/**/
	for ( ; pcsr->pgno != pgnoSplit && pcsr != pcsrUpdated; pcsr = pcsr->pcsrPath )
		;
	if ( pcsr == pcsrUpdated )
		return;
	for ( ; pcsr->pgno == pgnoSplit && pcsr != pcsrUpdated; pcsr = pcsr->pcsrPath )
		{
		pcsr->pgno = pcsrUpdated->pgno;
		Assert( pcsr->itagFather != itagNil );
		Assert( FPMValidItag( pcsr->itagFather ) );
	 	Assert( mpitag[pcsr->itagFather] != itagFOP );
		pcsr->itagFather = mpitag[pcsr->itagFather];
		Assert( pcsr->ibSon >= 0 );
		if ( pcsr->itag != itagNil && pcsr->itag != itagNull )
			{
			Assert( FPMValidItag( pcsr->itag ) );
			Assert( mpitag[pcsr->itag] != itagFOP );
			pcsr->itag = mpitag[pcsr->itag];
			}
		}

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\cat.c ===
#include "daestd.h"
#include "_cat.c"

DeclAssertFile; 				/* Declare file name for assert macros */


#define ErrCATClose( ppib, pfucbCatalog )	ErrFILECloseTable( ppib, pfucbCatalog )

/*	retrieve index into rgsystabdef.
/**/
INLINE LOCAL INT ICATITableDefIndex( CHAR *szTable )
	{
	INT iTable;

	/*	even though this loop looks like it is just asserting,
	/*	it is really determining the proper index into rgsytabdef.
	/**/
	for ( iTable = 0;
		strcmp( rgsystabdef[iTable].szName, szTable ) != 0;
		iTable++ )
		{
		/*	the table MUST be in rgsystabdef somewhere, which is why we
		/*	do not need to put the boundary check on i into the for loop.
		/**/
		Assert( iTable < csystabs - 1 );
		}

	return iTable;
	}


INLINE LOCAL ERR ErrCATOpenById( PIB *ppib, DBID dbid, FUCB **ppfucbCatalog, INT itable )
	{
	ERR err;

	Assert( dbid != dbidTemp );
	CallR( ErrFILEOpenTable( ppib, dbid, ppfucbCatalog, rgsystabdef[itable].szName, 0 ) );
	FUCBSetSystemTable( *ppfucbCatalog );

	return err;
	}


/*	assumes caller will open system table, then close it and update timestamp
/*	when all inserts are completed.
/**/
INLINE LOCAL ERR ErrCATInsertLine( PIB *ppib, FUCB *pfucbCatalog, INT itable, LINE rgline[] )
	{
	ERR				err;
	INT				i;
	JET_COLUMNID	*pcolumnid;

	CallR( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepInsert ) );

	pcolumnid = rgsystabdef[itable].rgcolumnid;

	for ( i = 0; i < rgsystabdef[itable].ccolumn; i++, pcolumnid++ )
		{
		if ( rgline[i].cb != 0 )
			{
			Assert( rgline[i].cb > 0 );
			CallR( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				*pcolumnid,
				rgline[i].pb,
				rgline[i].cb,
				0, NULL ) );
			}
		}

	/*	insert record into system table
	/**/
	return ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL );
	}



/*=================================================================
ErrCATCreate

Description:

	Called from ErrIsamCreateDatabase; creates all system tables

Parameters:

	PIB		*ppib		; PIB of user
	DBID	dbid		; dbid of database that needs tables

Return Value:

	whatever error it encounters along the way

=================================================================*/

ERR ErrCATCreate( PIB *ppib, DBID dbid )
	{
	/*	NOTE:	Since the System Tables are inserted as records into
	/*			themselves, we have to special-case in the beginning
	/*			to avoid trying to insert a record into a table with
	/*			no columns. CreateTable, and CreateIndex thus
	/*			do as their first action a check of their dbid. If it's
	/*			>= dbidMax, then they don't Call STI ( they fix it up by
	/*			subtracting dbidMax, as well ). Thus, all of these Calls
	/*			to CT, CI, AC must add dbidMax to the dbid before making the
	/*			Call.
	/**/
	ERR				err;
	unsigned	   	i;
	INT				j;
	LINE		   	line;
	JET_DATESERIAL	dtNow;
	OBJTYP  	   	objtypTemp;
	OBJID		   	objidParentId;
	LINE			rgline[ilineSxMax];
	FUCB		   	*rgpfucb[csystabs];
	ULONG		   	rgobjid[csystabs];
	ULONG		   	ulFlag;
	FUCB			*pfucbCatalog = pfucbNil;
	BOOL			fSysTablesCreated = fFalse;
	
	//	UNDONE:		international support.  Set these values from
	//			   	create database connect string.
	USHORT  	   	cp = usEnglishCodePage;
	USHORT 			langid = langidDefault;

	BYTE		   	fAutoincrement = 0;
	BYTE		   	fDisallowNull = 0;
	BYTE		   	fVersion = 0;
	BYTE		   	fUnique = 0;
	BYTE		   	fPrimary = 0;
	BYTE		   	fIgnoreNull = 0;
	BYTE			bFlags = 0;
	SHORT			sFlags = 0;
	JET_COLUMNID	columnidInitial = 0;
	ULONG		   	ulDensity = ulFILEDefaultDensity;
	ULONG		   	ulLength;
	PGNO			rgpgnoIndexFDP[csystabs][cSysIdxs];

	/*	initialize rgpfucb[] to pfucbNil for error handling
	/**/
	for ( i = 0; i < csystabs; i++ )
		{
		rgpfucb[i] = pfucbNil;
		}

	/*	create System Tables
	/**/
	for ( i = 0; i < csystabs; i++ )
		{
		CODECONST(IDESC)	*pidesc;
		JET_TABLECREATE		tablecreate = { sizeof(JET_TABLECREATE),
											(CHAR *)rgsystabdef[i].szName,
											rgsystabdef[i].cpg,
											ulDensity,
											NULL, 0, NULL, 0,	// No columns/indexes
											JET_bitTableCreateSystemTable,
											0, 0 };

		Call( ErrFILECreateTable( ppib, dbid, &tablecreate ) );
		rgpfucb[i] = (FUCB *)( tablecreate.tableid );
		Assert( tablecreate.cCreated == 1 );		// Only the table was created.

		/*	columns are created at open table time
		/**/

		/*	create indexes
		/**/
		pidesc = rgsystabdef[i].pidesc;

		for ( j = 0; j < rgsystabdef[i].cindex; j++, pidesc++ )
			{
			const BYTE *pbT;

			rgpfucb[i]->dbid = dbid + dbidMax;		// Flag as system table.
			line.pb = pidesc->szIdxKeys;

			pbT = line.pb;
			forever
				{
				while ( *pbT != '\0' )
					pbT++;
				if ( *(++pbT) == '\0' )
					break;
				}
			line.cb = (ULONG)(pbT - line.pb) + 1;

			Call( ErrIsamCreateIndex( ppib,
				rgpfucb[i],
				pidesc->szIdxName,
				pidesc->grbit,
				(CHAR *)line.pb,
				(ULONG)line.cb,
				ulDensity ) );
			}
		}

	/*	close system tables
	/**/
	for ( i = 0; i < csystabs; i++ )
		{
		FCB *pfcb = rgpfucb[i]->u.pfcb;

		rgobjid[i] = pfcb->pgnoFDP;

		/*	non-clustered indexes are chained on pfcbNextIndex in
		/*	the reverse of the order in which they were defined.
		/**/
		for ( j = rgsystabdef[i].cindex - 1; j >= 0; j--)
			{
			if (rgsystabdef[i].pidesc[j].grbit & JET_bitIndexClustered)
				{
				rgpgnoIndexFDP[i][j] = rgobjid[i];
				}
			else
				{
				Assert(pfcb->pfcbNextIndex != pfcbNil);
				pfcb = pfcb->pfcbNextIndex;
				Assert( UtilCmpName( pfcb->pidb->szName,
					rgsystabdef[i].pidesc[j].szIdxName ) == 0 );
				Assert( pfcb->pgnoFDP != rgobjid[i] );
				rgpgnoIndexFDP[i][j] = pfcb->pgnoFDP;
				}
			Assert( rgpgnoIndexFDP[i][j] > pgnoSystemRoot );
			Assert( rgpgnoIndexFDP[i][j] <= pgnoSysMax );
			}
		Assert(pfcb->pfcbNextIndex == pfcbNil);

		CallS( ErrFILECloseTable( ppib, rgpfucb[i] ) );
		rgpfucb[i] = pfucbNil;
		}
	fSysTablesCreated = fTrue;

	// UNDONE:  is it necessary to create table and index records for system
	// tables, since we never read them anyway

	pfucbCatalog = pfucbNil;
	Call( ErrCATOpenById( ppib, dbid, &pfucbCatalog, itableSo ) );

	/*	table records
	/**/
	UtilGetDateTime( &dtNow );
	ulFlag = JET_bitObjectSystem;

	rgline[iMSO_DateCreate].pb		= (BYTE *)&dtNow;
	rgline[iMSO_DateCreate].cb		= sizeof(JET_DATESERIAL);
	rgline[iMSO_DateUpdate].pb		= (BYTE *)&dtNow;
	rgline[iMSO_DateUpdate].cb		= sizeof(JET_DATESERIAL);
	rgline[iMSO_Owner].pb			= (BYTE *)rgbSidEngine;
	rgline[iMSO_Owner].cb			= sizeof(rgbSidEngine);
	rgline[iMSO_Flags].pb			= (BYTE *)&ulFlag;
	rgline[iMSO_Flags].cb			= sizeof(ULONG);
	rgline[iMSO_Pages].cb			= 0;
	rgline[iMSO_Density].pb 		= (BYTE *) &ulDensity;
	rgline[iMSO_Density].cb			= sizeof(ulDensity);
	rgline[iMSO_Stats].cb			= 0;

	for ( i = 0; i < ( sizeof(rgsysobjdef) / sizeof(SYSOBJECTDEF) ); i++ )
		{
		rgline[iMSO_Id].pb			= (BYTE *) &rgsysobjdef[i].objid;
		rgline[iMSO_Id].cb			= sizeof(OBJID);
		rgline[iMSO_ParentId].pb	= (BYTE *) &rgsysobjdef[i].objidParent;
		rgline[iMSO_ParentId].cb	= sizeof(OBJID);
		rgline[iMSO_Name].pb		= (BYTE *) rgsysobjdef[i].szName;
		rgline[iMSO_Name].cb		= strlen( rgsysobjdef[i].szName );
		rgline[iMSO_Type].pb		= (BYTE *) &rgsysobjdef[i].objtyp;
		rgline[iMSO_Type].cb		= sizeof(OBJTYP);

		Call( ErrCATInsertLine( ppib, pfucbCatalog, itableSo, rgline ) );
		}

	objidParentId = objidTblContainer;
	objtypTemp  = JET_objtypTable;

	rgline[iMSO_ParentId].pb		= (BYTE *)&objidParentId;
	rgline[iMSO_ParentId].cb		= sizeof(objidParentId);
	rgline[iMSO_Type].pb			= (BYTE *)&objtypTemp;
	rgline[iMSO_Type].cb			= sizeof(objtypTemp);

	for ( i = 0; i < csystabs; i++ )
		{
		rgline[iMSO_Id].pb			= (BYTE *)&rgobjid[i];
		rgline[iMSO_Id].cb			= sizeof(LONG);
		rgline[iMSO_Name].pb		= (BYTE *)rgsystabdef[i].szName;
		rgline[iMSO_Name].cb		= strlen( rgsystabdef[i].szName );
		rgline[iMSO_Pages].pb 		= (BYTE *) &rgsystabdef[i].cpg;
		rgline[iMSO_Pages].cb 		= sizeof(rgsystabdef[i].cpg);

		Call( ErrCATInsertLine( ppib, pfucbCatalog, itableSo, rgline ) );
		}

	CallS( ErrCATClose( ppib, pfucbCatalog ) );	// No timestamp update needed.
	pfucbCatalog = pfucbNil;

	/*	column records
	/**/
	Call( ErrCATOpenById( ppib, dbid, &pfucbCatalog, itableSc ) );

	rgline[iMSC_ColumnId].pb		= (BYTE *)&columnidInitial;
	rgline[iMSC_ColumnId].cb		= sizeof(columnidInitial);
	rgline[iMSC_CodePage].pb		= (BYTE *)&cp;
	rgline[iMSC_CodePage].cb		= sizeof(cp);
	rgline[iMSC_Flags].pb			= &bFlags;
	rgline[iMSC_Flags].cb			= sizeof(bFlags);
	rgline[iMSC_Default].cb			= 0;
	rgline[iMSC_POrder].cb			= 0;

	for ( i = 0; i < csystabs; i++ )
		{
		CODECONST( CDESC )	*pcdesc;
		JET_COLUMNID		*pcolumnid;
		ULONG				ibRec = sizeof(RECHDR);

		pcdesc = rgsystabdef[i].pcdesc;
		pcolumnid = rgsystabdef[i].rgcolumnid;
		
		rgline[iMSC_ObjectId].pb 		= (BYTE *)&rgobjid[i];
		rgline[iMSC_ObjectId].cb 		= sizeof(LONG);

		for ( j = 0; j < rgsystabdef[i].ccolumn; j++, pcdesc++ )
			{
			rgline[iMSC_Name].pb 		= pcdesc->szColName;
			rgline[iMSC_Name].cb 		= strlen( pcdesc->szColName );
			rgline[iMSC_ColumnId].pb	= (BYTE *)( pcolumnid + j );
			rgline[iMSC_ColumnId].cb  	= sizeof(JET_COLUMNID);
			rgline[iMSC_Coltyp].pb 		= (BYTE *) &pcdesc->coltyp;
			rgline[iMSC_Coltyp].cb 		= sizeof(BYTE);

			Assert( pcdesc->coltyp != JET_coltypNil );
			ulLength = UlCATColumnSize( pcdesc->coltyp, pcdesc->ulMaxLen, NULL );
			rgline[iMSC_Length].pb		= (BYTE *)&ulLength;
			rgline[iMSC_Length].cb		= sizeof(ULONG);

			if ( FFixedFid( (FID)pcolumnid[j] ) )
				{
				rgline[iMSC_RecordOffset].pb = (BYTE *)&ibRec;
				rgline[iMSC_RecordOffset].cb = sizeof(WORD);
				ibRec += ulLength;
				}
			else
				{
				Assert( FVarFid( (FID)pcolumnid[j] )  ||  FTaggedFid( (FID)pcolumnid[j] ) );
				rgline[iMSC_RecordOffset].pb = 0;
				rgline[iMSC_RecordOffset].cb = 0;
				}

			Call( ErrCATInsertLine( ppib, pfucbCatalog, itableSc, rgline ) );
			}
		}

	CallS( ErrCATClose( ppib, pfucbCatalog ) );	// No timestamp update needed.
	pfucbCatalog = pfucbNil;


	/*	index records
	/**/
	Call( ErrCATOpenById( ppib, dbid, &pfucbCatalog, itableSi ) );

	rgline[iMSI_Density].pb				= (BYTE *) &ulDensity;
	rgline[iMSI_Density].cb 			= sizeof(ulDensity);
	rgline[iMSI_LanguageId].pb			= (BYTE *)&langid;
	rgline[iMSI_LanguageId].cb			= sizeof(langid);
	rgline[iMSI_Flags].pb				= (BYTE *)&sFlags;
	rgline[iMSI_Flags].cb				= sizeof(sFlags);
	rgline[iMSI_Stats].cb				= 0;

	//	UNDONE: we do not store the key fields for system table indexes,
	//	because we should already know them.  However, if for some reason it is
	//	necessary then it should be stored here.
	rgline[iMSI_KeyFldIDs].cb			= 0;

	for ( i = 0; i < csystabs; i++ )
		{
		CODECONST( IDESC ) *pidesc;

		pidesc = rgsystabdef[i].pidesc;

		rgline[iMSI_ObjectId].pb 		= (BYTE *)&rgobjid[i];
		rgline[iMSI_ObjectId].cb 		= sizeof(LONG);

		for ( j = 0; j < rgsystabdef[i].cindex; j++, pidesc++ )
			{
			rgline[iMSI_Name].pb 		= pidesc->szIdxName;
			rgline[iMSI_Name].cb 		= strlen( pidesc->szIdxName );
			rgline[iMSI_IndexId].pb		= (BYTE *)&rgpgnoIndexFDP[i][j];
			rgline[iMSI_IndexId].cb		= sizeof(PGNO);

			Call( ErrCATInsertLine( ppib, pfucbCatalog, itableSi, rgline ) );
			}
		}

	CallS( ErrCATClose( ppib, pfucbCatalog ) );	// No timestamp update needed.

	return JET_errSuccess;


HandleError:
	if ( fSysTablesCreated )
		{
		if ( pfucbCatalog != pfucbNil )
			{
			CallS( ErrCATClose( ppib, pfucbCatalog ) );
			}
		}
	else
		{
		/*	on creation failure, close any system tables that are still open
		/**/
		for ( i = 0; i < csystabs; i++ )
			{
			if ( rgpfucb[i] != pfucbNil )
				{
				CallS( ErrFILECloseTable( ppib, rgpfucb[i] ) );
				}
			}
		}
		
	return err;
	}



// UNDONE: Currently only support batch insert into MSysColumns.  May support
// other system tables in the future if required by simply modifying the
// JET_COLUMNCREATE parameter to be a generic pointer and introducing an itable
// parameter.
ERR ErrCATBatchInsert(
	PIB					*ppib,
	DBID				dbid,
	JET_COLUMNCREATE	*pcolcreate,
	ULONG				cColumns,
	OBJID				objidTable,
	BOOL				fCompacting )
	{
	ERR					err;
	FUCB				*pfucbCatalog = NULL;
	LINE				rgline[ilineSxMax];
	JET_COLUMNCREATE	*plastcolcreate;

	// The following variables are only used to copy information to the catalog.
	WORD				ibNextFixedOffset = sizeof(RECHDR);
	BYTE				szFieldName[ JET_cbNameMost + 1 ];
	BYTE				bFlags;
	USHORT				cp;

	CallR( ErrCATOpenById( ppib, dbid, &pfucbCatalog, itableSc ) );

	rgline[iMSC_ObjectId].pb = (BYTE *)&objidTable;
	rgline[iMSC_ObjectId].cb = sizeof(objidTable);

	plastcolcreate = pcolcreate + cColumns;
	for ( ; pcolcreate < plastcolcreate; pcolcreate++ )
		{
		Assert( pcolcreate < plastcolcreate );

		// Name should already have been checked in FILEIBatchAddColumn(), but we
		// need to get the result, so we must do the check again.
		CallS( ErrUTILCheckName( szFieldName, pcolcreate->szColumnName, ( JET_cbNameMost + 1 ) ) );


		// For text columns, set code page.
		if ( FRECTextColumn( pcolcreate->coltyp ) )
			{
			// Should already have been validated in FILEIAddColumn().
			Assert( (USHORT)pcolcreate->cp == usEnglishCodePage  ||
				(USHORT)pcolcreate->cp == usUniCodePage );
			cp = (USHORT)pcolcreate->cp;
			}
		else
			cp = 0;		// Code page is inapplicable for all other column types.


		bFlags = 0;		// Initialise field options.


		//	UNDONE:	interpret pbDefault of NULL for NULL value, and
		//			cbDefault == 0 and pbDefault != NULL as set to
		//			zero length.
		if ( pcolcreate->cbDefault > 0 )
			{
			Assert( pcolcreate->pvDefault != NULL );
			FIELDSetDefault( bFlags );
			}

		if ( pcolcreate->grbit & JET_bitColumnVersion )
			{
			Assert( pcolcreate->coltyp == JET_coltypLong );
			Assert( !( pcolcreate->grbit & JET_bitColumnTagged ) );
			Assert( FFixedFid( pcolcreate->columnid ) );
			FIELDSetVersion( bFlags );
			}

		if ( pcolcreate->grbit & JET_bitColumnAutoincrement )
			{
			Assert( pcolcreate->coltyp == JET_coltypLong );
			Assert( !( pcolcreate->grbit & JET_bitColumnTagged ) );
			Assert( FFixedFid( pcolcreate->columnid ) );
			FIELDSetAutoInc( bFlags );
			}

		if ( pcolcreate->grbit & JET_bitColumnNotNULL )
			{
			FIELDSetNotNull( bFlags );
			}

		if ( pcolcreate->grbit & JET_bitColumnMultiValued )
			{
			FIELDSetMultivalue( bFlags );
			}


		if ( fCompacting )
			{
			USHORT	usPOrder = 0;

			}
		rgline[iMSC_Name].pb				= szFieldName;
		rgline[iMSC_Name].cb				= strlen(szFieldName);
		rgline[iMSC_ColumnId].pb			= (BYTE *)&pcolcreate->columnid;
		rgline[iMSC_ColumnId].cb			= sizeof(pcolcreate->columnid);
		rgline[iMSC_Coltyp].pb				= (BYTE *)&pcolcreate->coltyp;
		rgline[iMSC_Coltyp].cb				= sizeof(BYTE);
		rgline[iMSC_Length].pb				= (BYTE *)&pcolcreate->cbMax;
		rgline[iMSC_Length].cb				= sizeof(pcolcreate->cbMax);
		rgline[iMSC_CodePage].pb			= (BYTE *)&cp;
		rgline[iMSC_CodePage].cb			= sizeof(cp);
		rgline[iMSC_Flags].pb				= &bFlags;
		rgline[iMSC_Flags].cb				= sizeof(bFlags);
		rgline[iMSC_Default].pb				= (BYTE *)pcolcreate->pvDefault;
		rgline[iMSC_Default].cb				= pcolcreate->cbDefault;
		rgline[iMSC_POrder].cb				= 0;

		if ( fCompacting )
			{
			USHORT usPOrder;

			// Presentation order list hangs off the end of the column name
			// (+1 for null-terminator, +3 for alignment).
			usPOrder = *(USHORT *)(pcolcreate->szColumnName + JET_cbNameMost + 1 + 3);

			Assert( usPOrder >= 0 );
			if ( usPOrder > 0 )
				{
				rgline[iMSC_POrder].pb = pcolcreate->szColumnName + JET_cbNameMost + 1 + 3;
				rgline[iMSC_POrder].cb = sizeof(USHORT);
				}
			}


		if ( FFixedFid( pcolcreate->columnid ) )
			{
			rgline[iMSC_RecordOffset].pb = (BYTE *)&ibNextFixedOffset;
			rgline[iMSC_RecordOffset].cb = sizeof(WORD);

			Call( ErrCATInsertLine( ppib, pfucbCatalog, itableSc, rgline ) );

			// Update next fixed offset only after it's been written to the catalog.
			ibNextFixedOffset += (WORD)pcolcreate->cbMax;
			}
		else
			{
			// Don't need to persist record offsets for var/tagged columns.
			Assert( FVarFid( pcolcreate->columnid )  ||  FTaggedFid( pcolcreate->columnid ) );
			rgline[iMSC_RecordOffset].cb = 0;

			Call( ErrCATInsertLine( ppib, pfucbCatalog, itableSc, rgline ) );
			}


		}	// for

	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


/*=================================================================
ErrCATInsert

Description:

	Inserts a record into a system table when new tables, indexes,
	or columns are added to the database.

Parameters:

	PIB		*ppib;
	DBID   	dbid;
	INT		itable;
	LINE   	rgline[];

Return Value:

	whatever error it encounters along the way

=================================================================*/

ERR ErrCATInsert( PIB *ppib, DBID dbid, INT itable, LINE rgline[], OBJID objid )
	{
	ERR		err;
	FUCB	*pfucbCatalog = NULL;

	/*	open system table
	/**/
	CallR( ErrCATOpenById( ppib, dbid, &pfucbCatalog, itable ) );

	err = ErrCATInsertLine( ppib, pfucbCatalog, itable, rgline );

	/*	close system table
	/**/
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	/*	timestamp owning table if applicable
	/**/
	Assert( objid > 0 );
	if ( err >= JET_errSuccess  &&  ( itable == itableSi  || itable == itableSc ) )
		{
		CallR( ErrCATTimestamp( ppib, dbid, objid ) );
		}

	return err;
	}


/*	opens a catalog table and sets the specified index.
/**/
LOCAL ERR ErrCATOpen( PIB *ppib,
	DBID		dbid,
	const CHAR	*szCatTable,
	const CHAR	*szCatIndex,
	BYTE		*rgbKeyValue,
	ULONG		cbKeyValue,
	FUCB		**ppfucbCatalog )
	{
	ERR			err;

	/*	open the catalog and set to the correct index.
	/**/
	Assert( dbid != dbidTemp );
	CallR( ErrFILEOpenTable( ppib, dbid, ppfucbCatalog, szCatTable, 0 ) );
	FUCBSetSystemTable( *ppfucbCatalog );
	Call( ErrIsamSetCurrentIndex( ppib, *ppfucbCatalog, szCatIndex ) );

	Call( ErrIsamMakeKey( ppib, *ppfucbCatalog, rgbKeyValue, cbKeyValue, JET_bitNewKey ) );

	return JET_errSuccess;

HandleError:
	CallS( ErrFILECloseTable( ppib, *ppfucbCatalog ) );
	return err;
	}


// Moves to the next record in the catalog and determines if the record is an entry
// for a specified table and, optionally, a name.
//
// PARAMETERS:	columnidObjidCol - the columnid of the column containing the table id.
//				objidTable	- the table id that the contents of columnidObjidCol should
//							  match.
//				columnidNameCol	- the columnid of the column containing the name.
//				szName		- the name that the contents of columnidNameCol should match.
//
// NOTES:	This routine is typically used as the loop condition for processing
//			a range of records (eg. all the records matching a particular table id)
//			in the catalog.
INLINE LOCAL ERR ErrCATNext( PIB *ppib,
	FUCB			*pfucbCatalog,
	JET_COLUMNID	columnidObjidCol,
	OBJID			objidTable,
	JET_COLUMNID	columnidNameCol,
	CHAR			*szName )
	{
	ERR				err;
	OBJID			objidCurrTable;
	CHAR			szCurrName[JET_cbNameMost+1];
	ULONG			cbActual;

	Call( ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, 0 ) );

	Call( ErrIsamRetrieveColumn( ppib, pfucbCatalog, columnidObjidCol,
		(BYTE *)&objidCurrTable, sizeof(OBJID),
		&cbActual, 0, NULL ) );

	if ( objidCurrTable != objidTable )
		{
		return ErrERRCheck( JET_errRecordNotFound );
		}

	if ( columnidNameCol != 0 )
		{
		Assert( szName != NULL );

		Call( ErrIsamRetrieveColumn( ppib,
			pfucbCatalog,
			columnidNameCol,
			(BYTE *)szCurrName,
			JET_cbNameMost,
			&cbActual,
			0,
			NULL ) );
		szCurrName[cbActual] = '\0';
		
		if ( UtilCmpName( szCurrName, szName ) != 0 )
			{
			return ErrERRCheck( JET_errRecordNotFound );
			}
		}

	err = JET_errSuccess;
HandleError:
	return err;
	}


/*=================================================================
ErrCATDelete

Description:

	Deletes records from System Tables when tables, indexes, or
	columns are removed from the database.

Parameters:

	PIB		*ppib;
	DBID	dbid;
	INT		itable;
	CHAR	*szName;
	OBJID	objid;

=================================================================*/
ERR ErrCATDelete( PIB *ppib, DBID dbid, INT itable, CHAR *szName, OBJID objid )
	{
	ERR				err;
	FUCB	   		*pfucb;
	LINE	   		line;
	OBJID	   		objidParentId;
	ULONG	   		cbActual;

	CallR( ErrCATOpenById( ppib, dbid, &pfucb, itable ) );

	switch ( itable )
		{
		case itableSo:
			Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSoNameIndex ) );
			/*	set up key and seek for record in So
			/**/
			objidParentId = objidTblContainer;
			line.pb = (BYTE *)&objidParentId;
			line.cb = sizeof(objidParentId);
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) );
			line.pb = szName;
			line.cb = strlen( szName );
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, 0 ) );

			err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
			if ( err != JET_errSuccess )
				{
				goto HandleError;
				}

			/*	get the table id, then delete it
			/**/
			Call( ErrIsamRetrieveColumn( ppib,
				pfucb,
				CATIGetColumnid(itableSo, iMSO_Id),
				(BYTE *)&objid,
				sizeof(objid),
				&cbActual,
				0,
				NULL ) );
			Call( ErrIsamDelete( ppib, pfucb ) );
			CallS( ErrCATClose( ppib, pfucb ) );

			/*	delete associated indexes
			/**/
			CallR( ErrCATOpen( ppib, dbid, szSiTable, szSiObjectIdNameIndex,
				(BYTE *)&objid, sizeof(OBJID), &pfucb ) );

			/*	seek may not find anything
		 	/**/
			if ( ( ErrIsamSeek( ppib, pfucb, JET_bitSeekGE ) ) >= 0 )
				{
				Call( ErrIsamMakeKey( ppib, pfucb, (BYTE *)&objid, sizeof(OBJID),
					JET_bitNewKey | JET_bitStrLimit ) );
				err = ErrIsamSetIndexRange( ppib, pfucb, JET_bitRangeUpperLimit );
				while ( err != JET_errNoCurrentRecord )
					{
					if ( err != JET_errSuccess )
						{
						goto HandleError;
						}
					
					Call( ErrIsamDelete( ppib, pfucb ) );
					err = ErrIsamMove( ppib, pfucb, JET_MoveNext, 0 );
					}

				Assert( err == JET_errNoCurrentRecord );
				}

			CallS( ErrCATClose( ppib, pfucb ) );

			/*	delete associated columns
			/**/
			Call( ErrCATOpen( ppib, dbid, szScTable, szScObjectIdNameIndex,
				(BYTE *)&objid, sizeof(OBJID), &pfucb ) );

			if ( ( ErrIsamSeek( ppib, pfucb, JET_bitSeekGE ) ) >= 0 )
				{
				Call( ErrIsamMakeKey( ppib, pfucb, (BYTE *)&objid, sizeof(OBJID),
					JET_bitNewKey | JET_bitStrLimit) );
				err = ErrIsamSetIndexRange( ppib, pfucb, JET_bitRangeUpperLimit);
				while ( err != JET_errNoCurrentRecord )
					{
					if ( err != JET_errSuccess )
						goto HandleError;
					
					Call( ErrIsamDelete( ppib, pfucb ) );
					err = ErrIsamMove( ppib, pfucb, JET_MoveNext, 0 );
					}

				Assert( err == JET_errNoCurrentRecord );
				}

			CallS( ErrCATClose( ppib, pfucb ) );
			break;

		case itableSi:
			Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSiObjectIdNameIndex ) );

			/*	set up key and seek for record in itableSi
			/**/
			line.pb = (BYTE *)&objid;
			line.cb = sizeof(objid);
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) );
			line.pb = (BYTE *)szName;
			line.cb = strlen( szName );
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, 0 ) );

			err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
			if ( err != JET_errSuccess )
				{
				goto HandleError;
				}
			Call( ErrIsamDelete( ppib, pfucb ) );
			break;
		default:
			Assert( itable == itableSc );
			Call( ErrIsamSetCurrentIndex( ppib, pfucb, szScObjectIdNameIndex ) );

			/*	set up key and seek for record in itableSc
			/**/
			line.pb = (BYTE *)&objid;
			line.cb = sizeof(objid);
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, JET_bitNewKey ) );
			line.pb = (BYTE *) szName;
			line.cb = strlen( szName );
			Call( ErrIsamMakeKey( ppib, pfucb, line.pb, line.cb, 0 ) );
			err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
			if ( err != JET_errSuccess )
				{
				goto HandleError;
				}

			forever			
				{
				BYTE	coltyp;
				
				Call( ErrIsamRetrieveColumn( ppib, pfucb,
					CATIGetColumnid( itableSc, iMSC_Coltyp ),
					&coltyp, sizeof(coltyp),
					&cbActual, 0, NULL ) );
				Assert( cbActual == sizeof(coltyp) );

				/*	ensure the column has not already been deleted
				/**/
				if ( coltyp != JET_coltypNil )
					{
					Call( ErrIsamDelete( ppib, pfucb ) );
					break;
					}

				/*	table name entry MUST exist
				/**/
				err = ErrCATNext( ppib, pfucb,
					CATIGetColumnid( itableSc, iMSC_ObjectId ), objid,
					CATIGetColumnid( itableSc, iMSC_Name ), szName );
				if ( err < 0 )
					{
					if ( err == JET_errNoCurrentRecord || err == JET_errRecordNotFound )
						err = ErrERRCheck( JET_errColumnNotFound );
					goto HandleError;
					}
				}	// forever
			break;
		}
	
	/*	close table and timestamp owning table if applicable
	/**/
	if ( objid != 0 && ( ( itable == itableSi ) || ( itable == itableSc ) ) )
		{
		CallS( ErrCATClose( ppib, pfucb ) );
		CallR( ErrCATTimestamp( ppib, dbid, objid ) );
		}

	return JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucb ) );
	return err;
	}


/*	replaces the value in a column of a record of a system table.
/**/
ERR ErrCATReplace( PIB *ppib,
	DBID	dbid,
	INT		itable,
	OBJID	objidTable,
	CHAR	*szName,
	INT		iReplaceField,
	BYTE	*rgbReplaceValue,
	INT		cbReplaceValue )
	{
	ERR		err;
	FUCB	*pfucbCatalog = NULL;
	BYTE	coltyp;
	ULONG	cbActual;

	Assert( itable == itableSc );
	Assert( objidTable != 0 );

	CallR( ErrCATOpen( ppib, dbid, rgsystabdef[itable].szName,
		szScObjectIdNameIndex, (BYTE *)&objidTable,
		sizeof(objidTable), &pfucbCatalog ) );

	Call( ErrIsamMakeKey( ppib, pfucbCatalog, (BYTE *)szName, strlen(szName), 0 ) );
	Call( ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekEQ ) );

	forever			
		{
		Call( ErrIsamRetrieveColumn( ppib, pfucbCatalog,
			CATIGetColumnid(itable, iMSC_Coltyp), &coltyp, sizeof(coltyp),
			&cbActual, 0, NULL ) );
		Assert( cbActual == sizeof(coltyp) );

		/*	ensure the column has not already been deleted
		/**/
		if ( coltyp != JET_coltypNil )
			{
			Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
			Call( ErrIsamSetColumn( ppib, pfucbCatalog,
				CATIGetColumnid(itable, iReplaceField),
				rgbReplaceValue, cbReplaceValue, 0, NULL ) );
			Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL ) );
			break;
			}

		/*	table name entry MUST exist
		/**/
		if ( ( err = ErrCATNext( ppib, pfucbCatalog,
			CATIGetColumnid(itable, iMSC_ObjectId),
			objidTable,
			CATIGetColumnid(itable, iMSC_Name),
			szName ) ) < 0 )
			{
			if ( err == JET_errNoCurrentRecord ||
				err == JET_errRecordNotFound )
				{
				err = ErrERRCheck( JET_errColumnNotFound );
				}
			goto HandleError;
			}
		}
								
	/*	close table and timestamp owning table if applicable
	/**/
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	err = ErrCATTimestamp( ppib, dbid, objidTable );
	return err;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


/*=================================================================
ErrCATRename

Description:

	Alters system table records.

Parameters:

	PIB		*ppib;
	DBID	dbid;
	CHAR	*szNew;
	CHAR	*szName;
	OBJID	objid;
	INT		itable;

=================================================================*/

ERR ErrCATRename(
	PIB					*ppib,
	DBID				dbid,
	CHAR				*szNew,
	CHAR				*szName,
	OBJID				objid,
	INT					itable )
	{
	ERR					err;
	ERR					errDuplicate;
	const CHAR		  	*szIndexToUse;
	INT 				iRenameField;
	FUCB				*pfucb = NULL;
	JET_DATESERIAL		dtNow;

	switch ( itable )
		{
		case itableSo:
			szIndexToUse = szSoNameIndex;
			iRenameField = iMSO_Name;
			/*	for JET compatibility, must use JET_errTableDuplicate
			/**/
			// errDuplicate = JET_errObjectDuplicate;
			errDuplicate = JET_errTableDuplicate;
			break;
		case itableSi:
			szIndexToUse = szSiObjectIdNameIndex;
			iRenameField = iMSI_Name;
			errDuplicate = JET_errIndexDuplicate;
			break;
		default:
			Assert( itable == itableSc );
			szIndexToUse = szScObjectIdNameIndex;
			iRenameField = iMSC_Name;
			errDuplicate = JET_errColumnDuplicate;
		}

	CallR( ErrCATOpen( ppib, dbid, rgsystabdef[itable].szName,
		szIndexToUse, (BYTE *)&objid, sizeof(objid), &pfucb ) );
	Call( ErrIsamMakeKey( ppib, pfucb, szName, strlen( szName ), 0 ) );
	Call( ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ ) );

	if ( itable == itableSc || itable == itableSi )
	   	{
		/*	When the name to change is part of the clustered index (as
		/*	is the case for columns and indexes), we can't simply replace
		/*	the old name with the new name because the physical position
		/*	of the record would change, thus invalidating any bookmarks.
		/*	Hence, we must do a manual delete, then insert.
		/*	This part is a little tricky.  Our call to PrepareUpdate
		/*	provided us with a copy buffer.  So now, when we call Delete,
		/*	we still have a copy of the record we just deleted.
		/*	Here, we are inserting a new record, but we are using the
		/*	information from the copy buffer.
		/**/
		Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepInsertCopy ) );
		Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itable, iRenameField),
			szNew, strlen( szNew ), 0, NULL ) );
		Call( ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL ) );

		Call( ErrIsamDelete( ppib, pfucb ) );

		/*	update the timestamp of the corresponding object
		/**/
		Call( ErrCATTimestamp( ppib, dbid, objid ) );
		}
	else
		{
		Assert( itable == itableSo );

		Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepReplaceNoLock ) );

		/*	the name is not part of the clustered index, so a simple
		/*	replace is okay.
		/**/
		Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itableSo, iRenameField),
			szNew, strlen( szNew ), 0, NULL ) );

		/*	update date/time stamp
		/**/
		UtilGetDateTime( &dtNow );
		Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_DateUpdate),
			(BYTE *)&dtNow, sizeof(dtNow), 0, NULL ) );
		Call( ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL ) );
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucb ) );
	return ( err == JET_errKeyDuplicate ? ErrERRCheck( errDuplicate ) : err );
	}


/*=================================================================
ErrCATTimestamp

Description:

	Updates the DateUpdate field of the affected table's entry in
	So. This function is called indirectly, via ErrCATInsert
	and ErrCATDelete.

Parameters:

	PIB 		*ppib		; PIB of user
	DBID		dbid		; database ID of new table
	OBJID		objid;

=================================================================*/

ERR ErrCATTimestamp( PIB *ppib, DBID dbid, OBJID objid )
	{
	ERR				err;
	FUCB			*pfucb = NULL;
	JET_DATESERIAL	dtNow;
	LINE			*plineNewData;

	/*	open MSysObjects
	/**/
	Assert( objid != 0 );
	CallR( ErrCATOpen( ppib, dbid, szSoTable, szSoIdIndex,
		(BYTE *)&objid, sizeof(objid), &pfucb ) );

	err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
	if ( err != JET_errSuccess )
		{
		goto HandleError;
		}

	Call( ErrIsamPrepareUpdate( ppib, pfucb , JET_prepReplaceNoLock ) );
	UtilGetDateTime( &dtNow );
	Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_DateUpdate),
		(BYTE *)&dtNow, sizeof(JET_DATESERIAL), 0, NULL ) );
//	UNDONE:	fix write conflict contention below
//	Call( ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL ) );
	plineNewData = &pfucb->lineWorkBuf;
	Call( ErrDIRReplace( pfucb, plineNewData, fDIRNoVersion ) );
	
	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucb ) );
	return err;
	}


/*	ErrCATFindObjidFromIdName
/*	This routine can be used for getting the OBJID and OBJTYP of any existing
/*	database object using the SoName <ParentId, Name> index on So.
/**/
ERR ErrCATFindObjidFromIdName(
	PIB				*ppib,
	DBID   			dbid,
	OBJID  			objidParentId,
	const CHAR		*lszName,
	OBJID  			*pobjid,
	JET_OBJTYP		*pobjtyp )
	{
	ERR				err;
	FUCB   			*pfucb = NULL;
	OBJID  			objidObject;
	OBJTYP			objtypObject;
	ULONG  			cbActual;

	/*	open and set up first half of key
	/**/
	CallR( ErrCATOpen( ppib, dbid, szSoTable, szSoNameIndex,
		(BYTE *)&objidParentId, sizeof(objidParentId), &pfucb ) );

	/*	set up rest of key and seek for record in So
	/**/
	Call( ErrIsamMakeKey( ppib, pfucb, (BYTE *)lszName, strlen(lszName), 0 ) );
	if ( ( err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ ) ) !=	JET_errSuccess )
		{
		if ( err == JET_errRecordNotFound )
			{
			err = ErrERRCheck( JET_errObjectNotFound );
			}
		goto HandleError;
		}

	/*	get the Object Id
	/**/
	Call( ErrIsamRetrieveColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_Id),
		(BYTE *)&objidObject, sizeof(objidObject), &cbActual, 0, NULL ) );

	/*	get the Object Type
	/**/
	Call( ErrIsamRetrieveColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_Type),
		(BYTE *)&objtypObject, sizeof(objtypObject), &cbActual, 0, NULL ) );

	CallS( ErrCATClose( ppib, pfucb ) );

	Assert( pobjid != NULL );
	*pobjid = objidObject;
	if ( pobjtyp != NULL )
		{
		*pobjtyp = (JET_OBJTYP)objtypObject;
		}

	return JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucb ) );

	return err;
	}


/*		ErrCATFindNameFromObjid
/*
/*		This routine can be used for getting the name of any existing
/*		database object using the Id <Id> index on So.
/**/
ERR ErrCATFindNameFromObjid( PIB *ppib, DBID dbid, OBJID objid, VOID *pv, unsigned long cbMax, unsigned long *pcbActual )
	{			 	
	ERR				err;
	FUCB			*pfucb = NULL;
	unsigned long	cbActual;

	CallR( ErrCATOpen( ppib, dbid, szSoTable, szSoIdIndex,
		(BYTE *)&objid, sizeof(objid), &pfucb ) );

	err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ );
	if ( err != JET_errSuccess )
		{
		if ( err == JET_errRecordNotFound )
			{
			err = ErrERRCheck( JET_errObjectNotFound );
			}
		goto HandleError;
		}

	/*	retrieve object name and NULL terminate
	/**/
	Call( ErrIsamRetrieveColumn( ppib,
		pfucb,
		CATIGetColumnid(itableSo, iMSO_Name),
		pv,
		cbMax,
		&cbActual,
		0,
		NULL ) );
	((CHAR *)pv)[cbActual] = '\0';

	err = JET_errSuccess;
	if ( pcbActual != NULL )
		*pcbActual = cbActual;

HandleError:
	CallS( ErrCATClose( ppib, pfucb ) );

	return err;
	}


/*		ErrIsamGetObjidFromName
/*
/*		This routine can be used for getting the OBJID of any existing
/*		database object from its container/object name pair.
/**/

ERR VTAPI ErrIsamGetObjidFromName( JET_SESID sesid, JET_DBID vdbid, const char *lszCtrName, const char *lszObjName, OBJID *pobjid )
	{
	/*	Follow these rules:
	/*
	/*		ParentId		+	Name		-->		Id
	/*		--------			----				--
	/*		1.	( objidRoot )			ContainerName		objidOfContainer
	/*		2.	objidOfContainer	ObjectName			objidOfObject
	/**/
	ERR			err;
	DBID   		dbid;
	PIB			*ppib = (PIB *)sesid;
	OBJID 		objid;
	JET_OBJTYP	objtyp;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	dbid = DbidOfVDbid( vdbid );

	/*	get container information first...
	/**/
	if ( lszCtrName == NULL || *lszCtrName == '\0' )
		{
		objid = objidRoot;
		}
	else
		{
		CallR( ErrCATFindObjidFromIdName( ppib, dbid, objidRoot, lszCtrName, &objid, &objtyp ) );
		Assert( objid != objidNil );
		if ( objtyp != JET_objtypContainer )
			{
			return ErrERRCheck( JET_errObjectNotFound );
			}
		}

	/*	get object information next...
	*/
	CallR( ErrCATFindObjidFromIdName( ppib, dbid, objid, lszObjName, &objid, NULL ) );
	Assert( objid != objidNil );

	*pobjid = objid;
	return JET_errSuccess;
	}


/*=================================================================
ErrIsamCreateObject

Description:
  This routine is used to create an object record in So.

  It is expected that at the time this routine is called, all parameters
  will have been checked and all security constraints will have been
  satisfied.

Parameters:
  sesid 		identifies the session uniquely.
  dbid			identifies the database in which the object resides.
  objidParentId identifies the parent container object by OBJID.
  szObjectName	identifies the object within said container.
  objtyp		the value to be set for the appropriate So column.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  None specific to this routine.

Side Effects:
=================================================================*/
ERR VTAPI ErrIsamCreateObject( JET_VSESID vsesid, JET_DBID vdbid, OBJID objidParentId, const char *szName, JET_OBJTYP objtyp )
	{
	/*	Build a new record for So using the supplied data,
	/*	and insert the record into So.
	/*
	/*	Assumes that warning values returned by ErrIsamFoo routines mean
	/*	that it is still safe to proceed.
	/**/
	ERR				err;
	PIB				*ppib = (PIB *)vsesid;
	DBID   			dbid;
	CHAR   			szObject[JET_cbNameMost + 1];
	FUCB			*pfucb;
	LINE			line;
	OBJID			objidNewObject;
	OBJTYP			objtypSet = (OBJTYP)objtyp;
	JET_DATESERIAL	dtNow;
	ULONG			cbActual;
	ULONG			ulFlags = 0;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	CallR( VDbidCheckUpdatable( vdbid ) );
	dbid = DbidOfVDbid( vdbid );

	CallR( ErrUTILCheckName( szObject, szName, (JET_cbNameMost + 1) ) );

	/*	start a transaction so we get a consistent object id value
	/**/
	CallR( ErrDIRBeginTransaction( ppib ) );

	/*	open the So table and set the current index to Id...
	/**/
	Call( ErrCATOpenById( ppib, dbid, &pfucb, itableSo ) );

	Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSoIdIndex ) );

	/*	get the new object's OBJID value: find the highest-valued OBJID
	/*	in the index, increment it by one and use the result...
	/**/
	Call( ErrIsamMove( ppib, pfucb, JET_MoveLast, 0 ) );

	Call( ErrIsamRetrieveColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_Id),
		(BYTE *)&objidNewObject, sizeof(objidNewObject), &cbActual, 0, NULL ) );

	/*	prepare to create the new user account record...
	/**/
	Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepInsert ) );

	/*	set the Objid column...
	/**/
	objidNewObject++;
	line.pb = (BYTE *) &objidNewObject;
	line.cb = sizeof(objidNewObject);
	Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_Id),
		line.pb, line.cb, 0, NULL ) );

	/*	set the ParentId column...
	/**/
	line.pb = (BYTE *) &objidParentId;
	line.cb = sizeof(objidParentId);
	Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_ParentId),
		line.pb, line.cb, 0, NULL ) );

	/*	set the ObjectName column...
	/**/
	line.pb = (BYTE *) szObject;
	line.cb = strlen( szObject );
	Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_Name),
		line.pb, line.cb, 0, NULL ) );

	/*	set the Type column...
	/**/
	line.pb = (BYTE *)&objtypSet;
	line.cb = sizeof(objtypSet);
	Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_Type),
		line.pb, line.cb, 0, NULL ) );

	/*	set the DateCreate column...
	/**/
	UtilGetDateTime( &dtNow );
	line.pb = (BYTE *) &dtNow;
	line.cb = sizeof(JET_DATESERIAL);
	Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_DateCreate),
		line.pb, line.cb, 0, NULL ) );

	/*	set the DateUpdate column...
	/**/
	line.pb = (BYTE *) &dtNow;
	line.cb = sizeof(JET_DATESERIAL);
	Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_DateUpdate),
		line.pb, line.cb, 0, NULL ) );

	/*	set the Flags column...
	/**/
	Call( ErrIsamSetColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_Flags),
		(BYTE *)&ulFlags, sizeof(ulFlags), 0, NULL ) );

	/*	Add the record to the table.  Note that an error returned here
	/*	means that the transaction has already been rolled back and
	/*	So has been closed.
	/**/
	err = ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL );
	if ( err < 0 )
		{
		if ( err == JET_errKeyDuplicate )
			err = ErrERRCheck( JET_errObjectDuplicate );
		goto HandleError;
		}

	/*	close table
	/**/
	CallS( ErrCATClose( ppib, pfucb ) );
	err = ErrDIRCommitTransaction( ppib, 0 );
	if ( err >= 0 )
		{
		return JET_errSuccess;
		}

HandleError:
	/*	close table by aborting
	/**/
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}


/*=================================================================
ErrIsamDeleteObject

Description:
  This routine is used to delete an object record from So.

  It is expected that at the time this routine is called, all parameters
  will have been checked and all security constraints will have been
  satisfied.

Parameters:
  sesid 		identifies the session uniquely.
  dbid			identifies the database in which the object resides.
  objid 		identifies the object uniquely for dbid; obtained from
				ErrIsamGetObjidFromName.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errObjectNotFound:
    There does not exist an object bearing the specfied objid in dbid.

Side Effects:
=================================================================*/
ERR VTAPI ErrIsamDeleteObject( JET_VSESID vsesid, JET_VDBID vdbid, OBJID objid )
	{
	/*	The specified database, based on the supplied objid.
	/*	Delete the object record based on the object type.
	/*
	/*	Assumes that warning values returned by ErrIsamFoo routines mean
	/*	that it is still safe to proceed.
	/**/
	ERR				err;
	PIB				*ppib = (PIB *)vsesid;
	DBID			dbid;
	FUCB			*pfucb = pfucbNil;
	FUCB			*pfucbSoDup = pfucbNil;
	char			szObject[(JET_cbNameMost + 1)];
	OBJTYP			objtyp;
	OBJID			objidSo = objidNil;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	CallR( VDbidCheckUpdatable( vdbid ) );
	dbid = DbidOfVDbid( vdbid );

	/*	open the So table and set the current index to Id...
	/**/
	Call( ErrCATOpen( ppib, dbid, szSoTable, szSoIdIndex,
		(BYTE *)&objid, sizeof(objid), &pfucb ) );

	if ( ( err = ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ ) ) != JET_errSuccess )
		{
		if ( err == JET_errRecordNotFound )
			{
			err = ErrERRCheck( JET_errObjectNotFound );
			}
		goto HandleError;
		}

	/*	ensure we can delete this object
	/**/
	Call( ErrIsamRetrieveColumn( ppib, pfucb, CATIGetColumnid(itableSo, iMSO_Type),
		(BYTE *)&objtyp, sizeof(objtyp), NULL, 0, NULL ) );

	switch ( objtyp )
		{
		default:
		case JET_objtypDb:
		case JET_objtypLink:
			/*	delete the object record
			/**/
			Call( ErrIsamDelete( ppib, pfucb ) );
			break;

		case JET_objtypTable:
		case JET_objtypSQLLink:
			/*	get the table name
			/**/
			Call( ErrCATFindNameFromObjid( ppib, dbid, objid, szObject, sizeof(szObject), NULL ) );
			Call( ErrIsamDeleteTable( (JET_VSESID)ppib, vdbid, szObject ) );
			break;

		case JET_objtypContainer:
			/*	use a new cursor to make sure the container is empty
			/**/
			Call( ErrCATOpen( ppib, dbid, szSoTable, szSoNameIndex,
				(BYTE *)&objid, sizeof(objid), &pfucbSoDup ) );

			/*	find any object with a ParentId matching the container's id
			/**/
			err = ErrIsamSeek( ppib, pfucbSoDup, JET_bitSeekGE );
			if ( err >= 0 )
				{
				Call( ErrIsamRetrieveColumn( ppib, pfucbSoDup,
					CATIGetColumnid(itableSo, iMSO_ParentId), (BYTE *)&objidSo,
					sizeof(objidSo), NULL, 0, NULL ) );
				}

			/*	we have the info we want; close the table ( dropping tableid )
			/**/
			CallS( ErrCATClose( ppib, pfucbSoDup ) );
			pfucbSoDup = pfucbNil;

			/*	if the container is empty, then delete its record
			/**/
			if ( objid != objidSo )
				{
				Call( ErrIsamDelete( ppib, pfucb ) );
				}
			else
				{
				err = ErrERRCheck( JET_errContainerNotEmpty );
				goto HandleError;
				}
			break;
		}

	CallS( ErrCATClose( ppib, pfucb ) );
	pfucb = pfucbNil;

	return JET_errSuccess;

HandleError:
	if ( pfucb != pfucbNil )
		CallS( ErrCATClose( ppib, pfucb ) );
	if ( pfucbSoDup != pfucbNil )
		CallS( ErrCATClose( ppib, pfucbSoDup ) );
	return err;
	}


/*	Catalog-retrieval routines for system tables.
/*
/*	This code was lifted from the key parsing code in ErrIsamCreateIndex(), with
/*	optimisations for assumptions made for key strings of system table indexes.
/**/
INLINE LOCAL BYTE CfieldCATKeyString( FDB *pfdb, CHAR *szKey, IDXSEG *rgKeyFlds )
	{
	BYTE	*pb;
	FIELD	*pfield;
	FIELD	*pfieldFixed, *pfieldVar;
	BYTE	*szFieldName;
	BYTE	cfield = 0;

	for ( pb = szKey; *pb != '\0'; pb += strlen(pb) + 1 )
		{
		Assert( cfield < cSysIdxs );

		/*	Assume the first character of each component is a '+' (this is
		/*	specific to system table index keys).  In general, this may also
		/*	be a '-' or nothing at all (in which case '+' is assumed), but we
		/*	don't use descending indexes for system tables and we'll assume we
		/*	know enough to put '+' characters in our key string.
		/**/
		Assert( *pb == '+' );

		*pb++;

		/*	Code lifted from ErrFILEGetColumnId().  Can't call that function
		/*	directly because we don't have the pfcb hooked up to the pfucb
		/*	at this point. Additionally, we don't have to check tagged fields
		/*	because we know we don't have any.
		/**/
		pfieldFixed = PfieldFDBFixed( pfdb );
		pfieldVar = PfieldFDBVarFromFixed( pfdb, pfieldFixed );
		for ( pfield = pfieldFixed; ; pfield++ )
			{
			// Keep looking till we find the field we're looking for.  Since
			// this is a system table, we're assured that the field will exist,
			// so just assert that we never go past the end.
			Assert( pfield >= pfieldFixed );
			Assert( pfield <= pfieldVar + ( pfdb->fidVarLast - fidVarLeast ) );

			/*	should not be any deleted columns in a system table.
			/**/
			Assert( pfield->coltyp != JET_coltypNil );
			szFieldName = SzMEMGetString( pfdb->rgb, pfield->itagFieldName );
			if ( UtilCmpName( szFieldName, pb ) == 0 )
				{
				if ( pfield >= pfieldVar )
					{
					rgKeyFlds[cfield++] = (SHORT)( pfield - pfieldVar ) + fidVarLeast;
					}
				else
					{
					Assert( pfield >= pfieldFixed );
					rgKeyFlds[cfield++] = (SHORT)( pfield - pfieldFixed ) + fidFixedLeast;
					}
				break;
				}
			}

		}

	Assert( cfield > 0 && cfield <= JET_ccolKeyMost );

	return cfield;
	}


/*	get index info of a system table index
/**/
ERR ErrCATGetCATIndexInfo(
	PIB					*ppib,
	DBID				dbid,
	FCB					**ppfcb,
	FDB					*pfdb,
	PGNO				pgnoTableFDP,
	CHAR 				*szTableName,
	BOOL				fCreatingSys )
	{
	ERR					err;
	INT					iTable;
	INT					iIndex;
	FCB					*pfcb2ndIdxs = pfcbNil;
	FCB					*pfcbNewIdx;
	CODECONST(IDESC)	*pidesc;
	BOOL				fClustered;
	IDB					idb;

	idb.langid = langidDefault;
	idb.cbVarSegMac = JET_cbKeyMost;

	Assert( szTableName != NULL );
	for ( iTable = 0; strcmp( rgsystabdef[iTable].szName, szTableName ) != 0; iTable++ )
		{
		/*	the table MUST be in rgsystabdef somewhere (which is why we don't
		/*	need to put the boundary check on i into the for loop).
		/**/
		Assert( iTable < csystabs - 1 );
		}

	pidesc = rgsystabdef[iTable].pidesc;

	/*	note that system tables are assumed to always have a clustered index
	/**/
	if ( fCreatingSys )
		{
		Call( ErrFILEINewFCB(
			ppib,
			dbid,
			pfdb,
			ppfcb,
			pidbNil,
			fTrue /* clustered index */,
			pgnoTableFDP,
			ulFILEDefaultDensity ) );
		}
	else
		{
		Assert( pfcb2ndIdxs == pfcbNil );
		for( iIndex = 0; iIndex < rgsystabdef[iTable].cindex; iIndex++, pidesc++ )
			{
			strcpy( idb.szName, pidesc->szIdxName );
			idb.iidxsegMac = CfieldCATKeyString(pfdb, pidesc->szIdxKeys, idb.rgidxseg);
			idb.fidb = FidbFILEOfGrbit( pidesc->grbit, fFalse /* fLangid */ );
			fClustered = (pidesc->grbit & JET_bitIndexClustered);

			/*	make an FCB for this index
			/**/
			pfcbNewIdx = pfcbNil;

			if ( fClustered )
				{
				Call( ErrFILEINewFCB(
					ppib,
					dbid,
					pfdb,
					&pfcbNewIdx,
					&idb,
					fClustered,
					pgnoTableFDP,
					ulFILEDefaultDensity ) );
				*ppfcb = pfcbNewIdx;
				}
			else
				{
				PGNO	pgnoIndexFDP;

				// UNDONE:  This is a real hack to get around the problem of
				// determining pgnoFDPs of non-clustered system table indexes.
				// We take advantage of the fact that currently, the only
				// non-clustered system table index is the szSoNameIndex of
				// MSysObjects.  Further we know its FDP is page 3.
				// If we have more non-clustered system table indexes, this code
				// will have to be modified to handle it.
				Assert( iTable == 0 );
				Assert( iIndex == 0 );
				Assert( pidesc == rgidescSo );
				Assert( strcmp( pidesc->szIdxName, szSoNameIndex ) == 0 );
				Assert( strcmp( rgsystabdef[iTable].szName, szSoTable ) == 0 );
				pgnoIndexFDP = 3;

				Call( ErrFILEINewFCB(
					ppib,
					dbid,
					pfdb,
					&pfcbNewIdx,
					&idb,
					fClustered,
					pgnoIndexFDP,
					ulFILEDefaultDensity ) );

				pfcbNewIdx->pfcbNextIndex = pfcb2ndIdxs;
				pfcb2ndIdxs = pfcbNewIdx;
				}
			}

		}

	/*	link up sequential/clustered index with the rest of the indexes
	/**/
	(*ppfcb)->pfcbNextIndex = pfcb2ndIdxs;

	/*	link up pfcbTable of non-clustered indexes
	/**/
	FCBLinkClusteredIdx( *ppfcb );

	return JET_errSuccess;

	/*	error handling
	/**/
HandleError:
	if ( pfcb2ndIdxs != pfcbNil )
		{
		FCB	*pfcbT, *pfcbKill;

		// Only need to clean up secondary indexes.  Clustered index, if any,
		// will get cleaned up by caller (currently only ErrFILEIGenerateFCB()).
		pfcbT = pfcb2ndIdxs;
		do
			{
			if ( pfcbT->pidb != pidbNil )
				{
				RECFreeIDB( pfcbT->pidb );
				}
			pfcbKill = pfcbT;
			pfcbT = pfcbT->pfcbNextIndex;
			Assert( pfcbKill->cVersion == 0 );
			MEMReleasePfcb( pfcbKill );
			}
		while ( pfcbT != pfcbNil );
		}

	return err;
	}


/*	construct the catalog FDB using the static data structures
/*	defined in _cat.c.
/**/
ERR ErrCATConstructCATFDB( FDB **ppfdbNew, CHAR *szFileName )
	{
	ERR					err;
	FIELDEX				fieldex;
	INT					i;
	INT					iTable;
	CODECONST(CDESC)	*pcdesc;
	JET_COLUMNID		columnid;
	FDB					*pfdb;
	TCIB				tcib = { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	ULONG				ibRec;

	//	UNDONE:		international support.  Set these values from
	//			   	create database connect string.
	fieldex.field.cp = usEnglishCodePage;

	iTable = ICATITableDefIndex( szFileName );

	/*	first, determine how many columns there are
	/**/
	pcdesc = rgsystabdef[iTable].pcdesc;
	for ( i = 0; i < rgsystabdef[iTable].ccolumn; i++, pcdesc++ )
		{
		CallR( ErrFILEGetNextColumnid( pcdesc->coltyp, 0, &tcib, &columnid ) );
		rgsystabdef[iTable].rgcolumnid[i] = columnid;
		}

	CallR( ErrRECNewFDB( ppfdbNew, &tcib, fTrue ) );

	/*	make code a bit easier to read
	/**/
	pfdb = *ppfdbNew;

		/*	check initialisations
	/**/
	Assert( pfdb->fidVersion == 0 );
	Assert( pfdb->fidAutoInc == 0 );
	Assert( pfdb->lineDefaultRecord.cb == 0  &&  pfdb->lineDefaultRecord.pb == NULL );
	Assert( tcib.fidFixedLast == pfdb->fidFixedLast &&
	   tcib.fidVarLast == pfdb->fidVarLast &&
	   tcib.fidTaggedLast == pfdb->fidTaggedLast );

	/*	fill in the column info
	/**/
	ibRec = sizeof(RECHDR);
	pcdesc = rgsystabdef[iTable].pcdesc;
	for ( i = 0; i < rgsystabdef[iTable].ccolumn; i++, pcdesc++ )
		{
		CallR( ErrMEMAdd( pfdb->rgb, pcdesc->szColName,
			strlen( pcdesc->szColName ) + 1, &fieldex.field.itagFieldName ) );
		fieldex.field.coltyp = pcdesc->coltyp;
		Assert( fieldex.field.coltyp != JET_coltypNil );
		fieldex.field.cbMaxLen = UlCATColumnSize( pcdesc->coltyp, pcdesc->ulMaxLen, NULL );

		/*	flag for system table columns is JET_bitColumnNotNULL
		/**/
		Assert( pcdesc->grbit == 0 || pcdesc->grbit == JET_bitColumnNotNULL );
		fieldex.field.ffield = 0;
		if ( pcdesc->grbit == JET_bitColumnNotNULL )
			FIELDSetNotNull( fieldex.field.ffield );

		fieldex.fid = (FID)CATIGetColumnid(iTable, i);

		// ibRecordOffset is only relevant for fixed fields (it will be ignored by
		// RECAddFieldDef(), so don't even bother setting it).
		if ( FFixedFid( fieldex.fid ) )
			{
			fieldex.ibRecordOffset = (WORD) ibRec;
			ibRec += fieldex.field.cbMaxLen;
			}

		CallR( ErrRECAddFieldDef( pfdb, &fieldex ) );
		}
	RECSetLastOffset( pfdb, (WORD) ibRec );

	return JET_errSuccess;
	}


# if 0
/*	This routine determines if a specified column is a key field in any of the
/*	indexes of a specified table.
/*
/*	If the specified column is part of the key of at least one of the indexes
/*	of the specified table, JET_errSuccess is returned.  If the column does not
/*	belong to a key, JET_errColumnNotFound is returned.
/**/
ERR ErrCATCheckIndexColumn(
	PIB			*ppib,
	DBID		dbid,
	OBJID		objidTable,
	FID			fid )
	{
	ERR 		err;
	FUCB 		*pfucbSi;
	BYTE 		rgbT[JET_cbColumnMost];
	ULONG 		cbActual;
	FID			*pidKeyFld;

	CallR( ErrCATOpen( ppib, dbid, szSiTable, szSiObjectIdNameIndex,
		(BYTE *)&objidTable, sizeof(OBJID), &pfucbSi ) );

	if ( ( ErrIsamSeek( ppib, pfucbSi, JET_bitSeekGE ) ) >= 0 )
		{
		Call( ErrIsamMakeKey( ppib, pfucbSi, (BYTE *)&objidTable,
			sizeof(OBJID), JET_bitNewKey | JET_bitStrLimit) );
		err = ErrIsamSetIndexRange( ppib, pfucbSi, JET_bitRangeUpperLimit);
		while ( err != JET_errNoCurrentRecord )
			{
			if ( err != JET_errSuccess )
				{
				goto HandleError;
				}

			Call( ErrIsamRetrieveColumn( ppib, pfucbSi,
				CATIGetColumnid(itableSi, iMSI_KeyFldIDs), (BYTE *)rgbT,
				JET_ccolKeyMost * sizeof(FID), &cbActual, 0, NULL ) );

			/*	scan the list of key fields for the field in question
			/**/
			for ( pidKeyFld = (FID *)rgbT;
				(BYTE *)pidKeyFld < rgbT+cbActual;
				pidKeyFld++ )
				{
				if ( *pidKeyFld == fid || *pidKeyFld == -fid )
					{
					err = JET_errSuccess;
					goto HandleError;
					}
				}

			err = ErrIsamMove( ppib, pfucbSi, JET_MoveNext, 0);
			}

		Assert( err == JET_errNoCurrentRecord );
		}

	/*	column must not exist
	/**/
	err = ErrERRCheck( JET_errColumnNotFound );

HandleError:
	CallS( ErrCATClose( ppib, pfucbSi ) );
	return err;
	}
#endif	// 0



/*	Populate an IDB structure with index info.  Called by ErrCATGetIndexInfo().
/**/
INLINE LOCAL ERR ErrCATConstructIDB(
	PIB		*ppib,
	FUCB	*pfucbSi,
	IDB		*pidb,
	BOOL	*pfClustered,
	PGNO	*ppgnoIndexFDP,
	ULONG	*pulDensity )
	{
	ERR		err;
	INT		iCol, cColsOfInterest;
	BYTE	rgbIndexInfo[cSiColsOfInterest][sizeof(ULONG)];
	BYTE	rgbName[JET_cbNameMost+1];
	BYTE	rgbKeyFlds[JET_cbColumnMost];
	JET_RETRIEVECOLUMN rgretcol[cSiColsOfInterest];

	/*	initialize structure
	/**/
	memset( rgretcol, 0, sizeof(rgretcol) );

	/*	prepare call to retrieve columns
	/**/
	cColsOfInterest = 0;
	for ( iCol = 0; cColsOfInterest < cSiColsOfInterest; iCol++ )
		{
		Assert( iCol < sizeof(rgcdescSi)/sizeof(CDESC) );

		switch( iCol )
			{
			case iMSI_Name:
				rgretcol[cColsOfInterest].pvData = rgbName;
				rgretcol[cColsOfInterest].cbData = JET_cbNameMost;
				break;

			case iMSI_KeyFldIDs:
				rgretcol[cColsOfInterest].pvData = rgbKeyFlds;
				rgretcol[cColsOfInterest].cbData = JET_cbColumnMost;
				break;
				
			case iMSI_IndexId:
			case iMSI_Density:
			case iMSI_LanguageId:
			case iMSI_Flags:
			case iMSI_VarSegMac:
				rgretcol[cColsOfInterest].pvData = rgbIndexInfo[cColsOfInterest];
				rgretcol[cColsOfInterest].cbData = sizeof(ULONG);
				break;

			default:
			 	Assert(	iCol == iMSI_ObjectId || iCol == iMSI_Stats );
				continue;
			}
		rgretcol[cColsOfInterest].columnid = CATIGetColumnid(itableSi, iCol);
		rgretcol[cColsOfInterest].itagSequence = 1;
		cColsOfInterest++;
		}
	Assert( cColsOfInterest == cSiColsOfInterest );

	CallR( ErrIsamRetrieveColumns( (JET_VSESID)ppib, (JET_VTID)pfucbSi, rgretcol, cColsOfInterest ) );

	cColsOfInterest = 0;
	for ( iCol = 0; cColsOfInterest < cSiColsOfInterest; iCol++ )
		{
		Assert( iCol < sizeof(rgcdescSi)/sizeof(CDESC) );

		/*	verify success of retrieve column
		/**/
		CallR( rgretcol[cColsOfInterest].err );

		switch( iCol )
			{
			case iMSI_Name:
				Assert( rgretcol[cColsOfInterest].cbActual <= JET_cbNameMost );
				Assert( rgretcol[cColsOfInterest].pvData == rgbName );
				memcpy( pidb->szName, rgbName, rgretcol[cColsOfInterest].cbActual );
				/*	null-terminate
				/**/
				pidb->szName[rgretcol[cColsOfInterest].cbActual] = 0;
				break;

			case iMSI_IndexId:
				Assert( rgretcol[cColsOfInterest].cbActual == sizeof(PGNO) );
				*ppgnoIndexFDP = *( (PGNO UNALIGNED *)rgbIndexInfo[cColsOfInterest] );
				break;

			case iMSI_Density:
				Assert( rgretcol[cColsOfInterest].cbActual == sizeof(ULONG) );
				*pulDensity = *((ULONG UNALIGNED *)rgbIndexInfo[cColsOfInterest]);
				break;

			case iMSI_LanguageId:
				Assert( rgretcol[cColsOfInterest].cbActual == sizeof(LANGID) );
				pidb->langid = *( (LANGID UNALIGNED *)rgbIndexInfo[cColsOfInterest] );
				break;

			case iMSI_Flags:
				Assert( rgretcol[cColsOfInterest].cbActual == sizeof(SHORT) );
				pidb->fidb = *( (SHORT *)rgbIndexInfo[cColsOfInterest] );
				*pfClustered = FIDBClustered( pidb );
				break;

			case iMSI_VarSegMac:
				Assert( rgretcol[cColsOfInterest].cbActual == sizeof(SHORT) ||
					rgretcol[cColsOfInterest].cbActual == 0 );
				if ( rgretcol[cColsOfInterest].cbActual == 0 )
					pidb->cbVarSegMac = JET_cbKeyMost;
				else
					pidb->cbVarSegMac = *( (BYTE *)rgbIndexInfo[cColsOfInterest] );
				break;

			case iMSI_KeyFldIDs:
				Assert( rgretcol[cColsOfInterest].pvData == rgbKeyFlds );

				/*	the length of the list of key fields should be a multiple of the
				/*	length of one field.
				/**/
				Assert( rgretcol[cColsOfInterest].cbActual <= JET_cbColumnMost );
				Assert( rgretcol[cColsOfInterest].cbActual % sizeof(FID) == 0);
				
				/*	verify we do not have more key fields than we are allowed
				/**/
				Assert( (rgretcol[cColsOfInterest].cbActual / sizeof(FID)) <= JET_ccolKeyMost );
				pidb->iidxsegMac = (BYTE)( rgretcol[cColsOfInterest].cbActual / sizeof(FID) );

				memcpy( pidb->rgidxseg, rgbKeyFlds, rgretcol[cColsOfInterest].cbActual );
				break;

			default:
			 	Assert(	iCol == iMSI_ObjectId || iCol == iMSI_Stats );
				continue;
			}

		Assert( rgretcol[cColsOfInterest].columnid == CATIGetColumnid( itableSi, iCol ) );
		cColsOfInterest++;
		}
	Assert( cColsOfInterest == cSiColsOfInterest );

	return JET_errSuccess;
	}



ERR ErrCATGetTableAllocInfo( PIB *ppib, DBID dbid, PGNO pgnoTable, ULONG *pulPages, ULONG *pulDensity )
	{
	ERR		err;
	FUCB 	*pfucbSo = pfucbNil;
	ULONG	ulPages;
	ULONG	ulDensity;
	ULONG	cbActual;

	CallR( ErrCATOpen( ppib, dbid, szSoTable, szSoIdIndex,
		(BYTE *)&pgnoTable, sizeof(PGNO), &pfucbSo ) );
	Call( ErrIsamSeek( ppib, pfucbSo, JET_bitSeekEQ ) );
	Assert( err == JET_errSuccess );

	/*	pages are optional, density is not
	/**/
	if ( pulPages )
		{
		Call( ErrIsamRetrieveColumn( ppib, pfucbSo,
			CATIGetColumnid(itableSo, iMSO_Pages), (BYTE *)&ulPages,
			sizeof(ulPages), &cbActual, 0, NULL ) );
		Assert( cbActual == sizeof(ULONG) );
		Assert( err == JET_errSuccess );
		*pulPages = ulPages;
		}

	Assert( pulDensity );
	Call( ErrIsamRetrieveColumn( ppib, pfucbSo,
		CATIGetColumnid(itableSo, iMSO_Density), (BYTE *)&ulDensity,
		sizeof(ulDensity), &cbActual, 0, NULL ) );
	Assert( cbActual == sizeof(ULONG) );
	Assert( err == JET_errSuccess );
	*pulDensity = ulDensity;

HandleError:
	CallS( ErrCATClose( ppib, pfucbSo ) );
	return err;
	}


ERR ErrCATGetIndexAllocInfo(
	PIB *ppib,
	DBID dbid,
	PGNO pgnoTable,
	CHAR *szIndexName,
	ULONG *pulDensity )
	{
	ERR		err;
	FUCB 	*pfucbSi = pfucbNil;
	ULONG	ulDensity, cbActual;

	CallR( ErrCATOpen( ppib, dbid, szSiTable, szSiObjectIdNameIndex,
		(BYTE *)&pgnoTable, sizeof(PGNO), &pfucbSi ) );
	Call( ErrIsamMakeKey( ppib, pfucbSi, szIndexName,
		strlen(szIndexName), 0 ) );
	Call( ErrIsamSeek( ppib, pfucbSi, JET_bitSeekEQ ) );
	Assert( err == JET_errSuccess );

	Assert(pulDensity);
	Call( ErrIsamRetrieveColumn( ppib, pfucbSi,
		CATIGetColumnid(itableSi, iMSI_Density), (BYTE *)&ulDensity,
		sizeof(ulDensity), &cbActual, 0, NULL ) );
	Assert( cbActual == sizeof(ULONG) );
	Assert( err == JET_errSuccess );
	*pulDensity = ulDensity;

HandleError:
	CallS( ErrCATClose( ppib, pfucbSi ) );
	return err;
	}



ERR ErrCATGetIndexLangid(
	PIB		*ppib,
	DBID	dbid,
	PGNO	pgnoTable,
	CHAR	*szIndexName,
	USHORT	*pusLangid )
	{
	ERR		err;
	FUCB 	*pfucbSi = pfucbNil;
	ULONG	cbActual;
	USHORT	langid;

	CallR( ErrCATOpen( ppib, dbid, szSiTable, szSiObjectIdNameIndex,
		(BYTE *)&pgnoTable, sizeof(PGNO), &pfucbSi ) );
	Call( ErrIsamMakeKey( ppib, pfucbSi, szIndexName,
		strlen(szIndexName), 0 ) );
	Call( ErrIsamSeek( ppib, pfucbSi, JET_bitSeekEQ ) );
	Assert( err == JET_errSuccess );

	Assert( pusLangid );
	Call( ErrIsamRetrieveColumn( ppib, pfucbSi,
		CATIGetColumnid(itableSi, iMSI_LanguageId), (BYTE *)&langid,
		sizeof(langid), &cbActual, 0, NULL ) );
	Assert( cbActual == sizeof(USHORT) );
	Assert( err == JET_errSuccess );
	*pusLangid = langid;

HandleError:
	CallS( ErrCATClose( ppib, pfucbSi ) );
	return err;
	}



/*	Looks for the MSysIndexes records for a particular table and builds an FCB
/*	for each.  May optionally be used just to find the clustered index of a table.
/**/
ERR ErrCATGetIndexInfo( PIB *ppib, DBID dbid, FCB **ppfcb, FDB *pfdb, PGNO pgnoTableFDP  )
	{
	ERR    	err;
	FUCB   	*pfucbCatalog;
	FCB		*pfcb2ndIdxs = pfcbNil, *pfcbNewIdx;
	BOOL	fClustered = fFalse, fFoundClustered = fFalse;
	IDB		idb;
	PGNO	pgnoIndexFDP;
	ULONG	ulDensity;

	Assert( *ppfcb == pfcbNil );

	/*	the only way a temporary table could get to this point is if it was being
	/*	created, in which case there are no clustered or non-clustered indexes yet.
	/**/
	if ( dbid != dbidTemp )
		{
		CallR( ErrCATOpen( ppib, dbid, szSiTable, szSiObjectIdNameIndex,
			(BYTE *)&pgnoTableFDP, sizeof(pgnoTableFDP), &pfucbCatalog ) );

		/*	user who opened catalog is same user who opened table
		/**/
		Assert(ppib == pfucbCatalog->ppib);
		Assert(dbid == pfucbCatalog->dbid);

		Assert( pfcb2ndIdxs == pfcbNil );

		if ( ( ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekGE ) ) >= 0 )
			{
			Call( ErrIsamMakeKey( ppib, pfucbCatalog, (BYTE *)&pgnoTableFDP,
				sizeof(pgnoTableFDP), JET_bitNewKey | JET_bitStrLimit) );
			err = ErrIsamSetIndexRange( ppib, pfucbCatalog, JET_bitRangeUpperLimit);
			while ( err != JET_errNoCurrentRecord )
				{
				if ( err != JET_errSuccess )
					{
					goto HandleError;
					}

				/*	read the data
				/**/
				Call( ErrCATConstructIDB( ppib, pfucbCatalog, &idb,
					&fClustered, &pgnoIndexFDP, &ulDensity ) );

				Assert( pgnoIndexFDP > pgnoSystemRoot );
				Assert( pgnoIndexFDP <= pgnoSysMax );
				Assert( ( fClustered  &&  pgnoIndexFDP == pgnoTableFDP )  ||
					( !fClustered  &&  pgnoIndexFDP != pgnoTableFDP ) );

				/*	make an FCB for this index
				/**/
				pfcbNewIdx = pfcbNil;

				Call( ErrFILEINewFCB(
					ppib,
					dbid,
					pfdb,
					&pfcbNewIdx,
					&idb,
					fClustered,
					pgnoIndexFDP,
					ulDensity ) );

				if ( fClustered )
					{
					Assert( !fFoundClustered );
					fFoundClustered = fTrue;
					*ppfcb = pfcbNewIdx;
					}
				else
					{
					pfcbNewIdx->pfcbNextIndex = pfcb2ndIdxs;
					pfcb2ndIdxs = pfcbNewIdx;
					}
			
				err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, 0 );
				}

			Assert( err == JET_errNoCurrentRecord );
			}
		}

	if ( !fFoundClustered )
		{
		/*	no clustered index, so we need an FCB for the sequential index
		/**/
		Assert( *ppfcb == pfcbNil );

		if ( dbid == dbidTemp )
			{
			ulDensity = ulFILEDefaultDensity;
			}
		else
			{
			Call( ErrCATGetTableAllocInfo( ppib,
				dbid,
				pgnoTableFDP,
				NULL,
				&ulDensity ) );
			}
		Call( ErrFILEINewFCB(
			ppib,
			dbid,
			pfdb,
			ppfcb,
			pidbNil,
			fTrue,
			pgnoTableFDP,
			ulDensity ) );
		}

	/*	link up sequential/clustered index with the rest of the indexes
	/**/
	(*ppfcb)->pfcbNextIndex = pfcb2ndIdxs;

	/*	link up pfcbTable of non-clustered indexes
	/**/
	FCBLinkClusteredIdx( *ppfcb );

	err = JET_errSuccess;

HandleError:
	if ( err < 0  &&  pfcb2ndIdxs != pfcbNil )
		{
		FCB	*pfcbT, *pfcbKill;

		// Only need to clean up secondary indexes.  Clustered index, if any,
		// will get cleaned up by caller (currently only ErrFILEIGenerateFCB()).
		pfcbT = pfcb2ndIdxs;
		do
			{
			if ( pfcbT->pidb != pidbNil )
				{
				RECFreeIDB( pfcbT->pidb );
				}
			pfcbKill = pfcbT;
			pfcbT = pfcbT->pfcbNextIndex;
			Assert( pfcbKill->cVersion == 0 );
			MEMReleasePfcb( pfcbKill );
			}
		while ( pfcbT != pfcbNil );
		}

	if ( dbid != dbidTemp )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	return err;
	}


/*	Populate a FIELD structure with column info.  Called by ErrCATConstructFDB()
/*	once the proper column has been located.
/**/
INLINE LOCAL ERR ErrCATConstructField(
	PIB		*ppib,
	FUCB	*pfucbSc,
	FDB		*pfdb,
	FIELDEX	*pfieldex )
	{
	ERR					err;
	FIELD				*pfield = &pfieldex->field;
	JET_RETRIEVECOLUMN	rgretcol[cScColsOfInterest];
	BYTE				rgbFieldInfo[cScColsOfInterest][sizeof(ULONG)];
	BYTE				rgbName[JET_cbNameMost+1];
	INT					iCol, cColsOfInterest;

	/*	initialize
	/**/
	memset( rgretcol, 0, sizeof(rgretcol) );

	/*	prepare to retrieve columns
	/**/
	cColsOfInterest = 0;
	for ( iCol = 0; cColsOfInterest < cScColsOfInterest; iCol++ )
		{
		Assert( iCol < sizeof(rgcdescSc)/sizeof(CDESC) );

		switch( iCol )
			{
			case iMSC_Name:
				rgretcol[cColsOfInterest].pvData = rgbName;
				rgretcol[cColsOfInterest].cbData = JET_cbNameMost;
				break;

			case iMSC_ColumnId:
			case iMSC_Coltyp:
			case iMSC_Length:
			case iMSC_CodePage:
			case iMSC_Flags:
			case iMSC_RecordOffset:
				rgretcol[cColsOfInterest].pvData = rgbFieldInfo[cColsOfInterest];
				rgretcol[cColsOfInterest].cbData = sizeof(ULONG);
				break;
			default:
				Assert( iCol == iMSC_ObjectId  ||  iCol == iMSC_POrder );
				continue;
			}
		rgretcol[cColsOfInterest].columnid = CATIGetColumnid( itableSc, iCol );
		rgretcol[cColsOfInterest].itagSequence = 1;
		cColsOfInterest++;
		}
	Assert( cColsOfInterest == cScColsOfInterest );

	CallR( ErrIsamRetrieveColumns( (JET_VSESID)ppib, (JET_VTID)pfucbSc, rgretcol, cScColsOfInterest ) );

	// Process result of retrieval.
	cColsOfInterest = 0;
	for ( iCol = 0; cColsOfInterest < cScColsOfInterest; iCol++ )
		{
		Assert( iCol < sizeof(rgcdescSi)/sizeof(CDESC) );

		CallR( rgretcol[cColsOfInterest].err );

		// Should always return success, except in the case of RecordOffset, which
		// may be null for variable or tagged columns.
		Assert( err == JET_errSuccess  ||
			( err == JET_wrnColumnNull  &&  iCol == iMSC_RecordOffset ) );

		switch( iCol )
			{
			 case iMSC_Name:
				Assert( rgretcol[cColsOfInterest].cbActual <= JET_cbNameMost );
				Assert( rgretcol[cColsOfInterest].pvData == rgbName );
				rgbName[rgretcol[cColsOfInterest].cbActual] = '\0';	// Ensure null-termination.
				CallR( ErrMEMAdd( pfdb->rgb, rgbName,
					rgretcol[cColsOfInterest].cbActual + 1, &pfield->itagFieldName ) );
				break;

			 case iMSC_ColumnId:
				Assert( rgretcol[cColsOfInterest].cbActual == sizeof(JET_COLUMNID) );
				pfieldex->fid = (FID)( *( (JET_COLUMNID UNALIGNED *)rgbFieldInfo[cColsOfInterest] ) );
				break;

			 case iMSC_Coltyp:
				Assert( rgretcol[cColsOfInterest].cbActual == sizeof(BYTE) );
				pfield->coltyp = (JET_COLTYP)(*(rgbFieldInfo[cColsOfInterest]));
				break;

			 case iMSC_Length:
				Assert( rgretcol[cColsOfInterest].cbActual == sizeof(ULONG) );
				pfield->cbMaxLen = *( (ULONG UNALIGNED *)(rgbFieldInfo[cColsOfInterest]) );
				break;

			 case iMSC_CodePage:
				Assert( rgretcol[cColsOfInterest].cbActual == sizeof(USHORT) );
				pfield->cp = *( (USHORT UNALIGNED *)(rgbFieldInfo[cColsOfInterest]) );
				break;

			 case iMSC_Flags:
				Assert( rgretcol[cColsOfInterest].cbActual == sizeof(BYTE) );
				pfield->ffield = *(rgbFieldInfo[cColsOfInterest]);
				break;

			 case iMSC_RecordOffset:
				if ( err == JET_wrnColumnNull )
					{
					pfieldex->ibRecordOffset = 0;		// Set to a dummy value.
					}
				else
					{
					Assert( err == JET_errSuccess );
					Assert( rgretcol[cColsOfInterest].cbActual == sizeof(WORD) );
					pfieldex->ibRecordOffset = *( (WORD UNALIGNED *)rgbFieldInfo[cColsOfInterest] );
					Assert( pfieldex->ibRecordOffset >= sizeof(RECHDR) );
					}
				break;

			default:
				Assert( iCol == iMSC_ObjectId  ||
					iCol == iMSC_Default  ||
					iCol == iMSC_POrder );
				continue;
			}

		Assert( rgretcol[cColsOfInterest].columnid == CATIGetColumnid( itableSc, iCol ) );
		cColsOfInterest++;
		}
	Assert( cColsOfInterest == cScColsOfInterest );

	return JET_errSuccess;
	}
	

INLINE LOCAL VOID CATPatchFixedOffsets( FDB *pfdb, WORD ibRec )
	{
	WORD 	*pibFixedOffsets;
	FID		ifid;

	// Set the last offset.
	pibFixedOffsets = PibFDBFixedOffsets( pfdb );
	pibFixedOffsets[pfdb->fidFixedLast] = ibRec;
	Assert( ibRec <= cbRECRecordMost );

	Assert( pibFixedOffsets[0] == sizeof(RECHDR) );
	for ( ifid = 1; ifid <= pfdb->fidFixedLast; ifid++ )
		{		
		Assert( pibFixedOffsets[ifid] >= sizeof(RECHDR) );

		if ( pibFixedOffsets[ifid] == sizeof(RECHDR) )
			{
			FIELD	*pfieldFixed = PfieldFDBFixedFromOffsets( pfdb, pibFixedOffsets );
			
			// If there's an offset (other than the very first entry) that points
			// to the beginning of the record, it must mean that the original
			// AddColumn was rolled back, and thus the corresponding entry in
			// MSysColumns was never persisted.  So we fudge the entry based
			// on the entries before and after it.
			
			// The last fixed column *must* be in MSysColumns.  Therefore, this
			// column can't be it.
			Assert( ifid < pfdb->fidFixedLast );

			// These are the values with which the FIELD structures were initialised.
			// Since there was no MSysColumns entry, the FIELD structure should
			// still retain its initial values.
			Assert( pfieldFixed[ifid].coltyp == JET_coltypNil );
			Assert( pfieldFixed[ifid].cbMaxLen == 0 );

			if ( pfieldFixed[ifid-1].cbMaxLen > 0 )
				{
				pibFixedOffsets[ifid] = (WORD)( pibFixedOffsets[ifid-1] + pfieldFixed[ifid-1].cbMaxLen );
				}
			else
				{
				// Previous fixed column has cbMaxLen == 0.  Therefore, it
				// must be a deleted column, or a rolled-back column.  Assume its
				// length was 1 and set this columns record offset accordingly.
				Assert( pfieldFixed[ifid-1].coltyp == JET_coltypNil );
				Assert( pfieldFixed[ifid-1].cbMaxLen == 0 );
				pibFixedOffsets[ifid] = pibFixedOffsets[ifid-1] + 1;

				Assert( pibFixedOffsets[ifid] < pibFixedOffsets[ifid+1]  ||
					pibFixedOffsets[ifid+1] == sizeof(RECHDR) );
				}
			
			// The last fixed column *must* be in MSysColumns.  Therefore, this
			// column can't be it.
			Assert( pibFixedOffsets[ifid] < ibRec );
			}

		Assert( pibFixedOffsets[ifid] > sizeof(RECHDR) );		
		Assert( pibFixedOffsets[ifid] > pibFixedOffsets[ifid-1] );

		Assert( ifid == pfdb->fidFixedLast ?
			pibFixedOffsets[ifid] == ibRec :
			pibFixedOffsets[ifid] < ibRec );
		}
	}


/*	construct a table FDB from the column info in the catalog
/**/
ERR ErrCATConstructFDB( PIB *ppib, DBID dbid, PGNO pgnoTableFDP, FDB **ppfdbNew )
	{
	ERR    			err;
	OBJID			objidTable = (OBJID)pgnoTableFDP;
	FUCB   			*pfucbSc;
	FIELDEX			fieldex;
	FDB				*pfdb;
	TCIB			tcib = { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	JET_COLUMNID	columnid;
	INT				cbActual;
	INT				cbDefault;
	FUCB			fucbFake;
	FCB				fcbFake;
	BYTE			*pb;
	BOOL			fDefaultRecordPrepared = fFalse;

	if ( dbid == dbidTemp )
		{
		Assert( tcib.fidFixedLast >= fidFixedLeast - 1  &&
			tcib.fidFixedLast <= fidFixedMost );
		Assert( tcib.fidVarLast >= fidVarLeast - 1  &&
			tcib.fidVarLast <= fidVarMost );
		Assert( tcib.fidTaggedLast >= fidTaggedLeast - 1  &&
			tcib.fidTaggedLast <= fidTaggedMost );

		CallR( ErrRECNewFDB( ppfdbNew, &tcib, fTrue ) );

		pfdb = *ppfdbNew;

		Assert( pfdb->fidVersion == 0 );
		Assert( pfdb->fidAutoInc == 0 );
		Assert( tcib.fidFixedLast == pfdb->fidFixedLast );
		Assert( tcib.fidVarLast == pfdb->fidVarLast );
		Assert( tcib.fidTaggedLast == pfdb->fidTaggedLast );
	
		/*	for temporary tables, could only get here from
		/*	create table which means table should currently be empty
		/**/
		Assert( pfdb->fidFixedLast == fidFixedLeast - 1 );
		Assert( pfdb->fidVarLast == fidVarLeast - 1 );
		Assert( pfdb->fidTaggedLast == fidTaggedLeast - 1 );
		return JET_errSuccess;
		}

	Assert( dbid != dbidTemp );

	CallR( ErrCATOpen( ppib,
		dbid,
		szScTable,
		szScObjectIdNameIndex,
		(BYTE *)&objidTable,
		sizeof(OBJID),
		&pfucbSc ) );

	/*	get number of columns by category, by scanning all column records
	/**/
	if ( ( ErrIsamSeek( ppib, pfucbSc, JET_bitSeekGE ) ) >= 0 )
		{
		Call( ErrIsamMakeKey( ppib, pfucbSc, (BYTE *)&objidTable, sizeof(OBJID),
			JET_bitNewKey | JET_bitStrLimit) );
		err = ErrIsamSetIndexRange( ppib, pfucbSc, JET_bitRangeUpperLimit);
		while ( err != JET_errNoCurrentRecord )
			{
			if ( err != JET_errSuccess )
				{
				goto HandleError;
				}

			Call( ErrIsamRetrieveColumn( ppib, pfucbSc,
				CATIGetColumnid( itableSc, iMSC_ColumnId ), (BYTE *)&columnid,
				sizeof( columnid ), &cbActual, 0, NULL ) );
			Assert( cbActual == sizeof( columnid ) );

			if ( FFixedFid( (FID)columnid ) )
				{
				if ( (FID)columnid > tcib.fidFixedLast )
					tcib.fidFixedLast = (FID)columnid;
				}

			else if ( FVarFid( (FID)columnid ) )
				{
				if ( (FID)columnid > tcib.fidVarLast )
					tcib.fidVarLast = (FID)columnid;
				}

			else
				{
				Assert( FTaggedFid( (FID)columnid ) );
				if ( (FID)columnid > tcib.fidTaggedLast )
					tcib.fidTaggedLast = (FID)columnid;
				}

			err = ErrIsamMove( ppib, pfucbSc, JET_MoveNext, 0 );
			}

		Assert( err == JET_errNoCurrentRecord );
		}

	Assert( tcib.fidFixedLast >= fidFixedLeast - 1  &&
		tcib.fidFixedLast <= fidFixedMost );
	Assert( tcib.fidVarLast >= fidVarLeast - 1  &&
		tcib.fidVarLast <= fidVarMost );
	Assert( tcib.fidTaggedLast >= fidTaggedLeast - 1  &&
		tcib.fidTaggedLast <= fidTaggedMost );

	CallR( ErrRECNewFDB( ppfdbNew, &tcib, fTrue ) );

	pfdb = *ppfdbNew;

	Assert( pfdb->fidVersion == 0 );
	Assert( pfdb->fidAutoInc == 0 );
	Assert( tcib.fidFixedLast == pfdb->fidFixedLast );
	Assert( tcib.fidVarLast == pfdb->fidVarLast );
	Assert( tcib.fidTaggedLast == pfdb->fidTaggedLast );
	
	Call( ErrIsamMakeKey( ppib, pfucbSc, (BYTE *)&objidTable,
		sizeof(OBJID), JET_bitNewKey ) );
	if ( ( ErrIsamSeek( ppib, pfucbSc, JET_bitSeekGE ) ) >= 0 )
		{
		Call( ErrIsamMakeKey( ppib, pfucbSc, (BYTE *)&objidTable, sizeof(OBJID),
			JET_bitNewKey | JET_bitStrLimit) );
		err = ErrIsamSetIndexRange( ppib, pfucbSc, JET_bitRangeUpperLimit);
		while ( err != JET_errNoCurrentRecord )
			{
			if ( err != JET_errSuccess )
				{
				goto HandleError;
				}

			Call( ErrCATConstructField( ppib, pfucbSc, pfdb, &fieldex ) );

			// If field is deleted, the coltyp for the FIELD entry should
			// already be JET_coltypNil (initialised that way).
			Assert( fieldex.field.coltyp != JET_coltypNil  ||
				PfieldFDBFromFid( pfdb, fieldex.fid )->coltyp == JET_coltypNil );

			if ( fieldex.field.coltyp != JET_coltypNil )
				{
				Call( ErrRECAddFieldDef( pfdb, &fieldex ) );

				/*	set version and auto increment field ids (these are mutually
				/*	exclusive (ie. a field can't be both version and autoinc).
				/**/
				Assert( pfdb->fidVersion != pfdb->fidAutoInc  ||  pfdb->fidVersion == 0 );
				if ( FFIELDVersion( fieldex.field.ffield ) )
					{
					Assert( pfdb->fidVersion == 0 );
					pfdb->fidVersion = fieldex.fid;
					}
				if ( FFIELDAutoInc( fieldex.field.ffield ) )
					{
					Assert( pfdb->fidAutoInc == 0 );
					pfdb->fidAutoInc = fieldex.fid;
					}
				}
			else if ( FFixedFid( fieldex.fid ) )
				{
				// For deleted fixed columns, we still need its fixed offset.
				// In addition, we also need its length if it is the last fixed
				// column.  We use this length in order to calculate the
				// offset to the rest of the record (past the fixed data).
				Assert( PfieldFDBFromFid( pfdb, fieldex.fid )->coltyp == JET_coltypNil );
				Assert( PfieldFDBFromFid( pfdb, fieldex.fid )->cbMaxLen == 0 );
				if ( fieldex.fid == pfdb->fidFixedLast )
					{
					Assert( fieldex.field.cbMaxLen > 0 );
					PfieldFDBFixed( pfdb )[fieldex.fid - fidFixedLeast].cbMaxLen =
						fieldex.field.cbMaxLen;
					}
				FILEAddOffsetEntry( pfdb, &fieldex );
				}

			err = ErrIsamMove( ppib, pfucbSc, JET_MoveNext, 0 );
			}
		Assert( err == JET_errNoCurrentRecord );
		Assert( PibFDBFixedOffsets(pfdb)[pfdb->fidFixedLast] == sizeof(RECHDR) );
			
		// If any fixed columns are present, determine offset to data after
		// the fixed data.  If no fixed columns are present, just assert
		// that the offset to the rest of the record has already been
		// set properly.
		Assert( FFixedFid( pfdb->fidFixedLast )  ||
			( pfdb->fidFixedLast == fidFixedLeast - 1  &&
			PibFDBFixedOffsets(pfdb)[pfdb->fidFixedLast] == sizeof(RECHDR) ) );
		if ( pfdb->fidFixedLast >= fidFixedLeast )
			{
			WORD	*pibFixedOffsets = PibFDBFixedOffsets(pfdb);
			USHORT	iLastFid = pfdb->fidFixedLast - 1;

			Assert( iLastFid == 0 ? pibFixedOffsets[iLastFid] == sizeof(RECHDR) :
				pibFixedOffsets[iLastFid] > sizeof(RECHDR) );
			Assert( PfieldFDBFixedFromOffsets( pfdb, pibFixedOffsets )[iLastFid].cbMaxLen > 0 );
			CATPatchFixedOffsets( pfdb,
				(WORD)( pibFixedOffsets[iLastFid]
					+ PfieldFDBFixedFromOffsets( pfdb, pibFixedOffsets )[iLastFid].cbMaxLen ) );
			Assert( pibFixedOffsets[iLastFid+1] > sizeof(RECHDR) );
			}
		}


// UNDONE: Merge the building of the default record with the construction of the FDB above.
// The only tricky thing to be wary of is that we have to somehow first calculate the last
// entry in the fixed offsets table (ie. offset to record data after the fixed data).

	/*	build default record
	/**/
	Call( ErrFILEPrepareDefaultRecord( &fucbFake, &fcbFake, pfdb ) );
	fDefaultRecordPrepared = fTrue;

	Call( ErrIsamMakeKey( ppib, pfucbSc, (BYTE *)&objidTable,
		sizeof(OBJID), JET_bitNewKey ) );
	if ( ( ErrIsamSeek( ppib, pfucbSc, JET_bitSeekGE ) ) >= 0 )
		{
		Call( ErrIsamMakeKey( ppib, pfucbSc, (BYTE *)&objidTable,
			sizeof(OBJID), JET_bitNewKey | JET_bitStrLimit) );
		err = ErrIsamSetIndexRange( ppib, pfucbSc, JET_bitRangeUpperLimit);
		while ( err != JET_errNoCurrentRecord )
			{
			BYTE rgbT[cbLVIntrinsicMost];

			if ( err != JET_errSuccess )
				goto HandleError;

			Call( ErrIsamRetrieveColumn( ppib, pfucbSc,
				CATIGetColumnid(itableSc, iMSC_Default), rgbT,
				cbLVIntrinsicMost-1, &cbDefault, 0, NULL ) );
			Assert( cbDefault <= cbLVIntrinsicMost );
			if ( cbDefault > 0 )
				{
				Call( ErrIsamRetrieveColumn( ppib, pfucbSc,
					CATIGetColumnid(itableSc, iMSC_ColumnId),
					(BYTE *)&columnid, sizeof(columnid),
					&cbActual, 0, NULL ) );
				Assert( cbActual == sizeof( columnid ) );

				// Only long values are allowed to be greater than cbColumnMost.
				// If long value, max is one less than cbLVIntrinsicMost (one byte
				// is reserved for fSeparated flag).
				Assert(	FRECLongValue( PfieldFDBFromFid( pfdb, (FID)columnid )->coltyp ) ?
					cbDefault < cbLVIntrinsicMost : cbDefault <= JET_cbColumnMost );

				err = ErrRECSetDefaultValue( &fucbFake, (FID)columnid, rgbT, cbDefault );
				if ( err == JET_errColumnNotFound )
					err = JET_errSuccess;		// Column may have since been deleted.
				Call( err );
				}
			
			err = ErrIsamMove( ppib, pfucbSc, JET_MoveNext, 0 );
			}

		Assert( err == JET_errNoCurrentRecord );

		}

	/*	alloc and copy default record
	/**/
	pb = SAlloc( fucbFake.lineWorkBuf.cb );
	if ( pb == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	pfdb->lineDefaultRecord.pb = pb;
	LineCopy( &pfdb->lineDefaultRecord, &fucbFake.lineWorkBuf );


	err = JET_errSuccess;

HandleError:
	if ( fDefaultRecordPrepared )
		{
		FILEFreeDefaultRecord( &fucbFake );
		}

	CallS( ErrCATClose( ppib, pfucbSc ) );
	return err;
	}


//	UNDONE:	is there another function in JET which does this?
ULONG UlCATColumnSize( JET_COLTYP coltyp, INT cbMax, BOOL *pfMaxTruncated )
	{
	ULONG	ulLength;
	BOOL	fTruncated = fFalse;

	switch( coltyp )
		{
		case JET_coltypBit:
		case JET_coltypUnsignedByte:
			ulLength = 1;
			Assert( ulLength == sizeof(BYTE) );
			break;

		case JET_coltypShort:
			ulLength = 2;
			Assert( ulLength == sizeof(SHORT) );
			break;

		case JET_coltypLong:
		case JET_coltypIEEESingle:
#ifdef NEW_TYPES
		case JET_coltypDate:
		case JET_coltypTime:
#endif
			ulLength = 4;
			Assert( ulLength == sizeof(LONG) );
			break;

		case JET_coltypCurrency:
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			ulLength = 8;		// sizeof(DREAL)
			break;

#ifdef NEW_TYPES
		case JET_coltypGuid:
			ulLength = 16;
			break;
#endif

		case JET_coltypBinary:
		case JET_coltypText:
			if ( cbMax == 0 )
				{
				ulLength = JET_cbColumnMost;
				}
			else
				{
				ulLength = cbMax;
				if (ulLength > JET_cbColumnMost)
					{
					ulLength = JET_cbColumnMost;
					fTruncated = fTrue;
					}
				}
			break;

		default:
			// Just pass back what was given.
			Assert( FRECLongValue( coltyp )  ||  coltyp == JET_coltypNil );
			ulLength = cbMax;
			break;
		}

	if ( pfMaxTruncated != NULL )
		{
		*pfMaxTruncated = fTruncated;
		}

	return ulLength;
	}


/*	This routines sets/gets table and index stats.
/*	Pass NULL for sz2ndIdxName if looking for sequential or clustered index.
/**/
ERR ErrCATStats( PIB *ppib, DBID dbid, OBJID objidTable, CHAR *sz2ndIdxName, SR *psr, BOOL fWrite )
	{
	ERR		err;
	INT		iTable;
	INT		iStatsCol;
	FUCB	*pfucbCatalog = NULL;
	ULONG	cbActual;

	/*	stats for sequential and clustered indexes are in MSysObjects, while
	/*	stats for non-clustered indexes are in MSysIndexes.
	/**/
	if ( sz2ndIdxName )
		{
		iTable = itableSi;
		iStatsCol = iMSI_Stats;

		CallR( ErrCATOpen( ppib, dbid, szSiTable,
			szSiObjectIdNameIndex, (BYTE *)&objidTable, sizeof(objidTable), &pfucbCatalog ) );
		Call( ErrIsamMakeKey( ppib, pfucbCatalog,						
			(BYTE *)sz2ndIdxName, strlen(sz2ndIdxName), 0 ) );
		}
	else
		{
		iTable = itableSo;
		iStatsCol = iMSO_Stats;

		CallR( ErrCATOpen( ppib, dbid, szSoTable, szSoIdIndex,
			(BYTE *)&objidTable, sizeof(objidTable),  &pfucbCatalog ) );
		}

	Call( ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekEQ ) );

	/*	set/retrieve value
	/**/
	if ( fWrite )
		{
		Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
		Call( ErrIsamSetColumn( ppib, pfucbCatalog,
			CATIGetColumnid(iTable, iStatsCol), (BYTE *)psr, sizeof(SR),
			0, NULL ) );
		Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL ) );
		}
	else
		{
		Call( ErrIsamRetrieveColumn( ppib, pfucbCatalog,
			CATIGetColumnid(iTable, iStatsCol), (BYTE *)psr,
			sizeof(SR), &cbActual, 0, NULL ) );

		Assert( cbActual == sizeof(SR) || err == JET_wrnColumnNull );
		if ( err == JET_wrnColumnNull )
			{
			memset( (BYTE *)psr, '\0', sizeof(SR) );
			err = JET_errSuccess;
			}
		}

	Assert( err == JET_errSuccess );

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


JET_COLUMNID ColumnidCATGetColumnid( INT iTable, INT iField )
	{
	return CATIGetColumnid( iTable, iField );
	}


PGNO PgnoCATTableFDP( CHAR *szTable )
	{
	return rgsystabdef[ ICATITableDefIndex( szTable ) ].pgnoTableFDP;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\comp.c ===
#include "daestd.h"

DeclAssertFile;


#define cbLvMax					1990*16		/* CONSIDER: Optimized for ISAM V1 */

#define ulCMPDefaultDensity		100L		/* to be fine-tuned later */
#define ulCMPDefaultPages		0L

#define NO_GRBIT				0


// UNDONE:  Do these need to be localised?
#define szCompactStatsFile		"DFRGINFO.TXT"
#define szConvertStatsFile		"UPGDINFO.TXT"
#define szCMPAction( pconvert )	( pconvert ? "Upgrade" : "Defragmentation" )
#define szCMPSTATSTableName		"Table Name"
#define szCMPSTATSFixedVarCols	"# Fixed/Variable Columns"
#define szCMPSTATSTaggedCols	"# Tagged Columns"
#define szCMPSTATSPagesOwned	"Pages Owned (Source DB)"
#define szCMPSTATSPagesAvail	"Pages Avail. (Source DB)"
#define szCMPSTATSInitTime		"Table Create/Init. Time"
#define szCMPSTATSRecordsCopied	"# Records Copied"
#define szCMPSTATSRawData		"Raw Data Bytes Copied"
#define szCMPSTATSRawDataLV		"Raw Data LV Bytes Copied"
#define szCMPSTATSLeafPages		"Leaf Pages Traversed"
#define szCMPSTATSMinLVPages	"Min. LV Pages Traversed"
#define szCMPSTATSRecordsTime	"Copy Records Time"
#define szCMPSTATSNCIndexes		"# NC Indexes"
#define szCMPSTATSIndexesTime	"Rebuild Indexes Time"
#define szCMPSTATSTableTime		"Copy Table Time"


typedef struct COLUMNIDINFO
	{
	JET_COLUMNID    columnidSrc;
	JET_COLUMNID    columnidDest;
	} COLUMNIDINFO;


// DLL entry points for CONVERT  --  must be consistent with EXPORTS.DEF
#define szJetInit               "JetInit"
#define szJetTerm               "JetTerm"
#define szJetBeginSession       "JetBeginSession"
#define szJetEndSession         "JetEndSession"
#define szJetAttachDatabase     "JetAttachDatabase"
#define szJetDetachDatabase     "JetDetachDatabase"
#define szJetOpenDatabase       "JetOpenDatabase"
#define szJetCloseDatabase      "JetCloseDatabase"
#define szJetOpenTable          "JetOpenTable"
#define szJetCloseTable         "JetCloseTable"
#define szJetRetrieveColumn     "JetRetrieveColumn"
#define szJetMove               "JetMove"
#define szJetSetSystemParameter "JetSetSystemParameter"
#define szJetGetObjectInfo      "JetGetObjectInfo"
#define szJetGetDatabaseInfo    "JetGetDatabaseInfo"
#define szJetGetTableInfo       "JetGetTableInfo"
#define szJetGetTableColumnInfo "JetGetTableColumnInfo"
#define szJetGetTableIndexInfo  "JetGetTableIndexInfo"
#define szJetGetIndexInfo       "JetGetIndexInfo"

INLINE LOCAL ERR JET_API ErrCDAttachDatabase(
	JET_SESID	sesid,
	const CHAR	*szFilename,
	JET_GRBIT	grbit )
	{
	return ErrIsamAttachDatabase( sesid, szFilename, grbit );
	}

INLINE LOCAL ERR JET_API ErrCDDetachDatabase( JET_SESID sesid, const CHAR *szFilename )
	{
	return ErrIsamDetachDatabase( sesid, szFilename );
	}

INLINE LOCAL ERR JET_API ErrCDOpenDatabase(
	JET_SESID	sesid,
	const CHAR	*szDatabase,
	const CHAR	*szConnect,
	JET_DBID	*pdbid,
	JET_GRBIT	grbit )
	{
	return ErrIsamOpenDatabase( sesid, szDatabase, szConnect, pdbid, grbit );
	}

INLINE LOCAL ERR JET_API ErrCDCloseDatabase(
	JET_SESID	sesid,
	JET_DBID	dbid,
	JET_GRBIT	grbit )
	{
	return ErrIsamCloseDatabase( sesid, dbid, grbit );
	}

// WARNING:  be aware of difference in params Jet vs. Isam
INLINE LOCAL ERR JET_API ErrCDOpenTable(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const CHAR		*szTableName,
	const VOID		*pvParameters,
	ULONG			cbParameters,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid )
	{
	return ErrIsamOpenTable( sesid, dbid, ptableid, (CHAR *)szTableName, grbit );
	}

INLINE LOCAL ERR JET_API ErrCDCloseTable( JET_SESID sesid, JET_TABLEID tableid )
	{
	return ErrDispCloseTable( sesid, tableid );
	}

INLINE LOCAL ERR JET_API ErrCDRetrieveColumn(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	VOID			*pvData,
	ULONG			cbData,
	ULONG			*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo )
	{
	return ErrDispRetrieveColumn( sesid, tableid, columnid, pvData, cbData, pcbActual, grbit, pretinfo );
	}

INLINE LOCAL ERR JET_API ErrCDMove(
	JET_SESID	sesid,
	JET_TABLEID	tableid,
	signed long	cRow,
	JET_GRBIT	grbit )
	{
	return ErrDispMove( sesid, tableid, cRow, grbit );
	}

// WARNING:  be aware of difference in params Jet vs. Isam
INLINE LOCAL ERR JET_API ErrCDGetObjectInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_OBJTYP		objtyp,
	const CHAR		*szContainerName,
	const CHAR		*szObjectName,
	VOID			*pvResult,
	ULONG			cbMax,
	ULONG			InfoLevel )
	{
	return ErrIsamGetObjectInfo( sesid, dbid, objtyp, szContainerName, szObjectName, pvResult, cbMax, InfoLevel );
	}

INLINE LOCAL ERR JET_API ErrCDGetDatabaseInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	VOID			*pvResult,
	ULONG			cbMax,
	ULONG			InfoLevel )
	{
	return ErrIsamGetDatabaseInfo( sesid, dbid, pvResult, cbMax, InfoLevel );
	}

INLINE LOCAL ERR JET_API ErrCDGetTableInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	VOID			*pvResult,
	ULONG			cbMax,
	ULONG			InfoLevel )
	{
	return ErrDispGetTableInfo( sesid, tableid, pvResult, cbMax, InfoLevel );
	}

INLINE LOCAL ERR JET_API ErrCDGetTableColumnInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const CHAR		*szColumnName,
	VOID			*pvResult,
	ULONG			cbMax,
	ULONG			InfoLevel )
	{
	return ErrDispGetTableColumnInfo( sesid, tableid, szColumnName, pvResult, cbMax, InfoLevel );
	}

INLINE LOCAL ERR JET_API ErrCDGetTableIndexInfo(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const CHAR		*szIndexName,
	VOID			*pvResult,
	ULONG			cbResult,
	ULONG			InfoLevel )
	{
	return ErrDispGetTableIndexInfo( sesid, tableid, szIndexName, pvResult, cbResult, InfoLevel );
	}

// WARNING:  be aware of difference in params Jet vs. Isam
INLINE LOCAL ERR JET_API ErrCDGetIndexInfo(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const CHAR		*szTableName,
	const CHAR		*szIndexName,
	VOID			*pvResult,
	ULONG			cbResult,
	ULONG			InfoLevel )
	{
	return ErrIsamGetIndexInfo( sesid, dbid, szTableName, szIndexName, pvResult, cbResult, InfoLevel );
	}

typedef ERR	JET_API VTCDInit( JET_INSTANCE *);
typedef ERR JET_API VTCDTerm( JET_INSTANCE );
typedef ERR JET_API VTCDBeginSession( JET_INSTANCE, JET_SESID *, const CHAR *, const CHAR *);
typedef ERR JET_API VTCDEndSession( JET_SESID, JET_GRBIT );
typedef ERR JET_API VTCDAttachDatabase( JET_SESID, const CHAR *, JET_GRBIT );
typedef ERR JET_API VTCDDetachDatabase( JET_SESID, const CHAR * );
typedef ERR JET_API VTCDOpenDatabase( JET_SESID, const CHAR *, const CHAR *, JET_DBID *, JET_GRBIT );
typedef ERR JET_API VTCDCloseDatabase( JET_SESID, JET_DBID, JET_GRBIT );
typedef ERR JET_API VTCDOpenTable( JET_SESID, JET_DBID, const CHAR *, const VOID *, ULONG, JET_GRBIT, JET_TABLEID * );
typedef ERR JET_API VTCDCloseTable( JET_SESID, JET_TABLEID );
typedef ERR JET_API VTCDRetrieveColumn( JET_SESID, JET_TABLEID, JET_COLUMNID, VOID *, ULONG, ULONG *, JET_GRBIT, JET_RETINFO * );
typedef ERR JET_API VTCDMove( JET_SESID, JET_TABLEID, signed long, JET_GRBIT );
typedef ERR JET_API VTCDSetSystemParameter( JET_INSTANCE *, JET_SESID, ULONG, ULONG, const CHAR * );
typedef ERR JET_API VTCDGetObjectInfo( JET_SESID, JET_DBID, JET_OBJTYP, const CHAR *, const CHAR *, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDGetDatabaseInfo( JET_SESID, JET_DBID, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDGetTableInfo( JET_SESID, JET_TABLEID, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDGetTableColumnInfo( JET_SESID, JET_TABLEID, const CHAR *, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDGetTableIndexInfo( JET_SESID, JET_TABLEID, const CHAR *, VOID *, ULONG, ULONG );
typedef ERR JET_API VTCDGetIndexInfo( JET_SESID, JET_DBID, const CHAR *, const CHAR *, VOID *, ULONG, ULONG );

typedef struct tagVTCD
	{
	JET_SESID				sesid;
	VTCDInit				*pErrCDInit;
	VTCDTerm				*pErrCDTerm;
	VTCDBeginSession		*pErrCDBeginSession;
	VTCDEndSession			*pErrCDEndSession;
	VTCDAttachDatabase		*pErrCDAttachDatabase;
	VTCDDetachDatabase		*pErrCDDetachDatabase;
	VTCDOpenDatabase		*pErrCDOpenDatabase;
	VTCDCloseDatabase		*pErrCDCloseDatabase;
	VTCDOpenTable			*pErrCDOpenTable;
	VTCDCloseTable			*pErrCDCloseTable;
	VTCDRetrieveColumn		*pErrCDRetrieveColumn;					
	VTCDMove				*pErrCDMove;
	VTCDSetSystemParameter	*pErrCDSetSystemParameter;
	VTCDGetObjectInfo		*pErrCDGetObjectInfo;	
	VTCDGetDatabaseInfo		*pErrCDGetDatabaseInfo;
	VTCDGetTableInfo		*pErrCDGetTableInfo;
	VTCDGetTableColumnInfo	*pErrCDGetTableColumnInfo;
	VTCDGetTableIndexInfo	*pErrCDGetTableIndexInfo;
	VTCDGetIndexInfo		*pErrCDGetIndexInfo;

	} VTCD;		// The virtual function table used by compact's function dispatcher.


typedef struct tagCOMPACTINFO
	{
	JET_SESID		sesid;
	JET_DBID		dbidSrc;
	JET_DBID		dbidDest;
	COLUMNIDINFO	rgcolumnids[JET_ccolTableMost];
	ULONG			ccolSingleValue;
	STATUSINFO		*pstatus;
	JET_CONVERT		*pconvert;
	VTCD			vtcd;
	CHAR			rgbBuf[cbLvMax];
	} COMPACTINFO;


/*---------------------------------------------------------------------------
*                                                                                                                                               *
*       Procedure: ErrCMPReportProgress                                                                            *
*                                                                                                                                               *
*       Arguments: pcompactinfo - Compact information segment                                   *
*                                                                                                                                               *
*       Returns : JET_ERR returned by the status call back function                     *
*                                                                                                                                               *
*       Procedure fill up the correct details in the SNMSG structure and call   *
*       the status call back function.                                                                          *
*                                                                                                                                               *
---------------------------------------------------------------------------*/

ERR ErrCMPReportProgress( STATUSINFO *pstatus )
	{
	JET_SNPROG	snprog;

	Assert( pstatus != NULL );
	Assert( pstatus->pfnStatus != NULL );
	Assert( pstatus->snp == JET_snpCompact  ||
		pstatus->snp == JET_snpUpgrade  ||
		pstatus->snp == JET_snpRepair );

	snprog.cbStruct = sizeof( JET_SNPROG );
	snprog.cunitDone = pstatus->cunitDone;
	snprog.cunitTotal = pstatus->cunitTotal;

	Assert( snprog.cunitDone <= snprog.cunitTotal );

	return ( ERR )( *pstatus->pfnStatus )(
			pstatus->sesid,
			pstatus->snp,
			pstatus->snt,
			&snprog );
	}


INLINE LOCAL ERR ErrCMPPopulateVTCD( VTCD *pvtcd, HINSTANCE hDll )
	{
	FARPROC	pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetInit ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDInit = (VTCDInit *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetTerm ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDTerm = (VTCDTerm *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetBeginSession ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDBeginSession = (VTCDBeginSession *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetEndSession ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDEndSession = (VTCDEndSession *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetAttachDatabase ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDAttachDatabase = (VTCDAttachDatabase *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetDetachDatabase ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDDetachDatabase = (VTCDDetachDatabase *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetOpenDatabase ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDOpenDatabase = (VTCDOpenDatabase *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetCloseDatabase ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDCloseDatabase = (VTCDCloseDatabase *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetOpenTable ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDOpenTable = (VTCDOpenTable *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetCloseTable ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDCloseTable = (VTCDCloseTable *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetRetrieveColumn ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDRetrieveColumn = (VTCDRetrieveColumn *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetMove ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDMove = (VTCDMove *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetSetSystemParameter ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDSetSystemParameter = (VTCDSetSystemParameter *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetObjectInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetObjectInfo = (VTCDGetObjectInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetDatabaseInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetDatabaseInfo = (VTCDGetDatabaseInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetTableInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetTableInfo = (VTCDGetTableInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetTableColumnInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetTableColumnInfo = (VTCDGetTableColumnInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetTableIndexInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetTableIndexInfo = (VTCDGetTableIndexInfo *)pfn;

	if ( ( pfn = GetProcAddress( hDll, szJetGetIndexInfo ) ) == NULL )
		return ErrERRCheck( JET_errInvalidOperation );
	pvtcd->pErrCDGetIndexInfo = (VTCDGetIndexInfo *)pfn;
	
	return JET_errSuccess;	
	}


INLINE LOCAL ERR ErrCMPConvertInit(
	VTCD		*pvtcd,
	JET_CONVERT	*pconvert,
	const CHAR	*szDatabaseSrc )
	{
	ERR			err;
	HINSTANCE	hDll;
	DBFILEHDR	dbfilehdr;

	err = ErrUtilReadShadowedHeader( (CHAR *)szDatabaseSrc, (BYTE*)&dbfilehdr, sizeof(DBFILEHDR) );
	if ( err == JET_errSuccess  &&
		dbfilehdr.ulMagic == ulDAEMagic  &&
		dbfilehdr.ulVersion == ulDAEVersion )
		return ErrERRCheck( JET_errDatabaseAlreadyUpgraded );

	hDll = LoadLibrary( pconvert->szOldDll );
	if ( hDll == NULL )
		return ErrERRCheck( JET_errAccessDenied );

	Call( ErrCMPPopulateVTCD( pvtcd, hDll ) );

	if ( pconvert->szOldSysDb )
		{
		// Use JET_paramSysDbPath (instead of JET_paramSystemPath) for
		// backward compatibility with pre-500 series JET.
		Call( (*pvtcd->pErrCDSetSystemParameter)( 0, 0, JET_paramSysDbPath, 0, pconvert->szOldSysDb ) );
		}
	Call( (*pvtcd->pErrCDSetSystemParameter)( 0, 0, JET_paramTempPath, 0, "tempconv.edb" ) );
	Call( (*pvtcd->pErrCDSetSystemParameter)( 0, 0, JET_paramRecovery, 0, "off" ) );
	Call( (*pvtcd->pErrCDInit)( 0 ) );
	Call( (*pvtcd->pErrCDBeginSession)( 0, &pvtcd->sesid, "user", "" ) );
	Call( (*pvtcd->pErrCDAttachDatabase)( pvtcd->sesid, szDatabaseSrc, 0 ) );
	pconvert->fDbAttached = ( err == JET_wrnDatabaseAttached );

HandleError:
	return err;
	}


INLINE LOCAL ERR ErrCMPConvertCleanup(
	VTCD		*pvtcd,
	JET_CONVERT	*pconvert,
	const CHAR	*szDatabaseSrc,
	BOOL		fErrorOccurred )
	{
	ERR			err;
	JET_SESID	sesid = pvtcd->sesid;
	HINSTANCE	hDll = GetModuleHandle( pconvert->szOldDll );
	BOOL		fFunctionsLoaded;

	// Ensure that the functions we need are callable.
	fFunctionsLoaded = ( pvtcd->pErrCDDetachDatabase  &&
		pvtcd->pErrCDEndSession  &&  pvtcd->pErrCDTerm );
	if ( !fFunctionsLoaded )
		{
		err = JET_errSuccess;		// Can't shutdown gracefully.  Just get out.
		goto Done;
		}

	if ( fErrorOccurred )
		{
		err = JET_errSuccess;		// Force cleanup and return success.
		goto HandleError;
		}

	Assert( pvtcd->sesid != 0 );

	if ( !pconvert->fDbAttached )
		{
		Call( (*pvtcd->pErrCDDetachDatabase)( pvtcd->sesid, szDatabaseSrc ) );
		}

	Call( (*pvtcd->pErrCDEndSession)( pvtcd->sesid, 0 ) );
	sesid = 0;
	Call( (*pvtcd->pErrCDTerm)( 0 ) );

	goto Done;


HandleError:

	// Error has already occurred.  Ignore any errors generated by these
	// functions as we attempt to clean up.
	if ( sesid != 0 )
		{
		if ( !pconvert->fDbAttached )
			{
			(VOID)( (*pvtcd->pErrCDDetachDatabase)( pvtcd->sesid, szDatabaseSrc ) );
			}
		(VOID)( (*pvtcd->pErrCDEndSession)( pvtcd->sesid, 0 ) );
		}

	(VOID)( (*pvtcd->pErrCDTerm)( 0 ) );


Done:
	if ( hDll )
		{
		FreeLibrary( hDll );
		}

	return err;
	}


/*---------------------------------------------------------------------------
*                                                                                                                                               *
*       Procedure: ErrCMPCompactInit                                                                                                       *
*                                                                                                                                               *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                          szDatabaseSrc        - Source database that will be converted    *
*                          szConnectSrc         - Connect string for source database            *
*                          szDatabaseDest       - Destination database name                             *
*                          szConnectDest        - Connect string for destination database       *
*                          grbitCompact         - Compact options                                                       *
*                                                                                                                                               *
*       Returns : JET_ERR                                                                                                       *
*                                                                                                                                               *
*       Procedure Opens the source database.  It creates and opens                      *
*       the destination database.                                                                                               *
*                                                                                                                                               *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCompactInit(
	COMPACTINFO     *pcompactinfo,
	const CHAR      *szDatabaseSrc,
	const CHAR      *szDatabaseDest )
	{
	ERR				err;
	JET_SESID		sesid;
	JET_DBID		dbidSrc;
	JET_DBID		dbidDest;
	VTCD			*pvtcd = &pcompactinfo->vtcd;

	sesid = pcompactinfo->sesid;

	/*	open the source DB Exclusive and ReadOnly
	/**/
	CallR( (*pvtcd->pErrCDOpenDatabase)( pvtcd->sesid,
		szDatabaseSrc, NULL, &dbidSrc,
		JET_bitDbExclusive|JET_bitDbReadOnly ) );

	/* Create and then open the destination database. */

	/* JET_bitCompactDontCopyLocale is set when the user */
	/* wants to ensure that all locales are homogeneous */
	/* throughout the new compacted db - there are to be no */
	/* mixed-language indexes or tables. */

	/* Build a connect string for the destination database if the user */
	/* hasn't supplied one. */

	/* CONSIDER: Always build the connect substring and insert it into */
	/* CONSIDER: the user supplied connect string following the first */
	/* CONSIDER: semicolon ( if any ).  If the user has specified a locale, */
	/* CONSIDER: it will override the one from the connect substring. */

	Call( ErrIsamCreateDatabase( sesid, szDatabaseDest, NULL,
		&dbidDest, JET_bitDbRecoveryOff|JET_bitDbVersioningOff ) );

	/* CONSIDER: Should the destination database be deleted if it already */
	/* CONSIDER: exists? */

	pcompactinfo->dbidSrc = dbidSrc;
	pcompactinfo->dbidDest = dbidDest;

	return( JET_errSuccess );

HandleError:
	(*pvtcd->pErrCDCloseDatabase)( pvtcd->sesid, (JET_VDBID)dbidSrc, 0 );

	return( err );
	}


INLINE LOCAL ERR ErrCMPCopyTaggedColumns(
	COMPACTINFO		*pcompactinfo,
	JET_TABLEID		tableidSrc,
	JET_TABLEID		tableidDest,
	JET_COLUMNID	*mpcolumnidcolumnidTagged )
	{
	ERR				err;
	VTCD			*pvtcd = &pcompactinfo->vtcd;
	ULONG			cbActual;
	JET_COLUMNID	columnidSrc;
	JET_COLUMNID	columnidDest;
	JET_SETINFO		setinfo = { sizeof(JET_SETINFO), 0, 1 };
	JET_RETINFO		retinfo = { sizeof(JET_RETINFO), 0, 1, 0 };

		
	CallR( (*pvtcd->pErrCDRetrieveColumn)(
		pvtcd->sesid,
		tableidSrc,
		0,
		pcompactinfo->rgbBuf,
		cbLvMax,
		&cbActual,
		JET_bitRetrieveNull|JET_bitRetrieveIgnoreDefault,
		&retinfo ) );

	columnidSrc = 0;
	while ( err != JET_wrnColumnNull )
		{
		Assert( FTaggedFid( retinfo.columnidNextTagged ) );

		// Is this a new column, or another occurrence of the current column?
		if ( columnidSrc == retinfo.columnidNextTagged )
			{
			Assert( setinfo.itagSequence >= 1 );
			setinfo.itagSequence++;
			}
		else
			{
			columnidSrc = retinfo.columnidNextTagged;
			setinfo.itagSequence = 1;
			}

		Assert( mpcolumnidcolumnidTagged != NULL );
		columnidDest = mpcolumnidcolumnidTagged[columnidSrc - fidTaggedLeast];

		if ( cbActual > 0  ||  err == JET_wrnColumnSetNull )
			{
			ULONG	itagSequenceSave;

			// Save off table's retinfo, then set retinfo for current column.
			itagSequenceSave = retinfo.itagSequence;
			retinfo.itagSequence = setinfo.itagSequence;
			Assert( retinfo.ibLongValue == 0 );

			if ( cbActual > cbLvMax )
				{
				Assert( err == JET_wrnBufferTruncated );
				cbActual = cbLvMax;
				}

			Assert( setinfo.ibLongValue == 0 );
			CallR( ErrDispSetColumn(
				pcompactinfo->sesid,
				tableidDest,
				columnidDest,
				pcompactinfo->rgbBuf,
				cbActual,
				NO_GRBIT,
				&setinfo ) );

			/* while the long value is not all copied */

			while ( cbActual == cbLvMax )
				{
				retinfo.ibLongValue += cbLvMax;

				CallR( (*pvtcd->pErrCDRetrieveColumn)(
					pvtcd->sesid,
					tableidSrc,
					columnidSrc,
					pcompactinfo->rgbBuf,
					cbLvMax,
					&cbActual,
					JET_bitRetrieveNull|JET_bitRetrieveIgnoreDefault,
					&retinfo ) );
				Assert( err == JET_wrnBufferTruncated  ||  err == JET_errSuccess );
				Assert( retinfo.columnidNextTagged == columnidSrc );
				
				// Even though we specified RetrieveNull (to be consistent with
				// the initial call), we shouldn't encounter any (the initial
				// call would have handled it).
				// Note that even though we shouldn't get wrnColumnNull, cbActual
				// may still be 0 because retinfo.ibLongValue is greater than 0.
				Assert( err != JET_wrnColumnSetNull );
				Assert( err != JET_wrnColumnNull );

				if ( cbActual > 0 )
					{
					if ( cbActual > cbLvMax )
						{
						Assert( err == JET_wrnBufferTruncated );
						cbActual = cbLvMax;
						}

					// Since we're appending, no need to set ibLongValue.
					Assert( setinfo.ibLongValue == 0 );
					CallR( ErrDispSetColumn(
						pcompactinfo->sesid,
						tableidDest,
						columnidDest,
						pcompactinfo->rgbBuf,
						cbActual,
						JET_bitSetAppendLV,
						&setinfo ) );
					}
				}

			// Restore retinfo for next column.
			retinfo.itagSequence = itagSequenceSave;
			retinfo.ibLongValue = 0;
			}

		else		//	!( cbActual > 0 )
			{
			Assert( setinfo.ibLongValue == 0 );
			CallR( ErrDispSetColumn(
				pcompactinfo->sesid,
				tableidDest,
				columnidDest,
				NULL,
				0,
				JET_bitSetZeroLength,
				&setinfo ) );
			}

		retinfo.itagSequence++;

		Assert( retinfo.ibLongValue == 0 );
		
		CallR( (*pvtcd->pErrCDRetrieveColumn)(
			pvtcd->sesid,
			tableidSrc,
			0,
			pcompactinfo->rgbBuf,
			cbLvMax,
			&cbActual,
			JET_bitRetrieveNull|JET_bitRetrieveIgnoreDefault,
			&retinfo ) );

		}	// ( err != JET_wrnColumnNull )

	return JET_errSuccess;
	}

/*---------------------------------------------------------------------------
*                                                                                       *
*       Procedure: ErrCMPCopyColumnData                                                 *
*                                                                                       *
*       Arguments: sesid        - session id in which the work is done                  *
*                  tableidSrc   - tableid pointing to the row in the SrcTbl             *
*                  tableidDest  - tableid pointing to the row in the DestTbl            *
*                  columnidSrc  - the columnid of the column in the srcDb               *
*                  columnidDest - the columnid of the column in the DestDb              *
*                  pvBuf                - the segment for copying long values           *
*                                                                                       *
*       Returns : JET_ERR                                                               *
*                                                                                       *
*       Procedure copies a column for the from the source to dest db.                   *
*                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyColumnData(
	JET_SESID		sesid,
	JET_TABLEID		tableidSrc,
	JET_TABLEID		tableidDest,
	JET_COLUMNID	columnidSrc,
	JET_COLUMNID	columnidDest,
	VOID			*pvBuf,
	VTCD			*pvtcd )
	{
	ULONG			cbActual;
	JET_GRBIT		grbit;
	JET_RETINFO		retinfo;
	ERR				err;

	retinfo.cbStruct = sizeof( retinfo );
	retinfo.ibLongValue = 0;
	retinfo.itagSequence = 1;
	retinfo.columnidNextTagged = 0;

	// Tagged columns are handled in CMPCopyTaggedColumns().
	Assert( !FTaggedFid( columnidSrc ) );
	Assert( !FTaggedFid( columnidDest ) );

	CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, tableidSrc, columnidSrc, pvBuf,
			cbLvMax, &cbActual, NO_GRBIT, &retinfo ) );

	Assert( cbActual <= JET_cbColumnMost );
	Assert( err == JET_errSuccess  ||  err == JET_wrnColumnNull );

	grbit = ( cbActual == 0  &&  err != JET_wrnColumnNull ?
		JET_bitSetZeroLength : NO_GRBIT );

	CallR( ErrDispSetColumn( sesid, tableidDest, columnidDest, pvBuf,
			cbActual, grbit, NULL ) );

	return( JET_errSuccess );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCMPCopyOneIndex                                                                                              *
*                                                                                                                                                       *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                          tableidDest          - table on which to build the index                     *
*                          szTableName          - table name on which the index is based    *
*                          indexList            - struct return from JetGetTableIndexInfo   *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure copies the columns for a table from the source db                             *
*       to the destination databases                                                                                    *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

LOCAL ERR ErrCMPCopyOneIndex(
	COMPACTINFO		*pcompactinfo,
	JET_TABLEID		tableidDest,
	const CHAR		*szTableName,
	JET_INDEXLIST	*indexList )
	{
	CHAR			*szSeg;
	ERR				err;
	CHAR			szIndexName[JET_cbNameMost+1];
	CHAR			rgchColumnName[JET_cbNameMost];
	JET_GRBIT		grbit;
	JET_GRBIT		grbitColumn;
	ULONG			ichKey;
	ULONG			cbActual;
	ULONG			ulDensity = ulCMPDefaultDensity;
	USHORT			langid = 0;
	VTCD			*pvtcd = &pcompactinfo->vtcd;

	szSeg = pcompactinfo->rgbBuf;

	/* retrieve info from table and create the index */

	CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
				indexList->columnidindexname, szIndexName,
				JET_cbNameMost, &cbActual, NO_GRBIT, NULL ) );

	szIndexName[cbActual] = '\0';

	CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
				indexList->columnidgrbitIndex, &grbit,
				sizeof( JET_GRBIT ), &cbActual, NO_GRBIT, NULL ) );

	/* create the szkey used in ErrIsamCreateIndex */

	ichKey = 0;

	for ( ;; )
		{
		ULONG	iColumn;

		/* Get the individual columns that make up the index */

		CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
					indexList->columnidgrbitColumn, &grbitColumn,
					sizeof( JET_GRBIT ), &cbActual, NO_GRBIT, NULL ) );

		CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
					indexList->columnidcolumnname, rgchColumnName,
					JET_cbNameMost, &cbActual, NO_GRBIT, NULL ) );

		if ( grbitColumn == JET_bitKeyDescending )
			szSeg[ichKey++] = '-';
		else
			szSeg[ichKey++] = '+';

		/* Append the column name to the description */

		memcpy( szSeg+ichKey, rgchColumnName, ( size_t ) cbActual );

		ichKey += cbActual;
		szSeg[ichKey++] = '\0';

		err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MoveNext, NO_GRBIT );

		if ( err == JET_errNoCurrentRecord )
			break;

		if ( err < 0 )
			{
			return( err );
			}

		CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
				indexList->columnidiColumn, &iColumn,
				sizeof( iColumn ), &cbActual, NO_GRBIT, NULL ) );

		if ( iColumn == 0 )
			break;         /* Start of a new Index */
		}

	szSeg[ichKey++] = '\0';

	CallR( (*pvtcd->pErrCDGetIndexInfo)(
		pvtcd->sesid,
		(JET_VDBID)pcompactinfo->dbidSrc,
		szTableName,
		szIndexName,
		&ulDensity,
		sizeof(ulDensity),
		JET_IdxInfoSpaceAlloc ) );

	/*      get index language id
	/**/
	CallR( (*pvtcd->pErrCDGetIndexInfo)(
		pvtcd->sesid,
		pcompactinfo->dbidSrc,
		szTableName,
		szIndexName,
		&langid,
		sizeof(langid),
		JET_IdxInfoLangid ) );

	if ( langid != 0 )
		{
		*((UNALIGNED USHORT *)(&szSeg[ichKey])) = langid;
		ichKey += 2;
		szSeg[ichKey++] = '\0';
		szSeg[ichKey++] = '\0';
		}

	CallR( ErrDispCreateIndex( pcompactinfo->sesid, tableidDest,
			szIndexName, grbit, szSeg, ichKey, ulDensity ) );

	err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MovePrevious, NO_GRBIT );

	return( err );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                               *
*       Procedure: ErrCMPCopyTableIndexes                                                                          *
*                                                                                                                                               *
*       Arguments: pcompactinfo                                                                                                 *
*                  tableidDest  - table on which to build the index                             *
*                  szTableName  - table name on which the index is based                *
*                  indexList    - struct return from JetGetTableIndexInfo               *
*                                                                                                                                               *
*       Returns : JET_ERR                                                                                                       *
*                                                                                                                                               *
*       Procedure copies all the indexes except for the clustered index         *
*                                                                                                                                               *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyTableIndexes(
	COMPACTINFO		*pcompactinfo,
	JET_TABLEID		tableidDest,
	const CHAR		*szTableName,
	JET_INDEXLIST	*indexList,
	ULONG			cpgPerIndex )
	{
	ERR				err;
	JET_GRBIT		grbit;
	ULONG			cbActual;
	VTCD			*pvtcd = &pcompactinfo->vtcd;

	err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MoveFirst, NO_GRBIT );

	/* loop through all the indexes for this table          */

	while ( err >= 0 )
		{
		CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
					indexList->columnidgrbitIndex,
					&grbit, sizeof( JET_GRBIT ), &cbActual,
					NO_GRBIT, NULL ) );

		/* Don't copy references here */

		if ( ( grbit & JET_bitIndexReference ) == 0 )
			{
			/* If the index is not cluster create the index using CopyOneIndex */

			if ( ( grbit & JET_bitIndexClustered ) == 0 )
				{
				CallR( ErrCMPCopyOneIndex( pcompactinfo, tableidDest,
						szTableName, indexList ) );

				if ( pcompactinfo->pstatus )
					{
					pcompactinfo->pstatus->cNCIndexes++;
					pcompactinfo->pstatus->cunitDone += cpgPerIndex;
					CallR( ErrCMPReportProgress( pcompactinfo->pstatus ) );
					}
				}
			}

		err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MoveNext, NO_GRBIT );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	return( err );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCMPCopyClusteredIndex                                                                                *
*                                                                                                                                                       *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                          tableidDest          - table on which to build the index                     *
*                          szTableName          - table name on which the index is based    *
*                          indexList            - struct return from JetGetTableIndexInfo   *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure checks to see if there is cluster index for the function              *
*       if there is it creates the clustered index                                                              *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyClusteredIndex(
	COMPACTINFO		*pcompactinfo,
	JET_TABLEID		tableidDest,
	const CHAR		*szTableName,
	JET_INDEXLIST	*indexList,
	BOOL			*pfClustered )
	{
	ERR				err;
	JET_GRBIT		grbit;
	ULONG			cbActual;
	VTCD			*pvtcd = &pcompactinfo->vtcd;

	*pfClustered = fFalse;

	err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MoveFirst, NO_GRBIT );

	/* while there are still index rows or a cluster index has been found */

	while ( err >= 0 )
		{
		CallR( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, indexList->tableid,
					indexList->columnidgrbitIndex, &grbit,
					sizeof( JET_GRBIT ), &cbActual, NO_GRBIT, NULL ) );

		/* Don't copy references here */

		if ( ( grbit & JET_bitIndexReference ) == 0 )
			{
			/* If the index is clustered then create it */

			if ( grbit & JET_bitIndexClustered )
				{
				CallR( ErrCMPCopyOneIndex( pcompactinfo, tableidDest,
						szTableName, indexList ) );
				*pfClustered = fTrue;
				break;
				}
			}

		err = (*pvtcd->pErrCDMove)( pvtcd->sesid, indexList->tableid, JET_MoveNext, NO_GRBIT );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

	return( err );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCreateTableColumn                                                                                                *
*                                                                                                                                                       *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                  tableidDest          - table on which to build the index                     *
*                  szTableName          - table name on which the index is based    *
*                  columnList           - struct returned from GetTableColumnInfo       *
*                  columnidInfo         - the columnid's of the user table                      *
*                  tableidTagged        - the tableid of the tagged columns                     *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure copies the columns for a table from the source db                             *
*       to the destination databases                                                                                    *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCreateTableColumn(
	COMPACTINFO		*pcompactinfo,
	const CHAR		*szTableName,
	JET_TABLECREATE	*ptablecreate,
	JET_COLUMNLIST	*columnList,
	COLUMNIDINFO	*columnidInfo,
	JET_COLUMNID	**pmpcolumnidcolumnidTagged )
	{
	ERR				err;
	JET_SESID		sesid;
	JET_DBID		dbidSrc, dbidDest;
	ULONG			ccolSingleValue = 0, cColumns = 0;
	ULONG			cbAllocate;
	ULONG			cbActual;
	JET_COLUMNID	*mpcolumnidcolumnidTagged = NULL;
	BOOL			fLocalAlloc = fFalse;
	JET_COLUMNCREATE *rgcolcreate, *pcolcreateCurr;
	JET_COLUMNID	*rgcolumnidSrc, *pcolumnidSrc;
	JET_COLUMNID	columnidTaggedHighest = 0;
	BYTE			*rgbDefaultValues, *pbCurrDefault;
	BYTE			*pbMax;
	VTCD			*pvtcd = &pcompactinfo->vtcd;
	ULONG			cTagged = 0;

	typedef struct
		{
		BYTE 	szName[JET_cbNameMost+1+3];	// +1 for null-terminator, +3 for 4-byte alignment
		ULONG	ulPOrder;					// Only needs to be short, but make long for alignment
		} NAME_PO;
	NAME_PO			*rgNamePO, *pNamePOCurr;

	sesid = pcompactinfo->sesid;
	dbidSrc = pcompactinfo->dbidSrc;
	dbidDest = pcompactinfo->dbidDest;

	Assert( ptablecreate->cCreated == 0 );

	// Allocate a pool of memory for:
	//		1) list of source table columnids
	//		2) the JET_COLUMNCREATE structures
	//		3) buffer for column names and presentation order
	//		4) buffer for default values and presentation order
	// WARNING: Ensure that each of the elements above is 4-byte aligned

	cColumns = columnList->cRecord;
	cbAllocate =
		( cColumns *
			( sizeof(JET_COLUMNID) +	// source table columnids
			sizeof(JET_COLUMNCREATE) +	// JET_COLUMNCREATE structures
			sizeof(NAME_PO) ) )			// column names and presentation order
		+ cbRECRecordMost;				// all default values must fit in an intrinsic record

	// Can we use the buffer hanging off pcompactinfo?
	if ( cbAllocate <= cbLvMax )
		{
		rgcolumnidSrc = (JET_COLUMNID *)pcompactinfo->rgbBuf;
		}
	else
		{
		rgcolumnidSrc = SAlloc( cbAllocate );
		if ( rgcolumnidSrc == NULL )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			goto HandleError;
			}
		fLocalAlloc = fTrue;
		}
	memset( (BYTE *)rgcolumnidSrc, 0, cbAllocate );
	pbMax = (BYTE *)rgcolumnidSrc + cbAllocate;
	pcolumnidSrc = rgcolumnidSrc;

	// JET_COLUMNCREATE structures follow the tagged columnid map.
	rgcolcreate = pcolcreateCurr =
		(JET_COLUMNCREATE *)( rgcolumnidSrc + cColumns );
	Assert( (BYTE *)rgcolcreate < pbMax );

	// Column names and presentation order follow the JET_COLUMNCREATE structures.
	rgNamePO = pNamePOCurr =
		(NAME_PO *)( rgcolcreate + cColumns );
	Assert( (BYTE *)rgNamePO < pbMax );

	// Default values follow the NAME_PO structures.
	rgbDefaultValues = pbCurrDefault = (BYTE *)( rgNamePO + cColumns );

	Assert( rgbDefaultValues + cbRECRecordMost == pbMax );

	err = (*pvtcd->pErrCDMove)( pvtcd->sesid, columnList->tableid, JET_MoveFirst, NO_GRBIT );

	/* loop though all the columns in the table for the src tbl and
	/* copy the information in the destination database
	/**/
	cColumns = 0;
	while ( err >= 0 )
		{
		pcolcreateCurr->cbStruct = sizeof(JET_COLUMNCREATE);

		/* retrieve info from table and create all the columns
		/**/
		Call( (*pvtcd->pErrCDRetrieveColumn)(
			pvtcd->sesid,
			columnList->tableid,
			columnList->columnidcolumnname,
			pNamePOCurr->szName,
			JET_cbNameMost,
			&cbActual,
			NO_GRBIT,
			NULL ) );

		pNamePOCurr->szName[cbActual] = '\0';
		pcolcreateCurr->szColumnName = (BYTE *)pNamePOCurr;
		Assert( pcolcreateCurr->szColumnName == pNamePOCurr->szName );	// Assert name is first field.

		// Assert initialised to zero, which also means no PO.
		Assert( pNamePOCurr->ulPOrder == 0 );
		Call( (*pvtcd->pErrCDRetrieveColumn)(
			pvtcd->sesid,
			columnList->tableid,
			columnList->columnidPresentationOrder,
			&pNamePOCurr->ulPOrder,
			sizeof(pNamePOCurr->ulPOrder),
			&cbActual,
			NO_GRBIT,
			NULL ) );
		Assert( err == JET_wrnColumnNull  ||  cbActual == sizeof(ULONG) );

		pNamePOCurr++;
		Assert( (BYTE *)pNamePOCurr <= rgbDefaultValues );

		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidcoltyp, &pcolcreateCurr->coltyp,
			sizeof( pcolcreateCurr->coltyp ), &cbActual, NO_GRBIT, NULL ) );
		Assert( cbActual == sizeof( JET_COLTYP ) );

		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidcbMax, &pcolcreateCurr->cbMax,
			sizeof( pcolcreateCurr->cbMax ), &cbActual, NO_GRBIT, NULL ) );
		Assert( cbActual == sizeof( ULONG ) );

		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidgrbit, &pcolcreateCurr->grbit,
			sizeof( pcolcreateCurr->grbit ), &cbActual, NO_GRBIT, NULL ) );
		Assert( cbActual == sizeof( JET_GRBIT ) );

		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidCp, &pcolcreateCurr->cp,
			sizeof( pcolcreateCurr->cp ), &cbActual, NO_GRBIT, NULL ) );
		Assert( cbActual == sizeof( USHORT ) );

		/*	retrieve default value.
		/**/
		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidDefault, pbCurrDefault,
			cbRECRecordMost, &pcolcreateCurr->cbDefault, NO_GRBIT, NULL ) );
		pcolcreateCurr->pvDefault = pbCurrDefault;
		pbCurrDefault += pcolcreateCurr->cbDefault;
		Assert( pbCurrDefault <= pbMax );

		// Save the source columnid.
		/* CONSIDER: Should the column id be checked? */
		Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, columnList->tableid,
			columnList->columnidcolumnid, pcolumnidSrc,
			sizeof( JET_COLUMNID ), &cbActual, NO_GRBIT, NULL ) );
		Assert( cbActual == sizeof( JET_COLUMNID ) );

		if ( pcolcreateCurr->grbit & JET_bitColumnTagged )
			{
			cTagged++;
			columnidTaggedHighest = max( columnidTaggedHighest, *pcolumnidSrc );
			}

		pcolumnidSrc++;
		Assert( (BYTE *)pcolumnidSrc <= (BYTE *)rgcolcreate );

		pcolcreateCurr++;
		Assert( (BYTE *)pcolcreateCurr <= (BYTE *)rgNamePO );
		cColumns++;

		err = (*pvtcd->pErrCDMove)( pvtcd->sesid, columnList->tableid, JET_MoveNext, NO_GRBIT );
		}

	Assert( cColumns == columnList->cRecord );


	Assert( ptablecreate->rgcolumncreate == NULL );
	Assert( ptablecreate->cColumns == 0 );
	Assert( ptablecreate->rgindexcreate == NULL );
	Assert( ptablecreate->cIndexes == 0 );

	ptablecreate->rgcolumncreate = rgcolcreate;
	ptablecreate->cColumns = cColumns;

	Call( ErrIsamCreateTable( sesid, (JET_VDBID)dbidDest, ptablecreate ) );
	Assert( ptablecreate->cCreated == 1 + cColumns );

	ptablecreate->rgcolumncreate = NULL;
	ptablecreate->cColumns = 0;


	// If there's at least one tagged column, create an array for the
	// tagged columnid map.
	if ( cTagged > 0 )
		{
		Assert( FTaggedFid( columnidTaggedHighest ) );
		cbAllocate = sizeof(JET_COLUMNID) * ( columnidTaggedHighest + 1 - fidTaggedLeast );
		mpcolumnidcolumnidTagged = SAlloc( cbAllocate );
		if ( mpcolumnidcolumnidTagged == NULL )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			goto HandleError;
			}
		memset( (BYTE *)mpcolumnidcolumnidTagged, 0, cbAllocate );
		}


	// Update columnid maps.
	for ( pcolcreateCurr = rgcolcreate, pcolumnidSrc = rgcolumnidSrc, cColumns = 0;
		cColumns < columnList->cRecord;
		pcolcreateCurr++, pcolumnidSrc++, cColumns++ )
		{
		Assert( (BYTE *)pcolcreateCurr <= (BYTE *)rgNamePO );
		Assert( (BYTE *)pcolumnidSrc <= (BYTE *)rgcolcreate );

		if ( pcolcreateCurr->grbit & JET_bitColumnTagged )
			{
			Assert( FTaggedFid( *pcolumnidSrc ) );
			Assert( FTaggedFid( pcolcreateCurr->columnid ) );
			Assert( *pcolumnidSrc <= columnidTaggedHighest );
			Assert( mpcolumnidcolumnidTagged[*pcolumnidSrc - fidTaggedLeast] == 0 );
			mpcolumnidcolumnidTagged[*pcolumnidSrc - fidTaggedLeast] = pcolcreateCurr->columnid;
			}
		else
			{
			/*	else add the columnids to the columnid array
			/**/
			columnidInfo[ccolSingleValue].columnidDest = pcolcreateCurr->columnid;
			columnidInfo[ccolSingleValue].columnidSrc  = *pcolumnidSrc;
			ccolSingleValue++;
			}	// if ( columndef.grbit & JET_bitColumnTagged )
		}

	/*	set count of fixed and variable columns to copy
	/**/
	pcompactinfo->ccolSingleValue = ccolSingleValue;

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

HandleError:
	if ( err < 0  &&  mpcolumnidcolumnidTagged )
		{
		SFree( mpcolumnidcolumnidTagged );
		mpcolumnidcolumnidTagged = NULL;
		}

	if ( fLocalAlloc )
		{
		SFree( rgcolumnidSrc );
		}

	// Set return value.
	*pmpcolumnidcolumnidTagged = mpcolumnidcolumnidTagged;

	return err;
	}


LOCAL INLINE VOID CMPSetTime( ULONG *ptimerStart )
	{
	*ptimerStart = GetTickCount();
	}

LOCAL VOID CMPGetTime( ULONG timerStart, INT *piSec, INT *piMSec )
	{
	ULONG	timerEnd;

	timerEnd = GetTickCount();
	
	*piSec = ( timerEnd - timerStart ) / 1000;
	*piMSec = ( timerEnd - timerStart ) % 1000;
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCMPCopyTable                                                                                                 *
*                                                                                                                                                       *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                          szObjectName         - object name to copy the owner of              *
*                          szContainerName      - Container name in which the object exists *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure copies the table from the source database to the                              *
*       destination database.  It can also copy queries, invoked by                             *
*       ErrCMPCopyObjects                                                                                                                  *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyTable(
	COMPACTINFO		*pcompactinfo,
	const CHAR		*szObjectName )
	{
	JET_DBID		dbidSrc = pcompactinfo->dbidSrc;
	ERR				err;
	ERR				errT;
	JET_TABLEID		tableidSrc;
	JET_TABLEID		tableidDest;
	JET_COLUMNLIST	columnList;
	JET_INDEXLIST	indexList;
	INT				cIndexes;
	BOOL			fHasClustered;
	JET_COLUMNID    *mpcolumnidcolumnidTagged = NULL;
	BOOL			fPageBasedProgress = fFalse;
	STATUSINFO		*pstatus = pcompactinfo->pstatus;
	INT				iSec;
	INT				iMSec;
	ULONG			crowCopied = 0;
	ULONG			recidLast;
	ULONG			rgulAllocInfo[] = { ulCMPDefaultPages, ulCMPDefaultDensity };
	ULONG			cpgProjected;
	BOOL			fCorruption = fFalse;
	VTCD			*pvtcd = &pcompactinfo->vtcd;
	JET_TABLECREATE	tablecreate = {
		sizeof(JET_TABLECREATE),
		(CHAR *)szObjectName,
		ulCMPDefaultPages,
		ulCMPDefaultDensity,
		NULL,
		0,
		NULL,
		0,
		0,
		0,
		0
		};

	if ( pstatus  &&  pstatus->fDumpStats )
		{
		Assert( pstatus->hfCompactStats );
		fprintf( pstatus->hfCompactStats, "%s\t", szObjectName );
		fflush( pstatus->hfCompactStats );
		CMPSetTime( &pstatus->timerCopyTable );
		CMPSetTime( &pstatus->timerInitTable );
		}

	CallR( (*pvtcd->pErrCDOpenTable)(
		pvtcd->sesid,
		(JET_VDBID)dbidSrc,
		(CHAR *)szObjectName,
		NULL,
		0,
		JET_bitTableSequential,
		&tableidSrc ) );

	err = (*pvtcd->pErrCDGetTableInfo)(
		pvtcd->sesid,
		tableidSrc,
		rgulAllocInfo,
		sizeof(rgulAllocInfo),
		JET_TblInfoSpaceAlloc);
	if ( err < 0  &&  !fGlobalRepair )
		{
		goto CloseIt1;
		}

	// On error, just use the default values of rgulAllocInfo.
	tablecreate.ulPages = rgulAllocInfo[0];
	tablecreate.ulDensity = rgulAllocInfo[1];

	/*	get a table with the column information for the query in it
	/**/
	CallJ( (*pvtcd->pErrCDGetTableColumnInfo)(
		pvtcd->sesid,
		tableidSrc,
		NULL,
		&columnList,
		sizeof(columnList),
		JET_ColInfoListCompact ), CloseIt1 );

	/*	if a table create the columns in the Dest Db the same as in
	/*	the src Db.
	/**/
	err = ErrCMPCreateTableColumn(
		pcompactinfo,
		szObjectName,
		&tablecreate,
		&columnList,
		pcompactinfo->rgcolumnids,
		&mpcolumnidcolumnidTagged );

	errT = (*pvtcd->pErrCDCloseTable)( pvtcd->sesid, columnList.tableid );
	if ( err < 0  ||  errT < 0 )
		{
		if ( err >= 0 )
			{
			Assert( errT < 0 );
			err = errT;
			}
		goto CloseIt2;
		}

	tableidDest = tablecreate.tableid;
	Assert( tablecreate.cCreated == 1 + columnList.cRecord );

	/*  Get the information on the indexes and check if
	/*	there is a clustered index.
	/**/
	CallJ( (*pvtcd->pErrCDGetTableIndexInfo)(
		pvtcd->sesid,
		tableidSrc,
		NULL,
		&indexList,
		sizeof(indexList),
		JET_IdxInfoList ), CloseIt3 );

	if ( pcompactinfo->pconvert )
		// If converting, just assume there's at least one clustered and one-nonclustered.
		// It doesn't matter if we're incorrect -- CopyClusteredIndex() and CopyTableIndexes()
		// will handle it.
		cIndexes = 2;
	else
		{
		// This function only consults in-memory structures to determine the
		// number of indexes (ie. it runs through the table's pfcbNextIndex list).
		// Thus, it should always succeed, even for fGlobalRepair.
		CallJ( (*pvtcd->pErrCDGetTableIndexInfo)(
			pvtcd->sesid,
			tableidSrc,
			NULL,
			&cIndexes,
			sizeof(cIndexes),
			JET_IdxInfoCount ), CloseIt3 );
		}

	Assert( cIndexes >= 0 );

	CallJ( ErrCMPCopyClusteredIndex(
		pcompactinfo,
		tableidDest,
		szObjectName,
		&indexList,
		&fHasClustered ), CloseIt4 );
	Assert( !fHasClustered  ||  cIndexes > 0 );

	if ( pstatus )
		{
		Assert( pstatus->pfnStatus );
		Assert( pstatus->snt == JET_sntProgress );

		pstatus->szTableName = (char *)szObjectName;
		pstatus->cTableFixedVarColumns = pcompactinfo->ccolSingleValue;
		pstatus->cTableTaggedColumns = columnList.cRecord - pcompactinfo->ccolSingleValue;
		pstatus->cTableInitialPages = rgulAllocInfo[0];
		pstatus->cNCIndexes = 0;

		if ( !pcompactinfo->pconvert )
			{
			ULONG	rgcpgExtent[2];		// OwnExt and AvailExt
			ULONG	cpgUsed;

			// Can't do page-based progress meter during convert.
			fPageBasedProgress = fTrue;

			err = (*pvtcd->pErrCDGetTableInfo)(
				pvtcd->sesid,
				tableidSrc,
				rgcpgExtent,
				sizeof(rgcpgExtent),
				JET_TblInfoSpaceUsage );
			if ( err < 0 )
				{
				if ( fGlobalRepair )
					{
					//	if failure in space query then default to
					//	one page owned and no pages available.
					fCorruption = fTrue;
					rgcpgExtent[0] = 1;
					rgcpgExtent[1] = 0;
					}
				else
					{
					goto CloseIt4;
					}
				}

			// AvailExt always less than OwnExt.
			Assert( rgcpgExtent[1] < rgcpgExtent[0] );

			// cpgProjected is the projected total pages completed once
			// this table has been copied.
			cpgProjected = pstatus->cunitDone + rgcpgExtent[0];
			if ( cpgProjected > pstatus->cunitTotal )
				{
				Assert( fGlobalRepair );
				fCorruption = fTrue;
				cpgProjected = pstatus->cunitTotal;
				}

			cpgUsed = rgcpgExtent[0] - rgcpgExtent[1];
			Assert( cpgUsed > 0 );

			pstatus->cbRawData = 0;
			pstatus->cbRawDataLV = 0;
			pstatus->cLeafPagesTraversed = 0;
			pstatus->cLVPagesTraversed = 0;

			// If corrupt, suppress progression of meter.
			pstatus->cunitPerProgression =
				( fCorruption ? 0 : 1 + ( rgcpgExtent[1] / cpgUsed ) );
			pstatus->cTablePagesOwned = rgcpgExtent[0];
			pstatus->cTablePagesAvail = rgcpgExtent[1];
			}

		if ( pstatus->fDumpStats )
			{
			Assert( pstatus->hfCompactStats );
			CMPGetTime( pstatus->timerInitTable, &iSec, &iMSec );
			fprintf( pstatus->hfCompactStats, "%d\t%d\t",
				pstatus->cTableFixedVarColumns,
				pstatus->cTableTaggedColumns );
			if ( !pcompactinfo->pconvert )
				{
				fprintf( pstatus->hfCompactStats,
					"%d\t%d\t",
					pstatus->cTablePagesOwned,
					pstatus->cTablePagesAvail );
				}
			fprintf( pstatus->hfCompactStats,
				"%d.%d\t",
				iSec, iMSec );
			fflush( pstatus->hfCompactStats );
			CMPSetTime( &pstatus->timerCopyRecords );
			}
		}

	/*	copy the data in the table
	/**/
	err = (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidSrc, JET_MoveFirst, 0 );
	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto DoneCopyRecords;

	if ( pcompactinfo->pconvert )
		{
		COLUMNIDINFO	*pcolinfo, *pcolinfoMax;

		while ( err >= 0 )
			{
			CallJ( ErrDispPrepareUpdate(
				pcompactinfo->sesid,
				tableidDest,
				JET_prepInsert ), DoneCopyRecords );

			pcolinfo = pcompactinfo->rgcolumnids;
			pcolinfoMax = pcolinfo + pcompactinfo->ccolSingleValue;
			for ( ; pcolinfo < pcolinfoMax; pcolinfo++ )
				{
				CallJ( ErrCMPCopyColumnData(
					pcompactinfo->sesid,
					tableidSrc,
					tableidDest,
					pcolinfo->columnidSrc,
					pcolinfo->columnidDest,
					pcompactinfo->rgbBuf,
					pvtcd ), DoneCopyRecords );
				}

			// Copy tagged columns, if any.
			if ( mpcolumnidcolumnidTagged != NULL )
				{
				CallJ( ErrCMPCopyTaggedColumns(
					pcompactinfo,
					tableidSrc,
					tableidDest,
					mpcolumnidcolumnidTagged ), DoneCopyRecords );
				}

			CallJ( ErrDispUpdate(
				pcompactinfo->sesid,
				tableidDest,
				NULL, 0, NULL ), DoneCopyRecords );

			crowCopied++;
				
			err = (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidSrc, JET_MoveNext, 0 );
			}
		}

	else
		{
		err = ErrIsamCopyRecords(
			pcompactinfo->sesid,
			tableidSrc,
			tableidDest,
			(CPCOL *)pcompactinfo->rgcolumnids,
			pcompactinfo->ccolSingleValue,
			0,
			&crowCopied,
			&recidLast,
			mpcolumnidcolumnidTagged,
			pstatus );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

DoneCopyRecords:

	if ( fHasClustered )
		cIndexes--;		// Clustered already copied.


	if ( pstatus  &&  pstatus->fDumpStats )
		{
		Assert( pstatus->hfCompactStats );
		CMPGetTime( pstatus->timerCopyRecords, &iSec, &iMSec );
		fprintf( pstatus->hfCompactStats, "%d\t", crowCopied );
		if ( !pcompactinfo->pconvert )
			{
			fprintf( pstatus->hfCompactStats, "%d\t%d\t%d\t%d\t",
				pstatus->cbRawData,
				pstatus->cbRawDataLV,
				pstatus->cLeafPagesTraversed,
				pstatus->cLVPagesTraversed );
			}
		fprintf( pstatus->hfCompactStats, "%d.%d\t", iSec, iMSec );
		fflush( pstatus->hfCompactStats );
		CMPSetTime( &pstatus->timerRebuildIndexes );
		}

	// If no error, do indexes.
	// If an error, but we're repairing, do indexes.
	if ( cIndexes > 0  &&  ( err >= 0  ||  fGlobalRepair ) )
		{
		ULONG	cpgPerIndex = 0;

		Assert( !fCorruption || fGlobalRepair );
		if ( fPageBasedProgress  &&  !fCorruption )
			{
			ULONG	cpgRemaining;

			Assert( pstatus != NULL );

			Assert( pstatus->cunitDone <= cpgProjected );
			cpgRemaining = cpgProjected - pstatus->cunitDone;

			cpgPerIndex = cpgRemaining / cIndexes;
			Assert( cpgPerIndex * cIndexes <= cpgRemaining );
			}

		errT = ErrCMPCopyTableIndexes(
			pcompactinfo,
			tableidDest,
			szObjectName,
			&indexList,
			cpgPerIndex );
		if ( err >= 0 )
			err = errT;
		}

	if ( pstatus )
		{
		if ( pstatus->fDumpStats )
			{
			Assert( pstatus->hfCompactStats );
			CMPGetTime( pstatus->timerRebuildIndexes, &iSec, &iMSec );
			fprintf( pstatus->hfCompactStats, "%d\t%d.%d\t",
				pstatus->cNCIndexes, iSec, iMSec );
			fflush( pstatus->hfCompactStats );
			}

		if ( fPageBasedProgress  &&  ( err >= 0  ||  fGlobalRepair ) )
			{
			Assert( pstatus != NULL );

			// Top off progress meter for this table.
			Assert( pstatus->cunitDone <= cpgProjected );
			pstatus->cunitDone = cpgProjected;
			errT = ErrCMPReportProgress( pstatus );
			if ( err >= 0 )
				err = errT;
			}
		}

CloseIt4:
	errT = (*pvtcd->pErrCDCloseTable)( pvtcd->sesid, indexList.tableid );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

CloseIt3:
	Assert( tableidDest == tablecreate.tableid );
	errT = ErrDispCloseTable( pcompactinfo->sesid, tableidDest );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

CloseIt2:
	if ( mpcolumnidcolumnidTagged != NULL )
		{
		SFree( mpcolumnidcolumnidTagged );
		}

CloseIt1:
	errT = (*pvtcd->pErrCDCloseTable)( pvtcd->sesid, tableidSrc );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

	if ( pstatus  &&  pstatus->fDumpStats )
		{
		Assert( pstatus->hfCompactStats );
		CMPGetTime( pstatus->timerCopyTable, &iSec, &iMSec );
		fprintf( pstatus->hfCompactStats, "%d.%d\n", iSec, iMSec );
		fflush( pstatus->hfCompactStats );
		}

	return( err );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCMPCopyObjects                                                                                               *
*                                                                                                                                                       *
*       Arguments: pcompactinfo         - Compact information segment                           *
*                          szContainerName      - Container name in which the object exists *
*                          szObjectName         - object name to copy                                           *
*                          objtyp                       - object type                                                           *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure copies the exta info columns in the MSysObjects table                 *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyObject(
	COMPACTINFO	*pcompactinfo,
	const CHAR	*szObjectName,
	JET_OBJTYP	objtyp )
	{
	ERR	err = JET_errSuccess;

	switch ( objtyp )
		{
		case JET_objtypDb:
			/* Present after CreateDatabase */
			Assert( strcmp( szObjectName, szDbObject ) == 0 );
			break;

		case JET_objtypContainer:
			/* CreateDatabase already created Db/Table containers. */
			/* Pre-500 series DB's may also have a"Relationships" container. */
			Assert( strcmp( szObjectName, szDcObject ) == 0  ||
				strcmp( szObjectName, szTcObject ) == 0  ||
				( pcompactinfo->pconvert  &&  strcmp( szObjectName, "Relationships" ) == 0 ) );
			break;

		case JET_objtypTable:
				/*	CreateDatabase already created system tables.
				/**/
			if ( !FCATSystemTable( szObjectName ) )
				{
				err = ErrCMPCopyTable( pcompactinfo, szObjectName );
				if ( err < 0  &&  fGlobalRepair )
					{
					err = JET_errSuccess;
					UtilReportEvent( EVENTLOG_WARNING_TYPE, REPAIR_CATEGORY, REPAIR_BAD_TABLE, 1, &szObjectName );
					}
				}
			break;

		default :
			/* Don't know how to handle this.  Skip it. */
			Assert( 0 );
			err = ErrERRCheck( JET_errInvalidObject );
		break;
		}

	return( err );
	}



/*---------------------------------------------------------------------------
*
*       Procedure: ErrCMPCopyObjects
*
*       Arguments: pcompactinfo - Compact information segment
*
*       Returns : JET_ERR
*
*       Procedure copies the objects from the source
*       database to the destination databse.  It then copies the extra
*       information in the msysobjects table ( eg Description ) and copies the
*       security rights for all the objects in the database to which it has
*       access.
*       If fCopyContainers is fTrue, copy only container info into destination
*       If fCopyContainers is fFalse, copy only non-container info.
*       NOTE: progress callbacks are currently set up to work such that the
*       NOTE: first call to ErrCMPCopyObjects must be with fCopyContainers set FALSE.
*
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCopyObjects( COMPACTINFO *pcompactinfo )
	{
	JET_TABLEID		tableidMSO;
	JET_COLUMNID	columnidObjtyp;
	JET_COLUMNID	columnidObjectName;
	ERR				err;
	ERR				errT;
	ULONG			cbActual;
	CHAR			szObjectName[JET_cbNameMost+1];
	VTCD			*pvtcd = &pcompactinfo->vtcd;

	if ( pcompactinfo->pconvert )
		{
		JET_OBJECTLIST	objectlist;
		JET_OBJTYP		objtyp;			// When converting, need JET_OBJTYP

		/* Get the list of all objects in the source database */
		objectlist.tableid = 0;
		CallR( (*pvtcd->pErrCDGetObjectInfo)(
			pvtcd->sesid,
			(JET_VDBID)pcompactinfo->dbidSrc,
			JET_objtypNil,
			NULL,
			NULL,
			&objectlist,
			sizeof( objectlist ),
			JET_ObjInfoListNoStats ) );

		tableidMSO = objectlist.tableid;

		if ( pcompactinfo->pstatus )
			{
			pcompactinfo->pstatus->cunitDone = 0;
			pcompactinfo->pstatus->cunitTotal = objectlist.cRecord;
			pcompactinfo->pstatus->cunitPerProgression = 1;
			}

		columnidObjtyp = objectlist.columnidobjtyp;
		columnidObjectName = objectlist.columnidobjectname;

		Call( (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidMSO, JET_MoveFirst, 0 ) );

		do
			{
			/* Get the object's type and name */
			Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, tableidMSO,
				columnidObjtyp, &objtyp, sizeof(objtyp), &cbActual, 0, NULL ) );
			Assert( cbActual == sizeof(JET_OBJTYP) );

			Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, tableidMSO,
					columnidObjectName, szObjectName, JET_cbNameMost,
					&cbActual, 0, NULL ) );
			szObjectName[cbActual] = '\0';

			Call( ErrCMPCopyObject( pcompactinfo, szObjectName, objtyp ) );

			if ( pcompactinfo->pstatus )
				{
				Assert( pcompactinfo->pstatus->snt == JET_sntProgress );
				Assert( pcompactinfo->pstatus->cunitPerProgression == 1 );
				pcompactinfo->pstatus->cunitDone += 1;
				Call( ErrCMPReportProgress( pcompactinfo->pstatus ) );
				}
			}
		while ( ( err = (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidMSO, JET_MoveNext, 0 ) ) >= 0 );
		}

	else
		{
		JET_COLUMNDEF	columndef;
		OBJTYP			objtyp;			// When compacting, need OBJTYP

		CallR( (*pvtcd->pErrCDOpenTable)(
			pvtcd->sesid,
			(JET_VDBID)pcompactinfo->dbidSrc,
			szSoTable,
			NULL,
			0,
			0,
			&tableidMSO ) );

		Call( (*pvtcd->pErrCDGetTableColumnInfo)(
			pvtcd->sesid,
			tableidMSO,
			szSoObjectTypeColumn,
			&columndef,
			sizeof(columndef),
			JET_ColInfo ) );
		columnidObjtyp = columndef.columnid;

		Call( (*pvtcd->pErrCDGetTableColumnInfo)(
			pvtcd->sesid,
			tableidMSO,
			szSoObjectNameColumn,
			&columndef,
			sizeof(columndef),
			JET_ColInfo ) );
		columnidObjectName = columndef.columnid;

		Call( (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidMSO, JET_MoveFirst, 0 ) );

		do
			{
			/* Get the object's type and name */
			Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, tableidMSO,
				columnidObjtyp, &objtyp, sizeof(objtyp), &cbActual, 0, NULL ) );
			Assert( cbActual == sizeof(OBJTYP) );

			Call( (*pvtcd->pErrCDRetrieveColumn)( pvtcd->sesid, tableidMSO,
					columnidObjectName, szObjectName, JET_cbNameMost,
					&cbActual, 0, NULL ) );
			szObjectName[cbActual] = '\0';

			Call( ErrCMPCopyObject( pcompactinfo, szObjectName, (JET_OBJTYP)objtyp ) );
			}
		while ( ( err = (*pvtcd->pErrCDMove)( pvtcd->sesid, tableidMSO, JET_MoveNext, 0 ) ) >= 0 );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

HandleError:
	// Return result of CloseTable only if no other errors occurred.
	errT = (*pvtcd->pErrCDCloseTable)( pvtcd->sesid, tableidMSO );
	if ( err == JET_errSuccess )
		err = errT;

	return( err );
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: ErrCleanup                                                                                                   *
*                                                                                                                                                       *
*       Arguments: pcompactinfo - Compact information segment                                   *
*                                                                                                                                                       *
*       Returns : JET_ERR                                                                                                               *
*                                                                                                                                                       *
*       Procedure closes the databases                                                                                  *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

INLINE LOCAL ERR ErrCMPCloseDB( COMPACTINFO *pcompactinfo )
	{
	ERR		err;
	ERR		errT;
	VTCD	*pvtcd = &pcompactinfo->vtcd;

	err = (*pvtcd->pErrCDCloseDatabase)( pvtcd->sesid, (JET_VDBID)pcompactinfo->dbidSrc, 0 );
	errT = ErrIsamCloseDatabase( pcompactinfo->sesid, (JET_VDBID)pcompactinfo->dbidDest, 0 );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

	return err;
	}


/*---------------------------------------------------------------------------
*                                                                                                                                                       *
*       Procedure: JetCompact                                                                                                   *
*                                                                                                                                                       *
*       Returns:   JET_ERR returned by JetCompact or by other Jet API.                  *
*                                                                                                                                                       *
*       The procedure copies the source database into the destination database  *
*       so that it will take up less disk space storage.                                                *
*                                                                                                                                                       *
---------------------------------------------------------------------------*/

ERR ISAMAPI ErrIsamCompact(
	JET_SESID		sesid,
	const CHAR		*szDatabaseSrc,
	const CHAR		*szDatabaseDest,
	JET_PFNSTATUS	pfnStatus,
	JET_CONVERT		*pconvert,
	JET_GRBIT		grbit )
	{
	ERR				err = JET_errSuccess;
	ERR				errT;
	ULONG_PTR		grbitSave;
	COMPACTINFO		compactinfo;
	
	if ( pconvert )
		{
		// For convert, must specify old DLL.
		if ( pconvert->szOldDll )
			pconvert->fDbAttached = fFalse;
		else
			return ErrERRCheck( JET_errInvalidParameter );
		}

	CallR( ErrGetSystemParameter( sesid, JET_paramSessionInfo, &grbitSave, NULL, 0 ) );
	CallR( ErrSetSystemParameter( sesid, JET_paramSessionInfo,
		JET_bitAggregateTransaction | JET_bitCIMDirty, NULL ) );

	compactinfo.sesid = sesid;
	compactinfo.pconvert = pconvert;

	if ( pfnStatus )
		{
		compactinfo.pstatus = (STATUSINFO *)SAlloc( sizeof(STATUSINFO) );
		if ( compactinfo.pstatus == NULL )
			return ErrERRCheck( JET_errOutOfMemory );

		memset( compactinfo.pstatus, 0, sizeof(STATUSINFO) );

		compactinfo.pstatus->sesid = sesid;
		compactinfo.pstatus->pfnStatus = pfnStatus;
		
		if ( pconvert )
			compactinfo.pstatus->snp = JET_snpUpgrade;
		else if ( fGlobalRepair )
			compactinfo.pstatus->snp = JET_snpRepair;
		else
			compactinfo.pstatus->snp = JET_snpCompact;
			
		compactinfo.pstatus->snt = JET_sntBegin;
		CallR( ErrCMPReportProgress( compactinfo.pstatus ) );

		compactinfo.pstatus->snt = JET_sntProgress;

		compactinfo.pstatus->fDumpStats = ( grbit & JET_bitCompactStats );
		if ( compactinfo.pstatus->fDumpStats )
			{
			compactinfo.pstatus->hfCompactStats =
				fopen( pconvert ? szConvertStatsFile : szCompactStatsFile, "a" );
			if ( compactinfo.pstatus->hfCompactStats )
				{
				fprintf( compactinfo.pstatus->hfCompactStats,
					"\n\n***** %s of database '%s' started!\n",
					szCMPAction( pconvert ),
					szDatabaseSrc );
				fflush( compactinfo.pstatus->hfCompactStats );
				CMPSetTime( &compactinfo.pstatus->timerCopyDB );
				CMPSetTime( &compactinfo.pstatus->timerInitDB );
				}
			else
				{
				return ErrERRCheck( JET_errFileAccessDenied );
				}
			}
		}

	else
		{
		compactinfo.pstatus = NULL;
		}

	if ( pconvert )
		{
		memset( (BYTE *)&compactinfo.vtcd, 0, sizeof( VTCD ) );
		CallJ( ErrCMPConvertInit( &compactinfo.vtcd, pconvert, szDatabaseSrc ), AfterCloseDB );
		}
	else
		{
		VTCD	*pvtcd = &compactinfo.vtcd;

		// Items marked NULL means the function should not be called
		// during a regular compact.

		pvtcd->sesid = sesid;
		pvtcd->pErrCDInit = NULL;
		pvtcd->pErrCDTerm = NULL;
		pvtcd->pErrCDBeginSession = NULL;
		pvtcd->pErrCDEndSession = NULL;
		pvtcd->pErrCDAttachDatabase = ErrCDAttachDatabase;
		pvtcd->pErrCDDetachDatabase = ErrCDDetachDatabase;
		pvtcd->pErrCDOpenDatabase = ErrCDOpenDatabase;
		pvtcd->pErrCDCloseDatabase = ErrCDCloseDatabase;
		pvtcd->pErrCDOpenTable = ErrCDOpenTable;
		pvtcd->pErrCDCloseTable = ErrCDCloseTable;
		pvtcd->pErrCDRetrieveColumn= ErrCDRetrieveColumn;					
		pvtcd->pErrCDMove = ErrCDMove;
		pvtcd->pErrCDSetSystemParameter = NULL;
		pvtcd->pErrCDGetObjectInfo = ErrCDGetObjectInfo;	
		pvtcd->pErrCDGetDatabaseInfo = ErrCDGetDatabaseInfo;
		pvtcd->pErrCDGetTableInfo = ErrCDGetTableInfo;
		pvtcd->pErrCDGetTableColumnInfo = ErrCDGetTableColumnInfo;
		pvtcd->pErrCDGetTableIndexInfo = ErrCDGetTableIndexInfo;
		pvtcd->pErrCDGetIndexInfo = ErrCDGetIndexInfo;
		}

	/* Open and create the databases */

	CallJ( ErrCMPCompactInit( &compactinfo, szDatabaseSrc, szDatabaseDest ),
		AfterCloseDB );

	if ( pfnStatus != NULL )
		{
		Assert( compactinfo.pstatus );

		if ( !pconvert )
			{
			/* Init status meter.  We'll be tracking status by pages processed, */
			err = (*compactinfo.vtcd.pErrCDGetDatabaseInfo)(
				compactinfo.vtcd.sesid,
				compactinfo.dbidSrc,
				&compactinfo.pstatus->cDBPagesOwned,
				sizeof(compactinfo.pstatus->cDBPagesOwned),
				JET_DbInfoSpaceOwned );
			if ( err < 0 )
				{
				if ( fGlobalRepair )
					{
					// Set to default value.
					compactinfo.pstatus->cDBPagesOwned = cpgDatabaseMin;
					}
				else
					{
					goto HandleError;
					}
				}
			err = (*(compactinfo.vtcd.pErrCDGetDatabaseInfo))(
				compactinfo.vtcd.sesid,
				compactinfo.dbidSrc,
				&compactinfo.pstatus->cDBPagesAvail,
				sizeof(compactinfo.pstatus->cDBPagesAvail),
				JET_DbInfoSpaceAvailable );
			if ( err < 0 )
				{
				if ( fGlobalRepair )
					{
					// Set to default value.
					compactinfo.pstatus->cDBPagesAvail = 0;
					}
				else
					goto HandleError;
				}

			// Don't count unused space in the database;
			Assert( compactinfo.pstatus->cDBPagesOwned >= cpgDatabaseMin );
			Assert( compactinfo.pstatus->cDBPagesAvail < compactinfo.pstatus->cDBPagesOwned );
			compactinfo.pstatus->cunitTotal =
				compactinfo.pstatus->cDBPagesOwned - compactinfo.pstatus->cDBPagesAvail;

			// Approximate the number of pages used by MSysObjects, MSysColumns, and MSysIndexes.
			compactinfo.pstatus->cunitDone = 1 + 4 + 1;
			Assert( compactinfo.pstatus->cunitDone <= compactinfo.pstatus->cunitTotal );

			Call( ErrCMPReportProgress( compactinfo.pstatus ) );
			}

		if ( compactinfo.pstatus->fDumpStats )
			{
			INT iSec, iMSec;

			Assert( compactinfo.pstatus->hfCompactStats );
			CMPGetTime( compactinfo.pstatus->timerInitDB, &iSec, &iMSec );
			fprintf( compactinfo.pstatus->hfCompactStats,
				"\nNew database created and initialized in %d.%d seconds.\n",
				iSec, iMSec );
			if ( pconvert )
				{
				fprintf( compactinfo.pstatus->hfCompactStats,
					"\n\n%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n\n",
					szCMPSTATSTableName, szCMPSTATSFixedVarCols, szCMPSTATSTaggedCols,
					szCMPSTATSInitTime, szCMPSTATSRecordsCopied, szCMPSTATSRecordsTime,
					szCMPSTATSNCIndexes, szCMPSTATSIndexesTime, szCMPSTATSTableTime );
				}
			else				
				{
				fprintf( compactinfo.pstatus->hfCompactStats,
					"    (Source database owns %d pages, of which %d are available.)\n",
					compactinfo.pstatus->cDBPagesOwned,
					compactinfo.pstatus->cDBPagesAvail );
				fprintf( compactinfo.pstatus->hfCompactStats,
					"\n\n%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n\n",
					szCMPSTATSTableName, szCMPSTATSFixedVarCols, szCMPSTATSTaggedCols,
					szCMPSTATSPagesOwned, szCMPSTATSPagesAvail, szCMPSTATSInitTime,
					szCMPSTATSRecordsCopied, szCMPSTATSRawData, szCMPSTATSRawDataLV,
					szCMPSTATSLeafPages, szCMPSTATSMinLVPages,
					szCMPSTATSRecordsTime, szCMPSTATSNCIndexes, szCMPSTATSIndexesTime,
					szCMPSTATSTableTime );
				}
			fflush( compactinfo.pstatus->hfCompactStats );
			}
		}

	/* Create and copy all non-container objects */

	Call( ErrCMPCopyObjects( &compactinfo ) );

	Assert( !pfnStatus
		|| ( compactinfo.pstatus && compactinfo.pstatus->cunitDone <= compactinfo.pstatus->cunitTotal ) );

HandleError:
	errT = ErrCMPCloseDB( &compactinfo );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;

AfterCloseDB:
	if ( pconvert )
		{
		errT = ErrCMPConvertCleanup( &compactinfo.vtcd, pconvert, szDatabaseSrc, err < 0 );
		if ( ( errT < 0 ) && ( err >= 0 ) )
			err = errT;
		}

	/* reset session info */
	
	errT = ErrSetSystemParameter( sesid, JET_paramSessionInfo, grbitSave, NULL );
	if ( ( errT < 0 ) && ( err >= 0 ) )
		err = errT;
						
	if ( pfnStatus != NULL )		// Top off status meter.
		{
		Assert( compactinfo.pstatus );

		compactinfo.pstatus->snt = ( err < 0 ? JET_sntFail : JET_sntComplete );
		errT = ErrCMPReportProgress( compactinfo.pstatus );
		if ( ( errT < 0 ) && ( err >= 0 ) )
			err = errT;

		if ( compactinfo.pstatus->fDumpStats )
			{
			INT iSec, iMSec;
			
			Assert( compactinfo.pstatus->hfCompactStats );
			CMPGetTime( compactinfo.pstatus->timerCopyDB, &iSec, &iMSec );
			fprintf( compactinfo.pstatus->hfCompactStats, "\n\n***** %s completed in %d.%d seconds.\n\n",
				szCMPAction( pconvert ), iSec, iMSec );
			fflush( compactinfo.pstatus->hfCompactStats );
			fclose( compactinfo.pstatus->hfCompactStats );
			}

		SFree( compactinfo.pstatus );
		}

	/*      detach compacted database */
	(VOID)ErrIsamDetachDatabase( sesid, szDatabaseDest );

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\daestd.c ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1992 Microsoft Corporation.
*
* Component:
*
* File: Dummy file for building DAE PCH
*
* File Comments:
* <comments>
*
* Revision History:
*
*    [0]  27-Jul-94  t-andyg	Created
*
***********************************************************************/

#include "daestd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\db.c ===
#include "daestd.h"

DeclAssertFile; 				/* Declare file name for Assert macros */

DAB		*pdabGlobalMin = 0;
DAB		*pdabGlobalMax = 0;

extern CRIT  critBMClean;

BOOL	fUpdatingDBRoot = fFalse;

LOCAL ERR ErrDBInitDatabase( PIB *ppib, DBID dbid, CPG cpg );
#ifdef DAYTONA
LOCAL ERR ErrDBICheck200( CHAR *szDatabaseName );
LOCAL ERR ErrDBICheck400( CHAR *szDatabaseName );
#endif

//+local
//	ErrDBInitDatabase
//	========================================================================
//	ErrDBInitDatabase( PIB *ppib, DBID dbid, CPG cpgPrimary )
//
//	Initializes database structure.  Structure is customized for
//	system, temporary and user databases which are identified by
//	the dbid.  Primary extent is set to cpgPrimary but no allocation
//	is performed.  The effect of this routine can be entirely
//	represented with page operations.
//
//	PARAMETERS	ppib			ppib of database creator
//					dbid			dbid of created database
//					cpgPrimary 	number of pages to show in primary extent
//
//	RETURNS		JET_errSuccess or error returned from called routine.
//-
LOCAL ERR ErrDBInitDatabase( PIB *ppib, DBID dbid, CPG cpgPrimary )
	{
	ERR				err;
	LINE 		 	line;
	KEY 		 	key;
	FUCB 		 	*pfucb = pfucbNil;
	BYTE			rgbKey[sizeof(PGNO)];
	PGNO			pgnoT;

	/*	set up the root page
	/**/
	CallR( ErrDIRBeginTransaction( ppib ) );

	/*	open cursor on database domain.
	/**/
	Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );

	/*	set system root node ( pgno, itag )=( 1, 0 ) as empty FDP node
	/**/
	Call( ErrNDNewPage( pfucb, pgnoSystemRoot, pgnoSystemRoot, pgtypFDP, fTrue ) );
	DIRGotoFDPRoot( pfucb );

	/*	make the OWNEXT node
	/**/
	line.cb = sizeof(PGNO);
	line.pb = (BYTE *)&cpgPrimary;
	Call( ErrDIRInsert( pfucb, &line, pkeyOwnExt, fDIRNoVersion | fDIRBackToFather ) );

	/*	make the AVAILEXT node
	/**/
	Assert( line.cb == sizeof(PGNO) );
	pgnoT = pgnoNull;
	line.pb = (BYTE *)&pgnoT;
	Call( ErrDIRInsert( pfucb, &line, pkeyAvailExt, fDIRNoVersion | fDIRBackToFather ) );

	/*	setup OwnExt tree
	/**/
	KeyFromLong( rgbKey, cpgPrimary );
	key.cb = sizeof(PGNO);
	key.pb = (BYTE *)rgbKey;
	line.cb = sizeof(PGNO);
	line.pb = (BYTE *)&cpgPrimary;
	DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
	Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRBackToFather ) );

	/*	setup AvailExt tree if there are any pages left
	/**/
	if ( --cpgPrimary > 0 )
		{
		DIRGotoAVAILEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
		Assert( line.cb == sizeof(PGNO) );
		line.pb = (BYTE *)&cpgPrimary;
		/*	rgbKey should still contain last page key
		/**/
		Assert( key.cb == sizeof(PGNO) );
		Assert( key.pb == (BYTE *)rgbKey );
		Call( ErrDIRInsert( pfucb, &line, &key, fDIRNoVersion | fDIRBackToFather ) );
		}

	/*	goto FDP root and add pkeyTables son node
	/**/
	DIRGotoFDPRoot( pfucb );

	/*	close cursor and commit operations
	/**/
	DIRClose( pfucb );
	pfucb = pfucbNil;
	Call( ErrDIRCommitTransaction( ppib, 0 ) );
	return err;

HandleError:
	if ( pfucb != pfucbNil )
		{
		DIRClose( pfucb );
		}
	CallS( ErrDIRRollback( ppib ) );
	
	return err;
	}


//to prevent read ahead over-preread, we may want to keep track of last
//page of the database.

ERR ErrDBSetLastPage( PIB *ppib, DBID dbid )
	{
	ERR		err;
	DIB		dib;
	FUCB	*pfucb;
	PGNO	pgno;
	DBID	dbidT;

	ppib->fSetAttachDB = fTrue;
	CallJ( ErrDBOpenDatabase( ppib, rgfmp[dbid].szDatabaseName, &dbidT, 0 ), Retn);
	Assert( dbidT == dbid );

	CallJ( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ), CloseDB );
	DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
	dib.fFlags = fDIRNull;
	dib.pos = posLast;
	CallJ( ErrDIRDown( pfucb, &dib ), CloseFucb );
	Assert( pfucb->keyNode.cb == sizeof(PGNO) );
	LongFromKey( &pgno, pfucb->keyNode.pb );
	rgfmp[dbid].ulFileSizeLow = pgno << 12;
	rgfmp[dbid].ulFileSizeHigh = pgno >> 20;

CloseFucb:
	DIRClose( pfucb );
CloseDB:
	CallS( ErrDBCloseDatabase( ppib, dbid, 0 ) );
Retn:
	ppib->fSetAttachDB = fFalse;
	return err;
	}


ERR ErrDBISetupAttachedDB( DBID dbid, CHAR *szName )
	{
	ERR	err;
	FMP *pfmp = &rgfmp[dbid];
	DBFILEHDR *pdbfilehdr;
	PIB *ppib;

	/*	attach the database that was attached
	/**/
	err = ErrDBReadHeaderCheckConsistency( szName, dbid );
#ifdef DAYTONA
	if ( err == JET_errDatabaseCorrupted )
		{
		if ( ErrDBICheck400( szName ) == JET_errSuccess )
			err = ErrERRCheck( JET_errDatabase400Format );
		else if ( ErrDBICheck200( szName ) == JET_errSuccess )
			err = ErrERRCheck( JET_errDatabase200Format );
		}
#endif
	CallR( err );

	pdbfilehdr = pfmp->pdbfilehdr;
	Assert( pdbfilehdr );
	if ( memcmp( &pdbfilehdr->signLog, &signLogGlobal, sizeof(SIGNATURE) ) != 0 )
		{
		UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY, LOG_DATABASE_MISMATCH_ERROR_ID, 1, &szName );
		return JET_errBadLogSignature;
		}

	if ( !rgfmp[dbid].fReadOnly )
		{
		pdbfilehdr->fDBState = fDBStateInconsistent;
		CallR( ErrUtilWriteShadowedHeader( szName, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) ) );
		}
	DBIDSetAttached( dbid );
	CallR( ErrUtilOpenFile( szName, &pfmp->hf, 0, fFalse, fTrue ));
				
	CallR( ErrPIBBeginSession( &ppib, procidNil ) );
	err = ErrDBSetLastPage( ppib, dbid );
	PIBEndSession( ppib );

	return err;
	}


ERR ErrDBSetupAttachedDB(VOID)
	{
	ERR err;
	DBID dbid;
	
	/*	Same as attach database.
	 */
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		FMP *pfmp = &rgfmp[dbid];
		CHAR *szName;

		if ( pfmp->pdbfilehdr )
			{
			/*	must have been checked before. First LGInitSession during redo.
			 */
			Assert( fRecovering );
			continue;
			}

		/*	only attach the attached database.
		 */
		szName = pfmp->szDatabaseName;
		if ( !szName )
			continue;

		if ( fRecovering && fHardRestore )
			{
			/*	Only set the db that has been patched.
			 */
			INT irstmap = IrstmapLGGetRstMapEntry( pfmp->szDatabaseName );

			if ( irstmap < 0 )
				{
				DBIDSetAttachNullDb( dbid );
				DBIDSetAttached( dbid );
				continue;
				}
			else if ( !rgrstmapGlobal[irstmap].fPatched )
				{
				/*	wait for redoing attachdb to attach this db.
				 */
				continue;
				}
			else
				szName = rgrstmapGlobal[irstmap].szNewDatabaseName;
			}

		/*	if file does not exists, then set as attachment non-existing db.
		 */
		if ( !FIOFileExists( szName ) )
			{
			DBIDSetAttachNullDb( dbid );
			DBIDSetAttached( dbid );
			continue;
			}
	
		err = ErrDBISetupAttachedDB( dbid, szName );

		CallR( err );
		}
	return JET_errSuccess;
	}


LOCAL ERR ErrDABAlloc( PIB *ppib, VDBID *pvdbid, DBID dbid, JET_GRBIT grbit )
	{
	VDBID vdbid = (VDBID)VdbidMEMAlloc();

	if ( vdbid == NULL )
		return ErrERRCheck( JET_errTooManyOpenDatabases );
	vdbid->dbid = dbid;
	vdbid->ppib = ppib;

	/*	set the mode of db open
	/**/
	if ( FDBIDReadOnly( dbid ) )
		vdbid->grbit = JET_bitDbReadOnly;
	else
		vdbid->grbit = grbit;

	/*	insert DAB/VDBID into ppib dabList
	/**/
	vdbid->pdabNext = ppib->pdabList;
	ppib->pdabList = vdbid;

	*pvdbid = vdbid;
	return JET_errSuccess;
	}


LOCAL ERR ErrDABDealloc( PIB *ppib, VDBID vdbid )
	{
	DAB		**pdabPrev;
	DAB 	*pdab;

	pdab = ppib->pdabList;
	pdabPrev = &ppib->pdabList;

	/*	search through thread DAB list and unlink this DAB
	/**/
	for( ; pdab != pdabNil; pdabPrev = &pdab->pdabNext, pdab = pdab->pdabNext )
		{
		Assert( ppib == pdab->ppib );
		if ( pdab == vdbid )
			{
			*pdabPrev = pdab->pdabNext;
			ReleaseVDbid( vdbid );
			return( JET_errSuccess );
			}
		}

	Assert( fFalse );
	return( JET_errSuccess );
	}


ERR ISAMAPI ErrIsamCreateDatabase(
	JET_VSESID sesid,
	const CHAR *szDatabaseName,
	const CHAR  *szConnect,
	JET_DBID *pjdbid,
	JET_GRBIT grbit )
	{
	ERR		err;
	PIB		*ppib;
	DBID	dbid;
	VDBID	vdbid = vdbidNil;

	/*	check parameters
	/**/
	Assert( sizeof(JET_VSESID) == sizeof(PIB *) );
	ppib = (PIB *)sesid;
	CallR( ErrPIBCheck( ppib ) );

	dbid = 0;
	CallR( ErrDBCreateDatabase( ppib,
		(CHAR *) szDatabaseName,
		(CHAR *) szConnect,
		&dbid,
		cpgDatabaseMin,
		grbit,
		NULL ) );

	Call( ErrDABAlloc( ppib, &vdbid, (DBID) dbid, JET_bitDbExclusive ) );
	Assert( sizeof(vdbid) == sizeof(JET_VDBID) );
#ifdef	DB_DISPATCHING
	Call( ErrAllocateDbid( pjdbid, (JET_VDBID) vdbid, &vdbfndefIsam ) );
#else
	*pjdbid = (JET_DBID)vdbid;
#endif	/* !DB_DISPATCHING */

	return JET_errSuccess;

HandleError:
	if ( vdbid != vdbidNil )
		CallS( ErrDABDealloc( ppib, vdbid ) );
	(VOID)ErrDBCloseDatabase( ppib, dbid, grbit );
	return err;
	}


ERR ErrDBCreateDatabase( PIB *ppib, CHAR *szDatabaseName, CHAR *szConnect, DBID *pdbid, CPG cpgPrimary, ULONG grbit, SIGNATURE *psignDb )
	{
	ERR		err;
	DBID  	dbid = dbidTemp;
	CHAR  	rgbFullName[JET_cbFullNameMost];
	CHAR  	*szFullName;
	CHAR  	*szFileName;
	BOOL	fInBMClean = fFalse;
	BOOL	fDatabaseOpen = fFalse;
	DBFILEHDR *pdbfilehdr = NULL;

	CheckPIB( ppib );
	NotUsed( szConnect );
	Assert( *pdbid >= dbidMin && *pdbid < dbidMax );
	
	if ( ppib->level > 0 )
		return ErrERRCheck( JET_errInTransaction );

	if ( cpgPrimary == 0 )
		cpgPrimary = cpgDatabaseMin;

	if ( cpgPrimary > cpgDatabaseMax )
		return ErrERRCheck( JET_errDatabaseInvalidPages );

	if ( grbit & JET_bitDbVersioningOff )
		{
		if ( !( grbit & JET_bitDbRecoveryOff ) )
			{
			return ErrERRCheck( JET_errCannotDisableVersioning );
			}
		}

	/*	if recovering and dbid is a known one, the lock the dbid first
	/**/
	if ( fRecovering && *pdbid != dbidTemp )
		{
		dbid = *pdbid;

		/*	get corresponding dbid
		/**/
		CallS( ErrIOLockNewDbid( &dbid, rgfmp[dbid].szDatabaseName ) );

		szFullName = rgfmp[dbid].szDatabaseName;
		szFileName = szFullName;
		if ( fRecovering && fHardRestore )
			{
			INT irstmap;

			err = ErrLGGetDestDatabaseName( rgfmp[dbid].szDatabaseName, &irstmap, NULL);
			if ( err == JET_errSuccess && irstmap >= 0 )
				szFileName = rgrstmapGlobal[irstmap].szNewDatabaseName;
			else
				{
				/*	use given name.
				 */
				err = JET_errSuccess;
				}
			}
		}
	else
		{
		if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
			{
			return ErrERRCheck( JET_errDatabaseNotFound );
			}
		szFullName = rgbFullName;
		szFileName = rgbFullName;

		err = ErrIOLockNewDbid( &dbid, szFullName );
		if ( err != JET_errSuccess )
			{
			if ( err == JET_wrnDatabaseAttached )
				err = ErrERRCheck( JET_errDatabaseDuplicate );
			return err;
			}
		}

	/*	check if database file already exists
	/**/
	if ( dbid != dbidTemp && FIOFileExists( szFileName ) )
		{
		IOUnlockDbid( dbid );
		err = ErrERRCheck( JET_errDatabaseDuplicate );
		return err;
		}

	if ( HfFMPOfDbid(dbid) != handleNil )
		{
		IOUnlockDbid( dbid );
		err = ErrERRCheck( JET_errDatabaseDuplicate );
		return err;
		}

	/*	create an empty database with header only
	 */
	pdbfilehdr = (DBFILEHDR * )PvUtilAllocAndCommit( sizeof( DBFILEHDR ) );
	if ( pdbfilehdr == NULL )
		return ErrERRCheck( JET_errOutOfMemory );

	memset( pdbfilehdr, 0, sizeof( DBFILEHDR ) );
	rgfmp[dbid].pdbfilehdr = pdbfilehdr;
	pdbfilehdr->ulMagic = ulDAEMagic;
	pdbfilehdr->ulVersion = ulDAEVersion;
	DBHDRSetDBTime( pdbfilehdr, 0 );
	pdbfilehdr->grbitAttributes = 0;
	if ( fLogDisabled )
		{
		memset( &pdbfilehdr->signLog, 0, sizeof( SIGNATURE ) );
		}
	else
		{
		Assert( fSignLogSetGlobal );
		pdbfilehdr->signLog = signLogGlobal;
		}
	pdbfilehdr->dbid = dbid;
	if ( psignDb == NULL )
		SIGGetSignature( &pdbfilehdr->signDb );
	else
		memcpy( &pdbfilehdr->signDb, psignDb, sizeof( SIGNATURE ) );
	pdbfilehdr->fDBState = fDBStateJustCreated;

	Call( ErrUtilWriteShadowedHeader( szFileName, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) ) );
	rgfmp[ dbid ].pdbfilehdr = pdbfilehdr;

	err = ErrIOOpenDatabase( dbid, szFileName, 0 );
	if ( err >= 0 )
		err = ErrIONewSize( dbid, cpgPrimary + cpageDBReserved );

	if ( err < 0 )
		{
		IOFreeDbid( dbid );
		return err;
		}

	/*	set database non-loggable during create database
	/**/
	DBIDResetLogOn( dbid );
	DBIDSetCreate( dbid );

	/*	enter BMRCE Clean to make sure no OLC during sys tab creation
	/**/
	LgLeaveCriticalSection( critJet );
	LgEnterNestableCriticalSection( critBMClean );
	LgEnterCriticalSection( critJet );
	fInBMClean = fTrue;
	
	/*	not in a transaction, but still need to set lgposRC of the buffers
	/*	used by this function such that when get checkpoint, it will get
	/*	right check point.
	/**/
	if ( !( fLogDisabled || fRecovering ) )
		{
		EnterCriticalSection( critLGBuf );
		GetLgposOfPbEntry( &ppib->lgposStart );
		LeaveCriticalSection( critLGBuf );
		}

	/*	initialize the database file.  Logging of page operations is
	/*	turned off, during creation only.  After creation the database
	/*	is marked loggable and logging is turned on.
	/**/
	SetOpenDatabaseFlag( ppib, dbid );
	fDatabaseOpen = fTrue;

	Call( ErrDBInitDatabase( ppib, dbid, cpgPrimary ) );

	if ( dbid != dbidTemp )
		{
		/*	create system tables
		/**/
		Call( ErrCATCreate( ppib, dbid ) );
		}

	LgLeaveNestableCriticalSection( critBMClean );
	fInBMClean = fFalse;

	/*	flush buffers
	/**/
	Call( ErrBFFlushBuffers( dbid, fBFFlushAll ) );

	Assert( !FDBIDLogOn( dbid ) );

	/*	set database status to loggable
	/**/
	if ( grbit & JET_bitDbRecoveryOff )
		{
		if ( ( grbit & JET_bitDbVersioningOff ) != 0 )
			{
			DBIDSetVersioningOff( dbid );
			}
		}
	else
		{
		Assert( ( grbit & JET_bitDbVersioningOff ) == 0 );

		/*	set database to be loggable
		/**/
		DBIDSetLogOn( dbid );
		}

	if ( !FDBIDLogOn(dbid) )
		{
		goto EndOfLoggingRelated;
		}
	
	Call( ErrLGCreateDB(
		ppib,
		dbid,
		grbit,
		szFullName,
		strlen(szFullName) + 1,
		&rgfmp[dbid].pdbfilehdr->signDb,
		&lgposLogRec ) );

	/*	make sure the log is flushed before we change the state
	 */
	Call( ErrLGWaitForFlush( ppib, &lgposLogRec ) );

	if ( !fRecovering )
		{
		LgLeaveCriticalSection( critJet );
		LGUpdateCheckpointFile( fFalse );
		LgEnterCriticalSection( critJet );
		}

	/*	close the database, update header, open again.
	/**/
	pdbfilehdr->fDBState = fDBStateInconsistent;

	pdbfilehdr->lgposAttach = lgposLogRec;
	LGGetDateTime( &pdbfilehdr->logtimeAttach );

	IOCloseDatabase( dbid );
	Call( ErrUtilWriteShadowedHeader( szFileName, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) ) );
	Call( ErrIOOpenDatabase( dbid, szFullName, 0L ) );

EndOfLoggingRelated:
	*pdbid = dbid;

	IOSetAttached( dbid );
	IOUnlockDbid( dbid );

	/*	update checkpoint file to reflect the attachment changes
	/**/
	if ( !fRecovering && dbid != dbidTemp )
		{
		LgLeaveCriticalSection( critJet );
		LGUpdateCheckpointFile( fTrue );
		LgEnterCriticalSection( critJet );
		}

	/*	set the last page of the database, used to prevent over preread
	/**/
	Call( ErrDBSetLastPage( ppib, dbid ) );

	DBIDResetCreate( dbid );

	return JET_errSuccess;

HandleError:

	DBIDResetCreate( dbid );

	if ( fInBMClean )
		LgLeaveNestableCriticalSection( critBMClean );

	/*	functions may only use the call macro when the system state
	/*	is file exists, file open or closed, database record fWait
	/*	set, database record name valid and user logging status
	/*	valid.
	/**/

	/*	purge bad database
	/**/
	BFPurge( dbid );
	if ( FIODatabaseOpen(dbid) )
		IOCloseDatabase( dbid );
	(VOID)ErrIODeleteDatabase( dbid );

	if ( fDatabaseOpen )	
		{
		ResetOpenDatabaseFlag( ppib, dbid );
		}

	IOFreeDbid( dbid );
	
	if ( rgfmp[ dbid ].pdbfilehdr )
		{
		UtilFree( (VOID *)rgfmp[ dbid ].pdbfilehdr );
		rgfmp[ dbid ].pdbfilehdr = NULL;
		}
	return err;
	}


ERR ErrDBReadHeaderCheckConsistency( CHAR *szFileName, DBID dbid )
	{
	ERR				err = JET_errSuccess;
	DBFILEHDR		*pdbfilehdr;

	/*	bring in the database and check its header
	/**/
	pdbfilehdr = (DBFILEHDR * )PvUtilAllocAndCommit( sizeof( DBFILEHDR ) );
	if ( pdbfilehdr == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	
	err = ErrUtilReadShadowedHeader( szFileName, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) );
	if ( err == JET_errDiskIO )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
#ifdef DAYTONA
		if ( ErrDBICheck400( szFileName ) == JET_errSuccess )
			err = ErrERRCheck( JET_errDatabase400Format );
		else if ( ErrDBICheck200( szFileName ) == JET_errSuccess )
			err = ErrERRCheck( JET_errDatabase200Format );
#endif
		}
	Call( err );

	if ( !fGlobalRepair )
		{
		if ( pdbfilehdr->fDBState != fDBStateConsistent )
			{
			Error( ErrERRCheck( JET_errDatabaseInconsistent ), HandleError );
			}
		}

#define JET_errInvalidDatabaseVersion	JET_errDatabaseCorrupted

	if ( pdbfilehdr->ulVersion != ulDAEVersion &&
		 pdbfilehdr->ulVersion != ulDAEPrevVersion )
		{
		Error( ErrERRCheck( JET_errInvalidDatabaseVersion ), HandleError );
		}

	if ( pdbfilehdr->ulMagic != ulDAEMagic )
		{
		Error( ErrERRCheck( JET_errInvalidDatabaseVersion ), HandleError );
		}

	Assert( rgfmp[ dbid ].pdbfilehdr == NULL );
	Assert( err == JET_errSuccess );
	rgfmp[ dbid ].pdbfilehdr = pdbfilehdr;

HandleError:
	if ( err < 0 )
		UtilFree( (VOID *)pdbfilehdr );
	return err;
	}


VOID DBISetHeaderAfterAttach( DBFILEHDR *pdbfilehdr, LGPOS lgposAttach, DBID dbid, BOOL fKeepBackupInfo )
	{
	/*	Update database file header.
	 */
	pdbfilehdr->fDBState = fDBStateInconsistent;
	
	/*	Set attachment time and set consistent time
	 */
	if ( fLogDisabled )
		pdbfilehdr->lgposAttach = lgposMin;
	else
		pdbfilehdr->lgposAttach = lgposAttach;

	LGGetDateTime( &pdbfilehdr->logtimeAttach );

	/*	reset detach time
	 */
	pdbfilehdr->lgposDetach = lgposMin;
	memset( &pdbfilehdr->logtimeDetach, 0, sizeof( LOGTIME ) );

	/*	reset bkinfo except in the recovering UNDO mode where
	 *	we would like to keep the original backup information.
	 */
	if ( !fKeepBackupInfo )
		{
		if ( fLogDisabled ||
			memcmp( &pdbfilehdr->signLog, &signLogGlobal, sizeof( SIGNATURE ) ) != 0 )
			{
			/*	if no log or the log signaure is not the same as current log signature,
			 *	then the bkinfoIncPrev and bfkinfoFullPrev are not meaningful.
			 */
			memset( &pdbfilehdr->bkinfoIncPrev, 0, sizeof( BKINFO ) );
			memset( &pdbfilehdr->bkinfoFullPrev, 0, sizeof( BKINFO ) );
			}
		memset( &pdbfilehdr->bkinfoFullCur, 0, sizeof( BKINFO ) );
		}

	/*	Set global signature.
	 */
	if ( fLogDisabled )
		{
		memset( &pdbfilehdr->signLog, 0, sizeof( SIGNATURE ) );
		}
	else
		{
		Assert( fSignLogSetGlobal );
		pdbfilehdr->signLog = signLogGlobal;
		}
	pdbfilehdr->dbid = dbid;
	}
	

ERR ISAMAPI ErrIsamAttachDatabase( JET_VSESID sesid, const CHAR  *szDatabaseName, JET_GRBIT grbit )
	{
	PIB		*ppib;
	ERR		err;
	DBID	dbid;
	CHAR	rgbFullName[JET_cbFullNameMost];
	CHAR	*szFullName;
	LGPOS	lgposLogRec;
	DBFILEHDR *pdbfilehdr;
	BOOL	fReadOnly;

	/*	check parameters
	/**/
	Assert( sizeof(JET_VSESID) == sizeof(PIB *) );
	ppib = (PIB *)sesid;

	CallR( ErrPIBCheck( ppib ) );

	if ( fBackupInProgress )
		return ErrERRCheck( JET_errBackupInProgress );

	if ( ppib->level > 0 )
		return ErrERRCheck( JET_errInTransaction );

	if ( grbit & JET_bitDbVersioningOff )
		return ErrERRCheck( JET_errCannotDisableVersioning );

	if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
		{
		return ErrERRCheck( JET_errDatabaseNotFound );
		}
	szFullName = rgbFullName;

	CallR( ErrUtilGetFileAttributes( szFullName, &fReadOnly ) );
	if ( fReadOnly && !(grbit & JET_bitDbReadOnly) )
		return JET_errDatabaseFileReadOnly;
		
	/*	depend on _fullpath to make same files same name
	/*	thereby preventing same file to be multiply attached
	/**/
	err = ErrIOLockNewDbid( &dbid, szFullName );
	if ( err != JET_errSuccess )
		{
		Assert( err == JET_wrnDatabaseAttached ||
			err == JET_errOutOfMemory ||
			err == JET_errTooManyAttachedDatabases );
		return err;
		}

	err = ErrDBReadHeaderCheckConsistency( szFullName, dbid );
#ifdef DAYTONA
	if ( err == JET_errDatabaseCorrupted )
		{
		if ( ErrDBICheck400( szFullName ) == JET_errSuccess )
			err = ErrERRCheck( JET_errDatabase400Format );
		else if ( ErrDBICheck200( szFullName ) == JET_errSuccess )
			err = ErrERRCheck( JET_errDatabase200Format );
		}
#endif
	Call( err );

	/*	set database loggable flags.
	/**/
	if ( grbit & JET_bitDbRecoveryOff )
		{
		DBIDResetLogOn(dbid);
		}
	else if ( dbid != dbidTemp )
		{
		/*	set all databases loggable except Temp if not specified in grbit
		/**/
		DBIDSetLogOn(dbid);
		}

	// Can only turn versioning off for CreateDatabase().
	// UNDONE:  Is it useful to allow user to turn versioning off for AttachDatabase()?
	Assert( !FDBIDVersioningOff( dbid ) );

	pdbfilehdr = rgfmp[dbid].pdbfilehdr;

	/*	log Attach
	/**/
	Assert( dbid != dbidTemp );
	
	/*	Update database file header.
	 */
	rgfmp[dbid].fReadOnly = ( (grbit & JET_bitDbReadOnly) != 0 );

	Call( ErrLGAttachDB(
			ppib,
			dbid,
			(CHAR *)szFullName,
			strlen(szFullName) + 1,
			&pdbfilehdr->signDb,
			&pdbfilehdr->signLog,
			&pdbfilehdr->lgposConsistent,
			&lgposLogRec ) );

	/*	make sure the log is flushed before we change the state
	 */
	Call( ErrLGWaitForFlush( ppib, &lgposLogRec ) );

	/*	update checkpoint entry so that we know
	 *	any operations after this point, we must redo.
	 */
	if ( !fRecovering )
		{
		LgLeaveCriticalSection( critJet );
		LGUpdateCheckpointFile( fFalse );
		LgEnterCriticalSection( critJet );
		}

	if ( !rgfmp[dbid].fReadOnly )
		{
		DBISetHeaderAfterAttach( pdbfilehdr, lgposLogRec, dbid, fFalse );
		Call( ErrUtilWriteShadowedHeader( szFullName, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) ) );
		}

	Call( ErrIOOpenDatabase( dbid, szFullName, 0L ) );

	IOSetAttached( dbid );
	IOUnlockDbid( dbid );
	
	/*	set the last page of the database, used to prevent over preread.
	/**/
	if ( ( err = ErrDBSetLastPage( ppib, dbid ) ) < 0 )
		{
		IOResetAttached( dbid );
		Call( err );
		}

	/*	update checkpoint file to reflect the attachment changes.
	/**/
	if ( !fRecovering )
		{
		LgLeaveCriticalSection( critJet );
		LGUpdateCheckpointFile( fTrue );
		LgEnterCriticalSection( critJet );
		}

	return JET_errSuccess;

HandleError:
	if ( rgfmp[ dbid ].pdbfilehdr )
		{
		UtilFree( (VOID *)rgfmp[ dbid ].pdbfilehdr );
		rgfmp[ dbid ].pdbfilehdr = NULL;
		}
	IOFreeDbid( dbid );
	return err;
	}

/*	szDatabaseName of NULL detaches all user databases.  Note system database
/*	cannot be detached.
/**/
ERR ISAMAPI ErrIsamDetachDatabase( JET_VSESID sesid, const CHAR  *szDatabaseName )
	{
	ERR		err;
	PIB		*ppib;
	DBID   	dbid;
	CHAR   	rgbFullName[JET_cbFullNameMost];
	CHAR   	*szFullName;
	CHAR   	*szFileName;
	DBID	dbidDetach;
	LGPOS	lgposLogRec;
	DBFILEHDR *pdbfilehdr;

	/* check parameters
	/**/
	Assert( sizeof(JET_VSESID) == sizeof(PIB *) );
	ppib = (PIB *)sesid;

	CallR( ErrPIBCheck( ppib ) );

	if ( fBackupInProgress )
		return ErrERRCheck( JET_errBackupInProgress );

	if ( ppib->level > 0 )
		return ErrERRCheck( JET_errInTransaction );

	if ( szDatabaseName == NULL )
		dbidDetach = dbidUserLeast - 1;

DetachNext:
	if  ( szDatabaseName == NULL )
		{
		for ( dbidDetach++;
			  dbidDetach < dbidMax &&
				(rgfmp[dbidDetach].szDatabaseName == NULL || !FFMPAttached( &rgfmp[dbidDetach] ));
			  dbidDetach++ );
		Assert( dbidDetach > dbidTemp && dbidDetach <= dbidMax );
		if  ( dbidDetach == dbidMax )
			goto Done;
		szFullName = rgfmp[dbidDetach].szDatabaseName;
		}
	else
		{
		if ( fRecovering && fRecoveringMode == fRecoveringRedo )
			szFullName = (char *) szDatabaseName;
		else
			{
			if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
				return ErrERRCheck( JET_errDatabaseNotFound );
			szFullName = rgbFullName;
			}
		}

	err = ErrIOLockDbidByNameSz( szFullName, &dbid );
	if ( err < 0 )
		return err;

	if ( FIODatabaseInUse( dbid ) )
		{
		Call( ErrERRCheck( JET_errDatabaseInUse ) );
		}

	if ( !FIOAttached( dbid ) )
		{
		Call( ErrERRCheck( JET_errDatabaseNotFound ) )
		}
	
	Assert( dbid != dbidTemp );

	if ( !FDBIDAttachNullDb( dbid ) )
		{
		/* purge all MPL entries for this dbid
		/**/
		MPLPurge( dbid );

		/*	clean up all version store. Actually we only need to clean up
		/*	the entries that had dbid as the dbid for the new database.
		/**/
		Call( ErrRCECleanAllPIB() );
		}

	if ( FIODatabaseOpen( dbid ) )
		{
		/*	flush all database buffers
		/**/
		err = ErrBFFlushBuffers( dbid, fBFFlushAll );
		if ( err < 0 )
			{
			IOUnlockDbid( dbid );
			return err;
			}

		/*	purge all buffers for this dbid
		/**/
		BFPurge( dbid );

		IOCloseDatabase( dbid );
		}

	/*	log detach database
	/**/
	Assert( dbid != dbidTemp );
	Call( ErrLGDetachDB(
		ppib,
		dbid,
		(CHAR *)szFullName,
		strlen(szFullName) + 1,
		&lgposLogRec ));

	/*	make sure the log is flushed before we change the state
	 */
	Call( ErrLGWaitForFlush( ppib, &lgposLogRec ) );

	/*	Update database file header. If we are detaching a bogus entry,
	 *	then the db file should never be opened and pdbfilehdr will be Nil.
	 */
	pdbfilehdr = rgfmp[dbid].pdbfilehdr;

	if ( !rgfmp[dbid].fReadOnly && pdbfilehdr )
		{
		pdbfilehdr->fDBState = fDBStateConsistent;
	
		if ( fLogDisabled )
			{
			pdbfilehdr->lgposDetach = lgposMin;
			pdbfilehdr->lgposConsistent = lgposMin;
			}
		else
			{
			/*	Set detachment time.
			 */
			if ( fRecovering && fRecoveringMode == fRecoveringRedo )
				{
				Assert( szDatabaseName );
				pdbfilehdr->lgposDetach = lgposRedo;
				}
			else
				pdbfilehdr->lgposDetach = lgposLogRec;

			pdbfilehdr->lgposConsistent = pdbfilehdr->lgposDetach;
			}
		LGGetDateTime( &pdbfilehdr->logtimeDetach );
		pdbfilehdr->logtimeConsistent = pdbfilehdr->logtimeDetach;

		szFileName = szFullName;
		if ( fRecovering && fHardRestore )
			{
			INT irstmap;

			err = ErrLGGetDestDatabaseName( rgfmp[dbid].szDatabaseName, &irstmap, NULL );
			if ( err == JET_errSuccess && irstmap >= 0 )
				szFileName = rgrstmapGlobal[irstmap].szNewDatabaseName;
			else
				{
				/*	use given name.
				 */
				err = JET_errSuccess;
				}
			}

		Call( ErrUtilWriteShadowedHeader( szFileName, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) ) );
		}

	/*	do not free dbid on detach to avoid problems related to
	/*	version RCE aliasing and database name conflict during
	/*	recovery.
	/**/
#ifdef REUSE_DBID
	DBIDResetAttachNullDb( dbid );
	IOResetAttached( dbid );
	
	IOResetExclusive( dbid );
	IOUnlockDbid( dbid );
#else
	IOFreeDbid( dbid );
#endif

	if ( !FDBIDAttachNullDb( dbid ) )
		{
		/*	purge open table fcbs to avoid future confusion
		/**/
		FCBPurgeDatabase( dbid );
		}

	/*	indicate this db entry is detached.
	 */
	if ( pdbfilehdr )
		{
		if ( fRecovering && fRecoveringMode == fRecoveringRedo )
			{
			Assert( rgfmp[dbid].patchchk );
			SFree( rgfmp[dbid].patchchk );
			rgfmp[dbid].patchchk = NULL;
			}
		UtilFree( (VOID *)rgfmp[ dbid ].pdbfilehdr );
		rgfmp[dbid].pdbfilehdr = NULL;
		}
	
	DBIDResetAttachNullDb( dbid );
		
	if ( rgfmp[dbid].szDatabaseName )
		{
		SFree( rgfmp[dbid].szDatabaseName );
		rgfmp[dbid].szDatabaseName = NULL;
		}

	if ( rgfmp[dbid].szPatchPath )
		{
		Assert( fRecovering && fHardRestore );
		SFree( rgfmp[dbid].szPatchPath );
		rgfmp[dbid].szPatchPath = NULL;
		}

	/*	clean up fmp for future use
	/**/
	Assert( rgfmp[dbid].hf == handleNil );

	/*	update checkpoint file to reflect the attachment changes
	/**/
	if ( !fRecovering )
		{
		LgLeaveCriticalSection( critJet );
		LGUpdateCheckpointFile( fTrue );
		LgEnterCriticalSection( critJet );
		}

	/*	detach next database if found
	/**/
	if  ( szDatabaseName == NULL && dbidDetach < dbidMax )
		goto DetachNext;

Done:
	return JET_errSuccess;

HandleError:
	IOUnlockDbid( dbid );
	return err;
	}


/*	DAE databases are repaired automatically on system restart
/**/
ERR ISAMAPI ErrIsamRepairDatabase(
	JET_VSESID sesid,
	const CHAR  *lszDbFile,
	JET_PFNSTATUS pfnstatus )
	{
	PIB *ppib;

	Assert( sizeof(JET_VSESID) == sizeof(PIB *) );
	ppib = (PIB*) sesid;

	NotUsed(ppib);
	NotUsed(lszDbFile);
	NotUsed(pfnstatus);

	Assert( fFalse );
	return ErrERRCheck( JET_errFeatureNotAvailable );
	}


ERR ISAMAPI ErrIsamOpenDatabase(
	JET_VSESID sesid,
	const CHAR  *szDatabaseName,
	const CHAR  *szConnect,
	JET_DBID *pjdbid,
	JET_GRBIT grbit )
	{
	ERR		err;
	PIB		*ppib;
	DBID  	dbid;
	VDBID 	vdbid = vdbidNil;

	/*	check parameters
	/**/
	Assert( sizeof(JET_VSESID) == sizeof(PIB *) );
	ppib = (PIB *)sesid;
	NotUsed(szConnect);
	
	CallR( ErrPIBCheck( ppib ) );

	dbid = 0;
	CallR( ErrDBOpenDatabase( ppib, (CHAR *)szDatabaseName, &dbid, grbit ) );

	Call( ErrDABAlloc( ppib, &vdbid, dbid, grbit ) );
	Assert( sizeof(vdbid) == sizeof(JET_VDBID) );
#ifdef	DB_DISPATCHING
	Call( ErrAllocateDbid( pjdbid, (JET_VDBID) vdbid, &vdbfndefIsam ) );
#else	/* !DB_DISPATCHING */
	*pjdbid = (JET_DBID)vdbid;
#endif	/* !DB_DISPATCHING */

	return JET_errSuccess;

HandleError:
	if ( vdbid != vdbidNil )
		CallS( ErrDABDealloc( ppib, vdbid ) );
	CallS( ErrDBCloseDatabase( ppib, dbid, grbit ) );
	return err;
	}


ERR ErrDBOpenDatabase( PIB *ppib, CHAR *szDatabaseName, DBID *pdbid, ULONG grbit )
	{
	ERR		err = JET_errSuccess;
	CHAR  	rgbFullName[JET_cbFullNameMost];
	CHAR  	*szFullName;
	CHAR  	*szFileName;
	DBID  	dbid;
	BOOL	fNeedToClearPdbfilehdr = fFalse;

	if ( fRecovering )
		CallS( ErrIOLockDbidByNameSz( szDatabaseName, &dbid ) );

	if ( fRecovering && dbid != dbidTemp )
		{
		szFullName = rgfmp[dbid].szDatabaseName;
		szFileName = szFullName;
		if ( fRecovering && fHardRestore )
			{
			INT irstmap;
			
			err = ErrLGGetDestDatabaseName( rgfmp[dbid].szDatabaseName, &irstmap, NULL );
			if ( err == JET_errSuccess && irstmap >= 0 )
				szFileName = rgrstmapGlobal[irstmap].szNewDatabaseName;
			else
				{
				/*	use given name.
				 */
				err = JET_errSuccess;
				}
			}
		}
	else
		{
		if ( _fullpath( rgbFullName, szDatabaseName, JET_cbFullNameMost ) == NULL )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		szFullName = rgbFullName;
		szFileName = szFullName;
		}

	if ( !fRecovering )
		CallR( ErrIOLockDbidByNameSz( szFullName, &dbid ) );

	/*  during recovering, we could open an non-detached database
	/*  to force to initialize the fmp entry.
	/*	if database has been detached, then return error.
	/**/
	if ( !fRecovering && !FIOAttached( dbid ) )
		{
		err = ErrERRCheck( JET_errDatabaseNotFound );
		goto HandleError;
		}
	Assert( !FDBIDAttachNullDb( dbid ) );

	if ( rgfmp[dbid].fReadOnly && ( grbit & JET_bitDbReadOnly ) == 0 )
		err = ErrERRCheck( JET_wrnFileOpenReadOnly );

	if ( FIOExclusiveByAnotherSession( dbid, ppib ) )
		{
		IOUnlockDbid( dbid );
		return ErrERRCheck( JET_errDatabaseLocked );
		}

	if ( ( grbit & JET_bitDbExclusive ) )
		{
		if ( FIODatabaseInUse( dbid ) )
			{
			IOUnlockDbid( dbid );
			return ErrERRCheck( JET_errDatabaseInUse );
			}
		IOSetExclusive( dbid, ppib );
		}

	Assert( HfFMPOfDbid(dbid) != handleNil );
	SetOpenDatabaseFlag( ppib, dbid );
	IOUnlockDbid( dbid );

	*pdbid = dbid;
	return err;

HandleError:
	if ( fNeedToClearPdbfilehdr )
		{
		UtilFree( (VOID *)rgfmp[ dbid ].pdbfilehdr );
		rgfmp[ dbid ].pdbfilehdr = NULL;
		}
	IOResetExclusive( dbid );
	IOUnlockDbid( dbid );
	return err;
	}


ERR ISAMAPI ErrIsamCloseDatabase( JET_VSESID sesid, JET_VDBID vdbid, JET_GRBIT grbit )
	{
	ERR	  	err;
	PIB	  	*ppib = (PIB *)sesid;
	DBID   	dbid;
	/*	flags for corresponding open
	/**/
	ULONG  	grbitOpen;

	NotUsed(grbit);

	/*	check parameters
	/**/
	Assert( sizeof(JET_VSESID) == sizeof(PIB *) );
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	dbid = DbidOfVDbid( vdbid );
	
	grbitOpen = GrbitOfVDbid( vdbid );

	err = ErrDBCloseDatabase( ppib, dbid, grbitOpen );
	if ( err == JET_errSuccess )
		{
#ifdef	DB_DISPATCHING
		ReleaseDbid( DbidOfVdbid( vdbid, &vdbfndefIsam ) );
#endif	/* DB_DISPATCHING */
		CallS( ErrDABDealloc( ppib, (VDBID) vdbid ) );
		}
	return err;
	}


ERR ErrDBCloseDatabase( PIB *ppib, DBID dbid, ULONG	grbit )
	{
	ERR		err;
	FUCB	*pfucb;
	FUCB	*pfucbNext;

	if ( !( FUserOpenedDatabase( ppib, dbid ) ) )
		{
		return ErrERRCheck( JET_errDatabaseNotFound );
		}

	CallR( ErrIOLockDbidByDbid( dbid ) );

	Assert( FIODatabaseOpen( dbid ) );

	if ( FLastOpen( ppib, dbid ) )
		{
		/*	close all open FUCBs on this database
		/**/

		/*	get first table FUCB
		/**/
		pfucb = ppib->pfucb;
		while ( pfucb != pfucbNil && ( pfucb->dbid != dbid || !FFCBClusteredIndex( pfucb->u.pfcb ) ) )
			pfucb = pfucb->pfucbNext;

		while ( pfucb != pfucbNil )
			{
			/*	get next table FUCB
			/**/
			pfucbNext = pfucb->pfucbNext;
			while ( pfucbNext != pfucbNil && ( pfucbNext->dbid != dbid || !FFCBClusteredIndex( pfucbNext->u.pfcb ) ) )
				pfucbNext = pfucbNext->pfucbNext;

			if ( !( FFUCBDeferClosed( pfucb ) ) )
				{
				if ( pfucb->fVtid )
					{
					CallS( ErrDispCloseTable( (JET_SESID)ppib, TableidOfVtid( pfucb ) ) );
					}
				else
					{
					Assert(	pfucb->tableid == JET_tableidNil );
					CallS( ErrFILECloseTable( ppib, pfucb ) );
					}
				}
			pfucb = pfucbNext;
			}
		}

	/* if we opened it exclusively, we reset the flag
	/**/
	ResetOpenDatabaseFlag( ppib, dbid );
	if ( grbit & JET_bitDbExclusive )
		IOResetExclusive( dbid );
	IOUnlockDbid( dbid );

	/*	do not close file until file map space needed or database
	/*	detached.
	/**/
	return JET_errSuccess;
	}


/*	called by bookmark clean up to open database for bookmark
/*	clean up operation.  Returns error if database is in use for
/*	attachment/detachment.
/**/
ERR ErrDBOpenDatabaseByDbid( PIB *ppib, DBID dbid )
	{
	if ( !FIODatabaseAvailable( dbid ) )
		{
		return ErrERRCheck( JET_errDatabaseNotFound );
		}

	SetOpenDatabaseFlag( ppib, dbid );
	return JET_errSuccess;
	}


/*	called by bookmark clean up to close database.
/**/
VOID DBCloseDatabaseByDbid( PIB *ppib, DBID dbid )
	{
	ResetOpenDatabaseFlag( ppib, dbid );
	}


/* ErrDABCloseAllDBs: Close all databases (except system database) opened by this thread
/**/
ERR ErrDABCloseAllDBs( PIB *ppib )
	{
	ERR		err;

	while( ppib->pdabList != pdabNil )
		{
		Assert( FUserOpenedDatabase( ppib, ppib->pdabList->dbid ) );
		CallR( ErrIsamCloseDatabase( ( JET_VSESID ) ppib, (JET_VDBID) ppib->pdabList, 0 ) );
		}

	return JET_errSuccess;
	}


#ifdef DAYTONA
/* persistent database data, in database root node
/**/
#pragma pack(1)
typedef struct _database_data
	{
	ULONG	ulMagic;
	ULONG	ulVersion;
	ULONG	ulDBTime;
	USHORT	usFlags;
	} P_DATABASE_DATA;
#pragma pack()


LOCAL ERR ErrDBICheck400( CHAR *szDatabaseName )
	{
	ERR	  	err = JET_errSuccess;
	UINT	cb;
	HANDLE 	hf;
	PAGE   	*ppage;
	INT	  	ibTag;
	INT	  	cbTag;
	BYTE  	*pb;

	CallR( ErrUtilOpenFile( szDatabaseName, &hf, 0L, fFalse, fFalse ) );
	if ( ( ppage = (PAGE *)PvUtilAllocAndCommit( cbPage ) ) == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	UtilChgFilePtr( hf, 0, NULL, FILE_BEGIN, &cb );
	Assert( cb == 0 );
	err = ErrUtilReadBlock( hf, (BYTE*)ppage, cbPage, &cb );
	
	/*	since file exists and we are unable to read data,
	/*	it may not be a system.mdb
	/**/
	if ( err == JET_errDiskIO )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		}
	Call( err );
	
	IbCbFromPtag(ibTag, cbTag, &ppage->rgtag[0]);
	if ( ibTag < (BYTE*)&ppage->rgtag[1] - (BYTE*)ppage ||
		(BYTE*)ppage + ibTag + cbTag >= (BYTE*)(ppage + 1) )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	/*	at least FILES, OWNEXT, AVAILEXT
	/**/
	pb = (BYTE *)ppage + ibTag;
	if ( !FNDVisibleSons( *pb ) || CbNDKey( pb ) != 0 || FNDNullSon( *pb ) )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	/*	check data length
	/**/
	cb = cbTag - (UINT)( PbNDData( pb ) - pb );
	if ( cb != sizeof(P_DATABASE_DATA) )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	/*	check database version
	/**/
	if ( ((P_DATABASE_DATA *)PbNDData(pb))->ulVersion != 0x400 )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

HandleError:
	if ( ppage != NULL )
		{
		UtilFree( (VOID *)ppage );
		}
	(VOID)ErrUtilCloseFile( hf );
	return err;
	}


#pragma pack(1)
/* database root node data -- in-disk
/**/
typedef struct _dbroot
	{
	ULONG	ulMagic;
	ULONG	ulVersion;
	ULONG	ulDBTime;
	USHORT	usFlags;
	} DBROOT200;
#pragma pack()

LOCAL ERR ErrDBICheck200( CHAR *szDatabaseName )
	{
	ERR	  	err = JET_errSuccess;
	UINT	cb;
	HANDLE 	hf;
	PAGE   	*ppage;
	INT	  	ibTag;
	INT	  	cbTag;
	BYTE  	*pb;

	CallR( ErrUtilOpenFile( szDatabaseName, &hf, 0L, fTrue, fFalse ) );
	if ( ( ppage = (PAGE *)PvUtilAllocAndCommit( cbPage ) ) == NULL )
		{
		err = JET_errOutOfMemory;
		goto HandleError;
		}

	UtilChgFilePtr( hf, 0, NULL, FILE_BEGIN, &cb );
	Assert( cb == 0 );
	err = ErrUtilReadBlock( hf, (BYTE*)ppage, cbPage, &cb );
	
	/*	since file exists and we are unable to read data,
	/*	it may not be a system.mdb
	/**/
	if ( err == JET_errDiskIO )
		err = ErrERRCheck( JET_errDatabaseCorrupted );
	Call( err );
	
	IbCbFromPtag(ibTag, cbTag, &ppage->rgtag[0]);
	if ( ibTag < (BYTE*)&ppage->rgtag[1] - (BYTE*)ppage ||
		(BYTE*)ppage + ibTag + cbTag >= (BYTE*)(ppage + 1) )
		{
		err = JET_errDatabaseCorrupted;
		goto HandleError;
		}

	/*	at least FILES, OWNEXT, AVAILEXT
	/**/
	pb = (BYTE *)ppage + ibTag;
	if ( !FNDVisibleSons( *pb ) || CbNDKey( pb ) != 0 || FNDNullSon( *pb ) )
		{
		err = JET_errDatabaseCorrupted;
		goto HandleError;
		}

	/*	check data length
	/**/
	cb = cbTag - (UINT)( PbNDData( pb ) - pb );
	if ( cb != sizeof(DBROOT200) )
		{
		err = JET_errDatabaseCorrupted;
		goto HandleError;
		}

	/*	check database version
	/**/
	if ( ((DBROOT200 *)PbNDData(pb))->ulVersion != 1 )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

HandleError:
	if ( ppage != NULL )
		UtilFree( (VOID *)ppage );
	(VOID)ErrUtilCloseFile( hf );
	return err;
	}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\dir.c ===
#include "daestd.h"

DeclAssertFile;                                 /* Declare file name for assert macros */

extern void *  critSplit;
extern BOOL fOLCompact;
extern ULONG cOLCSplitsAvoided;

LOCAL ERR ErrDIRIIRefresh( FUCB *pfucb );
LOCAL ERR ErrDIRICopyKey( FUCB *pfucb, KEY *pkey );
LOCAL ERR ErrDIRIMoveToItem( FUCB *pfucb, SRID srid, BOOL fNext );
INLINE LOCAL ERR ErrDIRIGotoItem( FUCB *pfucb, SRID bmItemList, ITEM item );
	
#undef DIRAPIReturn
#define	DIRAPIReturn( pfucbX, err )									\
	{																\
	Assert( pfucbX == pfucbNil ||									\
		( (FUCB *)pfucbX)->pbfEmpty == pbfNil );   			   		\
	return err;														\
	}															


/****************** DIR Item Routines *********************
/**********************************************************
/**/
//	UNDONE:	if pcsr is always current then remove parameter
#define DIRIGetItemList( pfucb, pcsr )			   				\
	{											   				\
	Assert( pcsr == PcsrCurrent( pfucb ) );						\
	Assert( FFUCBNonClustered( (pfucb) ) );			  			\
	AssertFBFReadAccessPage( (pfucb), (pcsr)->pgno );	  	   	\
	AssertNDGet( pfucb, pcsr->itag ); 	 				  		\
	NDGetNode( (pfucb) );								   		\
	}


#define ErrDIRINextItem( pfucb )								\
	( pfucb->lineData.cb == sizeof(SRID) ?                      \
		ErrERRCheck( errNDNoItem ) : ErrNDNextItem( pfucb ) )


#define ErrDIRIPrevItem( pfucb )                                \
	( PcsrCurrent(pfucb)->isrid == 0 ?                          \
		ErrERRCheck( errNDNoItem ) : ErrNDPrevItem( pfucb ) )


/*	cache srid of first item list node for version.  Return
/*	warning JET_wrnKeyChanged if first item.
/**/
#define DIRICheckFirstSetItemListAndWarn( pfucb, wrn )			\
		{                                         				\
		if FNDFirstItem( *pfucb->ssib.line.pb )      			\
			{                                         			\
			wrn = ErrERRCheck( JET_wrnKeyChanged );		\
			DIRISetItemListFromFirst( pfucb );        			\
			}                                        	 		\
		}


/*	cache srid of first item list node for version
/**/
#define DIRICheckFirstSetItemList( pfucb )         				\
		{                                            			\
		if FNDFirstItem( *pfucb->ssib.line.pb )      			\
			{                                         			\
			DIRISetItemListFromFirst( pfucb );        			\
			}                                         			\
		}


#define DIRISetItemListFromFirst( pfucb )          			   	\
		{                                    				   	\
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 	   	\
		Assert( FNDFirstItem( *pfucb->ssib.line.pb ) );     	\
		NDGetBookmark( pfucb, &PcsrCurrent( pfucb )->bm );		\
		}


#define DIRICheckLastSetItemList( pfucb )                       \
		{                                                       \
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 		\
		if FNDLastItem( *pfucb->ssib.line.pb )                  \
			{                                                   \
			DIRISetItemListFromLast( pfucb );                   \
			}    												\
		}


#define DIRICheckLastSetItemListAndWarn( pfucb, wrn )              	\
		{														   	\
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 		   	\
		if FNDLastItem( *pfucb->ssib.line.pb )					   	\
			{													   	\
			wrn = ErrERRCheck( JET_wrnKeyChanged );		   	\
			DIRISetItemListFromLast( pfucb );					   	\
			}													  	\
		}


/*	remember to back up one item after move to last item via
/*	seek for sridMax, since this call will normally position
/*	after last item and we want to move onto last item.
/**/
#define DIRISetItemListFromLast( pfucb ) 							\
		{                                                           \
		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag ); 			\
		if FNDFirstItem( *pfucb->ssib.line.pb )                     \
			{                                                       \
			DIRISetItemListFromFirst( pfucb );                      \
			}                                                       \
		else                                                        \
			{                                                       \
			CallS( ErrDIRIMoveToItem( pfucb, sridMin, fFalse ) );   \
			DIRISetItemListFromFirst( pfucb );                      \
			CallS( ErrDIRIMoveToItem( pfucb, sridMax, fTrue ) );    \
			Assert( PcsrCurrent( pfucb )->isrid > 0 );				\
			PcsrCurrent( pfucb )->isrid--;							\
			}                                                       \
		}


/*********** DIR Fresh/Refresh Routines *************
/**********************************************************
/**/
#define AssertDIRFresh( pfucb )    													\
	{																				\
	AssertFBFReadAccessPage( (pfucb), PcsrCurrent(pfucb)->pgno );					\
	Assert( PcsrCurrent( pfucb )->qwDBTime == QwSTDBTimePssib( &pfucb->ssib ) );	\
	}


#define ErrDIRRefresh( pfucb )                                                                                            \
	( FBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) ?                                \
		ErrDIRIRefresh( pfucb ) : ErrDIRIIRefresh( pfucb ) )


#define ErrDIRIRefresh( pfucb )													\
	( !( FBFReadLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) &&							\
		PcsrCurrent(pfucb)->qwDBTime == QwSTDBTimePssib( &pfucb->ssib ) ?		\
		JET_errSuccess : ErrDIRIIRefresh( pfucb ) )


/*	this routine is called to refresh currency when time stamp is
/*	out of date or when buffer has been overlayed.  The common case
/*	is filtered out by the encapsulating macro.
/**/
LOCAL ERR ErrDIRIIRefresh( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	CSR		*pcsr;

#ifdef DEBUG
	ULONG	ctimes = 0;
#endif

Start:
#ifdef DEBUG
	ctimes++;
#endif

	/*	cache pcsr for efficiency.  Must recache after start since
	/*	CSR may change as a result of some navigation operations.
	/**/
	pcsr = PcsrCurrent( pfucb );

	/*	only need to refresh currency when on node, or before, or after
	/*	node.  Before first, and after last do not need restoration.
	/*	On FDP node does not need restoration since this node is
	/*	inherently fixed.
	/**/
	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatBeforeCurNode:
		case csrstatAfterCurNode:
		case csrstatOnFDPNode:
			break;
		case csrstatDeferGotoBookmark:
			/*	goto bookmark as though operation was
			/*	not defered.  Must store currency so
			/*	that timestamp set for future operations.
			/**/
			Call( ErrBTGotoBookmark( pfucb, pcsr->bm ) );
			pcsr->csrstat = csrstatOnCurNode;
			goto AfterNodeRefresh;
			break;
		case csrstatDeferMoveFirst:
			{
			DIB		dib;
			FUCB 	*pfucbIdx;

			if ( pfucb->pfucbCurIndex )
				{
				pfucbIdx = pfucb->pfucbCurIndex;
				}
			else
				{
				pfucbIdx = pfucb;
				}

			/*	go to DATA node
			/**/
			DIRGotoDataRoot( pfucbIdx );

			/*	move to first son of DATA node
			/**/
			dib.fFlags = fDIRPurgeParent;
			dib.pos = posFirst;
			err = ErrDIRDown( pfucbIdx, &dib );
			Assert( PcsrCurrent( pfucbIdx )->csrstat != csrstatDeferMoveFirst );
			if ( err < 0 )
				{
				/*	reset currency to defer move first
				/**/
				DIRDeferMoveFirst( pfucb );
				/*	polymorph error code for empty index
				/**/
				if ( err == JET_errRecordNotFound )
					err = ErrERRCheck( JET_errNoCurrentRecord );
				goto HandleError;
				}

			Assert( err == JET_errSuccess && PcsrCurrent( pfucbIdx )->csrstat == csrstatOnCurNode );
			if ( pfucb->pfucbCurIndex )
				{
				Assert( PcsrCurrent( pfucb ) == pcsr );
				pcsr->bm = PcsrCurrent( pfucbIdx )->item;
				Call( ErrBTGotoBookmark( pfucb, PcsrCurrent( pfucbIdx )->item ) );
				pcsr->csrstat = csrstatOnCurNode;
				}

			goto Done;
			}
		case csrstatOnDataRoot:
			{
			Assert( PcsrCurrent( pfucb ) == pcsr );
//			pcsr->bm = sridNull;
			pcsr->itagFather = itagNull;
			pcsr->pgno = PgnoRootOfPfucb( pfucb );
			while( !FBFReadAccessPage( pfucb, pcsr->pgno ) )
				{
				Call( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
				pcsr->pgno = PgnoRootOfPfucb( pfucb );
				}
			pcsr->itag = ItagRootOfPfucb( pfucb );
			NDGet( pfucb, pcsr->itag );

			/*	note that it is important here than the currency
			/*	is not set fresh since each time we use this CSR
			/*	we must go through the same process to navigate to the
			/*	data node.
			/**/
			goto Done;
			}
		default:
			Assert( pcsr->csrstat == csrstatAfterLast ||
				pcsr->csrstat == csrstatBeforeFirst );
			goto Done;
		}

	Assert( pcsr->csrstat == csrstatOnCurNode ||
		pcsr->csrstat == csrstatBeforeCurNode ||
		pcsr->csrstat == csrstatAfterCurNode ||
		pcsr->csrstat == csrstatOnFDPNode );

	/*	read access page and check for valid time stamp
	/**/
	if ( !FBFReadAccessPage( pfucb, pcsr->pgno ) )
		{
		err = ErrBFReadAccessPage( pfucb, pcsr->pgno );
		if ( err < 0 )
			return err;
		}

	/*	if timestamp unchanged then set line cache and data cache
	/*	for non-clustered cursors.  If timestamp changed then
	/*	refresh currency from bookmark.
	/**/
	if ( pcsr->qwDBTime == QwSTDBTimePssib( &pfucb->ssib ) )
		{
		NDGet( pfucb, pcsr->itag );
		if ( FFUCBNonClustered( pfucb ) )
			{
			DIRIGetItemList( pfucb, pcsr );
			}
		}
	else
		{
		/*	refresh node currency.  If node is not there for
		/*	caller then it must have been deleted so set
		/*	CSR status to before current node.
		/**/
		Assert( PcsrCurrent( pfucb ) == pcsr );
		err = ErrBTGotoBookmark( pfucb, pcsr->bm );
		if ( err < 0 )
			{
			if ( err == JET_errRecordDeleted )
				{
				err = JET_errSuccess;
				Assert( pcsr->csrstat == csrstatOnCurNode ||
					pcsr->csrstat == csrstatBeforeCurNode ||
					pcsr->csrstat == csrstatAfterCurNode );
				pcsr->csrstat = csrstatBeforeCurNode;
				}
			else
				goto HandleError;
			}

AfterNodeRefresh:
		/*	if non-clustered cursor and on item list, i.e. not on
		/*	index root, then position currency in item list.
		/**/
		if ( FFUCBNonClustered( pfucb ) && !FDIRDataRootRoot( pfucb, pcsr ) )
			{
			/*	fix item cursor for insert, delete, split.
			/**/
			DIRIGetItemList( pfucb, pcsr );
			Call( ErrDIRIMoveToItem( pfucb, pcsr->item, fTrue ) );
			}
		}

	DIRSetFresh( pfucb );
	err = JET_errSuccess;
Done:
	Assert( err >= 0 );
	if ( FBFReadLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		goto Start;
		}
	return err;

HandleError:
	Assert( err != JET_errRecordDeleted );
	return err;
	}


ERR ErrDIRGet( FUCB *pfucb )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	special case on current node if
	/* 		on current node and
	/* 		page cached and
	/* 		timestamp not changed and
	/* 		node has not been versioned or
	/* 		caller sees consistent version
	/**/
	if (  pcsr->csrstat == csrstatOnCurNode )
		{
		/*	read access page and check for valid time stamp
		/**/
		if ( !FBFReadAccessPage( pfucb, pcsr->pgno ) )
			{
			Call( ErrBFReadAccessPage( pfucb, pcsr->pgno ) );
			}

		if ( pcsr->qwDBTime == QwSTDBTimePssib( &pfucb->ssib ) )
			{
			NDGet( pfucb, pcsr->itag );
			if ( !FNDVerDel( *(pfucb->ssib.line.pb) ) || FPIBDirty( pfucb->ppib ) )
				{
				NDGetNode( pfucb );
				return JET_errSuccess;
				}
			}
		}

	/*	refresh currency
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent(pfucb);

	/*	check CSR status
	/**/
	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatOnFDPNode:
		case csrstatOnDataRoot:
			break;
		default:
			Assert( pcsr->csrstat == csrstatBeforeCurNode ||
				pcsr->csrstat == csrstatAfterCurNode ||
				pcsr->csrstat == csrstatAfterLast ||
				pcsr->csrstat == csrstatBeforeFirst );
			return ErrERRCheck( JET_errNoCurrentRecord );
		}

	/*	make node current, and return error if node is not there.
	/**/
	Call( ErrBTGetNode( pfucb, pcsr ) );

	/*	non-clustered cursor record bookmark cannot change.  Even
	/*	if record has been deleted, return from goto bookmark
	/*	operation will provide information.
	/**/
	err = JET_errSuccess;
	return err;

HandleError:
	DIRSetRefresh( pfucb );
	return err;
	}


/***************** DAE Internal Routines ******************
/**********************************************************
/**/
#define	DIRIPurgeParent( pfucb )												\
	FUCBFreePath( &(PcsrCurrent( pfucb )->pcsrPath), pcsrNil );


/*	free CSRs from current CSR to pcsr.
/**/
#define	DIRIUpToCSR( pfucb, pcsr )												\
	{																						\
	FUCBFreePath( &PcsrCurrent( pfucb ), pcsr );								\
	if ( FBFReadAccessPage( pfucb, pcsr->pgno ) )								\
		{																					\
		NDGet( pfucb, pcsr->itag );	  											\
		}																					\
	}


LOCAL ERR ErrDIRICopyKey( FUCB *pfucb, KEY *pkey )
	{
	if ( pfucb->pbKey == NULL )
		{
		pfucb->pbKey = LAlloc( 1L, JET_cbKeyMost + 1 );
		if ( pfucb->pbKey == NULL )
			return ErrERRCheck( JET_errOutOfMemory );
		}
	KSReset( pfucb );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	NDGetKey( pfucb );
	pkey->cb = pfucb->keyNode.cb;
	pkey->pb = pfucb->pbKey;
	memcpy( pkey->pb, pfucb->keyNode.pb, pkey->cb );
	return JET_errSuccess;
	}


/*	this routine gets bookmark of first item list node
/**/
ERR ErrDIRGetBMOfItemList( FUCB *pfucb, SRID *pbmItemList )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucbT = pfucbNil;

	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	if ( FNDFirstItem( *pfucb->ssib.line.pb ) )
		{
		NDGetBookmark( pfucb, pbmItemList );
		}
	else
		{
		CallR( ErrDIROpen( pfucb->ppib, pfucb->u.pfcb, pfucb->dbid, &pfucbT ) );
		DIRGotoBookmark( pfucbT, SridOfPgnoItag( PcsrCurrent( pfucb )->pgno, PcsrCurrent( pfucb )->itag ) );
		for ( ;; )
			{
			DIB		dib;

			dib.pos = posFirst;
			dib.pkey = pkeyNil;
			dib.fFlags = 0;
			Call( ErrDIRPrev( pfucbT, &dib ) );

			Call( ErrDIRGet( pfucbT ) );
			if ( FNDFirstItem( *pfucbT->ssib.line.pb ) )
				{
				NDGetBookmark( pfucbT, pbmItemList );
				break;
				}
			}
		}

HandleError:
	Assert( err >= 0 );
	if ( pfucbT != pfucbNil )
		{
		DIRClose( pfucbT );
		}
	return err;
	}


/*	this routine moves from first item list node to item insert
/*	position, or it moves from the last item list node to the
/*	first item list node.
/**/
LOCAL ERR ErrDIRIMoveToItem( FUCB *pfucb, SRID srid, BOOL fNext )
	{
	ERR		err = JET_errSuccess;
	SSIB	*pssib = &pfucb->ssib;
	CSR		*pcsr = PcsrCurrent( pfucb );
	DIB		dib;

	/*	item list nodes not versioned
	/**/
	dib.fFlags = fDIRItemList;

	forever
		{
		AssertFBFReadAccessPage( pfucb, pcsr->pgno );
		AssertNDGetNode( pfucb, pcsr->itag );

		/*	if we are moving to item insert position, then stop
		/*	when on last item list node or when insert position
		/*	found in item list node.
		/**/
		if ( fNext )
			{
			if ( srid != sridMax )
				{
				err = ErrNDSeekItem( pfucb, srid );
				}
			else
				{
				PcsrCurrent( pfucb )->isrid = (SHORT) ( pfucb->lineData.cb / sizeof(SRID) );
				err = ErrERRCheck( errNDGreaterThanAllItems );
				}
			if ( FNDLastItem( *pssib->line.pb ) || err != errNDGreaterThanAllItems )
				{
				break;
				}
			}
		else
			{
			if ( srid != sridMin )
				{
				err = ErrNDSeekItem( pfucb, srid );
				Assert( err == errNDGreaterThanAllItems ||
					err == wrnNDDuplicateItem ||
					err == JET_errSuccess );
				}
			else
				{
				pcsr->isrid = 0;
				}
			if ( FNDFirstItem( *pssib->line.pb ) || pcsr->isrid != 0 )
				{
				break;
				}
			}

		Call( ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fNext, &dib, NULL ) );
		DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
		}

	if ( err != wrnNDDuplicateItem )
		{
		err = JET_errSuccess;
		}

HandleError:
	return err;
	}


/*	return JET_errKeyDuplicate, if any potentially there item
/*	found in this item list.
/**/
INLINE LOCAL ERR ErrDIRIKeyDuplicate( FUCB *pfucb )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB 	*pssib = &pfucb->ssib;
	DIB		dib;
	SRID  	*psrid;
	SRID  	*psridMax;
	VS	  	vs;

	/*	must start on first item list node.
	/**/
	Assert( FNDFirstItem( *pssib->line.pb ) );
	AssertBTGetNode( pfucb, pcsr );

	dib.fFlags = fDIRNull;

	/*	for each node in item list, check for duplicate key.
	/**/
	forever
		{
		/*	for each SRID in item list, if item is potentially there
		/*	then return JET_errDuplicateKey.
		/**/
		psrid = (SRID *)pfucb->lineData.pb;
		psridMax = psrid + pfucb->lineData.cb / sizeof(SRID);
		for ( ; psrid < psridMax; psrid++ )
			{
			if ( FNDItemVersion( *(SRID UNALIGNED *)psrid ) )
				{
				vs = VsVERCheck( pfucb, PcsrCurrent( pfucb )->bm );
				if ( FVERPotThere( vs, FNDItemDelete( *(SRID UNALIGNED *)psrid ) ) )
					return ErrERRCheck( JET_errKeyDuplicate );
				}
			else
				{
				if ( !FNDItemDelete( *(SRID UNALIGNED *)psrid )   )
					return ErrERRCheck( JET_errKeyDuplicate );
				}
			}

		/*	if this node is last node in item list then break.
		/**/
		if ( FNDLastItem( *pssib->line.pb ) )
			break;

		Call( ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib, NULL ) );
		DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
		}

	err = JET_errSuccess;
HandleError:
	return err;
	}


/*	when a down does not find a valid item in the first/last item of
/*	an item list with the seek key, this routine is called to
/*	adjust the currency to a valid position.  The final position
/*	may be on a node with a key not equal to the seek key, if
/*	there was no valid item for the seek key.
/**/
INLINE LOCAL ERR ErrDIRIDownAdjust( FUCB *pfucb, DIB *pdib )
	{
	ERR		err = JET_errNoCurrentRecord;
	SSIB 	*pssib = &pfucb->ssib;
	INT		s;

	/* input currency on node.
	/**/
	AssertBTGetNode( pfucb, PcsrCurrent( pfucb ) );

	/*	item list nodes not versioned.
	/**/
	pdib->fFlags |= fDIRItemList;

	/*	if not pos last, move next to next valid item.
	/**/
	if ( pdib->pos != posLast )
		{
		while ( ( err = ErrDIRINextItem( pfucb ) ) < 0 )
			{
			Assert( err == errNDNoItem || err == errNDLastItemNode );
			/*	move to next node with DIB constraints
			/**/
			err = ErrBTNext( pfucb, pdib );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					{
					ERR	errT;
					errT = ErrBTPrev( pfucb, pdib );
					if ( errT < 0 )
						goto HandleError;
					break;
					}
				goto HandleError;
				}

			DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

			/*	if on new item list then set bookmark from
			/*	first item list node.
			/**/
			DIRICheckFirstSetItemList( pfucb );
			err = ErrNDFirstItem( pfucb );
			if ( err == JET_errSuccess )
				break;
			}
		}

	/*	if no valid item found then move previous item.
	/**/
	Assert( err == JET_errSuccess || err == JET_errNoCurrentRecord );
	if ( err < 0 )
		{
		while ( ( err = ErrDIRIPrevItem( pfucb ) ) < 0 )
			{
			Assert( err == errNDNoItem || err == errNDFirstItemNode );
			/*	move to previous node with DIB constraints
			/**/
			Call ( ErrBTPrev( pfucb, pdib ) );
	
			DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

			/*	if on new item list, then set bookmark from
			/*	first item list node.
			/**/
			DIRICheckLastSetItemList( pfucb );
			err = ErrNDLastItem( pfucb );
			if ( err == JET_errSuccess )
				break;
			}
		}

	/*	if posDown then set status.
	/**/
	Assert( err == JET_errSuccess );
	if ( pdib->pos == posDown )
		{
		s = CmpStKey( StNDKey( pssib->line.pb ), pdib->pkey );
		if ( s == 0 )
			err = JET_errSuccess;
		else
			err = ErrERRCheck( s < 0 ? wrnNDFoundLess : wrnNDFoundGreater );
		}

HandleError:
	if ( err == JET_errNoCurrentRecord )
		err = ErrERRCheck( JET_errRecordNotFound );
	return err;
	}

/*	delete item node that is neither first or last
/*	returns wrnBMConflict if there is a conflict
/**/

ERR	ErrDIRDeleteItemNode( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	SRID	*psrid;
	
	CallR( ErrDIRRefresh( pfucb ) );
	Assert( !FNDVersion( *( pfucb->ssib.line.pb ) ) );
	Assert( !FNDFirstItem( *( pfucb->ssib.line.pb ) ) );
	Assert( !FNDLastItem( *( pfucb->ssib.line.pb ) ) );

		//	check that there is only one item and it is flagged delete
		
	Assert( pfucb->lineData.cb == sizeof( SRID ) );	
	psrid = (SRID *) pfucb->lineData.pb;

	if ( FNDItemDelete( * ( (SRID UNALIGNED *) psrid ) ) )
		{
		NDSetDeleted( *( pfucb->ssib.line.pb ) );

		CallS( ErrNDDeleteNode( pfucb ) );
		}
	else
		{
			// some other thread inserted same item
			// added for debug purposes
		Assert( fTrue );
		}

	return err;
	}


#if 0
	// removed for stability reasons

/*	Deletes item node that is either first or last
/*	enters critSplit, so split does not reorganize page during this time
/*	latches all buffers required, so no other user can read inconsistent data
/*	( since the changes are not versioned ).
/**/
LOCAL ERR ErrDIRIDeleteEndItemNode( FUCB *pfucb, BOOL fFirstItem, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr = PcsrCurrent( pfucb );
	DIB		dib;
	BYTE 	bHeader;
	PGNO 	pgnoItem;
	BF	 	*pbfLatched;
	BF	 	*pbfSibling = pbfNil;
	
	/*	operations should not be versioned
	/**/
	Assert( !( fFlags & fDIRVersion ) );

	do
		{
Start:
		pbfSibling = pbfNil;
		LgLeaveCriticalSection( critJet );
		EnterNestableCriticalSection( critSplit );
		LgEnterCriticalSection( critJet );

		/*	check currency and refresh if necessary.
		/**/
		CallJ( ErrDIRRefresh( pfucb ), LeaveCritSplit );
		pgnoItem = pcsr->pgno;

		/* wait latch current page
		/**/
		AssertFBFReadAccessPage( pfucb, pgnoItem );
		pbfLatched = pfucb->ssib.pbf;
		if ( FBFWriteLatchConflict( pfucb->ppib, pbfLatched ) )
			{
			LeaveNestableCriticalSection( critSplit );
			goto Start;
			}
		BFSetWaitLatch( pbfLatched, pfucb->ppib );

		/*	if next/prev item node is on different page,
		/*	latch adjacent page
		/**/
		dib.fFlags = fDIRNull;
		if ( fFirstItem )
			{
			Call( ErrBTNext( pfucb, &dib ) );
			}
		else
			{
			Call( ErrBTPrev( pfucb, &dib ) );
			}

		if ( pcsr->pgno != pgnoItem )
			{
			Call( ErrBFWriteAccessPage( pfucb, pcsr->pgno ) );
			pbfSibling = pfucb->ssib.pbf;
			if ( FBFWriteLatchConflict( pfucb->ppib, pbfSibling ) )
				{
				BFResetWaitLatch( pbfLatched, pfucb->ppib );
				LeaveNestableCriticalSection( critSplit );
				goto Start;
				}
			
			BFSetWaitLatch( pbfSibling, pfucb->ppib );
			}

		/* go back page of deleted item and delete item node
		/**/
		Assert( dib.fFlags == fDIRNull );
		if ( fFirstItem )
			{
			CallS( ErrBTPrev( pfucb, &dib ) );
			}
		else
			{
			CallS( ErrBTNext( pfucb, &dib ) );
			}

		Call( ErrBTDelete( pfucb, fFlags ) );

		/*	make next/prev item list node new first/last item node
		/**/
		dib.fFlags = fDIRNull;
		if ( fFirstItem )
			{
			CallS( ErrBTNext( pfucb, &dib ) );
			}
		else
			{
			CallS( ErrBTPrev( pfucb, &dib ) );
			}

		CallS( ErrBTGet( pfucb, pcsr ) );
		bHeader = *pfucb->ssib.line.pb;
		if ( fFirstItem )
			NDSetFirstItem( bHeader );
		else
			NDSetLastItem( bHeader );

		//	UNDONE:	handle error from logging here
		CallS( ErrNDSetNodeHeader( pfucb, bHeader ) );

HandleError:
		if ( pbfSibling != pbfNil )
			{
			BFResetWaitLatch( pbfSibling, pfucb->ppib );
			}
		BFResetWaitLatch( pbfLatched, pfucb->ppib );
	
LeaveCritSplit:
		LeaveNestableCriticalSection(critSplit);
		}
	while ( err == errDIRNotSynchronous );

	return err;
	}

#endif		// 0

ERR ErrDIRICheckIndexRange( FUCB *pfucb )
	{
	ERR		err;

	AssertNDGetKey( pfucb, PcsrCurrent( pfucb )->itag );

	err = ErrFUCBCheckIndexRange( pfucb );
	if ( err == JET_errNoCurrentRecord )
		{
		if ( FFUCBUpper( pfucb ) )
			{
			DIRAfterLast( pfucb );
			}
		else
			{
			DIRBeforeFirst( pfucb );
			}
		}

	return err;
	}


#if 0
VOID DIRISaveOLCStats( FUCB *pfucb )
	{
	ERR  	err;
	LINE	line;
	DIB		dib;
	BOOL	fNonClustered = FFUCBNonClustered( pfucb );

	/*	release unneeded CSRs
	/**/
	if ( pfucb->pcsr != pcsrNil )
		{
		while ( pfucb->pcsr->pcsrPath != pcsrNil )
			{
			FUCBFreeCSR( pfucb );
			}
		}

	if ( !FFCBOLCStatsAvail( pfucb->u.pfcb ) )
		return;

	/* go to ../file/some_file/OLCStats
	/**/
	FUCBResetNonClustered( pfucb );
	DIRGotoFDPRoot( pfucb );

	dib.fFlags = fDIRNull;
	dib.pos = posDown;
	dib.pkey = pkeyOLCStats,
	err = ErrDIRDown( pfucb, &dib );
	Assert( err != JET_errRecordNotFound );
	if ( err != JET_errSuccess )
		{
		if ( err > 0 )
			{
			DIRUp( pfucb, 1 );
			err = ErrERRCheck( JET_errDatabaseCorrupted );
			}
		Error( err, HandleError );
		}

	/* replace existing data with pfcb->olcstats, if it has changed
	/**/
	if ( fOLCompact && FFCBOLCStatsChange( pfucb->u.pfcb ) )
		{
		line.pb = (BYTE *) &pfucb->u.pfcb->olc_data;
		line.cb = sizeof(P_OLC_DATA);

		Call( ErrDIRBeginTransaction( pfucb->ppib ) );
		err = ErrDIRReplace( pfucb, &line, fDIRNoVersion );
		if ( err >= JET_errSuccess )
			err = ErrDIRCommitTransaction( pfucb->ppib, JET_bitCommitLazyFlush );
		if ( err < 0 )
			{
			CallS( ErrDIRRollback( pfucb->ppib ) );
			}
		else
			{
			FCBResetOLCStatsChange( pfucb->u.pfcb );
			}
		}

HandleError:
	if ( fNonClustered )
		{
		FUCBSetNonClustered( pfucb );
		}
	return;
	}
#endif		// 0


VOID DIRIUp( FUCB *pfucb, INT ccsr )
	{
	CheckFUCB( pfucb->ppib, pfucb );
	CheckCSR( pfucb );
	Assert( ccsr > 0 );
	
	while ( PcsrCurrent( pfucb ) != pcsrNil && ccsr > 0 )
		{
		ccsr--;
		FUCBFreeCSR( pfucb );
		}

	/*	set currency.
	/**/
	Assert( ccsr == 0 );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	DIRSetRefresh( pfucb );

	/* set sridFather
	/**/
	{
	CSRSTAT		csrstat = PcsrCurrent( pfucb )->csrstat;
	if ( ( csrstat == csrstatOnFDPNode || csrstat == csrstatOnCurNode )
		 && PcsrCurrent( pfucb )->pcsrPath != pcsrNil )
		{
		pfucb->sridFather = PcsrCurrent( pfucb )->pcsrPath->bm;
		Assert( pfucb->sridFather != sridNull );
		Assert( pfucb->sridFather != sridNullLink );
		}
	else
		{
		pfucb->sridFather = sridNull;
		}
	}

	CheckCSR( pfucb );
	return;
	}


/******************** DIR API Routines ********************
/**********************************************************
/**/
ERR ErrDIROpen( PIB *ppib, FCB *pfcb, DBID dbid, FUCB **ppfucb )
	{	
	ERR		err;
	FUCB 	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	if ( !fRecovering && fSTInit == fSTInitDone )
		{
		CheckDBID( ppib, dbid );
		}
#endif

	/*	canabalize deferred closed cursor
	/**/
	for ( pfucb = ppib->pfucb;
		pfucb != pfucbNil;
		pfucb = pfucb->pfucbNext )
		{
		if ( FFUCBDeferClosed(pfucb) && !FFUCBNotReuse(pfucb) )
			{
			Assert( pfucb->u.pfcb != pfcbNil );
			if ( ( pfucb->u.pfcb == pfcb ) ||
				( pfcb == pfcbNil &&
				pfucb->u.pfcb->dbid == dbid &&
				pfucb->u.pfcb->pgnoFDP == pgnoSystemRoot ) )
				{
				Assert( ppib->level > 0 );
				Assert( pfucb->levelOpen <= ppib->level );
				FUCBResetDeferClose(pfucb);
				
				// UNDONE: integrate this with ErrFUCBOpen
				
				/*	Reset all used flags. Keep Updatable (fWrite) flag
				 */
				pfucb->ulFlags = 0;

				if ( FDBIDReadOnly( dbid ) )
					FUCBResetUpdatable(pfucb);
				else
					FUCBSetUpdatable(pfucb);
				goto GotoRoot;
				}
			}
		}

	err = ErrFUCBOpen( ppib, (DBID) (pfcb != pfcbNil ? pfcb->dbid : dbid), &pfucb );
	if ( err < 0 )
		{
		DIRAPIReturn( pfucbNil, err );
		}

	/*	link FCB
	/**/
	if ( pfcb == pfcbNil )
		{
		pfcb = PfcbFCBGet( dbid, pgnoSystemRoot );
		if ( pfcb == pfcbNil )
			Call( ErrFCBNew( ppib, dbid, pgnoSystemRoot, &pfcb ) );
		}
	FCBLink( pfucb, pfcb );

GotoRoot:
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	/*	initialize cursor location to root of domain.
	/*	set currency.  Note, that no line can be cached
	/*	since this domain may not yet exist in page format.
	/**/
	PcsrCurrent( pfucb )->csrstat = csrstatOnFDPNode;
	PcsrCurrent( pfucb )->bm =
		SridOfPgnoItag( PgnoFDPOfPfucb( pfucb ), itagFOP );
	PcsrCurrent( pfucb )->pgno = PgnoFDPOfPfucb( pfucb );
	PcsrCurrent( pfucb )->itag = itagFOP;
	PcsrCurrent( pfucb )->itagFather = itagFOP;
	Assert( !FCSRInvisible( PcsrCurrent( pfucb ) ) );
	pfucb->sridFather = sridNull;
	DIRSetRefresh( pfucb );

	/*	set return pfucb
	/**/
	*ppfucb = pfucb;
	DIRAPIReturn( pfucb, JET_errSuccess );

HandleError:
	FUCBClose( pfucb );
	DIRAPIReturn( pfucbNil, err );
	}


VOID DIRClose( FUCB *pfucb )
	{
	/*	this cursor should not be already defer closed
	/**/
	Assert( fRecovering || !FFUCBDeferClosed(pfucb) );

	/*	release key buffer if one was allocated.
	/**/
	if ( pfucb->pbKey != NULL )
		{
		LFree( pfucb->pbKey );
		pfucb->pbKey = NULL;
		}

	/*	if cursor created version then deferred close until transaction
	/*	level 0, for rollback support.
	/*	During recovery, close only used when absolutely need to close
	/*	cursor for detach.
	/**/
	if ( ( pfucb->ppib->level > 0 ) && ( FFUCBVersioned( pfucb ) ) )
		{
		Assert( pfucb->u.pfcb != pfcbNil );
		DIRIPurgeParent( pfucb );
		FUCBSetDeferClose( pfucb );
		Assert( PcsrCurrent( pfucb ) );
		CSRResetInvisible( PcsrCurrent( pfucb ) );
		}
	else
		{
		if ( FFUCBDenyRead( pfucb ) )
			FCBResetDomainDenyRead( pfucb->u.pfcb );
		if ( FFUCBDenyWrite( pfucb ) )
			FCBResetDomainDenyWrite( pfucb->u.pfcb );

		//	UNDONE:	find better way to write statistics info
		//			since loss of critJet can cause faults
		//			in FCB/FUCB linkage due to race conditions.
//		// If last reference to fcb, save the OLCStats info
//		if ( pfucb->u.pfcb->wRefCnt == 1 )
//			{
//			DIRISaveOLCStats( pfucb );
//			}

		FCBUnlink( pfucb );
		FUCBClose( pfucb );
		}
	}


ERR ErrDIRDown( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	CSR		**ppcsr = &PcsrCurrent( pfucb );
	SRID	sridFatherSav = pfucb->sridFather;
#ifdef DEBUG
	ULONG	ctimes = 0;
#endif

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( *ppcsr != pcsrNil );
	Assert( pdib->pos == posFirst ||
		pdib->pos == posLast ||
		pdib->pos == posDown );

#ifdef PREREAD
	/* clear preread statistics
	/**/	
	FUCBResetPrereadCount( pfucb );
#endif	// PREREAD

	/*	set cursor navigation level for rollback support
	/**/
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

Start:
#ifdef DEBUG
	ctimes++;
	Assert( ctimes < 10 );
#endif

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );

	switch( (*ppcsr)->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatOnFDPNode:
		case csrstatOnDataRoot:
			break;
		default:
			Assert( (*ppcsr)->csrstat == csrstatBeforeCurNode ||
				(*ppcsr)->csrstat == csrstatAfterCurNode ||
				(*ppcsr)->csrstat == csrstatBeforeFirst ||
				(*ppcsr)->csrstat == csrstatAfterLast );
			DIRAPIReturn( pfucb, ErrERRCheck( JET_errNoCurrentRecord ) );
		}

	/* save current node as visible father
	/**/
	pfucb->sridFather = (*ppcsr)->bm;

	/*	down to node
	/**/
	Call( ErrBTDown( pfucb, pdib ) );
	/*	case where the first item node has been moved elsewhere
	/**/
	if ( FFUCBNonClustered( pfucb )
		&& pdib->pos == posDown
		&& !FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
		{
		BTUp( pfucb );
		BFSleep( cmsecWaitGeneric );
		goto Start;
		}
	NDGetNode( pfucb );

	/*	handle key found case on non-clustered index before
	/*	status handling, since absence of valid items
	/*	may change case.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	if posLast, then move to last item.  If posFirst,
		/*	or posDown, then move to first item.
		/**/
		if ( err == JET_errSuccess )
			{
			if ( pdib->pos == posLast )
				{
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRISetItemListFromLast( pfucb );
				err = ErrNDLastItem( pfucb );
				}
			else
				{
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRISetItemListFromFirst( pfucb );
				err = ErrNDFirstItem( pfucb );
				}

			/*	if items not there, then go next previous
			/*	depending on DIB.  If no valid item found, then
			/*	discard leaf CSR and fail down operation.
			/**/
			if ( err != JET_errSuccess )
				{
				err = ErrDIRIDownAdjust( pfucb, pdib );
				if ( err < 0 )
					{
					if ( PcsrCurrent(pfucb)->pcsrPath )
						BTUp( pfucb );
					goto HandleError;
					}
				}
			}
		else
			{
			/*	set item list descriptor for subsequent ver
			/*	operations.
			/**/
			DIRISetItemListFromLast( pfucb );
			(VOID)ErrNDFirstItem( pfucb );
			}
		}
	else
		{
		/*	must store bookmark for currency.
		/**/
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	/*	set status depending on search findings.
	/**/
	switch( err )
		{
		case JET_errSuccess:

			(*ppcsr)->csrstat = csrstatOnCurNode;

			// No more navigation between FDP's.  FDP pointer nodes also
			// eliminated.
			Assert( !FNDFDPPtr( *pfucb->ssib.line.pb ) );
			break;

		case wrnNDFoundLess:
			(*ppcsr)->csrstat = csrstatAfterCurNode;
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there.
				/**/
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				(VOID)ErrNDLastItem( pfucb );
				}
			break;

		default:
			Assert( err == wrnNDFoundGreater );
			(*ppcsr)->csrstat = csrstatBeforeCurNode;
			/*	isrid value could be any valid item
			/*	in node with key greater than seek key.
			/**/
			break;
		}

	if ( pdib->fFlags & fDIRPurgeParent )
		{
		DIRIPurgeParent( pfucb );
		}

	DIRSetFresh( pfucb );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );

HandleError:
	/*	reinstate sridFather
	/**/
	pfucb->sridFather = sridFatherSav;
	CheckCSR( pfucb );
	Assert( err != JET_errNoCurrentRecord );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDownFromDATA( FUCB *pfucb, KEY *pkey )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );

#ifdef PREREAD
	/* clear preread statistics
	/**/	
	FUCBResetPrereadCount( pfucb );
#endif	// PREREAD

	/*	set cursor navigation level for rollback support
	/**/
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	/*	down to node
	/**/
	Call( ErrBTDownFromDATA( pfucb, pkey ) );
	NDGetNode( pfucb );

	/*	set to first item
	/**/
	PcsrCurrent( pfucb )->isrid = 0;

	/*	handle key found case on non-clustered index before
	/*	status handling, since absence of valid items
	/*	may change case.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	if posLast, then move to last item.  If posFirst,
		/*	or posDown, then move to first item.
		/**/
		if ( err == JET_errSuccess )
			{
			/*	set item list descriptor for subsequent ver
			/*	operations.
			/**/
			DIRISetItemListFromFirst( pfucb );
			err = ErrNDFirstItem( pfucb );

			/*	if items not there, then go next item.
			/*	If no valid item found, then set currency to
			/*	before first.
			/**/
			if ( err != JET_errSuccess )
				{
				DIB	dibT;

				dibT.fFlags = fDIRNull;
				dibT.pos = posDown;
				dibT.pkey = pkey;
				Call( ErrDIRIDownAdjust( pfucb, &dibT ) );
				}
			}
		else
			{
			/*	set item list descriptor for subsequent ver
			/*	operations.
			/**/
			DIRISetItemListFromLast( pfucb );
			(VOID)ErrNDFirstItem( pfucb );
			}
		}
	else
		{
		/*	must store bookmark for currency.
		/**/
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	/*	set status depending on search findings.
	/**/
	switch( err )
		{
		case JET_errSuccess:
			PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
			Assert( !FNDFDPPtr( *pfucb->ssib.line.pb ) );
			break;

		case wrnNDFoundLess:
			PcsrCurrent( pfucb )->csrstat = csrstatAfterCurNode;
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there.
				/**/
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				(VOID)ErrNDLastItem( pfucb );
				}
			break;

		default:
			Assert( err == wrnNDFoundGreater );
			PcsrCurrent( pfucb )->csrstat = csrstatBeforeCurNode;
			/*	isrid value could be any valid item
			/*	in node with key greater than seek key.
			/**/
			break;
		}

	Assert( PcsrCurrent( pfucb )->pcsrPath == pcsrNil );

	DIRSetFresh( pfucb );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );

HandleError:
	CheckCSR( pfucb );
	Assert( err != JET_errNoCurrentRecord );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDownKeyBookmark( FUCB *pfucb, KEY *pkey, SRID srid )
	{
	ERR		err;
	DIB		dib;
	CSR		*pcsr;
	CSR		*pcsrRoot = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	SRID	sridFatherSav = pfucb->sridFather;
#ifdef DEBUG
	INT		ctimes = 0;
#endif

	/*	this routine should only be called with non-clustered indexes.
	/**/
	Assert( FFUCBNonClustered( pfucb ) );

#ifdef PREREAD
	/* clear preread statistics
	/**/	
	FUCBResetPrereadCount( pfucb );
#endif	// PREREAD

	/*	set cursor navigation level for rollback support
	/**/
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	/*	check currency and refresh if necessary.
	/**/
Start:
#ifdef DEBUG
	ctimes++;
	Assert( ctimes < 10 );
#endif
	Assert( pfucb->pcsr->csrstat != csrstatDeferMoveFirst );
	CallR( ErrDIRRefresh( pfucb ) );

	/* save current node as visible father
	/**/
	pfucb->sridFather = pcsrRoot->bm;

	/*	item list nodes not versioned.
	/**/
	dib.fFlags = fDIRItemList;
	dib.pos = posDown;
	dib.pkey = pkey;
	Call( ErrBTDown( pfucb, &dib ) );
	Assert( err == JET_errSuccess );
	/*	case where the first item node has been moved elsewhere
	/**/
	if ( FFUCBNonClustered( pfucb )
		&& dib.pos == posDown
		&& !FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
		{
		BTUp( pfucb );
		BFSleep( cmsecWaitGeneric );
		goto Start;
		}

	LgHoldCriticalSection( critJet );

	/*	set currency to on item list and get item list in node data.
	/**/
	pcsr = PcsrCurrent( pfucb );
	pcsr->csrstat = csrstatOnCurNode;
	DIRIGetItemList( pfucb, pcsr );

	/*	set item list descriptor for subsequent ver
	/*	operations.
	/**/
	DIRISetItemListFromFirst( pfucb );

	LgReleaseCriticalSection( critJet );

	while ( ( err = ErrNDSeekItem( pfucb, srid ) ) == errNDGreaterThanAllItems )
		{
		Assert( !FNDLastItem( *pssib->line.pb ) );
		Call( ErrBTNextPrev( pfucb, pcsr, fTrue, &dib, NULL ) );
		DIRIGetItemList( pfucb, pcsr );
		}

	Assert( err == wrnNDDuplicateItem );
	Assert( pcsr->csrstat == csrstatOnCurNode );

	//	UNDONE:	remove this code when bug fixed
	if ( err != wrnNDDuplicateItem )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		goto HandleError;
		}

	/*	set item currency.
	/**/
	pcsr->item = srid;

	/*	always purge parent.
	/**/
	DIRIPurgeParent( pfucb );

	DIRSetFresh( pfucb );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, JET_errSuccess );

HandleError:
	/*	reinstate sridFather
	/**/
	pfucb->sridFather = sridFatherSav;
	DIRIUpToCSR( pfucb, pcsrRoot );
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


VOID DIRUp( FUCB *pfucb, INT ccsr )
	{
	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

#ifdef PREREAD
	/* clear preread statistics
	/**/	
	FUCBResetPrereadCount( pfucb );
#endif	// PREREAD
	
	/*	set cursor navigation level for rollback support
	/**/
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	DIRIUp( pfucb, ccsr );

	CheckCSR( pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	return;
	}


//+api
//	ERR ErrDIRNext( FUCB pfucb, DIB *pdib )
//
//	PARAMETERS
//		pfucb		 		cursor
//		pdib.pkey			key
//		pdib.fFlags
//		fDIRInPage			move to node/item of same page
//		fDIRNeighborKey		move to node/item of different key
//
//		RETURNS
//
//		err code					bottom CSR status
//		---------------------------------------------------
//		JET_errSuccess				OnCurNode
//		JET_errNoCurrentRecord		AfterLast
//		JET_errPageBoundary			AfterCurNode
//		JET_errKeyBoundary			AfterCurNode
//		errDIRFDP					OnFDPNode
//
//		COMMENTS
//
//		for negative return code, CSR status is unchanged
//-
ERR ErrDIRNext( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;
	CSR		*pcsr;
	KEY		key;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	set cursor navigation level for rollback support
	/**/
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent(pfucb);

	/*	switch action based on CSR status
	/**/
	switch( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatAfterCurNode:
			/*	get next item
			/**/
			break;

		case csrstatBeforeCurNode:
			/*	if non-clustered index then get first item.  If no item
			/*	then break to go to next item in next node.
			/**/
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there.
				/**/
				DIRIGetItemList( pfucb, pcsr );

				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckFirstSetItemList( pfucb );
				err = ErrNDFirstItem( pfucb );
				if ( err != JET_errSuccess )
					break;
				}
			else
				{
				/*	get current node.  If node is deleted, then break
				/*	to move to next node.
				/**/
				err = ErrBTGetNode( pfucb, pcsr );
				if ( err < 0 )
					{
					if ( err == JET_errRecordDeleted )
						break;
					goto HandleError;
					}
				}

			/*	set currency on current
			/**/
			pcsr->csrstat = csrstatOnCurNode;

			DIRSetFresh( pfucb );
			DIRAPIReturn( pfucb, err );

		case csrstatAfterLast:
			DIRAPIReturn( pfucb, ErrERRCheck( JET_errNoCurrentRecord ) );

		case csrstatOnFDPNode:
			// Lateral movement across FDP's no longer supported.
			Assert(0);
			break;

		default:
			{
			DIB	dib;
			Assert( pcsr->csrstat == csrstatBeforeFirst );

			/*	move to root.
			/**/
			DIRGotoDataRoot( pfucb );
			dib.fFlags = fDIRPurgeParent;
			dib.pos = posFirst;
			err = ErrDIRDown( pfucb, &dib );
			if ( err < 0 )
				{
				/*	retore currency.
				/**/
				DIRBeforeFirst( pfucb );

				/*	polymorph error code.
				/**/
				if ( err == JET_errRecordNotFound )
					err = ErrERRCheck( JET_errNoCurrentRecord );
				}

			DIRAPIReturn( pfucb, err );
			}
		}

	/*	setup dib key
	/**/
	if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
		{
		/*	get current node, which may no longer be there for us.
		/**/
		Call( ErrDIRICopyKey( pfucb, &key ) );
		pdib->pkey = &key;
		}

	/*	if non-clustered index, move to next item.  If on last item,
	/*	move to first item of next node else move to next node.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

		/*	item list nodes not versioned.
		/**/
		pdib->fFlags |= fDIRItemList;

		/*	if neighbor key set then move to first item of next neighbor key
		/*	node, else, move to next item.  If node is deleted then move to
		/*	first item of next node.
		/**/
		if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
			{
			do
				{
				err = ErrBTNext( pfucb, pdib );
				/*	handle no next node such that DIB preserved.
				/**/
				if ( err < 0 )
					{
					pdib->fFlags |= fDIRNeighborKey;
					Call( err );
					}
				/*	must be on first item list node
				/**/
				Assert( !( pdib->fFlags & fDIRNeighborKey ) || FNDFirstItem( *pfucb->ssib.line.pb ) );

				/*	must reset flag so can stop on item list nodes
				/*	in item list interior which have items while
				/*	other nodes have no items.  After stop then
				/*	reset DIB to initial state.
				/**/
				pdib->fFlags &= ~fDIRNeighborKey;
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckFirstSetItemListAndWarn( pfucb, wrn );
				err = ErrNDFirstItem( pfucb );
				/*	first item was not there, check for item there
				/*	later in same item list node.
				/**/
				if ( err != JET_errSuccess )
					err = ErrDIRINextItem( pfucb );
				}
			while ( err != JET_errSuccess );
			pdib->fFlags |= fDIRNeighborKey;
			}
		else
			{
			/*	non-clustered index nodes are always there.
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRIGetItemList( pfucb, pcsr );

			/*	move to next item and next node until item found.
			/**/
			while ( ( err = ErrDIRINextItem( pfucb ) ) < 0 )
				{
				Assert( err == errNDNoItem || err == errNDLastItemNode );
				/*	move to next node with DIB constraints
				/**/
				Call( ErrBTNext( pfucb, pdib ) );
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckFirstSetItemListAndWarn( pfucb, wrn );
				err = ErrNDFirstItem( pfucb );
				if ( err == JET_errSuccess )
					{
					break;
					}
				}
			}
		}
	else
		{
		/*	return warning if key changed
		/**/
		wrn = ErrERRCheck( JET_wrnKeyChanged );

		Call( ErrBTNext( pfucb, pdib ) );
		NDGetNode( pfucb );
		
		// No more TABLES or INDEXES subtrees.  Thus, no more
		// concept of next/prev FDP.
		Assert( !FNDFDPPtr( *pfucb->ssib.line.pb ) );
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

#ifdef PREREAD
	//	are we already reading forward?
	if ( !FFUCBPrereadForward( pfucb ) )
		{
		//	we are reversing direction
		FUCBResetPrereadCount( pfucb );
		Assert( IFUCBPrereadCount( pfucb ) == 0 );
		FUCBSetPrereadForward( pfucb );
		}
	FUCBIncrementPrereadCount( pfucb, pfucb->ssib.line.cb );
	Assert( FFUCBPrereadForward( pfucb ) );
#endif	// PREREAD		

	/*	check index range
	/**/
	if ( FFUCBLimstat( pfucb ) && FFUCBUpper( pfucb ) && err == JET_errSuccess )
		{
		Call( ErrDIRICheckIndexRange( pfucb ) );
		}

	DIRSetFresh( pfucb );
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRPrev( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;
	CSR		*pcsr;
	KEY		key;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	set cursor navigation level for rollback support
	/**/
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent(pfucb);

	/*	switch action based on CSR status
	/**/
	switch( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatBeforeCurNode:
			/*	get next item
			/**/
			break;

		case csrstatAfterCurNode:
			/*	if non-clustered index then get current item.  If no item
			/*	then break to go to previous item in next node.
			/**/
			if ( FFUCBNonClustered( pfucb ) )
				{
				/*	non-clustered index nodes are always there
				/**/
				DIRIGetItemList( pfucb, pcsr );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRISetItemListFromLast( pfucb );
				err = ErrNDGetItem( pfucb );
				if ( err != JET_errSuccess )
					break;
				}
			else
				{
				/*	get current node.  If node is deleted, then break
				/*	to move to next node.
				/**/
				err = ErrBTGetNode( pfucb, pcsr );
				if ( err < 0 )
					{
					if ( err == JET_errRecordDeleted )
						break;
					goto HandleError;
					}
				}

			/*	set currency on current
			/**/
			pcsr->csrstat = csrstatOnCurNode;

			DIRSetFresh( pfucb );
			DIRAPIReturn( pfucb, err );

		case csrstatBeforeFirst:
			DIRAPIReturn( pfucb, ErrERRCheck( JET_errNoCurrentRecord ) );

		case csrstatOnFDPNode:
			// Lateral movement across FDP's no longer supported.
			Assert(0);
			break;

		default:
			{
			DIB dib;

			Assert( pcsr->csrstat == csrstatAfterLast );

			/*	move up preserving currency in case down fails.
			/**/
			DIRGotoDataRoot( pfucb );
			dib.fFlags = fDIRPurgeParent;
			dib.pos = posLast;
			err = ErrDIRDown( pfucb, &dib );
			if ( err < 0 )
				{
				/*	restore currency.
				/**/
				DIRAfterLast( pfucb );

				/*	polymorph error code.
				/**/
				if ( err == JET_errRecordNotFound )
					err = ErrERRCheck( JET_errNoCurrentRecord );
				}
			DIRAPIReturn( pfucb, err );
			}
		}

	/*	setup dib key
	/**/
	if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
		{
		/*	get current node, which may no longer be there for us.
		/**/
		Call( ErrDIRICopyKey( pfucb, &key ) );
		pdib->pkey = &key;
		}

	/*	if non-clustered index, move to previous item
	/*	if on first item, move to last item of previous node
	/*	else move to previous node
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

		/*	item list nodes not versioned.
		/**/
		pdib->fFlags |= fDIRItemList;

		/*	if neighbor key then move to last item of previous neighbor key
		/*	node, else move to previous item.  If current node deleted, then
		/*	move to previous node.
		/**/
		if ( ( pdib->fFlags & fDIRNeighborKey ) != 0 )
			{
			do
				{
				/*	handle no prev node such that DIB preserved
				/**/
				err = ErrBTPrev( pfucb, pdib );
				if ( err < 0 )
					{
					pdib->fFlags |= fDIRNeighborKey;
					Call( err );
					}

				/*	must be last item list node
				/**/
				Assert( !( pdib->fFlags & fDIRNeighborKey ) || FNDLastItem( *pfucb->ssib.line.pb ) );

				/*	must reset flag so can stop on item list nodes
				/*	in item list interior which have items while
				/*	other nodes have no items.  After stop then
				/*	reset DIB to initial state.
				/**/
				pdib->fFlags &= ~fDIRNeighborKey;

				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckLastSetItemListAndWarn( pfucb, wrn );
				err = ErrNDLastItem( pfucb );
				/*	last item was not there, check for item there
				/*	earlier in same item list node.
				/**/
				if ( err != JET_errSuccess )
					err = ErrDIRIPrevItem( pfucb );
				}
			while ( err != JET_errSuccess );
			pdib->fFlags |= fDIRNeighborKey;
			}
		else
			{
			/*	non-clustered index nodes are always there.
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRIGetItemList( pfucb, pcsr );

			while ( ( err = ErrDIRIPrevItem( pfucb ) ) < 0 )
				{
				Assert( err == errNDNoItem || err == errNDFirstItemNode );
				/*	move to previous node with DIB constraints
				/**/
				Call( ErrBTPrev( pfucb, pdib ) );
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				/*	set item list descriptor for subsequent ver
				/*	operations.
				/**/
				DIRICheckLastSetItemListAndWarn( pfucb, wrn );
				err = ErrNDLastItem( pfucb );
				if ( err == JET_errSuccess )
					{
					break;
					}
				}
			}
		}
	else
		{
		/*	return warning if key changed
		/**/
		wrn = ErrERRCheck( JET_wrnKeyChanged );
		Call( ErrBTPrev( pfucb, pdib ) );
 		NDGetNode( pfucb );
		
		// No more TABLES or INDEXES subtrees.  Thus, no more
		// concept of next/prev FDP.
		Assert( !FNDFDPPtr( *pfucb->ssib.line.pb ) );
		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

#ifdef PREREAD
	//	are we already reading forward?
	if ( !FFUCBPrereadForward( pfucb ) )
		{
		//	we are reversing direction
		FUCBResetPrereadCount( pfucb );
		Assert( IFUCBPrereadCount( pfucb ) == 0 );
		FUCBSetPrereadForward( pfucb );
		}
	FUCBIncrementPrereadCount( pfucb, pfucb->ssib.line.cb );
	Assert( FFUCBPrereadForward( pfucb ) );

#endif	// PREREAD		

	/*	check index range.  If exceed range, then before first, disable
	/*	range and return no current record.
	/**/
	if ( FFUCBLimstat( pfucb ) && !FFUCBUpper( pfucb ) && err == JET_errSuccess )
		{
		Call( ErrDIRICheckIndexRange( pfucb ) );
		}

	DIRSetFresh( pfucb );
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRCheckIndexRange( FUCB *pfucb )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	/*	get keyNode for check index range
	/**/
	Call( ErrDIRGet( pfucb ) );
	Call( ErrDIRICheckIndexRange( pfucb ) );

	DIRSetFresh( pfucb );
HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRInsert( FUCB *pfucb, LINE *pline, KEY *pkey, INT fFlags )
	{
	ERR		err;
	CSR		*pcsrRoot;
	DIB		dib;
	BOOL	fCleaned = fFalse;
	
#ifdef DEBUG
	INT		ctimes = 0;
#endif

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	set cursor navigation level for rollback support
	/**/
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

Start:
#ifdef DEBUG
	ctimes++;
//	Assert( ctimes < 50 );
#endif
	/* save current node as visible father
	/**/
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	Assert( PcsrCurrent( pfucb )->csrstat != csrstatDeferMoveFirst );
	pcsrRoot = PcsrCurrent( pfucb );
	pfucb->sridFather = pcsrRoot->bm;
	Assert( pfucb->sridFather != sridNull );
	Assert( pfucb->sridFather != sridNullLink );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );

	if ( FFUCBNonClustered( pfucb ) )
		{
		SRID	srid;
		INT		cbReq;
		SSIB	*pssib = &pfucb->ssib;

		/*	get given item
		/**/
		Assert( pline->cb == sizeof(SRID) );
		srid = *(SRID UNALIGNED *) pline->pb;

		/*	seek first item list node with given key.  Allow duplicate nodes
		/*	even if non-clustered index does not allow duplicate key items
		/*	since node may contain item list with all deleted items.
		/**/
		err = ErrBTSeekForUpdate( pfucb, pkey, 0, 0, fDIRDuplicate | fDIRReplaceDuplicate | fFlags );

		switch ( err )
			{
			case JET_errSuccess:
				{
				/*	seek for update does not cache line pointers.
				/*	We need this information for item insertion.
				/**/
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

		 		/*	if versioning then get bookmark of first item list
				/*	node to hash item versions.
				/**/
				if ( fFlags & fDIRVersion )
					{
					SRID	bmItemList;

					/*	if node is not first item list node then
					/*	reseek to first item list node.  In this way,
					/*	thrashing across many duplicate index entries.
					/**/
					if ( !FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
						{
#ifdef	DEBUG
						ULONG	ctimes = 0;
#endif
						/*	go up to root, and reseek to begining of item list node list
						/**/
						DIRIUpToCSR( pfucb, pcsrRoot );
						dib.fFlags = fDIRNull;
						dib.pos = posDown;
						dib.pkey = pkey;
Refresh1:
#ifdef	DEBUG
						ctimes++;
						Assert( ctimes < 10 );
#endif
						Call( ErrBTGet( pfucb, PcsrCurrent( pfucb ) ) );
						Call( ErrBTDown( pfucb, &dib ) );
						/*	case where the first item node has been moved elsewhere
						/**/
						Assert( FFUCBNonClustered( pfucb )
							&& dib.pos == posDown );
						if ( !FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
							{
							BTUp( pfucb );
							BFSleep( cmsecWaitGeneric );
							Call( ErrDIRRefresh( pfucb ) );
							goto Refresh1;
							}
						DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
						}

					/*	set item list descriptor for subsequent ver operations
					/**/
					DIRISetItemListFromFirst( pfucb );
					bmItemList = PcsrCurrent( pfucb )->bm;

					/*	if duplicates are not allowed then check for duplicate
					/**/
					if ( !( fFlags & fDIRDuplicate ) )
						{
						Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );
					
						/*	check for duplicate key
						/**/
						Call( ErrDIRIKeyDuplicate( pfucb ) );
						Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
						}
					else if ( !FNDLastItem( *( pfucb->ssib.line.pb ) ) )
						{
						/*	now go back to end of item list node list and seek for
						/*	insertion point, which is more likely to be at
						/*	end of list.  Note that during this time, all items
						/*	may have been deleted and cleaned up, so if not found
						/*	success, then start over.
						/**/
						DIRIUpToCSR( pfucb, pcsrRoot );
						Call( ErrBTGet( pfucb, PcsrCurrent( pfucb ) ) );
						Call( ErrBTSeekForUpdate( pfucb, pkey, 0, 0, fDIRDuplicate | fDIRReplaceDuplicate | fFlags ) );
						if ( err != JET_errSuccess )
							goto Start;
						Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
						DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
						}

					/*	move to item insert position
					/**/
					Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
					Call( ErrDIRIMoveToItem( pfucb, srid, fFalse ) );

					/*	set bm from cached bm
					/**/
					PcsrCurrent( pfucb )->bm = bmItemList;
					}
				else
					{
					/*	set bookmark from current node
					/**/
					PcsrCurrent( pfucb )->bm = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
						PcsrCurrent( pfucb )->itag );

					/*	if duplicates are not allowed then check for duplicate
					/**/
					if ( !( fFlags & fDIRDuplicate ) )
						{
						/*	if node is not first item list node then
						/*	reseek to first item list node.  In this way,
						/*	thrashing across many duplicate index entries.
						/**/
						if ( !FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
							{
#ifdef	DEBUG
							ULONG	ctimes = 0;
#endif
							/*	go up to root, and reseek to begining of item list node list
							/**/
							DIRIUpToCSR( pfucb, pcsrRoot );
							dib.fFlags = fDIRNull;
							dib.pos = posDown;
							dib.pkey = pkey;
Refresh2:
#ifdef	DEBUG
							ctimes++;
							Assert( ctimes < 10 );
#endif
							Call( ErrBTGet( pfucb, PcsrCurrent( pfucb ) ) );
							err = ErrBTDown( pfucb, &dib );
							/*	case where the first item node has been moved elsewhere
							/**/
							Assert( FFUCBNonClustered( pfucb )
								&& dib.pos == posDown );
							if ( !FNDFirstItem( *( pfucb->ssib.line.pb ) ) )
								{
								BTUp( pfucb );
								BFSleep( cmsecWaitGeneric );
								Call( ErrDIRRefresh( pfucb ) );
								goto Refresh2;
								}
							Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );
							DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
							}

						/*	check for duplicate key
						/**/
						Assert( FNDFirstItem( *( pfucb->ssib.line.pb ) ) );
						Call( ErrDIRIKeyDuplicate( pfucb ) );
						}

					/*	move to item insert position
					/**/
					Assert( FNDLastItem( *( pfucb->ssib.line.pb ) ) );
					Call( ErrDIRIMoveToItem( pfucb, srid, fFalse ) );

					/*	set bookmark from current node
					/**/
					PcsrCurrent( pfucb )->bm = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno,
						PcsrCurrent( pfucb )->itag );
					}

				/*	if item already there, then overwrite with insert version
				/**/
				if ( err == wrnNDDuplicateItem )
					{
					// UNDONE: Possible bug here.  NDFlagInsertItem() assumes
					// versioning is enabled.  Call me if this assert fires. -- JL
					Assert( fFlags & fDIRVersion );
					err = ErrNDFlagInsertItem( pfucb );
					if ( err == errDIRNotSynchronous )
						{
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}
					Call( err );
					}
				else
					{
					/*	split item list node if maximum number of items
					/*	would be reached by current insertion.
					/**/
					if ( pfucb->lineData.cb == citemMost * sizeof(SRID) )
						{
						cbReq = cbFOPOneSon + pfucb->keyNode.cb;

						if ( FBTSplit( pssib, cbReq, 1 ) )
							{
							FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrRoot );
							AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

							if ( !fCleaned )
								{
								/*	attempt to clean page to release space
								/**/
								err = ErrBMCleanBeforeSplit(
											pfucb->ppib,
											pfucb->u.pfcb,
											PnOfDbidPgno( pfucb->dbid, PcsrCurrent( pfucb )->pgno ) );
								fCleaned = fTrue;
								}
							else
								{
								Call( ErrBTSplit( pfucb, pfucb->ssib.line.cb, cbReq, NULL, fDIRAppendItem | fDIRReplace ) );
								fCleaned = fFalse;
								}
							DIRIUpToCSR( pfucb, pcsrRoot );
							goto Start;
							}
			 			else if ( fCleaned )
							{
							/*	the cleanup paid off
							/**/
							cOLCSplitsAvoided++;
							}

						Call( ErrNDSplitItemListNode( pfucb, fFlags ) );
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}

					cbReq = sizeof(SRID);
					if ( FBTSplit( pssib, cbReq, 0 ) )
						{
						FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrRoot );
						AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
						if ( !fCleaned )
							{
							/*	attempt to clean page to release space
							/**/
							err = ErrBMCleanBeforeSplit(
										pfucb->ppib,
										pfucb->u.pfcb,
										PnOfDbidPgno( pfucb->dbid, PcsrCurrent( pfucb )->pgno ) );
							fCleaned = fTrue;
							}
						else
							{
							Call( ErrBTSplit( pfucb, pfucb->ssib.line.cb, cbReq, pkey, fDIRAppendItem | fDIRReplace ) );
							fCleaned = fTrue;
							}
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}
					else if ( fCleaned )
						{
						/*	the cleanup paid off
						/**/
						cOLCSplitsAvoided++;
						}

					/*	cache page access in case lost during loss of critJet
					/**/
					AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
					// UNDONE: dummy code.
					if ( !FBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) )
						{
						Call( ErrBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno ) );
						}
					NDGet( pfucb, PcsrCurrent( pfucb )->itag );
					DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
					err = ErrNDInsertItem( pfucb, (SRID)srid, fFlags );
					if ( err == errDIRNotSynchronous )
						{
						DIRIUpToCSR( pfucb, pcsrRoot );
						goto Start;
						}
					Call( err );
					PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
					}
				break;
				}

			case wrnNDFoundLess:
			case wrnNDFoundGreater:
				{
				cbReq = cbNullKeyData + pkey->cb + sizeof(SRID);
				if ( FBTAppendPage( pfucb, PcsrCurrent( pfucb ), cbReq, 0, CbFreeDensity( pfucb ), 1 ) ||
					FBTSplit( pssib, cbReq, 1 ) )
					{
					FUCBFreePath( &PcsrCurrent( pfucb )->pcsrPath, pcsrRoot );
					if ( !fCleaned )
						{
						/*	attempt to clean page to release space
						/**/
						err = ErrBMCleanBeforeSplit(
									pfucb->ppib,
									pfucb->u.pfcb,
									PnOfDbidPgno( pfucb->dbid, PcsrCurrent( pfucb )->pgno ) );
						fCleaned = fTrue;
						}
					else
						{
						Call( ErrBTSplit( pfucb, 0, cbReq, pkey, 0 ) );
						fCleaned = fTrue;
						}
					DIRIUpToCSR( pfucb, pcsrRoot );
					goto Start;
					}
	 			else if ( fCleaned )
					{
					/*	the cleanup paid off
					/**/
					cOLCSplitsAvoided++;
					}

				/*	insert item list node.
				/**/
				err = ErrNDInsertItemList( pfucb, pkey, *(SRID UNALIGNED *)pline->pb, fFlags );
				if ( err == errDIRNotSynchronous )
					{
					DIRIUpToCSR( pfucb, pcsrRoot );
					goto Start;
					}
				Call( err );
				PcsrCurrent( pfucb )->csrstat = csrstatOnCurNode;
				break;
				}

			case errDIRNotSynchronous:
				DIRIUpToCSR( pfucb, pcsrRoot );
				BFSleep( cmsecWaitWriteLatch );
				goto Start;
				
			default:
				goto HandleError;
			}
		}
	else
		{
		CSR	*pcsrParentOfRoot;

		Assert( PcsrCurrent( pfucb ) == pcsrRoot );
		pcsrParentOfRoot = pcsrRoot->pcsrPath;

		/*	clustered index
		/**/
		err = ErrBTSeekForUpdate( pfucb, pkey, 0, 0, fFlags );
		if ( err < 0 )
			{
			if ( err == errDIRNotSynchronous )
				{
				// ErrBTSeekForUpdate() should have restored currency for us.
				Assert( PcsrCurrent( pfucb ) == pcsrRoot );
				BFSleep( cmsecWaitWriteLatch );
				goto Start;
				}
			goto HandleError;
			}

		err = ErrBTInsert( pfucb, 0, pkey, pline, fFlags, &fCleaned );
		if ( err < 0 )
			{
			if ( err == errDIRNotSynchronous )
				{
				// If we're not already at the root level, we're one level below it.
				// WARNING:  Should never hit the case where we're at the root level,
				// but not at pcsrRoot.
				while ( PcsrCurrent( pfucb )->pcsrPath != pcsrParentOfRoot )
					{
					BTUp( pfucb );
					Assert( PcsrCurrent( pfucb ) != pcsrNil );
					}
				// pcsrRoot may have changed (if two-level split), but not
				// parent pcsr of pcsrRoot.
				Assert( PcsrCurrent( pfucb )->pcsrPath == pcsrParentOfRoot );
				goto Start;
				}
			goto HandleError;
			}		
		
		DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );
		}

	if ( fFlags & fDIRBackToFather )
		{
		DIRIUp( pfucb, 1 );
		Assert( PcsrCurrent( pfucb ) == pcsrRoot );
		}
	else
		{
		if ( fFlags & fDIRPurgeParent )
			{
			Assert( err >= 0 );
			DIRIPurgeParent( pfucb );
			}
		DIRSetFresh( pfucb );
		}

HandleError:
	/*	 if write latched empty page the release latch
	/**/
	if ( pfucb->pbfEmpty != pbfNil )
		{
		if ( err < 0 )
			{
			// Throw away error.  In the worst case, we just have to live
			// with the empty page -- keys on internal pages may become
			// out of order, causing performance degradation.
			(VOID)ErrBTAbandonEmptyPage( pfucb, pkey );
			PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
			}
		BFResetWriteLatch( pfucb->pbfEmpty, pfucb->ppib );
		pfucb->pbfEmpty = pbfNil;
		}
	else if ( err < 0 )
		{
		PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
		}

	/*	depend on ErrDIRRollback to clean up on error.  Rollback may have
	/*	already occured in which case even pcsrRoot may no longer be
	/*	present in CSR stack.
	/**/
//	if ( err < 0 )
//		{
//		DIRIUpToCSR( pfucb, pcsrRoot );
//		}

#ifdef DEBUG
	if ( err >= JET_errSuccess )
		CheckCSR( pfucb );
#endif

	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRCreateDirectory( FUCB *pfucb, CPG cpgMin, PGNO *ppgnoFDP )
	{
	ERR	err;
	CPG	cpgRequest = cpgMin;

	CheckFUCB( pfucb->ppib, pfucb );
	CheckCSR( pfucb );
	Assert( ppgnoFDP );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnFDPNode );	// Should be on "parent" FDP.

	/*	create FDP
	/**/
	*ppgnoFDP = pgnoNull;
	Call( ErrSPGetExt(
		pfucb,
		pfucb->u.pfcb->pgnoFDP,
		&cpgRequest,
		cpgMin,
		ppgnoFDP,
		fTrue ) );
	Assert( *ppgnoFDP > pgnoSystemRoot );
	Assert( *ppgnoFDP <= pgnoSysMax );

HandleError:
	return err;

	}


/*	This routine is for use in building non-clustered indexes.  It does not
/*	maintain normal CSR status and leaves currency on inserted node.  If for
/*	any reason simple insertion cannot be performed, errDIRNoShortCircuit
/*	is returned so that the insertion may be performed via DIRInsert.
/*
/*	Also, no versions are created for index items since the table
/*	must be opened exclusively.  When the index is visible to other
/*	sessions, so too will all the items.
/**/
ERR ErrDIRInitAppendItem( FUCB *pfucb )
	{
	ERR	err = JET_errSuccess;

	/*	allocate working buffer if needed
	/**/
	if ( pfucb->pbfWorkBuf == NULL )
		{
		err = ErrBFAllocTempBuffer( &pfucb->pbfWorkBuf );
		if ( err < 0 )
			{
			DIRAPIReturn( pfucb, err );
			}
		pfucb->lineWorkBuf.pb = (BYTE *)pfucb->pbfWorkBuf->ppage;
		}

	PrepareAppendItem( pfucb );
	((APPENDITEM *)pfucb->lineWorkBuf.pb)->isrid = 0;
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRAppendItem( FUCB *pfucb, LINE *pline, KEY *pkey, SRID sridPrev )
	{
	ERR		err;
	CSR		*pcsr;
	SSIB 	*pssib = &pfucb->ssib;
	INT		fNodeHeader;
	UINT 	cbReq;
	UINT 	cbFree;
	INT		citem;
	LONG 	l;
	INT		isrid = IsridAppendItemOfPfucb( pfucb );
	SRID 	*rgsrid = RgsridAppendItemOfPfucb( pfucb );

	/*	set cursor navigation level for rollback support
	/**/
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	Assert( pline->cb == sizeof(SRID) );
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	get current node to check for key append
	/**/
	NDGet( pfucb, pcsr->itag );
	DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
	Assert( FNDNullSon( *pssib->line.pb ) );
	citem = pfucb->lineData.cb / sizeof(SRID);

	/*	get free space to density contraint violation
	/**/
	cbFree = CbBTFree( pfucb, CbFreeDensity( pfucb ) );

	/*	if key same as current node then insert SRID, else
	/*	begin new item list node with given key
	/**/
	if ( CmpStKey( StNDKey( pssib->line.pb ), pkey ) == 0 )
		{
		/*	do not append duplicate key duplicate SRIDs
		/**/
		if ( ( isrid == 0	&& *(SRID UNALIGNED *)pline->pb == sridPrev )
			|| ( isrid > 0 && rgsrid[isrid - 1] == *(SRID UNALIGNED *)pline->pb ) )
			{
			DIRAPIReturn( pfucb, JET_errSuccess );
			}

		/*	if one more item would not require item list split
		/*	or page split, then cache current item for bulk
		/*	insertion, else if any cached items, then perform
		/*	bulk insertion.
		/*
		/*	cbReq is space required for cached item node replacement plus
		/*	space for new inserted item list node with one item.
		/**/
		cbReq = isrid * sizeof(SRID) + cbFOPOneSon + pfucb->keyNode.cb + sizeof(SRID);
		Assert( csridAppendItemMax >= citemMax );
		if ( citem + isrid == citemMost || cbReq > cbFree )
			{
			if ( isrid > 0 )
				{
				Call( ErrNDInsertItems( pfucb, (SRID *)rgsrid, isrid ) );
				IsridAppendItemOfPfucb( pfucb ) = 0;
				}
			}
		else
			{
			Assert( !FBTSplit( pssib, cbReq, 0 ) );
			Assert( citem + isrid < citemMax );
			/*	ignore duplicate key and SRID pairs which can
			/*	occur if a record has multiple columns values
			/*	which are sufficiently identical.
			/**/
			Assert( isrid >= 0 );
			rgsrid[isrid] = *(SRID UNALIGNED *)pline->pb;
			IsridAppendItemOfPfucb( pfucb )++;
			DIRAPIReturn( pfucb, JET_errSuccess );
			}

		/*	if this is last item insert before split item list
		/*	cannot be satified from page space, then split item
		/*	list prematurely to ensure good item packing.
		/**/
		cbReq = cbFOPOneSon + pfucb->keyNode.cb;
		if ( cbReq <= cbFree &&  cbReq + sizeof(SRID) > cbFree )
			{
#define	citemFrag		16
			/*	if number of items in current node exceeds
			/*	fragment then split node.
			/**/
			if ( citem > citemFrag )
				{
				/*	cache current item list for item list split.
				/**/
				NDGet( pfucb, PcsrCurrent( pfucb )->itag );
				DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
				Call( ErrNDSplitItemListNode( pfucb, fDIRNoVersion | fDIRAppendItem ) );
				DIRAPIReturn( pfucb, ErrERRCheck( errDIRNoShortCircuit ) );
				}
			}

		/*	honor density by checking free space to density violation
		/*	and check for split case.
		/**/
		cbReq = sizeof(SRID);
		if ( cbReq > cbFree )
			{
			DIRAPIReturn( pfucb, ErrERRCheck( errDIRNoShortCircuit ) );
			}
		Assert( !FBTSplit( pssib, cbReq, 0 ) );

		/*	get lineData
		/**/
		NDGet( pfucb, pcsr->itag );
		DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

		citem = pfucb->lineData.cb / sizeof(SRID);
		Assert( citem < citemMax );
		if ( citem == citemMost )
			{
			DIRAPIReturn( pfucb, ErrERRCheck( errDIRNoShortCircuit ) );
			}
		l = LSridCmp( *(((SRID UNALIGNED *)pfucb->lineData.pb) + citem - 1),
			*(SRID UNALIGNED *)pline->pb );
		/*	SRIDs are sorted and will be returned from SORT
		/*	in ascending order.
		/**/
		Assert( l < 0 );
		pcsr->isrid = (SHORT)citem;
		PcsrCurrent( pfucb )->bm = SridOfPgnoItag( PcsrCurrent( pfucb )->pgno, PcsrCurrent( pfucb )->itag );
		CallS( ErrNDInsertItem( pfucb, *(SRID UNALIGNED *)pline->pb, fDIRNoVersion ) );
		}
	else
		{
		/*	append duplicate items to last node
		/**/
		if ( isrid > 0 )
			{
			Call( ErrNDInsertItems( pfucb, (SRID *)rgsrid, isrid ) );
			IsridAppendItemOfPfucb( pfucb ) = 0;
			}

		Assert( CmpStKey( StNDKey( pssib->line.pb ), pkey ) < 0 );

		/*	check density contraint against free space and check split.
		/**/
		cbReq = cbFOPOneSon + CbKey( pkey ) + CbLine( pline );
		if ( cbReq > cbFree || FBTSplit( pssib, cbReq, 1 ) )
			{
			DIRAPIReturn( pfucb, ErrERRCheck( errDIRNoShortCircuit ) );
			}

		fNodeHeader = 0;
		NDSetFirstItem( fNodeHeader );
		NDSetLastItem( fNodeHeader );
		pcsr->ibSon++;
		while( ( err = ErrNDInsertNode( pfucb, pkey, pline, fNodeHeader, fDIRNoVersion ) ) == errDIRNotSynchronous );
		Call( err );
		}

	/*	set CSR status to on inserted node.
	/**/
	pcsr->csrstat = csrstatOnCurNode;
	DIRSetFresh( pfucb );

HandleError:
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRTermAppendItem( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	INT		isrid = IsridAppendItemOfPfucb( pfucb );
	CSR		*pcsr;
	SSIB	*pssib;
	UINT	cbReq;
	INT		citem;

	if ( isrid > 0 )
		{
		pssib = &pfucb->ssib;

		Call( ErrDIRRefresh( pfucb ) );
		pcsr = PcsrCurrent( pfucb );

		/*	get current node to check for key append.
		/**/
		NDGet( pfucb, pcsr->itag );
		DIRIGetItemList( pfucb, pcsr );
		Assert( FNDNullSon( *pssib->line.pb ) );

		/*	if key same as current node then insert SRID, else
		/*	begin new item list node with given key
		/**/
		citem = pfucb->lineData.cb / sizeof(SRID);
		cbReq = isrid * sizeof(SRID) + cbFOPOneSon + pfucb->keyNode.cb;
		Assert( isrid != csridAppendItemMax &&
			citem + isrid < citemMax &&
			(INT)cbReq <= ( CbBTFree( pfucb, CbFreeDensity( pfucb ) ) ) );
		Call( ErrNDInsertItems( pfucb,
			(SRID *)RgsridAppendItemOfPfucb( pfucb ),
			isrid ) );

		/*	set CSR status to on inserted node.
		/**/
		pcsr->csrstat = csrstatOnCurNode;

		DIRSetFresh( pfucb );
		}

HandleError:
	if ( pfucb->pbfWorkBuf != pbfNil )
		{
		BFSFree( pfucb->pbfWorkBuf );
		pfucb->pbfWorkBuf = pbfNil;
		}

	FUCBResetDeferredChecksum( pfucb );
	FUCBResetUpdateSeparateLV( pfucb );
	FUCBResetCbstat( pfucb );
	Assert( pfucb->pLVBuf == NULL );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRGotoPosition( FUCB *pfucb, ULONG ulLT, ULONG ulTotal )
	{
	ERR		err;
	CSR		**ppcsr = &PcsrCurrent( pfucb );
	DIB		dib;
	FRAC	frac;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

#ifdef PREREAD
	/* clear preread statistics
	/**/	
	FUCBResetPrereadCount( pfucb );
#endif	// PREREAD

	/*	set cursor navigation level for rollback support
	/**/
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );

	dib.fFlags = fDIRPurgeParent;
	dib.pos = posFrac;
	dib.pkey = (KEY *)&frac;

	frac.ulLT = ulLT;
	frac.ulTotal = ulTotal;

	/*	position fractionally on node.  Move up preserving currency
	/*	in case down fails.
	/**/
	Call( ErrBTDown( pfucb, &dib ) );
	/*	will not necessarily land on first item list node since
	/*	down by fraction and not by key.
	/**/
	NDGetNode( pfucb );

	/*	node cannot be FDP pointer, and must be record or index.
	/**/
	Assert( err == JET_errSuccess );
	Assert( !( FNDFDPPtr( *pfucb->ssib.line.pb ) ) );
	(*ppcsr)->csrstat = csrstatOnCurNode;

	/*	if non-clustered index, position fractionally on item.
	/*	FRAC will contain remaining fractional position, for
	/*	item list level.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		INT           citem;
		INT           iitem;

		/*	determine fractional position in item list
		/**/
		citem = (INT)CitemNDData( pfucb->ssib.line.pb,
			pfucb->ssib.line.cb,
			PbNDData( pfucb->ssib.line.pb ) );
		if ( frac.ulTotal / citemMost == 0 )
			{
			iitem = ( citem * frac.ulLT ) / frac.ulTotal;
			}
		else
			{
			iitem = ( citem * ( frac.ulLT / ( frac.ulTotal / citemMost ) ) ) / citemMost;
			}
		if ( iitem >= citem )
			iitem = citem - 1;

		/*	if cursor is on first item list node, then cache bookmark
		/*	for version operations.
		/*
		/*	else then move previous
		/*	in same item list until first item list node found.  Cache
		/*	bookmark of first item list node for version operations.
		/**/
		if ( FNDFirstItem( *pfucb->ssib.line.pb ) )
			{
			DIRISetItemListFromFirst( pfucb );
			}
		else
			{
			INT     iitemPrev;
			DIB     dibT;

			dibT.fFlags = fDIRNull;

			for ( iitemPrev = 0;; iitemPrev++)
				{
				Call( ErrDIRPrev( pfucb, &dibT ) );
				if ( FNDFirstItem( *pfucb->ssib.line.pb ) )
					break;
				}

			DIRISetItemListFromFirst( pfucb );

			for ( ; iitemPrev > 0; iitemPrev-- )
				{
				Call( ErrDIRNext( pfucb, &dibT ) );
				}
			}

		/*	position on first item.  If item is not there for this session
		/*	then increment iitem to move to correct position.
		/**/
		err = ErrNDFirstItem( pfucb );
		Assert( err == JET_errSuccess || err == errNDNoItem );
		if ( err == errNDNoItem )
			{
			iitem++;
			}

		while ( iitem-- > 0 )
			{
			DIB     dibT;

			dibT.fFlags = fDIRNull;

			Assert( iitem >= 0 );

			/*	move to next item in item list.  Note that if some items
			/*	are not there for us, we will move to the next item
			/*	list node.
			/**/
			err = ErrDIRNext( pfucb, &dibT );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					break;
				goto HandleError;
				}
			}

		/*	handle JET_errNoCurrentRecord.  We may have landed on a record
		/*	not there for us, or we may have moved past the last record
		/*	for us.  Try to move to next record, if there is no next record
		/*	then move previous to last record there for us.  If no previous
		/*	record then return JET_errNoCurrentRecord.
		/**/
		Assert( err != errNDNoItem );
		if ( err == JET_errNoCurrentRecord )
			{
			DIB     dibT;
			dibT.fFlags = fDIRNull;

			err = ErrDIRNext( pfucb, &dibT );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					Call( ErrDIRPrev( pfucb, &dibT ) );
				goto HandleError;
				}
			}
		}

	/*	always purge parent
	/**/
	DIRIPurgeParent( pfucb );
HandleError:
	DIRAPIReturn( pfucb, err );
	}


/*********** currency neutral DIR API Routines ************
/**********************************************************
/**/
ERR ErrDIRGetWriteLock( FUCB *pfucb )
	{
	ERR     err = JET_errSuccess;

	do
		{
	
		Assert( pfucb->ppib->level > 0 );

		/*	check currency and refresh if necessary.
		/**/
		Call( ErrDIRRefresh( pfucb ) );

		/*	check CSR status
		/**/
		switch ( PcsrCurrent( pfucb )->csrstat )
			{
			case csrstatOnCurNode:
			case csrstatOnFDPNode:
				break;
			default:
				Assert( PcsrCurrent( pfucb )->csrstat == csrstatBeforeCurNode ||
					PcsrCurrent( pfucb )->csrstat == csrstatAfterCurNode ||
					PcsrCurrent( pfucb )->csrstat == csrstatAfterLast ||
					PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst );
				DIRAPIReturn( pfucb, ErrERRCheck( JET_errNoCurrentRecord ) );
			}

		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
		NDGetNode( pfucb );

		err = ErrNDLockRecord( pfucb );
		}
	while ( err == errDIRNotSynchronous );
	Call( err );
	Assert( err == JET_errSuccess );

	DIRSetFresh( pfucb );
HandleError:
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDelete( FUCB *pfucb, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

//	UNDONE: fDIRDeleteItem is no longer used.  Remove it altogether.	
//	Assert( FFUCBNonClustered( pfucb ) || !( fFlags & fDIRDeleteItem ) );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
			Call( ErrBTGetNode( pfucb, pcsr ) );

			if ( FFUCBNonClustered( pfucb ) )
				{
				Assert( !FNDSon( *pfucb->ssib.line.pb ) );
				Assert( !( fFlags & fDIRDeleteItem ) );		// UNDONE: This flag is no longer used. Eliminate it.
				if ( ! ( fFlags & fDIRDeleteItem ) )
					{
					// UNDONE: Possible bug here.  NDFlagDeleteItem() assumes
					// versioning is enabled.  Call me if this assert fires. -- JL
					Assert( fFlags & fDIRVersion );

					// flag the item deleted
					err = ErrNDFlagDeleteItem( pfucb, fFlags & fDIRNoMPLRegister );
					while ( err == errDIRNotSynchronous )
						{
						Call( ErrDIRRefresh( pfucb ) );
						err = ErrNDFlagDeleteItem( pfucb, fFlags & fDIRNoMPLRegister );
						}
					Call( err );
					}
				else
					{
					Assert( 0 );		// The following is dead code, since fDIRDeleteItem is obsolete.
					
					/* actually delete the item
					/* used by VER in cleanup
					/**/
					Assert( !( fFlags & fDIRVersion ) );

					/*	if only one item then delete node
					/**/
					if ( pfucb->lineData.cb == sizeof(SRID) )
						{
						BOOL    fFirstItem;
						BOOL    fLastItem;

						Assert( FNDSingleItem( pfucb ) );

						if ( FNDFirstItem( *pfucb->ssib.line.pb ) )
							fFirstItem = fTrue;
						else
							fFirstItem = fFalse;

						if ( FNDLastItem( *pfucb->ssib.line.pb ) )
							fLastItem = fTrue;
						else
							fLastItem = fFalse;

						if ( fFirstItem || fLastItem )
							{
							/*	adjust fist/last item info appropriately
							/**/
							//	removed for stability
//							Call( ErrDIRIDeleteEndItemNode( pfucb, fFirstItem, fFlags ) );
							}
						else
							{
								//	delete the itemlist node
							Call( ErrDIRDeleteItemNode( pfucb ) );
							}
						}
					else
						{
						/*	delete item
						/**/
						Call( ErrDIRRefresh( pfucb ) );

						/*	has to be within critJet
						/**/
						LgHoldCriticalSection( critJet );
						AssertNDGet( pfucb, pcsr->itag );

						/*	item might have been reinserted
						/*	in that case, donot delete
						/**/
						if ( !FNDItemDelete( *( (SRID UNALIGNED *)pfucb->lineData.pb
							+ PcsrCurrent( pfucb )->isrid ) ) )
							{
							err = ErrNDDeleteItem( pfucb );
							}
						LgReleaseCriticalSection( critJet );
						Call( err );
						}
					}
				}
			else
				{
				/*	delete current node sons and then current node.  Even
				/*	though the node has sons, the tree may be empty of
				/*	visible sons.
				/**/
				if ( FNDSon( *pfucb->ssib.line.pb ) )
					{
					DIB	dib;

					dib.fFlags = fDIRNull;
					dib.pos = posFirst;
					err = ErrDIRDown( pfucb, &dib );
					if ( err < 0 && err != JET_errRecordNotFound )
						goto HandleError;
					if ( err != JET_errRecordNotFound )
						{
						do
							{
							err = ErrDIRDelete( pfucb, fFlags );
							if ( err < 0 )
								{
								DIRAPIReturn( pfucb, err );
								}
							err = ErrDIRNext( pfucb, &dib );
							}
						while ( err == JET_errSuccess );
						Assert( err != errDIRFDP );

						DIRUp( pfucb, 1 );
						if ( err != JET_errNoCurrentRecord )
							goto HandleError;
						/*	refresh currency after up
						/**/
						Call( ErrDIRRefresh( pfucb ) );
						}
					}
				err = ErrBTDelete( pfucb, fFlags );
				while ( err == errDIRNotSynchronous )
					{
					Call( ErrDIRRefresh( pfucb ) );
					err = ErrBTDelete( pfucb, fFlags );
					}
				Call( err );
				}
			break;

		default:
			Assert( pcsr->csrstat != csrstatOnFDPNode );
			err = ErrERRCheck( JET_errNoCurrentRecord );
		}

	DIRSetRefresh( pfucb );

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRReplace( FUCB *pfucb, LINE *pline, INT fFlags )
	{
	ERR		err;
	BOOL	fCleaned = fFalse;

	do
		{
		CheckFUCB( pfucb->ppib, pfucb );
		Assert( pfucb->pbfEmpty == pbfNil );
		CheckCSR( pfucb );

		/*	check currency and refresh if necessary.
		/**/
		Call( ErrDIRRefresh( pfucb ) );

		if ( PcsrCurrent( pfucb )->csrstat != csrstatOnCurNode &&
			PcsrCurrent( pfucb )->csrstat != csrstatOnFDPNode )
			{
			DIRAPIReturn( pfucb, ErrERRCheck( JET_errNoCurrentRecord ) );
			}

		NDGetNode( pfucb );
		err = ErrBTReplace( pfucb, pline, fFlags, &fCleaned );
		if ( err == JET_errSuccess )
			{
			DIRSetFresh( pfucb );
			DIRAPIReturn( pfucb, err );
			}

		Assert( pfucb->pbfEmpty == pbfNil );
		}
	while ( err == errDIRNotSynchronous );

	DIRSetRefresh( pfucb );
HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRDelta( FUCB *pfucb, INT iDelta, INT fFlags )
	{
	ERR		err;
	CSR		*pcsr;

	do
		{
		CheckFUCB( pfucb->ppib, pfucb );
		Assert( pfucb->pbfEmpty == pbfNil );
		CheckCSR( pfucb );

		/*	check currency and refresh if necessary.
		/**/
		Call( ErrDIRRefresh( pfucb ) );
		pcsr = PcsrCurrent( pfucb );

		Call( ErrBTGetNode( pfucb, pcsr ) );

		err = ErrNDDelta( pfucb, iDelta, fFlags );
		}
	while ( err == errDIRNotSynchronous );

HandleError:
	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal )
	{
	ERR		err;
	CSR		*pcsr;
	INT		isrid;
	INT		citem = 1;
	ULONG	ulLT;
	ULONG	ulTotal;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	LgLeaveCriticalSection( critJet );
	EnterNestableCriticalSection( critSplit );
	LgEnterCriticalSection( critJet );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	return error if not on a record
	/**/
	if ( pcsr->csrstat != csrstatOnCurNode )
		{
		DIRAPIReturn( pfucb, ErrERRCheck( JET_errNoCurrentRecord ) );
		}

	/*	if on non-clustered index, then treat item list as
	/*	additional tree level.
	/**/
	if ( FFUCBNonClustered( pfucb ) )
		{
		DIRIGetItemList( pfucb, pcsr );

		/*	refresh srid
		/**/
		isrid = pcsr->isrid;
		citem = (INT)CitemNDData( pfucb->ssib.line.pb,
			pfucb->ssib.line.cb,
			PbNDData( pfucb->ssib.line.pb ) );
		Assert( citem > 0 && citem < citemMax );
		}

	/*	get approximate position of node.
	/**/
	Call( ErrBTGetPosition( pfucb, &ulLT, &ulTotal ) );

	/*	assert that ErrBTGetPosition does not change the
	/*	current CSR.
	/**/
	Assert( pcsr == PcsrCurrent( pfucb ) );

	/*	if citem > 1 from non-clustered index with duplicates, then
	/*	adjust fractional positon by treating non-clustered index
	/*	as additional tree level.
	/**/
	if ( citem > 1 )
		{
		ulTotal *= citem;
		ulLT = ulLT * citem + pcsr->isrid;
		}

	/*	return results
	/**/
	Assert( err == JET_errSuccess );
	Assert( ulLT <= ulTotal );
	*pulLT = ulLT;
	*pulTotal = ulTotal;

HandleError:
	/*	honor currency semantics
	/**/
	if ( FBFReadAccessPage( pfucb, pcsr->pgno ) )
		{
		NDGet( pfucb, PcsrCurrent( pfucb )->itag );
		}

	LeaveNestableCriticalSection( critSplit );

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRIndexRecordCount( FUCB *pfucb, ULONG *pulCount, ULONG ulCountMost, BOOL fNext )
	{
	ERR		err;
	CSR		*pcsr;
	DIB		dib;
	INT		citem;
	ULONG 	ulCount;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary.
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	return error if not on a record
	/**/
	if ( pcsr->csrstat != csrstatOnCurNode )
		{
		DIRAPIReturn( pfucb, ErrERRCheck( JET_errNoCurrentRecord ) );
		}
	Call( ErrBTGetNode( pfucb, pcsr ) );

	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	item list nodes not versioned.
		/**/
		dib.fFlags = fDIRItemList;

		/*	initialize count with current position in item list
		/**/
		ulCount = CitemNDThere(
			pfucb,
			(BYTE)( fNext ? fNDCitemFromIsrid : fNDCitemToIsrid ),
			pcsr->isrid );
		Assert( ulCount < citemMax );

		/*	count all items util end of file or limit
		/**/
		forever
			{
			if ( ulCount > ulCountMost )
				{
				ulCount = ulCountMost;
				break;
				}

			err = ErrBTNextPrev( pfucb, pcsr, fNext, &dib, NULL );
			if ( err < 0 )
				break;

			/*	if on new item list then set bookmark from
			/*	first item list node, of if on new last item
			/*	list node then move to first, set bookmark,
			/*	and then move back to last.
			/**/
			if ( fNext )
				{
				DIRICheckFirstSetItemList( pfucb );
				}
			else
				{
				DIRICheckLastSetItemList( pfucb );
				}

			DIRIGetItemList( pfucb, pcsr );

			/*	check index range if on new first item list node (if traversing
			/*	forward) or new last item list node (if traversing backward),
			/*	i.e. key has changed.
			/**/
			if ( FFUCBLimstat( pfucb ) )
				{
				if ( ( fNext && FNDFirstItem( *pfucb->ssib.line.pb ) ) ||
					( !fNext && FNDLastItem( *pfucb->ssib.line.pb ) ) )
					{
					err = ErrDIRICheckIndexRange( pfucb );
					if ( err < 0 )
						break;
					}
				}

			citem = CitemNDThere( pfucb, fNDCitemAll, sridNull );	// srid is ignored if counting all, so pass dummy srid
			Assert( citem < citemMax );
			ulCount += citem;
			}
		}
	else
		{
		/*	clusterred index nodes can be versioned.
		/**/
		dib.fFlags = fDIRNull;

		/*	intialize count variable
		/**/
		ulCount = 0;

		/*	count nodes from current to limit or end of table
		/**/
		forever
			{
			ulCount++;
			if ( ulCount >= ulCountMost )
				{
				ulCount = ulCountMost;
				break;
				}
			err = ErrBTNextPrev( pfucb, pcsr, fNext, &dib, NULL );
			if ( err < JET_errSuccess )
				break;

			/*	check index range
			/**/
			if ( FFUCBLimstat( pfucb ) )
				{
				NDGetKey( pfucb );
				err = ErrDIRICheckIndexRange( pfucb );
				if ( err < 0 )
					break;
				}
			}
		}

	/*	common exit loop processing
	/**/
	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto HandleError;

	err = JET_errSuccess;
	*pulCount = ulCount;
HandleError:
	DIRAPIReturn( pfucb, err );
	}


ERR ErrDIRComputeStats( FUCB *pfucb, INT *pcitem, INT *pckey, INT *pcpage )
	{
	ERR		err;
	DIB		dib;
	BYTE	rgbKey[ JET_cbKeyMost ];
	KEY		key;
	PGNO	pgnoT;
	INT		citem = 0;
	INT		ckey = 0;
	INT		cpage = 0;
	INT		citemT;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );
	Assert( !FFUCBLimstat( pfucb ) );

	/*	go to first node
	/**/
	DIRGotoDataRoot( pfucb );
	dib.fFlags = fDIRNull;
	dib.pos = posFirst;
	err = ErrDIRDown( pfucb, &dib );
	if ( err < 0 )
		{
		/*	if index empty then set err to success
		/**/
		if ( err == JET_errRecordNotFound )
			{
			err = JET_errSuccess;
			goto Done;
			}
		goto HandleError;
		}

	/*	if there is at least one node, then there is a first page.
	/**/
	cpage = 1;

	if ( FFUCBNonClustered( pfucb ) )
		{
		/*	item list nodes not versioned.
		/**/
		dib.fFlags = fDIRItemList;

		/*	count all items util end of file or limit
		/**/
		forever
			{
			DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );

			citemT = CitemNDThere( pfucb, fNDCitemAll, sridNull );	// srid is ignored if counting all, so pass dummy srid

			Assert( citemT < citemMax );
			citem += citemT;

			if ( FNDFirstItem( *pfucb->ssib.line.pb ) && citemT > 0 )
				ckey++;

			pgnoT = PcsrCurrent( pfucb )->pgno;
			err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib, NULL );
			if ( err < 0 )
				break;
			
			/*	if on new item list then set bookmark from
			/*	first item list node.
			/**/
			DIRICheckFirstSetItemList( pfucb );

			if ( PcsrCurrent( pfucb )->pgno != pgnoT )
				cpage++;
			}
		}
	else
		{
		/*	if clustered index is unique then user much faster algorithm
		/**/
		if ( pfucb->u.pfcb->pidb != NULL &&
			( pfucb->u.pfcb->pidb->fidb & fidbUnique ) )
			{
			forever
				{
				citem++;

				/*	move to next node.  If cross page boundary then
				/*	increment page count.
				/**/
				pgnoT = PcsrCurrent( pfucb )->pgno;
				err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib, NULL );
				if ( PcsrCurrent( pfucb )->pgno != pgnoT )
					cpage++;
				if ( err < JET_errSuccess )
					{
					ckey = citem;
					goto Done;
					}
				}
			}
		else
			{
			/*	clusterred index nodes can be versioned.
			/**/
			Assert( dib.fFlags == fDIRNull );
			key.pb = rgbKey;

			forever
				{
				ckey++;
				err = ErrDIRICopyKey( pfucb, &key );
				if ( err < 0 )
					{
					DIRAPIReturn( pfucb, err );
					}

				forever
					{
					citem++;

					/*	move to next node.  If cross page boundary then
					/*	increment page count.
					/**/
					pgnoT = PcsrCurrent( pfucb )->pgno;
					err = ErrBTNextPrev( pfucb, PcsrCurrent( pfucb ), fTrue, &dib, NULL );
					if ( PcsrCurrent( pfucb )->pgno != pgnoT )
						cpage++;
					if ( err < JET_errSuccess )
						goto Done;
					if ( CmpStKey( StNDKey( pfucb->ssib.line.pb ), &key ) != 0 )
						break;
					}
				}
			}
		}

Done:
	/*	common exit loop processing
	/**/
	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto HandleError;

	err = JET_errSuccess;
	*pcitem = citem;
	*pckey = ckey;
	*pcpage = cpage;

HandleError:
	DIRAPIReturn( pfucb, err );
	}


/************** DIR Transaction Routines ******************
/**********************************************************
/**/
ERR ErrDIRBeginTransaction( PIB *ppib )
	{
	ERR		err = JET_errSuccess;

	/*	log begin transaction. Must be called first so that lgpos and trx
	 *	used in ver are consistent. Note that we use large critical section and
	 *	rely on the fact that VERBeginTransaction are not releasing critJet.
	 *	This is potential a problem for SMP and smaller crit environments.
	/**/
	if ( ppib->level == 0 )
		{
#ifdef DEBUG
		Assert( ppib->dwLogThreadId == 0 );
		ppib->dwLogThreadId = DwUtilGetCurrentThreadId();
#endif
		SgEnterCriticalSection( critVer );
		ppib->trxBegin0 = ++trxNewest;
		if ( trxOldest == trxMax )
			trxOldest = ppib->trxBegin0;
		SgLeaveCriticalSection( critVer );
		}
	else
		{
#ifdef DEBUG
		Assert( ppib->dwLogThreadId == DwUtilGetCurrentThreadId() );
#endif
		}

	err = ErrLGBeginTransaction( ppib, ppib->level );
	if ( err < 0 )
		{
		DIRAPIReturn( pfucbNil, err );
		}

	DIRAPIReturn( pfucbNil, ErrVERBeginTransaction( ppib ) );
	}


ERR ErrDIRRefreshTransaction( PIB *ppib )
	{
	ERR		err = JET_errSuccess;
#ifdef DEBUG
	TRX		trxPrev = ppib->trxBegin0;
#endif

	/*	log refresh transaction.
	/**/
	Assert ( ppib->level != 0 );
#ifdef DEBUG
	Assert( ppib->dwLogThreadId == DwUtilGetCurrentThreadId() );
#endif

	CallR( ErrLGCheckState( ) );
			
	SgEnterCriticalSection( critVer );
//	Assert( trxOldest == ppib->trxBegin0 );
	ppib->trxBegin0 = ++trxNewest;

	/*	recompute trxOldest if this was the oldest transaction
	/**/
	RecalcTrxOldest();
	Assert( trxOldest != trxPrev );
	SgLeaveCriticalSection( critVer );

	if ( !fLogDisabled )
		{
		if ( CmpLgpos( &ppib->lgposStart, &lgposMax ) == 0 )
			{
			/*	lgposStart is not set yet, set it here.
			/**/
			EnterCriticalSection( critLGBuf );
			ppib->lgposStart = lgposLogRec;
			LeaveCriticalSection( critLGBuf );
			}
		}

	err = ErrLGRefreshTransaction( ppib );

	DIRAPIReturn( pfucbNil, err );
	}


ERR ErrDIRCommitTransaction( PIB *ppib, JET_GRBIT grbit )
	{
	ERR		err;
	FUCB   	*pfucb;
	LGPOS	lgposPrecommitRec;
	BOOL	fCommit0 = ppib->levelDeferBegin == 0 && ppib->level == 1;

	CheckPIB( ppib );
	Assert( ppib->level > 0 );

#ifdef DEBUG
	Assert( ppib->dwLogThreadId == DwUtilGetCurrentThreadId() );
#endif

	/*	Write a precommit0 record and wait.
	 *	if it crashes after the precommit record is flushed and before commit record
	 *	is flushed, then during recovery, we treated it as a committed transaction.
	 *	if it crashes after commit record is flushed, it is treated as a committed xact.
	 *	if it crashes before precommit flushed, then it is an uncommitted xact.
	 *	With precommit, we can guarranteed that LGCommitTransaction and VERCommitTransaction
	 *	will be done within one critJet period. And we do not have to for the flush
	 *	which could be failed such as out of system resources during log IO.
	 */
	if ( fCommit0 )
		{
		if ( (err = ErrLGPrecommitTransaction( ppib, &lgposPrecommitRec ) ) < 0 )
			return err;

		ppib->lgposPrecommit0 = lgposPrecommitRec;
		
		grbit |= ppib->grbitsCommitDefault;

		if ( !( grbit & JET_bitCommitLazyFlush ) )
			{
			/*	remember the minimum requirement to flush. It is ok to use the beginning
			 *	of commit log record lgposLogRec since the way we flush is to flush up to
			 *	the end of all flushable log records and the whole log record will be
			 *	flushed.
			 */
			LeaveCriticalSection( critJet );
			err = ErrLGWaitPrecommit0Flush( ppib );
			EnterCriticalSection( critJet );
	
			Assert( err >= 0  ||
				( fLGNoMoreLogWrite  &&  err == JET_errLogWriteFail ) );

			if ( err < 0 )
				return err;
			}
		}
		
	/*	clean up before image chain.
	 */
	VERPrecommitTransaction( ppib );

SetTrx:
	if ( fCommit0 )
		{
		LeaveCriticalSection( critJet );
		EnterCriticalSection( critCommit0 );
		EnterCriticalSection( critJet );
		ppib->trxCommit0 = ++trxNewest;
		}

LogCommitRec:
	if ( (err = ErrLGCommitTransaction( ppib, ppib->level - 1 ) ) < 0 )
		{
		if ( fCommit0 )
			{
			LeaveCriticalSection( critCommit0 );
			if ( err == errLGNotSynchronous )
				{
				BFSleep( cmsecWaitLogFlush );
				goto SetTrx;
				}
			Assert( fLGNoMoreLogWrite );
			}
		else
			{
			if ( err == errLGNotSynchronous )
				{
				BFSleep( cmsecWaitLogFlush );
				goto LogCommitRec;
				}
			else
				return err;
			}
			
		/*	go ahead and continue since we have precommit logged.
		 */
		}

	/*	from this point, even log can not write, we behave like the commit is done
	 *	completely. Ignore any error occurs after this point,
	 */

	VERCommitTransaction( ppib, 0 );

	if ( err >= 0 && fCommit0 )
		{
		LeaveCriticalSection( critCommit0 );
		}
	
	/*	set all open cursor transaction levels to new level
	/**/
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
		{
		if ( pfucb->levelOpen > ppib->level )
			{
			pfucb->levelOpen = ppib->level;
			}

		if ( FFUCBRetPrepared( pfucb ) && pfucb->levelPrep == ppib->level + 1 )
			{
			pfucb->levelPrep = ppib->level;
			}

		if ( FFUCBDeferredUpdate( pfucb ) && pfucb->levelPrep == ppib->level )
			{
			/*	reset copy buffer status, which has been maintained
			/*	for rollback support.
			/**/
			FUCBResetDeferredChecksum( pfucb );
			FUCBResetUpdateSeparateLV( pfucb );
			FUCBResetCbstat( pfucb );
			Assert( pfucb->pLVBuf == NULL );
			}

		/*	set cursor navigation level for rollback support
		/**/
		Assert( fRecovering || LevelFUCBNavigate( pfucb ) <= ppib->level + 1 );
		if ( LevelFUCBNavigate( pfucb ) > ppib->level )
			{
			FUCBSetLevelNavigate( pfucb, ppib->level );
			}
		}

	/*	reset performed DDL operation flag on open cursors.  After commit to
	/*	level 0, DDL performed in transaction will not be rolled back.
	/*	Also, fully close cursors deferred closed.
	/**/
	if ( ppib->level == 0 )
		{
		DIRPurge( ppib );
		
#ifdef DEBUG
		ppib->dwLogThreadId = 0;
#endif
		}

	DIRAPIReturn( pfucbNil, JET_errSuccess );
	}


/*	closes deferred closed cursors not closed in commit to transaction
/*	level 0 via VERCommit.
/**/
VOID DIRPurge( PIB *ppib )
	{
	FUCB	*pfucb;
	FUCB	*pfucbNext;

	Assert( ppib->level == 0 );

	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucbNext )
		{
		pfucbNext = pfucb->pfucbNext;

		while ( FFCBWriteLatchByUs( pfucb->u.pfcb, ppib ) )
			{
			FCBResetWriteLatch( pfucb->u.pfcb, ppib );
			}
		if ( FFUCBDeferClosed( pfucb ) )
			{
			if ( FFUCBDenyRead( pfucb ) )
				FCBResetDomainDenyRead( pfucb->u.pfcb );
			if ( FFUCBDenyWrite( pfucb ) )
				FCBResetDomainDenyWrite( pfucb->u.pfcb );
			FCBUnlink( pfucb );
			FUCBClose( pfucb );
			}
		}

	return;
	}


ERR ErrDIRRollback( PIB *ppib )
	{
	ERR   	err;
	FUCB	*pfucb;

	CheckPIB( ppib );
	/*	must be in a transaction to rollback
	/**/
	Assert( ppib->level > 0 );

	/*	clean up cursor CSR stacks
	/*	leave each cursor with at most one CSR, and reset fFUCBAll flag
	/**/
	for ( pfucb = ppib->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNext )
		{
		Assert( fRecovering || LevelFUCBNavigate( pfucb ) <= ppib->level );
		if ( LevelFUCBNavigate( pfucb ) == ppib->level )
			{
			FUCBSetLevelNavigate( pfucb, ppib->level - 1 );
			if ( PcsrCurrent( pfucb ) != pcsrNil )
				{
				while ( PcsrCurrent( pfucb )->pcsrPath != pcsrNil )
					{
					BTUp( pfucb );
					}
				DIRBeforeFirst( pfucb );

				Assert( !FFUCBUpdatePrepared( pfucb ) ||
					pfucb->levelPrep == ppib->level );
				}
			}

		/*	reset copy buffer if prepared at transaction level
		/*	which is being rolled back.
		/**/
		Assert( !FFUCBUpdatePrepared( pfucb ) ||
			pfucb->levelPrep <= ppib->level );
		if ( FFUCBUpdatePreparedLevel( pfucb, ppib->level - 1 ) )
			{
			/*	reset update separate LV and copy buffer status on rollback.
			/*	All long value resources will be freed as a result of
			/*	rollback and currency is reset to copy buffer status must
			/*	be reset.
			/**/
			FUCBResetDeferredChecksum( pfucb );
			FUCBResetUpdateSeparateLV( pfucb );
			FUCBResetCbstat( pfucb );
			FLDFreeLVBuf( pfucb );
			Assert( pfucb->pLVBuf == NULL );
			}

		if ( FFUCBDeferredUpdate( pfucb ) &&
			pfucb->levelPrep == ppib->level - 1 )
			{
			/*	set copy buffer status to previous state
			/**/
			FUCBRollbackDeferredUpdate( pfucb );
			}
		}

	//	UNDONE:	rollback may fail from resource failure so
	//			we must retry in order to assure success
	/*	rollback changes made in transaction
	/**/
	CallS( ErrVERRollback( ppib ) );

	/*	log rollback. Must be called after VERRollback to record
	/*  the UNDO operations.  Do not handle error.
	/**/
	err = ErrLGRollback( ppib, 1 );
	Assert( err == JET_errSuccess ||
		err == JET_errLogWriteFail ||
		err == JET_errDiskFull );
	if ( err == JET_errLogWriteFail ||
		err == JET_errDiskFull )
		{
		/*	these error codes will lead to crash recovery which will
		/*	rollback transaction.
		/**/
		err = JET_errSuccess;
		}

#ifdef DEBUG
	if ( !ppib->level )
		{
		ppib->dwLogThreadId = 0;
		}
#endif

	/* if recoverying then we are done. No need to close fucb since they are faked and
	/* not the same behavior as regular fucb which could be deferred.
	/**/
	if ( !fRecovering )
		{
		/*	if rollback to level 0 then close deferred closed cursors
		/**/
		for ( pfucb = ppib->pfucb; pfucb != pfucbNil; )
			{
			FUCB    *pfucbT = pfucb->pfucbNext;

			if ( pfucb->levelOpen > ppib->level || ( ppib->level == 0 && FFUCBDeferClosed( pfucb ) ) )
				{
				if ( FFUCBDenyRead( pfucb ) )
					FCBResetDomainDenyRead( pfucb->u.pfcb );
				if ( FFUCBDenyWrite( pfucb ) )
					FCBResetDomainDenyWrite( pfucb->u.pfcb );
				FCBUnlink( pfucb );
				FUCBClose( pfucb );
				}

			pfucb = pfucbT;
			}
		}

	DIRAPIReturn( pfucbNil, err );
	}


#ifdef DEBUG


#define	cbKeyPrintMax		10 	
#define	cbDataPrintMax		10


VOID SPDump( FUCB *pfucb, INT cchIndent )
	{
	PGNO	pgno;
	CPG		cpg;
	INT		ich;

	/*	print indentation
	/**/
	for ( ich = 0; ich < cchIndent; ich++ )
		{		
		PrintF2( " " );
		}

	/*	print headings
	/**/
	if ( pfucb == pfucbNil )
		{
		PrintF2( "pgno      itag  bm        pgno last cpg\n");
		return;
		}

	Assert( pfucb->keyNode.cb == sizeof(PGNO) );
	pgno = *(PGNO UNALIGNED *)pfucb->keyNode.pb;

	Assert( pfucb->lineData.cb == sizeof(CPG) );
	cpg = *(PGNO UNALIGNED *)pfucb->lineData.pb;

	/*	print	node	pgno:itag
	/*					bookmark
	/*					pgno last
	/*					cpg
	/**/

	/*	print fixed lenght values
	/**/
	PrintF2( "%.8x  %.2x    %.8x  %.8x  %.8x",
		PcsrCurrent( pfucb )->pgno,
		PcsrCurrent( pfucb )->itag,
		PcsrCurrent( pfucb )->bm,
		pgno,
		cpg );

	/*	terminate line
	/**/
	PrintF2( "\n" );

	return;
	}


VOID LVDump( FUCB *pfucb, INT cchIndent )
	{
	ULONG		ulId = 0;
	LVROOT		lvroot;
	INT			ich;

	/*	print indentation
	/**/
	for ( ich = 0; ich < cchIndent; ich++ )
		{		
		PrintF2( " " );
		}

	/*	print headings
	/**/
	if ( pfucb == pfucbNil )
		{
		PrintF2( "****************** LONG VALUES ***********************\n" );
		PrintF2( "pgno      itag  bm        long id   lenght    reference count\n");
		return;
		}

	Assert( pfucb->keyNode.cb == sizeof(ulId) );
	//	UNDONE:	set long id from key

	Assert( pfucb->lineData.cb == sizeof(lvroot) );
	memcpy( &lvroot, pfucb->lineData.pb, sizeof(lvroot) );

	/*	print	node	pgno:itag
	/*					bookmark
	/*					long id
	/*					length
	/*					reference count
	/**/

	/*	print fixed lenght values
	/**/
	PrintF2( "%.8x  %.2x      %.8x  %.8x  %.8  %.8  ",
		PcsrCurrent( pfucb )->pgno,
		PcsrCurrent( pfucb )->itag,
		PcsrCurrent( pfucb )->bm,
		ulId,
		lvroot.ulSize,
		lvroot.ulReference );

	/*	terminate line
	/**/
	PrintF2( "\n" );

	return;
	}

BYTE mpbb[] = {	'0', '1', '2', '3', '4', '5', '6', '7',
				'8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
		
//BOOL fPrintFullKeys = fTrue;
BOOL fPrintFullKeys = fFalse;
BYTE rgbKeyLastGlobal[ JET_cbKeyMost + 1 ];
BYTE *pbKeyLastGlobal = rgbKeyLastGlobal;
INT cbKeyLastGlobal = 0;

VOID NDDump( FUCB *pfucb, INT cchIndent )
	{
	INT		cbT;
	INT		ibT;
	BYTE	szKey[JET_cbKeyMost * 3];
	BYTE	rgbData[cbDataPrintMax + 1];
	INT		ich;

	/*	print indentation
	/**/
	for ( ich = 0; ich < cchIndent; ich++ )
		{		
		PrintF2( " " );
		}

	/*	print headings
	/**/
	if ( pfucb == pfucbNil )
		{
		PrintF2( "pgno      itag  bm        header    key         data\n");
		return;
		}

	szKey[cbKeyPrintMax] = '\0';
	memset( szKey, ' ', cbKeyPrintMax );
	cbT = pfucb->keyNode.cb;
	if ( cbT > cbKeyPrintMax )
		cbT = cbKeyPrintMax;
	memcpy( szKey, pfucb->keyNode.pb, cbT );
		
	for ( ibT = 0; ibT < cbKeyPrintMax && ibT < (INT)pfucb->keyNode.cb; ibT++ )
		{
		if ( !( ( szKey[ibT] >= 'a' && szKey[ibT] <= 'z' ) ||
			( szKey[ibT] >= 'A' && szKey[ibT] <= 'Z' ) ) )
			{
			szKey[ibT] = '.';
			}
		}

	if ( fPrintFullKeys )
		{
		INT cbKey = (INT) pfucb->keyNode.cb;
		BYTE *pbKey = pfucb->keyNode.pb;
		BYTE *pbKeyMax = pbKey + pfucb->keyNode.cb;
		BYTE *pbPrint = szKey;
		
		if ( cbKeyLastGlobal == cbKey &&
			 memcmp( pbKeyLastGlobal, pbKey, cbKeyLastGlobal ) == 0 )
			*pbPrint++ = '*';
		else
			{
			*pbPrint++ = ' ';
			cbKeyLastGlobal = cbKey;
			memcpy( pbKeyLastGlobal, pbKey, cbKeyLastGlobal );
			}
		
		while ( pbKey < pbKeyMax )
			{
			BYTE b = *pbKey++;
			*pbPrint++ = mpbb[b >> 4];
			*pbPrint++ = mpbb[b & 0x0f];
			*pbPrint++ = ' ';
			}
		*pbPrint='\0';
		}

	rgbData[cbKeyPrintMax] = '\0';
	memset( rgbData, ' ', cbDataPrintMax );
	cbT = pfucb->lineData.cb;
	if ( cbT > cbDataPrintMax )
		cbT = cbDataPrintMax;
	memcpy( rgbData, pfucb->lineData.pb, cbT );
	for ( ibT = 0; ibT < cbDataPrintMax && ibT < (INT)pfucb->lineData.cb; ibT++ )
		{
		if ( !( ( rgbData[ibT] >= 'a' && rgbData[ibT] <= 'z' ) ||
			( rgbData[ibT] >= 'A' && rgbData[ibT] <= 'Z' ) ) )
			{
			rgbData[ibT] = '.';
			}
		}

	/*	print	node	pgno:itag
	/*					bookmark
	/*					header
	/*					key to 10 bytes
	/*					data to 10 bytes
	/**/

	/*	print fixed lenght values
	/**/
	PrintF2( "%.8x  %.2x    %.8x  %.2x        ",
		PcsrCurrent( pfucb )->pgno,
		PcsrCurrent( pfucb )->itag,
		PcsrCurrent( pfucb )->bm,
		*pfucb->ssib.line.pb );

	/*	print variable lenght values
	/**/
	PrintF2( "%s  %s", szKey, rgbData );

	/*	terminate line
	/**/
	PrintF2( "\n" );

	return;
	}


/*	prints tree nodes, indented by depth, in depth first fashion
/**/
ERR ErrDIRDump( FUCB *pfucb, INT cchIndent )
	{
	ERR	err = JET_errSuccess;
	DIB	dib;
	BYTE *pbKeyLastCurLevel;
	INT cbKeyLastCurLevel;

#define	cchPerDepth		5

	Call( ErrDIRGet( pfucb ) );
	/*	if parent is space node, then dump space
	/*	if parent is LONG, then dump long value root
	/*	otherwise dump node
	/**/										
	if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
		( ItagOfSrid( pfucb->sridFather ) == itagOWNEXT ||
		ItagOfSrid( pfucb->sridFather ) == itagAVAILEXT ) )
		{
		if ( cchIndent == 0 )
			SPDump( pfucbNil, cchIndent );
		SPDump( pfucb, cchIndent );
		}
	else if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
		ItagOfSrid( pfucb->sridFather ) == itagLONG )
		{
		if ( cchIndent == 0 )
			LVDump( pfucbNil, cchIndent );
		LVDump( pfucb, cchIndent );
		}
	else
		{
		if ( cchIndent == 0 )
			NDDump( pfucbNil, cchIndent );
		NDDump( pfucb, cchIndent );
		}

	pbKeyLastCurLevel = pbKeyLastGlobal;
	cbKeyLastCurLevel = cbKeyLastGlobal;

	dib.fFlags = fDIRNull;
	dib.pos = posFirst;
	err = ErrDIRDown( pfucb, &dib );
	if ( err != JET_errRecordNotFound )
		{
		if (!(pbKeyLastGlobal = SAlloc( sizeof( rgbKeyLastGlobal ) )))
			Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		cbKeyLastGlobal = 0;
		
		if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
			( ItagOfSrid( pfucb->sridFather ) == itagOWNEXT ||
			ItagOfSrid( pfucb->sridFather ) == itagAVAILEXT ) )
			{
			SPDump( pfucbNil, cchIndent + cchPerDepth );
			}
		else if ( PgnoOfSrid( pfucb->sridFather ) == pfucb->u.pfcb->pgnoFDP &&
			ItagOfSrid( pfucb->sridFather ) == itagLONG )
			{
			LVDump( pfucbNil, cchIndent + cchPerDepth );
			}
		else
			{
			NDDump( pfucbNil, cchIndent + cchPerDepth );
			}
			
		SFree( pbKeyLastGlobal );
		pbKeyLastGlobal = pbKeyLastCurLevel;
		cbKeyLastGlobal = cbKeyLastCurLevel;
		
		forever
			{
			if (!(pbKeyLastGlobal = SAlloc( sizeof( rgbKeyLastGlobal ))))
				Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
			cbKeyLastGlobal = 0;
			
			Call( ErrDIRDump( pfucb, cchIndent + cchPerDepth ) );
			
			SFree( pbKeyLastGlobal );
			pbKeyLastGlobal = pbKeyLastCurLevel;
			cbKeyLastGlobal = cbKeyLastCurLevel;
			
			err = ErrDIRNext( pfucb, &dib );
			if ( err < 0 )
				{
				if ( err == JET_errNoCurrentRecord )
					{
					break;
					}
				goto HandleError;
				}
			}

		if ( err == JET_errNoCurrentRecord )
			err = JET_errSuccess;

		DIRIUp( pfucb, 1 );
		}

	if ( err == JET_errRecordNotFound )
		err = JET_errSuccess;
HandleError:
	DIRAPIReturn( pfucbNil, err );
	}
#endif



// OBSOLETE -- to be removed
ERR ErrDIRCopyBookmarks( FUCB *pfucb,
	SRID 	*rgsrid,
	ULONG	csridMax,
	ULONG 	*pcsridCopied,
	BOOL	fNext )
	{
	ERR		err;
	//	UNDONE:	get rid of warning
	ERR		wrn;
	CSR		*pcsr;
	SRID	*psrid = rgsrid;
	SRID	*psridMax;
	DIB		dib;

	/*	initialize DIB
	/**/
	dib.fFlags = fDIRNull;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( pfucb->pbfEmpty == pbfNil );
	CheckCSR( pfucb );

	/*	check currency and refresh if necessary
	/**/
	Call( ErrDIRRefresh( pfucb ) );
	pcsr = PcsrCurrent( pfucb );

	/*	check CSR status
	/**/
	switch ( pcsr->csrstat )
		{
		case csrstatOnCurNode:
		case csrstatOnDataRoot:
			break;

		case csrstatOnFDPNode:
			Assert(0);
			break;

		default:
			Assert( pcsr->csrstat == csrstatBeforeCurNode ||
				pcsr->csrstat == csrstatAfterCurNode ||
				pcsr->csrstat == csrstatAfterLast ||
				pcsr->csrstat == csrstatBeforeFirst );
			return ErrERRCheck( JET_errNoCurrentRecord );
		}

	if ( fNext )
		{
		/*	copy bookmarks from clustered or non-clustered index
		/**/
		if ( FFUCBNonClustered( pfucb ) )
			{
			AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

			/*	item list nodes not versioned
			/**/
			dib.fFlags |= fDIRItemList;

			/*	non-clustered index nodes are always there
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRIGetItemList( pfucb, pcsr );

			Assert( psrid == rgsrid );
			for ( psridMax = rgsrid + csridMax; ; )
				{
				Assert( pcsr == PcsrCurrent( pfucb ) );
				*psrid++ = pcsr->item;

				Assert( psrid <= psridMax );
				if ( psrid == psridMax )
					break;

				/*	move to next item and next node until item found
				/**/
				while ( ( err = ErrDIRINextItem( pfucb ) ) < 0 )
					{
					Assert( err == errNDNoItem || err == errNDLastItemNode );
					/*	move to next node with DIB constraints
					/**/
					Call( ErrBTNext( pfucb, &dib ) );
					DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
					/*	set item list descriptor for subsequent ver
					/*	operations.
					/**/
					DIRICheckFirstSetItemListAndWarn( pfucb, wrn );
					err = ErrNDFirstItem( pfucb );
					if ( err == JET_errSuccess )
						{
						/*	check index range
						/**/
						if ( FFUCBLimstat( pfucb ) &&
							FFUCBUpper( pfucb ) )
							{
							Call( ErrDIRICheckIndexRange( pfucb ) );
							}
						break;
						}
					}
				}
			}
		else
			{
			Assert( psrid == rgsrid );
			for ( psridMax = rgsrid + csridMax; ; )
				{
				Assert( pcsr == PcsrCurrent( pfucb ) );
				*psrid++ = pcsr->bm;

				Assert( psrid <= psridMax );
				if ( psrid == psridMax )
					break;

				Call( ErrBTNext( pfucb, &dib ) );
				AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
				Assert( pcsr == PcsrCurrent( pfucb ) );
				DIRISetBookmark( pfucb, pcsr );

				Assert( err == JET_errSuccess );

				/*	check index range
				/**/
				if ( FFUCBLimstat( pfucb ) &&
					FFUCBUpper( pfucb ) )
					{
					Call( ErrDIRICheckIndexRange( pfucb ) );
					}
				}
			}
		}
	else
		{
		if ( FFUCBNonClustered( pfucb ) )
			{
			AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

			/*	item list nodes not versioned
			/**/
			dib.fFlags |= fDIRItemList;

			/*	non-clustered index nodes are always there.
			/**/
			pcsr->csrstat = csrstatOnCurNode;
			DIRIGetItemList( pfucb, pcsr );

			Assert( psrid == rgsrid );
			for ( psridMax = rgsrid + csridMax; ; )
				{
				Assert( pcsr == PcsrCurrent( pfucb ) );
				*psrid++ = pcsr->item;

				Assert( psrid <= psridMax );
				if ( psrid == psridMax )
					break;

				while ( ( err = ErrDIRIPrevItem( pfucb ) ) < 0 )
					{
					Assert( err == errNDNoItem || err == errNDFirstItemNode );
					/*	move to previous node with DIB constraints
					/**/
					Call( ErrBTPrev( pfucb, &dib ) );
					DIRIGetItemList( pfucb, PcsrCurrent( pfucb ) );
					/*	set item list descriptor for subsequent ver
					/*	operations.
					/**/
					DIRICheckLastSetItemListAndWarn( pfucb, wrn );
					err = ErrNDLastItem( pfucb );
					if ( err == JET_errSuccess )
						{
						/*	check index range.  If exceed range, then before first, disable
						/*	range and return no current record.
						/**/
						if ( FFUCBLimstat( pfucb ) &&
							!FFUCBUpper( pfucb ) )
							{
							Call( ErrDIRICheckIndexRange( pfucb ) );
							}
						break;
						}
					}
				}
			}
		else
			{
			Assert( psrid == rgsrid );
			for ( psridMax = rgsrid + csridMax; ; )
				{
				Assert( pcsr == PcsrCurrent( pfucb ) );
				*psrid++ = pcsr->bm;

				Assert( psrid <= psridMax );
				if ( psrid == psridMax )
					break;

				Call( ErrBTPrev( pfucb, &dib ) );
 				AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
				DIRISetBookmark( pfucb, PcsrCurrent( pfucb ) );

				Assert( err == JET_errSuccess );

				/*	check index range.  If exceed range, then before first, disable
				/*	range and return no current record.
				/**/
				if ( FFUCBLimstat( pfucb ) &&
					!FFUCBUpper( pfucb ) )
					{
					Call( ErrDIRICheckIndexRange( pfucb ) );
					}
				}
			}
		}

	DIRSetFresh( pfucb );
  	CheckCSR( pfucb );

HandleError:
	/*	reset currency fresh on error
	/**/
	if ( err < 0 )
		{
		DIRSetRefresh( pfucb );
		}

	/*	return count of bookmarks copied
	/**/
	Assert( pcsridCopied != NULL );
	*pcsridCopied = (ULONG)(psrid - rgsrid);

	CheckCSR( pfucb );
	DIRAPIReturn( pfucb, err );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\dump.c ===
#include "daestd.h"
#include "dbcc.h"
#include <ctype.h>

DeclAssertFile;					/* Declare file name for assert macros */


static char *rgszDBState[] = {
		"JustCreated",
		"Inconsistent",
		"Consistent" };


#ifdef DEBUG
// For ErrDUMPLog():

/* log file info. */
HANDLE		hfLog;			/* logfile handle */

CHAR		*pbLastMSFlush;	/* to LGBuf where last multi-sec flush LogRec sit*/

/* in-memory log buffer. */
#define		csecLGBufSize 100

extern CHAR	*pbLGBufMin;
extern CHAR *pbLGBufMax;

extern BOOL	fDBGTraceLog;
extern BOOL fDBGPrintToStdOut;

ULONG rgclrtyp[ lrtypMax ];
ULONG rgcb[ lrtypMax ];

extern INT cNOP;
extern CHAR *mplrtypsz[];

#endif


LOCAL VOID VARARG DUMPPrintF(const CHAR * fmt, ...)
	{
	va_list arg_ptr;
	va_start( arg_ptr, fmt );
	vprintf( fmt, arg_ptr );
	fflush( stdout );
	va_end( arg_ptr );
	}


LOCAL VOID DUMPPrintSig( SIGNATURE *psig )
	{
	LOGTIME tm = psig->logtimeCreate;
	DUMPPrintF( "Create time:%d/%d/%d %d:%d:%d ",
						(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
						(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
	DUMPPrintF( "Rand:%lu ", psig->ulRandom );
	DUMPPrintF( "Computer:%s\n", psig->szComputerName );
	}

ERR ErrDUMPCheckpoint( CHAR *szCheckpoint )
	{
	ERR			err;
	LGPOS		lgpos;
	LOGTIME		tm;
	CHECKPOINT	*pcheckpoint = NULL;
	DBMS_PARAM	dbms_param;
	DBID		dbid;

	pcheckpoint = (CHECKPOINT *) PvUtilAllocAndCommit( sizeof( CHECKPOINT ) );
	if ( pcheckpoint == NULL )
		return ErrERRCheck( JET_errOutOfMemory );

	Call( ErrInitializeCriticalSection( &critCheckpoint ) );

	err = ErrLGIReadCheckpoint( szCheckpoint, pcheckpoint );
	if ( err == JET_errSuccess )
		{
		lgpos = pcheckpoint->lgposLastFullBackupCheckpoint;
		DUMPPrintF( "      LastFullBackupCheckpoint (%u,%u,%u)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
		lgpos = pcheckpoint->lgposCheckpoint;
		DUMPPrintF( "      Checkpoint (%u,%u,%u)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );

		lgpos = pcheckpoint->lgposFullBackup;
		DUMPPrintF( "      FullBackup (%u,%u,%u)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );

		tm = pcheckpoint->logtimeFullBackup;
		DUMPPrintF( "      FullBackup time:%d/%d/%d %d:%d:%d\n",
					(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
					(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
		lgpos = pcheckpoint->lgposIncBackup;
		DUMPPrintF( "      IncBackup (%u,%u,%u)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );

		tm = pcheckpoint->logtimeIncBackup;
		DUMPPrintF( "      IncBackup time:%d/%d/%d %d:%d:%d\n",
					(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
					(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);

		DUMPPrintF( "      Signature: " );
		DUMPPrintSig( &pcheckpoint->signLog );

		dbms_param = pcheckpoint->dbms_param;
		DUMPPrintF( "      Env (Session, Opentbl, VerPage, Cursors, LogBufs, LogFile, Buffers)\n");
		DUMPPrintF( "          (%7lu, %7lu, %7lu, %7lu, %7lu, %7lu, %7lu)\n",
					dbms_param.ulMaxSessions, dbms_param.ulMaxOpenTables,
					dbms_param.ulMaxVerPages, dbms_param.ulMaxCursors,
					dbms_param.ulLogBuffers, dbms_param.ulcsecLGFile,
					dbms_param.ulMaxBuffers );
		
		rgfmp = (FMP *) LAlloc( (long) dbidMax, sizeof(FMP) );
        if (rgfmp == NULL)
            Call( JET_errOutOfMemory );
		for ( dbid = 0; dbid < dbidMax; dbid++)
			memset( &rgfmp[dbid], 0, sizeof(FMP) );
		Call( ErrLGLoadFMPFromAttachments( pcheckpoint->rgbAttach ) );
		for ( dbid = 0; dbid < dbidMax; dbid++)
			if ( rgfmp[dbid].szDatabaseName )
				{
				ATCHCHK *patchchk = rgfmp[dbid].patchchk;

				DUMPPrintF( "      %d %s %s %s %s\n", (INT)dbid, rgfmp[dbid].szDatabaseName,
							FDBIDLogOn(dbid) ? "LogOn" : "LogOff",
							FDBIDVersioningOff(dbid) ? "VerOff" : "VerOn",
							FDBIDReadOnly(dbid) ? "R" : "RW"
							);
				DUMPPrintF( "      Signature: " );
				DUMPPrintSig( &patchchk->signDb );
				DUMPPrintF( "      Last Attach (%u,%u,%u)  ",
						patchchk->lgposAttach.lGeneration,
						patchchk->lgposAttach.isec,
						patchchk->lgposAttach.ib );
				DUMPPrintF( "Last Consistent (%u,%u,%u)\n",
						patchchk->lgposConsistent.lGeneration,
						patchchk->lgposConsistent.isec,
						patchchk->lgposConsistent.ib );
				}
		}

HandleError:
    if (pcheckpoint)
	    UtilFree( pcheckpoint );
    if (critCheckpoint)
	    UtilDeleteCriticalSection( critCheckpoint );
	return err;
	}


#ifdef DEBUG

ERR ErrDUMPLog( CHAR *szLog )
	{
	ERR			err;
	LGPOS		lgposFirstT;
	BYTE		*pbNextLR;
	BOOL		fCloseNormally;
	CHECKPOINT	*pcheckpoint = NULL;
	DBMS_PARAM	dbms_param;
	DBID		dbid;
	LGPOS		lgposCheckpoint;
	INT			i;
	BYTE 	  	szPathJetChkLog[_MAX_PATH];
	
	fDBGPrintToStdOut = fTrue;
	csecLGBuf = csecLGBufSize;

	memset( rgclrtyp, 0, sizeof( rgclrtyp ) );
	memset( rgcb, 0, sizeof( rgcb ) );
	CallR( ErrInitializeCriticalSection( &critLGBuf ) < 0 );
	Call( ErrInitializeCriticalSection( &critCheckpoint ) < 0 );

	fLGIgnoreVersion = fTrue;
	fRecovering = fTrue;		/* behave like doing recovery */
	plgfilehdrGlobal = NULL;

	/* open the log file, and read dump its log record. */
	fDBGTraceLog = fTrue;
	err = ErrUtilOpenReadFile( szLog, &hfLog );
	if ( err < 0 )
		{
		DUMPPrintF("Cannot open file %s.\n\n", szLog);
		goto HandleError;
		}

	/* dump file header */
	plgfilehdrGlobal = (LGFILEHDR *) PvUtilAllocAndCommit( sizeof( LGFILEHDR ) );
	if ( plgfilehdrGlobal == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	err = ErrLGReadFileHdr( hfLog, plgfilehdrGlobal, fNoCheckLogID );
	if ( err < 0 )
		{
		DUMPPrintF("Cannot read log file header.\n\n");
		goto HandleError;
		}
		
	DUMPPrintF( "      lGeneration (%u)\n", plgfilehdrGlobal->lGeneration);

	/*	dump checkpoint file
	/**/
	pcheckpoint = (CHECKPOINT *)PvUtilAllocAndCommit( sizeof( CHECKPOINT ) );
	if ( pcheckpoint == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	LGFullNameCheckpoint( szPathJetChkLog );
	err = ErrLGIReadCheckpoint( szPathJetChkLog, pcheckpoint );
	if ( err == JET_errSuccess )
		{
		lgposCheckpoint = pcheckpoint->lgposCheckpoint;
		DUMPPrintF( "      Checkpoint (%u,%u,%u)\n",
			lgposCheckpoint.lGeneration,
			lgposCheckpoint.isec,
			lgposCheckpoint.ib );
		}
	else
		{
		DUMPPrintF( "      Checkpoint NOT AVAILABLE\n" );
		err = JET_errSuccess;
		}

	DUMPPrintF( "      creation time:%d/%d/%d %d:%d:%d\n",
		(short) plgfilehdrGlobal->tmCreate.bMonth,
		(short) plgfilehdrGlobal->tmCreate.bDay,
		(short) plgfilehdrGlobal->tmCreate.bYear + 1900,
		(short) plgfilehdrGlobal->tmCreate.bHours,
		(short) plgfilehdrGlobal->tmCreate.bMinutes,
		(short) plgfilehdrGlobal->tmCreate.bSeconds);
		
	DUMPPrintF( "      prev gen time:%d/%d/%d %d:%d:%d\n",
		(short) plgfilehdrGlobal->tmPrevGen.bMonth,
		(short) plgfilehdrGlobal->tmPrevGen.bDay,
		(short) plgfilehdrGlobal->tmPrevGen.bYear + 1900,
		(short) plgfilehdrGlobal->tmPrevGen.bHours,
		(short) plgfilehdrGlobal->tmPrevGen.bMinutes,
		(short) plgfilehdrGlobal->tmPrevGen.bSeconds);
	
#if 0
	DUMPPrintF( "             fEndWithMS:%d. ulVersion(%d.%d). Computer:%s\n",
		(short) plgfilehdrGlobal->fEndWithMS,
		(short) plgfilehdrGlobal->ulVersion >> 16,
		(short) plgfilehdrGlobal->ulVersion & 0x0ff,
		plgfilehdrGlobal->szComputerName);
#endif	

	DUMPPrintF( "      ulVersion(%d.%d)\n",
		(short) plgfilehdrGlobal->ulMajor,
		(short) plgfilehdrGlobal->ulMinor );

	DUMPPrintF( "      Signature: " );
	DUMPPrintSig( &plgfilehdrGlobal->signLog );

	DUMPPrintF( "      Env SystemPath:%s\n",
		plgfilehdrGlobal->dbms_param.szSystemPath);
	
	DUMPPrintF( "      Env LogFilePath:%s\n",
		plgfilehdrGlobal->dbms_param.szLogFilePath);
	
	DUMPPrintF( "      Env Log Sec size:%d\n",	plgfilehdrGlobal->cbSec);
	
	dbms_param = plgfilehdrGlobal->dbms_param;
	DUMPPrintF( "      Env (Session, Opentbl, VerPage, Cursors, LogBufs, LogFile, Buffers)\n");
	DUMPPrintF( "          (%7lu, %7lu, %7lu, %7lu, %7lu, %7lu, %7lu)\n",
				dbms_param.ulMaxSessions, dbms_param.ulMaxOpenTables,
				dbms_param.ulMaxVerPages, dbms_param.ulMaxCursors,
				dbms_param.ulLogBuffers, dbms_param.ulcsecLGFile,
				dbms_param.ulMaxBuffers );
			
	rgfmp = (FMP *) LAlloc( (long) dbidMax, sizeof(FMP) );
	for ( dbid = 0; dbid < dbidMax; dbid++)
		memset( &rgfmp[dbid], 0, sizeof(FMP) );
	err = ErrLGLoadFMPFromAttachments( plgfilehdrGlobal->rgbAttach );
	if ( err < 0 )
		{
		DUMPPrintF("Cannot read log file header.\n\n");
		goto HandleError;
		}
		

	for ( dbid = 0; dbid < dbidMax; dbid++)
		if ( rgfmp[dbid].szDatabaseName )
			{
			ATCHCHK *patchchk = rgfmp[dbid].patchchk;

			DUMPPrintF( "      %d %s\n", (INT)dbid, rgfmp[dbid].szDatabaseName );
			DUMPPrintF( "      Signature: " );
			DUMPPrintSig( &patchchk->signDb );
			DUMPPrintF( "      Last Attach (%u,%u,%u)  ",
							patchchk->lgposAttach.lGeneration,
							patchchk->lgposAttach.isec,
							patchchk->lgposAttach.ib );
			DUMPPrintF( "Last Consistent (%u,%u,%u)\n",
							patchchk->lgposConsistent.lGeneration,
							patchchk->lgposConsistent.isec,
							patchchk->lgposConsistent.ib );
			}

	/*	set buffer
	/**/
	cbSec = plgfilehdrGlobal->cbSec;
	pbLGBufMin = (BYTE *) PvUtilAllocAndCommit( csecLGBuf * cbSec );
	if ( pbLGBufMin == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	/*	reserve extra buffer for read ahead in redo
	/**/
	csecLGBuf--;
	pbLGBufMax = pbLGBufMin + csecLGBuf * cbSec;

	/* initialize othe variables
	 */
	memset( rgclrtyp, 0, sizeof( rgclrtyp ) );
	memset( rgcb, 0, sizeof( rgcb ) );

	/* read through the log file. */
	(VOID) ErrLGCheckReadLastLogRecord( &fCloseNormally);
	GetLgposOfPbEntry(&lgposLastRec);
	DUMPPrintF( "      Last Lgpos (%u,%u,%u)\n",
			lgposLastRec.lGeneration,
			lgposLastRec.isec,
			lgposLastRec.ib );
	
	pbLastMSFlush = 0;
	memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );
	lgposFirstT.lGeneration = plgfilehdrGlobal->lGeneration;
	lgposFirstT.isec = (WORD) csecHeader;
	lgposFirstT.ib = 0;
	
	ErrLGLocateFirstRedoLogRec( &lgposFirstT, &pbNextLR);
	
	PrintLgposReadLR();
	ShowLR((LR *)pbNextLR);

	rgclrtyp[ *pbNextLR ]++;
	rgcb[ *pbNextLR ] += CbLGSizeOfRec( (LR*) pbNextLR );

	fDBGTraceRedo = fTrue;
	while(ErrLGGetNextRec(&pbNextLR) == JET_errSuccess)
		{
			
		rgclrtyp[ *pbNextLR ]++;
		rgcb[ *pbNextLR ] += CbLGSizeOfRec( (LR*) pbNextLR );
		
		if ( *pbNextLR == lrtypEnd )
			break;
		else
			{
			LR *plr = (LR *) pbNextLR;
			
			if ( cNOP >= 1 && plr->lrtyp != lrtypNOP )
				{
				DUMPPrintF( " * %d", cNOP );
				cNOP = 0;
				}

			if ( cNOP == 0 || plr->lrtyp != lrtypNOP )
				{
				PrintLgposReadLR();
				ShowLR( plr );
				}
			}
		}

	if ( cNOP >= 1 )
		DUMPPrintF( " * %d", cNOP );

	DUMPPrintF("\n");
	for ( i = 0; i < lrtypMax; i++ )
		{
		if ( rgclrtyp[i] )
			DUMPPrintF( "%s %7lu	%7lu\n", mplrtypsz[i], rgclrtyp[i], rgcb[i]/rgclrtyp[i] );
		else
			DUMPPrintF( "%s %7lu	%7lu\n", mplrtypsz[i], rgclrtyp[i], 0 );
		}
	
HandleError:
	if ( pcheckpoint != NULL )
		UtilFree( pcheckpoint );
	if ( plgfilehdrGlobal != NULL )		
		UtilFree( plgfilehdrGlobal );
		
	UtilDeleteCriticalSection( critLGBuf );
	UtilDeleteCriticalSection( critCheckpoint );
	
	return err;
	}

#endif		// DEBUG


INLINE LOCAL VOID DUMPPrintBkinfo( BKINFO *pbkinfo )
	{
	LONG	genLow, genHigh;
	LOGTIME	tm = pbkinfo->logtimeMark;
	LGPOS	lgpos = pbkinfo->lgposMark;
	
	genLow = pbkinfo->genLow;
	genHigh = pbkinfo->genHigh;
	DUMPPrintF( "        Log Gen: %1l-%1l %1x-%1x\n", genLow, genHigh, genLow, genHigh );
	DUMPPrintF( "           Mark: (%u,%u,%u)\n", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	DUMPPrintF( "           Mark: %d/%d/%d %d:%d:%d\n",
						(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
						(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
	}	
		
ERR ErrDUMPHeader( CHAR *szDatabase, BOOL fSetState )
	{
	ERR			err;
	DBFILEHDR	*pdfh;
	LGPOS		lgpos;
	LOGTIME		tm;

	pdfh = (DBFILEHDR * )PvUtilAllocAndCommit( sizeof( DBFILEHDR ) );
	if ( pdfh == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	
	err = ErrUtilReadShadowedHeader( szDatabase, (BYTE *)pdfh, sizeof( DBFILEHDR ) );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	if ( fSetState )
		{
		pdfh->fDBState = fDBStateConsistent;
		}
	Call( ErrUtilWriteShadowedHeader( szDatabase, (BYTE *)pdfh, sizeof( DBFILEHDR ) ) );

	DUMPPrintF( "        ulMagic: 0x%lx\n", pdfh->ulMagic );
	DUMPPrintF( "      ulVersion: 0x%lx\n", pdfh->ulVersion );
		
	DUMPPrintF( "   DB Signature: " );
	DUMPPrintSig( &pdfh->signDb );
		
	DUMPPrintF( "       ulDBTime: %lu-%lu\n", pdfh->ulDBTimeHigh, pdfh->ulDBTimeLow );
		
	DUMPPrintF( "          State: %s\n", rgszDBState[pdfh->fDBState - 1] );

	lgpos = pdfh->lgposConsistent;
	DUMPPrintF( "Last Consistent: (%u,%u,%u)  ", lgpos.lGeneration, lgpos.isec, lgpos.ib );
	
	tm = pdfh->logtimeConsistent;
	DUMPPrintF( "%d/%d/%d %d:%d:%d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
			
	lgpos = pdfh->lgposAttach;
	DUMPPrintF( "    Last Attach: (%u,%u,%u)  ", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	tm = pdfh->logtimeAttach;
	DUMPPrintF( "%d/%d/%d %d:%d:%d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
	lgpos = pdfh->lgposDetach;
	DUMPPrintF( "    Last Detach: (%u,%u,%u)  ", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	tm = pdfh->logtimeDetach;
	DUMPPrintF( "%d/%d/%d %d:%d:%d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
	DUMPPrintF( "           Dbid: %d\n", (short) pdfh->dbid );
		
	DUMPPrintF( "  Log Signature: " );
	DUMPPrintSig( &pdfh->signLog );

	DUMPPrintF( "\nPrevious Full Backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoFullPrev );
	
	DUMPPrintF( "\nCurrent Incremental Backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoIncPrev );
		
	DUMPPrintF( "\nCurrent Full Backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoFullCur );

HandleError:
	UtilFree( pdfh );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\edbperf.h ===
/*  Performance counter symbol file "edbperf.h" from "edbperf.dat"  */


#define EDB 0
#define OpenTableCacheHits 2
#define OpenTableCacheRequests 4
#define LGBytesWrittenPerSec 6
#define LGUsersWaiting 8
#define LGCheckpointDepth 10
#define BFSyncReadsPerSec 12
#define BFAsyncReadsPerSec 14
#define BFBytesReadPerSec 16
#define BFSyncWritesPerSec 18
#define BFAsyncWritesPerSec 20
#define BFBytesWrittenPerSec 22
#define BFIOQueueLength 24
#define BFCacheHits 26
#define BFCacheRequests 28
#define BFPctClean 30
#define BFTotalBuffers2 32
#define BFPctAvail 34
#define BFTotalBuffers3 36
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\dbutil.c ===
#include "daestd.h"
#include "dbcc.h"

DeclAssertFile;					/* Declare file name for assert macros */



//	description of page_info table
static CODECONST( JET_COLUMNDEF ) rgcolumndefPageInfoTable[] =
	{
	//	Pgno
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnTTKey}, 

	//	consistency checked
	{sizeof(JET_COLUMNDEF), 0, JET_coltypBit, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnNotNULL},
	
	//	Avail
	{sizeof(JET_COLUMNDEF), 0, JET_coltypBit, 0, 0, 0, 0, 0, JET_bitColumnFixed },

	//	Modified
	{sizeof(JET_COLUMNDEF), 0, JET_coltypBit, 0, 0, 0, 0, 0, JET_bitColumnFixed },

	//	Tags used
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed},

	//	Forward links
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed},

	//	Space free
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed},

	//	Pgno left
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }, 

	//	Pgno right
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};	

#define icolumnidPageInfoPgno			0
#define icolumnidPageInfoFChecked		1
#define icolumnidPageInfoFAvail			2
#define	icolumnidPageInfoFModified		3
#define	icolumnidPageInfoTags			4
#define	icolumnidPageInfoLinks			5
#define	icolumnidPageInfoFreeSpace		6
#define	icolumnidPageInfoPgnoLeft		7
#define	icolumnidPageInfoPgnoRight		8

#define	ccolumndefPageInfoTable	( sizeof ( rgcolumndefPageInfoTable ) / sizeof(JET_COLUMNDEF) )

JET_COLUMNID 	rgcolumnidPageInfoTable[ccolumndefPageInfoTable];



//	description of space info table
static CODECONST( JET_COLUMNDEF ) rgcolumndefSpaceInfoTable[] =
	{
	//	Table Name
	{sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey}, 

	//	Index Name
	{sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey}, 

	//	Flag Clustered Index
	{sizeof(JET_COLUMNDEF), 0, JET_coltypBit, 0, 0, 0, 0, sizeof(BYTE), JET_bitColumnFixed},

	//	Cpg Owned
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, sizeof(LONG), JET_bitColumnFixed},

	//	Cpg Avail
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, sizeof(LONG), JET_bitColumnFixed},

	//	Pgno First
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, sizeof(LONG), JET_bitColumnFixed},

	//	Cpg Extent
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, sizeof(LONG), JET_bitColumnFixed},

	//	Stabilizer
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, sizeof(LONG), JET_bitColumnFixed|JET_bitColumnTTKey},

	//	Tree level
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, sizeof(LONG), JET_bitColumnFixed},

	//	Pgno This
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, sizeof(LONG), JET_bitColumnFixed}
	};

#define	icolumnidSpaceInfoTableName			0
#define	icolumnidSpaceInfoIndexName			1
#define	icolumnidSpaceInfoFClusteredIndex 	2
#define	icolumnidSpaceInfoCpgOwned			3
#define	icolumnidSpaceInfoCpgAvail			4
#define	icolumnidSpaceInfoPgnoFDP			5
#define	icolumnidSpaceInfoPgnoFirst			6
#define	icolumnidSpaceInfoCpgExtent			7
#define	icolumnidSpaceInfoStablizer			8
#define	icolumnidSpaceInfoTreeLevel			9
#define	icolumnidSpaceInfoPgnoThis			10

#define	ccolumndefSpaceInfoTable	( sizeof(rgcolumndefSpaceInfoTable) / sizeof(JET_COLUMNDEF) )

JET_COLUMNID 	rgcolumnidSpaceInfoTable[ccolumndefSpaceInfoTable];


#define szOneIndent		"    "
#define cbOneIndent		(sizeof(szOneIndent))
#define cMaxIndentLevel	4


//  Normalize data/text to displayable form from source data of a given
//  length to a destination string, stopping at cchApproxMax characters
//  (including the terminating NULL), plus a maximum overflow of five
//  more characters

#define ichDumpMaxNorm	64
#define ichDumpNormTextSlop 7

LOCAL VOID DBUTLSprintNormText( CHAR *szDest, CHAR *rgbSrc, INT cbSrc, INT cchApproxMax )
	{
	INT		ibSrc;
	INT		ibDest;

	//  convert text
	for ( ibSrc = 0, ibDest = 0; ibSrc < cbSrc && ibDest < (cchApproxMax - 1); ibSrc++ )
		{
		if ( isprint( rgbSrc[ibSrc] ) )
			{
			szDest[ibDest] = rgbSrc[ibSrc];
			ibDest += 1;
			}
		else
			{
			sprintf( szDest+ibDest, "\\x%.2x", (UCHAR)rgbSrc[ibSrc] );	// Cast to UNSIGNED to prevent sign extension
			ibDest += 4;
			}
		}
	szDest[ibDest] = '\0';

	//  if we didn't finish, add an ellipsis
	if ( ibSrc < cbSrc )
		strcat( szDest, "..." );

	return;
	}


LOCAL VOID DBUTLPrintfIntN( INT iValue, INT ichMax )
	{
	CHAR	rgchT[17]; /* C-runtime max bytes == 17 */
	INT		ichT;

	_itoa( iValue, rgchT, 10 );
	for ( ichT = 0; rgchT[ichT] != '\0' && ichT < 17; ichT++ )
		;
	if ( ichT > ichMax )
		{
		for ( ichT = 0; ichT < ichMax; ichT++ )
			printf( "#" );
		}
	else
		{
		for ( ichT = ichMax - ichT; ichT > 0; ichT-- )
			printf( " " );
		for ( ichT = 0; rgchT[ichT] != '\0'; ichT++ )
			printf( "%c", rgchT[ichT] );
		}
	return;
	}

LOCAL VOID DBUTLPrintfStringN( CHAR *sz, INT ichMax )
	{
	INT		ich;

	for ( ich = 0; sz[ich] != '\0' && ich < ichMax; ich++ )
		printf( "%c", sz[ich] );
	for ( ; ich < ichMax; ich++ )
		printf( " " );
	printf( " " );
	return;
	}


/*	register pages in PageInfo result table
/**/
LOCAL ERR ErrDBUTLRegExt( DBCCINFO *pdbccinfo, PGNO pgnoFirst, CPG cpg, BOOL fAvailT )
	{
	ERR 			err = JET_errSuccess;
	PGNO			pgno;
	PIB				*ppib = pdbccinfo->ppib;
	JET_SESID		sesid = (JET_SESID) pdbccinfo->ppib;
	JET_TABLEID		tableid = pdbccinfo->tableidPageInfo;
	BYTE			fAvail = (BYTE) fAvailT;
	
	Assert( tableid != JET_tableidNil );

	for ( pgno = pgnoFirst; pgno <= pgnoFirst + cpg - 1; pgno++ )
		{
		BOOL		fFound;
		BYTE		fChecked = fFalse;

		CallR( ErrIsamBeginTransaction( (JET_VSESID) ppib ) );

		/*	search for page in the table
		/**/
		CallS( ErrDispMakeKey( sesid, tableid, (BYTE *)&pgno, sizeof(pgno), JET_bitNewKey ) );
  		err = ErrDispSeek( sesid, tableid, JET_bitSeekEQ );
		if ( err < 0 && err != JET_errRecordNotFound )
			{
			Assert( fFalse );
			Call( err );
			}
		
		fFound = ( err == JET_errRecordNotFound ) ? fFalse : fTrue;
		if ( fFound )
			{
			ULONG	cbActual;
			BYTE	fAvailT2;
			
			/*	is this in availext
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
				(BYTE *)&fAvailT2,
				sizeof(fAvailT2),
				&cbActual,
				0,
				NULL ) );

			Assert( err == JET_wrnColumnNull || cbActual == sizeof(fAvailT2) );
			if ( err != JET_wrnColumnNull )
				{
				Assert( !fAvail || fAvailT2 );
				}

			/*	if fAvail is false, no changes to record
			/**/
			if ( !fAvail )
				goto Commit;

			/*	get fChecked [for setting it later]
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
				(BYTE *)&fChecked,
				sizeof(fChecked),
				&cbActual,
				0,
				NULL ) );

			Assert( cbActual == sizeof(fChecked) );

			Call( ErrDispPrepareUpdate( sesid, tableid, JET_prepReplaceNoLock ) );
			}
		else
			{
			Call( ErrDispPrepareUpdate( sesid, tableid, JET_prepInsert ) );

			/*	pgno
			/**/
			Call( ErrDispSetColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoPgno],
				(BYTE *) &pgno, 
				sizeof(pgno), 
				0, 
				NULL ) );
			}

		/*	set FChecked
		/**/
		Call( ErrDispSetColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
			(BYTE *)&fChecked, 
			sizeof(fChecked), 
			0, 
			NULL ) );

		/*	fAvail set if in AvailExt node
		/**/
		if ( fAvail )
			{
			Call( ErrDispSetColumn( sesid,
				tableid,
				rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
				(BYTE *) &fAvail, 
				sizeof(fAvail), 
				0, 
				NULL ) );
			}

		/*	update
		/**/
		Call( ErrDispUpdate( sesid, tableid, NULL, 0, NULL ) );								
		
		/*	commit
		/**/
Commit:
		Assert( ppib->level == 1 );
		Call( ErrIsamCommitTransaction( ( JET_VSESID ) ppib, 0 ) );
		}

	return JET_errSuccess;
	
HandleError:
	CallS( ErrIsamRollback( (JET_VSESID) ppib, JET_bitRollbackAll ) );

	return err;
	}


/*	check consistency of page if not checked before,
/*	and collect stats if required.
/**/
LOCAL ERR ErrDBUTLCheckPage( DBCCINFO *pdbccinfo, FUCB *pfucbT )
	{
	ERR 			err = JET_errSuccess;
	PIB				*ppib = pdbccinfo->ppib;
	PGNO			pgnoThis = PcsrCurrent( pfucbT )->pgno;
	SSIB			*pssib = &pfucbT->ssib; 
	PGNO			pgnoLeft;
	PGNO			pgnoRight;
	BYTE			fChecked = fFalse;
	BYTE 			fModified = FPMPageModified( pssib->pbf->ppage );
	BYTE 			fAvail = fFalse;
	ULONG			cLinks = CbPMLinkSpace( pssib ) / sizeof(TAG);
	ULONG			cUsedTags = ctagMax - CPMIFreeTag( pssib->pbf->ppage );
	ULONG			cbFreeSpace = CbNDFreePageSpace( pssib->pbf );
	BOOL			fFound;
	JET_SESID		sesid = (JET_SESID) pdbccinfo->ppib;
	JET_TABLEID		tableid = pdbccinfo->tableidPageInfo;
	BF				*pbfLatched;

	if ( !( pdbccinfo->grbitOptions & JET_bitDBUtilOptionPageDump ) )
		{
#ifdef DEBUG
		PageConsistent( pssib->pbf->ppage );
#endif
		return JET_errSuccess;
		}

	Assert( tableid != JET_tableidNil );

	/*	pin page in memory
	/**/
	pbfLatched = pssib->pbf;
	BFPin( pbfLatched );

	/*	search for page in the table
	/**/
	err = ErrDispMove( sesid, tableid, JET_MoveFirst, 0 );
	if ( err < 0 && err != JET_errNoCurrentRecord )
		{
		CallJ( err, Unpin );
		}

	CallS( ErrDispMakeKey( sesid, tableid, (BYTE *)&pgnoThis, sizeof(pgnoThis), JET_bitNewKey ) );

	err = ErrDispSeek( sesid, tableid, JET_bitSeekEQ );
	if ( err < 0 && err != JET_errRecordNotFound )
		{
		Assert( fFalse );
		CallJ( err, Unpin );
		}
	else 
		{
		fFound = err == JET_errRecordNotFound ? fFalse : fTrue;
		}
	
	CallJ( ErrIsamBeginTransaction( (JET_VSESID) ppib ), Unpin );

	if ( fFound )
		{
		ULONG	cbActual;
		
		/*	if page already been checked then return
		/**/
		Call( ErrDispRetrieveColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
			(BYTE *)&fChecked,
			sizeof(fChecked),
			&cbActual,
			0,
			NULL ) );

		Assert( cbActual == sizeof(fChecked) );

		if ( fChecked )
			{
			goto HandleError;
			}
		
		/*	page should not be avail
		/**/
		Call( ErrDispRetrieveColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
			(BYTE *)&fAvail,
			sizeof(fAvail),
			&cbActual,
			0,
			NULL ) );
		Assert( cbActual == sizeof(fAvail) || err == JET_wrnColumnNull );
		Assert( err == JET_wrnColumnNull || !fAvail );

		Call( ErrDispPrepareUpdate( sesid, tableid, JET_prepReplaceNoLock ) );
		}
	else
		{
		Call( ErrDispPrepareUpdate( sesid, tableid, JET_prepInsert ) );

		/*	pgno
		/**/
		Call( ErrDispSetColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoPgno],
			(BYTE *) &pgnoThis, 
			sizeof(pgnoThis), 
			0, 
			NULL ) );
		}

	/*	check page and set FChecked
	/**/
#ifdef DEBUG
	PageConsistent( pssib->pbf->ppage );
#endif

	fChecked = fTrue;
	Call( ErrDispSetColumn( sesid, 
		tableid, 
		rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
		(BYTE *) &fChecked, 
		sizeof(fChecked), 
		0, 
		NULL ) );

	/*	fAvail
	/**/
	fAvail = fFalse;
	Call( ErrDispSetColumn( sesid,
		tableid,
		rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
		(BYTE *) &fAvail, 
		sizeof(fAvail), 
		0, 
		NULL ) );

	/*	modified bit
	/**/
	Call( ErrDispSetColumn( sesid,
		tableid,
		rgcolumnidPageInfoTable[icolumnidPageInfoFModified],
		(BYTE *) &fModified, 
		sizeof(fModified), 
		0, 
		NULL ) );
								
	/*	left and right pgno
	/**/
	PgnoPrevFromPage( pssib, &pgnoLeft );
	PgnoNextFromPage( pssib, &pgnoRight );
	
	Call( ErrDispSetColumn( sesid, 
		tableid, 
		rgcolumnidPageInfoTable[icolumnidPageInfoPgnoLeft],
		(BYTE *) &pgnoLeft, 
		sizeof(pgnoLeft), 
		0, 
		NULL ) );
								
	Call( ErrDispSetColumn( sesid, 
		tableid, 
		rgcolumnidPageInfoTable[icolumnidPageInfoPgnoRight],
		(BYTE *) &pgnoRight, 
		sizeof(pgnoRight), 
		0, 
		NULL ) );
								
	/*	links
	/**/
	Call( ErrDispSetColumn( sesid, 
		tableid, 
		rgcolumnidPageInfoTable[icolumnidPageInfoLinks],
		(BYTE *) &cLinks, 
		sizeof(cLinks), 
		0, 
		NULL ) );
								
	/*	tags
	/**/
	Call( ErrDispSetColumn( sesid, 
		tableid, 
		rgcolumnidPageInfoTable[icolumnidPageInfoTags],
		(BYTE *) &cUsedTags, 
		sizeof(cUsedTags), 
		0, 
		NULL ) );

	/*	free space
	/**/
	Call( ErrDispSetColumn( sesid, 
		tableid, 
		rgcolumnidPageInfoTable[icolumnidPageInfoFreeSpace],
		(BYTE *) &cbFreeSpace, 
		sizeof(cbFreeSpace), 
		0, 
		NULL ) );

	/*	update and commit
	/**/
	Call( ErrDispUpdate( sesid, tableid, NULL, 0, NULL ) );								
				
	Call( ErrIsamCommitTransaction( ( JET_VSESID ) ppib, 0 ) );

	BFUnpin( pbfLatched );

	return JET_errSuccess;
	
HandleError:
	CallS( ErrIsamRollback( (JET_VSESID) ppib, JET_bitRollbackAll ) );

Unpin:
	BFUnpin( pbfLatched );
	return err;
	}


LOCAL ERR ErrDBUTLCheckBookmark(
	DBCCINFO	*pdbccinfo,
	PGNO		pgnoBM,
	INT			itagBM )
	{
	ERR		err;
	FUCB	*pfucb;
	FUCB	*pfucbT;

	pfucb = pdbccinfo->pfucb;
	Assert( PcsrCurrent( pfucb )->pgno != pgnoBM );

	CallR( ErrDIROpen(
		pdbccinfo->ppib,
		pfucb->u.pfcb,
		pfucb->dbid,
		&pfucbT ) );

	/*	get source page
	/**/
	Call( ErrBFWriteAccessPage( pfucbT, pgnoBM ) );
	Call( ErrDBUTLCheckPage( pdbccinfo, pfucbT ) );

	Assert( TsPMTagstatus( pfucbT->ssib.pbf->ppage , itagBM ) == tsLine  ||
		TsPMTagstatus( pfucbT->ssib.pbf->ppage, itagBM ) == tsLink );

	DIRGotoBookmark( pfucbT, SridOfPgnoItag( pgnoBM, itagBM ) );
	err = ErrDIRGet( pfucbT );

	if ( err == JET_errRecordDeleted )
		{
		// This indicates that a valid bookmark is pointing to a deleted record.
		// Polymorph to corrupted DB.
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		}

HandleError:
	DIRClose( pfucbT );

	return err;
	}


LOCAL ERR ErrDBUTLCheckBacklink(
	DBCCINFO	*pdbccinfo,
	PGNO		pgnoCurr,
	INT			itagCurr,
	PGNO		pgnoBM,
	INT			itagBM,
	BOOL		fNodeDeleted )
	{
	ERR		err;
	FUCB	*pfucb;
	FUCB	*pfucbT = pfucbNil;
	BF		*pbfSave;

	pfucb = pdbccinfo->pfucb;

	pbfSave = pfucb->ssib.pbf;
	BFPin( pbfSave );

	Call( ErrDIROpen(
		pdbccinfo->ppib,
		pfucb->u.pfcb,
		pfucb->dbid,
		&pfucbT ) );

	/*	get source page
	/**/
	Assert( pgnoCurr != pgnoBM );
	Call( ErrBFWriteAccessPage( pfucbT, pgnoBM ) );
	Call( ErrDBUTLCheckPage( pdbccinfo, pfucbT ) );

	Assert( TsPMTagstatus( pfucbT->ssib.pbf->ppage, itagBM ) == tsLink );

	DIRGotoBookmark( pfucbT, SridOfPgnoItag( pgnoBM, itagBM ) );
	err = ErrDIRGet( pfucbT );

	if ( fNodeDeleted )
		{
		// If node has been deleted, then we should get errRecordDeleted
		// if we try to land on it.
		if ( err == JET_errRecordDeleted )
			err = JET_errSuccess;
		else
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		}
	Call( err );

	// If we didn't end up where we started, then there's a problem.
	if ( pfucbT->pcsr->pgno != pgnoCurr  ||  pfucbT->pcsr->itag != itagCurr )
		err = ErrERRCheck( JET_errDatabaseCorrupted );

HandleError:
	if ( pfucbT != pfucbNil )
		DIRClose( pfucbT );
	BFUnpin( pbfSave );

	return err;
	}


	
/*	check space
/**/
LOCAL ERR ErrDBUTLCheckSpace( DBCCINFO *pdbccinfo, FUCB *pfucbFDP )
	{
	ERR				err = JET_errSuccess;
	PGNO			pgnoFDP = PcsrCurrent( pfucbFDP )->pgno;
	PGNO			pgnoFDPParent;
	DIB 			dib;
	CPG				cpgAvail;
	CPG				cpgOwned;
	JET_TABLEID		tableid = pdbccinfo->tableidSpaceInfo;
	BYTE			fClustered = fFalse;

	/*	sum owned space
	/**/
	cpgOwned = 0;

	dib.fFlags = fDIRNull;
	dib.pos = posDown;
	dib.pkey = pkeyOwnExt;
	Call( ErrDIRDown( pfucbFDP, &dib ) );

	Assert( dib.fFlags == fDIRNull );
	dib.pos = posFirst;
	err = ErrDIRDown( pfucbFDP, &dib );
	if ( err < 0 && err != JET_errRecordNotFound )
		goto HandleError;

	Call( ErrDIRGet( pfucbFDP ) );

	Assert( dib.fFlags == fDIRNull );
	do
		{
		Assert( pfucbFDP->lineData.cb == sizeof(PGNO) );
		cpgOwned += *(PGNO UNALIGNED *)pfucbFDP->lineData.pb;
		Assert( cpgOwned > 0 );
		err = ErrDIRNext( pfucbFDP, &dib );
		}
	while ( err >= 0 );
	if ( err != JET_errNoCurrentRecord )
		goto HandleError;
	DIRUp( pfucbFDP, 2 );

	/*	sum available space and get pgnoFDP parent
	/**/
	cpgAvail = 0;

	Assert( dib.fFlags == fDIRNull );
	dib.pos = posDown;
	dib.pkey = pkeyAvailExt;
	Call( ErrDIRDown( pfucbFDP, &dib ) );

	/*	get pgnoFDP parent
	/**/
	Call( ErrDIRGet( pfucbFDP ) );
	pgnoFDPParent = *(PGNO UNALIGNED *)pfucbFDP->lineData.pb;

	Assert( dib.fFlags == fDIRNull );
	dib.pos = posFirst;
	err = ErrDIRDown( pfucbFDP, &dib );
	if ( err < 0 && err != JET_errRecordNotFound )
		goto HandleError;

	/*	sum available space
	/**/
	if ( err < 0 )
		{
		cpgAvail = 0;
		DIRUp( pfucbFDP, 1 );
		}
	else
		{
		Call( ErrDIRGet( pfucbFDP ) );

		Assert( dib.fFlags == fDIRNull );
		do
			{
			Assert( pfucbFDP->lineData.cb == sizeof(PGNO) );
			cpgAvail += *(PGNO UNALIGNED *)pfucbFDP->lineData.pb;
			Assert( cpgAvail > 0 );
			err = ErrDIRNext( pfucbFDP, &dib );
			}
		while ( err >= 0 );
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		DIRUp( pfucbFDP, 2 );
		}

	fClustered = ( pgnoFDPParent == pgnoSystemRoot );

	/*	write results to space information table
	/**/
	Call( ErrIsamBeginTransaction( (JET_VSESID)pfucbFDP->ppib ) );
	Call( ErrDispPrepareUpdate( (JET_VSESID)pfucbFDP->ppib, tableid, JET_prepInsert ) );

	if ( pdbccinfo->szTable[0] != '\0' )
		{
		Call( ErrDispSetColumn( (JET_VSESID)pfucbFDP->ppib, 
			tableid, 
			rgcolumnidSpaceInfoTable[icolumnidSpaceInfoTableName],
			(BYTE *)pdbccinfo->szTable, 
			strlen(pdbccinfo->szTable),
			0, 
			NULL ) );
		}
	if ( pdbccinfo->szIndex[0] != '\0' )
		{
		if ( pdbccinfo->szTable[0] == '\0' )
			{
			Call( ErrDispSetColumn( (JET_VSESID)pfucbFDP->ppib, 
				tableid, 
				rgcolumnidSpaceInfoTable[icolumnidSpaceInfoTableName],
				(BYTE *)pdbccinfo->szTable, 
				strlen(pdbccinfo->szTable),
				0, 
				NULL ) );
				}
		Call( ErrDispSetColumn( (JET_VSESID)pfucbFDP->ppib, 
			tableid, 
			rgcolumnidSpaceInfoTable[icolumnidSpaceInfoIndexName],
			(BYTE *)pdbccinfo->szIndex, 
			strlen(pdbccinfo->szIndex),
			0, 
			NULL ) );
		}
	Call( ErrDispSetColumn( (JET_VSESID)pfucbFDP->ppib, 
		tableid, 
		rgcolumnidSpaceInfoTable[icolumnidSpaceInfoFClusteredIndex],
		(BYTE *)&fClustered,
		sizeof(BYTE),
		0, 
		NULL ) );
	Call( ErrDispSetColumn( (JET_VSESID)pfucbFDP->ppib, 
		tableid, 
		rgcolumnidSpaceInfoTable[icolumnidSpaceInfoCpgOwned],
		(BYTE *)&cpgOwned,
		sizeof(cpgOwned),
		0, 
		NULL ) );
	Call( ErrDispSetColumn( (JET_VSESID)pfucbFDP->ppib, 
		tableid, 
		rgcolumnidSpaceInfoTable[icolumnidSpaceInfoCpgAvail],
		(BYTE *)&cpgAvail,
		sizeof(cpgAvail),
		0, 
		NULL ) );
	/*	update and commit
	/**/
	Call( ErrDispUpdate( (JET_VSESID)pfucbFDP->ppib, tableid, NULL, 0, NULL ) );
	Call( ErrIsamCommitTransaction( (JET_VSESID)pfucbFDP->ppib, 0 ) );

	/*	set success return code
	/**/
	err = JET_errSuccess;

HandleError:
	Assert( err >= 0 );
	return err;
	}


LOCAL INLINE VOID EDBUTLGenIndentString( CHAR *szIndent, ULONG ulIndentLevel )
	{
	ULONG	ulCurrentLevel;

	szIndent[0] = 0;
	for ( ulCurrentLevel = 0 ; ulCurrentLevel < ulIndentLevel; ulCurrentLevel++ )
		{
		Assert( ulCurrentLevel < cMaxIndentLevel );
		strcat( szIndent, szOneIndent );
		}
	}

LOCAL INLINE ERR ErrDBUTLPrintColumnSizes(
	DBCCINFO		*pdbccinfo,
	JET_COLUMNLIST	*pcolumnlist )
	{
	ERR				err;
	JET_COLUMNID	columnidT;
	FUCB			*pfucb;
	INT				cbT;
	INT				cbTT;
	CHAR			szColumnName[JET_cbNameMost + 1];
	CHAR			szIndent[cbOneIndent*cMaxIndentLevel+1];
	BOOL			fPrint;

	pfucb = pdbccinfo->pfucb;

	Assert( pcolumnlist->tableid != JET_tableidNil );

	fPrint = ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionDumpVerbose );
	if ( fPrint )
		{
		Assert( pdbccinfo->op == opDBUTILDumpData );
		pdbccinfo->ulIndentLevel++;
		EDBUTLGenIndentString( szIndent, pdbccinfo->ulIndentLevel );
		}

	/*	for each column in table, retrieve column id.  Retrieve column
	/*	from record.  If column is non-NULL, then print column length
	/*	and name of column.
	/**/
	err = ErrDispMove( (JET_SESID)pdbccinfo->ppib, pcolumnlist->tableid, JET_MoveFirst, 0 );
	if ( err < 0 )
		{
		if ( err == JET_errNoCurrentRecord )
			err = JET_errSuccess;
		goto HandleError;
		}

	if ( fPrint )
		printf( "%s              Column Size   Column Name\n", szIndent );

	while ( err != JET_errNoCurrentRecord )
		{
		Call( ErrDispRetrieveColumn( (JET_SESID)pdbccinfo->ppib,
			pcolumnlist->tableid,
			pcolumnlist->columnidcolumnid,
			&columnidT,
			sizeof(columnidT),
			&cbT,
			0,
			NULL ) );
		Assert( cbT == sizeof(columnidT) );
		err = ErrIsamRetrieveColumn( pdbccinfo->ppib,
			pfucb,
			columnidT,
			NULL,
			0,
			&cbT,
			JET_bitRetrieveIgnoreDefault,
			NULL );
		if ( err == JET_errRecordDeleted )
			{
			if ( fPrint )
				printf( "%s              **** Record Deleted *****\n", szIndent );
			break;
			}
		else if ( err < 0 )
			{
			goto HandleError;
			}
		else if ( err != JET_wrnColumnNull )
			{
			Call( ErrDispRetrieveColumn( (JET_SESID)pdbccinfo->ppib,
				pcolumnlist->tableid,
				pcolumnlist->columnidcolumnname,
				&szColumnName,
				sizeof(szColumnName),
				&cbTT,
				0,
				NULL ) );
			szColumnName[cbTT] = '\0';

			if ( fPrint )
				{
				printf( "%s              ", szIndent );
				DBUTLPrintfIntN( cbT, 11 );
				printf( "   %s\n", szColumnName );
				}

			if ( FTaggedFid( columnidT ) )
				{
				JET_RETINFO	retinfo;

				retinfo.cbStruct = sizeof(retinfo);
				retinfo.itagSequence = 2;
				retinfo.ibLongValue = 0;

				forever
					{
					Call( ErrIsamRetrieveColumn( pdbccinfo->ppib,
						pfucb,
						columnidT,
						NULL,
						0,
						&cbT,
						JET_bitRetrieveIgnoreDefault,
						&retinfo ) );
					if ( err == JET_wrnColumnNull )
						break;

					if ( fPrint )
						{
						printf( "%s              ", szIndent );
						DBUTLPrintfIntN( cbT, 11 );
						printf( "   %s\n", szColumnName );
						}

					retinfo.itagSequence++;
					}
				}
			}

		err = ErrDispMove( (JET_SESID)pdbccinfo->ppib, pcolumnlist->tableid, JET_MoveNext, 0 );
		if ( err < 0 )
			{
			if ( err != JET_errNoCurrentRecord )
				goto HandleError;
			}
   		}

	err = JET_errSuccess;

HandleError:
	if ( fPrint )
		pdbccinfo->ulIndentLevel--;

	return err;
	}


LOCAL INLINE ERR ErrDBUTLPrintItemList( DBCCINFO *pdbccinfo, KEYSTATS *pkeystats )
	{
	ERR				err = JET_errSuccess;
	BYTE			*pbNode;
	ULONG			cbNode;
	ULONG			cbData;
	PGNO			pgnoBM;
	INT				itagBM;
	ITEM UNALIGNED	*rgitem;
	ULONG			iitem;
	ULONG			citem;
	CHAR			szIndent[cbOneIndent*cMaxIndentLevel+1];

	pbNode = pdbccinfo->pfucb->ssib.line.pb;
	cbNode = pdbccinfo->pfucb->ssib.line.cb;

	pdbccinfo->ulIndentLevel++;

	cbData = CbNDData( pbNode, cbNode );
	if ( cbData > 0  &&  ( cbData % sizeof(ITEM) == 0 ) )
		{
		EDBUTLGenIndentString( szIndent, pdbccinfo->ulIndentLevel );

		rgitem = (ITEM UNALIGNED *)PbNDData( pbNode );
		citem = cbData / sizeof(ITEM);

		Assert( citem > 0 );
		for( iitem = 0; iitem < citem; iitem++ ) 
			{
			pgnoBM = PgnoOfSrid( BmNDOfItem( rgitem[iitem] ) );
			itagBM = ItagOfSrid( BmNDOfItem( rgitem[iitem] ) );

			if ( !FNDItemDelete( rgitem[iitem] ) )
				{
				// Validate the bookmark.
				CallR( ErrDBUTLCheckBookmark(
					pdbccinfo,
					pgnoBM,
					itagBM ) );
				}
		
			if ( pdbccinfo->op == opDBUTILDumpData )
				{
				printf( "%s%s  [%d:%d]",
					szIndent,
					iitem == 0 ? "  Bookmarks:" : "            ",
					pgnoBM,
					itagBM );

				if ( FNDItemDelete( rgitem[iitem] ) )
					{
					printf( "  Deleted" );
					}
				else
					{
					// If node has been deleted, all items must also have
					// been flagged deleted.
					Assert( !FNDDeleted( *pbNode ) );
					}

				if ( FNDItemVersion( rgitem[iitem] ) )
					printf( "  Versioned" );

				printf("\n");
				}
			}

		if ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionKeyStats )
			{
			pkeystats->cOccurrencesCurKey += citem;
			if ( citem > 1 )
				pkeystats->cbKeySavings += ( CbNDKey( pbNode ) * ( citem - 1 ) );
			if ( FNDLastItem( *pbNode ) && !FNDDeleted( *pbNode ) )
				{
				if ( pkeystats->cOccurrencesCurKey <= 10 )
					pkeystats->rgcKeyOccurrences[ pkeystats->cOccurrencesCurKey-1 ] += 1;
				else if ( pkeystats->cOccurrencesCurKey <= 25 )
					pkeystats->rgcKeyOccurrences[ 10 ] += 1;
				else if ( pkeystats->cOccurrencesCurKey <= 100 )
					pkeystats->rgcKeyOccurrences[ 11 ] += 1;
				else if ( pkeystats->cOccurrencesCurKey <= 255 )
					pkeystats->rgcKeyOccurrences[ 12 ] += 1;
				else if ( pkeystats->cOccurrencesCurKey <= 1000 )
					pkeystats->rgcKeyOccurrences[ 13 ] += 1;
				else
					pkeystats->rgcKeyOccurrences[ 14 ] += 1;

				pkeystats->cOccurrencesCurKey = 0;		// Reset counter
				}

			}

		err = JET_errSuccess;
		}
	else if ( cbData != 0 )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		}

	pdbccinfo->ulIndentLevel--;

	return err;
	}



LOCAL INLINE BOOL FDBUTLPersistentNode( BYTE bHeader )
	{
	return ( !FNDVersion( bHeader )  &&
		!FNDDeleted( bHeader )  &&
		!FNDBackLink( bHeader )  &&
		!FNDFirstItem( bHeader )  &&
		!FNDLastItem( bHeader ) );
	}


LOCAL ERR ErrDBUTLDumpRawNode( DBCCINFO *pdbccinfo )
	{
	ERR		err = JET_errSuccess;
	DBID	dbid;
	FUCB	*pfucb;
	BYTE	*pbNode;
	ULONG	cbNode;
	CHAR	szIndent[cbOneIndent*cMaxIndentLevel+1];
	CHAR	szNorm[ ichDumpMaxNorm + ichDumpNormTextSlop];
	BYTE	bHeader;

	pfucb = pdbccinfo->pfucb;

	CallR( ErrDBUTLCheckPage( pdbccinfo, pfucb ) );

	AssertNDGetNode( pfucb, pfucb->pcsr->itag );
	NDCheckPage( &pfucb->ssib );

	pbNode = pfucb->ssib.line.pb;
	cbNode = pfucb->ssib.line.cb;

	if ( PbNDData( pbNode ) > pbNode + cbNode )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		}
	else if ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionDumpVerbose )
		{
		Assert( pdbccinfo->op == opDBUTILDumpData );

		dbid = pdbccinfo->dbid;
		bHeader = *pbNode;

		EDBUTLGenIndentString( szIndent, pdbccinfo->ulIndentLevel );

		printf( "%s NODE Flags:", szIndent );

		if ( FNDVersion( bHeader ) )
			printf( "  Versioned" );
		if ( FNDDeleted( bHeader ) )
			printf( "  Deleted" );
		if ( FNDNullSon( bHeader ) )
			printf( "  NullSon" );
		if ( FNDVisibleSons( bHeader ) )
			printf( "  VisibleSons" );
		else
			printf( "  InvisibleSons" );
		if ( FNDFirstItem( bHeader ) )
			printf( "  FirstItem" );
		if ( FNDLastItem( bHeader ) )
			printf( "  LastItem" );
		printf( "\n" );

		printf( "%s      cbKey:  %d\n", szIndent, CbNDKey( pbNode ) );

		if ( CbNDKey( pbNode ) )
			{
			DBUTLSprintNormText( szNorm, PbNDKey( pbNode ), CbNDKey( pbNode ), ichDumpMaxNorm );
			printf( "%s        Key:  \"%s\"\n", szIndent, szNorm );
			}

		if ( CbNDSon( pbNode ) > 0 )
			{
			INT ibSon;

			for ( ibSon = 0; ibSon < CbNDSon( pbNode ); ibSon++ )
				{
				BYTE itag = PbNDSon( pbNode )[ibSon];

				printf( "%s       %s  [%d:%d:%d]\n",
					szIndent,
					ibSon == 0 ? "Sons:" : "     ",
					dbid,
					PcsrCurrent( pfucb )->pgno,
					itag );
				}
			}

		if ( FNDBackLink( bHeader ) )
			{
			PGNO pgnoBM = PgnoOfSrid( *(SRID UNALIGNED *)PbNDBackLink( pbNode ) );
			BYTE itagBM = ItagOfSrid( *(SRID UNALIGNED *)PbNDBackLink( pbNode ) );
				
			printf( "%s   BackLink:  [%d:%d:%d]\n", szIndent, dbid, pgnoBM, itagBM );

			CallR( ErrDBUTLCheckBacklink(
				pdbccinfo,
				PcsrCurrent( pdbccinfo->pfucb )->pgno,
				PcsrCurrent( pdbccinfo->pfucb )->itag,
				pgnoBM,
				itagBM,
				FNDDeleted( bHeader ) ) );
			}
			
		printf( "%s     cbData:  %d\n", szIndent, CbNDData( pbNode, cbNode ) );
		if ( CbNDData( pbNode, cbNode ) )
			{
			DBUTLSprintNormText( szNorm, PbNDData( pbNode ), CbNDData( pbNode, cbNode ), ichDumpMaxNorm );
			printf( "%s       Data:  \"%s\"\n", szIndent, szNorm );
			}
		}

	return err;
	}

LOCAL ERR ErrDBUTLCheckExtent( DBCCINFO *pdbccinfo )
	{
	ERR		err;
	DBID	dbid;
	FUCB	*pfucbFDP;
	BOOL	fOwnExt;
	PGNO	pgno;
	CPG		cpg;
	BYTE	*pbNode;
	ULONG	cbNode;
	DIB		dib;
	CHAR	szIndent[cbOneIndent*cMaxIndentLevel+1];
	BOOL	fPrint;

	dbid = pdbccinfo->dbid;
	pfucbFDP = pdbccinfo->pfucb;

	fPrint = ( pdbccinfo->op == opDBUTILDumpData );

	Assert( PcsrCurrent( pfucbFDP )->itag == itagAVAILEXT  ||
		PcsrCurrent( pfucbFDP )->itag == itagOWNEXT );
	fOwnExt = ( PcsrCurrent( pfucbFDP )->itag == itagOWNEXT );

	if ( fPrint )
		{
		EDBUTLGenIndentString( szIndent, pdbccinfo->ulIndentLevel );

		printf( "%s[%d:%d:%d] %s\n",
			szIndent,
			dbid,
			PcsrCurrent( pfucbFDP )->pgno,
			PcsrCurrent( pfucbFDP )->itag,	
			fOwnExt ? "OWNED EXTENT" : "AVAILABLE EXTENT" );

		pdbccinfo->ulIndentLevel++;
		strcat( szIndent, szOneIndent );
		}

	pbNode = pfucbFDP->ssib.line.pb;
	cbNode = pfucbFDP->ssib.line.cb;
	Assert( FNDSon( *pbNode )  ||  !fOwnExt );		// AvailExt may not have sons.
	Assert( FDBUTLPersistentNode( *pbNode ) );
	Assert( CbNDKey( pbNode ) == 1 );
	Assert( fOwnExt ?
		memcmp( PbNDKey( pbNode ), pkeyOwnExt->pb, pkeyOwnExt->cb ) == 0 :
		memcmp( PbNDKey( pbNode ), pkeyAvailExt->pb, pkeyAvailExt->cb ) == 0 );
	Assert( CbNDData( pbNode, cbNode ) == sizeof(PGNO) );
	pgno = *( (PGNO UNALIGNED *)PbNDData( pbNode ) );

	if ( fPrint )
		{
		if ( fOwnExt )
			printf( "%sPrimary Ext:  %d page%s\n", szIndent, pgno, pgno == 1 ? "" : "s" );
		else
			printf( "%s Parent FDP:  %d\n", szIndent, pgno );
		}
	Call( ErrDBUTLDumpRawNode( pdbccinfo ) );

 	dib.pos = posFirst;
	dib.fFlags = ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionAllNodes ? fDIRAllNode : fDIRNull );
	err = ErrDIRDown( pfucbFDP, &dib );

	// AvailExt may not have any extent entries, but OwnExt must.
	Assert( err != JET_errRecordNotFound  ||  !fOwnExt );
	if ( err == JET_errRecordNotFound )
		{
		err = JET_errSuccess;
		goto HandleError;
		}

	while ( err >= 0  )
		{
		// Extent nodes are keyed according to ending page, and the number of
		// pages in the extent are stored in the data part of the node.
		pbNode = pfucbFDP->ssib.line.pb;
		cbNode = pfucbFDP->ssib.line.cb;

		Assert( CbNDKey( pbNode ) == sizeof(PGNO) );
		LongFromKey( &pgno, PbNDKey( pbNode ) );

		Assert( CbNDData( pbNode, cbNode ) == sizeof(CPG) );
		cpg = *( (PGNO UNALIGNED *)PbNDData( pbNode ) );

		Assert( cpg > 0 );
		Assert( pgno >= (PGNO)cpg );

		if ( fPrint )
			{
			printf( "%s[%d:%d:%d] Extent Range\n",
				szIndent, dbid, PcsrCurrent( pfucbFDP )->pgno, PcsrCurrent( pfucbFDP )->itag );

			pdbccinfo->ulIndentLevel++;
			printf( "%s%s      Pages:  %d - %d\n", szIndent, szOneIndent, pgno - cpg + 1, pgno );
			err = ErrDBUTLDumpRawNode( pdbccinfo );
			pdbccinfo->ulIndentLevel--;
			CallJ( err, BackToFather );
			}
		else
			{
			CallJ( ErrDBUTLDumpRawNode( pdbccinfo ), BackToFather );
			}

		if ( ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionPageDump ) &&
			!FNDDeleted( *pbNode ) )
			{
			CallJ( ErrDBUTLRegExt( pdbccinfo, pgno - cpg + 1, cpg, !fOwnExt ), BackToFather );
			}

		err = ErrDIRNext( pfucbFDP, &dib );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

BackToFather:
	DIRUp( pfucbFDP, 1 );

HandleError:
	if ( fPrint )
		pdbccinfo->ulIndentLevel--;

	return err;
	}


LOCAL ERR ErrDBUTLCheckAutoInc( DBCCINFO *pdbccinfo )
	{
	ERR		err;
	FUCB	*pfucb;
	BYTE	*pbNode;
	ULONG	cbNode;
	ULONG	ulAutoInc;
	CHAR	szIndent[cbOneIndent*cMaxIndentLevel+1];
	BOOL	fPrint;

	pfucb = pdbccinfo->pfucb;

	Assert( PcsrCurrent( pfucb )->itag == itagAUTOINC );

	fPrint = ( pdbccinfo->op == opDBUTILDumpData );
	if ( fPrint )
		{
		EDBUTLGenIndentString( szIndent, pdbccinfo->ulIndentLevel );

		printf( "%s[%d:%d:%d] %s\n",
			szIndent,
			pdbccinfo->dbid,
			PcsrCurrent( pfucb )->pgno,
			PcsrCurrent( pfucb )->itag,	
			"AUTO-INCREMENT" );
		
		pdbccinfo->ulIndentLevel++;
		strcat( szIndent, szOneIndent );
		}

	pbNode = pfucb->ssib.line.pb;
	cbNode = pfucb->ssib.line.cb;
	Assert( cbNode == 7 );	// Node header + key length + 1-byte key + 4-byte autoinc value
	Assert( FNDVisibleSons( *pbNode ) );
	Assert( FNDNullSon( *pbNode ) );
	Assert( FDBUTLPersistentNode( *pbNode ) );
	Assert( CbNDKey( pbNode ) == pkeyAutoInc->cb );
	Assert( memcmp( PbNDKey( pbNode ), pkeyAutoInc->pb, pkeyAutoInc->cb ) == 0 );
	Assert( CbNDData( pbNode, cbNode ) == sizeof(ULONG) );
	ulAutoInc = *( (ULONG UNALIGNED *)PbNDData( pbNode ) );

	if ( fPrint )
		printf( "%s      Value:  %d\n", szIndent, ulAutoInc );
	err = ErrDBUTLDumpRawNode( pdbccinfo );

	if ( fPrint )
		pdbccinfo->ulIndentLevel--;

	return err;
	}


LOCAL ERR ErrDBUTLCheckOneLV( DBCCINFO *pdbccinfo )
	{
	ERR		err;
	DBID	dbid;
	FUCB	*pfucb;
	BYTE	*pbNode;
	ULONG	cbNode;
	LVROOT	lvroot;
	LID		lid;
	ULONG	ulChunkOffset;
	DIB		dib;
	CHAR	szIndent[cbOneIndent*cMaxIndentLevel+1];
	BOOL	fPrint;

	dbid = pdbccinfo->dbid;
	pfucb = pdbccinfo->pfucb;

	// LV root nodes are keyed according to LID, and the data part
	// of the node contains the LVROOT structure.
	pbNode = pfucb->ssib.line.pb;
	cbNode = pfucb->ssib.line.cb;

	Assert( CbNDKey( pbNode ) == sizeof(LID) );
	LongFromKey( &lid, PbNDKey( pbNode ) );

	Assert( CbNDData( pbNode, cbNode ) == sizeof(LVROOT) );
	memcpy( &lvroot, PbNDData( pbNode ), sizeof(LVROOT) );

	fPrint = ( pdbccinfo->op == opDBUTILDumpData );
	if ( fPrint )
		{
		pdbccinfo->ulIndentLevel++;
		EDBUTLGenIndentString( szIndent, pdbccinfo->ulIndentLevel );

		printf( "%s        LID:  %d\n", szIndent, lid );
		printf( "%s   RefCount:  %d\n", szIndent, lvroot.ulReference );
		printf( "%s       Size:  %d\n", szIndent, lvroot.ulSize );
		}
	Call( ErrDBUTLDumpRawNode( pdbccinfo ) );

 	dib.pos = posFirst;
	dib.fFlags = ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionAllNodes ? fDIRAllNode : fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	if ( err == JET_errRecordNotFound )
		{
		err = JET_errSuccess;
		goto HandleError;
		}

	while ( err >= 0  )
		{
		pbNode = pfucb->ssib.line.pb;
		cbNode = pfucb->ssib.line.cb;

		Assert( CbNDKey( pbNode ) == sizeof(ULONG) );
		LongFromKey( &ulChunkOffset, PbNDKey( pbNode ) );

		Assert( CbNDData( pbNode, cbNode ) > 0 );
		Assert( CbNDData( pbNode, cbNode ) <= cbChunkMost );

		if ( fPrint )
			{
			printf( "%s[%d:%d:%d] LV Chunk\n",
				szIndent, dbid, PcsrCurrent( pfucb )->pgno, PcsrCurrent( pfucb )->itag );

			pdbccinfo->ulIndentLevel++;
			printf( "%s%s     Offset:  %d\n", szIndent, szOneIndent, ulChunkOffset );
			printf( "%s%s       Size:  %d\n", szIndent, szOneIndent, CbNDData( pbNode, cbNode ) );
			err = ErrDBUTLDumpRawNode( pdbccinfo );
			pdbccinfo->ulIndentLevel--;
			CallJ( err, BackToFather );
			}
		else
			{
			CallJ( ErrDBUTLDumpRawNode( pdbccinfo ), BackToFather );
			}

		err = ErrDIRNext( pfucb, &dib );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

BackToFather:
	DIRUp( pfucb, 1 );

HandleError:
	if ( fPrint )
		pdbccinfo->ulIndentLevel--;

	return err;
	}


LOCAL ERR ErrDBUTLCheckLV( DBCCINFO *pdbccinfo )
	{
	ERR		err;
	DBID	dbid;
	FUCB	*pfucb;
	BYTE	*pbNode;
	ULONG	cbNode;
	DIB		dib;
	CHAR	szIndent[cbOneIndent*cMaxIndentLevel+1];
	BOOL	fPrint;

	dbid = pdbccinfo->dbid;
	pfucb = pdbccinfo->pfucb;

	Assert( PcsrCurrent( pfucb )->itag == itagLONG );

	fPrint = ( pdbccinfo->op == opDBUTILDumpData );
	if ( fPrint )
		{
		EDBUTLGenIndentString( szIndent, pdbccinfo->ulIndentLevel );

		printf( "%s[%d:%d:%d] %s\n",
			szIndent,
			dbid,
			PcsrCurrent( pfucb )->pgno,
			PcsrCurrent( pfucb )->itag,	
			"LONG VALUES" );

		pdbccinfo->ulIndentLevel++;
		strcat( szIndent, szOneIndent );
		}

	pbNode = pfucb->ssib.line.pb;
	cbNode = pfucb->ssib.line.cb;
	Assert( FDBUTLPersistentNode( *pbNode ) );
	Assert( CbNDKey( pbNode ) == pkeyLong->cb );
	Assert( memcmp( PbNDKey( pbNode ), pkeyLong->pb, pkeyLong->cb ) == 0 );
	Assert( CbNDData( pbNode, cbNode ) == 0 );

	Call( ErrDBUTLDumpRawNode( pdbccinfo ) );

 	dib.pos = posFirst;
	dib.fFlags = ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionAllNodes ? fDIRAllNode : fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	if ( err == JET_errRecordNotFound )
		{
		err = JET_errSuccess;
		goto HandleError;
		}

	while ( err >= 0  )
		{
		if ( fPrint )
			{
			printf( "%s[%d:%d:%d] LV Root\n",
				szIndent, dbid, PcsrCurrent( pfucb )->pgno, PcsrCurrent( pfucb )->itag );
			}

		CallJ( ErrDBUTLCheckOneLV( pdbccinfo ), BackToFather );

		err = ErrDIRNext( pfucb, &dib );
		}

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

BackToFather:
	DIRUp( pfucb, 1 );

HandleError:
	if ( fPrint )
		pdbccinfo->ulIndentLevel--;

	return err;
	}


LOCAL ERR ErrDBUTLCheckData( DBCCINFO *pdbccinfo, BOOL fClusteredIndex )
	{
	ERR				err;
	DBID			dbid;
	FUCB			*pfucb;
	BYTE			*pbNode;
	ULONG			cbNode;
	ULONG			cbKey;
	JET_COLUMNLIST	columnlist;
	KEYSTATS		keystats;
	DIB				dib;
	CHAR			szIndent[cbOneIndent*cMaxIndentLevel+1];
	BOOL			fPrint;
	BOOL			fKeyStats;

	dbid = pdbccinfo->dbid;
	pfucb = pdbccinfo->pfucb;

	columnlist.tableid = JET_tableidNil;

	Assert( PcsrCurrent( pfucb )->itag == itagDATA );

	// Always generate Indent string.  It may be needed for the
	// key stats summary, even if no data dump.
	EDBUTLGenIndentString( szIndent, pdbccinfo->ulIndentLevel );

	// Always print out DATA node for clustered index.
	// Otherwise, output is optional.
	fPrint = ( pdbccinfo->op == opDBUTILDumpData );
	if ( fClusteredIndex  ||  fPrint )
		{
		printf( "%s[%d:%d:%d] %s",
			szIndent,
			dbid,
			PcsrCurrent( pfucb )->pgno,
			PcsrCurrent( pfucb )->itag,	
			"DATA" );

		if ( fClusteredIndex )
			{
			if ( pfucb->u.pfcb->pidb == pidbNil )
				printf( " (Sequential Index)\n" );
			else
				printf( " (Clustered Index: \"%s\")\n", pfucb->u.pfcb->pidb->szName );

			/*	get list of all columns in table
			/**/
			CallR( ErrIsamGetTableColumnInfo(
				(JET_VSESID)pdbccinfo->ppib,
				(JET_VTID)pfucb,
				NULL,
				(char *)&columnlist,
				sizeof(columnlist),
				JET_ColInfoList ) );
			}
		else
			{
			printf( "\n" );
			}

		pdbccinfo->ulIndentLevel++;
		strcat( szIndent, szOneIndent );

		}

	pbNode = pfucb->ssib.line.pb;
	cbNode = pfucb->ssib.line.cb;
	Assert( FDBUTLPersistentNode( *pbNode ) );
	Assert( CbNDKey( pbNode ) == pkeyData->cb );
	Assert( memcmp( PbNDKey( pbNode ), pkeyData->pb, pkeyData->cb ) == 0 );
	Assert( CbNDData( pbNode, cbNode ) == 0 );

	Call( ErrDBUTLDumpRawNode( pdbccinfo ) );

	fKeyStats = ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionKeyStats );
	if ( fKeyStats )
		{
		// Initialise stats.
		memset( &keystats, 0, sizeof(KEYSTATS) );
		keystats.cbMinKey = JET_cbKeyMost+1;
		}

 	dib.pos = posFirst;
	dib.fFlags = ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionAllNodes ? fDIRAllNode : fDIRNull );
	err = ErrDIRDown( pfucb, &dib );
	if ( err == JET_errRecordNotFound )
		{
		err = JET_errSuccess;
		goto HandleError;
		}

	while ( err >= 0 )
		{
		pbNode = pfucb->ssib.line.pb;
		cbNode = pfucb->ssib.line.cb;
		Assert( FNDNullSon( *pbNode ) );

		if ( fKeyStats )
			{
			cbKey = CbNDKey( pbNode );
			keystats.cbMinKey = min( keystats.cbMinKey, cbKey );
			keystats.cbMaxKey = max( keystats.cbMaxKey, cbKey );
			keystats.cbTotalKey += cbKey;
			keystats.cRecords++;
			}

		if ( fPrint )
			{
			printf( "%s[%d:%d:%d] %s\n",
				szIndent,
				dbid,
				PcsrCurrent( pfucb )->pgno,
				PcsrCurrent( pfucb )->itag,
				fClusteredIndex ? "Record" : "ItemList Node" );

			pdbccinfo->ulIndentLevel++;
			err = ErrDBUTLDumpRawNode( pdbccinfo );
			pdbccinfo->ulIndentLevel--;
			CallJ( err, BackToFather );
			}
		else
			{
			CallJ( ErrDBUTLDumpRawNode( pdbccinfo ), BackToFather );
			}
	
		CallJ( fClusteredIndex ?
			ErrDBUTLPrintColumnSizes( pdbccinfo, &columnlist ) :
			ErrDBUTLPrintItemList( pdbccinfo, &keystats ),
			BackToFather ); 

		err = ErrDIRNext( pfucb, &dib );
		}

	if ( err == JET_errNoCurrentRecord )
		{
		if ( fKeyStats )
			{
			printf( "%sKey Summary:  Total Records = %d\n", szIndent, keystats.cRecords );
			printf( "%s              Minimum Key Size = %d bytes\n", szIndent, keystats.cbMinKey );
			printf( "%s              Maximum Key Size = %d bytes\n", szIndent, keystats.cbMaxKey );
			printf( "%s              Average Key Size = %d bytes\n", szIndent, keystats.cbTotalKey/keystats.cRecords );

			// Only check for dupes in non-clustered indexes, since clustered indexes,
			// by their nature, don't have dupes.
			if ( !fClusteredIndex )
				{
				INT i;

				printf( "%s              Key Bytes Saved = %d bytes\n", szIndent, keystats.cbKeySavings );
				printf( "%s              Distribution of Key Occurrences:\n", szIndent );

				for ( i = 0; i < 10; i++ )
					{
					printf("%s                  %d - %d\n", szIndent, i+1, keystats.rgcKeyOccurrences[i] );
					}
				printf("%s                  <=25 - %d\n", szIndent, keystats.rgcKeyOccurrences[10] );
				printf("%s                  <=100 - %d\n", szIndent, keystats.rgcKeyOccurrences[11] );
				printf("%s                  <=255 - %d\n", szIndent, keystats.rgcKeyOccurrences[12] );
				printf("%s                  <=1000 - %d\n", szIndent, keystats.rgcKeyOccurrences[13] );
				printf("%s                  >1000 - %d\n", szIndent, keystats.rgcKeyOccurrences[14] );
				}
			}

		err = JET_errSuccess;
		}

BackToFather:
	DIRUp( pfucb, 1 );

HandleError:
	if ( fClusteredIndex  ||  fPrint )
		pdbccinfo->ulIndentLevel--;

	if ( columnlist.tableid != JET_tableidNil )
		{
		CallS( ErrDispCloseTable( (JET_SESID)pdbccinfo->ppib, columnlist.tableid ) );
		}

	return err;
	}


LOCAL ERR ErrDBUTLCheckBTree(
	DBCCINFO	*pdbccinfo,
	KEY			*pkeyFather,
	KEY			*pkeyLeftSiblingOfFather )
	{
	INT		i;
	ERR		err = JET_errSuccess;
	FUCB	*pfucb = pdbccinfo->pfucb;
	INT		itagFather;
	BYTE	*pbFatherNode;
	ULONG	cbFatherNode;
	BYTE	*pbSon;
	ULONG	cbSon;
	BYTE	*pbSonNode;
	PGNO	pgnoSon;
	PGNO	pgnoCurr = PgnoOfPn( pfucb->ssib.pbf->pn );

	CallR( ErrDBUTLCheckPage( pdbccinfo, pfucb ) );

	// Ignore CSR and use ssib.itag to track current line.
	if ( pfucb->ssib.itag == itagFOP )
		{
		// NDCheckPage will recursively check all subtrees on the
		// page, starting at FOP, so only need to perform the
		// check if we're on FOP.
		NDCheckPage( &pfucb->ssib );
		}

	itagFather = pfucb->ssib.itag;
	AssertNDGet( pfucb, itagFather );
	pbFatherNode = pfucb->ssib.line.pb;
	cbFatherNode = pfucb->ssib.line.cb;

	Assert( !FNDReserved( *pbFatherNode ) );

	if ( FNDSon( *pbFatherNode ) )
		{
		pbSon = PbNDSon( pbFatherNode );
		cbSon = CbNDSon( pbFatherNode );
		Assert( cbSon > 0 );

		if ( pkeyLeftSiblingOfFather )
			{
			if ( pkeyFather != NULL  ||
				cbSon > 1  ||
				FNDVisibleSons( *pbFatherNode ) )
				{
				// Verify first son is greater than or equal to
				// the left sibling of the father..
				NDGet( pfucb, pbSon[0] );
				Assert( CmpStKey( StNDKey( pfucb->ssib.line.pb ),
						pkeyLeftSiblingOfFather ) >= 0 );
				}
			else
				{
				// Special case: Last son of this tree level, invisible son,
				// and only son on this page.  In this case, it will be
				// NULL-keyed, so don't even bother checking it.
				Assert( CbNDKey( pbFatherNode ) == 0 );
				}
			}
		if ( pkeyFather )
			{
			// Verify last son is less than or equal to father.
			NDGet( pfucb, pbSon[ cbSon-1 ] );
			Assert( CmpStKey( StNDKey( pfucb->ssib.line.pb ),
				pkeyFather ) <= 0 );
			}

		if ( FNDVisibleSons( *pbFatherNode ) )
			{
			// See if there are grandsons on this page.
			for ( i = 0; i < (INT)cbSon; i++ )
				{
				// Re-cache father.
				Call( ErrBFReadAccessPage( pfucb, pgnoCurr ) );
				NDGet( pfucb, itagFather );
				pbFatherNode = pfucb->ssib.line.pb;
				Assert( pfucb->ssib.line.cb == cbFatherNode );
				pbSon = PbNDSon( pbFatherNode );
				Assert( CbNDSon( pbFatherNode ) == (INT)cbSon );
				NDGet( pfucb, pbSon[i] );
				pfucb->ssib.itag = pbSon[i];
				pbSonNode = pfucb->ssib.line.pb;

				if ( FNDBackLink( *pbSonNode ) )
					{
					PGNO pgnoBM = PgnoOfSrid( *(SRID UNALIGNED *)PbNDBackLink( pbSonNode ) );
					BYTE itagBM = ItagOfSrid( *(SRID UNALIGNED *)PbNDBackLink( pbSonNode ) );
									
					Call( ErrDBUTLCheckBacklink(
						pdbccinfo,
						pgnoCurr,
						pbSon[i],
						pgnoBM,
						itagBM,
						FNDDeleted( *pbSonNode ) ) );
					}
					
				Call( ErrDBUTLCheckBTree( pdbccinfo, NULL, NULL ) );
				}
			}
		else if ( itagFather != itagFOP  &&  cbSon == 1 )	// Intrinsic page pointer
			{
			// Intrinsic page pointers are the result of a
			// visible father on the same page, without any
			// invisible sons in between.
			Assert( pkeyLeftSiblingOfFather == NULL );
			Assert( pkeyFather == NULL );

			AssertNDGet( pfucb, itagFather );
			AssertNDIntrinsicSon( pbFatherNode, cbFatherNode );
			pgnoSon = PgnoNDOfPbSon( pbFatherNode );

			Call( ErrBFReadAccessPage( pfucb, pgnoSon ) );
			NDGet( pfucb, itagFOP );
			pfucb->ssib.itag = itagFOP;

			Call( ErrDBUTLCheckBTree( pdbccinfo, NULL, NULL ) );
			}
		else
			{
			BYTE	*pbSonNode;
			BYTE	pbKeyBuf[2][ JET_cbKeyMost ];
			KEY		key = { 0, NULL };
			KEY		keyLeftSibling;
			KEY		*pkey = &key;

			Assert( cbSon >= 1 );

			for ( i = 0; i < (INT)cbSon; i++ )
				{
				// Re-cache father.
				Call( ErrBFReadAccessPage( pfucb, pgnoCurr ) );
				NDGet( pfucb, itagFather );
				pbFatherNode = pfucb->ssib.line.pb;
				Assert( pfucb->ssib.line.cb == cbFatherNode );
				pbSon = PbNDSon( pbFatherNode );
				Assert( CbNDSon( pbFatherNode ) == (INT)cbSon );
				NDGet( pfucb, pbSon[i] );
				pbSonNode = pfucb->ssib.line.pb;

				// Invisible sons cannot themselves have sons, cannot be
				// flag-deleted, and cannot have backlinks.
				Assert( FNDNullSon( *pbSonNode ) );
				Assert( !FNDDeleted( *pbSonNode ) );
				Assert( !FNDBackLink( *pbSonNode ) );
				
				pgnoSon = *(PGNO UNALIGNED *)PbNDData( pbSonNode );

				keyLeftSibling = key;
				if ( i == (INT)cbSon - 1  &&  pkeyFather == NULL )
					{
					// Last node at each interior level is always NULL.
					Assert( CbNDKey( pbSonNode ) == 0 );
					pkey = NULL;
					}
				else
					{
					key.cb = CbNDKey( pbSonNode );
					key.pb = pbKeyBuf[ i % 2 ];
					memcpy( key.pb, PbNDKey( pbSonNode ), key.cb );

					// Flip-flop the two key buffers between 
					// key and keyLeftSibling.
					Assert( keyLeftSibling.pb != key.pb );

					Assert( pkey != NULL );
					Assert( pkey == &key );
					}

				Call( ErrBFReadAccessPage( pfucb, pgnoSon ) );
				NDGet( pfucb, itagFOP );
				pfucb->ssib.itag = itagFOP;

				Call( ErrDBUTLCheckBTree( pdbccinfo, pkey,
					i == 0 ? pkeyLeftSiblingOfFather : &keyLeftSibling ) );
				}
			}
		}

HandleError:
	return err;
	}


LOCAL ERR ErrDBUTLCheckOneIndex( DBCCINFO *pdbccinfo )
	{
	ERR		err;
	PIB		*ppib;
	DBID	dbid;
	FUCB	*pfucbTable;
	FUCB	*pfucbIndex;
	BYTE	*pbNode;
	ULONG	cbNode;
	DIB		dib;
	CHAR	szIndent[cbOneIndent*cMaxIndentLevel+1];

	ppib = pdbccinfo->ppib;
	dbid = pdbccinfo->dbid;

	pfucbTable = pdbccinfo->pfucb;			// Save off table cursor.
	pfucbIndex = pfucbTable->pfucbCurIndex;
	pdbccinfo->pfucb = pfucbIndex;
	DIRGotoFDPRoot( pfucbIndex );

	Assert( PcsrCurrent( pfucbIndex )->itag == itagFOP );
	pbNode = pfucbIndex->ssib.line.pb;
	cbNode = pfucbIndex->ssib.line.cb;

	Assert( cbNode == 8 );					// Node header + key length + son table
	Assert( FNDSon( *pbNode )  &&  FNDVisibleSons( *pbNode ) );
	Assert( FDBUTLPersistentNode( *pbNode ) );
	Assert( CbNDKey( pbNode ) == 0 );		// Null key
	Assert( CbNDSon( pbNode ) == 5 );		// AvailExt and OwnExt
	Assert( PbNDSon( pbNode )[0] == itagAVAILEXT );
	Assert( PbNDSon( pbNode )[1] == itagLONG );
	Assert( PbNDSon( pbNode )[2] == itagOWNEXT );
	Assert( PbNDSon( pbNode )[3] == itagDATA );
	Assert( PbNDSon( pbNode )[4] == itagAUTOINC );

	Assert( pdbccinfo->ulIndentLevel == 1 );
	EDBUTLGenIndentString( szIndent, pdbccinfo->ulIndentLevel );

	printf( "%s[%d:%d:%d] NON-CLUSTERED INDEX: \"%s\"\n",
		szIndent,
		dbid,
		PcsrCurrent( pfucbIndex )->pgno,
		PcsrCurrent( pfucbIndex )->itag,
		pfucbIndex->u.pfcb->pidb->szName );

	pdbccinfo->ulIndentLevel++;
	Call( ErrDBUTLDumpRawNode( pdbccinfo ) );

	if ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionCheckBTree )
		{
		Assert( pfucbIndex->ssib.itag == itagFOP );
		Call( ErrDBUTLCheckBTree( pdbccinfo, NULL, NULL ) );
		}
	else
		{
		dib.pos = posFirst;
		dib.fFlags = ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionAllNodes ? fDIRAllNode : fDIRNull );
		err = ErrDIRDown( pfucbIndex, &dib );
		while ( err >= 0 )
			{
			switch ( PcsrCurrent( pfucbIndex )->itag )
				{
				case itagAVAILEXT:
				case itagOWNEXT:
					Call( ErrDBUTLCheckExtent( pdbccinfo ) );
					break;
				case itagDATA:
					Call( ErrDBUTLCheckData( pdbccinfo, fFalse ) );
					break;
				case itagLONG:
					Call( ErrDBUTLCheckLV( pdbccinfo ) );
					break;
				case itagAUTOINC:
					Call( ErrDBUTLCheckAutoInc( pdbccinfo ) );
					break;
				default:
					Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
				}
			err = ErrDIRNext( pfucbIndex, &dib );
			}

		if ( err == JET_errNoCurrentRecord )
			err = JET_errSuccess;

		}
		
	Assert( pdbccinfo->ulIndentLevel == 2 );

HandleError:
	pdbccinfo->ulIndentLevel = 1;		// reset
	
	pdbccinfo->pfucb = pfucbTable;		// Restore table cursor.

	return err;
	}


LOCAL ERR ErrDBUTLCheckOneTable( DBCCINFO *pdbccinfo )
	{
	ERR		err;
	PIB		*ppib;
	DBID	dbid;
	FUCB	*pfucbTable = pfucbNil;
	BYTE	*pbNode;
	ULONG	cbNode;
	DIB		dib;
	FCB		*pfcbT;

	ppib = pdbccinfo->ppib;
	dbid = pdbccinfo->dbid;

	Call( ErrFILEOpenTable( ppib, dbid, &pfucbTable, pdbccinfo->szTable, 0 ) );
	DIRGotoFDPRoot( pfucbTable );
	pdbccinfo->pfucb = pfucbTable;

	Assert( PcsrCurrent( pfucbTable )->itag == itagFOP );
	pbNode = pfucbTable->ssib.line.pb;
	cbNode = pfucbTable->ssib.line.cb;

	Assert( cbNode == 8 );					// Node header + key length + son table
	Assert( FNDSon( *pbNode )  &&  FNDVisibleSons( *pbNode ) );
	Assert( FDBUTLPersistentNode( *pbNode ) );
	Assert( CbNDKey( pbNode ) == 0 );		// Null key
	Assert( CbNDSon( pbNode ) == 5 );		// AvailExt and OwnExt
	Assert( PbNDSon( pbNode )[0] == itagAVAILEXT );
	Assert( PbNDSon( pbNode )[1] == itagLONG );
	Assert( PbNDSon( pbNode )[2] == itagOWNEXT );
	Assert( PbNDSon( pbNode )[3] == itagDATA );
	Assert( PbNDSon( pbNode )[4] == itagAUTOINC );

	pdbccinfo->ulIndentLevel = 0;

	printf( "[%d:%d:%d] TABLE: \"%s\"\n", 
		dbid,
		PcsrCurrent( pfucbTable )->pgno,
		PcsrCurrent( pfucbTable )->itag,
		pdbccinfo->szTable );

	pdbccinfo->ulIndentLevel++;
	Call( ErrDBUTLDumpRawNode( pdbccinfo ) );

	if ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionCheckBTree )
		{
		Assert( pfucbTable->ssib.itag == itagFOP );
		Call( ErrDBUTLCheckBTree( pdbccinfo, NULL, NULL ) );
		}
	else
		{
		dib.pos = posFirst;
		dib.fFlags = ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionAllNodes ? fDIRAllNode : fDIRNull );
		err = ErrDIRDown( pfucbTable, &dib );
		while ( err >= 0 )
			{
			switch ( PcsrCurrent( pfucbTable )->itag )
				{
				case itagAVAILEXT:
				case itagOWNEXT:
					Call( ErrDBUTLCheckExtent( pdbccinfo ) );
					break;
				case itagDATA:
					Call( ErrDBUTLCheckData( pdbccinfo, fTrue ) );
					break;
				case itagLONG:
					Call( ErrDBUTLCheckLV( pdbccinfo ) );
					break;
				case itagAUTOINC:
					Call( ErrDBUTLCheckAutoInc( pdbccinfo ) );
					break;
				default:
					Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
				}
			err = ErrDIRNext( pfucbTable, &dib );
			}

		if ( err == JET_errNoCurrentRecord )
			err = JET_errSuccess;
		Call( err );
		}

	Assert( pdbccinfo->ulIndentLevel == 1 );
	
	// Check all non-clustered indexes.
	for ( pfcbT = pfucbTable->u.pfcb->pfcbNextIndex;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		Assert( pfcbT->pidb != pidbNil );
		Assert( pfcbT->pidb->szName != NULL );
		Call( ErrRECSetCurrentIndex( pfucbTable, pfcbT->pidb->szName ) );
		FUCBResetNonClustered( pfucbTable->pfucbCurIndex );	// Fake out FUCB
		err = ErrDBUTLCheckOneIndex( pdbccinfo );
		FUCBSetNonClustered( pfucbTable->pfucbCurIndex );
		Call( err );
		}
		
	Assert( pdbccinfo->ulIndentLevel == 1 );
	
HandleError:
	pdbccinfo->ulIndentLevel = 0;		// reset
	
	if ( pfucbTable != pfucbNil )
		{
		Assert( pfucbTable == pdbccinfo->pfucb );
		CallS( ErrFILECloseTable( ppib, pfucbTable ) );
		}
	pdbccinfo->pfucb = pfucbNil;

	printf( "\n" );

	return err;
	}


LOCAL ERR ErrDBUTLCheckTables( DBCCINFO *pdbccinfo )
	{
	ERR		err;
	PIB		*ppib;
	DBID	dbid;
	FUCB	*pfucbMSO = pfucbNil;
	OBJID	objidParent;
	ULONG	cbT;

	ppib = pdbccinfo->ppib;
	dbid = pdbccinfo->dbid;

	Call( ErrFILEOpenTable( ppib, dbid, &pfucbMSO, szSoTable, 0 ) );

	pdbccinfo->ulIndentLevel = 0;

	err = ErrIsamMove( ppib, pfucbMSO, JET_MoveFirst, 0 );
	while ( err >= 0 )
		{
		Call( ErrIsamRetrieveColumn( ppib,
			pfucbMSO,
			ColumnidCATGetColumnid( itableSo, iMSO_ParentId ),
			(BYTE *)&objidParent,
			sizeof(objidParent),
			&cbT,
			0,
			NULL ) );
		Assert( cbT == sizeof(objidParent) );
		if ( objidParent == objidTblContainer )
			{
			/*	print table information
			/**/
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSO,
				ColumnidCATGetColumnid( itableSo, iMSO_Name ),
				(BYTE *)pdbccinfo->szTable,
				sizeof(pdbccinfo->szTable),
				&cbT,
				0,
				NULL ) );
			Assert( cbT < sizeof(pdbccinfo->szTable) );
			pdbccinfo->szTable[cbT] = '\0';

			Call( ErrDBUTLCheckOneTable( pdbccinfo ) );
			}

		err = ErrIsamMove( ppib, pfucbMSO, JET_MoveNext, 0 );
		}
	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

HandleError:
	Assert( pdbccinfo->ulIndentLevel == 0 );

	if ( pfucbMSO != pfucbNil )
		{
		CallS( ErrFILECloseTable( ppib, pfucbMSO ) );
		}

	return err;
	}


LOCAL ERR ErrDBUTLCheckDB( DBCCINFO *pdbccinfo )
	{
	ERR		err;
	DBID	dbid;
	FUCB	*pfucb = pfucbNil;
	BYTE	*pbNode;
	ULONG	cbNode;
	DIB		dib;

	dbid = pdbccinfo->dbid;

	Call( ErrDIROpen( pdbccinfo->ppib, pfcbNil, dbid, &pfucb ) );
	pdbccinfo->pfucb = pfucb;

	Call( ErrDIRGet( pfucb ) );
	Assert( PcsrCurrent( pfucb )->pgno == pgnoSystemRoot );
	Assert( PcsrCurrent( pfucb )->itag == itagFOP );
	pbNode = pfucb->ssib.line.pb;
	cbNode = pfucb->ssib.line.cb;

	Assert( cbNode == 5 );					// Node header + key length + son table
	Assert( FNDSon( *pbNode )  &&  FNDVisibleSons( *pbNode ) );
	Assert( FDBUTLPersistentNode( *pbNode ) );
	Assert( CbNDKey( pbNode ) == 0 );		// Null key
	Assert( CbNDSon( pbNode ) == 2 );		// AvailExt and OwnExt
	Assert( PbNDSon( pbNode )[0] == itagAVAILEXT );
	Assert( PbNDSon( pbNode )[1] == itagOWNEXT );

	pdbccinfo->ulIndentLevel = 0;

	printf( "[%d:%d:%d] DATABASE ROOT\n", dbid, PcsrCurrent( pfucb )->pgno, PcsrCurrent( pfucb )->itag );

	pdbccinfo->ulIndentLevel++;
	Call( ErrDBUTLDumpRawNode( pdbccinfo ) );

	if ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionCheckBTree )
		{
		Assert( pfucb->ssib.itag == itagFOP );
		Call( ErrDBUTLCheckBTree( pdbccinfo, NULL, NULL ) );
		}
	else
		{
		dib.pos = posFirst;
		dib.fFlags = ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionAllNodes ? fDIRAllNode : fDIRNull );
		err = ErrDIRDown( pfucb, &dib );
		while ( err >= 0 )
			{
			Assert( PcsrCurrent( pfucb )->pgno == pgnoSystemRoot );		// Should not leave DB root page.
			switch ( PcsrCurrent( pfucb )->itag )
				{
				case itagAVAILEXT:
				case itagOWNEXT:
					Call( ErrDBUTLCheckExtent( pdbccinfo ) );
					break;
				default:
					Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
				}

			err = ErrDIRNext( pfucb, &dib );
			}

		if ( err == JET_errNoCurrentRecord )
			err = JET_errSuccess;
		}

	Assert( pdbccinfo->ulIndentLevel == 1 );
	
HandleError:
	pdbccinfo->ulIndentLevel = 0;		// reset
	
	if ( pfucb != pfucbNil )
		{
		Assert( pfucb == pdbccinfo->pfucb );
		DIRClose( pfucb );
		}
	pdbccinfo->pfucb = pfucbNil;

	printf( "\n" );

	return err;
	}


/***********************************************************
/******************* DBCC Info Routines ********************
/***********************************************************
/**/
/*	open temporary tables based on info required
/**/
LOCAL ERR ErrDBUTLInfoInit( DBCCINFO *pdbccinfo )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib = pdbccinfo->ppib;

	Assert( pdbccinfo->tableidPageInfo == JET_tableidNil );
	Assert( pdbccinfo->tableidSpaceInfo == JET_tableidNil );

	switch( pdbccinfo->op )
		{
		case opDBUTILConsistency:
		case opDBUTILDumpData:
			/*	open temporary table
			/**/
			if ( pdbccinfo->grbitOptions & JET_bitDBUtilOptionPageDump )
				{
				err = ErrIsamOpenTempTable( (JET_SESID) ppib, 
					rgcolumndefPageInfoTable, 
					ccolumndefPageInfoTable,
					0,
					JET_bitTTUpdatable|JET_bitTTIndexed, 
					&pdbccinfo->tableidPageInfo, 
					rgcolumnidPageInfoTable );
				}
			break;

		case opDBUTILDumpSpace:
			/*	open temporary table
			/**/
			err = ErrIsamOpenTempTable( (JET_SESID) ppib, 
				rgcolumndefSpaceInfoTable, 
				ccolumndefSpaceInfoTable,
				0,
				JET_bitTTUpdatable|JET_bitTTIndexed|JET_bitTTUnique, 
				&pdbccinfo->tableidSpaceInfo, 
				rgcolumnidSpaceInfoTable );
			break;
		}

	return err;
	}


/*	print information collected in temporary tables
/**/
LOCAL ERR ErrDBUTLInfoPrint( DBCCINFO *pdbccinfo )
	{
	ERR			err = JET_errSuccess;
	JET_SESID	sesid = (JET_SESID) pdbccinfo->ppib;
	ULONG		cbT;

	if ( pdbccinfo->tableidPageInfo != JET_tableidNil )
		{
		JET_TABLEID		tableid = pdbccinfo->tableidPageInfo;

		Assert( pdbccinfo->grbitOptions & JET_bitDBUtilOptionPageDump );

		/*	move to first record
		/**/
		err = ErrDispMove( sesid, tableid, JET_MoveFirst, 0 );
		if ( err == JET_errNoCurrentRecord )
			{
			err = JET_errSuccess;
			goto HandleError;
			}
		Call( err );
		
		printf( "\n\n ***************** PAGE DUMP *******************\n\n" );
		printf( "PGNO\tAVAIL\tCHECK\tMODIFIED\tLEFT\tRIGHT\t#LINKS\t#TAGS\tFREESPACE\n" );

		/*	while there are more records, print record
		/**/
		for( ;
			err == JET_errSuccess; 
			err = ErrDispMove( sesid, tableid, JET_MoveNext, 0 ) )
			{
			PGNO	pgnoThis;
			PGNO	pgnoLeft;
			PGNO	pgnoRight;
			BYTE 	fChecked;
			BYTE 	fAvail;
			BYTE	fModified;
			ULONG	cLinks;
			ULONG	cUsedTags;
			ULONG	cbFreeSpace;
			
			/*	pgno
			/**/
		 	Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoPgno],
				(BYTE *) &pgnoThis, 
				sizeof(pgnoThis), 
				&cbT,
	 			0, 
			 	NULL ) );

			Assert( cbT == sizeof(pgnoThis) );
			printf( "%u\t", pgnoThis );
			
			/*	FAvail
			/**/
			fAvail = fFalse;

			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
				(BYTE *) &fAvail, 
				sizeof(fAvail), 
				&cbT,
				0, 
				NULL ) );

			Assert( cbT == sizeof(fAvail) || err == JET_wrnColumnNull );

			if ( fAvail && err != JET_wrnColumnNull )
				{
				printf( "FAvail\t" );
				}
			else
				{
				printf("\t");
				}
				
			/*	FChecked
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
			 	rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
			 	(BYTE *)&fChecked, 
			 	sizeof(fChecked), 
			 	&cbT,
			 	0, 
				NULL ) );

			Assert( cbT == sizeof(fChecked) );
			Assert( fChecked || fAvail );

			if ( fChecked )
				{
				printf( "FCheck\t" );
				}
			else
				{
				printf( "\n" );
				continue;
				}

			/*	Modified bit
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
			 	rgcolumnidPageInfoTable[icolumnidPageInfoFModified],
			 	(BYTE *)&fModified, 
			 	sizeof(fModified), 
			 	&cbT,
			 	0, 
				NULL ) );

			Assert( cbT == sizeof(fModified) );
			if ( fModified )
				{
				printf( "Modified\t" );
				}
			else
				{
				printf( "\t" );
				}
				
			/*	left and right pgno
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoPgnoLeft],
				(BYTE *)&pgnoLeft, 
				sizeof(pgnoLeft), 
				&cbT,
				0, 		
				NULL ) );
			Assert( cbT == sizeof(pgnoLeft) );
									
			Call( ErrDispRetrieveColumn( sesid, 
				 tableid, 
				 rgcolumnidPageInfoTable[icolumnidPageInfoPgnoRight],
				 (BYTE *) &pgnoRight, 
				 sizeof(pgnoRight), 
				 &cbT,
				 0, 
				 NULL ) );
			Assert( cbT == sizeof(pgnoRight) );
									
			/*	links
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				 tableid, 
				 rgcolumnidPageInfoTable[icolumnidPageInfoLinks],
				 (BYTE *) &cLinks, 
				 sizeof(cLinks), 
				 &cbT,
				 0, 
				 NULL ) );
			Assert( cbT == sizeof(cLinks) );
									
			/*	tags
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoTags],
				(BYTE *)&cUsedTags, 
				sizeof(cUsedTags), 
				&cbT,
				0, 
				NULL ) );
			Assert( cbT == sizeof(cUsedTags) );
									
			/*	free space
			/**/
			Call( ErrDispRetrieveColumn( sesid,
				tableid,
				rgcolumnidPageInfoTable[icolumnidPageInfoFreeSpace],
				(BYTE *) &cbFreeSpace, 
				sizeof(cbFreeSpace), 
				&cbT,
				0, 
				NULL ) );
			Assert( cbT == sizeof(cbFreeSpace) );

			/*	print the rest
			/**/
			printf( "%u\t%u\t%u\t%u\t%u\n", pgnoLeft, pgnoRight, cLinks, cUsedTags, cbFreeSpace );
			}
		}
	

	if ( pdbccinfo->tableidSpaceInfo != JET_tableidNil )
		{
		JET_TABLEID		tableid = pdbccinfo->tableidSpaceInfo;

		Assert( pdbccinfo->op == opDBUTILDumpSpace );

		/*	move to first record
		/**/
		err = ErrDispMove( sesid, tableid, JET_MoveFirst, 0 );
		if ( err == JET_errNoCurrentRecord )
			{
			err = JET_errSuccess;
			goto HandleError;
			}
		Call( err );
		
		printf( "********************************* SPACE DUMP *********************************\n" );
		printf( "Table Name               Index Name                CI  Owned   Avail   Used   \n" );

		/*	while there are more records, print record
		/**/
		for( ;
			err == JET_errSuccess; 
			err = ErrDispMove( sesid, tableid, JET_MoveNext, 0 ) )
			{
			CHAR	szTableName[JET_cbNameMost + 1];
			CHAR	szIndexName[JET_cbNameMost + 1];
			BYTE	fClustered;
			CPG		cpgOwned;
			CPG		cpgAvail;
			
			/*	Table Name
			/**/
		 	Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidSpaceInfoTable[icolumnidSpaceInfoTableName],
				(BYTE *)szTableName,
				sizeof(szTableName), 
				&cbT,
	 			0, 
			 	NULL ) );
			szTableName[cbT] = '\0';

			/*	Index Name
			/**/
		 	Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidSpaceInfoTable[icolumnidSpaceInfoIndexName],
				(BYTE *)szIndexName,
				sizeof(szIndexName), 
				&cbT,
	 			0, 
			 	NULL ) );
			szIndexName[cbT]='\0';

			/*	FClusteredIndex
			/**/
		 	Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidSpaceInfoTable[icolumnidSpaceInfoFClusteredIndex],
				(BYTE *)&fClustered, 
				sizeof(fClustered), 
				&cbT,
	 			0, 
			 	NULL ) );
			Assert( cbT == sizeof(fClustered) );

			/*	CPG Owned
			/**/
		 	Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidSpaceInfoTable[icolumnidSpaceInfoCpgOwned],
				(BYTE *)&cpgOwned, 
				sizeof(cpgOwned), 
				&cbT,
	 			0, 
			 	NULL ) );
			Assert( cbT == sizeof(cpgOwned) );
			
			/*	CPG Avail
			/**/
		 	Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidSpaceInfoTable[icolumnidSpaceInfoCpgAvail],
				(BYTE *)&cpgAvail, 
				sizeof(cpgAvail), 
				&cbT,
	 			0, 
			 	NULL ) );
			Assert( cbT == sizeof(cpgAvail) );

			Assert( cpgOwned > cpgAvail );

			/*	print
			/**/
			if ( szTableName[0] != '\0' )
				{
				DBUTLPrintfStringN( szTableName, 24 );

				if ( szIndexName[0] != '\0' )
					{
					DBUTLPrintfStringN( szIndexName, 25 );
					}
				else
					{
					DBUTLPrintfStringN( "<sequential>", 25 );
					}
				}
			else
				{					    
				DBUTLPrintfStringN( "<database>", 25 );
				DBUTLPrintfStringN( "<database>", 25 );
				}
			if ( fClustered )
				{
				DBUTLPrintfStringN( "Yes", 3 );
				}
			else
				{
				DBUTLPrintfStringN( "No", 3 );
				}
			DBUTLPrintfIntN( cpgOwned, 7 );
			printf( " " );
			DBUTLPrintfIntN( cpgAvail, 7 );
			printf( " " );
			DBUTLPrintfIntN( cpgOwned - cpgAvail, 7 );
			printf( "\n" );
			}
		}

	/*	polymorph expected error to success
	/**/
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		}
HandleError:
	return err;
	}
	
	
/*	close temporary tables
/**/
LOCAL VOID DBUTLInfoTerm( DBCCINFO *pdbccinfo )
	{
	JET_SESID	sesid = (JET_SESID) pdbccinfo->ppib;
	
	if ( pdbccinfo->tableidPageInfo != JET_tableidNil )
		{
		Assert( pdbccinfo->grbitOptions & JET_bitDBUtilOptionPageDump );
		CallS( ErrDispCloseTable( sesid, pdbccinfo->tableidPageInfo ) );
		pdbccinfo->tableidPageInfo = JET_tableidNil;
		}

	if ( pdbccinfo->tableidSpaceInfo != JET_tableidNil )
		{
		Assert( pdbccinfo->op == opDBUTILDumpSpace );
		CallS( ErrDispCloseTable( sesid, pdbccinfo->tableidSpaceInfo ) );
		pdbccinfo->tableidSpaceInfo = JET_tableidNil;
		}
	}


LOCAL ERR ErrDBUTLDumpMetaData( DBCCINFO *pdbccinfo )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib = pdbccinfo->ppib;
	DBID	dbid = pdbccinfo->dbid;
	FUCB	*pfucbMSO = pfucbNil;
	FUCB	*pfucbMSI = pfucbNil;
	FUCB	*pfucbMSC  = pfucbNil;
	OBJID	objidParent;
	LONG	cbT;

	/*	open MSys tables
	/**/
	Call( ErrFILEOpenTable( ppib, dbid, &pfucbMSO, szSoTable, 0 ) );
	Call( ErrFILEOpenTable( ppib, dbid, &pfucbMSI, szSiTable, 0 ) );
	Call( ErrFILEOpenTable( ppib, dbid, &pfucbMSC, szScTable, 0 ) );

	/*	if dumping meta data for a single table, then seek to that
	/*	MSO record and set index range on that record.
	/**/
	if ( pdbccinfo->szTable[0] != '\0' )
		{
		Call( ErrIsamSetCurrentIndex( ppib, pfucbMSO, szSoNameIndex ) );
		objidParent = objidTblContainer;
		CallS( ErrIsamMakeKey( ppib, pfucbMSO, (BYTE *)&objidParent, sizeof(objidParent), JET_bitNewKey ) );
		CallS( ErrIsamMakeKey( ppib, pfucbMSO, pdbccinfo->szTable, strlen(pdbccinfo->szTable), 0 ) );
		Call( ErrIsamSeek( ppib, pfucbMSO, JET_bitSeekEQ|JET_bitSetIndexRange ) );
		}

	printf( "******************** META DATA DUMP ***********************\n" );

	do
		{
		OBJID	objid;
		CHAR	szTableName[JET_cbNameMost + 1];
		LONG	lPages;
		LONG	lDensity;

		/*	get parent objid
		/**/
		Call( ErrIsamRetrieveColumn( ppib,
			pfucbMSO,
			ColumnidCATGetColumnid( itableSo, iMSO_ParentId ),
			(BYTE *)&objidParent,
			sizeof(objidParent),
			&cbT,
			0,
			NULL ) );
		Assert( cbT == sizeof(objidParent) );
		if ( objidParent != objidTblContainer )
			{
			goto NextObject;
			}

		/*	get objid
		/**/
		Call( ErrIsamRetrieveColumn( ppib,
			pfucbMSO,
			ColumnidCATGetColumnid( itableSo, iMSO_Id ),
			(BYTE *)&objid,
			sizeof(objid),
			&cbT,
			0,
			NULL ) );
		Assert( cbT == sizeof(objid) );

		/*	print table information
		/**/
		Call( ErrIsamRetrieveColumn( ppib,
			pfucbMSO,
			ColumnidCATGetColumnid( itableSo, iMSO_Name ),
			(BYTE *)szTableName,
			sizeof(szTableName),
			&cbT,
			0,
			NULL ) );
		szTableName[cbT] = '\0';
		Call( ErrIsamRetrieveColumn( ppib,
			pfucbMSO,
			ColumnidCATGetColumnid( itableSo, iMSO_Pages ),
			(BYTE *)&lPages,
			sizeof(lPages),
			&cbT,
			0,
			NULL ) );
		Assert( cbT == sizeof(lPages) );
		Call( ErrIsamRetrieveColumn( ppib,
			pfucbMSO,
			ColumnidCATGetColumnid( itableSo, iMSO_Density ),
			(BYTE *)&lDensity,
			sizeof(lDensity),
			&cbT,
			0,
			NULL ) );
		Assert( cbT == sizeof(lDensity) );

		printf( "Table Name        Pages   Density\n" );
		printf( "=================================\n" );
		DBUTLPrintfStringN( szTableName, 15 );
		DBUTLPrintfIntN( lPages, 7 );
		printf( " " );
		DBUTLPrintfIntN( lDensity, 9 );
		printf( "\n" );

		/*	print column information
		/**/
		CallS( ErrIsamMakeKey( ppib, pfucbMSC, (BYTE *)&objid, sizeof(objid), JET_bitNewKey ) );
		err = ErrIsamSeek( ppib, pfucbMSC, JET_bitSeekGE );
		if ( err < 0 )
			{
			if ( err != JET_errRecordNotFound )
				Error( err, HandleError );
			err = JET_errNoCurrentRecord;
			}
		if ( err >= 0 )
			{
			CallS( ErrIsamMakeKey( ppib, pfucbMSC, (BYTE *)&objid, sizeof(objid), JET_bitNewKey | JET_bitStrLimit ) );
			err = ErrIsamSetIndexRange( ppib, pfucbMSC, JET_bitRangeUpperLimit );
			}
		if ( err < 0 )
			{
			if ( err != JET_errNoCurrentRecord )
				Error( err, HandleError );
			}
		if ( err != JET_errNoCurrentRecord )
			{
			printf( "    Column Name     Column Id  Column Type      Length  Default\n" );
			printf( "    -----------------------------------------------------------\n" );
			}
		while ( err != JET_errNoCurrentRecord )
			{
			CHAR	szColumnName[JET_cbNameMost + 1];
			LONG	lColumnId;
			BYTE	bColtyp;
			SHORT	sCodePage;
			BYTE	bFlags = 0;
			LONG	lLength;
			BOOL	fDefault;

			/*	print each column information
			/**/
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSC,
				ColumnidCATGetColumnid( itableSc, iMSC_Name ),
				(BYTE *)szColumnName,
				sizeof(szColumnName),
				&cbT,
				0,
				NULL ) );
			szColumnName[cbT] = '\0';
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSC,
				ColumnidCATGetColumnid( itableSc, iMSC_ColumnId ),
				(BYTE *)&lColumnId,
				sizeof(lColumnId),
				&cbT,
				0,
				NULL ) );
			Assert( cbT == sizeof(lColumnId) );
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSC,
				ColumnidCATGetColumnid( itableSc, iMSC_Coltyp ),
				(BYTE *)&bColtyp,
				sizeof(bColtyp),
				&cbT,
				0,
				NULL ) );
			Assert( cbT == sizeof(bColtyp) );

			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSC,
				ColumnidCATGetColumnid( itableSc, iMSC_CodePage ),
				(BYTE *)&sCodePage,
				sizeof(sCodePage),
				&cbT,
				0,
				NULL ) );
			Assert( cbT == sizeof(sCodePage) );
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSC,
				ColumnidCATGetColumnid( itableSc, iMSC_Flags ),
				(BYTE *)&bFlags,
				sizeof(bFlags),
				&cbT,
				0,
				NULL ) );
			Assert( ( err == JET_wrnColumnNull && cbT == 0 && bFlags == 0 )
				|| cbT == sizeof(bFlags) );
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSC,
				ColumnidCATGetColumnid( itableSc, iMSC_Length ),
				(BYTE *)&lLength,
				sizeof(lLength),
				&cbT,
				0,
				NULL ) );
			Assert( cbT == sizeof(lLength) );
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSC,
				ColumnidCATGetColumnid( itableSc, iMSC_Default ),
				NULL,
				0,
				&cbT,
				0,
				NULL ) );
			fDefault = ( err == JET_wrnColumnNull );
	
			printf( "    " );
			DBUTLPrintfStringN( szColumnName, 15 );
			DBUTLPrintfIntN( lColumnId, 9 );
			printf( "  " );
			switch ( bColtyp )
				{
				case JET_coltypBit:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Bit (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Bit (T)", 15 );
					else
						DBUTLPrintfStringN( "Bit", 15 );
					break;
				case JET_coltypUnsignedByte:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "UnsignedByte (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "UnsignedByte (T)", 15 );
					else
						DBUTLPrintfStringN( "UnsignedByte", 15 );
					break;
				case JET_coltypShort:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Short (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Short (T)", 15 );
					else
						DBUTLPrintfStringN( "Short", 15 );
					break;
				case JET_coltypLong:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Long (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Long (T)", 15 );
					else
						DBUTLPrintfStringN( "Long", 15 );
					break;
				case JET_coltypCurrency:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Currency (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Currency (T)", 15 );
					else
						DBUTLPrintfStringN( "Currency", 15 );
					break;
				case JET_coltypIEEESingle:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "IEEESingle (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "IEEESingle (T)", 15 );
					else
						DBUTLPrintfStringN( "IEEESingle", 15 );
					break;
				case JET_coltypIEEEDouble:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "IEEEDouble (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "IEEEDouble (T)", 15 );
					else
						DBUTLPrintfStringN( "IEEEDouble", 15 );
					break;
				case JET_coltypDateTime:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "DateTime (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "DateTime (T)", 15 );
					else
						DBUTLPrintfStringN( "DateTime", 15 );
					break;
				case JET_coltypBinary:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Binary (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Binary (T)", 15 );
					else
						DBUTLPrintfStringN( "Binary", 15 );
					break;
				case JET_coltypText:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Text (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "Text (T)", 15 );
					else
						DBUTLPrintfStringN( "Text", 15 );
					break;
				case JET_coltypLongBinary:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "LongBinary (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "LongBinary (T)", 15 );
					else
						DBUTLPrintfStringN( "LongBinary", 15 );
					break;
				case JET_coltypLongText:
					if ( FFixedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "LongText (F)", 15 );
					else if ( FTaggedFid( (FID)lColumnId ) )
						DBUTLPrintfStringN( "LongText (T)", 15 );
					else
						DBUTLPrintfStringN( "LongText", 15 );
					break;
				case JET_coltypNil:
					DBUTLPrintfStringN( "Deleted", 15 );
					break;
				default:
					DBUTLPrintfStringN( "Unknown", 15 );
					break;
				}
			DBUTLPrintfIntN( lLength, 7 );
			if ( FFIELDDefault( bFlags ) )
				{
				printf( "  Yes" );
				}
			printf( "\n" );
			if ( FRECTextColumn( bColtyp ) )
				{
				printf( "        Code Page=%d\n", sCodePage );
				}
			if ( FFIELDAutoInc( bFlags ) )
				printf( "        Auto Increment=yes\n" );
			if ( FFIELDVersion( bFlags ) )
				printf( "        Version=yes\n" );
			if ( FFIELDNotNull( bFlags ) )
				printf( "        Disallow Null=yes\n" );
			if ( FFIELDMultivalue( bFlags ) )
				printf( "        Multi-value=yes\n" );
			if ( bFlags )
				printf( "        Flags=0x%x\n", bFlags );

			err = ErrIsamMove( ppib, pfucbMSC, JET_MoveNext, 0 );
			if ( err < 0 )
				{
				if ( err != JET_errNoCurrentRecord )
					Error( err, HandleError );
				}
			}

		/*	print index information
		/**/
		CallS( ErrIsamMakeKey( ppib, pfucbMSI, (BYTE *)&objid, sizeof(objid), JET_bitNewKey ) );
		err = ErrIsamSeek( ppib, pfucbMSI, JET_bitSeekGE );
		if ( err < 0 )
			{
			if ( err != JET_errRecordNotFound )
				Error( err, HandleError );
			err = JET_errNoCurrentRecord;
			}
		if ( err >= 0 )
			{
			CallS( ErrIsamMakeKey( ppib, pfucbMSI, (BYTE *)&objid, sizeof(objid), JET_bitNewKey | JET_bitStrLimit ) );
			err = ErrIsamSetIndexRange( ppib, pfucbMSI, JET_bitRangeUpperLimit );
			}
		if ( err < 0 )
			{
			if ( err != JET_errNoCurrentRecord )
				Error( err, HandleError );
			}
		if ( err != JET_errNoCurrentRecord )
			{
			printf( "    Index Name        Density\n" );
			printf( "    -------------------------\n" );
			}
		while ( err != JET_errNoCurrentRecord )
			{
			CHAR	szIndexName[JET_cbNameMost + 1];
			LONG	lDensity;
			SHORT	sLanguageId;
			SHORT	sFlags;
			SHORT	rgfidKeyFldIDs[JET_ccolKeyMost];
			INT		ifidKeyFldIDMax;
			INT		ifid;
			LONG	lColumnId;

			/*	print each index information
			/**/
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSI,
				ColumnidCATGetColumnid( itableSi, iMSI_Name ),
				(BYTE *)szIndexName,
				sizeof(szIndexName),
				&cbT,
				0,
				NULL ) );
			szIndexName[cbT] = '\0';
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSI,
				ColumnidCATGetColumnid( itableSi, iMSI_Density ),
				(BYTE *)&lDensity,
				sizeof(lDensity),
				&cbT,
				0,
				NULL ) );
			Assert( cbT == sizeof(lDensity) );
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSI,
				ColumnidCATGetColumnid( itableSi, iMSI_LanguageId ),
				(BYTE *)&sLanguageId,
				sizeof(sLanguageId),
				&cbT,
				0,
				NULL ) );
			Assert( cbT == sizeof(sLanguageId) );
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSI,
				ColumnidCATGetColumnid( itableSi, iMSI_Flags ),
				(BYTE *)&sFlags,
				sizeof(sFlags),
				&cbT,
				0,
				NULL ) );
			Assert( cbT == sizeof(sFlags) );
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSI,
				ColumnidCATGetColumnid( itableSi, iMSI_KeyFldIDs ),
				(BYTE *)rgfidKeyFldIDs,
				sizeof(rgfidKeyFldIDs),
				&cbT,
				0,
				NULL ) );
			Assert( err == JET_wrnColumnNull || ( cbT > 0 && ( cbT % 2 == 0 ) ) );
			ifidKeyFldIDMax = cbT / 2;

			printf( "    " );
			DBUTLPrintfStringN( szIndexName, 15 );
			DBUTLPrintfIntN( lDensity, 9 );
			printf( "\n" );
			if ( sFlags & fidbUnique )					// UNDONE: Modify FIDBxxx() macros
				printf( "        Unique=yes\n" );		// so they're applicable here.
			if ( sFlags & fidbPrimary )
				printf( "        Primary=yes\n" );
			if ( sFlags & fidbNoNullSeg )
				printf( "        Disallow Null=yes\n" );
			if ( sFlags & fidbClustered )
				printf( "        Clustered=yes\n" );
			if ( sLanguageId )
				printf( "        Language Id=%d\n", sLanguageId );
			if ( sFlags )
				printf( "        Flags=0x%x\n", sFlags );

			/*	for each column in index, print ascending/descending
			/*	and column properties..
			/**/
			printf( "            Key Segment\n" );
			printf( "            -----------------------\n" );
			if ( ifidKeyFldIDMax == 0 )
				{
				printf( "            No information for system table index.\n" );
				}
			for ( ifid = 0; ifid < ifidKeyFldIDMax; ifid++ )
				{
				FID		fid;
				BOOL	fAscending;
				CHAR	szColumnName[JET_cbNameMost + 1];
				BYTE	bColtyp;
				SHORT	sCodePage;

				if ( rgfidKeyFldIDs[ifid] < 0 )
					{
					fid = -rgfidKeyFldIDs[ifid];
					fAscending = fFalse;
					}
				else
					{
					fid = rgfidKeyFldIDs[ifid];
					fAscending = fTrue;
					}

				CallS( ErrIsamMakeKey( ppib, pfucbMSC, (BYTE *)&objid, sizeof(objid), JET_bitNewKey ) );
				Call( ErrIsamSeek( ppib, pfucbMSC, JET_bitSeekGE ) );
#ifdef DEBUG
				CallS( ErrIsamMakeKey( ppib, pfucbMSC, (BYTE *)&objid, sizeof(objid), JET_bitNewKey | JET_bitStrLimit ) );
				err = ErrIsamSetIndexRange( ppib, pfucbMSC, JET_bitRangeUpperLimit );
				Assert( err != JET_errNoCurrentRecord );
				Call( err );
#endif
				forever
					{
					Call( ErrIsamRetrieveColumn( ppib,
						pfucbMSC,
						ColumnidCATGetColumnid( itableSc, iMSC_ColumnId ),
						(BYTE *)&lColumnId,
						sizeof(lColumnId),
						&cbT,
						0,
						NULL ) );
					Assert( cbT == sizeof(lColumnId) );
					if ( lColumnId == (LONG)fid )
						break;
					err = ErrIsamMove( ppib, pfucbMSC, JET_MoveNext, 0 );
					Assert( err != JET_errNoCurrentRecord );
					Call( err );
					}

				/*	print each index column information
				/**/
				Call( ErrIsamRetrieveColumn( ppib,
					pfucbMSC,
					ColumnidCATGetColumnid( itableSc, iMSC_Name ),
					(BYTE *)szColumnName,
					sizeof(szColumnName),
					&cbT,
					0,
					NULL ) );
				szColumnName[cbT] = '\0';
				Call( ErrIsamRetrieveColumn( ppib,
					pfucbMSC,
					ColumnidCATGetColumnid( itableSc, iMSC_Coltyp ),
					(BYTE *)&bColtyp,
					sizeof(bColtyp),
					&cbT,
					0,
					NULL ) );
				Assert( cbT == sizeof(bColtyp) );
				Call( ErrIsamRetrieveColumn( ppib,
					pfucbMSC,
					ColumnidCATGetColumnid( itableSc, iMSC_CodePage ),
					(BYTE *)&sCodePage,
					sizeof(sCodePage),
					&cbT,
					0,
					NULL ) );
				Assert( cbT == sizeof(sCodePage) );

				printf( "            " );
				if ( fAscending )
					printf( "+" );
				else
					printf( "-" );
				DBUTLPrintfStringN( szColumnName, 15 );
				printf( "\n" );
				if ( FRECTextColumn( bColtyp ) )
					{
					if ( sCodePage != usUniCodePage )
						printf("*****WARNING: invalid code page for indexed text column *****\n" );
					}
				}

			/*	move to next index
			/**/
			err = ErrIsamMove( ppib, pfucbMSI, JET_MoveNext, 0 );
			if ( err < 0 )
				{
				if ( err != JET_errNoCurrentRecord )
					Error( err, HandleError );
				}
			}

NextObject:
		err = ErrIsamMove( ppib, pfucbMSO, JET_MoveNext, 0 );
		if ( err < 0 )
			{
			if ( err != JET_errNoCurrentRecord )
				Error( err, HandleError );
			}
		}
	while ( err != JET_errNoCurrentRecord );

	/*	polymorph error
	/**/
	err = JET_errSuccess;

HandleError:
	if ( pfucbMSC != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucbMSC ) );
	if ( pfucbMSI != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucbMSI ) );
	if ( pfucbMSO != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucbMSO ) );

	return err;
	}


LOCAL ERR ErrDBUTLDumpSpaceData( DBCCINFO *pdbccinfo )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib = pdbccinfo->ppib;
	DBID	dbid = pdbccinfo->dbid;
	FUCB	*pfucbMSO = pfucbNil;
	FUCB	*pfucbMSI = pfucbNil;
	FUCB	*pfucbTable = pfucbNil;
	OBJID	objidParent;
	LONG	cbT;
	BOOL	fDumpedClusteredIndex;

	/*	open MSys tables
	/**/
	Call( ErrFILEOpenTable( ppib, dbid, &pfucbMSO, szSoTable, 0 ) );
	Call( ErrFILEOpenTable( ppib, dbid, &pfucbMSI, szSiTable, 0 ) );

	/*	if dumping meta data for a single table, then seek to that
	/*	MSO record and set index range on that record.
	/**/
	if ( pdbccinfo->szTable[0] != '\0' )
		{
		Call( ErrIsamSetCurrentIndex( ppib, pfucbMSO, szSoNameIndex ) );
		objidParent = objidTblContainer;
		CallS( ErrIsamMakeKey( ppib, pfucbMSO, (BYTE *)&objidParent, sizeof(objidParent), JET_bitNewKey ) );
		CallS( ErrIsamMakeKey( ppib, pfucbMSO, pdbccinfo->szTable, strlen(pdbccinfo->szTable), 0 ) );
		Call( ErrIsamSeek( ppib, pfucbMSO, JET_bitSeekEQ|JET_bitSetIndexRange ) );
		}

	do
		{
		OBJID	objid;

		/*	get parent objid
		/**/
		Call( ErrIsamRetrieveColumn( ppib,
			pfucbMSO,
			ColumnidCATGetColumnid( itableSo, iMSO_ParentId ),
			(BYTE *)&objidParent,
			sizeof(objidParent),
			&cbT,
			0,
			NULL ) );
		Assert( cbT == sizeof(objidParent) );
		if ( objidParent != objidTblContainer )
			{
			goto NextObject;
			}

		/*	get objid
		/**/
		Call( ErrIsamRetrieveColumn( ppib,
			pfucbMSO,
			ColumnidCATGetColumnid( itableSo, iMSO_Id ),
			(BYTE *)&objid,
			sizeof(objid),
			&cbT,
			0,
			NULL ) );
		Assert( cbT == sizeof(objid) );

		/*	print table information
		/**/
		Call( ErrIsamRetrieveColumn( ppib,
			pfucbMSO,
			ColumnidCATGetColumnid( itableSo, iMSO_Name ),
			(BYTE *)pdbccinfo->szTable,
			sizeof(pdbccinfo->szTable),
			&cbT,
			0,
			NULL ) );
		Assert( cbT < sizeof(pdbccinfo->szTable) );
		pdbccinfo->szTable[cbT] = '\0';

		/*	check space, for table
		/**/
		if ( pfucbTable != pfucbNil )
			{
			CallS( ErrFILECloseTable( ppib, pfucbTable ) );
			pfucbTable = pfucbNil;
			}
		Call( ErrFILEOpenTable( ppib, dbid, &pfucbTable, pdbccinfo->szTable, 0 ) );
//		DIRGotoFDPRoot( pfucbTable );
//		Call( ErrDBUTLCheckSpace( pdbccinfo, pfucbTable ) );

		/*	print index information
		/**/
		CallS( ErrIsamMakeKey( ppib, pfucbMSI, (BYTE *)&objid, sizeof(objid), JET_bitNewKey ) );
		err = ErrIsamSeek( ppib, pfucbMSI, JET_bitSeekGE );
		if ( err < 0 )
			{
			if ( err != JET_errRecordNotFound )
				Error( err, HandleError );
			err = JET_errNoCurrentRecord;
			}
		if ( err >= 0 )
			{
			CallS( ErrIsamMakeKey( ppib, pfucbMSI, (BYTE *)&objid, sizeof(objid), JET_bitNewKey | JET_bitStrLimit ) );
			err = ErrIsamSetIndexRange( ppib, pfucbMSI, JET_bitRangeUpperLimit );
			}
		if ( err < 0 )
			{
			if ( err != JET_errNoCurrentRecord )
				Error( err, HandleError );
			}
		fDumpedClusteredIndex = fFalse;
		while ( err != JET_errNoCurrentRecord )
			{
			/*	print each index information
			/**/
			Call( ErrIsamRetrieveColumn( ppib,
				pfucbMSI,
				ColumnidCATGetColumnid( itableSi, iMSI_Name ),
				(BYTE *)pdbccinfo->szIndex,
				sizeof(pdbccinfo->szIndex),
				&cbT,
				0,
				NULL ) );
			Assert( cbT < sizeof(pdbccinfo->szIndex) );
			pdbccinfo->szIndex[cbT] = '\0';

			/*	check space, for index
			/**/
			Call( ErrRECSetCurrentIndex( pfucbTable, pdbccinfo->szIndex ) );
			if ( pfucbTable->pfucbCurIndex == pfucbNil )
				{
				DIRGotoFDPRoot( pfucbTable );
				Call( ErrDBUTLCheckSpace( pdbccinfo, pfucbTable ) );
				fDumpedClusteredIndex = fTrue;
				}
			else
				{
				FUCBResetNonClustered( pfucbTable->pfucbCurIndex );
				DIRGotoFDPRoot( pfucbTable->pfucbCurIndex );
				err = ErrDBUTLCheckSpace( pdbccinfo, pfucbTable->pfucbCurIndex );
				FUCBSetNonClustered( pfucbTable->pfucbCurIndex );
				Call( err );
				}

			/*	move to next index
			/**/
			err = ErrIsamMove( ppib, pfucbMSI, JET_MoveNext, 0 );
			if ( err < 0 )
				{
				if ( err != JET_errNoCurrentRecord )
					Error( err, HandleError );
				}
			}

		if ( !fDumpedClusteredIndex )
			{
			pdbccinfo->szIndex[0] = 0;
			DIRGotoFDPRoot( pfucbTable );
			Call( ErrDBUTLCheckSpace( pdbccinfo, pfucbTable ) );
			}

NextObject:
		err = ErrIsamMove( ppib, pfucbMSO, JET_MoveNext, 0 );
		if ( err < 0 )
			{
			if ( err != JET_errNoCurrentRecord )
				Error( err, HandleError );
			}
		}
	while ( err != JET_errNoCurrentRecord );

	/*	polymorph error
	/**/
	err = JET_errSuccess;

HandleError:
	if ( pfucbTable != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucbTable ) );
	if ( pfucbMSI != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucbMSI ) );
	if ( pfucbMSO != pfucbNil )
		CallS( ErrFILECloseTable( ppib, pfucbMSO ) );

	return err;
	}



/***********************************************************
/******************* DBCC Main Routine *********************
/***********************************************************
/**/
ERR ISAMAPI ErrIsamDBUtilities( JET_SESID sesid, JET_DBUTIL *pdbutil )
	{
	JET_ERR	 				err = JET_errSuccess;
	DBCCINFO				dbccinfo;
	JET_INSTANCE			instance = 0;
	JET_DBID				dbid = 0;
	VDBID					vdbid;

	/*	initialize dbccinfo
	/**/
	memset( &dbccinfo, 0, sizeof(DBCCINFO) );
	Assert( dbccinfo.op == 0 );
	Assert( dbccinfo.grbitOptions == 0 );

	Assert( pdbutil->cbStruct == sizeof( JET_DBUTIL ) );
	
	// Populate DBCCINFO structure;
	if ( pdbutil->szDatabase == NULL )
		{
		err = ErrERRCheck( JET_errDatabaseInvalidName );
		return err;
		}
			
	switch ( pdbutil->op )
		{
#ifdef DEBUG
		case opDBUTILDumpData:
			if ( pdbutil->grbitOptions & JET_bitDBUtilOptionDumpVerbose )
				{
				// Verbose data dump also implies dumping key stats and
				// page information.
				dbccinfo.grbitOptions |= 
					( JET_bitDBUtilOptionDumpVerbose |
						JET_bitDBUtilOptionKeyStats |
						JET_bitDBUtilOptionPageDump );
				}
		case opDBUTILDumpMetaData:
		case opDBUTILDumpSpace:
			dbccinfo.op = pdbutil->op;
			break;

		case opDBUTILDumpLogfile:
			// szDatabase has been overloaded with the logfile to dump.
			err = ErrDUMPLog( pdbutil->szDatabase );
			return err;
		case opDBUTILSetHeaderState:
			err = ErrDUMPHeader( pdbutil->szDatabase, fTrue );
			return err;
#endif
		case opDBUTILDumpHeader:
			err = ErrDUMPHeader( pdbutil->szDatabase, fFalse );
			return err;
		case opDBUTILDumpCheckpoint:
			// szDatabase has been overloaded with the checkpoint file to dump.
			err = ErrDUMPCheckpoint( pdbutil->szDatabase );
			return err;
		
		default:
			// Unrecognized category or consistency check.  Force to consistency check.
			dbccinfo.op = opDBUTILConsistency;
		}

	if ( pdbutil->grbitOptions & JET_bitDBUtilOptionAllNodes )
		{
		dbccinfo.grbitOptions |= JET_bitDBUtilOptionAllNodes;
		}
	if ( pdbutil->grbitOptions & JET_bitDBUtilOptionKeyStats )
		{
		dbccinfo.grbitOptions |= JET_bitDBUtilOptionKeyStats;
		}
	if ( pdbutil->grbitOptions & JET_bitDBUtilOptionPageDump )
		{
		dbccinfo.grbitOptions |= JET_bitDBUtilOptionPageDump;
		}
	if ( pdbutil->grbitOptions & JET_bitDBUtilOptionCheckBTree )
		{
		dbccinfo.grbitOptions |= JET_bitDBUtilOptionCheckBTree;
		}

	Assert( pdbutil->szDatabase != NULL );		// Check is done above.
	strcpy( dbccinfo.szDatabase, pdbutil->szDatabase );

	if ( pdbutil->szTable != NULL )
		{
		strcpy( dbccinfo.szTable, pdbutil->szTable );
		}
	if ( pdbutil->szIndex != NULL )
		{
		strcpy( dbccinfo.szIndex, pdbutil->szIndex );
		}


	/*	attach/open database, table and index
	/**/
	Call( ErrIsamAttachDatabase( sesid, dbccinfo.szDatabase, JET_bitDbReadOnly ) );
	Assert( err != JET_wrnDatabaseAttached );	// Since logging/recovery is disabled.
	
	Call( ErrIsamOpenDatabase( sesid, dbccinfo.szDatabase, NULL, &dbid, JET_bitDbExclusive | JET_bitDbReadOnly ) );
	vdbid = (VDBID)dbid;

	/*	initialize dbccinfo
	/**/
	dbccinfo.ppib = vdbid->ppib;
	dbccinfo.dbid = vdbid->dbid;
	dbccinfo.tableidPageInfo = JET_tableidNil;
	dbccinfo.tableidSpaceInfo = JET_tableidNil;

	/*	create/open required temp tables
	/**/
	Call( ErrDBUTLInfoInit( &dbccinfo ) );
	
	/*	check database according to command line args/flags
	/**/
	switch ( dbccinfo.op )
		{
		case opDBUTILConsistency:
		case opDBUTILDumpData:
			if ( dbccinfo.szTable[0] != '\0' )
				{
				Call( ErrDBUTLCheckOneTable( &dbccinfo ) );
				}
			else
				{
				Call( ErrDBUTLCheckDB( &dbccinfo ) );
				Call( ErrDBUTLCheckTables( &dbccinfo ) );
				}
			break;
		case opDBUTILDumpMetaData:
			Call( ErrDBUTLDumpMetaData( &dbccinfo ) );
			break;
		case opDBUTILDumpSpace:
			Call( ErrDBUTLDumpSpaceData( &dbccinfo ) );
			break;
		default:
			Assert( fFalse );
		}

	/*	print results
	/**/
	Call( ErrDBUTLInfoPrint( &dbccinfo ) );
	
	/*	close temp tables
	/**/
	DBUTLInfoTerm( &dbccinfo );	
	
	/*	terminate
	/**/
HandleError:
	if ( dbid )
		{
		(VOID)ErrIsamCloseDatabase( sesid, dbid, 0 );
		}

	(VOID)ErrIsamDetachDatabase( sesid, dbccinfo.szDatabase );

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\fcb.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */


/*	LRU list of all file FCBs.  Some may not be in use, and have
/*	wRefCnt == 0 and may be reused for other directories.
/**/
CRIT	critFCB = NULL;
FCB		*pfcbGlobalMRU = pfcbNil;
FCB		*pfcbGlobalLRU = pfcbNil;

#define FCB_STATS	1

#ifdef FCB_STATS
ULONG	cfcbTables = 0;
ULONG	cfcbTotal = 0;
ULONG	cfucbLinked = 0;
ULONG	cfcbVer = 0; /* delete index in progress */
#endif


VOID FCBInit( VOID )
	{
	Assert( pfcbGlobalMRU == pfcbNil );
	Assert( pfcbGlobalLRU == pfcbNil );
	return;
	}

/*	reset pfcbGlobalMRU
/**/
VOID FCBTerm( VOID )
	{
	pfcbGlobalMRU = pfcbNil;
	pfcbGlobalLRU = pfcbNil;
	return;
	}


VOID FCBInsert( FCB *pfcb )
	{
	Assert( pfcbGlobalMRU != pfcb );

	/*	check LRU consistency
	/**/
	Assert( pfcbGlobalMRU == pfcbNil
		|| pfcbGlobalMRU->pfcbMRU == pfcbNil );
	Assert( pfcbGlobalLRU == pfcbNil
		|| pfcbGlobalLRU->pfcbLRU == pfcbNil );

	/*	link FCB in LRU list at MRU end
	/**/
	if ( pfcbGlobalMRU != pfcbNil )
		pfcbGlobalMRU->pfcbMRU = pfcb;
	pfcb->pfcbLRU = pfcbGlobalMRU;
	pfcb->pfcbMRU = pfcbNil;
	pfcbGlobalMRU = pfcb;
	if ( pfcbGlobalLRU == pfcbNil )
		pfcbGlobalLRU = pfcb;
	FCBSetInLRU( pfcb );
	
	/*	check LRU consistency
	/**/
	Assert( pfcbGlobalMRU == pfcbNil
		|| pfcbGlobalMRU->pfcbMRU == pfcbNil );
	Assert( pfcbGlobalLRU == pfcbNil
		|| pfcbGlobalLRU->pfcbLRU == pfcbNil );

#ifdef FCB_STATS
	{
	FCB	*pfcbT;

	cfcbTables++;
	for ( pfcbT = pfcb; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		cfcbTotal++;
	}
#endif

	return;
	}


LOCAL VOID FCBIDelete( FCB *pfcb )
	{
	/*	check LRU consistency
	/**/
	Assert( pfcbGlobalMRU == pfcbNil
		|| pfcbGlobalMRU->pfcbMRU == pfcbNil );
	Assert( pfcbGlobalLRU == pfcbNil
		|| pfcbGlobalLRU->pfcbLRU == pfcbNil );

	/*	unlink FCB from FCB LRU list
	/**/
	FCBResetInLRU( pfcb );
	Assert( pfcb->pfcbMRU == pfcbNil
		|| pfcb->pfcbMRU->pfcbLRU == pfcb );
	if ( pfcb->pfcbMRU != pfcbNil )
		pfcb->pfcbMRU->pfcbLRU = pfcb->pfcbLRU;
	else
		{
		Assert( pfcbGlobalMRU == pfcb );
		pfcbGlobalMRU = pfcb->pfcbLRU;
		}
	Assert( pfcb->pfcbLRU == pfcbNil
		|| pfcb->pfcbLRU->pfcbMRU == pfcb );
	if ( pfcb->pfcbLRU != pfcbNil )
		pfcb->pfcbLRU->pfcbMRU = pfcb->pfcbMRU;
	else
		{
		Assert( pfcbGlobalLRU == pfcb );
		pfcbGlobalLRU = pfcb->pfcbMRU;
		}

	/*	check LRU consistency
	/**/
	Assert( pfcbGlobalMRU == pfcbNil
		|| pfcbGlobalMRU->pfcbMRU == pfcbNil );
	Assert( pfcbGlobalLRU == pfcbNil
		|| pfcbGlobalLRU->pfcbLRU == pfcbNil );

#ifdef FCB_STATS
	{
	FCB	*pfcbT;

	cfcbTables--;
	for ( pfcbT = pfcb; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		cfcbTotal--;
	}
#endif

	return;
	}


VOID FCBIMoveToMRU( FCB *pfcb )
	{
	/*	unlink FCB from FCB LRU list
	/**/
	FCBIDelete( pfcb );

	/*	link FCB in LRU list at MRU end
	/**/
	FCBInsert( pfcb );

	return;
	}


VOID FCBLink( FUCB *pfucb, FCB *pfcb )
	{
	Assert( pfucb != pfucbNil );
	Assert( pfcb != pfcbNil );
	SgEnterCriticalSection( critFCB );
	pfucb->u.pfcb = pfcb;
	pfucb->pfucbNextInstance = pfcb->pfucb;
	pfcb->pfucb = pfucb;
	pfcb->wRefCnt++;
	Assert( pfcb->wRefCnt > 0 );
#ifdef DEBUG
	{
	FUCB	*pfucbT = pfcb->pfucb;
	INT		cfcb = 0;

	while( cfcb++ < pfcb->wRefCnt && pfucbT != pfucbNil )
		{
		pfucbT = pfucbT->pfucbNextInstance;
		}
	Assert( pfucbT == pfucbNil );
	}
#endif

#ifdef FCB_STATS
	cfucbLinked++;
#endif

	SgLeaveCriticalSection( critFCB );
	return;
	}


VOID FCBUnlink( FUCB *pfucb )
	{
	FUCB   	*pfucbCurr;
	FUCB   	*pfucbPrev;
	FCB		*pfcb;

	Assert( pfucb != pfucbNil );
	pfcb = pfucb->u.pfcb;
	Assert( pfcb != pfcbNil );
	SgEnterCriticalSection( critFCB );
	pfucb->u.pfcb = pfcbNil;
	pfucbPrev = pfucbNil;
	Assert( pfcb->pfucb != pfucbNil );
	pfucbCurr = pfcb->pfucb;
	while ( pfucbCurr != pfucb )
		{
		pfucbPrev = pfucbCurr;
		pfucbCurr = pfucbCurr->pfucbNextInstance;
		Assert( pfucbCurr != pfucbNil );
		}
	if ( pfucbPrev == pfucbNil )
		{
		pfcb->pfucb = pfucbCurr->pfucbNextInstance;
		}
	else
		{
		pfucbPrev->pfucbNextInstance = pfucbCurr->pfucbNextInstance;
		}
	Assert( pfcb->wRefCnt > 0 );
	pfcb->wRefCnt--;

	if ( pfcb->wRefCnt == 0  &&  FFCBInLRU( pfcb ) )
		{
		/*	move to MRU list if refernece count reduced to 0
		/**/
		FCBIMoveToMRU( pfcb );
		}

#ifdef FCB_STATS
	cfucbLinked--;
#endif

	SgLeaveCriticalSection( critFCB );
	return;
	}


/*	returns index of bucket in FCB Hash given dbid, pgnoFDP
/**/
LOCAL INLINE ULONG UlFCBHashVal( DBID dbid, PGNO pgnoFDP )
	{
	return ( dbid + pgnoFDP ) % cFCBBuckets;
	}


/*	inserts FCB in hash table
/**/
VOID FCBInsertHashTable( FCB *pfcb )
	{
	ULONG	cBucket = UlFCBHashVal( pfcb->dbid, pfcb->pgnoFDP );

	Assert( cBucket <= cFCBBuckets );
	Assert( pfcb->pfcbNextInHashBucket == pfcbNil );
	Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcbNil );

	Assert( pfcbHash[cBucket] != pfcb );
	pfcb->pfcbNextInHashBucket = pfcbHash[cBucket];
	pfcbHash[cBucket] = pfcb;
	
	return;
	}


/*	deletes FCB from hash table
/**/
VOID FCBDeleteHashTable( FCB *pfcb )
	{
	ULONG  	cBucket = UlFCBHashVal( pfcb->dbid, pfcb->pgnoFDP );
	FCB		**ppfcb;

	Assert( cBucket <= cFCBBuckets );
	
	for ( ppfcb = &pfcbHash[cBucket];
		*ppfcb != pfcbNil;
		ppfcb = &(*ppfcb)->pfcbNextInHashBucket )
		{
		Assert( UlFCBHashVal( (*ppfcb)->dbid, (*ppfcb)->pgnoFDP ) == cBucket );
		if ( *ppfcb == pfcb )
			{
			*ppfcb = pfcb->pfcbNextInHashBucket;
			pfcb->pfcbNextInHashBucket = pfcbNil;
			Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcbNil );
			
			return;
			}
		else
			{
			Assert( pfcb->dbid != (*ppfcb)->dbid || pfcb->pgnoFDP != (*ppfcb)->pgnoFDP );
			}
		}

	Assert( fFalse );
	}


/*	gets pointer to FCB with given dbid, pgnoFDP if one exists in hash;
/*	returns pfcbNil otherwise
/**/
FCB *PfcbFCBGet( DBID dbid, PGNO pgnoFDP )
	{
	ULONG  	cBucket = UlFCBHashVal( dbid, pgnoFDP );
	FCB		*pfcb = pfcbHash[cBucket];

	for ( ;
		pfcb != pfcbNil && !( pfcb->dbid == dbid && pfcb->pgnoFDP == pgnoFDP );
		pfcb = pfcb->pfcbNextInHashBucket );

#ifdef DEBUG
	/*	check for no duplicates in bucket
	/**/
	if ( pfcb != pfcbNil )
		{
		FCB	*pfcbT = pfcb->pfcbNextInHashBucket;

		for ( ; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextInHashBucket )
			{
			Assert ( pfcbT->dbid != dbid || pfcbT->pgnoFDP != pgnoFDP );
			}
		}
#endif

	Assert( pfcb == pfcbNil || ( pfcb->dbid == dbid && pfcb->pgnoFDP == pgnoFDP ) );
	return pfcb;
	}


/*	clean-up after redo
/**/
FCB *FCBResetAfterRedo( VOID )
	{
	FCB	 	*pfcb;

	for ( pfcb = pfcbGlobalMRU; pfcb != pfcbNil; pfcb = pfcb->pfcbLRU )
		{
		if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
			{
			FCBDeleteHashTable( pfcb );
			}
		pfcb->dbid = 0;
		pfcb->pgnoFDP = pgnoNull;
		pfcb->wRefCnt = 0;
		}

	return pfcbNil;
	}

// Check's if a table's FCB can be deallocated, and if so, is the table's FCB or
// any of its index FCBs allocated in the space above the preferred threshold.
STATIC INLINE BOOL FFCBAvail2( FCB *pfcbTable, PIB *ppib, BOOL *pfAboveThreshold )
	{
	Assert( pfcbTable != pfcbNil );
	Assert( pfAboveThreshold );
	*pfAboveThreshold = fFalse;
	
	// This IF is essentially the same check as FFCBAvail(), but I didn't call
	// it because then I'd have to loop through the FCB's twice -- once for
	// the version count and once for the threshold check.
	if ( pfcbTable->wRefCnt == 0 &&
		pfcbTable->pgnoFDP != 1 &&
		!FFCBReadLatch( pfcbTable ) &&
		!FFCBSentinel( pfcbTable ) &&
		!FFCBDomainDenyRead( pfcbTable, ppib ) &&
		!FFCBWait( pfcbTable ) )
		{
		FCB *pfcbT;

		for ( pfcbT = pfcbTable; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
			{
			if ( pfcbT->cVersion > 0 )
				return fFalse;
			if ( pfcbT >= PfcbMEMPreferredThreshold() )
				*pfAboveThreshold = fTrue;
			}

		return fTrue;
		}

	return fFalse;
	}	


ERR ErrFCBAlloc( PIB *ppib, FCB **ppfcb )
	{
	FCB		*pfcb;
	FCB		*pfcbAboveThreshold = pfcbNil;

	/*	first try free pool
	/**/
	pfcb = PfcbMEMAlloc();
	if ( pfcb != pfcbNil )
		{
		if ( pfcb >= PfcbMEMPreferredThreshold() )
			{
			pfcbAboveThreshold = pfcb;
#ifdef DEBUG
			// Need to init to bypass asserts in MEMReleasePfcb() in
			// case the FCB is subsequently freed below.
			FCBInitFCB( pfcbAboveThreshold );
#endif			
			}
		else
			{
			goto InitFCB;
			}
		}

	/*	clean versions in order to make more FCBs avaiable
	/*	for reuse.  This must be done sinece FCBs are referenced
	/*	by versioned and can only be cleaned when the cVersion
	/*	count in the FCB is 0.
	/**/
	(VOID)ErrRCECleanAllPIB();

	/*	look for FCB with 0 reference count, and also, no deny read
	/*	flag set.  It is possible that the reference count will be
	/*	zero and the deny read flag set.
	/**/

	// Try to free as many FCB's above the preferred threshold
	// as possible, and also try to find one below the threshold.
	if ( PfcbMEMPreferredThreshold() < PfcbMEMMax() )
		{
		FCB		*pfcbT;
		BOOL	fAboveThreshold;

		pfcb = pfcbNil;		// Reset;
		
		SgEnterCriticalSection( critFCB );
		for ( pfcbT = pfcbGlobalLRU; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbMRU )
			{
			if ( FFCBAvail2( pfcbT, ppib, &fAboveThreshold ) )
				{
				if ( fAboveThreshold )
					{
					FCB	*pfcbKill = pfcbT;
#ifdef DEBUG					
					FCB	*pfcbNextMRU = pfcbT->pfcbMRU;
#endif					

					pfcbT = pfcbT->pfcbLRU;
					
					// If the table FCB or any of its index FCB's is above the
					// preferred threshold, free the table.
					FCBIDelete( pfcbKill );
					FILEIDeallocateFileFCB( pfcbKill );

					Assert( pfcbT->pfcbMRU == pfcbNextMRU );
					}
				else if ( pfcb == pfcbNil )
					{
					// Found in the LRU an available FCB below the
					// preferred threshold.
					Assert( pfcbT < PfcbMEMPreferredThreshold() );
					pfcb = pfcbT;
					}
					
				}
			}
		SgLeaveCriticalSection( critFCB );

		pfcbT = PfcbMEMAlloc();
		if ( pfcbT != pfcbNil )
			{
			if ( pfcbT < PfcbMEMPreferredThreshold() )
				{
				// Cleanup yielded an FCB below the preferred threshold.
				if ( pfcbAboveThreshold != pfcbNil )
					{
					MEMReleasePfcb( pfcbAboveThreshold );
					}
				pfcb = pfcbT;
				goto InitFCB;
				}
			else
				{
#ifdef DEBUG
				// Need to init to bypass asserts in MEMReleasePfcb() in
				// case the FCB is subsequently freed below.
				FCBInitFCB( pfcbT );
#endif			
				if ( pfcbAboveThreshold == pfcbNil )
					{
					// Cleanup yielded an FCB above the preferred threshold.
					pfcbAboveThreshold = pfcbT;
					}
				else
					{
					// Cleanup yielded an FCB above the preferred threshold, but
					// we already have one.
					MEMReleasePfcb( pfcbT );
					}
				}
			}

		if ( pfcb == pfcbNil )
			{
			if ( pfcbAboveThreshold != pfcbNil )
				{
				// No free FCB's in the LRU, so just use the FCB that we found
				// previously, even though it's above the preferred threshold.
				pfcb = pfcbAboveThreshold;
				goto InitFCB;
				}
			else
				return ErrERRCheck( JET_errTooManyOpenTables );
				
			}
			
		Assert( !FFCBSentinel( pfcb ) );

		/*	remove from global list and deallocate
		/**/
		SgEnterCriticalSection( critFCB );
		FCBIDelete( pfcb );
		SgLeaveCriticalSection( critFCB );
		FILEIDeallocateFileFCB( pfcb );

		/*	there should be some FCBs free now, unless somebody happened to
		/*	grab the newly freed FCBs between these 2 statements
		/**/
		pfcb = PfcbMEMAlloc();
		if ( pfcb == pfcbNil )
			{
			if ( pfcbAboveThreshold != pfcbNil )
				{
				// No free FCB's in the LRU, so just use the FCB that we found
				// previously, even though it's above the preferred threshold.
				pfcb = pfcbAboveThreshold;
				}
			else
				return ErrERRCheck( JET_errOutOfMemory );
			}
		else if ( pfcbAboveThreshold != pfcbNil )
			{
			// The FCB we just allocated may or may not be below the preferred
			// threshold (only a loss of critJet between the dealloc and alloc
			// above would result in the FCB being above the threshold).  Gamble
			// that it is below the threshold and throw away the one we know is
			// definitely above the threshold.
			MEMReleasePfcb( pfcbAboveThreshold );
			}
		
		}
	else
		{
		// If there's no threshold, then an FCB couldn't have been allocated above it.
		Assert( pfcbAboveThreshold == pfcbNil );
		Assert( pfcb == pfcbNil );
		
		SgEnterCriticalSection( critFCB );
		for ( pfcb = pfcbGlobalLRU;
			pfcb != pfcbNil && !FFCBAvail( pfcb, ppib );
			pfcb = pfcb->pfcbMRU );
		SgLeaveCriticalSection( critFCB );
		
		if ( pfcb == pfcbNil )
			{
			return ErrERRCheck( JET_errTooManyOpenTables );
			}
			
		Assert( !FFCBSentinel( pfcb ) );

		/*	remove from global list and deallocate
		/**/
		SgEnterCriticalSection( critFCB );
		FCBIDelete( pfcb );
		SgLeaveCriticalSection( critFCB );
		FILEIDeallocateFileFCB( pfcb );

		/*	there should be some FCBs free now, unless somebody happened to
		/*	grab the newly freed FCBs between these 2 statements
		/**/
		pfcb = PfcbMEMAlloc();
		if ( pfcb == pfcbNil )
			{
			return ErrERRCheck( JET_errOutOfMemory );
			}
		}

InitFCB:

	FCBInitFCB( pfcb );
	*ppfcb = pfcb;
	Assert( (*ppfcb)->wRefCnt == 0 );

	return JET_errSuccess;
	}


//	UNDONE:	remove the need for this routine by having open
//		   	database create an FCB and permanently hold it
//		   	open via reference count on database record
ERR ErrFCBNew( PIB *ppib, DBID dbid, PGNO pgno, FCB **ppfcb )
	{
	ERR	err;

	NotUsed( pgno );

	CallR( ErrFCBAlloc( ppib, ppfcb ) );

	/*	initialize FCB
	/**/
	FCBInitFCB( *ppfcb );
	(*ppfcb)->dbid = dbid;
	(*ppfcb)->pgnoFDP = pgnoSystemRoot;
	(*ppfcb)->cVersion = 0;

	/*	insert into global fcb list and hash
	/**/
	FCBInsert( *ppfcb );
	FCBInsertHashTable( *ppfcb );

	return JET_errSuccess;
	}


//+API
//	FCBPurgeDatabase
//	========================================================================
//	FCBPurgeDatabase( DBID dbid )
//
//	Removes alls FCBs from the global list for given dbid.  Called when
//	database detached, so newly created or attached database with
//	same dbid will not have tables confused with previous databases
//	tables.
//
//	PARAMETERS		dbid		dbid of database
//		   						or dbidNull if all FCBs are to be purged
//
//	SIDE EFFECTS	FCBs whose FDPpgno matches the given dbid are
//		   			removed from the global list.
//-
VOID FCBPurgeDatabase( DBID dbid )
	{
	FCB	*pfcb;		// pointer to current FCB in list walk
	FCB	*pfcbT;		// pointer to next FCB

	SgEnterCriticalSection( critFCB );

	pfcb = pfcbGlobalMRU;
	while ( pfcb != pfcbNil )
		{
		pfcbT = pfcb->pfcbLRU;
		if ( pfcb->dbid == dbid || dbid == 0 )
			{
			FCBIDelete( pfcb );

			if ( FFCBSentinel( pfcb ) )
				{
				if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
					{
					FCBDeleteHashTable( pfcb );
					}
				Assert( pfcb->cVersion == 0 );
				MEMReleasePfcb( pfcb );
				}
			else
				{
				FILEIDeallocateFileFCB( pfcb );
				}
			}

		pfcb = pfcbT;
		}

	SgLeaveCriticalSection( critFCB );
	}


//+FILE_PRIVATE
// FCBPurgeTable
// ========================================================================
// FCBPurgeTable( DBID dbid, PNGO pgnoFDP )
//
// Purges and deallocates table FCBs from the global list.
//
// PARAMETERS	pgnoFDP		table FDP page number
//
// SIDE EFFECTS
//		The table index FCBs whose FDP pgno matches the input 
//		parameter are removed from the global list.
//-
VOID FCBPurgeTable( DBID dbid, PGNO pgnoFDP )
	{
	FCB		*pfcb;

	SgEnterCriticalSection( critFCB );

	pfcb = pfcbGlobalMRU;
	while ( pfcb != pfcbNil )
		{
		if ( pfcb->pgnoFDP == pgnoFDP
			&& pfcb->dbid == dbid )
			break;
		pfcb = pfcb->pfcbLRU;
		}

	if ( pfcb == pfcbNil )
		{
		SgLeaveCriticalSection( critFCB );
		return;
		}

	Assert( pfcb->wRefCnt == 0 );
	FCBIDelete( pfcb );

	if ( FFCBSentinel( pfcb ) )
		{
		if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb )
			{
			FCBDeleteHashTable( pfcb );
			}
		Assert( pfcb->cVersion == 0 );
		MEMReleasePfcb( pfcb );
		}
	else
		{
		FILEIDeallocateFileFCB( pfcb );
		}

	SgLeaveCriticalSection( critFCB );
	return;
	}


/***********************************************************
/****************** Table Operations ***********************
/***********************************************************
/**/


/*	set domain usage mode or return error.  Allow only one deny read
/*	or one deny write.  Sessions that own locks may open other read
/*	or read write cursors, but not another deny read or deny write cursor.
/*	This is done to facillitage flag management, but could be relaxed
/*	if required.
/**/
ERR ErrFCBISetMode( PIB *ppib, FCB *pfcb, JET_GRBIT grbit )
	{
	FUCB	*pfucbT;

	/*	if table is fake deny read, then return error
	/**/
	if ( FFCBSentinel( pfcb ) )
		return ErrERRCheck( JET_errTableLocked );

	/*	all cursors can read so check for deny read flag by other session.
	/**/
	if ( FFCBDomainDenyRead( pfcb, ppib ) )
		{
		/*	check if domain is deny read locked by other session.  If
		/*	deny read locked, then all cursors must be of same session.
		/**/
		Assert( pfcb->ppibDomainDenyRead != ppibNil );
		Assert ( pfcb->ppibDomainDenyRead != ppib );
		return ErrERRCheck( JET_errTableLocked );
		}

	if ( FFCBDeletePending( pfcb ) )
		{
		// Normally, the FCB of a table to be deleted is protected by the
		// DomainDenyRead flag.  However, this flag is released during VERCommit,
		// while the FCB is not actually purged until RCEClean.  So to prevent
		// anyone from accessing this FCB after the DomainDenyRead flag has been
		// released but before the FCB is actually purged, check the DeletePending
		// flag, which is NEVER cleared after a table is flagged for deletion.
		return ErrERRCheck( JET_errTableLocked );
		}

	/*	check for deny write flag by other session.  If deny write flag
	/*	set then only cursors of that session may have write privlages.
	/**/
	if ( grbit & JET_bitTableUpdatable )
		{
		if ( FFCBDomainDenyWrite( pfcb ) )
			{
			for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextInstance )
				{
				if ( pfucbT->ppib != ppib && FFUCBDenyWrite( pfucbT ) )
					return ErrERRCheck( JET_errTableLocked );
				}
			}
		}

	/*	if deny write lock requested, check for updatable cursor of
	/*	other session.  If lock is already held, even by given session,
	/*	then return error.
	/**/
	if ( grbit & JET_bitTableDenyWrite )
		{
		/*	if any session has this table open deny write, including given
		/*	session, then return error.
		/**/
		if ( FFCBDomainDenyWrite( pfcb ) )
			{
			return ErrERRCheck( JET_errTableInUse );
			}

		/*	check is cursors with write mode on domain.
		/**/
		for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextInstance )
			{
			if ( pfucbT->ppib != ppib && FFUCBUpdatable( pfucbT ) )
				{
				return ErrERRCheck( JET_errTableInUse );
				}
			}
		FCBSetDomainDenyWrite( pfcb );
		}

	/*	if deny read lock requested, then check for cursor of other
	/*	session.  If lock is already held, even by given session, then
	/*	return error.
	/**/
	if ( grbit & JET_bitTableDenyRead )
		{
		/*	if any session has this table open deny read, including given
		/*	session, then return error.
		/**/
		if ( FFCBDomainDenyRead( pfcb, ppib ) )
			{
			return ErrERRCheck( JET_errTableInUse );
			}
		/*	check if cursors belonging to another session
		/*	are open on this domain.
		/**/
		for ( pfucbT = pfcb->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextInstance )
			{
			if ( pfucbT->ppib != ppib )
				{
				return ErrERRCheck( JET_errTableInUse );
				}
			}
		FCBSetDomainDenyRead( pfcb, ppib );
		}

	return JET_errSuccess;
	}


/*	reset domain mode usage
/**/
VOID FCBResetMode( PIB *ppib, FCB *pfcb, JET_GRBIT grbit )
	{
	if ( grbit & JET_bitTableDenyRead )
		{
		Assert( FFCBDomainDenyRead( pfcb, ppib ) );
		FCBResetDomainDenyRead( pfcb );
		}

	if ( grbit & JET_bitTableDenyWrite )
		{
		Assert( FFCBDomainDenyWrite( pfcb ) );
		FCBResetDomainDenyWrite( pfcb );
		}

	return;
	}


ERR ErrFCBSetDeleteTable( PIB *ppib, DBID dbid, PGNO pgno )
	{
	ERR		err;
	FCB		*pfcb;

Start:
	SgEnterCriticalSection( critFCB );
	pfcb = PfcbFCBGet( dbid, pgno );
	if ( pfcb == pfcbNil )
		{
		CallR( ErrFCBAlloc( ppib, &pfcb ) );
		/*	allocation should be synchronous
		/**/
		Assert( PfcbFCBGet( dbid, pgno ) == pfcbNil );
		Assert( pfcbGlobalMRU != pfcb );
		pfcb->dbid = dbid;
		pfcb->pgnoFDP = pgno;
		Assert( pfcb->wRefCnt == 0 );
		FCBSetSentinel( pfcb );
		FCBSetDomainDenyRead( pfcb, ppib );
		FCBInsert( pfcb );
		FCBInsertHashTable( pfcb );
		}
	else
		{
		INT		wRefCnt = pfcb->wRefCnt;
		FUCB	*pfucbT;

		Assert( ppib != ppibBMClean );

		/*	if any open cursors on table, or deferred closed by other
		/*	session then return JET_errTableInUse.
		/**/
		for ( pfucbT = pfcb->pfucb;
			pfucbT != pfucbNil;
			pfucbT = pfucbT->pfucbNextInstance )
			{
			if ( FFUCBDeferClosed( pfucbT ) && pfucbT->ppib == ppib )
				{
				Assert( wRefCnt > 0 );
				wRefCnt--;
				}
			else if ( pfucbT->ppib == ppibBMClean )
				{
				SgLeaveCriticalSection( critFCB );
				/*	wait for bookmark cleanup
				/**/
				BFSleep( cmsecWaitGeneric );
				goto Start;
				}
			}

		if ( wRefCnt > 0 )
			{
			SgLeaveCriticalSection( critFCB );
			return ErrERRCheck( JET_errTableInUse );
			}
		else if ( FFCBDomainDenyRead( pfcb, ppib ) )
			{
			// Someone else may already be in the process of deleting the table.
			// Note that this is the ONLY possible way to get here.  If some other
			// thread had set the DomainDenyRead flag (besides one that is deleting
			// the table), then the FCB's RefCnt would have been greater than 0.
			// UNDONE: Can I add better asserts to check for this condition??
			SgLeaveCriticalSection( critFCB );
			return ErrERRCheck( JET_errTableLocked );
			}

		FCBSetDomainDenyRead( pfcb, ppib );
		}

	SgLeaveCriticalSection( critFCB );
	return JET_errSuccess;
	}


VOID FCBResetDeleteTable( FCB *pfcbDelete )
	{
	Assert( pfcbDelete != pfcbNil );

	if ( FFCBSentinel( pfcbDelete ) )
		{
		FCB	*pfcb;

		SgEnterCriticalSection( critFCB );
	
		pfcb = pfcbGlobalMRU;
		while ( pfcb != pfcbNil )
			{
			if ( pfcb == pfcbDelete )
				break;
			pfcb = pfcb->pfcbLRU;
			}

		Assert( pfcb == pfcbDelete );

		FCBDeleteHashTable( pfcb );
		FCBIDelete( pfcb );
		Assert( pfcb->cVersion == 0 );
		MEMReleasePfcb( pfcb );
		SgLeaveCriticalSection( critFCB );
		}
	else
		{
		FCBResetDomainDenyRead( pfcbDelete );
		}

	return;
	}


ERR ErrFCBSetRenameTable( PIB *ppib, DBID dbid, PGNO pgnoFDP )
	{
	ERR	err = JET_errSuccess;
	FCB	*pfcb;

	SgEnterCriticalSection( critFCB );
	pfcb = PfcbFCBGet( dbid, pgnoFDP );
	if ( pfcb != pfcbNil )
		{
		Call( ErrFCBSetMode( ppib, pfcb, JET_bitTableDenyRead ) );
		}
	else
		{
		CallR( ErrFCBAlloc( ppib, &pfcb ) );

		Assert( pfcbGlobalMRU != pfcb );
		pfcb->dbid = dbid;
		pfcb->pgnoFDP = pgnoFDP;
		pfcb->wRefCnt = 0;
		FCBSetDomainDenyRead( pfcb, ppib );
		FCBSetSentinel( pfcb );
		FCBInsert( pfcb );
		FCBInsertHashTable( pfcb );
		}

HandleError:
	SgLeaveCriticalSection( critFCB );
	return err;
	}


/*	return fTrue if table open with one or more non deferred closed tables
/**/
BOOL FFCBTableOpen( DBID dbid, PGNO pgnoFDP )
	{
	FCB 	*pfcb = PfcbFCBGet( dbid, pgnoFDP );
	FUCB	*pfucb;

	if ( pfcb == pfcbNil || pfcb->wRefCnt == 0 )
		return fFalse;

	for ( pfucb = pfcb->pfucb; pfucb != pfucbNil; pfucb = pfucb->pfucbNextInstance )
		{
		if ( !FFUCBDeferClosed( pfucb ) )
			return fTrue;
		}

	return fFalse;
	}

	
VOID FCBLinkIndex( FCB *pfcbTable, FCB *pfcbIndex )
	{
	pfcbIndex->pfcbNextIndex =	pfcbTable->pfcbNextIndex;
	pfcbTable->pfcbNextIndex = pfcbIndex;

#ifdef FCB_STATS
	cfcbTotal++;
#endif

	return;
	}


VOID FCBUnlinkIndex( FCB *pfcbTable, FCB *pfcbIndex )
	{
	FCB	*pfcbT;

	for ( pfcbT = pfcbTable;
		pfcbT != pfcbNil && pfcbT->pfcbNextIndex != pfcbIndex;
		pfcbT = pfcbT->pfcbNextIndex );
	Assert( pfcbT != pfcbNil );
	pfcbT->pfcbNextIndex = pfcbIndex->pfcbNextIndex;
	pfcbIndex->pfcbNextIndex = pfcbNil;

#ifdef FCB_STATS
	cfcbTotal--;
#endif

	return;
	}


BOOL FFCBUnlinkIndexIfFound( FCB *pfcbTable, FCB *pfcbIndex )
	{
	FCB	*pfcbT;

	for ( pfcbT = pfcbTable;
		pfcbT != pfcbNil && pfcbT->pfcbNextIndex != pfcbIndex;
		pfcbT = pfcbT->pfcbNextIndex );

	if ( pfcbT != pfcbNil )
		{
		pfcbT->pfcbNextIndex = pfcbIndex->pfcbNextIndex;
		pfcbIndex->pfcbNextIndex = pfcbNil;
#ifdef FCB_STATS
	cfcbTotal--;
#endif
		return fTrue;
		}

	return fFalse;
	}


/*	detach deleted index FCB from non-clustered index chain.
/**/
FCB *PfcbFCBUnlinkIndexByName( FCB *pfcb, CHAR *szIndex )
	{
	FCB	**ppfcbIdx;
	FCB	*pfcbT;

	/*	find non-clustered index in table index FCB list.
	/**/
	for ( ppfcbIdx = &pfcb->pfcbNextIndex;
		*ppfcbIdx != pfcbNil && UtilCmpName( (*ppfcbIdx)->pidb->szName, szIndex ) != 0;
		ppfcbIdx = &(*ppfcbIdx)->pfcbNextIndex )
		{
		;/*** Null-body ***/
		}

	Assert( *ppfcbIdx != pfcbNil );

	/*	remove index FCB
	/**/
	pfcbT = *ppfcbIdx;
	*ppfcbIdx = (*ppfcbIdx)->pfcbNextIndex;
#ifdef FCB_STATS
	cfcbTotal--;
#endif
	return pfcbT;
	}


ERR ErrFCBSetDeleteIndex( PIB *ppib, FCB *pfcbTable, CHAR *szIndex )
	{
	FCB		*pfcbT;
	INT		wRefCnt;
	FUCB	*pfucbT;

	/*	find index pfcb in index list
	/**/
	for( pfcbT = pfcbTable->pfcbNextIndex; ; pfcbT = pfcbT->pfcbNextIndex )
		{
		if ( UtilCmpName( szIndex, pfcbT->pidb->szName ) == 0 )
			break;
		Assert( pfcbT->pfcbNextIndex != pfcbNil );
		}

	wRefCnt = pfcbT->wRefCnt;

	/*	check for open cursors on table or deferred closed
	/*	cursors by other session.
	/**/
	if ( wRefCnt > 0 )
		{
		for ( pfucbT = pfcbT->pfucb;
			pfucbT != pfucbNil;
			pfucbT = pfucbT->pfucbNextInstance )
			{
			if ( FFUCBDeferClosed( pfucbT ) && pfucbT->ppib == ppib )
				{
				Assert( wRefCnt > 0 );
				wRefCnt--;
				}
			}
		}

	if ( wRefCnt > 0 )
		{
		SgLeaveCriticalSection( critFCB );
		return ErrERRCheck( JET_errIndexInUse );
		}

	FCBSetDomainDenyRead( pfcbT, ppib );
	FCBSetDeletePending( pfcbT );

	return JET_errSuccess;
	}


VOID FCBResetDeleteIndex( FCB *pfcbIndex )
	{
	FCBResetDeletePending( pfcbIndex );
	FCBResetDomainDenyRead( pfcbIndex );
	return;
	}


#ifdef FCB_STATS
ULONG UlFCBITableCount( VOID )
	{
	ULONG	ulT = 0;
	FCB		*pfcbT = pfcbGlobalLRU;

	for ( pfcbT = pfcbGlobalLRU; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbMRU )
		ulT++;
	return ulT;
	}


ULONG UlFCBITotalCount( VOID )
	{
	ULONG	ulT = 0;
	FCB		*pfcbT = pfcbGlobalLRU;
	FCB		*pfcbTT;

	for ( pfcbT = pfcbGlobalLRU; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbMRU )
		for ( pfcbTT = pfcbT; pfcbTT != pfcbNil; pfcbTT = pfcbTT->pfcbNextIndex )
		ulT++;
	return ulT;
	}

ULONG UlFCBITotalCursorCount( VOID )
	{
	ULONG	ulT = 0;
	FCB		*pfcbT = pfcbGlobalLRU;
	FCB		*pfcbTT;

	for ( pfcbT = pfcbGlobalLRU; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbMRU )
		for ( pfcbTT = pfcbT; pfcbTT != pfcbNil; pfcbTT = pfcbTT->pfcbNextIndex )
		ulT += pfcbTT->wRefCnt;
	return ulT;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\edbutil.c ===
#include <windows.h>

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <conio.h>

#include "jet.h"
#include "version.h"
#include "regenv.h"
#include "config.h"					// For DEBUG flag

#include "_edbutil.h"

#include "utilmsg.h"

#define szUser			"user"
#define szPassword		""



// UNDONE:  Must still be localised, but centralising all the localisable strings
// here makes my job easier.

static const char		*szDefaultDefragDB = "TEMPDFRG.EDB";
static const char		*szDefaultUpgradeDB = "TEMPUPGD.EDB";

static const char		*szDefrag =  "Defragmentation";
static const char		*szUpgrade = "Upgrade";
static const char		*szRestore = "Restore";
static const char		*szRepair = "Repair";

// UNDONE:  Get registry keys from TDCOMMON to insulate ourselves from changes.
#define szMachineKey			"HKEY_LOCAL_MACHINE"
#define szExchangeISKey			"SYSTEM\\CurrentControlSet\\Services\\MSExchangeIS\\ParametersSystem"
#define szExchangeISPrivKey		"SYSTEM\\CurrentControlSet\\Services\\MSExchangeIS\\ParametersPrivate"
#define szExchangeISPubKey		"SYSTEM\\CurrentControlSet\\Services\\MSExchangeIS\\ParametersPublic"
#define szExchangeISDBKey		"DB Path"
#define szExchangeISLogKey		"DB Log Path"
#define szExchangeISSysKey		"Working Directory"
#define szExchangeISMaxBufKey	"Max Buffers"
#define	szExchangeDSKey			"SYSTEM\\CurrentControlSet\\Services\\MSExchangeDS\\Parameters"
#define szExchangeDSDBKey		"DSA Database file"
#define szExchangeDSLogKey		"Database log files path"
#define szExchangeDSSysKey		"DSA Working Directory"
#define szExchangeDSMaxBufKey	"EDB max buffers"

#define szStatusMsg		" Status  ( % complete )"

#define	cNewLine		'\n'

#define szSwitches		"-/"

#define szRegistryMsg	"Using Registry environment..."

#define szErr1			"Error: Source database specification '%s' is invalid."
#define szErr2			"Error: Temporary database specification '%s' is invalid."
#define szErr3			"Error: Source database '%s' cannot be the same as the temporary database."
#define szErr4			"Error: Could not backup to '%s'."
#define szErr5			"Error: Could not instate database '%s'."
#define szErr6			"Error: Failed loading Registry Environment."

#define szUsageErr1		"Usage Error: Missing %s specification."
#define szUsageErr2		"Usage Error: Duplicate %s specification."
#define szUsageErr3		"Usage Error: Only one type of data dump allowed."
#define szUsageErr4		"Usage Error: Invalid option '%s'."
#define szUsageErr5		"Usage Error: Invalid argument '%s'. Options must be preceded by '-' or '/'."
#define szUsageErr6		"Usage Error: Invalid buffer cache size."
#define szUsageErr7		"Usage Error: Invalid batch I/O size."
#define szUsageErr8		"Usage Error: Invalid database extension size."
#define szUsageErr9		"Usage Error: No mode specified."
#define szUsageErr10	"Usage Error: Mode selection must be preceded by '-' or '/'."
#define szUsageErr11	"Usage Error: Old .DLL required in order to upgrade."
#define szUsageErr12	"Usage Error: Invalid mode."

#define szHelpDesc1		"DESCRIPTION:  Maintenance utilities for Microsoft(R) Exchange Server databases."
#define szHelpSyntax	"MODES OF OPERATION:"
#define szHelpModes1	"   Defragmentation:  %s /d <database name> [options]"
#define szHelpModes2	"          Recovery:  %s /r [options]"
#define szHelpModes3	"            Backup:  %s /b <backup path> [options]"
#define szHelpModes4	"       Consistency:  %s /c <database name> [options]"
#define szHelpModes5	"           Upgrade:  %s /u <database name> /d<previous .DLL> [options]"
#define szHelpModes6	"         File Dump:  %s /m[mode-modifier] <filename>"

#define szHelpPrompt1	"<<<<<  Press a key for more help  >>>>>"
#ifdef DEBUG
#define szHelpPrompt2   "D=Defragmentation, R=Recovery, B=Backup, C=Consistency, U=Upgrade, M=File Dump\n=> "
#else
#define szHelpPrompt2   "D=Defragmentation, R=Recovery, C=Consistency, U=Upgrade, M=File Dump => "
#endif

#define szOperSuccess	"Operation completed successfully in %d.%d seconds."
#define szOperFail		"Operation terminated with error %d."


#define cbMsgBufMax	256

static __inline VOID EDBUTLFormatMessage( ULONG ulMsgId, CHAR *szMsgBuf, CHAR *szMsgArg )
	{
	DWORD	err;
	CHAR	*rgszMsgArgs[1] = { szMsgArg };		// Currently only support one argument.
	
	if ( szMsgArg )
		{
		err = FormatMessage(
			FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ARGUMENT_ARRAY,
			NULL,
			ulMsgId,
			LANG_USER_DEFAULT,
			szMsgBuf,
			cbMsgBufMax,
			rgszMsgArgs );
		}
	else
		{
		err = FormatMessage(
			FORMAT_MESSAGE_FROM_HMODULE,
			NULL,
			ulMsgId,
			LANG_USER_DEFAULT,
			szMsgBuf,
			cbMsgBufMax,
			NULL );
		}
	if ( err == 0 )
		{
		// Format message failed.  No choice but to dump the error message
		// in English, then bail out.
		printf( "Unexpected Win32 error: %dL\n\n", GetLastError() );
		exit(1);
		}
	}
	

// Allocates a local buffer for the message, retrieves the message, and prints it out.
static VOID EDBUTLPrintMessage( ULONG ulMsgId, CHAR *szMsgArg )
	{
	CHAR	szMsgBuf[cbMsgBufMax];

	EDBUTLFormatMessage( ulMsgId, szMsgBuf, szMsgArg );
	printf( szMsgBuf );
	}
		

static VOID EDBUTLPrintLogo( void )
	{
	CHAR	szVersion[8];

	sprintf( szVersion, "%d", rmj );
	
	EDBUTLPrintMessage( PRODUCTNAME_ID, NULL );
	EDBUTLPrintMessage( VERSION_ID, szVersion );
	EDBUTLPrintMessage( COPYRIGHT_ID, NULL );
	}

static __inline VOID EDBUTLHelpDefrag( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "DEFRAGMENTATION/COMPACTION:%c", cNewLine );
	printf( "    DESCRIPTION:  Performs off-line compaction of a database.%c", cNewLine );
	printf( "         SYNTAX:  %s /d <database name> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to compact, or one of%c", cNewLine );
	printf( "                                    /ispriv, /ispub, or /ds (see NOTES below)%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /l<path> - location of log files (default: current directory)%c", cNewLine );
	printf( "                  /s<path> - location of system files (eg. checkpoint file)%c", cNewLine );
	printf( "                             (default: current directory)%c", cNewLine );
	printf( "                  /r       - repair database while defragmenting%c", cNewLine );
	printf( "                  /b<db>   - make backup copy under the specified name%c", cNewLine );
	printf( "                  /t<db>   - set temp. database name (default: TEMPDFRG.EDB)%c", cNewLine );
	printf( "                  /p       - preserve temporary database (ie. don't instate)%c", cNewLine );
	printf( "                  /n       - dump defragmentation information to DFRGINFO.TXT%c", cNewLine );
#ifdef DEBUG	// Undocumented switches
	printf( "                  /c<#>    - buffer cache size, in 4k pages (default: 512)%c", cNewLine );
	printf( "                  /w<#>    - buffer batch I/O size, in 4k pages (default: 16)%c", cNewLine );
	printf( "                  /x<#>    - database extension size, in 4k pages (default: 256)%c", cNewLine );
#endif	
	printf( "                  /o       - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) The switches /ispriv, /ispub, and /ds use the Registry%c", cNewLine );
	printf( "                     to automatically set the database name, log file path,%c", cNewLine );
	printf( "                     and system file path for the appropriate Exchange store.%c", cNewLine );
	printf( "                  2) Before defragmentation begins, soft recovery is always%c", cNewLine );
	printf( "                     performed to ensure the database is in a consistent state.%c", cNewLine );
	printf( "                  3) If instating is disabled (ie. /p), the original database%c", cNewLine );
	printf( "                     is preserved uncompacted, and the temporary database will%c", cNewLine );
	printf( "                     contain the defragmented version of the database.%c", cNewLine );
	}


#ifdef DEBUG
static __inline VOID EDBUTLHelpBackup( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "BACKUP:%c", cNewLine );
	printf( "    DESCRIPTION:  Performs backup, bringing all databases to a%c", cNewLine );
	printf( "                  consistent state.%c", cNewLine );
	printf( "         SYNTAX:  %s /b <backup path> [options]%c", szAppName, cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /l<path>   - location of log files%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
	printf( "                  /s<path>   - location of system files (eg. checkpoint file)%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
	printf( "                  /c<path>   - incremental backup%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
	}
#endif


static __inline VOID EDBUTLHelpRecovery( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "RECOVERY:%c", cNewLine );
	printf( "    DESCRIPTION:  Performs recovery, bringing all databases to a%c", cNewLine );
	printf( "                  consistent state.%c", cNewLine );
	printf( "         SYNTAX:  %s /r [options]%c", szAppName, cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /is or /ds - see NOTES below%c", cNewLine );
	printf( "                  /l<path>   - location of log files%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
	printf( "                  /s<path>   - location of system files (eg. checkpoint file)%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
#ifdef DEBUG
	printf( "                  /b<path>   - restore from backup (ie. hard recovery) from the%c", cNewLine );
	printf( "                               specified location%c", cNewLine );
	printf( "                  /r<path>   - restore to specified location (only valid when%c", cNewLine );
	printf( "                               the /b switch is also specified)%c", cNewLine );
#endif
	printf( "                  /o         - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) The special switches /is and /ds use the Registry to%c", cNewLine );
	printf( "                     automatically set the log file path and system file path%c", cNewLine );
	printf( "                     for recovery of the appropriate Exchange store(s).%c", cNewLine );
#ifdef DEBUG
	printf( "                  2) Soft recovery is always performed unless the /b switch is%c", cNewLine );
	printf( "                     specified, in which case hard recovery is performed.%c", cNewLine );
	printf( "                  3) The /d switch (ie. restore to new location) is only valid%c", cNewLine );
	printf( "                     during hard recovery (ie. /b must also be specified).%c", cNewLine );
#endif
	}


static __inline VOID EDBUTLHelpConsistency( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "CONSISTENCY:%c", cNewLine );
	printf( "    DESCRIPTION:  Verifies consistency of a database.%c", cNewLine );
	printf( "         SYNTAX:  %s /c <database name> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to verify, or one of%c", cNewLine );
	printf( "                                    /ispriv, /ispub, or /ds (see NOTES below)%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /a       - check all nodes, including deleted ones%c", cNewLine );
	printf( "                  /k       - generate key usage statistics%c", cNewLine );
	printf( "                  /p       - generate page usage information%c", cNewLine );
	printf( "                  /t<name> - performs a check on the specified table only%c", cNewLine );
	printf( "                             (default: checks all tables in the database)%c", cNewLine );
#ifdef DEBUG
	printf( "                  /b       - verify consistency of database B-Tree structure%c", cNewLine );
	printf( "                  /m[v|m|s]- dump data (verbose/meta-data/space)%c", cNewLine );
#endif
	printf( "                  /o       - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) The consistency-checker performs no recovery and always%c", cNewLine );
	printf( "                     assumes that the database is in a consistent state,%c", cNewLine );
	printf( "                     returning an error if this is not the case.%c", cNewLine );
	printf( "                  2) The special switches /ispriv, /ispub, and /ds use the%c", cNewLine );
	printf( "                     Registry to automatically set the database name for the%c", cNewLine );
	printf( "                     appropriate Exchange store.%c", cNewLine );
	}

static __inline VOID EDBUTLHelpUpgrade( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "UPGRADE:%c", cNewLine );
	printf( "    DESCRIPTION:  Upgrades a database (created using a previous release of%c", cNewLine );
	printf( "                  Microsoft(R) Exchange Server) to the current version.%c", cNewLine );
	printf( "         SYNTAX:  %s /u <database name> /d<previous .DLL> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name>   - filename of the database to upgrade.%c", cNewLine );
	printf( "                  /d<previous .DLL> - pathed filename of the .DLL that came%c", cNewLine );
	printf( "                                      with the release of Microsoft(R) Exchange%c", cNewLine );
	printf( "                                      Server from which you're upgrading.%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /b<db> - make backup copy under the specified name%c", cNewLine );
	printf( "                  /t<db> - set temporary database name (default: TEMPUPGD.EDB)%c", cNewLine );
	printf( "                  /p     - preserve temporary database (ie. don't instate)%c", cNewLine );
	printf( "                  /n     - dump upgrade information to UPGDINFO.TXT%c", cNewLine );
#ifdef DEBUG	// Undocumented switches.
	printf( "                  /x<#>  - database extension size, in 4k pages (default: 256)%c", cNewLine );
#endif	
	printf( "                  /o     - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) This utility should only be used to upgrade a database%c", cNewLine );
	printf( "                     after an internal database format change has taken place.%c", cNewLine );
	printf( "                     If necessary, this will usually only coincide with the%c", cNewLine );
	printf( "                     release of a major, new revision of Microsoft(R)%c", cNewLine );
	printf( "                     Exchange Server.%c", cNewLine );
	printf( "                  2) Before upgrading, the database should be in a consistent%c", cNewLine );
	printf( "                     state. An error will be returned if otherwise.%c", cNewLine );
	printf( "                  3) If instating is disabled (ie. /p), the original database%c", cNewLine );
	printf( "                     is preserved unchanged, and the temporary database will%c", cNewLine );
	printf( "                     contain the upgraded version of the database.%c", cNewLine );
	}


static __inline VOID EDBUTLHelpDump( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "FILE DUMP:%c", cNewLine );
	printf( "    DESCRIPTION:  Generates formatted output of various database file types.%c", cNewLine );
	printf( "         SYNTAX:  %s /m[mode-modifier] <filename>%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  [mode-modifier] - an optional letter designating the type of%c", cNewLine );
	printf( "                                    file dump to perform. Valid values are:%c", cNewLine );
	printf( "                                    h - dump database header (default)%c", cNewLine );
	printf( "                                    k - dump checkpoint file%c", cNewLine );
#ifdef DEBUG
	printf( "                                    f - force database state to be consistent%c", cNewLine );
	printf( "                                    l - dump log file%c", cNewLine );
#endif
	printf( "                  <filename>      - name of file to dump. The type of the%c", cNewLine );
	printf( "                                    specified file should match the dump type%c", cNewLine );
	printf( "                                    being requested (eg. if using /mh, then%c", cNewLine );
	printf( "                                    <filename> must be the name of a database).%c", cNewLine );
	}


static __inline VOID EDBUTLHelp( char *szAppName )
	{
	char c;

	EDBUTLPrintLogo();
	printf( szHelpDesc1 );
	printf( "%c%c", cNewLine, cNewLine );
	printf( szHelpSyntax );
	printf( "%c", cNewLine );
	printf( szHelpModes1, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes2, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes3, szAppName );
	printf( "%c", cNewLine );
#ifdef DEBUG	// mode 4 is backup mode
	printf( szHelpModes4, szAppName );
	printf( "%c", cNewLine );
#endif
	printf( szHelpModes5, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes6, szAppName );
	printf( "%c", cNewLine );
	
	printf( "%c", cNewLine );
	printf( "%s%c", szHelpPrompt1, cNewLine );
	printf( "%s", szHelpPrompt2 );
	c = _getch();

	printf( "%c%c", cNewLine, cNewLine );

	switch ( c)
		{
		case 'd':
		case 'D':
			EDBUTLHelpDefrag( szAppName );
			break;
		case 'r':
		case 'R':
			EDBUTLHelpRecovery( szAppName );
			break;
#ifdef DEBUG
		case 'b':
		case 'B':
			EDBUTLHelpBackup( szAppName );
			break;
#endif
		case 'c':
		case 'C':
			EDBUTLHelpConsistency( szAppName );
			break;
		case 'u':
		case 'U':
			EDBUTLHelpUpgrade( szAppName );
			break;
		case 'm':
		case 'M':
			EDBUTLHelpDump( szAppName );
			break;
		}
	}


static VOID EDBUTLGetTime( ULONG timerStart, INT *piSec, INT *piMSec )
	{
	ULONG	timerEnd;

	timerEnd = GetTickCount();
	
	*piSec = ( timerEnd - timerStart ) / 1000;
	*piMSec = ( timerEnd - timerStart ) % 1000;
	}

static JET_ERR __stdcall PrintStatus( JET_SESID sesid, JET_SNP snp, JET_SNT snt, void *pv )
	{
	static int	iLastPercentage;
	int 		iPercentage;
	int			dPercentage;
	char		*szOperation = NULL;

	switch ( snp )
		{
		case JET_snpCompact:
		case JET_snpUpgrade:
		case JET_snpRestore:
		case JET_snpRepair:
			switch( snt )
				{
				case JET_sntProgress:
					assert( pv );
					iPercentage = ( ( (JET_SNPROG *)pv )->cunitDone * 100 ) / ( (JET_SNPROG *)pv )->cunitTotal;
					dPercentage = iPercentage - iLastPercentage;
					assert( dPercentage >= 0 );
					while ( dPercentage >= 2 )
						{
						printf( "." );
						iLastPercentage += 2;
						dPercentage -= 2;
						}
					break;

				case JET_sntBegin:
					{
					const char	*szOperation;
					INT			i, cbPadding;

					switch ( snp )
						{
						default:
							szOperation = szDefrag;
							break;
						case JET_snpUpgrade:
							szOperation = szUpgrade;
							break;
						case JET_snpRestore:
							szOperation = szRestore;
							break;
						case JET_snpRepair:
							szOperation = szRepair;
							break;
						}

					printf( "%c", cNewLine );
					printf( "          " );

					// Center the status message above the status bar.
					// Formula is: ( length of status bar - length of message ) / 2
					cbPadding = ( 51 - ( strlen( szOperation ) + strlen( szStatusMsg ) ) ) / 2;
					assert( cbPadding >= 0 );

					for ( i = 0; i < cbPadding; i++ )
						{
						printf( " " );
						}
					
					printf( "%s%s%c%c", szOperation, szStatusMsg, cNewLine, cNewLine );
					printf( "          0    10   20   30   40   50   60   70   80   90  100\n" );
					printf( "          |----|----|----|----|----|----|----|----|----|----|\n" );
					printf( "          " );

					iLastPercentage = 0;
					break;
					}

				case JET_sntComplete:
					dPercentage = 100 - iLastPercentage;
					assert( dPercentage >= 0 );
					while ( dPercentage >= 2 )
						{
						printf( "." );
						iLastPercentage += 2;
						dPercentage -= 2;
						}

					printf( ".%c%c", cNewLine, cNewLine );
					break;
				}
			break;				
		}

	return JET_errSuccess;
	}


static JET_ERR ErrEDBUTLCheckDBNames( UTILOPTS *popts, const char *szDefaultTempDB )
	{
	CHAR	szFullpathSourceDB[ _MAX_PATH + 1];
	CHAR	szFullpathTempDB[ _MAX_PATH + 1 ];

	if ( popts->szSourceDB == NULL )
		{
		printf( szUsageErr1, "source database" );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidParameter;
		}
	
	if ( popts->szTempDB == NULL )
		popts->szTempDB = (char *)szDefaultDefragDB;

	if ( _fullpath( szFullpathSourceDB, popts->szSourceDB, _MAX_PATH ) == NULL )
		{
		printf( szErr1, popts->szSourceDB );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidPath;
		}

	if ( _fullpath( szFullpathTempDB, popts->szTempDB, _MAX_PATH ) == NULL )
		{
		printf( szErr2, popts->szTempDB );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidPath;
		}

	if ( _stricmp( szFullpathSourceDB, szFullpathTempDB ) == 0 )
		{
		printf( szErr3, popts->szSourceDB );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidDatabase;
		}	
		
	return JET_errSuccess;
	}


#ifdef DEBUG
static JET_ERR ErrEDBUTLCheckBackupPath( UTILOPTS *popts )
	{
	CHAR	szFullpathBackup[ _MAX_PATH + 1];

	if ( popts->szBackup == NULL )
		{
		printf( szUsageErr1, "backup path" );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidParameter;
		}
	
	if ( _fullpath( szFullpathBackup, popts->szBackup, _MAX_PATH ) == NULL )
		{
		printf( szErr1, popts->szBackup );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidPath;
		}

	return JET_errSuccess;
	}
#endif


static BOOL FEDBUTLParsePath( char *arg, char **pszParam, char *szParamDesc )
	{
	BOOL	fResult = fTrue;
	
	if ( *arg == '\0' )
		{
		printf( szUsageErr1, szParamDesc );			// Missing spec.
		printf( "%c%c", cNewLine, cNewLine );
		fResult = fFalse;
		}
	else if ( *pszParam == NULL )
		{
		*pszParam = arg;
		}
	else
		{
		printf( szUsageErr2, szParamDesc );			// Duplicate spec.
		printf( "%c%c", cNewLine, cNewLine );
		fResult = fFalse;
		}
		
	return fResult;
	}


static BOOL FEDBUTLSetExchangeDB( UTILOPTS *popts, EXCHANGEDB db )
	{
	BOOL fResult;

	if ( popts->db == dbNormal )
		{
		popts->db = db;
		fResult = fTrue;
		}
	else
		{
		printf( szUsageErr2, "database" );
		printf( "%c%c", cNewLine, cNewLine );
		fResult = fFalse;
		}
			
	return fResult;
	}	

static BOOL FEDBUTLCheckExchangeDB( char *arg, UTILOPTS *popts )
	{
	BOOL fResult;

	if ( _stricmp( arg, "ispriv" ) == 0  || _stricmp( arg, "is" ) == 0 )
		{
		// If just "is" specified, default to ISPriv.
		fResult = FEDBUTLSetExchangeDB( popts, dbISPriv );
		}
	else if ( _stricmp( arg, "ispub" ) == 0 )
		{
		fResult = FEDBUTLSetExchangeDB( popts, dbISPub );
		}
	else if ( _stricmp( arg, "ds" ) == 0 )
		{
		fResult = FEDBUTLSetExchangeDB( popts, dbDS );
		}
	else
		{
		printf( szUsageErr4, arg-1 );
		printf( "%c%c", cNewLine, cNewLine );
		fResult = fFalse;
		}

	return fResult;
	}

static __inline JET_ERR ErrEDBUTLRegOpenExchangeKey( char *szKey, PHKEY phkey )
	{
	if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, KEY_ALL_ACCESS, phkey ) == ERROR_SUCCESS )
		return JET_errSuccess;
	else
		return JET_errAccessDenied;
	}

static JET_ERR ErrEDBUTLRegQueryExchangeValue( HKEY hkey, char *szValue, char **psz )
	{
	DWORD	errWin;
	DWORD	cbData;
	DWORD	type;
	LPBYTE	lpbData;

	if ( ( errWin = RegQueryValueEx( hkey, szValue, 0, &type, NULL, &cbData ) ) != ERROR_SUCCESS )
		{
		return JET_errAccessDenied;
		}

	if ( ( lpbData = GlobalAlloc( 0, cbData ) ) == NULL )
		{
		return JET_errOutOfMemory;
		}

	if ( ( errWin = RegQueryValueEx( hkey, szValue, 0, &type, lpbData, &cbData ) ) != ERROR_SUCCESS )
		{
		GlobalFree( lpbData );
		return JET_errAccessDenied;
		}

	if ( type == REG_EXPAND_SZ )
		{
		DWORD	cbDataExpanded;
		LPBYTE	lpbDataExpanded;

		cbDataExpanded = ExpandEnvironmentStrings( lpbData, NULL, 0 );
		if ( ( lpbDataExpanded = GlobalAlloc( 0, cbDataExpanded ) ) == NULL )
			{
			GlobalFree( lpbData );
			return JET_errOutOfMemory;
			}

		if ( !ExpandEnvironmentStrings( lpbData, lpbDataExpanded, cbDataExpanded ) )
			{
			GlobalFree( lpbDataExpanded );
			GlobalFree( lpbData );
			return JET_errAccessDenied;
			}

		GlobalFree( lpbData );

		if ( ((char *)lpbDataExpanded)[0] != '\0' )
			{
			*psz = lpbDataExpanded;
			}
		else
			{
			GlobalFree( lpbDataExpanded );
			}
		}

	else if ( ( type == REG_SZ  &&  ((char *)lpbData)[0] != '\0' ) ||
		( type == REG_DWORD  &&  cbData > 0 ) )
		{
		*psz = lpbData;
		}

	else
		{
		GlobalFree( lpbData );
		}

	return JET_errSuccess;
	}

static JET_ERR ErrEDBUTLLoadExchangeDB( UTILOPTS *popts )
	{
	JET_ERR	err = JET_errSuccess;
	HKEY	hkeyExchStoreRoot = (HKEY)-1;
	DWORD	dwBuf = 0;

	if ( popts->szSourceDB || popts->szLogfilePath || popts->szSystemPath ||
		popts->cpageBuffers )
		{
		printf( "Warning: Overriding command-line parameters with registry settings%c", cNewLine );
		printf( "         for the specified Exchange store.%c%c", cNewLine, cNewLine );
		popts->szSourceDB = NULL;
		popts->szLogfilePath = NULL;
		popts->szSystemPath = NULL;
		popts->cpageBuffers = 0;
		}

	switch( popts->db )
		{
		case dbISPriv:
		case dbISPub:
			Call( ErrEDBUTLRegOpenExchangeKey(
				popts->db == dbISPriv ? szExchangeISPrivKey : szExchangeISPubKey,
				&hkeyExchStoreRoot ) );
			Call( ErrEDBUTLRegQueryExchangeValue( hkeyExchStoreRoot, szExchangeISDBKey, &popts->szSourceDB ) );
			RegCloseKey( hkeyExchStoreRoot );
			Call( ErrEDBUTLRegOpenExchangeKey( szExchangeISKey, &hkeyExchStoreRoot ) );
			Call( ErrEDBUTLRegQueryExchangeValue( hkeyExchStoreRoot, szExchangeISLogKey, &popts->szLogfilePath ) );
			Call( ErrEDBUTLRegQueryExchangeValue( hkeyExchStoreRoot, szExchangeISSysKey, &popts->szSystemPath ) );
			Call( ErrEDBUTLRegQueryExchangeValue( hkeyExchStoreRoot, szExchangeISMaxBufKey, (char **)&dwBuf ) );
			if ( dwBuf )
				popts->cpageBuffers = max( *(long *)dwBuf, 0 );
			else
				err = JET_errAccessDenied;				
			break;

		case dbDS:
			Call( ErrEDBUTLRegOpenExchangeKey( szExchangeDSKey, &hkeyExchStoreRoot ) );
			Call( ErrEDBUTLRegQueryExchangeValue( hkeyExchStoreRoot, szExchangeDSDBKey, &popts->szSourceDB ) );
			Call( ErrEDBUTLRegQueryExchangeValue( hkeyExchStoreRoot, szExchangeDSLogKey, &popts->szLogfilePath ) );
			Call( ErrEDBUTLRegQueryExchangeValue( hkeyExchStoreRoot, szExchangeDSSysKey, &popts->szSystemPath ) );
			Call( ErrEDBUTLRegQueryExchangeValue( hkeyExchStoreRoot, szExchangeDSMaxBufKey, (char **)&dwBuf ) );
			if ( dwBuf )
				popts->cpageBuffers = max( *(long *)dwBuf, 0 );
			else
				err = JET_errAccessDenied;
			break;

		default:
			assert( popts->db == dbNormal );
			err = JET_errInvalidParameter;
		}

	
HandleError:
	if ( hkeyExchStoreRoot != (HKEY)(-1) )
		{
		RegCloseKey( hkeyExchStoreRoot );
		}

	switch( err )
		{
		case JET_errOutOfMemory:
			printf( "Ran out of memory accessing registry keys/values for specified Exchange Store." );
			printf( "%c%c", cNewLine, cNewLine );
			break;

		case JET_errAccessDenied:
			printf( "Error encountered accessing registry keys/values for specified Exchange Store." );
			printf( "%c%c", cNewLine, cNewLine );
			break;

		default:
			assert( err == JET_errSuccess );
		}

	return err;
	}


static BOOL FEDBUTLParseDefragment( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'l':
		case 'L':
			fResult = FEDBUTLParsePath( arg+2, &popts->szLogfilePath, "logfile path" );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSystemPath, "system path" );
			break;

		case 'b':
		case 'B':
			fResult = FEDBUTLParsePath( arg+2, &popts->szBackup, "backup database" );
			break;

		case 'n':		
		case 'N':
			UTILOPTSSetDefragInfo( popts->fUTILOPTSFlags );
			break;
			
		case 'p':
		case 'P':
			UTILOPTSSetPreserveTempDB( popts->fUTILOPTSFlags );
			break;
			
		case 'r':
		case 'R':
			UTILOPTSSetDefragRepair( popts->fUTILOPTSFlags );
			break;
			
		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempDB, "temporary database" );
			break;

		case 'c':
		case 'C':
			popts->cpageBuffers = atol( arg + 2 );
			if ( popts->cpageBuffers <= 0 )
				{
				printf( szUsageErr6 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;

		case 'w':
		case 'W':				
			popts->cpageBatchIO = atol( arg + 2 );
			if ( popts->cpageBatchIO <= 0 )
				{
				printf( szUsageErr7 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;

		case 'x':
		case 'X':
			popts->cpageDbExtension = atol( arg + 2 );
			if ( popts->cpageDbExtension <= 0 )
				{
				printf( szUsageErr8 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;

		default:
			fResult = FEDBUTLCheckExchangeDB( arg+1, popts );
		}

	return fResult;
	}


static BOOL FEDBUTLParseRecovery( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'l':
		case 'L':
			fResult = FEDBUTLParsePath( arg+2, &popts->szLogfilePath, "logfile path" );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSystemPath, "system path" );
			break;

#ifdef DEBUG
		case 'b':
		case 'B':
			fResult = FEDBUTLParsePath( arg+2, &popts->szBackup, "backup directory" );
			break;
			
		case 'r':
		case 'R':
			fResult = FEDBUTLParsePath( arg+2, &popts->szRestore, "destination directory" );
			break;
#endif
			
		default:
			fResult = FEDBUTLCheckExchangeDB( arg+1, popts );
		}

	return fResult;
	}	

				
#ifdef DEBUG
static BOOL FEDBUTLParseBackup( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fFalse;	// backup directory must be set at least.

	switch( arg[1] )
		{
		case 'l':
		case 'L':
			fResult = FEDBUTLParsePath( arg+2, &popts->szLogfilePath, "logfile path" );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSystemPath, "system path" );
			break;

		case 'c':
		case 'C':
			UTILOPTSSetIncrBackup( popts->fUTILOPTSFlags );
			break;
		default:
			fResult = FEDBUTLCheckExchangeDB( arg+1, popts );
		}

	return fResult;
	}	
#endif
			
				
static BOOL FEDBUTLParseUpgrade( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'd':
		case 'D':
			fResult = FEDBUTLParsePath( arg+2, &((JET_CONVERT *)(popts->pv))->szOldDll, "old .DLL" );
			break;

		case 'y':
		case 'Y':
			// UNDOCUMENTED SWITCH:  Only required if upgrading from 400-series Jet.
			fResult = FEDBUTLParsePath( arg+2, &((JET_CONVERT *)(popts->pv))->szOldSysDb, "old system database" );
			break;

		case 'b':
		case 'B':
			fResult = FEDBUTLParsePath( arg+2, &popts->szBackup, "backup database" );
			break;
			
		case 'n':
		case 'N':
			UTILOPTSSetDefragInfo( popts->fUTILOPTSFlags );
			break;
			
		case 'p':
		case 'P':
			UTILOPTSSetPreserveTempDB( popts->fUTILOPTSFlags );
			break;
			
		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempDB, "temporary database" );
			break;
			
		case 'x':
		case 'X':
			popts->cpageDbExtension = atol( arg + 2 );
			if ( popts->cpageDbExtension <= 0 )
				{
				printf( szUsageErr8 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
		}

	return fResult;
	}	

		
static BOOL FEDBUTLParseConsistency( char *arg, UTILOPTS *popts )
	{
	BOOL		fResult = fTrue;
	JET_DBUTIL	*pdbutil;

	pdbutil = (JET_DBUTIL *)(popts->pv);
	assert( pdbutil != NULL );

	switch( arg[1] )
		{
		case 'a':
		case 'A':
			pdbutil->grbitOptions |= JET_bitDBUtilOptionAllNodes;
			break;

		case 'k':
		case 'K':
			pdbutil->grbitOptions |= JET_bitDBUtilOptionKeyStats;
			break;

		case 'p':
		case 'P':
			pdbutil->grbitOptions |= JET_bitDBUtilOptionPageDump;
			break;

		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &pdbutil->szTable, "table name" );
			break;

#ifdef DEBUG
		case 'b':
		case 'B':
			pdbutil->grbitOptions |= JET_bitDBUtilOptionCheckBTree;
			break;

		case 'm':
		case 'M':
			if ( pdbutil->op != opDBUTILConsistency )
				{
				printf( szUsageErr3 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				break;
				}

			// Override consistency check with a dump.
			switch( arg[2] )
				{
				case 'v':		// verbose dump of nodes
				case 'V':
					pdbutil->grbitOptions |= JET_bitDBUtilOptionDumpVerbose;
					// Fall through to set DumpData as well.
					
				case 0:
					// No dump options.  Plain data dump.
					pdbutil->op = opDBUTILDumpData;
					break;

				case 'm':
				case 'M':
					pdbutil->op = opDBUTILDumpMetaData;
					break;

				case 's':
				case 'S':
					pdbutil->op = opDBUTILDumpSpace;
					break;

				default:
					printf( szUsageErr4, arg );
					printf( "%c%c", cNewLine, cNewLine );
					fResult = fFalse;
				}
			break;
#endif			

		default:
			fResult = FEDBUTLCheckExchangeDB( arg+1, popts );
		}

	return fResult;
	}



static BOOL FEDBUTLParseOptions(
	int			argc,
	char		*argv[],
	UTILOPTS	*popts,
	BOOL		(*pFEDBUTLParseMode)( char *arg, UTILOPTS *popts ) )
	{
	BOOL		fResult = fTrue;
	char		*arg;
	INT			iarg;

	// First option specifies the mode, so start with the second option.
	for ( iarg = 2; fResult  &&  iarg < argc; iarg++ )
		{
		arg = argv[iarg];

		if ( strchr( szSwitches, arg[0] ) == NULL )
			{
			// SPECIAL CASE: Recovery mode does not take a DB specification.
			if ( popts->szSourceDB == NULL  &&  popts->mode != modeRecovery )
				{
				if ( popts->mode == modeBackup )
					popts->szBackup = arg;
				else
					popts->szSourceDB = arg;
				}
			else
				{				
				printf( szUsageErr5, arg );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			}

		else
			{
			// Parse options common to all modes.  Pass off unique options to the
			// custom parsers.
			switch ( arg[1] )
				{
				case 'o':
				case 'O':
					UTILOPTSSetSuppressLogo( popts->fUTILOPTSFlags );
					break;

#ifdef DEBUG
				case 'e':
				case 'E':
					popts->fUseRegistry = fTrue;
					break;
#endif
		
				default:
					if ( pFEDBUTLParseMode )
						{
						fResult = (*pFEDBUTLParseMode)( arg, popts );
						}
					else
						{
						printf( szUsageErr4, arg );
						printf( "%c%c", cNewLine, cNewLine );
						fResult = fFalse;
						}
					break;
				}
			}
		}

	return fResult;		
	}


// Backs up source database if required, then copies temporary database over
// source database if required.  Should be called after Jet has terminated.	
static JET_ERR ErrEDBUTLBackupAndInstateDB(
	JET_SESID	sesid,
	UTILOPTS	*popts )
	{
	JET_ERR		err = JET_errSuccess;;

	assert( popts->szSourceDB != NULL );
	assert( popts->szTempDB != NULL );

	// Make backup before instating, if requested.
	if ( popts->szBackup != NULL )
		{
		if ( !MoveFileEx( popts->szSourceDB, popts->szBackup, 0 ) )
			{
			DWORD	dw = GetLastError();

			// If source file is on different device then copy file
			// to backup and delete original.
			if ( dw == ERROR_NOT_SAME_DEVICE )
				{
				if ( !CopyFile( popts->szSourceDB, popts->szBackup, 0 ) )
					{
					printf( szErr4, popts->szBackup );
					printf( "%c%c", cNewLine, cNewLine );
					Call( JET_errFileAccessDenied );
					}
				}
			else
				{
				printf( szErr4, popts->szBackup );
				printf( "%c%c", cNewLine, cNewLine );
				Call( JET_errFileAccessDenied );
				}
			}
		}
	
	if ( !FUTILOPTSPreserveTempDB( popts->fUTILOPTSFlags ) )
		{
		// Delete source database and overwrite with temporary database.
		// This is how we simulate instate defragmentation..
		if ( !MoveFileEx( popts->szTempDB, popts->szSourceDB, MOVEFILE_REPLACE_EXISTING ) )
			{
			DWORD	dw = GetLastError();

			// If defragmented file is on different device then copy
			// over source file and delete..
			if ( dw == ERROR_NOT_SAME_DEVICE )
				{
				if ( !CopyFile( popts->szTempDB, popts->szSourceDB, 0 ) )
					{
					printf( szErr5, popts->szSourceDB );
					printf( "%c%c", cNewLine, cNewLine );
					Call( JET_errFileAccessDenied );
					}
				}
			else
				{
				printf( szErr5, popts->szSourceDB );
				printf( "%c%c", cNewLine, cNewLine );
				Call( JET_errFileAccessDenied );
				}
			}

		// Delete temporary database only if everything was successful.			
		DeleteFile( popts->szTempDB );
		}

HandleError:
	return err;
	}


// Load registry environment, if enabled.  Then load command-line overrides.
static JET_ERR ErrEDBUTLUserSystemParameters( JET_INSTANCE *pinstance, UTILOPTS *popts )
	{
	JET_ERR	err;

	// Facilitate debugging.
	Call( JetSetSystemParameter( pinstance, 0, JET_paramAssertAction, JET_AssertMsgBox, NULL ) );

	if ( popts->fUseRegistry )
		{
		printf( "%s%c%c", szRegistryMsg, cNewLine, cNewLine );
		if ( LoadRegistryEnvironment( _TEXT( "EDBUtil" ) ) )
			{
			printf( szErr6 );
			err = JET_errInvalidOperation;		// UNDONE: Choose a better error code.
			goto HandleError;
			}
		}

	// Command-line parameters override all default and registry values.
	if ( popts->szLogfilePath != NULL )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramLogFilePath, 0, popts->szLogfilePath ) );
		}
	if ( popts->szSystemPath != NULL )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramSystemPath, 0, popts->szSystemPath ) );
		}
	if ( popts->cpageBuffers != 0 )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramMaxBuffers, popts->cpageBuffers, NULL ) );
		}
	if ( popts->cpageBatchIO != 0 )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramBufBatchIOMax, popts->cpageBatchIO * 4, NULL ) );
		}
	if ( popts->cpageDbExtension != 0 )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramDbExtensionSize, popts->cpageDbExtension, NULL ) );
		}

HandleError:
	return err;
	}


// Teminate Jet, either normally or abnormally.
static JET_ERR ErrEDBUTLCleanup( JET_INSTANCE instance, JET_SESID sesid, JET_ERR err )
	{
	if ( sesid != 0 )
		{
		JET_ERR	errT = JetEndSession( sesid, 0 );

		if ( err >= 0 )
			err = errT;
		}

	if ( err < 0 ) 
		{
		// On error, terminate abruptly and throw out return code from JetTerm2().
		JetTerm2( instance, JET_bitTermAbrupt );
		}
	else 
		{
		err = JetTerm2( instance, JET_bitTermComplete );
		}

	return err;
	}
	

int _cdecl main( int argc, char *argv[] )
	{
	JET_INSTANCE	instance = 0;
	JET_SESID		sesid = 0;
	JET_ERR			err;
	BOOL			fResult = fTrue;
	UTILOPTS		opts;
	JET_CONVERT		convert;
	JET_DBUTIL		dbutil;
	ULONG			timer;
	INT				iSec, iMSec;

	memset( &opts, 0, sizeof(UTILOPTS) );
	opts.db = dbNormal;

	printf( "%c", cNewLine );

	if ( argc < 2 )
		{
		printf( szUsageErr9 );
		printf( "%c%c", cNewLine, cNewLine );
		goto Usage;
		}
		
	if ( strchr( szSwitches, argv[1][0] ) == NULL )
		{
		printf( szUsageErr10 );
		printf( "%c%c", cNewLine, cNewLine );
		goto Usage;
		}

	switch( argv[1][1] )
		{
		case 'c':		// Consistency check
		case 'C':
			opts.mode = modeConsistency;
			memset( &dbutil, 0, sizeof(JET_DBUTIL) );
			opts.pv = &dbutil;
			dbutil.cbStruct = sizeof(JET_DBUTIL);
			dbutil.op = opDBUTILConsistency;			
			fResult = FEDBUTLParseOptions( argc, argv, &opts, FEDBUTLParseConsistency );
			break;

		case 'd':		// Defragment
		case 'D':
			opts.mode = modeDefragment;
			fResult = FEDBUTLParseOptions( argc, argv, &opts, FEDBUTLParseDefragment );
			break;
			
		case 'm':		// File dump.
		case 'M':
			opts.mode = modeDump;
			memset( &dbutil, 0, sizeof(JET_DBUTIL) );
			opts.pv = &dbutil;
			dbutil.cbStruct = sizeof(JET_DBUTIL);

			switch( argv[1][2] )
				{
				case 0:
				case 'h':
				case 'H':
					dbutil.op = opDBUTILDumpHeader;
					break;

				case 'k':
				case 'K':
					dbutil.op = opDBUTILDumpCheckpoint;
					break;

#ifdef DEBUG
				case 'f':
				case 'F':
					dbutil.op = opDBUTILSetHeaderState;
					break;

				case 'l':
				case 'L':
					dbutil.op = opDBUTILDumpLogfile;
					break;
#endif

				default:
					printf( szUsageErr12 );
					printf( "%c%c", cNewLine, cNewLine );
					fResult = fFalse;
				}

			if ( fResult )
				{
				fResult = FEDBUTLParseOptions( argc, argv, &opts, NULL );
				}
			break;

		case 'u':		// Upgrade/convert
		case 'U':
			opts.mode = modeUpgrade;
			memset( &convert, 0, sizeof(JET_CONVERT) );
			opts.pv = &convert;
			fResult = FEDBUTLParseOptions( argc, argv, &opts, FEDBUTLParseUpgrade );
			if ( fResult  &&  convert.szOldDll == NULL )
				{
				printf( szUsageErr11 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;					
				}				
			break;

		case 'r':		// Recovery
		case 'R':
			opts.mode = modeRecovery;
			fResult = FEDBUTLParseOptions( argc, argv, &opts, FEDBUTLParseRecovery );
			break;

#ifdef DEBUG
		case 'b':		// Backup
		case 'B':
			opts.mode = modeBackup;
			fResult = FEDBUTLParseOptions( argc, argv, &opts, FEDBUTLParseBackup );
			break;
#endif

		case '?':
			goto Usage;			

		default:
			printf( szUsageErr12 );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
		}
		
	if ( !fResult )
		goto Usage;

	if ( !FUTILOPTSSuppressLogo( opts.fUTILOPTSFlags ) )
		{
		EDBUTLPrintLogo();
		}

	if ( opts.db != dbNormal )
		{
		Call( ErrEDBUTLLoadExchangeDB( &opts ) );
		}

	// Lights, cameras, action...
	timer = GetTickCount();
	
	switch ( opts.mode )
		{
		case modeRecovery:
			printf( "Initiating RECOVERY mode...%c", cNewLine );
			printf( "       Log files: %s%c", opts.szLogfilePath ? opts.szLogfilePath : "<current directory>", cNewLine );
			printf( "    System files: %s%c%c", opts.szSystemPath ? opts.szSystemPath : "<current directory>", cNewLine, cNewLine );

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "on" ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxBuffers, 500, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTableIndexes, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxCursors, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxVerPages, 128, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramLogBuffers, 41, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramLogFlushThreshold, 10, NULL ) );

			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			if ( opts.szBackup == NULL )
				{
				// Soft recovery.
				printf( "Performing soft recovery..." );
				err = JetInit( &instance );
				Call( ErrEDBUTLCleanup( instance, 0, err ) );
				printf( "%c%c", cNewLine, cNewLine );
				}
			else
				{
				// Hard recovery.

				// Kludge to allow LGRestore() to set fGlobalRepair.
				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "repair" ) );

				if ( opts.szRestore )
					{
					printf( "Restoring to '%s' from '%s'...", opts.szRestore, opts.szBackup );
					}
				else
					{
					printf( "Restoring to <current directory> from '%s'...", opts.szBackup );
					}
				err = JetRestore2( opts.szBackup, opts.szRestore, PrintStatus );
				printf( "%c%c", cNewLine, cNewLine );
				}
			break;

#ifdef DEBUG
		case modeBackup:
			Call( ErrEDBUTLCheckBackupPath( &opts ) );
			printf( "Initiating BACKUP mode...%c", cNewLine );
			printf( "       Log files: %s%c", opts.szLogfilePath ? opts.szLogfilePath : "<current directory>", cNewLine );
			printf( "    System files: %s%c%c", opts.szSystemPath ? opts.szSystemPath : "<current directory>", cNewLine, cNewLine );

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "on" ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxBuffers, 500, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTableIndexes, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxCursors, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxVerPages, 128, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramLogBuffers, 41, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramLogFlushThreshold, 10, NULL ) );

			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			if ( FUTILOPTSIncrBackup( opts.fUTILOPTSFlags ) )
				{
				printf( "Performing incremental backup..." );
				Call( JetInit( &instance ) );
				CallJ( JetBackup( opts.szBackup, JET_bitBackupIncremental | JET_bitBackupAtomic, NULL ), Cleanup );
				}
			else
				{
				printf( "Performing full backup..." );
				Call( JetInit( &instance ) );
				CallJ( JetBackup( opts.szBackup, JET_bitBackupAtomic, NULL ), Cleanup );
				}

			printf( "%c%c", cNewLine, cNewLine );
			Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );
			break;
#endif

		case modeDefragment:
			Call( ErrEDBUTLCheckDBNames( &opts, szDefaultDefragDB ) );
			
			printf( "Initiating DEFRAGMENTATION mode%s...%c",
				FUTILOPTSDefragRepair( opts.fUTILOPTSFlags ) ? " (with REPAIR option)" : "",
				cNewLine );
			printf( "        Database: %s%c", opts.szSourceDB, cNewLine );
			printf( "       Log files: %s%c", opts.szLogfilePath ? opts.szLogfilePath : "<current directory>", cNewLine );
			printf( "    System files: %s%c", opts.szSystemPath ? opts.szSystemPath : "<current directory>", cNewLine );
			printf( "  Temp. Database: %s%c", opts.szTempDB, cNewLine );

			// Recover to a consistent state and detach the database.
			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0,
				FUTILOPTSDefragRepair( opts.fUTILOPTSFlags ) ? "repair" : "on" ) );
			if ( opts.szLogfilePath != NULL )
				{
				Call( JetSetSystemParameter( &instance, 0, JET_paramLogFilePath, 0, opts.szLogfilePath ) );
				opts.szLogfilePath = NULL;		// Prevent from being reset.				
				}
			if ( opts.szSystemPath != NULL )
				{
				Call( JetSetSystemParameter( &instance, 0, JET_paramSystemPath, 0, opts.szSystemPath ) );
				opts.szSystemPath = NULL;			// Prevent from being reset.
				}

			Call( JetInit( &instance ) );
			CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );
			err = JetDetachDatabase( sesid, opts.szSourceDB );
			if ( err < 0  &&  err != JET_errDatabaseNotFound )
				{
				goto Cleanup;
				}
			Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );
			sesid = 0;

			if ( FUTILOPTSDefragRepair( opts.fUTILOPTSFlags ) )
				{
				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "repair_nolog" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramPageReadAheadMax, 0, NULL ) );
				}
			else
				{ 
				// Restart with logging/recovery disabled.
				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramPageReadAheadMax, 32, NULL ) );
				}
				
			Call( JetSetSystemParameter( &instance, 0, JET_paramOnLineCompact, 0, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramBfThrshldLowPrcnt, 1, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramBfThrshldHighPrcnt, 95, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramDbExtensionSize, 256, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 2000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTableIndexes, 2000, NULL ) );

			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );
				
			Call( JetInit( &instance ) );
			CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );

			// Detach temporary database and delete file if present (ignore errors).
			JetDetachDatabase( sesid, opts.szTempDB );
			DeleteFile( opts.szTempDB );
	
			CallJ( JetAttachDatabase( sesid, opts.szSourceDB, JET_bitDbReadOnly ), Cleanup );
			assert( err != JET_wrnDatabaseAttached );

			CallJ( JetCompact(
				sesid,
				opts.szSourceDB,
				opts.szTempDB,
				PrintStatus,
				NULL,
				FUTILOPTSDefragInfo( opts.fUTILOPTSFlags ) ? JET_bitCompactStats : 0 ), Cleanup );

			// Detach source database to avoid log aliasing.
			// UNDONE:  Is detaching really necessary, since we attached with logging disabled.
			CallJ( JetDetachDatabase( sesid, opts.szSourceDB ), Cleanup );
			
			Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );

			Call( ErrEDBUTLBackupAndInstateDB( sesid, &opts ) );

			printf( "Note:%c", cNewLine );
			printf( "  It is recommended that you immediately perform a full backup%c", cNewLine );
			printf( "  of this database. If you restore a backup made before the%c", cNewLine );
			printf( "  defragmentation, the database will be rolled back to the state%c", cNewLine );
			printf( "  it was in at the time of that backup.%c%c", cNewLine, cNewLine );
			
			break;

		case modeUpgrade:
			Call( ErrEDBUTLCheckDBNames( &opts, szDefaultUpgradeDB ) );
			
			printf( "Initiating UPGRADE mode...%c", cNewLine );
			printf( "        Database: %s%c", opts.szSourceDB, cNewLine );
			printf( "  Temp. Database: %s%c", opts.szTempDB, cNewLine );

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramOnLineCompact, 0, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramBfThrshldLowPrcnt, 1, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramBfThrshldHighPrcnt, 95, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramDbExtensionSize, 256, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramPageReadAheadMax, 32, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 1000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTableIndexes, 1000, NULL ) );
			
			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			Call( JetInit( &instance ) );
			CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );

			// Detach temporary database and delete file if present (ignore errors).
			JetDetachDatabase( sesid, opts.szTempDB );
			DeleteFile( opts.szTempDB );
	
			assert( opts.pv == &convert );
			CallJ( JetCompact(
				sesid,
				opts.szSourceDB,
				opts.szTempDB,
				PrintStatus,
				&convert,
				FUTILOPTSDefragInfo( opts.fUTILOPTSFlags ) ? JET_bitCompactStats : 0 ), Cleanup );

			Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );

			Call( ErrEDBUTLBackupAndInstateDB( sesid, &opts ) );
			break;

		case modeDump:
		default:
			// Make the most innocuous operation the fall-through (to cover
			// ourselves in the unlikely event we messed up the modes).
			assert( opts.mode == modeConsistency  ||  opts.mode == modeDump );
			assert( opts.pv == &dbutil );

			if ( opts.mode == modeDump )
				{
				if ( opts.szSourceDB == NULL )
					{
					printf( szUsageErr1, "database/filename" );			// Missing spec.
					printf( "%c%c", cNewLine, cNewLine );
					Call( JET_errInvalidParameter );
					}
				printf( "Initiating FILE DUMP mode...%c", cNewLine );
				
				switch( dbutil.op )
					{
					case opDBUTILDumpLogfile:
						printf( "      Log file: %s%c", opts.szSourceDB, cNewLine );
						break;
					case opDBUTILDumpCheckpoint:
						printf( "      Checkpoint file: %s%c", opts.szSourceDB, cNewLine );
						break;
					case opDBUTILSetHeaderState:
						printf( "      Database %s will be forced to be in consistent state%c", opts.szSourceDB, cNewLine );
						break;
					default:
						assert( dbutil.op == opDBUTILDumpHeader );
						printf( "      Database: %s%c", opts.szSourceDB, cNewLine );

					}
				}
			else
				{
				if ( opts.szSourceDB == NULL )
					{
					printf( szUsageErr1, "database/filename" );			// Missing spec.
					printf( "%c%c", cNewLine, cNewLine );
					Call( JET_errInvalidParameter );
					}
				printf( "Initiating CONSISTENCY mode...%c", cNewLine );
				printf( "    Database: %s%c", opts.szSourceDB, cNewLine );
				}

			printf( "%c", cNewLine );

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramOnLineCompact, 0, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 1000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTableIndexes, 1000, NULL ) );
			
			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );
			
			dbutil.szDatabase = opts.szSourceDB;
			Call( JetDBUtilities( &dbutil ) );
			printf( "%c", cNewLine );
		}
		
	EDBUTLGetTime( timer, &iSec, &iMSec );

	printf( szOperSuccess, iSec, iMSec );
	printf( "%c%c", cNewLine, cNewLine );
	return 0;
	

Cleanup:
	ErrEDBUTLCleanup( instance, sesid, err );

HandleError:
	printf( szOperFail, err );
	printf( "%c%c", cNewLine, cNewLine );
	return 1;


Usage:
	EDBUTLHelp( _strupr( argv[0] ) );
	return 1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\fcreate.c ===
#include "daestd.h"
#include "info.h"

DeclAssertFile; 				/* Declare file name for assert macro[	s */

#define StringKey( sz ) {sizeof( sz )-1, sz}


CODECONST(KEY) rgkeySTATIC[] = {
	StringKey( "" ),		// 0	NULL
	StringKey( "O" ),		// 1	OWNED SPACE
	StringKey( "A" ),		// 2	AVAILABLE SPACE
	StringKey( "R" ),		// 3	ROOT
	StringKey( "L" ),		// 4	LONG DATA
	StringKey( "U" ),		// 5	UNIQUE AUTOINCREMENT ID
	StringKey( "D" )		// 6	DATABASES
	};

/*	Waits till trx becomes the oldest transaction alive
/*	Uses exponential back off
/*	BFSleep releases critical sections to avoid deadlocks
/**/
LOCAL VOID FILEIWaitTillOldest( TRX trx )
	{
	ULONG ulmsec = ulStartTimeOutPeriod;

	/*	must be in critJet when inspect trxOldest global variable.
	/*	Call BFSleep to release critJet while sleeping.
	/**/
	for ( ; trx != trxOldest; )
		{
		BFSleep( ulmsec );
		ulmsec *= 2;
		if ( ulmsec > ulMaxTimeOutPeriod )
			ulmsec = ulMaxTimeOutPeriod;
		}
	return;
	}


ERR VTAPI ErrIsamCreateTable( JET_VSESID vsesid, JET_VDBID vdbid, JET_TABLECREATE *ptablecreate )
	{
	ERR				err;
	PIB				*ppib = (PIB *)vsesid;
#ifdef DISPATCHING
	JET_TABLEID		tableid;
#endif
	FUCB 			*pfucb;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	CallR( VDbidCheckUpdatable( vdbid ) );

#ifdef	DISPATCHING
	/*	Allocate a dispatchable tableid
	/**/
	CallR( ErrAllocateTableid( &tableid, (JET_VTID) 0, &vtfndefIsam ) );

	/*	create the table, and open it
	/**/
	Call( ErrFILECreateTable( ppib, DbidOfVDbid( vdbid ), ptablecreate ) );
	pfucb = (FUCB *)(ptablecreate->tableid);

	/*	inform dispatcher of correct JET_VTID
	/**/
	CallS( ErrSetVtidTableid( (JET_SESID)ppib, tableid, (JET_VTID)pfucb ) );
	pfucb->fVtid = fTrue;
	pfucb->tableid = tableid;
	FUCBSetVdbid( pfucb );
	ptablecreate->tableid = tableid;

	Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns + ptablecreate->cIndexes );
#else
	err = ErrFILECreateTable( ppib, DbidOfVDbid( vdbid ), ptablecreate );
#endif	/* DISPATCHING */

HandleError:
	if ( err < 0 )
		{
		ReleaseTableid( tableid );

		/*	do not build indexes if error
		/**/
		Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns );
		}

	return err;
	}


/*	return fTrue if the column type specified has a fixed length
/**/
INLINE LOCAL BOOL FCOLTYPFixedLength( JET_COLTYP coltyp )
	{
	switch( coltyp )
		{
		case JET_coltypBit:
		case JET_coltypUnsignedByte:
		case JET_coltypShort:
		case JET_coltypLong:
		case JET_coltypCurrency:
		case JET_coltypIEEESingle:
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
#ifdef NEW_TYPES
		case JET_coltypDate:
		case JET_coltypTime:
		case JET_coltypQuid:
#endif
			return fTrue;

		default:
			return fFalse;
		}
	}


INLINE LOCAL ERR ErrFILEIAddColumn(
	JET_COLUMNCREATE	*pcolcreate,
	FDB					*pfdb,
	WORD				*pibNextFixedOffset )
	{
	ERR					err;
	BYTE				szFieldName[ JET_cbNameMost + 1 ];
	TCIB				tcib = { pfdb->fidFixedLast, pfdb->fidVarLast, pfdb->fidTaggedLast };
	BOOL				fMaxTruncated;
	BOOL				fVersion = fFalse, fAutoInc = fFalse;

	if ( pcolcreate == NULL  ||  pcolcreate->cbStruct != sizeof(JET_COLUMNCREATE) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	CallR( ErrUTILCheckName( szFieldName, pcolcreate->szColumnName, ( JET_cbNameMost + 1 ) ) );

	/*	cannibalised this field in the FDB to provide us with an indication
	/*	of whether we should check for duplicate column names.
	/**/
	if ( pfdb->rgb != NULL )
		{
		JET_COLUMNCREATE	*pcolcreateCurr = (JET_COLUMNCREATE *)pfdb->rgb;
		BYTE				szCurrName[ JET_cbNameMost + 1];

		for ( pcolcreateCurr = (JET_COLUMNCREATE *)pfdb->rgb;
			pcolcreateCurr < pcolcreate;
			pcolcreateCurr++ )
			{
			/*	column should already have been processed,
			/*	so name check should always succeed.
			/**/
			CallS( ErrUTILCheckName( szCurrName, pcolcreateCurr->szColumnName, ( JET_cbNameMost + 1 ) ) );
			if ( UtilCmpName( szCurrName, szFieldName ) == 0 )
				{
				return ErrERRCheck( JET_errColumnDuplicate );
				}
			}
		
		Assert( pcolcreateCurr == pcolcreate );
		}

	if ( pcolcreate->coltyp == 0 || pcolcreate->coltyp > JET_coltypLongText )
		{
		return ErrERRCheck( JET_errInvalidColumnType );
		}

	/*	if column type is text then check code page
	/**/
	if ( FRECTextColumn( pcolcreate->coltyp ) )
		{
		/*	check code page
		/**/
		if ( (USHORT)pcolcreate->cp != usEnglishCodePage  &&
			(USHORT)pcolcreate->cp != usUniCodePage )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		}

	/*	set field options
	/**/
	if ( ( pcolcreate->grbit & JET_bitColumnTagged ) &&
		( pcolcreate->grbit & JET_bitColumnNotNULL ) )
		return ErrERRCheck( JET_errTaggedNotNULL );

	if ( ( pcolcreate->grbit & JET_bitColumnAutoincrement ) &&
		( pcolcreate->grbit & JET_bitColumnVersion ) )
		return ErrERRCheck( JET_errInvalidParameter );

	if ( ( pcolcreate->grbit & JET_bitColumnFixed ) &&
		( pcolcreate->grbit & JET_bitColumnTagged ) )
		return ErrERRCheck( JET_errInvalidParameter );

	/*	if column attribute is JET_bitVersion
	/*	return error if previous column attribute has been defined
	/*	return error if column type is not long
	/*	return error if tagged
	/*	set column flag
	/**/
	if ( pcolcreate->grbit & JET_bitColumnVersion )
		{
		if ( pfdb->fidVersion != 0 )
			return ErrERRCheck( JET_errColumn2ndSysMaint );
		if ( pcolcreate->coltyp != JET_coltypLong )
			return ErrERRCheck( JET_errInvalidParameter );
		if ( pcolcreate->grbit & JET_bitColumnTagged )
			return ErrERRCheck( JET_errCannotBeTagged );

		fVersion = fTrue;
		}

	/*	if column attribute is JET_bitAutoincrement
	/*	return error if previous column attribute has been defined
	/*	return error if column type is not long
	/*	set column flag
	/**/
	if ( pcolcreate->grbit & JET_bitColumnAutoincrement )
		{
		if ( pfdb->fidAutoInc != 0 )
			return ErrERRCheck( JET_errColumn2ndSysMaint );
		if ( pcolcreate->coltyp != JET_coltypLong )
			return ErrERRCheck( JET_errInvalidParameter );
		if ( pcolcreate->grbit & JET_bitColumnTagged )
			return ErrERRCheck( JET_errCannotBeTagged );

		fAutoInc = fTrue;
		}

	pcolcreate->cbMax = UlCATColumnSize( pcolcreate->coltyp, pcolcreate->cbMax, &fMaxTruncated );

	/*	for fixed-length columns, make sure record not too big
	/**/
	Assert( pfdb->fidFixedLast >= fidFixedLeast ?
		*pibNextFixedOffset > sizeof(RECHDR) :
		*pibNextFixedOffset == sizeof(RECHDR) );
	if ( ( ( pcolcreate->grbit & JET_bitColumnFixed ) || FCOLTYPFixedLength( pcolcreate->coltyp ) )
		&& *pibNextFixedOffset + pcolcreate->cbMax > cbRECRecordMost )
		{
		return ErrERRCheck( JET_errRecordTooBig );
		}

	CallR( ErrFILEGetNextColumnid(
		pcolcreate->coltyp,
		pcolcreate->grbit,
		&tcib,
		&pcolcreate->columnid ) );

	/*	update FDB
	/**/
	if ( FTaggedFid( pcolcreate->columnid ) )
		pfdb->fidTaggedLast++;
	else if ( FVarFid( pcolcreate->columnid ) )
		pfdb->fidVarLast++;
	else
		{
		Assert( FFixedFid( pcolcreate->columnid ) );
		pfdb->fidFixedLast++;
		*pibNextFixedOffset += (WORD)pcolcreate->cbMax;
		}

	/*	version and autoincrement are mutually exclusive
	/**/
	Assert( !( fVersion  &&  fAutoInc ) );
	if ( fVersion )
		{
		Assert( pfdb->fidVersion == 0 );
		pfdb->fidVersion = (FID)pcolcreate->columnid;
		}
	else if ( fAutoInc )
		{
		Assert( pfdb->fidAutoInc == 0 );
		pfdb->fidAutoInc = (FID)pcolcreate->columnid;
		}

	/*	propagate MaxTruncated warning only if no other errors/warnings
	/**/
	if ( fMaxTruncated  &&  err == JET_errSuccess )
		err = ErrERRCheck( JET_wrnColumnMaxTruncated );

	return err;
	}


INLINE LOCAL ERR ErrFILEIBatchAddColumns(
	PIB					*ppib,
	DBID				dbid,
	JET_TABLECREATE		*ptablecreate,
	OBJID				objidTable )
	{
	ERR					err;		
	/*	use a fake FDB to track last FIDs and version/autoinc fields
	/**/
	FDB					fdb = { NULL, fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1,
								0, 0, 0, { 0, NULL } };
	WORD				ibNextFixedOffset = sizeof(RECHDR);
	JET_COLUMNCREATE	*pcolcreate, *plastcolcreate;

	Assert( dbid != dbidTemp );
	Assert( !( ptablecreate->grbit & JET_bitTableCreateSystemTable ) );
	/*	table has been created
	/**/
	Assert( ptablecreate->cCreated == 1 );

	//	UNDONE:	should we check for duplicate column names?
	if ( ptablecreate->grbit & JET_bitTableCreateCheckColumnNames )
		{
		fdb.rgb = (BYTE *)ptablecreate->rgcolumncreate;
		}
	Assert( fdb.rgb == NULL  ||  ( ptablecreate->grbit & JET_bitTableCreateCheckColumnNames ) );

#ifdef DEBUG
	/*	despite the JET_bitTableCreateCheckColumnNames flag,
	/*	always do the name check on DEBUG builds.
	/**/
	fdb.rgb = (BYTE *)ptablecreate->rgcolumncreate;
#endif

	plastcolcreate = ptablecreate->rgcolumncreate + ptablecreate->cColumns;
	for ( pcolcreate = ptablecreate->rgcolumncreate;
		pcolcreate < plastcolcreate;
		pcolcreate++ )
		{
		Assert( pcolcreate < ptablecreate->rgcolumncreate + ptablecreate->cColumns );

		pcolcreate->err = ErrFILEIAddColumn(
			pcolcreate,
			&fdb,
			&ibNextFixedOffset );
		CallR( pcolcreate->err );

		ptablecreate->cCreated++;
		Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns );
		}

	CallR( ErrCATBatchInsert(
		ppib,
		dbid,
		ptablecreate->rgcolumncreate,
		ptablecreate->cColumns,
		objidTable,
		ptablecreate->grbit & JET_bitTableCreateCompaction ) );

	return JET_errSuccess;
	}


INLINE LOCAL ERR ErrFILEICreateIndexes( PIB *ppib, FUCB *pfucb, JET_TABLECREATE *ptablecreate )
	{
	ERR				err = JET_errSuccess;
	JET_INDEXCREATE	*pidxcreate, *plastidxcreate;

	Assert( !( ptablecreate->grbit & JET_bitTableCreateSystemTable ) );
	Assert( ptablecreate->cIndexes > 0 );
	Assert( ptablecreate->cCreated == 1 + ptablecreate->cColumns );

	plastidxcreate = ptablecreate->rgindexcreate + ptablecreate->cIndexes;
	for ( pidxcreate = ptablecreate->rgindexcreate;
		pidxcreate < plastidxcreate;
		pidxcreate++ )
		{
		Assert( pidxcreate < ptablecreate->rgindexcreate + ptablecreate->cIndexes );

		if ( pidxcreate == NULL || pidxcreate->cbStruct != sizeof(JET_INDEXCREATE) )
			{
			/*	if an invalid structure is encountered, get out right away
			/**/
			err = ErrERRCheck( JET_errInvalidCreateIndex );
			break;
			}
		else
			{
			pidxcreate->err = ErrIsamCreateIndex(
				ppib,
				pfucb,
				pidxcreate->szIndexName,
				pidxcreate->grbit | JET_bitIndexEmptyTable,
				pidxcreate->szKey,
				pidxcreate->cbKey,
				pidxcreate->ulDensity );
			if ( pidxcreate->err >= JET_errSuccess )
				{
				ptablecreate->cCreated++;
				Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns + ptablecreate->cIndexes );
				}
			else
				{
				err = pidxcreate->err;
				}
			}
		}

	return err;
	}


//+API
// ErrFILECreateTable
// =========================================================================
// ERR ErrFILECreateTable( PIB *ppib, DBID dbid, CHAR *szName,
//		ULONG ulPages, ULONG ulDensity, FUCB **ppfucb )
//
// Create file with pathname szName.  Created file will have no fields or
// indexes defined (and so will be a "sequential" file ).
//
// PARAMETERS
//					ppib   			PIB of user
//					dbid   			database id
//					szName			path name of new file
//					ulPages			initial page allocation for file
//					ulDensity		initial loading density
//					ppfucb			Exclusively locked FUCB on new file
// RETURNS		Error codes from DIRMAN or
//					 JET_errSuccess		Everything worked OK
//					-DensityIvlaid	  	Density parameter not valid
//					-TableDuplicate   	A file already exists with the path given
// COMMENTS		A transaction is wrapped around this function.	Thus, any
//			 	work done will be undone if a failure occurs.
// SEE ALSO		ErrIsamAddColumn, ErrIsamCreateIndex, ErrIsamDeleteTable
//-
ERR ErrFILECreateTable( PIB *ppib, DBID dbid, JET_TABLECREATE *ptablecreate )
	{
	ERR		  	err;
	CHAR	  	szTable[(JET_cbNameMost + 1 )];
	FUCB	  	*pfucb;
	PGNO		pgnoFDP;
	BOOL		fSystemTable = ( ptablecreate->grbit & JET_bitTableCreateSystemTable );
	BOOL		fWriteLatchSet = fFalse;
	ULONG		ulDensity = ptablecreate->ulDensity;

	Assert( dbid < dbidMax );

	/*	check parms
	/**/
	CheckPIB(ppib );
	CheckDBID( ppib, dbid );
	CallR( ErrUTILCheckName( szTable, ptablecreate->szTableName, (JET_cbNameMost + 1) ) );

	ptablecreate->cCreated = 0;

	if ( ulDensity == 0 )
		{
		ulDensity = ulFILEDefaultDensity;
		}
	if ( ulDensity < ulFILEDensityLeast || ulDensity > ulFILEDensityMost )
		{
		return ErrERRCheck( JET_errDensityInvalid );
		}

	CallR( ErrDIRBeginTransaction( ppib ) );

	/*	allocate cursor
	/**/
	Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );

	Call( ErrDIRCreateDirectory( pfucb, (CPG)ptablecreate->ulPages, &pgnoFDP ) );

	DIRClose( pfucb );

	/*	insert record in MSysObjects
	/**/
	if ( dbid != dbidTemp && !fSystemTable )
		{
		OBJID		    objidTable	 	= pgnoFDP;
		LINE			rgline[ilineSxMax];
		OBJTYP			objtyp			= (OBJTYP)JET_objtypTable;
		OBJID    		objidParentId	= objidTblContainer;
		LONG			flags  			= 0;
		FID				fidFixedLast	= fidFixedLeast - 1;
		FID				fidVarLast		= fidVarLeast - 1;
		FID				fidTaggedLast	= fidTaggedLeast - 1;
		JET_DATESERIAL	dtNow;

		UtilGetDateTime( &dtNow );

		rgline[iMSO_Id].pb				= (BYTE *)&objidTable;
		rgline[iMSO_Id].cb				= sizeof(objidTable);
		rgline[iMSO_ParentId].pb		= (BYTE *)&objidParentId;
		rgline[iMSO_ParentId].cb		= sizeof(objidParentId);
		rgline[iMSO_Name].pb			= (BYTE *)szTable;
		rgline[iMSO_Name].cb			= strlen(szTable);
		rgline[iMSO_Type].pb			= (BYTE *)&objtyp;
		rgline[iMSO_Type].cb			= sizeof(objtyp);
		rgline[iMSO_DateCreate].pb		= (BYTE *)&dtNow;
		rgline[iMSO_DateCreate].cb		= sizeof(JET_DATESERIAL);
		rgline[iMSO_DateUpdate].pb		= (BYTE *)&dtNow;
		rgline[iMSO_DateUpdate].cb		= sizeof(JET_DATESERIAL);
		rgline[iMSO_Owner].cb			= 0;
		rgline[iMSO_Flags].pb			= (BYTE *) &flags;
		rgline[iMSO_Flags].cb			= sizeof(ULONG);
		rgline[iMSO_Pages].pb			= (BYTE *)&(ptablecreate->ulPages);
		rgline[iMSO_Pages].cb			= sizeof(ptablecreate->ulPages);
		rgline[iMSO_Density].pb			= (BYTE *)&ulDensity;
		rgline[iMSO_Density].cb			= sizeof(ulDensity);
		rgline[iMSO_Stats].cb			= 0;

		err = ErrCATInsert( ppib, dbid, itableSo, rgline, objidTable );
		if ( err < 0 )
			{
			/*	duplicate key in catalog means this table already exists
			/**/
			if ( err == JET_errKeyDuplicate )
				{
				err = ErrERRCheck( JET_errTableDuplicate );
				}
			goto HandleError;
			}
		}

	Assert( ptablecreate->cCreated == 0 );
	ptablecreate->cCreated = 1;

	if ( ptablecreate->cColumns > 0 )
		{
		Call( ErrFILEIBatchAddColumns( ppib, dbid, ptablecreate, pgnoFDP ) );
		}

	Assert( ptablecreate->cCreated == 1 + ptablecreate->cColumns );

	/*	for temporary tables, must inform open table of the table FDP
	/*	by cannibalising the pfucb.
	/**/
	if ( dbid == dbidTemp )
		{
		pfucb = (FUCB *)((ULONG_PTR)pgnoFDP);
		}

	/*	open table in exclusive mode, for output parameter
	/**/
	Call( ErrFILEOpenTable(
		ppib,
		dbid,
		&pfucb,
		ptablecreate->szTableName,
		( fSystemTable ? JET_bitTableDenyRead|JET_bitTableCreateSystemTable :
			JET_bitTableDenyRead ) ) );
	Assert( ptablecreate->cColumns > 0  ||
		fSystemTable  ||
		( pfucb->u.pfcb->pfdb->fidFixedLast == fidFixedLeast-1  &&
		pfucb->u.pfcb->pfdb->fidVarLast == fidVarLeast-1  &&
		pfucb->u.pfcb->pfdb->fidTaggedLast == fidTaggedLeast-1 ) );

    Assert( !FFCBReadLatch( pfucb->u.pfcb ) );
	Assert( !FFCBWriteLatch( pfucb->u.pfcb, ppib ) );
	FCBSetWriteLatch( pfucb->u.pfcb, ppib );
	fWriteLatchSet = fTrue;

	Call( ErrVERFlag( pfucb, operCreateTable, NULL, 0 ) );
	/*	write latch will be reset by either commit or rollback after VERFlag
	/**/
	fWriteLatchSet = fFalse;
	FUCBSetVersioned( pfucb );

	if ( ptablecreate->cIndexes > 0 )
		{
		Call( ErrFILEICreateIndexes( ppib, pfucb, ptablecreate ) );
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	/*	internally, we use tableid and pfucb interchangeably
	/**/
	ptablecreate->tableid = (JET_TABLEID)pfucb;

	return JET_errSuccess;

HandleError:
	/*	close performed by rollback
	/**/
	CallS( ErrDIRRollback( ppib ) );

	/*	if write latch was not reset in commit/rollback, and it was
	/*	set, then reset it.
	/**/
	if ( fWriteLatchSet )
		FCBResetWriteLatch( pfucb->u.pfcb, ppib );

	/*	reset return variable if close table via rollback
	/**/
	ptablecreate->tableid = (JET_TABLEID)pfucbNil;

	return err;
	}


//====================================================
// Determine field "mode" as follows:
// if ("long" textual || JET_bitColumnTagged given ) ==> TAGGED
// else if (numeric type || JET_bitColumnFixed given ) ==> FIXED
// else ==> VARIABLE
//====================================================
ERR ErrFILEGetNextColumnid(
	JET_COLTYP		coltyp,
	JET_GRBIT		grbit,
	TCIB			*ptcib,
	JET_COLUMNID	*pcolumnid )
	{
	JET_COLUMNID	columnidMost;

	if ( ( grbit & JET_bitColumnTagged ) || FRECLongValue( coltyp ) )
		{
		*pcolumnid = ++(ptcib->fidTaggedLast);
		columnidMost = fidTaggedMost;
		}
	else if ( ( grbit & JET_bitColumnFixed ) || FCOLTYPFixedLength( coltyp ) )
		{
		*pcolumnid = ++(ptcib->fidFixedLast);
		columnidMost = fidFixedMost;
		}
	else
		{
		Assert( !( grbit & JET_bitColumnTagged ) );
		Assert( !( grbit & JET_bitColumnFixed ) );
		Assert( coltyp == JET_coltypText || coltyp == JET_coltypBinary );
		*pcolumnid = ++(ptcib->fidVarLast);
		columnidMost = fidVarMost;
		}

	return ( *pcolumnid > columnidMost ? ErrERRCheck( JET_errTooManyColumns ) : JET_errSuccess );
	}


//+API
// ErrIsamAddColumn
// ========================================================================
// ERR ErrIsamAddColumn(
//		PIB				*ppib;			// IN PIB of user
//		FUCB			*pfucb;	 		// IN Exclusively opened FUCB on file
//		CHAR			*szName;		// IN name of new field
//		JET_COLUMNDEF	*pcolumndef		// IN definition of column added
//		BYTE			*pbDefault		// IN Default value of column
//		ULONG			cbDefault		// IN length of Default value
//		JET_COLUMNID	*pcolumnid )	// OUT columnid of added column
//
// Creates a new field definition for a file.
//
// PARAMETERS
//				pcolumndef->coltyp			data type of new field, see jet.h
//				pcolumndef->grbit  			field describing flags:
//					VALUE				MEANING
//					========================================
//					JET_bitColumnNotNULL		 	Indicates that the field may
//													not take on NULL values.
//					JET_bitColumnTagged		 		The field is a "tagged" field.
//					JET_bitColumnVersion		 	The field is a version field
//					JET_bitColumnAutoIncrement		The field is a autoinc field
//
// RETURNS		JET_errSuccess			Everything worked OK.
//					-TaggedDefault			A default value was specified
//												for a tagged field.
//					-ColumnDuplicate		There is already a field
//												defined for the name given.
// COMMENTS
//		There must not be anyone currently using the file, unless
//		the ErrIsamAddColumn is at level 0 [when non-exclusive ErrIsamAddColumn works].
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//		Transaction logging is turned off for temporary files.
//
// SEE ALSO		ErrIsamCreateTable, ErrIsamCreateIndex
//-
ERR VTAPI ErrIsamAddColumn(
	PIB				*ppib,
	FUCB		  	*pfucb,
	CHAR		  	*szName,
	JET_COLUMNDEF	*pcolumndef,
	BYTE		  	*pbDefault,
	ULONG		  	cbDefault,
	JET_COLUMNID	*pcolumnid )
	{
	TCIB			tcib;
#ifdef DEBUG
	TCIB			tcibT;
#endif
	KEY				key;
	ERR				err;
	BYTE		  	rgbColumnNorm[ JET_cbKeyMost ];
	BYTE			szFieldName[ JET_cbNameMost + 1 ];
	FCB				*pfcb;
	JET_COLUMNID	columnid;
	LINE			lineDefault;
	LINE			*plineDefault;
	FIELDEX			fieldex;
	BOOL		  	fMaxTruncated = fFalse;
	BOOL			fTemp;
	ULONG			cFixed, cVar, cTagged;
	ULONG			cbFieldsTotal, cbFieldsUsed, cbFree, cbNeeded;
	BOOL			fAddOffsetEntry = fFalse;
	BOOL			fWriteLatchSet = fFalse;

	/*	check paramaters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CallR( ErrUTILCheckName( szFieldName, szName, ( JET_cbNameMost + 1 ) ) );

	/*	ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb ) );

	Assert( pfucb->dbid < dbidMax );

	fTemp = FFCBTemporaryTable( pfucb->u.pfcb );

	if ( pcolumndef->cbStruct < sizeof(JET_COLUMNDEF) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	fieldex.field.coltyp = pcolumndef->coltyp;

	/*	if column type is text then check code page and language id
	/**/
	if ( FRECTextColumn( fieldex.field.coltyp ) )
		{
		/*	check code page
		/**/
		fieldex.field.cp = pcolumndef->cp;
		if ( fieldex.field.cp != usEnglishCodePage && fieldex.field.cp != usUniCodePage )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

		}
	else
		fieldex.field.cp = 0;		// Force code page to 0 for non-text columns.

	//	UNDONE:	interpret pbDefault of NULL for NULL value, and
	//			cbDefault == 0 and pbDefault != NULL as set to
	//			zero length.
	if ( cbDefault > 0 )
		{
		lineDefault.cb = cbDefault;
		lineDefault.pb = (BYTE *)pbDefault;
		plineDefault = &lineDefault;
		}
	else
		{
		plineDefault = NULL;
		}

	if ( ( pcolumndef->grbit & JET_bitColumnTagged )  &&
		( pcolumndef->grbit & JET_bitColumnNotNULL ) )
		{
		return ErrERRCheck( JET_errTaggedNotNULL );
		}

	Assert( ppib != ppibNil );
	Assert( pfucb != pfucbNil );
	CheckTable( ppib, pfucb );
	Assert( pfucb->u.pfcb != pfcbNil );
	pfcb = pfucb->u.pfcb;

	/*	wait for bookmark cleanup and on-going replace/insert.
	/*	UNDONE: decouple operation from other index creations
	/**/
	while ( FFCBReadLatch( pfcb ) )
		{
		BFSleep( cmsecWaitGeneric );
		}

	/*	quiesce replace and inserts
	/**/
	if ( FFCBWriteLatch( pfcb, ppib ) )
		{
		/*	abort if DDL modification in progress
		/**/
		return ErrERRCheck( JET_errWriteConflict );
		}
	FCBSetWriteLatch( pfcb, ppib );
	fWriteLatchSet = fTrue;

	/*	normalize column name
	/**/
	UtilNormText( szFieldName, strlen(szFieldName), rgbColumnNorm, sizeof(rgbColumnNorm), &key.cb );
	key.pb = rgbColumnNorm;

	err = ErrDIRBeginTransaction( ppib );
	if ( err < 0 )
		{
		FCBResetWriteLatch( pfcb, ppib );
		return err;
		}

	/*	move to FDP root and update FDP timestamp
	/**/
	Assert( pfucb->ppib->level < levelMax );
	DIRGotoFDPRoot( pfucb );

	/*	set tcib
	/**/
	tcib.fidFixedLast = pfcb->pfdb->fidFixedLast;
	tcib.fidVarLast = pfcb->pfdb->fidVarLast;
	tcib.fidTaggedLast = pfcb->pfdb->fidTaggedLast;
#ifdef DEBUG
	tcibT.fidFixedLast = tcib.fidFixedLast;
	tcibT.fidVarLast = tcib.fidVarLast;
	tcibT.fidTaggedLast = tcib.fidTaggedLast;
#endif

	/*	check for field existence, if not a system table.  If a system table,
	/*	then we assume same column not added twice.
	/**/
	if ( PfieldFCBFromColumnName( pfcb, szFieldName ) != NULL )
		{
		Call( ErrERRCheck( JET_errColumnDuplicate ) );
		}

	if ( fieldex.field.coltyp == 0 || fieldex.field.coltyp > JET_coltypLongText )
		{
		err = ErrERRCheck( JET_errInvalidColumnType );
		goto HandleError;
		}

	fieldex.field.ffield = 0;

	/*	set field parameters
	/**/
	if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement ) &&
		( pcolumndef->grbit & JET_bitColumnVersion ) )
		{
		/*	mutual exclusive
		/**/
		err = ErrERRCheck( JET_errInvalidParameter );
		goto HandleError;
		}

	/*	if column attribute is JET_bitVersion
	/*	return error if previous column attribute has been defined
	/*	return error if column type is not long
	/*	set column flag
	/**/
	if ( ( pcolumndef->grbit & JET_bitColumnVersion ) != 0 )
		{
		if ( pfcb->pfdb->fidVersion != 0 )
			{
			err = ErrERRCheck( JET_errColumn2ndSysMaint );
			goto HandleError;
			}
		if ( fieldex.field.coltyp != JET_coltypLong )
			{
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
			}
		/*	autoincrement cannot be tagged
		/**/
		if ( pcolumndef->grbit & JET_bitColumnTagged )
			{
			err = ErrERRCheck( JET_errCannotBeTagged );
			goto HandleError;
			}
		FIELDSetVersion( fieldex.field.ffield );
		}

	/*	if column attribute is JET_bitAutoincrement
	/*	return error if previous column attribute has been defined
	/*	return error if column type is not long
	/*	set column flag
	/**/
	if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement ) != 0 )
		{
		/*	it is an autoinc column that we want to add
		/**/
		if ( pfcb->pfdb->fidAutoInc != 0 )
			{
			/*	there is already an autoinc column for the table.
			/*	and we don't allow two autoinc columns for one table.
			/**/
			err = ErrERRCheck( JET_errColumn2ndSysMaint );
			goto HandleError;
			}
		if ( fieldex.field.coltyp != JET_coltypLong )
			{
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
			}

		/*	autoincrement cannot be tagged
		/**/
		if ( pcolumndef->grbit & JET_bitColumnTagged )
			{
			err = ErrERRCheck( JET_errCannotBeTagged );
			goto HandleError;
			}

		FIELDSetAutoInc( fieldex.field.ffield );
		}

	if ( pcolumndef->grbit & JET_bitColumnNotNULL )
		{
		FIELDSetNotNull( fieldex.field.ffield );
		}

	if ( pcolumndef->grbit & JET_bitColumnMultiValued )
		{
		FIELDSetMultivalue( fieldex.field.ffield );
		}

//	UNDONE: support zero-length default values
	if ( cbDefault > 0 )
		{
		FIELDSetDefault( fieldex.field.ffield );
		}

	/*******************************************************
	/*	Determine maximum field length as follows:
	/*	switch field type
	/*		case numeric:
	/*			max = <exact length of specified type>;
	/*		case "short" textual ( Text || Binary ):
	/*			if (specified max == 0 ) max = JET_cbColumnMost
	/*			else max = MIN( JET_cbColumnMost, specified max )
	/*		case "long" textual (Memo || Graphic ):
	/*			max = specified max (if 0, unlimited )
	/******************************************************
	/**/
	Assert( fieldex.field.coltyp != JET_coltypNil );
	fieldex.field.cbMaxLen = UlCATColumnSize( fieldex.field.coltyp, pcolumndef->cbMax, &fMaxTruncated );

	/*	for fixed-length columns, make sure record not too big
	/**/
	Assert( pfcb->pfdb->fidFixedLast >= fidFixedLeast ?
		PibFDBFixedOffsets( pfcb->pfdb )[pfcb->pfdb->fidFixedLast] > sizeof(RECHDR) :
		PibFDBFixedOffsets( pfcb->pfdb )[pfcb->pfdb->fidFixedLast] == sizeof(RECHDR) );
	if ( ( ( pcolumndef->grbit & JET_bitColumnFixed ) ||
		FCOLTYPFixedLength( fieldex.field.coltyp ) )
		&& PibFDBFixedOffsets( pfcb->pfdb )[pfcb->pfdb->fidFixedLast] + fieldex.field.cbMaxLen > cbRECRecordMost )
		{
		err = ErrERRCheck( JET_errRecordTooBig );
		goto HandleError;
		}

	Call( ErrFILEGetNextColumnid( fieldex.field.coltyp, pcolumndef->grbit, &tcib, &columnid ) );

#ifdef DEBUG
	Assert( ( FFixedFid(columnid) && ( tcib.fidFixedLast == ( tcibT.fidFixedLast + 1 ) ) ) ||
		tcib.fidFixedLast == tcibT.fidFixedLast );
	Assert( ( FVarFid(columnid) && ( tcib.fidVarLast == ( tcibT.fidVarLast + 1 ) ) ) ||
		tcib.fidVarLast == tcibT.fidVarLast );
	Assert( ( FTaggedFid(columnid) && ( tcib.fidTaggedLast == ( tcibT.fidTaggedLast + 1 ) ) ) ||
		tcib.fidTaggedLast == tcibT.fidTaggedLast );
#endif

	fieldex.fid = (FID)columnid;

	Call( ErrVERFlag( pfucb, operAddColumn, (VOID *)&fieldex.fid, sizeof(FID) ) );

	/*	write latch will be reset by either commit or rollback after VERFlag
	/**/
	fWriteLatchSet = fFalse;

	if ( pcolumnid != NULL )
		{
		*pcolumnid = columnid;
		}

	/*	update FDB and default record value
	/**/
	Call( ErrDIRGet( pfucb ) );

	cFixed = pfcb->pfdb->fidFixedLast + 1 - fidFixedLeast;
	cVar = pfcb->pfdb->fidVarLast + 1 - fidVarLeast;
	cTagged = pfcb->pfdb->fidTaggedLast + 1 - fidTaggedLeast;
	cbFieldsUsed = ( ( cFixed + cVar + cTagged ) * sizeof(FIELD) ) +
		(ULONG)((ULONG_PTR)Pb4ByteAlign( (BYTE *) ( ( pfcb->pfdb->fidFixedLast + 1 ) * sizeof(WORD) ) ));
	cbFieldsTotal = CbMEMGet( pfcb->pfdb->rgb, itagFDBFields );
	Assert( cbFieldsTotal >= cbFieldsUsed );
	cbFree = cbFieldsTotal - cbFieldsUsed;
	cbNeeded = sizeof( FIELD );

	if ( FFixedFid( columnid ) )
		{
		/*	If already on a 4-byte boundary, need to add two WORDs.  If not on
		/*	a 4-byte boundary, then there must be extra padding we can take
		/*	advantage of, ie. do not need to add anything.
		/**/
		if ( ( ( cFixed + 1 ) % 2 ) == 0 )
			{
			cbNeeded += sizeof(DWORD);
			fAddOffsetEntry = fTrue;
			}
		}

	if ( cbNeeded > cbFree )
		{
		/*	add space for another 10 columns
		/**/
		Call( ErrMEMReplace(
			pfcb->pfdb->rgb,
			itagFDBFields,
			NULL,
			cbFieldsTotal + ( sizeof(FIELD) * 10 )
			) );
		}

	/*	incrementing fidFixed/Var/TaggedLast guarantees that a new FIELD structure
	/*	was added -- rollback checks for this.
	/**/
	if ( fieldex.fid == pfcb->pfdb->fidTaggedLast + 1 )
		{
		// Initialise the FIELD structure we'll be using.
		memset(
			(BYTE *)( PfieldFDBTagged( pfcb->pfdb ) + ( fieldex.fid - fidTaggedLeast ) ),
			0,
			sizeof(FIELD) );

		pfcb->pfdb->fidTaggedLast++;
		fieldex.ibRecordOffset = 0;
		}
	else if ( fieldex.fid == pfcb->pfdb->fidVarLast + 1 )
		{
		FIELD *pfieldTagged = PfieldFDBTagged( pfcb->pfdb );

		/*	adjust the location of the FIELD structures for tagged columns to
		/*	accommodate the insertion of a variable column FIELD structure.
		/**/
		memmove(
			pfieldTagged + 1,
			pfieldTagged,
			sizeof(FIELD) * cTagged
			);

		// Initialise the new variable column FIELD structure, now located where
		// the tagged column FIELD structures used to start.
		memset( pfieldTagged, 0, sizeof(FIELD) );

		pfcb->pfdb->fidVarLast++;
		fieldex.ibRecordOffset = 0;
		}
	else
		{
		FIELD	*pfieldFixed = PfieldFDBFixed( pfcb->pfdb );
		FIELD	*pfieldVar = PfieldFDBVarFromFixed( pfcb->pfdb, pfieldFixed );
		ULONG	cbShift;

		Assert( fieldex.fid == pfcb->pfdb->fidFixedLast + 1 );

		/*	Adjust the location of the FIELD structures for tagged and variable
		/*	columns to accommodate the insertion of a fixed column FIELD structure
		/*	and its associated entry in the fixed offsets table.
		/**/
		cbShift = sizeof(FIELD) + ( fAddOffsetEntry ? sizeof(DWORD) : 0 );
		memmove(
			(BYTE *)pfieldVar + cbShift,
			pfieldVar,
			sizeof(FIELD) * ( cVar + cTagged )
			);

		// Initialise the new fixed column FIELD structure, now located where
		// the variable column FIELD structures used to start.
		memset( (BYTE *)pfieldVar, 0, cbShift );

		if ( fAddOffsetEntry )
			{
			memmove(
				(BYTE *)pfieldFixed + sizeof(DWORD),
				pfieldFixed,
				sizeof(FIELD) * cFixed
				);
			}

		fieldex.ibRecordOffset = PibFDBFixedOffsets( pfcb->pfdb )[pfcb->pfdb->fidFixedLast];
		pfcb->pfdb->fidFixedLast++;
		RECSetLastOffset( (FDB *)pfcb->pfdb, (WORD)( fieldex.ibRecordOffset + fieldex.field.cbMaxLen ) );
		}

	/*	version and autoincrement are mutually exclusive
	/**/
	Assert( !( FFIELDVersion( fieldex.field.ffield )  &&
		FFIELDAutoInc( fieldex.field.ffield ) ) );
	if ( FFIELDVersion( fieldex.field.ffield ) )
		{
		Assert( pfcb->pfdb->fidVersion == 0 );
		pfcb->pfdb->fidVersion = fieldex.fid;
		}
	else if ( FFIELDAutoInc( fieldex.field.ffield ) )
		{
		Assert( pfcb->pfdb->fidAutoInc == 0 );
		pfcb->pfdb->fidAutoInc = fieldex.fid;
		}

	/*	temporarily set to illegal value (for rollback)
	/**/
	Assert( PfieldFDBFromFid( (FDB *)pfcb->pfdb, fieldex.fid )->itagFieldName == 0 );
	fieldex.field.itagFieldName = 0;

	/*	add the column name to the buffer
	/**/
	Call( ErrMEMAdd(
		pfcb->pfdb->rgb,
		szFieldName,
		strlen( szFieldName ) + 1,
		&fieldex.field.itagFieldName
		) );
	Assert( fieldex.field.itagFieldName != 0 );

	err = ErrRECAddFieldDef( (FDB *)pfcb->pfdb, &fieldex );
	Assert( err == JET_errSuccess );

	if ( FFIELDDefault( fieldex.field.ffield ) )
		{
		/*	rebuild the default record if changed
		/**/
		Assert( plineDefault != NULL  &&  cbDefault > 0 );
		Call( ErrFDBRebuildDefaultRec(
			(FDB *)pfcb->pfdb,
			fieldex.fid,
			plineDefault ) );
		}

#ifdef DEBUG
	Assert( ( FFixedFid(columnid) && ( tcib.fidFixedLast == ( tcibT.fidFixedLast + 1 ) ) ) ||
		tcib.fidFixedLast == tcibT.fidFixedLast );
	Assert( ( FVarFid(columnid) && ( tcib.fidVarLast == ( tcibT.fidVarLast + 1 ) ) ) ||
		tcib.fidVarLast == tcibT.fidVarLast );
	Assert( ( FTaggedFid(columnid) && ( tcib.fidTaggedLast == ( tcibT.fidTaggedLast + 1 ) ) ) ||
		tcib.fidTaggedLast == tcibT.fidTaggedLast );
#endif

	/*	set currency before first
	/**/
	DIRBeforeFirst( pfucb );
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		DIRBeforeFirst( pfucb->pfucbCurIndex );
		}

	/*	insert column record into MSysColumns
	/**/
	if ( !fTemp )
		{
		LINE			rgline[ilineSxMax];
		OBJID   		objidTable			=	pfucb->u.pfcb->pgnoFDP;
		BYTE			fRestricted			=	0;
		WORD			ibRecordOffset;

		rgline[iMSC_ObjectId].pb			= (BYTE *)&objidTable;
		rgline[iMSC_ObjectId].cb			= sizeof(objidTable);
		rgline[iMSC_Name].pb				= szFieldName;
		rgline[iMSC_Name].cb				= strlen(szFieldName);
		rgline[iMSC_ColumnId].pb			= (BYTE *)&columnid;
		rgline[iMSC_ColumnId].cb			= sizeof(columnid);
		rgline[iMSC_Coltyp].pb				= (BYTE *)&fieldex.field.coltyp;
		rgline[iMSC_Coltyp].cb				= sizeof(BYTE);
		rgline[iMSC_Length].pb				= (BYTE *)&fieldex.field.cbMaxLen;
		rgline[iMSC_Length].cb				= sizeof(fieldex.field.cbMaxLen);
		rgline[iMSC_CodePage].pb			= (BYTE *)&fieldex.field.cp;
		rgline[iMSC_CodePage].cb			= sizeof(fieldex.field.cp);
		rgline[iMSC_Flags].pb				= &fieldex.field.ffield;
		rgline[iMSC_Flags].cb				= sizeof(fieldex.field.ffield);
		rgline[iMSC_Default].pb				= pbDefault;
		rgline[iMSC_Default].cb				= cbDefault;
		rgline[iMSC_POrder].cb				= 0;

		if ( FFixedFid( columnid ) )
			{
			Assert( (FID)columnid == pfcb->pfdb->fidFixedLast );
			ibRecordOffset = PibFDBFixedOffsets(pfcb->pfdb)[columnid - fidFixedLeast];
			
			rgline[iMSC_RecordOffset].pb = (BYTE *)&ibRecordOffset;
			rgline[iMSC_RecordOffset].cb = sizeof(WORD);
			}
		else
			{
			Assert( FVarFid( columnid )  ||  FTaggedFid( columnid ) );
			rgline[iMSC_RecordOffset].cb = 0;
			}

		err = ErrCATInsert( ppib, pfucb->dbid, itableSc, rgline, objidTable );
		if ( err < 0 )
			{
			if ( err == JET_errKeyDuplicate )
				{
				err = ErrERRCheck( JET_errColumnDuplicate );
				}
			goto HandleError;
			}
		}

	if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement) != 0 )
		{
		DIB dib;

		DIRGotoFDPRoot( pfucb );
		dib.fFlags = fDIRNull;
		dib.pos = posDown;

		/*	see if table is empty
		/**/
		Assert( dib.fFlags == fDIRNull );
		Assert( dib.pos == posDown );
		dib.pkey = pkeyData;
		err = ErrDIRDown( pfucb, &dib );
		if ( err != JET_errSuccess )
			{
			if ( err < 0 )
				goto HandleError;
			Assert( err == wrnNDFoundLess || err == wrnNDFoundGreater );
			err = JET_errDatabaseCorrupted;
			goto HandleError;
			}

		Assert( dib.fFlags == fDIRNull );
		dib.pos = posFirst;
		err = ErrDIRDown( pfucb, &dib );
		if ( err < 0 && err != JET_errRecordNotFound )
			{
			goto HandleError;
			}
		else if ( err != JET_errRecordNotFound )
			{
			ULONG	ul = 1;
			LINE	lineAutoInc;
			FID		fidAutoIncTmp = pfucb->u.pfcb->pfdb->fidAutoInc;

			do
				{
				Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepReplaceNoLock ) );
				PrepareInsert( pfucb );
				Call( ErrIsamSetColumn(ppib, pfucb, (ULONG)fidAutoIncTmp, (BYTE *)&ul,
				  sizeof(ul), 0, NULL ) );
				PrepareReplace(pfucb);
				Call( ErrIsamUpdate( ppib, pfucb, 0, 0, 0 ) );
				ul++;
				err = ErrIsamMove( ppib, pfucb, JET_MoveNext, 0 );
				if ( err < 0 && err != JET_errNoCurrentRecord )
					{
					goto HandleError;
					}
				}
			while ( err != JET_errNoCurrentRecord );

			/*	now ul has the correct value for the next autoinc field.
			/*	replace the value in the autoinc node in FDP
			/**/
			while ( PcsrCurrent( pfucb )->pcsrPath != NULL )
				{
				DIRUp( pfucb, 1 );
				}

			/*	go down to AutoIncrement node
			/**/
			DIRGotoFDPRoot( pfucb );
			Assert( dib.fFlags == fDIRNull );
			dib.pos = posDown;
			dib.pkey = pkeyAutoInc;
			err = ErrDIRDown( pfucb, &dib );
			if ( err != JET_errSuccess )
				{
				if ( err > 0 )
					{
					err = ErrERRCheck( JET_errDatabaseCorrupted );
					}
				Error( err, HandleError );
				}
			lineAutoInc.pb = (BYTE *)&ul;
			lineAutoInc.cb = sizeof(ul);
			CallS( ErrDIRReplace( pfucb, &lineAutoInc, fDIRNoVersion ) );
			}

		/*	leave currency as it was
		/**/
		Assert( PcsrCurrent( pfucb ) != NULL );
		while( PcsrCurrent( pfucb )->pcsrPath != NULL )
			{
			DIRUp( pfucb, 1 );
			}

		DIRBeforeFirst( pfucb );
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	if ( fMaxTruncated )
		return ErrERRCheck( JET_wrnColumnMaxTruncated );

	return JET_errSuccess;

HandleError:
	CallS( ErrDIRRollback( ppib ) );

	if ( fWriteLatchSet )
		FCBResetWriteLatch( pfcb, ppib );

	return err;
	}


ERR ErrRECDDLWaitTillOldest( FCB *pfcb, PIB *ppib )
	{
	ERR err;

	/*	if not for recovery, then we have to wait till no other cursor
	/*	can interfere us by wait it becomes the oldest transaction and
	/*	all the changes made by other cursor are versioned.
	/**/
	if ( !fRecovering )
		{
		if ( !FFCBDomainDenyReadByUs( pfcb, ppib ) )
			{
			if ( ppib->level > 1 )
				return JET_errInTransaction;

			FILEIWaitTillOldest( ppib->trxBegin0 );

			err = ErrDIRRefreshTransaction( ppib );

			if ( err < 0 )
				{
				return err;
				}
			}
		}

	return JET_errSuccess;
	}


//+API
// ErrIsamCreateIndex
// ========================================================================
// ERR ErrIsamCreateIndex(
//		PIB		*ppib;			// IN	PIB of user
//		FUCB  	*pfucb;   		// IN	Exclusively opened FUCB of file
//		CHAR  	*szName;  		// IN	name of index to define
//		ULONG 	ulFlags; 		// IN	index describing flags
//		CHAR    *szKey;  		// IN	index key string
//		ULONG 	cchKey;
//		ULONG 	ulDensity ); 	// IN	loading density of index
//
//	Defines an index on a file.
//
// PARAMETERS
//		ppib		PIB of user
//		pfucb		Exclusively opened FUCB of file
//		szName		name of index to define
//		ulFlags		index describing flags
//			VALUE				MEANING
//			========================================
//			JET_bitIndexPrimary		This index is to be the primary
//									index on the data file.  The file
//									must be empty, and there must not
//									already be a primary index.
//			JET_bitIndexUnique		Duplicate entries are not allowed.
//			JET_bitIndexIgnoreNull	Null keys are not to be indexed.
//			ulDensity				load density of index
//
// RETURNS	Error code from DIRMAN or
//			JET_errSuccess			Everything worked OK.
//			-JET_errColumnNotFound 	The index key specified
//									contains an undefined field.
//			-IndexHasPrimary 		The primary index for this
//							 		Insertfile is already defined.
// 			-IndexDuplicate  		An index on this file is
//	   								already defined with the
//									given name.
// 			-IndexInvalidDef 		There are too many segments
//							 		in the key.
// 			-TableNotEmpty	 		A primary index may not be
// 									defined because there is at
// 									least one record already in
// 									the file.
// COMMENTS
//		If transaction level > 0, there must not be anyone currently
//		using the file.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//
// SEE ALSO		ErrIsamAddColumn, ErrIsamCreateTable
//-
ERR VTAPI ErrIsamCreateIndex(
	PIB					*ppib,
	FUCB				*pfucbTable,
	CHAR				*szName,
	ULONG				grbit,
	CHAR				*szKey,
	ULONG				cchKey,
	ULONG				ulDensity )
	{
	ERR					err;
	CHAR				szIndex[ (JET_cbNameMost + 1) ];
	FCB				 	*pfcbIdx = pfcbNil;
	BYTE				cFields, iidxseg;
	char				*rgsz[JET_ccolKeyMost];
	const BYTE			*pb;
	BYTE				rgfbDescending[JET_ccolKeyMost];
	FID					fid, rgKeyFldIDs[JET_ccolKeyMost];
	KEY					keyIndex;
	BYTE				rgbIndexNorm[ JET_cbKeyMost ];
	FCB					*pfcb;
	BOOL				fVersion;
	OBJID				objidTable;
	LANGID				langid = 0;
	BYTE				fLangid = fFalse;
	SHORT				fidb;
	BOOL				fClustered		= grbit & JET_bitIndexClustered;
	BOOL				fPrimary		= grbit & JET_bitIndexPrimary;
	BOOL				fUnique			= grbit & (JET_bitIndexUnique | JET_bitIndexPrimary);
	BOOL				fDisallowNull	= grbit & (JET_bitIndexDisallowNull | JET_bitIndexPrimary);
	BOOL				fIgnoreNull		= grbit & JET_bitIndexIgnoreNull;
	BOOL				fIgnoreAnyNull	= grbit & JET_bitIndexIgnoreAnyNull;
	BOOL				fIgnoreFirstNull= grbit & JET_bitIndexIgnoreFirstNull;
	FUCB				*pfucb;
	BOOL				fSys;
	BOOL				fTemp;
	DBID				dbid;
	PGNO				pgnoIndexFDP;
	IDB					idb;
	BOOL				fWriteLatchSet = fFalse;
	USHORT				cbVarSegMac = JET_cbKeyMost;

	/*	check parms
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbTable );

	if ( !FFUCBDenyRead( pfucbTable ) && ppib->level != 0 )
		{
		return ErrERRCheck( JET_errNotInTransaction );
		}

	/*	check index name
	/**/
	CallR( ErrUTILCheckName( szIndex, szName, (JET_cbNameMost + 1) ) );

	/*	ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucbTable ) );

	/*	fix up the dbid.  Note that adding dbidMax to actual dbid
	/*	is the method used to indicate creation of system tables.
	/**/
	dbid = pfucbTable->dbid;
	if ( dbid >= dbidMax )
		{
		dbid -= dbidMax;
		}

	CallR( ErrDIROpen( ppib, pfucbTable->u.pfcb, dbid, &pfucb ) );
	FUCBSetIndex( pfucb );

	/*	do not allow clustered indexes with any Ignore bits on
	/**/
	if ( fClustered && ( fIgnoreNull || fIgnoreAnyNull || fIgnoreFirstNull ) )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		goto CloseFUCB;
		}

	/*	set fSys and fix DBID
	/**/
	if ( fSys = ( pfucbTable->dbid >= dbidMax ) )
		{
		pfucbTable->dbid -= dbidMax;
		Assert( pfucb->dbid == pfucbTable->dbid );
		}

	fTemp = FFCBTemporaryTable( pfucb->u.pfcb );

	Assert( !FFUCBNonClustered( pfucb ) );

	/*	check index description for required format.
	/**/
	if ( cchKey == 0 )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		goto CloseFUCB;
		}
	if ( ( szKey[0] != '+' && szKey[0] != '-' ) ||
		szKey[cchKey - 1] != '\0' ||
		szKey[cchKey - 2] != '\0' )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		goto CloseFUCB;
		}
	Assert( szKey[cchKey - 1] == '\0' );
	Assert( szKey[cchKey - 2] == '\0' );

	Assert( pfucb->u.pfcb != pfcbNil );
	pfcb = pfucb->u.pfcb;
	if ( ulDensity == 0 )
		ulDensity = ulFILEDefaultDensity;
	if ( ulDensity < ulFILEDensityLeast || ulDensity > ulFILEDensityMost )
		{
		err = ErrERRCheck( JET_errDensityInvalid );
		goto CloseFUCB;
		}

	cFields = 0;
	pb = szKey;
	while ( *pb != '\0' )
		{
		if ( cFields >= JET_ccolKeyMost )
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			goto CloseFUCB;
			}
		if ( *pb == '-' )
			{
			rgfbDescending[cFields] = 1;
			pb++;
			}
		else
			{
			rgfbDescending[cFields] = 0;
			if ( *pb == '+' )
				pb++;
			}
		rgsz[cFields++] = (char *) pb;
		pb += strlen( pb ) + 1;
		}
	if ( cFields < 1 )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		goto CloseFUCB;
		}

	/*	number of columns should not exceed maximum
	/**/
	Assert( cFields <= JET_ccolKeyMost );

	/*	get locale from end of szKey if present
	/**/
	pb++;
	Assert( pb > szKey );
	if ( (unsigned)( pb - szKey ) < cchKey )
		{
		if ( pb - szKey + sizeof(LANGID) + 2 * sizeof(BYTE) == cchKey )
			{
			langid = *((LANGID UNALIGNED *)(pb));
			CallJ( ErrUtilCheckLangid( &langid ), CloseFUCB );
			fLangid = fTrue;
			}
		else if ( pb - szKey + sizeof(LANGID) + 2 * sizeof(BYTE) + sizeof(BYTE) + 2 == cchKey )
			{
			langid = *((LANGID UNALIGNED *)(pb));
			CallJ( ErrUtilCheckLangid( &langid ), CloseFUCB );
			fLangid = fTrue;
			cbVarSegMac = *(pb + sizeof(LANGID) + 2 * sizeof(BYTE));
			if ( cbVarSegMac == 0 || cbVarSegMac > JET_cbKeyMost )
				{
				err = ErrERRCheck( JET_errIndexInvalidDef );
				goto CloseFUCB;
				}
			}
		else
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			goto CloseFUCB;
			}
		}

	/*	return an error if this is a second primary index definition
	/**/
	if ( fPrimary )
		{
		FCB *pfcbNext = pfcb;

		while ( pfcbNext != pfcbNil )
			{
			if ( pfcbNext->pidb != pidbNil && ( pfcbNext->pidb->fidb & fidbPrimary ) )
				{
				/*	if that primary index is not already deleted transaction
				/*	but not yet committed.
				/**/
				if ( !FFCBDeletePending( pfcbNext ) )
					{
					err = ErrERRCheck( JET_errIndexHasPrimary );
					goto CloseFUCB;
					}
				else
					{
					/*	there can only be one primary index
					/**/
					break;
					}
				}
			Assert( pfcbNext != pfcbNext->pfcbNextIndex );
			pfcbNext = pfcbNext->pfcbNextIndex;
			}
		}

	/*	wait for bookmark cleanup and on-going replace/insert.
	/*	UNDONE: decouple operation from other index creations
	/**/
	while ( FFCBReadLatch( pfcb ) )
		{
		BFSleep( cmsecWaitGeneric );
		}

	/*	set DenyDDL to stop update/replace operations
	/**/
	if ( FFCBWriteLatch( pfcb, ppib ) )
		{
		/*	abort if DDL modification in progress
		/**/
		err = ErrERRCheck( JET_errWriteConflict );
		goto CloseFUCB;
		}
	FCBSetWriteLatch( pfcb, ppib );
	fWriteLatchSet = fTrue;

	/*	normalize index name and set key
	/**/
	UtilNormText( szIndex, strlen(szIndex), rgbIndexNorm, sizeof(rgbIndexNorm), &keyIndex.cb );
	keyIndex.pb = rgbIndexNorm;

	err = ErrDIRBeginTransaction( ppib );
	if ( err < 0 )
		{
		goto CloseFUCB;
		}

	/*	allocate FCB for index
	/**/
	pfcbIdx = NULL;
	if ( !fClustered )
		{
		err = ErrFCBAlloc( ppib, &pfcbIdx );
		if ( err < 0 )
			{
			goto HandleError;
			}
		}

	/*	create index is flagged in version store so that
	/*	DDL will be undone.  If flag fails then pfcbIdx
	/*	must be released.
	/**/
	err = ErrVERFlag( pfucb, operCreateIndex, &pfcbIdx, sizeof(pfcbIdx) );
	if ( err < 0 )
		{
		if ( !fClustered )
			{
			Assert( pfcbIdx != NULL );
			Assert( pfcbIdx->cVersion == 0 );
			MEMReleasePfcb( pfcbIdx );
			}
		goto HandleError;
		}

	/*	write latch will be reset by either commit or rollback after VERFlag
	/**/
	fWriteLatchSet = fFalse;

	Call( ErrRECDDLWaitTillOldest( pfcb, ppib ) );

	/*	move to FDP root
	/**/
	DIRGotoFDPRoot( pfucb );

	/*	get FID for each field
	/**/
	for ( iidxseg = 0 ; iidxseg < cFields; ++iidxseg )
		{
		JET_COLUMNID	columnidT;
		
		err = ErrFILEGetColumnId( ppib, pfucb, rgsz[iidxseg], &columnidT );
		fid = ( FID ) columnidT;
		
		if ( err < 0 )
			{
			goto HandleError;
			}
		rgKeyFldIDs[iidxseg] = rgfbDescending[iidxseg] ? -fid : fid;
		}

	/*	for temporary tables, check FCB's for duplicate.  For system tables,
	/*	we assume we're smart enough not to add duplicates.  For user tables,
	/*	catalog will detect duplicates.
	/**/
	if ( fTemp )
		{
		if ( PfcbFCBFromIndexName( pfcb, szIndex ) != pfcbNil )
			{
			err = ErrERRCheck( JET_errIndexDuplicate );
			goto HandleError;
			}
		}

	/*	currently on Table FDP
	/**/
	if ( fClustered )
		{
		/*	check for clustered index
		/**/
		if ( pfcb->pidb != pidbNil )
			{
			err = ErrERRCheck( JET_errIndexHasClustered );
			goto HandleError;
			}

		/*	clustered indexes are in same FDP as table
		/**/
		pgnoIndexFDP = pfcb->pgnoFDP;
		Assert( pgnoIndexFDP == PcsrCurrent(pfucb)->pgno );;

		fVersion = fDIRVersion;
		}
	else
		{
		Call( ErrDIRCreateDirectory( pfucb, (CPG)0, &pgnoIndexFDP ) );
		Assert( pgnoIndexFDP != pfcb->pgnoFDP );

		fVersion = fDIRNoVersion;
		}
	
	/*	clustered index definition
	/**/
	if ( fClustered
#ifdef DEBUG
		|| ( grbit & JET_bitIndexEmptyTable )
#endif
		)
		{
		DIB dib;

		/*	check for records
		/**/
		DIRGotoDataRoot( pfucb );
		Call( ErrDIRGet( pfucb ) );

		dib.fFlags = fDIRNull;
		dib.pos = posFirst;
		if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errRecordNotFound )
			{
			if ( err == JET_errSuccess )
				{
				err = ErrERRCheck( JET_errTableNotEmpty );
				}
			goto HandleError;
			}

		DIRGotoFDPRoot( pfucb );
		}

	Assert( pgnoIndexFDP > pgnoSystemRoot );
	Assert( pgnoIndexFDP <= pgnoSysMax );

	fidb = 0;
	if ( !fDisallowNull && !fIgnoreAnyNull )
		{	   	
		fidb |= fidbAllowSomeNulls;
		if ( !fIgnoreFirstNull )
			fidb |= fidbAllowFirstNull;
		if ( !fIgnoreNull )
			fidb |= fidbAllowAllNulls;
		}
	fidb |= (fUnique ? fidbUnique : 0)
		| (fPrimary ? fidbPrimary : 0)
		| (fClustered ? fidbClustered : 0)
		| (fDisallowNull ? fidbNoNullSeg : 0)
		| (fLangid ? fidbLangid : 0);
	Assert( fidb == FidbFILEOfGrbit( grbit, fLangid ) );

	objidTable = pfcb->pgnoFDP;

	/*	insert index record into MSysIndexes before committing
	/**/
	if ( !fSys && !fTemp )
		{
		LINE	rgline[ilineSxMax];

		rgline[iMSI_ObjectId].pb			= (BYTE *)&objidTable;
		rgline[iMSI_ObjectId].cb			= sizeof(objidTable);
		rgline[iMSI_Name].pb				= szIndex;
		rgline[iMSI_Name].cb				= strlen(szIndex);
		rgline[iMSI_IndexId].pb				= (BYTE *)&pgnoIndexFDP;
		rgline[iMSI_IndexId].cb				= sizeof(pgnoIndexFDP);
		rgline[iMSI_Density].pb				= (BYTE *)&ulDensity;
		rgline[iMSI_Density].cb				= sizeof(ulDensity);
		rgline[iMSI_LanguageId].pb			= (BYTE *)&langid;
		rgline[iMSI_LanguageId].cb			= sizeof(langid);
		rgline[iMSI_Flags].pb				= (BYTE *)&fidb;
		rgline[iMSI_Flags].cb				= sizeof(fidb);
		rgline[iMSI_KeyFldIDs].pb 			= (BYTE *)rgKeyFldIDs;
		rgline[iMSI_KeyFldIDs].cb 			= cFields * sizeof(FID);
		rgline[iMSI_Stats].cb				= 0;
		Assert( cbVarSegMac <= JET_cbKeyMost );
		if ( cbVarSegMac < JET_cbKeyMost )
			{
			rgline[iMSI_VarSegMac].pb 	   	= (BYTE *)&cbVarSegMac;
			rgline[iMSI_VarSegMac].cb 	   	= sizeof(cbVarSegMac);
			}
		else
			{
			rgline[iMSI_VarSegMac].cb 	   	= 0;
			}

		err = ErrCATInsert( ppib, dbid, itableSi, rgline, objidTable );
		if ( err < 0 )
			{
			if ( err == JET_errKeyDuplicate )
				{
				err = ErrERRCheck( JET_errIndexDuplicate );
				}
			goto HandleError;
			}
		}

	idb.langid = langid;
	Assert( cbVarSegMac > 0 && cbVarSegMac <= 255 );
	idb.cbVarSegMac = (BYTE)cbVarSegMac;
	idb.fidb = fidb;
	idb.iidxsegMac = cFields;
	strcpy( idb.szName, szIndex );
	memcpy( idb.rgidxseg, rgKeyFldIDs, cFields * sizeof(FID) );

	if ( fClustered )
		{
		Call( ErrFILEIGenerateIDB( pfcb, (FDB *) pfcb->pfdb, &idb ) );
		Assert( pfcb->pgnoFDP == pgnoIndexFDP );
		Assert( ((( 100 - ulDensity ) * cbPage ) / 100) < cbPage );
		pfcb->cbDensityFree = (SHORT)( ( ( 100 - ulDensity ) * cbPage ) / 100 );

		/*	set currency to before first
		/**/
		DIRBeforeFirst( pfucb );
		}
	else
		{
		/*	make an FCB for this index
		/**/
		Call( ErrFILEINewFCB(
			ppib,
			dbid,
			(FDB *)pfcb->pfdb,
			&pfcbIdx,
			&idb,
			fFalse,
			pgnoIndexFDP,
			ulDensity ) );

		/*	link new FCB
		/**/
		pfcbIdx->pfcbNextIndex = pfcb->pfcbNextIndex;
		pfcb->pfcbNextIndex = pfcbIdx;
		pfcbIdx->pfcbTable = pfcb;

		/*	only build the index if necessary. There is an assert
		/*	above to ensure that the table is indeed empty.
		/**/
		if ( !( grbit & JET_bitIndexEmptyTable ) )
			{
			/*	move to before first, then build the index.
			/**/
			DIRBeforeFirst( pfucb );
			Call( ErrFILEBuildIndex( ppib, pfucb, szIndex ) );
			}
		}

	Assert( FFCBWriteLatchByUs( pfcb, ppib ) );

	/*	update all index mask
	/**/
	FILESetAllIndexMask( pfcb );
	
	Call( ErrDIRCommitTransaction( ppib, (grbit & JET_bitIndexLazyFlush ) ? JET_bitCommitLazyFlush : 0 ) );

	DIRClose( pfucb );

	return err;

HandleError:
	CallS( ErrDIRRollback( ppib ) );

CloseFUCB:
	/*	if write latch was not reset in commit/rollback, and it was
	/*	set, then reset it.
	/**/
	if ( fWriteLatchSet )
		{
		FCBResetWriteLatch( pfcb, ppib );
		}

	DIRClose( pfucb );
	return err;
	}


//+API
// BuildIndex
// ========================================================================
// ERR BuildIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
//
// Builds a new index for a file from scratch;  szIndex gives the
// name of an index definition.
//
// PARAMETERS	ppib						PIB of user
//		   		pfucb						Exclusively opened FUCB on file
//		   		szIndex 					name of index to build
//
// RETURNS		Error code from DIRMAN or SORT or
//					JET_errSuccess	  		Everything worked OK.
//					IndexCantBuild			The index name specfied refers
//		   									to the primary index.
// COMMENTS
//			A transaction is wrapped around this function at the callee.
//
// SEE ALSO		ErrIsamCreateIndex
//-
ERR ErrFILEBuildIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
	{
	ERR	  	err;
	CHAR   	szIdxOrig[JET_cbNameMost + 1];
	INT		fDIRFlags;
	INT		fDIRWithBackToFather;
	FUCB   	*pfucbIndex = pfucbNil;
	FUCB   	*pfucbSort = pfucbNil;
	DIB	  	dib;
	FDB	  	*pfdb;
	IDB	  	*pidb;
	LINE   	rgline[2];
	BYTE   	rgbKey[JET_cbKeyMost];
	SRID   	sridData;
	ULONG  	itagSequence;
	FCB	  	*pfcb;
	BOOL   	fNoNullSeg;
	BOOL   	fAllowNulls;
	BOOL   	fAllowFirstNull;
	BOOL   	fAllowSomeNulls;
	INT		fUnique;
	LONG   	cRecInput = 0;
	LONG   	cRecOutput = 0;
	INT		fOldSeq;
	SRID	sridPrev;

	pfcb = pfucb->u.pfcb;
	fOldSeq = FFUCBSequential( pfucb );

	CallS( ErrIsamGetCurrentIndex(ppib, pfucb, szIdxOrig, sizeof( szIdxOrig ) ) );
	Call( ErrRECSetCurrentIndex( pfucb, szIndex ) );
	pfucbIndex = pfucb->pfucbCurIndex;
	if ( pfucbIndex == pfucbNil )
		{
		err = ErrERRCheck( JET_errIndexCantBuild );
		goto HandleError;
		}
	pfdb = (FDB *)pfcb->pfdb;
	pidb = pfucbIndex->u.pfcb->pidb;
	fNoNullSeg = ( pidb->fidb & fidbNoNullSeg ) ? fTrue : fFalse;
	fAllowNulls = ( pidb->fidb & fidbAllowAllNulls ) ? fTrue : fFalse;
	fAllowFirstNull = ( pidb->fidb & fidbAllowFirstNull ) ? fTrue : fFalse;
	fAllowSomeNulls = ( pidb->fidb & fidbAllowSomeNulls ) ? fTrue : fFalse;
	fUnique = ( pidb->fidb & fidbUnique ) ? fSCBUnique : 0;

	/*  set FUCB to sequential mode for a more efficient scan during build
	/**/
	FUCBSetSequential( pfucb );

	/*	directory manager flags
	/**/
	fDIRFlags = fDIRNoVersion | fDIRAppendItem | ( fUnique ? 0 : fDIRDuplicate );
	fDIRWithBackToFather = fDIRFlags | fDIRBackToFather;

	/*	open sort
	/**/
	Call( ErrSORTOpen( ppib, &pfucbSort, fSCBIndex|fUnique ) );
	rgline[0].pb = rgbKey;
	rgline[1].cb = sizeof(SRID);
	rgline[1].pb = (BYTE *)&sridData;

	/*	build up new index in a sort file
	/**/
	dib.fFlags = fDIRNull;
	forever
		{
		err = ErrDIRNext( pfucb, &dib );
	   	if ( err < 0 )
			{
			if ( err == JET_errNoCurrentRecord )
				break;
			goto HandleError;
			}

//		Call( ErrDIRGet( pfucb ) );
		DIRGetBookmark( pfucb, &sridData );

		for ( itagSequence = 1; ; itagSequence++ )
			{
			KEY *pkey = &rgline[0];

			Call( ErrRECRetrieveKeyFromRecord( pfucb,
				pfdb,
				pidb,
				pkey,
				itagSequence,
				fFalse ) );
			Assert( err == wrnFLDOutOfKeys ||
				err == wrnFLDNullKey ||
				err == wrnFLDNullFirstSeg ||
				err == wrnFLDNullSeg ||
				err == JET_errSuccess );

			if ( err > 0 )
				{
				if ( err == wrnFLDOutOfKeys )
					{
					Assert( itagSequence > 1 );
					break;
					}

				if ( fNoNullSeg && ( err == wrnFLDNullSeg || err == wrnFLDNullFirstSeg || err == wrnFLDNullKey ) )
					{
					err = ErrERRCheck( JET_errNullKeyDisallowed );
					goto HandleError;
					}

				if ( err == wrnFLDNullKey )
					{
					if ( fAllowNulls )
						{
						Call( ErrSORTInsert( pfucbSort, rgline ) );
						cRecInput++;
						}
					break;
					}
				else
					{
					/*	do not insert keys with NULL first segment as indicated
					/**/
					if ( err == wrnFLDNullFirstSeg && !fAllowFirstNull )
						{
						break;
						}
					else
						{
						/*	do not insert keys with null segment as indicated
						/**/
						if ( err == wrnFLDNullSeg && !fAllowSomeNulls )
							{
							break;
							}
						}
					}
				}

			Call( ErrSORTInsert( pfucbSort, rgline ) );
			cRecInput++;

			if ( !( pidb->fidb & fidbHasMultivalue ) )
				{
				break;
				}

			/*	currency may have been lost so refresh record for
			/*	next tagged column
			/**/
			Call( ErrDIRGet( pfucb ) );
			}
		}
	Call( ErrSORTEndInsert( pfucbSort ) );

	/*	transfer index entries to actual index
	/*	insert first one in normal method!
	/**/
	if ( ( err = ErrSORTNext( pfucbSort ) ) == JET_errNoCurrentRecord )
		goto Done;
	if ( err < 0 )
		goto HandleError;
	cRecOutput++;

	/*	move to FDP root
	/**/
	DIRGotoDataRoot( pfucbIndex );
	Call( ErrDIRInsert( pfucbIndex, &pfucbSort->lineData,
		&pfucbSort->keyNode, fDIRFlags ) );
	sridPrev = *(SRID UNALIGNED *)pfucbSort->lineData.pb;

	Call( ErrDIRInitAppendItem( pfucbIndex ) );

	Assert( dib.fFlags == fDIRNull );
	dib.pos = posLast;

	/*	from now on, try short circuit first
	/**/
	forever
		{
		err = ErrSORTNext( pfucbSort );
		if ( err == JET_errNoCurrentRecord )
			break;
		if ( err < 0 )
			goto HandleError;
		cRecOutput++;
		err = ErrDIRAppendItem( pfucbIndex, &pfucbSort->lineData, &pfucbSort->keyNode, sridPrev );
		sridPrev = *(SRID UNALIGNED *)pfucbSort->lineData.pb;
		if ( err < 0 )
			{
			if ( err == errDIRNoShortCircuit )
				{
				DIRUp( pfucbIndex, 1 );
				Call( ErrDIRInsert( pfucbIndex,
					&pfucbSort->lineData,
					&pfucbSort->keyNode,
					fDIRFlags ) );
				/*	leave currency on inserted item list for
				/*	next in page item append.
				/**/
				}
			else
				goto HandleError;
			}
		}

	Call( ErrDIRTermAppendItem( pfucbIndex ) );

	if ( fUnique && cRecOutput < cRecInput )
		{
		err = ErrERRCheck( JET_errKeyDuplicate );
		goto HandleError;
		}

Done:
	Call( ErrSORTClose( pfucbSort ) );
	(VOID) ErrRECSetCurrentIndex( pfucb, szIdxOrig );
	if ( !fOldSeq )
		FUCBResetSequential( pfucb );
	return JET_errSuccess;

HandleError:
	if ( pfucbIndex != pfucbNil && pfucbIndex->pbfWorkBuf != pbfNil )
		{
		BFSFree(pfucbIndex->pbfWorkBuf);
		pfucbIndex->pbfWorkBuf = pbfNil;
		}
	if ( pfucbSort != pfucbNil )
		{
		(VOID) ErrSORTClose( pfucbSort );
		}
	(VOID) ErrRECSetCurrentIndex( pfucb, NULL );
	(VOID) ErrRECSetCurrentIndex( pfucb, szIdxOrig );
	if ( !fOldSeq )
		FUCBResetSequential( pfucb );
	return err;
	}


//+API
// ErrIsamDeleteTable
// ========================================================================
// ERR ErrIsamDeleteTable( JET_VSESID vsesid, JET_VDBID vdbid, CHAR *szName )
//
// Calls ErrFILEIDeleteTable to
// delete a file and all indexes associated with it.
//
// RETURNS		JET_errSuccess or err from called routine.
//
// SEE ALSO		ErrIsamCreateTable
//-
ERR VTAPI ErrIsamDeleteTable( JET_VSESID vsesid, JET_VDBID vdbid, CHAR *szName )
	{
	ERR		err;
	PIB		*ppib = (PIB *)vsesid;
	DBID	dbid;
	CHAR	szTable[(JET_cbNameMost + 1)];
	PGNO	pgnoFDP = 0;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	CallR( VDbidCheckUpdatable( vdbid ) );
	dbid = DbidOfVDbid (vdbid);
	CallR( ErrUTILCheckName( szTable, szName, (JET_cbNameMost + 1) ) );

	if ( dbid != dbidTemp )
		{
		JET_OBJTYP	objtyp;

		err = ErrCATFindObjidFromIdName( ppib, dbid, objidTblContainer, szTable, &pgnoFDP, &objtyp );
		if ( err < 0 )
			{
			return err;
			}
		else
			{
			if ( objtyp == JET_objtypQuery || objtyp == JET_objtypLink )
				{
				err = ErrIsamDeleteObject( (JET_SESID)ppib, vdbid, (OBJID)pgnoFDP );
				return err;
				}
			}
		}
	else
		{
		FUCB *pfucbT;

		AssertSz( 0, "Cannot use DeleteTable to remove temporary tables. Use CloseTable instead." );

		// User wants to delete a temp table.  Find it in his list of open cursors
		Assert( dbid == dbidTemp );
		for ( pfucbT = ppib->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNext )
			{
			if ( FFCBTemporaryTable( pfucbT->u.pfcb )  &&
				UtilCmpName( szTable, pfucbT->u.pfcb->szFileName ) )
				{
				pgnoFDP = pfucbT->u.pfcb->pgnoFDP;
				}				
			}
		if ( pfucbT == pfucbNil )
			{
			Assert( pgnoFDP == 0 );		// pgnoFDP never got set.
			return ErrERRCheck( JET_errObjectNotFound );
			}
		}

	err = ErrFILEDeleteTable( ppib, dbid, szTable, pgnoFDP );
	return err;
	}


// ErrFILEDeleteTable
// ========================================================================
// ERR ErrFILEDeleteTable( PIB *ppib, DBID dbid, CHAR *szName )
//
// Deletes a file and all indexes associated with it.
//
// RETURNS		JET_errSuccess or err from called routine.
//

// COMMENTS
//	Acquires an exclusive lock on the file [FCBSetDelete].
//	A transaction is wrapped around this function.	Thus,
//	any work done will be undone if a failure occurs.
//	Transaction logging is turned off for temporary files.
//
// SEE ALSO		ErrIsamCreateTable
//-
ERR ErrFILEDeleteTable( PIB *ppib, DBID dbid, CHAR *szTable, PGNO pgnoFDP )
	{
	ERR   	err;
	FUCB  	*pfucb = pfucbNil;
	FCB	  	*pfcb;
	FCB	  	*pfcbT;
	BOOL  	fWriteLatchSet = fFalse;

	CheckPIB( ppib );
	CheckDBID( ppib, dbid );

	CallR( ErrDIRBeginTransaction( ppib ) );

	/*	open cursor on database and seek to table without locking
	/**/
	Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) );

	Call( ErrFCBSetDeleteTable( ppib, dbid, pgnoFDP ) );

    pfcb = PfcbFCBGet( dbid, pgnoFDP );
    Assert( pfcb != pfcbNil );

    /*	wait for other domain operation
    /**/
    while ( FFCBReadLatch( pfcb ) )
        {
        BFSleep( cmsecWaitGeneric );
        }

	/*	abort if index is being built on file
	/**/
	if ( FFCBWriteLatch( pfcb, ppib ) )
		{
		err = ErrERRCheck( JET_errWriteConflict );
		goto HandleError;
		}

	FCBSetWriteLatch( pfcb, ppib );
	fWriteLatchSet = fTrue;

	err = ErrVERFlag( pfucb, operDeleteTable, &pgnoFDP, sizeof(pgnoFDP) );
	if ( err < 0 )
		{
		FCBResetDeleteTable( pfcb );
		goto HandleError;
		}
	/*	write latch will be reset by either commit or rollback after VERFlag
	/**/
	fWriteLatchSet = fFalse;

	Call( ErrDIRDeleteDirectory( pfucb, pgnoFDP ) );

	/*	remove MPL entries for this table and all indexes
	/**/
	Assert( pfcb->pgnoFDP == pgnoFDP );
	for ( pfcbT = pfcb; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		{
		Assert( dbid == pfcbT->dbid );
		MPLPurgeFDP( dbid, pfcbT->pgnoFDP );
		FCBSetDeletePending( pfcbT );
		}

	DIRClose( pfucb );
	pfucb = pfucbNil;

	/*	remove table record from MSysObjects before committing.
	/*	Also remove associated columns and indexes in MSC/MSI.
	/*	Pass 0 for tblid; MSO case in STD figures it out.
	/**/
	if ( dbid != dbidTemp )
		{
		Call( ErrCATDelete( ppib, dbid, itableSo, szTable, 0 ) );
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	return err;

HandleError:
	if ( pfucb != pfucbNil )
		DIRClose( pfucb );

	CallS( ErrDIRRollback( ppib ) );
	
	if ( fWriteLatchSet )
		FCBResetWriteLatch( pfcb, ppib );

	return err;
	}


//+API
// DeleteIndex
// ========================================================================
// ERR DeleteIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
//
// Deletes an index definition and all index entries it contains.
//
// PARAMETERS	ppib						PIB of user
// 				pfucb						Exclusively opened FUCB on file
// 				szName						name of index to delete
// RETURNS		Error code from DIRMAN or
//					JET_errSuccess		  	 Everything worked OK.
//					-TableInvalid			 There is no file corresponding
// 											 to the file name given.
//					-TableNoSuchIndex		 There is no index corresponding
// 											 to the index name given.
//					-IndexMustStay			 The clustered index of a file may
// 											 not be deleted.
// COMMENTS
//		There must not be anyone currently using the file.
//		A transaction is wrapped around this function.	Thus,
//		any work done will be undone if a failure occurs.
//		Transaction logging is turned off for temporary files.
// SEE ALSO		DeleteTable, CreateTable, CreateIndex
//-
ERR VTAPI ErrIsamDeleteIndex( PIB *ppib, FUCB *pfucbTable, CHAR *szName )
	{
	ERR		err;
	CHAR	szIndex[ (JET_cbNameMost + 1) ];
	BYTE	rgbIndexNorm[ JET_cbKeyMost ];
	KEY		key;
	FCB		*pfcb;
	FCB		*pfcbIdx;
	FUCB	*pfucb;
	BOOL	fWriteLatchSet = fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbTable );
	CallR( ErrUTILCheckName( szIndex, szName, ( JET_cbNameMost + 1 ) ) );

	/*	ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucbTable )  );

	Assert( ppib != ppibNil );
	Assert( pfucbTable != pfucbNil );
	Assert( pfucbTable->u.pfcb != pfcbNil );
	pfcb = pfucbTable->u.pfcb;

	/*	normalize index and set key to normalized index
	/**/
	UtilNormText( szIndex, strlen(szIndex), rgbIndexNorm, sizeof(rgbIndexNorm), &key.cb );
	key.pb = rgbIndexNorm;

	/*	create new cursor -- to leave user's cursor unmoved
	/**/
	CallR( ErrDIROpen( ppib, pfucbTable->u.pfcb, pfucbTable->dbid, &pfucb ) );

	/*	wait for bookmark cleanup and on-going replace/insert.
	/*	UNDONE: decouple operation from other index creations
	/**/
	while ( FFCBReadLatch( pfcb ) )
		{
		BFSleep( cmsecWaitGeneric );
		}

	/*	abort if DDL is being done on file
	/**/
	if ( FFCBWriteLatch( pfcb, ppib ) )
		{
		err = ErrERRCheck( JET_errWriteConflict );
		goto CloseFUCB;
		}
	FCBSetWriteLatch( pfcb, ppib );
	fWriteLatchSet = fTrue;

	err = ErrDIRBeginTransaction( ppib );
	if ( err < 0 )
		{
		goto CloseFUCB;
		}

	/*	cannot delete clustered index
	/**/
	if ( pfcb->pidb != pidbNil && UtilCmpName( szIndex, pfcb->pidb->szName ) == 0 )
		{
		err = ErrERRCheck( JET_errIndexMustStay );
		goto HandleError;
		}

	/*	flag delete index
	/**/
	pfcbIdx = PfcbFCBFromIndexName( pfcb, szIndex );
	if ( pfcbIdx == NULL )
		{
#if 0
		// UNDONE:	This case goes away when the data structures
		//			are versioned also.
		//			This case means basically, that another session
		//			has changed this index BUT has not committed to level 0
		//			BUT has changed the RAM data structures.
		err = ErrERRCheck( JET_errWriteConflict );
#endif
		err = ErrERRCheck( JET_errIndexNotFound );
		goto HandleError;
		}

	err = ErrFCBSetDeleteIndex( ppib, pfcb, szIndex );
	if ( err < 0 )
		{
		goto HandleError;
		}

	err = ErrVERFlag( pfucb, operDeleteIndex, &pfcbIdx, sizeof(pfcbIdx) );
	if ( err < 0 )
		{
		FCBResetDeleteIndex( pfcbIdx );
		goto HandleError;
		}
	/*	write latch will be reset by either commit or rollback after VERFlag
	/**/
	fWriteLatchSet = fFalse;

	/*	wait until we are the oldest
	/**/
	Call( ErrRECDDLWaitTillOldest( pfcb, ppib ) );

	/*	purge MPL entries -- must be done after FCBSetDeletePending
	/**/
	MPLPurgeFDP( pfucb->dbid, pfcbIdx->pgnoFDP );

	/*	assert not deleting current non-clustered index
	/**/
	Assert( pfucb->pfucbCurIndex == pfucbNil ||
		UtilCmpName( szIndex, pfucb->pfucbCurIndex->u.pfcb->pidb->szName ) != 0 );

	Call( ErrDIRDeleteDirectory( pfucb, pfcbIdx->pgnoFDP ) );

	/*	remove index record from MSysIndexes before committing...
	/**/
	if ( pfucb->dbid != dbidTemp )
		{
		Call( ErrCATDelete( ppib, pfucb->dbid, itableSi, szIndex, pfucb->u.pfcb->pgnoFDP ) );
		}

	/*	update all index mask
	/**/
	FILESetAllIndexMask( pfcb );

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	/*	set currency to before first
	/**/
	DIRBeforeFirst( pfucb );
	DIRClose( pfucb );
 	return JET_errSuccess;

HandleError:
	CallS( ErrDIRRollback( ppib ) );

CloseFUCB:
	if ( fWriteLatchSet )
		FCBResetWriteLatch( pfcb, ppib );

	DIRClose( pfucb );
	return err;
	}


/*	determines if a column is part of an index
/**/
LOCAL BOOL FFILEIsIndexColumn( FCB *pfcbIndex, FID fid )
	{
	BYTE		iidxseg;
	IDXSEG		idxseg;
	
	while ( pfcbIndex != pfcbNil )
		{
		if ( pfcbIndex->pidb != NULL )
			{
			for ( iidxseg = 0; iidxseg < pfcbIndex->pidb->iidxsegMac; iidxseg++ )
				{
				idxseg = pfcbIndex->pidb->rgidxseg[iidxseg];
				if ( idxseg < 0 )
					idxseg = -idxseg;

				// UNDONE: IDXSEG is signed, FID is not
				if ( (FID)idxseg == fid )
					{
					/*	found the column in an index
					/**/
					return fTrue;
					}
				}
			}

		/*	the pointer pfcbIndex is passed by value, so modifying
		/*	it here will not affect the caller version of pfcbIndex.
		/**/
		pfcbIndex = pfcbIndex->pfcbNextIndex;
		}

	/*	column not in any indexes
	/**/
	return fFalse;
	}


ERR ErrFILEICheckIndexColumn( FCB *pfcbIndex, FID fid )
	{
	ERR err;

	if ( FFILEIsIndexColumn( pfcbIndex, fid ) )
		{
		// UNDONE:  Found the column.  but it may belong to an index which is
		// going to be deleted.  See if we can clean up and double-check.
		// Will still return erroneous results if the DeleteIndex was not
		// committed, or if the oldest transaction before the DeleteIndex was
		// not commited.  Ideally, we want to version DDL info and avoid this
		// kludge altogether.
		Call( ErrRCECleanAllPIB() );
		err = ( FFILEIsIndexColumn( pfcbIndex, fid ) ?
			JET_errSuccess : ErrERRCheck( JET_errColumnNotFound ) );
		}
	else
		err = ErrERRCheck( JET_errColumnNotFound );

HandleError:
	Assert( err <= JET_errSuccess );	// Shouldn't return warnings.
	return err;
	}


ERR VTAPI ErrIsamDeleteColumn( PIB *ppib, FUCB *pfucb, CHAR *szName )
	{
	ERR				err;
	CHAR			szColumn[ (JET_cbNameMost + 1) ];
	FCB				*pfcb;
	FDB				*pfdb;
	FID				fidColToDelete;
	JET_COLUMNID	columnidT;
	TCIB  			tcib;
	FIELD			*pfield;
	VERCOLUMN		vercolumn;
	BOOL			fWriteLatchSet = fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CallR( ErrUTILCheckName( szColumn, szName, (JET_cbNameMost + 1) ) );

	/*	ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb ) );

	Assert( ppib != ppibNil );
	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	pfcb = pfucb->u.pfcb;

	/*	wait for bookmark cleanup and on-going replace/insert.
	/*	UNDONE: decouple operation from other index creations
	/**/
	while ( FFCBReadLatch( pfcb ) )
		{
		BFSleep( cmsecWaitGeneric );
		}

	/*	abort if DDL is being done on file
	/**/
	if ( FFCBWriteLatch( pfcb, ppib ) )
		{
		return ErrERRCheck( JET_errWriteConflict );
		}
	FCBSetWriteLatch( pfcb, ppib );
	fWriteLatchSet = fTrue;

	/*	cache pfdb after DenyDDL is set
	/**/
	pfdb = (FDB *)pfcb->pfdb;

	err = ErrFILEGetColumnId( ppib, pfucb, szColumn, &columnidT );
	if ( err != JET_errSuccess )
		{
		Assert( fWriteLatchSet );
		FCBResetWriteLatch( pfcb, ppib );

		Assert( err == JET_errColumnNotFound );
		return err;
		}
		
	fidColToDelete = (FID)columnidT;

	err = ErrDIRBeginTransaction( ppib );
	if ( err < 0 )
		{
		Assert( fWriteLatchSet );
		FCBResetWriteLatch( pfcb, ppib );

		return err;
		}

	pfield = PfieldFDBFromFid( pfdb, fidColToDelete );

	vercolumn.fid = fidColToDelete;
	vercolumn.coltyp = pfield->coltyp;

	Call( ErrVERFlag( pfucb, operDeleteColumn, (VOID *)&vercolumn, sizeof(vercolumn) ) );

	/*	write latch will be reset by either commit or rollback after VERFlag
	/**/
	fWriteLatchSet = fFalse;

	/*	move to FDP root
	/**/
	DIRGotoFDPRoot( pfucb );

	/*	search for column in use in indexes
	/**/
	err = ErrFILEICheckIndexColumn( pfcb, fidColToDelete );
	if ( err != JET_errColumnNotFound )
		{
		Call( err == JET_errSuccess ? ErrERRCheck( JET_errColumnInUse ) : err );
		}

#if 0
	/*	checking the catalog is more elegant, but too slow.  Nevertheless, keep
	/*	the code here in case we need it (eg. concurrent DDL)
	/**/
	err = ErrCATCheckIndexColumn( ppib, pfucb->dbid, pfcb->pgnoFDP, fidColToDelete );
	if ( err != JET_errColumnNotFound )
		{
		Call( err == JET_errSuccess ? ErrERRCheck( JET_errColumnInUse : err );
		}
#endif

	tcib.fidFixedLast = pfdb->fidFixedLast;
	tcib.fidVarLast = pfdb->fidVarLast;
	tcib.fidTaggedLast = pfdb->fidTaggedLast;

	/*	if fixed field, insert a placeholder for computing offsets, and
	/*	rebuild FDB
	/**/
	Call( ErrDIRGet( pfucb ) );

	/*	mark column as deleted by simply changing its type to Nil
	/**/
	pfield->coltyp = JET_coltypNil;

	/*	reset FDBs version or autoinc values if needed.
	/*	Note that the two are mutually exclusive.
	/**/
	Assert( !( pfdb->fidVersion == fidColToDelete  &&
		pfdb->fidAutoInc == fidColToDelete ) );
	if ( pfdb->fidVersion == fidColToDelete )
		pfdb->fidVersion = 0;
	else if ( pfdb->fidAutoInc == fidColToDelete )
		pfdb->fidAutoInc = 0;

	/*	Do not reconstruct default record.  This facilitates
	/*	rollback.  If the DeleteColumn commits, the space used by the deleted
	/*	column will be reclaimed on the next AddColumn, which is the only time
	/*	we would ever run out of space.
	/**/
//	if ( FFIELDDefault( pfield->ffield ) )
//		{
//		Call( ErrFDBRebuildDefaultRec( pfdb, fidColToDelete, NULL ) );
//		}

	/*	set currencies at BeforeFirst and remove unused CSR
	/**/
	Assert( PcsrCurrent( pfucb ) != pcsrNil );
	PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		Assert( PcsrCurrent( pfucb->pfucbCurIndex ) != pcsrNil );
		PcsrCurrent( pfucb->pfucbCurIndex )->csrstat = csrstatBeforeFirst;
		}

	/*	remove column record from MSysColumns before committing
	/**/
	if ( pfucb->dbid != dbidTemp )
		{
		/*	need to retain MSysColumn records for all fixed columns (because we
		/*	need their fixed offset), as well as the last column for each type
		/*	(to compute (fidFixed/Var/TaggedLast).
		/**/
		if ( FFixedFid( fidColToDelete ) ||
			fidColToDelete == tcib.fidVarLast  ||
			fidColToDelete == tcib.fidTaggedLast )
			{
			/*	flag column as deleted in system table
			/**/
			BYTE coltyp = JET_coltypNil;
			Call( ErrCATReplace( ppib,
				pfucb->dbid,
				itableSc,
				pfcb->pgnoFDP,
				szColumn,
				iMSC_Coltyp,
				&coltyp,
				sizeof(coltyp) ) );
			}
		else
			{
			Call( ErrCATDelete( ppib, pfucb->dbid, itableSc, szColumn, pfcb->pgnoFDP ) );
			}
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	return JET_errSuccess;

HandleError:
	CallS( ErrDIRRollback( ppib ) );

	/*	if write latch was not reset in commit/rollback, and it was
	/*	set, then reset it.
	/**/
	if ( fWriteLatchSet )
		FCBResetWriteLatch( pfcb, ppib );

	return err;
	}


#define fRenameColumn   (1<<0)
#define fRenameIndex    (1<<1)


//+API
//	ErrIsamRenameTable
//	========================================================================
//	ErrIsamRenameTable( JET_VSESID vsesid, JET_VDBID vdbid, CHAR *szFile, CHAR *szFileNew )
//
//	Renames file szFile to szFileNew.  No other attributes of the file
//	change.	The renamed file need not reside in the same directory
//	as the original file.
//
// RETURNS		Error code from DIRMAN or
//					 JET_errSuccess			Everything worked OK.
//					-InvalidName			One of the elements in the
//											path given is an FDP node.
//					-TableDuplicate 		A file already exists with
//										 	the path given.
// COMMENTS
//
//	There must not be anyone currently using the file.
//	A transaction is wrapped around this function.	Thus, any
//	work done will be undone if a failure occurs.
//
// SEE ALSO		CreateTable, DeleteTable
//-
ERR VTAPI ErrIsamRenameTable( JET_VSESID vsesid, JET_VDBID vdbid, CHAR *szName, CHAR *szNameNew )
	{
	ERR 		err;
	PIB			*ppib = (PIB *)vsesid;
	CHAR		szTable[ (JET_cbNameMost + 1) ];
	CHAR		szTableNew[ (JET_cbNameMost + 1) ];
	DBID		dbid;
	FUCB		*pfucbTable = pfucbNil;
	FCB			*pfcb;
	KEY	  		key;
	BYTE		rgbKey[ JET_cbKeyMost ];
	PGNO		pgnoFDP = pgnoNull;
	BOOL		fSetRename = fFalse;
	CHAR		*szFileName;
	OBJID		objid;
	JET_OBJTYP	objtyp;
	BOOL		fWriteLatchSet = fFalse;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	CallR( VDbidCheckUpdatable( vdbid ) );
	dbid = DbidOfVDbid( vdbid );

	/*	cannot be temporary database
	/**/
	Assert( dbid != dbidTemp );

	CallR( ErrUTILCheckName( szTable, szName, (JET_cbNameMost + 1) ) );
	CallR( ErrUTILCheckName( szTableNew, szNameNew, (JET_cbNameMost + 1) ) );

	CallR( ErrDIRBeginTransaction( ppib ) );

	CallJ( ErrCATFindObjidFromIdName( ppib, dbid, objidTblContainer,
		szTable, &objid, &objtyp ), SystabError );

	if ( objtyp == JET_objtypQuery || objtyp == JET_objtypLink )
		{
		CallJ( ErrCATRename( ppib, dbid, szTableNew, szTable,
			objidTblContainer, itableSo ), SystabError );
		CallJ( ErrDIRCommitTransaction( ppib, 0 ), SystabError );
		return err;

SystabError:
		CallS( ErrDIRRollback( ppib ) );
		return err;
		}

	pgnoFDP = objid;
		
	pfcb = PfcbFCBGet( dbid, pgnoFDP );

	if ( pfcb != pfcbNil )
		{
		/*	cannot rename a table open by anyone
		/**/
		if ( FFCBTableOpen( dbid, pgnoFDP ) )
			{
			err = ErrERRCheck( JET_errTableInUse );
			goto HandleError;
			}
		}

	/*	make sure that table to be renamed is open to
	/*	avoid special case handling of closed table
	/**/
	Call( ErrFILEOpenTable( ppib, dbid, &pfucbTable, szTable, 0 ) );
	
	/*	no one else should have this table open,
	/**/
    Assert( !FFCBReadLatch( pfucbTable->u.pfcb ) );
	Assert( !FFCBWriteLatch( pfucbTable->u.pfcb, ppib ) );
	FCBSetWriteLatch( pfucbTable->u.pfcb, ppib );
	fWriteLatchSet = fTrue;
	
	DIRGotoFDPRoot( pfucbTable );

	/*	lock table for rename
	/**/
	Call( ErrFCBSetRenameTable( ppib, dbid, pgnoFDP ) );
	fSetRename = fTrue;

	/*	make new table name into key
	/**/
	UtilNormText( szTableNew, strlen(szTableNew), rgbKey, sizeof(rgbKey), &key.cb );
	key.pb = rgbKey;

	/*	store just the pointer to the old name.
	/*	Free it on commit, restore it on rollback.
	/**/
	Assert( strcmp( pfucbTable->u.pfcb->szFileName, szTable ) == 0 );
	Call( ErrVERFlag(
		pfucbTable,
		operRenameTable,
		(BYTE *)&pfucbTable->u.pfcb->szFileName,
		sizeof(BYTE *) ) );

	/*	write latch will be reset by either commit or rollback after VERFlag
	/**/
	fWriteLatchSet = fFalse;

	/*	fix name in MSysObjects entry for this table before committing
	/**/
	Call( ErrCATRename( ppib, dbid, szTableNew, szTable, objidTblContainer, itableSo ) );

	szFileName = SAlloc( strlen( szTableNew ) + 1 );
	if ( szFileName == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	strcpy( szFileName, szTableNew );

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	/*	change in memory name of table, if table in memory structures exist
	/**/
	Assert( pfucbTable->u.pfcb == PfcbFCBGet( dbid, pgnoFDP ) );
	Assert( pfucbTable->u.pfcb != pfcbNil );
	pfucbTable->u.pfcb->szFileName = szFileName;

HandleError:
	/*	remove lock for rename
	/**/
	if ( fSetRename )
		{
		FCBResetRenameTable( pfucbTable->u.pfcb );
		}

	/*	free table cursor if allocated
	/**/
	if ( pfucbTable != pfucbNil )
		{
		CallS( ErrFILECloseTable( ppib, pfucbTable ) );
		}

	/*	rollback if fail
	/**/
	if ( err < 0 )
		{
		CallS( ErrDIRRollback( ppib ) );
		}

	if ( fWriteLatchSet )
		FCBResetWriteLatch( pfucbTable->u.pfcb, ppib );

	return err;
	}


//+api
// ErrFILEIRenameIndexColumn
// ========================================================================
// LOCAL ERR ErrFILEIRenameIndexColumn( ppib, pfucb, szName, szNameNew )
//
//	Renames a column or index.
//
//	seek to old field definition
//	copy old field definition
//	modify field name
//	delete old field definition
//	add new field definition with new key
//	correct system table entry
//	rebuild field RAM structures
//
//	PARAMETERS	ppib			PIB of user
//			  	pfucb			Exclusively opened FUCB of file
//			  	szName			old name
//			  	szNameNew		new name
//			  	fRenameType 	rename column or index?
//
// RETURNS		JET_errSuccess
//					JET_errIndexNotFound
//					JET_errColumnNotFound
//-


// UNDONE:  Break this out into separate functions -- RenameIndex() and RenameColumn()

LOCAL ERR ErrFILEIRenameIndexColumn(
	PIB			*ppib,
	FUCB		*pfucb,
	CHAR		*szName,
	CHAR		*szNameNew,
	BYTE		fRenameType )
	{
	ERR			err;
	ERR			errNotFound;
	ERR			errDuplicate;
	CHAR		szIC[ (JET_cbNameMost + 1) ];
	CHAR		rgbICNorm[ JET_cbKeyMost ];
	CHAR		szICNew[ (JET_cbNameMost + 1) ];
	BYTE		rgbICNewNorm[ JET_cbKeyMost ];
	CHAR		*pchName;
	FCB			*pfcb;
	KEY			keyIC;
	KEY			keyICNew;
	FIELD		*pfield;
	INT			itable;
	VERRENAME	verrename;
	BOOL		fWriteLatchSet = fFalse;

	/*	check parameters
	/**/
	CheckPIB( ppib );
	CheckTable( ppib, pfucb );

	Assert( !FFUCBNonClustered( pfucb ) );
	/*	return error if table is not exclusively locked
	/**/
	pfcb = pfucb->u.pfcb;

	/*	validate, normalize name and set key
	/**/
	CallR( ErrUTILCheckName( szIC, szName, (JET_cbNameMost + 1) ) );
	UtilNormText( szIC, strlen(szIC), rgbICNorm, sizeof(rgbICNorm), &keyIC.cb );
	keyIC.pb = rgbICNorm;

	/*	validate, normalize new name and set key
	/**/
	CallR( ErrUTILCheckName( szICNew, szNameNew, (JET_cbNameMost + 1) ) );
	UtilNormText( szICNew, strlen(szICNew), rgbICNewNorm, sizeof(rgbICNewNorm), &keyICNew.cb );
	keyICNew.pb = rgbICNewNorm;

	/*	marshal names for rollback support
	/**/
	strcpy( verrename.szName, szIC );
	strcpy( verrename.szNameNew, szICNew );

	CallR( ErrDIRBeginTransaction( ppib ) );
	DIRGotoFDPRoot( pfucb );

	if ( fRenameType == fRenameColumn )
		{
		errNotFound = JET_errColumnNotFound;
		errDuplicate = JET_errColumnDuplicate;
		itable = itableSc;
	
		err = JET_errSuccess;
		if ( PfieldFCBFromColumnName( pfcb, szICNew ) != pfieldNil )
			{
			err = ErrERRCheck( errDuplicate );
			goto HandleError;
			}

		if ( ( pfield = PfieldFCBFromColumnName( pfcb, szIC ) ) == pfieldNil )
			{
			err = ErrERRCheck( errNotFound );
			goto HandleError;
			}

		if ( !( FFCBTemporaryTable( pfcb ) ) )
			{
			/*	change column name in system table
			/**/
			err = ErrCATRename( ppib, pfucb->dbid, szICNew, szIC,
				pfucb->u.pfcb->pgnoFDP, itable );
			if ( err < 0 )
				{
				// UNDONE: Detect column duplicates via the catalog (currently,
				// cannot be done because we allow column duplicates).
				Assert( err != JET_errKeyDuplicate );
				if ( err == JET_errRecordNotFound )
					err = ErrERRCheck( errNotFound );
				goto HandleError;					
				}
			}
		}
	else	// !( fRenameType == fRenameColumn )
		{
		Assert( fRenameType == fRenameIndex );
		errNotFound = JET_errIndexNotFound;
		errDuplicate = JET_errIndexDuplicate;
		itable = itableSi;

		// If SINGLE_LEVEL_TREES is enabled, let the catalog detect duplicates
		// for us, except for temp tables (which are not in the catalog).
		// For temp tables, it is safe to consult the RAM structures
		// because temp tables are exclusively held.
		if ( FFCBTemporaryTable( pfcb ) )
			{
			if ( PfcbFCBFromIndexName( pfcb, szIC ) == pfcbNil )
				{
				err = ErrERRCheck( errNotFound );
				goto HandleError;
				}
			if ( PfcbFCBFromIndexName( pfcb, szICNew ) != pfcbNil )
				{
				err = ErrERRCheck( errDuplicate );
				goto HandleError;
				}
			}
		else
			{
			/*	change index name in system table
			/**/
			err = ErrCATRename( ppib, pfucb->dbid, szICNew, szIC,
				pfucb->u.pfcb->pgnoFDP, itable );
			if ( err < 0 )
				{
				if ( err == JET_errRecordNotFound )
					err = ErrERRCheck( errNotFound );
				else if ( err == JET_errKeyDuplicate )
					err = ErrERRCheck( errDuplicate );
				goto HandleError;					
				}
			}
		}

	/*	get pointer to name in RAM structures.  If RAM structures don't agree with
	/*  the catalog, then report WriteConflict.
	/**/
	if ( fRenameType == fRenameIndex )
		{
		FCB	*pfcbT = PfcbFCBFromIndexName( pfcb, szIC );
		if ( pfcbT == pfcbNil  ||  PfcbFCBFromIndexName( pfcb, szICNew ) != pfcbNil )
			{
			err = ErrERRCheck( JET_errWriteConflict );
			goto HandleError;
			}
		pchName = pfcbT->pidb->szName;
		}

	else
		{
		Assert( fRenameType == fRenameColumn );

		if ( PfieldFCBFromColumnName( pfcb, szIC ) == pfieldNil  ||
			PfieldFCBFromColumnName( pfcb, szICNew ) != pfieldNil )
			{
			err = ErrERRCheck( JET_errWriteConflict );
			goto HandleError;
			}
		}

	/*	wait for bookmark cleanup and on-going replace/insert.
	/*	UNDONE: decouple operation from other index creations
	/**/
	while ( FFCBReadLatch( pfcb ) )
		{
		BFSleep( cmsecWaitGeneric );
		}

	/*	abort if DDL is being done on table
	/**/
	if ( FFCBWriteLatch( pfcb, ppib ) )
		{
		err = ErrERRCheck( JET_errWriteConflict );
		goto HandleError;
		}
	FCBSetWriteLatch( pfcb, ppib );
	fWriteLatchSet = fTrue;

	if ( fRenameType == fRenameColumn )
		{
		Call( ErrVERFlag( pfucb, operRenameColumn, (BYTE *)&verrename, sizeof(verrename) ) );
		fWriteLatchSet = fFalse;
		
		Call( ErrMEMReplace( pfcb->pfdb->rgb, pfield->itagFieldName, szICNew, strlen( szICNew ) + 1 ) );
		}
	else
		{
		Assert( fRenameType == fRenameIndex );
		Call( ErrVERFlag( pfucb, operRenameIndex, (BYTE *)&verrename, sizeof(verrename) ) );
		fWriteLatchSet = fFalse;
		
		/*	change name in RAM structure
		/**/
		strcpy( pchName, szICNew );
		}

	DIRBeforeFirst( pfucb );

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	return err;

HandleError:
	Assert( err != JET_errKeyDuplicate );
	CallS( ErrDIRRollback( ppib ) );

	if ( fWriteLatchSet )
		FCBResetWriteLatch( pfcb, ppib );

	return err;
	}


ERR ErrFILERenameObject( PIB *ppib, DBID dbid, OBJID objidParent, char  *szObjectName, char  *szObjectNew )
	{
	ERR         err = JET_errSuccess;

	/*	change the object's name.
	/**/
	CallR( ErrDIRBeginTransaction( ppib ) );
	Call( ErrCATRename( ppib, dbid, szObjectNew, szObjectName, objidParent, itableSo ) );
	Call( ErrDIRCommitTransaction( ppib, 0 ) );
	return err;

HandleError:
	CallS( ErrDIRRollback( ppib ) );
	return err;
	}


ERR VTAPI ErrIsamRenameObject(
	JET_VSESID	vsesid,
	JET_VDBID	vdbid,
	const char  *szContainerName,
	const char  *szObjectName,
	const char  *szObjectNameNew )
	{
	ERR         err;
	PIB			*ppib = (PIB *)vsesid;
	DBID		dbid;
	OBJID       objid;
	OBJID       objidParent;
	JET_OBJTYP  objtyp;
	CHAR        szContainer[ JET_cbNameMost+1 ];
	CHAR		szObject[ JET_cbNameMost+1 ];
	CHAR		szObjectNew[ JET_cbNameMost+1 ];

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	CallR( VDbidCheckUpdatable( vdbid ) );
	dbid = DbidOfVDbid( vdbid );

	/*	check names
	/**/
	Call( ErrUTILCheckName( szObject, szObjectName, JET_cbNameMost + 1 ) );
	Call( ErrUTILCheckName( szObjectNew, szObjectNameNew, JET_cbNameMost + 1 ) );

	if ( szContainerName == NULL || *szContainerName == '\0' )
		{
		/*	root objid if no container given
		/**/
		objidParent = objidRoot;
		}
	else
		{
		/*	check container name
		/**/
		Call( ErrUTILCheckName( szContainer, szContainerName, JET_cbNameMost+1 ) );

		/*	get container objid
		/**/
		Call( ErrCATFindObjidFromIdName( ppib, dbid, objidRoot,
			szContainer, &objidParent, &objtyp ) );
		if ( objidParent == objidNil || objtyp != JET_objtypContainer )
			return ErrERRCheck( JET_errObjectNotFound );
		}

	Call( ErrCATFindObjidFromIdName( ppib, dbid, objidParent, szObject, &objid, &objtyp ) );

	/*	special case rename table
	/**/
	if ( objtyp == JET_objtypTable || objtyp == JET_objtypSQLLink )
		{
		err = ErrIsamRenameTable( (JET_VSESID)ppib, vdbid, szObject, szObjectNew );
		if ( err == JET_errTableDuplicate )
			{
			err = ErrERRCheck( JET_errObjectDuplicate );
			}
		}
	else
		{
		/*	rename object
		/**/
		err = ErrFILERenameObject( ppib, dbid, objidParent, szObject, szObjectNew );
		}

HandleError:
	return err;
	}


	ERR VTAPI
ErrIsamRenameColumn( PIB *ppib, FUCB *pfucb, CHAR *szName, CHAR *szNameNew )
	{
	ERR	err;

	/*	ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb ) );

	err = ErrFILEIRenameIndexColumn( ppib, pfucb, szName, szNameNew, fRenameColumn );
	return err;
	}


	ERR VTAPI
ErrIsamRenameIndex( PIB *ppib, FUCB *pfucb, CHAR *szName, CHAR *szNameNew )
	{
	ERR	err;

	/*	ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb ) );

	err = ErrFILEIRenameIndexColumn( ppib, pfucb, szName, szNameNew, fRenameIndex );
	return err;
	}


SHORT FidbFILEOfGrbit( JET_GRBIT grbit, BOOL fLangid )
	{
	SHORT	fidb = 0;
	BOOL	fDisallowNull	= grbit & (JET_bitIndexDisallowNull | JET_bitIndexPrimary);
	BOOL	fIgnoreNull		= grbit & JET_bitIndexIgnoreNull;
	BOOL	fIgnoreAnyNull	= grbit & JET_bitIndexIgnoreAnyNull;
	BOOL	fIgnoreFirstNull= grbit & JET_bitIndexIgnoreFirstNull;

	if ( !fDisallowNull && !fIgnoreAnyNull )
		{	   	
		fidb |= fidbAllowSomeNulls;
		if ( !fIgnoreFirstNull )
			fidb |= fidbAllowFirstNull;
		if ( !fIgnoreNull )
			fidb |= fidbAllowAllNulls;
		}

	if ( grbit & JET_bitIndexClustered )
		fidb |= fidbClustered;

	if ( grbit & JET_bitIndexPrimary )
		{
		fidb |= (fidbPrimary | fidbUnique | fidbNoNullSeg);	
		}
	else
		{
		/*	primary implies Unique and DisallowNull, so if already
		/*	Primary, no need to check these.
		/**/
		if ( grbit & JET_bitIndexUnique )
			fidb |= fidbUnique;
		if ( fDisallowNull )
			fidb |= fidbNoNullSeg;
		}
	
	if ( fLangid )
		{
		fidb |= fidbLangid;
		}

	return fidb;
	}








=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\fileopen.c ===
#include "daestd.h"

DeclAssertFile;						/* Declare file name for assert macros */

extern SIG	sigDoneFCB;


ERR VTAPI ErrIsamDupCursor( PIB *ppib, FUCB *pfucbOpen, FUCB **ppfucb, ULONG grbit )
	{
	ERR		err;
	FUCB 	*pfucb;
	CSR		*pcsr;
#ifdef	DISPATCHING
	JET_TABLEID	tableid = JET_tableidNil;
#endif	/* DISPATCHING */

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbOpen );

	/*	silence warnings
	/**/
	grbit = grbit;

#ifdef	DISPATCHING
	/*	allocate a dispatchable tableid
	/**/
	CallR( ErrAllocateTableid( &tableid, (JET_VTID) 0, &vtfndefIsam ) );
#endif	/* DISPATCHING */

	/*	allocate FUCB
	/**/
	Call( ErrDIROpen( ppib, pfucbOpen->u.pfcb, 0, &pfucb ) );

	/*	reset copy buffer
	/**/
	pfucb->pbfWorkBuf = pbfNil;
	pfucb->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	/*	reset key buffer
	/**/
	pfucb->pbKey = NULL;
	KSReset( pfucb );

	/*	copy cursor flags
	/**/
	FUCBSetIndex( pfucb );
	if ( FFUCBUpdatable( pfucbOpen ) )
		{
		FUCBSetUpdatable( pfucb );
		}
	else
		{
		FUCBResetUpdatable( pfucb );
		}

	/*	set currency before first node
	/**/
	pcsr = PcsrCurrent( pfucb );
	Assert( pcsr != pcsrNil );
	pcsr->csrstat = csrstatBeforeFirst;

	/*	move currency to the first record and ignore error if no records
	/**/
	RECDeferMoveFirst( ppib, pfucb );
	err = JET_errSuccess;

#ifdef	DISPATCHING
	/*	inform dispatcher of correct JET_VTID
	/**/
	CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucb ) );
	pfucb->fVtid = fTrue;
	pfucb->tableid = tableid;
	pfucb->vdbid = pfucbOpen->vdbid;
	*(JET_TABLEID *) ppfucb = tableid;
#else	/* !DISPATCHING */
	*ppfucb = pfucb;
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
#ifdef	DISPATCHING
	ReleaseTableid( tableid );
#endif	/* DISPATCHING */
	return err;
	}


//+local
// ErrRECNewFDB
// ========================================================================
// ErrRECNewFDB(
//		FDB **ppfdb,			// OUT	 receives new FDB
//		FID fidFixedLast,		// IN	   last fixed field id to be used
//		FID fidVarLast,			// IN	   last var field id to be used
//		FID fidTaggedLast )		// IN	   last tagged field id to be used
//
// Allocates a new FDB, initializing internal elements appropriately.
//
// PARAMETERS
//				ppfdb			receives new FDB
//				fidFixedLast	last fixed field id to be used
//								(should be fidFixedLeast-1 if none)
//				fidVarLast		last var field id to be used
//								(should be fidVarLeast-1 if none)
//				fidTaggedLast	last tagged field id to be used
//								(should be fidTaggedLeast-1 if none)
// RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfMemory	Failed to allocate memory.
// SEE ALSO		ErrRECAddFieldDef
//-
ERR ErrRECNewFDB(
	FDB **ppfdb,
	TCIB *ptcib,
	BOOL fAllocateNameSpace )
	{
	ERR		err;				// standard error value
	INT		iib;	  			// loop counter
	WORD 	cfieldFixed;  		// # of fixed fields
	WORD 	cfieldVar;	  		// # of var fields
	WORD 	cfieldTagged; 		// # of tagged fields
	WORD	cfieldTotal;		// Fixed + Var + Tagged
	WORD	*pibFixedOffsets;	// Fixed Offsets table
	FDB   	*pfdb;		  		// temporary FDB pointer
	ULONG	cbFieldInfo;		// space consumed by FIELD structures and offsets table
	ULONG	itag;

	Assert( ppfdb != NULL );
	Assert( ptcib->fidFixedLast <= fidFixedMost );
	Assert( ptcib->fidVarLast >= fidVarLeast-1 && ptcib->fidVarLast <= fidVarMost );
	Assert( ptcib->fidTaggedLast >= fidTaggedLeast-1 && ptcib->fidTaggedLast <= fidTaggedMost );

	err = JET_errSuccess;
					
	/*	calculate how many of each field type to allocate
	/**/
	cfieldFixed = ptcib->fidFixedLast + 1 - fidFixedLeast;
	cfieldVar = ptcib->fidVarLast + 1 - fidVarLeast;
	cfieldTagged = ptcib->fidTaggedLast + 1 - fidTaggedLeast;
	cfieldTotal = cfieldFixed + cfieldVar + cfieldTagged;

	if ( ( pfdb = (FDB *)SAlloc( sizeof(FDB) ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	memset( (BYTE *)pfdb, '\0', sizeof(FDB) );

	/*	fill in max field id numbers
	/**/
	pfdb->fidFixedLast = ptcib->fidFixedLast;
	pfdb->fidVarLast = ptcib->fidVarLast;
	pfdb->fidTaggedLast = ptcib->fidTaggedLast;

	// NOTE:  FixedOffsets requires one more entry than the actual number of
	// fields so that we can calculate the size of the last field.  Another way
	// to look at it is that the extra entry marks where the next fixed column
	// would start if/when one is added.
	// Moreover, an additional entry may have to be added to satisfy alignment.
	cbFieldInfo = ( cfieldTotal * sizeof(FIELD) )
		+ (ULONG)((ULONG_PTR)Pb4ByteAlign( (BYTE *) ( ( cfieldFixed + 1 ) * sizeof(WORD) ) ));

	// Allocate space for the FIELD structures and fixed offsets table.  In
	// addition, allocate space for field names if specified.
	if ( fAllocateNameSpace )
		{
		Call( ErrMEMCreateMemBuf(
			&pfdb->rgb,
			cbFieldInfo + ( cbAvgColName * cfieldTotal ),
			cfieldTotal + 1 ) );		// # tag entries = 1 per fieldname plus 1 for all FIELD structures
		}
	else
		{
		Call( ErrMEMCreateMemBuf( &pfdb->rgb, cbFieldInfo, 1 ) );
		}

	Call( ErrMEMAdd( pfdb->rgb, NULL, cbFieldInfo, &itag ) );
	Assert( itag == itagFDBFields );	// Should be the first entry in the buffer.


	/* initialize fixed field offset table
	/**/
	pibFixedOffsets = PibFDBFixedOffsets( pfdb );
	for ( iib = 0; iib <= cfieldFixed; iib++ )
		{
		pibFixedOffsets[iib] = sizeof(RECHDR);
		}

	/* Initialise FIELD structures by zeroing everything out.
	/* Note how the FIELD structures follow immediately after the fixed offsets table.
	/**/
	Assert( (BYTE *)Pb4ByteAlign( (BYTE *) ( pibFixedOffsets + iib ) ) + ( cfieldTotal * sizeof(FIELD) ) ==
		(BYTE *)PibFDBFixedOffsets( pfdb ) + cbFieldInfo );
	memset( (BYTE *)Pb4ByteAlign( (BYTE *) ( pibFixedOffsets + iib ) ),
		'\0',
		cfieldTotal * sizeof(FIELD) );

	/*	set output parameter and return
	/**/
	*ppfdb = pfdb;
	return JET_errSuccess;

HandleError:
	return err;
	}



#ifdef DEBUG
// Pass fidFixedLast+1 to get the offset for the rest of the record (ie. just past
// all the fixed data).
// WARNING:	This function only works properly if called:
//			1) when fixed columns are being added in FID order, or
//			2) after all fixed columns have been added and the offset to the rest
//			of the record (after the fixed data) is required.
VOID RECSetLastOffset( FDB *pfdb, WORD ibRec )
	{
	WORD 	*pibFixedOffsets;
	FID		ifid;

	// Set the last offset.
	pibFixedOffsets = PibFDBFixedOffsets( pfdb );
	pibFixedOffsets[pfdb->fidFixedLast] = ibRec;
	Assert( ibRec <= cbRECRecordMost );

	Assert( pibFixedOffsets[0] == sizeof(RECHDR) );
	for ( ifid = 1; ifid <= pfdb->fidFixedLast; ifid++ )
		{
		Assert( pibFixedOffsets[ifid] > sizeof(RECHDR) );		
		Assert( pibFixedOffsets[ifid] > pibFixedOffsets[ifid-1] );

		Assert( ifid == pfdb->fidFixedLast ?
			pibFixedOffsets[ifid] == ibRec :
			pibFixedOffsets[ifid] < ibRec );
		}
	}
#endif


VOID FILEAddOffsetEntry( FDB *pfdb, FIELDEX *pfieldex )
	{
	WORD *pibFixedOffsets = PibFDBFixedOffsets( pfdb );

	Assert( FFixedFid( pfieldex->fid ) );
	Assert( PibFDBFixedOffsets( pfdb )[0] == sizeof(RECHDR) );
	Assert( pfieldex->ibRecordOffset >= sizeof(RECHDR) );

	pibFixedOffsets[pfieldex->fid-fidFixedLeast] = pfieldex->ibRecordOffset;
	}


//+API
// ErrRECAddFieldDef
// ========================================================================
// ErrRECAddFieldDef(
//		FDB *pfdb,		//	INOUT	FDB to add field definition to
//		FID fid );		//	IN		field id of new field
//
// Adds a field descriptor to an FDB.
//
// PARAMETERS	pfdb   			FDB to add new field definition to
//				fid	   			field id of new field (should be within
//					   			the ranges imposed by the parameters
//								supplied to ErrRECNewFDB)
//				ftFieldType		data type of field
//				cbField			field length (only important when
//								defining fixed textual fields)
//				bFlags			field behaviour flags:
//					VALUE				MEANING
//					========================================
//					ffieldNotNull		Field may not contain NULL values.
//				szFieldName		name of field
//
// RETURNS		Error code, one of:
//					 JET_errSuccess			Everything worked.
//					-ColumnInvalid	   		Field id given is greater than
//									   		the maximum which was given
//									   		to ErrRECNewFDB.
//					-JET_errBadColumnId		A nonsensical field id was given.
//					-errFLDInvalidFieldType The field type given is either
//									   		undefined, or is not acceptable
//									   		for this field id.
// COMMENTS		When adding a fixed field, the fixed field offset table
//				in the FDB is recomputed.
// SEE ALSO		ErrRECNewFDB
//-
ERR ErrRECAddFieldDef( FDB *pfdb, FIELDEX *pfieldex )
	{
	FID			fid = pfieldex->fid;
	JET_COLTYP	coltyp = pfieldex->field.coltyp;

	Assert( pfdb != pfdbNil );

	/*	fixed field: determine length, either from field type
	/*	or from parameter (for text/binary types)
	/**/
	if ( FFixedFid( fid ) )
		{
		if ( fid > pfdb->fidFixedLast )
			return ErrERRCheck( JET_errColumnNotFound );

		FILEAddOffsetEntry( pfdb, pfieldex );

		PfieldFDBFixed( pfdb )[fid-fidFixedLeast] = pfieldex->field;
		}

	else if ( FVarFid( fid ) )
		{
		/*	variable column.  Check for bogus numeric and long types
		/**/
		if ( fid > pfdb->fidVarLast )
			return ErrERRCheck( JET_errColumnNotFound );
		else if ( coltyp != JET_coltypBinary && coltyp != JET_coltypText )
			return ErrERRCheck( JET_errInvalidColumnType );
		
		PfieldFDBVar( pfdb )[fid-fidVarLeast] = pfieldex->field;
		}
	else if ( FTaggedFid( fid ) )
		{
		/*	tagged field: any type is ok
		/**/
		if ( fid > pfdb->fidTaggedLast )
			return ErrERRCheck( JET_errColumnNotFound );

		PfieldFDBTagged( pfdb )[fid-fidTaggedLeast] = pfieldex->field;
		}

	else
		{
		return ErrERRCheck( JET_errBadColumnId );
		}

	return JET_errSuccess;
	}


ERR ErrFILEIGenerateIDB(FCB *pfcb, FDB *pfdb, IDB *pidb)
	{
	FID					fid;
	FIELD				*pfield;
	IDXSEG UNALIGNED 	*pidxseg;
	IDXSEG 				*pidxsegMac;
	
	Assert(pfcb != pfcbNil);
	Assert(pfdb != pfdbNil);
	Assert(pidb != pidbNil);

	Assert( (cbitFixed % 8) == 0 );
	Assert( (cbitVariable % 8) == 0 );
	Assert( (cbitTagged % 8) == 0 );

	if ( pidb->iidxsegMac > JET_ccolKeyMost )
		return ErrERRCheck( errFLDTooManySegments );

	memset( pidb->rgbitIdx, 0x00, 32 );

	/*	check validity of each segment id and
	/*	also set index mask bits
	/**/
	pidxsegMac = pidb->rgidxseg + pidb->iidxsegMac;
	for ( pidxseg = pidb->rgidxseg; pidxseg < pidxsegMac; pidxseg++ )
		{
		/*	field id is absolute value of segment id
		/**/
		fid = *pidxseg >= 0 ? *pidxseg : -(*pidxseg);
		if ( FFixedFid( fid ) )
			{
			if ( fid > pfdb->fidFixedLast )
				return ErrERRCheck( JET_errColumnNotFound );
			pfield = PfieldFDBFixed( pfdb ) + ( fid-fidFixedLeast );
			if ( pfield->coltyp == JET_coltypNil )
				return ErrERRCheck( JET_errColumnNotFound );
			}
		else if ( FVarFid( fid ) )
			{
			if ( fid > pfdb->fidVarLast )
				return ErrERRCheck( JET_errColumnNotFound );
			pfield = PfieldFDBVar( pfdb ) + ( fid-fidVarLeast );
			if ( pfield->coltyp == JET_coltypNil )
				return ErrERRCheck( JET_errColumnNotFound );
			}
		else if ( FTaggedFid( fid ) )
			{
			if ( fid > pfdb->fidTaggedLast )
				return ErrERRCheck( JET_errColumnNotFound );
			pfield = PfieldFDBTagged( pfdb ) +  ( fid-fidTaggedLeast );
			if ( pfield->coltyp == JET_coltypNil )
				return ErrERRCheck( JET_errColumnNotFound );
			if ( FFIELDMultivalue( pfield->ffield ) )
				pidb->fidb |= fidbHasMultivalue;
			}
		else
			return ErrERRCheck( JET_errBadColumnId );

		IDBSetColumnIndex( pidb, fid );
		Assert ( FIDBColumnIndex( pidb, fid ) );
		
		}

	if ( ( pfcb->pidb = PidbMEMAlloc() ) == NULL )
		return ErrERRCheck( JET_errTooManyOpenIndexes );
	
	*(pfcb->pidb) = *pidb;

	return JET_errSuccess;
	}


ERR VTAPI ErrIsamOpenTable(
	JET_VSESID	vsesid,
	JET_VDBID	vdbid,
	JET_TABLEID	*ptableid,
	CHAR		*szPath,
	JET_GRBIT	grbit )
	{
	ERR			err;
	PIB			*ppib = (PIB *)vsesid;
	DBID		dbid;
	FUCB		*pfucb = pfucbNil;
#ifdef	DISPATCHING
	JET_TABLEID  tableid = JET_tableidNil;
#endif

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	dbid = DbidOfVDbid( vdbid );

#ifdef	DISPATCHING
	/*	allocate a dispatchable tableid
	/**/
	CallR( ErrAllocateTableid( &tableid, (JET_VTID) 0, &vtfndefIsam ) );
#endif	/* DISPATCHING */

	/*	only go into FILEOpenTable with this bit
	/*	if we are creating a system table.
	/**/
	Assert( !( grbit & JET_bitTableCreateSystemTable ) );

	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szPath, grbit ) );

	/*	if database was opened read-only, so should the cursor
	/**/
	if ( FVDbidReadOnly( vdbid ) )
		FUCBResetUpdatable( pfucb );
	else
		FUCBSetUpdatable( pfucb );

#ifdef	DISPATCHING
	/*	inform dispatcher of correct JET_VTID
	/**/
	CallS( ErrSetVtidTableid( (JET_SESID) ppib, tableid, (JET_VTID) pfucb ) );
	pfucb->fVtid = fTrue;
	pfucb->tableid = tableid;

	FUCBSetVdbid( pfucb );
	*ptableid = tableid;

#else	/* !DISPATCHING */
	*(FUCB **)ptableid = pfucb;
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
#ifdef	DISPATCHING
	ReleaseTableid( tableid );
#endif	/* DISPATCHING */

	if ( err == JET_errObjectNotFound )
		{
		ERR			err;
		OBJID		objid;
		JET_OBJTYP	objtyp;

		err = ErrCATFindObjidFromIdName( ppib, dbid, objidTblContainer, szPath, &objid, &objtyp );

		if ( err >= 0 )
			{
			if ( objtyp == JET_objtypQuery )
				return ErrERRCheck( JET_errQueryNotSupported );
			if ( objtyp == JET_objtypLink )
				return ErrERRCheck( JET_errLinkNotSupported );
			if ( objtyp == JET_objtypSQLLink )
				return ErrERRCheck( JET_errSQLLinkNotSupported );
			}
		else
			return err;
		}

	return err;
	}


	/* monitoring statistics */

unsigned long cOpenTables = 0;

PM_CEF_PROC LOpenTablesCEFLPpv;

long LOpenTablesCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		*((unsigned long *)pvBuf) = cOpenTables ? cOpenTables : 1;
		}
		
	return 0;
	}

unsigned long cOpenTableCacheHits = 0;

PM_CEF_PROC LOpenTableCacheHitsCEFLPpv;

long LOpenTableCacheHitsCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		*((unsigned long *)pvBuf) = cOpenTableCacheHits;
		}
		
	return 0;
	}


INLINE LOCAL ERR ErrFILESeek( PIB *ppib, DBID dbid, CHAR *szTable, PGNO *ppgnoFDP )
	{
	ERR  		err;
	JET_OBJTYP	objtyp;

	Assert( ppgnoFDP );

	CallR( ErrCATFindObjidFromIdName(
		ppib,
		dbid,
		objidTblContainer,
		szTable,
		ppgnoFDP,
		&objtyp ) );

	switch( objtyp )
		{
		case JET_objtypTable:
			break;
		case JET_objtypQuery:
			err = ErrERRCheck( JET_errQueryNotSupported );
			break;
		case JET_objtypLink:
			err = ErrERRCheck( JET_errLinkNotSupported );
			break;
		case JET_objtypSQLLink:
			err = ErrERRCheck( JET_errSQLLinkNotSupported );
			break;
		default:
			err = ErrERRCheck( JET_errInvalidObject );
		}

	return err;
	}


//+local
//	ErrFILEOpenTable
//	========================================================================
//	ErrFILEOpenTable(
//		PIB *ppib,			// IN	 PIB of who is opening file
//		DBID dbid,			// IN	 database id
//		FUCB **ppfucb,		// OUT	 receives a new FUCB open on the file
//		CHAR *szName,		// IN	 path name of file to open
//		ULONG grbit );		// IN	 open flags
//	Opens a data file, returning a new
//	FUCB on the file.
//
// PARAMETERS
//				ppib	   	PIB of who is opening file
//				dbid	   	database id
//				ppfucb		receives a new FUCB open on the file
//						   	( should NOT already be pointing to an FUCB )
//				szName		path name of file to open ( the node
//						   	corresponding to this path must be an FDP )
//				grbit	   	flags:
//						   	JET_bitTableDenyRead	open table in exclusive mode;
//						   	default is share mode
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess					Everything worked.
//					-TableInvalidName	 			The path given does not
//										 			specify a file.
//					-JET_errDatabaseCorrupted		The database directory tree
//										 			is corrupted.
//					-Various out-of-memory error codes.
//				In the event of a fatal ( negative ) error, a new FUCB
//				will not be returned.
// SIDE EFFECTS FCBs for the file and each of its secondary indexes are
//				created ( if not already in the global list ).  The file's
//				FCB is inserted into the global FCB list.  One or more
//				unused FCBs may have had to be reclaimed.
//				The currency of the new FUCB is set to "before the first item".
// SEE ALSO		ErrFILECloseTable
//-

ERR ErrFILEOpenTable( PIB *ppib, DBID dbid, FUCB **ppfucb, const CHAR *szName, ULONG grbit )
	{
	ERR		err;
	CHAR  	szTable[JET_cbFullNameMost + 1];
	FCB		*pfcb;
	PGNO	pgnoFDP;
	BOOL  	fReUsing = fTrue;
	BOOL	fOpeningSys = fFalse;
	BOOL	fCreatingSys = fFalse;
	
	Assert( dbid < dbidMax );
	
	if ( dbid == dbidTemp )
		{
            ULONG_PTR ulptrpgnoFDP = (ULONG_PTR)(*ppfucb);
            
            pgnoFDP = (PGNO)(ULONG)(ulptrpgnoFDP);
            Assert(pgnoFDP == ulptrpgnoFDP);
		}
	else if ( fCreatingSys = (grbit & JET_bitTableCreateSystemTable) )
		{
		// Must have come from FILECreateTable().
		Assert( grbit == (JET_bitTableCreateSystemTable|JET_bitTableDenyRead) );
		fOpeningSys = fTrue;
		}
	else
		{
		fOpeningSys = FCATSystemTable( szName );
		}

	/*	initialize return value to Nil
	/**/

	*ppfucb = pfucbNil;

	CheckPIB( ppib );
	CheckDBID( ppib, dbid );
	CallR( ErrUTILCheckName( szTable, szName, (JET_cbNameMost + 1) ) );

	Assert( ppib != ppibNil );
	Assert( ppfucb != NULL );

	/*	request table open mutex
	/**/
	SgEnterCriticalSection( critGlobalFCBList );

	if ( fOpeningSys )
		{
		pgnoFDP = PgnoCATTableFDP( szTable );
		}
	else if ( dbid != dbidTemp )		// For temp tables, pgnoFDP is passed in.
		{
		Call( ErrFILESeek( ppib, dbid, szTable, &pgnoFDP ) );
		}
	Assert( pgnoFDP > pgnoSystemRoot  &&  pgnoFDP <= pgnoSysMax );


Retry:
	pfcb = PfcbFCBGet( dbid, pgnoFDP );

	/*	insert FCB in global list
	/**/
	if ( pfcb == pfcbNil )
		{
		FCB	*pfcbT;

		/*	have to build it from directory tree info
		/**/
		fReUsing = fFalse;

		SgLeaveCriticalSection( critGlobalFCBList );

		/*	pass name for system table
		/**/
		Call( ErrFILEIGenerateFCB( ppib, dbid, &pfcb, pgnoFDP,
			(fOpeningSys ? (CHAR *)szTable : NULL), fCreatingSys ) );
		Assert( pfcb != pfcbNil );

		/*	combine index column masks into a single mask
		/*	for fast record replace.
		/**/
		FILESetAllIndexMask( pfcb );

		//	UNDONE: move this into fcb.c
		SgEnterCriticalSection( critGlobalFCBList );

		/*	Must search global list again since while I was out reading
		/*	the tree, some other joker just might have been opening
		/*	the same file and may have actually beat me to it.
		/**/
		pfcbT = PfcbFCBGet( dbid, pgnoFDP );
		if ( pfcbT != pfcbNil )
			{
			/*	If the FCB was put in the list while I was
			/*	building my copy, just throw mine away.
			/**/
			fReUsing = fTrue;
			pfcb->pgnoFDP = pgnoNull;
			pfcb->szFileName = NULL;				// Haven't allocated name yet, so don't have to worry about freeing it.
			Assert( FFCBAvail( pfcb, ppib ) );		// Make sure it's marked unused,
			Assert( !FFCBDeletePending( pfcb ) );	// so Deallocate won't fail.
			FILEIDeallocateFileFCB( pfcb );
			pfcb = pfcbT;
			}
		else
			{
			/*	insert FCB in global list and in hash table
			/**/
			FCBInsert( pfcb );
			FCBInsertHashTable( pfcb );
			}
		}

	/*	wait on bookmark clean up if necessary
	/**/
	while ( FFCBWait( pfcb ) )
		{
		LgLeaveCriticalSection( critJet );
		SignalWait( &sigDoneFCB, -1 );
		LgEnterCriticalSection( critJet );
		}

	if ( PfcbFCBGet( dbid, pgnoFDP ) != pfcb )
		{
		goto Retry;
		}

	/*	set table usage mode
	/**/
	Call( ErrFCBSetMode( ppib, pfcb, grbit ) );

	/*	open table cursor
	/**/
	Assert( *ppfucb == pfucbNil );
	Call( ErrDIROpen( ppib, pfcb, 0, ppfucb ) );
	FUCBSetIndex( *ppfucb );

	/*	this code must coincide with call to ErrFCBSetMode above.
	/**/
	if ( grbit & JET_bitTableDenyRead )
		FUCBSetDenyRead( *ppfucb );
	if ( grbit & JET_bitTableDenyWrite )
		FUCBSetDenyWrite( *ppfucb );
	Assert( !FFCBDeletePending( pfcb ) );

	/*  set FUCB for sequential access if requested
	/**/
	if ( grbit & JET_bitTableSequential )
		FUCBSetSequential( *ppfucb );
	else
		FUCBResetSequential( *ppfucb );

#ifdef COSTLY_PERF
	/*  set the Table Class for this table and all its indexes
	/**/
	{
	FCB *pfcbT;
	
	pfcb->lClass = ( grbit & JET_bitTableClassMask ) / JET_bitTableClass1;
	for ( pfcbT = pfcb->pfcbNextIndex; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		pfcbT->lClass = pfcb->lClass;
	}
#endif  //  COSTLY_PERF

	/*	reset copy buffer
	/**/
	( *ppfucb )->pbfWorkBuf = pbfNil;
	( *ppfucb )->lineWorkBuf.pb = NULL;
	Assert( !FFUCBUpdatePrepared( *ppfucb ) );

	/*	reset key buffer
	/**/
	( *ppfucb )->pbKey = NULL;
	KSReset( ( *ppfucb ) );

	/*	store the file name now
	/**/
	if ( !fReUsing )
		{
		if ( ( pfcb->szFileName = SAlloc( strlen( szTable ) + 1 ) ) == NULL )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			goto HandleError;
			}
		strcpy( pfcb->szFileName, szTable );
		}

	/*	set currency before first node
	/**/
	Assert( PcsrCurrent( *ppfucb ) != pcsrNil );
	PcsrCurrent( *ppfucb )->csrstat = csrstatBeforeFirst;

	/*	move currency to the first record and ignore error if no records
	/**/
	RECDeferMoveFirst( ppib, *ppfucb );
	err = JET_errSuccess;

	/*	release crit section
	/**/
	SgLeaveCriticalSection( critGlobalFCBList );

	/*	link up pfcbTable of secondary indexes
	/**/
//  Already performed by CATGetIndexInfo().  Just double-check here.
//	FCBLinkClusteredIdx( *ppfucb );
#ifdef DEBUG
	{
	FCB *pfcbT;
	
	for ( pfcbT = pfcb->pfcbNextIndex; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
		{
		Assert( pfcbT->pfcbTable == pfcb );
		}
	}
#endif

	/*	update monitoring statistics
	/**/
	cOpenTables++;
	if ( fReUsing )
		{
		cOpenTableCacheHits++;
		}
	return JET_errSuccess;

HandleError:

	if ( *ppfucb != pfucbNil )
		{
		DIRClose( *ppfucb );
		*ppfucb = pfucbNil;
		}
		
	/*	release crit section
	/**/
	SgLeaveCriticalSection( critGlobalFCBList );
	return err;
	}




ERR VTAPI ErrIsamCloseTable( PIB *ppib, FUCB *pfucb )
	{
	ERR		err;
#ifdef DEBUG
	VTFNDEF	*pvtfndef;
#endif		

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );

#ifdef	DISPATCHING
	Assert( pfucb->fVtid );
	Assert( FValidateTableidFromVtid( (JET_VTID)pfucb, pfucb->tableid, &pvtfndef ) );
	Assert( FFUCBSystemTable( pfucb ) ? pvtfndef == &vtfndefIsamInfo : pvtfndef == &vtfndefIsam );
	ReleaseTableid( pfucb->tableid );
	pfucb->tableid = JET_tableidNil;
	pfucb->fVtid = fFalse;
#endif	/* DISPATCHING */

	err = ErrFILECloseTable( ppib, pfucb );
	return err;
	}


//+API
//	ErrFILECloseTable
//	========================================================================
//	ErrFILECloseTable( PIB *ppib, FUCB *pfucb )
//
//	Closes the FUCB of a data file, previously opened using FILEOpen.
//	Also closes the current secondary index, if any.
//
//	PARAMETERS	ppib	PIB of this user
//				pfucb	FUCB of file to close
//
//	RETURNS		JET_errSuccess
//				or lower level errors
//
//	SEE ALSO 	ErrFILEOpenTable
//-
ERR ErrFILECloseTable( PIB *ppib, FUCB *pfucb )
	{
	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	Assert( pfucb->tableid == JET_tableidNil );
	Assert( pfucb->fVtid == fFalse );

	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	/*	release working buffer
	/**/
	if ( pfucb->pbfWorkBuf != pbfNil )
		{
		BFSFree( pfucb->pbfWorkBuf );
		pfucb->pbfWorkBuf = pbfNil;
		pfucb->lineWorkBuf.pb = NULL;
		}

	if ( pfucb->pbKey != NULL )
		{
		LFree( pfucb->pbKey );
		pfucb->pbKey = NULL;
		}

	/*	detach, close and free index FUCB, if any
	/**/
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		DIRClose( pfucb->pfucbCurIndex );
		pfucb->pfucbCurIndex = pfucbNil;
		}

	/*	if closing a temporary table, free resources if
	/*	last one to close.
	/**/
	if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
		{
		FCB		*pfcb = pfucb->u.pfcb;
		DBID   	dbid = pfucb->dbid;
		BYTE   	szFileName[JET_cbNameMost+1];
		INT		wRefCnt;
		FUCB	*pfucbT;

		strncpy( szFileName, ( pfucb->u.pfcb )->szFileName, JET_cbNameMost+1 );
		DIRClose( pfucb );

		/*	one reference count is reserved for deletion purposes in
		/*	sort materialize.  If reference is reduced to 1 then delete
		/*	table as it is no longer reference by any user.
		/*
		/*	We may have deferred close cursors on the temporary table.
		/*	If one or more cursors are open, then temporary table
		/*	should not be deleted.
		/**/
		pfucbT = ppib->pfucb;
		wRefCnt = pfcb->wRefCnt;
		while ( wRefCnt > 0 && pfucbT != pfucbNil )
			{
			if ( pfucbT->u.pfcb == pfcb )
				{
				if ( !FFUCBDeferClosed( pfucbT ) )
					{
					break;
					}
				Assert( wRefCnt > 0 );
				wRefCnt--;
				}

			pfucbT = pfucbT->pfucbNext;
			}
		if ( wRefCnt > 1 )
			{
			return JET_errSuccess;
			}

		/*	if fail to delete temporary table, then lose space until
		/*	termination.  Temporary database is deleted on termination
		/*	and space is reclaimed.  This error should be rare, and
		/*	can be caused by resource failure.
		/**/
		(VOID)ErrFILEDeleteTable( ppib, dbid, szFileName, pfcb->pgnoFDP );
		return JET_errSuccess;
		}

	FUCBResetGetBookmark( pfucb );
	DIRClose( pfucb );
	return JET_errSuccess;
	}


ERR ErrFILEINewFCB(
	PIB		*ppib,
	DBID	dbid,
	FDB		*pfdb,
	FCB		**ppfcbNew,
	IDB		*pidb,
	BOOL	fClustered,
	PGNO	pgnoFDP,
	ULONG	ulDensity )
	{
	ERR		err = JET_errSuccess;
	FCB		*pfcb;
	BOOL	fFCBAllocated = fFalse;

	Assert( pgnoFDP > pgnoSystemRoot );
	Assert( pgnoFDP <= pgnoSysMax );

	/*	allocate a new FCB if one hasn't already been allocated
	/**/
	if ( *ppfcbNew == pfcbNil )
		{
		CallR( ErrFCBAlloc( ppib, ppfcbNew ) );
		fFCBAllocated = fTrue;
		}
	pfcb = *ppfcbNew;

	/*	initialise relevant FCB fields
	/**/
	pfcb->dbid = dbid;
	Assert( pfcb->wRefCnt == 0 );
	pfcb->ulFlags = 0;
	Assert( fClustered || pfcb->pfdb == pfdbNil );
	if ( fClustered )
		{
		pfcb->pfdb = pfdb;
		FCBSetClusteredIndex( pfcb );
		}
	pfcb->pgnoFDP = pgnoFDP;
	Assert( ((( 100 - ulDensity ) * cbPage ) / 100) < cbPage );
	pfcb->cbDensityFree = (SHORT)( ( ( 100 - ulDensity ) * cbPage ) / 100 );
	pfcb->pidb = pidbNil;
	
	/*	if not sequential, generate an IDB
	/**/
	Assert( pidb != pidbNil  ||  fClustered );
	if ( pidb != pidbNil )
		{
		Call( ErrFILEIGenerateIDB( pfcb, pfdb, pidb ) );
		}

	Assert( pfcb->dbkMost == 0 );		// defer setting until needed.

	// UNDONE:  Remove OLC stats altogether.  For now, just mark it as unavailable.
	FCBResetOLCStatsAvail( pfcb );

	Assert( err >= 0 );
	return err;

HandleError:	
	Assert( err < 0 );
	Assert( pfcb->pidb == pidbNil );	// Verify IDB not allocated.
	if ( fFCBAllocated )
		{
		Assert( *ppfcbNew != pfcbNil );
		(*ppfcbNew)->pfdb = pfdbNil;
		MEMReleasePfcb( *ppfcbNew );
		*ppfcbNew = pfcbNil;			// Reset to NULL.
		}
	return err;
	}


//+INTERNAL
//	ErrFILEIGenerateFCB
//	=======================================================================
//	ErrFILEIGenerateFCB( FUCB *pfucb, FCB **ppfcb )
//
//	Allocates FCBs for a data file and its indexes, and fills them in
//	from the database directory tree.
//
//	PARAMETERS
//					pfucb		FUCB opened on the FDP to be built from
//					ppfcb		receives the built FCB for this file
//
//	RETURNS		lower level errors, or one of:
//					JET_errSuccess						
//					JET_errTooManyOpenTables			could not allocate enough FCBs.
//
//	On fatal (negative) error, any FCBs which were allocated
//	are returned to the free pool.
//
//	SIDE EFFECTS	Global FCB list may be reaped for unused FCBs
//-
ERR ErrFILEIGenerateFCB(
	PIB		*ppib,
	DBID	dbid,
	FCB		**ppfcb,
	PGNO	pgnoTableFDP,
	CHAR	*szFileName,
	BOOL fCreatingSys )
	{
	ERR		err;
	FDB		*pfdbNew = pfdbNil;

	Assert( ppfcb != NULL );
	Assert( *ppfcb == pfcbNil );
	Assert( ppib != ppibNil );
	Assert( ppib->level < levelMax );

	/*	build FDB and index definitions
	/**/
	if ( szFileName != NULL )
		{
		Call( ErrCATConstructCATFDB( &pfdbNew, szFileName ) );
		Call( ErrCATGetCATIndexInfo( ppib, dbid, ppfcb, pfdbNew, pgnoTableFDP, szFileName, fCreatingSys ) );
		}
	else
		{
		Call( ErrCATConstructFDB( ppib, dbid, pgnoTableFDP, &pfdbNew ) );
		Call( ErrCATGetIndexInfo( ppib, dbid, ppfcb, pfdbNew, pgnoTableFDP ) );
		}

	// Defer setting these until actually needed.
	Assert( (*ppfcb)->ulLongIdMax == 0 );
	Assert( (*ppfcb)->dbkMost == 0 );

	return JET_errSuccess;

	/*	error handling
	/**/
HandleError:	
	if ( *ppfcb != pfcbNil )
		{
		FCB *pfcbT, *pfcbKill;

		pfcbT = *ppfcb;
		if ( pfcbT->pfdb != pfdbNil )		// Check if clustered index has FDB attached to it.
			{
			Assert( pfcbT->pfdb == pfdbNew );
			pfcbT->pfdb = pfdbNil;			// Defer freeing FDB until below.
			}
		do
			{
			if ( pfcbT->pidb != pidbNil )
				{
				RECFreeIDB( pfcbT->pidb );
				}
			pfcbKill = pfcbT;
			pfcbT = pfcbT->pfcbNextIndex;
			Assert( pfcbKill->cVersion == 0 );
			MEMReleasePfcb( pfcbKill );
			}
		while ( pfcbT != pfcbNil );
		}

	if ( pfdbNew != pfdbNil )
		{
		FDBDestruct( pfdbNew );
		}

	return err;
	}


// To build a default record, we need a fake FUCB and FCB for RECSetColumn().
// We also need to allocate a temporary buffer in which to store the default
// record.
ERR ErrFILEPrepareDefaultRecord( FUCB *pfucbFake, FCB *pfcbFake, FDB *pfdb )
	{
	ERR		err;
	RECHDR	*prechdr;

	pfcbFake->pfdb = pfdb;			// Attach a real FDB and a fake FCB.
	pfucbFake->u.pfcb = pfcbFake;
	FUCBSetIndex( pfucbFake );

	Call( ErrBFAllocTempBuffer( &pfucbFake->pbfWorkBuf ) );
	pfucbFake->lineWorkBuf.pb = (BYTE *)pfucbFake->pbfWorkBuf->ppage;

	prechdr = (RECHDR *)pfucbFake->lineWorkBuf.pb;
	prechdr->fidFixedLastInRec = (BYTE)( fidFixedLeast - 1 );
	prechdr->fidVarLastInRec = (BYTE)( fidVarLeast - 1 );

	pfucbFake->lineWorkBuf.cb = cbRECRecordMin;
	*(WORD *)( prechdr + 1 ) = (WORD)pfucbFake->lineWorkBuf.cb;	// offset to tagged

HandleError:
	return err;
	}


ERR ErrFDBRebuildDefaultRec(
	FDB			*pfdb,
	FID  		fidAdd,
	LINE		*plineDefault )
	{
	ERR			err = JET_errSuccess;
	BYTE		*pb = NULL;
	BOOL		fDefaultRecordPrepared = fFalse;
	LINE		lineDefaultValue;
	FID			fidT;
	FIELD		*pfieldT;
	FUCB		fucbFake;
	FCB			fcbFake;

	CallR( ErrFILEPrepareDefaultRecord( &fucbFake, &fcbFake, pfdb ) );
	fDefaultRecordPrepared = fTrue;

	pfieldT = PfieldFDBFixed( pfdb );
	for ( fidT = fidFixedLeast; ;
		fidT++, pfieldT++ )
		{
		/*	when we hit the last fixed column, skip to the variable columns
		/**/
		if ( fidT == pfdb->fidFixedLast + 1 )
			{
			fidT = fidVarLeast;
			pfieldT = PfieldFDBVar( pfdb );
			}

		/*	when we hit the last variable column, skip to the tagged columns
		/**/
		if ( fidT == pfdb->fidVarLast + 1 )
			{
			fidT = fidTaggedLeast;
			pfieldT = PfieldFDBTagged( pfdb );
			}

		/*	when we hit the last tagged column, get out
		/**/
		if ( fidT >pfdb->fidTaggedLast )
			break;
	
		Assert( ( fidT >= fidFixedLeast && fidT <= pfdb->fidFixedLast )  ||
			( fidT >= fidVarLeast && fidT <= pfdb->fidVarLast )  ||
			( fidT >= fidTaggedLeast && fidT <= pfdb->fidTaggedLast ) );

		/*	make sure column not deleted
		/**/
		if ( pfieldT->coltyp != JET_coltypNil  &&  FFIELDDefault( pfieldT->ffield ) )
			{
			if ( fidT == fidAdd )
				{
				Assert( plineDefault );
				lineDefaultValue = *plineDefault;
				}
			else
				{
				/*	get the old value from the old FDB
				/**/
				Call( ErrRECIRetrieveColumn( pfdb, &pfdb->lineDefaultRecord,
					&fidT, NULL, 1, &lineDefaultValue, 0 ) );
				if ( err == wrnRECLongField )
					{
					// Default long values must be intrinsic.
					Assert( !FFieldIsSLong( lineDefaultValue.pb ) );
					lineDefaultValue.pb += offsetof( LV, rgb );
					lineDefaultValue.cb -= offsetof( LV, rgb );
					}
				}

			Assert( lineDefaultValue.pb != NULL  &&  lineDefaultValue.cb > 0 );
			Call( ErrRECSetDefaultValue( &fucbFake, fidT, lineDefaultValue.pb, lineDefaultValue.cb ) );
			}
		}

	/*	alloc and copy default record, release working buffer
	/**/
	pb = SAlloc( fucbFake.lineWorkBuf.cb );
	if ( pb == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	/*	free old default record
	/**/
	SFree( pfdb->lineDefaultRecord.pb );

	pfdb->lineDefaultRecord.pb = pb;
	LineCopy( &pfdb->lineDefaultRecord, &fucbFake.lineWorkBuf );

HandleError:
	/*	reset copy buffer
	/**/
	if ( fDefaultRecordPrepared )
		{
		FILEFreeDefaultRecord( &fucbFake );
		}

	return err;
	}


VOID FDBDestruct( FDB *pfdb )
	{
	Assert( pfdb != NULL );

	Assert( pfdb->rgb != NULL );
	MEMFreeMemBuf( pfdb->rgb );

	if ( pfdb->lineDefaultRecord.pb != NULL )
		SFree( pfdb->lineDefaultRecord.pb );
	SFree( pfdb );
	return;
	}


/*	set all table FCBs to given pfdb.  Used during reversion to
/*	saved FDB during DDL operation.
/**/
VOID FDBSet( FCB *pfcb, FDB *pfdb )
	{
	FCB	*pfcbT;

 	/*	correct non-clusterred index FCBs to new FDB
	/**/
	for ( pfcbT = pfcb;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		pfcbT->pfdb = pfdb;
		}

	return;
	}


//+INTERNAL
// FILEIDeallocateFileFCB
// ========================================================================
// FILEIDeallocateFileFCB( FCB *pfcb )
//
// Frees memory allocations associated with a file FCB and all of its
// secondary index FCBs.
//
// PARAMETERS	
//		pfcb			pointer to FCB to deallocate
//
//-
VOID FILEIDeallocateFileFCB( FCB *pfcb )
	{
	FCB		*pfcbIdx;
	FCB		*pfcbT;

	Assert( pfcb != pfcbNil );
	Assert( CVersionFCB( pfcb ) == 0 );

	/*	delete FCB hash table entry
	/**/
	pfcbIdx = pfcb->pfcbNextIndex;
	
	Assert( fRecovering ||
		pfcb->pgnoFDP == pgnoNull ||		// If FCB aborted during FILEOpenTable()
		PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb );
	if ( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) != pfcbNil )
		{
		Assert( PfcbFCBGet( pfcb->dbid, pfcb->pgnoFDP ) == pfcb );
		FCBDeleteHashTable( pfcb );
		}

	while ( pfcbIdx != pfcbNil )
		{
		/*	return the memory used
		/**/
		Assert( pfcbIdx->pidb != pidbNil );
		RECFreeIDB( pfcbIdx->pidb );
		pfcbT = pfcbIdx->pfcbNextIndex;
		Assert( PfcbFCBGet( pfcbIdx->dbid, pfcbIdx->pgnoFDP ) == pfcbNil );
		Assert( pfcbIdx->cVersion == 0 );
		Assert( pfcbIdx->crefWriteLatch == 0 );
		Assert( pfcbIdx->crefReadLatch == 0 );
		MEMReleasePfcb( pfcbIdx );
		pfcbIdx = pfcbT;
		}

	/*	if fcb was on table was opened during the creation of
	/*	this FCB, then szFileName would not be set
	/**/
	if ( pfcb->szFileName != NULL )
		{
		SFree( pfcb->szFileName );
		}
	if ( pfcb->pfdb != pfdbNil )
		{
		FDBDestruct( (FDB *)pfcb->pfdb );
		(FDB *)pfcb->pfdb = pfdbNil;
		}
	if ( pfcb->pidb != pidbNil )
		{
		RECFreeIDB( pfcb->pidb );
		pfcb->pidb = pidbNil;
		}

	Assert( CVersionFCB( pfcb ) == 0 );
	Assert( pfcb->crefWriteLatch == 0 );
	Assert( pfcb->crefReadLatch == 0 );
	MEMReleasePfcb( pfcb );
	return;
	}


/*	combines all index column masks into a single per table
/*	index mask, used for index update check skip.
/**/
VOID FILESetAllIndexMask( FCB *pfcbTable )
	{
	FCB		*pfcbT;
	LONG	*plMax;
	LONG	*plAll;
	LONG	*plIndex;

	/*	initialize variables
	/**/
	plMax = (LONG *)pfcbTable->rgbitAllIndex +
		sizeof( pfcbTable->rgbitAllIndex ) / sizeof(LONG);

	/*	initialize mask to clustered index, or to 0s for sequential file.
	/**/
	if ( pfcbTable->pidb != pidbNil )
		{
		memcpy( pfcbTable->rgbitAllIndex,
			pfcbTable->pidb->rgbitIdx,
			sizeof( pfcbTable->pidb->rgbitIdx ) );
		}
	else
		{
		memset( pfcbTable->rgbitAllIndex, '\0', sizeof(pfcbTable->rgbitAllIndex) );
		}

	/*	for each non-clustered index, combine index mask with all index
	/*	mask.  Also, combine has tagged flag.
	/**/
	for ( pfcbT = pfcbTable->pfcbNextIndex;
		pfcbT != pfcbNil;
		pfcbT = pfcbT->pfcbNextIndex )
		{
		plAll = (LONG *) pfcbTable->rgbitAllIndex;
		plIndex = (LONG *)pfcbT->pidb->rgbitIdx;
		for ( ; plAll < plMax; plAll++, plIndex++ )
			{
			*plAll |= *plIndex;
			}
		}

	return;
	}


FIELD *PfieldFCBFromColumnName( FCB *pfcb, CHAR *szName )
	{
	FDB		*pfdb;
	FIELD  	*pfield, *pfieldStart;

	pfdb = (FDB *)pfcb->pfdb;
	pfield = PfieldFDBFixed( pfdb );

	pfieldStart = PfieldFDBFixed( pfdb );
	pfield = PfieldFDBTagged( pfdb ) + ( pfdb->fidTaggedLast - fidTaggedLeast );

	/*	search tagged, variable, and fixed fields, in that order
	/**/
	for ( ; pfield >= pfieldStart; pfield-- )
		{
		Assert( pfield >= PfieldFDBFixed( pfdb ) );
		Assert( pfield <= PfieldFDBTagged( pfdb ) + ( pfdb->fidTaggedLast - fidTaggedLeast ) );
		if ( pfield->coltyp != JET_coltypNil  &&
			UtilCmpName( SzMEMGetString( pfdb->rgb, pfield->itagFieldName ), szName ) == 0 )
			{
			return pfield;
			}
		}

	/*	did not find column
	/**/
	return NULL;
	}


FCB *PfcbFCBFromIndexName( FCB *pfcbTable, CHAR *szName )
	{
	FCB	*pfcb;

	/*	find index FCB and change name.
	/**/
	for ( pfcb = pfcbTable; pfcb != pfcbNil; pfcb = pfcb->pfcbNextIndex )
		{
		if ( pfcb->pidb != NULL &&
			UtilCmpName( pfcb->pidb->szName, szName ) == 0 )
			{
			break;
			}
		}
	return pfcb;
	}


FIELD *PfieldFDBFromFid( FDB *pfdb, FID fid )
	{
	if ( FFixedFid( fid ) )
		{
		Assert( fid <= pfdb->fidFixedLast );
		return PfieldFDBFixed( pfdb ) + (fid - fidFixedLeast);
		}
	else if ( FVarFid( fid ) )
		{
		Assert( fid <= pfdb->fidVarLast );
		return PfieldFDBVar( pfdb ) + (fid - fidVarLeast);
		}
	else
		{
		Assert( FTaggedFid( fid ) );
		Assert( fid <= pfdb->fidTaggedLast );
		return PfieldFDBTagged( pfdb ) + (fid - fidTaggedLeast);
		}
	}


#ifdef DEBUG
ERR	ErrFILEDumpTable( PIB *ppib, DBID dbid, CHAR *szTable )
	{
	ERR		err = JET_errSuccess;
	FUCB  	*pfucb = pfucbNil;

	Call( ErrFILEOpenTable( ppib, dbid, &pfucb, szTable, JET_bitTableDenyRead ) );

	/*	move to table root
	/**/
	DIRGotoFDPRoot( pfucb );

	/*	dump table
	/**/
	Call( ErrDIRDump( pfucb, 0 ) );

HandleError:
	if ( pfucb != pfucbNil )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}

	return err;
	}
#endif	// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\fldext.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */

INLINE LOCAL ERR ErrRECIRetrieveColumns( FUCB *pfucb, JET_RETRIEVECOLUMN *pretcols, ULONG cretcols );


//+API
//	ErrRECIRetrieveColumn
//	========================================================================
//	ErrRECIRetrieveColumn( FDB *pfdb, LINE *plineRec, FID *pfid, ULONG itagSequence, ULONG *pitagSequence, LINE *plineField)
//
//	Retrieves a column from a record.  This amounts to returning a pointer
//	into the record (to where the column data starts) and a count of the
//	number of bytes in the column data.
//
//	PARAMETERS	pfdb				column descriptors for this record
//				plineRec			record to retreive column from
//				pfid				column id of column to retrieve
//						  			If this parameter is zero, then the
//						  			tagged columns are scanned without
//						  			regard to their column ids, and occurance
//						  			number "itagSequence" is returned.  This can
//						  			be used to sequentially scan all values in
//						  			the tagged area of the record.	The column
//						  			id of the column value returned is placed
//						  			in *pfid as an output parameter.
//				itagSequence	  	if a tagged column is being retrieved,
//								  	this parameter specifies which occurance
//								  	of the tagged column to retrieve.	 Tagged
//								  	column occurances are number consecutively
//								  	starting with 1.  Occurance numbers greater
//								  	than the maximum occurance in the record
//								  	are returned as NULL-valued columns.
//	 			plineField			Receives retrieved column.  plineField->pb
//								  	will point into the record, at the start
//								  	of the column.  plineField->cb will be set
//								  	to the length of the column data.
//								  	If the column requested contains a NULL
//								  	value, then plineField->pb will be set to
//								  	NULL and plineField->cb will be set to 0.
//								  	Additionally, JET_wrnColumnNull would be returned
//	RETURNS	
//		JET_errSuccess			 	Everything worked.
//		JET_errColumnInvalid	 	The column id given does not
//	 	   						 	correspond to a defined column.
//		JET_wrnColumnNull 			Retrieved column has null value
//-
ERR ErrRECIRetrieveColumn(
	FDB		*pfdb,
	LINE  	*plineRec,
	FID		*pfid,
	ULONG 	*pitagSequence,
	ULONG 	itagSequence,
	LINE  	*plineField,
	ULONG	grbit )
	{
	ERR					err;
	FID	 	 			fid;			   	   	// column to retrieve
	ULONG 				ulNumOccurrences;  	   	// counts column occurances
	BYTE				*pbRec;					// efficiency var: ptr to record data
	FID					fidFixedLastInRec;		// highest fixed fid actually in record
	FID					fidVarLastInRec;		// highest var fid actually in record
	WORD UNALIGNED 		*pibVarOffs;			// pointer to var column offsets
	FIELD				*pfield;
	BYTE				*pbRecMax;				// end of current data record
	TAGFLD UNALIGNED	*ptagfld;				// pointer to tagged column

	Assert(	grbit == 0  ||
			grbit == JET_bitRetrieveNull  ||
			grbit == JET_bitRetrieveIgnoreDefault  ||
			grbit == ( JET_bitRetrieveNull | JET_bitRetrieveIgnoreDefault ) );

	Assert( pfid != NULL );
	fid = *pfid;
	Assert( pfdb != pfdbNil );
	Assert( !FLineNull( plineRec ) );
	Assert( plineRec->cb >= cbRECRecordMin );
	pbRec = plineRec->pb;
	Assert( plineField != NULL );
	fidFixedLastInRec = ((RECHDR*)pbRec)->fidFixedLastInRec;
	Assert( fidFixedLastInRec >= (BYTE)(fidFixedLeast - 1) &&
		fidFixedLastInRec <= (BYTE)(fidFixedMost) );

	/*** ---------EXTRACTING FIXED FIELD-------- ***/
	if ( FFixedFid( fid ) )
		{
		BYTE	*prgbitNullity;		// pointer to fixed column bitmap
		WORD	*pibFixOffs;		// fixed column offsets

		if ( fid > pfdb->fidFixedLast )
			return ErrERRCheck( JET_errColumnNotFound );

		pfield = PfieldFDBFixed( pfdb ) + ( fid - fidFixedLeast );
		if ( pfield->coltyp == JET_coltypNil )
			return ErrERRCheck( JET_errColumnNotFound );

		/*	column not represented in record, retrieve from default
		/*	or null column.
		/**/
		if ( fid > fidFixedLastInRec )
			{
			/*	if default value set, then retrieve default
			/**/
			if ( FFIELDDefault( pfield->ffield ) )
				{
				/*	assert no infinite recursion
				/**/
				Assert( plineRec != &pfdb->lineDefaultRecord );
				err = ErrRECIRetrieveColumn(
					pfdb,
					&pfdb->lineDefaultRecord,
					pfid,
					pitagSequence,
					itagSequence,
					plineField,
					0 );
				return err;
				}

			goto NullField;
			}

		/*	adjust fid to an index
		/**/
		fid -= fidFixedLeast;

		/*	byte containing bit representing fid's nullity
		/**/
		pibFixOffs = PibFDBFixedOffsets( pfdb );
		prgbitNullity = pbRec + pibFixOffs[fidFixedLastInRec] + fid/8;

		/*	bit is not set: column is NULL
		/**/
		if ( FFixedNullBit( prgbitNullity, fid ) )
			goto NullField;

		/*	set output parameter to length and address of column
		/**/
		Assert( pfield == ( PfieldFDBFixed( pfdb ) + fid ) );
		Assert( pfield->cbMaxLen == 
			UlCATColumnSize( pfield->coltyp, pfield->cbMaxLen, NULL ) );
		plineField->cb = pfield->cbMaxLen;
		plineField->pb = pbRec + pibFixOffs[fid];
		return JET_errSuccess;
		}

	/*	more efficiency variables
	/**/
	fidVarLastInRec = ((RECHDR*)pbRec)->fidVarLastInRec;
	Assert( fidVarLastInRec >= (BYTE)(fidVarLeast-1) &&
		fidVarLastInRec <= (BYTE)(fidVarMost));
	pibVarOffs = (WORD *)(pbRec + PibFDBFixedOffsets( pfdb )[fidFixedLastInRec] +
		(fidFixedLastInRec + 7) / 8);
	Assert( pibVarOffs[fidVarLastInRec+1-fidVarLeast] <= plineRec->cb );

	/*** ---------EXTRACTING VARIABLE FIELD-------- ***/
	if ( FVarFid( fid ) )
		{
		if ( fid > pfdb->fidVarLast )
			return ErrERRCheck( JET_errColumnNotFound );

		pfield = PfieldFDBVar( pfdb ) + ( fid - fidVarLeast );
		if ( pfield->coltyp == JET_coltypNil )
			return ErrERRCheck( JET_errColumnNotFound );

		/*	column not represented in record: column is NULL
		/**/
		if ( fid > fidVarLastInRec )
			{
			/*	if default value set, then retrieve default
			/**/
			if ( FFIELDDefault( pfield->ffield ) )
				{
				/*	assert no infinite recursion
				/**/
				Assert( plineRec != &pfdb->lineDefaultRecord );
				err = ErrRECIRetrieveColumn(
					pfdb,
					&pfdb->lineDefaultRecord,
					pfid,
					pitagSequence,
					itagSequence,
					plineField,
					0 );
				return err;
				}

			goto NullField;
			}

		/*	adjust fid to an index
		/**/
		fid -= fidVarLeast;

		/*	set output parameter: column length
		/**/
		plineField->cb = ibVarOffset( pibVarOffs[fid+1] ) - ibVarOffset( pibVarOffs[fid] );
		Assert( plineField->cb <= plineRec->cb );

		/*	column is set to Null
		/**/
		if ( FVarNullBit( pibVarOffs[fid] ) )
			{
			Assert( plineField->cb == 0 );
			goto NullField;
			}

		/*	length is zero: return success [zero-length non-null values are allowed]
		/**/
		if ( plineField->cb == 0 )
			{
			plineField->pb = NULL;
			return JET_errSuccess;
			}

		/*	set output parameter: column address
		/**/
		plineField->pb = pbRec + ibVarOffset( pibVarOffs[fid] );
		Assert( plineField->pb >= pbRec && plineField->pb <= pbRec+plineRec->cb );
		return JET_errSuccess;
		}

	/*** ---------EXTRACTING TAGGED FIELD-------- ***/

	/*	for the first occurrence, itagSequence must be 1, not 0
	/**/
	if ( itagSequence == 0 )
		return ErrERRCheck( JET_errBadItagSequence );

	if ( fid > pfdb->fidTaggedLast )
		return ErrERRCheck( JET_errColumnNotFound );

	Assert( FTaggedFid(fid) || fid == 0 );

	pfield = PfieldFDBTagged( pfdb );

	/*	scan tagged columns, counting occurances of desired column
	/**/
	pbRecMax = pbRec + plineRec->cb;
	
	// Null bit shouldn't be set for last entry in variable offsets table, which is
	// really the entry that points to the tagged columns.
	Assert( !FVarNullBit( pibVarOffs[fidVarLastInRec+1-fidVarLeast] ) );
	Assert( ibVarOffset( pibVarOffs[fidVarLastInRec+1-fidVarLeast] ) ==
		pibVarOffs[fidVarLastInRec+1-fidVarLeast] );

	ptagfld = (TAGFLD UNALIGNED *)(pbRec + pibVarOffs[fidVarLastInRec+1-fidVarLeast] );
	ulNumOccurrences = 0;

	/*	if fid == 0, then all tagged columns are being retrieved
	/**/
	if ( fid == 0 )
		{
		FID		fidCurr = fidTaggedLeast;
		BOOL	fRetrieveNulls = ( grbit & JET_bitRetrieveNull );
		BOOL	fRetrieveDefaults = !( grbit & JET_bitRetrieveIgnoreDefault );

		Assert( (BYTE *)ptagfld <= pbRecMax );
		while ( (BYTE *)ptagfld < pbRecMax )
			{
			Assert( FTaggedFid( ptagfld->fid ) );
			if ( fGlobalRepair && ptagfld->fid > pfdb->fidTaggedLast )
				{
				/*	log event
				/**/
				UtilReportEvent( EVENTLOG_WARNING_TYPE, REPAIR_CATEGORY, REPAIR_BAD_COLUMN_ID, 0, NULL );
				break;
				}
			Assert( ptagfld->fid <= pfdb->fidTaggedLast );

			// Check for any "gaps" caused by default values (if we want default
			// values retrieved).
			if ( fRetrieveDefaults )
				{
				for ( ; fidCurr < ptagfld->fid; fidCurr++ )
					{
					Assert( ulNumOccurrences < itagSequence );
					if ( FFIELDDefault( pfield[fidCurr - fidTaggedLeast].ffield )  &&
						pfield[fidCurr - fidTaggedLeast].coltyp != JET_coltypNil  &&
						++ulNumOccurrences == itagSequence )
						{
						*pfid = fidCurr;
						if ( pitagSequence != NULL )
							*pitagSequence = 1;

						Assert( plineRec != &pfdb->lineDefaultRecord );	// No infinite recursion.
						return ErrRECIRetrieveDefaultValue( pfdb, pfid, plineField );
						}
					}
				Assert( fidCurr == ptagfld->fid );
				}
			else
				fidCurr = ptagfld->fid;

			// Only count columns explicitly set to null if the RetrieveSetTagged
			// flag is passed.  Otherwise, just skip it.
			if ( ptagfld->fNull )
				{
				// If there's an explicit null entry, it should be the only
				// occurrence of this fid.  Also the only reason for an explict
				// null entry is to override a default value.
				Assert( FRECLastTaggedInstance( fidCurr, ptagfld, pbRecMax ) );
				Assert( ptagfld->cb == 0 );
				Assert( FFIELDDefault( pfield[fidCurr-fidTaggedLeast].ffield ) );
				Assert( ulNumOccurrences < itagSequence );

				if ( fRetrieveNulls && ++ulNumOccurrences == itagSequence )
					{
					*pfid = ptagfld->fid;
					if ( pitagSequence != NULL )
						*pitagSequence = 1;

					plineField->cb = 0;
					plineField->pb = NULL;
					return ErrERRCheck( JET_wrnColumnSetNull );
					}

				ptagfld = PtagfldNext( ptagfld );
				Assert( (BYTE *)ptagfld <= pbRecMax );
				}

			else if ( pfield[fidCurr - fidTaggedLeast].coltyp == JET_coltypNil )
				{
				// Column has been deleted.  Skip all tagfld entries with this fid.
				do
					{
					ptagfld = PtagfldNext( ptagfld );
					Assert( (BYTE *)ptagfld <= pbRecMax );
					}
				while ( (BYTE *)ptagfld < pbRecMax  &&  ptagfld->fid == fidCurr );
				}

			else
				{
				ULONG ulCurrFidOccurrences = 0;

				do	{
					ulCurrFidOccurrences++;
					Assert( !ptagfld->fNull );
					Assert( ulNumOccurrences < itagSequence );

					if ( ++ulNumOccurrences == itagSequence )
						{
						plineField->cb = ptagfld->cb;
						plineField->pb = ptagfld->rgb;

						*pfid = fidCurr;
						if ( pitagSequence != NULL )
							*pitagSequence = ulCurrFidOccurrences;

						// return success, or warning if column found is a long value.
						return ( FRECLongValue( pfield[fidCurr-fidTaggedLeast].coltyp ) ?
							ErrERRCheck( wrnRECLongField ) : JET_errSuccess );
						}

					ptagfld = PtagfldNext( ptagfld );
					Assert( (BYTE *)ptagfld <= pbRecMax );
					}
				while ( (BYTE *)ptagfld < pbRecMax  &&  ptagfld->fid == fidCurr );
				
				}	// if ( ptagfld->fNull )

			fidCurr++;

			}	// while ( ptagfld < pbRecMax )


		if ( fRetrieveDefaults )
			{
			// If we want default values, check for any beyond the last
			// tagged column in the record.
			for ( ; fidCurr <= pfdb->fidTaggedLast; fidCurr++ )
				{
				Assert( ulNumOccurrences < itagSequence );
				if ( FFIELDDefault( pfield[fidCurr - fidTaggedLeast].ffield )  &&
					pfield[fidCurr - fidTaggedLeast].coltyp != JET_coltypNil  &&
					++ulNumOccurrences == itagSequence )
					{
					*pfid = fidCurr;
					if ( pitagSequence != NULL )
						*pitagSequence = 1;

					Assert( plineRec != &pfdb->lineDefaultRecord );	// No infinite recursion.
					return ErrRECIRetrieveDefaultValue( pfdb, pfid, plineField );
					}
				}
			}

		// If we reached here, no more tagged columns.
		*pfid = 0;
		if ( pitagSequence != NULL )
			*pitagSequence = 0;
		}
	else if ( pfield[fid - fidTaggedLeast].coltyp == JET_coltypNil )
		{
		// Specifid fid requested, but the column has been deleted.
		return ErrERRCheck( JET_errColumnNotFound );
		}
	else	// if ( fid == 0 )
		{
		/*	retrieving specific fid
		/**/
		Assert( *pfid == fid );

		/*	skip all tagged fields until we reach the one we want
		/**/
		while ( (BYTE *)ptagfld < pbRecMax && ptagfld->fid < fid )
			{
			Assert( FTaggedFid( ptagfld->fid ) );
			Assert( ptagfld->fid <= pfdb->fidTaggedLast );
			ptagfld = PtagfldNext( ptagfld );
			Assert( (BYTE *)ptagfld <= pbRecMax );
			}

		/*	did we find the field we are looking for
		/**/
		if ( (BYTE *)ptagfld < pbRecMax  &&  ptagfld->fid == fid )
			{
			/*	if there is an explicit null entry, then it should be the only
			/*	occurrence of that column.  Also, the only reason for an explicit
			/*	null entry is to override a default value.
			/**/
			Assert( !ptagfld->fNull  ||  FRECLastTaggedInstance( fid, ptagfld, pbRecMax ) );
			Assert( !ptagfld->fNull  ||  ptagfld->cb == 0 );
			Assert( !ptagfld->fNull  ||  FFIELDDefault( pfield[fid-fidTaggedLeast].ffield ) );

			/*	if non-null, find the occurrence we want
			/*	else fall through to NullField.
			/**/
			if ( !ptagfld->fNull )
				{
				Assert( ulNumOccurrences == 0 );
				do
					{
					Assert( !ptagfld->fNull );
					Assert( ulNumOccurrences < itagSequence );

					if ( ++ulNumOccurrences == itagSequence )
						{
						plineField->cb = ptagfld->cb;
						plineField->pb = ptagfld->rgb;

						// return success, or warning if column found is a long value.
						return ( FRECLongValue( pfield[fid-fidTaggedLeast].coltyp ) ?
							ErrERRCheck( wrnRECLongField ) : JET_errSuccess );
						}
					ptagfld = PtagfldNext( ptagfld );
					Assert( (BYTE *)ptagfld <= pbRecMax );
					}
				while ( (BYTE *)ptagfld < pbRecMax  &&  ptagfld->fid == fid );

				// If we reached here, our desired occurrrence is not in the
				// record.  Fall through to NullField.
				Assert( ulNumOccurrences < itagSequence );
				}
			}
		else if ( !( grbit & JET_bitRetrieveIgnoreDefault )
			&& FFIELDDefault( pfield[fid-fidTaggedLeast].ffield )
			&& itagSequence == 1 )
			{
			/*	no occurrrences found, but a default value exists and
			/*	we are retrieving first occcurence.
			/**/
			Assert( ulNumOccurrences == 0 );
			Assert( plineRec != &pfdb->lineDefaultRecord );
			return ErrRECIRetrieveDefaultValue( pfdb, pfid, plineField );
			}
		}	// if ( fid == 0 )

	/*	occurrence not found, column is NULL, fall through
	/**/
NullField:
	/*	null column common exit point
	/**/
	plineField->cb = 0;
	plineField->pb = NULL;
	return ErrERRCheck( JET_wrnColumnNull );
	}



/*	counts number of columns for a given column id in a given record.
/**/
ERR ErrRECCountColumn( FUCB *pfucb, FID fid, INT *pccolumn, JET_GRBIT grbit )
	{
	ERR					err = JET_errSuccess;
	LINE  				lineRec;
	FDB					*pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	INT					ccolumn = 0;
	BYTE  				*pbRec;				   	// efficiency var: ptr to record data
	FID					fidFixedLastInRec;		// highest fixed fid actually in record
	FID					fidVarLastInRec;	   	// highest var fid actually in record
	WORD UNALIGNED 		*pibVarOffs;		   	// pointer to var column offsets
	BYTE  				*pbRecMax;			   	// end of current data record
	TAGFLD UNALIGNED	*ptagfld;			   	// pointer to tagged column
	FIELD				*pfield;

	Assert( pfdb != pfdbNil );

	/*	get record
	/**/
	if ( ( grbit & JET_bitRetrieveCopy ) && FFUCBRetPrepared( pfucb ) )
		{
		/*	only index cursors have copy buffers.
		/**/
		Assert( FFUCBIndex( pfucb ) );
		lineRec = pfucb->lineWorkBuf;
		}
	else
		{
		if ( FFUCBIndex( pfucb ) )
			{
			CallR( ErrDIRGet( pfucb ) );
			}
		else
			{
			Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||
				PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst ||
				PcsrCurrent( pfucb )->csrstat == csrstatAfterLast );
			if ( PcsrCurrent( pfucb )->csrstat != csrstatOnCurNode )
				return ErrERRCheck( JET_errNoCurrentRecord );
			Assert( pfucb->lineData.cb != 0 || FFUCBIndex( pfucb ) );
			}
		lineRec = pfucb->lineData;
		}
	Assert( lineRec.cb >= cbRECRecordMin );
	pbRec = lineRec.pb;
	fidFixedLastInRec = ((RECHDR *)pbRec)->fidFixedLastInRec;
	Assert( fidFixedLastInRec >= (BYTE)(fidFixedLeast-1) &&
			fidFixedLastInRec <= (BYTE)(fidFixedMost));

	/*** ---------EXTRACTING FIXED FIELD-------- ***/
	if ( FFixedFid( fid ) )
		{
		BYTE *prgbitNullity;		// pointer to fixed column bitmap
		WORD *pibFixOffs;			// fixed column offsets

		if ( fid > pfdb->fidFixedLast )
			return ErrERRCheck( JET_errColumnNotFound );

		pfield = PfieldFDBFixed( pfdb );
		if ( pfield[fid-fidFixedLeast].coltyp == JET_coltypNil )
			return ErrERRCheck( JET_errColumnNotFound );

		/*	column never set
		/**/
		if ( fid > fidFixedLastInRec )
			{
			/*	if default value set, then retrieve default
			/**/
			if ( FFIELDDefault( pfield[fid - fidFixedLeast].ffield ) )
				{
				*pccolumn = 1;
				return JET_errSuccess;
				}
			goto NullField;
			}

		/*	adjust fid to index
		/**/
		fid -= fidFixedLeast;

		/*	byte containing bit representing fid's nullity
		/**/
		pibFixOffs = PibFDBFixedOffsets( pfdb );
		prgbitNullity = pbRec + pibFixOffs[fidFixedLastInRec] + fid/8;

		/*	column is NULL
		/**/
		if ( !( *prgbitNullity & ( 1 << fid % 8 ) ) )
			goto NullField;

		*pccolumn = 1;
		return JET_errSuccess;
		}

	/*** More efficiency variables ***/
	fidVarLastInRec = ((RECHDR*)pbRec)->fidVarLastInRec;
	Assert( fidVarLastInRec >= (BYTE)(fidVarLeast-1) &&
			fidVarLastInRec <= (BYTE)(fidVarMost));
	pibVarOffs = (WORD *)(pbRec + PibFDBFixedOffsets( pfdb )[fidFixedLastInRec] +
		(fidFixedLastInRec + 7) / 8);
	Assert(pibVarOffs[fidVarLastInRec+1-fidVarLeast] <= lineRec.cb);

	/*** ---------EXTRACTING VARIABLE FIELD-------- ***/
	if ( FVarFid( fid ) )
		{
		if ( fid > pfdb->fidVarLast )
			return ErrERRCheck( JET_errColumnNotFound );

		pfield = PfieldFDBFixed( pfdb );
		if ( pfield[fid-fidVarLeast].coltyp == JET_coltypNil )
			return ErrERRCheck( JET_errColumnNotFound );

		/*	column never set
		/**/
		if ( fid > fidVarLastInRec )
			{
			/*	if default value set, then retrieve default
			/**/
			if ( FFIELDDefault( pfield[fid - fidVarLeast].ffield ) )
				{
				*pccolumn = 1;
				return JET_errSuccess;
				}
			goto NullField;
			}

		/*	adjust fid to an index
		/**/
		fid -= fidVarLeast;

		/*	column is set to Null
		/**/
		if ( FVarNullBit( pibVarOffs[fid] ) )
			{
			goto NullField;
			}

		*pccolumn = 1;
		return JET_errSuccess;
		}

	/*** ---------EXTRACTING TAGGED FIELD-------- ***/
	if ( fid > pfdb->fidTaggedLast )
		return ErrERRCheck( JET_errColumnNotFound );
	Assert( FTaggedFid( fid ) || fid == 0 );

	pfield = PfieldFDBTagged( pfdb );

	/*	scan tagged columns, counting occurances of desired column
	/**/
	pbRecMax = pbRec + lineRec.cb;

	// Null bit shouldn't be set for last entry in variable offsets table, which is
	// really the entry that points to the tagged columns.
	Assert( !FVarNullBit( pibVarOffs[fidVarLastInRec+1-fidVarLeast] ) );
	Assert( ibVarOffset( pibVarOffs[fidVarLastInRec+1-fidVarLeast] ) ==
		pibVarOffs[fidVarLastInRec+1-fidVarLeast] );

	ptagfld = (TAGFLD UNALIGNED *)(pbRec + pibVarOffs[fidVarLastInRec+1-fidVarLeast] );

	// If fid==0, count all non-null, non-deleted columns, including unset columns
	// with default values.
	if ( fid == 0 )
		{
		FID	fidCurr = fidTaggedLeast;

		Assert( (BYTE *)ptagfld <= pbRecMax );
		while ( (BYTE *)ptagfld < pbRecMax )
			{
			Assert( FTaggedFid( ptagfld->fid ) );
			Assert( ptagfld->fid <= pfdb->fidTaggedLast );

			// Check for any "gaps" caused by default values.
			for ( ; fidCurr < ptagfld->fid; fidCurr++ )
				{
				if ( FFIELDDefault( pfield[fidCurr - fidTaggedLeast].ffield )  &&
					pfield[fidCurr - fidTaggedLeast].coltyp != JET_coltypNil )
					{
					++ccolumn;
					}
				}
			Assert( fidCurr == ptagfld->fid );

			// Don't count deleted columns or columns explicitly set to null.
			if ( ptagfld->fNull )
				{
				// If there's an explicit null entry, it should be the only
				// occurrence of this fid.  Also the only reason for an explict
				// null entry is to override a default value.
				Assert( FRECLastTaggedInstance( fidCurr, ptagfld, pbRecMax ) );
				Assert( ptagfld->cb == 0 );
				Assert( FFIELDDefault( pfield[fid-fidTaggedLeast].ffield ) );

				ptagfld = PtagfldNext( ptagfld );
				Assert( (BYTE *)ptagfld <= pbRecMax );
				}

			else if ( pfield[fidCurr - fidTaggedLeast].coltyp == JET_coltypNil )
				{
				// Column has been deleted.  Skip all tagfld entries with this fid.
				do
					{
					ptagfld = PtagfldNext( ptagfld );
					Assert( (BYTE *)ptagfld <= pbRecMax );
					}
				while ( (BYTE *)ptagfld < pbRecMax  &&  ptagfld->fid == fidCurr );
				}

			else
				{
				do	{
					++ccolumn;
					ptagfld = PtagfldNext( ptagfld );
					Assert( (BYTE *)ptagfld <= pbRecMax );
					}
				while ( (BYTE *)ptagfld < pbRecMax  &&  ptagfld->fid == fidCurr );
				
				}	// if ( ptagfld->fNull )

			fidCurr++;

			}	// while ( ptagfld < pbRecMax )


		// Check for default values beyond the last tagged column in the record.
		for ( ; fidCurr <= pfdb->fidTaggedLast; fidCurr++ )
			{
			if ( FFIELDDefault( pfield[fidCurr - fidTaggedLeast].ffield )  &&
				pfield[fidCurr - fidTaggedLeast].coltyp != JET_coltypNil )
				{
				++ccolumn;
				}
			}
		}

	else if ( pfield[fid - fidTaggedLeast].coltyp == JET_coltypNil )
		{
		// Specifid fid requested, but the column has been deleted.
		return ErrERRCheck( JET_errColumnNotFound );
		}

	else	// if ( fid == 0 )
		{
		/*	retrieving specific fid
		/**/

		// Skip all tagged fields until we reach the one we want.
		while ( (BYTE *)ptagfld < pbRecMax  &&  ptagfld->fid < fid )
			{
			Assert( FTaggedFid( ptagfld->fid ) );
			Assert( ptagfld->fid <= pfdb->fidTaggedLast );
			ptagfld = PtagfldNext( ptagfld );
			Assert( (BYTE *)ptagfld <= pbRecMax );
			}

		/*	Did we find the field we're looking for?
		/**/
		if ( (BYTE *)ptagfld < pbRecMax  &&  ptagfld->fid == fid )
			{
			/*	If there is an explicit null entry, then it should be the only
			/*	occurrence of that column.  Also, the only reason for an explicit
			/*	null entry is to override a default value.
			/**/
			Assert( !ptagfld->fNull  ||  FRECLastTaggedInstance( fid, ptagfld, pbRecMax ) );
			Assert( !ptagfld->fNull  ||  ptagfld->cb == 0 );
			Assert( !ptagfld->fNull  ||  FFIELDDefault( pfield[fid-fidTaggedLeast].ffield ) );

			/*	If non-null, find the occurrence we want.
			/*  If null, fall through to NullField.
			/**/
			if ( !ptagfld->fNull )
				{
				do
					{
					++ccolumn;
					ptagfld = PtagfldNext( ptagfld );
					Assert( (BYTE *)ptagfld <= pbRecMax );
					}
				while ( (BYTE *)ptagfld < pbRecMax  &&  ptagfld->fid == fid );
				}
			}
		
		else if ( FFIELDDefault( pfield[fid-fidTaggedLeast].ffield ) )
			{
			// No occurrrences found, but a default value exists, so account for it.
			ccolumn = 1;
			}

		}	// if ( fid == 0 )

NullField:
	*pccolumn = ccolumn;
	return JET_errSuccess;
	}


ERR ErrRECRetrieveColumn( FUCB *pfucb, FID *pfid, ULONG itagSequence, LINE *plineField, ULONG grbit )
	{
	ERR		err;
	FDB		*pfdb;
	ULONG	itagSequenceT;

	/*	set pfdb.  pfdb is same for indexes and for sorts.
	/**/
	Assert( pfucb->u.pfcb->pfdb == ((FCB*)pfucb->u.pscb)->pfdb );
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	Assert( pfdb != pfdbNil );

	/*	if retrieving from copy buffer.
	/**/
	if ( ( grbit & JET_bitRetrieveCopy ) && FFUCBRetPrepared( pfucb ) )
		{
		/*	only index cursors have copy buffers.
		/**/
		Assert( FFUCBIndex( pfucb ) );

		err = ErrRECIRetrieveColumn(
				pfdb,
				&pfucb->lineWorkBuf,
				pfid,
				&itagSequenceT,
				itagSequence,
				plineField,
				grbit & (JET_bitRetrieveNull|JET_bitRetrieveIgnoreDefault) );	// Filter out unsupported grbits.
		return err;
		}

	/*	get current data for index cursors.  Sorts always have
	/*	current data cached.
	/**/
	if ( FFUCBIndex( pfucb ) )
		{
		CallR( ErrDIRGet( pfucb ) );
		}
	else
		{
		Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||
			PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst ||
			PcsrCurrent( pfucb )->csrstat == csrstatAfterLast );
		if ( PcsrCurrent( pfucb )->csrstat != csrstatOnCurNode )
			return ErrERRCheck( JET_errNoCurrentRecord );
		Assert( pfucb->lineData.cb != 0 || FFUCBIndex( pfucb ) );
		}

	err = ErrRECIRetrieveColumn(
			pfdb,
			&pfucb->lineData,
			pfid,
			&itagSequenceT,
			itagSequence,
			plineField,
			grbit & (JET_bitRetrieveNull|JET_bitRetrieveIgnoreDefault) );	// Filter out unsupported grbits
	return err;
	}


ERR ErrRECIRetrieveFromIndex( FUCB *pfucb,
	FID 		fid,
	ULONG		*pitagSequence,
	BYTE		*pb,
	ULONG		cbMax,
	ULONG		*pcbActual,
	ULONG		ibGraphic,
	JET_GRBIT	grbit )
	{
	ERR			err;
	FUCB   		*pfucbIdx = pfucb->pfucbCurIndex;
	FDB			*pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	IDB			*pidb;
	BOOL   		fText = fFalse;
	BOOL   		fTagged = fFalse;
	BOOL   		fLongValue = fFalse;
	BOOL   		fUnicode = fFalse;
	INT			iidxseg;
	LINE   		lineColumn;
	BYTE   		rgb[JET_cbKeyMost];
	ULONG  		cbReturned;
	KEY			key;
	INT			itagSequence;
	FIELD		*pfield;

	/*	if on clustered index, then return code indicating that
	/*	retrieve should be from record.  Note, sequential files
	/*	having no indexes, will be natually handled this way.
	/**/
	if ( pfucbIdx == pfucbNil )
		{
		/*	the itagSequence should not be important since
		/*	clustered indexes are not allowed over multi-value
		/*	columns.
		/**/
	  	return ErrERRCheck( errDIRNoShortCircuit );
		}

	/*	determine column type so that long value warning can be returned.
	/*	this warning is used by the caller to support byte range
	/*	retrieval. Also, if coltype is Unicode, retrieve from Record only
	/**/
	if ( FFixedFid( fid ) )
		{
		pfield = PfieldFDBFixed( pfdb );
		fUnicode = ( pfield[fid - fidFixedLeast].cp == usUniCodePage );
		Assert( pfield[fid - fidFixedLeast].coltyp != JET_coltypLongText );
		fText = ( pfield[fid - fidFixedLeast].coltyp == JET_coltypText );
		}
	else if ( FVarFid( fid ) )
		{
		pfield = PfieldFDBVar( pfdb );
		fUnicode = ( pfield[fid - fidVarLeast].cp == usUniCodePage );
		Assert( pfield[fid - fidVarLeast].coltyp != JET_coltypLongText );
		fText = ( pfield[fid - fidVarLeast].coltyp == JET_coltypText );
		}
	else
		{
		fTagged = fTrue;
		pfield = PfieldFDBTagged( pfdb );
		fUnicode = ( pfield[fid - fidTaggedLeast].cp == usUniCodePage );
		fLongValue = FRECLongValue( pfield[fid - fidTaggedLeast].coltyp );
		fText = ( ( pfield[fid - fidTaggedLeast].coltyp == JET_coltypText )
			|| ( pfield[fid - fidTaggedLeast].coltyp == JET_coltypLongText ) );
		}

	/*	find index segment for given column id
	/**/
	pidb = pfucbIdx->u.pfcb->pidb;
	for ( iidxseg = 0; iidxseg < pidb->iidxsegMac; iidxseg++ )
		{
		if ( pidb->rgidxseg[iidxseg] == fid ||
			pidb->rgidxseg[iidxseg] == -fid )
			{
			break;
			}
		}
	Assert( iidxseg <= pidb->iidxsegMac );
	if ( iidxseg == pidb->iidxsegMac )
		{
		return ErrERRCheck( JET_errColumnNotFound );
		}

	/*	check for valid currency
	/**/
	Call( ErrDIRGet( pfucbIdx ) );

	/*	if key may have been truncated, then return code indicating
	/*	that retrieve should be from record.  Due to binary column
	/*	normalization, key may be truncated if greater than or equal
	/*	to JET_cbKeyMost - 8.
	/**/
	if ( pfucbIdx->keyNode.cb >= JET_cbKeyMost - 8
		|| fText
		|| fUnicode )
		{
		err = ErrERRCheck( errDIRNoShortCircuit );
		goto ComputeItag;
		}

	lineColumn.pb = rgb;
	Call( ErrRECIRetrieveColumnFromKey( pfdb, pidb, &pfucbIdx->keyNode, fid, &lineColumn ) );

	/*	if long value then effect offset
	/**/
	if ( fLongValue )
		{
		if ( pcbActual )
			{
			if ( ibGraphic >= lineColumn.cb  )
				*pcbActual = 0;
			else
				*pcbActual = lineColumn.cb - ibGraphic;
			}
		if ( lineColumn.cb == 0 )
			{
			Assert( err == JET_errSuccess );
			goto ComputeItag;
			}
		if ( ibGraphic >= lineColumn.cb )
			{
//			lineColumn.pb = NULL;
			lineColumn.cb = 0;
			}
		else
			{
			lineColumn.pb += ibGraphic;
			lineColumn.cb -= ibGraphic;
			}
		}

	/*	set return values
	/**/
	if ( pcbActual )
		*pcbActual = lineColumn.cb;
	if ( lineColumn.cb == 0 )
		{
		Assert( err == JET_errSuccess || err == JET_wrnColumnNull );
		goto ComputeItag;
		}
	if ( lineColumn.cb <= cbMax )
		{
		cbReturned = lineColumn.cb;
		Assert( err == JET_errSuccess );
		}
	else
		{
		cbReturned = cbMax;
		err = ErrERRCheck( JET_wrnBufferTruncated );
		}
	memcpy( pb, lineColumn.pb, (size_t)cbReturned );

ComputeItag:
	if ( err == errDIRNoShortCircuit || ( grbit & JET_bitRetrieveTag ) )
		{
		ERR errT = err;

		/*	retrieve keys from record and compare against current key
		/*	to compute itag for tagged column instance, responsible for
		/*	this index key.
		/**/
		Assert( fTagged || *pitagSequence == 1 );
		if ( fTagged )
			{
			key.pb = rgb;

			for ( itagSequence = 1; ;itagSequence++ )
				{
				/*	get record for key retrieval
				/**/
				Call( ErrDIRGet( pfucb ) );
				Call( ErrRECRetrieveKeyFromRecord( pfucb, pfdb, pidb,
					&key, itagSequence, fFalse ) );
				Call( ErrDIRGet( pfucbIdx ) );
				if ( memcmp( pfucbIdx->keyNode.pb, key.pb, min( pfucbIdx->keyNode.cb, key.cb ) ) == 0 )
					break;
				}
			err = ErrERRCheck( errDIRNoShortCircuit );
			if ( pitagSequence != NULL )
				{
				*pitagSequence = itagSequence;
				}
			}

		err = errT;
		}

HandleError:
	return err;
	}


ERR VTAPI ErrIsamRetrieveColumn(
	PIB	 			*ppib,
	FUCB		  	*pfucb,
	JET_COLUMNID	columnid,
	BYTE		  	*pb,
	ULONG		  	cbMax,
	ULONG		  	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo )
	{
	ERR				err;
	LINE			line;
	FID				fid = (FID)columnid;
	ULONG			itagSequence;
	ULONG			ibGraphic;
	ULONG			cbReturned;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );

	if ( pretinfo != NULL )
		{
		if ( pretinfo->cbStruct < sizeof(JET_RETINFO) )
			return ErrERRCheck( JET_errInvalidParameter );
		itagSequence = pretinfo->itagSequence;
		ibGraphic = pretinfo->ibLongValue;
		}
	else
		{
		itagSequence = 1;
		ibGraphic = 0;
		}

	if ( grbit & JET_bitRetrieveFromIndex )
		{
		err = ErrRECIRetrieveFromIndex( pfucb, fid, &itagSequence, pb, cbMax, pcbActual, ibGraphic, grbit );
		/*	return itagSequence if requested
		/**/
		if ( pretinfo != NULL &&
			( grbit & JET_bitRetrieveTag ) &&
			( err == errDIRNoShortCircuit || err >= 0 ) )
			{
			pretinfo->itagSequence = itagSequence;			
			}
		if ( err != errDIRNoShortCircuit )
			{
			return err;
		 	}
		}

	CallR( ErrRECRetrieveColumn( pfucb, &fid, itagSequence, &line, grbit ) );

	if ( err == wrnRECLongField )
		{
		/*	use line.cb to determine if long column
		/*	is intrinsic or separated
		/**/
		Assert( line.cb > 0 );
		if ( FFieldIsSLong( line.pb ) )
			{
			if ( grbit & JET_bitRetrieveLongId )
				{
				/* adjust line to intrinsic long column
				/**/
				line.pb += offsetof( LV, lid );
				line.cb -= offsetof( LV, lid );
				Assert( line.cb == sizeof(LID) );
				Assert( ibGraphic == 0 );
				if ( pcbActual )
					{
					*pcbActual = line.cb;
					}
				err = JET_wrnSeparateLongValue;
				}
			else
				{
				ULONG		cbActual;

				Assert( line.cb == sizeof( LV ) );

				CallR( ErrRECRetrieveSLongField( pfucb,
					LidOfLV( line.pb ),
					ibGraphic,
					pb,
					cbMax,
		  			&cbActual ) );

				/*	set return values
				/**/
				if ( pretinfo != NULL )
					pretinfo->columnidNextTagged = fid;
				if ( pcbActual )
					*pcbActual = cbActual;
				return cbMax < cbActual ? ErrERRCheck( JET_wrnBufferTruncated ) : JET_errSuccess;
				}
			}
		else
			{
			/* adjust line to intrinsic long column
			/**/
			line.pb += offsetof( LV, rgb );
			line.cb -= offsetof( LV, rgb );
			if ( pcbActual )
				{
				if ( ibGraphic >= line.cb  )
					*pcbActual = 0;
				else
					*pcbActual = line.cb - ibGraphic;
				}
			if ( ibGraphic >= line.cb )
				{
//				line.pb = NULL;
				line.cb = 0;
				}
			else
				{
				line.pb += ibGraphic;
				line.cb -= ibGraphic;
				}

			/*	change err to JET_errSuccess
			/**/
			Assert( err == wrnRECLongField );
			err = JET_errSuccess;
			}
		}

	/*** Set return values ***/
	if ( pcbActual )
		*pcbActual = line.cb;
	if ( pretinfo != NULL )
		pretinfo->columnidNextTagged = fid;
	if ( line.cb <= cbMax )
		{
		cbReturned = line.cb;
		}
	else
		{
		cbReturned = cbMax;
		err = ErrERRCheck( JET_wrnBufferTruncated );
		}
	memcpy( pb, line.pb, (size_t)cbReturned );
	return err;
	}


/*	This routine is mainly for reducing the number of calls to DIRGet
/*	while retrieving many columns from the same record
/*	retrieves many columns from a record and returns value in pretcol
/*	pcolinfo is used for passing intermediate info.
/**/
INLINE LOCAL ERR ErrRECIRetrieveColumns( FUCB *pfucb, JET_RETRIEVECOLUMN *pretcol, ULONG cretcol )
	{
	ERR					err;
	ULONG				cbReturned;
	BOOL				fBufferTruncated = fFalse;
	JET_RETRIEVECOLUMN	*pretcolMax = pretcol + cretcol;
	JET_RETRIEVECOLUMN	*pretcolT;

	/*	set pfdb, pfdb is same for indexes and for sorts
	/**/
	Assert( pfucb->u.pfcb->pfdb == ((FCB*)pfucb->u.pscb)->pfdb );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );

	/*	get current data for index cursors,
	/*	sorts always have current data cached.
	/**/
	if ( FFUCBIndex( pfucb ) )
		{
		CallR( ErrDIRGet( pfucb ) );
		}
	else
		{
		Assert( PcsrCurrent( pfucb )->csrstat == csrstatOnCurNode ||
			PcsrCurrent( pfucb )->csrstat == csrstatBeforeFirst ||
			PcsrCurrent( pfucb )->csrstat == csrstatAfterLast );
		if ( PcsrCurrent( pfucb )->csrstat != csrstatOnCurNode )
			return ErrERRCheck( JET_errNoCurrentRecord );
		Assert( pfucb->lineData.cb != 0 || FFUCBIndex( pfucb ) );
		}

	for ( pretcolT = pretcol; pretcolT < pretcolMax; pretcolT++ )
		{
		/* efficiency variables
		/**/
		FID		fid;
		ULONG	cbMax;
		ULONG	ibLongValue;
		ULONG	ulT;
		LINE 	line;

		/*	those columns needing retrieval will have error set
		/*	to JET_errNullInvalid.  Any other value indicates column
		/*	has already been retrieved from index or copy buffer or as count.
		/**/
		if ( pretcolT->err != JET_errNullInvalid )
			continue;

		/*	set efficiency variables
		/**/
		fid = (FID)pretcolT->columnid;
		cbMax = pretcolT->cbData;
		ibLongValue = pretcolT->ibLongValue;

		CallR( ErrRECIRetrieveColumn( (FDB *)pfucb->u.pfcb->pfdb,
			&pfucb->lineData,
			&fid,
			&ulT,
			pretcolT->itagSequence,
			&line,
			0 ) );

		if ( err == wrnRECLongField )
			{
			/*	use line.cb to determine if long column
			/*	is intrinsic or separated
			/**/
			Assert( line.cb > 0 );
			if ( FFieldIsSLong( line.pb ) )
				{
				if ( pretcolT->grbit & JET_bitRetrieveLongId )
					{
					/* adjust line to intrinsic long column
					/**/
					line.pb += offsetof( LV, lid );
					line.cb -= offsetof( LV, lid );
					Assert( line.cb == sizeof(LID) );
					Assert( pretcolT->ibLongValue == 0 );
					pretcolT->cbActual = line.cb;
					pretcolT->err = JET_wrnSeparateLongValue;
					}
				else
					{
					Assert( line.cb == sizeof( LV ) );

					CallR( ErrRECRetrieveSLongField( pfucb,
						LidOfLV( line.pb ),
						ibLongValue,
						pretcolT->pvData,
						cbMax,
				  		&pretcolT->cbActual ) );
					
					/*	set return values
					/**/
					if ( err != JET_wrnColumnNull )
						{
						err = JET_errSuccess;
	 					if ( cbMax < pretcolT->cbActual )
							{
							err = ErrERRCheck( JET_wrnBufferTruncated );
							fBufferTruncated = fTrue;
							}
						}
					pretcolT->err = err;
			  		pretcolT->columnidNextTagged = (JET_COLUMNID)fid;

 					/*	must recache record if may have given up critical section
					/**/
					if ( FFUCBIndex( pfucb ) )
						{
						CallR( ErrDIRGet( pfucb ) );
						}

	 				continue;
					}
				}
			else
				{
				/* adjust line to intrinsic long column
				/**/
				line.pb += offsetof( LV, rgb );
				line.cb -= offsetof( LV, rgb );

				pretcolT->cbActual = ( ibLongValue >= line.cb  ) ? 0 : line.cb - ibLongValue;

				if ( ibLongValue >= line.cb )
					{
					line.cb = 0;
					}
				else
					{
					line.pb += ibLongValue;
					line.cb -= ibLongValue;
					}
				}
			}
		else
			{
			/*	set cbActual
			/**/
			pretcolT->cbActual = line.cb;
			}

		/*	set return values
		/**/
		pretcolT->columnidNextTagged = (JET_COLUMNID)fid;

		if ( err == JET_wrnColumnNull )
			{
			pretcolT->err = err;
			continue;
			}

		if ( line.cb <= cbMax )
			{
			pretcolT->err = JET_errSuccess;
			cbReturned = line.cb;
			}
		else
			{
			pretcolT->err = ErrERRCheck( JET_wrnBufferTruncated );
			cbReturned = cbMax;
			fBufferTruncated = fTrue;
			}

		memcpy( pretcolT->pvData, line.pb, (size_t)cbReturned );
		}

	return fBufferTruncated ? ErrERRCheck( JET_wrnBufferTruncated ) : JET_errSuccess;
	}


ERR VTAPI ErrIsamRetrieveColumns(
	JET_VSESID				vsesid,
	JET_VTID				vtid,
	JET_RETRIEVECOLUMN		*pretcol,
	ULONG					cretcol )
	{
	ERR					  	err = JET_errSuccess;
	PIB						*ppib = (PIB *)vsesid;
	FUCB					*pfucb = (FUCB *)vtid;
	ERR					  	wrn = JET_errSuccess;
	BOOL					fRetrieveFromRecord = fFalse;
	JET_RETRIEVECOLUMN		*pretcolT;
	JET_RETRIEVECOLUMN		*pretcolMax = pretcol + cretcol;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );

	for ( pretcolT = pretcol; pretcolT < pretcolMax; pretcolT++ )
		{
		/*	if itagSequence is 0 then count columns instead of retrieving.
		/**/
		if ( pretcolT->itagSequence == 0 )
			{
			Call( ErrRECCountColumn( pfucb,
				(FID)pretcolT->columnid,
				&pretcolT->itagSequence,
				pretcolT->grbit ) );

			Assert( err != JET_errNullInvalid );
			pretcolT->cbActual = 0;
			pretcolT->columnidNextTagged = pretcolT->columnid;
			Assert( err != JET_wrnBufferTruncated );
			pretcolT->err = err;
			continue;
			}

		/*	try to retrieve from index; if no short circuit, RECIRetrieveMany
		/*	will take retrieve record
		/**/
		if ( pretcolT->grbit & JET_bitRetrieveFromIndex )
			{
			err = ErrRECIRetrieveFromIndex(
				pfucb,
				(FID)pretcolT->columnid,
				&pretcolT->itagSequence,
				(BYTE *)pretcolT->pvData,
				pretcolT->cbData,
				&(pretcolT->cbActual),
				pretcolT->ibLongValue,
				pretcolT->grbit );
			if ( err != errDIRNoShortCircuit )
				{
				if ( err < 0 )
					goto HandleError;
				else
					{
					pretcolT->columnidNextTagged = pretcolT->columnid;
					Assert( err != JET_errNullInvalid );
					pretcolT->err = err;
					if ( err == JET_wrnBufferTruncated )
						wrn = err;
					continue;
					}
				}
			}

		/*	if retrieving from copy buffer.
		/**/
		if ( pretcolT->grbit & JET_bitRetrieveCopy )
			{
			JET_RETINFO	retinfo;

			retinfo.cbStruct = sizeof(retinfo);
			retinfo.itagSequence = pretcolT->itagSequence;
			retinfo.ibLongValue = pretcolT->ibLongValue;

			Call( ErrIsamRetrieveColumn( ppib,
				pfucb,
				pretcolT->columnid,
				pretcolT->pvData,
				pretcolT->cbData,
				&pretcolT->cbActual,
				pretcolT->grbit,
				&retinfo ) );

			pretcolT->columnidNextTagged = retinfo.columnidNextTagged;
			Assert( err != JET_errNullInvalid );
			pretcolT->err = err;
			if ( err == JET_wrnBufferTruncated )
				wrn = err;
			continue;
			}

		fRetrieveFromRecord = fTrue;
		pretcolT->err = ErrERRCheck( JET_errNullInvalid );
		}

	/*	retrieve columns with no short circuit
	/**/
	if ( fRetrieveFromRecord )
		{
		Call( ErrRECIRetrieveColumns( pfucb, pretcol, cretcol ) );
		if ( err == JET_wrnBufferTruncated )
			wrn = err;
		}

HandleError:
		return ( ( err < 0 ) ? err : wrn );
		}


#ifdef DEBUG
FIELD *PfieldFLDInfo( FDB *pfdb, INT iInfo )
	{
	switch( iInfo )
		{
		case 0:
			return (FIELD *)PibFDBFixedOffsets( pfdb );
		case 1:
			return PfieldFDBFixed( pfdb );
		case 2:
			return PfieldFDBVar( pfdb );
		default:
			Assert( iInfo == 3 );
			return PfieldFDBTagged( pfdb );
		}

	Assert( fFalse );
	}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\fldnorm.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */


LOCAL ERR ErrRetrieveFromLVBuf( FUCB *pfucb, LID lid, LINE *pline )
	{
	LVBUF *pLVBufT = pfucb->pLVBuf;

	for ( pLVBufT = pfucb->pLVBuf; pLVBufT != NULL; pLVBufT = pLVBufT->pLVBufNext )
		{
		if ( pLVBufT->lid == lid )
			{
			pline->pb = pLVBufT->pLV;
			pline->cb = pLVBufT->cbLVSize;
			return JET_errSuccess;
			}
		else if ( pLVBufT->lid > lid )
			break;		// Not in the buffer;
		}

	return ErrERRCheck( JET_errColumnNotFound );
	}


LOCAL ERR ErrRECIExtractLongValue(
	FUCB	*pfucb,
	BYTE	*rgbLV,
	ULONG	cbMax,
	LINE	*pline,
	BOOL	fRetrieveFromLVBuf )
	{
	ERR		err;
	ULONG	cbActual;

	if ( pline->cb >= sizeof(LV) && FFieldIsSLong( pline->pb ) )
		{
		if ( fRetrieveFromLVBuf )
			{
			err = ErrRetrieveFromLVBuf( pfucb, LidOfLV( pline->pb ), pline );
			if ( err == JET_errSuccess )
				return err;
			Assert( err == JET_errColumnNotFound );
			}

		/*	If there is an id, then there must be a chunk.
		 *	WARNING: Possible loss of critJet.  Caller (currently only
		 *	ErrRECIRetrieveKey()) must refresh if necessary.
		/**/	
		Call( ErrRECRetrieveSLongField( pfucb,
			LidOfLV( pline->pb ),
			0,
			rgbLV,
			cbMax,
			&cbActual ) );
			
		pline->pb = rgbLV;
		pline->cb = cbActual;
		}
	else
		{
		/*	intrinsic long column
		/**/
		pline->pb += offsetof( LV, rgb );
		pline->cb -= offsetof( LV, rgb );
		}

	/*	constrain pline->cb to be within max
	/**/
	if ( pline->cb > cbMax )
		pline->cb = cbMax;
	Assert( pline->cb <= JET_cbColumnMost );
	err = JET_errSuccess;
	
HandleError:
	return err;
	}

#if 0
/*	retrieves key from record after write lacthing page
/**/
ERR ErrRECRetrieveKeyFromRecord(
	FUCB	 	*pfucb,
	FDB		 	*pfdb,
	IDB			*pidb,
	LINE		*plineRec,
	KEY			*pkey,
	ULONG		itagSequence,
	BOOL		fRetrieveBeforeImg )
	{
	ERR	err;
	BF	*pbfLatched = pfucb->ssib.pbf;

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	Assert( plineRec->cb == pfucb->lineData.cb && plineRec->pb == pfucb->lineData.pb );
	
	BFPin( pbfLatched );
	while( FBFWriteLatchConflict( pfucb->ppib, pbfLatched ) )
		{
		BFSleep( cmsecWaitWriteLatch );
		}
		
	BFSetWriteLatch( pbfLatched, pfucb->ppib );
	BFUnpin( pbfLatched );

	/*	refresh currency
	/**/
	Call( ErrDIRGet( pfucb ) );
	
	Call( ErrRECIRetrieveKey( pfucb, pfdb, pidb, &pfucb->lineData, pkey, itagSequence, fRetrieveBeforeImg ) );

HandleError:
	BFResetWriteLatch( pbfLatched, pfucb->ppib );
	return err;
	}
#endif
	

//+API
//	ErrRECIRetrieveKey
//	========================================================
//	ErrRECIRetrieveKey( FUCB *pfucb, FDB *pfdb, IDB *pidb, LINE *plineRec, KEY *pkey, ULONG itagSequence )
//
//	Retrieves the normalized key from a record, based on an index descriptor.
//
//	PARAMETERS
//		pfucb			cursor for record
//	 	pfdb		  	column info for index
// 		pidb		  	index key descriptor
// 		plineRec	  	data record to retrieve key from
// 		pkey		  	buffer to put retrieve key in; pkey->pb must
//						point to a large enough buffer, JET_cbKeyMost bytes.
// 		itagSequence  	A secondary index whose key contains a tagged
//						column segment will have an index entry made for
//						each value of the tagged column, each refering to
//						the same record.  This parameter specifies which
//						occurance of the tagged column should be included
//						in the retrieve key.
//
//	RETURNS	Error code, one of:
//		JET_errSuccess		success
//		+wrnFLDNullKey	   	key has all NULL segments
//		+wrnFLDNullSeg	   	key has NULL segment
//
//	COMMENTS
//		Key formation is as follows:  each key segment is retrieved
//		from the record, transformed into a normalized form, and
//		complemented if it is "descending" in the key.	The key is
//		formed by concatenating each such transformed segment.
//-
ERR ErrRECIRetrieveKey(
	FUCB	  	*pfucb,
	FDB	 		*pfdb,
	IDB	 		*pidb,
	BOOL		fCopyBuf,
	KEY	 		*pkey,
	ULONG	   	itagSequence,
	BOOL		fRetrieveBeforeImg )
	{
	ERR	 		err = JET_errSuccess; 				// Error code of various utility
	BOOL	  	fAllNulls = fTrue;					// Assume all null, until proven otherwise
	BOOL	  	fNullFirstSeg = fFalse;			 	// Assume no null first segment
	BOOL	  	fNullSeg = fFalse;					// Assume no null segments
	BOOL	  	fColumnTruncated = fFalse;
	BOOL	  	fKeyTruncated = fFalse;
	BOOL	  	fSawMultivalue = fFalse;

	BYTE	  	*pbSeg;					  			// Pointer to current segment
	INT	 		cbKeyAvail;				  			// Space remaining in key buffer
	INT			cbVarSegMac;						// Maximum size of text/binary key segment
	IDXSEG		*pidxseg;
	IDXSEG		*pidxsegMac;
	JET_COLTYP	coltyp;
	LINE		*plineRec = fCopyBuf ? &pfucb->lineWorkBuf : &pfucb->lineData;
	
	/*	long value support
	/**/
	BYTE	  	rgbLV[JET_cbColumnMost];

	Assert( pkey != NULL );
	Assert( pkey->pb != NULL );
	Assert( pfdb != pfdbNil );
	Assert( pidb != pidbNil );

	/*	check cbVarSegMac and set to key most plus one if no column
	/*	truncation enabled.  This must be done for subsequent truncation
	/* 	checks.
	/**/
	Assert( pidb->cbVarSegMac > 0 && pidb->cbVarSegMac <= JET_cbKeyMost );
	cbVarSegMac = (INT)(UINT)pidb->cbVarSegMac;
	Assert( cbVarSegMac > 0 && cbVarSegMac <= JET_cbKeyMost );
	if ( cbVarSegMac == JET_cbKeyMost )
		cbVarSegMac = JET_cbKeyMost + 1;

	/*	start at beginning of buffer, with max size remaining.
	/**/
	pbSeg = pkey->pb;
	cbKeyAvail = JET_cbKeyMost;

	/*	fRetrieveBeforeImg flags whether or not we have to check in the LV buffer.
	/*	We only check in the LV buffer if one exists, and if we are looking for the
	/*	before-imaged (as specified by the parameter passed in).  Assert that this
	/*	only occurs during a Replace.
	/**/
	fRetrieveBeforeImg = ( pfucb->pLVBuf  &&  fRetrieveBeforeImg );
	Assert( !fRetrieveBeforeImg  ||  FFUCBReplacePrepared( pfucb ) );

	/*	retrieve each segment in key description
	/**/
	pidxseg = pidb->rgidxseg;
	pidxsegMac = pidxseg + pidb->iidxsegMac;
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{
		FIELD 	*pfield;						// pointer to curr FIELD struct
		FID		fid;					 		// field id of segment.
		BYTE   	*pbField;						// pointer to column data.
		INT		cbField;						// length of column data.
		INT		cbT;
		BOOL   	fDescending;					// segment is in desc. order.
		BOOL   	fFixedField;					// current column is fixed-length?
		BOOL   	fMultivalue = fFalse;			// current column is multi-valued.
		BYTE   	rgbSeg[ JET_cbKeyMost ]; 		// segment buffer.
		int		cbSeg;							// length of segment.
		WORD   	w;
		ULONG  	ul;
		LINE   	lineField;

		/*	negative column id means descending in the key
		/**/
		fid = ( fDescending = ( *pidxseg < 0 ) ) ? -(*pidxseg) : *pidxseg;

		/*	determine column type from FDB
		/**/
		if ( fFixedField = FFixedFid( fid ) )
			{
			Assert(fid <= pfdb->fidFixedLast);
			pfield = PfieldFDBFixed( pfdb ) + ( fid - fidFixedLeast );
			coltyp = pfield->coltyp;
			}
		else if ( FVarFid( fid ) )
			{
			Assert( fid <= pfdb->fidVarLast );
			pfield = PfieldFDBVar( pfdb ) + ( fid - fidVarLeast );
			coltyp = pfield->coltyp;
			Assert( coltyp == JET_coltypBinary || coltyp == JET_coltypText );
			}
		else
			{
			Assert( FTaggedFid( fid ) );
			Assert( fid <= pfdb->fidTaggedLast );
			pfield = PfieldFDBTagged( pfdb ) + ( fid - fidTaggedLeast );
			coltyp = pfield->coltyp;
			fMultivalue = FFIELDMultivalue( pfield->ffield );
			}

		/*	with no space left in the key buffer we cannot insert any more
		/*	normalised keys
		/**/
		if ( cbKeyAvail == 0 )
			{
			fKeyTruncated = fTrue;

			/*	check if column is NULL for tagged column support
			/**/
			err = ErrRECIRetrieveColumn(
					pfdb, plineRec, &fid, pNil,
					( fMultivalue && !fSawMultivalue ) ? itagSequence : 1,
					&lineField, 0 );
			
			Assert( err >= 0 );
			if ( err == JET_wrnColumnNull )
				{
				/*	cannot be all NULL and cannot be first NULL
				/*	since key truncated.
				/**/
				Assert( itagSequence >= 1 );
				if ( itagSequence > 1
					&& fMultivalue
					&& !fSawMultivalue )
					{
					err = ErrERRCheck( wrnFLDOutOfKeys );
					goto HandleError;
					}
				else
					{
					if ( pidxseg == pidb->rgidxseg )
						fNullFirstSeg = fTrue;
					fNullSeg = fTrue;
					}
				}

			Assert( err == JET_errSuccess || err == wrnRECLongField || err == JET_wrnColumnNull );
			err = JET_errSuccess;
			
			if ( fMultivalue )
				fSawMultivalue = fTrue;
			continue;
			}

		/*	get segment value: get from the record
		/*	using ErrRECRetrieveColumn.
		/**/
		Assert( !FLineNull( plineRec ) );
		if ( fMultivalue && !fSawMultivalue )
			{
			Assert( fid != 0 );
			err = ErrRECIRetrieveColumn( pfdb, plineRec, &fid, pNil, itagSequence, &lineField, 0 );
			Assert( err >= 0 );
			if ( err == wrnRECLongField )
				{
				Call( ErrRECIExtractLongValue( pfucb, rgbLV, sizeof(rgbLV),
					&lineField, fRetrieveBeforeImg ) );

				/*	possible loss of critJet -- refresh currency
				/**/
				if ( !fCopyBuf )
					{
					Call( ErrDIRGet( pfucb ) );
					}
				}
			if ( itagSequence > 1 && err == JET_wrnColumnNull )
				{
				err = ErrERRCheck( wrnFLDOutOfKeys );
				goto HandleError;
				}
			fSawMultivalue = fTrue;
			}
		else
			{
			err = ErrRECIRetrieveColumn( pfdb, plineRec, &fid, pNil, 1, &lineField, 0 );
			Assert( err >= 0 );
			if ( err == wrnRECLongField )
				{
				Call( ErrRECIExtractLongValue( pfucb, rgbLV, sizeof(rgbLV),
					&lineField, fRetrieveBeforeImg ) );

				/*	possible loss of critJet -- refresh currency
				/**/
				if ( !fCopyBuf )
					{
					Call( ErrDIRGet( pfucb ) );
					}
				}
			}
		Assert( err == JET_errSuccess || err == JET_wrnColumnNull );
		Assert( lineField.cb <= JET_cbColumnMost );
		cbField = lineField.cb;
		pbField = lineField.pb;

		/*	segment transformation: check for null column or zero-length columns first
		/*	err == JET_wrnColumnNull => Null column
		/*	zero-length column otherwise,
		/*	the latter is allowed only for Text and LongText
		/**/
		if ( err == JET_wrnColumnNull || pbField == NULL || cbField == 0 )
			{
			if ( err == JET_wrnColumnNull )
				{
				if ( pidxseg == pidb->rgidxseg )
					fNullFirstSeg = fTrue;
				fNullSeg = fTrue;
				}
			switch ( coltyp )
				{
				/*	most nulls are represented by 0x00
				/**/
				case JET_coltypBit:
				case JET_coltypUnsignedByte:
				case JET_coltypShort:
				case JET_coltypLong:
				case JET_coltypCurrency:
				case JET_coltypIEEESingle:
				case JET_coltypIEEEDouble:
				case JET_coltypDateTime:
#ifdef NEW_TYPES
				case JET_coltypGuid:
				case JET_coltypDate:
				case JET_coltypTime:
#endif
					Assert( err == JET_wrnColumnNull );
				case JET_coltypText:
				case JET_coltypLongText:
					cbSeg = 1;
					if ( err == JET_wrnColumnNull)
						rgbSeg[0] = 0;
					else
						rgbSeg[0] = 0x40;
					break;

				/*	binary-data: 0x00 if fixed, else 9 0x00s (a chunk)
				/**/
				default:
					Assert( err == JET_errSuccess || err == JET_wrnColumnNull );
					Assert( FRECBinaryColumn( coltyp ) );
					memset( rgbSeg, 0, cbSeg = min( cbKeyAvail, ( fFixedField ? 1 : 9 ) ) );
					break;
				}

			/*	avoid annoying over-nesting
			/**/
			goto AppendToKey;
			}

		/*	column is not null-valued: perform transformation
		/**/
		fAllNulls = fFalse;
		switch ( coltyp )
			{
			/*	BIT: prefix with 0x7f, flip high bit
			/**/
			/*	UBYTE: prefix with 0x7f
			/**/
			case JET_coltypBit:
				Assert( cbField == 1 );
				cbSeg = 2;
				rgbSeg[0] = 0x7f;
				rgbSeg[1] = *pbField == 0 ? 0x00 : 0xff;
				break;
			case JET_coltypUnsignedByte:
				Assert( cbField == 1 );
				cbSeg = 2;
				rgbSeg[0] = 0x7f;
				rgbSeg[1] = *pbField;
				break;

			/*	SHORT: prefix with 0x7f, flip high bit
			/**/
			case JET_coltypShort:
				Assert( cbField == 2 );
				cbSeg = 3;
				rgbSeg[0] = 0x7f;
/***BEGIN MACHINE DEPENDENT***/
				w = wFlipHighBit( *(WORD UNALIGNED *) pbField);
				rgbSeg[1] = (BYTE)(w >> 8);
				rgbSeg[2] = (BYTE)(w & 0xff);
/***END MACHINE DEPENDANT***/
				break;

			/**	LONG: prefix with 0x7f, flip high bit
			/**/
			/** works because of 2's complement **/
			case JET_coltypLong:
				Assert( cbField == 4 );
				cbSeg = 5;
				rgbSeg[0] = 0x7f;
				ul = ulFlipHighBit( *(ULONG UNALIGNED *) pbField );
				rgbSeg[1] = (BYTE)((ul >> 24) & 0xff);
				rgbSeg[2] = (BYTE)((ul >> 16) & 0xff);
				rgbSeg[3] = (BYTE)((ul >> 8) & 0xff);
				rgbSeg[4] = (BYTE)(ul & 0xff);
				break;

			/*	REAL: First swap bytes.  Then, if positive:
			/*	flip sign bit, else negative: flip whole thing.
			/*	Then prefix with 0x7f.
			/**/
			case JET_coltypIEEESingle:
				Assert( cbField == 4 );
				cbSeg = 5;
				rgbSeg[0] = 0x7f;
/***BEGIN MACHINE DEPENDANT***/
				rgbSeg[4] = *pbField++; rgbSeg[3] = *pbField++;
				rgbSeg[2] = *pbField++; rgbSeg[1] = *pbField;
				if (rgbSeg[1] & maskByteHighBit)
					*(ULONG UNALIGNED *)(&rgbSeg[1]) = ~*(ULONG UNALIGNED *)(&rgbSeg[1]);
				else
					rgbSeg[1] = bFlipHighBit(rgbSeg[1]);
 /***END MACHINE DEPENDANT***/
				break;

			/*	LONGREAL: First swap bytes.  Then, if positive:
			/*	flip sign bit, else negative: flip whole thing.
			/*	Then prefix with 0x7f.
			/**/
			/*	Same for DATETIME and CURRENCY
			/**/
			case JET_coltypCurrency:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				Assert( cbField == 8 );
				cbSeg = 9;
				rgbSeg[0] = 0x7f;
/***BEGIN MACHINE DEPENDANT***/
				rgbSeg[8] = *pbField++; rgbSeg[7] = *pbField++;
				rgbSeg[6] = *pbField++; rgbSeg[5] = *pbField++;
				rgbSeg[4] = *pbField++; rgbSeg[3] = *pbField++;
				rgbSeg[2] = *pbField++; rgbSeg[1] = *pbField;
				if ( coltyp != JET_coltypCurrency && (rgbSeg[1] & maskByteHighBit) )
					{
					*(ULONG UNALIGNED *)(&rgbSeg[1]) = ~*(ULONG UNALIGNED *)(&rgbSeg[1]);
					*(ULONG UNALIGNED *)(&rgbSeg[5]) = ~*(ULONG UNALIGNED *)(&rgbSeg[5]);
					}
				else
					rgbSeg[1] = bFlipHighBit(rgbSeg[1]);
/***END MACHINE DEPENDANT***/
				break;

#ifdef NEW_TYPES
			case JET_coltypDate:
			case JET_coltypTime:
				Assert( cbField == 4 );
				cbSeg = 5;
				rgbSeg[0] = 0x7f;
/***BEGIN MACHINE DEPENDANT***/
				rgbSeg[4] = *pbField++; rgbSeg[3] = *pbField++;
				rgbSeg[2] = *pbField++; rgbSeg[1] = *pbField;
				if ( (rgbSeg[1] & maskByteHighBit) )
					{
					*(ULONG UNALIGNED *)(&rgbSeg[1]) = ~*(ULONG UNALIGNED *)(&rgbSeg[1]);
					}
				else
					rgbSeg[1] = bFlipHighBit(rgbSeg[1]);
/***END MACHINE DEPENDANT***/
				break;

			case JET_coltypGuid:
				Assert( cbField == 16 );
				Assert( cbKeyAvail > 0 );
				cbSeg = 17;
				rgbSeg[0] = 0x7f;
/***BEGIN MACHINE DEPENDANT***/
				rgbSeg[16] = *pbField++; rgbSeg[15] = *pbField++;
				rgbSeg[14] = *pbField++; rgbSeg[13] = *pbField++;
				rgbSeg[12] = *pbField++; rgbSeg[11] = *pbField++;
				rgbSeg[10] = *pbField++; rgbSeg[9] = *pbField++;
				rgbSeg[1] = *pbField++; rgbSeg[2] = *pbField++;
				rgbSeg[3] = *pbField++; rgbSeg[4] = *pbField++;
				rgbSeg[5] = *pbField++; rgbSeg[6] = *pbField++;
				rgbSeg[7] = *pbField++; rgbSeg[8] = *pbField++;
				break;
/***END MACHINE DEPENDANT***/
				break;
#endif

			/*	case-insensetive TEXT: convert to uppercase.
			/*	If fixed, prefix with 0x7f;  else affix with 0x00
			/**/
			case JET_coltypText:
			case JET_coltypLongText:
				Assert( cbKeyAvail > 0 );
				Assert( cbVarSegMac > 0 );
				/*	cbT is the max size of the key segment data,
				/*	and does not include the header byte which indicates
				/*	NULL key, zero length key, or non-NULL key.
				/**/
				cbT = ( cbKeyAvail == 0 ) ? 0 : min( cbKeyAvail - 1, cbVarSegMac - 1 );

				/*	unicode support
				/**/
				if ( pfield->cp == usUniCodePage )
					{
					ERR	errT;

					/*	cbField may have been truncated to an odd number
					/*	of bytes, so enforce even.
					/**/
					Assert( cbField % 2 == 0 || cbField == JET_cbColumnMost );
					cbField = ( cbField / 2 ) * 2;
					errT = ErrUtilMapString(
						(LANGID)( FIDBLangid( pidb ) ? pidb->langid : langidDefault ),
						pbField,
						cbField,
						rgbSeg + 1,
						cbT,
						&cbSeg );						
					if ( errT < 0 )
						{
						Assert( errT == JET_errInvalidLanguageId );
						err = errT;
						goto HandleError;
						}
					Assert( errT == JET_errSuccess || errT == wrnFLDKeyTooBig );
					if ( errT == wrnFLDKeyTooBig && cbSeg < cbVarSegMac - 1 )
						fColumnTruncated = fTrue;
					}
				else
					{
					ERR	errT;

					errT = ErrUtilNormText( pbField, cbField, cbT, rgbSeg + 1, &cbSeg );
					Assert( errT == JET_errSuccess || errT == wrnFLDKeyTooBig );
					if ( errT == wrnFLDKeyTooBig && cbSeg < cbVarSegMac - 1 )
						fColumnTruncated = fTrue;
					}
				Assert( cbSeg <= cbT );

				/*	put the prefix there
				/**/
				*rgbSeg = 0x7f;
				cbSeg++;

				break;

			/*	BINARY data: if fixed, prefix with 0x7f;
			/*	else break into chunks of 8 bytes, affixing each
			/*	with 0x09, except for the last chunk, which is
			/*	affixed with the number of bytes in the last chunk.
			/**/
			default:
				Assert( FRECBinaryColumn( coltyp ) );
				if ( fFixedField )
					{
					Assert( cbKeyAvail > 0 );
					Assert( cbVarSegMac > 0 );
					/*	cbT is the max size of the key segment.
					/**/
					cbT = min( cbKeyAvail, cbVarSegMac );
					cbSeg = cbField + 1;
					if ( cbSeg > cbT )
						{
						cbSeg = cbT;
						if ( cbSeg < cbVarSegMac )
							fColumnTruncated = fTrue;
						}
					Assert( cbSeg > 0 );
					rgbSeg[0] = 0x7f;
					memcpy( &rgbSeg[1], pbField, cbSeg - 1 );
					}
				else
					{
					BYTE *pb;

					/*	cbT is the max size of the key segment data.
					/**/
					cbT = min( cbKeyAvail, cbVarSegMac );

					/*	calculate total bytes needed for chunks and
					/*	counts;  if it won't fit, round off to the
					/*	nearest chunk.
					/**/
					cbSeg = ( ( ( cbField + 7 ) / 8 ) * 9 );
					if ( cbSeg > cbT )
						{
						cbSeg = ( cbT / 9 ) * 9;
						cbField = ( cbSeg / 9 ) * 8;

						if ( cbSeg < ( cbVarSegMac / 9 ) * 9 )
							fColumnTruncated = fTrue;
						}
					/*	copy data by chunks, affixing 0x09s
					/**/
					pb = rgbSeg;
					while ( cbField >= 8 )
						{
						memcpy( pb, pbField, 8 );
						pbField += 8;
						pb += 8;
						*pb++ = 9;
						cbField -= 8;
						}
					/*	last chunk: pad with 0x00s if needed
					/**/
					if ( cbField == 0 )
						pb[-1] = 8;
					else
						{
						memcpy( pb, pbField, cbField );
						pb += cbField;
						memset( pb, 0, 8 - cbField );
						pb += ( 8 - cbField );
						*pb = (BYTE)cbField;
						}
					}
				break;
			}

AppendToKey:
		/*	if key has not already been truncated, then append
		/*	normalized key segment.  If insufficient room in key
		/*	for key segment, then set key truncated to fTrue.  No
		/*	additional key data will be appended after this append.
		/**/
		if ( !fKeyTruncated )
			{
			/*	if column truncated or insufficient room in key
			/*	for key segment, then set key truncated to fTrue.
			/*	Append variable size column keys only.
			/**/
			if ( fColumnTruncated || cbSeg > cbKeyAvail )
				{
				fKeyTruncated = fTrue;

				if ( coltyp == JET_coltypBinary ||
					coltyp == JET_coltypText ||
					FRECLongValue( coltyp ) )
					{
					cbSeg = min( cbSeg, cbKeyAvail );
					}
				else
					cbSeg = 0;
				}

			/*	if descending, flip all bits of transformed segment
			/**/
			if ( fDescending && cbSeg > 0 )
				{
				BYTE *pb;

				for ( pb = rgbSeg + cbSeg - 1; pb >= (BYTE*)rgbSeg; pb-- )
					*pb ^= 0xff;
				}

			memcpy( pbSeg, rgbSeg, cbSeg );
			pbSeg += cbSeg;
			cbKeyAvail -= cbSeg;
			}
		}

	/*	compute length of key and return error code
	/**/
	pkey->cb = (ULONG)(pbSeg - pkey->pb);
	if ( fAllNulls )
		{
		err = ErrERRCheck( wrnFLDNullKey );
		}
	else
		{
		if ( fNullFirstSeg )
			err = ErrERRCheck( wrnFLDNullFirstSeg );
		else
			{
			if ( fNullSeg )
				err = ErrERRCheck( wrnFLDNullSeg );
			}
		}

	Assert( err == JET_errSuccess
		|| err == wrnFLDNullKey
		|| err == wrnFLDNullFirstSeg ||
		err == wrnFLDNullSeg );
HandleError:
	return err;
	}


INLINE LOCAL ERR ErrFLDNormalizeSegment(
	IDB			*pidb,
	LINE		*plineColumn,
	LINE		*plineNorm,
	FIELD		*pfield,
	INT			cbAvail,
	BOOL		fDescending,
	BOOL		fFixedField,
	JET_GRBIT	grbit )
	{
	ERR	 	  	err = JET_errSuccess;
	JET_COLTYP	coltyp = pfield->coltyp;
	INT	 	  	cbColumn;
	BYTE 		*pbColumn;
	BYTE		*pbNorm = plineNorm->pb;
	WORD		wT;
	ULONG		ulT;
	INT			cbVarSegMac;
	INT			cbT;

	/*	check cbVarSegMac and set to key most plus one if no column
	/*	truncation enabled.  This must be done for subsequent truncation
	/* 	checks.
	/**/
	Assert( pidb->cbVarSegMac > 0 && pidb->cbVarSegMac <= JET_cbKeyMost );
	cbVarSegMac = (INT)(UINT)pidb->cbVarSegMac;
	Assert( cbVarSegMac > 0 && cbVarSegMac <= JET_cbKeyMost );
	if ( cbVarSegMac == JET_cbKeyMost )
		cbVarSegMac = JET_cbKeyMost + 1;

	/*	check for null or zero-length column first
	/*	plineColumn == NULL implies null-column,
	/*	zero-length otherwise
	/**/
	if ( plineColumn == NULL || plineColumn->pb == NULL || plineColumn->cb == 0 )
		{
		switch ( coltyp )
			{
			/*	most nulls are represented by 0x00
			/*	zero-length columns are represented by 0x40
			/*	and are useful only for text and longtext
			/**/
			case JET_coltypBit:
			case JET_coltypUnsignedByte:
			case JET_coltypShort:
			case JET_coltypLong:
			case JET_coltypCurrency:
			case JET_coltypIEEESingle:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
#ifdef NEW_TYPES
			case JET_coltypDate:
			case JET_coltypTime:
			case JET_coltypGuid:
#endif
				plineNorm->cb = 1;
				Assert( plineColumn == NULL );
				*pbNorm = 0;
				break;
			case JET_coltypText:
			case JET_coltypLongText:
				plineNorm->cb = 1;
				if ( grbit & JET_bitKeyDataZeroLength )
					{
					*pbNorm = 0x40;
					}
				else
					{
					*pbNorm = 0;
					}
				break;

			/*	binary-data: 0x00 if fixed, else 9 0x00s (a chunk)
			/**/
			default:
				Assert( plineColumn == NULL );
				Assert( FRECBinaryColumn( coltyp ) );
				memset( pbNorm, 0, plineNorm->cb = ( fFixedField ? 1 : 9 ) );
				break;
			}
		goto FlipSegment;
		}

	cbColumn = plineColumn->cb;
	pbColumn = plineColumn->pb;

	switch ( coltyp )
		{
		/*	BYTE: prefix with 0x7f, flip high bit
		/**/
		/*	UBYTE: prefix with 0x7f
		/**/
		case JET_coltypBit:
			plineNorm->cb = 2;
			*pbNorm++ = 0x7f;
			*pbNorm = ( *pbColumn == 0 ) ? 0x00 : 0xff;
			break;
		case JET_coltypUnsignedByte:
			plineNorm->cb = 2;
			*pbNorm++ = 0x7f;
			*pbNorm = *pbColumn;
			break;

		/*	SHORT: prefix with 0x7f, flip high bit
		/**/
		/*	UNSIGNEDSHORT: prefix with 0x7f
		/**/
		case JET_coltypShort:
			plineNorm->cb = 3;
			*pbNorm++ = 0x7f;
			wT = wFlipHighBit( *(WORD UNALIGNED *)pbColumn );
			*pbNorm++ = (BYTE)(wT >> 8);
			*pbNorm = (BYTE)(wT & 0xff);
			break;

		/*	LONG: prefix with 0x7f, flip high bit
		/**/
		/*	UNSIGNEDLONG: prefix with 0x7f
		/**/
		case JET_coltypLong:
			plineNorm->cb = 5;
			*pbNorm++ = 0x7f;
			ulT = ulFlipHighBit( *(ULONG UNALIGNED *) pbColumn);
			*pbNorm++ = (BYTE)((ulT >> 24) & 0xff);
			*pbNorm++ = (BYTE)((ulT >> 16) & 0xff);
			*pbNorm++ = (BYTE)((ulT >> 8) & 0xff);
			*pbNorm = (BYTE)(ulT & 0xff);
			break;

		/*	REAL: First swap bytes.  Then, if positive:
		/*	flip sign bit, else negative: flip whole thing.
		/*	Then prefix with 0x7f.
		/**/
		case JET_coltypIEEESingle:
			plineNorm->cb = 5;
			pbNorm[0] = 0x7f;
/***BEGIN MACHINE DEPENDANT***/
			pbNorm[4] = *pbColumn++; pbNorm[3] = *pbColumn++;
			pbNorm[2] = *pbColumn++; pbNorm[1] = *pbColumn;
			if (pbNorm[1] & maskByteHighBit)
				*(ULONG*)(&pbNorm[1]) = ~*(ULONG*)(&pbNorm[1]);
			else
				pbNorm[1] = bFlipHighBit(pbNorm[1]);
/***END MACHINE DEPENDANT***/
			break;

		/*	LONGREAL: First swap bytes.  Then, if positive:
		/*	flip sign bit, else negative: flip whole thing.
		/*	Then prefix with 0x7f.
		/*	Same for DATETIME and CURRENCY
		/**/
		case JET_coltypCurrency:
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			plineNorm->cb = 9;
			pbNorm[0] = 0x7f;
/***BEGIN MACHINE DEPENDANT***/
			pbNorm[8] = *pbColumn++; pbNorm[7] = *pbColumn++;
			pbNorm[6] = *pbColumn++; pbNorm[5] = *pbColumn++;
			pbNorm[4] = *pbColumn++; pbNorm[3] = *pbColumn++;
			pbNorm[2] = *pbColumn++; pbNorm[1] = *pbColumn;
			if ( coltyp != JET_coltypCurrency && ( pbNorm[1] & maskByteHighBit ) )
				{
				*(ULONG *)(&pbNorm[1]) = ~*(ULONG*)(&pbNorm[1]);
				*(ULONG *)(&pbNorm[5]) = ~*(ULONG*)(&pbNorm[5]);
				}
			else
				pbNorm[1] = bFlipHighBit(pbNorm[1]);
/***END MACHINE DEPENDANT***/
			break;

#ifdef NEW_TYPES
		case JET_coltypDate:
		case JET_coltypTime:
			plineNorm->cb = 5;
			pbNorm[0] = 0x7f;
/***BEGIN MACHINE DEPENDANT***/
			pbNorm[4] = *pbColumn++; pbNorm[3] = *pbColumn++;
			pbNorm[2] = *pbColumn++; pbNorm[1] = *pbColumn;
			if ( ( pbNorm[1] & maskByteHighBit ) )
				{
				*(ULONG *)(&pbNorm[1]) = ~*(ULONG*)(&pbNorm[1]);
				*(ULONG *)(&pbNorm[5]) = ~*(ULONG*)(&pbNorm[5]);
				}
			else
				pbNorm[1] = bFlipHighBit(pbNorm[1]);
/***END MACHINE DEPENDANT***/
			break;

		case JET_coltypGuid:
			Assert( cbAvail >= 17 );
			plineNorm->cb = 17;
			*pbNorm++ = 0x7f;
/***BEGIN MACHINE DEPENDANT***/
			pbNorm[15] = *pbColumn++; pbNorm[14] = *pbColumn++;
			pbNorm[13] = *pbColumn++; pbNorm[12] = *pbColumn++;
			pbNorm[11] = *pbColumn++; pbNorm[10] = *pbColumn++;
			pbNorm[9] = *pbColumn++; pbNorm[8] = *pbColumn++;
			pbNorm[0] = *pbColumn++; pbNorm[1] = *pbColumn++;
			pbNorm[2] = *pbColumn++; pbNorm[3] = *pbColumn++;
			pbNorm[4] = *pbColumn++; pbNorm[5] = *pbColumn++;
			pbNorm[6] = *pbColumn++; pbNorm[7] = *pbColumn++;
/***END MACHINE DEPENDANT***/
			break;
#endif

		/*	case-insensetive TEXT:	convert to uppercase.
		/*	If fixed, prefix with 0x7f;  else affix with 0x00
		/**/
		case JET_coltypText:
		case JET_coltypLongText:
				Assert( cbAvail > 0 );
				Assert( cbVarSegMac > 0 );
				/*	cbT is the max size of the key segment data,
				/*	and does not include the header byte which indicates
				/*	NULL key, zero length key, or non-NULL key.
				/**/
				cbT = min( cbAvail - 1, cbVarSegMac - 1 );

				/*	unicode support
				/**/
				if ( pfield->cp == usUniCodePage )
					{
					/*	cbColumn may have been truncated to an odd number
					/*	of bytes, so enforce even.
					/**/
					Assert( cbColumn % 2 == 0 || cbColumn == JET_cbColumnMost );
					cbColumn = ( cbColumn / 2 ) * 2;
					err = ErrUtilMapString(
						(LANGID)( FIDBLangid( pidb ) ? pidb->langid : langidDefault ),
						pbColumn,
						cbColumn,
  						pbNorm + 1,
						cbT,
						&cbColumn );
					switch( err )
						{
						default:
							Assert( err == JET_errSuccess );
							break;
						case wrnFLDKeyTooBig:
							if ( cbColumn == cbVarSegMac - 1 )
								err = JET_errSuccess;
							break;
						case JET_errInvalidLanguageId:
							return err;
						}
					}
				else
					{
					err = ErrUtilNormText( pbColumn, cbColumn, cbT, pbNorm + 1, &cbColumn );
					if ( err == wrnFLDKeyTooBig
						&& cbColumn == cbVarSegMac - 1 )
						err = JET_errSuccess;
					Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );
					}

			Assert( cbColumn <= cbAvail - 1 && cbColumn <= cbVarSegMac );

			/*	put the prefix there
			/**/
			*pbNorm = 0x7f;
			plineNorm->cb = cbColumn + 1;

			break;

		/*	BINARY data: if fixed, prefix with 0x7f;
		/*	else break into chunks of 8 bytes, affixing each
		/*	with 0x09, except for the last chunk, which is
		/*	affixed with the number of bytes in the last chunk.
		/**/
		default:
			Assert( FRECBinaryColumn( coltyp ) );
			if ( fFixedField )
				{
				Assert( cbAvail > 0 );
				Assert( cbVarSegMac > 0 );
				/*	cbT is the max size of the key segment.
				/**/
				cbT = min( cbAvail, cbVarSegMac );
				if ( cbColumn > cbT - 1 )
					{
					cbColumn = cbT - 1;
					if ( cbColumn < cbVarSegMac - 1 )
						err = ErrERRCheck( wrnFLDKeyTooBig );
					}
				plineNorm->cb = cbColumn + 1;
				*pbNorm++ = 0x7f;
				memcpy( pbNorm, pbColumn, cbColumn );
				}
			else
				{
				BYTE *pb;

				/*	cbT is the max size of the key segment.
				/**/
				cbT = min( cbAvail, cbVarSegMac );
				if ( ( ( cbColumn + 7 ) / 8 ) * 9 > cbT )
					{
					cbColumn = cbT / 9 * 8;
					if ( ( ( cbColumn / 8 ) * 9 ) < ( cbVarSegMac / 9 ) * 9 )
						err = ErrERRCheck( wrnFLDKeyTooBig );
					}
				plineNorm->cb = ( ( cbColumn + 7 ) / 8 ) * 9;
				/*	copy data by chunks, affixing 0x09s
				/**/
				pb = pbNorm;
				while ( cbColumn >= 8 )
					{
					memcpy( pb, pbColumn, 8 );
					pbColumn += 8;
					pb += 8;
					*pb++ = 9;
					cbColumn -= 8;
					}
				/*	last chunk: pad with 0x00s if needed
				/**/
				if ( cbColumn == 0 )
					pb[-1] = 8;
				else
					{
					memcpy( pb, pbColumn, cbColumn );
					pb += cbColumn;
					memset( pb, 0, 8 - cbColumn );
					pb += ( 8 - cbColumn );
					*pb = (BYTE)cbColumn;
					}
				}
			break;
		}

FlipSegment:
	if ( fDescending )
		{
		BYTE *pbMin = plineNorm->pb;
		BYTE *pb = pbMin + plineNorm->cb - 1;
		while ( pb >= pbMin )
			*pb-- ^= 0xff;
		}

	/*	string and substring limit key support
	/**/
	if ( grbit & ( JET_bitStrLimit | JET_bitSubStrLimit ) )
		{
		if ( ( grbit & JET_bitSubStrLimit ) && FRECTextColumn( coltyp ) )
			{
			if ( pfield->cp == usUniCodePage )
				{
				INT		ibT = 1;
				BYTE	bUnicodeDelimiter = fDescending ? 0xfe : 0x01;
				BYTE	bUnicodeSentinel = 0xff;

				/*	find end of base char weight and truncate key
				/*	Append 0xff as first byte of next character as maximum
				/*	possible value.
				/**/
				while ( plineNorm->pb[ibT] != bUnicodeDelimiter && ibT < cbAvail )
					{
					ibT += 2;
					}

				if( ibT < cbAvail )
					{
					plineNorm->cb = ibT + 1;
					plineNorm->pb[ibT] = bUnicodeSentinel;
					}
				else
					{
					Assert( ibT == cbAvail );
					plineNorm->pb[ibT - 1] = bUnicodeSentinel;
					}
				}
			else
				{
				Assert( plineNorm->cb > 1 );	// At the minimum, must have prefix.
				Assert( (INT)plineNorm->cb <= cbAvail );
				if ( plineNorm->pb[plineNorm->cb - 1] == 0 )
					{
					// Strip off null-terminator.
					plineNorm->cb--;
					Assert( plineNorm->cb >= 1 );
					Assert( (INT)plineNorm->cb < cbAvail );
					}

				/*	there should be no accent information, as non-unicode
				/*	text normalization is upper case only.  Append
				/*	0xff or increment last non-0xff byte.
				/**/
				if( (INT)plineNorm->cb < cbAvail )
					{
					do
						{
						plineNorm->pb[plineNorm->cb++] = 0xff;
						}
					while ( (INT)plineNorm->cb < cbAvail );
					}
				else
					{
					Assert( (INT)plineNorm->cb == cbAvail );
					Assert( plineNorm->pb[cbAvail - 1] < 0xff );
					plineNorm->pb[cbAvail - 1]++;
					}
				}
			}
		else if ( grbit & JET_bitStrLimit )
			{
			/*	binary columns padded with 0s so must effect limit within key format
			/**/
			if ( FRECBinaryColumn( coltyp ) && !fFixedField )
				{
				pbNorm = plineNorm->pb + plineNorm->cb - 1;
				Assert( *pbNorm >= 0 && *pbNorm < 9 );
				pbNorm -= (8 - *pbNorm);
				Assert( *pbNorm == 0 || *pbNorm == 8 );
				while ( *pbNorm == 0 )
					*pbNorm++ = 0xff;
				Assert( pbNorm == plineNorm->pb + plineNorm->cb - 1 );
				Assert( *pbNorm >= 0 && *pbNorm < 9 );
				*pbNorm = 0xff;
				}
			else
				{
				if ( (INT)plineNorm->cb < cbAvail )
					{
					do
						{
						plineNorm->pb[plineNorm->cb++] = 0xff;
						}
					while ( (INT)plineNorm->cb < cbAvail );
					}
				else if ( plineColumn != NULL && plineColumn->cb > 0 )
					{
					INT		cbT = plineNorm->cb;

					while( cbT > 0 && plineNorm->pb[cbT - 1] == 0xff )
						{
						Assert( cbT > 0 );
						cbT--;
						}
					if ( cbT > 0 )
						{
						/*	increment last normalized byte
						/**/
						plineNorm->pb[cbT - 1]++;
						}
					}
				}
			}
		}

	Assert( err == JET_errSuccess || err == wrnFLDKeyTooBig );
	return err;
	}


ERR VTAPI ErrIsamMakeKey( PIB *ppib, FUCB *pfucb, BYTE *pbKeySeg, ULONG cbKeySeg, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	IDB		*pidb;
	FDB		*pfdb;
	FIELD 	*pfield;
	FID		fid;
	INT		iidxsegCur;
	LINE  	lineNormSeg;
	BYTE  	rgbNormSegBuf[ JET_cbKeyMost ];
	BYTE  	rgbSpaceFilled[ JET_cbKeyMost ];
	BOOL  	fDescending;
	BOOL  	fFixedField;
	LINE  	lineKeySeg;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );

	/*	set efficiency variables
	/**/
	lineNormSeg.pb = rgbNormSegBuf;
	lineKeySeg.pb = pbKeySeg;
	lineKeySeg.cb = min( JET_cbColumnMost, cbKeySeg );

	/*	allocate key buffer if needed
	/**/
	if ( pfucb->pbKey == NULL )
		{
		pfucb->pbKey = LAlloc( 1L, JET_cbKeyMost + 1 );
		if ( pfucb->pbKey == NULL )
			return ErrERRCheck( JET_errOutOfMemory );
		}

	Assert( !( grbit & JET_bitKeyDataZeroLength ) || cbKeySeg == 0 );

	/*	if key is already normalized, then copy directly to
	/*	key buffer and return.
	/**/
	if ( grbit & JET_bitNormalizedKey )
		{
		if ( cbKeySeg > JET_cbKeyMost )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

		/*	set key segment counter to any value
		/*	regardless of the number of key segments.
		/**/
		pfucb->pbKey[0] = 1;
		memcpy( pfucb->pbKey + 1, pbKeySeg, cbKeySeg );
		pfucb->cbKey = cbKeySeg + 1;
		KSSetPrepare( pfucb );
		return JET_errSuccess;
		}

	/*	start new key if requested
	/**/
	if ( grbit & JET_bitNewKey )
		{
		pfucb->pbKey[0] = 0;
		pfucb->cbKey = 1;
		}
	else
		{
		if ( !( FKSPrepared( pfucb ) ) )
			{
			return ErrERRCheck( JET_errKeyNotMade );
			}
		}

	/*	get pidb
	/**/
	if ( FFUCBIndex( pfucb ) )
		{
		if ( pfucb->pfucbCurIndex != pfucbNil )
			pidb = pfucb->pfucbCurIndex->u.pfcb->pidb;
		else if ( ( pidb = pfucb->u.pfcb->pidb ) == pidbNil )
			return ErrERRCheck( JET_errNoCurrentIndex );
		}
	else
		{
		pidb = ((FCB*)pfucb->u.pscb)->pidb;
		}

	Assert( pidb != pidbNil );
	if ( ( iidxsegCur = pfucb->pbKey[0] ) >= pidb->iidxsegMac )
		return ErrERRCheck( JET_errKeyIsMade );
	fid = ( fDescending = pidb->rgidxseg[iidxsegCur] < 0 ) ?
		-pidb->rgidxseg[iidxsegCur] : pidb->rgidxseg[iidxsegCur];
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	if ( fFixedField = FFixedFid( fid ) )
		{
		pfield = PfieldFDBFixed( pfdb ) + ( fid - fidFixedLeast );

		/*	check that length of key segment matches fixed column length
		/**/
		if ( cbKeySeg > 0 && cbKeySeg != pfield->cbMaxLen )
			{
			/*	if column is fixed text and buffer size is less
			/*	than fixed size then padd with spaces.
			/**/
			Assert( pfield->coltyp != JET_coltypLongText );
			if ( pfield->coltyp == JET_coltypText && cbKeySeg < pfield->cbMaxLen )
				{
				Assert( cbKeySeg == lineKeySeg.cb );
				memcpy( rgbSpaceFilled, lineKeySeg.pb, lineKeySeg.cb );
				memset ( rgbSpaceFilled + lineKeySeg.cb, ' ', pfield->cbMaxLen - lineKeySeg.cb );
				lineKeySeg.pb = rgbSpaceFilled;
				lineKeySeg.cb = pfield->cbMaxLen;
				}
			else
				{
				return ErrERRCheck( JET_errInvalidBufferSize );
				}
			}
		}
	else if ( FVarFid( fid ) )
		{
		pfield = PfieldFDBVar( pfdb ) + ( fid - fidVarLeast );
		}
	else
		{
		pfield = PfieldFDBTagged( pfdb ) + ( fid - fidTaggedLeast );
		}

	Assert( pfucb->cbKey <= JET_cbKeyMost + 1 );
	if ( !FKSTooBig( pfucb ) && ( pfucb->cbKey < JET_cbKeyMost + 1 ) )
		{
		ERR		errT;

		errT = ErrFLDNormalizeSegment(
			pidb,
			( cbKeySeg != 0 || ( grbit & JET_bitKeyDataZeroLength ) ) ? (&lineKeySeg) : NULL,
			&lineNormSeg,
			pfield,
			JET_cbKeyMost + 1 - pfucb->cbKey,
			fDescending,
			fFixedField,
			grbit );
		switch( errT )
			{
			default:
				Assert( errT == JET_errSuccess );
				break;
			case wrnFLDKeyTooBig:
				KSSetTooBig( pfucb );
				break;
			case JET_errInvalidLanguageId:
				Assert( FRECTextColumn( pfield->coltyp ) );
				Assert( pfield->cp == usUniCodePage );
				return errT;
			}
		}
	else
		{
		lineNormSeg.cb = 0;
		Assert( pfucb->cbKey <= JET_cbKeyMost + 1 );
		}

	/*	increment segment counter
	/**/
	pfucb->pbKey[0]++;
	if ( pfucb->cbKey + lineNormSeg.cb > JET_cbKeyMost + 1 )
		{
		lineNormSeg.cb = JET_cbKeyMost + 1 - pfucb->cbKey;
		/*	no warning returned when key exceeds most size
		/**/
		}
	memcpy( pfucb->pbKey + pfucb->cbKey, lineNormSeg.pb, lineNormSeg.cb );
	pfucb->cbKey += lineNormSeg.cb;
	KSSetPrepare( pfucb );
	Assert( err == JET_errSuccess );
	return err;
	}


//+API
//	ErrRECIRetrieveColumnFromKey
//	========================================================================
//	ErrRECIRetrieveColumnFromKey(
//		FDB *pfdb,				// IN	 column info for index
//		IDB *pidb,				// IN	 IDB of index defining key
//		KEY *pkey,				// IN	 key in normalized form
//		LINE *plineColumn ); 	// OUT	 receives value list
//
//	PARAMETERS	
//		pfdb			column info for index
//		pidb			IDB of index defining key
//		pkey			key in normalized form
//		plineColumn		plineColumn->pb must point to a buffer large
//						enough to hold the denormalized column.  A buffer
//						of JET_cbKeyMost bytes is sufficient.
//
//	RETURNS		JET_errSuccess
//
//-
ERR ErrRECIRetrieveColumnFromKey( FDB *pfdb, IDB *pidb, KEY *pkey, FID fid, LINE *plineColumn )
	{
	ERR		err = JET_errSuccess;
	IDXSEG	*pidxseg;
	IDXSEG	*pidxsegMac;
	BYTE  	*pbKey;		// runs through key bytes
	BYTE  	*pbKeyMax;	// end of key

	Assert( pfdb != pfdbNil );
	Assert( pidb != pidbNil );
	Assert( !FKeyNull(pkey) );
	Assert( plineColumn != NULL );
	Assert( plineColumn->pb != NULL );
	pbKey = pkey->pb;
	pbKeyMax = pbKey + pkey->cb;
	pidxseg = pidb->rgidxseg;
	pidxsegMac = pidxseg + pidb->iidxsegMac;
	for ( ; pidxseg < pidxsegMac && pbKey < pbKeyMax; pidxseg++ )
		{
		FID			fidT;				   	// Field id of segment.
		JET_COLTYP 	coltyp;				   	// Type of column.
		INT	 		cbField;			   	// Length of column data.
		BOOL 	   	fDescending;		   	// Segment is in desc. order.
		BOOL 	   	fFixedField = fFalse;	// Current column is fixed-length?
		WORD 	   	w;					   	// Temp var.
		ULONG 		ul;					   	// Temp var.
		BYTE 	   	mask;


		err = JET_errSuccess;				// reset error code

		/*	negative column id means descending in the key
		/**/
		fDescending = ( *pidxseg < 0 );
		fidT = fDescending ? -(*pidxseg) : *pidxseg;
		mask = (BYTE)(fDescending ? 0xff : 0x00);

		/*	determine column type from FDB
		/**/
		if ( FFixedFid(fidT) )
			{
			Assert(fidT <= pfdb->fidFixedLast);
			coltyp = PfieldFDBFixed( pfdb )[fidT-fidFixedLeast].coltyp;
			fFixedField = fTrue;
			}
		else if ( FVarFid(fidT) )
			{
			Assert(fidT <= pfdb->fidVarLast);
			coltyp = PfieldFDBVar( pfdb )[fidT-fidVarLeast].coltyp;
			Assert( coltyp == JET_coltypBinary || coltyp == JET_coltypText );
			}
		else
			{
			Assert( FTaggedFid( fidT ) );
			Assert(fidT <= pfdb->fidTaggedLast);
			coltyp = PfieldFDBTagged( pfdb )[fidT-fidTaggedLeast].coltyp;
			}

		Assert( coltyp != JET_coltypNil );

		switch ( coltyp ) {
			default:
				Assert( coltyp == JET_coltypBit );
				if ( *pbKey++ == (BYTE)(mask ^ 0) )
					{
					plineColumn->cb = 0;
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert( pbKey[-1] == (BYTE)(mask ^ (BYTE)0x7f) );
					plineColumn->cb = 1;
					*plineColumn->pb = ( ( mask ^ *pbKey++ ) == 0 ) ? 0xff : 0x00;
					}
				break;

			case JET_coltypUnsignedByte:
				if ( *pbKey++ == (BYTE)(mask ^ 0) )
					{
					plineColumn->cb = 0;
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert( pbKey[-1] == (BYTE)(mask ^ (BYTE)0x7f) );
					plineColumn->cb = 1;
					*plineColumn->pb = (BYTE)( mask ^ *pbKey++ );
					}
				break;

			case JET_coltypShort:
				if ( *pbKey++ == (BYTE)(mask ^ 0) )
					{
					plineColumn->cb = 0;
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert( pbKey[-1] == (BYTE)(mask ^ (BYTE)0x7f) );
					w = ((mask ^ pbKey[0]) << 8) + (BYTE)(mask ^ pbKey[1]);
					pbKey += 2;
					plineColumn->cb = 2;
					*(WORD UNALIGNED *)plineColumn->pb = wFlipHighBit(w);
					}
				break;

			case JET_coltypLong:
				if ( *pbKey++ == (BYTE)(mask ^ 0) )
					{
					plineColumn->cb = 0;
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert(pbKey[-1] == (BYTE)(mask ^ (BYTE)0x7f));
					ul = ((ULONG)(mask ^ (UINT)pbKey[0])<<24) +
						 ((ULONG)(BYTE)(mask ^ (UINT)pbKey[1])<<16) +
						 ((mask ^ (UINT)pbKey[2])<<8) +
						 (BYTE)(mask ^ (UINT)pbKey[3]);
					pbKey += 4;
					plineColumn->cb = 4;
					*(ULONG UNALIGNED *)plineColumn->pb = ulFlipHighBit(ul);
					}
				break;

			case JET_coltypIEEESingle:
				if ( fDescending )
					{
					if ( *pbKey++ == (BYTE)~0 )
						{
						plineColumn->cb = 0;
						err = ErrERRCheck( JET_wrnColumnNull );
						}
					else
						{
						Assert( pbKey[-1] == (BYTE)~0x7f );
						plineColumn->cb = 4;
						if ( pbKey[0] & maskByteHighBit )
							{
							plineColumn->pb[0] = pbKey[3];
							plineColumn->pb[1] = pbKey[2];
							plineColumn->pb[2] = pbKey[1];
							plineColumn->pb[3] = pbKey[0];
							}
						else
							{
							plineColumn->pb[0] = (BYTE)~pbKey[3];
							plineColumn->pb[1] = (BYTE)~pbKey[2];
							plineColumn->pb[2] = (BYTE)~pbKey[1];
							plineColumn->pb[3] = bFlipHighBit(~pbKey[0]);
							}
						pbKey += 4;
						}
					}
				else
					{
					if ( *pbKey++ == 0 )
						{
						plineColumn->cb = 0;
						err = ErrERRCheck( JET_wrnColumnNull );
						}
					else
						{
						Assert( pbKey[-1] == 0x7f );
						plineColumn->cb = 4;
						if ( pbKey[0] & maskByteHighBit )
							{
							plineColumn->pb[0] = pbKey[3];
							plineColumn->pb[1] = pbKey[2];
							plineColumn->pb[2] = pbKey[1];
							plineColumn->pb[3] = bFlipHighBit(pbKey[0]);
							}
						else
							{
							plineColumn->pb[0] = (BYTE)~pbKey[3];
							plineColumn->pb[1] = (BYTE)~pbKey[2];
							plineColumn->pb[2] = (BYTE)~pbKey[1];
							plineColumn->pb[3] = (BYTE)~pbKey[0];
							}
						pbKey += 4;
						}
					}
				break;

			case JET_coltypCurrency:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				if ( fDescending )
					{
					if ( *pbKey++ == (BYTE)~0 )
						{
						plineColumn->cb = 0;
						err = ErrERRCheck( JET_wrnColumnNull );
						}
					else
						{
						Assert( pbKey[-1] == (BYTE)~0x7f );
						plineColumn->cb = 8;
						if ( coltyp != JET_coltypCurrency &&
							(pbKey[0] & maskByteHighBit) )
							{
							plineColumn->pb[0] = pbKey[7];
							plineColumn->pb[1] = pbKey[6];
							plineColumn->pb[2] = pbKey[5];
							plineColumn->pb[3] = pbKey[4];
							plineColumn->pb[4] = pbKey[3];
							plineColumn->pb[5] = pbKey[2];
							plineColumn->pb[6] = pbKey[1];
							plineColumn->pb[7] = pbKey[0];
							}
						else
							{
							plineColumn->pb[0] = (BYTE)~pbKey[7];
							plineColumn->pb[1] = (BYTE)~pbKey[6];
							plineColumn->pb[2] = (BYTE)~pbKey[5];
							plineColumn->pb[3] = (BYTE)~pbKey[4];
							plineColumn->pb[4] = (BYTE)~pbKey[3];
							plineColumn->pb[5] = (BYTE)~pbKey[2];
							plineColumn->pb[6] = (BYTE)~pbKey[1];
							plineColumn->pb[7] = bFlipHighBit(~pbKey[0]);
							}
						pbKey += 8;
						}
					}
				else
					{
					if ( *pbKey++ == 0 )
						{
						plineColumn->cb = 0;
						err = ErrERRCheck( JET_wrnColumnNull );
						}
					else
						{
						Assert( pbKey[-1] == 0x7f );
						plineColumn->cb = 8;
						if ( coltyp == JET_coltypCurrency || (pbKey[0] & maskByteHighBit) )
							{
							plineColumn->pb[0] = pbKey[7];
							plineColumn->pb[1] = pbKey[6];
							plineColumn->pb[2] = pbKey[5];
							plineColumn->pb[3] = pbKey[4];
							plineColumn->pb[4] = pbKey[3];
							plineColumn->pb[5] = pbKey[2];
							plineColumn->pb[6] = pbKey[1];
							plineColumn->pb[7] = bFlipHighBit(pbKey[0]);
							}
						else
							{
							plineColumn->pb[0] = (BYTE)~pbKey[7];
							plineColumn->pb[1] = (BYTE)~pbKey[6];
							plineColumn->pb[2] = (BYTE)~pbKey[5];
							plineColumn->pb[3] = (BYTE)~pbKey[4];
							plineColumn->pb[4] = (BYTE)~pbKey[3];
							plineColumn->pb[5] = (BYTE)~pbKey[2];
							plineColumn->pb[6] = (BYTE)~pbKey[1];
							plineColumn->pb[7] = (BYTE)~pbKey[0];
							}
						pbKey += 8;
						}
					}
				break;

#ifdef NEW_TYPES
			case JET_coltypDate:
				if ( fDescending )
					{
					if ( *pbKey++ == (BYTE)~0 )
						{
						plineColumn->cb = 0;
						err = ErrERRCheck( JET_wrnColumnNull );
						}
					else
						{
						Assert( pbKey[-1] == (BYTE)~0x7f );
						plineColumn->cb = 4;
						if ( (pbKey[0] & maskByteHighBit) )
							{
							plineColumn->pb[0] = pbKey[3];
							plineColumn->pb[1] = pbKey[2];
							plineColumn->pb[2] = pbKey[1];
							plineColumn->pb[3] = pbKey[0];
							}
						else
							{
							plineColumn->pb[0] = (BYTE)~pbKey[3];
							plineColumn->pb[1] = (BYTE)~pbKey[2];
							plineColumn->pb[2] = (BYTE)~pbKey[1];
							plineColumn->pb[3] = bFlipHighBit(~pbKey[0]);
							}
						pbKey += 4;
						}
					}
				else
					{
					if ( *pbKey++ == 0 )
						{
						plineColumn->cb = 0;
						err = ErrERRCheck( JET_wrnColumnNull );
						}
					else
						{
						Assert( pbKey[-1] == 0x7f );
						plineColumn->cb = 4;
						if ( (pbKey[0] & maskByteHighBit) )
							{
							plineColumn->pb[0] = pbKey[3];
							plineColumn->pb[1] = pbKey[2];
							plineColumn->pb[2] = pbKey[1];
							plineColumn->pb[3] = bFlipHighBit(pbKey[0]);
							}
						else
							{
							plineColumn->pb[0] = (BYTE)~pbKey[3];
							plineColumn->pb[1] = (BYTE)~pbKey[2];
							plineColumn->pb[2] = (BYTE)~pbKey[1];
							plineColumn->pb[3] = (BYTE)~pbKey[0];
							}
						pbKey += 4;
						}
					}
				break;

			case JET_coltypGuid:
				if ( *pbKey++ == (BYTE)(mask ^ 0) )
					{
					plineColumn->cb = 0;
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert( pbKey[-1] == (BYTE)(mask ^ (BYTE)0x7f) );
					plineColumn->cb = 16;
					plineColumn->pb[8] = *pbKey++; plineColumn->pb[9] = *pbKey++;
					plineColumn->pb[10] = *pbKey++; plineColumn->pb[11] = *pbKey++;
					plineColumn->pb[12] = *pbKey++; plineColumn->pb[13] = *pbKey++;
					plineColumn->pb[14] = *pbKey++; plineColumn->pb[15] = *pbKey++;
					plineColumn->pb[7] = *pbKey++; plineColumn->pb[6] = *pbKey++;
					plineColumn->pb[5] = *pbKey++; plineColumn->pb[4] = *pbKey++;
					plineColumn->pb[3] = *pbKey++; plineColumn->pb[2] = *pbKey++;
					plineColumn->pb[1] = *pbKey++; plineColumn->pb[0] = *pbKey++;
					}
				break;
#endif

			case JET_coltypText:
			case JET_coltypLongText:
TextTypes:
				if ( fDescending )
					{
					if ( fFixedField )
						{
						if ( *pbKey++ == (BYTE)~0 )
							{
							plineColumn->cb = 0;
							err = ErrERRCheck( JET_wrnColumnNull );
							}
//						/* zero-length strings -- only for Text and LongText
//						/**/	
//						else if ( pbKey[-1] == (BYTE)~0x40 )
//							{
//							plineColumn->cb = 0;
//							Assert( FRECTextColumn( coltyp ) );
//							}
						else
							{
							FIELD	*pfieldFixed = PfieldFDBFixed( pfdb );
							INT		ibT = 0;

							Assert( pbKey[-1] == (BYTE)~0x7f );
							cbField = pfieldFixed[fidT - 1].cbMaxLen;
							if ( cbField > pbKeyMax - pbKey )
								cbField = (INT)(pbKeyMax - pbKey);
							plineColumn->cb = cbField;
							while ( cbField-- )
								{
								plineColumn->pb[ibT++] = (BYTE)~*pbKey++;
								}
							}
						}
					else
						{
						cbField = 0;
						switch( *pbKey )
							{
							case (BYTE)~0:		  						/* Null-column */
								err = ErrERRCheck( JET_wrnColumnNull );
								break;

							case (BYTE)~0x40:							/* zero-length string */
								Assert( FRECTextColumn( coltyp ) );

								break;

							default:
								Assert( *pbKey == ~0x7f );
								for ( ; *pbKey != (BYTE)~0; cbField++)
									plineColumn->pb[cbField] = (BYTE)~*pbKey++;
						  	}
						pbKey++;
						plineColumn->cb = (BYTE)cbField;
						}
					}
				else
					{
					if ( fFixedField )
						{
						if ( *pbKey++ == 0 )
							{
							plineColumn->cb = 0;
							err = ErrERRCheck( JET_wrnColumnNull );
							}
//						/* zero-length strings -- only for Text and LongText
//						/**/	
//						else if ( pbKey[-1] == (BYTE)0x40 )
//							{
//							Assert( FRECTextColumn( coltyp ) );
//							plineColumn->cb = 0;
//							}
						else
							{
							FIELD *pfieldFixed = PfieldFDBFixed( pfdb );

							cbField = pfieldFixed[fidT-1].cbMaxLen;
							if ( cbField > pbKeyMax-pbKey )
								cbField = (INT)(pbKeyMax-pbKey);
							plineColumn->cb = cbField;
							memcpy( plineColumn->pb, pbKey, cbField );
							pbKey += cbField;
							}
						}
					else
						{
						cbField = 0;
						switch( *pbKey )
							{
							/* Null-column
							/**/
							case (BYTE) 0:
								err = ErrERRCheck( JET_wrnColumnNull );
								break;

							/* zero-length string
							/**/
							case (BYTE) 0x40:
								Assert( FRECTextColumn( coltyp ) );

								break;

							default:
								Assert( *pbKey == 0x7f );
								pbKey++;
								for ( ; *pbKey != (BYTE)0; cbField++)
									plineColumn->pb[cbField] = (BYTE)*pbKey++;
							}
						pbKey++;
						plineColumn->cb = (BYTE)cbField;
						}
					}
				break;

			case JET_coltypBinary:
			case JET_coltypLongBinary:
				if ( fFixedField )
					goto TextTypes;
				if ( fDescending )
					{
					BYTE	*pbColumn = plineColumn->pb;

					cbField = 0;
					do {
						BYTE	cbChunk;
						BYTE	ib;

						if ((cbChunk = (BYTE)~pbKey[8]) == 9)
							cbChunk = 8;
						for (ib = 0; ib < cbChunk; ib++)
							pbColumn[ib] = (BYTE)~pbKey[ib];
						cbField += cbChunk;
						pbKey += 9;
						pbColumn += cbChunk;
						}
					while (pbKey[-1] == (BYTE)~9);
					plineColumn->cb = (BYTE)cbField;
					}
				else
					{
					BYTE	*pbColumn = plineColumn->pb;

					cbField = 0;
					do {
						BYTE cbChunk;

						if ( ( cbChunk = pbKey[8] ) == 9 )
							cbChunk = 8;
						memcpy( pbColumn, pbKey, cbChunk );
						cbField += cbChunk;
						pbKey += 9;
						pbColumn += cbChunk;
						}
					while( pbKey[-1] == 9 );
					plineColumn->cb = cbField;
					}

				if ( cbField == 0 )
					{
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				break;
			}
		
		/*	if just retrieve field requested then break
		/**/
		if ( fidT == fid )
			break;
		}

	Assert( err == JET_errSuccess || err == JET_wrnColumnNull );
	return err;
	}


ERR VTAPI ErrIsamRetrieveKey(
	PIB			*ppib,
	FUCB		*pfucb,
	BYTE		*pb,
	ULONG		cbMax,
	ULONG		*pcbActual,
	JET_GRBIT	grbit )
	{
	ERR			err;
	FUCB		*pfucbIdx;
	FCB			*pfcbIdx;
	ULONG		cbKeyReturned;
			  	
	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );

	/*	retrieve key from key buffer
	/**/
	if ( grbit & JET_bitRetrieveCopy )
		{
		//	UNDONE:	support JET_bitRetrieveCopy for inserted record
		//			by creating key on the fly.
		if ( pfucb->cbKey == 0 )
			{
			return ErrERRCheck( JET_errKeyNotMade );
			}
		if ( pb != NULL )
			{
			memcpy( pb, pfucb->pbKey + 1, min( pfucb->cbKey - 1, cbMax ) );
			}
		if ( pcbActual )
			*pcbActual = pfucb->cbKey - 1;
		return JET_errSuccess;
		}

	/*	retrieve current index value
	/**/
	if ( FFUCBIndex( pfucb ) )
		{
		pfucbIdx = pfucb->pfucbCurIndex != pfucbNil ? pfucb->pfucbCurIndex : pfucb;
		Assert( pfucbIdx != pfucbNil );
		pfcbIdx = pfucbIdx->u.pfcb;
		Assert( pfcbIdx != pfcbNil );
		CallR( ErrDIRGet( pfucbIdx ) );
		}
	else
		{
		pfucbIdx = pfucb;
		pfcbIdx = (FCB *)pfucb->u.pscb; // first element of an SCB is an FCB
		Assert( pfcbIdx != pfcbNil );
		}

	/*	set err to JET_errSuccess.
	/**/
	err = JET_errSuccess;

	cbKeyReturned = pfucbIdx->keyNode.cb;
	if ( pcbActual )
		*pcbActual = cbKeyReturned;
	if ( cbKeyReturned > cbMax )
		{
		err = ErrERRCheck( JET_wrnBufferTruncated );
		cbKeyReturned = cbMax;
		}

	if ( pb != NULL )
		{
		memcpy( pb, pfucbIdx->keyNode.pb, (size_t)cbKeyReturned );
		}

	return err;
	}


ERR VTAPI ErrIsamGetBookmark( PIB *ppib, FUCB *pfucb, BYTE *pb, ULONG cbMax, ULONG *pcbActual )
	{
	ERR		err;
	ULONG	cb;
	SRID 	srid;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	Assert( pb != NULL );

	/*	retrieve bookmark
	/**/
	FUCBSetGetBookmark( pfucb );
	CallR( ErrDIRGetBookmark( pfucb, &srid ) );
	cb = sizeof(SRID);
	if ( cb > cbMax )
		cb = cbMax;
	if ( pcbActual )
		*pcbActual = sizeof(SRID);
	memcpy( pb, &srid, (size_t)cb );

	return JET_errSuccess;
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\info.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */


extern CDESC *  rgcdescSc;


/*	local data types
/**/

typedef struct						/* returned by INFOGetTableColumnInfo */
	{
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	USHORT			wCountry;
	USHORT			langid;
	USHORT			cp;
	USHORT			wCollate;
	ULONG			cbMax;
	JET_GRBIT		grbit;
	INT				cbDefault;
	BYTE			rgbDefault[JET_cbColumnMost];
	CHAR			szName[JET_cbNameMost + 1];
	} COLUMNDEF;


/* Static data for ErrIsamGetObjectInfo */

CODECONST( JET_COLUMNDEF ) rgcolumndefGetObjectInfo[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypDateTime, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypDateTime, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};

#define ccolumndefGetObjectInfoMax \
	( sizeof(rgcolumndefGetObjectInfo) / sizeof(JET_COLUMNDEF) )

/* column indexes for rgcolumndefGetObjectInfo */
#define iContainerName		0
#define iObjectName			1
#define iObjectType			2
#define iDtCreate			3
#define iDtUpdate			4
#define iCRecord			5
#define iCPage				6
#define iGrbit				7
#define iFlags				8

/*	SID
/*	ACM
/*	grbit
/**/
CODECONST(JET_COLUMNDEF) rgcolumndefGetObjectAcmInfo[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypBinary, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};

/*	column indexes for rgcolumndefGetObjectAcmInfo
/**/
#define iAcmSid				0
#define iAcmAcm				1
#define iAcmGrbit			2

#define ccolumndefGetObjectAcmInfoMax \
	( sizeof( rgcolumndefGetObjectAcmInfo ) / sizeof( JET_COLUMNDEF ) )

/* static data for ErrIsamGetColumnInfo
/**/
CODECONST( JET_COLUMNDEF ) rgcolumndefGetColumnInfo[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypBinary, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 }
	};

CODECONST( JET_COLUMNDEF ) rgcolumndefGetColumnInfoCompact[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypBinary, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 }
	};

#define ccolumndefGetColumnInfoMax \
	( sizeof( rgcolumndefGetColumnInfo ) / sizeof( JET_COLUMNDEF ) )

#define iColumnPOrder		0
#define iColumnName			1
#define iColumnId  			2
#define iColumnType			3
#define iColumnCountry		4
#define iColumnLangid		5
#define iColumnCp			6
#define iColumnCollate		7
#define iColumnSize			8
#define iColumnGrbit  		9
#define iColumnDefault		10
#define iColumnTableName	11
#define iColumnColumnName	12


/*	static data for ErrIsamGetIndexInfo
/**/
CODECONST( JET_COLUMNDEF ) rgcolumndefGetIndexInfo[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 }
	};

#define ccolumndefGetIndexInfoMax ( sizeof( rgcolumndefGetIndexInfo ) / sizeof( JET_COLUMNDEF ) )

#define iIndexName		0
#define iIndexGrbit		1
#define iIndexCKey		2
#define iIndexCEntry  	3
#define iIndexCPage		4
#define iIndexCCol		5
#define iIndexICol		6
#define iIndexColId		7
#define iIndexColType	8
#define iIndexCountry	9
#define iIndexLangid  	10
#define iIndexCp	  	11
#define iIndexCollate	12
#define iIndexColBits	13
#define iIndexColName	14


/*	internal function prototypes
/**/
/*=================================================================
INFOGetTableColumnInfo

Parameters:	pfucb				pointer to FUCB for table containing columns
			pfid	  			pointer field id to start search at
			szColumnName		column name or NULL for next column
			pcolumndef			output buffer containing column info

Return Value: Column id of column found ( fidTaggedMost if none )

Errors/Warnings:

Side Effects:
=================================================================*/
LOCAL VOID INFOGetTableColumnInfo(
	FUCB		*pfucb, 			/* FUCB for table containing columns */
	FID			*pfid, 				/* field id where search is to start */
	CHAR		*szColumnName, 		/* column name or NULL for next column */
	COLUMNDEF 	*pcolumndef )	 	/* output buffer for column info */
	{
	ERR			err;
	FID			fid = *pfid;
	FDB			*pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	FIELD		*pfield;			/* first element of specific field type */
	FID			ifield;			 	/* index to current element of field type */
	FID			fidLast;		 	/* column id of last field defined for type */
	JET_GRBIT 	grbit;				/* flags for the field */
	FID			fidT;
	ULONG		itagSequenceT;
	LINE		lineT;

	/*	check the fixed fields first
	/**/
	if ( fid <= fidFixedMost )
		{
		ifield  = fid - fidFixedLeast;
		fidLast = pfdb->fidFixedLast - fidFixedLeast + 1;
		pfield  = PfieldFDBFixed( pfdb );

		while ( ifield < fidLast &&
			( pfield[ifield].coltyp == JET_coltypNil ||
			( szColumnName != NULL &&
			UtilCmpName( szColumnName, SzMEMGetString( pfdb->rgb, pfield[ifield].itagFieldName ) ) != 0 ) ) )
			{
			ifield++;
			}

		if ( ifield < fidLast )
			{
			fid   = ifield + fidFixedLeast;
			grbit = FFUCBUpdatable( pfucb ) ? JET_bitColumnFixed | JET_bitColumnUpdatable : JET_bitColumnFixed;
			}
		else
			{
			fid = fidVarLeast;
			}
		}

	/*	check variable fields
	/**/
	if ( fid >= fidVarLeast && fid <= fidVarMost )
		{
		ifield  = fid - fidVarLeast;
		fidLast = pfdb->fidVarLast - fidVarLeast + 1;
		pfield  = PfieldFDBVar( pfdb );

		while ( ifield < fidLast &&
			( pfield[ifield].coltyp == JET_coltypNil ||
			( szColumnName != NULL &&
			UtilCmpName( szColumnName, SzMEMGetString( pfdb->rgb, pfield[ifield].itagFieldName ) ) != 0 ) ) )
			ifield++;

		if ( ifield < fidLast )
			{
			fid   = ifield + fidVarLeast;
			grbit = FFUCBUpdatable( pfucb ) ? JET_bitColumnUpdatable : 0;
			}
		else
			{
			fid = fidTaggedLeast;
			}
		}

	/*	check the tagged fields
	/**/
	if ( fid >= fidTaggedLeast )
		{
		ifield  = fid - fidTaggedLeast;
		fidLast	= pfdb->fidTaggedLast - fidTaggedLeast + 1;
		pfield  = PfieldFDBTagged( pfdb );

		while ( ifield < fidLast &&
			( pfield[ifield].coltyp == JET_coltypNil ||
			( szColumnName != NULL &&
			UtilCmpName( szColumnName, SzMEMGetString( pfdb->rgb, pfield[ifield].itagFieldName ) ) != 0 ) ) )
			{
			ifield++;
			}

		if ( ifield < fidLast )
			{
			fid   = ifield + fidTaggedLeast;
			grbit = FFUCBUpdatable( pfucb ) ? JET_bitColumnTagged | JET_bitColumnUpdatable : JET_bitColumnTagged;
			}
		else
			{
			fid = fidMax;
			}
		}

	/*	if a field was found, then return the information about it
	/**/
	if ( fid < fidMax )
		{
		if ( FFIELDNotNull( pfield[ifield].ffield ) )
			grbit |= JET_bitColumnNotNULL;

		if ( FFIELDAutoInc( pfield[ifield].ffield ) )
			grbit |= JET_bitColumnAutoincrement;

		if ( FFIELDVersion( pfield[ifield].ffield ) )
			grbit |= JET_bitColumnVersion;

		if ( FFIELDMultivalue( pfield[ifield].ffield ) )
			grbit |= JET_bitColumnMultiValued;

		pcolumndef->columnid 	= fid;
		pcolumndef->coltyp		= pfield[ifield].coltyp;
		pcolumndef->wCountry	= countryDefault;
		pcolumndef->langid		= langidDefault;
		pcolumndef->cp			= pfield[ifield].cp;
//	UNDONE:	support collation order
		pcolumndef->wCollate	= JET_sortEFGPI;
		pcolumndef->grbit    	= grbit;
		pcolumndef->cbMax      	= pfield[ifield].cbMaxLen;

		pcolumndef->cbDefault	= 0;

		if ( FFIELDDefault( pfield[ifield].ffield ) )
			{
			itagSequenceT = 1;
			fidT = fid;

			Assert( pfdb == (FDB *)pfucb->u.pfcb->pfdb );
			err = ErrRECIRetrieveColumn( pfdb,
				&pfdb->lineDefaultRecord,
				&fidT,
				&itagSequenceT,
				1,
				&lineT,
				0 );
			Assert( err >= JET_errSuccess );
			if ( err == wrnRECLongField )
				{
				// Default long values must be intrinsic.
				Assert( !FFieldIsSLong( lineT.pb ) );
				lineT.pb += offsetof( LV, rgb );
				lineT.cb -= offsetof( LV, rgb );
				}

			pcolumndef->cbDefault = lineT.cb;
			memcpy( pcolumndef->rgbDefault, lineT.pb, lineT.cb );
			}

		strcpy( pcolumndef->szName,
			SzMEMGetString( pfdb->rgb, pfield[ifield].itagFieldName ) );
		}

	*pfid = fid;
	return;
	}


LOCAL ERR ErrInfoGetObjectInfo0(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	CHAR			*szContainerName,
	CHAR			*szObjectName,
	VOID			*pv,
	unsigned long	cbMax );
LOCAL ERR ErrInfoGetObjectInfo12(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	CHAR			*szContainerName,
	CHAR			*szObjectName,
	VOID			*pv,
	unsigned long	cbMax,
	long			lInfoLevel );
LOCAL ERR ErrInfoGetObjectInfo3(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	CHAR			*szContainerName,
	CHAR			*szObjectName,
	VOID			*pv,
	unsigned long	cbMax,
	BOOL			fReadOnly );

LOCAL ERR ErrInfoGetTableColumnInfo0( PIB *ppib, FUCB *pfucb, CHAR *szColumnName, VOID *pv, unsigned long cbMax );
LOCAL ERR ErrInfoGetTableColumnInfo1( PIB *ppib, FUCB *pfucb, CHAR *szColumnName, VOID *pv, unsigned long cbMax, BOOL fCompacting );
LOCAL ERR ErrInfoGetTableColumnInfo3( PIB *ppib, FUCB *pfucb, CHAR *szColumnName, VOID *pv, unsigned long cbMax );
LOCAL ERR ErrInfoGetTableColumnInfo4( PIB *ppib, FUCB *pfucb, CHAR *szColumnName, VOID *pv, unsigned long cbMax );
LOCAL ERR ErrInfoGetTableIndexInfo01( PIB *ppib, FUCB *pfucb, CHAR *szIndexName, VOID *pv, unsigned long cbMax, LONG lInfoLevel );
LOCAL ERR ErrInfoGetTableIndexInfo2( PIB *ppib, FUCB *pfucb, CHAR *szIndexName, VOID *pv, unsigned long cbMax );



/*=================================================================
ErrIsamGetObjectInfo

Description: Returns information about all objects or a specified object

Parameters:		ppib		   	pointer to PIB for current session
				dbid		   	database id containing objects
				objtyp			type of object or objtypNil for all objects
				szContainer		container name or NULL for all objects
				szObjectName	object name or NULL for all objects
				pout		   	output buffer
				lInfoLevel		level of information ( 0, 1, or 2 )

Return Value:	JET_errSuccess if the oubput buffer is valid

Errors/Warnings:

Side Effects:
=================================================================*/
ERR VDBAPI ErrIsamGetObjectInfo(
	JET_VSESID		vsesid, 			/* pointer to PIB for current session */
	JET_DBID		vdbid, 	  			/* database id containing objects */
	JET_OBJTYP		objtyp,				/* type of object or objtypNil for all */
	const CHAR		*szContainer, 		/* container name or NULL for all */
	const CHAR		*szObject, 			/* object name or NULL for all */
	VOID			*pv,
	unsigned long	cbMax,
	unsigned long	lInfoLevel ) 		/* information level */
	{
	PIB				*ppib = (PIB *) vsesid;
	ERR				err;
	DBID   			dbid;
	FUCB   			*pfucbMSO = NULL;
	CHAR   			szContainerName[( JET_cbNameMost + 1 )];
	CHAR   			szObjectName[( JET_cbNameMost + 1 )];
	OBJID  			objidCtr;
	ULONG  			cbActual;
	JET_COLUMNID	columnidObjectId;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	dbid = DbidOfVDbid( vdbid );

	if ( szContainer == NULL || *szContainer == '\0' )
		*szContainerName = '\0';
	else
		CallR( ErrUTILCheckName( szContainerName, szContainer, ( JET_cbNameMost + 1 ) ) );
	if ( szObject == NULL || *szObject == '\0' )
		*szObjectName = '\0';
	else
		CallR( ErrUTILCheckName( szObjectName, szObject, ( JET_cbNameMost + 1 ) ) );

	/*	check for invalid information level
	/**/
	switch( lInfoLevel )
		{
		case JET_ObjInfo:
		case JET_ObjInfoListNoStats:
		case JET_ObjInfoList:
		case JET_ObjInfoSysTabCursor:
		case JET_ObjInfoListACM:
		case JET_ObjInfoNoStats:
		case JET_ObjInfoSysTabReadOnly:
		case JET_ObjInfoRulesLoaded:
			break;
		default:
			return ErrERRCheck( JET_errInvalidParameter );
		}

	/* MSysObjects will be accessed directly or scanned for all object info
	/**/
	CallR( ErrFILEOpenTable( ppib, (DBID)dbid, &pfucbMSO, szSoTable, 0 ) );
	if ( lInfoLevel == JET_ObjInfo ||
		lInfoLevel == JET_ObjInfoListNoStats ||
		lInfoLevel == JET_ObjInfoList ||
		FVDbidReadOnly( vdbid ) )
		{
		FUCBResetUpdatable( pfucbMSO );
		}

	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoIdColumn, &columnidObjectId ) );

	/*	use the object name index for both direct access and scanning
	/**/
	Call( ErrIsamSetCurrentIndex( ppib, pfucbMSO, szSoNameIndex ) );

	/*	get the object id for the specified container
	/**/
	objidCtr = objidRoot;
	if ( szContainerName != NULL && *szContainerName != '\0' )
		{
		Call( ErrIsamMakeKey( ppib, pfucbMSO, (void *)&objidCtr, sizeof( objidCtr ), JET_bitNewKey ) );
		Call( ErrIsamMakeKey( ppib, pfucbMSO, szContainerName, strlen( szContainerName ), 0 ) );
		err = ErrIsamSeek( ppib, pfucbMSO, JET_bitSeekEQ );
		if ( err < 0 )
			{
			if ( err == JET_errRecordNotFound )
				err = ErrERRCheck( JET_errObjectNotFound );
			goto HandleError;
			}

		/*	retrieve the container object id
		/**/
		Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidObjectId,
			(BYTE *)&objidCtr, sizeof( objidCtr ), &cbActual, 0, NULL ) );
		Assert( objidCtr != objidNil );
		}

	switch ( lInfoLevel )
		{
		case JET_ObjInfoNoStats:
		case JET_ObjInfo:
			err = ErrInfoGetObjectInfo0(
				ppib,
				pfucbMSO,
				objidCtr,
				objtyp,
				szContainerName,
				szObjectName,
				pv,
				cbMax );
			break;
		case JET_ObjInfoListNoStats:
		case JET_ObjInfoList:
			err = ErrInfoGetObjectInfo12(
				ppib,
				pfucbMSO,
				objidCtr,
				objtyp,
				szContainerName,
				szObjectName,
				pv,
				cbMax,
				lInfoLevel );
			break;
		case JET_ObjInfoSysTabCursor:
		case JET_ObjInfoSysTabReadOnly:
			err = ErrInfoGetObjectInfo3(
				ppib,
				pfucbMSO,
				objidCtr,
				objtyp,
				szContainerName,
				szObjectName,
				pv,
				cbMax,
				FVDbidReadOnly( vdbid ) );
			break;

//		case JET_ObjInfoListACM:
//		case JET_ObjInfoRulesLoaded:
		default:
			Assert (fFalse);  	/* Should have been previously validated */
			err = ErrERRCheck( JET_errFeatureNotAvailable );

		}

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucbMSO ) );
	return err;
	}


LOCAL ERR ErrInfoGetObjectInfo0(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	CHAR			*szContainerName,
	CHAR			*szObjectName,
	VOID			*pv,
	unsigned long	cbMax )
	{
	ERR				err;
	BYTE			*pb;
	ULONG			cbT;
	ULONG			cbActual;

	JET_COLUMNID  	columnidParentId;			/* columnid for ParentId column in MSysObjects */
	JET_COLUMNID 	columnidObjectName;			/* columnid for Name column in MSysObjects */
	JET_COLUMNID 	columnidObjectType;			/* columnid for Type column in MSysObjects */
	JET_COLUMNID 	columnidObjectId;			/* columnid for Id column in MSysObjects */
	JET_COLUMNID 	columnidCreate;				/* columnid for DateCreate column in MSysObjects */
	JET_COLUMNID 	columnidUpdate;				/* columnid for DateUpdate column in MSysObjects */
	JET_COLUMNID 	columnidFlags;				/* columnid for Flags column in MSysObjects */
	OBJTYP			objtypObject;

	/*	get columnids
	/**/
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoParentIdColumn, &columnidParentId ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectNameColumn, &columnidObjectName ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectTypeColumn, &columnidObjectType ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoIdColumn, &columnidObjectId ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateCreateColumn, &columnidCreate ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateUpdateColumn, &columnidUpdate ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoFlagsColumn, &columnidFlags ) );

	/*	use the object name index for both direct access and scanning
	/**/
	Call( ErrIsamSetCurrentIndex( ppib, pfucbMSO, szSoNameIndex ) );

	/*	return error if the output buffer is too small
	/**/
	if ( cbMax < sizeof(JET_OBJECTINFO) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	/*	seek to key ( ParentId = container id, Name = object name )
	/**/
	Call( ErrIsamMakeKey( ppib, pfucbMSO, (void *)&objidCtr, sizeof( objidCtr ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( ppib, pfucbMSO, szObjectName, strlen( szObjectName ), 0 ) );
	Call( ErrIsamSeek( ppib, pfucbMSO, JET_bitSeekEQ ) );

	/*	set cbStruct
	/**/
	((JET_OBJECTINFO *)pv)->cbStruct = sizeof(JET_OBJECTINFO);

	/*	set output data
	/**/
	pb = (BYTE *)&objtypObject;
	cbT = sizeof(objtypObject);
	Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidObjectType, pb, cbT, &cbActual, 0, NULL ) );
	*((JET_OBJTYP *)&(((JET_OBJECTINFO *)pv)->objtyp)) = (JET_OBJTYP)objtypObject;

	cbT = sizeof(JET_DATESERIAL);
	pb = (void *)&( ( JET_OBJECTINFO *)pv)->dtCreate;
	Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidCreate, pb, cbT, &cbActual, 0, NULL ) );

	pb = (void *)&( ( JET_OBJECTINFO *)pv)->dtUpdate;
	cbT = sizeof(JET_DATESERIAL);
	Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidUpdate, pb, cbT, &cbActual, 0, NULL ) );

	pb    = (void *)&( ( JET_OBJECTINFO *)pv )->flags;
	cbT = sizeof(ULONG);
	Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidFlags, pb, cbT, &cbActual, 0, NULL ) );
	if ( cbActual == 0 )
		{
		( (JET_OBJECTINFO *)pv )->flags = 0;
		}

	/*	set stats
	/**/
	if ( (JET_OBJTYP)objtypObject == JET_objtypTable )
		{
		Call( ErrSTATSRetrieveTableStats( ppib, pfucbMSO->dbid, szObjectName,
			&((JET_OBJECTINFO *)pv)->cRecord,
			NULL,
			&((JET_OBJECTINFO *)pv)->cPage ) );
		}
	else
		{
		((JET_OBJECTINFO *)pv )->cRecord = 0;
		((JET_OBJECTINFO *)pv )->cPage   = 0;
		}

	//	UNDONE:	how to set updatable
	((JET_OBJECTINFO *)pv )->grbit   = 0;
	if ( FFUCBUpdatable( pfucbMSO ) )
		{
		((JET_OBJECTINFO *)pv )->grbit |= JET_bitTableInfoUpdatable;
		}

	err = JET_errSuccess;

HandleError:
	if ( err == JET_errRecordNotFound )
		err = ErrERRCheck( JET_errObjectNotFound );
	return err;
	}


LOCAL ERR ErrInfoGetObjectInfo12(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	CHAR			*szContainerName,
	CHAR			*szObjectName,
	VOID			*pv,
	unsigned long	cbMax,
	long			lInfoLevel )
	{
#ifdef	DISPATCHING
	ERR				err;
	LINE  			line;

	JET_COLUMNID	columnidParentId;   	/* columnid for ParentId col in MSysObjects */
	JET_COLUMNID	columnidObjectName; 	/* columnid for Name column in MSysObjects */
	JET_COLUMNID	columnidObjectType; 	/* columnid for Type column in MSysObjects */
	JET_COLUMNID	columnidObjectId;   	/* columnid for Id column in MSysObjects */
	JET_COLUMNID	columnidCreate;     	/* columnid for DateCreate in MSysObjects */
	JET_COLUMNID	columnidUpdate;     	/* columnid for DateUpdate  in MSysObjects */
	JET_COLUMNID	columnidFlags;	   	/* columnid for Flags column in MSysObjects */

	CHAR  			szCtrName[( JET_cbNameMost + 1 )];
	CHAR  			szObjectNameCurrent[( JET_cbNameMost + 1 )+1];

	JET_TABLEID		tableid;
	JET_COLUMNID	rgcolumnid[ccolumndefGetObjectInfoMax];
	JET_OBJTYP		objtypObject;		/* type of current object */

	long  			cRows = 0;			/* count of objects found */
	long  			cRecord = 0;		/* count of records in table */
	long  			cPage = 0;			/* count of pages in table */

	BYTE			*pbContainerName;
	ULONG			cbContainerName;
	BYTE			*pbObjectName;
	ULONG			cbObjectName;
	BYTE			*pbObjectType;
	ULONG			cbObjectType;
	BYTE			*pbDtCreate;
	ULONG			cbDtCreate;
	BYTE			*pbDtUpdate;
	ULONG			cbDtUpdate;
	BYTE			*pbCRecord;
	ULONG			cbCRecord;
	BYTE			*pbCPage;
	ULONG			cbCPage;
	BYTE			*pbFlags;
	ULONG			cbFlags;

	JET_GRBIT		grbit;
	BYTE			*pbGrbit;
	ULONG			cbGrbit;

	/* get columnids
	/**/
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoParentIdColumn, &columnidParentId ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectNameColumn, &columnidObjectName ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectTypeColumn, &columnidObjectType ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoIdColumn, &columnidObjectId ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateCreateColumn, &columnidCreate ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateUpdateColumn, &columnidUpdate ) );
	CallR( ErrFILEGetColumnId( ppib, pfucbMSO, szSoFlagsColumn, &columnidFlags ) );

	/*	use the object name index for both direct access and scanning
	/**/
	CallR( ErrIsamSetCurrentIndex( ppib, pfucbMSO, szSoNameIndex ) );

	/*	quit if the output buffer is too small
	/**/
	if ( cbMax < sizeof(JET_OBJECTLIST) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	pbCRecord = (BYTE  *)&cRecord;
	cbCRecord = sizeof( cRecord );

	pbCPage = (BYTE  *) &cPage;
	cbCPage = sizeof( cPage );

	pbObjectType = (BYTE  *)&objtypObject;
	cbObjectType = sizeof( objtypObject );

	pbContainerName = szContainerName;
	if ( szContainerName == NULL || *szContainerName == '\0' )
		cbContainerName = 0;
	else
		cbContainerName = strlen( szContainerName );

	/* Open the temporary table which will be returned to the caller
	/**/
	CallR( ErrIsamOpenTempTable( (JET_SESID)ppib,
		(JET_COLUMNDEF *)rgcolumndefGetObjectInfo,
		ccolumndefGetObjectInfoMax,
		0,
		JET_bitTTScrollable,
		&tableid,
		rgcolumnid ) );

	/* Position to the record for the first object */
	if ( szContainerName == NULL || *szContainerName == '\0' )
		{
		/* If container not specified, then use first record in table */
		Call( ErrIsamMove( ppib, pfucbMSO, JET_MoveFirst, 0 ) );
		}
	else
		{
		/* move the first record for an object in the container
		/**/
		Call( ErrIsamMakeKey( ppib, pfucbMSO, (void *)&objidCtr,
			sizeof( objidCtr ), JET_bitNewKey ) );
		Call( ErrIsamSeek( ppib, pfucbMSO, JET_bitSeekGE ) );
		}

	do
		{
		/* get pointer to the object type
		/**/
		Call( ErrRECRetrieveColumn( pfucbMSO, (FID *)&columnidObjectType, 0, &line, 0 ) );

		/*	set objtypObject from line retrieval.
		/**/
		objtypObject = (JET_OBJTYP)( *(OBJTYP UNALIGNED *)line.pb );

		/*	get pointer to the ParentId ( container id )
		/**/
		Call( ErrRECRetrieveColumn( pfucbMSO, (FID *)&columnidParentId, 0, &line, 0 ) );

		/* done if container specified and object isn't in it
		/**/
		if ( szContainerName != NULL && *szContainerName != '\0' && objidCtr != *(OBJID UNALIGNED *)line.pb )
			goto ResetTempTblCursor;

		Assert( objidCtr == objidRoot || objidCtr == *(OBJID UNALIGNED *)line.pb );

		/* if desired object type and container
		/**/
		if ( objtyp == JET_objtypNil || objtyp == objtypObject )
			{
			/*	get the container name
			/**/
			if ( *(OBJID UNALIGNED *)line.pb == objidRoot )
				{
				pbContainerName = NULL;
				cbContainerName = 0;
				}
			else
				{
				Call( ErrCATFindNameFromObjid( ppib, pfucbMSO->dbid, *(OBJID UNALIGNED *)line.pb, szCtrName, sizeof(szCtrName), &cbContainerName ) );
				Assert( cbContainerName <= cbMax );
				szCtrName[cbContainerName] = '\0';
				pbContainerName = szCtrName;
				}

			/* get pointer to the object name
			/**/
			Call( ErrRECRetrieveColumn( pfucbMSO, (FID *)&columnidObjectName, 0, &line, 0 ) );
			pbObjectName = line.pb;
			cbObjectName = line.cb;

			/* get pointer to the object creation date
			/**/
			Call( ErrRECRetrieveColumn( pfucbMSO, (FID *)&columnidCreate, 0, &line, 0 ) );
			pbDtCreate = line.pb;
			cbDtCreate = line.cb;

			/* get pointer to the last update date
			/**/
			Call( ErrRECRetrieveColumn( pfucbMSO, (FID *)&columnidUpdate, 0, &line, 0 ) );
			pbDtUpdate = line.pb;
			cbDtUpdate = line.cb;

			/* get pointer to the last update date
			/**/
			Call( ErrRECRetrieveColumn( pfucbMSO, (FID *)&columnidFlags, 0, &line, 0 ) );
			pbFlags = line.pb;
			cbFlags = line.cb;

			/* get pointer to the last update date
			/**/
			grbit = 0;
			pbGrbit = (BYTE *)&grbit;
			cbGrbit = sizeof(JET_GRBIT);

			/*	get statistics if requested and if object is table
			/**/
			Assert( lInfoLevel == JET_ObjInfoList ||
				lInfoLevel == JET_ObjInfoListNoStats );
			if ( lInfoLevel == JET_ObjInfoList && objtypObject == JET_objtypTable )
				{
				/* terminate the name
				/**/
				memcpy( szObjectNameCurrent, pbObjectName, ( size_t )cbObjectName );
				szObjectNameCurrent[cbObjectName] = '\0';

				Call( ErrSTATSRetrieveTableStats( ppib,
					pfucbMSO->dbid,
					szObjectNameCurrent,
					&cRecord,
					NULL,
					&cPage ) );
				}

			/* add the current object info to the temporary table
			/**/
			Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid, JET_prepInsert ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iContainerName], pbContainerName,
				cbContainerName, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iObjectName], pbObjectName,
				cbObjectName, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iObjectType], pbObjectType,
				cbObjectType, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iDtCreate], pbDtCreate,
				cbDtCreate, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iDtUpdate], pbDtUpdate,
				cbDtUpdate, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iCRecord], pbCRecord,
				cbCRecord, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iCPage], pbCPage, cbCPage, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iFlags], pbFlags, cbFlags, 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iGrbit], pbGrbit, cbGrbit, 0, NULL ) );
			Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL ) );

			/* set the number of objects found
			/**/
			cRows++;
			}

		/* move to the next record
		/**/
		err = ErrIsamMove( ppib, pfucbMSO, JET_MoveNext, 0 );
		} while ( err >= 0 );

	/* return if error other than end of range
	/**/
	if ( err != JET_errNoCurrentRecord )
		goto HandleError;

ResetTempTblCursor:

	/* move to first record in the temporary table
	/**/
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	/* set the return structure
	/**/
	((JET_OBJECTLIST *)pv)->cbStruct = sizeof(JET_OBJECTLIST);
	((JET_OBJECTLIST *)pv)->tableid = tableid;
	((JET_OBJECTLIST *)pv)->cRecord = cRows;
	((JET_OBJECTLIST *)pv)->columnidcontainername = rgcolumnid[iContainerName];
	((JET_OBJECTLIST *)pv)->columnidobjectname = rgcolumnid[iObjectName];
	((JET_OBJECTLIST *)pv)->columnidobjtyp = rgcolumnid[iObjectType];
	((JET_OBJECTLIST *)pv)->columniddtCreate = rgcolumnid[iDtCreate];
	((JET_OBJECTLIST *)pv)->columniddtUpdate = rgcolumnid[iDtUpdate];
	((JET_OBJECTLIST *)pv)->columnidgrbit = rgcolumnid[iGrbit];
	((JET_OBJECTLIST *)pv)->columnidflags =	rgcolumnid[iFlags];
	((JET_OBJECTLIST *)pv)->columnidcRecord = rgcolumnid[iCRecord];
	((JET_OBJECTLIST *)pv)->columnidcPage = rgcolumnid[iCPage];

	return JET_errSuccess;

HandleError:
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );
	if ( err == JET_errRecordNotFound )
		err = ErrERRCheck( JET_errObjectNotFound );
	return err;
#else	/* !DISPATCHING */
	Assert( fFalse );
	return ErrERRCheck( JET_errFeatureNotAvailable );
#endif	/* !DISPATCHING */
	}


LOCAL ERR ErrInfoGetObjectInfo3(
	PIB				*ppib,
	FUCB			*pfucbMSO,
	OBJID			objidCtr,
	JET_OBJTYP		objtyp,
	CHAR			*szContainerName,
	CHAR			*szObjectName,
	VOID			*pv,
	unsigned long	cbMax,
	BOOL			fReadOnly )
	{
	ERR			err;
	FUCB			*pfucb = NULL;
#ifdef	DISPATCHING
	JET_TABLEID	tableid;
#endif	/* DISPATCHING */

	if ( cbMax < sizeof(JET_TABLEID) )
		return ErrERRCheck( JET_errInvalidParameter );

	CallR( ErrFILEOpenTable( ppib, (DBID)pfucbMSO->dbid, &pfucb, szSoTable, 0 ) );
	if ( fReadOnly )
		FUCBResetUpdatable( pfucb );
	Call( ErrIsamSetCurrentIndex( ppib, pfucb, szSoNameIndex ) );
	Call( ErrIsamMakeKey( ppib, pfucb, (void *)&objidCtr, sizeof( objidCtr ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( ppib, pfucb, szObjectName, strlen( szObjectName ), 0 ) );
	Call( ErrIsamSeek( ppib, pfucb, JET_bitSeekEQ ) );

	FUCBSetSystemTable( pfucb );

#ifdef	DISPATCHING
	Call( ErrAllocateTableid( &tableid, (JET_VTID)pfucb, &vtfndefIsamInfo ) );
	pfucb->fVtid = fTrue;
	pfucb->tableid = tableid;
	*(JET_TABLEID *)pv = tableid;
#else	/* !DISPATCHING */
	*(FUCB **)pv = pfucb;
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
	if ( err == JET_errRecordNotFound )
		err = ErrERRCheck( JET_errObjectNotFound );
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return err;
	}


ERR VTAPI ErrIsamGetTableInfo(
	JET_VSESID		vsesid,
	JET_VTID	 	vtid,
	void		 	*pvResult,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )
	{
	ERR	 			err = JET_errSuccess;
	PIB				*ppib = (PIB *)vsesid;
	FUCB		 	*pfucb = (FUCB *)vtid;
	FUCB 		 	*pfucbMSO;
	ULONG		 	cbActual;
	OBJID		 	objidCtr;
	OBJTYP			objtypObject;

	JET_COLUMNID  	columnidParentId;   	/* columnid for ParentId column in MSysObjects */
	JET_COLUMNID  	columnidObjectName; 	/* columnid for Name column in MSysObjects */
	JET_COLUMNID  	columnidObjectType; 	/* columnid for Type column in MSysObjects */
	JET_COLUMNID  	columnidObjectId;   	/* columnid for Id column in MSysObjects */
	JET_COLUMNID  	columnidCreate;	   		/* columnid for DateCreate column in MSysObjects */
	JET_COLUMNID  	columnidUpdate;		   	/* columnid for DateUpdate column in MSysObjects */
	JET_COLUMNID  	columnidFlags;	   		/* columnid for Flags column in MSysObjects */

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );

	/* if OLCStats info/reset can be done now
	/**/
	switch( lInfoLevel )
		{
		case JET_TblInfoOLC:
			{
			FCB	*pfcb = pfucb->u.pfcb;

			Assert( cbMax >= sizeof(JET_OLCSTAT) );
			cbActual = sizeof(JET_OLCSTAT);
			memcpy( (BYTE *) pvResult, (BYTE * ) &pfcb->olc_data, sizeof(P_OLC_DATA) );
			( (JET_OLCSTAT *) pvResult )->cpgCompactFreed = pfcb->cpgCompactFreed;
			return JET_errSuccess;
			}

		case JET_TblInfoResetOLC:
			pfucb->u.pfcb->cpgCompactFreed = 0;
			return JET_errSuccess;

		case JET_TblInfoSpaceAlloc:
			/*	number of pages and density
			/**/
			Assert( cbMax >= sizeof(ULONG) * 2);
			err = ErrCATGetTableAllocInfo(
					ppib,
					pfucb->dbid,
					pfucb->u.pfcb->pgnoFDP,
					(ULONG *)pvResult,
					((ULONG *)pvResult) + 1);
			return err;

		case JET_TblInfoSpaceUsage:
			{
			BYTE	fSPExtents = fSPOwnedExtent|fSPAvailExtent;

			if ( cbMax > 2 * sizeof(CPG) )
				fSPExtents |= fSPExtentLists;

			err = ErrSPGetInfo( ppib, pfucb->dbid, pfucb, pvResult, cbMax, fSPExtents );
			return err;
			}

		case JET_TblInfoSpaceOwned:
			err = ErrSPGetInfo( ppib, pfucb->dbid, pfucb, pvResult, cbMax, fSPOwnedExtent );
			return err;

		case JET_TblInfoSpaceAvailable:
			err = ErrSPGetInfo( ppib, pfucb->dbid, pfucb, pvResult, cbMax, fSPAvailExtent );
			return err;

		case JET_TblInfoDumpTable:
#ifdef DEBUG
			err = ErrFILEDumpTable( ppib, pfucb->dbid, pfucb->u.pfcb->szFileName );
			return err;
#else
			Assert( fFalse );
			return ErrERRCheck( JET_errFeatureNotAvailable );
#endif
		}

		
	CallR( ErrFILEOpenTable( ppib, (DBID)pfucb->dbid, &pfucbMSO, szSoTable, 0 ) );
	FUCBResetUpdatable( pfucbMSO );

	/* get columnids
	/**/
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoParentIdColumn, &columnidParentId ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectNameColumn, &columnidObjectName ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoObjectTypeColumn, &columnidObjectType ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoIdColumn, &columnidObjectId ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateCreateColumn, &columnidCreate ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoDateUpdateColumn, &columnidUpdate ) );
	Call( ErrFILEGetColumnId( ppib, pfucbMSO, szSoFlagsColumn, &columnidFlags ) );

	Call( ErrIsamSetCurrentIndex( ppib, pfucbMSO, szSoNameIndex ) );

	switch ( lInfoLevel )
		{
	case JET_TblInfo:
		/* check buffer size
		/**/
		if ( cbMax < sizeof(JET_OBJECTINFO) )
			{
			err = ErrERRCheck( JET_errBufferTooSmall );
			goto HandleError;
			}

		if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
			{
			err = ErrERRCheck( JET_errObjectNotFound );
			goto HandleError;
			}

		/* seek on made key ( ParentId = container id, Name = object name )
		/**/
		objidCtr = objidTblContainer;
		Call( ErrIsamMakeKey( ppib, pfucbMSO, (void *)&objidCtr,
			sizeof( objidCtr ), JET_bitNewKey ) );
		Call( ErrIsamMakeKey( ppib, pfucbMSO, pfucb->u.pfcb->szFileName,
			strlen( pfucb->u.pfcb->szFileName ), 0 ) );
		Call( ErrIsamSeek( ppib, pfucbMSO, JET_bitSeekEQ ) );

		/* set data to return
		/**/
		((JET_OBJECTINFO *)pvResult)->cbStruct = sizeof(JET_OBJECTINFO);

		Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidObjectType, (void *)&objtypObject,
			sizeof( objtypObject ), &cbActual, 0, NULL ) );
		Assert( cbActual == sizeof(objtypObject) );
		*((JET_OBJTYP *)&(((JET_OBJECTINFO *)pvResult)->objtyp)) =	(JET_OBJTYP) objtypObject;

		Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidCreate,
			(void *)&( ( JET_OBJECTINFO *)pvResult )->dtCreate,
			sizeof( JET_DATESERIAL ),
			&cbActual, 0, NULL ) );
		Assert( cbActual == sizeof( JET_DATESERIAL ) );

		Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidUpdate,
			(void *)&( ( JET_OBJECTINFO *)pvResult )->dtUpdate,
			sizeof(JET_DATESERIAL), &cbActual, 0, NULL ) );
		Assert( cbActual == sizeof( JET_DATESERIAL ) );

		Call( ErrIsamRetrieveColumn( ppib, pfucbMSO, columnidFlags,
			(void *)&((JET_OBJECTINFO *)pvResult )->flags,
			sizeof(JET_GRBIT), &cbActual, 0, NULL ) );
		if ( cbActual == 0 )
			((JET_OBJECTINFO *) pvResult)->flags = 0;

		/*	set base table capability bits
		/**/
		((JET_OBJECTINFO  *) pvResult)->grbit = JET_bitTableInfoBookmark;
		((JET_OBJECTINFO  *) pvResult)->grbit |= JET_bitTableInfoRollback;
		if ( FFUCBUpdatable( pfucb ) )
			{
			((JET_OBJECTINFO *)pvResult)->grbit |= JET_bitTableInfoUpdatable;
			}

		Call( ErrSTATSRetrieveTableStats( pfucb->ppib,
			pfucb->dbid,
			pfucb->u.pfcb->szFileName,
			&((JET_OBJECTINFO *)pvResult )->cRecord,
			NULL,
			&((JET_OBJECTINFO *)pvResult)->cPage ) );

		break;

	case JET_TblInfoRvt:
		err = ErrERRCheck( JET_errQueryNotSupported );
		break;

	case JET_TblInfoName:
	case JET_TblInfoMostMany:
		//	UNDONE:	add support for most many
		if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
			{
			err = ErrERRCheck( JET_errInvalidOperation );
			goto HandleError;
			}
		if ( strlen( pfucb->u.pfcb->szFileName ) >= cbMax )
			err = ErrERRCheck( JET_errBufferTooSmall );
		else
			{
			strcpy( pvResult, pfucb->u.pfcb->szFileName );
			}
		break;

	case JET_TblInfoDbid:
		if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
			{
			err = ErrERRCheck( JET_errInvalidOperation );
			goto HandleError;
			}
		/* check buffer size
		/**/
		if ( cbMax < sizeof(JET_DBID) + sizeof(JET_VDBID) )
			{
			err = ErrERRCheck( JET_errBufferTooSmall );
			goto HandleError;
			}
		else
			{
			DAB			*pdab = pfucb->ppib->pdabList;
#ifdef DB_DISPATCHING
			JET_DBID	dbid;
#endif

			for ( ; pdab->dbid != pfucb->dbid; pdab = pdab->pdabNext )
				;
#ifdef DB_DISPATCHING
			dbid = DbidOfVdbid( (JET_VDBID)pdab, &vdbfndefIsam );
			*(JET_DBID *)pvResult = dbid;
#else
			*(JET_DBID *)pvResult = (JET_DBID)pdab;
#endif
			*(JET_VDBID *)((CHAR *)pvResult + sizeof(JET_DBID)) = (JET_VDBID)pdab;
			}
		break;

	default:
		err = ErrERRCheck( JET_errInvalidParameter );
		}

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucbMSO ) );
	if ( err == JET_errRecordNotFound )
		err = ErrERRCheck( JET_errObjectNotFound );
	return err;
	}



/*=================================================================
ErrIsamGetColumnInfo

Description: Returns information about all columns for the table named

Parameters:
			ppib				pointer to PIB for current session
			dbid				id of database containing the table
			szTableName			table name
			szColumnName		column name or NULL for all columns
			pv					pointer to results
			cbMax				size of result buffer
			lInfoLevel			level of information ( 0, 1, or 2 )

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VDBAPI
ErrIsamGetColumnInfo(
	JET_VSESID		vsesid, 				/* pointer to PIB for current session */
	JET_DBID  		vdbid, 					/* id of database containing the table */
	const CHAR		*szTable, 				/* table name */
	const CHAR		*szColumnName,   		/* column name or NULL for all columns */
	VOID			*pv,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )	 		/* information level ( 0, 1, or 2 ) */
	{
	PIB				*ppib = (PIB *) vsesid;
	ERR				err;
	DBID	 		dbid;
	CHAR	 		szTableName[ ( JET_cbNameMost + 1 ) ];
	FUCB	 		*pfucb;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	dbid = DbidOfVDbid( vdbid );
	CallR( ErrUTILCheckName( szTableName, szTable, ( JET_cbNameMost + 1 ) ) );

	err = ErrFILEOpenTable( ppib, (DBID)dbid, &pfucb, szTableName, 0 );
	if ( err >= 0 )
		{
		if ( lInfoLevel == 0 || lInfoLevel == 1 || lInfoLevel == 4
			|| FVDbidReadOnly( vdbid ) )
			{
			FUCBResetUpdatable( pfucb );
			}
		}

	if ( err == JET_errObjectNotFound )
		{
		ERR			err;
		OBJID	 	objid;
		JET_OBJTYP	objtyp;

		err = ErrCATFindObjidFromIdName( ppib, dbid, objidTblContainer, szTableName, &objid, &objtyp );

		if ( err >= JET_errSuccess )
			{
			if ( objtyp == JET_objtypQuery )
				return ErrERRCheck( JET_errQueryNotSupported );
			if ( objtyp == JET_objtypLink )
				return ErrERRCheck( JET_errLinkNotSupported );
			if ( objtyp == JET_objtypSQLLink )
				return ErrERRCheck( JET_errSQLLinkNotSupported );
			}
		else
			return err;
		}

	Call( ErrIsamGetTableColumnInfo( (JET_VSESID) ppib, (JET_VTID) pfucb,
		szColumnName, pv, cbMax, lInfoLevel ) );
	CallS( ErrFILECloseTable( ppib, pfucb ) );

HandleError:
	return err;
	}


/*=================================================================
ErrIsamGetTableColumnInfo

Description: Returns column information for the table id passed

Parameters: 	ppib				pointer to PIB for the current session
				pfucb				pointer to FUCB for the table
				szColumnName		column name or NULL for all columns
				pv					pointer to result buffer
				cbMax				size of result buffer
				lInfoLevel			level of information

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VTAPI
ErrIsamGetTableColumnInfo(
	JET_VSESID		vsesid,				/* pointer to PIB for current session */
	JET_VTID		vtid, 				/* pointer to FUCB for the table */
	const CHAR		*szColumn, 			/* column name or NULL for all columns */
	void   			*pb,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )		/* information level ( 0, 1, or 2 ) */
	{
	ERR			err;
	PIB			*ppib = (PIB *)vsesid;
	FUCB		*pfucb = (FUCB *)vtid;
	CHAR		szColumnName[ (JET_cbNameMost + 1) ];

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	if ( szColumn == NULL || *szColumn == '\0' )
		{
		*szColumnName = '\0';
		}
	else
		{
		CallR( ErrUTILCheckName( szColumnName, szColumn, ( JET_cbNameMost + 1 ) ) );
		}

	switch ( lInfoLevel )
		{
		case JET_ColInfo:
			err = ErrInfoGetTableColumnInfo0( ppib, pfucb, szColumnName, pb, cbMax );
			break;
		case JET_ColInfoList:
			err = ErrInfoGetTableColumnInfo1( ppib, pfucb, szColumnName, pb, cbMax, fFalse );
			break;
		case JET_ColInfoSysTabCursor:
			err = ErrInfoGetTableColumnInfo3( ppib, pfucb, szColumnName, pb, cbMax );
			break;
		case JET_ColInfoBase:
			err = ErrInfoGetTableColumnInfo4( ppib, pfucb, szColumnName, pb, cbMax );
			break;
		case JET_ColInfoListCompact:
			err = ErrInfoGetTableColumnInfo1( ppib, pfucb, szColumnName, pb, cbMax, fTrue );
			break;
		default:
			err = ErrERRCheck( JET_errInvalidParameter );
		}

	return err;
	}


LOCAL ERR ErrInfoGetTableColumnInfo0( PIB *ppib, FUCB *pfucb, CHAR *szColumnName, VOID *pv, unsigned long cbMax )
	{
	FID				fid;
	COLUMNDEF	  	columndef;

	if ( cbMax < sizeof(JET_COLUMNDEF) || szColumnName == NULL )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	fid = fidFixedLeast;
	INFOGetTableColumnInfo( pfucb, &fid, szColumnName, &columndef );
	if ( fid > fidTaggedMost )
		{
		return ErrERRCheck( JET_errColumnNotFound );
		}

	((JET_COLUMNDEF *)pv)->cbStruct	= sizeof(JET_COLUMNDEF);
	((JET_COLUMNDEF *)pv)->columnid	= columndef.columnid;
	((JET_COLUMNDEF *)pv)->coltyp  	= columndef.coltyp;
	((JET_COLUMNDEF *)pv)->cbMax   	= columndef.cbMax;
	((JET_COLUMNDEF *)pv)->grbit   	= columndef.grbit;
	((JET_COLUMNDEF *)pv)->wCollate	= 0;
	((JET_COLUMNDEF *)pv)->cp	   	= columndef.cp;
	((JET_COLUMNDEF *)pv)->wCountry	= columndef.wCountry;
	((JET_COLUMNDEF *)pv)->langid  	= columndef.langid;

	return JET_errSuccess;
	}


LOCAL ERR ErrInfoGetTableColumnInfo1( PIB *ppib, FUCB *pfucb, CHAR *szColumnName, VOID *pv, unsigned long cbMax, BOOL fCompacting )
	{
#ifdef	DISPATCHING
	ERR				err;
	JET_TABLEID		tableid;
	JET_COLUMNID	rgcolumnid[ccolumndefGetColumnInfoMax];
	FID				fid;
	COLUMNDEF  		columndef;
	LONG		  	cRows = 0;
	WORD			wCollate = JET_sortEFGPI;	// For compacting
	JET_TABLEID		tableidInfo;

	/*	initialize variables
	/**/
	if ( cbMax < sizeof(JET_COLUMNLIST) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	/*	create temporary table
	/**/
	CallR( ErrIsamOpenTempTable( (JET_SESID)ppib,
		(JET_COLUMNDEF *)( fCompacting ? rgcolumndefGetColumnInfoCompact : rgcolumndefGetColumnInfo ),
		ccolumndefGetColumnInfoMax,
		0,
		JET_bitTTScrollable,
		&tableid,
		rgcolumnid ) );

	for ( fid = fidFixedLeast; ; fid++ )
		{
		INFOGetTableColumnInfo( pfucb, &fid, NULL, &columndef );
		if ( fid > fidTaggedMost )
			break;

		Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid, JET_prepInsert ) );

		/*	get presentation order for this column and set in
		/*	output table.  For temp tables, no order will be available.
		/**/
		err = ErrInfoGetTableColumnInfo3( ppib, pfucb, columndef.szName, &tableidInfo, sizeof(tableidInfo) );
		if ( err == JET_errSuccess )
			{
			ULONG	ulPOrder;
			ULONG	cb;

			Call( ErrDispRetrieveColumn( (JET_SESID)ppib, tableidInfo, ColumnidCATGetColumnid( itableSc, iMSC_POrder ), &ulPOrder, sizeof(ulPOrder), &cb, 0, NULL ) );

			if ( err != JET_wrnColumnNull )
				{
				// UNDONE: In the catalog, POrder is a SHORT, but in the temp table, it's LONG.
				Assert( cb == sizeof(USHORT)  ||  err == JET_wrnColumnNull );
				Call( ErrDispSetColumn( (JET_SESID)ppib, tableid, rgcolumnid[iColumnPOrder], &ulPOrder, sizeof(ulPOrder), 0, NULL ) );
				}

			CallS( ErrDispCloseTable( (JET_SESID)ppib, tableidInfo ) );
			}

		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnName], columndef.szName,
			strlen( columndef.szName ), 0 , NULL ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnId], (BYTE *)&columndef.columnid,
			sizeof(columndef.columnid), 0 , NULL ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnType], (BYTE *)&columndef.coltyp,
			sizeof(columndef.coltyp), 0 , NULL ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnCountry], &columndef.wCountry,
			sizeof( columndef.wCountry ), 0 , NULL ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnLangid], &columndef.langid,
			sizeof( columndef.langid ), 0 , NULL ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnCp], &columndef.cp,
			sizeof(columndef.cp), 0 , NULL ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnSize], (BYTE *)&columndef.cbMax,
			sizeof(columndef.cbMax), 0 , NULL ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnGrbit], &columndef.grbit,
			sizeof(columndef.grbit), 0 , NULL ) );

		Assert( !fCompacting  ||  wCollate == JET_sortEFGPI );
		if ( !fCompacting )
			wCollate = columndef.wCollate;
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnCollate], &wCollate,
			sizeof(wCollate), 0 , NULL ) );

		if ( columndef.cbDefault > 0 )
			{
			// UNDONE: Null default values are currently illegal.
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iColumnDefault], columndef.rgbDefault,
				columndef.cbDefault, 0 , NULL ) );
			}

		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnTableName], pfucb->u.pfcb->szFileName,
			strlen( pfucb->u.pfcb->szFileName ), 0 , NULL ) );
		Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
			rgcolumnid[iColumnColumnName], columndef.szName,
			strlen( columndef.szName ), 0 , NULL ) );

		Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL ) );
		cRows++;

		}	// for


	/*	move temporary table cursor to first row and return column list
	/**/
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	((JET_COLUMNLIST *)pv)->cbStruct = sizeof(JET_COLUMNLIST);
	((JET_COLUMNLIST *)pv)->tableid = tableid;
	((JET_COLUMNLIST *)pv)->cRecord = cRows;
	((JET_COLUMNLIST *)pv)->columnidPresentationOrder = rgcolumnid[iColumnPOrder];
	((JET_COLUMNLIST *)pv)->columnidcolumnname = rgcolumnid[iColumnName];
	((JET_COLUMNLIST *)pv)->columnidcolumnid = rgcolumnid[iColumnId];
	((JET_COLUMNLIST *)pv)->columnidcoltyp = rgcolumnid[iColumnType];
	((JET_COLUMNLIST *)pv)->columnidCountry = rgcolumnid[iColumnCountry];
	((JET_COLUMNLIST *)pv)->columnidLangid = rgcolumnid[iColumnLangid];
	((JET_COLUMNLIST *)pv)->columnidCp = rgcolumnid[iColumnCp];
	((JET_COLUMNLIST *)pv)->columnidCollate = rgcolumnid[iColumnCollate];
	((JET_COLUMNLIST *)pv)->columnidcbMax = rgcolumnid[iColumnSize];
	((JET_COLUMNLIST *)pv)->columnidgrbit = rgcolumnid[iColumnGrbit];
	((JET_COLUMNLIST *)pv)->columnidDefault =	rgcolumnid[iColumnDefault];
	((JET_COLUMNLIST *)pv)->columnidBaseTableName = rgcolumnid[iColumnTableName];
	((JET_COLUMNLIST *)pv)->columnidBaseColumnName = rgcolumnid[iColumnColumnName];
 	((JET_COLUMNLIST *)pv)->columnidDefinitionName = rgcolumnid[iColumnName];

	return JET_errSuccess;

HandleError:
#if 0
	if ( pfucbMSC != pfucbNil )
		{
		CassS( ErrFILECloseTable( ppib, pfucbMSC ) );
		}
#endif
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );
	return err;
#else	/* !DISPATCHING */
	Assert( fFalse );
	return ErrERRCheck( JET_errFeatureNotAvailable );
#endif	/* !DISPATCHING */
	}


LOCAL ERR ErrInfoGetTableColumnInfo3( PIB *ppib,
	FUCB 			*pfucb,
	CHAR 			*szColumnName,
	VOID			*pv,
	unsigned long	cbMax )
	{
	ERR			err;
	ULONG		ulPgnoFDP = pfucb->u.pfcb->pgnoFDP;
	FUCB		*pfucbMSC = NULL;
#ifdef	DISPATCHING
	JET_TABLEID	tableid;
#endif	/* DISPATCHING */

	if ( szColumnName == NULL || cbMax < sizeof(JET_TABLEID) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	CallR( ErrFILEOpenTable( ppib, (DBID)pfucb->dbid, &pfucbMSC, szScTable, 0 ) );
	Call( ErrIsamSetCurrentIndex( ppib, pfucbMSC, szScObjectIdNameIndex ) );

	Call( ErrIsamMakeKey( ppib, pfucbMSC, (void *)&ulPgnoFDP, sizeof( ulPgnoFDP ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( ppib, pfucbMSC, szColumnName, strlen( szColumnName ), 0 ) );
	Call( ErrIsamSeek( ppib, pfucbMSC, JET_bitSeekEQ ) );
	FUCBSetSystemTable( pfucbMSC );

#ifdef	DISPATCHING
	Call( ErrAllocateTableid( &tableid, ( JET_VTID )pfucbMSC, &vtfndefIsamInfo ) );
	pfucbMSC->fVtid = fTrue;
	pfucbMSC->tableid = tableid;
	*(JET_TABLEID *)pv = tableid;
#else	/* !DISPATCHING */
	*( FUCB * *)pv = pfucbMSC;
#endif	/* !DISPATCHING */
	return JET_errSuccess;

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucbMSC ) );
	if ( err == JET_errRecordNotFound )
		err = ErrERRCheck( JET_errColumnNotFound );
	return err;
	}


LOCAL ERR ErrInfoGetTableColumnInfo4( PIB *ppib, FUCB *pfucb, CHAR *szColumnName, VOID *pv, unsigned long cbMax )
	{
	FID				fid;
	COLUMNDEF		columndef;

	if ( cbMax < sizeof(JET_COLUMNBASE) || szColumnName == NULL )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	fid = fidFixedLeast;
	INFOGetTableColumnInfo( pfucb, &fid, szColumnName, &columndef );
	if ( fid > fidTaggedMost )
		{
		return ErrERRCheck( JET_errColumnNotFound );
		}

	((JET_COLUMNBASE *)pv)->cbStruct		= sizeof(JET_COLUMNBASE);
	((JET_COLUMNBASE *)pv)->columnid		= columndef.columnid;
	((JET_COLUMNBASE *)pv)->coltyp		= columndef.coltyp;
	((JET_COLUMNBASE *)pv)->wFiller		= 0;
	((JET_COLUMNBASE *)pv)->cbMax			= columndef.cbMax;
	((JET_COLUMNBASE *)pv)->grbit			= columndef.grbit;
	strcpy( ( ( JET_COLUMNBASE *)pv )->szBaseTableName, pfucb->u.pfcb->szFileName );
	strcpy( ( ( JET_COLUMNBASE *)pv )->szBaseColumnName, szColumnName );
	((JET_COLUMNBASE *)pv)->wCountry		= columndef.wCountry;
	((JET_COLUMNBASE *)pv)->langid  		= columndef.langid;
	((JET_COLUMNBASE *)pv)->cp	   		= columndef.cp;

	return JET_errSuccess;
	}


/*=================================================================
ErrIsamGetIndexInfo

Description: Returns a temporary file containing index definition

Parameters:		ppib		   		pointer to PIB for the current session
				dbid		   		id of database containing the table
				szTableName	 		name of table owning the index
				szIndexName	 		index name
				pv					pointer to result buffer
				cbMax				size of result buffer
				lInfoLevel	 		level of information ( 0, 1, or 2 )

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VDBAPI
ErrIsamGetIndexInfo(
	JET_VSESID		vsesid,					/* pointer to PIB for current session */
	JET_DBID		vdbid, 	 				/* id of database containing table */
	const CHAR		*szTable, 				/* name of table owning the index */
	const CHAR		*szIndexName, 			/* index name */
	VOID			*pv,
	unsigned long	cbMax,
	unsigned long	lInfoLevel ) 			/* information level ( 0, 1, or 2 ) */
	{
	ERR				err;
	PIB				*ppib = (PIB *) vsesid;
	DBID			dbid;
	CHAR			szTableName[ ( JET_cbNameMost + 1 ) ];
	FUCB 			*pfucb;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	dbid = DbidOfVDbid( vdbid );
	CallR( ErrUTILCheckName( szTableName, szTable, ( JET_cbNameMost + 1 ) ) );

	CallR( ErrFILEOpenTable( ppib, dbid, &pfucb, szTableName, 0 ) );
	if ( lInfoLevel == 0 || lInfoLevel == 1 || FVDbidReadOnly( vdbid ) )
		FUCBResetUpdatable( pfucb );
	err = ErrIsamGetTableIndexInfo( (JET_VSESID) ppib, (JET_VTID) pfucb,
		szIndexName, pv, cbMax, lInfoLevel );

	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return err;
	}


/*=================================================================
ErrIsamGetTableIndexInfo

Description: Returns a temporary table containing the index definition

Parameters:		ppib		   		pointer to PIB for the current session
				pfucb		   		FUCB for table owning the index
				szIndexName			index name
				pv					pointer to result buffer
				cbMax				size of result buffer
				lInfoLevel			level of information

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VTAPI
ErrIsamGetTableIndexInfo(
	JET_VSESID		vsesid,					/* pointer to PIB for current session */
	JET_VTID		vtid, 					/* FUCB for the table owning the index */
	const CHAR		*szIndex, 				/* index name */
	void			*pb,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )			/* information level ( 0, 1, or 2 ) */
	{
	ERR			err;
	PIB			*ppib = (PIB *) vsesid;
	FUCB		*pfucb = (FUCB *) vtid;
	CHAR		szIndexName[ ( JET_cbNameMost + 1 ) ];

	/*	validate the arguments
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	if ( szIndex == NULL || *szIndex == '\0' )
		{
		*szIndexName = '\0';
		}
	else
		{
		CallR( ErrUTILCheckName( szIndexName, szIndex, ( JET_cbNameMost + 1 ) ) );
		}

	switch ( lInfoLevel )
		{
		case JET_IdxInfo:
		case JET_IdxInfoList:
		case JET_IdxInfoOLC:
			err = ErrInfoGetTableIndexInfo01( ppib, pfucb, szIndexName, pb, cbMax, lInfoLevel );
			break;
		case JET_IdxInfoSysTabCursor:
			err = ErrInfoGetTableIndexInfo2( ppib, pfucb, szIndexName, pb, cbMax );
			break;
		case JET_IdxInfoSpaceAlloc:
			Assert(cbMax == sizeof(ULONG));
			err = ErrCATGetIndexAllocInfo(ppib, pfucb->dbid,
				pfucb->u.pfcb->pgnoFDP, szIndexName, (ULONG *)pb);
			break;
		case JET_IdxInfoLangid:
			Assert(cbMax == sizeof(USHORT));
			err = ErrCATGetIndexLangid( ppib, pfucb->dbid,
				pfucb->u.pfcb->pgnoFDP, szIndexName, (USHORT *)pb );
			break;
		case JET_IdxInfoCount:
			{
			INT	cIndexes = 0;
			FCB	*pfcbT;

			for ( pfcbT = pfucb->u.pfcb; pfcbT != pfcbNil; pfcbT = pfcbT->pfcbNextIndex )
				{
				cIndexes++;
				}

			Assert( cbMax == sizeof(INT) );
			*( (INT *)pb ) = cIndexes;

			err = JET_errSuccess;
			break;
			}

		default:
			return ErrERRCheck( JET_errInvalidParameter );
		}

	return err;
	}


LOCAL ERR ErrInfoGetTableIndexInfo01( PIB *ppib,
	FUCB 			*pfucb,
	CHAR 			*szIndexName,
	VOID			*pv,
	unsigned long	cbMax,
	LONG 			lInfoLevel )
	{
#ifdef	DISPATCHING
	ERR		err;			   		/* return code from internal functions */
	FCB		*pfcb;			  		/* file control block for the index */
	IDB		*pidb;			  		/* current index control block */
	FDB		*pfdb;			  		/* field descriptor block for column */
	FID		fid;			   		/* column id */
	FIELD	*pfield;			  	/* pointer to current field definition */
	IDXSEG	*rgidxseg;				/* pointer to current index key defintion */
	BYTE	*szFieldName;			/* pointer to current field name */

	long	cRecord;	 			/* number of index entries */
	long	cKey;		 			/* number of unique index entries */
	long	cPage;					/* number of pages in the index */
	long	cRows;					/* number of index definition records */
	long	cColumn;	 			/* number of columns in current index */
	long	iidxseg;	 			/* segment number of current column */

	JET_TABLEID		tableid;  		/* table id for the VT */
	JET_COLUMNID	columnid;		/* column id of the current column */
	JET_GRBIT		grbit;			/* flags for the current index */
	JET_GRBIT		grbitColumn;	/* flags for the current column */
	JET_COLUMNID	rgcolumnid[ccolumndefGetIndexInfoMax];

	WORD			wCollate = JET_sortEFGPI;
	WORD			wT;
	LANGID			langidT;

	/*	return nothing if the buffer is too small
	/**/
	if ( cbMax < sizeof(JET_INDEXLIST) )
		return ErrERRCheck( JET_wrnBufferTruncated );

	/*	set the pointer to the field definitions for the table
	/**/
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;

	/*	locate the FCB for the specified index ( clustered index if null name )
	/**/
	for ( pfcb = pfucb->u.pfcb; pfcb != pfcbNil; pfcb = pfcb->pfcbNextIndex )
		if ( pfcb->pidb != pidbNil && ( *szIndexName == '\0' ||
			UtilCmpName( szIndexName, pfcb->pidb->szName ) == 0 ) )
			break;

	if ( pfcb == pfcbNil && *szIndexName != '\0' )
		return ErrERRCheck( JET_errIndexNotFound );

	/* if OLCStats info/reset, we can do it now
	/**/
	if ( lInfoLevel == JET_IdxInfoOLC )
		{
		if ( cbMax < sizeof(JET_OLCSTAT) )
			return ErrERRCheck( JET_errBufferTooSmall );
		memcpy( (BYTE *) pv, (BYTE * ) &pfcb->olc_data, sizeof(P_OLC_DATA) );
		( (JET_OLCSTAT *)pv )->cpgCompactFreed = pfcb->cpgCompactFreed;
		return JET_errSuccess;
		}
	if ( lInfoLevel == JET_IdxInfoResetOLC )
		{
		pfcb->cpgCompactFreed = 0;
		return JET_errSuccess;
		}
	
	/*	open the temporary table ( fills in the column ids in rgcolumndef )
	/**/
	CallR( ErrIsamOpenTempTable( (JET_SESID)ppib,
		(JET_COLUMNDEF *)rgcolumndefGetIndexInfo,
		ccolumndefGetIndexInfoMax,
		0,
		JET_bitTTScrollable,
		&tableid,
		rgcolumnid ) );

	cRows = 0;

	/*	as long as there is a valid index, add its definition to the VT
	/**/
	while ( pfcb != pfcbNil )
		{
		pidb 	= pfcb->pidb;			/* point to the IDB for the index */
		cColumn	= pidb->iidxsegMac;		/* get number of columns in the key */

		/*	set the index flags
		/**/
		grbit  = ( pfcb == pfucb->u.pfcb ) ? JET_bitIndexClustered: 0;
#ifndef JETSER
		grbit |= ( pidb->fidb & fidbPrimary ) ? JET_bitIndexPrimary: 0;
#endif
		grbit |= ( pidb->fidb & fidbUnique ) ? JET_bitIndexUnique: 0;
		grbit |= ( pidb->fidb & fidbNoNullSeg ) ? JET_bitIndexDisallowNull: 0;
		if ( !( pidb->fidb & fidbNoNullSeg ) )
			{
			grbit |= ( pidb->fidb & fidbAllowAllNulls ) ? 0: JET_bitIndexIgnoreNull;
			grbit |= ( pidb->fidb & fidbAllowFirstNull ) ? 0: JET_bitIndexIgnoreFirstNull;
			grbit |= ( pidb->fidb & fidbAllowSomeNulls ) ? 0: JET_bitIndexIgnoreAnyNull;
			}

		/*	process each column in the index key
		/**/
		for ( iidxseg = 0; iidxseg < cColumn; iidxseg++ )
			{
			Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid, JET_prepInsert ) );

			/* index name
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib,
				tableid,
				rgcolumnid[iIndexName],
				pidb->szName,
				strlen( pidb->szName ),
				0,
				NULL ) );

			/*	index flags
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexGrbit], &grbit, sizeof( grbit ), 0, NULL ) );

			/*	get statistics
			/**/
			Call( ErrSTATSRetrieveIndexStats( pfucb, pidb->szName,
				FFCBClusteredIndex(pfcb), &cRecord, &cKey, &cPage ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCKey], &cKey, sizeof( cKey ), 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCEntry], &cRecord, sizeof( cRecord ), 0, NULL ) );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCPage], &cPage, sizeof( cPage ), 0, NULL ) );

			/*	number of key columns
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCCol], &cColumn, sizeof( cColumn ), 0, NULL ) );

 			/*	column number within key
			/*	required by CLI and JET spec
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexICol], &iidxseg, sizeof( iidxseg ), 0, NULL ) );

			/*	get the column id and ascending/descending flag
			/**/
			rgidxseg = pidb->rgidxseg;
			if ( rgidxseg[iidxseg] < 0 )
				{
				grbitColumn = JET_bitKeyDescending;
				fid = -rgidxseg[iidxseg];
				}
			else
				{
				grbitColumn = JET_bitKeyAscending;
				fid = rgidxseg[iidxseg];
				}

			/*	column id
			/**/
			columnid  = fid;
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexColId], &columnid, sizeof( columnid ),
				0, NULL ) );

			/*	set the pointer to the column definition
			/**/
			if ( fid < fidFixedMost )
				{
				pfield = PfieldFDBFixed( pfdb ) + ( fid - fidFixedLeast );
				}
			else if ( fid < fidVarMost )
				{
				pfield = PfieldFDBVar( pfdb ) + ( fid - fidVarLeast );
				}
			else
				{
				pfield = PfieldFDBTagged( pfdb ) + ( fid - fidTaggedLeast );
				}

			/*	column type
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexColType], &pfield->coltyp, sizeof( pfield->coltyp ), 0, NULL ) );

			/*	Country
			/**/
			wT = countryDefault;
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCountry], &wT, sizeof( wT ), 0, NULL ) );

			/*	Langid
			/**/
			langidT = langidDefault;
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexLangid], &langidT, sizeof( langidT ), 0, NULL ) );

			/*	Cp
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCp], &pfield->cp, sizeof(pfield->cp), 0, NULL ) );

			/* Collate
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexCollate], &wCollate, sizeof(wCollate), 0, NULL ) );

			/* column flags
			/**/
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexColBits], &grbitColumn,
				sizeof( grbitColumn ), 0, NULL ) );

			/*	column name
			/**/
			szFieldName = SzMEMGetString( pfdb->rgb, pfield->itagFieldName );
			Call( ErrDispSetColumn( (JET_SESID)ppib, tableid,
				rgcolumnid[iIndexColName], szFieldName,
				strlen( szFieldName ), 0, NULL ) );

			Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL ) );

			/* count the number of VT rows
			/**/
			cRows++;
			}

		/*	quit if an index name was specified; otherwise do the next index
		/**/
		if ( *szIndexName != '\0' )
			break;
		else
			pfcb = pfcb->pfcbNextIndex;
		}

	/*	position to the first entry in the VT ( ignore error if no rows )
	/**/
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, 0 );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	/*	set up the return structure
	/**/
	((JET_INDEXLIST *)pv)->cbStruct = sizeof(JET_INDEXLIST);
	((JET_INDEXLIST *)pv)->tableid = tableid;
	((JET_INDEXLIST *)pv)->cRecord = cRows;
	((JET_INDEXLIST *)pv)->columnidindexname = rgcolumnid[iIndexName];
	((JET_INDEXLIST *)pv)->columnidgrbitIndex = rgcolumnid[iIndexGrbit];
	((JET_INDEXLIST *)pv)->columnidcEntry = rgcolumnid[iIndexCEntry];
	((JET_INDEXLIST *)pv)->columnidcKey = rgcolumnid[iIndexCKey];
	((JET_INDEXLIST *)pv)->columnidcPage = rgcolumnid[iIndexCPage];
	((JET_INDEXLIST *)pv)->columnidcColumn = rgcolumnid[iIndexCCol];
	((JET_INDEXLIST *)pv)->columnidiColumn = rgcolumnid[iIndexICol];
	((JET_INDEXLIST *)pv)->columnidcolumnid = rgcolumnid[iIndexColId];
	((JET_INDEXLIST *)pv)->columnidcoltyp = rgcolumnid[iIndexColType];
	((JET_INDEXLIST *)pv)->columnidCountry = rgcolumnid[iIndexCountry];
	((JET_INDEXLIST *)pv)->columnidLangid = rgcolumnid[iIndexLangid];
	((JET_INDEXLIST *)pv)->columnidCp = rgcolumnid[iIndexCp];
	((JET_INDEXLIST *)pv)->columnidCollate = rgcolumnid[iIndexCollate];
	((JET_INDEXLIST *)pv)->columnidgrbitColumn = rgcolumnid[iIndexColBits];
	((JET_INDEXLIST *)pv)->columnidcolumnname = rgcolumnid[iIndexColName];

	return JET_errSuccess;

HandleError:
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );
	return err;
#else	/* !DISPATCHING */
	Assert( fFalse );
	return ErrERRCheck( JET_errFeatureNotAvailable );
#endif	/* !DISPATCHING */
	}


LOCAL ERR ErrInfoGetTableIndexInfo2( PIB *ppib, FUCB *pfucb, CHAR *szIndexName, VOID *pv, unsigned long cbMax )
	{
	ERR			err;
	ULONG  		ulPgnoFDP = pfucb->u.pfcb->pgnoFDP;
	FUCB   		*pfucbMSI = NULL;
#ifdef	DISPATCHING
	JET_TABLEID	tableid;
#endif	/* DISPATCHING */

	if ( *szIndexName == '\0' || cbMax < sizeof(JET_TABLEID) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	CallR( ErrFILEOpenTable( ppib, (DBID)pfucb->dbid, &pfucbMSI, szSiTable, 0 ) );
	Call( ErrIsamSetCurrentIndex( ppib, pfucbMSI, szSiObjectIdNameIndex ) );

	Call( ErrIsamMakeKey( ppib, pfucbMSI, (void *)&ulPgnoFDP, sizeof( ulPgnoFDP ), JET_bitNewKey ) );
	Call( ErrIsamMakeKey( ppib, pfucbMSI, szIndexName, strlen( szIndexName ), 0 ) );
	Call( ErrIsamSeek( ppib, pfucbMSI, JET_bitSeekEQ ) );

	FUCBSetSystemTable( pfucbMSI );

#ifdef	DISPATCHING
	Call( ErrAllocateTableid( &tableid, ( JET_VTID )pfucbMSI, &vtfndefIsamInfo ) );
	pfucbMSI->fVtid = fTrue;
	pfucbMSI->tableid = tableid;
	*(JET_TABLEID *)pv = tableid;
#else	/* !DISPATCHING */
	*(FUCB **)pv = pfucbMSI;
#endif	/* !DISPATCHING */

	return JET_errSuccess;

HandleError:
	if ( err == JET_errRecordNotFound )
		err = ErrERRCheck( JET_errIndexNotFound );
	CallS( ErrFILECloseTable( ppib, pfucbMSI ) );
	return err;
	}


ERR VDBAPI ErrIsamGetDatabaseInfo(
	JET_VSESID		vsesid,
	JET_DBID	  	vdbid,
	void 		  	*pv,
	unsigned long	cbMax,
	unsigned long	ulInfoLevel )
	{
	PIB				*ppib = (PIB *) vsesid;
	ERR				err;
	DBID			dbid;
	//	UNDONE:	support these fields;
	WORD 			cp			= usEnglishCodePage;
	WORD			wCountry	= countryDefault;
	LANGID			langid  	= langidDefault;
	WORD			wCollate = JET_sortEFGPI;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrDABCheck( ppib, (DAB *)vdbid ) );
	dbid = DbidOfVDbid( vdbid );
	
	Assert ( cbMax == 0 || pv != NULL );

	//	UNDONE:	move access to FMP internals into io.c for proper MUTEX.
	//			Please note that below is a bug.

	/*	returns database name and connect string given dbid
	/**/
	if ( rgfmp[dbid].szDatabaseName == NULL )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		goto HandleError;
		}

	switch ( ulInfoLevel )
		{
		case JET_DbInfoFilename:
			if ( strlen( rgfmp[dbid].szDatabaseName ) + 1UL > cbMax )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			strcpy( (CHAR  *)pv, rgfmp[dbid].szDatabaseName );
			break;

		case JET_DbInfoConnect:
			if ( 1UL > cbMax )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			*(CHAR *)pv = '\0';
			break;

		case JET_DbInfoCountry:
			 if ( cbMax != sizeof(long) )
			    return ErrERRCheck( JET_errInvalidBufferSize );
			*(long  *)pv = wCountry;
			break;

		case JET_DbInfoLangid:
			if ( cbMax != sizeof(long) )
	  			return ErrERRCheck( JET_errInvalidBufferSize );
			*(long  *)pv = langid;
			break;

		case JET_DbInfoCp:
			if ( cbMax != sizeof(long) )
				return ErrERRCheck( JET_errInvalidBufferSize );
			*(long  *)pv = cp;
			break;

		case JET_DbInfoCollate:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(long) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );
     		*(long *)pv = wCollate;
     		break;

		case JET_DbInfoOptions:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(JET_GRBIT) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );

			/*	return the open options for the current database
			/**/
			*(JET_GRBIT *)pv = ((VDBID)vdbid)->grbit;
     		break;

		case JET_DbInfoTransactions:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(long) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );

			*(long*)pv = levelUserMost;
     		break;

		case JET_DbInfoVersion:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(long) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );

			*(long *)pv = JET_DbVersion20;
     		break;

		case JET_DbInfoIsam:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(long) + sizeof(long) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );
     		*(long *)pv = JET_IsamBuiltinBlue;
     		*( (long *)pv + 1 ) = JET_bitFourByteBookmark;
     		break;

		case JET_DbInfoFilesize:
		case JET_DbInfoSpaceOwned:
			// Return file size in terms of 4k pages.
			if ( cbMax != sizeof(ULONG) )
				return ErrERRCheck( JET_errInvalidBufferSize );

			// FMP should store agree with database's OwnExt tree.
			Assert( ErrSPGetInfo( ppib, dbid, pfucbNil, pv, cbMax, fSPOwnedExtent ) == JET_errSuccess  &&
				*(ULONG *)pv == ( rgfmp[dbid].ulFileSizeLow >> 12 ) + ( rgfmp[dbid].ulFileSizeHigh << 20 ) );

			// If filesize, add DB header.
			*(ULONG *)pv =
				( rgfmp[dbid].ulFileSizeLow >> 12 ) +
				( rgfmp[dbid].ulFileSizeHigh << 20 ) +
				( ulInfoLevel == JET_DbInfoFilesize ? cpageDBReserved : 0 );
			break;

		case JET_DbInfoSpaceAvailable:
			err = ErrSPGetInfo( ppib, dbid, pfucbNil, pv, cbMax, fSPAvailExtent );
			return err;

		default:
			 return ErrERRCheck( JET_errInvalidParameter );
		}

	err = JET_errSuccess;
HandleError:
	return err;
	}


ERR VTAPI ErrIsamGetSysTableColumnInfo(
	PIB 			*ppib,
	FUCB 			*pfucb,
	CHAR 			*szColumnName,
	VOID			*pv,
	unsigned long	cbMax,
	long 			lInfoLevel )
	{
	ERR				err;

	if ( lInfoLevel > 0 )
		return ErrERRCheck( JET_errInvalidParameter );
	err = ErrIsamGetTableColumnInfo( (JET_VSESID) ppib,
		(JET_VTID) pfucb, szColumnName, pv, cbMax, lInfoLevel );
	return err;
	}


ERR ErrFILEGetColumnId( PIB *ppib, FUCB *pfucb, const CHAR *szColumn, JET_COLUMNID *pcolumnid )
	{
	FDB		*pfdb;
	FIELD	*pfield;
	FIELD	*pfieldFixed, *pfieldVar, *pfieldTagged;

	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfucb->u.pfcb->pfdb != pfdbNil );
	Assert( pcolumnid != NULL );

	pfdb = (FDB *)pfucb->u.pfcb->pfdb;

	pfieldFixed = PfieldFDBFixed( pfdb );
	pfieldVar = PfieldFDBVarFromFixed( pfdb, pfieldFixed );
	pfieldTagged = PfieldFDBTaggedFromVar( pfdb, pfieldVar );
	pfield = pfieldTagged + ( pfdb->fidTaggedLast - fidTaggedLeast );

	// Search tagged, variable, and fixed fields, in that order.
	for ( ; pfield >= pfieldFixed; pfield-- )
		{
		Assert( pfield >= PfieldFDBFixed( pfdb ) );
		Assert( pfield <= PfieldFDBTagged( pfdb ) + ( pfdb->fidTaggedLast - fidTaggedLeast ) );
		if ( pfield->coltyp != JET_coltypNil  &&
			UtilCmpName( SzMEMGetString( pfdb->rgb, pfield->itagFieldName ), szColumn ) == 0 )
			{
			if ( pfield >= pfieldTagged )
				*pcolumnid = (JET_COLUMNID)( pfield - pfieldTagged ) + fidTaggedLeast;
			else if ( pfield >= pfieldVar )
				*pcolumnid = (JET_COLUMNID)( pfield - pfieldVar ) + fidVarLeast;
			else
				{
				Assert( pfield >= pfieldFixed );
				*pcolumnid = (JET_COLUMNID)( pfield - pfieldFixed ) + fidFixedLeast;
				}
			return JET_errSuccess;
			}
		}

	return ErrERRCheck( JET_errColumnNotFound );
	}


ERR VTAPI ErrIsamInfoRetrieveColumn(
	PIB				*ppib,
	FUCB		   	*pfucb,
	JET_COLUMNID	columnid,
	BYTE		   	*pb,
	unsigned long	cbMax,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo )
	{
	ERR				err;

	err = ErrIsamRetrieveColumn( ppib, pfucb, columnid, pb, cbMax, pcbActual, grbit, pretinfo );
	return err;
	}


ERR VTAPI ErrIsamInfoSetColumn(
	PIB				*ppib,
	FUCB			*pfucb,
	JET_COLUMNID	columnid,
	const void		*pbData,
	unsigned long	cbData,
	JET_GRBIT		grbit,
	JET_SETINFO		*psetinfo )
	{
	ERR				err;

	/*	check table updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb ) );

	err = ErrIsamSetColumn( ppib, pfucb, columnid, (BYTE *)pbData, cbData, grbit, psetinfo );
	return err;
	}


ERR VTAPI ErrIsamInfoUpdate(
	JET_VSESID		vsesid,
	JET_VTID 		vtid,
	void	 		*pb,
	unsigned long 	cbMax,
	unsigned long 	*pcbActual )
	{
	ERR	err;

	/*	ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( (FUCB *) vtid ) );

	err = ErrIsamUpdate( (PIB *) vsesid, (FUCB *) vtid, pb, cbMax, pcbActual );
	return err;
	}


ERR VTAPI ErrIsamGetCursorInfo(
	JET_VSESID 		vsesid,
	JET_VTID   		vtid,
	void 	   		*pvResult,
	unsigned long 	cbMax,
	unsigned long 	InfoLevel )
	{
	PIB		*ppib = (PIB *) vsesid;
	FUCB	*pfucb = (FUCB *) vtid;
	ERR		err = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );
	VS		vs;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( pfucb->ppib, pfucb );

	if ( cbMax != 0 || InfoLevel != 0 )
		return ErrERRCheck( JET_errInvalidParameter );

	if ( pcsr->csrstat != csrstatOnCurNode )
		return ErrERRCheck( JET_errNoCurrentRecord );

	/*	check if this record is being updated by another cursor
	/**/
	Call( ErrDIRGet( pfucb ) );
	if ( FNDVersion( *( pfucb->ssib.line.pb ) ) )
		{
		SRID	srid;
		NDGetBookmark( pfucb, &srid );
		vs = VsVERCheck( pfucb, srid );
		if ( vs == vsUncommittedByOther )
			{
			return ErrERRCheck( JET_errSessionWriteConflict );
			}
		}

	/*	temporary tables are never visible to other sessions
	/**/
	if ( FFCBTemporaryTable( pfucb->u.pfcb ) )
		return JET_errSuccess;

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\fucb.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */


static CSR csrTemplate =
	{
	qwDBTimeMin,			// page time stamp
	sridNull,				// bmRefresh
	pgnoNull,				// pgno of node page
	sridNull,				//	bookmark of node
	sridNull,				// item
	csrstatBeforeFirst,		// status of csr relative to node
	itagNull,				// node itag
	isridNull,				// index of item in item list
	itagNull,	  			// itag of father
	ibSonNull,				// index of son in father son table
	NULL,					// parent currency
	};


ERR ErrFUCBAllocCSR( CSR **ppcsr )
	{
	CSR *pcsr;

	pcsr = PcsrMEMAlloc( );
	if ( !pcsr )
		return ErrERRCheck( JET_errCurrencyStackOutOfMemory );

	*pcsr = csrTemplate;

	Assert(	pcsr->csrstat == csrstatBeforeFirst );
	Assert(	pcsr->pgno == pgnoNull );
	Assert(	pcsr->itag == itagNull );
	Assert(	pcsr->itagFather == itagNull );
	Assert(	pcsr->ibSon	== ibSonNull );
	Assert(	pcsr->isrid	== isridNull );
	Assert(	pcsr->pcsrPath == NULL );
	Assert( pcsr->bmRefresh == sridNull );

	*ppcsr = pcsr;
	return JET_errSuccess;
	}


//+api
//	ErrFUCBNewCSR
//	========================================================================
//	ERR ErrFUCBNewCSR( FUCB *pfucb )
//	
//	Insert a null csr in the bottom of path of pfucb.
//
//	PARAMETERS	pfucb
//
//	RETURNS		JET_errOutOfMemory
//-
ERR ErrFUCBNewCSR( FUCB *pfucb )
	{
	ERR err;
	CSR **ppcsr;
	CSR *pcsr;

	CallR( ErrFUCBAllocCSR( &pcsr ) );

	ppcsr = &PcsrCurrent( pfucb );
	pcsr->pcsrPath = *ppcsr;
	*ppcsr = pcsr;

	return JET_errSuccess;
	}


//+api
//	FUCBFreeCSR
//	========================================================================
//	VOID FUCBFreeCSR( FUCB *pfucb )
//
//	Delete the csr in the bottom of path of pfucb.
//
//	PARAMETERS	pfucb
//	RETURNS		JET_errOutOfMemory
//-
VOID FUCBFreeCSR( FUCB *pfucb )
	{
	CSR **ppcsr = &PcsrCurrent( pfucb );
	CSR *pcsr;

	*ppcsr = ( pcsr = *ppcsr )->pcsrPath;
	MEMReleasePcsr( pcsr );
	return;
	}


//+api
//	FUCBFreePath
//	========================================================================
//	VOID FUCBFreePath( CSR **ppcsr, CSR *pcsrMark )
//
//	Delete all the csr in the current path of pfucb.
//
//	PARAMETERS	pfucb
//
//	RETURNS		JET_errOutOfMemory
//-
VOID FUCBFreePath( CSR **ppcsr, CSR *pcsrMark )
	{
	while ( *ppcsr != pcsrMark )
		{
		CSR *pcsrTmp = *ppcsr;
		Assert( pcsrTmp != pcsrNil );
		*ppcsr = pcsrTmp->pcsrPath;
		MEMReleasePcsr( pcsrTmp );
		}
	return;
	}



//+api
//	ErrFUCBOpen
//	------------------------------------------------------------------------
//	ERR ErrFUCBOpen( PIB *ppib, DBID dbid, FUCB **ppfucb );
//
//	Creates an open FUCB. At this point, no FCB is assigned yet.
//
//	PARAMETERS	ppib	PIB of this user
//				dbid	Database Id.
//				ppfucb	Address of pointer to FUCB.	 If *ppfucb == NULL, 
//						an FUCB is allocated and **ppfucb is set to its
//						address.  Otherwise, *ppfucb is assumed to be
//						pointing at a closed FUCB, to be reused in the open.
//
//	RETURNS		JET_errSuccess if successful.
//					JET_errOutOfCursors
//					ErrFUCBNewCSR: JET_errOutOfMemory.
//
//	SIDE EFFECTS	links the newly opened FUCB into the chain of open FUCBs
//					for this session.
//
//	SEE ALSO		ErrFUCBClose
//-
ERR ErrFUCBOpen( PIB *ppib, DBID dbid, FUCB **ppfucb ) 
	{
	ERR err;
	FUCB *pfucb;
	
	/*	if no fucb allocate new fucb and initialize it
	/*	and allocate csr
	/*	pib must be set before call to NewCSR
	/**/

	pfucb = PfucbMEMAlloc( );
	if ( pfucb == pfucbNil )
		{
		err = ErrERRCheck( JET_errOutOfCursors );
		return err;
		}
	/*	memset implicitly clears pointer cache
	/**/
	//Assert( pfucb->pfucbNext == (FUCB *)0xffffffff );
	memset( (BYTE *)pfucb, '\0', sizeof( FUCB ) );

	pfucb->tableid = JET_tableidNil;

	if ( FDBIDReadOnly( dbid ) )
		FUCBResetUpdatable( pfucb );
	else
		FUCBSetUpdatable( pfucb );

	pfucb->dbid = dbid;
	SSIBSetDbid( &pfucb->ssib, dbid );
	pfucb->ssib.pbf = pbfNil;
	pfucb->pbfEmpty = pbfNil;

	// set ppib before set NewCSR
	pfucb->ppib = ppib;
	pfucb->ssib.ppib = ppib;

	/* allocate a CSR for this fucb
	/**/
	Call( ErrFUCBNewCSR( pfucb ) );
	pfucb->levelOpen = ppib->level;

	/*	link new FUCB into user chain, only when success is sure
	/*	as unlinking NOT handled in error
	/**/
	if ( *ppfucb == pfucbNil )
		{
		*ppfucb = pfucb;
		// link the fucb now
		pfucb->pfucbNext = ( FUCB * )ppib->pfucb;
		ppib->pfucb = pfucb;
		return JET_errSuccess;
		}

	pfucb->pfucbCurIndex = pfucbNil;
	return JET_errSuccess;

HandleError:
	MEMReleasePfucb( pfucb );
	return err;
	}


//+api
//	FUCBClose
//	------------------------------------------------------------------------
//	FUCBClose( FUCB *pfucb )
//
//	Closes an active FUCB, optionally returning it to the free FUCB pool.
//	All the pfucb->pcsr are freed.
//
//	PARAMETERS		pfucb		FUCB to close.	Should be open. pfucb->ssib should
//									hold no page.
//
//	SIDE EFFECTS	Unlinks the closed FUCB from the FUCB chain of its
//					   associated PIB and FCB.
//
//	SEE ALSO		ErrFUCBOpen
//-
VOID FUCBClose( FUCB *pfucb )
	{
	FUCB		*pfucbPrev;

	FUCBFreePath( &PcsrCurrent( pfucb ), pcsrNil );

	/*	locate the pfucb in this thread and take it out of the fucb list
	/**/
	pfucbPrev = (FUCB *)( (BYTE *)&pfucb->ppib->pfucb - (BYTE *)&( (FUCB *)0 )->pfucbNext );
	while ( pfucbPrev->pfucbNext != pfucb )
		{
		pfucbPrev = pfucbPrev->pfucbNext;
		Assert( pfucbPrev != pfucbNil );
		}
	pfucbPrev->pfucbNext = pfucb->pfucbNext;

	/*	set ppibNil to detect bogus reusage.
	/**/
	#ifdef DEBUG
		pfucb->ppib = ppibNil;
	#endif

	/*	release key buffer if one was allocated.
	/**/
	if ( pfucb->pbKey != NULL )
		{
		LFree( pfucb->pbKey );
		pfucb->pbKey = NULL;
		}

	Assert( pfucb->pbfEmpty == pbfNil );
	Assert( pfucb->tableid == JET_tableidNil );

	/* release the fucb
	/**/
	MEMReleasePfucb( pfucb );
	return;
	}


VOID FUCBRemoveInvisible( CSR **ppcsr )
	{
	CSR	*pcsr;
	CSR	*pcsrPrev;
	
	Assert( ppcsr && *ppcsr );
	
	if ( (*ppcsr)->itag == itagNil)
		{
		CSR *pcsrT = *ppcsr;
		*ppcsr = (*ppcsr)->pcsrPath;
		MEMReleasePcsr( pcsrT );
		}

	pcsrPrev = *ppcsr;
	pcsr = pcsrPrev->pcsrPath;
	
	while ( pcsr )
		{
		if ( FCSRInvisible( pcsr ) )
			{
			CSR *pcsrT = pcsrPrev->pcsrPath;
			pcsr = pcsrPrev->pcsrPath = pcsr->pcsrPath;
			MEMReleasePcsr( pcsrT );
			}
		else
			{
			Assert( pcsr->itag != itagNil );
			pcsrPrev = pcsr;
			pcsr = pcsr->pcsrPath;
			}
		}

	return;
	}
	

VOID FUCBSetIndexRange( FUCB *pfucb, JET_GRBIT grbit )
	{
	/*	set limstat
	/**/
	FUCBSetLimstat( pfucb );
	if ( grbit & JET_bitRangeUpperLimit )
		{
		FUCBSetUpper( pfucb );
		}
	else
		{
		FUCBResetUpper( pfucb );
		}
	if ( grbit & JET_bitRangeInclusive )
		{
		FUCBSetInclusive( pfucb );
		}
	else
		{
		FUCBResetInclusive( pfucb );
		}

	return;
	}


VOID FUCBResetIndexRange( FUCB *pfucb )
	{
	if ( pfucb->pfucbCurIndex )
		{
		FUCBResetLimstat( pfucb->pfucbCurIndex );
		}

	FUCBResetLimstat( pfucb );
	}


ERR ErrFUCBCheckIndexRange( FUCB *pfucb )
	{
	ERR	err = JET_errSuccess;
	KEY	keyLimit;
	INT	cmp;

	Assert( pfucb->cbKey > 0 );
	keyLimit.pb = pfucb->pbKey + 1;
	keyLimit.cb = pfucb->cbKey - 1;
	cmp = CmpPartialKeyKey( &pfucb->keyNode, &keyLimit );

	if ( FFUCBUpper( pfucb ) )
		{
		if ( FFUCBInclusive( pfucb ) && cmp > 0 || !FFUCBInclusive( pfucb ) && cmp >= 0 )
			{
			PcsrCurrent( pfucb )->csrstat = csrstatAfterLast;
			FUCBResetLimstat( pfucb );
			err = ErrERRCheck( JET_errNoCurrentRecord );
			}
		}
	else
		{
		if ( FFUCBInclusive( pfucb ) && cmp < 0 || !FFUCBInclusive( pfucb ) && cmp <= 0 )
			{
			PcsrCurrent( pfucb )->csrstat = csrstatBeforeFirst;
			FUCBResetLimstat( pfucb );
			err = ErrERRCheck( JET_errNoCurrentRecord );
			}
		}

	return err;
	}

INT CmpPartialKeyKey( KEY *pkey1, KEY *pkey2 )
	{
	INT		cmp;

	if ( FKeyNull( pkey1 ) || FKeyNull( pkey2 ) )
		{
		if ( FKeyNull( pkey1 ) && !FKeyNull( pkey2 ) )
			cmp = -1;
		else if ( !FKeyNull( pkey1 ) && FKeyNull( pkey2 ) )
			cmp = 1;
		else
			cmp = 0;
		}
	else
		{
		cmp = memcmp( pkey1->pb, pkey2->pb, pkey1->cb < pkey2->cb ? pkey1->cb : pkey2->cb );
		}

	return cmp;
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\fldmod.c ===
#include "daestd.h"
#include "malloc.h"


DeclAssertFile; 				/* Declare file name for assert macros */

ERR ErrRECSetColumn( FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField );

/* structure used for passing parameters between
/* ErrIsamRetrieveColumns and ErrRECIRetrieveMany */
/**/
typedef	struct colinfo {
		LINE		lineField;
		FID			fid;
		} COLINFO;


ERR ErrRECISetAutoIncrement( FUCB *pfucb )
	{
	ERR		err;
	FUCB	*pfucbT = pfucbNil;
	LINE	line;
	ULONG	ulAutoIncrement;
	BOOL	fCommit = fFalse;
	PIB		*ppib = pfucb->ppib;
	DIB		dib;

	/*	the operation is redo only. no version needed.
	/*	If necessary, start a transaction such that the redo
	/*	would not ignore the operation.
	/**/
	if ( ppib->level == 0 || !FPIBAggregateTransaction( ppib )  )
		{
		CallR( ErrDIRBeginTransaction( ppib ) );
		fCommit = fTrue;
		}

	Call( ErrDIROpen( ppib, pfucb->u.pfcb, 0, &pfucbT ) );
	Assert( pfucbT != pfucbNil );
	FUCBSetIndex( pfucbT );

	/*	the autoinc column is not set to a value, so we use the value
	/*	stored in the AutoInc node, a son of the FDP
	/*	go down to AutoInc node
	/**/
	DIRGotoFDPRoot( pfucbT );
	dib.fFlags = fDIRNull;
	dib.pos = posDown;
	dib.pkey = pkeyAutoInc;
	err = ErrDIRDown( pfucbT, &dib );
	if ( err != JET_errSuccess )
		{
		if ( err > 0 )
			{
			DIRUp( pfucbT, 1 );
			err = ErrERRCheck( JET_errDatabaseCorrupted );
			}
		goto HandleError;
		}
	Call( ErrDIRGet( pfucbT ) );
	Assert( pfucbT->lineData.cb == sizeof(ulAutoIncrement) );
	ulAutoIncrement = *(ULONG UNALIGNED *)pfucbT->lineData.pb;
	Assert( ulAutoIncrement > 0 );
	line.pb = (BYTE *)&ulAutoIncrement;
	line.cb = sizeof(ulAutoIncrement);

	/*	increment ulAutoIncrement in table BEFORE accessing
	/*	any other page.  This is to prevent loss of context
	/*	which could result in duplicate autoinc usage.
	/**/
	++ulAutoIncrement;
	Call( ErrDIRReplace( pfucbT, &line, fDIRNoVersion ) );
	
	/*	set auto increment column in record.  Must decrement
	/*	the cached table auto increment to the value first found.
	/**/
	--ulAutoIncrement;
	err = ErrRECSetColumn( pfucb, pfucb->u.pfcb->pfdb->fidAutoInc, 0, &line );

HandleError:
	if ( pfucbT != pfucbNil )
		{
		DIRClose( pfucbT );
		}

	/*	always commit to log a symetric commit for begin transaction.
	/**/
	if ( fCommit )
		{
		if ( err >= JET_errSuccess )
			err = ErrDIRCommitTransaction( ppib, 0 );
		if ( err < 0 )
			CallS( ErrDIRRollback( ppib ) );
		}

	Assert( err < 0 || FFUCBColumnSet( pfucb, pfucb->u.pfcb->pfdb->fidAutoInc ) );
	return err;
	}


#ifdef DEBUG
ERR ErrRECICheckWriteConflict( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppibT = pfucb->ppib;
	FUCB	*pfucbT = pfucb;
	
	for ( pfucbT = ppibT->pfucb; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNext )
		{
		if ( pfucbT->dbid == pfucb->dbid &&
			FFUCBReplacePrepared( pfucbT ) &&
			PcsrCurrent( pfucbT )->bm == PcsrCurrent(pfucb)->bm &&
			pfucbT != pfucb )
			{
			return ErrERRCheck( JET_errSessionWriteConflict );
			}
		}

	return err;
	}
#endif


ERR VTAPI ErrIsamPrepareUpdate( PIB *ppib, FUCB *pfucb, ULONG grbit )
	{
	ERR		err = JET_errSuccess;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	Assert( ppib->level < levelMax );
	Assert( PcsrCurrent( pfucb ) != pcsrNil );

	/*	ensure that table is updatable
	/**/
	CallR( FUCBCheckUpdatable( pfucb )  );

	/*	allocate working buffer if needed
	/**/
	if ( pfucb->pbfWorkBuf == pbfNil )
		{
		Call( ErrBFAllocTempBuffer( &pfucb->pbfWorkBuf ) );
		pfucb->lineWorkBuf.pb = (BYTE*)pfucb->pbfWorkBuf->ppage;
		}

	switch ( grbit )
		{
		case JET_prepCancel:
			if ( !FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errUpdateNotPrepared );

			if ( FFUCBUpdateSeparateLV( pfucb ) )
				{
				/*	cannot execute this code due to behavior of
				/*	copy buffer, whose transaction semantics do NOT
				/*	match version store.  Lose space on cancel
				/*	until rollback transaction frees space via version
				/*	store.  Fix by implementing nested transactions
				/*	in version store.
				/**/
#if 0
				/*	if copy buffer was prepared for replacement
				/*	then cache the record and write latch the
				/*	buffer, to prevent overlay during long value
				/*	deletion.
				/**/
				if ( FFUCBReplacePrepared( pfucb ) )
					{
					err = ErrDIRGet( pfucb );
				
					/*	wait and retry while write latch conflict
					/**/
#ifdef DEBUG
					if ( err >= 0 )
	 					AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
#endif  // DEBUG
	 				while( err >= JET_errSuccess &&
	 					FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
						{
						BFSleep( cmsecWaitWriteLatch );
						err = ErrDIRGet( pfucb );
#ifdef DEBUG
						if ( err >= 0 )
		 					AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
#endif  // DEBUG
						}

					if ( err >= JET_errSuccess )
						{
						(VOID)ErrRECAffectLongFields( pfucb, &pfucb->lineWorkBuf, fDereferenceAdded );
						/*	ignore error code
						/**/
						}
					/*	ignore error code
					/**/
					err = JET_errSuccess;
					}
				else
					{
					Assert( FFUCBInsertPrepared( pfucb ) );
					(VOID)ErrRECAffectLongFields( pfucb, &pfucb->lineWorkBuf, fDereferenceAdded );
					/*	ignore error code
					/**/
					}
#endif

				FUCBResetUpdateSeparateLV( pfucb );
				
				}

			// Ensure empty LV buffer.  Don't put this check inside the
			// FFUCBUpdateSeparateLV() check above because we may have created
			// a copy buffer, but cancelled the SetColumn() (eg. write conflict)
			// before the LV was actually updated (before FUCBSetUpdateSeparateLV()
			// could be called).
			FLDFreeLVBuf( pfucb );

			/*	this is an instrument to catch any lv sets that
			/*	are cancelled and committed.
			/**/
#ifdef CHECK_ROLLBACK_UPDATE_CANCEL
			/*	flag cursor as having updated a separate LV
			/**/
			if ( FUCBSetUpdateSeparateLV( pfucb ) )
				{
				PIBSetLevelRollback( pfucb->ppib, pfucb->ppib->level );
				}
#endif

			FUCBResetDeferredChecksum( pfucb );
			Assert( !FFUCBUpdateSeparateLV( pfucb ) );
			FUCBResetCbstat( pfucb );
			err = JET_errSuccess;
			break;

		case JET_prepInsert:
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );
			Assert( pfucb->pbfWorkBuf != pbfNil );

			/*	initialize record
			/**/
			Assert( pfucb != pfucbNil );
			Assert( pfucb->lineWorkBuf.pb != NULL );
			Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );

			if ( !FLineNull( (LINE *) &pfucb->u.pfcb->pfdb->lineDefaultRecord ) )
				{
				Assert( pfucb->u.pfcb != pfcbNil );
				Assert( pfucb->u.pfcb->pfdb->lineDefaultRecord.cb >= cbRECRecordMin );

				// Temporary tables and system tables don't have default records.
				Assert( !( FFUCBSort( pfucb )  ||
					FFCBTemporaryTable( pfucb->u.pfcb )  ||
					FFCBSystemTable( pfucb->u.pfcb ) ) );
			
				// Only burst fixed and variable column defaults.
				pfucb->lineWorkBuf.cb =
					ibTaggedOffset( pfucb->u.pfcb->pfdb->lineDefaultRecord.pb,
						PibFDBFixedOffsets( pfucb->u.pfcb->pfdb ) );
				Assert( pfucb->lineWorkBuf.cb >= cbRECRecordMin );
				Assert( pfucb->lineWorkBuf.cb <= pfucb->u.pfcb->pfdb->lineDefaultRecord.cb );
				memcpy( pfucb->lineWorkBuf.pb,
					pfucb->u.pfcb->pfdb->lineDefaultRecord.pb,
					pfucb->lineWorkBuf.cb );
				}
			else
				{
				RECHDR *prechdr;
	   	
				// Only temporary tables and system tables don't have default records
				// (ie. all "regular" tables have at least a minimal default record).
				Assert( FFUCBSort( pfucb )  ||
					FFCBTemporaryTable( pfucb->u.pfcb )  ||
					FFCBSystemTable( pfucb->u.pfcb ) );
			
				prechdr = (RECHDR*)pfucb->lineWorkBuf.pb;
				prechdr->fidFixedLastInRec = (BYTE)(fidFixedLeast-1);
				prechdr->fidVarLastInRec = (BYTE)(fidVarLeast-1);
				*(WORD *)(prechdr+1) = (WORD) pfucb->lineWorkBuf.cb = cbRECRecordMin;
				}

			FUCBResetColumnSet( pfucb );
			PrepareInsert( pfucb );

			/*	if table has an autoincrement column, then set column
			/*	value now so that it can be retrieved from copy buffer.
			/**/
			if ( pfucb->u.pfcb->pfdb->fidAutoInc != 0 )
				{
				Call( ErrRECISetAutoIncrement( pfucb ) );
				}
			err = JET_errSuccess;
			break;

		case JET_prepReplace:
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );

#ifdef DEBUG
			/*	put assert to catch client's misbehavior. Make sure that
			 *	no such sequence:
			 *		PrepUpdate(t1) PrepUpdate(t2) Update(t1) Update(t2)
			 *	where t1 and t2 happen to be on the same record and on the
			 *	the same table. Client will experience lost update of t1 if
			 *	they have such calling sequence.
			 */
			Assert( ErrRECICheckWriteConflict( pfucb ) == JET_errSuccess );
#endif

			/*	write lock node.  Note that ErrDIRGetWriteLock also
			/*	gets the current node, so no additional call to ErrDIRGet
			/*	is required.
			/**/
			/*	if locking at level 0 then goto JET_prepReplaceNoLock
			/*	since lock cannot be acquired at level 0 and lock flag
			/*	in fucb will prevent locking in update operation required
			/*	for rollback.
			/**/
			if ( pfucb->ppib->level == 0 )
				goto ReplaceNoLock;

			Call( ErrDIRGetWriteLock( pfucb ) );
			Assert( pfucb->pbfWorkBuf != pbfNil );
			LineCopy( &pfucb->lineWorkBuf, &pfucb->lineData );
			FUCBResetColumnSet( pfucb );
			PrepareReplace( pfucb );
			break;

		case JET_prepReplaceNoLock:
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );

ReplaceNoLock:			
			Assert( !FFUCBUpdatePrepared( pfucb ) );
			Call( ErrDIRGet( pfucb ) );
			Assert( pfucb->pbfWorkBuf != pbfNil );
			LineCopy( &pfucb->lineWorkBuf, &pfucb->lineData );
			FUCBResetColumnSet( pfucb );
			PrepareReplaceNoLock( pfucb );

			if ( pfucb->ppib->level == 0 )
				StoreChecksum( pfucb );
			else
				FUCBSetDeferredChecksum( pfucb );
			break;

		case JET_prepInsertCopy:
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );
			Call( ErrDIRGet( pfucb ) );
			Assert( pfucb->pbfWorkBuf != pbfNil );
			LineCopy( &pfucb->lineWorkBuf, &pfucb->lineData );
			FUCBResetColumnSet( pfucb );

			/*	wait and retry while write latch conflict
			/**/
	   		AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
			while( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
				{
				BFSleep( cmsecWaitWriteLatch );
				Call( ErrDIRGet( pfucb ) );
 				AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
				}

			/*	increment reference count on long values
			/**/
			Call( ErrRECAffectLongFields( pfucb, &pfucb->lineWorkBuf, fReference ) );

			PrepareInsert( pfucb );
			
			/*	if table has an autoincrement column, then set column
			/*	value now so that it can be retrieved from copy
			/*	buffer.
			/**/
			if ( pfucb->u.pfcb->pfdb->fidAutoInc != 0 )
				{
				Call( ErrRECISetAutoIncrement( pfucb ) );
				}

			break;
		default:
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
		}

	// Ensure long value buffer is empty.
	Assert( pfucb->pLVBuf == NULL );

	Assert( err == JET_errSuccess );

HandleError:
	return err;
	}


VOID FLDFreeLVBuf( FUCB *pfucb )
	{
	LVBUF *pLVBufT, *pLVBufFree;

	pLVBufT = pfucb->pLVBuf;
	while ( pLVBufT != NULL )
		{
		pLVBufFree = pLVBufT;
		pLVBufT = pLVBufT->pLVBufNext;		
		SFree( pLVBufFree );
		}
	pfucb->pLVBuf = NULL;
	return;
	}


INLINE ERR ErrFLDAddToLVBuf( FUCB *pfucb, LID lid )
	{
	ERR err;
	LVBUF *pLVBuf, *pLVBufTrailer, *pLVBufNew;
	BYTE rgbLV[JET_cbColumnMost];
	LONG cbActual;

	// The buffer is sorted in LID ascending order.

	for ( pLVBuf = pfucb->pLVBuf, pLVBufTrailer = NULL;
		pLVBuf != NULL  &&  pLVBuf->lid < lid;
		pLVBufTrailer = pLVBuf, pLVBuf = pLVBuf->pLVBufNext ) ;

	// Only put the LV in the buffer if not already there.
	if ( pLVBuf == NULL  ||  pLVBuf->lid != lid )
		{
		Assert( pLVBuf == NULL  ||  pLVBuf->lid > lid );

		// Extract the before image.
		CallR( ErrRECRetrieveSLongField( pfucb, lid, 0, rgbLV, JET_cbColumnMost, &cbActual ) );

		// WARNING:  In this case, cbActual is a bit of a misnomer.  We usually
		// use cbActual as the actual bytes returned.  But in this case, cbActual
		// refers to the actual size of the long value.  However, we really only
		// care about the first 255 bytes (since that's all that's significant
		// when indexing over long values), so truncate if necessary.
		cbActual = min( cbActual, JET_cbColumnMost );

		pLVBufNew = (LVBUF *)SAlloc( sizeof(LVBUF) + cbActual );

		if ( pLVBufNew == NULL )
			return ErrERRCheck( JET_errOutOfMemory );
			
		pLVBufNew->lid = lid;
		pLVBufNew->pLV = ((BYTE *)pLVBufNew) + sizeof(LVBUF);	// Data hangs off end.
		pLVBufNew->cbLVSize = cbActual;
		pLVBufNew->pLVBufNext = pLVBuf;

		// Copy the before-image to the buffer.		
		memcpy( pLVBufNew->pLV, rgbLV, cbActual );

		if ( pLVBufTrailer == NULL )
			pfucb->pLVBuf = pLVBufNew;
		else
			pLVBufTrailer->pLVBufNext = pLVBufNew;
		}

	return JET_errSuccess;
	}


LOCAL INLINE ERR ErrFLDSetOneColumn(
	FUCB 	*pfucb,
	FID 	fid,
	LINE	*plineField,
	ULONG	grbit,
	ULONG	itagSequence,
	ULONG	ibLongValue )
	{
	ERR	err;

	/*	set long column
	/**/
	if ( fid >= fidTaggedLeast  &&  fid <= pfucb->u.pfcb->pfdb->fidTaggedLast )
		{
		FIELD *pfield = PfieldFDBTagged( pfucb->u.pfcb->pfdb ) + ( fid - fidTaggedLeast );

		if ( FRECLongValue( pfield->coltyp ) )
			{
			/*	if we are replacing, and modifying a column that belongs
			/*	to an index, and the portion that is being modified is indexable
			/*	i.e. part of the first 255 bytes, then we need to copy the
			/*	before image to the LV buffer.
			/**/
			if ( FFUCBReplacePrepared( pfucb )  &&
				itagSequence > 0  &&
				ibLongValue < JET_cbColumnMost )
				{
				err = ErrFILEICheckIndexColumn( pfucb->u.pfcb, fid );
				if ( err < 0 )
					{
					if ( err != JET_errColumnNotFound )
						goto HandleError;
					}

				else
					{
					LINE lineBeforeImg;

					/*	ErrFILEICheckIndexColumn should not return warning
					/**/
					Assert( err == JET_errSuccess );

					/*	extract before image
					/**/
					Assert( itagSequence > 0 );
					Call( ErrRECRetrieveColumn( pfucb, &fid, itagSequence, &lineBeforeImg, 0 ) );
					Assert( err == wrnRECLongField || err == JET_wrnColumnNull );

					/*	if before image was a separated long value,
					/*	then make a copy in the LV buffer.
					/**/
					if ( err == wrnRECLongField && FFieldIsSLong( lineBeforeImg.pb ) )
						{
						Assert( lineBeforeImg.cb == sizeof(LV) );
						Call( ErrFLDAddToLVBuf( pfucb, LidOfLV( lineBeforeImg.pb ) ) );
						}
					}
				}

			FUCBSetColumnSet( pfucb, fid );
			err = ErrRECSetLongField(
				pfucb,
				fid,
				itagSequence,
				plineField,
				grbit,
				ibLongValue,
				pfield->cbMaxLen );

			/*	if column does not fit then try to separate long values
			/*	and try to set column again.
			/**/
			if ( err == JET_errRecordTooBig )
				{
				Call( ErrRECAffectLongFields(
					pfucb,
					&pfucb->lineWorkBuf,
					fSeparateAll ) );
				err = ErrRECSetLongField(
					pfucb,
					fid,
					itagSequence,
					plineField,
					grbit,
					ibLongValue,
					pfield->cbMaxLen );
				}

			return err;
			}
		}


	/*	do the actual column operation
	/**/

	/*	setting value to NULL
	/**/
	if ( plineField->cb == 0 && ( (grbit & JET_bitSetZeroLength) == 0 ) )
		plineField = NULL;

	err = ErrRECSetColumn( pfucb, fid, itagSequence, plineField );
	if ( err == JET_errRecordTooBig )
		{
		Call( ErrRECAffectLongFields( pfucb, &pfucb->lineWorkBuf, fSeparateAll ) );
		err = ErrRECSetColumn( pfucb, fid, itagSequence, plineField );
		}

HandleError:
	return err;
	}



//+API
//	ErrIsamSetColumn
//	========================================================================
//	ErrIsamSetColumn( PIB *ppib, FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField, JET_GRBIT grbit )
//
//	Adds or changes a column value in the record being worked on.
//	Fixed and variable columns are replaced if they already have values.
//	A sequence number must be given for tagged columns.  If this is zero,
//	a new tagged column occurance is added to the record.  If not zero, it
//	specifies the occurance to change.
//	A working buffer is allocated if there isn't one already.
//	If fNewBuf == fTrue, the buffer is initialized with the default values
//	for the columns in the record.  If fNewBuf == fFalse, and there was
//	already a working buffer, it is left unaffected;	 if a working buffer
//	had to be allocated, then this new working buffer will be initialized
//	with either the column values of the current record, or the default column
//	values (if the user's currency is not on a record).
//
//	PARAMETERS	ppib			PIB of user
//				pfucb			FUCB of data file to which this record
//								is being added/updated.
//				fid				column id: which column to set
//				itagSequence 	Occurance number (for tagged columns):
//								which occurance of the column to change
//								If zero, it means "add a new occurance"
//				plineField		column data to use
//				grbit 			If JET_bitSetZeroLength, the column is set to size 0.
//
//	RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfBuffers		Failed to allocate a working
//												buffer
//					-JET_errInvalidBufferSize
//												
//					-ColumnInvalid				The column id given does not
//												corresponding to a defined column
//					-NullInvalid			  	An attempt was made to set a
//												column to NULL which is defined
//												as NotNull.
//					-JET_errRecordTooBig		There is not enough room in
//												the record for new column.
//	COMMENTS 	The GET and DELETE commands discard the working buffer
//				without writing it to the database.	 The REPLACE and INSERT
//				commands may be used to write the working buffer to the
//				database, but they also discard it when finished (the INSERT
//				command can be told not to discard it, though;	this is
//				useful for adding several similar records).
//				For tagged columns, if the data given is NULL-valued, then the
//				tagged column occurance specified is deleted from the record.
//				If there is no tagged column occurance corresponding to the
//				specified occurance number, a new tagged column is added to
//				the record, and assumes the new highest occurance number
//				(unless the data given is NULL-valued, in which case the
//				record is unaffected).
//-
ERR VTAPI ErrIsamSetColumn(
	PIB				*ppib,
	FUCB 			*pfucb,
	JET_COLUMNID	columnid,
	BYTE	  		*pbData,
	ULONG	  		cbData,
	ULONG	  		grbit,
	JET_SETINFO		*psetinfo )
	{
	ERR				err;
	FID 	  		fid = (FID)columnid;
	LINE	  		lineField;
	ULONG	  		itagSequence;
	ULONG			ibLongValue;

	/* check for updatable table
	/**/
	CallR( FUCBCheckUpdatable( pfucb )  );

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );

	if ( ! ( FFUCBSetPrepared( pfucb ) ) )
		return ErrERRCheck( JET_errUpdateNotPrepared );

	lineField.pb = pbData;
	lineField.cb = cbData;

	if ( psetinfo != NULL )
		{
		if ( psetinfo->cbStruct < sizeof(JET_SETINFO) )
			return ErrERRCheck( JET_errInvalidParameter );
		itagSequence = psetinfo->itagSequence;
		ibLongValue = psetinfo->ibLongValue;
		}
	else
		{
		itagSequence = 1;
		ibLongValue = 0;
		}

	/*	Return error if version or autoinc column is being set.
	/*	Check is perfomed for all fixed size column types
	/*	for replace operations.
	/**/
	if ( FFUCBReplacePrepared( pfucb ) && fid <= fidFixedMost )
		{
		BYTE	ffield = PfieldFDBFixed( pfucb->u.pfcb->pfdb )[fid - 1].ffield;

		if ( FFIELDVersion( ffield ) || FFIELDAutoInc( ffield ) )
			return ErrERRCheck( JET_errInvalidColumnType );
		}

	err = ErrFLDSetOneColumn( pfucb, fid, &lineField, grbit, itagSequence, ibLongValue );
	return err;
	}


ERR VTAPI ErrIsamSetColumns(
	JET_VSESID		vsesid,
	JET_VTID		vtid,
	JET_SETCOLUMN	*psetcols,
	unsigned long	csetcols )
	{
	ERR	 			err;
	PIB				*ppib = (PIB *)vsesid;
	FUCB			*pfucb = (FUCB *)vtid;
	ULONG			ccols;
	FID				fid;
	LINE			lineField;
	JET_SETCOLUMN	*psetcolcurr;

	/* check for updatable table
	/**/
	CallR( FUCBCheckUpdatable( pfucb )  );

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );

	if ( !( FFUCBSetPrepared( pfucb ) ) )
		return ErrERRCheck( JET_errUpdateNotPrepared );

	for ( ccols = 0; ccols < csetcols ; ccols++ )
		{
		psetcolcurr = &psetcols[ccols];

		fid = (FID) psetcolcurr->columnid;
		lineField.pb = (BYTE *)psetcolcurr->pvData;
		lineField.cb = psetcolcurr->cbData;

		/*	ignore ibLongValue as only allow append to existing long column
		/**/

		/*	return error if version or autoinc column is being set.
		/*	Check is perfomed for all fixed size column types
		/*	for replace operations.
		/**/
		if ( FFUCBReplacePrepared( pfucb ) && fid <= fidFixedMost )
			{
			BYTE ffield = PfieldFDBFixed( pfucb->u.pfcb->pfdb )[fid - 1].ffield;

			if ( FFIELDVersion( ffield ) || FFIELDAutoInc( ffield ) )
				{
				err = ErrERRCheck( JET_errInvalidColumnType );
				goto HandleError;
				}
			}

		Call( ErrFLDSetOneColumn(
			pfucb,
			fid,
			&lineField,
			psetcolcurr->grbit,
			psetcolcurr->itagSequence,
			psetcolcurr->ibLongValue ) );
		psetcolcurr->err = err;
		}

HandleError:
	return err;
	}


ERR ErrRECSetDefaultValue( FUCB *pfucbFake, FID fid, BYTE *pbDefault, ULONG cbDefault )
	{
	ERR		err;
	LINE	lineField = { cbDefault, pbDefault };
	FDB		*pfdb = (FDB*)pfucbFake->u.pfcb->pfdb;

	if ( FRECLongValue( PfieldFDBFromFid( pfdb, fid )->coltyp ) )
		{
		Assert( FTaggedFid( fid ) );
		Assert( fid <= pfdb->fidTaggedLast );
		if ( cbDefault >= cbLVIntrinsicMost )
			{
			// Max. default long value is cbLVIntrinsicMost-1 (one byte reserved
			// for fSeparated flag).
			err = ErrERRCheck( JET_errColumnTooBig );
			}
		else
			{
			LINE lineNull = { 0, NULL };

			err = ErrRECAOIntrinsicLV(
				pfucbFake,
				fid,
				0,			// itagSequence == 0 to force new column
				&lineNull,
				&lineField,
				0,			// no grbit
				0 );		// ibLongValue
			}
		}
	else
		{
		err = ErrRECSetColumn( pfucbFake, fid, 0, &lineField );
		}

	return err;
	}


INLINE LOCAL ULONG CbBurstVarDefaults( FDB *pfdb, FID fidVarLastInRec, FID fidSet, FID *pfidLastDefault )
	{
	ULONG cbBurstDefaults = 0;

	// Compute space needed to burst default values.
	// Default values may have to be burst if there are default value columns
	// between the last one currently in the record and the one we are setting.
	// (note that if the column being set also has a default value, we don't
	// bother setting it, since it will be overwritten).
	Assert( pfdb->lineDefaultRecord.cb >= cbRECRecordMin  ||
		pfdb->lineDefaultRecord.cb == 0 );		// Only temp tables have no default record.
	*pfidLastDefault = ( pfdb->lineDefaultRecord.cb == 0 ?
		fidVarLeast - 1 :
		((RECHDR *)(pfdb->lineDefaultRecord.pb))->fidVarLastInRec );
	Assert( *pfidLastDefault >= fidVarLeast-1 );
	Assert( *pfidLastDefault <= pfdb->fidVarLast );

	if ( *pfidLastDefault > fidVarLastInRec )
		{
		FIELD 			*pfieldVar = PfieldFDBVar( pfdb );
		WORD UNALIGNED	*pibDefaultVarOffs;
		FID				fidT;

		Assert( pfdb->lineDefaultRecord.cb >= cbRECRecordMin );
		Assert( fidVarLastInRec < fidSet );
		Assert( fidSet <= pfdb->fidVarLast );

		Assert( ((RECHDR*)(pfdb->lineDefaultRecord.pb))->fidFixedLastInRec >= fidFixedLeast-1 );
		Assert( ((RECHDR*)(pfdb->lineDefaultRecord.pb))->fidFixedLastInRec <= pfdb->fidFixedLast );
		pibDefaultVarOffs = PibRECVarOffsets( pfdb->lineDefaultRecord.pb,
			PibFDBFixedOffsets( pfdb ) );

		for ( fidT = fidVarLastInRec + 1; fidT < fidSet; fidT++ )
			{
			if ( FFIELDDefault( pfieldVar[fidT-fidVarLeast].ffield )  &&
				pfieldVar[fidT-fidVarLeast].coltyp != JET_coltypNil )
				{
				Assert( ibVarOffset( pibDefaultVarOffs[fidT+1-fidVarLeast] ) <=
					(WORD)pfdb->lineDefaultRecord.cb );

				cbBurstDefaults +=
					( ibVarOffset( pibDefaultVarOffs[fidT+1-fidVarLeast] ) -
					ibVarOffset( pibDefaultVarOffs[fidT-fidVarLeast] ) );
				Assert( cbBurstDefaults > 0 );

				*pfidLastDefault = fidT;
				}
			}
		}

	Assert( cbBurstDefaults == 0  ||
		( *pfidLastDefault > fidVarLastInRec  &&  *pfidLastDefault < fidSet ) );

	return cbBurstDefaults;
	}



//+INTERNAL
//	ErrRECSetColumn
//	========================================================================
//  ErrRECSetColumn( FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField )
//
//	Internal function: used to implement most of ErrRECAddField and
//	ErrRECChangeField, since they are very similar in operation.
//	The only difference is in handling tagged columns.  Please see the
//	documentation for AddField and ChangeField for details.
//	If plineField is NULL, then value of the column is set to NULL
//-
ERR ErrRECSetColumn( FUCB *pfucb, FID fid, ULONG itagSequence, LINE *plineField )
	{
	ERR					err;					// return code
	FDB					*pfdb;					// column info of file
	ULONG			  	cbRec;					// length of current data record
	BYTE			  	*pbRec;					// pointer to current data record
	FID					fidFixedLastInRec;	 	// highest fixed fid actually in record
	FID					fidVarLastInRec;		// highest var fid actually in record
	BYTE			  	*prgbitNullity;			// pointer to fixed column bitmap
	WORD			  	*pibFixOffs;			// pointer to fixed column offsets
	WORD UNALIGNED	  	*pibVarOffs;			// pointer to var column offsets
	WORD UNALIGNED 		*pib;
	WORD UNALIGNED 		*pibLast;
	ULONG			  	cbTagField;				// Length of tag column.
	ULONG			  	ulNumOccurrences;		// Counts column occurances.
	BYTE			  	*pbRecMax; 				// End of record.
	ULONG			  	cbCopy;					// Number of bytes to copy from user's buffer
	LONG			  	dbFieldData;			// Size change in column data.
	TAGFLD UNALIGNED	*ptagfld;
	FIELD				*pfield;

	/*	efficiency variables
	/**/
	Assert( pfucb != pfucbNil );
	cbRec = pfucb->lineWorkBuf.cb;
	Assert( cbRec >= cbRECRecordMin && cbRec <= cbRECRecordMost );
	pbRec = pfucb->lineWorkBuf.pb;
	Assert( pbRec != NULL );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );
	/*	use same fdb reference for File as for Sort since sort
	/*	is conformant to file control block access
	/**/
	Assert( pfucb->u.pfcb != pfcbNil );
	pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	Assert( pfdb != pfdbNil );
	fidFixedLastInRec = ((RECHDR*)pbRec)->fidFixedLastInRec;
	Assert( fidFixedLastInRec >= (BYTE)(fidFixedLeast-1) &&
		fidFixedLastInRec <= (BYTE)(fidFixedMost));
	fidVarLastInRec = ((RECHDR*)pbRec)->fidVarLastInRec;
	Assert( fidVarLastInRec >= (BYTE)(fidVarLeast-1) &&
		fidVarLastInRec <= (BYTE)(fidVarMost));
	pibFixOffs = PibFDBFixedOffsets( pfdb );			// fixed column offsets


	/*	record the fact that this column has been changed
	/**/
	FUCBSetColumnSet( pfucb, fid );

	/*** -----------MODIFYING FIXED FIELD---------- ***/
	if ( FFixedFid( fid ) )
		{
		if ( fid > pfdb->fidFixedLast )
			return ErrERRCheck( JET_errColumnNotFound );

		pfield = PfieldFDBFixedFromOffsets( pfdb, pibFixOffs ) + ( fid - fidFixedLeast );
		if ( pfield->coltyp == JET_coltypNil )
			return ErrERRCheck( JET_errColumnNotFound );

		/*	column not represented in record? Make room, make room
		/**/
		if ( fid > fidFixedLastInRec )
			{
			ULONG		ibOldFixEnd;   	// End of fixed columns
			ULONG		ibNewFixEnd;   	// before and after shift
			ULONG		cbOldBitMap;   	// Size of old fixcolumn bitmap
			ULONG		cbNewBitMap;	// Size of new fixcolumn bitmap
			ULONG		ibOldBitMapEnd; // Offset of fixcolumn bitmap
			ULONG		ibNewBitMapEnd; // before and after shift
			ULONG		cbShift;		// Space for new columns
			FID			fidT;
			FID			fidLastDefault;

			/*	adding NULL : if ( plineField==NULL || plineField->cb==0 || plineField->pb==NULL )
			/**/
			if ( FLineNull( plineField )  &&  FFIELDNotNull( pfield->ffield ) )
				{
				return ErrERRCheck( JET_errNullInvalid );
				}

			/*	compute room needed for new column and bitmap
			/**/
			ibOldFixEnd	= pibFixOffs[fidFixedLastInRec];
			ibNewFixEnd	= pibFixOffs[fid];
			Assert( ibNewFixEnd > ibOldFixEnd );

			cbOldBitMap		= (fidFixedLastInRec+7)/8;
			ibOldBitMapEnd	= ibOldFixEnd + cbOldBitMap;
			cbNewBitMap		= (fid+7)/8;
			ibNewBitMapEnd	= ibNewFixEnd + cbNewBitMap;
			Assert( ibNewBitMapEnd > ibOldBitMapEnd );

			cbShift	= ibNewBitMapEnd - ibOldBitMapEnd;
			Assert( cbShift > 0 );

			if ( cbRec + cbShift > cbRECRecordMost )
				return ErrERRCheck( JET_errRecordTooBig );

			/*	shift rest of record over to make room
			/**/
			memmove( pbRec + ibNewBitMapEnd, pbRec + ibOldBitMapEnd, cbRec - ibOldBitMapEnd );
			
#ifdef DEBUG
			memset( pbRec + ibOldBitMapEnd, '*', cbShift );
#endif

			cbRec = (pfucb->lineWorkBuf.cb += cbShift);

			/*	increase var column offsets by cbShift
			/**/
			pibVarOffs = (WORD *)( pbRec + ibNewBitMapEnd );
			pibLast = pibVarOffs+fidVarLastInRec+1-fidVarLeast;
			for ( pib = pibVarOffs; pib <= pibLast; pib++ )
				{
				*pib += (WORD) cbShift;
				Assert( (ULONG)ibVarOffset(*pib) >= (ULONG)((BYTE *)pibLast - pbRec) && (ULONG)ibVarOffset(*pib) <= cbRec );
				}

			/*	shift fixed column bitmap over
			/**/
			memmove( pbRec + ibNewFixEnd, pbRec + ibOldFixEnd, cbOldBitMap );

#ifdef DEBUG
			memset( pbRec + ibOldFixEnd, '*', ibNewFixEnd - ibOldFixEnd );
#endif

			/*	clear all new bitmap bits
			/**/

			// If there's at least one fixed column currently in the record,
			// find the nullity bit for the last fixed column and clear the
			// rest of the bits in that byte.
			if ( fidFixedLastInRec >= fidFixedLeast )
				{
				FID ifid = fidFixedLastInRec - fidFixedLeast;	// Fid converted to an index.

				prgbitNullity = pbRec + ibNewFixEnd + ifid/8;
				for ( fidT = fidFixedLastInRec + 1; fidT <= fid; fidT++ )
					{
					ifid = fidT - fidFixedLeast;
					if ( ( pbRec + ibNewFixEnd + ifid/8 ) != prgbitNullity )
						{
						Assert( ( pbRec + ibNewFixEnd + ifid/8 ) == ( prgbitNullity + 1 ) );
						break;
						}
					SetFixedNullBit( prgbitNullity, ifid );
					}

				prgbitNullity++;		// Advance to next nullity byte.
				Assert( prgbitNullity <= pbRec + ibNewBitMapEnd );
				}
			else
				{
				prgbitNullity = pbRec + ibNewFixEnd;
				Assert( prgbitNullity < pbRec + ibNewBitMapEnd );
				}

			for ( ; prgbitNullity < pbRec + ibNewBitMapEnd; prgbitNullity++ )
				{
				*prgbitNullity = 0;		// Clear all the bits at once.
				}
			Assert( prgbitNullity == pbRec + ibNewBitMapEnd );


			// Default values may have to be burst if there are default value columns
			// between the last one currently in the record and the one we are setting.
			// (note that if the column being set also has a default value, we have
			// to set the default value first in case the actual set fails.
			Assert( pfdb->lineDefaultRecord.cb >= cbRECRecordMin  ||
				pfdb->lineDefaultRecord.cb == 0 );		// Only temp tables have no default record.
			fidLastDefault = ( pfdb->lineDefaultRecord.cb == 0 ?
				fidFixedLeast - 1 :
				((RECHDR *)(pfdb->lineDefaultRecord.pb))->fidFixedLastInRec );
			Assert( fidLastDefault >= fidFixedLeast-1 );
			Assert( fidLastDefault <= pfdb->fidFixedLast );
			if ( fidLastDefault > fidFixedLastInRec )
				{
				FIELD 	*pfieldFixed = PfieldFDBFixedFromOffsets( pfdb, pibFixOffs );
				FID		ifid;				// Fid converted to an index.

				Assert( fidFixedLastInRec < fid );
				for ( fidT = fidFixedLastInRec + 1; fidT <= fid; fidT++ )
					{
					Assert( fidT <= pfdb->fidFixedLast );
					ifid = fidT - fidFixedLeast;		// Convert to an index
					if ( FFIELDDefault( pfieldFixed[ifid].ffield )  &&
						pfieldFixed[ifid].coltyp != JET_coltypNil )
						{
						// Update nullity bit.  Assert that it's currently set to null,
						// then set it to non-null in preparation of the bursting of
						// the default value.
						prgbitNullity = pbRec + ibNewFixEnd + (ifid/8);
						Assert( FFixedNullBit( prgbitNullity, ifid ) );
						ResetFixedNullBit( prgbitNullity, ifid );
						fidLastDefault = fidT;
						}
					}

				// Only burst default values between the last fixed column currently
				// in the record and the column now being set.
				Assert( fidLastDefault > fidFixedLastInRec );
				if ( fidLastDefault <= fid )
					{
					// The fixed offsets table has already been updated appropriately
					// in the loop above.
					Assert( pibFixOffs[fidLastDefault] > pibFixOffs[fidFixedLastInRec] );
					memcpy( pbRec + pibFixOffs[fidFixedLastInRec],
						pfdb->lineDefaultRecord.pb + pibFixOffs[fidFixedLastInRec],
						pibFixOffs[fidLastDefault] - pibFixOffs[fidFixedLastInRec] );
					}
				}

			/*	increase fidFixedLastInRec
			/**/
			fidFixedLastInRec = ((RECHDR*)pbRec)->fidFixedLastInRec = (BYTE)fid;
			}

		/*	fid is now definitely represented in
		/*	the record; its data can simply be replaced
		/**/

		/*	adjust fid to an index
		/**/
		fid -= fidFixedLeast;

		/*	byte containing bit representing column's nullity
		/**/
		prgbitNullity = pbRec + pibFixOffs[fidFixedLastInRec] + fid/8;

		/*	adding NULL: clear bit (or maybe error)
		/**/
		if ( FLineNull( plineField ) )
			{
			if ( FFIELDNotNull( pfield->ffield ) )
				return ErrERRCheck( JET_errNullInvalid );
			SetFixedNullBit( prgbitNullity, fid );
			}

		else
			{
			/*	adding non-NULL value: set bit, copy value into slot
			/**/
			JET_COLTYP coltyp = pfield->coltyp;

			err = JET_errSuccess;

			Assert( pfield->cbMaxLen == UlCATColumnSize( coltyp, pfield->cbMaxLen, NULL ) );
			cbCopy = pfield->cbMaxLen;

			if ( plineField->cb != cbCopy )
				{
				switch ( coltyp )
					{
					case JET_coltypBit:
					case JET_coltypUnsignedByte:
					case JET_coltypShort:
					case JET_coltypLong:
					case JET_coltypCurrency:
					case JET_coltypIEEESingle:
					case JET_coltypIEEEDouble:
					case JET_coltypDateTime:
						return ErrERRCheck( JET_errInvalidBufferSize );

					case JET_coltypBinary:
						if ( plineField->cb > cbCopy )
							return ErrERRCheck( JET_errInvalidBufferSize );
						else
							memset( pbRec + pibFixOffs[fid] + plineField->cb, 0, cbCopy - plineField->cb );
						cbCopy = plineField->cb;
						break;

					default:
						Assert( coltyp == JET_coltypText );
						if ( plineField->cb > cbCopy )
							return ErrERRCheck( JET_errInvalidBufferSize );
						else
							memset( pbRec + pibFixOffs[fid] + plineField->cb, ' ', cbCopy - plineField->cb );
						cbCopy = plineField->cb;
						break;
					}
				}

			ResetFixedNullBit( prgbitNullity, fid );

			if ( coltyp != JET_coltypBit )
				memcpy(pbRec + pibFixOffs[fid], plineField->pb, cbCopy);
			else if ( *plineField->pb == 0 )
				*(pbRec+pibFixOffs[fid]) = 0;
			else
				*(pbRec+pibFixOffs[fid]) = 0xFF;

			Assert( pfucb->lineWorkBuf.cb <= cbRECRecordMost );
			return err;
			}

		Assert( pfucb->lineWorkBuf.cb <= cbRECRecordMost );
		return JET_errSuccess;
		}

	/*** -----------MODIFYING VARIABLE FIELD---------- ***/
	if ( FVarFid(fid) )
		{
		ULONG  				cbFieldOld;			// Current size of column.
		WORD UNALIGNED 		*pibFieldEnd;		// Ptr to offset of end of column.
		WORD UNALIGNED 		*pib;
#ifdef DEBUG
		BOOL				fBurstRecord = ( fid > fidVarLastInRec );
#endif

		if ( fid > pfdb->fidVarLast )
			return ErrERRCheck( JET_errColumnNotFound );

		pfield = PfieldFDBVar( pfdb ) + ( fid - fidVarLeast );
		if ( pfield->coltyp == JET_coltypNil )
			return ErrERRCheck( JET_errColumnNotFound );

		err = JET_errSuccess;

		/*	NULL-value check
		/**/
		if ( plineField == NULL )
			{
			if ( FFIELDNotNull( pfield->ffield ) )
				return ErrERRCheck( JET_errNullInvalid );
			else
				cbCopy = 0;
			}
		else if ( plineField->pb == NULL )
			{
			cbCopy = 0;
			}
		else if ( plineField->cb > pfield->cbMaxLen )
			{
			/*	column too long
			/**/
			cbCopy = pfield->cbMaxLen;
			err = ErrERRCheck( JET_wrnColumnMaxTruncated );
			}
		else
			{
			cbCopy = plineField->cb;
			}

		/*	variable column offsets
		/**/
		pibVarOffs = (WORD *)( pbRec + pibFixOffs[fidFixedLastInRec] +
			( fidFixedLastInRec + 7 ) / 8 );

		/*	column not represented in record?  Make room, make room
		/**/
		if ( fid > fidVarLastInRec )
			{
			ULONG	cbNeed;					// Space needed for new offsets.
			BYTE	*pbVarOffsEnd;			// Ptr to end of existing offsets.
			ULONG	ibTagFields;			// offset of tagged column section
			FID		fidLastDefault;
			ULONG	cbBurstDefaults = 0;	// Space needed to burst default values.

			Assert( !( plineField == NULL  &&  FFIELDNotNull( pfield->ffield ) ) );

			/*	compute space needed for new var column offsets
			/**/
			cbNeed = ( fid - fidVarLastInRec ) * sizeof(WORD);
			cbBurstDefaults = CbBurstVarDefaults( pfdb, fidVarLastInRec, fid, &fidLastDefault );
			if ( cbRec + cbNeed + cbBurstDefaults + cbCopy > cbRECRecordMost )
				return ErrERRCheck( JET_errRecordTooBig );

			/*	bump existing var column offsets
			/**/
			pibLast = pibVarOffs+fidVarLastInRec+1-fidVarLeast;
			for ( pib = pibVarOffs; pib <= pibLast; pib++ )
				{
				*pib += (WORD) cbNeed;
				Assert( (ULONG)ibVarOffset(*pib) >= (ULONG)((BYTE*)pibLast - pbRec ) && (ULONG)ibVarOffset(*pib) <= cbRec + cbNeed );
				}

			/*	shift rest of record over to make room
			/**/
			pbVarOffsEnd=(BYTE*)pibLast;
			memmove(pbVarOffsEnd + cbNeed, pbVarOffsEnd, (size_t)(pbRec + cbRec - pbVarOffsEnd));
#ifdef DEBUG
			memset(pbVarOffsEnd, '*', cbNeed);
#endif

			/*	set new var offsets to tag offset, making them NULL
			/**/
			pibLast = pibVarOffs+fid-fidVarLeast;
			ibTagFields = pibLast[1];
			SetVarNullBit( ibTagFields );
			pib = pibVarOffs+fidVarLastInRec+1-fidVarLeast;
			Assert( (ULONG)ibVarOffset( ibTagFields ) >= (ULONG)((BYTE*)pib - pbRec) );
			Assert( (ULONG)ibVarOffset( ibTagFields ) <= cbRec + cbNeed );
			while( pib <= pibLast )
				*pib++ = (WORD) ibTagFields;
			Assert( pib == pibVarOffs+fid+1-fidVarLeast );
			Assert( *pib == ibVarOffset( (WORD)ibTagFields ) );

			/*	increase record size to reflect addition of entries in the
			/*	variable offsets table.
			/**/
			Assert( fidVarLastInRec == ((RECHDR *)pbRec)->fidVarLastInRec );
			Assert( pfucb->lineWorkBuf.cb == cbRec );
			cbRec += cbNeed;

			// Burst default values if required.
			Assert( cbBurstDefaults == 0  ||
				( fidLastDefault > fidVarLastInRec  &&  fidLastDefault < fid ) );
			if ( cbBurstDefaults > 0 )
				{
				WORD UNALIGNED	*pibDefaultVarOffs = PibRECVarOffsets( pfdb->lineDefaultRecord.pb, pibFixOffs );
				WORD UNALIGNED	*pibDefault;
				FIELD			*pfieldVar;
				FID				fidT;

				// Make room for the default values to be burst.
				Assert( pibVarOffs[fidVarLastInRec+1-fidVarLeast] ==
					(WORD)ibTagFields );	// Includes null-bit comparison.
				Assert( pibVarOffs[fid-fidVarLeast] ==
					(WORD)ibTagFields );	// Includes null-bit comparison.
				Assert( ibVarOffset( pibVarOffs[fid+1-fidVarLeast] ) ==
					ibVarOffset( (WORD)ibTagFields ) );		// Null-bits are not equivalent.
				Assert( cbRec >= ibVarOffset( ibTagFields ) );
				memmove( pbRec + ibVarOffset( ibTagFields ) + cbBurstDefaults,
					pbRec + ibVarOffset( ibTagFields ),
					cbRec - ibVarOffset( ibTagFields ) );

				Assert( ibVarOffset( pibDefaultVarOffs[fidVarLastInRec+1-fidVarLeast] ) <
					ibVarOffset( pibDefaultVarOffs[fidLastDefault+1-fidVarLeast] ) );
				Assert( ibVarOffset( pibDefaultVarOffs[fidLastDefault+1-fidVarLeast] ) <=
					(WORD)pfdb->lineDefaultRecord.cb );


				pib = pibVarOffs + ( fidVarLastInRec + 1 - fidVarLeast );
				Assert( *pib == (WORD)ibTagFields );		// Null bit also compared.
				ResetVarNullBit( *pib );		// Loop below will set this bit properly.
				pibDefault = pibDefaultVarOffs + ( fidVarLastInRec + 1 - fidVarLeast );
				pfieldVar = PfieldFDBVar( pfdb ) + ( fidVarLastInRec + 1 - fidVarLeast );

				for ( fidT = fidVarLastInRec + 1;
					fidT <= fidLastDefault;
					fidT++, pib++, pibDefault++, pfieldVar++ )
					{

					// Null bit always gets reset by the previous iteration.
					Assert( !FVarNullBit( *pib ) );

					Assert( *(pib+1) == (WORD)ibTagFields );	// Null bit also compared.
					
					if ( FFIELDDefault( pfieldVar->ffield ) &&
						pfieldVar->coltyp != JET_coltypNil )
						{
						ULONG cb;

						// Update offset entry in preparation for the default value.
						Assert( !FVarNullBit( *pibDefault ) );
						Assert( !FVarNullBit( *pib ) );		// Null bit already reset.
						cb = ibVarOffset( *(pibDefault+1) ) - ibVarOffset( *pibDefault );
						Assert( cb > 0 );
						*(pib+1) = ibVarOffset( *pib ) + (WORD)cb;

						// Copy the default value into the record.
						memcpy( pbRec + ibVarOffset( *pib ),
							pfdb->lineDefaultRecord.pb + ibVarOffset( *pibDefault ),
							cb );

						FUCBSetColumnSet( pfucb, fidT );
						}
					else
						{
						SetVarNullBit( *pib );
						*(pib+1) = ibVarOffset( *pib );	
						}
					}

				Assert( !FVarNullBit( *pib ) );		// Null bit was reset.
				SetVarNullBit( *pib );
				Assert( ibVarOffset( *pib ) -
					ibVarOffset( pibVarOffs[fidVarLastInRec+1-fidVarLeast] ) ==
					(WORD)cbBurstDefaults );
				Assert( ibVarOffset( *pib ) ==
					ibVarOffset( (WORD)ibTagFields ) + (WORD)cbBurstDefaults );

				// Offset entries up to the last default have been set.
				// Update the entries between the last default and the
				// column being set.
				pibLast = pibVarOffs + ( fid + 1 - fidVarLeast );
				for ( pib++; pib <= pibLast; pib++ )
					{
					Assert( ibVarOffset( *pib ) ==
						ibVarOffset( (WORD)ibTagFields ) );		// Null bit may not be equivalent.

					// Only the last variable offset entry (the one
					// pointing to the tagged fields) should be marked
					// non-null.
					Assert( pib == pibLast ? !FVarNullBit( *pib ) : FVarNullBit( *pib ) );

					*pib += (WORD)cbBurstDefaults;
					}

#ifdef DEBUG
				// Verify null bits vs. offsets.
				pibLast = pibVarOffs + ( fid - fidVarLeast );
				for ( pib = pibVarOffs; pib <= pibLast; pib++ )
					{
					Assert( ibVarOffset( *(pib+1) ) >= ibVarOffset( *pib ) );
					if ( FVarNullBit( *pib ) )
						{
						Assert( pib != pibVarOffs + ( fidLastDefault - fidVarLeast ) );
						Assert( ibVarOffset( *(pib+1) ) == ibVarOffset( *pib ) );
						}
					else
						{
						Assert( pib <= pibVarOffs + ( fidLastDefault - fidVarLeast ) );
						Assert( ibVarOffset( *(pib+1) ) > ibVarOffset( *pib ) );
						}
					}
				// Offset to tagged fields should be flagged non-null.
				Assert( !FVarNullBit( *pib ) );
#endif
				}
			
			Assert( fidVarLastInRec == ((RECHDR *)pbRec)->fidVarLastInRec );
			Assert( pfucb->lineWorkBuf.cb == cbRec - cbNeed );
			fidVarLastInRec = ((RECHDR *)pbRec)->fidVarLastInRec = (BYTE)fid;
			pfucb->lineWorkBuf.cb = ( cbRec += cbBurstDefaults );
			}

		/*	fid is now definitely represented in the record;
		/*	its data can be replaced, shifting remainder of record,
		/*	either to the right or left (if expanding/shrinking)
		/**/

		Assert( err == JET_errSuccess  ||  err == JET_wrnColumnMaxTruncated );


		/*	adjust fid to an index
		/**/
		fid -= fidVarLeast;

		/*	compute change in column size and value of null-bit in offset
		/**/
		pibFieldEnd = &pibVarOffs[fid+1];
		cbFieldOld  = ibVarOffset( *pibFieldEnd ) - ibVarOffset( *(pibFieldEnd-1) );
		dbFieldData = cbCopy - cbFieldOld;

		/*	size changed: must shift rest of record data
		/**/
		if ( dbFieldData != 0 )
			{
			/*	shift data
			/**/
			if ( cbRec + dbFieldData > cbRECRecordMost )
				{
				Assert( !fBurstRecord );		// If record had to be extended, space
												// consumption was already checked.
				return ErrERRCheck( JET_errRecordTooBig );
				}
			
			memmove(pbRec + ibVarOffset( *pibFieldEnd ) + dbFieldData,
					pbRec + ibVarOffset( *pibFieldEnd ),
					cbRec - ibVarOffset( *pibFieldEnd ) );

#ifdef DEBUG
			if ( dbFieldData > 0 )
				memset( pbRec + ibVarOffset( *pibFieldEnd ), '*', dbFieldData );
#endif

			cbRec = ( pfucb->lineWorkBuf.cb += dbFieldData );

			/*	bump remaining var column offsets
			/**/
			pibLast = pibVarOffs+fidVarLastInRec+1-fidVarLeast;
			for ( pib = pibVarOffs + fid + 1; pib <= pibLast; pib++ )
				{
				*pib += (WORD) dbFieldData;
				Assert( (ULONG)ibVarOffset( *pib ) >= (ULONG)((BYTE *)pibLast - pbRec )
					&& (ULONG)ibVarOffset( *pib ) <= cbRec );
				}
			}

		/*	data shift complete, if any;  copy new column value in
		/**/
		if ( cbCopy != 0 )
			{
			memcpy( pbRec + ibVarOffset( *( pibFieldEnd - 1 ) ), plineField->pb, cbCopy );
			}

		/*	set value of null-bit in offset
		/**/
		if ( plineField == NULL )
			{
			SetVarNullBit( *( pibFieldEnd - 1 ) );
			}
		else
			{
			ResetVarNullBit( *( pibFieldEnd - 1 ) );
			}

		Assert( pfucb->lineWorkBuf.cb <= cbRECRecordMost );
		Assert( err == JET_errSuccess  ||  err == JET_wrnColumnMaxTruncated );
		return err;
		}

	/*** -----------MODIFYING TAGGED FIELD---------- ***/
	if ( !FTaggedFid(fid) )
		return ErrERRCheck( JET_errBadColumnId );
	if ( fid > pfdb->fidTaggedLast )
		return ErrERRCheck( JET_errColumnNotFound );

	pfield = PfieldFDBTagged( pfdb ) + ( fid - fidTaggedLeast );
	if ( pfield->coltyp == JET_coltypNil )
		return ErrERRCheck( JET_errColumnNotFound );

	/*	check for column too long
	/**/
	if ( pfield->cbMaxLen > 0 )
		{
		ULONG	cbMax = pfield->cbMaxLen;

		/*	compensate for long column overhead
		/**/
		if ( FRECLongValue( pfield->coltyp ) )
			{
			cbMax += offsetof(LV, rgb);
			}

		if ( (ULONG)CbLine( plineField ) > cbMax )
			{
			return ErrERRCheck( JET_errColumnTooBig );
			}
		}

	/*	check fixed size column size
	/**/
	if ( CbLine( plineField ) > 0 )
		{
		switch ( pfield->coltyp )
			{
			case JET_coltypBit:
			case JET_coltypUnsignedByte:
				if ( CbLine( plineField ) != 1 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			case JET_coltypShort:
				if ( CbLine( plineField ) != 2 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			case JET_coltypLong:
			case JET_coltypIEEESingle:
#ifdef NEW_TYPES
			case JET_coltypDate:
			case JET_coltypTime:
#endif
				if ( CbLine( plineField ) != 4 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			case JET_coltypCurrency:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				if ( CbLine( plineField ) != 8 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
#ifdef NEW_TYPES
			case JET_coltypGuid:
				if ( CbLine( plineField ) != 16 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
#endif
			default:
				Assert( pfield->coltyp == JET_coltypText ||
					pfield->coltyp == JET_coltypBinary ||
					FRECLongValue( pfield->coltyp ) );
				break;
			}
		}

	/*	cannot set column more than cbLVIntrinsicMost bytes
	/**/
	if ( CbLine( plineField ) > cbLVIntrinsicMost )
		{
		return ErrERRCheck( JET_errColumnLong );
		}

	// Null bit shouldn't be set for last entry in variable offsets table, which is
	// really the entry that points to the tagged columns.
	Assert( !FVarNullBit( ibTaggedOffset( pbRec, pibFixOffs ) ) );

	ptagfld = (TAGFLD *)( pbRec + ibTaggedOffset( pbRec, pibFixOffs ) );
	ulNumOccurrences = 0;
	pbRecMax = pbRec + cbRec;
	while ( (BYTE *)ptagfld < pbRecMax )
		{
		Assert( FTaggedFid( ptagfld->fid ) );
		Assert( ptagfld->fid <= pfdb->fidTaggedLast );
		cbTagField = ptagfld->cb;
		Assert( !ptagfld->fNull  ||  cbTagField == 0 );		// If null, length is 0.
		if ( ptagfld->fid == fid )
			{
			// If null entry, this should be the only instance of the column.
			Assert( !ptagfld->fNull  ||  ( ulNumOccurrences == 0  &&
				FRECLastTaggedInstance( fid, ptagfld, pbRecMax ) ) );
			if ( ptagfld->fNull  ||  ++ulNumOccurrences == itagSequence )
				break;
			}
		else if ( ptagfld->fid > fid )
			{
			break;
			}

		ptagfld = PtagfldNext( ptagfld );
		Assert( (BYTE *)ptagfld <= pbRecMax );
		}
	Assert( (BYTE *)ptagfld <= pbRecMax );

	// If itagSequence was 0, then we should be either appending or inserting,
	// or overwriting a null entry.
	Assert( (BYTE *)ptagfld == pbRecMax  ||  ptagfld->fid > fid  ||
		itagSequence > 0  ||  ptagfld->fNull );
	
	if ( (BYTE *)ptagfld == pbRecMax  ||  ptagfld->fid > fid )
		{
		/*	Specified column/itagSequence not found, so insert or append new
		/*	tagged column instance.
		/**/

		ULONG cbField;

		/*	Adding NULL: In most cases, we do nothing.  However, there
		/*	is one specialised case where we have to insert a null entry.
		/*	This is the case where there are currently no instances of this
		/*	column in the record, and where there is also a default value
		/*	for this column.
		/**/
		if ( plineField == NULL )
			{
			if ( FFIELDDefault( pfield->ffield )  &&  ulNumOccurrences == 0 )
				cbField = 0;
			else
				return JET_errSuccess;
			}
		else
			cbField = plineField->cb;

		/*	will column fit?
		/**/
		if ( cbRec + sizeof(TAGFLD) + cbField > cbRECRecordMost )
			return ErrERRCheck( JET_errRecordTooBig );

		Assert( (BYTE *)ptagfld <= pbRecMax );
		if ( (BYTE *)ptagfld < pbRecMax )
			{
			// If inserting, open up space for the new column
			memmove( ptagfld->rgb + cbField, (BYTE *)ptagfld, (size_t)(pbRecMax - (BYTE *)ptagfld) );
			}

		/*	copy in new column data; bump record size
		/**/
		ptagfld->fid = fid;
		ptagfld->cbData = (WORD)cbField;		// Implicitly clears null bit.
		Assert( !ptagfld->fNull );
		if ( plineField == NULL )
			{
			Assert( cbField == 0 );
			Assert( FFIELDDefault( pfield->ffield ) );
			Assert( ulNumOccurrences == 0 );
			ptagfld->fNull = fTrue;
			Assert( ptagfld->cb == 0 );
			}
		else
			{
			memcpy( ptagfld->rgb, plineField->pb, cbField );
			}
		pfucb->lineWorkBuf.cb += sizeof(TAGFLD) + cbField;
		}

	else if ( plineField != NULL )				// Overwrite with a non-null value.
		{

#ifdef DEBUG
		if ( ptagfld->fNull )
			{
			Assert( FFIELDDefault( pfield->ffield ) );
			Assert( ulNumOccurrences == 0  &&
				FRECLastTaggedInstance( fid, ptagfld, pbRecMax ) );
			Assert( cbTagField == 0 );
			}
		else
			{
			// Ensure that we've found a field.
			Assert( itagSequence > 0 );
			Assert( itagSequence == ulNumOccurrences  &&  ptagfld->fid == fid );
			Assert( (BYTE *)PtagfldNext( ptagfld ) <= pbRecMax );
			Assert( (BYTE *)PtagfldNext( ptagfld ) == pbRecMax  ||
				PtagfldNext( ptagfld )->fid >= fid );
			}
#endif

		/*	overwrite with non-NULL value: have to shift record data
		/*	Compute change in column size.
		/**/
		dbFieldData = plineField->cb - cbTagField;
		if ( cbRec + dbFieldData > cbRECRecordMost )
			return ErrERRCheck( JET_errRecordTooBig );

		/*	shift rest of record over
		/**/
		memmove( ptagfld->rgb + cbTagField + dbFieldData,
			ptagfld->rgb + cbTagField,
			(size_t)(pbRecMax - ( ptagfld->rgb + cbTagField )) );

		/*	copy in new column data; bump record size
		/**/
		memcpy( ptagfld->rgb, plineField->pb, plineField->cb );
		ptagfld->cbData = (WORD) plineField->cb;		// Implicitly clears null bit.
		Assert( !ptagfld->fNull );
		pfucb->lineWorkBuf.cb += dbFieldData;
		}

	else if ( !ptagfld->fNull )				// Overwriting non-null with null
		{
		// Ensure that we've found a field.
		Assert( itagSequence > 0 );
		Assert( itagSequence == ulNumOccurrences  &&  ptagfld->fid == fid );
		Assert( (BYTE *)PtagfldNext( ptagfld ) <= pbRecMax );
		Assert( (BYTE *)PtagfldNext( ptagfld ) == pbRecMax  ||
			PtagfldNext( ptagfld )->fid >= fid );

		/*	Overwrite with NULL: In most cases, just delete the occurrence from
		/*	the record.  However, there is one rare case where we have to
		/*	leave behind a null entry.  This is the case where there are no
		?*	other instances of this column for this record, and where this
		/*	column has a default value.
		/*	To determine if this is the only occurrence, we first check if its
		/*	itagSequence is 1.  If so, then we check the next TAGFLD in the record.
		/*	If we hit the end, or if the next TAGFLD has a different fid, then there
		/*	is only one occurrence of this column.
		/**/
		if ( FFIELDDefault( pfield->ffield )  &&  itagSequence == 1  &&
			FRECLastTaggedInstance( fid, ptagfld, pbRecMax ) )
			{
			memmove( ptagfld->rgb, ptagfld->rgb + cbTagField,
				(size_t)(pbRecMax - ( ptagfld->rgb + cbTagField )) );
			ptagfld->cbData = 0;				// Implicitly clears null bit.
			ptagfld->fNull = fTrue;
			pfucb->lineWorkBuf.cb -= cbTagField;
			}
		else
			{
			memmove( (BYTE*)ptagfld, ptagfld->rgb + cbTagField,
				(size_t)(pbRecMax - ( ptagfld->rgb + cbTagField )) );
			pfucb->lineWorkBuf.cb -= sizeof(TAGFLD) + cbTagField;
			}
		}

#ifdef DEBUG
	else									// Overwriting null with null.  Do nothing.
		{
		Assert( FFIELDDefault( pfield->ffield ) );
		Assert( ulNumOccurrences == 0  &&  FRECLastTaggedInstance( fid, ptagfld, pbRecMax ) );
		Assert( cbTagField == 0 );
		}
#endif
	
	Assert( pfucb->lineWorkBuf.cb <= cbRECRecordMost );
	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\initterm.c ===
#include "std.h"
#include "version.h"

#include <stdio.h>

#ifndef RETAIL

#define wAssertActionDefault	3 /* no action */
unsigned wAssertAction = wAssertActionDefault;

#endif	/* RETAIL */

DeclAssertFile;


JET_ERR JET_API ErrSetSystemParameter(JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char  *sz);

BOOL  fJetInitialized = fFalse;
BOOL  fBackupAllowed = fFalse;
void  *  critJet = NULL;

/*=================================================================
JetSetSystemParameter

Description:
  This function sets system parameter values.  It calls ErrSetSystemParameter
  to actually set the parameter values.

Parameters:
  sesid 	is the optional session identifier for dynamic parameters.
  paramid	is the system parameter code identifying the parameter.
  lParam	is the parameter value.
  sz		is the zero terminated string parameter.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidParameter:
    Invalid parameter code.
  JET_errAlreadyInitialized:
    Initialization parameter cannot be set after the system is initialized.
  JET_errInvalidSesid:
    Dynamic parameters require a valid session id.

Side Effects:
  * May allocate memory
=================================================================*/

JET_ERR JET_NODSAPI JetSetSystemParameter(JET_INSTANCE  *pinstance, JET_SESID sesid,
	unsigned long paramid, ULONG_PTR lParam, const char  *sz)
	{
	JET_ERR err;
	int fReleaseCritJet = 0;
	
	if (critJet == NULL)
		fReleaseCritJet = 1;
	APIInitEnter();
	
	err = ErrSetSystemParameter(sesid, paramid, lParam, sz);

	if (fReleaseCritJet)
		{
		APITermReturn( err );
		}

	APIReturn( err );
	}


/*=================================================================
JetInit

Description:
  This function initializes Jet and the built-in ISAM.

Parameters: None

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings: from ErrInitInstance (wininst.asm) or ErrInit (below)

Side Effects: Allocates an instance data segment if necessary.
=================================================================*/

JET_ERR JET_NODSAPI JetInit(JET_INSTANCE  *pinstance )
	{
	JET_ERR err;

	APIInitEnter();

	err = ErrInit( fFalse );
	if ( err < 0 && err != JET_errAlreadyInitialized )
		{
		APITermReturn( err );
		}

	/*	backup allowed only after Jet is properly initialized.
	/**/
	fBackupAllowed = fTrue;

	APIReturn( err );
	}


/*=================================================================
ErrInit

Description:
  This function initializes Jet and the built-in ISAM.	It expects the
  DS register to be set correctly for this instance.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

=================================================================*/

JET_ERR JET_API ErrInit( BOOL fSkipIsamInit )
	{
	JET_ERR		err = JET_errSuccess;

	if ( fJetInitialized )
		{
		return JET_errAlreadyInitialized;
		}

	err = ErrUtilInit();
	if ( err < 0 )
		return err;

	/*	initialize JET subsystems
	/**/
	err = ErrVtmgrInit();
	if ( err < 0 )
		return err;

	/*	initialize the integrated ISAM
	/**/
	if ( !fSkipIsamInit )
		{
		err = ErrIsamInit( 0 );

		if ( err < 0 )
			return err;
		}
	fJetInitialized = fTrue;

	return JET_errSuccess;
	}


/*=================================================================
JetTerm

Description:
  This function terminates the current instance of the Jet engine.
  If DS instancing is in use, the instance data segment is released.

Parameters: None

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings: from ErrIsamTerm

Side Effects: Releases the instance data segment if necessary.
=================================================================*/

JET_ERR JET_API JetTerm( JET_INSTANCE instance )
	{
	return JetTerm2( instance, JET_bitTermAbrupt );
	}


BOOL	fTermInProgress = fFalse;
int		cSessionInJetAPI = 0;
#define fSTInitNotDone	0
extern BOOL fSTInit;				/* Flag indicate if isam is initialized or terminated. */

JET_ERR JET_API JetTerm2( JET_INSTANCE instance, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;

	if ( critJet == NULL )
		{
		APIInitEnter();
		Assert( cSessionInJetAPI == 1 );
		}
	else
		{
		APIEnter();
		Assert( cSessionInJetAPI >= 1 );
		}

	fTermInProgress = fTrue;

	Assert( cSessionInJetAPI >= 1 );

	while ( cSessionInJetAPI > 1 )
		{
		/*	session still active
		/**/
		UtilLeaveCriticalSection( critJet );
		UtilSleep( 100 );
		UtilEnterCriticalSection( critJet );
		}
		
	Assert( fJetInitialized || err == JET_errSuccess );

	Assert( cSessionInJetAPI == 1 );

	if ( fJetInitialized )
		{
		/*	backup not allowed during/after termination
		/**/
		fBackupAllowed = fFalse;

		err = ErrIsamTerm( grbit );

		Assert( cSessionInJetAPI == 1 );

		if ( fSTInit == fSTInitNotDone )
			{
			UtilTerm();

			Assert( cSessionInJetAPI == 1 );

			fJetInitialized = fFalse;
			}
		}
		
	fTermInProgress = fFalse;
	
	APITermReturn( err );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\gmem.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */


#define	cbMemoryPage	( (LONG) siSystemConfig.dwPageSize )


static CRIT critMem = NULL;

#ifdef DEBUG

typedef struct {
	INT	cresAlloc;
	INT	cresAllocMax;
	} RS;

static RS rgrs[iresMax];

#ifdef MEM_CHECK
LOCAL VOID MEMCheckFound( INT ires )
	{		
	INT		iresi;

	for ( iresi = 0; iresi < rgres[ires].iblockCommit; iresi++ )
		{
		BYTE 	*pb = (BYTE *)rgres[ires].pbAlloc + (iresi * rgres[ires].cbSize);
		BYTE	*pbT;
		BOOL	fFound = fFalse;

		for( pbT = (BYTE *)rgres[ires].pbAvail;
			pbT != NULL;
			pbT = *(BYTE **)pbT )
			{
			if ( pbT == pb )
				{
				fFound = fTrue;
				break;
				}
			}
		Assert( fFound );
		}
	}

		
LOCAL INT CblockMEMCount( INT ires )
	{
	INT		ipb;
	BYTE	*pb;

	for( pb = rgres[ires].pbAvail, ipb = 0;
		pb != NULL;
		pb = *( BYTE**)pb, ipb++ );
	return ipb;
	}


VOID MEMCheck( VOID )
	{
	INT	ires;

	for ( ires = 0; ires < iresLinkedMax; ires++ )
		{
		Assert( rgres[ires].iblockCommit == rgres[ires].cblockAvail );
		if ( rgres[ires].iblockCommit != rgres[ires].cblockAvail )
			{
			MEMCheckFound( ires );
			}
		}
	}
#endif


VOID MEMStat( INT ires, BOOL fAlloc )
	{
	Assert( ires < iresMax );

	if ( fAlloc )
		{
		rgrs[ires].cresAlloc++;
		if ( rgrs[ires].cresAlloc > rgrs[ires].cresAllocMax )
			{
			rgrs[ires].cresAllocMax = rgrs[ires].cresAlloc;
			}
		}
	else
		{
		rgrs[ires].cresAlloc--;
		}
	}


VOID MEMPrintStat( VOID )
	{
	INT		ires;
	CHAR	*sz;

	if ( ( sz = GetDebugEnvValue( szVerbose ) ) != NULL )
		{
		for ( ires = 0; ires < iresMax; ires++ )
			{
			PrintF( "%d resource %d allocated %d peak allocation.\n",
				ires, rgrs[ires].cresAlloc, rgrs[ires].cresAllocMax );
			}

		SFree( sz );
		}
	}
#endif /* DEBUG */


ERR ErrMEMInit( VOID )
	{
	ERR		err = JET_errSuccess;
	INT		ires;

	CallR( SgErrInitializeCriticalSection( &critMem ) );

#ifdef DEBUG
	memset( rgrs, '\0', sizeof(rgrs) );
#endif

	/* allocate space for system resources
	/**/
	for ( ires = 0; ires < iresLinkedMax; ires++ )
		{
		/*	the size of the allocated resource should be on a 32-byte boundary,
		/*	for cache locality.
		/**/
#ifdef PCACHE_OPTIMIZATION
		Assert( rgres[ires].cbSize == 16 || rgres[ires].cbSize % 32 == 0 );
#endif
		rgres[ires].pbAlloc = PvUtilAlloc( (ULONG)rgres[ires].cblockAlloc * (USHORT)rgres[ires].cbSize );
		/*	if try to allocate more than zero and fail then out of memory
		/**/
		if ( rgres[ires].pbAlloc == NULL && rgres[ires].cblockAlloc > 0 )
			{
			INT iresT;

			for ( iresT = 0; iresT < ires; iresT++ )
				{
				UtilFree( rgres[iresT].pbAlloc );
				}

			return ErrERRCheck( JET_errOutOfMemory );
			}
#ifdef PCACHE_OPTIMIZATION
		Assert( ( (ULONG_PTR) rgres[ires].pbAlloc & 31 ) == 0 );
#endif

		rgres[ires].pbAvail = NULL;
		rgres[ires].cblockAvail = 0;
		rgres[ires].iblockCommit = 0;

		rgres[ires].pbPreferredThreshold =
			rgres[ires].pbAlloc + ( rgres[ires].cblockAlloc * rgres[ires].cbSize );
		}

	return JET_errSuccess;
	}


VOID MEMTerm( VOID )
	{
	INT	ires;

	for ( ires = 0; ires < iresLinkedMax; ires++ )
		{
		/*	size of the allocated reaource should be on a 4-byte boundary, for MIPS
		/**/
#if defined(_MIPS_) || defined(_ALPHA_) || defined(_M_PPC)
		Assert( rgres[ires].cbSize % 4 == 0 );
#endif

		UtilFree( rgres[ires].pbAlloc );
		rgres[ires].pbAlloc = NULL;
//		rgres[ires].cblockAlloc = 0;
		rgres[ires].pbAvail = NULL;
		rgres[ires].cblockAvail = 0;
		rgres[ires].iblockCommit = 0;
		}

	SgDeleteCriticalSection( critMem );
	critMem = NULL;

	return;
	}


BYTE *PbMEMAlloc( INT ires )
	{
	BYTE	*pb;

	Assert( ires < iresLinkedMax );

#ifdef RFS2
	switch ( ires )
		{
		case iresCSR:
			if (!RFSAlloc( CSRAllocResource ) )
				return NULL;
			break;
		case iresFCB:
			if (!RFSAlloc( FCBAllocResource ) )
				return NULL;
			break;
		case iresFUCB:
			if (!RFSAlloc( FUCBAllocResource ) )
				return NULL;
			break;
		case iresIDB:
			if (!RFSAlloc( IDBAllocResource ) )
				return NULL;
			break;
		case iresPIB:
			if (!RFSAlloc( PIBAllocResource ) )
				return NULL;
			break;
		case iresSCB:
			if (!RFSAlloc( SCBAllocResource ) )
				return NULL;
			break;
		case iresVER:
			if (!RFSAlloc( VERAllocResource ) )
				return NULL;
			break;
		case iresDAB:
			if (!RFSAlloc( DABAllocResource ) )
				return NULL;
			break;
		default:
			if (!RFSAlloc( UnknownAllocResource ) )
				return NULL;
			break;
		};
#endif

	SgEnterCriticalSection( critMem );
#ifdef DEBUG
	MEMStat( ires, fTrue );
#endif
	pb = rgres[ires].pbAvail;
	if ( pb != NULL )
		{
		rgres[ires].cblockAvail--;
		rgres[ires].pbAvail = (BYTE *)*(BYTE * UNALIGNED *)pb;
		}

	/*	commit new resource if have uncommitted available
	/**/
	if ( pb == NULL && rgres[ires].iblockCommit < rgres[ires].cblockAlloc )
		{
		INT	cblock = 1;

		/*	there must be at least 1 block left
		/**/
		Assert( rgres[ires].cblockAlloc > rgres[ires].iblockCommit );

		if ( rgres[ires].cbSize < cbMemoryPage )
			{
			/*	commit one pages of memory at a time
			/**/
			cblock = ( ( ( ( ( ( rgres[ires].iblockCommit * rgres[ires].cbSize ) + cbMemoryPage - 1 )
				/ cbMemoryPage ) + 1 ) * cbMemoryPage )
				/ rgres[ires].cbSize ) - rgres[ires].iblockCommit;
			Assert( cblock > 0 && cblock <= (LONG) ( cbMemoryPage/sizeof(BYTE *) ) );
			if ( cblock > rgres[ires].cblockAlloc - rgres[ires].iblockCommit )
				cblock = rgres[ires].cblockAlloc - rgres[ires].iblockCommit;
			}

#ifdef MEM_CHECK
		cblock = 1;
#endif

		pb = rgres[ires].pbAlloc + ( rgres[ires].iblockCommit * rgres[ires].cbSize );
			
		if ( PvUtilCommit( pb, cblock * rgres[ires].cbSize ) == NULL )
			{
			pb = NULL;
			}
		else
			{
			rgres[ires].iblockCommit += cblock;

			/*	if surplus blocks, then link to resource
			/**/
			if ( cblock > 1 )
				{
				BYTE	*pbLink = pb + rgres[ires].cbSize;
				BYTE	*pbLinkMax = pb + ( ( cblock - 1 ) * rgres[ires].cbSize );

				Assert( rgres[ires].pbAvail == NULL );
				rgres[ires].pbAvail = pbLink;
				rgres[ires].cblockAvail += cblock - 1;

				/*	link surplus blocks into resource free list
				/**/
				for ( ; pbLink < pbLinkMax; pbLink += rgres[ires].cbSize )
					{
					*(BYTE * UNALIGNED *)pbLink = pbLink + rgres[ires].cbSize;
					}
				*(BYTE * UNALIGNED *)pbLink = NULL;
				}
			}
		}
	
	SgLeaveCriticalSection( critMem );

#ifdef DEBUG
	/*	for setting break point:
	/**/
	if ( pb == NULL )
		pb = NULL;
	else
		{
		/*	set resource space to 0xff
		/**/
		memset( pb, (CHAR)0xff, rgres[ires].cbSize );
		}
#endif

	return pb;
	}


VOID MEMRelease( INT ires, BYTE *pb )
	{
	Assert( ires < iresLinkedMax );

#ifdef DEBUG
	memset( pb, (CHAR)0xff, rgres[ires].cbSize );
#endif

	SgEnterCriticalSection( critMem );

	rgres[ires].cblockAvail++;
#ifdef DEBUG
	MEMStat( ires, fFalse );
#endif

	if ( pb >= rgres[ires].pbPreferredThreshold )
		{
		BYTE	*pbT;
		BYTE	*pbLast = NULL;

		Assert( pb < rgres[ires].pbAlloc + ( rgres[ires].cblockAlloc * rgres[ires].cbSize ) );

		// We need to ensure that we first re-use resources below the
		// preferred threshold.
		for ( pbT = rgres[ires].pbAvail;
			pbT != NULL  &&  pbT < rgres[ires].pbPreferredThreshold;
			pbT = *(BYTE * UNALIGNED *)pbT )
			{
			pbLast = pbT;
			}
			
		*(BYTE * UNALIGNED *)pb = pbT;
		
		if ( pbLast != NULL )
			{
			Assert( *(BYTE * UNALIGNED *)pbLast == pbT );
			*(BYTE * UNALIGNED *)pbLast = pb;
			}
		else
			{
			Assert( rgres[ires].pbAvail == pbT );
			rgres[ires].pbAvail = pb;
			}
		}
	else
		{
		*(BYTE * UNALIGNED *)pb = rgres[ires].pbAvail;
		rgres[ires].pbAvail = pb;
		}
	
	SgLeaveCriticalSection( critMem );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\jetmsg.c ===
#include "std.h"

/*	entry point for message DLL
/**/
INT APIENTRY LibMain( HANDLE hDLL, DWORD dwReason, LPVOID lpReserved )
	{
    /*	parameters are ignored
	/**/
    (VOID)hDLL;
    (VOID)dwReason;
    (VOID)lpReserved;

    /*	needs to return true indicating success when 
    /*	dwReson= DLL_PROCESS_ATTACH
	/**/
    return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\jetstr.c ===
#include "std.h"

/*** System object names (non-table) ***/

CODECONST(char) szTcObject[]	= "Tables";
CODECONST(char) szDcObject[]	= "Databases";
CODECONST(char) szDbObject[]	= "MSysDb";

/*** System table names ***/

CODECONST(char) szSoTable[]		= "MSysObjects";
CODECONST(char) szScTable[]		= "MSysColumns";
CODECONST(char) szSiTable[]		= "MSysIndexes";
CODECONST(char) szSqTable[]		= "MSysQueries";
CODECONST(char) szSrTable[]		= "MSysRelationships";

/*** System table index names ***/

CODECONST(char) szSoNameIndex[]				= "ParentIdName";
CODECONST(char) szSoIdIndex[]				= "Id";
CODECONST(char) szScObjectIdNameIndex[]		= "ObjectIdName";
CODECONST(char) szSiObjectIdNameIndex[]		= "ObjectIdName";

/*** System table column names ***/

CODECONST(char) szSoIdColumn[]				= "Id";
CODECONST(char) szSoParentIdColumn[]		= "ParentId";
CODECONST(char) szSoObjectNameColumn[]		= "Name";
CODECONST(char) szSoObjectTypeColumn[]		= "Type";
CODECONST(char) szSoDateUpdateColumn[]		= "DateUpdate";
CODECONST(char) szSoDateCreateColumn[]		= "DateCreate";
CODECONST(char) szSoLvColumn[]				= "Lv";
CODECONST(char) szSoDatabaseColumn[]		= "Database";
CODECONST(char) szSoConnectColumn[]			= "Connect";
CODECONST(char) szSoForeignNameColumn[] 	= "ForeignName";
CODECONST(char) szSoFlagsColumn[]			= "Flags";
CODECONST(char) szSoPresentationOrder[]		= "PresentationOrder";

CODECONST(char) szSiObjectNameColumn[]		= "Name";
CODECONST(char) szSiIdColumn[]				= "ObjectId";
CODECONST(char)	szSiIndexIdColumn[]			= "IndexId";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\jetperf.c ===
#include "std.h"
#include "version.h"


	/*  Performance Monitoring support
	/*
	/*  Status information is reported to the Event Log in the PERFORMANCE_CATEGORY
	/**/

#include "perfutil.h"


	/*  function prototypes (to keep __stdcall happy)  */
	
DWORD APIENTRY OpenPerformanceData(LPWSTR);
DWORD APIENTRY CollectPerformanceData(LPWSTR, LPVOID *, LPDWORD, LPDWORD);
DWORD APIENTRY ClosePerformanceData(void);

	/*  OpenPerformanceData() is an export that is called when another application
	/*  wishes to start fetching performance data from this DLL.  Any initializations
	/*  that need to be done on the first or subsequent opens are done here.
	/*
	/**/

DWORD dwOpenCount = 0;
DWORD dwFirstCounter;
DWORD dwFirstHelp;
BOOL fTemplateDataInitialized = fFalse;
DWORD cbMaxCounterBlockSize;
DWORD cbInstanceSize;

DWORD APIENTRY OpenPerformanceData(LPWSTR lpwszDeviceNames)
{
	HKEY hkeyPerf = (HKEY)(-1);
	DWORD err;
	DWORD Type;
	LPBYTE lpbData;
	PPERF_OBJECT_TYPE ppotObjectSrc;
	PPERF_INSTANCE_DEFINITION ppidInstanceSrc;
	PPERF_COUNTER_DEFINITION ppcdCounterSrc;
	DWORD dwCurObj;
	DWORD dwCurCtr;
	DWORD dwMinDetailLevel;
	DWORD dwOffset;
	PSDA psda;

	if (!dwOpenCount)
	{
			/*  perform first open initializations  */

			/*  initialize system layer  */

		if ((err = DwPerfUtilInit()) != ERROR_SUCCESS)
			goto HandleFirstOpenError;

			/*  initialize collect count  */

		psda = (PSDA)pvPERFSharedData;
		psda->cCollect = 0;
			
			/*  initialize template data if not initialized  */

		if (!fTemplateDataInitialized)
		{
				/*  retrieve counter/help ordinals from the registry  */

			if ((err = DwPerfUtilRegOpenKeyEx(
					HKEY_LOCAL_MACHINE,
					"SYSTEM\\CurrentControlSet\\Services\\" szVerName "\\Performance",
					&hkeyPerf)) != ERROR_SUCCESS)
	  		{
#ifdef DEBUG
				PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,"Not installed.");
#endif
				goto HandleFirstOpenError;
	  		}

			err = DwPerfUtilRegQueryValueEx(hkeyPerf,"First Counter",&Type,&lpbData);
			if (err != ERROR_SUCCESS || Type != REG_DWORD) 
			{
#ifdef DEBUG
				PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,"Installation corrupt.");
#endif
				goto HandleFirstOpenError;
			}
			else
			{
				dwFirstCounter = *((DWORD *)lpbData);
				free(lpbData);
			}

			err = DwPerfUtilRegQueryValueEx(hkeyPerf,"First Help",&Type,&lpbData);
			if (err != ERROR_SUCCESS || Type != REG_DWORD) 
			{
#ifdef DEBUG
				PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,"Installation corrupt.");
#endif
				goto HandleFirstOpenError;
			}
			else
			{
				dwFirstHelp = *((DWORD *)lpbData);
				free(lpbData);
			}

			(VOID)DwPerfUtilRegCloseKeyEx(hkeyPerf);
			hkeyPerf = (HKEY)(-1);

				/*  initialize template data  */
				
			ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
			ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->DefinitionLength);
			cbMaxCounterBlockSize = sizeof(PERF_COUNTER_BLOCK);
			for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			{
					/*  update name/help ordinals for object  */
					
				ppotObjectSrc->ObjectNameTitleIndex += dwFirstCounter;
				ppotObjectSrc->ObjectHelpTitleIndex += dwFirstHelp;

				ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->HeaderLength);
				dwMinDetailLevel = PERF_DETAIL_NOVICE;
				dwOffset = sizeof(PERF_COUNTER_BLOCK);
				for (dwCurCtr = 0; dwCurCtr < ppotObjectSrc->NumCounters; dwCurCtr++)
				{
						/*  update name/help ordinals for counter  */
						
					ppcdCounterSrc->CounterNameTitleIndex += dwFirstCounter;
					ppcdCounterSrc->CounterHelpTitleIndex += dwFirstHelp;

						/*  get minimum detail level of counters  */

					dwMinDetailLevel = min(dwMinDetailLevel,ppcdCounterSrc->DetailLevel);

						/*  update counter's data offset value  */

					ppcdCounterSrc->CounterOffset = dwOffset;
					dwOffset += ppcdCounterSrc->CounterSize;
					
					ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppcdCounterSrc + ppcdCounterSrc->ByteLength);
				}

					/*  set object's detail level as the minimum of all its counter's detail levels  */

				ppotObjectSrc->DetailLevel = dwMinDetailLevel;

					/*  keep track of the max counter block size  */

				cbMaxCounterBlockSize = max(cbMaxCounterBlockSize,dwOffset);
				
				ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc + ppotObjectSrc->TotalByteLength);
			}
			cbInstanceSize = ppidInstanceSrc->ByteLength + cbMaxCounterBlockSize;

			fTemplateDataInitialized = fTrue;
		}
	}

		/*  perform per open initializations  */

	;

		/*  all initialization succeeded  */

	dwOpenCount++;
	
#ifdef DEBUG
//	sprintf(szDescr,"Opened successfully.  Open Count = %ld.",dwOpenCount);
//	PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_INFORMATION_TYPE,szDescr);
#endif
	
	return ERROR_SUCCESS;

		/*  Error Handlers  */

/*HandlePerOpenError:*/

HandleFirstOpenError:

	if (hkeyPerf != (HKEY)(-1))
		(VOID)DwPerfUtilRegCloseKeyEx(hkeyPerf);

#ifdef DEBUG
	{
	CHAR szDescr[256];
	sprintf(szDescr,"Open attempt failed!  Open Count = %ld.",dwOpenCount);
	PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,szDescr);
	}
#endif
	
	PerfUtilTerm();

	return ERROR_OPEN_FAILED;
}


	/*  CollectPerformanceData() is an export that is called by another application to
	/*  collect performance data from this DLL.  A list of the desired data is passed in
	/*  and the requested data is returned ASAP in the caller's buffer.
	/*
	/*  NOTE:  because we are multithreaded, locks must be used in order to update or
	/*  read any performance information in order to avoid reporting bad results.
	/*
	/**/

WCHAR wszDelim[] = L"\n\r\t\v ";
WCHAR wszForeign[] = L"Foreign";
WCHAR wszGlobal[] = L"Global";
WCHAR wszCostly[] = L"Costly";

DWORD APIENTRY CollectPerformanceData(
	LPWSTR  lpwszValueName,
	LPVOID  *lppData,
	LPDWORD lpcbTotalBytes,
	LPDWORD lpNumObjectTypes)
{
	LPWSTR lpwszValue = NULL;
	LPWSTR lpwszTok;
	BOOL fNoObjFound;
	DWORD dwIndex;
	DWORD cbBufferSize;
	PPERF_OBJECT_TYPE ppotObjectSrc;
	PPERF_OBJECT_TYPE ppotObjectDest;
	PPERF_INSTANCE_DEFINITION ppidInstanceSrc;
	PPERF_INSTANCE_DEFINITION ppidInstanceDest;
	PPERF_COUNTER_BLOCK ppcbCounterBlockDest;
	DWORD dwCurObj;
	DWORD dwCurInst;
	PSDA psda = (PSDA)pvPERFSharedData;
	DWORD cInstances;
	long iBlock;
	long lCount;
//	char szT[256];
//
//	char *rgsz[3];
//
//	memset( *lppData, 0xFF, *lpcbTotalBytes );

		/*  no data if OpenPerformanceData() was never called  */

	if ( !lpwszValueName || !dwOpenCount)
	{
ReturnNoData:
		if (lpwszValue)
			free(lpwszValue);	
	    *lpcbTotalBytes = 0;
	    *lpNumObjectTypes = 0;
	    
		 return ERROR_SUCCESS;
	}
		
		/*  make our own copy of the value string for tokenization and
		/*  get the first token
		/**/

	if (!(lpwszValue = malloc((wcslen(lpwszValueName)+1)*sizeof(WCHAR))))
		goto ReturnNoData;
	lpwszTok = wcstok(wcscpy(lpwszValue,lpwszValueName),wszDelim);
	if ( !lpwszTok )
		{
		goto ReturnNoData;
		}

		/*  we don't support foreign computer data requests  */

	if (!wcscmp(lpwszTok,wszForeign))  /*  lpwszTok == wszForeign  */
		goto ReturnNoData;

		/*  if none of our objects are in the value list, return no data  */

	if (wcscmp(lpwszTok,wszGlobal) && wcscmp(lpwszTok,wszCostly))  /*  lpwszTok != wszGlobal || lpwszTok != wszCostly  */
	{
		fNoObjFound = fTrue;
		do
		{
			dwIndex = (DWORD)wcstoul(lpwszTok,NULL,10)-dwFirstCounter;
			if (dwIndex <= dwPERFMaxIndex)
			{
				fNoObjFound = fFalse;
				break;
			}
		}
		while (lpwszTok = wcstok(NULL,wszDelim));

		if (fNoObjFound)
			goto ReturnNoData;
	}

		/*  grab instance mutex to lock out other instances of this dll  */
		
	WaitForSingleObject(hPERFInstanceMutex,INFINITE);

		/*  delay init or term of instances of JET until collection is done  */
	
	WaitForSingleObject(hPERFNewProcMutex,INFINITE);
		
		/*  initialize shared data area for data collection  */

	WaitForSingleObject(hPERFProcCountSem,INFINITE);
	ReleaseSemaphore(hPERFProcCountSem,1,&lCount);
	
	WaitForSingleObject(hPERFSharedDataMutex,INFINITE);

	psda->cCollect++;
	psda->dwProcCount = (DWORD)(PERF_INIT_INST_COUNT-(lCount+1));
	psda->iNextBlock = 0;
	psda->cbAvail = PERF_SIZEOF_SHARED_DATA - sizeof(SDA);
	psda->ibTop = PERF_SIZEOF_SHARED_DATA;
	
	ReleaseMutex(hPERFSharedDataMutex);
	
		/*  if instances of the main dll are active, send Collect event and wait for Done event  */

	if (psda->dwProcCount)
	{
//		sprintf(szT,"Releasing %ld instances of JET...",psda->dwProcCount);
//		PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_INFORMATION_TYPE,szT);
		ReleaseSemaphore(hPERFCollectSem,psda->dwProcCount,NULL);
		if (WaitForSingleObject(hPERFDoneEvent,15000) == WAIT_TIMEOUT)
		{
#ifdef DEBUG
			PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_WARNING_TYPE,"At least one collection thread hung/went away.");
#endif
			while (WaitForSingleObject(hPERFCollectSem,0) == WAIT_OBJECT_0);  //  flush semaphore
		}
		
			/*  if dwProcCount > 0 at this point, some processes have gone away, so subtract
			/*  them from the process count semaphore
			/**/

		if (psda->dwProcCount)
		{
			ReleaseSemaphore(hPERFProcCountSem,psda->dwProcCount,NULL);
			while (WaitForSingleObject(hPERFCollectSem,0) == WAIT_OBJECT_0);  //  flush semaphore
		}
	}

		/*  allow JET instances to continue init or term  */

	ReleaseMutex(hPERFNewProcMutex);

	/*****************************************************************************************
	/*
	/*  NOTE!  This has been designed so that if NO instances of the main DLL are found, the
	/*  buffer filling routines will fill the buffer correctly as if each object has ZERO
	/*  instances (which is permitted).  This is mainly done by having each of the instance
	/*  loops fail on entry because psda->iNextBlock will be ZERO.
	/*
	/****************************************************************************************/
	
		/*  convert Block Offsets to be 0 relative (a.k.a. true pointers)
		/*
		/*  Aaaaahhhhh...  Flat Map Memory Model!
		/**/

	for (iBlock = (long)psda->iNextBlock-1; iBlock >= 0; iBlock--)
		psda->ibBlockOffset[iBlock] += (DWORD)pvPERFSharedData;

    	/*  all data has been collected, so fill the buffer with it and return it.
    	/*  if we happen to run out of space along the way, we will stop building
    	/*  and request more buffer space for next time.
    	/**/

	ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
	ppotObjectDest = (PPERF_OBJECT_TYPE)*lppData;
	for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
	{
			/*  if the end of this object goes past the buffer, we're out of space  */

		if (((char *)ppotObjectDest - (char *)*lppData) + ppotObjectSrc->DefinitionLength > *lpcbTotalBytes)
			goto NeedMoreData;

			/*  copy current object's template data to buffer  */

		memcpy((void *)ppotObjectDest,(void *)ppotObjectSrc,ppotObjectSrc->DefinitionLength);
	
			/*  update the object's TotalByteLength and NumInstances to include instances  */

		for (iBlock = (long)psda->iNextBlock-1; iBlock >= 0; iBlock--)
			ppotObjectDest->NumInstances += *((DWORD *)psda->ibBlockOffset[iBlock]);
		ppotObjectDest->TotalByteLength += cbMaxCounterBlockSize + (ppotObjectDest->NumInstances-1)*cbInstanceSize;

			/*  if there are no instances, append a counter block to the object definition  */
		
		if (!ppotObjectDest->NumInstances)
			ppotObjectDest->TotalByteLength += cbMaxCounterBlockSize;

			/*  if the end of this object goes past the buffer, we're out of space  */

		if (((char *)ppotObjectDest - (char *)*lppData) + ppotObjectDest->TotalByteLength > *lpcbTotalBytes)
			goto NeedMoreData;
	
			/*  collect all instances for all processes  */

		ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectDest + ppotObjectDest->DefinitionLength);
		for (iBlock = (long)psda->iNextBlock-1; iBlock >= 0; iBlock--)
		{
				/*  copy all instance data for the current object for this process  */

			cInstances = *((DWORD *)psda->ibBlockOffset[iBlock]);
			ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)(psda->ibBlockOffset[iBlock] + sizeof(DWORD));
			memcpy((void *)ppidInstanceDest,(void *)ppidInstanceSrc,cbInstanceSize * cInstances);

				/*  update the instance's data fields  */

			for (dwCurInst = 0; dwCurInst < cInstances; dwCurInst++)
			{
					/*  if this is not the root object, setup instance hierarchy information  */
					
				if (dwCurObj)
				{
					ppidInstanceDest->ParentObjectTitleIndex = ((PPERF_OBJECT_TYPE)pvPERFDataTemplate)->ObjectNameTitleIndex;
					ppidInstanceDest->ParentObjectInstance = (long)psda->iNextBlock-1-iBlock;
				}
					
				ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)ppidInstanceDest+cbInstanceSize);
			}

				/*  increment block offset past used instances  */

			psda->ibBlockOffset[iBlock] += sizeof(DWORD) + cbInstanceSize * cInstances;
		}

			/*  if there are no instances, zero the counter block  */

		if (!ppotObjectDest->NumInstances)
		{
			ppcbCounterBlockDest = (PPERF_COUNTER_BLOCK)((char *)ppotObjectDest + ppotObjectDest->DefinitionLength);
			memset((void *)ppcbCounterBlockDest,0,cbMaxCounterBlockSize);
			ppcbCounterBlockDest->ByteLength = cbMaxCounterBlockSize;
		}
		
		ppotObjectDest = (PPERF_OBJECT_TYPE)((char *)ppotObjectDest+ppotObjectDest->TotalByteLength);
		ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc+ppotObjectSrc->TotalByteLength);
	}

	cbBufferSize = (char *)ppotObjectDest - (char *)*lppData;
//	Assert( cbBufferSize <= *lpcbTotalBytes );

//	sprintf(	szT,
//				"Data collected starting at 0x%lX with length 0x%lX (0x100 bytes after our data are displayed).  "
//				"We were given 0x%lX bytes of buffer.",
//				*lppData,
//				cbBufferSize,
//				*lpcbTotalBytes );
//	
//	rgsz[0]	= "";
//	rgsz[1] = "";
//	rgsz[2]	= szT;
//	
//	ReportEvent(
//		hOurEventSource,
//		EVENTLOG_ERROR_TYPE,
//		(WORD)PERFORMANCE_CATEGORY,
//		PLAIN_TEXT_ID,
//		0,
//		3,
//		cbBufferSize + 256,
//		rgsz,
//		*lppData );
			
	free(lpwszValue);	
	*lppData = (void *)ppotObjectDest;
	*lpcbTotalBytes = cbBufferSize;
	*lpNumObjectTypes = dwPERFNumObjects;
	
	ReleaseMutex(hPERFInstanceMutex);
	return ERROR_SUCCESS;

NeedMoreData:

	free(lpwszValue);	
    *lpcbTotalBytes = 0;
    *lpNumObjectTypes = 0;
    
	ReleaseMutex(hPERFInstanceMutex);
	return ERROR_MORE_DATA;
}


	/*  ClosePerformanceData() is an export that is called by another application when
	/*  it no longer desires performance data.  Per application or final termination
	/*  code for the performance routines can be performed here.
	/*
	/**/

DWORD APIENTRY ClosePerformanceData(void)
{
	if (!dwOpenCount)
		return ERROR_SUCCESS;

	dwOpenCount--;
	
		/*  perform per close termination  */

	;

		/*  perform final close termination  */

	if (!dwOpenCount)
	{
		;
	}

		/*  log closing  */
	
#ifdef DEBUG
//	{	
//	CHAR szDescr[256];
//	sprintf(szDescr,"Closed successfully.  Open Count = %ld.",dwOpenCount);
//	PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_INFORMATION_TYPE,szDescr);
//	}
#endif

		/*  shut down system layer  */

	if (!dwOpenCount)
	{
		PerfUtilTerm();
	}
	
	return ERROR_SUCCESS;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\io.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */


/******************************************************************/
/*				Database Record Routine                           */
/******************************************************************/


FMP	*rgfmp;						/* database file map */

/*	ErrIOLockDbidByNameSz returns the dbid of the database with the
/*	given name or 0 if there is no database with the given name.
/**/
ERR ErrIOLockDbidByNameSz( CHAR *szFileName, DBID *pdbid )
	{
	ERR		err;
	DBID	dbid;

	err = JET_errDatabaseNotFound;
	dbid = dbidMin;
	SgEnterCriticalSection( critBuf );
	while ( dbid < dbidMax )
		{
		if ( rgfmp[dbid].szDatabaseName != pbNil &&
			UtilCmpName( szFileName, rgfmp[dbid].szDatabaseName ) == 0 )
			{
			if ( ( FDBIDWait(dbid) ) )
				{
				SgLeaveCriticalSection( critBuf );
				BFSleep( cmsecWaitGeneric );
				SgEnterCriticalSection( critBuf );
				dbid = dbidMin;
				}
			else
				{
				*pdbid = dbid;
				DBIDSetWait( dbid );
				err = JET_errSuccess;
				break;
				}
			}
		else
			dbid++;
		}
	SgLeaveCriticalSection( critBuf );

	Assert( err == JET_errSuccess  ||  err == JET_errDatabaseNotFound );

#ifdef DEBUG
	return ( err == JET_errSuccess ? JET_errSuccess : ErrERRCheck( JET_errDatabaseNotFound ) );
#else
	return err;
#endif
	}


/*
 *	Used in initialization and detach to lock database entries from dbid.
 */
ERR ErrIOLockDbidByDbid( DBID dbid )
	{
	forever
		{
		SgEnterCriticalSection( critBuf );
		if ( !( FDBIDWait(dbid) ) )
			{
			DBIDSetWait( dbid );
			break;
			}
		SgLeaveCriticalSection( critBuf );
		BFSleep( cmsecWaitGeneric );
		}
	SgLeaveCriticalSection( critBuf );
	return JET_errSuccess;
	}


/*
 *	ErrIOLockNewDbid( DBID *pdbid, CHAR *szDatabaseName )
 *
 *	ErrIOLockNewDbid returns JET_errSuccess and sets *pdbid to the index
 *	of a free file table entry or returns TooManyOpenDatabases if every
 *	entry is used with a positive reference count.  If the given name
 *	is found in the file map, even if it is in the process of being
 *	detached, JET_wrnAlreadyAttached is returned.
 *	
 *	Available entries are determined by their names being set to
 *	NULL.  All database record fields are reset.  The wait flag is
 *	set to prevent the database from being opened before creation or
 *	attachment is complete.	
 */
ERR ErrIOLockNewDbid( DBID *pdbid, CHAR *szDatabaseName )
	{
	ERR		err = JET_errSuccess;
	DBID	dbid;
	BYTE	*pb;
	
	/* look for unused file map entry
	/**/
	SgEnterCriticalSection( critBuf );
	for ( dbid = dbidMin; dbid < dbidMax; dbid++ )
		{
		/*	critBuf guards rgfmp[*].szDatabaseName, fWait guards
		/*	file handle.  Therefore, only need critBuf to compare
		/*	all database names, even those with fWait set
		/**/
		if ( rgfmp[dbid].szDatabaseName != NULL &&
			UtilCmpName( rgfmp[dbid].szDatabaseName, szDatabaseName) == 0 )
			{
#ifdef REUSE_DBID
			if ( FDBIDAttached( dbid ) || FDBIDWait( dbid ) )
				{
				err = ErrERRCheck( JET_wrnDatabaseAttached );
				}
			else
				{
				/*	if find same name, then return warning with same dbid.
				/**/
				DBIDSetWait( dbid );
				Assert( !( FDBIDExclusive( dbid ) ) );
				*pdbid = dbid;
				}
#else
			err = ErrERRCheck( JET_wrnDatabaseAttached );
#endif
			goto HandleError;
			}
		}

	for ( dbid = dbidMin; dbid < dbidMax; dbid++ )
		{
		if ( rgfmp[dbid].szDatabaseName == pbNil )
			{
			pb = SAlloc(strlen(szDatabaseName) + 1);
			if ( pb == NULL )
				{
				err = ErrERRCheck( JET_errOutOfMemory );
				goto HandleError;
				}

			rgfmp[dbid].szDatabaseName = pb;
			strcpy( rgfmp[dbid].szDatabaseName, szDatabaseName );

			DBIDSetWait( dbid );
			DBIDResetExclusive( dbid );
			*pdbid = dbid;
			err = JET_errSuccess;
			goto HandleError;
			}
		}

	err = ErrERRCheck( JET_errTooManyAttachedDatabases );

HandleError:
	SgLeaveCriticalSection( critBuf );
	return err;
	}


/*
 *	ErrIOSetDbid( DBID dbid, CHAR *szDatabaseName )
 *
 *	ErrIOSetDbid sets the database record for dbid to the given name
 *	and initializes the record.  Used only in system initialization.
 */

ERR ErrIOSetDbid( DBID dbid, CHAR *szDatabaseName )
	{
	ERR		err;
	BYTE	*pb;

	Assert( HfFMPOfDbid(dbid) == handleNil );
	Assert( rgfmp[dbid].szDatabaseName == NULL );
	pb = SAlloc(strlen(szDatabaseName) + 1);
	if ( pb == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}
	rgfmp[dbid].szDatabaseName = pb;
	strcpy( rgfmp[dbid].szDatabaseName, szDatabaseName );
	DBIDResetWait( dbid );
	DBIDResetExclusive( dbid );

	err = JET_errSuccess;
	
HandleError:
	return err;
	}


/*
 *	IOFreeDbid( DBID dbid )
 *
 *	IOFreeDbid frees memory allocated for database name and sets
 *	database name to NULL.  Note, no other fields are reset.  This
 *	must be done when an entry is selected for reuse.
 */

VOID IOFreeDbid( DBID dbid )
	{
	SgEnterCriticalSection( critBuf );
	if ( rgfmp[dbid].szDatabaseName != NULL )
		{
		SFree( rgfmp[dbid].szDatabaseName );
		}

	rgfmp[dbid].szDatabaseName = NULL;
	SgLeaveCriticalSection( critBuf );
	}


/*
 *	FIODatabaseInUse returns fTrue if database is
 *	opened by one or more users.  If no user has the database open,
 *	then the database record fWait flag is set and fFalse is
 *	returned.
 */
BOOL FIODatabaseInUse( DBID dbid )
	{
	PIB *ppibT;

	SgEnterCriticalSection( critBuf );
	ppibT = ppibGlobal;
	while ( ppibT != ppibNil )
		{
		if ( FUserOpenedDatabase( ppibT, dbid ) )
				{
				SgLeaveCriticalSection( critBuf );
				return fTrue;
				}
		ppibT = ppibT->ppibNext;
		}

	SgLeaveCriticalSection( critBuf );
	return fFalse;
	}


BOOL FIODatabaseAvailable( DBID dbid )
	{
	BOOL	fAvail;

	SgEnterCriticalSection( critBuf );
	
	fAvail = ( FDBIDAttached(dbid) &&
//		!FDBIDExclusive(dbid) &&
		!FDBIDWait(dbid) );

	SgLeaveCriticalSection( critBuf );

	return fAvail;
	}


/******************************************************************/
/*				IO                                                */
/******************************************************************/

BOOL fGlobalFMPLoaded = fFalse;

ERR ErrFMPInit( )
	{
	ERR		err;
	DBID	dbid;

	/* initialize the file map array */
	rgfmp = (FMP *) LAlloc( (long) dbidMax, sizeof(FMP) );
	if ( !rgfmp )
		return ErrERRCheck( JET_errOutOfMemory );
	
	for ( dbid = 0; dbid < dbidMax; dbid++)
		{
		memset( &rgfmp[dbid], 0, sizeof(FMP) );
		rgfmp[dbid].hf =
		rgfmp[dbid].hfPatch = handleNil;
		rgfmp[dbid].pdbfilehdr = NULL;	/* indicate it is not attached. */

		CallR( ErrInitializeCriticalSection( &rgfmp[dbid].critExtendDB ) );
		CallR( ErrInitializeCriticalSection( &rgfmp[dbid].critCheckPatch ) );
		DBIDResetExtendingDB( dbid );
		}
		
	fGlobalFMPLoaded = fFalse;

	return JET_errSuccess;
	}

	
VOID FMPTerm( )
	{
	INT	dbid;

	for ( dbid = 0; dbid < dbidMax; dbid++ )
		{
		if ( rgfmp[dbid].szDatabaseName )
			SFree( rgfmp[dbid].szDatabaseName );

		if ( rgfmp[dbid].pdbfilehdr )
			UtilFree( (VOID *)rgfmp[dbid].pdbfilehdr );

		if ( rgfmp[dbid].patchchk )
			SFree( rgfmp[dbid].patchchk );

		if ( rgfmp[dbid].szPatchPath )
			SFree( rgfmp[dbid].szPatchPath );

		DeleteCriticalSection( rgfmp[dbid].critExtendDB );
		DeleteCriticalSection( rgfmp[dbid].critCheckPatch );
		}

	/*	free FMP
	/**/
	LFree( rgfmp );
	
	return;
	}


/*
 *	Initilize IO
 */
ERR ErrIOInit( VOID )
	{
	return JET_errSuccess;
	}


/*	go through FMP closing files.
/**/
ERR ErrIOTerm( BOOL fNormal )
	{
	ERR			err;
	DBID		dbid;
	LGPOS		lgposShutDownMarkRec = lgposMin;

	/*	update checkpoint before fmp is cleaned if fGlobalFMPLoaded is true.
	 */
	LeaveCriticalSection( critJet );
	LGUpdateCheckpointFile( fTrue );
	EnterCriticalSection( critJet );

	/*	No more checkpoint update from now on. Now I can safely clean up the
	 *	rgfmp.
	 */
	fGlobalFMPLoaded = fFalse;
	
	/*	Set proper shut down mark.
	 */
	if ( fNormal && !fLogDisabled )
		{
		if ( fRecovering && fRecoveringMode == fRecoveringRedo )
			{
#ifdef DEBUG
			extern LGPOS lgposRedo;

			Assert( (lgposRedo.lGeneration == 1 && lgposRedo.isec == 8 && lgposRedo.ib == 10 ) ||
					CmpLgpos( &lgposRedoShutDownMarkGlobal, &lgposMin ) != 0 );
#endif
			lgposShutDownMarkRec = lgposRedoShutDownMarkGlobal;
			}
		else
			{
			CallR( ErrLGShutDownMark( &lgposShutDownMarkRec ) );
			}
		}

	SgEnterCriticalSection( critBuf );
	for ( dbid = dbidMin; dbid < dbidMax; dbid++ )
		{
		/*	maintain the attach checker.
		 */
		if ( fNormal &&
			 fRecovering && fRecoveringMode == fRecoveringRedo )
			{
			Assert( CmpLgpos( &lgposShutDownMarkRec, &lgposRedoShutDownMarkGlobal ) == 0 );
			if ( rgfmp[dbid].patchchk )
				rgfmp[dbid].patchchk->lgposConsistent = lgposShutDownMarkRec;
			}

		/*	free pdbfilehdr
		 */
		if ( HfFMPOfDbid(dbid) != handleNil )
			{
			IOCloseFile( HfFMPOfDbid(dbid) );
			HfFMPOfDbid(dbid) = handleNil;

			if ( fNormal && dbid != dbidTemp && !rgfmp[dbid].fReadOnly )
				{
				DBFILEHDR *pdbfilehdr = rgfmp[dbid].pdbfilehdr;
				CHAR *szFileName;

				/*	Update database header.
				 */
				pdbfilehdr->fDBState = fDBStateConsistent;
				
				if ( fRecovering )
					{
					FMP *pfmp = &rgfmp[dbid];
					if ( pfmp->pdbfilehdr->bkinfoFullCur.genLow != 0 )
						{
						Assert( pfmp->pdbfilehdr->bkinfoFullCur.genHigh != 0 );
						pfmp->pdbfilehdr->bkinfoFullPrev = pfmp->pdbfilehdr->bkinfoFullCur;
						memset(	&pfmp->pdbfilehdr->bkinfoFullCur, 0, sizeof( BKINFO ) );
						memset(	&pfmp->pdbfilehdr->bkinfoIncPrev, 0, sizeof( BKINFO ) );
						}
					}

				if ( fLogDisabled )
					{
					pdbfilehdr->lgposConsistent = lgposMin;
					}
				else
					{
					pdbfilehdr->lgposConsistent = lgposShutDownMarkRec;
					}
				LGGetDateTime( &pdbfilehdr->logtimeConsistent );
			
				szFileName = rgfmp[dbid].szDatabaseName;
				if ( fRecovering && fHardRestore && dbid != dbidTemp )
					{
					INT irstmap;
					ERR err;

					err = ErrLGGetDestDatabaseName( rgfmp[dbid].szDatabaseName, &irstmap, NULL );
					if ( err == JET_errSuccess && irstmap >= 0 )
						szFileName = rgrstmapGlobal[irstmap].szNewDatabaseName;
					}
				CallR( ErrUtilWriteShadowedHeader(
						szFileName, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) ) );
				}

			if ( rgfmp[dbid].pdbfilehdr )
				{
				UtilFree( (VOID *)rgfmp[dbid].pdbfilehdr );
				rgfmp[dbid].pdbfilehdr = NULL;
				}
			}
//		DeleteCriticalSection( rgfmp[dbid].critExtendDB );
		}
	SgLeaveCriticalSection( critBuf );

#ifdef DEBUG
	lgposRedoShutDownMarkGlobal = lgposMin;
#endif

	return JET_errSuccess;
	}

	
LOCAL ERR ErrIOOpenFile(
	HANDLE	*phf,
	CHAR	*szDatabaseName,
	ULONG	*pul,
	ULONG	*pulHigh )
	{
	ERR err;
	
	err = ErrUtilOpenFile( szDatabaseName, phf, *pul, fFalse, fTrue );
	Assert(	err < 0 ||
			err == JET_wrnFileOpenReadOnly ||
			err == JET_errSuccess );

	if ( err >= JET_errSuccess )
		{
		/*	get file size
		/**/
		ULONG	cbHigh = 0;
		ULONG	cb = 0;
		
		UtilChgFilePtr( *phf, 0, &cbHigh, FILE_END, &cb );
		*pul = cb;
		*pulHigh = cbHigh;
		cbHigh = 0;
		UtilChgFilePtr( *phf, 0, &cbHigh, FILE_BEGIN, &cb );
		Assert( cb == 0 );
		Assert( cbHigh == 0 );
		}
		
	return err;
	}


VOID IOCloseFile( HANDLE hf )
	{
	CallS( ErrUtilCloseFile( hf ) );
	}


BOOL FIOFileExists( CHAR *szFileName )
	{
	ERR		err;
	HANDLE	hf = handleNil;
	ULONG	cb = 0;
	ULONG	cbHigh = 0;

	err = ErrIOOpenFile( &hf, szFileName, &cb, &cbHigh );
	if ( err == JET_errFileNotFound )
		return fFalse;
	if ( hf != handleNil )
		IOCloseFile( hf );
	return fTrue;
	}


ERR ErrIONewSize( DBID dbid, CPG cpg )
	{
	ERR		err;
	HANDLE	hf = HfFMPOfDbid(dbid);
	ULONG  	cb;
	ULONG  	cbHigh;

	AssertCriticalSection( critJet );

	Assert( cbPage == 1 << 12 );
	cb = cpg << 12;
	cbHigh = cpg >> 20;

	/*	set new EOF pointer
	/**/
	LeaveCriticalSection( critJet );
	err = ErrUtilNewSize( hf, cb, cbHigh, fTrue );
	EnterCriticalSection( critJet );
	Assert( err < 0 || err == JET_errSuccess );
	if ( err == JET_errSuccess )
		{
		/*	set database size in FMP
		/**/
		rgfmp[dbid].ulFileSizeLow = cb;
		rgfmp[dbid].ulFileSizeHigh = cbHigh;
		}

	return err;
	}


/*
 *  opens database file, returns JET_errSuccess if file is already open
 */
ERR ErrIOOpenDatabase( DBID dbid, CHAR *szDatabaseName, CPG cpg )
	{
	ERR		err = JET_errSuccess;
	HANDLE	hf;
	ULONG	ul;
	ULONG	ulHigh;
	
	Assert( dbid < dbidMax );
	Assert( FDBIDWait(dbid) == fTrue );

	if ( HfFMPOfDbid(dbid) == handleNil )
		{
		ul = cpg * cbPage;
		ulHigh = 0;
		CallR( ErrIOOpenFile( &hf, szDatabaseName, &ul, &ulHigh ) );
		HfFMPOfDbid(dbid) = hf;
		rgfmp[dbid].ulFileSizeLow = ul;
		rgfmp[dbid].ulFileSizeHigh = ulHigh;
		if ( err == JET_wrnFileOpenReadOnly )
			DBIDSetReadOnly( dbid );
		else
			DBIDResetReadOnly( dbid );
		}
	return err;
	}


VOID IOCloseDatabase( DBID dbid )
	{
	Assert( dbid < dbidMax );
//	Assert( fRecovering || FDBIDWait(dbid) == fTrue );
	Assert( HfFMPOfDbid(dbid) != handleNil );
	IOCloseFile( HfFMPOfDbid(dbid) );
	HfFMPOfDbid(dbid) = handleNil;
	DBIDResetReadOnly( dbid );
	}
	

ERR ErrIODeleteDatabase( DBID dbid )
	{
	ERR err;
	
	Assert( dbid < dbidMax );
//	Assert( FDBIDWait(dbid) == fTrue );
	
	CallR( ErrUtilDeleteFile( rgfmp[dbid].szDatabaseName ) );
	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\log.c ===
#include "daestd.h"
#include <ctype.h>
#include "version.h"

DeclAssertFile;					/* Declare file name for assert macros */

/*	thread control variables
/**/
extern HANDLE	handleLGFlushLog;
extern BOOL		fLGFlushLogTerm;

extern long lBufGenAge;

/*	global variables
/**/
BOOL	fLGGlobalCircularLog;

SIGNATURE	signLogGlobal;
BOOL		fSignLogSetGlobal = fFalse;

/*	constants
/**/
LGPOS		lgposMax = { 0xffff, 0xffff, 0x7fffffff };
LGPOS		lgposMin = { 0x0,  0x0,  0x0 };

/*	system parameters
/**/
INT			csecLGFile;
INT			csecLGBuf;			/* available buffer, exclude the shadow sec */

INT csecLGCheckpointCount;		/* counter for starting checkpoint */
INT csecLGCheckpointPeriod;		/* checkpoint period, set by system param. */

/*	logfile handle
/**/
HANDLE		hfLog = handleNil;

/*	switch to issue no write in order
/*	to test the performance without real IO.
/**/
//#define NO_WRITE	1

/*	cached current log file header
/**/
LGFILEHDR	*plgfilehdrGlobal;
LGFILEHDR	*plgfilehdrGlobalT;

/*	in memory log buffer
/**/
CHAR		*pbLGBufMin = NULL;
CHAR		*pbLGBufMax = NULL;

/*	where last multi-sec flush LogRec in LGBuf
/**/
CHAR		*pbLastMSFlush = 0;
LGPOS		lgposLastMSFlush = { 0, 0, 0 };

/*	variables used in logging only, corresponding
/*	pbNext, pbRead, isecRead, and lgposRedo are defined in redut.c
/**/
BYTE		*pbEntry = NULL;		/* location of next buffer entry */
BYTE		*pbWrite = NULL; 		/* location of next sec to flush */
INT			isecWrite = 0;			/* next disk to write */
LGPOS		lgposLogRec;			/* last log record entry, updated by ErrLGLogRec */
LGPOS		lgposToFlush;			/* first log record to flush */

BYTE		*pbLGFileEnd = pbNil;
LONG		isecLGFileEnd = 0;
/*	for debug
/**/
LGPOS		lgposStart;		/* when lrStart is added */
LGPOS		lgposRecoveryUndo;
LGPOS		lgposFullBackup = { 0, 0, 0 };
LOGTIME		logtimeFullBackup;

LGPOS		lgposIncBackup = { 0, 0, 0 };
LOGTIME		logtimeIncBackup;

/*	file system related variables.
 */
LONG		cbSec = 0;		/* disk sector size */
LONG		csecHeader = 0;	/* # of sectors for log header */

/*	logging event
/**/
SIG  	sigLogFlush;

/*	crit sequence: critLGFlush->critLGBuf->critLGWaitQ
 */
CRIT 	critLGFlush;
CRIT 	critLGBuf;
CRIT 	critLGWaitQ;

/*	counter of user waiting for flush.
/**/
LONG cXactPerFlush = 0;

#ifdef PERFCNT
BOOL fPERFEnabled = 0;
ULONG rgcCommitByLG[10] = {	0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
ULONG rgcCommitByUser[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
ULONG tidLG;
#endif

	
/*  monitoring statistics
/**/
unsigned long cLogWrites = 0;

PM_CEF_PROC LLGWritesCEFLPpv;

long LLGWritesCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		*((unsigned long *)pvBuf) = cLogWrites;
		}

	return 0;
	}

DWORD cbLogWritten = 0;

PM_CEF_PROC LLGBytesWrittenCEFLPpv;

long LLGBytesWrittenCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		*((DWORD *)((char *)pvBuf)) = cbLogWritten;
		}

	return 0;
	}

PM_CEF_PROC LLGUsersWaitingCEFLPpv;

long LLGUsersWaitingCEFLPpv( long iInstance, void *pvBuf )
	{
	if ( pvBuf )
		{
		*((unsigned long *)pvBuf) = cXactPerFlush;
		}

	return 0;
	}


BOOL FIsNullLgpos( LGPOS *plgpos )
	{
	return	plgpos->lGeneration == 0 &&
			plgpos->isec == 0 &&
			plgpos->ib == 0;
	}


VOID GetLgpos( BYTE *pb, LGPOS *plgpos )
	{
	CHAR	*pbAligned;
	INT		csec;
	INT		isecCurrentFileEnd;

#ifdef DEBUG
	if ( !fRecovering )
		{
		AssertCriticalSection( critLGBuf );
		}
#endif

	/*	pbWrite is always aligned
	/**/
	Assert( pbWrite != NULL && pbWrite == PbSecAligned( pbWrite ) );
	Assert( isecWrite >= csecHeader );

	pbAligned = PbSecAligned( pb );
	plgpos->ib = (USHORT)(pb - pbAligned);
	if ( pbAligned < pbWrite )
		csec = (INT)(csecLGBuf - ( pbWrite - pbAligned )) / cbSec;
	else
		csec = (INT)( pbAligned - pbWrite ) / cbSec;

	plgpos->isec = isecWrite + csec;

	isecCurrentFileEnd = isecLGFileEnd ? isecLGFileEnd : csecLGFile - 1;
	if ( plgpos->isec >= isecCurrentFileEnd )
		{
		plgpos->isec = (WORD) ( plgpos->isec - isecCurrentFileEnd + csecHeader );
		plgpos->lGeneration = plgfilehdrGlobal->lGeneration + 1;
		}
	else
		plgpos->lGeneration = plgfilehdrGlobal->lGeneration;

	return;
	}


VOID SIGGetSignature( SIGNATURE *psign )
	{
	INT cbComputerName;

	LGGetDateTime( &psign->logtimeCreate );
	psign->ulRandom = rand() + rand() + rand();
//	(VOID) GetComputerName( psign->szComputerName, &cbComputerName );
	cbComputerName = 0;
	memset( psign->szComputerName + cbComputerName,
		0,
		sizeof( psign->szComputerName ) - cbComputerName );
	}


/*	write log file data.
/**/
ERR ErrLGWrite(
	INT		isecOffset,			/* disk sector offset of logfile to write */
	BYTE	*pbData,			/* log record to write. */
	INT		csecData )			/* number of sector to write */
	{
 	ULONG	ulFilePointer;
	ERR		err;
	INT		cbWritten;
	INT		cbData = csecData * cbSec;

	Assert( isecOffset == 0 || isecOffset == csecHeader ||
		pbData == PbSecAligned( pbData ) );

	Assert( isecOffset < csecLGBuf );
	Assert( isecOffset + csecData <= csecLGBuf );

	/*	move disk head to the given offset
	/**/
 	UtilChgFilePtr( hfLog, isecOffset * cbSec, NULL, FILE_BEGIN, &ulFilePointer );
 	Assert( ulFilePointer == (ULONG) isecOffset * cbSec );

 	/*	do system write on log file
	/**/
 	err = ErrUtilWriteBlock( hfLog, pbData, (UINT) cbData, &cbWritten );
 	if ( err != JET_errSuccess || cbWritten != cbData )
		{
		CHAR	*rgszT[3];
		BYTE	sz1T[16];
		BYTE	sz2T[16];

		rgszT[0] = szLogName;

		/*	log information for win32 errors
		/**/
		if ( err )
			{
			sprintf( sz1T, "%d", DwUtilGetLastError() );
			rgszT[1] = sz1T;
			UtilReportEvent( EVENTLOG_ERROR_TYPE,
				LOGGING_RECOVERY_CATEGORY,
				LOG_FILE_SYS_ERROR_ID,
				2,
				rgszT );
			}
		else
			{
			sprintf( sz1T, "%d", cbData );
			sprintf( sz2T, "%d", cbWritten );
			rgszT[1] = sz1T;
			rgszT[2] = sz2T;
			UtilReportEvent( EVENTLOG_ERROR_TYPE,
				BUFFER_MANAGER_CATEGORY,
				LOG_IO_SIZE_ERROR_ID,
				3,
				rgszT );
			}
		err = ErrERRCheck( JET_errLogWriteFail );
		}
	if ( err < 0 )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, LOG_WRITE_ERROR_ID, err );
		fLGNoMoreLogWrite = fTrue;
		}

	/*	monitor statistics
	/**/
	cLogWrites++;
	cbLogWritten += cbWritten;

	return err;
	}


/*	write log file header.  No need to make a shadow since
/*	it will not be overwritten.
/**/
ERR ErrLGWriteFileHdr( LGFILEHDR *plgfilehdr )
	{
	ERR		err;

	Assert( plgfilehdr->dbms_param.ulLogBuffers );

	plgfilehdr->ulChecksum = UlUtilChecksum( (BYTE*) plgfilehdr, sizeof(LGFILEHDR) );

	Call( ErrLGWrite( 0, (BYTE *)plgfilehdr, csecHeader ) );

HandleError:
	if ( err < 0 )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, LOG_HEADER_WRITE_ERROR_ID, err );
		fLGNoMoreLogWrite = fTrue;
		}

	return err;
	}


/*
 *	Read log data. The last disk sector is a shadow
 *  sector. If an I/O error (assumed to be caused by an incompleted
 *  disk sector write ending a previous run) is encountered, the shadow
 *  sector is read and (if this is successful) replaces the previous
 *  disksec in memory.
 *
 *	PARAMETERS	hf		log file handle
 *				pbData	pointer to data to read
 *				lOffset	offset of data log file header (not including shadow)
 *				cbData	size of data
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 * 				(reading shadow or rewriting bad last sector).
 */
ERR ErrLGRead(
	HANDLE	hfLog,
	INT		isecOffset,			/* disk sector offset of logfile to write */
	BYTE	*pbData,			/* log record buffer to read. */
	INT		csecData )			/* number of sectors to read */
	{
	ERR		err;
 	ULONG	ulT;
 	ULONG	ulOffset;
	UINT	cb = csecData * cbSec;
	UINT	cbT;

	Assert( isecOffset == 0 || pbData == PbSecAligned(pbData) );

 	/*	move file pointer
	/**/
 	ulOffset = isecOffset * cbSec;
 	UtilChgFilePtr( hfLog, ulOffset, NULL, FILE_BEGIN, &ulT );
 	Assert( ulT == ulOffset );

 	/*	read bytes at file pointer
	/**/
 	cb = csecData * cbSec;
 	cbT = 0;
 	err = ErrUtilReadBlock( hfLog, pbData, (UINT)cb, &cbT );

 	/*	UNDONE: test for EOF, return errEOF
	/**/

	/*	if failed on last page, then read its shadow.
	 */
 	if ( err < 0 &&
		cbT < cb &&
		cbT >= ( cb - cbSec ) )
		{
 		UtilChgFilePtr( hfLog, ulOffset + cb, NULL, FILE_BEGIN, &ulT );
 		Assert( ulT == ulOffset + cb );
 		Call( ErrUtilReadBlock( hfLog, pbData + cb - cbSec, cbSec, &cbT ) );

		/*	fix up the last page if possible.
		/**/
 		UtilChgFilePtr( hfLog,
			ulOffset + cb - cbSec,
			NULL,
 			FILE_BEGIN,
			&ulT );
		Assert( ulT == ulOffset + cb - cbSec );
		(VOID)ErrUtilWriteBlock(hfLog, pbData + cb - cbSec, cbSec, &cbT );

		fLGNoMoreLogWrite = fTrue;
		}

HandleError:
	if ( err < 0 )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, LOG_READ_ERROR_ID, err );
		}

	return err;
	}


/*
 *	Read log file header, detect any incomplete or
 *	catastrophic write failures.  These failures will be used to
 *	determine if the log file is valid or not.
 *
 *	On error, contents of plgfilehdr are unknown.
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 */
ERR ErrLGReadFileHdr( HANDLE hfLog, LGFILEHDR *plgfilehdr, BOOL fNeedToCheckLogID )
	{
	ERR		err;
	ULONG	ulT;
	ULONG	cbT;

	/*	read log file header.  Header is written only during
	/*	log file creation and cannot become corrupt unless system
	/*	crash in the middle of file creation.
	/**/
 	UtilChgFilePtr( hfLog, 0, NULL, FILE_BEGIN, &ulT );
 	Assert( ulT == 0 );
 	Call( ErrUtilReadBlock( hfLog, plgfilehdr, sizeof(LGFILEHDR), &cbT ) );
	if ( cbT != sizeof(LGFILEHDR) )
		{
		Error( ErrERRCheck( JET_errDiskIO ), HandleError );
		}
	Assert( err == JET_errSuccess && cbT == sizeof(LGFILEHDR) );

#ifdef DAYTONA
	/*	check for old JET version
	/**/
	if ( *(long *)(((char *)plgfilehdr) + 20) == 443
		&& *(long *)(((char *)plgfilehdr) + 24) == 0
		&& *(long *)(((char *)plgfilehdr) + 28) == 0 )
		{
		/*	version 400
		/**/
		Error( ErrERRCheck( JET_errDatabase400Format ), HandleError );
		}
	else if ( *(long *)(((char *)plgfilehdr) + 44) == 0
		&& *(long *)(((char *)plgfilehdr) + 48) == 0x0ca0001 )
		{
		/*	version 200
		/**/
		Error( ErrERRCheck( JET_errDatabase200Format ), HandleError );
		}
#endif

	/*	check if the data is bogus
	/**/
	if ( plgfilehdr->ulChecksum != UlUtilChecksum( (BYTE*)plgfilehdr, sizeof(LGFILEHDR) ) )
		{
		Error( ErrERRCheck( JET_errDiskIO ), HandleError );
		}

#ifdef CHECK_LOG_VERSION
	if ( !fLGIgnoreVersion )
		{
		if ( plgfilehdr->ulMajor != rmj ||
			plgfilehdr->ulMinor != rmm ||
			plgfilehdr->ulUpdate != rup )
			{
			Error( ErrERRCheck( JET_errBadLogVersion ), HandleError );
			}
		}
#endif

	if ( fSignLogSetGlobal )
		{
		if ( fNeedToCheckLogID )
			{
			if ( memcmp( &signLogGlobal, &plgfilehdr->signLog, sizeof( signLogGlobal ) ) != 0 )
				Error( ErrERRCheck( JET_errBadLogSignature ), HandleError );
			}
		}
	else
		{
		signLogGlobal = plgfilehdr->signLog;
		fSignLogSetGlobal = fTrue;
		}

HandleError:
	if ( err == JET_errSuccess )
		{
		/*	reinitialized disk sector size in order to
		 *	operate on this log file.
		 */
		cbSec = plgfilehdr->cbSec;
		Assert( cbSec >= 512 );
		csecHeader = sizeof( LGFILEHDR ) / cbSec;
		csecLGFile = plgfilehdr->csecLGFile;
		}
	else
		{

		if ( err == JET_errBadLogVersion )
			{
			UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, LOG_BAD_VERSION_ERROR_ID, err );
			}
		else
			{
			UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, READ_LOG_HEADER_ERROR_ID, err );
			}

		fLGNoMoreLogWrite = fTrue;
		}

	return err;
	}


/*	Create the log file name (no extension) corresponding to the lGeneration
/*	in szFName. NOTE: szFName need minimum 9 bytes.
/*
/*	PARAMETERS	rgbLogFileName	holds returned log file name
/*				lGeneration 	log generation number to produce	name for
/*	RETURNS		JET_errSuccess
/**/

#define lLGFileBase		( 16 )
char rgchLGFileDigits[lLGFileBase] =
	{
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
	};

VOID LGSzFromLogId( CHAR *szFName, LONG lGeneration )
	{
	LONG	ich;

	strcpy( szFName, szJetLogNameTemplate );
	for ( ich = 7; ich > 2; ich-- )
		{
		szFName[ich] = rgchLGFileDigits[lGeneration % lLGFileBase];
		lGeneration = lGeneration / lLGFileBase;
		}

	return;
	}


/*	copy tm to a smaller structure logtm to save space on disk.
 */
VOID LGGetDateTime( LOGTIME *plogtm )
	{
	_JET_DATETIME tm;

	UtilGetDateTime2( &tm );

	plogtm->bSeconds = (BYTE)tm.second;
	plogtm->bMinutes = (BYTE)tm.minute;
	plogtm->bHours = (BYTE)tm.hour;
	plogtm->bDay = (BYTE)tm.day;
	plogtm->bMonth = (BYTE)tm.month;
	plogtm->bYear = tm.year - 1900;
	}


/*  Open szJetLog. If failed, try to rename jettemp.log to szJetLog.
/*	If soft failure occurred while new log generation file
/*	was being created, look for active log generation file
/*	in temporary name.  If found, rename and proceed.
/*	Assume rename cannot cause file loss.
/**/
// UNDONE: we will stop using jet.log and always use name jetxxxxx.log
// UNDONE: and never rename it. When reading file header and first MS of
// UNDONE: jetxxxxx.log and fail, we know the file (system) is crashed
// UNDONE: while the log file is generated since we only write once on
// UNDONE: log file header.

ERR ErrLGOpenJetLog( VOID )
	{
	ERR		err;
	CHAR	szPathJetTmpLog[_MAX_PATH + 1];
	CHAR	szFNameT[_MAX_FNAME + 1];

	strcpy( szFNameT, szJet );
	LGMakeLogName( szLogName, szFNameT );
	LGMakeLogName( szPathJetTmpLog, (CHAR *) szJetTmp );
	err = ErrUtilOpenFile( szLogName, &hfLog, 0L, fTrue, fFalse );
	if ( err < 0 )
		{
		/*	no current szJetLog. Try renaming szJetTmpLog to szJetLog
		/**/
		if ( err == JET_errFileAccessDenied  ||
			( err = ErrUtilMove( szPathJetTmpLog, szLogName ) ) != JET_errSuccess )
			return err;

		CallS( ErrUtilOpenFile( szLogName, &hfLog, 0L, fTrue, fFalse ) );
		}

	/*  we opened current szJetLog successfully,
	/*	try to delete temporary log file in case failure
	/*	occurred after temp was created and possibly not
	/*	completed but before active log file was renamed
	/**/
	(VOID)ErrUtilDeleteFile( szPathJetTmpLog );

	return err;
	}


ERR	ErrLGNewReservedLogFile()
	{
	CHAR	*szT = szLogCurrent;

	szLogCurrent = szLogFilePath;
	(VOID)ErrLGNewLogFile( 0, fLGReserveLogs );
	szLogCurrent = szT;
	if ( lsGlobal != lsNormal )
		{
		return JET_errLogDiskFull;
		}
		
	return JET_errSuccess;
	}

/*
 *	Closes current log generation file, creates and initializes new
 *	log generation file in a safe manner.
 *
 *	PARAMETERS	plgfilehdr		pointer to log file header
 *				lGeneration 	current generation being closed
 *				fOld			TRUE if a current log file needs closing
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 *
 *	COMMENTS	Active log file must be completed before new log file is
 *				called.
 */
ERR ErrLGNewLogFile( LONG lgenToClose, BOOL fLGFlags )
	{
	ERR			err;
	ERR			errT;
	BYTE  		szPathJetLog[_MAX_PATH + 1];
	BYTE  		szPathJetTmpLog[_MAX_PATH + 1];
	LOGTIME		tmOldLog;
	HANDLE		hfT = handleNil;
	CHAR		szFNameT[_MAX_FNAME + 1];
	LRMS		*plrms;

	/*	if lgenToClose == 0 then initial new log file operations
	/*	by reserving log files and setting log state accordingly.
	/**/
	if ( fLGFlags == fLGReserveLogs )
		{
		LS	lsBefore = lsGlobal;

		if ( lsBefore == lsOutOfDiskSpace )
			return JET_errLogDiskFull;

		lsGlobal = lsNormal;

		LGMakeLogName( szPathJetLog, szLogRes2 );
		if ( FUtilFileExists( szPathJetLog ) )
			{
			err = ErrUtilOpenFile( szPathJetLog, &hfT, 0, fFalse, fFalse );
			if ( err >= 0 )
				{
				err = ErrUtilNewSize( hfT, csecLGFile * cbSec, 0, 0 );
				CallS( ErrUtilCloseFile( hfT ) );
				}
			}
		else
			{
			err = ErrUtilOpenFile( szPathJetLog, &hfT, csecLGFile * cbSec, fFalse, fFalse );
			if ( err >= 0 )
				{
				CallS( ErrUtilCloseFile( hfT ) );
				}
			}
		if ( err < 0 )
			{
			if ( lsBefore == lsNormal )
				{
				UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY, LOW_LOG_DISK_SPACE, 0, NULL );
				}
			lsGlobal = lsQuiesce;
			}
		else
			{
			LGMakeLogName( szPathJetLog, szLogRes1 );
			if ( FUtilFileExists( szPathJetLog ) )
				{
				err = ErrUtilOpenFile( szPathJetLog, &hfT, 0, fFalse, fFalse );
				if ( err >= 0 )
					{
					err = ErrUtilNewSize( hfT, csecLGFile * cbSec, 0, 0 );
					CallS( ErrUtilCloseFile( hfT ) );
					}
				}
			else
				{
				err = ErrUtilOpenFile( szPathJetLog, &hfT, csecLGFile * cbSec, fFalse, fFalse );
				if ( err >= 0 )
					{
					CallS( ErrUtilCloseFile( hfT ) );
					}
				}
			if ( err < 0 )
				{
				if ( lsBefore == lsNormal )
					{
					UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY, LOW_LOG_DISK_SPACE, 0, NULL );
					}
				lsGlobal = lsQuiesce;
				}
			}

//		hfT = handleNil;
		if ( lsGlobal == lsNormal )
			err = JET_errSuccess;
		Assert( lsGlobal != lsNormal || err != JET_errDiskFull );
		if ( err == JET_errDiskFull )
			{
			err = JET_errLogDiskFull;
			}
		return err;
		}

	AssertCriticalSection( critLGFlush );

	/*	return error on log generation number roll over
	/**/
	if ( plgfilehdrGlobal->lGeneration == lGenerationMax )
		{
		return ErrERRCheck( JET_errLogSequenceEnd );
		}

	LGMakeLogName( szPathJetLog, (CHAR *)szJet );
	LGMakeLogName( szPathJetTmpLog, (CHAR *)szJetTmp );

	/*	if circular log file flag set and backup not in progress
	/*	then find oldest log file and if no longer needed for
	/*	soft-failure recovery, then rename to szJetTempLog.
	/*	Otherwise, create szJetTempLog.
	/**/
	if ( fLGGlobalCircularLog && !fBackupInProgress )
		{
		/*	when find first numbered log file, set fLGGlobalFoundOldest to
		/*	true and lgenLGGlobalOldest to log file number
		/**/
		BOOL fLGGlobalFoundOldest = fFalse;
		LONG lgenLGGlobalOldest;

		if ( !fLGGlobalFoundOldest )
			{
			LGFirstGeneration( szLogFilePath, &lgenLGGlobalOldest );
			if ( lgenLGGlobalOldest != 0 )
				{
				fLGGlobalFoundOldest = fTrue;
				}
			}

		/*	if found oldest generation and oldest than checkpoint,
		/*	then move log file to szJetTempLog.  Note that the checkpoint
		/*	must be flushed to ensure that the flushed checkpoint is
		/*	after then oldest generation.
		/**/
		if ( fLGGlobalFoundOldest )
			{
			//	UNDONE:	related issue of checkpoint write
			//			synchronization with dependent operations
			//	UNDONE:	error handling for checkpoint write
			LGUpdateCheckpointFile( fFalse );
			if ( fLGGlobalFoundOldest &&
				lgenLGGlobalOldest <
				pcheckpointGlobal->lgposCheckpoint.lGeneration )
				{
				LGSzFromLogId( szFNameT, lgenLGGlobalOldest );
				LGMakeLogName( szLogName, szFNameT );
				err = ErrUtilMove( szLogName, szPathJetTmpLog );
				Assert( err < 0 || err == JET_errSuccess );
				if ( err == JET_errSuccess )
					{
					(VOID)ErrUtilOpenFile( szPathJetTmpLog,
						&hfT,
						0,
						fFalse,
						fFalse );
					}
				}
			}
		}

	/*  open an empty szJetTempLog file
	/**/
	if ( hfT == handleNil )
		{
		err = ErrUtilOpenFile( szPathJetTmpLog,
			&hfT,
			csecLGFile * cbSec,
			fFalse,
			fFalse );
		/*	if disk full, attempt to open reserved log file 2
		/**/
		if ( err == JET_errDiskFull )
			{
			/*	use reserved log file and change to log state
			/**/
			LGMakeLogName( szLogName, szLogRes2 );
			errT = ErrUtilMove( szLogName, szPathJetTmpLog );
			Assert( errT < 0 || errT == JET_errSuccess );
			if ( errT == JET_errSuccess )
				{
				(VOID)ErrUtilOpenFile( szPathJetTmpLog,
					&hfT,
					0,
					fFalse,
					fFalse );
				}
			if ( hfT != handleNil )
				err = JET_errSuccess;
			if ( lsGlobal == lsNormal )
				{
				UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY, LOW_LOG_DISK_SPACE, 0, NULL );
				lsGlobal = lsQuiesce;
				}
			}
		/*	if disk full, attempt to open reserved log file 1
		/**/
		if ( err == JET_errDiskFull )
			{
			/*	use reserved log file and change to log state
			/**/
			LGMakeLogName( szLogName, szLogRes1 );
			errT = ErrUtilMove( szLogName, szPathJetTmpLog );
			Assert( errT < 0 || errT == JET_errSuccess );
			if ( errT == JET_errSuccess )
				{
				(VOID)ErrUtilOpenFile( szPathJetTmpLog,
					&hfT,
					0,
					fFalse,
					fFalse );
				}
			if ( hfT != handleNil )
				err = JET_errSuccess;
			Assert( lsGlobal == lsQuiesce || lsGlobal == lsOutOfDiskSpace );
			}
		if ( err == JET_errDiskFull )
			{
			Assert( lsGlobal == lsQuiesce || lsGlobal == lsOutOfDiskSpace );
			if ( lsGlobal == lsQuiesce )
				{
				UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY, LOG_DISK_FULL, 0, NULL );
				lsGlobal = lsOutOfDiskSpace;
				}
			}
		if ( err < 0 )
			goto HandleError;
		}

	/*	close active log file (if fLGFlags is fTrue)
	/*	create new log file	under temporary name
	/*	rename active log file to archive name numbered log (if fOld is fTrue)
	/*	rename new log file to active log file name
	/*	open new active log file with ++lGenerationToClose
	/**/
	if ( fLGFlags == fLGOldLogExists || fLGFlags == fLGOldLogInBackup )
		{
		/* there was a previous szJetLog file, close it and
		/* create an archive name for it, do not rename it yet.
		/**/
		tmOldLog = plgfilehdrGlobal->tmCreate;

		if ( fLGFlags == fLGOldLogExists )
			{
			CallS( ErrUtilCloseFile( hfLog ) );
			hfLog = handleNil;
			}

		LGSzFromLogId( szFNameT, plgfilehdrGlobal->lGeneration );
		LGMakeLogName( szLogName, szFNameT );
		}
	else
		{
		/*	reset file header
		/**/
		memset( plgfilehdrGlobal, 0, sizeof(LGFILEHDR) );
		}

	/*	move new log file handle into global log file handle
	/**/
	Assert( hfLog == handleNil );
	hfLog = hfT;
	hfT = handleNil;

	EnterCriticalSection( critLGBuf );

	/*	initialize the new szJetTempLog file header
	/**/

	/*	set release version numbers
	/**/
	plgfilehdrGlobalT->ulMajor = rmj;
	plgfilehdrGlobalT->ulMinor = rmm;
	plgfilehdrGlobalT->ulUpdate = rup;

	plgfilehdrGlobalT->cbSec = cbSec;
	plgfilehdrGlobalT->csecLGFile = csecLGFile;

	/*	set lgfilehdr and pbLastMSFlush and lgposLastMSFlush.
	/**/
	if ( fLGFlags == fLGOldLogExists || fLGFlags == fLGOldLogInBackup )
		{
		/*	set position of first record
		/**/
		Assert( lgposToFlush.lGeneration && lgposToFlush.isec );

		/*	overhead contains one LRMS and one will-be-overwritten lrtypNOP
		/**/
		Assert( pbEntry >= pbLGBufMin && pbEntry < pbLGBufMax );
		Assert( pbWrite >= pbLGBufMin && pbWrite < pbLGBufMax );

		plrms = (LRMS *)pbWrite;
		plrms->lrtyp = lrtypMS;
		plrms->ibForwardLink = 0;
		plrms->isecForwardLink = 0;
		plrms->ulCheckSum = 0;
		*( pbWrite + sizeof( LRMS ) ) = lrtypEnd;

		pbLastMSFlush = pbWrite;
		lgposLastMSFlush.lGeneration = lgenToClose + 1;

		plgfilehdrGlobalT->tmPrevGen = tmOldLog;
		}
	else
		{
		LRMS *plrms;

		/*	no currently valid logfile initialize checkpoint to start of file
		/**/

		/*	start of data area, set pbEntry to point lrtypEnd
		/**/
		pbEntry = pbLGBufMin + sizeof( LRMS );
		pbWrite = pbLGBufMin;

		Assert( sizeof(LRTYP) == 1 );
		plrms = (LRMS *) pbLGBufMin;
		plrms->lrtyp = lrtypMS;
		plrms->ibForwardLink = 0;
		plrms->isecForwardLink = 0;
		plrms->ulCheckSum = 0;
		*(pbLGBufMin + sizeof( LRMS )) = lrtypEnd;

		pbLastMSFlush = pbLGBufMin;
		lgposLastMSFlush.lGeneration = 1;
		}
	lgposLastMSFlush.ib = 0;
	lgposLastMSFlush.isec = (WORD) csecHeader;

	plgfilehdrGlobalT->lGeneration = lgenToClose + 1;

	lgposToFlush.lGeneration = plgfilehdrGlobalT->lGeneration;
	lgposToFlush.isec = (WORD) csecHeader;
	lgposToFlush.ib = 0;

	LeaveCriticalSection( critLGBuf );

	/*	set time create
	/**/
	LGGetDateTime( &plgfilehdrGlobalT->tmCreate );

	EnterCriticalSection( critJet );

	/*	set DBMS parameters
	/**/
	LGSetDBMSParam( &plgfilehdrGlobalT->dbms_param );

	/*	set database attachments
	/**/
	LGLoadAttachmentsFromFMP( plgfilehdrGlobalT->rgbAttach,
		(INT)(((BYTE *)(plgfilehdrGlobalT + 1)) - plgfilehdrGlobalT->rgbAttach) );

	LeaveCriticalSection( critJet );

	if ( plgfilehdrGlobalT->lGeneration == 1 )
		{
		SIGGetSignature( &plgfilehdrGlobalT->signLog );

		/*	first generation, set checkpoint
		/**/
		pcheckpointGlobal->lgposCheckpoint.lGeneration = plgfilehdrGlobalT->lGeneration;
		pcheckpointGlobal->lgposCheckpoint.isec = (WORD) csecHeader;
		pcheckpointGlobal->lgposCheckpoint.ib = 0;

		pcheckpointGlobal->signLog = plgfilehdrGlobalT->signLog;
		
		/*	update checkpoint file before write log file header to make the
		/*	attachment information in check point will be consistent with
		/*	the newly generated log file.
		/**/
		LGUpdateCheckpointFile( fFalse );
		}
	else
		{
		Assert( fSignLogSetGlobal );
		plgfilehdrGlobalT->signLog = signLogGlobal;
		}

	CallJ( ErrLGWriteFileHdr( plgfilehdrGlobalT ), CloseJetTmp );

	Assert( ( fLGFlags == fLGOldLogExists ||
		fLGFlags == fLGOldLogInBackup ) ||
		lgposToFlush.ib == 0 );

	/*	write the first log record and its shadow, and then
	/*	reset the End log record for next flush.
	/*	NOTE: do not change isecWrite until caller has
	/*	plgfilehdrGlobal->lGeneration set.
	/**/
	CallJ( ErrLGWrite( csecHeader, pbWrite, 1 ), CloseJetTmp );
	CallJ( ErrLGWrite( csecHeader + 1, pbWrite, 1 ), CloseJetTmp );
	*( pbWrite + sizeof(LRMS) ) = lrtypNOP;

CloseJetTmp:
	/*	close new file szJetTmpLog
	/**/
	CallS( ErrUtilCloseFile( hfLog ) );
	hfLog = handleNil;

	/*	error returned from ErrLGWriteFileHdr
	/**/
	Call( err );

	
	if ( fLGFlags == fLGOldLogExists )
		{
		/*	there was a previous szJetLog, rename it to its archive name
		/**/
		Call( ErrUtilMove( szPathJetLog, szLogName ) );
		}
	

	/*	rename szJetTmpLog to szJetLog, and open it as szJetLog
	/**/
	err = ErrUtilMove( szPathJetTmpLog, szPathJetLog );

HandleError:
	if ( err < 0 )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, NEW_LOG_ERROR_ID, err );
		fLGNoMoreLogWrite = fTrue;
		}
	else
		fLGNoMoreLogWrite = fFalse;

	return err;
	}


/*
 *	Log flush thread is signalled to flush log asynchronously when at least
 *	cThreshold disk sectors have been filled since last flush.
 */

#ifdef DEBUG
DWORD dwLogThreadId;
#endif

ULONG LGFlushLog( VOID )
	{
#ifdef DEBUG
	dwLogThreadId = DwUtilGetCurrentThreadId();
#endif
		
	forever
		{
		SignalWait( sigLogFlush, cmsLGFlushPeriod );

		/*	error may be returned if conflicting files exist.
		/*	Async flush should do nothing and let error be
		/*	propogated to user when synchronous flush occurs.
		/**/
#ifdef PERFCNT
		(void) ErrLGFlushLog( 1 );
#else
		(void) ErrLGFlushLog( );
#endif

		if ( fLGFlushLogTerm )
			break;
		}

	return 0;
	}


/*	check formula - make last MS (isec, ib) as a long l. add l
 *	and all the longs that are aligned on 256 boundary up to
 *	current MS.
 */
ULONG UlLGMSCheckSum( CHAR *pbLrmsNew )
	{
	ULONG ul = 34089457;
	UINT uiStep = 16;
	CHAR *pb;

	Assert( *pbLrmsNew == lrtypMS );
	Assert( pbLastMSFlush );
	Assert( *pbLastMSFlush == lrtypMS );

	ul += lgposLastMSFlush.isec << 16 | lgposLastMSFlush.ib;
	pb = (( pbLastMSFlush - pbLGBufMin ) / uiStep + 1 ) * uiStep + pbLGBufMin;

	/*	make sure the lrms is not be used for checksum.
	/*/
	if ( pbLastMSFlush + sizeof( LRMS ) > pb )
		pb += uiStep;

	if ( pbLrmsNew < pbLastMSFlush )
		{
		/*	wrapp around
		/**/
		while ( pb < pbLGBufMax )
			{
			ul += *(ULONG *) pb;
			pb += uiStep;
			}
		pb = pbLGBufMin;
		}

	/*	LRMS may be changed during next operation, do not take any possible LRMS for checksum.
	/*/
	while ( pb + sizeof( LRMS ) < pbLrmsNew )
		{
		ul += *(ULONG *) pb;
		pb += uiStep;
		}

	ul += *pbLrmsNew;

	return ul;
	}


/*
 *	Flushes log buffer to log generation files.	 This function is
 *	called synchronously from wait flush and asynchronously from
 *	log buffer flush thread.
 *
 *	PARAMETERS	lgposMin	flush log records up to or pass lgposMin
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 */
#ifdef PERFCNT
ERR ErrLGFlushLog( BOOL fCalledByLGFlush )
#else
ERR ErrLGFlushLog( )
#endif
	{
	ERR		err = JET_errSuccess;
	INT		csecWrapAround = 0;
	BOOL  	fSingleSectorFlush;
	CHAR  	*pbNextToWrite;
	INT		csecToWrite = 0;
	CHAR  	*pbFlushEnd;
	CHAR	*pbLGFileEndT;
	CHAR  	*pbWriteNew;
	INT		isecWriteNew;
	LGPOS 	lgposToFlushT;
	BOOL  	fDoneCheckpoint = fFalse;
 	ULONG	ulFilePointer;
	INT		cbWritten;
	INT		cbToWrite;
	CHAR	szFNameT[_MAX_FNAME + 1];

	/*	serialize log flush
	/**/
	EnterCriticalSection( critLGFlush );

	/*	prepare to access log buffer
	/**/
	EnterCriticalSection( critLGBuf );

	if ( fLGNoMoreLogWrite )
		{
		/*	if previous error then do nothing
		/**/
		LeaveCriticalSection( critLGBuf );
		LeaveCriticalSection( critLGFlush );
		// typically this is due to out of disk space.
//		Assert( fFalse );
		return ErrERRCheck( JET_errLogWriteFail );
		}

	if ( hfLog == handleNil )
		{
		/*	log file not available yet, do nothing
		/**/
		LeaveCriticalSection( critLGBuf );
		LeaveCriticalSection( critLGFlush );
		return JET_errSuccess;
		}

	/*	make a local copy so that later we can check pbLGFileEnd out critLGBuf.
	 *	Since csecLGBuf is less than csecLGFile, unless this log is generated completely
	 *	the pbLGFileEnd can not be set again.
	 */
	pbLGFileEndT = pbLGFileEnd;
	if ( !fNewLogRecordAdded && pbLGFileEndT == pbNil )
		{
		/*	nothing to flush
		/**/
		lgposToFlushT = lgposToFlush;
		LeaveCriticalSection( critLGBuf );

		if ( ppibLGFlushQHead != ppibNil )
			{
			goto WakeUp;
			}
		LeaveCriticalSection( critLGFlush );
		return JET_errSuccess;
		}

#ifdef PERFCNT
    if ( fCalledByLGFlush )
		{
		if ( cXactPerFlush < 10 )
			rgcCommitByLG[cXactPerFlush]++;
		}
	else
		{
		if ( cXactPerFlush < 10 )
			rgcCommitByUser[cXactPerFlush]++;
		}
#endif

	/* reset the waiting users */
	cXactPerFlush = 0;

DoFlush:

	if ( pbLGFileEndT != pbNil )
		{
		/*	flush to generate new log file.
		 */
		Assert( isecLGFileEnd && isecLGFileEnd <= csecLGFile - 1 );
		Assert( pbLGFileEnd <= pbLGBufMax && pbLGFileEnd >= pbLGBufMin );
		if ( pbLGFileEnd == pbLGBufMin )
			pbFlushEnd = pbLGBufMax - cbLGMSOverhead;
		else
		    pbFlushEnd = pbLGFileEnd - cbLGMSOverhead;

		/*	We are patching the end of log file, or during recovery, the log file
		 *	is patched but not rename to archived log file.
		 */
		Assert( *pbFlushEnd == lrtypNOP ||
				( fRecovering &&
				  *pbFlushEnd == lrtypMS &&
				  pbLastMSFlush == pbFlushEnd &&
				  lgposLastMSFlush.isec == isecLGFileEnd - 1 )
				);
		Assert( *(pbFlushEnd + cbLGMSOverhead - 1 ) == lrtypNOP );
		}
	else
		pbFlushEnd = pbEntry;

	Assert( pbFlushEnd <= pbLGBufMax && pbFlushEnd >= pbLGBufMin );
	Assert( pbWrite < pbLGBufMax && pbWrite >= pbLGBufMin );
	Assert( pbWrite != NULL && pbWrite == PbSecAligned( pbWrite ) );

	/*	check buffer wraparound
	/**/
	if ( pbFlushEnd < pbWrite )
		{
		Assert( pbWrite != NULL && pbWrite == PbSecAligned( pbWrite ) );
		csecWrapAround = (INT)( pbLGBufMax - pbWrite ) / cbSec;
		pbNextToWrite = pbLGBufMin;
		}
	else
		{
		csecWrapAround = 0;
		pbNextToWrite = pbWrite;
		}

	/*	pbFlushEnd + 1 for end log record
	/**/
	Assert( sizeof(LRTYP) == 1 );
	Assert( pbNextToWrite == PbSecAligned(pbNextToWrite) );

	/*	Note that since we are going to append lrtypEnd, so when calculate
	 *	csecToWrite, no need to do "- 1" before "/ cbSec".
	 */
	csecToWrite = (INT)(pbFlushEnd - pbNextToWrite) / cbSec + 1;

	/*	check if this is a multi-sector flush
	/**/
	if ( ( csecWrapAround + csecToWrite ) == 1 )
		{
		Assert( fTrue == 1 );
		Assert( csecToWrite == 1 );
		fSingleSectorFlush = fTrue;
		}
	else
		{
		INT		cbToFill;
		LRMS	lrmsNewLastMSFlush;
		LGPOS	lgposNewLastMSFlush;
		CHAR	*pbNewLastMSFlush;

		fSingleSectorFlush = fFalse;

		/*  more than one log sector will be flushed. Append MS flush log record.
		/*  Note there must be enough space for it because before we
		/*  add new log rec into the buffer, we also check if there
		/*	is enough space for adding MS flush log record.
		/**/

		/*  if the MS log flush record crosses a sector boundary, put NOP
		/*  to fill to the rest of sector, and start from the beginning
		/*  of the next new sector. Also adjust csecToWrite.
		/*  NOTE: we must guarrantee that the whole MS log flush record
		/*  NOTE: on the same sector so that when we update MS log flush
		/*  NOTE: we can always assume that it is in the buffer.
		/*  NOTE: even the whole LRMS ends with sec boundary, we still need
		/*  NOTE: to move the record to next sector so that we can guarantee
		/*  NOTE: after flush, the last sector is still in buffer, such that
		/*  NOTE: pbLastMSFlush is still effective.
		/**/
		cbToFill = ( cbSec * 2 - (INT)( pbFlushEnd - PbSecAligned(pbFlushEnd) ) ) % cbSec;
		Assert( pbFlushEnd != pbLGBufMax || cbToFill == 0 );
		Assert( pbLGFileEnd == pbNil || cbToFill == cbLGMSOverhead );

		if ( cbToFill == 0 )
			{
			/*	check if wraparound occurs
			/**/
			if ( pbFlushEnd == pbLGBufMax )
				{
				pbFlushEnd = pbLGBufMin;
				csecWrapAround = csecToWrite - 1;
				csecToWrite = 1;
				}
			}
		else if ( cbToFill <= sizeof(LRMS) )
			{
			CHAR *pbEOS = pbFlushEnd + cbToFill;

			Assert( sizeof(LRTYP) == 1 );
			for ( ; pbFlushEnd < pbEOS; pbFlushEnd++ )
				*(LRTYP*)pbFlushEnd = lrtypNOP;
			Assert( pbFlushEnd == PbSecAligned(pbFlushEnd) );

			/*	one more sector that will contain MS log flush record only
			/**/
			Assert( fSingleSectorFlush == fFalse );

			/*	check if wraparound occurs
			/**/
			if ( pbFlushEnd == pbLGBufMax )
				{
				pbFlushEnd = pbLGBufMin;
				csecWrapAround = csecToWrite;
				csecToWrite = 1;
				}
			else
				{
				csecToWrite++;
				}
			}

		/*	add the MS log flush record, which should never cause
		/*	wraparound after the check above.
		/**/

		/*	remember where the MS log flush is inserted
		/**/
		Assert( pbFlushEnd < pbLGBufMax && pbFlushEnd >= pbLGBufMin );
		pbNewLastMSFlush = pbFlushEnd;
		GetLgpos( pbFlushEnd, &lgposNewLastMSFlush );

		/*	insert a MS log record
		/**/
		lrmsNewLastMSFlush.lrtyp = lrtypMS;
		lrmsNewLastMSFlush.ibForwardLink = 0;
		lrmsNewLastMSFlush.isecForwardLink = 0;
		
		*pbFlushEnd = lrtypMS;	// set lrtypMS for checksum calculation
		lrmsNewLastMSFlush.ulCheckSum = UlLGMSCheckSum( pbFlushEnd );

		AddLogRec( (CHAR *)&lrmsNewLastMSFlush,
				   sizeof(LRMS),
				   &pbFlushEnd );

		/*  EOF must stay with LRMS in the same sector
		 */
		Assert( PbSecAligned( pbFlushEnd ) == PbSecAligned( pbFlushEnd - 1 ) );

#ifdef DEBUG
		if ( fDBGTraceLog )
			{
			extern INT cNOP;

			/* show lrms record */
			LGPOS lgposLogRec = lgposNewLastMSFlush;
			BYTE *pbLogRec = pbFlushEnd - sizeof( LRMS );
			DWORD dwCurrentThreadId = DwUtilGetCurrentThreadId();

			EnterCriticalSection( critDBGPrint );

			if ( cNOP >= 1 )
				{
				FPrintF2( " * %d", cNOP );
				cNOP = 0;
				}

			if ( dwCurrentThreadId == dwBMThreadId || dwCurrentThreadId == dwLogThreadId )
				FPrintF2("\n$");
			else if ( FLGDebugLogRec( (LR *)pbLogRec ) )
				FPrintF2("\n#");
			else
				FPrintF2("\n<");
				
			FPrintF2(" {%u} ", dwCurrentThreadId );
			FPrintF2("%2u,%3u,%3u", lgposLogRec.lGeneration, lgposLogRec.isec, lgposLogRec.ib );
			ShowLR( (LR *)pbFlushEnd - sizeof( LRMS ) );

			LeaveCriticalSection( critDBGPrint );
			}
#endif

		/*	at this point, lgposNewLastMSFlush is pointing at the MS record
		/**/
		Assert( lgposNewLastMSFlush.lGeneration == plgfilehdrGlobal->lGeneration );

		/*  previous flush log must be in memory still. Set the
		/*  previous flush log record to point to the new flush log rec.
		/**/
		if ( pbLastMSFlush )
			{
			LRMS *plrms = (LRMS *)pbLastMSFlush;

			Assert( plrms->lrtyp == lrtypMS );
			plrms->ibForwardLink = lgposNewLastMSFlush.ib;
			plrms->isecForwardLink = lgposNewLastMSFlush.isec;
			}

		pbLastMSFlush = pbNewLastMSFlush;
		lgposLastMSFlush = lgposNewLastMSFlush;
		Assert( lgposLastMSFlush.isec >= csecHeader && lgposLastMSFlush.isec < csecLGFile - 1 );
		}

	((LR *)pbFlushEnd)->lrtyp = lrtypEnd;

	/*  release pbEntry so that other user can continue adding log records
	/*  while we are flushing log buffer. Note that we only flush up to
	/*  pbEntryT.
	/**/

	/*	set the lgposToFlush, should include lrtypEnd.
	/**/
	GetLgpos( pbFlushEnd, &lgposToFlushT );

	if ( pbLGFileEnd )
		{
		/* pbEntry is not touched */
		Assert( isecLGFileEnd && isecLGFileEnd <= csecLGFile - 1 );
		Assert( pbFlushEnd <= pbLGBufMax && pbFlushEnd > pbLGBufMin );
		Assert( ( (ULONG_PTR) pbFlushEnd + sizeof( LRTYP ) ) % cbSec == 0 ||
				( (ULONG_PTR) pbFlushEnd + cbLGMSOverhead ) % cbSec == 0 );
		}
	else
		{
		pbEntry = pbFlushEnd;
		Assert( *(LRTYP *)pbEntry == lrtypEnd );
		pbEntry += sizeof( LRTYP );	/* keep lrtypEnd */

		fNewLogRecordAdded = fFalse;
		}

	/*	copy isecWrite to isecWriteNew since we will change isecWriteNew
	 *	during flush.
	 */
	isecWriteNew = isecWrite;

	LeaveCriticalSection( critLGBuf );

 	UtilChgFilePtr( hfLog, isecWriteNew * cbSec, NULL, FILE_BEGIN, &ulFilePointer );
 	Assert( ulFilePointer == (ULONG) isecWriteNew * cbSec );

	/*	Always wirte first page first to make sure the following case won't happen
	 *	OS write and destroy shadow page, and then failed while writing the first page
	 */

#ifdef DEBUG
	if (fDBGTraceLogWrite)
		PrintF2(
			"\n0. Writing %d sectors into sector %d from buffer (%u,%u).",
			1, isecWriteNew, pbWrite, pbEntry);
#endif

#ifdef NO_WRITE
	goto EndOfWrite0;
#endif

	err = ErrUtilWriteBlock( hfLog, pbWrite, cbSec, &cbWritten );
	if ( err < 0 )
		{

		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, LOG_FLUSH_WRITE_0_ERROR_ID, err );
		fLGNoMoreLogWrite = fTrue;
		goto HandleError;
		}
	Assert( cbWritten == cbSec );

	/*  monitor statistics  */

	cLogWrites++;
	cbLogWritten += cbWritten;

#ifdef NO_WRITE
EndOfWrite0:
#endif

	isecWriteNew++;
	pbWriteNew = pbWrite + cbSec;

	if ( !csecWrapAround )
		{
		/*	first sec was written out already, decrement csecToWrite.
		 *	csecToWrite is ok to be 0.
		 */
		csecToWrite--;
		}
	else if ( csecWrapAround == 1 )
		{
		Assert( csecToWrite >= 1 );
		Assert( pbWriteNew == pbLGBufMax );

		pbWriteNew = pbLGBufMin;
		}
	else
		{
		Assert( csecToWrite >= 1 );

		/*	first sec was written out already, decrement number of WrapAround
		 */
		csecWrapAround--;
		Assert( csecWrapAround <= (INT) csecLGBuf );

#ifdef DEBUG
		if ( fDBGTraceLogWrite )
			PrintF2(
				"\n1.Writing %d sectors into sector %d from buffer (%u,%u).",
				csecWrapAround, isecWriteNew, pbWrite, pbEntry);
#endif

#ifdef NO_WRITE
		goto EndOfWrite1;
#endif
 		err = ErrUtilWriteBlock(
			hfLog,
			pbWriteNew,
			csecWrapAround * cbSec,
			&cbWritten );
		if ( err < 0 )
			{
			UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, LOG_FLUSH_WRITE_1_ERROR_ID, err );
			fLGNoMoreLogWrite = fTrue;
			goto HandleError;
			}
 		Assert( cbWritten == csecWrapAround * cbSec );

		/*  monitor statistics  */

		cLogWrites++;
		cbLogWritten += cbWritten;

#ifdef NO_WRITE
EndOfWrite1:
#endif

		isecWriteNew += csecWrapAround;
		pbWriteNew = pbLGBufMin;
		}

	Assert( pbWriteNew != NULL && pbWriteNew == PbSecAligned( pbWriteNew ) );
	Assert ( csecToWrite >= 0 );

	cbToWrite = csecToWrite * cbSec;

	if ( cbToWrite == 0 )
		goto EndOfWrite2;

#ifdef DEBUG
	if (fDBGTraceLogWrite)
		PrintF2(
			"\n2.Writing %d sectors into sector %d from buffer (%u,%u).",
			csecToWrite, isecWriteNew, pbWriteNew, pbEntry);
#endif

#ifdef NO_WRITE
	goto EndOfWrite2;
#endif

 	err = ErrUtilWriteBlock(
		hfLog,
		pbWriteNew,
		cbToWrite,
		&cbWritten );
	if ( err < 0 )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, LOG_FLUSH_WRITE_2_ERROR_ID, err );
		fLGNoMoreLogWrite = fTrue;
		goto HandleError;
		}
 	Assert( cbWritten == cbToWrite );

	/*  monitor statistics  */

	cLogWrites++;
	cbLogWritten += cbWritten;

EndOfWrite2:

#ifdef NO_WRITE
	goto EndOfWrite3;
#endif
 	err = ErrUtilWriteBlock(
		hfLog,
		pbWriteNew + cbToWrite - cbSec,
		cbSec,
		&cbWritten );
	if ( err < 0 )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, LOG_FLUSH_WRITE_3_ERROR_ID, err );
		fLGNoMoreLogWrite = fTrue;
		goto HandleError;
		}
 	Assert( cbWritten == cbSec );

	/*  monitor statistics  */

	cLogWrites++;
	cbLogWritten += cbWritten;

#ifdef NO_WRITE
EndOfWrite3:
#endif

	/*	last page is always not full, need to rewrite next time
	/**/
	Assert( pbWriteNew + cbToWrite > pbFlushEnd );

	pbWriteNew += cbToWrite - cbSec;
	Assert( pbWriteNew < pbFlushEnd );
	Assert( pbWriteNew != NULL && pbWriteNew == PbSecAligned( pbWriteNew ) );

	isecWriteNew += csecToWrite - 1;
	Assert( isecWriteNew >= isecWrite && isecWrite >= csecHeader );
	Assert( isecWriteNew <= lgposToFlushT.isec );

	/*	free up buffer space
	/**/
	EnterCriticalSection( critLGBuf );

	Assert( pbWriteNew < pbLGBufMax && pbWriteNew >= pbLGBufMin );
	Assert( pbWriteNew != NULL && pbWriteNew == PbSecAligned( pbWriteNew ) );
	Assert( isecWriteNew >= isecWrite && isecWrite >= csecHeader );
	Assert( isecWriteNew <= lgposToFlushT.isec );

	AssertCriticalSection( critLGBuf );
	lgposToFlush = lgposToFlushT;
	isecWrite = isecWriteNew;
	pbWrite = pbWriteNew;

	/* if it is for new log file, then we skip the last sector. */
	if ( pbLGFileEndT )
		{
		Assert( isecLGFileEnd && isecLGFileEnd <= csecLGFile - 1 );
		pbWrite += cbSec;
		if ( pbWrite == pbLGBufMax )
			pbWrite = pbLGBufMin;
		}

	/* reset last lrtypEnd for next flush */
	*(LRTYP *)pbFlushEnd = lrtypNOP;

	LeaveCriticalSection(critLGBuf);

	/*  go through the waiting list and wake those whose log records
	/*  were flushed in this batch.
	/**/
WakeUp:
		{
		PIB *ppibT;

		/*	wake it up!
		/**/
		EnterCriticalSection( critLGWaitQ );

		for ( ppibT = ppibLGFlushQHead;
			ppibT != ppibNil;
			ppibT = ppibT->ppibNextWaitFlush )
			{
			if ( CmpLgpos( &ppibT->lgposPrecommit0, &lgposToFlushT ) < 0 )
				{
				Assert( ppibT->fLGWaiting );
				ppibT->fLGWaiting = fFalse;

				if ( ppibT->ppibPrevWaitFlush )
					{
					ppibT->ppibPrevWaitFlush->ppibNextWaitFlush =
						ppibT->ppibNextWaitFlush;
					}
				else
					{
					ppibLGFlushQHead = ppibT->ppibNextWaitFlush;
					}

				if ( ppibT->ppibNextWaitFlush )
					{
					ppibT->ppibNextWaitFlush->ppibPrevWaitFlush =
						ppibT->ppibPrevWaitFlush;
					}
				else
					{
					ppibLGFlushQTail = ppibT->ppibPrevWaitFlush;
					}

				SignalSend( ppibT->sigWaitLogFlush );
				}
			}
		LeaveCriticalSection( critLGWaitQ );
		}

	/*	it is time for check point?
	/**/
	if ( ( csecLGCheckpointCount -= ( csecWrapAround + csecToWrite ) ) < 0 )
		{
		csecLGCheckpointCount = csecLGCheckpointPeriod;

		/*	update checkpoint
		/**/
		LGUpdateCheckpointFile( fFalse );

		fDoneCheckpoint = fTrue;
		}

#ifdef DEBUG
	EnterCriticalSection( critLGBuf );
	if ( !fRecovering && pbLastMSFlush )
		{
		LRMS *plrms = (LRMS *)pbLastMSFlush;
		Assert( plrms->lrtyp == lrtypMS );
		}
	LeaveCriticalSection( critLGBuf );
#endif

	/*  check if new generation should be created. If larger than
	 *	desired LG File size or	requested a new log file. We always
	 *	always reserve one sector for shadow.
	 */
	if ( pbLGFileEndT != pbNil )
		{
		Assert( isecLGFileEnd && isecLGFileEnd <= csecLGFile - 1 );

		if ( !fDoneCheckpoint )
			{
			/*	restart check point counter
			/**/
			csecLGCheckpointCount = csecLGCheckpointPeriod;

			/*	obtain checkpoint
			/**/
			LGUpdateCheckpointFile( fFalse );
			}

		Call( ErrLGNewLogFile( plgfilehdrGlobal->lGeneration, fLGOldLogExists ) );

		/*	set global variables
		/**/
		strcpy( szFNameT, szJet );
		LGMakeLogName( szLogName, szFNameT );

 		err = ErrUtilOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse );
		if ( err < 0 )
			{
			UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, LOG_FLUSH_OPEN_NEW_FILE_ERROR_ID, err );
			fLGNoMoreLogWrite = fTrue;
			goto HandleError;
			}

//		the hdr is stored in plgfilehdrGlobalT. No need to reread it.
//		Call( ErrLGReadFileHdr( hfLog, plgfilehdrGlobalT ) );
//		Assert( isecWrite == csecHeader );

		/*	flush to new log file
		/**/
		EnterCriticalSection( critLGBuf );

		Assert( plgfilehdrGlobalT->lGeneration == plgfilehdrGlobal->lGeneration + 1 );
		memcpy( plgfilehdrGlobal, plgfilehdrGlobalT, sizeof( LGFILEHDR ) );
		isecWrite = csecHeader;
		pbLGFileEnd =
		pbLGFileEndT = pbNil;
		isecLGFileEnd = 0;

		goto DoFlush;
		}

HandleError:
	LeaveCriticalSection( critLGFlush );

	return err;
	}


/********************* CHECKPOINT **************************
/***********************************************************
/**/

VOID LGLoadAttachmentsFromFMP( BYTE *pbBuf, INT cb )
	{
	ERR		err = JET_errSuccess;
	DBID	dbidT;
	BYTE	*pbT;
	INT		cbT;

	AssertCriticalSection( critJet );

	pbT = pbBuf;
	for ( dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
		{
		if ( rgfmp[dbidT].pdbfilehdr != NULL )
			{
			/*	store DBID
			/**/
			*pbT = (BYTE) dbidT;
			pbT++;

			/*	store loggable info
			/**/
			*pbT = (BYTE)FDBIDLogOn(dbidT);
			pbT++;

			// Versioning can only be disabled if logging is disabled.
			Assert( !( FDBIDVersioningOff( dbidT )  &&  FDBIDLogOn( dbidT ) ) );
			*pbT = (BYTE)FDBIDVersioningOff(dbidT);
			pbT++;

			/*	store ReadOnly info
			/**/
			*pbT = (BYTE)FDBIDReadOnly(dbidT);
			pbT++;

			/*	store lgposAttch
			/**/
			*(LGPOS UNALIGNED *)pbT = rgfmp[dbidT].pdbfilehdr->lgposAttach;
			pbT += sizeof(LGPOS);

			/*	store lgposConsistent
			/**/
			*(LGPOS UNALIGNED *)pbT = rgfmp[dbidT].pdbfilehdr->lgposConsistent;
			pbT += sizeof(LGPOS);

			/*	copy Signature
			/**/
			memcpy( pbT, &rgfmp[dbidT].pdbfilehdr->signDb, sizeof( SIGNATURE ) );
			pbT += sizeof( SIGNATURE );

			/*	path length
			/**/
			cbT = strlen( rgfmp[dbidT].szDatabaseName );
			*(SHORT UNALIGNED *)pbT = (WORD)cbT;
			pbT += sizeof(SHORT);

			/*	copy path
			/**/
			memcpy( pbT, rgfmp[dbidT].szDatabaseName, cbT );
			pbT += cbT;
			}
		}

	/*	put a sentinal
	/**/
	*pbT = '\0';

	//	UNDONE: next version we will allow it go beyond 4kByte limit
	Assert( pbBuf + cb > pbT );
	}


ERR ErrLGLoadFMPFromAttachments( BYTE *pbAttach )
	{
	BYTE	*pbT;
	INT		cbT;

	pbT = pbAttach;
	while( *pbT != 0 )
		{
		DBID dbidT;

		/*	get DBID
		/**/
		dbidT = *pbT;
		pbT++;

		/*	get loggable info
		/**/
		if ( *pbT )
			DBIDSetLogOn( dbidT );
		else
			DBIDResetLogOn( dbidT );
		pbT++;

		// Versioning can only be disabled if logging is disabled.
		if ( *pbT )
			DBIDSetVersioningOff( dbidT );
		else
			DBIDResetVersioningOff( dbidT );
		
		pbT++;
		Assert( !( FDBIDVersioningOff( dbidT ) && FDBIDLogOn( dbidT ) ) );

		/*	get readonly info
		/**/
		if ( *pbT )
			DBIDSetReadOnly( dbidT );
		else
			DBIDResetReadOnly( dbidT );
		pbT++;

		/*	get lgposAttch
		/**/
		if ( rgfmp[dbidT].patchchk == NULL )
			if (( rgfmp[dbidT].patchchk = SAlloc( sizeof( ATCHCHK ) ) ) == NULL )
				return ErrERRCheck( JET_errOutOfMemory );
			
		rgfmp[dbidT].patchchk->lgposAttach = *(LGPOS UNALIGNED *)pbT;
		pbT += sizeof(LGPOS);

		rgfmp[dbidT].patchchk->lgposConsistent = *(LGPOS UNALIGNED *)pbT;
		pbT += sizeof(LGPOS);

		/*	copy signature
		/**/
		memcpy( &rgfmp[dbidT].patchchk->signDb, pbT, sizeof( SIGNATURE ) );
		pbT += sizeof( SIGNATURE );

		/*	path length
		/**/
		cbT = *(SHORT UNALIGNED *)pbT;
		pbT += sizeof(SHORT);

		/*	copy path
		/**/
		if ( rgfmp[dbidT].szDatabaseName )
			SFree( rgfmp[dbidT].szDatabaseName );

		if ( !( rgfmp[dbidT].szDatabaseName = SAlloc( cbT + 1 ) ) )
			return ErrERRCheck( JET_errOutOfMemory );

		memcpy( rgfmp[dbidT].szDatabaseName, pbT, cbT );
		rgfmp[dbidT].szDatabaseName[ cbT ] = '\0';
		pbT += cbT;
		}

	return JET_errSuccess;
	}


VOID LGSetDBMSParam( DBMS_PARAM *pdbms_param )
	{
	CHAR	rgbT[JET_cbFullNameMost + 1];
	INT		cbT;
	CHAR	*sz;

	sz = _fullpath( pdbms_param->szSystemPath, szSystemPath, JET_cbFullNameMost );
	Assert( sz != NULL );

	cbT = strlen( szLogFilePath );

	while ( szLogFilePath[ cbT - 1 ] == '\\' )
		cbT--;

	if ( szLogFilePath[cbT - 1] == ':' && szLogFilePath[cbT] == '\\' )
		cbT++;

	memcpy( rgbT, szLogFilePath, cbT );
	rgbT[cbT] = '\0';
	sz = _fullpath( pdbms_param->szLogFilePath, rgbT, JET_cbFullNameMost );
	Assert( sz != NULL );

	Assert( lMaxSessions >= 0 );
	Assert( lMaxOpenTables >= 0 );
	Assert( lMaxVerPages >= 0 );
	Assert( lMaxCursors >= 0 );
	Assert( lLogBuffers >= lLogBufferMin );
	Assert( lMaxBuffers >= lMaxBuffersMin );

	pdbms_param->ulMaxSessions = lMaxSessions;
	pdbms_param->ulMaxOpenTables = lMaxOpenTables;
	pdbms_param->ulMaxVerPages = lMaxVerPages;
	pdbms_param->ulMaxCursors = lMaxCursors;
	pdbms_param->ulLogBuffers = lLogBuffers;
	pdbms_param->ulcsecLGFile = csecLGFile;
	pdbms_param->ulMaxBuffers = lMaxBuffers;

	return;
	}


/*	this checkpoint design is an optimization.  JET logging/recovery
/*	can still recover a database without a checkpoint, but the checkpoint
/*	allows faster recovery by directing recovery to begin closer to
/*	logged operations which must be redone.
/**/

/*	in-memory checkpoint
/**/
CHECKPOINT	*pcheckpointGlobal = NULL;
/*	critical section to serialize read/write of in-memory and on-disk
/*	checkpoint.  This critical section can be held during IO.
/**/
CRIT critCheckpoint = NULL;
/*	disable checkpoint write if checkpoint shadow sector corrupted.
/*	Default to true until checkpoint initialization.
/**/
BOOL   	fDisableCheckpoint = fTrue;
#ifdef DEBUG
BOOL   	fDBGFreezeCheckpoint = fFalse;
#endif


/*  monitor statistics  */

PM_CEF_PROC LLGCheckpointDepthCEFLPpv;

LONG LLGCheckpointDepthCEFLPpv( LONG iInstance, VOID *pvBuf )
	{
	if ( pvBuf && pcheckpointGlobal )
		{
		LONG	cb;

		cb = (LONG) CbOffsetLgpos( lgposLogRec, pcheckpointGlobal->lgposCheckpoint );
		*( (ULONG *)((CHAR *)pvBuf)) = fDisableCheckpoint ? 0 : (ULONG) max( cb, 0 );
		}

	return 0;
	}


VOID LGFullNameCheckpoint( CHAR *szFullName )
	{
	ULONG	cbSystemPath = strlen( szSystemPath );
	
	if ( cbSystemPath > 0 )
		{
		strcpy( szFullName, szSystemPath );
		switch( szSystemPath[ cbSystemPath-1 ] )
			{
			case '\\':
			case ':':
				break;

			case '/':
				// Convert forward slash to backslash.
				szFullName[ cbSystemPath-1 ] = '\\';
				break;

			default:
				// Append trailing backslash if required.
				strcat( szFullName, "\\" );
			}
		strcat( szFullName, szJet );
		}
	else
		{
		strcpy( szFullName, szJet );
		}

	strcat( szFullName, szChkExt );

	return;
	}


ERR ErrLGCheckpointInit( BOOL *pfGlobalNewCheckpointFile )
	{
	ERR 	err;
	HANDLE	hCheckpoint = handleNil;
	BYTE	szPathJetChkLog[_MAX_PATH + 1];

	AssertCriticalSection( critJet );

	*pfGlobalNewCheckpointFile = fFalse;

	Assert( critCheckpoint == NULL );
	Call( ErrUtilInitializeCriticalSection( &critCheckpoint ) );

	Assert( pcheckpointGlobal == NULL );
	pcheckpointGlobal = (CHECKPOINT *)PvUtilAllocAndCommit( sizeof(CHECKPOINT) );
	if ( pcheckpointGlobal == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	Assert( hCheckpoint == handleNil );
	LGFullNameCheckpoint( szPathJetChkLog );
 	err = ErrUtilOpenFile( szPathJetChkLog, &hCheckpoint, 0, fFalse, fFalse );

	if ( err == JET_errFileNotFound )
		{
		pcheckpointGlobal->lgposCheckpoint.lGeneration = 1; /* first generation */
		pcheckpointGlobal->lgposCheckpoint.isec = (WORD) (sizeof( LGFILEHDR ) / cbSec);
		pcheckpointGlobal->lgposCheckpoint.ib = 0;

		*pfGlobalNewCheckpointFile = fTrue;
		}
	else
		{
		if ( err >= JET_errSuccess )
			{
			CallS( ErrUtilCloseFile( hCheckpoint ) );
			hCheckpoint = handleNil;
			}
		}

	fDisableCheckpoint = fFalse;
	err = JET_errSuccess;
	
HandleError:
	if ( err < 0 )
		{
		if ( critCheckpoint != NULL )
			{
			UtilDeleteCriticalSection( critCheckpoint );
			critCheckpoint = NULL;
			}
		if ( pcheckpointGlobal != NULL )
			{
			UtilFree( pcheckpointGlobal );
			pcheckpointGlobal = NULL;
			}
		}

	Assert( hCheckpoint == handleNil );
	return err;
	}


VOID LGCheckpointTerm( VOID )
	{
	if ( pcheckpointGlobal != NULL )
		{
		fDisableCheckpoint = fTrue;
		UtilFree( pcheckpointGlobal );
		pcheckpointGlobal = NULL;
		UtilDeleteCriticalSection( critCheckpoint );
		critCheckpoint = NULL;
		}

	return;
	}


/*	read checkpoint from file.
/**/
ERR ErrLGIReadCheckpoint( CHAR *szCheckpointFile, CHECKPOINT *pcheckpoint )
	{
	ERR		err;

	EnterCriticalSection( critCheckpoint );
	
	err = ErrUtilReadShadowedHeader( szCheckpointFile, (BYTE *)pcheckpoint, sizeof(CHECKPOINT) );
	if ( err < 0 )
		{
		/*	it should never happen that both checkpoints in the checkpoint
		/*	file are corrupt.  The only time this can happen is with a
		/*	hardware error.
		/**/
		err = ErrERRCheck( JET_errCheckpointCorrupt );
		}
	else if ( fSignLogSetGlobal )
		{
		if ( memcmp( &signLogGlobal, &pcheckpoint->signLog, sizeof( signLogGlobal ) ) != 0 )
			err = ErrERRCheck( JET_errBadCheckpointSignature );
		}

	LeaveCriticalSection( critCheckpoint );
	
	return err;
	}


/*	write checkpoint to file.
/**/
ERR ErrLGIWriteCheckpoint( CHAR *szCheckpointFile, CHECKPOINT *pcheckpoint )
	{
	ERR		err;
	
	AssertCriticalSection( critCheckpoint );
	Assert( pcheckpoint->lgposCheckpoint.isec >= csecHeader );
	Assert( pcheckpoint->lgposCheckpoint.lGeneration >= 1 );

	err = ErrUtilWriteShadowedHeader( szCheckpointFile, (BYTE *)pcheckpoint, sizeof(CHECKPOINT));
	
	if ( err < 0 )
		fDisableCheckpoint = fTrue;

	return err;
	}


/*	update in memory checkpoint.
/*
/*	computes log checkpoint, which is the lGeneration, isec and ib
/*	of the oldest transaction which either modified a currently-dirty buffer
/*	an uncommitted version (RCE).  Recovery begins redoing from the
/*	checkpoint.
/*
/*	The checkpoint is stored in the checkpoint file, which is rewritten
/*	whenever a isecChekpointPeriod disk sectors are written.
/**/
INLINE LOCAL VOID LGIUpdateCheckpoint( CHECKPOINT *pcheckpoint )
	{
	PIB		*ppibT;
	LGPOS	lgposCheckpoint;

	AssertCriticalSection( critJet );
	Assert( !fLogDisabled );

#ifdef DEBUG
	if ( fDBGFreezeCheckpoint )
		return;
#endif

	/*	find the oldest transaction which dirtied a current buffer
	/**/
	BFOldestLgpos( &lgposCheckpoint );

	/*	find the oldest transaction with an uncommitted update
	 *	must be in critJet to make sure no new transaction are created.
	 */
	AssertCriticalSection( critJet );
	for ( ppibT = ppibGlobal; ppibT != NULL; ppibT = ppibT->ppibNext )
		{
		if ( ppibT->level != levelNil &&			/* pib active */
			 ppibT->fBegin0Logged &&				/* open transaction */
			 CmpLgpos( &ppibT->lgposStart, &lgposCheckpoint ) < 0 )
			{
			lgposCheckpoint = ppibT->lgposStart;
			}
		}

	if ( CmpLgpos( &lgposCheckpoint, &lgposMax ) == 0 )
		{
		/*	nothing logged, up to the last flush point
		/**/
		EnterCriticalSection(critLGBuf);
		pcheckpoint->lgposCheckpoint = lgposToFlush;
		Assert( pcheckpoint->lgposCheckpoint.isec >= csecHeader );
		LeaveCriticalSection(critLGBuf);
//		//	UNDONE:	mutex access to lgposLastMS
//		pcheckpoint->lgposCheckpoint.lGeneration = plgfilehdrGlobal->lGeneration;
		}
	else
		{
		/*	set the new checkpoint if it is valid and advancing
		 */
		if (	CmpLgpos( &lgposCheckpoint, &pcheckpoint->lgposCheckpoint ) > 0 &&
				lgposCheckpoint.isec != 0 )
			{
			Assert( lgposCheckpoint.lGeneration != 0 );
			pcheckpoint->lgposCheckpoint = lgposCheckpoint;
			}
		Assert( pcheckpoint->lgposCheckpoint.isec >= csecHeader );
		}

	/*	set DBMS parameters
	/**/
	LGSetDBMSParam( &pcheckpoint->dbms_param );
	Assert( pcheckpoint->dbms_param.ulLogBuffers );

	/*	set database attachments
	/**/
	LGLoadAttachmentsFromFMP( pcheckpoint->rgbAttach,
		(INT)(((BYTE *)(plgfilehdrGlobal + 1)) - plgfilehdrGlobal->rgbAttach) );

	if ( lgposFullBackup.lGeneration )
		{
		/*	full backup in progress
		/**/
		pcheckpoint->lgposFullBackup = lgposFullBackup;
		pcheckpoint->logtimeFullBackup = logtimeFullBackup;
		}

	if ( lgposIncBackup.lGeneration )
		{
		/*	incremental backup in progress
		/**/
		pcheckpoint->lgposIncBackup = lgposIncBackup;
		pcheckpoint->logtimeIncBackup = logtimeIncBackup;
		}

	return;
	}


/*	update checkpoint file.
/**/
VOID LGUpdateCheckpointFile( BOOL fUpdatedAttachment )
	{
	ERR		err = JET_errSuccess;
	LGPOS	lgposCheckpointT;
	BYTE	szPathJetChkLog[_MAX_PATH + 1];
	BOOL	fCheckpointUpdated;

	if ( fDisableCheckpoint || fLogDisabled || !fGlobalFMPLoaded )
		return;

	EnterCriticalSection( critJet );
	EnterCriticalSection( critCheckpoint );

	/*	save checkpoint
	/**/
	lgposCheckpointT = pcheckpointGlobal->lgposCheckpoint;

	/*	update checkpoint
	/**/
	LGIUpdateCheckpoint( pcheckpointGlobal );
	if ( CmpLgpos( &pcheckpointGlobal->lgposCheckpoint, &lgposCheckpointT ) > 0 )
		{
		fCheckpointUpdated = fTrue;
		}
	else
		{
		fCheckpointUpdated = fFalse;
		}
	LeaveCriticalSection( critJet );

	/*	if checkpoint unchanged then return JET_errSuccess
	/**/
	if ( fUpdatedAttachment || fCheckpointUpdated )
		{
		Assert( fSignLogSetGlobal );
		pcheckpointGlobal->signLog = signLogGlobal;
		
		LGFullNameCheckpoint( szPathJetChkLog );
		err = ErrLGIWriteCheckpoint( szPathJetChkLog, pcheckpointGlobal );

		if ( err < 0 )
			fDisableCheckpoint = fTrue;
		}

	LeaveCriticalSection( critCheckpoint );
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\logapi.c ===
#include "daestd.h"
#include <ctype.h>

DeclAssertFile;					/* Declare file name for assert macros */

/*	thread control variables
/**/
HANDLE	handleLGFlushLog;
BOOL	fLGFlushLogTerm = 0;
INT		cmsLGFlushPeriod = 0;
LONG	lCurrentFlushThreshold;

/*	global log disabled flag
/**/
BOOL	fLGNoMoreLogWrite = fFalse;
LS		lsGlobal = lsNormal;

INT		cLGWaitingUserMax = 3;
PIB		*ppibLGFlushQHead = ppibNil;
PIB		*ppibLGFlushQTail = ppibNil;

BOOL	fLGIgnoreVersion = 0;

#ifdef DEBUG
BOOL   	fDBGTraceLog = fFalse;
BOOL   	fDBGTraceLogWrite = fFalse;
BOOL   	fDBGTraceRedo = fFalse;
BOOL   	fDBGTraceBR = fFalse;
BOOL   	fDBGDontFlush = fFalse;
#endif

BOOL   	fNewLogRecordAdded = fFalse;	/* protected by critLGBuf */
BOOL   	fLogDisabled = fTrue;
/*	environment variable RECOVERY
/**/
BOOL   	fRecovering = fFalse;
BOOL   	fRecoveringMode = fRecoveringNone;
BOOL   	fHardRestore = fFalse;
static BOOL	fLogInitialized = fFalse;


	/*  monitoring statistics  */

unsigned long cLogRecords = 0;

PM_CEF_PROC LLGRecordsCEFLPpv;

long LLGRecordsCEFLPpv(long iInstance,void *pvBuf)
{
	if (pvBuf)
		*((unsigned long *)pvBuf) = cLogRecords;
		
	return 0;
}


VOID LGMakeLogName( CHAR *szLogName, CHAR *szFName )
	{
	strcpy( szLogName, szLogCurrent );
	strcat( szLogName, szFName );
	strcat( szLogName, szLogExt );
	}


ERR ErrLGInitLogBuffers( LONG lIntendLogBuffers )
	{
	ERR		err = JET_errSuccess;

	EnterCriticalSection( critLGBuf );
	
	csecLGBuf = lIntendLogBuffers + 1;

	Assert( csecLGBuf > 4 );
	//	UNDONE: enforce log buffer > a data page

	/*	reset log buffer
	/**/
	if ( pbLGBufMin )
		{
		UtilFree( pbLGBufMin );
		pbLGBufMin = NULL;
		}
	
	pbLGBufMin = (BYTE *) PvUtilAllocAndCommit( csecLGBuf * cbSec );
	if ( pbLGBufMin == NULL )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}

	/*	reserve extra buffer for read ahead in redo
	/**/
	csecLGBuf--;
	pbLGBufMax = pbLGBufMin + csecLGBuf * cbSec;

	lCurrentFlushThreshold = max ( lLogFlushThreshold, lLogBuffers / 2 );

HandleError:
	if ( err < 0 )
		{
		if ( pbLGBufMin )
			{
			UtilFree( pbLGBufMin );
			pbLGBufMin = NULL;
			}
		}

	LeaveCriticalSection( critLGBuf );
	return err;
	}


/*
 *  Initialize global variablas and threads for log manager.
 */
ERR ErrLGInit( BOOL *pfNewCheckpointFile )
	{
	ERR		err;
	CHAR	*szT;

	if ( fLogInitialized )
		return JET_errSuccess;

	Assert( fLogDisabled == fFalse );

#ifdef PERFCNT
//	{
//	CHAR	*sz;
//
//	if ( ( sz = GetDebugEnvValue ( "PERFCNT" ) ) != NULL )
//	{
		fPERFEnabled = fTrue;
//		SFree(sz);
//	}
//	else
//		fPERFEnabled = fFalse;
//	}
#endif


#ifdef DEBUG
	{
	CHAR	*sz;

	if ( ( sz = GetDebugEnvValue ( "TRACELOG" ) ) != NULL )
		{
		fDBGTraceLog = fTrue;
		SFree(sz);
		}
	else
		fDBGTraceLog = fFalse;

	if ( ( sz = GetDebugEnvValue ( "TRACELOGWRITE" ) ) != NULL )
		{
		fDBGTraceLogWrite = fTrue;
		SFree(sz);
		}
	else
		fDBGTraceLogWrite = fFalse;

	if ( ( sz = GetDebugEnvValue ( "FREEZECHECKPOINT" ) ) != NULL )
		{
		fDBGFreezeCheckpoint = fTrue;
		SFree(sz);
		}
	else
		fDBGFreezeCheckpoint = fFalse;

	if ( ( sz = GetDebugEnvValue ( "TRACEREDO" ) ) != NULL )
		{
		fDBGTraceRedo = fTrue;
		SFree(sz);
		}
	else
		fDBGTraceRedo = fFalse;

	if ( ( sz = GetDebugEnvValue ( "TRACEBR" ) ) != NULL )
		{
		fDBGTraceBR = atoi( sz );
		SFree(sz);
		}
	else
		fDBGTraceBR = 0;

	if ( ( sz = GetDebugEnvValue ( "DONTFLUSH" ) ) != NULL )
		{
		fDBGDontFlush = fTrue;
		SFree(sz);
		}
	else
		fDBGDontFlush = fFalse;
	
	if ( ( sz = GetDebugEnvValue ( "IGNOREVERSION" ) ) != NULL )
		{
		fLGIgnoreVersion = fTrue;
		SFree(sz);
		}
	else
		fLGIgnoreVersion = fFalse;
	}
#endif

	/*	initialize szLogFilePath
	/**/
	if ( szLogFilePath [ strlen( szLogFilePath ) - 1 ] != '\\' )
		strcat( szLogFilePath, "\\");

	/*	get cbSec
	/**/
	{
	CHAR  	rgbFullName[JET_cbFullNameMost];
	CHAR	szDriveT[_MAX_DRIVE + 1];
	ULONG	ulT;

	if ( _fullpath( rgbFullName, szLogFilePath, JET_cbFullNameMost ) == NULL )
		{
		CHAR	*szPathT = szLogFilePath;
		UtilReportEvent(
			EVENTLOG_ERROR_TYPE,
			LOGGING_RECOVERY_CATEGORY,
			FILE_NOT_FOUND_ERROR_ID,
			1, &szPathT );
		return ErrERRCheck( JET_errFileNotFound );
		}
	_splitpath( rgbFullName, szDriveT, NULL, NULL, NULL );
	strcat( szDriveT, "\\" );
	CallR( ErrUtilGetDiskFreeSpace( szDriveT, &ulT, &cbSec, &ulT, &ulT ) );

	Assert( cbSec >= 512 );
	csecHeader = sizeof( LGFILEHDR ) /cbSec;
	}

	/*	assuming everything will work out
	/**/
	fLGNoMoreLogWrite = fFalse;

	/*	log file header must be aligned on correct boundary for device;
	/*	which is 16-byte for MIPS and 512-bytes for at least one NT
	/*	platform.
	/**/
	if ( !( plgfilehdrGlobal = (LGFILEHDR *)PvUtilAllocAndCommit( sizeof(LGFILEHDR) * 2 ) ) )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	/*	assert 512-byte aligned
	/**/
	Assert( ( (ULONG_PTR)plgfilehdrGlobal & 0x000001ff ) == 0 );
	plgfilehdrGlobalT = plgfilehdrGlobal + 1;

	/*  create and initialize critcal sections
	/**/
	CallJ( ErrInitializeCriticalSection( &critLGBuf ), FreeLGFileHdr );
	CallJ( ErrInitializeCriticalSection( &critLGFlush ), FreeCritLGBuf );
	CallJ( ErrInitializeCriticalSection( &critLGWaitQ ), FreeCritLGFlush );

	/*	log file size must be at least a
	/*	header and at least 2 pages of log data.
	/*	Prevent overflow by limiting parmater values.
	/**/
	if ( lLogFileSize > 0xffffffff )
		{
		lLogFileSize = 0xffffffff;
		}
	csecLGFile = max( (ULONG) ( lLogFileSize * 1024 ) / cbSec,
		sizeof( LGFILEHDR ) / cbSec + 2 * cbPage / cbSec );

	/*	adjust log resource parameters to legal and local optimal values
	/*	make cbLogSec an integral number of disk sectors
	/*	enforce log file size greater than or equal to log buffer
	/**/
	if ( lLogBuffers >= csecLGFile )
		{
		CallJ( ErrERRCheck( JET_errInvalidParameter ), FreeCritLGWaitQ );
		}

	/* always start with new buffer here! */
	pbLGBufMin = NULL;		
	CallJ( ErrLGInitLogBuffers( lLogBuffers ), FreeCritLGWaitQ );

	/*	set check point period
	/**/
	csecLGCheckpointCount =
		csecLGCheckpointPeriod = lLGCheckPointPeriod;

	cmsLGFlushPeriod = lLogFlushPeriod;
	cLGWaitingUserMax = lLGWaitingUserMax;

	/*	create log buffer flush thread
	/**/
	CallJ( ErrSignalCreateAutoReset( &sigLogFlush, NULL ), FreeOLPLog2 );
	fLGFlushLogTerm = fFalse;
	CallJ( ErrUtilCreateThread( LGFlushLog,
		cbFlushLogStack, THREAD_PRIORITY_HIGHEST,
		&handleLGFlushLog ), FreeSigLogFlush );

	CallJ( ErrLGCheckpointInit( pfNewCheckpointFile ), FreeSigLogFlush );

	memset( &signLogGlobal, 0, sizeof( signLogGlobal ) );
	fSignLogSetGlobal = fFalse;

	/*	allocate log reserves, and set log state.
	/**/
	szT = szLogCurrent;
	szLogCurrent = szLogFilePath;
	(VOID)ErrLGNewLogFile( 0, fLGReserveLogs );
	szLogCurrent = szT;

	fLogInitialized = fTrue;

	return err;

FreeSigLogFlush:
	SignalClose( sigLogFlush );
FreeOLPLog2:
FreeCritLGWaitQ:
	UtilDeleteCriticalSection(critLGWaitQ);
FreeCritLGFlush:
	UtilDeleteCriticalSection(critLGFlush);
FreeCritLGBuf:
	UtilDeleteCriticalSection(critLGBuf);
FreeLGFileHdr:
	if ( plgfilehdrGlobal )
		{
		UtilFree( plgfilehdrGlobal );
		}
	return err;
	}


/*
 *  Soft start tries to start the system from current directory.
 *  The database maybe in one of the following state:
 *  1) no log files.
 *  2) database was shut down normally.
 *  3) database was rolled back abruptly.
 *  In case 1, a new log file is generated.
 *  In case 2, the last log file is opened.
 *  In case 3, soft redo is incurred.
 *  At the end of the function, it a proper szJetLog must exists.
 */
ERR ErrLGSoftStart( BOOL fAllowNoJetLog, BOOL fNewCheckpointFile, BOOL *pfJetLogGeneratedDuringSoftStart )
	{
	ERR			err;
	BOOL		fCloseNormally;
	BOOL		fSoftRecovery = fFalse;
	CHAR		szFNameT[_MAX_FNAME + 1];
	CHAR		szT[_MAX_FNAME + 1];
	BYTE   		szPathJetChkLog[_MAX_PATH + 1];
	LGFILEHDR	*plgfilehdrCurrent;
	LGFILEHDR	*plgfilehdrT = NULL;
	CHECKPOINT	*pcheckpointT = NULL;
	LONG		lgenT;

	*pfJetLogGeneratedDuringSoftStart = fFalse;

	/*	set szLogCurrent
	/**/
	szLogCurrent = szLogFilePath;

	//	CONSIDER: for tight check, we may check if all log files are
	//	CONSIDER: continuous by checking the generation number and
	//	CONSIDER: previous gen's creatiion date.

Start:
	/*	try to open current log file to decide the status of log files.
	/**/
	err = ErrLGOpenJetLog();
	if ( err < 0 )
		{
		if ( err == JET_errFileAccessDenied )
			goto HandleError;

		/*	neither szJetLog nor szJetTmpLog exist. If no old generation
		/*	files exists, gen a new logfile at generation 1, otherwise
		/*	check if fAllowNoJetLog is true, if it is, then
		/*	change the last generation log file to log file.
		/**/
		LGLastGeneration( szLogCurrent, &lgenT );
		if ( lgenT != 0 )
			{
			if ( !fAllowNoJetLog )
				{
				/*	if edbxxxxx.log exist but no edb.log, return error.
				/**/
				return JET_errMissingLogFile;
				}
			else
				{
				/*	move last generation log file to edb.log
				/**/
				CHAR szJetOldLog[_MAX_PATH + 1];

				/*	rename to szJetLog and restart
				/**/
				LGSzFromLogId ( szFNameT, lgenT );
				LGMakeLogName( szJetOldLog, szFNameT );
				strcpy( szFNameT, szJet );
				LGMakeLogName( szLogName, szFNameT );

				Call( ErrUtilMove( szJetOldLog, szLogName ) );
				goto Start;
				}
			}

		LeaveCriticalSection( critJet );
		EnterCriticalSection( critLGFlush );
		if ( ( err = ErrLGNewLogFile( 0, /* generation 0 + 1 */	fLGOldLogNotExists ) ) < 0 )
			{
			LeaveCriticalSection( critLGFlush );
			EnterCriticalSection( critJet );
			goto HandleError;
			}
		
		EnterCriticalSection( critLGBuf );
		memcpy( plgfilehdrGlobal, plgfilehdrGlobalT, sizeof( LGFILEHDR ) );
		isecWrite = csecHeader;
		LeaveCriticalSection( critLGBuf );
		
		LeaveCriticalSection( critLGFlush );
		EnterCriticalSection( critJet );

		/*	set flag for initialization
		/**/
		*pfJetLogGeneratedDuringSoftStart = fTrue;

		Assert( plgfilehdrGlobal->lGeneration == 1 );

		Assert( pbLastMSFlush == pbLGBufMin );
		Assert( lgposLastMSFlush.lGeneration == 1 );
		}
	else
		{
		/*	read current log file header
		/**/
		Call( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal, fCheckLogID ) );

		/*	re-initialize log buffers according to check pt env
		/**/
		Call( ErrLGInitLogBuffers( plgfilehdrGlobal->dbms_param.ulLogBuffers ) );

		/*	set up a special case for pbLastMSFlush
		/**/
		pbLastMSFlush = 0;
		memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );

		/*	read last written log record recorded in file header
		/*	into buffer, access last record logged, determine if we
		/*	finished normally last time.
		/**/
		Call( ErrLGCheckReadLastLogRecord( &fCloseNormally) );

		CallS( ErrUtilCloseFile( hfLog ) );
		hfLog = handleNil;

		/*	If the edb.log was not closed normally or the checkpoint file was
		 *	missing and new one is created, then do soft recovery.
		 */
		if ( !fCloseNormally || fNewCheckpointFile )
			{
			BOOL		fOpenFile = fFalse;

			/*	always redo from beginning of a log generation.
			/*	This is needed such that the attach info will be matching
			/*	the with the with the redo point. Note that the attach info
			/*	is not necessarily consistent with the checkpoint.
			/**/
			if ( plgfilehdrT == NULL )
				{
				plgfilehdrT = (LGFILEHDR *)PvUtilAllocAndCommit( sizeof(LGFILEHDR) );
				if  ( plgfilehdrT == NULL )
					{
					err = ErrERRCheck( JET_errOutOfMemory );
					goto HandleError;
					}
				}

			if ( pcheckpointT == NULL )
				{
				pcheckpointT = (CHECKPOINT *)PvUtilAllocAndCommit( sizeof(CHECKPOINT) );
				if  ( pcheckpointT == NULL )
					{
					err = ErrERRCheck( JET_errOutOfMemory );
					goto HandleError;
					}
				}

			/*  did not terminate normally and need to redo from checkpoint
			/**/
			LGFullNameCheckpoint( szPathJetChkLog );

			if ( fNewCheckpointFile )
				{
				/*	Delete the newly created empty checkpoint file.
				 *	Let redo recreate one.
				 */
				(VOID)ErrUtilDeleteFile( szPathJetChkLog );
				goto DoNotUseCheckpointFile;
				}
			else
				err = ErrLGIReadCheckpoint( szPathJetChkLog, pcheckpointT );

			/*	if checkpoint could not be read, then revert to redoing
			/*	log from first log record in first log generation file.
			/**/
			if ( err >= 0 )
				{
				logtimeFullBackup = pcheckpointT->logtimeFullBackup;
				lgposFullBackup = pcheckpointT->lgposFullBackup;
				logtimeIncBackup = pcheckpointT->logtimeIncBackup;
				lgposIncBackup = pcheckpointT->lgposIncBackup;
				
				if ( plgfilehdrGlobal->lGeneration == pcheckpointT->lgposCheckpoint.lGeneration )
					{
					err = ErrLGOpenJetLog();
					}
				else
					{
					LGSzFromLogId( szFNameT, pcheckpointT->lgposCheckpoint.lGeneration );
					strcpy( szT, szLogFilePath );
					strcat( szT, szFNameT );
					strcat( szT, szLogExt );
					err = ErrUtilOpenFile( szT, &hfLog, 0, fTrue, fFalse );
					}
				/*	read log file header
				/**/
				if ( err >= 0 )
					{
					fOpenFile = fTrue;
					err = ErrLGReadFileHdr( hfLog, plgfilehdrT, fCheckLogID );
					}
				if ( err >= 0 )
					{
					plgfilehdrCurrent = plgfilehdrT;
					}
				}
			else
				{
DoNotUseCheckpointFile:

				LGFirstGeneration( szLogFilePath, &lgenT );
				if ( lgenT == 0 )
					{
					plgfilehdrCurrent = plgfilehdrGlobal;
					err = JET_errSuccess;
					}
				else
					{
					LGSzFromLogId( szFNameT, lgenT );
					strcpy( szT, szLogFilePath );
					strcat( szT, szFNameT );
					strcat( szT, szLogExt );
					err = ErrUtilOpenFile( szT, &hfLog, 0, fTrue, fFalse );
					/*	read log file header
					/**/
					if ( err >= 0 )
						{
						fOpenFile = fTrue;
						err = ErrLGReadFileHdr( hfLog, plgfilehdrT, fCheckLogID );
						}
					if ( err >= 0 )
						{
						plgfilehdrCurrent = plgfilehdrT;
						}
					}
				}

			if ( err >= 0 )
				{
				pcheckpointT->dbms_param = plgfilehdrCurrent->dbms_param;
				pcheckpointT->lgposCheckpoint.lGeneration = plgfilehdrCurrent->lGeneration;
				pcheckpointT->lgposCheckpoint.isec = (WORD) csecHeader;
				pcheckpointT->lgposCheckpoint.ib = 0;
				memcpy( pcheckpointT->rgbAttach, plgfilehdrCurrent->rgbAttach, cbAttach );
				AssertCriticalSection( critJet );
				err = ErrLGLoadFMPFromAttachments( plgfilehdrCurrent->rgbAttach );
				}
				
			if ( fOpenFile )
				{
				CallS( ErrUtilCloseFile( hfLog ) );
				hfLog = handleNil;
				}

			Call( err );

			/*	set log path to current directory
			/**/
			Assert( szLogCurrent == szLogFilePath );

			UtilReportEvent( EVENTLOG_INFORMATION_TYPE, LOGGING_RECOVERY_CATEGORY, REDO_ID, 0, NULL );
			fSoftRecovery = fTrue;
	
			/*	redo from last checkpoint
			/**/
			errGlobalRedoError = JET_errSuccess;
			Call( ErrLGRedo( pcheckpointT, NULL ) )

			CallS( ErrUtilCloseFile( hfLog ) );
			hfLog = handleNil;

			if ( fGlobalRepair && errGlobalRedoError != JET_errSuccess )
				{
				Call( JET_errRecoveredWithErrors );
				}
			}
		}

	/*	at this point, we have a szJetLog file, reopen the log files
	/**/

	/*	re-initialize the buffer manager with user settings
	/**/
	Call( ErrLGInitLogBuffers( lLogBuffers ) );

	/*  reopen the log file
	/**/
	LGMakeLogName( szLogName, (CHAR *) szJet );
	Call( ErrUtilOpenFile( szLogName, &hfLog, 0L, fTrue, fFalse ) );
	Call( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal, fCheckLogID ) );

	/*	set up a special case for pbLastMSFlush
	/**/
	pbLastMSFlush = 0;
	memset( &lgposLastMSFlush, 0, sizeof(lgposLastMSFlush) );

	/*	set up log variables properly
	/**/
	Call( ErrLGCheckReadLastLogRecord(	&fCloseNormally ) );
	CallS( ErrUtilCloseFile( hfLog ) );
	hfLog = handleNil;
	Call( ErrUtilOpenFile( szLogName, &hfLog, 0L, fFalse, fFalse ) );

	/*	should be set properly
	/**/
	Assert( isecWrite != 0 );

	/*  pbEntry and pbWrite were set for next record in LocateLastLogRecord
	/**/
	Assert( pbWrite == PbSecAligned(pbWrite) );
	Assert( pbWrite <= pbEntry && pbEntry <= pbWrite + cbSec );

	/*  setup log flushing starting point
	/**/
	EnterCriticalSection( critLGBuf );
	GetLgposOfPbEntry( &lgposToFlush );
	LeaveCriticalSection( critLGBuf );

	Assert( fRecovering == fFalse );
 	Assert( fHardRestore == fFalse );

HandleError:
	if ( err < 0 )
		{
		Assert( fHardRestore == fFalse );

		if ( hfLog != handleNil )
			{
			CallS( ErrUtilCloseFile( hfLog ) );
			hfLog = handleNil;
			}

		if ( fSoftRecovery )
			{
			UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, 0, err );
			}
		}

	if ( plgfilehdrT != NULL )
		{
		UtilFree( plgfilehdrT );
		}

	if ( pcheckpointT != NULL )
		{
		UtilFree( pcheckpointT );
		}

	return err;
	}


/*	Terminates update logging.	Adds quit record to in-memory log,
/*	flushes log buffer to disk, updates checkpoint and closes active
/*	log generation file.  Frees buffer memory.
/*
/*	RETURNS	   JET_errSuccess, or error code from failing routine
/**/
ERR ErrLGTerm( BOOL fNeedFlushLogFile )
	{
	ERR		err = JET_errSuccess;

	/*	if logging has been initialized, terminate it!
	/**/
	if ( !fLogInitialized )
		return JET_errSuccess;

	if ( fLGNoMoreLogWrite || hfLog == handleNil )
		goto FreeResources;

	if ( !fNeedFlushLogFile )
		goto FreeResources;
		
	/*	last written sector should have been written during final flush
	/**/
	if ( !fRecovering )
		{
		Call( ErrLGQuit( &lgposStart ) );
		}

	LeaveCriticalSection( critJet );
#ifdef PERFCNT
	err = ErrLGFlushLog( 0 );	/* critical section not requested, not needed */
#else
	err = ErrLGFlushLog();		/* critical section not requested, not needed */
#endif
	EnterCriticalSection( critJet );
	Call( err );

	/*	flush must have checkpoint log so no need to do checkpoint again
	/**/
//	Call( ErrLGWriteFileHdr( plgfilehdrGlobal ) );

#ifdef PERFCNT
	if ( fPERFEnabled )
		{
		INT i;

		PrintF2("Group commit distribution:\n");

		PrintF2("          ");
		for (i = 0; i < 10; i++)
			PrintF2("%4d ", i);
		PrintF2("\n By User  ");

		for (i = 0; i < 10; i++)
			PrintF2("%4lu ", rgcCommitByUser[i]);
		PrintF2("\n By LG    ");

		for (i = 0; i < 10; i++)
			PrintF2("%4lu ", rgcCommitByLG[i]);
		PrintF2("\n");
		}
#endif

	/*	terminate LGFlushLog thread
	/**/
	Assert( handleLGFlushLog != 0 );

FreeResources:
HandleError:
	/*	terminate log checkpoint
	/**/
	LGCheckpointTerm();

	fLGFlushLogTerm = fTrue;
	LgLeaveCriticalSection(critJet);
	UtilEndThread( handleLGFlushLog, sigLogFlush );
	LgEnterCriticalSection(critJet);
	SignalClose(sigLogFlush);

	DeleteCriticalSection( critLGBuf );
	DeleteCriticalSection( critLGFlush );
	DeleteCriticalSection( critLGWaitQ );

	/*	close the log file
	/**/
	if ( hfLog != handleNil )
		{
		CallS( ErrUtilCloseFile( hfLog ) );
		hfLog = handleNil;
		}

	/*	clean up allocated resources
	/**/
	if ( pbLGBufMin )
		{
		UtilFree( pbLGBufMin );
		pbLGBufMin = NULL;
		}
	if ( plgfilehdrGlobal )
		{
		UtilFree( plgfilehdrGlobal );
		plgfilehdrGlobal = NULL;
		}
	
	fLogInitialized = fFalse;
	
	return err;
	}


/********************** LOGGING ****************************
/***********************************************************
/**/

VOID AddLogRec( BYTE *pb, INT cb, BYTE **ppbET )
	{
	CHAR *pbET = *ppbET;

	if ( pbWrite < pbET )
		{
		INT cbT;

		/*	check wrapparound case
		/**/
		if ( ( cbT = (INT)(pbLGBufMax - pbET) ) < cb )
			{
			memcpy( pbET, pb, cbT );
			pb += cbT;
			cb -= cbT;
			pbET = pbLGBufMin;
			}
		}
	memcpy( pbET, pb, cb );

	/*	return next available entry
	/**/
	*ppbET = pbET + cb;
	return;
	}


/*	check ulDBTime for each log record and return error if ulDBTime too
/*	close to log sequence number roll-over. Total is max uldbtime is 2 ** 36.
/**/
STATIC QWORD qwDBTimeSafeMost = (qwDBTimeMax - (1<<20));

ERR	ErrLGICheckLogSequence( BYTE *pb )
	{
	ERR		err = JET_errSuccess;
	QWORDX qwxDBTime;

	qwxDBTime.qw = 0;

	if ( !fRecovering )
		{
		switch ( (LRTYP)*pb )
			{
			default:
				Assert( err == JET_errSuccess );
				break;
			case lrtypInitFDP:
				{
				LRINITFDP *plr = (LRINITFDP *)pb;
				qwxDBTime.l = plr->ulDBTimeLow;
				qwxDBTime.h = plr->ulDBTimeHigh;
				break;
				}
			case lrtypSplit:
				{
				LRSPLIT *plr = (LRSPLIT *)pb;
				qwxDBTime.l = plr->ulDBTimeLow;
				qwxDBTime.h = plr->ulDBTimeHigh;
				break;
				}
			case lrtypEmptyPage:
				{
				LREMPTYPAGE *plr = (LREMPTYPAGE *)pb;
				qwxDBTime.l = plr->ulDBTimeLow;
				qwxDBTime.h = plr->ulDBTimeHigh;
				break;
				}
			case lrtypMerge:
				{
				LRMERGE *plr = (LRMERGE *)pb;
				qwxDBTime.l = plr->ulDBTimeLow;
				qwxDBTime.h = plr->ulDBTimeHigh;
				break;
				}
			case lrtypInsertNode:
			case lrtypInsertItemList:
			case lrtypReplace:
			case lrtypReplaceD:
			case lrtypFlagDelete:
			case lrtypUpdateHeader:
			case lrtypDelete:
			case lrtypInsertItem:
			case lrtypInsertItems:
			case lrtypFlagInsertItem:
			case lrtypFlagDeleteItem:
			case lrtypSplitItemListNode:
			case lrtypDeleteItem:
			case lrtypDelta:
			case lrtypLockBI:
			case lrtypCheckPage:
				{
				LRINSERTNODE *plr = (LRINSERTNODE *)pb;
				qwxDBTime.l = plr->ulDBTimeLow;
				qwxDBTime.h = plr->ulDBTimeHigh;
				break;
				}
			case lrtypELC:
				{
				LRELC *plr = (LRELC *)pb;
				qwxDBTime.l = plr->ulDBTimeLow;
				qwxDBTime.h = plr->ulDBTimeHigh;
				break;
				}
			case lrtypFreeSpace:
				{
				LRFREESPACE *plr = (LRFREESPACE *)pb;
				qwxDBTime.l = plr->ulDBTimeLow;
				qwxDBTime.h = (ULONG) plr->wDBTimeHigh;
				break;
				}
			}
		}

	if ( qwxDBTime.qw > qwDBTimeSafeMost )
		{
		err = ErrERRCheck( JET_errLogSequenceEnd );
		}

	return err;
	}


/*
 *	Add log record to circular log buffer. Signal flush thread to flush log
 *	buffer if at least cThreshold disk sectors are ready for flushing.
 *	Wait on log flush if we run out of log buffer space. Log records with
 *  variable data portions are added in several parts: first the fixed
 *  length portion of the record, then the variable portions of the record.
 *  If fFlush is set, buffer is flushed as soon as log record has been added.
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 */

#ifdef DEBUG
BYTE rgbDumpLogRec[ 8192 ];
extern BOOL fDBGNoLog;
#endif

ERR ErrLGLogRec( LINE *rgline, INT cline, BOOL fNewGen, LGPOS *plgposLogRec )
	{
	ERR		err = JET_errSuccess;
	INT		cbReq;
	INT		iline;
//	LGPOS	lgposEntryT;

//	AssertCriticalSection(critJet);
	Assert( fLogDisabled == fFalse );
	Assert( rgline[0].pb != NULL );

	Assert( !fDBGNoLog );

	/*	check for log sequence near end.
	/**/
	CallR( ErrLGICheckLogSequence( rgline[0].pb ) );

	/*	cbReq is total net space required for record
	/**/
	for ( cbReq = 0, iline = 0; iline < cline; iline++ )
		cbReq += rgline[iline].cb;

	/*	get pbEntry in order to add log record
	/**/
	forever
		{
		INT		ibEntry;
		INT		csecReady;
		INT		cbAvail;
		LGPOS	lgposLogRecT;
		INT		csecToExclude;
		INT		cbFraction;
		INT		csecToAdd;
		INT		isecLGFileEndT = 0;

		EnterCriticalSection( critLGBuf );
		if ( fLGNoMoreLogWrite )
			{
			LeaveCriticalSection( critLGBuf );
//			Assert( fFalse );
			return ErrERRCheck( JET_errLogWriteFail );
			}

		Assert( isecWrite == csecHeader || lgposLastMSFlush.isec );

		/*	if just initialized or no input since last flush
		/**/
		GetLgposOfPbEntry( &lgposLogRecT );
		
		/*	during recovering, we will add some log record. But the log file
		 *	may be patched already and need to generate a new log file. So
		 *	do not jump out if it is for recovery so that the it will be
		 *	checked if new log file need to be gnereated.
		 */
		if ( !fRecovering &&
			( pbEntry == pbWrite ||
			( lgposLogRecT.isec == lgposToFlush.isec &&
			lgposLogRecT.ib == lgposToFlush.ib ) ) )
			{
			break;
			}

		/*	calculate available space
		/**/
		if ( pbWrite > pbEntry )
			cbAvail = (INT)(pbWrite - pbEntry);
		else
			cbAvail = (INT)((pbLGBufMax - pbEntry) + (pbWrite - pbLGBufMin));

		/*	calculate sectors of buffer ready to flush. Excluding
		 *	the half filled sector.
		 */
		csecToExclude = ( cbAvail - 1 ) / cbSec + 1;
		csecReady = csecLGBuf - csecToExclude;

		/*	check if add this record, it will reach the point of
		 *	the sector before last sector of current log file and the point
		 *	is enough to hold a lrtypMS and lrtypEnd. Note we always
		 *	reserve the last sector as a shadow sector.
		 *	if it reach the point, check if there is enough space to put
		 *	NOP to the end of log file and cbLGMSOverhead of NOP's for the
		 *	first sector of next generation log file. And then set pbEntry
		 *	there and continue adding log record.
		 */
		
		if ( pbLGFileEnd != pbNil )
			{
			Assert( isecLGFileEnd != 0 );
			/* already creating new log, do not bother to check fNewGen. */
			goto AfterCheckEndOfFile;
			}
		
		ibEntry = (INT)(pbEntry - PbSecAligned(pbEntry));
		
		/*	check if after adding this record, the sector will reach
		 *	the sector before last sector. If it does, let's patch NOP.
		 */
		if ( fNewGen )
			{
			/* last sector is the one that will be patched with NOP */
			cbFraction = ibEntry + cbLGMSOverhead;
			csecToAdd = ( cbFraction - 1 ) / cbSec + 1;
			isecLGFileEndT = isecWrite + csecReady + csecToAdd;
			}
		else
			{
			/* check if new gen is necessary. */
			cbFraction = ibEntry + cbReq + cbLGMSOverhead;
			csecToAdd = ( cbFraction - 1 ) / cbSec + 1;
			if ( csecReady + isecWrite + csecToAdd >= ( csecLGFile - 1 ) )
				{
				isecLGFileEndT = csecLGFile - 1;
				fNewGen = fTrue;
				}
			}

		if ( fNewGen )
			{
			INT cbToFill, cbFilled;
			
			/*	Adding the new record, we will reach the point. So let's
			 *	check if there is enough space to patch NOP all the way to
			 *	the end of file. If not enough, then wait the log flush to
			 *	flush.
			 */
			INT csecToFill = isecLGFileEndT - ( isecWrite + csecReady );
			Assert( csecToFill > 0 || csecToFill == 0 && ibEntry == 0 );

			if ( ( cbAvail / cbSec ) <= csecToFill + 1 )
				/*	available space is not enough to fill to end of file plus
				 *	first sector of next generation. Wait flush to generate
				 *	more space.
				 */
				goto Restart;

			/*	now we have enough space to patch.
			 *	Let's set pbLGFileEnd for log flush to generate new log file.
			 */
			cbToFill = csecToFill * cbSec - ibEntry + cbLGMSOverhead;
			if ( pbEntry + cbToFill >= pbLGBufMax )
				{
				cbFilled = (INT)(pbLGBufMax - pbEntry);
				memset( pbEntry, lrtypNOP, cbFilled );
				cbFilled = cbToFill - cbFilled;
				Assert( cbFilled % cbSec == cbLGMSOverhead );
				memset( pbLGBufMin, lrtypNOP, cbFilled );
				pbEntry = pbLGBufMin + cbFilled;
				Assert( pbEntry < pbLGBufMax && pbEntry > pbLGBufMin );
				}
			else
				{
				Assert( pbEntry + cbToFill <= pbLGBufMax - cbSec + cbLGMSOverhead );
				cbFilled = cbToFill;
				memset( pbEntry, lrtypNOP, cbFilled );
				pbEntry += cbFilled;
				Assert( pbEntry < pbLGBufMax && pbEntry > pbLGBufMin );
				}
			
			pbLGFileEnd = pbEntry - cbLGMSOverhead;
			isecLGFileEnd = isecLGFileEndT;
			
			/* send signal to generate new log file */
			SignalSend( sigLogFlush );
			
			/* start all over again with new pbEntry, cbAvail etc. */
			LeaveCriticalSection( critLGBuf );
			continue;
			}
AfterCheckEndOfFile:

		if ( csecReady > lCurrentFlushThreshold )
			{
			/*	reach the threshold, flush before adding new record
			/**/
			SignalSend( sigLogFlush );
			}

		/* make sure cbAvail is enough to hold one LRMS and end type.
		 */
		if ( cbAvail > (INT) ( cbReq + cbLGMSOverhead ) )
			{
			/*	no need to flush */
			break;
			}
		else
			{
			/*	restart.  Leave critical section for other users
			/**/
Restart:
			SignalSend( sigLogFlush );
			LeaveCriticalSection( critLGBuf );
			return ErrERRCheck( errLGNotSynchronous );
			}
		}

	/*	now we are holding pbEntry, let's add the log record.
	/**/
	GetLgposOfPbEntry( &lgposLogRec );
	if ( plgposLogRec )
		*plgposLogRec = lgposLogRec;
	fNewLogRecordAdded = fTrue;

#ifdef DEBUG
	{
	CHAR *pbEntryT = (pbEntry == pbLGBufMax) ? pbLGBufMin : pbEntry;
#endif

	for ( iline = 0; iline < cline; iline++ )
		{
		AddLogRec( rgline[iline].pb, rgline[iline].cb, &pbEntry );
		}

	/*	add a dummy fill record to indicate end-of-data
	/**/
	if ( pbEntry == pbLGBufMax )
		pbEntry = pbLGBufMin;
	((LR *)pbEntry)->lrtyp = lrtypEnd;
	Assert( pbEntry < pbLGBufMax && pbEntry >= pbLGBufMin );

#ifdef DEBUG
	if ( fDBGTraceLog )
		{
		extern INT cNOP;
		DWORD dwCurrentThreadId = DwUtilGetCurrentThreadId();
		BYTE *pb;
		
		EnterCriticalSection( critDBGPrint );

		/*	must access rgbDumpLogRec in critDBGPrint.
		 */
		pb = rgbDumpLogRec;
		for ( iline = 0; iline < cline; iline++ )
			{
			memcpy( pb, rgline[iline].pb, rgline[iline].cb );
			pb += rgline[iline].cb;
			}

		if ( cNOP >= 1 && ((LR *)rgbDumpLogRec)->lrtyp != lrtypNOP )
			{
			FPrintF2( " * %d", cNOP );
			cNOP = 0;
			}

		if ( cNOP == 0 || ((LR *)rgbDumpLogRec)->lrtyp != lrtypNOP )
			{
			if ( dwCurrentThreadId == dwBMThreadId || dwCurrentThreadId == dwLogThreadId )
				FPrintF2("\n$");
			else if ( FLGDebugLogRec( (LR *)rgbDumpLogRec ) )
				FPrintF2("\n#");
			else
				FPrintF2("\n<");
				
			FPrintF2(" {%u} ", dwCurrentThreadId );

			FPrintF2("%u,%u,%u", lgposLogRec.lGeneration, lgposLogRec.isec, lgposLogRec.ib );
			ShowLR( (LR *)rgbDumpLogRec );
			}
		
		LeaveCriticalSection( critDBGPrint );
		}
	}
#endif

//	GetLgposOfPbEntry( &lgposEntryT );

	/*  monitor statistics  */
	cLogRecords++;
		
	/*	now we are done with the insertion to buffer.
	/**/
	LeaveCriticalSection( critLGBuf );

	return JET_errSuccess;
	}


/*	Group commits, by waiting to give others a chance to flush this
/*	and other commits.
/**/
ERR ErrLGWaitPrecommit0Flush( PIB *ppib )
	{
	ERR err = JET_errSuccess;

	/*	assert not in critJet
	/**/
#ifdef DEBUG
	EnterCriticalSection( critJet );
	LeaveCriticalSection( critJet );
#endif
	
	if ( fLogDisabled || fRecovering && fRecoveringMode == fRecoveringUndo )
		return JET_errSuccess;

	/*  if there are too many user are waiting
	/*  or no wait time, then flush directly.
	/**/
	if ( cXactPerFlush >= cLGWaitingUserMax	|| ppib->lWaitLogFlush == 0 )
		{
#ifdef PERFCNT
		err = ErrLGFlushLog( 0 );
#else
		err = ErrLGFlushLog( );
#endif
		goto Done;
		}

	EnterCriticalSection( critLGBuf );
	if ( CmpLgpos( &ppib->lgposPrecommit0, &lgposToFlush ) <= 0 )
		{
		/*	it is flushed, no need to wait
		/**/
		LeaveCriticalSection( critLGBuf );
		goto Done;
		}

	/*	count number of waiting users
	/**/
	cXactPerFlush++;

	EnterCriticalSection( critLGWaitQ );

	Assert( !ppib->fLGWaiting );
	ppib->fLGWaiting = fTrue;
	ppib->ppibNextWaitFlush = ppibNil;

	if ( ppibLGFlushQHead == ppibNil )
		{
		ppibLGFlushQTail = ppibLGFlushQHead = ppib;
		ppib->ppibPrevWaitFlush = ppibNil;
		}
	else
		{
		Assert( ppibLGFlushQTail != ppibNil );
		ppib->ppibPrevWaitFlush = ppibLGFlushQTail;
		ppibLGFlushQTail->ppibNextWaitFlush = ppib;
		ppibLGFlushQTail = ppib;
		}

	LeaveCriticalSection( critLGWaitQ );
	LeaveCriticalSection( critLGBuf );

Wait:
	/*	wait for flushing task for a limited time
	/**/
	SignalWait( ppib->sigWaitLogFlush, ppib->lWaitLogFlush );

	{
	BOOL fLGWaiting;

	EnterCriticalSection( critLGWaitQ );
	fLGWaiting = ppib->fLGWaiting;
	LeaveCriticalSection( critLGWaitQ );
	if ( fLGWaiting )
		{
		/*	it is not flushed still, wake up the flush process again!
		/**/
		SignalSend( sigLogFlush );
		
		/*	it is blocked already, jump out
		/**/
		if ( fLGNoMoreLogWrite )
			{
			ppib->fLGWaiting = fFalse;
			err = ErrERRCheck( JET_errLogWriteFail );
			goto Done;
			}

		goto Wait;
		}
	}

#ifdef DEBUG
	{
	LGPOS lgposToFlushT;

	EnterCriticalSection( critLGBuf );
	lgposToFlushT = lgposToFlush;
	Assert( CmpLgpos( &lgposToFlush, &ppib->lgposPrecommit0 ) >= 0 );
	LeaveCriticalSection( critLGBuf );
	}
#endif

Done:
	Assert( err < 0 || ppib->fLGWaiting == fFalse );
	if ( err < 0 )
		{
		err = JET_errLogWriteFail;
		}

	return err;
	}


#ifndef NO_LOG

LOCAL VOID INLINE LGSetQwDBTime( BF *pbf, QWORD qwDBTime )
	{
	Assert( pbf->cPin );
	Assert( pbf->fDirty );
	AssertCriticalSection(critJet);
	
	Assert( QwPMDBTime( pbf->ppage ) <= qwDBTime );

	Assert( qwDBTime <= QwDBHDRDBTime( rgfmp[ DbidOfPn( pbf->pn ) ].pdbfilehdr ) &&
			qwDBTime >= QwDBHDRDBTime( rgfmp[ DbidOfPn( pbf->pn ) ].pdbfilehdr ) / 2 );

#ifdef DEBUG
	BFEnterCriticalSection( pbf );
	Assert( fRecovering || CmpLgpos( &pbf->lgposRC, &lgposMax ) != 0 );
	BFLeaveCriticalSection( pbf );
#endif  //  DEBUG

	PMSetDBTime( pbf->ppage, qwDBTime );
	}

LOCAL VOID INLINE LGIDepend( BF *pbf, LGPOS lgposLogRec )
	{
	Assert( pbf->fDirty );
	Assert( DbidOfPn( pbf->pn ) != dbidTemp );

#ifdef DEBUG
	if ( !pbf->fSyncWrite )
		{
		Assert( pbf->cPin || pbf->fHold );
		AssertCriticalSection(critJet);
		}
#endif

	BFEnterCriticalSection( pbf );	
	if ( CmpLgpos( &lgposLogRec, &pbf->lgposModify ) > 0 )
		pbf->lgposModify = lgposLogRec;
	BFLeaveCriticalSection( pbf );
	}

#define cpbfStep	8
LOCAL ERR ErrLGIIPrepareDepend( PIB *ppib, INT cpbf )
	{
	while ( ppib->ipbfLatchedAvail + cpbf >= ppib->cpbfLatchedMac )
		{
		BF **rgpbfLatchedOld = ppib->rgpbfLatched;
		INT cpbfLatchedMacOld = ppib->cpbfLatchedMac;
		BF **rgpbfLatched = SAlloc( sizeof( BF * ) * (cpbfLatchedMacOld + cpbfStep ) );
		if ( rgpbfLatched == NULL )
			return ErrERRCheck( JET_errOutOfMemory );

		memcpy( rgpbfLatched, rgpbfLatchedOld, sizeof( BF * ) * cpbfLatchedMacOld );
		memset( (rgpbfLatched + cpbfLatchedMacOld), 0, sizeof( BF * ) * cpbfStep );
		ppib->rgpbfLatched = rgpbfLatched;
		ppib->cpbfLatchedMac = cpbfLatchedMacOld + cpbfStep;
		if ( rgpbfLatchedOld )
			SFree( rgpbfLatchedOld );
		}

	return JET_errSuccess;
	}

LOCAL ERR INLINE ErrLGIPrepareDepend( PIB *ppib, INT cpbf )
	{
	if ( !ppib->fMacroGoing )
		return JET_errSuccess;

	return ErrLGIIPrepareDepend( ppib, cpbf );
	}


LOCAL VOID INLINE LGDepend( PIB *ppib, BF *pbf, LGPOS lgposLogRec )
	{
	if ( !ppib->fMacroGoing )
		LGIDepend( pbf, lgposLogRec );
	else
		{
		/*	Latch the buffer, set LG dependency of StopMacro.
		 */
		BFSetWriteLatch( pbf, ppib );
		Assert( ppib->ipbfLatchedAvail < ppib->cpbfLatchedMac );
		ppib->rgpbfLatched[ ppib->ipbfLatchedAvail++ ] = pbf;
		}
	}

//  same as above except we are already in the BFs critical section
LOCAL VOID INLINE LGDepend2( BF *pbf, LGPOS lgposLogRec )
	{
	Assert( pbf->fDirty );
	Assert( DbidOfPn( pbf->pn ) != dbidTemp );

#ifdef DEBUG
	if ( !pbf->fSyncWrite )
		{
		Assert( pbf->cPin || pbf->fHold );
		AssertCriticalSection(critJet);
		}
#endif

	if ( CmpLgpos( &lgposLogRec, &pbf->lgposModify ) > 0 )
		pbf->lgposModify = lgposLogRec;
	}


/**********************************************************/
/*****     deferred begin transactions                *****/
/**********************************************************/

INLINE LOCAL ERR ErrLGIDeferBeginTransaction( PIB *ppib );

INLINE LOCAL ERR ErrLGDeferBeginTransaction( PIB *ppib )
	{
	Assert( ppib->level > 0 );
	if ( ppib->levelDeferBegin != 0 )
		{
		return ErrLGIDeferBeginTransaction( ppib );
		}
	return JET_errSuccess;
	}


/**********************************************************/
/*****     Page Oriented Operations                   *****/
/**********************************************************/

ERR ErrLGInsertNode(
	LRTYP			lrtyp,
	FUCB			*pfucb,
	INT				lHeader,
	KEY				*pkey,
	LINE			*plineData,
	INT				fDIRFlags)
	{
	ERR				err;
	LINE			rgline[3];
	LRINSERTNODE	lrinsertnode;
	CSR				*pcsr;
	LGPOS			lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	Assert( !( fDIRFlags & fDIRNoLog ) );

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent( pfucb );

	lrinsertnode.lrtyp		= lrtyp;
	lrinsertnode.cbKey		= (BYTE) pkey->cb;
	lrinsertnode.cbData		= (WORD) plineData->cb;
	Assert( pfucb->ppib->procid < 64000 );
	lrinsertnode.procid		= (USHORT) pfucb->ppib->procid;
	lrinsertnode.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrinsertnode.fDirVersion	= ( fDIRFlags & fDIRVersion ) == fDIRVersion;

	lrinsertnode.bHeader	= (BYTE)lHeader;
	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrinsertnode.itagSon	= (BYTE)pcsr->itag;
	Assert(	pcsr->itagFather >= 0 && pcsr->itagFather <= 255 );
	lrinsertnode.itagFather = (BYTE)pcsr->itagFather;
	Assert(	pcsr->ibSon >= 0 &&	pcsr->ibSon <= 255 );
	lrinsertnode.ibSon		= (BYTE) pcsr->ibSon;

	rgline[0].pb = (BYTE *)&lrinsertnode;
	rgline[0].cb = sizeof(LRINSERTNODE);
	rgline[1].pb = pkey->pb;
	rgline[1].cb = pkey->cb;
	rgline[2].pb = plineData->pb;
	rgline[2].cb = plineData->cb;

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrinsertnode.ulDBTimeLow = qwxDBTime.l;
		lrinsertnode.ulDBTimeHigh = qwxDBTime.h;
		
		if ( ( err = ErrLGLogRec( rgline, 3, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );

	} while ( err == errLGNotSynchronous );

	LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


ERR ErrLGReplace( FUCB *pfucb, LINE *plineNew, INT fDIRFlags, INT cbOldData, BYTE *pbDiff, INT cbDiff )
	{
	ERR			err;
	LINE		rgline[2]; /* check ErrLGLogRec! */
	LRREPLACE	lrreplace;
	CSR			*pcsr;
	LGPOS		lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	Assert( !( fDIRFlags & fDIRNoLog ) );

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent(pfucb);

	Assert( pfucb->ppib->procid < 64000 );
	lrreplace.procid	= (USHORT) pfucb->ppib->procid;
	lrreplace.pn		= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrreplace.fDirVersion = ( fDIRFlags & fDIRVersion ) == fDIRVersion;

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrreplace.itag		= (BYTE)pcsr->itag;
	lrreplace.bm		= pcsr->bm;

	rgline[0].pb = (BYTE *)&lrreplace;
	rgline[0].cb = sizeof(LRREPLACE);

	lrreplace.cbNewData = (WORD) plineNew->cb;
	lrreplace.cbOldData = (USHORT)cbOldData;
	
	if ( cbDiff )
		{
		lrreplace.lrtyp	= lrtypReplaceD;
		lrreplace.cb = (USHORT) cbDiff;
		rgline[1].cb = cbDiff;
		rgline[1].pb = pbDiff;
		}
	else
		{
		lrreplace.lrtyp	= lrtypReplace;
		lrreplace.cb = (USHORT) plineNew->cb;
		rgline[1].cb = plineNew->cb;
		rgline[1].pb = plineNew->pb;
		}

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrreplace.ulDBTimeLow = qwxDBTime.l;
		lrreplace.ulDBTimeHigh = qwxDBTime.h;

		if ( ( err = ErrLGLogRec( rgline, 2, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	Assert(	lrreplace.lrtyp == lrtypReplaceD ||
			lrreplace.cbNewData == lrreplace.cb );
	LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


/*	Log record for pessimistic locking
/**/
ERR ErrLGLockBI( FUCB *pfucb, INT cbData )
	{
	ERR			err;
	LRLOCKBI	lrlockrec;
	LINE		rgline[1];
	CSR			*pcsr;
	LGPOS		lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent(pfucb);

	lrlockrec.lrtyp		= lrtypLockBI;
	Assert( pfucb->ppib->procid < 64000 );
	lrlockrec.procid	= (USHORT) pfucb->ppib->procid;
	lrlockrec.pn		= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrlockrec.itag		= (BYTE)pcsr->itag;
	lrlockrec.bm		= pcsr->bm;
	lrlockrec.cbOldData	= (USHORT)cbData;
	
	rgline[0].pb = (BYTE *)&lrlockrec;
	rgline[0].cb = sizeof(LRLOCKBI);

	Assert( (unsigned) cbData == pfucb->lineData.cb );

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrlockrec.ulDBTimeLow = qwxDBTime.l;
		lrlockrec.ulDBTimeHigh = qwxDBTime.h;

		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


/*	log Deferred Before Image of given RCE.
 */
ERR ErrLGDeferredBIWithoutRetry( RCE *prce )
	{
	ERR				err;
	FUCB   			*pfucb = prce->pfucb;
	LRDEFERREDBI	lrdbi;
	LINE   			rgline[2];
	LGPOS			lgposLogRecT;

	/*	NOTE: even during recovering, we might want to record it if
	 *	NOTE: it is logging during undo in LGEndAllSession.
	/**/
	if ( fLogDisabled )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	if ( fRecovering && fRecoveringMode == fRecoveringRedo )
		return errLGNotSynchronous;

	Assert( prce->pbfDeferredBI );

	lrdbi.lrtyp		= lrtypDeferredBI;
	Assert( pfucb->ppib->procid < 64000 );
	lrdbi.procid	= (USHORT) pfucb->ppib->procid;
	lrdbi.dbid		= prce->pfucb->dbid;
	lrdbi.bm		= prce->bm;
	lrdbi.level		= prce->level;
	lrdbi.cbData	= prce->cbData - cbReplaceRCEOverhead;
	
	rgline[0].pb = (BYTE *)&lrdbi;
	rgline[0].cb = sizeof(LRDEFERREDBI);

	rgline[1].pb = prce->rgbData + cbReplaceRCEOverhead;
	rgline[1].cb = lrdbi.cbData;

	err = ErrLGLogRec( rgline, 2, fNoNewGen, &lgposLogRecT );

	Assert( prce->pbfDeferredBI->fSyncRead == fFalse );
	Assert( prce->pbfDeferredBI->fAsyncRead == fFalse );
//	Assert( prce->pbfDeferredBI->fSyncWrite == fFalse );
	Assert( prce->pbfDeferredBI->fAsyncWrite == fFalse );
	Assert(	prce->pbfDeferredBI->fDirty );

	if ( err == JET_errSuccess )
		LGDepend2( prce->pbfDeferredBI, lgposLogRecT );

	return err;
	}


ERR ErrLGDeferredBI( RCE *prce )
	{
	FUCB   	*pfucb = prce->pfucb;
	LRDEFERREDBI	lrdbi;
	LINE   	rgline[2];
	LGPOS	lgposLogRecT;
	ERR		err;

	/*	NOTE: even during recovering, we might want to record it if
	 *	NOTE: it is logging during undo in LGEndAllSession.
	/**/
	if ( fLogDisabled )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	if ( fRecovering && fRecoveringMode == fRecoveringRedo )
		return errLGNotSynchronous;

	Assert( prce->pbfDeferredBI );

	lrdbi.lrtyp		= lrtypDeferredBI;
	Assert( pfucb->ppib->procid < 64000 );
	lrdbi.procid	= (USHORT) pfucb->ppib->procid;
	lrdbi.dbid		= pfucb->dbid;
	lrdbi.bm		= prce->bm;
	lrdbi.level		= prce->level;
	lrdbi.cbData	= prce->cbData - cbReplaceRCEOverhead;
	
	rgline[0].pb = (BYTE *)&lrdbi;
	rgline[0].cb = sizeof(LRDEFERREDBI);

	rgline[1].pb = prce->rgbData + cbReplaceRCEOverhead;
	rgline[1].cb = lrdbi.cbData;

	do
		{
		if ( ( err = ErrLGLogRec( rgline, 2, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	Assert( prce->pbfDeferredBI->fSyncRead == fFalse );
	Assert( prce->pbfDeferredBI->fAsyncRead == fFalse );
	Assert( prce->pbfDeferredBI->fSyncWrite == fFalse );
	Assert( prce->pbfDeferredBI->fAsyncWrite == fFalse );
	Assert(	prce->pbfDeferredBI->fDirty );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, prce->pbfDeferredBI, lgposLogRecT );
	return err;
	}


ERR ErrLGFlagDelete( FUCB *pfucb, INT fDIRFlags )
	{
	ERR				err;
	LRFLAGDELETE	lrflagdelete;
	LINE			rgline[1];
	CSR				*pcsr;
	LGPOS			lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	Assert( !( fDIRFlags & fDIRNoLog ) );

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent(pfucb);

	lrflagdelete.lrtyp		= lrtypFlagDelete;
	Assert( pfucb->ppib->procid < 64000 );
	lrflagdelete.procid		= (USHORT) pfucb->ppib->procid;
	lrflagdelete.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrflagdelete.fDirVersion	= ( fDIRFlags & fDIRVersion ) == fDIRVersion;

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrflagdelete.itag		= (BYTE)pcsr->itag;
	lrflagdelete.bm			= pcsr->bm;

	rgline[0].pb = (BYTE *)&lrflagdelete;
	rgline[0].cb = sizeof(LRFLAGDELETE);

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrflagdelete.ulDBTimeLow = qwxDBTime.l;
		lrflagdelete.ulDBTimeHigh = qwxDBTime.h;

		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


ERR ErrLGUpdateHeader( FUCB *pfucb, INT bHeader )
	{
	ERR				err;
	LRUPDATEHEADER	lr;
	LINE			rgline[1];
	CSR				*pcsr;
	LGPOS			lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent(pfucb);

	lr.lrtyp		= lrtypUpdateHeader;
	Assert( pfucb->ppib->procid < 64000 );
	lr.procid		= (USHORT) pfucb->ppib->procid;
	lr.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lr.bHeader		= (BYTE)bHeader;

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lr.itag			= (BYTE)pcsr->itag;
	lr.bm			= pcsr->bm;

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(LRUPDATEHEADER);

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lr.ulDBTimeLow = qwxDBTime.l;
		lr.ulDBTimeHigh = qwxDBTime.h;

		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}
	
	
ERR ErrLGDelete( FUCB *pfucb )
	{
	ERR			err;
	LRDELETE	lrdelete;
	LINE		rgline[1];
	CSR			*pcsr;
	LGPOS		lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent(pfucb);

	lrdelete.lrtyp		= lrtypDelete;
	Assert( pfucb->ppib->procid < 64000 );
	lrdelete.procid		= (USHORT) pfucb->ppib->procid;
	lrdelete.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrdelete.itag		= (BYTE)pcsr->itag;

	rgline[0].pb = (BYTE *)&lrdelete;
	rgline[0].cb = sizeof(LRDELETE);

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrdelete.ulDBTimeLow = qwxDBTime.l;
		lrdelete.ulDBTimeHigh = qwxDBTime.h;

		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


ERR ErrLGUndo(	RCE *prce )
	{
	FUCB   	*pfucb = prce->pfucb;
	LRUNDO	lrundo;
	LINE   	rgline[1];
	ERR		err;
	CSR		*pcsr;
	LGPOS	lgposLogRecT;

	/*	NOTE: even during recovering, we want to record it
	/**/
	if ( fLogDisabled || ( fRecovering && fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	lrundo.lrtyp		= lrtypUndo;
	Assert( pfucb->ppib->procid < 64000 );
	lrundo.procid		= (USHORT) pfucb->ppib->procid;
	lrundo.bm			= prce->bm;
	lrundo.dbid			= (BYTE) prce->pfucb->dbid;
	lrundo.level		= prce->level;
	lrundo.oper			= prce->oper == operReplaceWithDeferredBI ? operReplace : prce->oper;
	Assert( lrundo.oper == prce->oper );		/* regardless the size */
	Assert( lrundo.oper != operNull );
	pcsr = PcsrCurrent( pfucb );
	lrundo.bmTarget		= SridOfPgnoItag( pcsr->pgno, pcsr->itag );

	if ( prce->oper == operInsertItem ||
		prce->oper == operFlagInsertItem ||
		prce->oper == operFlagDeleteItem )
		{
		Assert( prce->cbData == sizeof(SRID) );
		lrundo.item	= *(SRID *)prce->rgbData;
		}
	else
		{
		lrundo.item	= 0;
		}

	rgline[0].pb = (BYTE *)&lrundo;
	rgline[0].cb = sizeof(LRUNDO);

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrundo.ulDBTimeLow = qwxDBTime.l;
		lrundo.wDBTimeHigh = (WORD) qwxDBTime.h;

		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


#if 0
ERR ErrLGFreeSpace( FUCB *pfucb, SRID bm, INT cbDelta )
	{
	LRFREESPACE	lrfs;
	LINE		rgline[1];
	ERR			err;
	CSR			*pcsr;
	LGPOS		lgposLogRecT;

	/* NOTE: even during recovering, we want to record it */
	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	lrfs.lrtyp		= lrtypFreeSpace;
	Assert( pfucb->ppib->procid < 64000 );
	lrfs.procid		= (USHORT) pfucb->ppib->procid;
	lrfs.bm			= bm;
	lrfs.dbid		= pfucb->dbid;
	lrfs.level		= pfucb->ppib->level;
	pcsr = PcsrCurrent( pfucb );
	lrfs.bmTarget  	= SridOfPgnoItag( pcsr->pgno, pcsr->itag );

	lrfs.cbDelta	= cbDelta;

	rgline[0].pb = (BYTE *)&lrfs;
	rgline[0].cb = sizeof(LRFREESPACE);

	do {
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrfs.ulDBTimeLow = qwxDBTime.l;
		lrfs.wDBTimeHigh = (WORD)qwxDBTime.h;

		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );
	
	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}
#endif	
	
ERR ErrLGExpungeLinkCommit( FUCB *pfucb, SSIB *pssibSrc, SRID sridSrc )
	{
	ERR		err;
	LRELC	lrelc;
	LINE	rgline[1];
	CSR		*pcsr;
	LGPOS	lgposLogRecT;

	/* can be called at level 1 only
	/**/
	Assert( pfucb->ppib->level == 1 );

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		{
		/*	since begin transaction may have defered a
		/*	begin even if logging disabled on this database
		/*	we must decrement deferred level begin if incremented.
		/**/
		if ( pfucb->ppib->levelDeferBegin > 0 )
			{
			pfucb->ppib->levelDeferBegin--;
			}
		return JET_errSuccess;
		}

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 2 ) );

	pcsr = PcsrCurrent(pfucb);

	lrelc.lrtyp		= lrtypELC;
	Assert( pfucb->ppib->procid < 64000 );
	lrelc.procid	= (USHORT) pfucb->ppib->procid;
	lrelc.pn		= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag >= 0 && pcsr->itag <= 255 );
	lrelc.itag		= (BYTE)pcsr->itag;
	lrelc.sridSrc	= sridSrc;

	rgline[0].pb = (BYTE *)&lrelc;
	rgline[0].cb = sizeof(LRELC);

	do {
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		LGSetQwDBTime( pssibSrc->pbf, qwxDBTime.qw );
		lrelc.ulDBTimeLow = qwxDBTime.l;
		lrelc.ulDBTimeHigh = qwxDBTime.h;

		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		{
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
		LGDepend( pfucb->ppib, pssibSrc->pbf, lgposLogRecT );
		}
	return err;
	}


ERR ErrLGInsertItem( FUCB *pfucb, INT fDIRFlags )
	{
	ERR				err;
	LINE			rgline[1];
	LRINSERTITEM	lrinsertitem;
	CSR				*pcsr;
	LGPOS			lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	Assert( !( fDIRFlags & fDIRNoLog ) );

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent( pfucb );

	lrinsertitem.lrtyp		= lrtypInsertItem;
	Assert( pfucb->ppib->procid < 64000 );
	lrinsertitem.procid		= (USHORT) pfucb->ppib->procid;
	lrinsertitem.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrinsertitem.fDirVersion	= ( fDIRFlags & fDIRVersion ) == fDIRVersion;

	Assert(	pcsr->itag > 0 && pcsr->itag <= 255 );
	lrinsertitem.itag		= (BYTE)pcsr->itag;
	Assert( pcsr->item != sridNull && pcsr->item != sridNullLink );
	lrinsertitem.srid		= pcsr->item;
	Assert( pcsr->bm != sridNull && pcsr->bm != sridNullLink );
	lrinsertitem.sridItemList = pcsr->bm;

	rgline[0].pb = (BYTE *)&lrinsertitem;
	rgline[0].cb = sizeof(LRINSERTITEM);

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrinsertitem.ulDBTimeLow = qwxDBTime.l;
		lrinsertitem.ulDBTimeHigh = qwxDBTime.h;
		
		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


ERR ErrLGInsertItems( FUCB *pfucb, ITEM *rgitem, INT citem )
	{
	ERR				err;
	LINE			rgline[2];
	LRINSERTITEMS	lrinsertitems;
	CSR				*pcsr;
	LGPOS			lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent(pfucb);

	lrinsertitems.lrtyp		= lrtypInsertItems;
	Assert( pfucb->ppib->procid < 64000 );
	lrinsertitems.procid	= (USHORT) pfucb->ppib->procid;
	lrinsertitems.pn		= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag > 0 && pcsr->itag <= 255 );
	lrinsertitems.itag		= (BYTE)pcsr->itag;
	lrinsertitems.citem		= (USHORT)citem;

	rgline[0].pb = (BYTE *)&lrinsertitems;
	rgline[0].cb = sizeof(LRINSERTITEMS);
	rgline[1].pb = (BYTE *)rgitem;
	rgline[1].cb = sizeof(ITEM) * citem;

	do {
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrinsertitems.ulDBTimeLow = qwxDBTime.l;
		lrinsertitems.ulDBTimeHigh = qwxDBTime.h;
		
		if ( ( err = ErrLGLogRec( rgline, 2, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


ERR	ErrLGDeleteItem( FUCB *pfucb )
	{
	ERR				err;
	LRDELETEITEM 	lrdeleteitem;
	LINE			rgline[1];
	CSR				*pcsr;
	LGPOS			lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent( pfucb );

	lrdeleteitem.lrtyp		= lrtypDeleteItem;
	Assert( pfucb->ppib->procid < 64000 );
	lrdeleteitem.procid		= (USHORT) pfucb->ppib->procid;
	lrdeleteitem.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag > 0 && pcsr->itag <= 255 );
	lrdeleteitem.itag		= (BYTE)pcsr->itag;
	lrdeleteitem.srid		= pcsr->item;
	lrdeleteitem.sridItemList	= pcsr->bm;

	rgline[0].pb = (BYTE *)&lrdeleteitem;
	rgline[0].cb = sizeof(LRDELETEITEM);

	do {
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrdeleteitem.ulDBTimeLow = qwxDBTime.l;
		lrdeleteitem.ulDBTimeHigh = qwxDBTime.h;
		
		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


ERR ErrLGFlagItem( FUCB *pfucb, LRTYP lrtyp )
	{
	ERR			err;
	LRFLAGITEM	lrflagitem;
	LINE		rgline[1];
	CSR			*pcsr;
	LGPOS		lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent(pfucb);

	lrflagitem.lrtyp		= lrtyp;
	Assert( pfucb->ppib->procid < 64000 );
	lrflagitem.procid		= (USHORT) pfucb->ppib->procid;
	lrflagitem.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );

	Assert(	pcsr->itag > 0 && pcsr->itag <= 255 );
	lrflagitem.itag			= (BYTE)pcsr->itag;
	lrflagitem.srid			= PcsrCurrent( pfucb )->item;
	lrflagitem.sridItemList	= PcsrCurrent( pfucb )->bm;

	rgline[0].pb = (BYTE *)&lrflagitem;
	rgline[0].cb = sizeof(LRFLAGITEM);

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrflagitem.ulDBTimeLow = qwxDBTime.l;
		lrflagitem.ulDBTimeHigh = qwxDBTime.h;
		
		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


ERR ErrLGSplitItemListNode(
	FUCB	*pfucb,
	INT		cItem,
	INT		itagFather,
	INT		ibSon,
	INT		itagToSplit,
	INT		fDIRFlags )
	{
	ERR		err;
	LINE	rgline[1];
	LRSPLITITEMLISTNODE lrsplititemlistnode;
	CSR		*pcsr;
	LGPOS	lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent(pfucb);

	lrsplititemlistnode.lrtyp	= lrtypSplitItemListNode;
	Assert( pfucb->ppib->procid < 64000 );
	lrsplititemlistnode.procid	= (USHORT) pfucb->ppib->procid;
	lrsplititemlistnode.pn		= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrsplititemlistnode.fDirAppendItem = ( fDIRFlags & fDIRAppendItem ) == fDIRAppendItem;

	lrsplititemlistnode.cItem		= (USHORT)cItem;
	Assert(	itagToSplit >= 0 && itagToSplit <= 255 );
	lrsplititemlistnode.itagToSplit	= (BYTE)itagToSplit;
	lrsplititemlistnode.itagFather	= (BYTE)itagFather;
	lrsplititemlistnode.ibSon		= (BYTE)ibSon;

	rgline[0].pb = (BYTE *)&lrsplititemlistnode;
	rgline[0].cb = sizeof(LRSPLITITEMLISTNODE);

	do {
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrsplititemlistnode.ulDBTimeLow = qwxDBTime.l;
		lrsplititemlistnode.ulDBTimeHigh = qwxDBTime.h;
		
		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


ERR ErrLGDelta( FUCB *pfucb, LONG lDelta, INT fDIRFlags )
	{
	LINE		rgline[1];
	LRDELTA	lrdelta;
	ERR		err;
	CSR		*pcsr;
	LGPOS	lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	pcsr = PcsrCurrent(pfucb);

	lrdelta.lrtyp		= lrtypDelta;
	Assert( pfucb->ppib->procid < 64000 );
	lrdelta.procid		= (USHORT) pfucb->ppib->procid;
	lrdelta.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrdelta.fDirVersion	= ( fDIRFlags & fDIRVersion ) == fDIRVersion;

	Assert(	pcsr->itag > 0 && pcsr->itag <= 255 );
	lrdelta.itag		= (BYTE)pcsr->itag;
	lrdelta.bm			= pcsr->bm;
	lrdelta.lDelta		= lDelta;

	rgline[0].pb = (BYTE *)&lrdelta;
	rgline[0].cb = sizeof( LRDELTA );

	do {
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrdelta.ulDBTimeLow = qwxDBTime.l;
		lrdelta.ulDBTimeHigh = qwxDBTime.h;
		
		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}


#ifdef DEBUG

ERR ErrLGCheckPage2( PIB *ppib, BF *pbf, SHORT cbFree, SHORT cbUncommitted, SHORT itagNext, PGNO pgnoFDP )
	{
	ERR				err;
	LINE 			rgline[1];
	LRCHECKPAGE		lrcheckpage;
	LGPOS			lgposLogRecT;
	DBID			dbid = DbidOfPn( pbf->pn );

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(dbid) )
		return JET_errSuccess;

	CallR( ErrLGIPrepareDepend( ppib, 1 ) );

	lrcheckpage.lrtyp		= lrtypCheckPage;
	Assert( ppib->procid < 64000 );
	lrcheckpage.procid		= (USHORT) ppib->procid;
	lrcheckpage.pn			= pbf->pn;
	lrcheckpage.pgnoFDP	= pgnoFDP;
	lrcheckpage.cbFree	= cbFree;
	lrcheckpage.cbUncommitted = cbUncommitted;
	lrcheckpage.itagNext = itagNext;

	rgline[0].pb = (BYTE *)&lrcheckpage;
	rgline[0].cb = sizeof( LRCHECKPAGE );

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ dbid ].pdbfilehdr );

		LGSetQwDBTime( pbf, qwxDBTime.qw );
		lrcheckpage.ulDBTimeLow = qwxDBTime.l;
		lrcheckpage.ulDBTimeHigh = qwxDBTime.h;

		NDCheckTreeInPage( pbf->ppage, itagFOP );
		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( ppib, pbf, lgposLogRecT );
	return err;
	}


ERR ErrLGCheckPage( FUCB *pfucb, SHORT cbFree, SHORT cbUncommitted, SHORT itagNext, PGNO pgnoFDP )
	{
	ERR				err;
	CSR				*pcsr = PcsrCurrent( pfucb );
	LINE 			rgline[1];
	LRCHECKPAGE		lrcheckpage;
	LGPOS			lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	assert in a transaction since will not redo level 0 modifications
	/**/
	Assert( pfucb->ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 1 ) );

	lrcheckpage.lrtyp		= lrtypCheckPage;
	Assert( pfucb->ppib->procid < 64000 );
	lrcheckpage.procid		= (USHORT) pfucb->ppib->procid;
	lrcheckpage.pn			= PnOfDbidPgno( pfucb->dbid, pcsr->pgno );
	lrcheckpage.pgnoFDP	= pgnoFDP;
	lrcheckpage.cbFree	= cbFree;
	lrcheckpage.cbUncommitted = cbUncommitted;
	lrcheckpage.itagNext = itagNext;

	rgline[0].pb = (BYTE *)&lrcheckpage;
	rgline[0].cb = sizeof( LRCHECKPAGE );

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrcheckpage.ulDBTimeLow = qwxDBTime.l;
		lrcheckpage.ulDBTimeHigh = qwxDBTime.h;
		
		NDCheckTreeInPage( pfucb->ssib.pbf->ppage, itagFOP );
		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		LGDepend( pfucb->ppib, pfucb->ssib.pbf, lgposLogRecT );
	return err;
	}

//  in critJet

ERR ErrLGTrace( PIB *ppib, CHAR *sz )
	{
	ERR				err;
	LINE 			rgline[2];
	INT				cline;
	LRTRACE			lrtrace;

	AssertCriticalSection( critJet );
	
	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	lrtrace.lrtyp = lrtypTrace;
	if ( ppib != ppibNil )
		{
		Assert( ppib->procid < 64000 );
		lrtrace.procid = (USHORT) ppib->procid;
		}
	lrtrace.cb = strlen( sz ) + 1;
	rgline[0].pb = (BYTE *) &lrtrace;
	rgline[0].cb = sizeof( lrtrace );
	cline = 1;

	if ( lrtrace.cb )
		{
		rgline[1].cb = lrtrace.cb;
		rgline[1].pb = sz;
		cline = 2;
		}
	
	while ( ( err = ErrLGLogRec( rgline, cline, fNoNewGen, pNil ) ) == errLGNotSynchronous )
		BFSleep( cmsecWaitLogFlush );

	return err;
	}


//  not in critJet

ERR ErrLGTrace2( PIB *ppib, CHAR *sz )
	{
	ERR				err;
	LINE 			rgline[2];
	INT				cline;
	LRTRACE			lrtrace;

	AssertNotInCriticalSection( critJet );
	
	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	lrtrace.lrtyp = lrtypTrace;
	if ( ppib != ppibNil )
		{
		Assert( ppib->procid < 64000 );
		lrtrace.procid = (USHORT) ppib->procid;
		}
	lrtrace.cb = strlen( sz ) + 1;
	rgline[0].pb = (BYTE *) &lrtrace;
	rgline[0].cb = sizeof( lrtrace );
	cline = 1;

	if ( lrtrace.cb )
		{
		rgline[1].cb = lrtrace.cb;
		rgline[1].pb = sz;
		cline = 2;
		}
	
	while ( ( err = ErrLGLogRec( rgline, cline, fNoNewGen, pNil ) ) == errLGNotSynchronous )
		UtilSleep( cmsecWaitLogFlush );

	return err;
	}
#endif


		/****************************************************/
		/*     Transaction Operations                       */
		/****************************************************/


/*	logs deferred open transactions.  No error returned since
/*	failure to log results in termination.
/**/
LOCAL ERR ErrLGIDeferBeginTransaction( PIB *ppib )
	{
	ERR	   		err;
	LINE		rgline[1];
	LRBEGIN0	lrbegin0;

	Assert( fLogDisabled == fFalse );
	Assert( ppib->levelDeferBegin > 0 );
	Assert( fRecovering == fFalse );

	/*	if using reserve log space, try to allocate more space
	/*	to resume normal logging.
	/**/
	CallR ( ErrLGCheckState( ) );

	/*	begin transaction may be logged during rollback if
	/*	rollback is from a higher transaction level which has
	/*	not performed any updates.
	/**/
	Assert( ppib->procid < 64000 );
	lrbegin0.procid = (USHORT) ppib->procid;

	lrbegin0.levelBegin = ppib->levelBegin;
	Assert(	lrbegin0.levelBegin >= 0 && lrbegin0.levelBegin <= levelMax );
	lrbegin0.level = (BYTE) ppib->levelDeferBegin;
	Assert(	lrbegin0.level >= 0 && lrbegin0.level <= levelMax );

	rgline[0].pb = (BYTE *) &lrbegin0;
	if ( lrbegin0.levelBegin == 0 )
		{
		Assert( ppib->trxBegin0 != trxMax );
		Assert( ppib->trxBegin0 != trxMin );
		lrbegin0.trxBegin0 = ppib->trxBegin0;

		lrbegin0.lrtyp = lrtypBegin0;
		rgline[0].cb = sizeof(LRBEGIN0);
		}
	else
		{
		lrbegin0.lrtyp = lrtypBegin;
		rgline[0].cb = sizeof(LRBEGIN);
		}
	
	while ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, pNil ) ) == errLGNotSynchronous )
		BFSleep( cmsecWaitLogFlush );

	/* reset deferred open transaction count
	/**/
	if ( err >= 0 )
		{
		ppib->levelDeferBegin = 0;
		if ( lrbegin0.levelBegin == 0 )
			ppib->fBegin0Logged = fTrue;
		}

	return err;
	}


VOID LGJetOp( JET_SESID sesid, INT op )
	{
	ERR	   		err;
	LINE		rgline[1];
	PIB			*ppib = (PIB *) sesid;
	LRJETOP		lrjetop;

	if ( sesid == (JET_SESID)0xffffffff )
		return;

	if ( !fLogDisabled && !fRecovering )
		{
		Assert( fLogDisabled == fFalse );
		Assert( fRecovering == fFalse );

		lrjetop.lrtyp = lrtypJetOp;
		Assert( ppib->procid < 64000 );
		lrjetop.procid = (USHORT) ppib->procid;
		lrjetop.op = (BYTE)op;
		rgline[0].pb = (BYTE *) &lrjetop;
		rgline[0].cb = sizeof(LRJETOP);
	
		while ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, pNil ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
		}

	return;
	}


ERR ErrLGBeginTransaction( PIB *ppib, INT levelBeginFrom )
	{
	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( ppib->levelDeferBegin == 0 )
		{
		ppib->levelBegin = (BYTE)levelBeginFrom;
		}

	ppib->levelDeferBegin++;
	Assert( ppib->levelDeferBegin < levelMax );

	return JET_errSuccess;
	}


ERR ErrLGRefreshTransaction( PIB *ppib )
	{
	ERR			err;
	LRREFRESH	lrrefresh;
	LINE		rgline[1];
	
	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	/*	log refresh operation
	/**/
	rgline[0].pb = (BYTE *) &lrrefresh;
	rgline[0].cb = sizeof ( LRREFRESH );
	lrrefresh.lrtyp = lrtypRefresh;
	Assert( ppib->procid < 64000 );
	lrrefresh.procid = (USHORT) ppib->procid;
	lrrefresh.trxBegin0 = (ppib)->trxBegin0;		
	while ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, pNil ) ) == errLGNotSynchronous )
 		BFSleep( cmsecWaitLogFlush );

	return JET_errSuccess;
	}


ERR ErrLGPrecommitTransaction( PIB *ppib, LGPOS *plgposRec )
	{
	ERR			err;
	LINE		rgline[1];
	LRPRECOMMIT	lrprecommit;

	if ( fLogDisabled || fRecovering )
		{
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	if ( ppib->levelDeferBegin > 0 )
		{
		*plgposRec = lgposMin;
		ppib->levelDeferBegin--;
		return JET_errSuccess;
		}

	Assert( ppib->procid < 64000 );
	lrprecommit.procid = (USHORT) ppib->procid;

	rgline[0].pb = (BYTE *)&lrprecommit;

	Assert( ppib->trxCommit0 != trxMax );
	lrprecommit.lrtyp = lrtypPrecommit;
	rgline[0].cb = sizeof(LRPRECOMMIT);
	while ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, plgposRec ) ) == errLGNotSynchronous )
		BFSleep( cmsecWaitLogFlush );
	Assert( err >= 0 || fLGNoMoreLogWrite );
	return err;
	}


ERR ErrLGCommitTransaction( PIB *ppib, INT levelCommitTo )
	{
	ERR			err;
	LINE		rgline[1];
	LRCOMMIT0	lrcommit0;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( ppib->levelDeferBegin > 0 )
		{
		ppib->levelDeferBegin--;
		return JET_errSuccess;
		}

	Assert( ppib->procid < 64000 );
	lrcommit0.procid = (USHORT) ppib->procid;
	lrcommit0.level = (BYTE)levelCommitTo;

	rgline[0].pb = (BYTE *)&lrcommit0;

	if ( levelCommitTo == 0 )
		{
		Assert( ppib->trxCommit0 != trxMax );
		Assert( ppib->trxCommit0 != trxMin );
		lrcommit0.trxCommit0 = ppib->trxCommit0;
		lrcommit0.lrtyp = lrtypCommit0;
		rgline[0].cb = sizeof(LRCOMMIT0);
		}
	else
		{
		lrcommit0.lrtyp = lrtypCommit;
		rgline[0].cb = sizeof(LRCOMMIT);
		}

	err = ErrLGLogRec( rgline, 1, fNoNewGen, pNil );
	Assert( err >= 0 || fLGNoMoreLogWrite || err == errLGNotSynchronous );
	if ( err >= 0 )
		{
		if ( levelCommitTo == 0 )
			ppib->fBegin0Logged = fFalse;
		}
	return err;
	}


ERR ErrLGRollback( PIB *ppib, INT levelsRollback )
	{
	ERR			err;
	LINE		rgline[1];
	LRROLLBACK		lrrollback;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( ppib->levelDeferBegin > 0 )
		{
		if ( ppib->levelDeferBegin >= levelsRollback )
			{
			ppib->levelDeferBegin -= (BYTE)levelsRollback;
			return JET_errSuccess;
			}
		levelsRollback -= ppib->levelDeferBegin;
		ppib->levelDeferBegin = 0;
		}

	Assert( levelsRollback > 0 );
	lrrollback.lrtyp = lrtypRollback;
	Assert( ppib->procid < 64000 );
	lrrollback.procid = (USHORT) ppib->procid;
	lrrollback.levelRollback = (BYTE)levelsRollback;

	rgline[0].pb = (BYTE *)&lrrollback;
	rgline[0].cb = sizeof(LRROLLBACK);
	
	while ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, pNil ) ) == errLGNotSynchronous )
		BFSleep( cmsecWaitLogFlush );
		
	if ( err >= 0 )
		{
		/*	Rollback to level 0
		 */
		if ( ppib->level == 0 )
			ppib->fBegin0Logged = fFalse;
		}

 	return err;
	}


/****************************************************/
/*     Database Operations		                    */
/****************************************************/

ERR ErrLGCreateDB(
	PIB			*ppib,
	DBID		dbid,
	JET_GRBIT	grbit,
	CHAR		*sz,
	INT			cch,
	SIGNATURE	*psignDb,
	LGPOS		*plgposRec
	)
	{
	ERR			err;
	LINE		rgline[2];
	LRCREATEDB	lrcreatedb;

	if ( fLogDisabled || fRecovering )
		{
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	if ( !FDBIDLogOn(dbid) )
		{
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	CallR( ErrLGCheckState( ) );

	/*	insert database attachment in log attachments
	/**/
	lrcreatedb.lrtyp = lrtypCreateDB;
	Assert( ppib->procid < 64000 );
	lrcreatedb.procid = (USHORT) ppib->procid;
	Assert( dbid <= 255 );
	lrcreatedb.dbid = (BYTE)dbid;
	lrcreatedb.fLogOn = fTrue;
	lrcreatedb.grbit = grbit;
	lrcreatedb.signDb = *psignDb;
	lrcreatedb.cbPath = (USHORT)cch;

	rgline[0].pb = (BYTE *)&lrcreatedb;
	rgline[0].cb = sizeof(LRCREATEDB);
	rgline[1].pb = sz;
	rgline[1].cb = cch;
	
	while ( ( err = ErrLGLogRec( rgline, 2, fNoNewGen, plgposRec ) ) == errLGNotSynchronous )
		BFSleep( cmsecWaitLogFlush );
		
	return err;
	}

ERR ErrLGAttachDB(
	PIB *ppib,
	DBID dbid,
	CHAR *sz,
	INT cch,
	SIGNATURE *psignDb,
	SIGNATURE *psignLog,
	LGPOS *plgposConsistent,
	LGPOS *plgposRec
	)
	{
	ERR			err;
	LINE		rgline[2];
	LRATTACHDB	lrattachdb;

	if ( fLogDisabled || ( fRecovering && fRecoveringMode != fRecoveringUndo ) )
		{
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	if ( !FDBIDLogOn(dbid) )
		{
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	/*	insert database attachment in log attachments
	/**/
	lrattachdb.lrtyp = lrtypAttachDB;
	Assert( ppib->procid < 64000 );
	lrattachdb.procid = (USHORT) ppib->procid;
	lrattachdb.dbid = dbid;
	lrattachdb.fLogOn = fTrue;
	lrattachdb.fReadOnly = (USHORT)rgfmp[dbid].fReadOnly;
	lrattachdb.fVersioningOff = (USHORT)rgfmp[dbid].fVersioningOff;
	lrattachdb.cbPath = (USHORT)cch;
	lrattachdb.signDb = *psignDb;
	lrattachdb.signLog = *psignLog;
	lrattachdb.lgposConsistent = *plgposConsistent;

	rgline[0].pb = (BYTE *)&lrattachdb;
	rgline[0].cb = sizeof(LRATTACHDB);
	rgline[1].pb = sz;
	rgline[1].cb = cch;
	
	while ( ( err = ErrLGLogRec( rgline, 2, fNoNewGen, plgposRec ) ) == errLGNotSynchronous )
		BFSleep( cmsecWaitLogFlush );

	return err;
	}


ERR ErrLGDetachDB(
	PIB *ppib,
	DBID dbid,
	CHAR *sz,
	INT cch,
	LGPOS *plgposRec )
	{
	ERR			err;
	LINE		rgline[2];
	LRDETACHDB	lrdetachdb;

	if ( fLogDisabled || ( fRecovering && fRecoveringMode != fRecoveringUndo ) )
		{
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	if ( !FDBIDLogOn(dbid) )
		{
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	/*	delete database attachment in log attachments
	/**/
	lrdetachdb.lrtyp = lrtypDetachDB;
	Assert( ppib->procid < 64000 );
	lrdetachdb.procid = (USHORT) ppib->procid;
	lrdetachdb.dbid = dbid;
	lrdetachdb.cbPath = (USHORT)cch;

	rgline[0].pb = (BYTE *)&lrdetachdb;
	rgline[0].cb = sizeof(LRDETACHDB);
	rgline[1].pb = sz;
	rgline[1].cb = cch;
	
	while ( ( err = ErrLGLogRec( rgline, 2, fNoNewGen, plgposRec ) ) == errLGNotSynchronous )
		BFSleep( cmsecWaitLogFlush );
	
	return err;
	}


ERR ErrLGMerge( FUCB *pfucb, SPLIT *psplit )
	{
	ERR		err;
	LINE	rgline[3];
	INT		cline = 0;
	LRMERGE	lrmerge;
	LGPOS	lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	/*	merge is always happen in level 0.
	 */
	Assert( pfucb->ppib->level == 0 );
//	LGDeferBeginTransaction( pfucb->ppib );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 3 + psplit->cpbf ) );
		
	memset(&lrmerge, 0, sizeof(LRMERGE) );
	lrmerge.lrtyp = lrtypMerge;
	Assert( pfucb->ppib->procid < 64000 );
	lrmerge.procid = (USHORT) pfucb->ppib->procid;
	lrmerge.pn = PnOfDbidPgno( pfucb->dbid, psplit->pgnoSplit );
	lrmerge.pgnoRight = psplit->pgnoSibling;
	lrmerge.pgnoParent = PcsrCurrent( pfucb )->pcsrPath->pgno;
	Assert( PgnoOfPn( psplit->pbfPagePtr->pn ) == lrmerge.pgnoParent );
	lrmerge.itagPagePtr = (SHORT)psplit->itagPagePointer;

	/* write the log record */
	/**/
	rgline[cline].pb = (BYTE *) &lrmerge;
	rgline[cline++].cb = sizeof(LRMERGE);
	
	rgline[cline].cb = (BYTE) lrmerge.cbKey = (BYTE) psplit->key.cb;
	rgline[cline++].pb = psplit->key.pb;
	
	if ( psplit->cbklnk )
		{
		lrmerge.cbklnk = (SHORT)psplit->cbklnk;
		rgline[cline].cb = sizeof(BKLNK) * psplit->cbklnk;
		rgline[cline++].pb = (BYTE *) psplit->rgbklnk;
		}
	else
		{
		}

	/* set proper timestamp for each touched page
	/**/
	do {
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		psplit->qwDBTimeRedo = qwxDBTime.qw;
		
		Assert( psplit->pbfSplit != pbfNil );
		LGSetQwDBTime( psplit->pbfSplit, qwxDBTime.qw );

		Assert ( psplit->pbfSibling != pbfNil );
		LGSetQwDBTime( psplit->pbfSibling, qwxDBTime.qw );

		Assert ( psplit->pbfPagePtr != pbfNil );
		LGSetQwDBTime( psplit->pbfPagePtr, qwxDBTime.qw );
		
		if ( psplit->cpbf )
			{
			BF **ppbf = psplit->rgpbf;
			BF **ppbfMax = ppbf + psplit->cpbf;
			for (; ppbf < ppbfMax; ppbf++)
				LGSetQwDBTime( *ppbf, qwxDBTime.qw );
			}

		lrmerge.ulDBTimeLow = qwxDBTime.l;
		lrmerge.ulDBTimeHigh = qwxDBTime.h;

		if ( ( err = ErrLGLogRec( rgline, cline, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );

	} while ( err == errLGNotSynchronous );

	/* set the buffer-logrec dependency */
	/**/
	if ( err == JET_errSuccess )
		{
		LGDepend( pfucb->ppib, psplit->pbfSplit, lgposLogRecT );		  	/* merged page */
		LGDepend( pfucb->ppib, psplit->pbfPagePtr, lgposLogRecT );		  	/* merged page */
		LGDepend( pfucb->ppib, psplit->pbfSibling, lgposLogRecT );		/* merged-to page */
		if ( psplit->cpbf )
			{
			BF **ppbf = psplit->rgpbf;
			BF **ppbfMax = ppbf + psplit->cpbf;
			for (; ppbf < ppbfMax; ppbf++)
				LGDepend( pfucb->ppib, *ppbf, lgposLogRecT );				/* backlink pages */
			}
		}

	return err;
	}


/**********************************************************/
/*****     Split Operations			                  *****/
/**********************************************************/


ERR ErrLGSplit(
	SPLITT		splitt,
	FUCB		*pfucb,
	CSR			*pcsrPagePointer,
	SPLIT		*psplit,
	PGTYP		pgtypNew )
	{
	ERR			err;
	LINE		rgline[4];
	INT			cline;
	LRSPLIT		lrsplit;
	LGPOS		lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	CallR( ErrLGCheckState( ) );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucb->ppib, 4 + psplit->cpbf ) );

	memset( &lrsplit, 0, sizeof(LRSPLIT) );

	lrsplit.lrtyp = lrtypSplit;
	Assert( pfucb->ppib->procid < 64000 );
	lrsplit.procid = (USHORT) pfucb->ppib->procid;
	lrsplit.splitt = (BYTE)splitt;
	Assert( psplit->fLeaf == 0 || psplit->fLeaf == 1 );
	lrsplit.fLeaf = (BYTE)psplit->fLeaf;
	lrsplit.pn = PnOfDbidPgno( pfucb->dbid, psplit->pgnoSplit );

	Assert(	psplit->itagSplit >= 0 && psplit->itagSplit <= 255 );
	lrsplit.itagSplit = (BYTE)psplit->itagSplit;
	lrsplit.ibSonSplit = (SHORT)psplit->ibSon;
	lrsplit.pgtyp = pgtypNew;

	lrsplit.pgnoNew = psplit->pgnoNew;

	if ( splitt == splittDoubleVertical )
		{
		lrsplit.pgnoNew2 = psplit->pgnoNew2;
		lrsplit.pgnoNew3 = psplit->pgnoNew3;
		}
	else if ( splitt != splittVertical )
		{
		lrsplit.pgnoSibling = psplit->pgnoSibling;
		lrsplit.pgnoFather = pcsrPagePointer->pgno;
		lrsplit.itagFather = pcsrPagePointer->itag;
		Assert(	pcsrPagePointer->ibSon >= 0 &&
			pcsrPagePointer->ibSon <= 255 );
		lrsplit.ibSonFather = (BYTE) pcsrPagePointer->ibSon;
		lrsplit.itagGrandFather = pcsrPagePointer->itagFather;
		}

	/*	write the log record
	/**/
	rgline[0].pb = (BYTE *) &lrsplit;
	rgline[0].cb = sizeof(LRSPLIT);

	if ( splitt == splittVertical )
		cline = 1;
	else
		{
		rgline[1].cb = (BYTE) lrsplit.cbKey = (BYTE) psplit->key.cb;
		rgline[1].pb = psplit->key.pb;
		rgline[2].cb = (BYTE) lrsplit.cbKeyMac = (BYTE) psplit->keyMac.cb;
		rgline[2].pb = psplit->keyMac.pb;
		cline = 3;
		}

	if ( psplit->cbklnk )
		{
		lrsplit.cbklnk = (SHORT)psplit->cbklnk;
		rgline[cline].cb = sizeof( BKLNK ) * lrsplit.cbklnk;
		rgline[cline].pb = (BYTE *) psplit->rgbklnk;
		cline++;
		}

	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		/* set proper timestamp for each touched page
		/**/
		psplit->qwDBTimeRedo = qwxDBTime.qw;

		Assert( QwPMDBTime( psplit->pbfSplit->ppage ) < qwxDBTime.qw );

		LGSetQwDBTime( psplit->pbfSplit, qwxDBTime.qw );
		
		LGSetQwDBTime( psplit->pbfNew, qwxDBTime.qw );

		if ( psplit->pbfNew2 )
			{
			Assert( psplit->pbfNew3 );
			LGSetQwDBTime( psplit->pbfNew2, qwxDBTime.qw );
			LGSetQwDBTime( psplit->pbfNew3, qwxDBTime.qw );
			}
			
		if ( psplit->pbfSibling )
			LGSetQwDBTime( psplit->pbfSibling, qwxDBTime.qw );

		if ( psplit->pbfPagePtr )
			LGSetQwDBTime( psplit->pbfPagePtr, qwxDBTime.qw );

		if ( psplit->cpbf )
			{
			BF **ppbf = psplit->rgpbf;
			BF **ppbfMax = ppbf + psplit->cpbf;
			for (; ppbf < ppbfMax; ppbf++)
				LGSetQwDBTime( *ppbf, qwxDBTime.qw );
			}

		lrsplit.ulDBTimeLow = qwxDBTime.l;
		lrsplit.ulDBTimeHigh = qwxDBTime.h;

		if ( ( err = ErrLGLogRec( rgline, cline, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );

	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		{
		/*	set the buffer-logrec dependency
		/**/
		LGDepend( pfucb->ppib, psplit->pbfSplit, lgposLogRecT );	  	/* split page */

		LGDepend( pfucb->ppib, psplit->pbfNew, lgposLogRecT );		  	/* new page */

		if ( splitt == splittDoubleVertical )
			{
			Assert( psplit->pbfNew2 );
			Assert( psplit->pbfNew3 );
			LGDepend( pfucb->ppib, psplit->pbfNew2, lgposLogRecT );
			LGDepend( pfucb->ppib, psplit->pbfNew3, lgposLogRecT );
			}
		else
			{
			if ( psplit->pbfSibling )
				LGDepend( pfucb->ppib, psplit->pbfSibling, lgposLogRecT );

			if ( psplit->pbfPagePtr )
				LGDepend( pfucb->ppib, psplit->pbfPagePtr, lgposLogRecT );
			}

		if ( psplit->cpbf )
			{
			BF **ppbf = psplit->rgpbf;
			BF **ppbfMax = ppbf + psplit->cpbf;

			for (; ppbf < ppbfMax; ppbf++)
				LGDepend( pfucb->ppib, *ppbf, lgposLogRecT );
			}
		}

	return err;
	}


ERR ErrLGEmptyPage( FUCB *pfucbFather, RMPAGE *prmpage )
	{
	ERR			err;
	LINE		rgline[1];
	LREMPTYPAGE	lremptypage;
	LGPOS		lgposLogRecT;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucbFather->dbid) )
		return JET_errSuccess;

	CallR( ErrLGDeferBeginTransaction( pfucbFather->ppib ) );
	CallR( ErrLGIPrepareDepend( pfucbFather->ppib, 3 ) );

	memset( &lremptypage, 0, sizeof(LREMPTYPAGE) );
	lremptypage.lrtyp = lrtypEmptyPage;
	Assert( pfucbFather->ppib->procid < 64000 );
	lremptypage.procid = (USHORT) pfucbFather->ppib->procid;
	lremptypage.pn = PnOfDbidPgno( prmpage->dbid, prmpage->pgnoRemoved );
	lremptypage.pgnoLeft = prmpage->pgnoLeft;
	lremptypage.pgnoRight = prmpage->pgnoRight;
	lremptypage.pgnoFather = prmpage->pgnoFather;
	lremptypage.itag = (USHORT)prmpage->itagPgptr;
	Assert(	prmpage->itagFather >= 0 && prmpage->itagFather <= 255 );
	lremptypage.itagFather = (BYTE)prmpage->itagFather;
	lremptypage.ibSon = (BYTE)prmpage->ibSon;

	/* write the log record */
	rgline[0].pb = (BYTE *) &lremptypage;
	rgline[0].cb = sizeof(LREMPTYPAGE);

	/* set proper timestamp for each touched page
	/**/
	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucbFather->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucbFather->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucbFather->ssib.pbf, qwxDBTime.qw );
		lremptypage.ulDBTimeLow = qwxDBTime.l;
		lremptypage.ulDBTimeHigh = qwxDBTime.h;
		
		if ( prmpage->pbfLeft )
			LGSetQwDBTime( prmpage->pbfLeft, qwxDBTime.qw );

		if ( prmpage->pbfRight )
			LGSetQwDBTime( prmpage->pbfRight, qwxDBTime.qw );

		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposLogRecT ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );

	} while ( err == errLGNotSynchronous );

	if ( err == JET_errSuccess )
		{
		/* set buffer-logrec dependencies
		/**/
		LGDepend( pfucbFather->ppib, prmpage->pbfFather, lgposLogRecT );
		if ( prmpage->pbfLeft )
			LGDepend( pfucbFather->ppib, prmpage->pbfLeft, lgposLogRecT );
		if ( prmpage->pbfRight )
			LGDepend( pfucbFather->ppib, prmpage->pbfRight, lgposLogRecT );
		}

	return err;
	}


		/****************************************************/
		/*     Misclanious Operations	                    */
		/****************************************************/


ERR ErrLGInitFDP(
	FUCB			*pfucb,
	PGNO			pgnoFDPParent,
	PN				pnFDP,
	INT				cpgGot,
	INT				cpgWish )
	{
	ERR				err;
	LINE			rgline[1];
	LRINITFDP	lrinitfdppage;

	if ( fLogDisabled || fRecovering )
		return JET_errSuccess;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return JET_errSuccess;

	CallR( ErrLGCheckState( ) );

	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	lrinitfdppage.lrtyp = lrtypInitFDP;
	Assert( pfucb->ppib->procid < 64000 );
	lrinitfdppage.procid = (USHORT) pfucb->ppib->procid;
	lrinitfdppage.pgnoFDPParent = pgnoFDPParent;
	lrinitfdppage.pn = pnFDP;
	lrinitfdppage.cpgGot = (USHORT)cpgGot;
	lrinitfdppage.cpgWish = (USHORT)cpgWish;

	rgline[0].pb = (BYTE *)&lrinitfdppage;
	rgline[0].cb = sizeof(LRINITFDP);
	
	do
		{
		QWORDX qwxDBTime;

		DBHDRIncDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );
		qwxDBTime.qw = QwDBHDRDBTime( rgfmp[ pfucb->dbid ].pdbfilehdr );

		LGSetQwDBTime( pfucb->ssib.pbf, qwxDBTime.qw );
		lrinitfdppage.ulDBTimeLow = qwxDBTime.l;
		lrinitfdppage.ulDBTimeHigh = qwxDBTime.h;
		
		if ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, pNil ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	} while ( err == errLGNotSynchronous );
	return err;
	}


ERR ErrLGStart( )
	{
	ERR		err;
	LINE	rgline[1];
	LRINIT	lr;

	if ( fLogDisabled || ( fRecovering && fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	lr.lrtyp = lrtypInit;
	LGSetDBMSParam( &lr.dbms_param );

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(lr);
	while ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, pNil ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );
	lgposStart = lgposLogRec;
	
	return err;
	}
	

ERR ErrLGMacroBegin( PIB *ppib )
	{
	ERR		err;
	LINE	rgline[1];
	LRMACROBEGIN	lr;

	Assert( !fRecovering );
	
	if ( fLogDisabled )
		return JET_errSuccess;

	Assert( !ppib->fMacroGoing );
	Assert( ppib->rgpbfLatched == NULL );
	Assert( ppib->cpbfLatchedMac == 0 );
	Assert( ppib->ipbfLatchedAvail == 0 );

	lr.lrtyp = lrtypMacroBegin;
	lr.procid = (USHORT) ppib->procid;

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(lr);
	while ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, pNil ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );

	if ( err >= 0 )
		{
		ppib->fMacroGoing = fTrue;
		ppib->levelMacro = ppib->level;
		}

	return err;
	}
	

ERR ErrLGMacroEnd( PIB *ppib, LRTYP lrtyp )
	{
	ERR		err;
	LINE	rgline[1];
	LRMACROEND	lr;
	LGPOS	lgposRec;
	INT		ipbf;

	Assert( !fRecovering || fRecoveringMode == fRecoveringUndo );
	
	if ( fLogDisabled )
		return JET_errSuccess;

	Assert( ppib->fMacroGoing );
	Assert( ppib->level == ppib->levelMacro );

	Assert( lrtyp == lrtypMacroCommit || lrtyp == lrtypMacroAbort );
	lr.lrtyp = lrtyp;
	lr.procid = (USHORT) ppib->procid;

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(lr);
	while ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, &lgposRec ) ) == errLGNotSynchronous )
			BFSleep( cmsecWaitLogFlush );

	for ( ipbf = 0; ipbf < ppib->ipbfLatchedAvail; ipbf++ )
		{
		BF *pbf = *( ppib->rgpbfLatched + ipbf );

		Assert( pbf != NULL );

		/*	Set dependency and unlatch the buffers.
		 */
		LGIDepend( pbf, lgposLogRec );
		BFResetWriteLatch( pbf, ppib );
		}

	ppib->fMacroGoing = fFalse;
	ppib->levelMacro = 0;
	if ( ppib->rgpbfLatched )
		{
		SFree( ppib->rgpbfLatched );
		ppib->rgpbfLatched = NULL;
		ppib->cpbfLatchedMac = 0;
		ppib->ipbfLatchedAvail = 0;
		}
	else
		{
		Assert( ppib->cpbfLatchedMac == 0 );
		Assert( ppib->ipbfLatchedAvail == 0 );
		}

	return err;
	}


ERR ErrLGShutDownMark( LGPOS *plgposRec )
	{
	ERR			err;
	LINE		rgline[1];
	LRSHUTDOWNMARK	lr;

	/*	record even during recovery
	/**/
	if ( fLogDisabled || ( fRecovering && fRecoveringMode != fRecoveringUndo ) )
		{
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	lr.lrtyp = lrtypShutDownMark;
	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(lr);
	while ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, plgposRec ) ) == errLGNotSynchronous )
		BFSleep( cmsecWaitLogFlush );
	return err;
	}

	
ERR ErrLGQuitRec( LRTYP lrtyp, LGPOS *plgpos, LGPOS *plgposRedoFrom, BOOL fHard )
	{
	ERR			err;
	LINE		rgline[1];
	LRTERMREC	lr;

	/*	record even during recovery
	/**/
	if ( fLogDisabled || ( fRecovering && fRecoveringMode != fRecoveringUndo ) )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	lr.lrtyp = lrtyp;
	lr.lgpos = *plgpos;
	if ( plgposRedoFrom )
		{
		Assert( lrtyp == lrtypRecoveryQuit );
		lr.lgposRedoFrom = *plgposRedoFrom;
		lr.fHard = (BYTE)fHard;
		}
	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(lr);
	while ( ( err = ErrLGLogRec( rgline, 1, fNoNewGen, pNil ) ) == errLGNotSynchronous )
		BFSleep( cmsecWaitLogFlush );
	return err;
	}

	
ERR ErrLGLogRestore( LRTYP lrtyp, CHAR * szLogRestorePath, BOOL fNewGen, LGPOS *plgposLogRec )
	{
	ERR				err;
	LINE			rgline[2];
	LRLOGRESTORE	lr;
	
	/*	record even during recovery
	/**/
	if ( fLogDisabled || ( fRecovering && fRecoveringMode != fRecoveringUndo ) )
		{
        if (plgposLogRec)
		    *plgposLogRec = lgposMin;
		return JET_errSuccess;
		}

	lr.lrtyp = lrtyp;
	lr.cbPath = (USHORT)strlen( szLogRestorePath );

	rgline[0].pb = (BYTE *)&lr;
	rgline[0].cb = sizeof(lr);
	rgline[1].pb = szLogRestorePath;
	rgline[1].cb = lr.cbPath;
	while ( ( err = ErrLGLogRec( rgline, 2, fNewGen, plgposLogRec ) ) == errLGNotSynchronous )
		BFSleep( cmsecWaitLogFlush );
	return err;
	}


#endif


#ifdef DEBUG

CHAR *mplrtypsz[ lrtypMax + 1 ] = {
		/* 	0 */		"NOP      ",
		/* 	1 */		"Start    ",
		/* 	2 */		"Quit     ",
		/* 	3 */		"MS       ",
		/* 	4 */		"Fill     ",

		/* 	5 */		"Begin    ",
		/*	6 */		"Commit   ",
		/*	7 */		"Rollback  ",

		/*	8 */		"CreateDB ",
		/* 	9 */		"AttachDB ",
		/*	10*/		"DetachDB ",

		/*	11*/		"InitFDP  ",

		/*	12*/		"Split    ",
		/*	13*/		"EmptyPg  ",
		/*	14*/		"Merge    ",

		/* 	15*/		"InsertND ",
		/* 	16*/		"InsertIL ",
		/* 	17*/		"FDelete  ",
		/* 	18*/		"Replace  ",
		/* 	19*/		"ReplaceD ",

		/*	20*/		"LockBI   ",
		/* 	21*/		"DeferBI  ",
										
		/* 	22*/		"UpdtHdr  ",
		/* 	23*/		"InsertI  ",
		/* 	24*/		"InsertIs ",
		/*	25*/		"FDeleteI ",
		/* 	26*/		"FInsertI ",
		/*	27*/		"DeleteI  ",
		/*	28*/		"SplitItm ",

		/*	29*/		"Delta    ",
		/*	30*/		"DelNode  ",
		/*	31*/		"ELC      ",

		/*	32*/		"FreeSpace",
		/*	33*/		"Undo     ",
		
		/* 	34*/		"Precommit",
		/* 	35*/		"Begin0   ",
		/*	36*/		"Commit0  ",
		/*	37*/		"Refresh  ",
		
		/*	38*/		"RcvUndo  ",
		/*	39*/		"RcvQuit  ",
		
		/*	40*/		"FullBkUp ",
		/*	41*/		"IncBkUp  ",

		/*	42*/		"CheckPage",
		/*	43*/		"JetOp    ",
		/*	44*/		"Trace    ",
		
		/*	45*/		"ShutDown ",

		/*	46*/		"McroBegin",		
		/*	47*/		"McroCmmt ",		
		/*	49*/		"*UNKNOWN*"
};

CHAR *mpopsz[ opMax + 1 ] = {
	0,							/*	0	*/	
	"JetIdle",					/*	1	*/
	"JetGetTableIndexInfo",		/*	2	*/
	"JetGetIndexInfo",			/*	3	*/
	"JetGetObjectInfo",			/*	4	*/
	"JetGetTableInfo",			/*	5	*/
	"JetCreateObject",			/*	6	*/
	"JetDeleteObject",			/*	7	*/
	"JetRenameObject",			/*	8	*/
	"JetBeginTransaction",		/*	9	*/
	"JetCommitTransaction",		/*	10	*/
	"JetRollback",				/*	11	*/
	"JetOpenTable",				/*	12	*/
	"JetDupCursor",				/*	13	*/
	"JetCloseTable",			/*	14	*/
	"JetGetTableColumnInfo",	/*	15	*/
	"JetGetColumnInfo",			/*	16	*/
	"JetRetrieveColumn",		/*	17	*/
	"JetRetrieveColumns",		/*	18	*/
	"JetSetColumn",				/*	19	*/
	"JetSetColumns",			/*	20	*/
	"JetPrepareUpdate",			/*	21	*/
	"JetUpdate",				/*	22	*/
	"JetDelete",				/*	23	*/
	"JetGetCursorInfo",			/*	24	*/
	"JetGetCurrentIndex",		/*	25	*/
	"JetSetCurrentIndex",		/*	26	*/
	"JetMove",					/* 	27	*/
	"JetMakeKey",				/*	28	*/
	"JetSeek",					/*	29	*/
	"JetGetBookmark",			/*	30	*/
	"JetGotoBookmark",			/*	31	*/
	"JetGetRecordPosition",		/*	32	*/
	"JetGotoPosition",			/*	33	*/
	"JetRetrieveKey",			/*	34	*/
	"JetCreateDatabase",		/*	35	*/
	"JetOpenDatabase",			/*	36	*/
	"JetGetDatabaseInfo",		/*	37	*/
	"JetCloseDatabase",			/*	38	*/
	"JetCapability",			/*	39	*/
	"JetCreateTable",			/*	40	*/
	"JetRenameTable",			/*	41	*/
	"JetDeleteTable",			/*	42	*/
	"JetAddColumn",				/*	43	*/
	"JetRenameColumn",			/*	44	*/
	"JetDeleteColumn",			/*	45	*/
	"JetCreateIndex",			/*	46	*/
	"JetRenameIndex",			/*	47	*/
	"JetDeleteIndex",			/*	48	*/
	"JetComputeStats",			/*	49	*/
	"JetAttachDatabase",		/*	50	*/
	"JetDetachDatabase",		/*	51	*/
	"JetOpenTempTable",			/*	52	*/
	"JetSetIndexRange",			/*	53	*/
	"JetIndexRecordCount",		/*	54	*/
	"JetGetChecksum",			/*	55	*/
	"JetGetObjidFromName",		/*	56	*/
};

VOID PrintSign( SIGNATURE *psign )
	{
	LOGTIME tm = psign->logtimeCreate;
	PrintF2( "Create time:%d/%d/%d %d:%d:%d ",
						(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
						(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
	PrintF2( "Rand:%lu ", psign->ulRandom );
	PrintF2( "Computer:%s\n", psign->szComputerName );
	}

/*	Prints log record contents.  If pb == NULL, then data is assumed
/*	to follow log record in contiguous memory.
/**/
INT cNOP = 0;

VOID ShowLR( LR *plr )
	{
	LRTYP lrtyp;

 	if ( plr->lrtyp >= lrtypMax )
		lrtyp = lrtypMax;
	else
		lrtyp = plr->lrtyp;

	if ( cNOP == 0 || lrtyp != lrtypNOP )
		FPrintF2( " %s", mplrtypsz[lrtyp] );
		
	switch ( plr->lrtyp )
		{
		case lrtypNOP:
			cNOP++;
			break;

		case lrtypMS:
			{
			LRMS *plrms = (LRMS *)plr;

			FPrintF2( " (%u,%u checksum %u)",
				plrms->isecForwardLink, plrms->ibForwardLink,
				plrms->ulCheckSum );
			break;
			}

		case lrtypInsertNode:
		case lrtypInsertItemList:
			{
			LRINSERTNODE	*plrinsertnode = (LRINSERTNODE *)plr;
			BYTE			*pb;
			USHORT			cb;

			pb = (BYTE *) plr + sizeof( LRINSERTNODE );
			cb = plrinsertnode->cbKey + plrinsertnode->cbData;
			
			if ( plr->lrtyp == lrtypInsertItemList )
				{
				SRID item = *(SRID UNALIGNED *) (pb + plrinsertnode->cbKey);

				FPrintF2( " %lu-%lu(%x,([%u:%lu:%u,%u],%u:%lu:%u)%#4X,%u,%u,(%u:%lu:%u))",
					plrinsertnode->ulDBTimeHigh,
					plrinsertnode->ulDBTimeLow,
					plrinsertnode->procid,
					DbidOfPn(plrinsertnode->pn),
					PgnoOfPn(plrinsertnode->pn),
					plrinsertnode->itagFather,
					plrinsertnode->ibSon,
					DbidOfPn(plrinsertnode->pn),
					PgnoOfPn(plrinsertnode->pn),
					plrinsertnode->itagSon,
					plrinsertnode->bHeader,
					plrinsertnode->cbKey,
					plrinsertnode->cbData,
					DbidOfPn(plrinsertnode->pn),
					PgnoOfSrid(BmNDOfItem(item)),
					ItagOfSrid(BmNDOfItem(item)) );
				}
			else
				{
				FPrintF2( " %lu-%lu(%x,([%u:%lu:%u,%d],%u:%lu:%u)%#4X,%u,%u)",
					plrinsertnode->ulDBTimeHigh,
					plrinsertnode->ulDBTimeLow,
					plrinsertnode->procid,
					DbidOfPn(plrinsertnode->pn),
					PgnoOfPn(plrinsertnode->pn),
					plrinsertnode->itagFather,
					plrinsertnode->ibSon,
					DbidOfPn(plrinsertnode->pn),
					PgnoOfPn(plrinsertnode->pn),
					plrinsertnode->itagSon,
					plrinsertnode->bHeader,
					plrinsertnode->cbKey,
					plrinsertnode->cbData );
				}
			ShowData( pb, cb );
			break;
			}

		case lrtypReplace:
		case lrtypReplaceD:
			{
			LRREPLACE *plrreplace = (LRREPLACE *)plr;
			BYTE	*pb;
			USHORT	cb;

			pb = (BYTE *) plrreplace + sizeof( LRREPLACE );
			cb = plrreplace->cb;

			FPrintF2( " %lu-%lu(%x,(%u:%lu:%u),(%u:%lu:%u),%u,%5u,%5u,%5u)",
				plrreplace->ulDBTimeHigh,
				plrreplace->ulDBTimeLow,
				plrreplace->procid,
				DbidOfPn(plrreplace->pn),
				PgnoOfPn(plrreplace->pn),
				plrreplace->itag,
				DbidOfPn(plrreplace->pn),
				PgnoOfSrid(plrreplace->bm),
				ItagOfSrid(plrreplace->bm),
				plrreplace->fDirVersion,
				cb,
				plrreplace->cbNewData,
				plrreplace->cbOldData);
			if ( plr->lrtyp == lrtypReplaceD )
				LGDumpDiff(	pb, cb );
			else
				ShowData( pb, cb );
			break;
			}

		case lrtypFlagDelete:
			{
			LRFLAGDELETE *plrdelete = (LRFLAGDELETE *)plr;
			FPrintF2( " %lu-%lu(%x,(%u:%lu:%u),(%u:%lu:%u),%u)",
				plrdelete->ulDBTimeHigh,
				plrdelete->ulDBTimeLow,
				plrdelete->procid,
				DbidOfPn(plrdelete->pn),
				PgnoOfPn(plrdelete->pn),
				plrdelete->itag,
				DbidOfPn(plrdelete->pn),
				PgnoOfSrid(plrdelete->bm),
				ItagOfSrid(plrdelete->bm),
				plrdelete->fDirVersion );
			break;
			}

		case lrtypDelete:
			{
			LRDELETE *plrdelete = (LRDELETE *)plr;
			FPrintF2( " %lu-%lu(%x,(%u:%lu:%u))",
				plrdelete->ulDBTimeHigh,
				plrdelete->ulDBTimeLow,
				plrdelete->procid,
				DbidOfPn(plrdelete->pn),
				PgnoOfPn(plrdelete->pn),
				plrdelete->itag );
			break;
			}

		case lrtypLockBI:
			{
			LRLOCKBI	*plrlockrec = (LRLOCKBI *)plr;
			FPrintF2( " %lu-%lu,(%x,(%u:%lu:%u),(%u:%lu:%u))",
				plrlockrec->ulDBTimeHigh,
				plrlockrec->ulDBTimeLow,
				plrlockrec->procid,
				DbidOfPn(plrlockrec->pn),
				PgnoOfPn(plrlockrec->pn),
				plrlockrec->itag,
				DbidOfPn(plrlockrec->pn),
				PgnoOfSrid(plrlockrec->bm),
				(USHORT) ItagOfSrid(plrlockrec->bm)
				);
			break;
			}

		case lrtypDeferredBI:
			{
			LRDEFERREDBI *plrdbi = (LRDEFERREDBI *)plr;
			FPrintF2( " (%x,(%u:%lu:%u),%u,%u)",
				plrdbi->procid,
				plrdbi->dbid,
				PgnoOfSrid(plrdbi->bm),
				(USHORT) ItagOfSrid(plrdbi->bm),
				(USHORT) plrdbi->level,
				plrdbi->cbData
				);

			ShowData( plrdbi->rgbData, plrdbi->cbData );
			break;
			}

		case lrtypELC:
			{
			LRELC *plrelc = (LRELC *)plr;
			FPrintF2( " %lu-%lu(%x,(%u:%lu:%u), (%u:%lu:%u))",
				plrelc->ulDBTimeHigh,
				plrelc->ulDBTimeLow,
				plrelc->procid,
				DbidOfPn(plrelc->pn),
				PgnoOfPn(plrelc->pn),
				plrelc->itag,
				DbidOfPn(plrelc->pn),
				PgnoOfSrid(plrelc->sridSrc),
				ItagOfSrid(plrelc->sridSrc) );
			break;
			}

		case lrtypInsertItem:
			{
			LRINSERTITEM *plrinsertitem = (LRINSERTITEM *)plr;
			FPrintF2( " %lu-%lu(%x,(%u:%lu:%d),(%u:%lu:%u),(%u:%lu:%u))",
				plrinsertitem->ulDBTimeHigh,
				plrinsertitem->ulDBTimeLow,
				plrinsertitem->procid,
				DbidOfPn(plrinsertitem->pn),
				PgnoOfPn(plrinsertitem->pn),
				plrinsertitem->itag,
				DbidOfPn(plrinsertitem->pn),
				PgnoOfSrid(plrinsertitem->sridItemList),
				ItagOfSrid(plrinsertitem->sridItemList),
				DbidOfPn(plrinsertitem->pn),
				PgnoOfSrid(BmNDOfItem(plrinsertitem->srid)),
				ItagOfSrid(plrinsertitem->srid) );
			break;
			}

		case lrtypInsertItems:
			{
			LRINSERTITEMS *plrinsertitems = (LRINSERTITEMS *)plr;
			ITEM	*pitemMax = plrinsertitems->rgitem + plrinsertitems->citem;
			ITEM	*pitem = plrinsertitems->rgitem;

			FPrintF2( " %lu-%lu(%x,(%u:%lu:%u),%u)\n",
				plrinsertitems->ulDBTimeHigh,
				plrinsertitems->ulDBTimeLow,
				plrinsertitems->procid,
				DbidOfPn(plrinsertitems->pn),
				PgnoOfPn(plrinsertitems->pn),
				plrinsertitems->itag,
				plrinsertitems->citem
				);

			for ( ; pitem<pitemMax; pitem++ )
				{
				FPrintF2( "[%u:%lu:%u]\n",
					DbidOfPn(plrinsertitems->pn),
					PgnoOfSrid( *(ITEM UNALIGNED *)pitem ),
					ItagOfSrid( *(ITEM UNALIGNED *)pitem )
					);
				}
			break;
			}

		case lrtypFlagDeleteItem:
		case lrtypFlagInsertItem:
			{
			LRFLAGITEM *plritem = (LRFLAGITEM *)plr;
			FPrintF2( " %lu-%lu(%x,(%u:%lu:%u),(%u:%lu:%u),(%u:%lu:%u))",
				plritem->ulDBTimeHigh,
				plritem->ulDBTimeLow,
				plritem->procid,
				DbidOfPn(plritem->pn),
				PgnoOfPn(plritem->pn),
				plritem->itag,
				DbidOfPn(plritem->pn),
				PgnoOfSrid(plritem->sridItemList),
				ItagOfSrid(plritem->sridItemList),
				DbidOfPn(plritem->pn),
				PgnoOfSrid(plritem->srid),
				ItagOfSrid(plritem->srid) );
			break;
			}

		case lrtypDeleteItem:
			{
			LRDELETEITEM *plritem = (LRDELETEITEM *)plr;
			FPrintF2( " %lu-%lu(%x,(%u:%lu:%u),(%u:%lu:%u),(%u:%lu:%u))",
				plritem->ulDBTimeHigh,
				plritem->ulDBTimeLow,
				plritem->procid,
				DbidOfPn(plritem->pn),
				PgnoOfPn(plritem->pn),
				plritem->itag,
				DbidOfPn(plritem->pn),
				PgnoOfSrid(plritem->sridItemList),
				ItagOfSrid(plritem->sridItemList),
				DbidOfPn(plritem->pn),
				PgnoOfSrid(plritem->srid),
				ItagOfSrid(plritem->srid));
			break;
			}

		case lrtypSplitItemListNode:
			{
			LRSPLITITEMLISTNODE *plrsiln = (LRSPLITITEMLISTNODE *)plr;

			FPrintF2( " %lu-%lu(%x,([%u:%lu:%u],%d,%u)%u)",
				plrsiln->ulDBTimeHigh,
				plrsiln->ulDBTimeLow,
				plrsiln->procid,
				DbidOfPn(plrsiln->pn),
				PgnoOfPn(plrsiln->pn),
				plrsiln->itagToSplit,
				plrsiln->itagFather,
				plrsiln->ibSon,
				plrsiln->cItem);
			break;
			}

		case lrtypDelta:
			{
			LRDELTA *plrdelta = (LRDELTA *)plr;

			FPrintF2( " %lu-%lu(%x,(%u:%lu:%u),%u,(%u:%lu:%u),%d)",
				plrdelta->ulDBTimeHigh,
				plrdelta->ulDBTimeLow,
				plrdelta->procid,
				DbidOfPn(plrdelta->pn),
				PgnoOfPn(plrdelta->pn),
				plrdelta->itag,
				plrdelta->fDirVersion,
				DbidOfPn(plrdelta->pn),
				PgnoOfSrid(plrdelta->bm),
				ItagOfSrid(plrdelta->bm),
				plrdelta->lDelta );
			break;
			}

		case lrtypCheckPage:
			{
			LRCHECKPAGE *plrcheckpage = (LRCHECKPAGE *)plr;

			FPrintF2( " %lu-%lu(%x,([%u:%lu],%u),%d,%d,%lu)",
				plrcheckpage->ulDBTimeHigh,
				plrcheckpage->ulDBTimeLow,
				plrcheckpage->procid,
				DbidOfPn(plrcheckpage->pn),
				PgnoOfPn(plrcheckpage->pn),
				plrcheckpage->itagNext,
				plrcheckpage->cbFree,
				plrcheckpage->cbUncommitted,
				plrcheckpage->pgnoFDP );
			break;
			}

		case lrtypJetOp:
			{
			LRJETOP *plrjetop = (LRJETOP *)plr;
	   		FPrintF2( " (%lx) -- %s",
	   			plrjetop->procid,
	   			mpopsz[ plrjetop->op ] );
			break;
			}

		case lrtypBegin:
		case lrtypBegin0:
			{
			LRBEGIN0 *plrbegin0 = (LRBEGIN0 *)plr;
			Assert(plrbegin0->level >= 0);
			Assert(plrbegin0->level <= levelMax);
	   		FPrintF2( " (%x,%d,%d)",
	   			plrbegin0->procid,
	   			(USHORT) plrbegin0->levelBegin,
	   			(USHORT) plrbegin0->level );
			if ( plr->lrtyp == lrtypBegin0 )
				FPrintF2( " %lu", plrbegin0->trxBegin0 );
			break;
			}

		case lrtypMacroBegin:
		case lrtypMacroCommit:
		case lrtypMacroAbort:
			{
			LRMACROBEGIN *plrmbegin = (LRMACROBEGIN *)plr;
	   		FPrintF2( " (%x)", plrmbegin->procid );
			break;
			}

		case lrtypRefresh:
			{
			LRREFRESH *plrrefresh = (LRREFRESH *) plr;

			FPrintF2( " (%x,%lu)",
	   			plrrefresh->procid,
	   			plrrefresh->trxBegin0 );

			break;
			}

		case lrtypPrecommit:
			{
			LRPRECOMMIT *plrprecommit = (LRPRECOMMIT *)plr;
			
	   		FPrintF2( " (%x)", plrprecommit->procid );
			break;
			}
			
		case lrtypCommit:
		case lrtypCommit0:
			{
			LRCOMMIT0 *plrcommit0 = (LRCOMMIT0 *)plr;
	   		FPrintF2( " (%x,%d)",
	   			plrcommit0->procid,
	   			(USHORT) plrcommit0->level );
			if ( plr->lrtyp == lrtypCommit0 )
				FPrintF2( " %lu", plrcommit0->trxCommit0 );
			break;
			}

		case lrtypRollback:
			{
			LRROLLBACK *plrrollback = (LRROLLBACK *)plr;
			FPrintF2( " (%x,%d)",
				plrrollback->procid,
				(USHORT) plrrollback->levelRollback );
			break;
			}

		case lrtypCreateDB:
			{
			LRCREATEDB *plrcreatedb = (LRCREATEDB *) plr;
			CHAR *sz;

			sz = (BYTE *)plr + sizeof(LRCREATEDB);
			FPrintF2( " (%s,%u)   Sig: ", sz, plrcreatedb->dbid );
			PrintSign( &plrcreatedb->signDb );
			break;
			}

		case lrtypAttachDB:
			{
			LRATTACHDB *plrattachdb = (LRATTACHDB *) plr;
			CHAR *sz;

			sz = (BYTE *)plrattachdb + sizeof(LRATTACHDB);
			FPrintF2( " (%s,%u)", sz, plrattachdb->dbid );
			FPrintF2( " consistent:(%d,%d,%d)   Sig: ",
				(short) plrattachdb->lgposConsistent.lGeneration,
				(short) plrattachdb->lgposConsistent.isec,
				(short) plrattachdb->lgposConsistent.ib );
			PrintSign( &plrattachdb->signDb );
			break;
			}

		case lrtypDetachDB:
			{
			LRDETACHDB *plrdetachdb = (LRDETACHDB *) plr;
			CHAR *sz;

			sz = (BYTE *)plrdetachdb + sizeof(LRDETACHDB);
			FPrintF2( " (%s,%u)", sz, plrdetachdb->dbid );
			break;
			}

		case lrtypInitFDP:
			{
			LRINITFDP *plrinitfdppage = (LRINITFDP *)plr;

			FPrintF2( " %lu-%lu(%x,(%d:%lu),(%d:%lu),%u,%u)",
				plrinitfdppage->ulDBTimeHigh,
				plrinitfdppage->ulDBTimeLow,
				plrinitfdppage->procid,
				DbidOfPn(plrinitfdppage->pn),
				PgnoOfPn(plrinitfdppage->pn),
				DbidOfPn(plrinitfdppage->pn),
				plrinitfdppage->pgnoFDPParent,
				(USHORT) plrinitfdppage->cpgGot,
				(USHORT) plrinitfdppage->cpgWish );
			break;
			}

		case lrtypSplit:
			{
			LRSPLIT *plrsplit = (LRSPLIT *)plr;

			if ( plrsplit->splitt == splittVertical )
				FPrintF2( " Vertical" );
			else if ( plrsplit->splitt == splittDoubleVertical )
				FPrintF2( " DoubleV" );
			else if ( plrsplit->splitt == splittLeft )
				FPrintF2( " SplitLeft" );
			else if ( plrsplit->splitt == splittRight )
				FPrintF2( " SplitRight" );
			else
				{
				Assert ( plrsplit->splitt == splittAppend );
				FPrintF2(" Append");
				}

			if ( plrsplit->splitt == splittVertical )
				{
				FPrintF2( " %lu-%lu(%x,(%u:%lu:%u),%u:%lu,%u)",
					plrsplit->ulDBTimeHigh,
					plrsplit->ulDBTimeLow,
					plrsplit->procid,
					DbidOfPn(plrsplit->pn),
					PgnoOfPn(plrsplit->pn),
					plrsplit->itagSplit,
					DbidOfPn(plrsplit->pn),					
					plrsplit->pgnoNew,
					plrsplit->pgtyp );
				}
			else if ( plrsplit->splitt == splittDoubleVertical )
				{
				FPrintF2( " %lu-%lu(%x,(%u:%lu:%u),%u:%lu,%u:%lu,%u:%lu,%u)",
					plrsplit->ulDBTimeHigh,
					plrsplit->ulDBTimeLow,
					plrsplit->procid,
					DbidOfPn(plrsplit->pn),
					PgnoOfPn(plrsplit->pn),
					plrsplit->itagSplit,
					DbidOfPn(plrsplit->pn),
					plrsplit->pgnoNew,
					DbidOfPn(plrsplit->pn),
					plrsplit->pgnoNew2,
					DbidOfPn(plrsplit->pn),
					plrsplit->pgnoNew3,
					plrsplit->pgtyp );
				}
			else
				{
				FPrintF2( " %lu-%lu(%x,split:[(%u:%lu:%u),%u],ptr:[%u,(%u:%lu:%u),%u],new:(%u:%lu),%u)",
					plrsplit->ulDBTimeHigh,
					plrsplit->ulDBTimeLow,
					plrsplit->procid,
					DbidOfPn(plrsplit->pn),
					PgnoOfPn(plrsplit->pn),
					plrsplit->itagSplit,
					plrsplit->ibSonSplit,
					plrsplit->itagGrandFather,
					DbidOfPn(plrsplit->pn),
					plrsplit->pgnoFather,
					plrsplit->itagFather,
					plrsplit->ibSonFather,
					DbidOfPn(plrsplit->pn),
					plrsplit->pgnoNew,
					plrsplit->pgtyp );
				}

			#if 1
				if ( plrsplit->cbklnk )
					{
					BKLNK	*pbklnk = (BKLNK *)(plrsplit->rgb +
										plrsplit->cbKey +
										plrsplit->cbKeyMac);
					BKLNK	*pbklnkMax = pbklnk + plrsplit->cbklnk;

					for ( ; pbklnk < pbklnkMax; pbklnk++ )
						{
						SRID	sridBackLink = ((BKLNK UNALIGNED *) pbklnk)->sridBackLink;
						SRID	sridNew = ((BKLNK UNALIGNED *) pbklnk)->sridNew;

						FPrintF2( "\n [%u:%lu:%u] [%u:%lu:%u]",
							DbidOfPn(plrsplit->pn),
							PgnoOfSrid( sridBackLink ),
							ItagOfSrid( sridBackLink ),
							DbidOfPn(plrsplit->pn),
							PgnoOfSrid( sridNew ),
							ItagOfSrid( sridNew ) );
						}
					}
			#endif

	
			break;
			}

		case lrtypEmptyPage:
			{
			LREMPTYPAGE *plrep = (LREMPTYPAGE *)plr;

			FPrintF2( " %lu-%lu(%x,(%u:%lu),(%u:%lu:%u-%u),[%u:%lu], [%u:%lu])",
				plrep->ulDBTimeHigh,
				plrep->ulDBTimeLow,
				plrep->procid,
				DbidOfPn(plrep->pn),
				PgnoOfPn(plrep->pn),
				DbidOfPn(plrep->pn),
				plrep->pgnoFather,
				plrep->itagFather,
				plrep->itag,
				DbidOfPn(plrep->pn),
				plrep->pgnoLeft,
				DbidOfPn(plrep->pn),
				plrep->pgnoRight );
			break;
			}

		case lrtypMerge:
			{
			LRMERGE *plrmerge = (LRMERGE *)plr;
			BYTE 	*pb = &(plrmerge->rgb[0]);
			INT		cb = plrmerge->cbKey;
			
			FPrintF2(" %lu-%lu(%x,[%u:%lu],[%u:%lu],[%u:%lu:%u],%u)",
				plrmerge->ulDBTimeHigh,
				plrmerge->ulDBTimeLow,
				plrmerge->procid,
				DbidOfPn(plrmerge->pn),
				PgnoOfPn(plrmerge->pn),
				DbidOfPn(plrmerge->pn),
				plrmerge->pgnoRight,
				DbidOfPn(plrmerge->pn),
				plrmerge->pgnoParent,
				plrmerge->itagPagePtr,
				plrmerge->cbklnk );

			ShowData( pb, cb );

			if ( plrmerge->cbklnk )
				{
				BKLNK 	*pbklnk = (BKLNK *) ( plrmerge->rgb + plrmerge->cbKey );
				BKLNK	*pbklnkMax = pbklnk + plrmerge->cbklnk;

				Assert( plrmerge->cbKey >= 0 );
				for ( ; pbklnk < pbklnkMax; pbklnk++ )
					{
					SRID	sridBackLink = ((BKLNK UNALIGNED *) pbklnk)->sridBackLink;
					SRID	sridNew = ((BKLNK UNALIGNED *) pbklnk)->sridNew;

					FPrintF2( "\n[%u:%lu:%u] [%u:%lu:%u]",
						DbidOfPn(plrmerge->pn),
						PgnoOfSrid( sridBackLink ),
						ItagOfSrid( sridBackLink ),
						DbidOfPn(plrmerge->pn),
						PgnoOfSrid( sridNew ),
						ItagOfSrid( sridNew ) );
					}
				}

			break;
			}
			
		case lrtypFreeSpace:
			{
			LRFREESPACE *plrfreespace = (LRFREESPACE *)plr;
			FPrintF2( " %lu-%lu(%x,(%u:%lu:%u),%u,%u)",
				(ULONG) plrfreespace->wDBTimeHigh,
				plrfreespace->ulDBTimeLow,
				plrfreespace->procid,
				plrfreespace->dbid,
				PgnoOfSrid(plrfreespace->bm),
				(USHORT) ItagOfSrid(plrfreespace->bm),
				(USHORT) plrfreespace->level,
				(USHORT) plrfreespace->cbDelta
				);
			break;
			}

		case lrtypUndo:
			{
			LRUNDO *plrundo = (LRUNDO *)plr;
			FPrintF2( " %lu-%lu(%x,(%u:%lu:%u),%u,%u,(%u:%lu:%u))",
				(ULONG) plrundo->wDBTimeHigh,
				plrundo->ulDBTimeLow,
				plrundo->procid,
				
				plrundo->dbid,
				PgnoOfSrid(plrundo->bm),
				(USHORT) ItagOfSrid(plrundo->bm),
				
				(USHORT) plrundo->level,
				(USHORT) plrundo->oper,
				
				plrundo->dbid,
				PgnoOfSrid(BmNDOfItem(plrundo->item)),
				(USHORT) ItagOfSrid(plrundo->item)

				);
			break;
			}

		case lrtypInit:
			{
			DBMS_PARAM *pdbms_param = &((LRINIT *)plr)->dbms_param;
			FPrintF2( "\n      Env SystemPath:%s\n",	pdbms_param->szSystemPath);
			FPrintF2( "      Env LogFilePath:%s\n", pdbms_param->szLogFilePath);
			FPrintF2( "      Env (Session, Opentbl, VerPage, Cursors, LogBufs, LogFile, Buffers)\n");
			FPrintF2( "          (%7lu, %7lu, %7lu, %7lu, %7lu, %7lu, %7lu)\n",
				pdbms_param->ulMaxSessions,
				pdbms_param->ulMaxOpenTables,
				pdbms_param->ulMaxVerPages,
				pdbms_param->ulMaxCursors,
				pdbms_param->ulLogBuffers,
				pdbms_param->ulcsecLGFile,
				pdbms_param->ulMaxBuffers );
			}
			break;
			
		case lrtypTerm:
		case lrtypShutDownMark:
			break;
			
		case lrtypRecoveryQuit:
			{
			LRTERMREC *plrquit = (LRTERMREC *) plr;

			if ( plrquit->fHard )
				FPrintF2( "\n      Quit on Hard Restore." );
			else
				FPrintF2( "\n      Quit on Soft Restore." );
			
			FPrintF2( "\n      RedoFrom:(%d,%d,%d)\n",
				(short) plrquit->lgposRedoFrom.lGeneration,
				(short) plrquit->lgposRedoFrom.isec,
				(short) plrquit->lgposRedoFrom.ib );
						
			FPrintF2( "      UndoRecordFrom:(%d,%d,%d)\n",
  				(short) plrquit->lgpos.lGeneration,
				(short) plrquit->lgpos.isec,
				(short) plrquit->lgpos.ib );
			}
			break;
			
		case lrtypRecoveryUndo:
		case lrtypFullBackup:
		case lrtypIncBackup:
			{
			LRLOGRESTORE *plrlr = (LRLOGRESTORE *) plr;

		   	if ( plrlr->cbPath )
				{
				FPrintF2( "%*s", plrlr->cbPath, plrlr->szData );
				}
			break;
			}

		case lrtypUpdateHeader:
			{
			LRUPDATEHEADER *plruh = (LRUPDATEHEADER *)plr;
			FPrintF2( " %lu-%lu(%x,(%u:%lu:%d),(%u:%lu:%u)),%#4X",
				plruh->ulDBTimeHigh,
				plruh->ulDBTimeLow,
				plruh->procid,
				DbidOfPn(plruh->pn),
				PgnoOfPn(plruh->pn),
				plruh->itag,
				DbidOfPn(plruh->pn),
				PgnoOfSrid(plruh->bm),
				(USHORT) ItagOfSrid(plruh->bm),
				(USHORT) plruh->bHeader
				);
			break;
			}
			
		case lrtypTrace:
			{
			LRTRACE *plrtrace = (LRTRACE *)plr;
			char szFormat[255];
			sprintf( szFormat, " (%%x) %%%lds", plrtrace->cb );
			
	   		FPrintF2( szFormat,	plrtrace->procid, plrtrace->sz );
			break;
			}

		default:
			{
			Assert( fFalse );
			break;
			}
		}
	}


extern BYTE mpbb[];


VOID ShowData ( BYTE *pbData, INT cbData )
	{
	BYTE	*pb;
	BYTE	*pbMax;
	BYTE	rgbPrint[200];
	BYTE	*pbPrint = rgbPrint;

	if ( cbData > 8 )
		pbMax = pbData + 8;
	else
		pbMax = pbData + cbData;

	for( pb = pbData; pb < pbMax; pb++ )
		{
		BYTE b = *pb;
		
		*pbPrint++ = mpbb[b >> 4];
		*pbPrint++ = mpbb[b & 0x0f];
		*pbPrint++ = ' ';
		
//		if ( isalnum( *pb ) )
//			FPrintF2( "%c", *pb );
//		else
//			FPrintF2( "%x", *pb );
		}

#if 0
	if ( cbData > 8 )
		{
		*pbPrint++ = '.';
		*pbPrint++ = '.';
		
//		FPrintF2( ".." );

		pb = pbMax - 3;
		}

	for( ; pb < pbMax; pb++ )
		{
		BYTE b = *pb;
		
		*pbPrint++ = mpbb[b >> 4];
		*pbPrint++ = mpbb[b & 0x0f];
		*pbPrint++ = ' ';
		
//		if ( isalnum( *pb ) )
//			FPrintF2( "%c", *pb );
//		else
//			FPrintF2( "%x", *pb );
		}
#endif

	*pbPrint='\0';
	FPrintF2( "%s", rgbPrint );
	}


#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\logdiff.c ===
#include "daestd.h"
#include "malloc.h"


DeclAssertFile; 				/* Declare file name for assert macros */

#ifdef DEBUG
/*
 *	Dump diffs
 */
VOID LGDumpDiff (
	BYTE *pbDiff,
	INT cbDiff
	)
	{
	BYTE *pbDiffCur = pbDiff;
	BYTE *pbDiffMax = pbDiff + cbDiff;

	while ( pbDiffCur < pbDiffMax )
		{
		INT	ibOffsetOld;
		INT cbDataNew;
		BOOL f2Bytes;
		
		DIFFHDR diffhdr = *(DIFFHDR *) pbDiffCur;
		pbDiffCur += sizeof( diffhdr );

		ibOffsetOld = diffhdr.ibOffset;
		FPrintF2( "\n[ Offs:%u ", ibOffsetOld );

		f2Bytes = diffhdr.f2BytesLength ? 1 : 0;
		if ( f2Bytes )
			FPrintF2( "2B " );
		else
			FPrintF2( "1B " );
		
		if ( f2Bytes )
			cbDataNew = *(WORD UNALIGNED *) pbDiffCur;
		else
			cbDataNew = *(BYTE *) pbDiffCur;
		pbDiffCur += sizeof( BYTE ) + f2Bytes;
				
		if ( diffhdr.fInsert )
			{
			if ( diffhdr.fInsertWithFill )
				{
				FPrintF2( "InsertWithFill %u ", cbDataNew );
				}
			else
				{
				FPrintF2( "InsertWithValue %u ", cbDataNew );
				ShowData( pbDiffCur, cbDataNew );
				pbDiffCur += cbDataNew;
				}
			}
		else
			{
			if ( diffhdr.fReplaceWithSameLength )
				{
				FPrintF2( "ReplaceWithSameLength %u ", cbDataNew );
				ShowData( pbDiffCur, cbDataNew );
				pbDiffCur += cbDataNew;
				}
			else
				{
				INT cbDataOld;

				if ( f2Bytes )
					{
					cbDataOld = *(WORD UNALIGNED *) pbDiffCur;
					pbDiffCur += sizeof( WORD );
					}
				else
					{
					cbDataOld = *(BYTE *) pbDiffCur;
					pbDiffCur += sizeof( BYTE );
					}
				
				FPrintF2( "ReplaceWithNewValue %u,%u ", cbDataNew, cbDataOld );
				ShowData( pbDiffCur, cbDataNew );
				pbDiffCur += cbDataNew;
				}
			}

		FPrintF2( "] " );
		
		Assert( pbDiffCur <= pbDiffMax );
		}
	}
#endif


VOID LGGetAfterImage(
	BYTE *pbDiff,
	INT	cbDiff,
	BYTE *pbOld,
	INT cbOld,
	BYTE *pbNew,
	INT	*pcbNew
	)
	{
	BYTE *pbOldCur = pbOld;
	BYTE *pbNewCur = pbNew;
	BYTE *pbDiffCur = pbDiff;
	BYTE *pbDiffMax = pbDiff + cbDiff;
	INT	cbT;

	while ( pbDiffCur < pbDiffMax )
		{
		INT cbDataNew;
		INT ibOffsetOld;
		DIFFHDR diffhdr;
		BOOL f2Bytes;
		INT cbSkip;
		
		diffhdr = *(DIFFHDR *) pbDiffCur;
		pbDiffCur += sizeof( diffhdr );

		ibOffsetOld = diffhdr.ibOffset;

		f2Bytes = diffhdr.f2BytesLength ? 1 : 0;

		cbSkip = (INT)(pbOld + ibOffsetOld - pbOldCur);
		Assert( cbChunkMost > cbRECRecordMost && pbNewCur + cbSkip - pbNew <= cbChunkMost );
		memcpy( pbNewCur, pbOldCur, cbSkip );
		pbNewCur += cbSkip;
		pbOldCur += cbSkip;
		
		if ( f2Bytes )
			{
			cbDataNew = *(WORD UNALIGNED *) pbDiffCur;
			pbDiffCur += sizeof( WORD );
			}
		else
			{
			cbDataNew = *(BYTE *) pbDiffCur;
			pbDiffCur += sizeof( BYTE );
			}
				
		Assert( cbChunkMost > cbRECRecordMost && pbNewCur + cbDataNew - pbNew <= cbChunkMost );
		if ( diffhdr.fInsert )
			{
			if ( diffhdr.fInsertWithFill )
				{
				/*	Insert with junk fill.
				 */
#ifdef DEBUG
				memset( pbNewCur, '*', cbDataNew );
#endif
				}
			else
				{
				memcpy( pbNewCur, pbDiffCur, cbDataNew );
				pbDiffCur += cbDataNew;
				}
			}
		else
			{
			INT cbDataOld;

			if ( diffhdr.fReplaceWithSameLength )
				{
				cbDataOld = cbDataNew;
				}
			else
				{
				if ( f2Bytes )
					{
					cbDataOld = *(WORD UNALIGNED *) pbDiffCur;
					pbDiffCur += sizeof( WORD );
					}
				else
					{
					cbDataOld = *(BYTE *) pbDiffCur;
					pbDiffCur += sizeof( BYTE );
					}
				}
				
			memcpy( pbNewCur, pbDiffCur, cbDataNew );
			pbDiffCur += cbDataNew;

			pbOldCur += cbDataOld;
			}

		pbNewCur += cbDataNew;

		Assert( pbDiffCur <= pbDiffMax );
		Assert( pbOldCur <= pbOld + cbOld );
		}

	/*	copy the rest of before image.
	 */
	cbT = (INT)(pbOld + cbOld - pbOldCur);
	Assert( cbChunkMost > cbRECRecordMost && pbNewCur + cbT - pbNew <= cbChunkMost );
	memcpy( pbNewCur, pbOldCur, cbT );
	pbNewCur += cbT;

	/*	set return value.
	 */
	*pcbNew = (INT)(pbNewCur - pbNew);

	return;	
	}


/*	cbDataOld == 0 ----------------------> insertion.
 *	cbDataNew == 0 ----------------------> deletion.
 *	cbDataOld != 0 && cbDataNew != 0 ----> replace.
 *
 *	Fomat: DiffHdr - cbDataNew - [cbDataOld] - [NewData]
 */

BOOL FLGAppendDiff(
	BYTE **ppbCur,		/* diff to append */
	BYTE *pbMax,		/* max of pbCur to append */
	INT	ibOffsetOld,
	INT	cbDataOld,
	INT	cbDataNew,
	BYTE *pbDataNew
	)
	{
	DIFFHDR diffhdr;
	BYTE *pbCur = *ppbCur;
	BOOL f2Bytes;

	Assert( sizeof( diffhdr ) == sizeof( WORD ) );
	
	diffhdr.ibOffset = (USHORT)ibOffsetOld;

	if ( cbDataOld > 255 || cbDataNew > 255 )
		f2Bytes = 1;
	else
		f2Bytes = 0;

	if ( f2Bytes )		
		diffhdr.f2BytesLength = fTrue;					/* two byte length */
	else
		diffhdr.f2BytesLength = fFalse;					/* one byte length */

	if ( cbDataOld == 0 )
		{
		diffhdr.fInsert = fTrue;						/* insertion */
		if ( pbDataNew )
			{
			diffhdr.fInsertWithFill = fFalse;		/* insert with value */

			/*	check if diff is too big.
			 */
			if ( ( pbCur + sizeof( DIFFHDR ) + ( 1 + f2Bytes ) + cbDataNew ) > pbMax )
				return fFalse;
			}
		else
			{
			diffhdr.fInsertWithFill = fTrue;			/* insert with Fill */
			
			/*	check if diff is too big.
			 */
			if ( ( pbCur + sizeof( DIFFHDR ) + ( 1 + f2Bytes ) ) > pbMax )
				return fFalse;
			}
		}
	else
		{
		diffhdr.fInsert = fFalse;					/* replace / deletion */
		if ( cbDataOld == cbDataNew )
			{
			diffhdr.fReplaceWithSameLength = fTrue;		/* replace with same length */

			Assert( cbDataOld != 0 );

			/*	check if diff is too big.
			 */
			if ( ( pbCur + sizeof( DIFFHDR ) + ( 1 + f2Bytes ) + cbDataNew ) > pbMax )
				return fFalse;
			}
		else
			{
			diffhdr.fReplaceWithSameLength = fFalse;	/* replace with different length */

			/*	check if diff is too big.
			 */
			if ( ( pbCur + sizeof( DIFFHDR ) + ( 1 + f2Bytes ) * 2 + cbDataNew ) > pbMax )
				return fFalse;
			}
		}

	/*	Create Diffs
	 */

	*(DIFFHDR *) pbCur = diffhdr;						/* assign diff header */
	pbCur += sizeof( DIFFHDR );

	if ( f2Bytes )
		{
		*(WORD UNALIGNED *)pbCur = (WORD)cbDataNew;						/* assign new data length */
		pbCur += sizeof( WORD );

		if ( cbDataOld != 0 && !diffhdr.fReplaceWithSameLength )
			{											/* if replace with different length */
			*(WORD UNALIGNED *)pbCur = (WORD)cbDataOld;					/* assign the old data length */
			pbCur += sizeof( WORD );
			}
		}
	else
		{
		*pbCur = (BYTE)cbDataNew;								/* assign new data length */
		pbCur += sizeof( BYTE );

		if ( cbDataOld != 0 && !diffhdr.fReplaceWithSameLength )
			{											/* if replace with different length */
			*pbCur = (BYTE)cbDataOld;							/* assign the old data length */
			pbCur += sizeof( BYTE );
			}
		}

	if ( pbDataNew && cbDataNew )
		{
		memcpy( pbCur, pbDataNew, cbDataNew );			/* copy new data */
		pbCur += cbDataNew;
		}

	*ppbCur = pbCur;

	return fTrue;
	}


/*	Go through each column, compare the before image and after image of each column.
 */

//  UNDONE:  Currently, we look at the rgbitSet bit array to detect if a column has
//  been set.  Since these bits no longer uniquely identify a particular column as
//  being set, we must compare the BI and the change for a difference for each column
//  set, and then only log if there is an actual change.

VOID LGSetDiffs(
	FUCB 		*pfucb,
	BYTE		*pbDiff,
	INT			*pcbDiff
	)
	{
	FDB		*pfdb;					// column info of file

	BYTE	*pbDiffCur;
	BYTE	*pbDiffMax;
	BOOL	fWithinBuffer;
	
	BYTE	*pbRecOld;
	INT		cbRecOld;
	FID		fidFixedLastInRecOld; 	// highest fixed fid actually in old record
	FID		fidVarLastInRecOld;		// highest var fid actually in old record

	BYTE	*pbRecNew;
	INT		cbRecNew;
	FID		fidFixedLastInRecNew; 	// highest fixed fid actually in new record
	FID		fidVarLastInRecNew;		// highest var fid actually in new record
	
	BOOL	fLogFixedFieldNullArray;
	BOOL	fLogVarFieldOffsetArray;
	
	WORD	UNALIGNED *pibFixOffs;
	WORD	UNALIGNED *pibVarOffsNew;
	WORD	UNALIGNED *pibVarOffsOld;
	TAGFLD	UNALIGNED *ptagfldNew;
	TAGFLD	UNALIGNED *ptagfldOld;
	BYTE	*pbRecNewMax;
	BYTE	*pbRecOldMax;
		
	FID		fid;

	Assert( pfucb != pfucbNil );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );
	Assert( pfucb->u.pfcb != pfcbNil );

	pfdb = (FDB *)pfucb->u.pfcb->pfdb;
	Assert( pfdb != pfdbNil );
	pibFixOffs = PibFDBFixedOffsets( pfdb );	// fixed column offsets

	/*	get old data
	 */
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
	pbRecOld = pfucb->lineData.pb;
	cbRecOld = pfucb->lineData.cb;
	Assert( pbRecOld != NULL );
	Assert( cbRecOld >= 4 && cbRecOld <= cbRECRecordMost );
	
	fidFixedLastInRecOld = ((RECHDR*)pbRecOld)->fidFixedLastInRec;
	Assert( fidFixedLastInRecOld >= (BYTE)(fidFixedLeast - 1) &&
		fidFixedLastInRecOld <= (BYTE)(fidFixedMost));
	
	fidVarLastInRecOld = ((RECHDR*)pbRecOld)->fidVarLastInRec;
	Assert( fidVarLastInRecOld >= (BYTE)(fidVarLeast - 1) &&
		fidVarLastInRecOld <= (BYTE)(fidVarMost));

	/*	get new data
	 */
	pbRecNew = pfucb->lineWorkBuf.pb;
	cbRecNew = pfucb->lineWorkBuf.cb;
	Assert( pbRecNew != NULL );
	Assert( cbRecNew >= 4 && cbRecNew <= cbRECRecordMost );
	
	fidFixedLastInRecNew = ((RECHDR*)pbRecNew)->fidFixedLastInRec;
	Assert( fidFixedLastInRecNew >= (BYTE)(fidFixedLeast - 1) &&
		fidFixedLastInRecNew <= (BYTE)(fidFixedMost));
	
	fidVarLastInRecNew = ((RECHDR*)pbRecNew)->fidVarLastInRec;
	Assert( fidVarLastInRecNew >= (BYTE)(fidVarLeast - 1) &&
		fidVarLastInRecNew <= (BYTE)(fidVarMost));

	/*	check old and new data are consistent.
	 */
	Assert( fidFixedLastInRecOld <= fidFixedLastInRecNew );
	Assert( fidVarLastInRecOld <= fidVarLastInRecNew );

	/*	get diff buffer, no bigger than after image (new rec)
	 */
	pbDiffCur = pbDiff;
	pbDiffMax = pbDiffCur + cbRecNew;
	fWithinBuffer = fTrue;

	/*	for each changed column, set its diff. check starting fixed column,
	 *	variable length column, and long value columns.
	 */
	fLogFixedFieldNullArray = fFalse;
	fLogVarFieldOffsetArray = fFalse;

	/*	log diffs if fidFixedLastInRec or fidVarLastInRec is changed.
	 */
		{
		INT ibOffsetOld;
		INT cbData = 0;
		BYTE *pbDataNew;

		if ( fidFixedLastInRecOld != fidFixedLastInRecNew &&
			 fidVarLastInRecOld == fidVarLastInRecNew )
			{
			ibOffsetOld = 0;
			cbData = 1;
			pbDataNew = pbRecNew;
			}
		else if ( fidFixedLastInRecOld == fidFixedLastInRecNew &&
			 fidVarLastInRecOld != fidVarLastInRecNew )
			{
			ibOffsetOld = 1;
			cbData = 1;
			pbDataNew = pbRecNew + 1;
			}
		else if ( fidFixedLastInRecOld != fidFixedLastInRecNew &&
			 fidVarLastInRecOld != fidVarLastInRecNew )
			{
			ibOffsetOld = 0;
			cbData = 2;
			pbDataNew = pbRecNew;
			}

		if ( cbData != 0 )
			{
			fWithinBuffer = FLGAppendDiff(
					&pbDiffCur,							/* diff to append */
					pbDiffMax,							/* max of pbDiffCur to append */
					ibOffsetOld,						/* offset to old rec */
					cbData,								/* cbDataOld */
					cbData,								/* cbDataNew */
					pbDataNew							/* pbDataNew */
					);
			/*	check if diff is too big.
			 */
			if ( !fWithinBuffer )
				goto AbortDiff;
			}
		}
			
	for ( fid = fidFixedLeast; fid <= pfdb->fidFixedLast; fid++ )
		{
		FIELD *pfield;
		INT	cbField;

		/*  if this column is not set, skip
		 */
		// UNDONE: make it table look up instead of loop.
		if ( !FFUCBColumnSet( pfucb, fid ) )
			{
			continue;
			}

		/*  at this point, the column _may_be_ set, but this is not known for
		 *  sure!
		 */

		/*	this fixed column is set, make the diffs.
		 *  (if this is a deleted column, skip)
		 */
		pfield = PfieldFDBFixed( pfdb ) + ( fid - fidFixedLeast );
		if ( pfield->coltyp == JET_coltypNil )
			{
			continue;
			}
		cbField = pfield->cbMaxLen;

		if ( fid <= fidFixedLastInRecOld )
			{
			/*	column was in old record. Log diffs.
			*/
			BYTE *prgbitNullityNew = pbRecNew + pibFixOffs[ fidFixedLastInRecNew ] + ( fid - fidFixedLeast ) / 8;
			BOOL fFieldNullNew = !( *prgbitNullityNew & (1 << ( fid + 8 - fidFixedLeast ) % 8) );
			BYTE *prgbitNullityOld = pbRecOld + pibFixOffs[ fidFixedLastInRecOld ] + ( fid - fidFixedLeast ) / 8;
			BOOL fFieldNullOld = !( *prgbitNullityOld & (1 << ( fid + 8 - fidFixedLeast ) % 8) );

			if ( fFieldNullNew || fFieldNullOld )
				{
//				/*	New field is null. Log whole null. Old one should not be null.
//				 */
//#ifdef DEBUG
//				BYTE *prgbitNullityNew = pbRecOld + pibFixOffs[ fidFixedLastInRecOld ] + ( fid - fidFixedLeast ) / 8;
//				Assert( (*prgbitNullityNew) & (1 << ( fid + 8 - fidFixedLeast ) % 8) );
//#endif

				/*	log the null array if one of the field whose old or new value is null
				 *	and got changed.
				 */
				fLogFixedFieldNullArray = fTrue;
				}
			
			if ( !fFieldNullNew )
				{
				fWithinBuffer = FLGAppendDiff(
					&pbDiffCur,									/* diff to append */
					pbDiffMax,									/* max of pbDiffCur to append */
					pibFixOffs[ fid ] - cbField,				/* offset to old rec */
					cbField,									/* cbDataOld */
					cbField,									/* cbDataNew */
					pbRecNew + pibFixOffs[ fid ] - cbField		/* pbDataNew */
					);
				
				/*	check if diff is too big.
				 */
				if ( !fWithinBuffer )
					goto AbortDiff;
				}
			}
		else
			{
			/*	column was not in old record. Log extended fixed columns.
			 *	if the column is first time added, then it can not be null.
			 */
			INT cbToAppend;

//#ifdef DEBUG
//			BYTE *prgbitNullity = pbRecNew + pibFixOffs[ fidFixedLastInRecNew ] + ( fid - fidFixedLeast ) / 8;
//			Assert( (*prgbitNullity) & (1 << ( fid + 8 - fidFixedLeast ) % 8) );
//#endif
			/*	we extend fixed field. Var offset is changed. Log it.
			 */
			fLogVarFieldOffsetArray = fTrue;

			/*	we extend fixed field. Null array is resized. Log it.
			 */
			fLogFixedFieldNullArray = fTrue;

			/*	log all the fields after fidFixedLastInRecOld.
			 */
			cbToAppend = pibFixOffs[ fidFixedLastInRecNew ] - pibFixOffs[ fidFixedLastInRecOld ];

			fWithinBuffer = FLGAppendDiff(
				&pbDiffCur,									/* diff to append */
				pbDiffMax,									/* max of pbDiffCur to append */
				pibFixOffs[ fidFixedLastInRecOld ],			/* offset to old rec */
				0,											/* cbDataOld */
				cbToAppend,									/* cbDataNew */
				pbRecNew + pibFixOffs[ fidFixedLastInRecNew ] - cbToAppend	/* pbDataNew */
				);
			
			/*	check if diff is too big.
			 */
			if ( !fWithinBuffer )
				goto AbortDiff;

			break;
			}

		}

	/*	check if need to log fixed fields Null Array.
	 */
	if ( fLogFixedFieldNullArray )
		{
		fWithinBuffer = FLGAppendDiff(
			&pbDiffCur,
			pbDiffMax,										/* max of pbDiffCur to append */
			pibFixOffs[ fidFixedLastInRecOld ],		/* offset to old image */
			( fidFixedLastInRecOld + 7 ) / 8,			/* length of the old image */
			( fidFixedLastInRecNew + 7 ) / 8,			/* length of the new image */
			pbRecNew + pibFixOffs[ fidFixedLastInRecNew ]	/* pbDataNew */
			);

		/*	check if diff is too big.
		 */
		if ( !fWithinBuffer )
			goto AbortDiff;
		}

	/*	check variable length fields
	/**/
	pibVarOffsOld = (WORD UNALIGNED *)( pbRecOld + pibFixOffs[ fidFixedLastInRecOld ] +
		( fidFixedLastInRecOld + 7 ) / 8 );
	
	pibVarOffsNew = (WORD UNALIGNED *)( pbRecNew + pibFixOffs[ fidFixedLastInRecNew ] +
		( fidFixedLastInRecNew + 7 ) / 8 );
	
	/*	check if need to log var field Offset Array.
	/**/
	if ( fLogVarFieldOffsetArray )
		{
		/*	log the offset array, including the tag field offset.
		/**/
		fWithinBuffer = FLGAppendDiff(
			&pbDiffCur,
			pbDiffMax,											/* max of pbDiffCur to append */
			(INT)((BYTE *)pibVarOffsOld - pbRecOld),			/* offset to old image */
			(fidVarLastInRecOld + 1 - fidVarLeast + 1 ) * sizeof(WORD),	/* length of the old image */
			(fidVarLastInRecNew + 1 - fidVarLeast + 1 ) * sizeof(WORD),	/* length of the new image */
			(BYTE *) pibVarOffsNew								/* pbDataNew */
			);
		
		/*	check if diff is too big.
		 */
		if ( !fWithinBuffer )
			goto AbortDiff;
		}
	else
		{
		/*	find first set var field whose length is changed. Log offset of fid after
		 *	this field. Note that also check the tag field offset ( fidVarLastInRecOld + 1 ).
		 */
		for ( fid = fidVarLeast; fid <= fidVarLastInRecOld + 1; fid++ )
			{
			if ( * ( (WORD UNALIGNED *) pibVarOffsOld + fid - fidVarLeast ) !=
			   * ( (WORD UNALIGNED *) pibVarOffsNew + fid - fidVarLeast  ) )
				break;
			}

		if ( fid <= fidVarLastInRecNew + 1 )
			{
			/*	we need to log the offset between fid and fidVarLastInRecNew and tag field offset
			 */
			fWithinBuffer = FLGAppendDiff(
				&pbDiffCur,
				pbDiffMax,													/* max of pbDiffCur to append */
				(INT)((BYTE*)( pibVarOffsOld + fid - fidVarLeast ) - pbRecOld),	/* offset to old image */
				( fidVarLastInRecOld + 1 - fid + 1 ) * sizeof(WORD),		/* length of the old image */
				( fidVarLastInRecNew + 1 - fid + 1 ) * sizeof(WORD),		/* length of the new image */
				(BYTE *)(pibVarOffsNew + fid - fidVarLeast )				/* pbDataNew */
				);
			
			/*	check if diff is too big.
			 */
			if ( !fWithinBuffer )
				goto AbortDiff;
			}
		}

	/*	check if diff is too big.
	 */
	if ( !fWithinBuffer )
		goto AbortDiff;

	/*	scan through each variable length field up to old last fid and log its replace image.
	 */
	for ( fid = fidVarLeast; fid <= fidVarLastInRecOld; fid++ )
		{
		FIELD			*pfield;
		INT				cbDataOld;
		INT				cbDataNew;
		WORD UNALIGNED	*pibFieldEnd;
		
		/*  if this column is not set, skip
		 */
		if ( !FFUCBColumnSet( pfucb, fid ) )
			continue;

		/*  at this point, the column _may_be_ set, but this is not known for
		 *  sure!
		 */

		/*  if this column is deleted, skip
		 */
		pfield = PfieldFDBVar( pfdb ) + ( fid - fidVarLeast );
		if ( pfield->coltyp == JET_coltypNil )
			{
			continue;
			}

		pibFieldEnd = &pibVarOffsOld[ fid + 1 - fidVarLeast ];
		cbDataOld  = ibVarOffset( *(WORD UNALIGNED *)pibFieldEnd ) - ibVarOffset( *(WORD UNALIGNED *)(pibFieldEnd-1) );
		
		pibFieldEnd = &pibVarOffsNew[ fid + 1 - fidVarLeast ];
		cbDataNew  = ibVarOffset( *(WORD UNALIGNED *)pibFieldEnd ) - ibVarOffset( *(WORD UNALIGNED *)(pibFieldEnd-1) );

		fWithinBuffer = FLGAppendDiff(
			&pbDiffCur,
			pbDiffMax,																/* max of pbDiffCur to append */
			( (WORD UNALIGNED *) pibVarOffsOld )[ fid - fidVarLeast ],				/* offset to old image */
			cbDataOld,																/* length of the old image */
			cbDataNew,																/* length of the new image */
			pbRecNew + ( (WORD UNALIGNED *) pibVarOffsNew )[ fid - fidVarLeast ]	/* pbDataNew */
			);
		
		/*	check if diff is too big.
		 */
		if ( !fWithinBuffer )
			goto AbortDiff;
		}
	
	/*	insert new image for fid > old last var fid as one contigous diff
	 */
	if ( fid <= fidVarLastInRecNew )
		{
		WORD UNALIGNED	*pibFieldStart = &pibVarOffsNew[ fid - fidVarLeast ];
		WORD UNALIGNED	*pibFieldEnd = &pibVarOffsNew[ fidVarLastInRecNew + 1 - fidVarLeast ];
		INT				cbDataNew = ibVarOffset( *(WORD UNALIGNED *)pibFieldEnd ) - ibVarOffset( *(WORD UNALIGNED *)pibFieldStart );

		Assert( fid == fidVarLastInRecOld + 1 );

		fWithinBuffer = FLGAppendDiff(
			&pbDiffCur,
			pbDiffMax,														/* max of pbDiffCur to append */
			( (WORD UNALIGNED *) pibVarOffsOld )[ fid - fidVarLeast ],		/* offset to old image */
			0,																/* length of the old image */
			cbDataNew,														/* length of the new image */
			pbRecNew + ibVarOffset( *( (WORD UNALIGNED *) pibFieldStart ) )	/* pbDataNew */
			);						

		/*	check if diff is too big.
		 */
		if ( !fWithinBuffer )
			goto AbortDiff;
		}

	/*	UNDONE see if a tagged column has been set. if not goto SetReturnValue
	/**/
	if ( !FFUCBTaggedColumnSet( pfucb ) )
		{
		goto SetReturnValue;
		}

	/*	go through each Tag fields. check if tag field is different and check if a tag is
	 *	deleted (set to Null), added (new tag field), or replaced.
	 */
	ptagfldOld = (TAGFLD *)
		( pbRecOld + ( (WORD UNALIGNED *) pibVarOffsOld )[fidVarLastInRecOld+1-fidVarLeast] );

	ptagfldNew = (TAGFLD *)
		( pbRecNew + ( (WORD UNALIGNED *) pibVarOffsNew )[fidVarLastInRecNew+1-fidVarLeast] );

	pbRecOldMax = pbRecOld + cbRecOld;
	pbRecNewMax = pbRecNew + cbRecNew;
	while ( (BYTE *)ptagfldOld < pbRecOldMax &&	(BYTE *)ptagfldNew < pbRecNewMax )
		{
		FID fidOld = ptagfldOld->fid;
		INT cbTagFieldOld = ptagfldOld->cb;
//		BOOL fNullOld = ptagfldOld->fNull;
		
		FID fidNew = ptagfldNew->fid;
		INT cbTagFieldNew = ptagfldNew->cb;
//		BOOL fNullNew = ptagfldNew->fNull;

		if ( fidOld == fidNew )
			{
			INT ibReplaceFrom;
			INT cbOld, cbNew;
			BYTE *pbNew;

			/*	check if contents are still the same. If not, log replace.
			 */
			if ( cbTagFieldNew != cbTagFieldOld ||
				 ptagfldOld->fNull != ptagfldNew->fNull ||
				 memcmp( ptagfldOld->rgb, ptagfldNew->rgb, cbTagFieldNew ) != 0 )
				{
				/*	replace from offset. Excluding FID.
				 */

				/*	make sure first field is fid.
				 */
				Assert( ptagfldOld->fid == *(FID UNALIGNED *)ptagfldOld );
				Assert( ptagfldNew->fid == *(FID UNALIGNED *)ptagfldNew );
			
				ibReplaceFrom = (INT)((BYTE *)ptagfldOld + sizeof(FID) - pbRecOld);
				cbOld = cbTagFieldOld + sizeof( *ptagfldOld ) - sizeof(FID);
				cbNew = cbTagFieldNew + sizeof( *ptagfldNew ) - sizeof(FID);
				pbNew = ptagfldNew->rgb - sizeof(FID);
				
				fWithinBuffer = FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,								/* max of pbDiffCur to append */
					ibReplaceFrom,							/* offset to old image */
					cbOld,									/* length of the old image */
					cbNew,									/* length of the new image */
					pbNew									/* pbDataNew */
					);
				
				/*	check if diff is too big.
				 */
				if ( !fWithinBuffer )
					goto AbortDiff;
				}

			ptagfldNew = (TAGFLD*)((BYTE*)(ptagfldNew + 1) + cbTagFieldNew);
			ptagfldOld = (TAGFLD*)((BYTE*)(ptagfldOld + 1) + cbTagFieldOld);
			}
		else if ( fidOld > fidNew )
			{
			/*	just set a new column, log insertion.
			 */
			INT ibInsert = (INT)((BYTE *)ptagfldOld - pbRecOld);
			INT cbNew = sizeof( *ptagfldNew ) + cbTagFieldNew;
			BYTE *pbNew = (BYTE *)ptagfldNew;
				
			fWithinBuffer = FLGAppendDiff(
				&pbDiffCur,
				pbDiffMax,									/* max of pbDiffCur to append */
				ibInsert,									/* offset to old image */
				0,											/* length of the old image */
				cbNew,										/* length of the new image */
				pbNew										/* pbDataNew */
				);
			
			/*	check if diff is too big.
			 */
			if ( !fWithinBuffer )
				goto AbortDiff;

			ptagfldNew = (TAGFLD*)((BYTE*)(ptagfldNew + 1) + cbTagFieldNew);
			}
		else
			{
			/*	just set a column to Null (or default value if default value is defined)
			 *	log as deletion.
			 */
			INT ibDelete = (INT)((BYTE *)ptagfldOld - pbRecOld);
			INT cbOld = sizeof( *ptagfldOld ) + cbTagFieldOld;
				
			fWithinBuffer = FLGAppendDiff(
				&pbDiffCur,
				pbDiffMax,										/* max of pbDiffCur to append */
				ibDelete,									/* offset to old image */
				cbOld,										/* length of the old image */
				0,											/* length of the new image */
				pbNil										/* pbDataNew */
				);
						
			/*	check if diff is too big.
			 */
			if ( !fWithinBuffer )
				goto AbortDiff;

			ptagfldOld = (TAGFLD*)((BYTE*)(ptagfldOld + 1) + cbTagFieldOld);
			}

		/*	check if diff is too big.
		 */
		if ( !fWithinBuffer )
			goto AbortDiff;
		}

	if ( (BYTE *)ptagfldNew < pbRecNewMax )
		{
		/*	insert the rest of new tag columns
		 */
		INT ibInsert = (INT)((BYTE *)ptagfldOld - pbRecOld);
		INT cbNew = (INT)(pbRecNewMax - (BYTE *) ptagfldNew);
		BYTE *pbNew = (BYTE *) ptagfldNew;

		Assert( (BYTE *)ptagfldOld == pbRecOldMax );
		
		fWithinBuffer = FLGAppendDiff(
			&pbDiffCur,
			pbDiffMax,										/* max of pbDiffCur to append */
			ibInsert,									/* offset to old image */
			0,											/* length of the old image */
			cbNew,										/* length of the new image */
			pbNew										/* pbDataNew */
			);

		/*	check if diff is too big.
		 */
		if ( !fWithinBuffer )
			goto AbortDiff;
		}

	if ( (BYTE *)ptagfldOld < pbRecOldMax )
		{
		/*	delete the remaining old tag columns
		 */
		INT ibDelete = (INT)((BYTE *)ptagfldOld - pbRecOld);
		INT cbOld = (INT)(pbRecOldMax - (BYTE *)ptagfldOld);
		
		Assert( (BYTE *)ptagfldNew == pbRecNewMax );
				
		fWithinBuffer = FLGAppendDiff(
			&pbDiffCur,
			pbDiffMax,										/* max of pbDiffCur to append */
			ibDelete,									/* offset to old image */
			cbOld,										/* length of the old image */
			0,											/* length of the new image */
			pbNil										/* pbDataNew */
			);

		/*	check if diff is too big.
		 */
		if ( !fWithinBuffer )
			goto AbortDiff;
		}

SetReturnValue:
	/*	set up return value.
	 */
	if ( pbDiffCur == pbDiff )
		{
		/*	Old and New are the same, log a short diff.
		 */
		if ( !FLGAppendDiff(
				&pbDiffCur,
				pbDiffMax,						/* max of pbDiffCur to append */
				0,							/* offset to old image */
				0,							/* length of the old image */
				0,							/* length of the new image */
				pbNil						/* pbDataNew */
				) )
			{
			Assert( *pcbDiff == 0 );
			return;
			}
		}

	*pcbDiff = (INT)(pbDiffCur - pbDiff);
	return;

AbortDiff:
	*pcbDiff = 0;
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\jstub.c ===
#include "std.h"


JET_ERR JET_API JetSetAccess(
JET_SESID sesid,
JET_DBID dbid,
const char  *szContainerName,
const char  *szObjectName,
const char  *szName,
JET_ACM acm,
JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetCreateLink(JET_SESID sesid, JET_DBID dbidDest,
	const char  *szNameDest, JET_DBID dbidSource,
	const char  *szNameSource, JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetCreateQuery(JET_SESID sesid, JET_DBID dbid,
	const char  *szQoName, JET_TABLEID  *ptableid)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetGetQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	const char  *szQuery, void  *pvResult, unsigned long cbMax,
	unsigned long  *pcbActual)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetSetQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char  *rgchSql, unsigned long cchSql, const char  *szConnect, JET_GRBIT grbit)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetOpenQueryDef(JET_SESID sesid, JET_DBID dbid,
	const char  *szQoName, JET_TABLEID  *ptableid)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetRetrieveQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char  *rgchSql, unsigned long cchMax, unsigned long  *pcchActual, 
	void  *pvConnect, unsigned long cbConnectMax, 
	unsigned long  *pcbConnectActual, JET_GRBIT  *pgrbit)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetGetTableReferenceInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char FAR *szReferenceName, void FAR *pvResult,
	unsigned long cbResult, unsigned long InfoLevel)
	{
   return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetExecuteSql(JET_SESID sesid, JET_DBID dbid,
	const char FAR *szSql)
	{
   return JET_errFeatureNotAvailable;
	}

JET_ERR JET_API JetGetSidFromName(JET_SESID sesid, const char  *szName,
	void  *pvSid, unsigned long cbMax, unsigned long  *pcbActual,
	long  *pfGroup)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetGetNameFromSid(JET_SESID sesid,
	const void  *pvSid, unsigned long cbSid,
	char  *szName, unsigned long cchName, long  *pfGroup)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetAddMember(JET_SESID sesid,
	const char  *szGroup, const char  *szUser)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetGetAccess(JET_SESID sesid, JET_DBID dbid,
	const char  *szContainerName, const char  *szObjectName,
	const char  *szName, long fIndividual,
	JET_ACM  *pacm, JET_GRBIT  *pgrbit)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetValidateAccess(JET_SESID sesid, JET_DBID dbid,
	const char  *szContainerName, const char  *szObjectName,
	JET_ACM acmRequired)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetDeleteGroup(JET_SESID sesid, const char  *szGroup)
	{
	return JET_errFeatureNotAvailable;
	}

	
JET_ERR JET_API JetSetOwner(JET_SESID sesid, JET_DBID dbid,
	const char  *szContainerName, const char  *szObjectName,
	const char  *szName)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetGetOwner(JET_SESID sesid, JET_DBID dbid,
	const char  *szContainerName, const char  *szObjectName,
	char  *szName, unsigned long cchMax)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetSetFatCursor(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvBookmark, unsigned long cbBookmark, unsigned long crowSize)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetFillFatCursor(JET_SESID sesid, JET_TABLEID tableid,
	void  *pvBookmark, unsigned long cbBookmark, unsigned long crow,
	unsigned long  *pcrow, JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetFastFind(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char  *szExpr, JET_GRBIT grbit,
	signed long  *pcrow)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetFastFindBegin(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char  *szExpr, JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetFastFindEnd(JET_SESID sesid, JET_TABLEID tableid)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetExecuteTempQuery(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const void  *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID  *ptableid)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetExecuteTempSVT(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const void  *pvParameters,
	unsigned long cbParameters, unsigned long crowSample, JET_GRBIT grbit,
	void  *pmgblist, unsigned long cbMax, unsigned long  *pcbActual)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetGetTempQueryColumnInfo(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char  *szColumnName,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetGetTempQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, void  *pvResult, unsigned long cbMax,
	unsigned long  *pcbActual)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetValidateData(JET_SESID sesid, JET_TABLEID tableidBase,
		JET_TABLEID  *ptableid )
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetDeleteUser(JET_SESID sesid, const char  *szUser)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetDeleteRelationship(JET_SESID sesid, JET_DBID dbidIn,
	const char  *szName)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetDeleteReference(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szReferenceName)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetCopyQuery(JET_SESID sesid, JET_TABLEID tableidSrc,
	JET_DBID dbidDest, const char  *szQueryDest,
	JET_TABLEID  *ptableidDest)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetChangeUserPassword(JET_SESID sesid,
	const char  *szUser, const char  *szOldPassword,
	const char  *szNewPassword)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetCreateGroup(JET_SESID sesid, const char  *szGroup,
	const char  *szPin)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetCreateUser(JET_SESID sesid, const char  *szUser,
	const char  *szPassword, const char  *szPin)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetCreateRelationship(JET_SESID sesid,JET_DBID dbidIn,
	const char  *szRelationshipName, const char  *szObjectName,
	const char  *szColumns, const char  *szReferencedObject,
	const char  *szReferncedColumns, char  *szLongName,
	unsigned long cbMax, unsigned long  *pcbActual, JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetCreateReference(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szReferenceName, const char  *szColumns,
	const char  *szReferencedTable,
	const char  *szReferencedColumns, JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}


JET_ERR JET_API JetUpdateUserFunctions(JET_SESID sesid)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetSetProperty(JET_SESID sesid, JET_DBID dbid,
	const char  *szContainerName, const char  *szObjectName, 
	const char  *szSubObjectName, const char  *szPropertyName,
	void  *pvData, unsigned long cbData, JET_COLTYP coltyp, 
	JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetSetTableProperty(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szSubObjectName, const char  *szPropertyName,
	void  *pvData, unsigned long cbData, JET_COLTYP coltyp, 
	JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetRetrieveTableProperty(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szSubObjectName, const char  *szPropertyName,
	void  *pvData, unsigned long cbData, unsigned long  *pcbActual,
	JET_COLTYP  *pcoltyp, JET_GRBIT grbit, unsigned long InfoLevel)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetRetrieveProperty(JET_SESID sesid, JET_DBID dbid,
	const char  *szContainerName, const char  *szObjectName, 
	const char  *szSubObjectName, const char  *szPropertyName,
	void  *pvData, unsigned long cbData, unsigned long  *pcbActual, 
	JET_COLTYP  *pcoltyp, JET_GRBIT grbit, unsigned long InfoLevel)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetGetReferenceInfo(JET_SESID sesid, JET_DBID dbid,
	const char  *szTableName, const char  *szReference,
	void  *pvResult, unsigned long cbResult, unsigned long InfoLevel)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetGetRelationshipInfo(JET_SESID sesid, JET_DBID dbid,
	const char  *szTableName, const char  *szRelationship,
	void  *pvResult, unsigned long cbResult)
	{
	return JET_errFeatureNotAvailable;
	}
	


JET_ERR JET_API JetOpenSVT(JET_SESID sesid, JET_DBID dbid,
	const char  *szQuery, const void  *pvParameters,
	unsigned long cbParameters, unsigned long crowSample, JET_GRBIT grbit,
	void  *pmgblist, unsigned long cbMax, unsigned long  *pcbActual)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetOpenVtQbe(JET_SESID sesid, const char  *szExpn,
	long  *plCols, JET_TABLEID  *ptableid, JET_GRBIT grbit)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetRefreshLink(JET_SESID sesid, JET_DBID dbid, 
	const char  *szLinkName, const char  *szConnect,
	const char  *szDatabase)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetRenameReference(JET_SESID sesid, JET_TABLEID tableid,
	const char  *szReference, const char  *szReferenceNew)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetRestartQuery(JET_SESID sesid, JET_TABLEID tableid,
	const void  *pvParameters, unsigned long cbParameters)
	{
	return JET_errFeatureNotAvailable;
	}
	

JET_ERR JET_API JetRemoveMember(JET_SESID sesid,
	const char  *szGroup, const char  *szUser)
	{
	return JET_errFeatureNotAvailable;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\logutil.c ===
#include "daestd.h"

#include <stdarg.h>
#include <io.h>

DeclAssertFile;					/* Declare file name for assert macros */

ERR ISAMAPI ErrIsamBeginExternalBackup( JET_GRBIT grbit );
ERR ISAMAPI ErrIsamGetAttachInfo( VOID *pv, ULONG cbMax, ULONG *pcbActual );
ERR ISAMAPI ErrIsamOpenFile( const CHAR *szFileName,
	JET_HANDLE	*phfFile, ULONG *pulFileSizeLow, ULONG *pulFileSizeHigh );
ERR ISAMAPI ErrIsamReadFile( JET_HANDLE hfFile, VOID *pv, ULONG cbMax, ULONG *pcbActual );
ERR ISAMAPI ErrIsamCloseFile( JET_HANDLE hfFile );
ERR ISAMAPI ErrIsamGetLogInfo( VOID *pv, ULONG cbMax, ULONG *pcbActual );
ERR ISAMAPI ErrIsamTruncateLog( VOID );
ERR ISAMAPI ErrIsamEndExternalBackup( VOID );
ERR ISAMAPI ErrIsamExternalRestore( CHAR *szCheckpointFilePath, CHAR *szLogPath, JET_RSTMAP *rgjstmap, INT cjrstmap, CHAR *szBackupLogPath, LONG lgenLow, LONG lgenHigh, JET_PFNSTATUS pfn );
VOID LGIClosePatchFile( FMP *pfmp );

STATIC ERR ErrLGExternalBackupCleanUp( ERR err );

#define cpagePatch	20
#define szTemp	"temp"

/*	global current log file name, for logging and recovery
/**/
CHAR	szLogName[_MAX_PATH + 1];

/*	global log file directory
/**/
CHAR	*szLogCurrent;

/*	global backup variables
/**/
BOOL	fGlobalExternalRestore = fFalse;
LONG	lGlobalGenLowRestore;
LONG	lGlobalGenHighRestore;

BOOL	fBackupInProgress = fFalse;
LGPOS	lgposFullBackupMark;
LOGTIME	logtimeFullBackupMark;
LONG	lgenCopyMic;
LONG	lgenCopyMac;
LONG	lgenDeleteMic;
LONG	lgenDeleteMac;
PIB		*ppibBackup = ppibNil;
BOOL	fBackupFull;
BOOL	fBackupBeginNewLogFile;

PATCHLST **rgppatchlst = NULL;


VOID LGMakeName( CHAR *szName, CHAR *szPath, CHAR *szFName, CHAR *szExt )
	{
	CHAR	szDriveT[_MAX_DRIVE + 1];
	CHAR	szDirT[_MAX_DIR + 1];
	CHAR	szFNameT[_MAX_FNAME + 1];
	CHAR	szExtT[_MAX_EXT + 1];

	_splitpath( szPath, szDriveT, szDirT, szFNameT, szExtT );
	_makepath( szName, szDriveT, szDirT, szFName, szExt );
	return;
	}


VOID LGFirstGeneration( CHAR *szFindPath, LONG *plgen )
	{
	ERR		err;
	CHAR	szFind[_MAX_PATH + _MAX_FNAME + 1];
	CHAR	szFileName[_MAX_FNAME + 1];
	HANDLE	handleFind = handleNil;
	LONG	lGenMax = lGenerationMax;

	/*	make search string "<search path>\edb*.log"
	/**/
	strcpy( szFind, szFindPath );
	Assert( szFindPath[strlen(szFindPath) - 1] == '\\' );
	strcat( szFind, szJet );
	strcat( szFind, "*" );
	strcat( szFind, szLogExt );

	err = ErrUtilFindFirstFile( szFind, &handleFind, szFileName );
	if ( err < 0 )
		{
		if ( err != JET_errFileNotFound )
			{
			Error( ErrERRCheck( err ), HandleError );
			}
		}

	Assert( err == JET_errSuccess || err == JET_errFileNotFound );
	if ( err != JET_errFileNotFound )
		{
		forever
			{
			BYTE	szT[4];
			CHAR	szDriveT[_MAX_DRIVE + 1];
			CHAR	szDirT[_MAX_DIR + 1];
			CHAR	szFNameT[_MAX_FNAME + 1];
			CHAR	szExtT[_MAX_EXT + 1];

			/*	call splitpath to get file name and extension
			/**/
			_splitpath( szFileName, szDriveT, szDirT, szFNameT, szExtT );

			/* if length of a numbered log file name and has log file extension
			/**/
			if ( strlen( szFNameT ) == 8 && UtilCmpName( szExtT, szLogExt ) == 0 )
				{
				memcpy( szT, szFNameT, 3 );
				szT[3] = '\0';

				/* if has log file extension
				/**/
				if ( UtilCmpName( szT, szJet ) == 0 )
					{
					INT		ib = 3;
					INT		ibMax = 8;
					LONG	lGen = 0;

					for ( ; ib < ibMax; ib++ )
						{
						BYTE	b = szFNameT[ib];

						if ( b >= '0' && b <= '9' )
							lGen = lGen * 16 + b - '0';
						else if ( b >= 'A' && b <= 'F' )
							lGen = lGen * 16 + b - 'A' + 10;
						else
							break;
						}
				
					if ( ib == ibMax )
						{
						if ( lGen < lGenMax )
							lGenMax = lGen;
						}
					}
				}

			err = ErrUtilFindNextFile( handleFind, szFileName );
			if ( err < 0 )
				{
				if ( err != JET_errFileNotFound )
					Error( ErrERRCheck( err ), HandleError );
				break;
				}
			}
		}

HandleError:
	if ( handleFind != handleNil )
		UtilFindClose( handleFind ); 	

	if ( lGenMax == lGenerationMax )
		lGenMax = 0;
	*plgen = lGenMax;
	return;
	}


VOID LGLastGeneration( CHAR *szFindPath, LONG *plgen )
	{
	ERR		err;
	CHAR	szFind[_MAX_PATH + _MAX_FNAME + 1];
	CHAR	szFileName[_MAX_FNAME + 1];
	HANDLE	handleFind = handleNil;
	LONG	lGenLast = 0;

	/*	make search string "<search path>\edb*.log"
	/**/
	strcpy( szFind, szFindPath );
	Assert( szFindPath[strlen(szFindPath) - 1] == '\\' );
	strcat( szFind, szJet );
	strcat( szFind, "*" );
	strcat( szFind, szLogExt );

	err = ErrUtilFindFirstFile( szFind, &handleFind, szFileName );
	if ( err < 0 )
		{
		if ( err != JET_errFileNotFound )
			{
			Error( ErrERRCheck( err ), HandleError );
			}
		}

	Assert( err == JET_errSuccess || err == JET_errFileNotFound );
	if ( err != JET_errFileNotFound )
		{
		forever
			{
			BYTE	szT[4];
			CHAR	szDriveT[_MAX_DRIVE + 1];
			CHAR	szDirT[_MAX_DIR + 1];
			CHAR	szFNameT[_MAX_FNAME + 1];
			CHAR	szExtT[_MAX_EXT + 1];

			/*	call splitpath to get file name and extension
			/**/
			_splitpath( szFileName, szDriveT, szDirT, szFNameT, szExtT );

			/* if length of a numbered log file name and has log file extension
			/**/
			if ( strlen( szFNameT ) == 8 && UtilCmpName( szExtT, szLogExt ) == 0 )
				{
				memcpy( szT, szFNameT, 3 );
				szT[3] = '\0';

				/* if has log file extension
				/**/
				if ( UtilCmpName( szT, szJet ) == 0 )
					{
					INT		ib = 3;
					INT		ibMax = 8;
					LONG	lGen = 0;

					for ( ; ib < ibMax; ib++ )
						{
						BYTE	b = szFNameT[ib];

						if ( b >= '0' && b <= '9' )
							lGen = lGen * 16 + b - '0';
						else if ( b >= 'A' && b <= 'F' )
							lGen = lGen * 16 + b - 'A' + 10;
						else
							break;
						}
				
					if ( ib == ibMax )
						{
						if ( lGen > lGenLast )
							lGenLast = lGen;
						}
					}
				}

			err = ErrUtilFindNextFile( handleFind, szFileName );
			if ( err < 0 )
				{
				if ( err != JET_errFileNotFound )
					Error( ErrERRCheck( err ), HandleError );
				break;
				}
			}
		}

HandleError:
	if ( handleFind != handleNil )
		UtilFindClose( handleFind );

	*plgen = lGenLast;
	return;
	}


ERR ErrLGCheckDBFiles( CHAR *szDatabase, CHAR *szPatch, SIGNATURE *psignLog, int genLow, int genHigh )
	{
	ERR err;
	DBFILEHDR *pdbfilehdrDb;
	DBFILEHDR *pdbfilehdrPatch;

	/*	check if dbfilehdr of database and patchfile are the same.
	/**/
	pdbfilehdrDb = (DBFILEHDR * )PvUtilAllocAndCommit( sizeof( DBFILEHDR ) );
	if ( pdbfilehdrDb == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	err = ErrUtilReadShadowedHeader( szDatabase, (BYTE *)pdbfilehdrDb, sizeof( DBFILEHDR ) );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader2;
		}

	pdbfilehdrPatch = (DBFILEHDR * )PvUtilAllocAndCommit( sizeof( DBFILEHDR ) );
	if ( pdbfilehdrPatch == NULL )
		{
		UtilFree( pdbfilehdrDb );
		goto EndOfCheckHeader2;
		}

	err = ErrUtilReadShadowedHeader( szPatch, (BYTE *)pdbfilehdrPatch, sizeof( DBFILEHDR ) );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader;
		}

	if ( memcmp( &pdbfilehdrDb->signDb, &pdbfilehdrPatch->signDb, sizeof( SIGNATURE ) ) != 0 ||
		 memcmp( &pdbfilehdrDb->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 ||
		 memcmp( &pdbfilehdrPatch->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 ||
		 CmpLgpos( &pdbfilehdrDb->bkinfoFullCur.lgposMark,
				   &pdbfilehdrPatch->bkinfoFullCur.lgposMark ) != 0 )
		{
		char *rgszT[1];
		rgszT[0] = szDatabase;
		UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
					DATABASE_PATCH_FILE_MISMATCH_ERROR_ID, 1, rgszT );
		err = JET_errDatabasePatchFileMismatch;
		}
		
	else if ( pdbfilehdrPatch->bkinfoFullCur.genLow < (ULONG) genLow )
		{
		/*	It should start at most from bkinfoFullCur.genLow
		 */
		char szT1[20];
		char szT2[20];
		char *rgszT[2];
		_itoa( genLow, szT1, 10 );
		_itoa( pdbfilehdrPatch->bkinfoFullCur.genLow, szT2, 10 );
 		rgszT[0] = szT1;
 		rgszT[1] = szT2;
		UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
					STARTING_RESTORE_LOG_TOO_HIGH_ERROR_ID, 2, rgszT );
		err = JET_errStartingRestoreLogTooHigh;
		}

	else if ( pdbfilehdrPatch->bkinfoFullCur.genHigh > (ULONG) genHigh )
		{
		/*	It should be at least from bkinfoFullCur.genHigh
		 */
		char szT1[20];
		char szT2[20];
		char *rgszT[2];
		_itoa( genHigh, szT1, 10 );
		_itoa( pdbfilehdrPatch->bkinfoFullCur.genHigh, szT2, 10 );
 		rgszT[0] = szT1;
 		rgszT[1] = szT2;
		UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
					ENDING_RESTORE_LOG_TOO_LOW_ERROR_ID, 2, rgszT );
		err = JET_errEndingRestoreLogTooLow;
		}
		 
EndOfCheckHeader:	
	UtilFree( pdbfilehdrPatch );
EndOfCheckHeader2:	
	UtilFree( pdbfilehdrDb );

	return err;
	}


ERR ErrLGRSTOpenLogFile( CHAR *szLogPath, INT gen, HANDLE *phf )
	{
	BYTE   		rgbFName[_MAX_FNAME + 1];
	CHAR		szPath[_MAX_PATH + 1];

	strcpy( szPath, szLogPath );

	if ( gen == 0 )
		strcat( szPath, szJetLog );
	else
		{
		LGSzFromLogId( rgbFName, gen );
		strcat( szPath, rgbFName );
		strcat( szPath, szLogExt );
		}

	return ErrUtilOpenFile( szPath, phf, 0, fFalse, fFalse );
	}


#define fLGRSTIncludeJetLog	fTrue
#define fLGRSTNotIncludeJetLog fFalse
VOID LGRSTDeleteLogs( CHAR *szLog, INT genLow, INT genHigh, BOOL fIncludeJetLog )
	{
	INT gen;
	BYTE rgbFName[_MAX_FNAME + 1];
	CHAR szPath[_MAX_PATH + 1];
	
	for ( gen = genLow; gen <= genHigh; gen++ )
		{
		LGSzFromLogId( rgbFName, gen );
		strcpy( szPath, szLog );
		strcat( szPath, rgbFName );
		strcat( szPath, szLogExt );
		(VOID)ErrUtilDeleteFile( szPath );
		}

	if ( fIncludeJetLog )
		{
		strcpy( szPath, szLog );
		strcat( szPath, szJetLog );
		(VOID)ErrUtilDeleteFile( szPath );
		}
	}


ERR ErrLGRSTCheckSignaturesLogSequence(
	char *szRestorePath,
	char *szLogFilePath,
	INT	genLow,
	INT	genHigh )
	{
	ERR			err = JET_errSuccess;
	INT			gen;
	INT			genLowT;
	INT			genHighT;
	HANDLE		hfT = handleNil;
	LGFILEHDR	*plgfilehdrT = NULL;
	LGFILEHDR	*plgfilehdrCur[2] = { NULL, NULL };
	LGFILEHDR	*plgfilehdrLow = NULL;
	LGFILEHDR	*plgfilehdrHigh = NULL;
	INT			ilgfilehdrAvail = 0;
	INT			ilgfilehdrCur;
	INT			ilgfilehdrPrv;
	BOOL		fReadyToCheckContiguity;
	ERR			wrn = JET_errSuccess;

	plgfilehdrT = (LGFILEHDR *)PvUtilAllocAndCommit( sizeof(LGFILEHDR) * 4 );
	if ( plgfilehdrT == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	plgfilehdrCur[0] = plgfilehdrT;
	plgfilehdrCur[1] = plgfilehdrT + 1;
	plgfilehdrLow = plgfilehdrT + 2;
	plgfilehdrHigh = plgfilehdrT + 3;

	/*	starting from lowest generation of the restored path.
	 *	Check the given logs are all correct and contiguous
	 */
	for ( gen = genLow; gen <= genHigh; gen++ )
		{
		ilgfilehdrCur = ilgfilehdrAvail++ % 2;
		ilgfilehdrPrv = ilgfilehdrAvail % 2;

		Call( ErrLGRSTOpenLogFile( szRestorePath, gen, &hfT ) );
		Call( ErrLGReadFileHdr( hfT, plgfilehdrCur[ ilgfilehdrCur ], fCheckLogID ) );
		CallS( ErrUtilCloseFile( hfT ) );
		hfT = handleNil;

		if ( gen == genLow )
			{
			memcpy( plgfilehdrLow, plgfilehdrCur[ ilgfilehdrCur ], sizeof( LGFILEHDR ) );
			}

		if ( gen == genHigh )
			{
			memcpy( plgfilehdrHigh, plgfilehdrCur[ ilgfilehdrCur ], sizeof( LGFILEHDR ) );
			}

		if ( gen > genLow )
			{			
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->signLog,
						 &plgfilehdrCur[ ilgfilehdrPrv ]->signLog,
						 sizeof( SIGNATURE ) ) != 0 )
				{
				char szT[20];
				char *rgszT[1];
				_itoa( gen, szT, 16 );
				rgszT[0] = szT;
				UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
					RESTORE_LOG_FILE_HAS_BAD_SIGNATURE_ERROR_ID, 1, rgszT );
				Call( ErrERRCheck( JET_errGivenLogFileHasBadSignature ) );
				}
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->tmPrevGen,
						 &plgfilehdrCur[ ilgfilehdrPrv ]->tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				char szT[20];
				char *rgszT[1];
				_itoa( gen, szT, 16 );
				rgszT[0] = szT;
				UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
					RESTORE_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID, 1, rgszT );
				Call( ErrERRCheck( JET_errGivenLogFileIsNotContiguous ) );
				}
			}
		}

	if ( gen <= genHigh )
		{
		char szT[20];
		char *rgszT[1];
		_itoa( gen, szT, 16 );
		rgszT[0] = szT;
		UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
				RESTORE_LOG_FILE_MISSING_ERROR_ID, 1, rgszT );
		Call( ErrERRCheck( JET_errMissingRestoreLogFiles ) );
		}

	/*	if Restore path and log path is different, delete all the unrelated log files
	 *	in the log path.
	 */
	if ( _stricmp( szRestorePath, szLogFilePath ) != 0 )
		{
		LGFirstGeneration( szRestorePath, &genLowT );
		LGRSTDeleteLogs( szRestorePath, genLowT, genLow - 1, fLGRSTNotIncludeJetLog );
		
		LGLastGeneration( szRestorePath, &genHighT );
		LGRSTDeleteLogs( szRestorePath, genHigh + 1, genHighT, fLGRSTIncludeJetLog );
		}

	/*	Check the log directory. Make sure all the log files has the same signature.
	 */
	LGFirstGeneration( szLogFilePath, &genLowT );
	LGLastGeneration( szLogFilePath, &genHighT );

	/*	genHighT + 1 implies JetLog file (edb.log).
	 */
	if ( genLowT > genHigh )
		fReadyToCheckContiguity = fTrue;
	else
		fReadyToCheckContiguity = fFalse;

	for ( gen = genLowT; gen <= genHighT + 1; gen++ )
		{
		if ( gen == 0 )
			{
			/*	A special case. Check if JETLog(edb.log) exist?
			 */
			if ( ErrLGRSTOpenLogFile( szLogFilePath, 0, &hfT ) < 0 )
				break;

			/*	Set break condition. Also set condition to check if
			 *	the log is contiguous from the restore logs ( genHigh + 1 )
			 */
			gen = genHigh + 1;
			genHighT = genHigh;
			Assert( gen == genHighT + 1 );
			}
		else
			{
			if ( gen == genHighT + 1 )
				{
				/*	A special case. Check if JETLog(edb.log) exist?
				 */
				if ( ErrLGRSTOpenLogFile( szLogFilePath, 0, &hfT ) < 0 )
					break;
				}
			else
				{
				if ( ErrLGRSTOpenLogFile( szLogFilePath, gen, &hfT ) < 0 )
					goto NotContiguous;
				}
			}

		ilgfilehdrCur = ilgfilehdrAvail++ % 2;
		ilgfilehdrPrv = ilgfilehdrAvail % 2;

		Call( ErrLGReadFileHdr( hfT, plgfilehdrCur[ ilgfilehdrCur ], fNoCheckLogID ) );
		CallS( ErrUtilCloseFile( hfT ) );
		hfT = handleNil;

		if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->signLog,
					 &plgfilehdrHigh->signLog,
					 sizeof( SIGNATURE ) ) != 0 )
			{
			INT	genDeleteFrom;
			INT genDeleteTo;
			INT genCurrent;
			BOOL fDeleteJetLog;
			
			char szT1[20];
			char szT2[20];
			char szT3[20];
			char *rgszT[3];
			rgszT[0] = szT1;
			rgszT[1] = szT2;
			rgszT[2] = szT3;

			if ( gen < genLow )
				{
				genDeleteFrom = genLowT;
				genDeleteTo = genLow - 1;
				genCurrent = genLow - 1;
				fDeleteJetLog = fLGRSTNotIncludeJetLog;
				}
			else if ( gen <= genHigh )
				{
				genDeleteFrom = genLowT;
				genDeleteTo = gen;
				genCurrent = gen;
				fDeleteJetLog = fLGRSTNotIncludeJetLog;
				}
			else
				{
				genDeleteFrom = gen;
				genDeleteTo = genHighT;
				genCurrent = genHighT + 1;	// to break out the loop
				fDeleteJetLog = fLGRSTIncludeJetLog;
				}
			_itoa( gen, szT1, 16 );
			_itoa( genDeleteFrom, szT2, 16 );
			_itoa( genDeleteTo, szT3, 16 );
			UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY,
								 EXISTING_LOG_FILE_HAS_BAD_SIGNATURE_ERROR_ID, 3, rgszT );

			wrn = ErrERRCheck( JET_wrnExistingLogFileHasBadSignature );
			LGRSTDeleteLogs( szLogFilePath, genDeleteFrom, genDeleteTo, fDeleteJetLog );
			gen = genCurrent;
			fReadyToCheckContiguity = fFalse;
			continue;
			}

		if ( fReadyToCheckContiguity )
			{
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->tmPrevGen,
						 &plgfilehdrCur[ ilgfilehdrPrv ]->tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
NotContiguous:
				fReadyToCheckContiguity = fFalse;
				wrn = ErrERRCheck( JET_wrnExistingLogFileIsNotContiguous );

				if ( gen < genLow )
					{
					char szT1[20];
					char szT2[20];
					char szT3[20];
					char *rgszT[3];

					_itoa( gen, szT1, 16 );
					_itoa( genLowT, szT2, 16 );
					_itoa( gen - 1, szT3, 16 );
					
					rgszT[0] = szT1;
					rgszT[1] = szT2;
					rgszT[2] = szT3;

					UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY,
							EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID, 3, rgszT );

					LGRSTDeleteLogs( szLogFilePath, genLowT, gen - 1, fLGRSTNotIncludeJetLog );
					continue;
					}
				else if ( gen <= genHigh )
					{
					char szT1[20];
					char szT2[20];
					char szT3[20];
					char *rgszT[3];

					_itoa( gen, szT1, 16 );
					_itoa( genLowT, szT2, 16 );
					_itoa( genHigh, szT3, 16 );

					rgszT[0] = szT1;
					rgszT[1] = szT2;
					rgszT[2] = szT3;

					UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY,
							EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID, 3, rgszT );

					Assert( _stricmp( szRestorePath, szLogFilePath ) != 0 );
					LGRSTDeleteLogs( szLogFilePath, genLowT, genHigh, fLGRSTNotIncludeJetLog );
					gen = genHigh;
					continue;
					}
				else
					{
					char szT1[20];
					char szT2[20];
					char szT3[20];
					char *rgszT[3];

					_itoa( gen, szT1, 16 );
					_itoa( gen, szT2, 16 );
					_itoa( genHighT, szT3, 16 );

					rgszT[0] = szT1;
					rgszT[1] = szT2;
					rgszT[2] = szT3;

					UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY,
							EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID, 3, rgszT );

					LGRSTDeleteLogs( szLogFilePath, gen, genHighT, fLGRSTIncludeJetLog );
					break;
					}
				}
			}

		if ( gen == genLow - 1 )
			{
			/*	make sure it and the restore log are contiguous. If not, then delete
			 *	all the logs up to genLow - 1.
			 */
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->tmCreate,
						 &plgfilehdrLow->tmPrevGen,
						 sizeof( LOGTIME ) ) != 0 )
				{
				char szT1[20];
				char szT2[20];
				char szT3[20];
				char *rgszT[3];

				_itoa( gen, szT1, 16 );
				_itoa( genLowT, szT2, 16 );
				_itoa( gen - 1, szT3, 16 );
				
				rgszT[0] = szT1;
				rgszT[1] = szT2;
				rgszT[2] = szT3;

				UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY,
							EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID, 3, rgszT );

				wrn = ErrERRCheck( JET_wrnExistingLogFileIsNotContiguous );

				LGRSTDeleteLogs( szLogFilePath, genLowT, gen - 1, fLGRSTNotIncludeJetLog );
				fReadyToCheckContiguity = fFalse;

				continue;
				}
			}

		if ( gen == genLow )
			{
			/*	make sure it and the restore log are the same. If not, then delete
			 *	all the logs up to genHigh.
			 */
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->tmCreate,
						 &plgfilehdrLow->tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				char szT1[20];
				char szT2[20];
				char szT3[20];
				char *rgszT[3];

				_itoa( gen, szT1, 16 );
				_itoa( genLowT, szT2, 16 );
				_itoa( genHigh, szT3, 16 );

				rgszT[0] = szT1;
				rgszT[1] = szT2;
				rgszT[2] = szT3;

				UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY,
							EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID, 3, rgszT );

				wrn = ErrERRCheck( JET_wrnExistingLogFileIsNotContiguous );

				Assert( _stricmp( szRestorePath, szLogFilePath ) != 0 );
				LGRSTDeleteLogs( szLogFilePath, genLowT, genHigh, fLGRSTNotIncludeJetLog );
				gen = genHigh;
				continue;
				}
			}

		if ( gen == genHigh + 1 )
			{
			/*	make sure it and the restore log are contiguous. If not, then delete
			 *	all the logs higher than genHigh.
			 */
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->tmPrevGen,
						 &plgfilehdrHigh->tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				char szT1[20];
				char szT2[20];
				char szT3[20];
				char *rgszT[3];

				_itoa( gen, szT1, 16 );
				_itoa( genHigh + 1, szT2, 16 );
				_itoa( genHighT, szT3, 16 );
				rgszT[0] = szT1;
				rgszT[1] = szT2;
				rgszT[2] = szT3;

				UtilReportEvent( EVENTLOG_WARNING_TYPE, LOGGING_RECOVERY_CATEGORY,
							EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID, 3, rgszT );

				wrn = ErrERRCheck( JET_wrnExistingLogFileIsNotContiguous );

				LGRSTDeleteLogs( szLogFilePath, genHigh + 1, genHighT, fLGRSTIncludeJetLog );
				break;
				}
			}
		
		fReadyToCheckContiguity = fTrue;
		}

HandleError:
	if ( err == JET_errSuccess )
		err = wrn;

	if ( hfT != handleNil )
		CallS( ErrUtilCloseFile( hfT ) );
	
	if ( plgfilehdrT != NULL )
		UtilFree( plgfilehdrT );

	return err;
	}


/*	caller has to make sure szDir has enough space for appending "\*"
/**/
LOCAL ERR ErrLGDeleteAllFiles( CHAR *szDir )
	{
	ERR		err;
	CHAR	szFileName[_MAX_FNAME + 1];
	CHAR	szFilePathName[_MAX_PATH + _MAX_FNAME + 1];
	HANDLE	handleFind = handleNil;

	Assert( szDir[strlen(szDir) - 1] == '\\' );
	strcat( szDir, "*" );

	err = ErrUtilFindFirstFile( szDir, &handleFind, szFileName );
	/*	restore szDir
	/**/
	szDir[strlen(szDir) - 1] = '\0';
	if ( err < 0 )
		{
		if ( err != JET_errFileNotFound )
			{
			Error( ErrERRCheck( err ), HandleError );
			}
		}

	Assert( err == JET_errSuccess || err == JET_errFileNotFound );
	if ( err != JET_errFileNotFound )
		{
		forever
			{
			/* not . , and .. and not temp
			/**/
			if ( szFileName[0] != '.' &&
				UtilCmpName( szFileName, szTemp ) != 0 )
				{
				strcpy( szFilePathName, szDir );
				strcat( szFilePathName, szFileName );
				err = ErrUtilDeleteFile( szFilePathName );
				if ( err != JET_errSuccess )
					{
					err = ErrERRCheck( JET_errDeleteBackupFileFail );
					goto HandleError;
					}
				}

			err = ErrUtilFindNextFile( handleFind, szFileName );
			if ( err < 0 )
				{
				if ( err != JET_errFileNotFound )
					Error( ErrERRCheck( err ), HandleError );
				break;
				}
			}
		}

	err = JET_errSuccess;

HandleError:
	/*	assert restored szDir
	/**/
	Assert( szDir[strlen(szDir)] != '*' );

	if ( handleFind != handleNil )
		UtilFindClose( handleFind );

	return err;
	}


/*	caller has to make sure szDir has enough space for appending "\*"
/**/
LOCAL ERR ErrLGCheckDir( CHAR *szDir, CHAR *szSearch )
	{
	ERR		err;
	CHAR	szFileName[_MAX_FNAME + 1];
	HANDLE	handleFind = handleNil;

	Assert( szDir[strlen(szDir) - 1] == '\\' );
	strcat( szDir, "*" );

	err = ErrUtilFindFirstFile( szDir, &handleFind, szFileName );
	/*	restore szDir
	/**/
	szDir[ strlen(szDir) - 1 ] = '\0';
	if ( err < 0 )
		{
		if ( err != JET_errFileNotFound )
			{
			Error( ErrERRCheck( err ), HandleError );
			}
		}

	Assert( err == JET_errSuccess || err == JET_errFileNotFound );
	if ( err != JET_errFileNotFound )
		{
		forever
			{
			/* not . , and .. not temp
			/**/
			if ( szFileName[0] != '.' &&
				( szSearch == NULL ||
				UtilCmpName( szFileName, szSearch ) == 0 ) )
				{
				err = ErrERRCheck( JET_errBackupDirectoryNotEmpty );
				goto HandleError;
				}

			err = ErrUtilFindNextFile( handleFind, szFileName );
			if ( err < 0 )
				{
				if ( err != JET_errFileNotFound )
					Error( ErrERRCheck( err ), HandleError );
				break;
				}
			}
		}

	err = JET_errSuccess;

HandleError:
	/*	assert restored szDir
	/**/
	Assert( szDir[strlen(szDir)] != '*' );

	if ( handleFind != handleNil )
		UtilFindClose( handleFind );

	return err;
	}


//	padding to add to account for log files
#define cBackupStatusPadding	0.05

/*	calculates initial backup size, and accounts for
/*	database growth during backup.
/**/
LOCAL VOID LGGetBackupSize( DBID dbidNextToBackup, ULONG cPagesSoFar, ULONG *pcExpectedPages )
	{
	DBID	dbid;
	FMP		*pfmpT;
	ULONG	cPagesLeft = 0, cNewExpected;

	//Assert( cPagesSoFar >= 0 && *pcExpectedPages >= 0 );

	for ( dbid = dbidNextToBackup; dbid < dbidMax; dbid++ )
		{
		QWORDX		qwxFileSize;

		pfmpT = &rgfmp[dbid];

		if ( !pfmpT->szDatabaseName || !pfmpT->fLogOn )
			continue;

		qwxFileSize.l = pfmpT->ulFileSizeLow;
		qwxFileSize.h = pfmpT->ulFileSizeHigh;
		cPagesLeft = (ULONG)( qwxFileSize.qw / cbPage );
		}

	cNewExpected = cPagesSoFar + cPagesLeft;
	cNewExpected = cNewExpected + (ULONG)(cBackupStatusPadding * cNewExpected);

	Assert(cNewExpected >= *pcExpectedPages);

	/*	check if grown since our last determination of backup size
	/**/
	if ( cNewExpected > *pcExpectedPages )
		*pcExpectedPages = cNewExpected;
	}

#ifdef DEBUG
BYTE	*pbLGDBGPageList = NULL;
#endif

/*	read cpage into buffer ppageMin for backup.
 */
ERR ErrLGBKReadPages(
	FUCB *pfucb,
	OLP *polp,
	DBID dbid,
	PAGE *ppageMin,
	INT	cpage,
	INT	*pcbActual
	)
	{
	ERR		err = JET_errSuccess;
	INT		cpageT;
	INT		ipageT;
	FMP		*pfmp = &rgfmp[dbid];

	/*	assume that database will be read in sets of cpage
	/*	pages.  Preread next cpage pages while the current
	/*	cpage pages are being read, and copied to caller
	/*	buffer.
	/*
	/*	preread next next cpage pages.  These pages should
	/*	be read while the next cpage pages are written to
	/*	the backup datababase file.
	/**/

#ifdef OLD_BACKUP
	if ( pfmp->pgnoCopyMost + cpage < pfmp->pgnoMost )
		{
		INT		cpageReal;
		cpageT = min( cpage, (INT)(pfmp->pgnoMost - pfmp->pgnoCopyMost - cpage ) );
		BFPreread( PnOfDbidPgno( dbid, pfmp->pgnoCopyMost + 1 + cpage ), cpageT, &cpageReal );
		}
#endif

	/*	read pages, which may have been preread, up to cpage but
	/*	not beyond last page at time of initiating backup.
	/**/
	Assert( pfmp->pgnoMost >= pfmp->pgnoCopyMost );
	cpageT = min( cpage, (INT)( pfmp->pgnoMost - pfmp->pgnoCopyMost ) );
	*pcbActual = 0;
	ipageT = 0;

	if ( pfmp->pgnoCopyMost == 0 )
		{
		/* Copy header
		 */
		Assert( sizeof( PAGE ) == sizeof( DBFILEHDR ) );
		pfmp->pdbfilehdr->ulChecksum = UlUtilChecksum( (BYTE *)pfmp->pdbfilehdr, sizeof( DBFILEHDR ) );
		memcpy( (BYTE *)ppageMin, pfmp->pdbfilehdr, sizeof( DBFILEHDR ) );
		memcpy( (BYTE *)(ppageMin + 1), pfmp->pdbfilehdr, sizeof( DBFILEHDR ) );

		/*	we use first 2 pages buffer
		 */
		*pcbActual += sizeof(DBFILEHDR) * 2;
		ipageT += ( sizeof(DBFILEHDR) / cbPage ) * 2;
		Assert( ( sizeof(DBFILEHDR) / cbPage ) * 2 == cpageDBReserved );
		Assert( cpage >= ipageT );
		}


#ifdef OLD_BACKUP
	/*	copy next cpageT pages
	/**/
	{
	PGNO	pgnoCur;
	pgnoCur = pfmp->pgnoCopyMost + 1;
	for ( ; ipageT < cpageT; ipageT++, pgnoCur++ )
		{
		//	UNDONE:	differentiate page access errors for page never written
		//			from other errors.

		EnterCriticalSection( pfmp->critCheckPatch );
		pfmp->pgnoCopyMost++;
		Assert( pfmp->pgnoCopyMost <= pfmp->pgnoMost );
		LeaveCriticalSection( pfmp->critCheckPatch );

		/*	must get make sure no write access so that we will not read
		 *	a page being half written.
		 */
AccessPage:
		err = ErrBFReadAccessPage( pfucb, pgnoCur );
		if ( err < 0 )
			{
			memset( ppageMin + ipageT, 0, cbPage );
			}
		else
			{
			BOOL fCopyFromBuffer;
			PAGE *ppageT;
			BF *pbf = pfucb->ssib.pbf;

			/*	lock the buffer for read to backup. If it is being write, then
			 *	wait till write is completed and then lock it (set fBackup).
			 */
			BFEnterCriticalSection( pbf );
			if ( pbf->fSyncWrite || pbf->fAsyncWrite )
				{
				BFLeaveCriticalSection( pbf );
				BFSleep( cmsecWaitIOComplete );
				goto AccessPage;
				}

			pbf->fBackup = fTrue;

			if ( !pbf->fDirty && !FBFInUse( ppibNil, pbf ) )
				{
				pbf->fHold = fTrue;
				fCopyFromBuffer = fTrue;
				}
			else
				fCopyFromBuffer = fFalse;
					
			BFLeaveCriticalSection( pbf );

			ppageT = ppageMin + ipageT;
					
			if ( fCopyFromBuffer )
				{
				memcpy( (BYTE *)(ppageT), (BYTE *)(pbf->ppage), cbPage );

				/*	recalculate checksum since checksum may be wrong by
				 *	DeferredSetVersionBit.
				 */
				ppageT->ulChecksum = UlUtilChecksum( (BYTE*)ppageT, sizeof(PAGE) );

				BFEnterCriticalSection( pbf );
				pbf->fHold = fFalse;
				Assert( pbf->fSyncWrite == fFalse );
				Assert( pbf->fAsyncWrite == fFalse );
				pbf->fBackup = fFalse;
				BFLeaveCriticalSection( pbf );
				BFTossImmediate( pfucb->ppib, pbf );
				}
			else
				{
				INT cb;
				INT cmsec;

				/* read from disk.
				 */
				UtilLeaveCriticalSection( critJet );
						
				polp->Offset = LOffsetOfPgnoLow( pgnoCur );
				polp->OffsetHigh = LOffsetOfPgnoHigh( pgnoCur );
				SignalReset( polp->hEvent );

				cmsec = 1 << 3;
IssueReadOverlapped:
				err = ErrUtilReadBlockOverlapped(
						pfmp->hf, (BYTE *)ppageT, cbPage, &cb, polp);
				if ( err == JET_errTooManyIO )
					{
					cmsec <<= 1;
					if ( cmsec > ulMaxTimeOutPeriod )
						cmsec = ulMaxTimeOutPeriod;
					UtilSleep( cmsec - 1 );
					goto IssueReadOverlapped;
					}
				if ( err < 0 )
					{
//					BFIODiskEvent( pbf, err, "ExBackup Sync overlapped ReadBlock Fails",0,0 );
					goto EndOfDiskRead;
					}

				if ( ErrUtilGetOverlappedResult(
						pfmp->hf, polp, &cb, fTrue ) != JET_errSuccess ||
					 cb != sizeof(PAGE) )
					{
//					BFIODiskEvent( pbf, err, "Backup Sync overlapped read GetResult Fails",0,0 );
					err = ErrERRCheck( JET_errDiskIO );
					}
EndOfDiskRead:
				BFEnterCriticalSection( pbf );
				Assert( pbf->fSyncWrite == fFalse );
				Assert( pbf->fAsyncWrite == fFalse );
				pbf->fBackup = fFalse;
				BFLeaveCriticalSection( pbf );
				UtilEnterCriticalSection( critJet );
				}

			CallR( err );
			}

		err = JET_errSuccess;

#ifdef DEBUG
		if ( fDBGTraceBR > 1 && pbLGDBGPageList )
			{
			QWORDX qwxDBTime;
			qwxDBTime.qw = QwPMDBTime( (ppageMin + ipageT) );
			sprintf( pbLGDBGPageList, "(%ld, %ld) ",
					pgnoCur,
					qwxDBTime.h,
					qwxDBTime.l );
			pbLGDBGPageList += strlen( pbLGDBGPageList );
			}
#endif

		*pcbActual += sizeof(PAGE);
				
		if ( pfmp->pgnoCopyMost == pfmp->pgnoMost )
			break;
		}
	}
#else	// !OLD_BACKUP
	/*	Copy next cpageT pages, lock range lock from
	/**/
	pfmp->pgnoCopyMost += cpageT - ipageT;
	CallR( ErrBFDirectRead(
				dbid,
				pfmp->pgnoCopyMost - ( cpageT - ipageT ) + 1,
				ppageMin + ipageT,
				cpageT - ipageT
		) );
	*pcbActual += cbPage * ( cpageT - ipageT );

#ifdef DEBUG
	{
	PGNO pgnoCur = pfmp->pgnoCopyMost - ( cpageT - ipageT ) + 1;
	for ( ; ipageT < cpageT; ipageT++, pgnoCur++ )
		{
		if ( fDBGTraceBR > 1 && pbLGDBGPageList )
			{
			QWORDX qwxDBTime;
			qwxDBTime.qw = QwPMDBTime( (ppageMin + ipageT) );

			sprintf( pbLGDBGPageList, "(%ld, %ld) ",
					 pgnoCur,
					 qwxDBTime.h,
					 qwxDBTime.l );
			pbLGDBGPageList += strlen( pbLGDBGPageList );
			}
		}
	}
#endif	
#endif	// !OLD_BACKUP

	return err;
	}


/*	begin new log file and compute log backup parameters:
 *		lgenCopyMac = plgfilehdrGlobal->lGeneration;
 *		lgenCopyMic = fFullBackup ? set befor database copy : lgenDeleteMic.
 *		lgenDeleteMic = first generation in szLogFilePath
 *		lgenDeleteMac = current checkpoint, which may be several gen less than lgenCopyMac
 */
ERR ErrLGBKPrepareLogFiles(
	BOOL		fFullBackup,
	CHAR		*szLogFilePath,
	CHAR		*szPathJetChkLog,
	CHAR		*szBackupPath )
	{
	ERR			err;
	CHECKPOINT	*pcheckpointT;
	LGPOS		lgposRecT;
	
	if ( fFullBackup )
		{
		CallR( ErrLGFullBackup( "", &lgposRecT ) );
		lgposFullBackup = lgposRecT;
		LGGetDateTime( &logtimeFullBackup );
		}
	else
		{
		CallR( ErrLGIncBackup( "", &lgposRecT ) );
		lgposIncBackup = lgposRecT;
		LGGetDateTime( &logtimeIncBackup );
		}

	while ( lgposRecT.lGeneration > plgfilehdrGlobal->lGeneration )
		{
		if ( fLGNoMoreLogWrite )
			{
			return( ErrERRCheck( JET_errLogWriteFail ) );
			}
		BFSleep( cmsecWaitGeneric );
		}

	fBackupBeginNewLogFile = fTrue;

	/*	compute lgenCopyMac:
	/*	copy all log files up to but not including current log file
	/**/
	UtilLeaveCriticalSection( critJet );
	UtilEnterCriticalSection( critLGFlush );
	UtilEnterCriticalSection( critJet );
	Assert( lgenCopyMac == 0 );
	lgenCopyMac = plgfilehdrGlobal->lGeneration;
	Assert( lgenCopyMac != 0 );
	UtilLeaveCriticalSection( critLGFlush );
			
	/*	set lgenDeleteMic
	/*	to first log file generation number.
	/**/
	Assert( lgenDeleteMic == 0 );
	LGFirstGeneration( szLogFilePath, &lgenDeleteMic );
	Assert( lgenDeleteMic != 0 );

	if ( !fFullBackup && szBackupPath )
		{
		LONG lgenT;

		/*	validate incremental backup against previous
		/*	full and incremenal backup.
		/**/
		LGLastGeneration( szBackupPath, &lgenT );
		if ( lgenDeleteMic > lgenT + 1 )
			{
			Call( ErrERRCheck( JET_errInvalidLogSequence ) );
			}
		}
	
	/*	compute lgenCopyMic
	/**/
	if ( fFullBackup )
		{
		/*	lgenCopyMic set before database copy
		/**/
		Assert( lgenCopyMic != 0 );
		}
	else
		{
		/*	copy all files that are deleted for incremental backup
		/**/
		lgenCopyMic = lgenDeleteMic;
		}

	/*	set lgenDeleteMac to checkpoint log file
	/**/
	pcheckpointT = (CHECKPOINT *) PvUtilAllocAndCommit( sizeof(CHECKPOINT) );
	if ( pcheckpointT == NULL )
		CallR( ErrERRCheck( JET_errOutOfMemory ) );
	
	LGFullNameCheckpoint( szPathJetChkLog );
	Call( ErrLGIReadCheckpoint( szPathJetChkLog, pcheckpointT ) );
	Assert( lgenDeleteMac == 0 );
	lgenDeleteMac = pcheckpointT->lgposCheckpoint.lGeneration;
	Assert( lgenDeleteMic != 0 );
	Assert( lgenDeleteMac <= lgenCopyMac );

HandleError:
	UtilFree( pcheckpointT );
	return err;
	}
	

ERR ErrLGCheckIncrementalBackup( void )
	{
	DBID dbid;
	FMP	*pfmp;
	BKINFO *pbkinfo;
	
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		/*	make sure all the attached DB are qaulified for incremental backup.
		 */
		if ( FDBIDAttached( dbid ) && !FDBIDAttachNullDb( dbid ) )
			{
			pfmp = &rgfmp[dbid];
			Assert( pfmp->pdbfilehdr );
			pbkinfo = &pfmp->pdbfilehdr->bkinfoFullPrev;
			if ( pbkinfo->genLow == 0 )
				{
				char *rgszT[1];
				rgszT[0] = pfmp->szDatabaseName;
				UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
						DATABASE_MISS_FULL_BACKUP_ERROR_ID, 1, rgszT );
				return ErrERRCheck( JET_errMissingFullBackup );
				}
			}
		}
	return JET_errSuccess;
	}


/*	copies database files and logfile generations starting at checkpoint
 *  record to directory specified by the environment variable BACKUP.
 *  No flushing or switching of log generations is involved.
 *  The Backup call may be issued at any time, and does not interfere
 *  with the normal functioning of the system - nothing gets locked.
 *
 *  The database page is copied page by page in page sequence number. If
 *  a copied page is dirtied after it is copied, the page has to be
 *  recopied again. A flag is indicated if a database is being copied. If
 *  BufMan is writing a dirtied page and the page is copied, then BufMan
 *  has to copy the dirtied page to both the backup copy and the current
 *  database.
 *
 *  If the copy is later used to Restore without a subsequent log file, the
 *  restored database will be consistent and will include any transaction
 *  committed prior to backing up the very last log record; if there is a
 *  subsequent log file, that file will be used during Restore as a
 *  continuation of the backed-up log file.
 *
 *	PARAMETERS
 *
 *	RETURNS
 *		JET_errSuccess, or the following error codes:
 *			JET_errNoBackupDirectory
 *			JET_errFailCopyDatabase
 *			JET_errFailCopyLogFile
 *
 */
ERR ISAMAPI ErrIsamBackup( const CHAR *szBackup, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus )
	{
	ERR			err = JET_errSuccess;
	DBID		dbid;
	BOOL		fInCritJet = fTrue;
	PAGE		*ppageMin = pNil;
	LGFILEHDR	*plgfilehdrT = pNil;
	PIB			*ppib = ppibNil;
	DBID		dbidT = 0;
	FUCB		*pfucb = pfucbNil;
	HANDLE		hfDatabaseBackup = handleNil;
	FMP			*pfmpT = pNil;
	BOOL		fFullBackup = !( grbit & JET_bitBackupIncremental );
	BOOL		fBackupAtomic = ( grbit & JET_bitBackupAtomic );
	LONG		lT;
	/*	backup directory
	/**/
	CHAR		szBackupPath[_MAX_PATH + 1];
	/*	name of database patch file
	/**/
	CHAR		szPatch[_MAX_PATH + 1];
	/*	temporary variables
	/**/
	CHAR		szT[_MAX_PATH + 1];
	CHAR		szFrom[_MAX_PATH + 1];
	CHECKPOINT	*pcheckpointT = NULL;
	CHAR		szDriveT[_MAX_DRIVE + 1];
	CHAR		szDirT[_MAX_DIR + 1];
	CHAR		szExtT[_MAX_EXT + 1];
	CHAR		szFNameT[_MAX_FNAME + 1];
	BYTE	   	szPathJetChkLog[_MAX_PATH + 1];
	ULONG		cPagesSoFar = 0;
	ULONG		cExpectedPages = 0;
	JET_SNPROG	snprog;
	BOOL		fShowStatus = fFalse;
	BOOL		fOlpCreated = fFalse;
	OLP			olp;

	// UNDONE: cpage should be a system parameter
#define	cpageBackupBufferMost	64
	INT cpageBackupBuffer = cpageBackupBufferMost;

	if ( fBackupInProgress )
		{
		return ErrERRCheck( JET_errBackupInProgress );
		}

	if ( fLogDisabled )
		{
		return ErrERRCheck( JET_errLoggingDisabled );
		}

	if ( fLGNoMoreLogWrite )
		{
		Assert( fFalse );
		return ErrERRCheck( JET_errLogWriteFail );
		}

	if ( !fFullBackup && fLGGlobalCircularLog )
		{
		return ErrERRCheck( JET_errInvalidBackup );
		}

	pcheckpointT = (CHECKPOINT *) PvUtilAllocAndCommit( sizeof(CHECKPOINT) );
	if ( pcheckpointT == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	/*	initialize backup variables
	/**/
	SignalSend( sigBFCleanProc );
	fBackupInProgress = fTrue;
	
	if ( fFullBackup )
		{
		lgposFullBackupMark = lgposLogRec;
		LGGetDateTime( &logtimeFullBackupMark );
		}
	else
		{
		Call( ErrLGCheckIncrementalBackup() )
		}
	
	lgenCopyMic = 0;
	lgenCopyMac = 0;
	lgenDeleteMic = 0;
	lgenDeleteMac = 0;

	/*	if NULL backup directory then just delete log files
	/**/
	if ( szBackup == NULL || szBackup[0] == '\0' )
		{
		/*	set lgenDeleteMic to first log file generation number
		/**/
		LGFirstGeneration( szLogFilePath, &lgenDeleteMic );

		/*	if only log file is current log then terminate backup
		/**/
		if ( lgenDeleteMic == 0 )
			{
			Assert( err == JET_errSuccess );
			goto HandleError;
			}

		/*	get checkpoint to determine which log files can
		/*	be deleted while still providing system crash recovery.
		/*	lgenMac is the first generation file which
		/*	must be retained.
		/**/
		LGFullNameCheckpoint( szPathJetChkLog );
		Call( ErrLGIReadCheckpoint( szPathJetChkLog, pcheckpointT ) );
		lgenDeleteMac = pcheckpointT->lgposCheckpoint.lGeneration;

		UtilLeaveCriticalSection( critJet );
		fInCritJet = fFalse;
		goto DeleteLogs;
		}

	/*	backup directory
	/**/
	strcpy( szBackupPath, szBackup );
	strcat( szBackupPath, "\\" );

	/*	initialize the copy buffer
	/**/
	ppageMin = (PAGE *)PvUtilAllocAndCommit( cpageBackupBuffer * sizeof(PAGE) );
	if ( ppageMin == NULL )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}

	/*	reconsist atomic backup directory
	/*	1)	if temp directory, delete temp directory
	/**/
  	strcpy( szT, szBackupPath );
	strcat( szT, szTempDir );
	Call( ErrLGDeleteAllFiles( szT ) );
  	strcpy( szT, szBackupPath );
	strcat( szT, szTempDir );
	Call( ErrUtilRemoveDirectory( szT ) );

	if ( fBackupAtomic )
		{
		/*	2)	if old and new directories, delete old directory
		/*	3)	if new directory, move new to old
		/*
		/*	Now we should have an empty direcotry, or a directory with
		/*	an old subdirectory with a valid backup.
		/*
		/*	4) make a temporary directory for the current backup.
		/**/
		err = ErrLGCheckDir( szBackupPath, szAtomicNew );
		if ( err == JET_errBackupDirectoryNotEmpty )
			{
	  		strcpy( szT, szBackupPath );
			strcat( szT, szAtomicOld );
			strcat( szT, "\\" );
			Call( ErrLGDeleteAllFiles( szT ) );
	  		strcpy( szT, szBackupPath );
			strcat( szT, szAtomicOld );
			Call( ErrUtilRemoveDirectory( szT ) );

			strcpy( szFrom, szBackupPath );
			strcat( szFrom, szAtomicNew );
			Call( ErrUtilMove( szFrom, szT ) );
			}

		/*	if incremental, set backup directory to szAtomicOld
		/*	else create and set to szTempDir
		/**/
		if ( !fFullBackup )
			{
			/*	backup to old directory
			/**/
			strcat( szBackupPath, szAtomicOld );
			strcat( szBackupPath, "\\" );
			}
		else
			{
			strcpy( szT, szBackupPath );
			strcat( szT, szTempDir );
			err = ErrUtilCreateDirectory( szT );
			if ( err < 0 )
				{
				Call( ErrERRCheck( JET_errMakeBackupDirectoryFail ) );
				}

			/*	backup to temp directory
			/**/
			strcat( szBackupPath, szTempDir );
			}
		}
	else
		{
		if ( !fFullBackup )
			{
			/*	check for non-atomic backup directory empty
			/**/
			Call( ErrLGCheckDir( szBackupPath, szAtomicNew ) );
			Call( ErrLGCheckDir( szBackupPath, szAtomicOld ) );
			}
		else
			{
			/*	check for backup directory empty
			/**/
			Call( ErrLGCheckDir( szBackupPath, NULL ) );
			}
		}

	if ( !fFullBackup )
		{
		goto PrepareCopyLogFiles;
		}

	/*	full backup
	/**/
	Assert( fFullBackup );

	/*	set lgenCopyMic to checkpoint log file
	/**/
	LGFullNameCheckpoint( szPathJetChkLog );
	Call( ErrLGIReadCheckpoint( szPathJetChkLog, pcheckpointT ) );
	lgenCopyMic = pcheckpointT->lgposCheckpoint.lGeneration;

	/*  copy all databases opened by this user. If the database is not
	/*  being opened, then copy the database file into the backup directory,
	/*  otheriwse, the database page by page. Also copy all the logfiles
	/**/
	Call( ErrPIBBeginSession( &ppib, procidNil ) );

	memset( &lgposIncBackup, 0, sizeof(LGPOS) );
	memset( &logtimeIncBackup, 0, sizeof(LOGTIME) );

	/*	initialize status
	/**/
	if ( fShowStatus = (pfnStatus != NULL) )
		{
		snprog.cbStruct = sizeof(JET_SNPROG);
		snprog.cunitDone = 0;
		snprog.cunitTotal = 100;

		/*	status callback
		/**/
		(*pfnStatus)(0, JET_snpBackup, JET_sntBegin, &snprog);
		}

	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		ULONG	ulT;
		INT		cpageT;
		INT		cbT;
		DBFILEHDR *pdbfilehdr;
		BKINFO	*pbkinfo;

		pfmpT = &rgfmp[dbid];

		if ( !pfmpT->szDatabaseName ||
			!pfmpT->fLogOn ||
			!FDBIDAttached( dbid ) ||
			FDBIDAttachNullDb( dbid ) )
			{
			continue;
			}

		_splitpath( pfmpT->szDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
		LGMakeName( szT, szBackupPath, szFNameT, szExtT );

		/*  read database page by page till the last page is read.
		/*  and then patch the pages that are not changed during the copy.
		/**/
		CallJ( ErrDBOpenDatabase( ppib,
			pfmpT->szDatabaseName,
			&dbidT,
			JET_bitDbReadOnly ), HandleError )
		Assert( dbidT == dbid );

		/*	set backup database file size to current database file size
		/**/
		Assert( pfmpT->ulFileSizeLow != 0 || pfmpT->ulFileSizeHigh != 0 );

		EnterCriticalSection( pfmpT->critCheckPatch );
			{
			QWORDX		qwxFileSize;
			
			qwxFileSize.l = pfmpT->ulFileSizeLow;
			qwxFileSize.h = pfmpT->ulFileSizeHigh;
			pfmpT->pgnoMost = (ULONG)( qwxFileSize.qw / cbPage );
			}
		LeaveCriticalSection( pfmpT->critCheckPatch );

		if ( fShowStatus )
			{
			/*	recalculate backup size for each database in case the
			/*	database has grown during the backup process.
			/**/
			LGGetBackupSize( dbid, cPagesSoFar, &cExpectedPages );
			}

#ifdef DEBUG
		{
		DIB		dib;
		PGNO	pgnoT;

		/* get a temporary FUCB
		/**/
		Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) )

		/*	get last page number
		/**/
		DIRGotoOWNEXT( pfucb, PgnoFDPOfPfucb( pfucb ) );
		dib.fFlags = fDIRNull;
		dib.pos = posLast;
		Call( ErrDIRDown( pfucb, &dib ) )
		Assert( pfucb->keyNode.cb == sizeof(PGNO) );
		LongFromKey( &pgnoT, pfucb->keyNode.pb );

		Assert( pgnoT == pfmpT->pgnoMost );

		/*	close FUCB
		/**/
		DIRClose( pfucb );
		pfucb = pfucbNil;
		}
#endif

		CallS( ErrDBCloseDatabase( ppib, dbidT, 0 ) );
		dbidT = 0;

		/*	create a local patch file
		/**/
		pfmpT->cpage = 0;
		UtilLeaveCriticalSection( critJet );
		fInCritJet = fFalse;

		LGMakeName( szPatch, szLogFilePath, szFNameT, szPatExt );
		/*	avoid aliasing of patch file pages by deleting
		/*	preexisting patch file if present
		/**/
		err = ErrUtilDeleteFile( szPatch );
		Assert( err == JET_errFileNotFound || err == JET_errSuccess );
		//	UNDONE:	delete file error handling
		Assert( pfmpT->cPatchIO == 0 );
		Call( ErrUtilOpenFile( szPatch, &pfmpT->hfPatch, cbPage, fFalse, fTrue ) )
		pfmpT->errPatch = JET_errSuccess;
		UtilChgFilePtr( pfmpT->hfPatch, sizeof(DBFILEHDR)*2, NULL, FILE_BEGIN, &ulT );
		Assert( ( sizeof(DBFILEHDR) / cbPage ) * 2 == cpageDBReserved );

		/*	create a new copy of the database in backup directory
		/*	initialize it as a cbPage byte file.
		/**/
		Assert( hfDatabaseBackup == handleNil );
		Call( ErrUtilOpenFile( szT, &hfDatabaseBackup, cbPage, fFalse, fFalse ) );
		UtilChgFilePtr( hfDatabaseBackup, 0, NULL, FILE_BEGIN, &ulT );
		Assert( ulT == 0 );

		/*	create database backup
		/**/
		UtilEnterCriticalSection( critJet );
		fInCritJet = fTrue;

		/*	setup patch file header for copy
		/**/
		pdbfilehdr = pfmpT->pdbfilehdr;
		pbkinfo = &pdbfilehdr->bkinfoFullCur;
		pbkinfo->lgposMark = lgposFullBackupMark;
		pbkinfo->logtimeMark = logtimeFullBackupMark;
		pbkinfo->genLow = lgenCopyMic;
		pbkinfo->genHigh = lgenCopyMac - 1;

		/*  read database page by page till the last page is read.
		/*  and then patch the pages that are not changed during the copy.
		/**/
		Call( ErrDBOpenDatabase( ppib,
			pfmpT->szDatabaseName,
			&dbidT,
			JET_bitDbReadOnly ) );
		Assert( dbidT == dbid );
		/* get a temporary FUCB
		/**/
		Call( ErrDIROpen( ppib, pfcbNil, dbid, &pfucb ) )

		/*  read pages into buffers, and copy them to the backup file.
		/*  also set up pfmp->pgnoCopyMost.
		/**/
		Assert( pfmpT->pgnoCopyMost == 0 );
		Assert( pfmpT->pgnoMost > pfmpT->pgnoCopyMost );
		cpageT = min( cpageBackupBuffer, (INT)(pfmpT->pgnoMost) );
		
#ifdef OLD_BACKUP
		{
		INT		cpageReal;
		/*	preread first cpageBackupBuffer pages
		/**/
		
		BFPreread( PnOfDbidPgno( dbid, pfmpT->pgnoCopyMost + 1 ), cpageT, &cpageReal );
		}
#else
		cpageT = min( cpageBackupBuffer, (INT)(pfmpT->pgnoMost - pfmpT->pgnoCopyMost) );
#endif
		Call( ErrSignalCreate( &olp.hEvent, NULL ) );
		fOlpCreated = fTrue;

		do	{
			INT cbActual = 0;

			/*	if termination in progress, then fail sort
			/**/
			if ( fTermInProgress )
				{
				Error( ErrERRCheck( JET_errTermInProgress ), HandleError );
				}

			/*	read next cpageBackupBuffer pages
			/**/
			Call( ErrLGBKReadPages(
					pfucb,
					&olp,
					dbid,
					ppageMin,
					cpageBackupBuffer,
					&cbActual
					) );

			/*	write data that was read
			/**/
			UtilLeaveCriticalSection( critJet );
			fInCritJet = fFalse;
			Call( ErrUtilWriteBlock( hfDatabaseBackup, (BYTE *)ppageMin, cbActual, &cbT ) )
			Assert( cbT == cbActual );

			if ( fShowStatus )
				{
				/*	update status
				/**/
				cPagesSoFar += cpageT;

				/*	because of padding, we should never attain the expected pages
				/**/
				Assert( cPagesSoFar < cExpectedPages );

				if ((ULONG)(100 * cPagesSoFar / cExpectedPages) > snprog.cunitDone)
					{
					Assert( snprog.cbStruct == sizeof(snprog) &&
						snprog.cunitTotal == 100 );
					snprog.cunitDone = (ULONG)(100 * cPagesSoFar / cExpectedPages);
					(*pfnStatus)(0, JET_snpBackup, JET_sntProgress, &snprog);
					}
				}

			UtilEnterCriticalSection( critJet );
			fInCritJet = fTrue;
			}
		while ( pfmpT->pgnoCopyMost < pfmpT->pgnoMost );

		/*	close FUCB
		/**/
		DIRClose( pfucb );
		pfucb = pfucbNil;

		/*	close database
		/**/
		CallS( ErrDBCloseDatabase( ppib, dbidT, 0 ) );
		dbidT = 0;

		UtilLeaveCriticalSection( critJet );
		fInCritJet = fFalse;

		/*	no need for buffer manager to make extra copy from now on
		/**/
		LGIClosePatchFile( pfmpT );

		pfmpT = pNil;

		/*	close backup file and patch file
		/**/
		CallS( ErrUtilCloseFile( hfDatabaseBackup ) );
		hfDatabaseBackup = handleNil;

		UtilEnterCriticalSection( critJet );
		fInCritJet = fTrue;
		}

	/*	successful copy of all the databases
	/**/
	pfmpT = pNil;

	PIBEndSession( ppib );
	ppib = ppibNil;

PrepareCopyLogFiles:
	/*	begin new log file and compute log backup parameters.
	/**/
	Call( ErrLGBKPrepareLogFiles(
			fFullBackup,
			szLogFilePath,
			szPathJetChkLog,
			szBackupPath ) );

	UtilLeaveCriticalSection( critJet );
	fInCritJet = fFalse;

	if ( fShowStatus )
		{
		/*	since we do not need them anymore, overload the page count variables
		/*	to count log files copied.  Add an extra copy to compensate for
		/*	possible log deletions and cleanup.
		/**/
		cExpectedPages = cPagesSoFar + lgenCopyMac -
			lgenCopyMic + 1 + 1;
		}

	if ( !fFullBackup )
		{
		goto CopyLogFiles;
		}

	/*	write header out to all patch files and move them to backup directory
	/**/
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		DBFILEHDR	*pdbfilehdr;
		BKINFO		*pbkinfo;

		/*	if termination in progress, then fail sort
		/**/
		if ( fTermInProgress )
			{
			Error( ErrERRCheck( JET_errTermInProgress ), HandleError );
			}

		pfmpT = &rgfmp[dbid];

		if ( !pfmpT->szDatabaseName ||
			!pfmpT->fLogOn ||
			!FDBIDAttached( dbid ) ||
			FDBIDAttachNullDb( dbid ) )
			{
			continue;
			}
		_splitpath( pfmpT->szDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
		LGMakeName( szPatch, szLogFilePath, szFNameT, szPatExt );

		/*	write out patch file header
		/**/
		pdbfilehdr = pfmpT->pdbfilehdr;
		pbkinfo = &pdbfilehdr->bkinfoFullCur;
		Assert( CmpLgpos( &pbkinfo->lgposMark, &lgposFullBackupMark ) == 0 );
		Assert( memcmp( &pbkinfo->logtimeMark, &logtimeFullBackupMark, sizeof(LOGTIME) ) == 0 );
		pbkinfo->genLow = lgenCopyMic;
		pbkinfo->genHigh = lgenCopyMac - 1;
		Call( ErrUtilWriteShadowedHeader( szPatch, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) ) );
				
		/*	copy database patch file from log directory to backup directory.
		/**/
		_splitpath( pfmpT->szDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
		LGMakeName( szT, szBackupPath, szFNameT, szPatExt );
		/*	if error occurred during patch file write then return error
		/**/
		if ( pfmpT->errPatch != JET_errSuccess )
			{
			Error( pfmpT->errPatch, HandleError );
			}
		Call( ErrUtilCopy( szPatch, szT, fFalse ) );
		CallS( ErrUtilDeleteFile( szPatch ) );
		Assert( err == JET_errSuccess );
		}
	
CopyLogFiles:
	/*	copy each log file from lgenCopyMic to lgenCopyMac.
	/*	Only delete log files after backup is guaranteed to succeed.
	/**/
	for ( lT = lgenCopyMic; lT < lgenCopyMac; lT++ )
		{
		/*	if termination in progress, then fail sort
		/**/
		if ( fTermInProgress )
			{
			Error( ErrERRCheck( JET_errTermInProgress ), HandleError );
			}

		LGSzFromLogId( szFNameT, lT );
		LGMakeName( szLogName, szLogFilePath, szFNameT, (CHAR *)szLogExt );
		LGMakeName( szT, szBackupPath, szFNameT, szLogExt );
		Call( ErrUtilCopy( szLogName, szT, fFalse ) );

		if ( fShowStatus )
			{
			/*	update status
			/**/
			cPagesSoFar++;

			/*	because of padding, we should never attain the expected pages
			/**/
			Assert( cPagesSoFar < cExpectedPages );

			if ( (ULONG)(100 * cPagesSoFar / cExpectedPages) > snprog.cunitDone )
				{
				Assert(snprog.cbStruct == sizeof(snprog)  &&
					snprog.cunitTotal == 100);
				snprog.cunitDone = (ULONG)(100 * cPagesSoFar / cExpectedPages);
				(*pfnStatus)(0, JET_snpBackup, JET_sntProgress, &snprog);
				}
			}
		}

	/*	delete szJetTmpLog if any
	/**/
	(VOID)ErrUtilDeleteFile( szJetTmpLog );

	/*	for full backup, graduate temp backup to new backup
	/*	and delete old backup.
	/**/
	if ( fBackupAtomic && fFullBackup )
		{
	  	strcpy( szFrom, szBackupPath );

		/*	reset backup path
		/**/
		szBackupPath[strlen(szBackupPath) - strlen(szTempDir)] = '\0';

		strcpy( szT, szBackupPath );
		strcat( szT, szAtomicNew );
		err = ErrUtilMove( szFrom, szT );
		if ( err < 0 )
			{
			if ( err != JET_errFileNotFound )
				Error( ErrERRCheck( err ), HandleError );
			err = JET_errSuccess;
			}

		strcpy( szT, szBackupPath );
		strcat( szT, szAtomicOld );
		strcat( szT, "\\" );
		Call( ErrLGDeleteAllFiles( szT ) );
		strcpy( szT, szBackupPath );
		strcat( szT, szAtomicOld );
		Call( ErrUtilRemoveDirectory( szT ) );
		}

DeleteLogs:
	/*	if termination in progress, then fail sort
	/**/
	if ( fTermInProgress )
		{
		Error( ErrERRCheck( JET_errTermInProgress ), HandleError );
		}
	Assert( err == JET_errSuccess );
	Call( ErrIsamTruncateLog( ) );

	UtilEnterCriticalSection( critJet );
	fInCritJet = fTrue;

	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		FMP *pfmp = &rgfmp[dbid];

		if ( pfmp->szDatabaseName != NULL
			 && pfmp->fLogOn
			 && FFMPAttached( pfmp ) )
			{
			if ( fFullBackup )
				{
				/*	set up database file header accordingly.
				 */
				pfmp->pdbfilehdr->bkinfoFullPrev = pfmp->pdbfilehdr->bkinfoFullCur;
				memset(	&pfmp->pdbfilehdr->bkinfoFullCur, 0, sizeof( BKINFO ) );
				memset(	&pfmp->pdbfilehdr->bkinfoIncPrev, 0, sizeof( BKINFO ) );
				}
			else
				{
				pfmp->pdbfilehdr->bkinfoIncPrev.genLow = lgenCopyMic;
				pfmp->pdbfilehdr->bkinfoIncPrev.genHigh = lgenCopyMac - 1;
				}
			}
		}

	/*	complete status update
	/**/
	if ( fShowStatus )
		{
		Assert( snprog.cbStruct == sizeof(snprog) && snprog.cunitTotal == 100 );
		snprog.cunitDone = 100;
		(*pfnStatus)(0, JET_snpBackup, JET_sntComplete, &snprog);
		}

HandleError:
	if ( fOlpCreated )
		{
		SignalClose( olp.hEvent );
		}
	
	if ( !fInCritJet )
		{
		UtilEnterCriticalSection( critJet );
		}

	if ( pcheckpointT != NULL )
		{
		UtilFree( pcheckpointT );
		}

	if ( ppageMin != NULL )
		{
		UtilFree( ppageMin );
		}

	if ( plgfilehdrT != NULL )
		{
		UtilFree( plgfilehdrT );
		}

	if ( pfucb != pfucbNil )
		{
		DIRClose( pfucb );
		}

	if ( dbidT != 0 )
		{
		CallS( ErrDBCloseDatabase( ppib, dbidT, 0 ) );
		}

	if ( ppib != ppibNil )
		{
		PIBEndSession( ppib );
		}

	if ( pfmpT != pNil && pfmpT->hfPatch != handleNil )
		{
		/*	must be set Nil before leave crit jet so that no current
		/*	IO will think patch is needed.
		/**/
		LeaveCriticalSection( critJet );
		LGIClosePatchFile( pfmpT );
		EnterCriticalSection( critJet );
		}

	if ( hfDatabaseBackup != handleNil )
		{
		CallS( ErrUtilCloseFile( hfDatabaseBackup ) );
		hfDatabaseBackup = handleNil;
		}

	fBackupInProgress = fFalse;

	return err;
	}


/*
 *	Restores databases from database backups and log generations.  Redoes
 *	log from latest checkpoint record. After the backed-up logfile is
 *  Restored, the initialization process continues with Redo of the current
 *  logfile as long as the generation numbers are contiguous. There must be a
 *  log file szJetLog in the backup directory, else the Restore process fails.
 *
 *	GLOBAL PARAMETERS
 *		szRestorePath (IN) 	pathname of the directory with backed-up files.
 *		lgposRedoFrom(OUT)	is the position (generation, logsec, displacement)
 *							of the last saved log record; Redo of the
 *							current logfile will continue from this point.
 *
 *	RETURNS
 *		JET_errSuccess, or error code from failing routine, or one
 *				of the following "local" errors:
 *				-AfterInitialization
 *				-errFailRestoreDatabase
 *				-errNoRestoredDatabases
 *				-errMissingJetLog
 *  FAILS ON
 *		missing szJetLog or System.mdb on backup directory
 *		noncontiguous log generation
 *
 *  SIDE EFFECTS:
 *		All databases may be changed.
 *
 *  COMMENTS
 *		this call is executed during the normal first JetInit call,
 *  	if the environment variable RESTORE is set. Subsequent to
 *		the successful execution of Restore,
 *		system operation continues normally.
 */
VOID LGFreeRstmap( VOID )
	{
	RSTMAP *prstmapCur = rgrstmapGlobal;
	RSTMAP *prstmapMax = rgrstmapGlobal + irstmapGlobalMac;
		
	while ( prstmapCur < prstmapMax )
		{
		if ( prstmapCur->szDatabaseName )
			SFree( prstmapCur->szDatabaseName );
		if ( prstmapCur->szNewDatabaseName )
			SFree( prstmapCur->szNewDatabaseName );
		if ( prstmapCur->szGenericName )
			SFree( prstmapCur->szGenericName );
		if ( prstmapCur->szPatchPath )
			SFree( prstmapCur->szPatchPath );

		prstmapCur++;
		}
	SFree( rgrstmapGlobal );
	rgrstmapGlobal = NULL;
	irstmapGlobalMac = 0;
	}
	
	
/*	initialize log path, restore log path, and check its continuity
/**/
ERR ErrLGRSTInitPath( CHAR *szBackupPath, CHAR *szNewLogPath, CHAR *szRestorePath, CHAR *szLogDirPath )
	{
	if ( _fullpath( szRestorePath, szBackupPath == NULL ? "." : szBackupPath, _MAX_PATH ) == NULL )
		return ErrERRCheck( JET_errInvalidPath );
	strcat( szRestorePath, "\\" );

	szLogCurrent = szRestorePath;

	if ( _fullpath( szLogDirPath, szNewLogPath, _MAX_PATH ) == NULL )
		return ErrERRCheck( JET_errInvalidPath );
	strcat( szLogDirPath, "\\" );

	return JET_errSuccess;
	}


/*	log restore checkpoint setup
/**/
ERR ErrLGRSTSetupCheckpoint( LONG lgenLow, LONG lgenHigh, CHAR *szCurCheckpoint )
	{
	ERR			err;
	CHAR		szFNameT[_MAX_FNAME + 1];
	CHAR		szT[_MAX_PATH + 1];
	LGPOS		lgposCheckpoint;

	//	UNDONE:	optimize to start at backup checkpoint

	/*	Set up *checkpoint* and related *system parameters*.
	 *	Read checkpoint file in backup directory. If does not exist, make checkpoint
	 *	as the oldest log files. Also set dbms_paramT as the parameter for the redo
	 *	point.
	 */

	/*  redo backedup logfiles beginning with first gen log file.
	/**/
	LGSzFromLogId( szFNameT, lgenLow );
	strcpy( szT, szRestorePath );
	strcat( szT, szFNameT );
	strcat( szT, szLogExt );
	Assert( strlen( szT ) <= sizeof( szT ) - 1 );
	Call( ErrUtilOpenFile( szT, &hfLog, 0, fFalse, fFalse ) );

	/*	read log file header
	/**/
	Call( ErrLGReadFileHdr( hfLog, plgfilehdrGlobal, fCheckLogID ) );
	pcheckpointGlobal->dbms_param = plgfilehdrGlobal->dbms_param;

	lgposCheckpoint.lGeneration = lgenLow;
	lgposCheckpoint.isec = (WORD) csecHeader;
	lgposCheckpoint.ib = 0;
	pcheckpointGlobal->lgposCheckpoint = lgposCheckpoint;

	Assert( sizeof( pcheckpointGlobal->rgbAttach ) == cbAttach );
	memcpy( pcheckpointGlobal->rgbAttach, plgfilehdrGlobal->rgbAttach, cbAttach );

	/*	delete the old checkpoint file
	/**/
	if ( szCurCheckpoint )
		{
		strcpy( szT, szCurCheckpoint );
		strcat( szT, "\\" );
		strcat( szT, szJet );
		strcat( szT, szChkExt );
		(VOID) ErrUtilDeleteFile( szT );

		strcpy( szSystemPath, szCurCheckpoint );
		}
	
HandleError:
	if ( hfLog != handleNil )
		{
		CallS( ErrUtilCloseFile( hfLog ) );
		hfLog = handleNil;
		}

	return err;
	}


/*	for log restore to build restore map RSTMAP
/**/
ERR ErrLGRSTBuildRstmapForRestore( VOID )
	{
	ERR		err;
	INT		irstmap = 0;
	INT		irstmapMac = 0;
	RSTMAP	*rgrstmap = NULL;
	RSTMAP	*prstmap;

	CHAR	szSearch[_MAX_PATH + 1];
	CHAR	szFileName[_MAX_FNAME + 1];
	HANDLE	handleFind = handleNil;


	/*	build rstmap, scan all *.pat files and build RSTMAP
	 *	build generic name for search the destination. If szDest is null, then
	 *	keep szNewDatabase Null so that it can be copied backup to szOldDatabaseName.
	 */
	strcpy( szSearch, szRestorePath );
	strcat( szSearch, "*.pat" );

	err = ErrUtilFindFirstFile( szSearch, &handleFind, szFileName );
	if ( err < 0 && err != JET_errFileNotFound )
		Call( err );

	Assert( err == JET_errSuccess || err == JET_errFileNotFound );
	if ( fGlobalRepair && JET_errSuccess != err )
		{
		fGlobalSimulatedRestore = fTrue;
		goto SetReturnValue;
		}

	while ( err != JET_errFileNotFound )
		{
		/*	run out of rstmap entries, allocate more
		/**/
		if ( irstmap == irstmapMac )
			{
			prstmap = SAlloc( sizeof(RSTMAP) * ( irstmap + 4 ) );
			if ( prstmap == NULL )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			memset( prstmap + irstmap, 0, sizeof( RSTMAP ) * 4 );
			if ( rgrstmap != NULL )
				{
				memcpy( prstmap, rgrstmap, sizeof(RSTMAP) * irstmap );
				SFree( rgrstmap );
				}
			rgrstmap = prstmap;
			irstmapMac += 4;
			}

		/*	keep resource db null for non-external restore.
		 *	Store generic name ( szFileName with .pat extention.
		 */
		szFileName[ strlen( szFileName ) - 4 ] = '\0';
		prstmap = rgrstmap + irstmap;
		if ( (prstmap->szGenericName = SAlloc( strlen( szFileName ) + 1 ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szGenericName, szFileName );

		irstmap++;

		err = ErrUtilFindNextFile( handleFind, szFileName );
		if ( err < 0 )
			{
			if ( err != JET_errFileNotFound )
				Call( err );
			break;
			}
		}

	UtilFindClose( handleFind );

SetReturnValue:
	irstmapGlobalMac = irstmap;
	rgrstmapGlobal = rgrstmap;

	return JET_errSuccess;

HandleError:
	Assert( rgrstmap != NULL );
	LGFreeRstmap( );
	
	Assert( irstmapGlobalMac == 0 );
	Assert( rgrstmapGlobal == NULL );
	
	if ( handleFind != handleNil )
		UtilFindClose( handleFind );

	return err;
	}


PATCH *PpatchLGSearch( QWORD qwDBTimeRedo, PN pn )
	{
	PATCHLST	*ppatchlst = rgppatchlst[ IppatchlstHash( pn ) ];
	PATCH		*ppatch = NULL;

	while ( ppatchlst != NULL && ppatchlst->pn != pn )
		ppatchlst = ppatchlst->ppatchlst;
	
	if ( ppatchlst != NULL )
		{
		ppatch = ppatchlst->ppatch;
		while( ppatch != NULL && ppatch->qwDBTime < qwDBTimeRedo )
			ppatch = ppatch->ppatch;
		}
	return ppatch;
	}


ERR ErrLGPatchPage( PIB *ppib, PN pn, PATCH *ppatch )
	{
	BF		*pbf;
	DBID	dbid = DbidOfPn( pn );
	HANDLE	hfPatch;
	ERR		err;
	LONG	lRelT, lRelHighT;
	ULONG	ulT;
	PAGE	*ppage;
	INT		cbT;

	/*	Allocate the page buffer and patch it on the spot.
	 */
	if ( ( err = ErrBFAccessPage( ppib, &pbf, pn ) ) != JET_errSuccess )
		{
		/*	allocate a buffer for the page.
		 */
		CallR( ErrBFAllocPageBuffer( ppib, &pbf, pn, ppib->lgposStart, 0 ) );
		}
	else
		{
		CallR( ErrBFRemoveDependence( ppib, pbf, fBFWait ) );

		// Must re-access page because we may have lost critJet during RemoveDependence.
		CallR( ErrBFAccessPage( ppib, &pbf, pn ) );
		}
			
	while ( FBFWriteLatchConflict( ppib, pbf ) )
		BFSleep( cmsecWaitWriteLatch );

	/*	Open the patch file, read the page.
	 */
	CallR( ErrUtilOpenReadFile( rgfmp[dbid].szPatchPath, &hfPatch ) );

	lRelT = LOffsetOfPgnoLow( ppatch->ipage + 1 );
	lRelHighT = LOffsetOfPgnoHigh( ppatch->ipage + 1 );
	UtilChgFilePtr( hfPatch, lRelT, &lRelHighT, FILE_BEGIN, &ulT );
	Assert( ulT == ( sizeof(PAGE) * ( ppatch->ipage + cpageDBReserved ) ) );

	ppage = (PAGE *)PvUtilAllocAndCommit( sizeof(PAGE) );
	if ( ppage == NULL )
		{
        CallR ( ErrUtilCloseFile( hfPatch ) );
		return ErrERRCheck( JET_errOutOfMemory );
		}

	CallR( ErrUtilReadBlock( hfPatch, (BYTE *)ppage, sizeof(PAGE), &cbT ) );

	CallS( ErrUtilCloseFile( hfPatch ) );

#ifdef DEBUG
	{
	PGNO	pgnoThisPage;
	LFromThreeBytes( &pgnoThisPage, &ppage->pgnoThisPage );
	Assert( PgnoOfPn(pbf->pn) == pgnoThisPage );
	}
#endif

	BFSetWriteLatch( pbf, ppib );
	memcpy( pbf->ppage, ppage, sizeof( PAGE ) );
	BFSetDirtyBit( pbf );
	BFResetWriteLatch( pbf, ppib );

	Assert( ppage != NULL );
	UtilFree( ppage );

	return err;
	}


VOID PatchTerm()
	{
	INT	ippatchlst;

	if ( rgppatchlst == NULL )
		return;

	for ( ippatchlst = 0; ippatchlst < cppatchlstHash; ippatchlst++ )
		{
		PATCHLST	*ppatchlst = rgppatchlst[ippatchlst];

		while( ppatchlst != NULL )
			{
			PATCHLST	*ppatchlstNext = ppatchlst->ppatchlst;
			PATCH		*ppatch = ppatchlst->ppatch;

			while( ppatch != NULL )
				{
				PATCH *ppatchNext = ppatch->ppatch;

				SFree( ppatch );
				ppatch = ppatchNext;
				}

			SFree( ppatchlst );
			ppatchlst = ppatchlstNext;
			}
		}

	Assert( rgppatchlst != NULL );
	SFree( rgppatchlst );
	rgppatchlst = NULL;

	return;
	}

#define cRestoreStatusPadding	0.10	// Padding to add to account for DB copy.

ERR ErrLGGetDestDatabaseName(
	CHAR *szDatabaseName,
	INT *pirstmap,
	LGSTATUSINFO *plgstat )
	{
	ERR		err;
	CHAR	szDriveT[_MAX_DRIVE + 1];
	CHAR	szDirT[_MAX_DIR + 1];
	CHAR	szFNameT[_MAX_FNAME + _MAX_EXT + 1];
	CHAR	szExtT[_MAX_EXT + 1];
	CHAR	szT[_MAX_PATH + 1];
	CHAR	szRestoreT[_MAX_PATH + 3 + 1];
	CHAR	*sz;
	CHAR	*szNewDatabaseName;
	INT		irstmap;

	Assert( !fGlobalSimulatedRestore || ( !fGlobalExternalRestore && fGlobalRepair ) );

	irstmap = IrstmapLGGetRstMapEntry( szDatabaseName );
	*pirstmap = irstmap;
	
	if ( irstmap < 0 )
		{
		if ( !fGlobalSimulatedRestore )
			return( ErrERRCheck( JET_errFileNotFound ) );
		else
			{
			if ( irstmapGlobalMac == 0 )
				{
				RSTMAP *prstmap;

				prstmap = SAlloc( sizeof(RSTMAP) * dbidMax );
				if ( prstmap == NULL )
					{
					CallR( ErrERRCheck( JET_errOutOfMemory ) );
					}
				memset( prstmap, 0, sizeof( RSTMAP ) * dbidMax );
				rgrstmapGlobal = prstmap;
				}
			irstmap = irstmapGlobalMac++;

			/*	check if the file exists in backup directory.
			 */
			goto CheckRestoreDir;
			}
		}

	if ( rgrstmapGlobal[irstmap].fPatched || rgrstmapGlobal[irstmap].fDestDBReady )
		return JET_errSuccess;

CheckRestoreDir:
	/*	check if there is any database in the restore directory.
	 *	Make sure szFNameT is big enough to hold both name and extention.
	 */
	_splitpath( szDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
	strcat( szFNameT, szExtT );

	/* make sure szRestoreT has enogh trailing space for the following function to use.
	 */
	strcpy( szRestoreT, szRestorePath );
	if ( ErrLGCheckDir( szRestoreT, szFNameT ) != JET_errBackupDirectoryNotEmpty )
		return( ErrERRCheck( JET_errFileNotFound ) );

	/*	goto next block, copy it back to working directory for recovery
	 */
	if ( fGlobalExternalRestore )
		{
		Assert( _stricmp( rgrstmapGlobal[irstmap].szDatabaseName, szDatabaseName) == 0
			&& irstmap < irstmapGlobalMac );
		
		szNewDatabaseName = rgrstmapGlobal[irstmap].szNewDatabaseName;
		}
	else
		{
		CHAR		*szSrcDatabaseName;
		CHAR		szFullPathT[_MAX_PATH + 1];

		/*	store source path in rstmap
		/**/
		if ( ( szSrcDatabaseName = SAlloc( strlen( szDatabaseName ) + 1 ) ) == NULL )
			return JET_errOutOfMemory;
		strcpy( szSrcDatabaseName, szDatabaseName );
		rgrstmapGlobal[irstmap].szDatabaseName = szSrcDatabaseName;

		/*	store restore path in rstmap
		/**/
		if ( szNewDestination[0] != '\0' )
			{
			if ( ( szNewDatabaseName = SAlloc( strlen( szNewDestination ) + strlen( szFNameT ) + 1 ) ) == NULL )
				return JET_errOutOfMemory;
			strcpy( szNewDatabaseName, szNewDestination );
			strcat( szNewDatabaseName, szFNameT );
			}
		else
			{
			if ( ( szNewDatabaseName = SAlloc( strlen( szDatabaseName ) + 1 ) ) == NULL )
				return JET_errOutOfMemory;
			strcpy( szNewDatabaseName, szDatabaseName );
			}
		rgrstmapGlobal[irstmap].szNewDatabaseName = szNewDatabaseName;

		/*	copy database if not external restore.
		 *	make database names and copy the database.
		 */
		_splitpath( szDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
		strcpy( szT, szRestorePath );
		strcat( szT, szFNameT );

		if ( szExtT[0] != '\0' )
			{
			strcat( szT, szExtT );
			}
		Assert( strlen( szT ) <= sizeof( szT ) - 1 );

		Assert( FUtilFileExists( szT ) );

		if ( _fullpath( szFullPathT, szT, _MAX_PATH ) == NULL )
			{
			return ErrERRCheck( JET_errInvalidPath );
			}

		if ( _stricmp( szFullPathT, szNewDatabaseName ) != 0 )
			{
			CallR( ErrUtilCopy( szT, szNewDatabaseName, fFalse ) );
 			}

		if ( fGlobalSimulatedRestore )
			{
			RSTMAP *prstmap = &rgrstmapGlobal[irstmap];

			if ( (prstmap->szGenericName = SAlloc( strlen( szFNameT ) + 1 ) ) == NULL )
				CallR( ErrERRCheck( JET_errOutOfMemory ) );
			strcpy( prstmap->szGenericName, szFNameT );
			}
		}

	if ( !fGlobalSimulatedRestore )
		{
		/*	make patch name prepare to patch the database.
		/**/
		_splitpath( szNewDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
		LGMakeName( szT, szRestorePath, szFNameT, szPatExt );

		/*	store patch path in rstmap
		/**/
		if ( ( sz = SAlloc( strlen( szT ) + 1 ) ) == NULL )
			return JET_errOutOfMemory;
		strcpy( sz, szT );
		rgrstmapGlobal[irstmap].szPatchPath = sz;
		}

	rgrstmapGlobal[irstmap].fDestDBReady = fTrue;
	*pirstmap = irstmap;

	if ( !fGlobalSimulatedRestore &&
		 plgstat != NULL )
		{
		JET_SNPROG	*psnprog = &plgstat->snprog;
		ULONG		cPercentSoFar;
		ULONG		cDBCopyEstimate;

		cDBCopyEstimate = max((ULONG)(plgstat->cGensExpected * cRestoreStatusPadding / irstmapGlobalMac), 1);
		plgstat->cGensExpected += cDBCopyEstimate;

		cPercentSoFar = (ULONG)( ( cDBCopyEstimate * 100 ) / plgstat->cGensExpected );
		Assert( cPercentSoFar > 0  &&  cPercentSoFar < 100 );
		Assert( cPercentSoFar <= ( cDBCopyEstimate * 100) / plgstat->cGensExpected );

		if ( cPercentSoFar > psnprog->cunitDone )
			{
			Assert( psnprog->cbStruct == sizeof(JET_SNPROG)  &&
					psnprog->cunitTotal == 100 );
			psnprog->cunitDone = cPercentSoFar;
			( *( plgstat->pfnStatus ) )( 0, JET_snpRestore, JET_sntProgress, psnprog );
			}
		}

	return JET_errSuccess;
	}


/*	set new db path according to the passed rstmap
/**/
ERR ErrPatchInit( VOID )
	{
	/*	set up a patch hash table and fill it up with the patch file
	/**/
	INT cbT = sizeof( PATCHLST * ) * cppatchlstHash;

	if ( ( rgppatchlst = (PATCHLST **) SAlloc( cbT ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	memset( rgppatchlst, 0, cbT );
	return JET_errSuccess;
	}


VOID LGIRSTPrepareCallback(
	LGSTATUSINFO	*plgstat,
	LONG			lgenHigh,
	LONG			lgenLow,
	JET_PFNSTATUS	pfn
	)
	{
	/*	get last generation in log dir directory.  Compare with last generation
	/*	in restore directory.  Take the higher.
	/**/
	if ( szLogFilePath && *szLogFilePath != '\0' )
		{
		LONG	lgenHighT;
		CHAR	szFNameT[_MAX_FNAME + 1];

		/*	check if it is needed to continue the log files in current
		/*	log working directory.
		/**/
		LGLastGeneration( szLogFilePath, &lgenHighT );

		/*	check if edb.log exist, if it is, then add one more generation.
		/**/
		strcpy( szFNameT, szLogFilePath );
		strcat( szFNameT, szJetLog );
			
		if ( FUtilFileExists( szFNameT ) )
			{
			lgenHighT++;
			}

		lgenHigh = max( lgenHigh, lgenHighT );

		Assert( lgenHigh >= pcheckpointGlobal->lgposCheckpoint.lGeneration );
		}

	plgstat->cGensSoFar = 0;
	plgstat->cGensExpected = lgenHigh - lgenLow + 1;

	/*	If the number of generations is less than about 67%, then count sectors,
	/*	otherwise, just count generations.  We set the threshold at 67% because
	/*	this equates to about 1.5% per generation.  Any percentage higher than
	/*	this (meaning fewer generations) and we count sectors.  Any percentage
	/*	lower than this (meaning more generations) and we just count generations.
	/**/
	plgstat->fCountingSectors = (plgstat->cGensExpected <
			(ULONG)((100 - (cRestoreStatusPadding * 100)) * 2/3));

	/*	Granularity of status callback is 1%.
	/*	Assume we callback after every generation.  If there are 67
	/*	callbacks, this equates to 1.5% per generation.  This seems like a
	/*	good cutoff value.  So, if there are 67 callbacks or more, count
	/*	generations.  Otherwise, count bytes per generation.
	/**/
	plgstat->pfnStatus = pfn;
	plgstat->snprog.cbStruct = sizeof(JET_SNPROG);
	plgstat->snprog.cunitDone = 0;
	plgstat->snprog.cunitTotal = 100;

	(*(plgstat->pfnStatus))(0, JET_snpRestore, JET_sntBegin, &plgstat->snprog);
	}
		

CHAR	szRestorePath[_MAX_PATH + 1];
CHAR	szNewDestination[_MAX_PATH + 1];
RSTMAP	*rgrstmapGlobal;
INT		irstmapGlobalMac;


ERR ErrLGRestore( CHAR *szBackup, CHAR *szDest, JET_PFNSTATUS pfn )
	{
	ERR				err;
	CHAR			szBackupPath[_MAX_PATH + 1];
	CHAR			szLogDirPath[cbFilenameMost + 1];
	BOOL			fLogDisabledSav;
	LONG			lgenLow;
	LONG			lgenHigh;
	LGSTATUSINFO	lgstat;
	LGSTATUSINFO	*plgstat = NULL;
	char			*rgszT[1];
	INT				irstmap;
	BOOL			fNewCheckpointFile;

	Assert( fGlobalRepair == fFalse );

	if ( _stricmp( szRecovery, "repair" ) == 0 )
		{
		// If szRecovery is exactly "repair", then enable logging.  If anything
		// follows "repair", then disable logging.
		fGlobalRepair = fTrue;
		}

	strcpy( szBackupPath, szBackup );

	Assert( fSTInit == fSTInitDone || fSTInit == fSTInitNotDone );
	if ( fSTInit == fSTInitDone )
		{
		return ErrERRCheck( JET_errAfterInitialization );
		}

	if ( szDest )
		{
		if ( _fullpath( szNewDestination, szDest, _MAX_PATH ) == NULL )
			return ErrERRCheck( JET_errInvalidPath );
		strcat( szNewDestination, "\\" );
		}
	else
		szNewDestination[0] = '\0';

	fSignLogSetGlobal = fFalse;

	CallR( ErrLGRSTInitPath( szBackupPath, szLogFilePath, szRestorePath, szLogDirPath ) );
	LGFirstGeneration( szRestorePath, &lgenLow );
	LGLastGeneration( szRestorePath, &lgenHigh );
	err = ErrLGRSTCheckSignaturesLogSequence( szRestorePath, szLogDirPath, lgenLow, lgenHigh );
	
	if ( err < 0 )
		{
		/*	if szAtomicNew subdirectory found, then restore from szAtomicNew
		/*	if szAtomicOld subdirectory found, then restore from szAtomicOld
		/**/
		strcat( szBackupPath, "\\" );
		err = ErrLGCheckDir( szBackupPath, szAtomicNew );
		if ( err == JET_errBackupDirectoryNotEmpty )
			{
			strcat( szBackupPath, szAtomicNew );
			CallR( ErrLGRSTInitPath( szBackupPath, szLogFilePath, szRestorePath, szLogDirPath ) );
			LGFirstGeneration( szRestorePath, &lgenLow );
			LGLastGeneration( szRestorePath, &lgenHigh );
			CallR( ErrLGRSTCheckSignaturesLogSequence( szRestorePath, szLogDirPath, lgenLow, lgenHigh ) );
			}
		else
			{
			err = ErrLGCheckDir( szBackupPath, szAtomicOld );
	 		if ( err == JET_errBackupDirectoryNotEmpty )
				{
				strcat( szBackupPath, szAtomicOld );
				CallR( ErrLGRSTInitPath( szBackupPath, szLogFilePath, szRestorePath, szLogDirPath ) );
				LGFirstGeneration( szRestorePath, &lgenLow );
				LGLastGeneration( szRestorePath, &lgenHigh );
				CallR( ErrLGRSTCheckSignaturesLogSequence(
					szRestorePath, szLogDirPath, lgenLow, lgenHigh ) );
				}
			}
		}
//	fDoNotOverWriteLogFilePath = fTrue;
	Assert( strlen( szRestorePath ) < sizeof( szRestorePath ) - 1 );
	Assert( strlen( szLogDirPath ) < sizeof( szLogDirPath ) - 1 );
	Assert( szLogCurrent == szRestorePath );

	CallR( ErrFMPInit() );

	fLogDisabledSav = fLogDisabled;
	fHardRestore = fTrue;
	fLogDisabled = fFalse;

	/*  initialize log manager
	/**/
	CallJ( ErrLGInit( &fNewCheckpointFile ), TermFMP );

	rgszT[0] = szBackupPath;
	UtilReportEvent( EVENTLOG_INFORMATION_TYPE, LOGGING_RECOVERY_CATEGORY, START_RESTORE_ID, 1, rgszT );

	/*	all saved log generation files, database backups
	/*	must be in szRestorePath.
	/**/
	Call( ErrLGRSTSetupCheckpoint( lgenLow, lgenHigh, NULL ) );
		
	lGlobalGenLowRestore = lgenLow;
	lGlobalGenHighRestore = lgenHigh;

	/*	prepare for callbacks
	/**/
	if ( pfn != NULL )
		{
		plgstat = &lgstat;
		LGIRSTPrepareCallback( plgstat, lgenHigh, lgenLow, pfn );
		}

	/*	load the most recent rgbAttach. Load FMP for user to choose restore
	/*	restore directory.
	/**/
	AssertCriticalSection( critJet );
	Call( ErrLGLoadFMPFromAttachments( pcheckpointGlobal->rgbAttach ) );
	logtimeFullBackup = pcheckpointGlobal->logtimeFullBackup;
	lgposFullBackup = pcheckpointGlobal->lgposFullBackup;
	logtimeIncBackup = pcheckpointGlobal->logtimeIncBackup;
	lgposIncBackup = pcheckpointGlobal->lgposIncBackup;
	Assert( szLogCurrent == szRestorePath );

	Call( ErrLGRSTBuildRstmapForRestore( ) );

	/*	make sure all the patch files have enough logs to replay
	/**/
	for ( irstmap = 0; irstmap < irstmapGlobalMac; irstmap++ )
		{
		CHAR	szDriveT[_MAX_DRIVE + 1];
		CHAR	szDirT[_MAX_DIR + 1];
		CHAR	szFNameT[_MAX_FNAME + _MAX_EXT + 1];
		CHAR	szExtT[_MAX_EXT + 1];
		CHAR	szT[_MAX_PATH + 1];

		/*	Open patch file and check its minimum requirement for full backup.
		 */
		CHAR *szNewDatabaseName = rgrstmapGlobal[irstmap].szNewDatabaseName;

		if ( !szNewDatabaseName )
			continue;

		_splitpath( szNewDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
		LGMakeName( szT, szRestorePath, szFNameT, szPatExt );

		Assert( fSignLogSetGlobal );
		Call( ErrLGCheckDBFiles( szNewDatabaseName, szT, &signLogGlobal, lgenLow, lgenHigh ) )
		}

	/*	adjust fmp according to the restore map.
	/**/
	Assert( fGlobalExternalRestore == fFalse );
	Call( ErrPatchInit( ) );

	/*	do redo according to the checkpoint, dbms_params, and rgbAttach
	/*	set in checkpointGlobal.
	/**/
	Assert( szLogCurrent == szRestorePath );
	errGlobalRedoError = JET_errSuccess;
	Call( ErrLGRedo( pcheckpointGlobal, plgstat ) );

	if ( plgstat )
		{
		lgstat.snprog.cunitDone = lgstat.snprog.cunitTotal;
		(*lgstat.pfnStatus)( 0, JET_snpRestore, JET_sntComplete, &lgstat.snprog );
		}

HandleError:

		{
		DBID	dbidT;

		/*	delete .pat files
		/**/
		for ( dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
			{
			FMP *pfmpT = &rgfmp[dbidT];

			if ( pfmpT->szPatchPath )
				{
#ifdef DELETE_PATCH_FILES
				(VOID)ErrUtilDeleteFile( pfmpT->szPatchPath );
#endif
				SFree( pfmpT->szPatchPath );
				pfmpT->szPatchPath = NULL;
				}
			}
		}

	/*	delete restore map
	/**/
	(VOID)ErrUtilDeleteFile( szRestoreMap );

	/*	delete the patch hash table
	/**/
	PatchTerm();

	LGFreeRstmap( );

	if ( err < 0  &&  fSTInit != fSTInitNotDone )
		{
		Assert( fSTInit == fSTInitDone );
		CallS( ErrITTerm( fTermError ) );
		}

	CallS( ErrLGTerm( err >= JET_errSuccess ) );

TermFMP:	
	FMPTerm();

	fHardRestore = fFalse;

	/*	reset initialization state
	/**/
	fSTInit = fSTInitNotDone;

	if ( err != JET_errSuccess )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, 0, err );
		}
	else
		{
		if ( fGlobalRepair && errGlobalRedoError != JET_errSuccess )
			err = JET_errRecoveredWithErrors;
		}
	UtilReportEvent( EVENTLOG_INFORMATION_TYPE, LOGGING_RECOVERY_CATEGORY, STOP_RESTORE_ID, 0, NULL );

	fSignLogSetGlobal = fFalse;

//	fDoNotOverWriteLogFilePath = fFalse;
	fLogDisabled = fLogDisabledSav;
	return err;
	}


ERR ISAMAPI ErrIsamRestore( CHAR *szBackup, JET_PFNSTATUS pfn )
	{
	return ErrLGRestore( szBackup, NULL, pfn );
	}


ERR ISAMAPI ErrIsamRestore2( CHAR *szBackup, CHAR *szDest, JET_PFNSTATUS pfn )
	{
	return ErrLGRestore( szBackup, szDest, pfn );
	}


#ifdef DEBUG
VOID DBGBRTrace( CHAR *sz )
	{
	FPrintF2( "%s", sz );
	}
#endif


/*	applies local patchfile to local database backup.  Both patch file
/*	and backup data must already be copied from the backup directory.
/**/
ERR ErrLGPatchDatabase( DBID dbid, INT irstmap )
	{
	ERR			err = JET_errSuccess;
	HANDLE		hfDatabase = handleNil;
	HANDLE		hfPatch = handleNil;
	LONG		lRel, lRelMax;
	ULONG		cbT;
	QWORDX		qwxFileSize;
	PGNO		pgnoT;
	PAGE		*ppage = (PAGE *) NULL;
	PGNO		pgnoMost;
	INT			ipage;

	CHAR		*szDatabase = rgrstmapGlobal[irstmap].szNewDatabaseName;
	CHAR		*szPatch = rgrstmapGlobal[irstmap].szPatchPath;
	CHAR		*szT;

	/*	open patch file
	/**/
	err = ErrUtilOpenReadFile( szPatch, &hfPatch );
	if ( err == JET_errFileNotFound )
		{
		/*	not thing to patch, return.
		 */
		return JET_errSuccess;
		}
	CallR( err );

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		BYTE sz[256];

		sprintf( sz, "     Apply patch file %s\n", szPatch );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

	UtilChgFilePtr( hfPatch, 0, NULL, FILE_END, &lRelMax );
	Assert( lRelMax != 0 );
	UtilChgFilePtr( hfPatch, sizeof(DBFILEHDR) * 2, NULL, FILE_BEGIN, &lRel );
	Assert( ( sizeof(DBFILEHDR) / cbPage ) * 2 == cpageDBReserved );
	Assert( lRel == sizeof(DBFILEHDR) * 2 );

	/*	allocate page 
	/**/
	ppage = (PAGE *)PvUtilAllocAndCommit( sizeof(PAGE) );
	if ( ppage == NULL )
		{
        Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	/*	open database file
	/**/
	Call( ErrUtilOpenFile( szDatabase, &hfDatabase, 0, fFalse, fFalse ) );

	/*	find out database size.
	/**/
	qwxFileSize.qw = 0;
	UtilChgFilePtr( hfDatabase, 0, &qwxFileSize.h, FILE_END, &qwxFileSize.l );
	if ( qwxFileSize.qw == 0 || qwxFileSize.qw % cbPage != 0 )
		{
		char *rgszT[1];
		rgszT[0] = szDatabase;
		UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY,
						BAD_BACKUP_DATABASE_SIZE, 1, rgszT );
		Call( ErrERRCheck( JET_errMissingFullBackup ));
		//Call( JET_errBadBackupDatabaseSize );
		}
	pgnoMost = (ULONG)( qwxFileSize.qw / cbPage ) - cpageDBReserved;

	/*	read each patch file page and write it to
	/*	database file according to page header page number.
	/**/
	ipage = -1;
	while ( lRel < lRelMax )
		{
		PN		pn;
		PATCHLST **pppatchlst;
		PATCH	**pppatch;
		PATCH	*ppatch;

		Call( ErrUtilReadBlock(
			hfPatch,
			(BYTE *)ppage,
			sizeof(PAGE),
			&cbT ) );
		Assert( cbT == sizeof(PAGE) );
		lRel += cbT;
		ipage++;

		LFromThreeBytes( &pgnoT, &ppage->pgnoThisPage );
		if ( pgnoT == 0 )
			continue;

#ifdef  CHECKSUM
		Assert( ppage->ulChecksum == UlUtilChecksum( (BYTE*)ppage, sizeof(PAGE) ) );
#endif
		
		if ( pgnoT > pgnoMost )
			{
			/*	pgnoT + 1 to get to the end of page
			/**/
			ULONG	cb = LOffsetOfPgnoLow( pgnoT + 1 );
			ULONG	cbHigh = LOffsetOfPgnoHigh( pgnoT + 1 );
			
			/*	need to grow the database size
			/**/
			Call( ErrUtilNewSize( hfDatabase, cb, cbHigh, fFalse ) );

			/*	set new database size
			/**/
			pgnoMost = pgnoT;
			}
		
		pn = PnOfDbidPgno( dbid, pgnoT );
		pppatchlst = &rgppatchlst[ IppatchlstHash( pn ) ];

		while ( *pppatchlst != NULL && (*pppatchlst)->pn != pn )
			pppatchlst = &(*pppatchlst)->ppatchlst;

		if ( *pppatchlst == NULL )
			{
			PATCHLST *ppatchlst;
			
			if ( ( ppatchlst = SAlloc( sizeof( PATCHLST ) ) ) == NULL )
				Call( ErrERRCheck( JET_errOutOfMemory ) );
			ppatchlst->ppatch = NULL;
			ppatchlst->pn = pn;
			ppatchlst->ppatchlst = *pppatchlst;
			*pppatchlst = ppatchlst;
			}

		pppatch = &(*pppatchlst)->ppatch;
		while ( *pppatch != NULL && (*pppatch)->qwDBTime < QwPMDBTime( ppage ) )
			pppatch = &(*pppatch)->ppatch;

		if ( ( ppatch = SAlloc( sizeof( PATCH ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			
		ppatch->dbid = dbid;
		ppatch->qwDBTime = QwPMDBTime(ppage);
		ppatch->ipage = ipage;
		ppatch->ppatch = *pppatch;
		*pppatch = ppatch;
		}

	Assert( err == JET_errSuccess );
	if ( ( szT = SAlloc( strlen( szPatch ) + 1 ) ) == NULL )
		Call( ErrERRCheck( JET_errOutOfMemory ) );
	strcpy( szT, szPatch );
	if ( rgfmp[dbid].szPatchPath != NULL )
		SFree( rgfmp[dbid].szPatchPath );
	rgfmp[dbid].szPatchPath = szT;
	rgrstmapGlobal[irstmap].fPatched = fTrue;

HandleError:
	Assert( ppage != NULL );
	UtilFree( ppage );
	
	/*	close database file
	/**/
	if ( hfDatabase != handleNil )
		{
		CallS( ErrUtilCloseFile( hfDatabase ) );
		hfDatabase = handleNil;
		}

	/*	close patch file
	/**/
	if ( hfPatch != handleNil )
		{
		CallS( ErrUtilCloseFile( hfPatch ) );
		hfPatch = handleNil;
		}
	return err;
	}

	
/***********************************************************
/********************* EXTERNAL BACKUP *********************
/*****/
ERR ISAMAPI ErrIsamBeginExternalBackup( JET_GRBIT grbit )
	{
	ERR			err = JET_errSuccess;
	CHECKPOINT	*pcheckpointT = NULL;
	BYTE 	  	szPathJetChkLog[_MAX_PATH + 1];
	BOOL		fDetachAttach;

#ifdef DEBUG
	if ( fDBGTraceBR )
		DBGBRTrace("** Begin BeginExternalBackup - ");
#endif

	if ( fBackupInProgress )
		{
		return ErrERRCheck( JET_errBackupInProgress );
		}

	if ( fLogDisabled )
		{
		return ErrERRCheck( JET_errLoggingDisabled );
		}

	if ( fRecovering || fLGNoMoreLogWrite )
		{
		Assert( fFalse );
		return ErrERRCheck( JET_errLogWriteFail );
		}

	/*	grbit may be 0 or JET_bitBackupIncremental
	/**/
	if ( grbit & (~JET_bitBackupIncremental) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	Assert( ppibBackup != ppibNil );

	SignalSend( sigBFCleanProc );
	fBackupInProgress = fTrue;
	
	/*	make sure no detach/attach going. If there are, let them continue and finish.
	/**/
CheckDbs:
	SgEnterCriticalSection( critBuf );
		{
		DBID dbid;
		for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			if ( ( fDetachAttach = FDBIDWait(dbid) ) != fFalse )
				break;
		}
	SgLeaveCriticalSection( critBuf );
	if ( fDetachAttach )
		{
		BFSleep( cmsecWaitGeneric );
		goto CheckDbs;
		}

	if ( grbit & JET_bitBackupIncremental )
		{
		Call( ErrLGCheckIncrementalBackup() )
		}
	else
		{
		lgposFullBackupMark = lgposLogRec;
		LGGetDateTime( &logtimeFullBackupMark );
		}
	
	Assert( ppibBackup != ppibNil );

	/*	reset global copy/delete generation variables
	/**/
	lgenCopyMic = 0;
	lgenCopyMac = 0;
	lgenDeleteMic = 0;
	lgenDeleteMac = 0;

	fBackupBeginNewLogFile = fFalse;

	/*	if incremental backup set copy/delete mic and mac variables,
	/*	else backup is full and set copy/delete mic and delete mac.
	/*	Copy mac will be computed after database copy is complete.
	/**/
	if ( grbit & JET_bitBackupIncremental )
		{
#ifdef DEBUG
		if ( fDBGTraceBR )
			DBGBRTrace("Incremental Backup.\n");
#endif
		UtilReportEvent( EVENTLOG_INFORMATION_TYPE, LOGGING_RECOVERY_CATEGORY, START_INCREMENTAL_BACKUP_ID, 0, NULL );
		fBackupFull = fFalse;

		/*	if all database are allowed to do incremental backup? Check bkinfo prev.
		 */
		}
	else
		{
#ifdef DEBUG
		if ( fDBGTraceBR )
			DBGBRTrace("Full Backup.\n");
#endif
		UtilReportEvent( EVENTLOG_INFORMATION_TYPE, LOGGING_RECOVERY_CATEGORY, START_FULL_BACKUP_ID, 0, NULL );
		fBackupFull = fTrue;

		pcheckpointT = (CHECKPOINT *) PvUtilAllocAndCommit( sizeof(CHECKPOINT) );
		if ( pcheckpointT == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		LGFullNameCheckpoint( szPathJetChkLog );

		// This call should only return an error on hardware failure.
		err = ErrLGIReadCheckpoint( szPathJetChkLog, pcheckpointT );
		Assert( err == JET_errSuccess || err == JET_errCheckpointCorrupt );
		Call( err );

		lgenCopyMic = pcheckpointT->lgposCheckpoint.lGeneration;
		Assert( lgenCopyMic != 0 );
		}

HandleError:
	if ( pcheckpointT != NULL )
		{
		UtilFree( pcheckpointT );
		}

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		BYTE sz[256];

		sprintf( sz, "   End BeginExternalBackup (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

	if ( err < 0 )
		{
		fBackupInProgress = fFalse;
		}

	return err;
	}


ERR ISAMAPI ErrIsamGetAttachInfo( VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	ERR		err = JET_errSuccess;
	DBID	dbid;
	FMP		*pfmp;
	ULONG	cbActual;
	CHAR	*pch = NULL;
	CHAR	*pchT;

	if ( !fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	/*	should not get attach info if not performing full backup
	/**/
	if ( !fBackupFull )
		{
		return ErrERRCheck( JET_errInvalidBackupSequence );
		}

#ifdef DEBUG
	if ( fDBGTraceBR )
		DBGBRTrace( "** Begin GetAttachInfo.\n" );
#endif

	/*	compute cbActual, for each database name with NULL terminator
	/*	and with terminator of super string.
	/**/
	cbActual = 0;
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		pfmp = &rgfmp[dbid];
		if ( pfmp->szDatabaseName != NULL
			&& pfmp->fLogOn
			&& FFMPAttached( pfmp ) 
			&& !pfmp->fAttachNullDb )
			{
			cbActual += strlen( pfmp->szDatabaseName ) + 1;
			}
		}
	cbActual += 1;

	pch = SAlloc( cbActual );
	if ( pch == NULL )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}

	pchT = pch;
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		pfmp = &rgfmp[dbid];
		if ( pfmp->szDatabaseName != NULL
			&& pfmp->fLogOn
			&& FFMPAttached( pfmp )
			&& !pfmp->fAttachNullDb )
			{
			Assert( pchT + strlen( pfmp->szDatabaseName ) + 1 < pchT + cbActual );
			strcpy( pchT, pfmp->szDatabaseName );
			pchT += strlen( pfmp->szDatabaseName );
			Assert( *pchT == 0 );
			pchT++;
			}
		}
	Assert( pchT == pch + cbActual - 1 );
	*pchT = 0;

	/*	return cbActual
	/**/
	if ( pcbActual != NULL )
		{
		*pcbActual = cbActual;
		}

	/*	return data
	/**/
	if ( pv != NULL )
		memcpy( pv, pch, min( cbMax, cbActual ) );

HandleError:
	/*	free buffer
	/**/
	if ( pch != NULL )
		{
		SFree( pch );
		pch = NULL;
		}

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		BYTE sz[256];
		BYTE *pb;

		if ( err >= 0 )
			{
			sprintf( sz, "   Attach Info with cbActual = %d and cbMax = %d :\n", cbActual, cbMax );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );

			if ( pv != NULL )
				{
				pb = pv;

				do {
					if ( strlen( pb ) != 0 )
						{
						sprintf( sz, "     %s\n", pb );
						Assert( strlen( sz ) <= sizeof( sz ) - 1 );
						DBGBRTrace( sz );
						pb += strlen( pb );
						}
					pb++;
					} while ( *pb );
				}
			}

		sprintf( sz, "   End GetAttachInfo (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif
		
	if ( err < 0 )
		{
		CallS( ErrLGExternalBackupCleanUp( err ) );
		Assert( !fBackupInProgress );
		}

	return err;
	}


/*	Recovery Handle for File Structure:
/*	access to handle structure is assumed to be synchonrous and guarded by
/*	backup serialization.
/**/
typedef struct
	{
	BOOL	fInUse;
	BOOL	fDatabase;
	HANDLE	hf;
	OLP		olp;
	DBID	dbid;
	} RHF;

#define crhfMax	1
RHF rgrhf[crhfMax];
INT crhfMac = 0;

#ifdef DEBUG
LONG cbDBGCopied;
#endif

ERR ISAMAPI ErrIsamOpenFile( const CHAR *szFileName,
	JET_HANDLE		*phfFile,
	ULONG			*pulFileSizeLow,
	ULONG			*pulFileSizeHigh )
	{
	ERR		err;
	INT		irhf;
	DBID	dbidT;
	FMP		*pfmpT;
	CHAR	szDriveT[_MAX_DRIVE + 1];
	CHAR	szDirT[_MAX_DIR + 1];
	CHAR	szFNameT[_MAX_FNAME + 1];
	CHAR	szExtT[_MAX_EXT + 1];
	CHAR  	szPatch[_MAX_PATH + 1];
	ULONG	ulT;
	QWORDX	qwxFileSize;

	if ( !fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	/*	allocate rhf from rhf array.
	/**/
	if ( crhfMac < crhfMax )
		{
		irhf = crhfMac;
		crhfMac++;
		}
	else
		{
		Assert( crhfMac == crhfMax );
		for ( irhf = 0; irhf < crhfMax; irhf++ )
			{
			if ( !rgrhf[irhf].fInUse )
				{
				break;
				}
			}
		}
	if ( irhf == crhfMax )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	Assert( irhf < crhfMac );
	rgrhf[irhf].fInUse = fTrue;
	rgrhf[irhf].fDatabase = fFalse;
	rgrhf[irhf].dbid = 0;
	rgrhf[irhf].hf = handleNil;

	err = ErrDBOpenDatabase( ppibBackup, (CHAR *)szFileName, &dbidT, 0 );
	Assert( err < 0 || err == JET_errSuccess || err == JET_wrnFileOpenReadOnly );
	if ( err < 0 && err != JET_errDatabaseNotFound )
		{
		goto HandleError;
		}
	if ( err == JET_errSuccess || err == JET_wrnFileOpenReadOnly )
		{
		DBFILEHDR *pdbfilehdr;
		BKINFO *pbkinfo;

		/*	should not open databse if not performing full backup
		/**/
		if ( !fBackupFull )
			{
			Error( ErrERRCheck( JET_errInvalidBackupSequence ), HandleError );
			}

		Assert( rgrhf[irhf].hf == handleNil );
	   	rgrhf[irhf].fDatabase = fTrue;
	   	rgrhf[irhf].dbid = dbidT;

		/*	create a local patch file
		/**/
		pfmpT = &rgfmp[dbidT];
		/*	database should be loggable or would not have been
		/*	given out for backup purposes.
		/**/
		Assert( pfmpT->fLogOn );
		pfmpT->cpage = 0;

		/*	patch file should be in database directory during backup. In log directory during
		 *	restore.
		 */
		_splitpath( pfmpT->szDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
		_makepath( szPatch, szDriveT, szDirT, szFNameT, szPatExt );
//		LGMakeName( szPatch, ".\\", szFNameT, szPatExt );
//		LGMakeName( szPatch, szLogFilePath, szFNameT, szPatExt );

		/*	avoid aliasing of patch file pages by deleting
		/*	preexisting patch file if present
		/**/
		UtilLeaveCriticalSection( critJet );
		err = ErrUtilDeleteFile( szPatch );
		UtilEnterCriticalSection( critJet );

		if ( err < 0 && err != JET_errFileNotFound )
			{
			goto HandleError;
			}
		UtilLeaveCriticalSection( critJet );
		Assert( pfmpT->cPatchIO == 0 );
		err = ErrUtilOpenFile( szPatch, &pfmpT->hfPatch, cbPage, fFalse, fTrue );
		if ( err >= 0 )
			{
			UtilChgFilePtr( pfmpT->hfPatch, sizeof(DBFILEHDR)*2, NULL, FILE_BEGIN, &ulT );
			Assert( ulT == sizeof(DBFILEHDR)*2 );
			}
		UtilEnterCriticalSection( critJet );
		Call( err );

		pfmpT->errPatch = JET_errSuccess;
		Assert( pfmpT->pgnoCopyMost == 0 );

		/*	set backup database file size to current database file size
		/**/
		Assert( pfmpT->ulFileSizeLow != 0 || pfmpT->ulFileSizeHigh != 0 );
		EnterCriticalSection( pfmpT->critCheckPatch );
			{
			qwxFileSize.l = pfmpT->ulFileSizeLow;
			qwxFileSize.h = pfmpT->ulFileSizeHigh;
			pfmpT->pgnoMost = (ULONG)( qwxFileSize.qw / cbPage );
			}

		/*	set the returned file size.
		 */
		qwxFileSize.qw += cbPage * cpageDBReserved;
		LeaveCriticalSection( pfmpT->critCheckPatch );
		
		/*	must be the last Call of this code path for correct error recovery.
		 */	
		Call( ErrSignalCreate( &rgrhf[irhf].olp.hEvent, NULL ) );

		/*	setup patch file header for copy.
		 */
		pdbfilehdr = pfmpT->pdbfilehdr;
		pbkinfo = &pdbfilehdr->bkinfoFullCur;
		pbkinfo->lgposMark = lgposFullBackupMark;
		pbkinfo->logtimeMark = logtimeFullBackupMark;

#ifdef DEBUG
		if ( fDBGTraceBR )
			{
			char sz[256];
			sprintf( sz, "START COPY DB %ld", pfmpT->pgnoMost );
			CallS( ErrLGTrace( ppibNil, sz ) );

			cbDBGCopied = pfmpT->pgnoMost * cbPage;
			}
#endif
		}
	else
		{
		ULONG ulT;

		Assert( err == JET_errDatabaseNotFound );
		Assert( rgrhf[irhf].hf == handleNil );
	   	rgrhf[irhf].fDatabase = fFalse;

		/*	open log or patch file - read only, not overlapped.
		/**/
		Call( ErrUtilOpenFile( (CHAR *)szFileName, &rgrhf[irhf].hf, 0, fTrue, fFalse ) );
		Assert( rgrhf[irhf].hf != handleNil );

		/*	get file size
		/**/
		qwxFileSize.qw = 0;
		UtilChgFilePtr( rgrhf[irhf].hf, 0, &qwxFileSize.h, FILE_END, &qwxFileSize.l );
		Assert( qwxFileSize.qw > 0 );

		/*	move file cursor to begin of file
		/**/
		UtilChgFilePtr( rgrhf[irhf].hf, 0, NULL, FILE_BEGIN, &ulT );
		
#ifdef DEBUG
		if ( fDBGTraceBR )
			cbDBGCopied = qwxFileSize.l;
#endif
		}

	*phfFile = (JET_HANDLE)irhf;
	*pulFileSizeLow = qwxFileSize.l;
	*pulFileSizeHigh = qwxFileSize.h;

	err = JET_errSuccess;

HandleError:
	if ( err < 0 )
		{
		/*	release file handle resource on error
		/**/
		rgrhf[irhf].fInUse = fFalse;
		}

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		BYTE sz[256];
	
		sprintf( sz, "** OpenFile (%d) %s of size %ld.\n", err, szFileName, cbDBGCopied );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		cbDBGCopied = 0;
		}
#endif

	if ( err < 0 )
		{
		CallS( ErrLGExternalBackupCleanUp( err ) );
		Assert( !fBackupInProgress );
		}

	return err;
	}


ERR ISAMAPI ErrIsamReadFile( JET_HANDLE hfFile, VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	ERR		err = JET_errSuccess;
	INT		irhf = (INT)hfFile;
	FUCB	*pfucb = pfucbNil;
	INT		cpage;
	PAGE	*ppageMin;
	FMP		*pfmpT;
	ULONG	cbActual = 0;
#ifdef DEBUG
	BYTE	*szLGDBGPageList = "\0";
#endif

	if ( !fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	if ( !rgrhf[irhf].fDatabase )
		{
		/*	use ReadFile to read log files
		/**/
		Call( ErrUtilReadFile( rgrhf[irhf].hf, pv, cbMax, pcbActual ) );
		
#ifdef DEBUG
		if ( fDBGTraceBR )
			cbDBGCopied += min( cbMax, *pcbActual );
#endif
		}
	else
		{
		pfmpT = &rgfmp[ rgrhf[irhf].dbid ];

		//	we require at least 2 page buffers to read.

		if ( ( cbMax % cbPage ) != 0 || cbMax <= cbPage * 2 )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

		cpage = cbMax / cbPage;

#ifdef DEBUG
	if ( fDBGTraceBR > 1 )
		{
		szLGDBGPageList = SAlloc( cpage * 20 );
		pbLGDBGPageList = szLGDBGPageList;
		*pbLGDBGPageList = '\0';
		}
#endif

		if ( cpage > 0 )
			{
			ppageMin = (PAGE *)pv;

			/*	get a temporary FUCB
			/**/
			Assert( pfucb == pfucbNil );
			Call( ErrDIROpen( ppibBackup, pfcbNil, rgrhf[irhf].dbid, &pfucb ) )

			/*	read next cpageBackupBuffer pages
			/**/
			Call( ErrLGBKReadPages(
				pfucb,
				&rgrhf[irhf].olp,
				rgrhf[irhf].dbid,
				ppageMin,
				cpage,
				&cbActual ) );
#ifdef DEBUG
			if ( fDBGTraceBR )
				cbDBGCopied += cbActual;

			/*	if less then 16 M (4k * 4k),
			 *	then put an artificial wait.
			 */
			if ( pfmpT->pgnoMost <= cbPage )
				BFSleep( rand() % 1000 );
#endif
			/*	close FUCB
			/**/
			DIRClose( pfucb );
			pfucb = pfucbNil;
			}

		if ( pcbActual )
			{
			*pcbActual = cbActual;
			}
		}

HandleError:
	if ( pfucb != pfucbNil )
		{
		DIRClose( pfucb );
		pfucb = NULL;
		}

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		BYTE sz[256];
	
		sprintf( sz, "** ReadFile (%d) ", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		if ( fDBGTraceBR > 1 )
			DBGBRTrace( szLGDBGPageList );
		pbLGDBGPageList = NULL;
		DBGBRTrace( "\n" );
		}
#endif

	if ( rgrhf[irhf].fDatabase )
		if ( pfmpT->errPatch != JET_errSuccess )
			{
			err = pfmpT->errPatch;
			}

	if ( err < 0 )
		{
		CallS( ErrLGExternalBackupCleanUp( err ) );
		Assert( !fBackupInProgress );
		}

	return err;
	}


VOID LGIClosePatchFile( FMP *pfmp )
	{
	HANDLE hfT = pfmp->hfPatch;
	
	for (;;)
		{
		EnterCriticalSection( pfmp->critCheckPatch );
		
		if ( pfmp->cPatchIO )
			{
			LeaveCriticalSection( pfmp->critCheckPatch );
			UtilSleep( 1 );
			continue;
			}
		else
			{
			/*	no need for buffer manager to make extra copy from now on
			/**/
			pfmp->pgnoCopyMost = 0;
			pfmp->hfPatch = handleNil;
			LeaveCriticalSection( pfmp->critCheckPatch );
			break;
			}
		}

	CallS( ErrUtilCloseFile( hfT ) );
	}


ERR ISAMAPI ErrIsamCloseFile( JET_HANDLE hfFile )
	{
	INT		irhf = (INT)hfFile;
	DBID	dbidT;

	if ( !fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	if ( irhf < 0 ||
		irhf >= crhfMac ||
		!rgrhf[irhf].fInUse )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	/*	check if handle if for database file or non-database file.
	/*	if handle is for database file, then terminate patch file
	/*	support and release recovery handle for file.
	/*
	/*	if handle is for non-database file, then close file handle
	/*	and release recovery handle for file.
	/**/
	if ( rgrhf[irhf].fDatabase )
		{
		Assert( rgrhf[irhf].hf == handleNil );
		dbidT = rgrhf[irhf].dbid;

		UtilLeaveCriticalSection( critJet );
		LGIClosePatchFile( &rgfmp[dbidT] );
		UtilEnterCriticalSection( critJet );

#ifdef DEBUG
		if ( fDBGTraceBR )
			{
			char sz[256];
			sprintf( sz, "STOP COPY DB" );
			CallS( ErrLGTrace( ppibNil, sz ) );
			}
#endif

		CallS( ErrDBCloseDatabase( ppibBackup, dbidT, 0 ) );
		SignalClose( rgrhf[irhf].olp.hEvent );
		}
	else
		{
		Assert( rgrhf[irhf].hf != handleNil );
		CallS( ErrUtilCloseFile( rgrhf[irhf].hf ) );
		rgrhf[irhf].hf = handleNil;
		}

	/*	reset backup file handle and free
	/**/
	Assert( rgrhf[irhf].fInUse == fTrue );
	rgrhf[irhf].fDatabase = fFalse;
	rgrhf[irhf].dbid = 0;
	rgrhf[irhf].hf = handleNil;
	rgrhf[irhf].fInUse = fFalse;

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		BYTE sz[256];
		
		sprintf( sz, "** CloseFile (%d) - %ld Bytes.\n", 0, cbDBGCopied );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif
	
	return JET_errSuccess;
	}


ERR ISAMAPI ErrIsamGetLogInfo( VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	ERR			err = JET_errSuccess;
	INT			irhf;
	LONG		lT;
	CHAR		*pch = NULL;
	CHAR		*pchT;
	ULONG		cbActual;
	CHAR		szDriveT[_MAX_DRIVE + 1];
	CHAR		szDirT[_MAX_DIR + 1];
	CHAR		szFNameT[_MAX_FNAME + 1];
	CHAR		szExtT[_MAX_EXT + 1];
	CHAR  		szT[_MAX_PATH + 1];
	CHAR  		szDriveDirT[_MAX_PATH + 1];
	CHAR  		szFullLogFilePath[_MAX_PATH + 1];
	INT			ibT;
	FMP			*pfmp;
	CHECKPOINT	*pcheckpointT;
	BYTE	   	szPathJetChkLog[_MAX_PATH + 1];

	/*	make full path from log file path, including trailing back slash
	/**/
	if ( _fullpath( szFullLogFilePath, szLogFilePath, _MAX_PATH ) == NULL )
		{
		return ErrERRCheck( JET_errInvalidPath );
		}
	
#ifdef DEBUG
	if ( fDBGTraceBR )
		DBGBRTrace("** Begin GetLogInfo.\n" );
#endif
	
	ibT = strlen( szFullLogFilePath );
	if ( szFullLogFilePath[ibT] != '\\' )
		{
		szFullLogFilePath[ibT] = '\\';
		Assert( ibT < _MAX_PATH );
		szFullLogFilePath[ibT + 1] = '\0';
		}

	if ( !fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	/*	all backup files must be closed
	/**/
	for ( irhf = 0; irhf < crhfMax; irhf++ )
		{
		if ( rgrhf[irhf].fInUse )
			{
			return ErrERRCheck( JET_errInvalidBackupSequence );
			}
		}

	pcheckpointT = NULL;

	/*	begin new log file and compute log backup parameters
	/**/
	if ( !fBackupBeginNewLogFile )
		{
		Call( ErrLGBKPrepareLogFiles(
			fBackupFull,
			szLogFilePath,
			szPathJetChkLog,
			NULL ) );
		}

	/*	get cbActual for log file and patch files.
	/**/
	cbActual = 0;

	_splitpath( szFullLogFilePath, szDriveT, szDirT, szFNameT, szExtT );
	for ( lT = lgenCopyMic; lT < lgenCopyMac; lT++ )
		{
		LGSzFromLogId( szFNameT, lT );
		strcpy( szDriveDirT, szDriveT );
		strcat( szDriveDirT, szDirT );
		LGMakeName( szT, szDriveDirT, szFNameT, szLogExt );
		cbActual += strlen( szT ) + 1;
		}

	if ( fBackupFull )
		{
		DBID dbid;

		/*	put all the patch file info
		/**/
		for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			pfmp = &rgfmp[dbid];

			if ( pfmp->szDatabaseName != NULL
//				&& pfmp->cpage > 0
				&& FFMPAttached( pfmp )
				&& !FDBIDAttachNullDb( dbid ) )
				{
				pfmp = &rgfmp[dbid];

				/*	database with patch file must be loggable
				/**/
				Assert( pfmp->fLogOn );
				_splitpath( pfmp->szDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
				_makepath( szT, szDriveT, szDirT, szFNameT, szPatExt );
				cbActual += strlen( szT ) + 1;
				}
			}
		}
	cbActual++;

	pch = SAlloc( cbActual );
	if ( pch == NULL )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}

	/*	return list of log files and patch files
	/**/
	pchT = pch;

	_splitpath( szFullLogFilePath, szDriveT, szDirT, szFNameT, szExtT );
	for ( lT = lgenCopyMic; lT < lgenCopyMac; lT++ )
		{
		LGSzFromLogId( szFNameT, lT );
		strcpy( szDriveDirT, szDriveT );
		strcat( szDriveDirT, szDirT );
		LGMakeName( szT, szDriveDirT, szFNameT, szLogExt );
		Assert( pchT + strlen( szT ) + 1 < pchT + cbActual );
		strcpy( pchT, szT );
		pchT += strlen( szT );
		Assert( *pchT == 0 );
		pchT++;
		}

	if ( fBackupFull )
		{
		DBID dbid;

		/*	copy all the patch file info
		/**/
		for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			pfmp = &rgfmp[dbid];
			if ( pfmp->szDatabaseName != NULL
				&& FFMPAttached( pfmp )
				&& !FDBIDAttachNullDb( dbid ) )
				{
				DBFILEHDR *pdbfilehdr;
				BKINFO *pbkinfo;
				
				_splitpath( pfmp->szDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
				_makepath( szT, szDriveT, szDirT, szFNameT, szPatExt );
				Assert( pchT + strlen( szT ) + 1 < pchT + cbActual );
				strcpy( pchT, szT );
				pchT += strlen( szT );
				Assert( *pchT == 0 );
				pchT++;

				/*	Write out patch file header.
				 */
				pdbfilehdr = pfmp->pdbfilehdr;
				pbkinfo = &pdbfilehdr->bkinfoFullCur;
				Assert( CmpLgpos( &pbkinfo->lgposMark, &lgposFullBackupMark ) == 0 );
				Assert( memcmp( &pbkinfo->logtimeMark, &logtimeFullBackupMark, sizeof(LOGTIME) ) == 0 );
				pbkinfo->genLow = lgenCopyMic;
				pbkinfo->genHigh = lgenCopyMac - 1;
				Call( ErrUtilWriteShadowedHeader( szT, (BYTE *)pdbfilehdr, sizeof( DBFILEHDR ) ) );
				}
			}
		}
	Assert( pchT == pch + cbActual - 1 );
	*pchT = 0;

	/*	return cbActual
	/**/
	if ( pcbActual != NULL )
		{
		*pcbActual = cbActual;
		}

	/*	return data
	/**/
	if ( pv != NULL )
		memcpy( pv, pch, min( cbMax, cbActual ) );

HandleError:
	if ( pcheckpointT != NULL )
		UtilFree( pcheckpointT );

	if ( pch != NULL )
		{
		SFree( pch );
		pch = NULL;
		}
	
#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		BYTE sz[256];
		BYTE *pb;

		if ( err >= 0 )
			{
			sprintf( sz, "   Log Info with cbActual = %d and cbMax = %d :\n", cbActual, cbMax );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );

			if ( pv != NULL )
				{
				pb = pv;

				do {
					if ( strlen( pb ) != 0 )
						{
						sprintf( sz, "     %s\n", pb );
						Assert( strlen( sz ) <= sizeof( sz ) - 1 );
						DBGBRTrace( sz );
						pb += strlen( pb );
						}
					pb++;
					} while ( *pb );
				}
			}

		sprintf( sz, "   End GetLogInfo (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

	if ( err < 0 )
		{
		CallS( ErrLGExternalBackupCleanUp( err ) );
		Assert( !fBackupInProgress );
		}

	return err;
	}


ERR ISAMAPI ErrIsamTruncateLog( VOID )
	{
	ERR		err = JET_errSuccess;
	LONG	lT;
	CHAR	szFNameT[_MAX_FNAME + 1];

	if ( !fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

//return JET_errSuccess;

	/*	delete logs.  Note that log files must be deleted in
	/*	increasing number order.
	/**/
	for ( lT = lgenDeleteMic; lT < lgenDeleteMac; lT++ )
		{
		LGSzFromLogId( szFNameT, lT );
		LGMakeName( szLogName, szLogFilePath, szFNameT, szLogExt );
		err = ErrUtilDeleteFile( szLogName );
		if ( err != JET_errSuccess )
			{
			/*	must maintain a continuous log file sequence,
			/*	No need to clean up (reset fBackupInProgress etc) if fails.
			/**/
			break;
			}
		}

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		BYTE sz[256];
	
		sprintf( sz, "** TruncateLog (%d) %d - %d.\n", err, lgenDeleteMic, lgenDeleteMac );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif
	
	return err;
	}


ERR ISAMAPI ErrIsamEndExternalBackup( VOID )
	{
	return ErrLGExternalBackupCleanUp( JET_errSuccess );
	}


ERR ErrLGExternalBackupCleanUp( ERR errBackup )
	{
	BOOL	fNormal = ( errBackup == JET_errSuccess );
	ERR		err = JET_errSuccess;
	CHAR  	szT[_MAX_PATH + 1];
	CHAR	szDriveT[_MAX_DRIVE + 1];
	CHAR	szDirT[_MAX_DIR + 1];
	CHAR	szFNameT[_MAX_FNAME + 1];
	CHAR	szExtT[_MAX_EXT + 1];
	CHAR	szDriveDirT[_MAX_FNAME + 1];
	DBID	dbid;

	if ( !fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	/*	delete patch files, if present, for all databases
	/**/
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		FMP *pfmp = &rgfmp[dbid];

		if ( pfmp->szDatabaseName != NULL
			&& pfmp->fLogOn
			&& FFMPAttached( pfmp ) 
			&& !pfmp->fAttachNullDb )
			{
			_splitpath( pfmp->szDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
			strcpy( szDriveDirT, szDriveT );
			strcat( szDriveDirT, szDirT );
			LGMakeName( szT, szDriveDirT, szFNameT, szPatExt );
			(VOID)ErrUtilDeleteFile( szT );

			if ( fNormal )
				{
				if ( fBackupFull )
					{
					/*	set up database file header accordingly
					/**/
					pfmp->pdbfilehdr->bkinfoFullPrev = pfmp->pdbfilehdr->bkinfoFullCur;
					memset(	&pfmp->pdbfilehdr->bkinfoFullCur, 0, sizeof( BKINFO ) );
					memset(	&pfmp->pdbfilehdr->bkinfoIncPrev, 0, sizeof( BKINFO ) );
					}
				else
					{
					pfmp->pdbfilehdr->bkinfoIncPrev.genLow = lgenCopyMic;
					pfmp->pdbfilehdr->bkinfoIncPrev.genHigh = lgenCopyMac - 1;
					}
				}
			}
		}

	/*	clean up rhf entries
	/**/
		{
		INT	irhf;

		for ( irhf = 0; irhf < crhfMax; irhf++ )
			{
			rgrhf[irhf].fInUse = fFalse;
			}
		}
	
	/*	log error event
	/**/
	if ( errBackup < 0 )
		{
		BYTE	sz1T[32];
		CHAR	*rgszT[1];
		
		sprintf( sz1T, "%d", errBackup );
		rgszT[0] = sz1T;
		UtilReportEvent( EVENTLOG_ERROR_TYPE, LOGGING_RECOVERY_CATEGORY, STOP_BACKUP_ERROR_ID, 1, rgszT );
		}
	else
		{	
		UtilReportEvent( EVENTLOG_INFORMATION_TYPE, LOGGING_RECOVERY_CATEGORY, STOP_BACKUP_ID, 0, NULL );
		}

	fBackupInProgress = fFalse;

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		BYTE sz[256];
	
		sprintf( sz, "** EndExternalBackup (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif
	
	Assert( err == JET_errSuccess );
	return err;
	}


ERR ErrLGRSTBuildRstmapForExternalRestore( JET_RSTMAP *rgjrstmap, int cjrstmap )
	{
	ERR			err;
	INT			irstmapMac = 0;
	INT			irstmap = 0;
	RSTMAP		*rgrstmap;
	RSTMAP		*prstmap;
	JET_RSTMAP	*pjrstmap;

	if ( ( rgrstmap = SAlloc( sizeof(RSTMAP) * cjrstmap ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	memset( rgrstmap, 0, sizeof( RSTMAP ) * cjrstmap );

	for ( irstmap = 0; irstmap < cjrstmap; irstmap++ )
		{
		CHAR		szDriveT[_MAX_DRIVE + 1];
		CHAR		szDirT[_MAX_DIR + 1];
		CHAR		szFNameT[_MAX_FNAME + 1];
		CHAR		szExtT[_MAX_EXT + 1];
		CHAR  		szT[_MAX_PATH + 1];

		pjrstmap = rgjrstmap + irstmap;
		prstmap = rgrstmap + irstmap;
		if ( (prstmap->szDatabaseName = SAlloc( strlen( pjrstmap->szDatabaseName ) + 1 ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szDatabaseName, pjrstmap->szDatabaseName );

		if ( (prstmap->szNewDatabaseName = SAlloc( strlen( pjrstmap->szNewDatabaseName ) + 1 ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szNewDatabaseName, pjrstmap->szNewDatabaseName );

		/*	make patch name prepare to patch the database.
		/**/
		_splitpath( pjrstmap->szNewDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
		LGMakeName( szT, szRestorePath, szFNameT, szPatExt );

		if ( ( prstmap->szPatchPath = SAlloc( strlen( szT ) + 1 ) ) == NULL )
			return JET_errOutOfMemory;
		strcpy( prstmap->szPatchPath, szT );

		prstmap->fDestDBReady = fTrue;
		}

	irstmapGlobalMac = irstmap;
	rgrstmapGlobal = rgrstmap;

	return JET_errSuccess;

HandleError:
	Assert( rgrstmap != NULL );
	LGFreeRstmap();
	
	Assert( irstmapGlobalMac == 0 );
	Assert( rgrstmapGlobal == NULL );
	
	return err;
	}


ERR ISAMAPI ErrIsamExternalRestore( CHAR *szCheckpointFilePath, CHAR *szNewLogPath, JET_RSTMAP *rgjrstmap, int cjrstmap, CHAR *szBackupLogPath, LONG lgenLow, LONG lgenHigh, JET_PFNSTATUS pfn )
	{
	ERR				err;
	BOOL			fLogDisabledSav;
	LGSTATUSINFO	lgstat;
	LGSTATUSINFO	*plgstat = NULL;
	char			*rgszT[1];
	INT				irstmap;
	BOOL			fNewCheckpointFile;

	Assert( szNewLogPath );
	Assert( rgjrstmap );
	Assert( szBackupLogPath );
//	Assert( lgenLow );
//	Assert( lgenHigh );

#ifdef DEBUG
	ITDBGSetConstants();
#endif

	Assert( fSTInit == fSTInitDone || fSTInit == fSTInitNotDone );
	if ( fSTInit == fSTInitDone )
		{
		return ErrERRCheck( JET_errAfterInitialization );
		}

	fSignLogSetGlobal = fFalse;

	/*	set restore path
	/**/			
	CallR( ErrLGRSTInitPath( szBackupLogPath, szNewLogPath, szRestorePath, szLogFilePath ) );
	Assert( strlen( szRestorePath ) < sizeof( szRestorePath ) - 1 );
	Assert( strlen( szLogFilePath ) < _MAX_PATH + 1 );
	Assert( szLogCurrent == szRestorePath );
	
	/*	check log signature and database signatures
	/**/
	CallR( ErrLGRSTCheckSignaturesLogSequence(
		szRestorePath, szLogFilePath, lgenLow, lgenHigh ) );

//	fDoNotOverWriteLogFilePath = fTrue;
	fLogDisabledSav = fLogDisabled;
	fHardRestore = fTrue;
	fLogDisabled = fFalse;

	/*  set system path and checkpoint file
	 */
	CallJ( ErrLGRSTBuildRstmapForExternalRestore( rgjrstmap, cjrstmap ), TermResetGlobals );

	/*	make sure all the patch files have enough logs to replay
	/**/
	for ( irstmap = 0; irstmap < irstmapGlobalMac; irstmap++ )
		{
		CHAR	szDriveT[_MAX_DRIVE + 1];
		CHAR	szDirT[_MAX_DIR + 1];
		CHAR	szFNameT[_MAX_FNAME + _MAX_EXT + 1];
		CHAR	szExtT[_MAX_EXT + 1];
		CHAR	szT[_MAX_PATH + 1];

		/*	open patch file and check its minimum requirement for full backup
		/**/
		CHAR *szNewDatabaseName = rgrstmapGlobal[irstmap].szNewDatabaseName;

		_splitpath( szNewDatabaseName, szDriveT, szDirT, szFNameT, szExtT );
		LGMakeName( szT, szRestorePath, szFNameT, szPatExt );
		
		Assert( fSignLogSetGlobal );
		CallJ( ErrLGCheckDBFiles( szNewDatabaseName, szT, &signLogGlobal, lgenLow, lgenHigh ), TermFreeRstmap )
		}

	CallJ( ErrFMPInit(), TermFreeRstmap );

	/*  initialize log manager
	/**/
	CallJ( ErrLGInit( &fNewCheckpointFile ), TermFMP );

	rgszT[0] = szBackupLogPath;
	UtilReportEvent( EVENTLOG_INFORMATION_TYPE, LOGGING_RECOVERY_CATEGORY, START_RESTORE_ID, 1, rgszT );

#ifdef DEBUG
	if ( fDBGTraceBR )
		{
		BYTE sz[256];
	
		sprintf( sz, "** Begin ExternalRestore:\n" );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );

		if ( szCheckpointFilePath )
			{
			sprintf( sz, "     CheckpointFilePath: %s\n", szCheckpointFilePath );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );
			}
		if ( szNewLogPath )
			{
			sprintf( sz, "     LogPath: %s\n", szNewLogPath );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );
			}
		if ( szBackupLogPath )
			{
			sprintf( sz, "     BackupLogPath: %s\n", szBackupLogPath );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );
			}
		sprintf( sz, "     Generation number: %d - %d\n", lgenLow, lgenHigh );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );

		if ( irstmapGlobalMac )
			{
			INT irstmap;

			for ( irstmap = 0; irstmap < irstmapGlobalMac; irstmap++ )
				{
				RSTMAP *prstmap = rgrstmapGlobal + irstmap;
			
				sprintf( sz, "     %s --> %s\n", prstmap->szDatabaseName, prstmap->szNewDatabaseName );
				Assert( strlen( sz ) <= sizeof( sz ) - 1 );
				DBGBRTrace( sz );
				}
			}	
		}
#endif

	/*	set up checkpoint file for restore
	/**/
	if ( lgenLow == 0 )
		LGFirstGeneration( szRestorePath, &lgenLow );
	if ( lgenHigh == 0 )
		LGLastGeneration( szRestorePath, &lgenHigh );
	
	/*  set system path and checkpoint file
	 */
	Call( ErrLGRSTSetupCheckpoint( lgenLow, lgenHigh, szCheckpointFilePath ) );

	lGlobalGenLowRestore = lgenLow;
	lGlobalGenHighRestore = lgenHigh;

	/*	prepare for callbacks
	/**/
	if ( pfn != NULL )
		{
		plgstat = &lgstat;
		LGIRSTPrepareCallback( plgstat, lgenHigh, lgenLow, pfn );
		}

	/*	load the most recent rgbAttach. Load FMP for user to choose restore
	/*	restore directory.
	/**/
	AssertCriticalSection( critJet );
	Call( ErrLGLoadFMPFromAttachments( pcheckpointGlobal->rgbAttach ) );
	logtimeFullBackup = pcheckpointGlobal->logtimeFullBackup;
	lgposFullBackup = pcheckpointGlobal->lgposFullBackup;
	logtimeIncBackup = pcheckpointGlobal->logtimeIncBackup;
	lgposIncBackup = pcheckpointGlobal->lgposIncBackup;

	/*	adjust fmp according to the restore map
	/**/
	fGlobalExternalRestore = fTrue;
	Call( ErrPatchInit( ) );
			
	/*	do redo according to the checkpoint, dbms_params, and rgbAttach
	/*	set in checkpointGlobal.
	/**/
	Assert( szLogCurrent == szRestorePath );
	errGlobalRedoError = JET_errSuccess;
	Call( ErrLGRedo( pcheckpointGlobal, plgstat ) );

	/*	same as going to shut down, Make all attached databases consistent
	/**/
	if ( plgstat )
		{
		/*	top off the progress metre and wrap it up
		/**/
		lgstat.snprog.cunitDone = lgstat.snprog.cunitTotal;
		(*lgstat.pfnStatus)(0, JET_snpRestore, JET_sntComplete, &lgstat.snprog);
		}
	
HandleError:

		{
		DBID	dbidT;

		/*	delete .pat files
		/**/
		for ( dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
			{
			FMP *pfmpT = &rgfmp[dbidT];

			if ( pfmpT->szPatchPath )
				{
#ifdef DELETE_PATCH_FILES
				(VOID)ErrUtilDeleteFile( pfmpT->szPatchPath );
#endif
				SFree( pfmpT->szPatchPath );
				pfmpT->szPatchPath = NULL;
				}
			}
		}

	/*	delete the patch hash table
	/**/
	PatchTerm();

	/*	either error or terminated
	/**/
	Assert( err < 0 || fSTInit == fSTInitNotDone );
	if ( err < 0  &&  fSTInit != fSTInitNotDone )
		{
		Assert( fSTInit == fSTInitDone );
		CallS( ErrITTerm( fTermError ) );
		}

	CallS( ErrLGTerm( err >= JET_errSuccess ) );

TermFMP:	
	FMPTerm();
	
TermFreeRstmap:
	LGFreeRstmap( );

TermResetGlobals:
	fHardRestore = fFalse;

	/*	reset initialization state
	/**/
	fSTInit = fSTInitNotDone;

	if ( err != JET_errSuccess )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, 0, err );
		}
	else
		{
		if ( fGlobalRepair && errGlobalRedoError != JET_errSuccess )
			err = JET_errRecoveredWithErrors;
		}
	UtilReportEvent( EVENTLOG_INFORMATION_TYPE, LOGGING_RECOVERY_CATEGORY, STOP_RESTORE_ID, 0, NULL );

	fSignLogSetGlobal = fFalse;

//	fDoNotOverWriteLogFilePath = fFalse;
	fLogDisabled = fLogDisabledSav;
	fGlobalExternalRestore = fFalse;

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\mem.c ===
#include "daestd.h"

DeclAssertFile; 						// Declare file name for assert macros


#define cbMemBufChunkSize		256		// If out of buffer space, increase by this many bytes.
#define cTagChunkSize			4		// If out of tag space, increase by this many tags.

#define itagMemBufTagArray		0		// itag 0 is reserved for the itag array itself
#define itagMemBufFirstUsable	1		// First itag available for users


#ifdef DEBUG
VOID MEMAssertMemBuf( MEMBUF *pmembuf )
	{
	MEMBUFHDR	*pbufhdr;
	MEMBUFTAG	*rgbTags;
		
	Assert( pmembuf );
	Assert( pmembuf->pbuf );

	pbufhdr = &pmembuf->bufhdr;
	rgbTags = (MEMBUFTAG *)pmembuf->pbuf;

	Assert( rgbTags[itagMemBufTagArray].ib == 0 );
	Assert( rgbTags[itagMemBufTagArray].cb == pbufhdr->cTotalTags * sizeof(MEMBUFTAG) );

	Assert( pbufhdr->cbBufSize >= rgbTags[itagMemBufTagArray].cb );
	Assert( pbufhdr->ibBufFree >= rgbTags[itagMemBufTagArray].ib + rgbTags[itagMemBufTagArray].cb );
	Assert( pbufhdr->ibBufFree <= pbufhdr->cbBufSize );
	Assert( pbufhdr->cTotalTags >= 1 );
	Assert( pbufhdr->iTagUnused >= itagMemBufFirstUsable );
	Assert( pbufhdr->iTagUnused <= pbufhdr->cTotalTags );
	Assert( pbufhdr->iTagFreed >= itagMemBufFirstUsable );
	Assert( pbufhdr->iTagFreed <= pbufhdr->iTagUnused );
	}

VOID MEMAssertMemBufTag( MEMBUF *pmembuf, ULONG iTagEntry )
	{
	MEMBUFTAG	*rgbTags = (MEMBUFTAG *)pmembuf->pbuf;

	Assert( iTagEntry >= itagMemBufFirstUsable  &&  iTagEntry < pmembuf->bufhdr.iTagUnused );

	Assert( rgbTags[iTagEntry].cb > 0 );
	Assert( rgbTags[iTagEntry].ib >= rgbTags[itagMemBufTagArray].ib + rgbTags[itagMemBufTagArray].cb );
	Assert( rgbTags[iTagEntry].ib + rgbTags[iTagEntry].cb
		<= pmembuf->bufhdr.ibBufFree );
	}
#endif

// Create a buffer local to the caller.  Eventually, I envision a single global
// buffer visible only to this module.  But for now, anyone can create their own.
ERR ErrMEMCreateMemBuf( BYTE **prgbBuffer, ULONG cbInitialSize, ULONG cInitialEntries )
	{
	MEMBUF  	*pmembuf;
	MEMBUFTAG	*rgbTags;
	BYTE		*pbuf;

	// Make sure no buffer currently exists.
	Assert( *prgbBuffer == NULL );

	cInitialEntries++;			// Add one for the tag array itself
	Assert( cInitialEntries >= 1 );

	cbInitialSize += cInitialEntries * sizeof(MEMBUFTAG);
	Assert( cbInitialSize >= sizeof(MEMBUFTAG) );		// At least one tag.

	pmembuf = (MEMBUF *)SAlloc( sizeof(MEMBUF) );
	if ( pmembuf == NULL )
		return ErrERRCheck( JET_errOutOfMemory );

	pbuf = (BYTE *)SAlloc( cbInitialSize );
	if ( pbuf == NULL )
    {
        SFree(pmembuf);
		return ErrERRCheck( JET_errOutOfMemory );
    }

	rgbTags = (MEMBUFTAG *)pbuf;
	rgbTags[itagMemBufTagArray].ib = 0;		// tag array starts at beginning of memory
	rgbTags[itagMemBufTagArray].cb = cInitialEntries * sizeof(MEMBUFTAG);

	Assert( rgbTags[itagMemBufTagArray].cb <= cbInitialSize );

	pmembuf->bufhdr.cbBufSize = cbInitialSize;
	pmembuf->bufhdr.ibBufFree = rgbTags[itagMemBufTagArray].cb;
	pmembuf->bufhdr.cTotalTags = cInitialEntries;
	pmembuf->bufhdr.iTagUnused = itagMemBufFirstUsable;
	pmembuf->bufhdr.iTagFreed = itagMemBufFirstUsable;

	pmembuf->pbuf = pbuf;

	*prgbBuffer = ( BYTE * ) pmembuf;
	
	return JET_errSuccess;
	}



VOID MEMFreeMemBuf( BYTE *rgbBuffer )
	{
	MEMBUF	*pmembuf = ( MEMBUF * ) rgbBuffer;

	MEMAssertMemBuf( pmembuf );			// Validate integrity of buffer.

	SFree( pmembuf->pbuf );
	SFree( pmembuf );
	}


LOCAL INLINE BOOL FMEMResizeBuf( MEMBUF *pmembuf, ULONG cbNeeded )
	{
	BYTE 		*pbuf;
	MEMBUFHDR	*pbufhdr = &pmembuf->bufhdr;
	ULONG 		cbNewBufSize = pbufhdr->cbBufSize + cbNeeded + cbMemBufChunkSize;

	// UNDONE: When we move to concurrent DDL, we will need a critical section
	// to protect against a buffer getting reallocated while another thread holds
	// a pointer into the buffer.
	// At the moment, this is just a placeholder to remind me that this needs to
	// be done.  -- JL
	SgEnterCriticalSection( critMemBuf );

	// Not enough memory to add the entry.  Allocate more.  The amount
	// to allocate is enough to satisfy adding the entry, plus an additional
	// chunk to satisfy future insertions.
	pbuf = ( BYTE * ) SAlloc( cbNewBufSize );
	if ( pbuf == NULL )
		return fFalse;

	// Copy the old buffer contents to the new, then delete the old buffer.
	memcpy( pbuf, pmembuf->pbuf, pbufhdr->cbBufSize );
	SFree( pmembuf->pbuf );
				
	// Buffer has relocated.
	pmembuf->pbuf = pbuf;
	pbufhdr->cbBufSize = cbNewBufSize;

	SgLeaveCriticalSection( critMemBuf );

	return fTrue;
	}


LOCAL INLINE ERR ErrMEMGrowEntry( MEMBUF *pmembuf, ULONG iTagEntry, ULONG cbNew )
	{
	MEMBUFHDR	*pbufhdr = &pmembuf->bufhdr;
	MEMBUFTAG	*rgbTags = (MEMBUFTAG *)pmembuf->pbuf;
	ULONG		iTagCurrent, ibEntry, cbOld, cbAdditional;

	Assert( iTagEntry >= itagMemBufFirstUsable  ||  iTagEntry == itagMemBufTagArray );

	ibEntry = rgbTags[iTagEntry].ib;
	cbOld = rgbTags[iTagEntry].cb;

	Assert( cbNew > cbOld );
	cbAdditional = cbNew - cbOld;

	// First ensure that we have enough buffer space to allow the entry
	// to enlarge.
	if ( pbufhdr->cbBufSize - pbufhdr->ibBufFree < cbAdditional )
		{
		if ( !FMEMResizeBuf( pmembuf, cbAdditional - ( pbufhdr->cbBufSize - pbufhdr->ibBufFree ) ) )
			return ErrERRCheck( JET_errOutOfMemory );

		// Buffer likely relocated, so refresh.
		rgbTags = (MEMBUFTAG *)pmembuf->pbuf;
		}

	Assert( ( ibEntry + cbOld ) <= pbufhdr->ibBufFree );
	Assert( ( ibEntry + cbNew ) <= pbufhdr->cbBufSize );
	memmove( pmembuf->pbuf + ibEntry + cbNew, pmembuf->pbuf + ibEntry + cbOld,
		pbufhdr->ibBufFree - ( ibEntry + cbOld ) );

	pbufhdr->ibBufFree += cbAdditional;
	Assert( pbufhdr->ibBufFree <= pbufhdr->cbBufSize );

	// Fix up the tag array to match the byte movement of the buffer.
	for ( iTagCurrent = itagMemBufFirstUsable; iTagCurrent < pbufhdr->iTagUnused; iTagCurrent++ )
		{
		// Ignore itags on the freed list.  Also ignore buffer space that occurs
		// before the space to be enlarged.
		if ( rgbTags[iTagCurrent].cb > 0  &&  rgbTags[iTagCurrent].ib > ibEntry )
			{
			Assert( rgbTags[iTagCurrent].ib >= ibEntry + cbOld );
			rgbTags[iTagCurrent].ib += cbAdditional;
			Assert( rgbTags[iTagCurrent].ib + rgbTags[iTagCurrent].cb <= pbufhdr->ibBufFree );
			}
		}
	Assert( iTagCurrent == pbufhdr->iTagUnused );

	// Update byte count.
	rgbTags[iTagEntry].cb = cbNew;

	return JET_errSuccess;
	}


// Add some bytes to the buffer and return an itag to its entry.
ERR ErrMEMAdd( BYTE *rgbBuffer, BYTE *rgb, ULONG cb, ULONG *piTag )
	{
	MEMBUF		*pmembuf = ( MEMBUF * ) rgbBuffer;
	MEMBUFHDR	*pbufhdr;
	MEMBUFTAG	*rgbTags;

	Assert( cb > 0 );
	Assert( piTag );

	MEMAssertMemBuf( pmembuf );					// Validate integrity of string buffer.
	pbufhdr = &pmembuf->bufhdr;
	rgbTags = (MEMBUFTAG *)pmembuf->pbuf;

	// Check for tag space.
	if ( pbufhdr->iTagFreed < pbufhdr->iTagUnused )
		{
		// Re-use a freed iTag.
		*piTag = pbufhdr->iTagFreed;
		Assert( rgbTags[pbufhdr->iTagFreed].cb == 0 );
		Assert( rgbTags[pbufhdr->iTagFreed].ib >= itagMemBufFirstUsable );

		//	The tag entry of the freed tag will point to the next freed tag.
		pbufhdr->iTagFreed = rgbTags[pbufhdr->iTagFreed].ib;
		Assert( rgbTags[pbufhdr->iTagFreed].cb == 0  ||
			pbufhdr->iTagFreed == pbufhdr->iTagUnused );
		}

	else 
		{
		// No freed tags to re-use, so get the next unused tag.
		Assert( pbufhdr->iTagFreed == pbufhdr->iTagUnused );

		if ( pbufhdr->iTagUnused == pbufhdr->cTotalTags )
			{
			ERR err;

			Assert( rgbTags[itagMemBufTagArray].cb == pbufhdr->cTotalTags * sizeof(MEMBUFTAG) );

			// Tags all used up.  Allocate a new block of tags.
			err = ErrMEMGrowEntry(
				pmembuf,
				itagMemBufTagArray,
				rgbTags[itagMemBufTagArray].cb + ( cTagChunkSize * sizeof(MEMBUFTAG) ) );
			if ( err != JET_errSuccess )
				{
				Assert( err == JET_errOutOfMemory );
				return err;
				}

			rgbTags = (MEMBUFTAG *)pmembuf->pbuf;		// In case buffer relocated to accommodate growth.

			pbufhdr->cTotalTags += cTagChunkSize;
			}

		*piTag = pbufhdr->iTagUnused;
		pbufhdr->iTagFreed++;
		pbufhdr->iTagUnused++;
		}

	Assert( pbufhdr->iTagFreed <= pbufhdr->iTagUnused );
	Assert( pbufhdr->iTagUnused <= pbufhdr->cTotalTags );

	// Check for buffer space.
	if ( pbufhdr->cbBufSize - pbufhdr->ibBufFree < cb )
		{
		if ( !FMEMResizeBuf( pmembuf, cb - ( pbufhdr->cbBufSize - pbufhdr->ibBufFree ) ) )
			{
			// Return the itag we reserved for this entry to the freed list.
			rgbTags[*piTag].ib = pbufhdr->iTagFreed;
			rgbTags[*piTag].cb = 0;
			pbufhdr->iTagFreed = *piTag;
			*piTag = 0;
	
			return ErrERRCheck( JET_errOutOfMemory );
			}

		// Buffer likely relocated, so refresh.
		rgbTags = (MEMBUFTAG *)pmembuf->pbuf;
		}

	// Put the bytes into our buffer.
	rgbTags[*piTag].ib = pbufhdr->ibBufFree;
	rgbTags[*piTag].cb = cb;

	// If user passed in info, copy it to the buffer space allocated.
	if ( rgb )
		{
		memcpy( pmembuf->pbuf + pbufhdr->ibBufFree, rgb, cb );
		}
	
	pbufhdr->ibBufFree += cb;
	Assert( pbufhdr->ibBufFree <= pbufhdr->cbBufSize );

	return JET_errSuccess;	
	}


LOCAL INLINE VOID MEMShrinkEntry( MEMBUF *pmembuf, ULONG iTagEntry, ULONG cbNew )
	{
	MEMBUFHDR	*pbufhdr = &pmembuf->bufhdr;
	MEMBUFTAG	*rgbTags = (MEMBUFTAG *)pmembuf->pbuf;
	BYTE		*pbuf = pmembuf->pbuf;
	ULONG		iTagCurrent, ibNewEnd, cbDelete;

	Assert( iTagEntry >= itagMemBufFirstUsable );
	Assert( cbNew < rgbTags[iTagEntry].cb );

	ibNewEnd = rgbTags[iTagEntry].ib + cbNew;
	cbDelete = rgbTags[iTagEntry].cb - cbNew;

	// Remove the entry to be deleted by collapsing the buffer over
	// the space occupied by that entry.
	Assert( ibNewEnd > 0 );
	Assert( ibNewEnd >= rgbTags[itagMemBufTagArray].ib + rgbTags[itagMemBufTagArray].cb );
	Assert( ( ibNewEnd + cbDelete ) <= pbufhdr->ibBufFree );

	// UNDONE:  Potential overlap.  Should I use memmove() instead?
	memcpy( pbuf + ibNewEnd, pbuf + ibNewEnd + cbDelete,
			 pbufhdr->ibBufFree - ( ibNewEnd + cbDelete ) );

	pbufhdr->ibBufFree -= cbDelete;
	Assert( pbufhdr->ibBufFree > 0 );
	Assert( pbufhdr->ibBufFree >= rgbTags[itagMemBufTagArray].ib + rgbTags[itagMemBufTagArray].cb );

	// Fix up the tag array to match the byte movement of the buffer.
	for ( iTagCurrent = itagMemBufFirstUsable; iTagCurrent < pbufhdr->iTagUnused; iTagCurrent++ )
		{
		Assert( rgbTags[iTagCurrent].ib != ibNewEnd  ||
			( iTagCurrent == iTagEntry  &&  cbNew == 0 ) );

		// Ignore itags on the freed list.  Also ignore buffer space that occurs
		// before the space to be deleted.
		if ( rgbTags[iTagCurrent].cb > 0  &&  rgbTags[iTagCurrent].ib > ibNewEnd )
			{
			Assert( rgbTags[iTagCurrent].ib >= ibNewEnd + cbDelete );
			rgbTags[iTagCurrent].ib -= cbDelete;
			Assert( rgbTags[iTagCurrent].ib >= ibNewEnd );
			Assert( rgbTags[iTagCurrent].ib + rgbTags[iTagCurrent].cb <= pbufhdr->ibBufFree );
			}
		}
	Assert( iTagCurrent == pbufhdr->iTagUnused );

	rgbTags[iTagEntry].cb = cbNew;
	}


VOID MEMDelete( BYTE *rgbBuffer, ULONG iTagEntry )
	{
	MEMBUF		*pmembuf = ( MEMBUF * ) rgbBuffer;
	MEMBUFHDR	*pbufhdr;
	MEMBUFTAG	*rgbTags;

	MEMAssertMemBuf( pmembuf );					// Validate integrity of buffer.

	pbufhdr = &pmembuf->bufhdr;
	rgbTags = (MEMBUFTAG *)pmembuf->pbuf;

	// We should not have already freed this entry.
	Assert( iTagEntry >= itagMemBufFirstUsable  &&  iTagEntry < pbufhdr->iTagUnused );
	Assert( iTagEntry != pbufhdr->iTagFreed );

	// Remove the space dedicated to the entry to be deleted.
	Assert( rgbTags[iTagEntry].cb > 0 );			// Make sure it's not currently on the freed list.
	MEMShrinkEntry( pmembuf, iTagEntry, 0 );

	// Add the tag of the deleted entry to the list of freed tags.
	Assert( rgbTags[iTagEntry].cb == 0 );
	rgbTags[iTagEntry].ib = pbufhdr->iTagFreed;
	pbufhdr->iTagFreed = iTagEntry;
	}


// If rgb==NULL, then just resize the entry (ie. don't replace the contents).
ERR ErrMEMReplace( BYTE *rgbBuffer, ULONG iTagEntry, BYTE *rgb, ULONG cb )
	{
	ERR			err = JET_errSuccess;
	MEMBUF		*pmembuf = (MEMBUF *) rgbBuffer;
	MEMBUFTAG	*rgbTags;

	// If replacing to 0 bytes, use MEMDelete() instead.
	Assert( cb > 0 );

	MEMAssertMemBuf( pmembuf );					// Validate integrity of buffer.
	Assert( iTagEntry >= itagMemBufFirstUsable  &&  iTagEntry < pmembuf->bufhdr.iTagUnused );

	rgbTags = (MEMBUFTAG *)pmembuf->pbuf;

	Assert( rgbTags[iTagEntry].cb > 0 );
	Assert( rgbTags[iTagEntry].ib + rgbTags[iTagEntry].cb <= pmembuf->bufhdr.ibBufFree );

	if ( cb < rgbTags[iTagEntry].cb )
		{
		// The new entry is smaller than the old entry.  Remove leftover space.
		MEMShrinkEntry( pmembuf, iTagEntry, cb );
		}
	else if ( cb > rgbTags[iTagEntry].cb )
		{
		// The new entry is larger than the old entry, so enlargen the
		// entry before writing to it.
		err = ErrMEMGrowEntry( pmembuf, iTagEntry, cb );
		rgbTags = (MEMBUFTAG *)pmembuf->pbuf;		// In case buffer relocated to accommodate growth.
		}

	if ( err == JET_errSuccess  &&  rgb != NULL )
		{
		// Overwrite the old entry with the new one.
		memcpy( pmembuf->pbuf + rgbTags[iTagEntry].ib, rgb, cb );
		}

	return err;
	}


#ifdef DEBUG
BYTE *SzMEMGetString( BYTE *rgbBuffer, ULONG iTagEntry )
	{
	BYTE 	*szString;

	szString = PbMEMGet( rgbBuffer, iTagEntry );
	Assert( strlen( szString ) == CbMEMGet( rgbBuffer, iTagEntry ) - 1 );	// Account for null-terminator.

	return szString;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\loggen.c ===
#include "config.h"

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "daedef.h"
#include "ssib.h"
#include "pib.h"
#include "util.h"
#include "page.h"
#include "stapi.h"
#include "nver.h"
#include "dirapi.h"
#include "logapi.h"
#include "log.h"

DeclAssertFile;					/* Declare file name for assert macros */


/*	log file info
/**/
HANDLE		hfLog;			/* logfile handle */
int			csecLGFile = 3;
LGFILEHDR	lgfilehdr;		/* cached current log file header */

char		*pbLastMSFlush;	/* to LGBuf where last multi-sec flush LogRec sit*/

extern int	isecRead;
extern BYTE *pbRead;
extern BYTE *pbNext;

/*	in memory log buffer
/**/

#define		csecLGBufSize 40

int			csecLGBuf = csecLGBufSize;
char		rgbLGBuf[ csecLGBufSize * cbSec + cbSec ];
char		*pbLGBufMin = rgbLGBuf;
char		*pbLGBufMax = rgbLGBuf + csecLGBufSize * cbSec;


/*	generate an empty szJetLog file
/**/

void _cdecl main( int argc, char *argv[] )
	{
	pbEntry = pbLGBufMin;			/* start of data area */
	*(LRTYP *)pbEntry = lrtypEnd;	/* add one end record */
	pbWrite = pbLGBufMin;
	strcat( szLogFilePath, "\\" );
	szLogCurrent = szLogFilePath;
	(void)ErrLGNewLogFile(
		0,		/* generation to close */
		fFalse	/* no old log */
		);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\jet500\xjet\src\node.c ===
#include "daestd.h"

DeclAssertFile;					/* Declare file name for assert macros */

#ifdef DEBUG
#define CHECK_LOG	1
#ifdef CHECK_LOG
		
#define	NDLGCheckPage( pfucb )						  	 	\
	{			 										   	\
	(VOID)ErrLGCheckPage( pfucb,						   	\
		pfucb->ssib.pbf->ppage->cbFree,			   	\
		pfucb->ssib.pbf->ppage->cbUncommittedFreed,  	\
		(SHORT)ItagPMQueryNextItag( &pfucb->ssib ),			\
		(PGNO) pfucb->ssib.pbf->ppage->pgnoFDP );    	\
	}

#else
#define NDLGCheckPage( pfucb )
#endif
#else
#define NDLGCheckPage( pfucb )
#endif

#undef cmsecWaitWriteLatch
#define cmsecWaitWriteLatch 	1

/*==========================================================
ErrNDNewPage

Initalizes a page to have a one line at itag 0, having no sons.

Inputs:	pgno									pgno of page
			pgnoFDP								pgnoFDP of page
			pgtyp									page type
			fVisible								flag indicating visibility of sons

Returns:	JET_errSuccess
			error from called routine

==========================================================*/
ERR ErrNDNewPage( FUCB *pfucb, PGNO pgno, PGNO pgnoFDP, PGTYP pgtyp, BOOL fVisibleSons )
	{
	ERR		err;
	SSIB	*pssib = &pfucb->ssib;
 	BYTE	rgb[2];
	LINE	line;

	/*	initialize new page to have all resources available and
	/*	no lines.
	/**/
	CallR( ErrBFNewPage( pfucb, pgno, pgtyp, pgnoFDP ) );
	PcsrCurrent( pfucb )->pgno = pgno;

	/*	new page is always dirty.
	/**/
	AssertBFDirty( pfucb->ssib.pbf );

	/*	insert FOP or FDP root node, with initial line.
	/**/
	rgb[0] = 0;
	if ( fVisibleSons )
		NDSetVisibleSons( rgb[0] );
	NDSetKeyLength( PbNDKeyCb( rgb ), 0 );
	Assert( rgb[1] == 0 );
	line.cb = 2;
	line.pb = rgb;
	CallS( ErrPMInsert( pssib, &line, 1 ) );
	Assert( pssib->itag == 0 );
	return err;
	}


VOID NDSeekSon( FUCB *pfucb, CSR *pcsr, KEY const *pkey, INT fFlags )
	{
	SSIB 	*pssib 			= &pfucb->ssib;
	PAGE 	*ppage 			= pssib->pbf->ppage;
	TAG		*rgbtag    		= ( TAG * ) ( ( BYTE * )ppage->rgtag );
	BYTE 	*pbNode			= ( BYTE * ) ( pssib->line.pb );
	BYTE 	*pbSonTable		= ( BYTE * ) pbNode + pbNode[1] + 2;

	BYTE 	*pitagStart		= pbSonTable + 1;
	BYTE 	*pitagEnd		= pbSonTable + *pbSonTable;
	BYTE 	*pitagMid;
	INT		s;

	AssertFBFReadAccessPage( pfucb, pcsr->pgno );
	AssertNDGet( pfucb, pcsr->itagFather );
	Assert( FNDSon( *pssib->line.pb ) );
	NDCheckPage( pssib );

	/*	seek son depending on replace or insert operation.
	/**/
	if ( !( fFlags & fDIRReplace ) )
		{
		BOOL	fFoundEqual = fFalse;

		while ( pitagEnd > pitagStart )
			{
			pitagMid = pitagStart + ( ( pitagEnd - pitagStart ) >> 1 );

			s = CmpStKey( StNDKey( (BYTE *)ppage + rgbtag[*pitagMid].ib ), pkey );
			if ( s > 0 )
				{
				pitagEnd = pitagMid;
				}
			else
				{
				if ( s == 0 )
					fFoundEqual = fTrue;

				pitagStart = pitagMid + 1;
				}
			}

		// Our search algorithm above may actually place us one past
		// the key we're searching for.  If so, correct it.

		if ( fFoundEqual )
			{
			if ( CbNDKey( (BYTE *)ppage + rgbtag[*pitagEnd].ib ) > 0 )
				{
				Assert( CmpStKey( StNDKey( (BYTE *)ppage + rgbtag[*pitagEnd].ib ),
						pkey ) >= 0 );

				// Only check the previous key if the current key is larger than
				// the desired key.
				if ( CmpStKey( StNDKey( (BYTE *)ppage + rgbtag[*pitagEnd].ib ),
						pkey ) != 0 )
					{
					// Since we found the key, but it's not the current one, it MUST
					// be the previous one.
					Assert( pitagEnd > pbSonTable + 1 );	// Ensure a previous key exists.
					Assert( CmpStKey( StNDKey( (BYTE *)ppage + rgbtag[*(pitagEnd-1)].ib ),
							pkey ) == 0 );
					pitagEnd--;
					}
				}
#ifdef DEBUG
			else
				{
				// Special case: We're currently sitting on the NULL key (ie. the
				// last son).  However, the key we're searching for was previously
				// found on this page.  Therefore, it must be the previous key.
				// In this case, stay on the NULL key.
				Assert( CbNDKey( (BYTE *)ppage + rgbtag[*pitagEnd].ib ) == 0 );
				Assert( pitagEnd > pbSonTable + 1 );	// Ensure a previous key exists.
				Assert( CmpStKey( StNDKey( (BYTE *)ppage + rgbtag[*(pitagEnd-1)].ib ),
						pkey ) == 0 );
				}
#endif
			}
		}
	else
		{
		while ( pitagEnd > pitagStart )
			{
			pitagMid = pitagStart + ( ( pitagEnd - pitagStart ) >> 1 );

			s = CmpStKey( StNDKey( (BYTE *)ppage + rgbtag[*pitagMid].ib ), pkey );
			if ( s < 0 )
				{
				pitagStart = pitagMid + 1;
				}
			else
				{
				pitagEnd = pitagMid;
				}
			}
		}

	/*	get current node
	/**/
	pcsr->ibSon = (SHORT)(pitagEnd - ( pbSonTable + 1 ));
	pcsr->itag = *pitagEnd;
	NDGet( pfucb, pcsr->itag );
	return;
	}


VOID NDMoveFirstSon( FUCB *pfucb, CSR *pcsr )
	{
	SSIB   	*pssib = &pfucb->ssib;
	BYTE   	*pbSonTable;

	AssertFBFReadAccessPage( pfucb, pcsr->pgno );
	AssertNDGet( pfucb, pcsr->itagFather );
	Assert( FNDNullSon( *pssib->line.pb ) || CbNDSon( pssib->line.pb ) != 0 );
	
	pcsr->ibSon = 0;
	pbSonTable = PbNDSonTable( pssib->line.pb );
	pcsr->itag = ( INT ) pbSonTable[ pcsr->ibSon + 1 ];
	NDGet( pfucb, pcsr->itag );
	}


VOID NDMoveLastSon( FUCB *pfucb, CSR *pcsr )
	{
	SSIB   	*pssib = &pfucb->ssib;
	BYTE   	*pbSonTable;

	AssertFBFReadAccessPage( pfucb, pcsr->pgno );
	AssertNDGet( pfucb, pcsr->itagFather );

	pbSonTable = PbNDSonTable( pssib->line.pb );
	pcsr->ibSon = *pbSonTable - 1;
	pcsr->itag = ( INT ) pbSonTable[ pcsr->ibSon + 1 ];
	NDGet( pfucb, pcsr->itag );
	}


ERR ErrNDMoveSon( FUCB *pfucb, CSR *pcsr )
	{
	SSIB   	*pssib = &pfucb->ssib;
	BYTE   	*pbSonTable;

	AssertFBFReadAccessPage( pfucb, pcsr->pgno );
	AssertNDGet( pfucb, pcsr->itagFather );

	if ( !( FNDSon( *pssib->line.pb ) ) )
		return ErrERRCheck( errNDOutSonRange );

	pbSonTable = PbNDSonTable( pssib->line.pb );
	if ( pcsr->ibSon < 0 || pcsr->ibSon >= ( INT )*pbSonTable )
  		return ErrERRCheck( errNDOutSonRange );

  	pcsr->itag = ( INT )pbSonTable[ pcsr->ibSon + 1 ];
	NDGet( pfucb, pcsr->itag );
	return JET_errSuccess;
	}


VOID NDGetNode( FUCB *pfucb )
	{
	SSIB   	*pssib 	= &pfucb->ssib;
	BYTE   	*pbNode	= pssib->line.pb;
	BYTE   	*pb		= pbNode + 1;
	INT		cb;

	/*	assert line currency.
	/**/
	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	pfucb->keyNode.cb = ( INT )*pb;
	pfucb->keyNode.pb = pb + 1;
	pb += *pb + 1;

	/* skip son
	/**/
	if ( FNDSon( *pbNode ) )
		{
		if ( FNDInvisibleSons( *pbNode ) && *pb == 1 )
			pb += sizeof(PGNO) + 1;
		else
			pb += *pb + 1;
		}

	/*	skip back pointer
	/**/
	if ( FNDBackLink( *pbNode ) )
		pb += sizeof( SRID );

	/* get data
	/**/
	if ( ( cb = pssib->line.cb - (INT)( pb - pbNode ) ) == 0 )
		{
		pfucb->lineData.cb = 0;
		return;
		}

	pfucb->lineData.pb = pb;
	pfucb->lineData.cb = cb;
	return;
	}


#ifdef DEBUG
VOID AssertNDGetKey( FUCB *pfucb, INT itag )
	{
	SSIB   	*pssib = &pfucb->ssib;

	AssertNDGet( pfucb, itag );
	Assert( CbNDKey( pssib->line.pb ) == pfucb->keyNode.cb );
	Assert( CbNDKey( pssib->line.pb ) == 0 ||
		PbNDKey( pssib->line.pb ) == pfucb->keyNode.pb );
	return;
	}

VOID AssertNDGetNode( FUCB *pfucb, INT itag )
	{
	SSIB   	*pssib = &pfucb->ssib;

	AssertNDGet( pfucb, itag );
	Assert( CbNDKey( pssib->line.pb ) == pfucb->keyNode.cb );
	Assert( CbNDKey( pssib->line.pb ) == 0 ||
		PbNDKey( pssib->line.pb ) == pfucb->keyNode.pb );
	Assert( CbNDData( pssib->line.pb, pssib->line.cb ) == pfucb->lineData.cb );
	Assert( pfucb->lineData.cb == 0  ||
		PbNDData( pssib->line.pb ) == pfucb->lineData.pb );
	return;
	}
#endif


VOID NDGetBookmarkFromCSR( FUCB *pfucb, CSR *pcsr, SRID *psrid )
	{
	ERR		err = JET_errSuccess;

	AssertFBFReadAccessPage( pfucb, pcsr->pgno );
	AssertNDGet( pfucb, pcsr->itag );

	NDIGetBookmarkFromCSR( pfucb, pcsr, psrid );
	return;
	}


INLINE LOCAL VOID NDInsertSon( FUCB *pfucb, CSR *pcsr )
	{
	SSIB	*pssib = &pfucb->ssib;
	BYTE	itag = ( BYTE ) pssib->itag;
	LINE	rgline[5];
	INT 	cline;
	BYTE	cbSon;
	BYTE	bNodeFlag;
	BYTE	rgbT[2];
	BYTE	*pb;
	UINT	cbCopied;

	/*	get father node
	/**/
	NDGet( pfucb, pcsr->itagFather );
	NDCheckPage( pssib );

	/*	assert father is not deleted
	/**/
	Assert( !( FNDDeleted( *pssib->line.pb ) ) );

	/*	insert the son into position indicated by pcsr->ibSon
	/*	skip key
	/**/
	pb = PbNDSonTable( pssib->line.pb );

	/*	copy up to son table
	/**/
	cbCopied = (UINT)(pb - pssib->line.pb);

	if ( FNDNullSon( *pssib->line.pb ) )
		{
		// copy the father node, create the the son table, insert it into
		// the son table

		// adjust the line pointer since we can not update the first
		// flag byte directly
		// set the son flag
		pcsr->ibSon = 0;

		bNodeFlag = *pssib->line.pb;
		NDSetSon( bNodeFlag );
		rgline[0].pb = &bNodeFlag;
		rgline[0].cb = 1;

		rgline[1].pb = pssib->line.pb + 1;
		rgline[1].cb = cbCopied - 1;

		rgbT[0] = 1;
		// son count: 1 son
		rgbT[1] = itag;
		// the itag entry of the son
		rgline[2].pb = rgbT;
		rgline[2].cb = 2;

		// copy the data of the node
		rgline[3].pb = pssib->line.pb + cbCopied;
		Assert( pssib->line.cb >= cbCopied );
		rgline[3].cb = pssib->line.cb - cbCopied;

		cline = 4;
		}
	else
		{
		// copy out the father node, shift the the son table, insert it
		// into the son table

		rgline[0].pb = pssib->line.pb;
		rgline[0].cb = cbCopied;

		// copy son count and increment it by one
		cbSon = ( *pb++ ) + ( BYTE )1;
		rgline[1].pb = &cbSon;
		rgline[1].cb = 1;

		// copy the first half of son table
		rgline[2].pb = pb;
		rgline[2].cb = pcsr->ibSon;
		pb += pcsr->ibSon;				// move cursor forward
		cbCopied += pcsr->ibSon + 1;	// count in the son count

		// copy the new entry
		rgline[3].pb = &itag;
		rgline[3].cb = 1;

		// copy the second half of the son table and data portion

		rgline[4].pb = pb;
		Assert( pssib->line.cb >= cbCopied );
		rgline[4].cb = pssib->line.cb - cbCopied;

		cline = 5;
		}

	/*	update the father node now cbRec is the new total length
	/**/
	pssib->itag = pcsr->itagFather;
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	return;
	}


ERR ErrNDInsertNode( FUCB *pfucb, KEY const *pkey, LINE *plineData, INT fHeader, INT fFlags )
	{
	ERR		err = JET_errSuccess;
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	INT		itag;
	SRID	bm;
	LINE	rgline[4];
	INT		cline = 0;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	if ( !( fFlags & fDIRNoLog ) && FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
		
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		pfucb->ppib->cLatchConflict++;
		BFSleep( cmsecWaitWriteLatch );
		return ErrERRCheck( errDIRNotSynchronous );
		}

	/*	query next itag to be used for insert
	/**/
	itag = ItagPMQueryNextItag( pssib );

	bm = SridOfPgnoItag( pcsr->pgno, itag );

	/*	create version entry for inserted node.  If version entry creation
	/*	fails, undo insert and return error.
	/**/
	if ( ( fFlags & fDIRVersion ) &&  !FDBIDVersioningOff( pfucb->dbid ) )
		{
		Assert( FNDVersion( fHeader ) );
		Call( ErrVERInsert( pfucb, bm ) );
		}
	else
		{
		Assert( !FNDVersion( fHeader ) );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	/*	insert the data into the page first
	/**/
	rgline[cline].pb = (BYTE *)&fHeader;

	/*	machine dependent see the macro
	/**/
	rgline[cline++].cb = 1;
	rgline[cline].pb = (BYTE *) &pkey->cb;

	/*	machine dependent
	/**/
	rgline[cline++].cb = 1;

	if ( !FKeyNull( pkey ) )
		{
		rgline[cline].pb = pkey->pb;
		rgline[cline++].cb = pkey->cb;
		}

	if ( !FLineNull( plineData ) )
		{
		rgline[cline++] = *plineData;
		}

	/*	insert son in father son table
	/**/
	pssib->itag = itag;
	NDInsertSon( pfucb, pcsr );

	/* insert the node and set CSR itag to inserted node
	/**/
	CallS( ErrPMInsert( pssib, rgline, cline ) );
	Assert( pssib->itag == itag );
	pcsr->itag = (SHORT)itag;
	Assert( bm == SridOfPgnoItag( pcsr->pgno, pcsr->itag ) );
	pcsr->bm = bm;

	// Verify that we picked the correct insertion point.
	Assert( pssib == &pfucb->ssib );
	NDCheckPage( pssib );

	/*	assert line currency to inserted node
	/**/
	AssertNDGet( pfucb, pcsr->itag );

	if ( !( fFlags & fDIRNoLog ) )
		{
		/* if log fail return to caller, system should crash by the caller
		/**/
		err = ErrLGInsert( pfucb, fHeader, (KEY *)pkey, plineData, fFlags );
		NDLGCheckPage( pfucb );
		}

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

HandleError:
	return err;
	}


ERR ErrNDFlagDeleteNode( FUCB *pfucb, INT fFlags )
	{
	ERR		err = JET_errSuccess;
	CSR    	*pcsr = PcsrCurrent( pfucb );
	SSIB   	*pssib = &pfucb->ssib;
	BOOL	fDoVersioning = ( ( fFlags & fDIRVersion ) && !FDBIDVersioningOff( pfucb->dbid ) );

	if ( !( fFlags & fDIRNoLog ) && FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
		
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		pfucb->ppib->cLatchConflict++;
		BFSleep( cmsecWaitWriteLatch );
		return ErrERRCheck( errDIRNotSynchronous );
		}

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	if ( fDoVersioning )
		{
#ifdef DEBUG
			{
			SRID	srid;

			NDIGetBookmark( pfucb, &srid );
			Assert( pcsr->bm == srid );
			}
#endif
		/*	if node is flag deleted then access node and
		/*	return JET_errRecordDeleted if not there.
		/**/
		if ( FNDDeleted( *pfucb->ssib.line.pb ) )
			{
			NS		ns;

			ns = NsVERAccessNode( pfucb, pcsr->bm );
			if ( ns == nsDatabase )
				return ErrERRCheck( JET_errRecordDeleted );
			}
		Call( ErrVERFlagDelete( pfucb, pcsr->bm ) );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( pssib );

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	flag node as versioned
	/**/
	if ( fDoVersioning )
		NDSetVersion( *pssib->line.pb );

	/*	flag node as deleted
	/**/
	NDSetDeleted( *pssib->line.pb );

	if ( !( fFlags & fDIRNoLog ) )
		{
		/* if log fail return to caller, system should crash by the caller
		/**/
		err = ErrLGFlagDelete( pfucb, fFlags );
		NDLGCheckPage( pfucb );
		}

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	if ( !fRecovering )
		{
#ifdef OLC_DEBUG
		Assert( pfucb->sridFather != sridNull &&
				pfucb->sridFather != sridNullLink );
#endif

		MPLRegister( pfucb->u.pfcb,
			pssib,
			PnOfDbidPgno( pfucb->dbid,
			pcsr->pgno ),
			pfucb->sridFather );
		}

HandleError:
	return err;
	}


/*	makes lone son of node intrinsic
/*
/*	PARAMETERS
/*		pfucb->pcsr->itag	node with one son to be made intrinsic
/**/
LOCAL VOID NDMakeSonIntrinsic( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	LINE	lineNode;
	BYTE	*pb;
	INT		itagSon;
	LINE	rgline[3];
	PGNO	pgnoPagePointer;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	/* get node
	/**/
	NDGet( pfucb, pcsr->itag );

	Assert( !FNDNullSon( *pssib->line.pb ) );
	Assert( CbNDSon( pssib->line.pb ) == 1 );
	Assert( FNDInvisibleSons( *pssib->line.pb ) );

	lineNode.pb = pssib->line.pb;
	lineNode.cb = pssib->line.cb;
	pb = PbNDSonTable( lineNode.pb );
	Assert( *pb == 1 );
	/*	get son
	/**/
	itagSon = *(++pb);

	/*	copy up to and including to son count [which remains 1]
	/**/
	rgline[0].pb = lineNode.pb;
	rgline[0].cb = (ULONG)(pb - lineNode.pb);

	/*	get the data portion of son node
	/**/
	NDGet( pfucb, itagSon );
	Assert( CbNDData( pssib->line.pb, pssib->line.cb ) == sizeof(PGNO) );
	pgnoPagePointer = *(PGNO UNALIGNED *)PbNDData( pssib->line.pb );
	rgline[1].pb = (BYTE *)&pgnoPagePointer;
	rgline[1].cb = sizeof(pgnoPagePointer);

	/*	there was only one son, do not copy the son count and this son
	/**/
	pb++;

	/*	copy the rest of record from end of son table
	/**/
	rgline[2].pb = pb;
	rgline[2].cb = (ULONG)(lineNode.pb + lineNode.cb - pb);

	/* delete son (extrinsic copy)
	/**/
	pssib->itag = itagSon;
	PMDelete( pssib );

	/*	update node, do not log it
	/**/
	pssib->itag = pcsr->itag;
	CallS( ErrPMReplace( pssib, rgline, 3 ) );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	return;
	}


INLINE VOID NDDeleteSon( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SSIB	*pssib = &pfucb->ssib;
	BYTE	*pb;
	LINE	rgline[5];
	INT		cline;
	BYTE	bNodeFlag;
	BYTE	cbSon;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );

	/* first delete the son entry in father of node
	/**/
	NDGet( pfucb, pcsr->itagFather );

	Assert( !FNDNullSon( *pssib->line.pb ) );
	pb = PbNDSonTable( pssib->line.pb );

	/*	copy up to son count
	/**/
	rgline[0].pb = pssib->line.pb;
	rgline[0].cb = (ULONG)(pb - pssib->line.pb);

	/*	pb is pointing to the son count, decrement the son count
	/*	copy first half of the son table
	/**/
	if ( *pb == 1 )
		{
		/* skip node header
		/**/
		rgline[1].pb = rgline[0].pb + 1;
		rgline[1].cb = rgline[0].cb - 1;
		
		/* set node header
		/**/
		bNodeFlag = *pssib->line.pb;
		NDResetSon( bNodeFlag );
		rgline[0].pb = &bNodeFlag;
		rgline[0].cb = 1;

		/*	there was only one son, do not copy the son count and this son
		/**/
		if ( pcsr->itagFather != itagFOP && FNDInvisibleSons( bNodeFlag ) )
			{
			/* intrinsic son
			/**/
			pb += 1 + 4;
			}
		else
			{
			/*	check for valid ibSon
			/**/
			Assert( pb[pcsr->ibSon + 1] == pcsr->itag );

			pb += 1 + 1;
			}
		NDSetVisibleSons( bNodeFlag );
		Assert( FNDVisibleSons( bNodeFlag ) || pcsr->itagFather != itagFOP );
		cline = 2;
		}
	else
		{
		/*	check for valid ibSon
		/**/
		Assert( pb[pcsr->ibSon + 1] == pcsr->itag );

		/*	copy the son count
		/**/
		cbSon = ( *pb++ ) - ( BYTE ) 1;
		/*	new son count
		/**/
		rgline[1].pb = &cbSon;
		rgline[1].cb = 1;

		/*	copy half of the table of the record
		/*	portion of son table
		/*	son count and portion of son table
		/**/
		rgline[2].pb = pb;
		rgline[2].cb = pcsr->ibSon;

		/*	skip those copied and the deleted son
		/**/
		pb += pcsr->ibSon + 1;

		/*	continue copying from this point
		/**/
		cline = 3;
		}

	/*	copy the rest of record from end of son table
	/**/
	rgline[cline].pb = pb;
	rgline[cline++].cb = (ULONG)(pssib->line.pb + pssib->line.cb - pb);

	/*	update the father node, do not log it
	/**/
	pssib->itag = pcsr->itagFather;
	CallS( ErrPMReplace( pssib, rgline, cline ) );

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	return;
	}


INLINE LOCAL  VOID NDIReplaceNodeData( FUCB *pfucb, LINE *plineData, INT fFlags )
	{
	LINE	rgline[3];
	BYTE	bHeader;
	BYTE	*pbData;
	BYTE	*pbNode;
	BYTE	*pbT;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	Assert( !( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) ) );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	pbNode = pfucb->ssib.line.pb;
	pbData = PbNDData( pbNode );
	Assert( pbData <= pfucb->ssib.line.pb + pfucb->ssib.line.cb );
	Assert( pbData > pfucb->ssib.line.pb );

	/*	set predata line
	/**/
	bHeader = *pbNode;
	if ( ( fFlags & fDIRVersion )  &&  !FDBIDVersioningOff( pfucb->dbid ) )
		NDSetVersion( bHeader );
	rgline[0].pb = &bHeader;
	rgline[0].cb = sizeof( BYTE );

	/*	set predata line
	/**/
	rgline[1].pb =
	pbT = pbNode + 1;
	rgline[1].cb = (ULONG)(pbData - pbT);
	Assert( rgline[1].cb != 0 );

	/*	append data line
	/**/
	rgline[2].pb = plineData->pb;
	rgline[2].cb = plineData->cb;

	pfucb->ssib.itag = PcsrCurrent( pfucb )->itag;

	/* update the node
	/**/
	CallS( ErrPMReplace( &pfucb->ssib, rgline, 3 ) );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	return;
	}


ERR ErrNDDelta( FUCB *pfucb, LONG lDelta, INT fFlags )
	{
	ERR		err;

	if ( !( fFlags & fDIRNoLog ) && FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}

	err = ErrNDDeltaNoCheckLog( pfucb, lDelta, fFlags );
	return err;
	}


ERR ErrNDDeltaNoCheckLog( FUCB *pfucb, LONG lDelta, INT fFlags )
	{
	ERR		err = JET_errSuccess;
	BYTE	rgb[cbMaxCounterNode];
	CSR		*pcsr = PcsrCurrent( pfucb );
	LINE	line;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		pfucb->ppib->cLatchConflict++;
		BFSleep( cmsecWaitWriteLatch );
		return ErrERRCheck( errDIRNotSynchronous );
		}

	if ( ( fFlags & fDIRVersion )  &&  !FDBIDVersioningOff( pfucb->dbid ) )
		{
#ifdef DEBUG
		SRID	srid;

		NDIGetBookmark( pfucb, &srid );
		Assert( pcsr->bm == srid );
#endif

		/*	version store information is delta rather than before image
		/**/
		pfucb->lineData.pb = (BYTE *)&lDelta;
		pfucb->lineData.cb = sizeof(lDelta);
		err = ErrVERDelta( pfucb, pcsr->bm );
		Call( err );

		/*	refresh node cache
		/**/
		NDGetNode( pfucb );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer
	/**/
	PMDirty( &pfucb->ssib );

	AssertNDGetNode( pfucb, pcsr->itag );
	memcpy( rgb, pfucb->lineData.pb, pfucb->lineData.cb );

	Assert( ibCounter <= (INT)(pfucb->lineData.cb - sizeof(ULONG)) );

	/*	delta cannot have negative results
	/**/
	Assert( (*(LONG UNALIGNED *)(rgb + ibCounter)) + lDelta >= 0 );
	(*(LONG UNALIGNED *)(rgb + ibCounter)) += lDelta;
	line.cb = pfucb->lineData.cb;
	line.pb = (BYTE *)rgb;

	/* should be an in-place replace
	/**/
	NDIReplaceNodeData( pfucb, &line, fFlags );

	if ( !( fFlags & fDIRNoLog ) )
		{
		/* if log fail return to caller, system should crash by the caller
		/**/
		err = ErrLGDelta( pfucb, lDelta, fFlags );
		NDLGCheckPage( pfucb );
		}

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

HandleError:
	return err;
	}


ERR ErrNDLockRecord( FUCB *pfucb )
	{
	ERR err;
	RCE	*prce;
	
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	if ( FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
		
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		pfucb->ppib->cLatchConflict++;
		BFSleep( cmsecWaitWriteLatch );
		return ErrERRCheck( errDIRNotSynchronous );
		}

	/*	if node is flag deleted then access node and
	/*	return JET_errRecordDeleted if not there.
	/**/
	if ( FNDDeleted( *pfucb->ssib.line.pb ) )
		{
		NS		ns;

		ns = NsVERAccessNode( pfucb, PcsrCurrent( pfucb )->bm );
		if ( ns == nsDatabase )
			{
			return ErrERRCheck( JET_errRecordDeleted );
			}
		}

	if ( FDBIDVersioningOff( pfucb->dbid ) )
		return JET_errSuccess;

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	put before image in version store as write lock.
	/*	no before image will be put in version store
	/*	during replacement.
	/**/
	Call( ErrVERModify( pfucb, PcsrCurrent( pfucb )->bm, operReplace, &prce ) );
	PMDirty( &pfucb->ssib );
	if ( prce != prceNil )
		{
		Call( ErrLGLockBI( pfucb, pfucb->lineData.cb ) );
		}
	NDLGCheckPage( pfucb );

HandleError:
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	return err;
	}


VOID NDDeltaLog( FUCB *pfucb, LINE *plineNewData, BYTE *pbDiff, INT *pcbDiff, INT fDIRFlags )
	{
	Assert( pbDiff );
	Assert( ! ( fDIRFlags & fDIRNoLog ) );

	*pcbDiff = 0;

	if ( fLogDisabled || fRecovering )
		return;

	if ( !FDBIDLogOn(pfucb->dbid) )
		return;
	
	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

	if ( fDIRLogColumnDiffs & fDIRFlags )
		{
		LGSetDiffs( pfucb, pbDiff, pcbDiff );
		if ( *pcbDiff )
			goto CheckReturn;
		}
	
	else if ( fDIRLogChunkDiffs & fDIRFlags )
		{
		if ( pfucb->lineData.cb == plineNewData->cb )
			{
			BYTE *pbOldCur = pfucb->lineData.pb;
			BYTE *pbOldMax = pbOldCur + pfucb->lineData.cb;
			BYTE *pbNewCur = plineNewData->pb;
			BYTE *pbDiffCur = pbDiff;
			BYTE *pbDiffMax = pbDiffCur + plineNewData->cb;

			while ( pbOldCur < pbOldMax )
				{
				if ( *pbOldCur == *pbNewCur )
					{
					pbOldCur++;
					pbNewCur++;
					}
				else
					{
					INT ibOld;
					INT cbNewData;
					BYTE *pbNewData;
					
					/*	store the offset
					 */
					ibOld = (INT)(pbOldCur - pfucb->lineData.pb);
					pbNewData = pbNewCur;
					cbNewData = 0;

					do {
						INT cbT = 0;

						if ( pbOldCur + sizeof( LONG ) >= pbOldMax )
							cbT = (INT)(pbOldMax - pbOldCur);
						else
							{
							if ( *(LONG UNALIGNED *)pbOldCur == *(LONG UNALIGNED *)pbNewCur )
								break;
							cbT = sizeof( LONG );
							}
						cbNewData += cbT;
						pbOldCur += cbT;
						pbNewCur += cbT;
					} while ( pbOldCur < pbOldMax );
					
					if ( !FLGAppendDiff(
							&pbDiffCur,
							pbDiffMax,					/* max of pbCur to append */
							ibOld,						/* offset to old image */
							cbNewData,					/* length of the old image */
							cbNewData,					/* length of the new image */
							pbNewData					/* pbDataNew */
							) )
						{
						Assert( *pcbDiff == 0 );
						return;
						}
					}
				}
				
			if ( pbOldCur == pbOldMax )
				{
				if ( pbDiffCur == pbDiff )
					{
					/*	No diff is found. Old and New are the same. Log insert null.
					 */
					if ( !FLGAppendDiff(
							&pbDiffCur,
							pbDiffMax,					/* max of pbCur to append */
							0,							/* offset to old image */
							0,							/* length of the old image */
							0,							/* length of the new image */
							pbNil						/* pbDataNew */
							) )
						{
						Assert( *pcbDiff == 0 );
						return;
						}
					else
						{
						*pcbDiff = (INT)(pbDiffCur - pbDiff);
						goto CheckReturn;
						}
					}

				*pcbDiff = (INT)(pbDiffCur - pbDiff);
				goto CheckReturn;
				}
			}
		}

	Assert( *pcbDiff == 0 );
	return;

CheckReturn:

#if DEBUG
	Assert( *pcbDiff != 0 );
	if ( fDIRLogChunkDiffs & fDIRFlags )
		{
		INT		cbNew;
		BYTE	*rgbNew;

		rgbNew = SAlloc(cbChunkMost);
		Assert( cbChunkMost > cbRECRecordMost );

		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	
		LGGetAfterImage( pbDiff, *pcbDiff, pfucb->lineData.pb, pfucb->lineData.cb,
						 rgbNew, &cbNew );
		Assert( plineNewData->cb == (UINT) cbNew );

		Assert( memcmp( plineNewData->pb, rgbNew, cbNew ) == 0 );
		
		SFree(rgbNew);
		}
	else
		{
		INT		cbNew;
		BYTE	*rgbNew, *pbRec;
		FDB		*pfdb;
		WORD	*pibFixOffs;
		FID		fidFixedLastInRec;
		FID		fid;

		rgbNew = SAlloc(cbChunkMost);
		Assert( cbChunkMost > cbRECRecordMost );

		AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );
	
		LGGetAfterImage( pbDiff, *pcbDiff, pfucb->lineData.pb, pfucb->lineData.cb,
						 rgbNew, &cbNew );
		Assert( plineNewData->cb == (UINT) cbNew );

		pfdb = (FDB *)pfucb->u.pfcb->pfdb;
		pibFixOffs = PibFDBFixedOffsets( pfdb );	// fixed column offsets
		pbRec = plineNewData->pb;
		fidFixedLastInRec = ((RECHDR*)pbRec)->fidFixedLastInRec;

		/*	RECHDR should be the same
		 */
		Assert( memcmp( rgbNew, pbRec, sizeof( RECHDR ) ) == 0 );

		/*	check each fixed field. Skip the null field.
		 */
		for ( fid = fidFixedLeast; fid <= fidFixedLastInRec; fid++ )
			{
			BOOL fFieldNullNewData;
			BOOL fFieldNullAfterImage;
			BYTE *prgbitNullity;
		
			prgbitNullity = pbRec + pibFixOffs[ fidFixedLastInRec ] + ( fid - fidFixedLeast ) / 8;
			fFieldNullNewData = !( *prgbitNullity & (1 << ( fid + 8 - fidFixedLeast ) % 8) );
			prgbitNullity = rgbNew + pibFixOffs[ fidFixedLastInRec ] + ( fid - fidFixedLeast ) / 8;
			fFieldNullAfterImage = !( *prgbitNullity & (1 << ( fid + 8 - fidFixedLeast ) % 8) );

			Assert( fFieldNullNewData == fFieldNullAfterImage );

			if ( !fFieldNullNewData )
				{
				FIELD *pfield = PfieldFDBFixed( pfdb ) + ( fid - fidFixedLeast );

//				Assert( memcmp( pbRec + pibFixOffs[ fid - fidFixedLeast ],
//								rgbNew + pibFixOffs[ fid - fidFixedLeast ],
//								pfield->cbMaxLen ) == 0 );
				}
			}

		/*	check the rest of the record.
		 */
		Assert( memcmp( pbRec + pibFixOffs[ fidFixedLastInRec ],
						rgbNew + pibFixOffs[ fidFixedLastInRec ],
						cbNew - pibFixOffs[ fidFixedLastInRec ] ) == 0 );

		SFree(rgbNew);
		}
#endif
		
	return;
	}


ERR ErrNDReplaceNodeData( FUCB *pfucb, LINE *pline, INT fFlags )
	{
	ERR 	err = JET_errSuccess;
	ERR		errT;
	INT		cbData = pfucb->lineData.cb;
	SRID	bm = PcsrCurrent( pfucb )->bm;
	RCE 	*prce;
	INT		cbReserved;

	BYTE rgbDiff[ cbChunkMost ];
	INT cbDiff;

	/*	assert currency
	/**/
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	if ( !( fFlags & fDIRNoLog ) && FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}
		
	if ( FBFWriteLatchConflict( pfucb->ppib, pfucb->ssib.pbf ) )
		{
		pfucb->ppib->cLatchConflict++;
		BFSleep( cmsecWaitWriteLatch );
		return ErrERRCheck( errDIRNotSynchronous );
		}

	AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );

	/*	if versioning, then create before image version for node data.
	/**/
	if ( ( fFlags & fDIRVersion ) &&  !FDBIDVersioningOff( pfucb->dbid ) )
		{
#ifdef DEBUG
		SRID		srid;

		NDIGetBookmark( pfucb, &srid );
		Assert( PcsrCurrent( pfucb )->bm == srid );
#endif
		/*	if node is flag deleted then access node and
		/*	return JET_errRecordDeleted if not there.
		/**/
		if ( FNDDeleted( *pfucb->ssib.line.pb ) )
			{
			NS		ns;

			ns = NsVERAccessNode( pfucb, PcsrCurrent( pfucb )->bm );
			err = ErrERRCheck( ns == nsDatabase ? JET_errRecordDeleted : JET_errWriteConflict );
			return err;
			}

		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		Assert( !FNDDeleted( *pfucb->ssib.line.pb ) );

		/*	if data enlarged in size and versioning enable then
		/*	free page space. VERSetCbAdjust must be called before
		/*  replace to release reserved space so that reserved
		/*  space will be available for the replace operation.
		/**/
		if ( (INT)pline->cb > cbData )
			{
			if ( !FNDFreePageSpace( &pfucb->ssib, (INT)pline->cb - cbData ) )
				{
				pfucb->ssib.itag = PcsrCurrent( pfucb )->itag;
				cbReserved = CbVERGetNodeReserve(
					pfucb->ppib,
					pfucb->dbid,
					PcsrCurrent( pfucb )->bm,
					CbNDData( pfucb->ssib.line.pb, pfucb->ssib.line.cb ) );

				/*	if node expansion cannot be satisfied from
				/*	reserved space, then check for page having
				/*	sufficient free page, above that of the already
				/*	reserved space.
				/**/
				if ( (INT)pline->cb - cbData > cbReserved )
					{
					Assert( (INT)pline->cb - cbData - cbReserved > 0 );
					if ( !FNDFreePageSpace( &pfucb->ssib, (INT)pline->cb - cbData - cbReserved ) )
						{
						err = ErrERRCheck( errPMOutOfPageSpace );
						goto HandleError;
						}
					}
				}
			}

		errT = ErrVERReplace( pfucb, bm, &prce );
		Call( errT );
		Assert( prce != prceNil );

		/*	write latch page from dirty until log completion
		/**/
		BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

		if ( (INT)pline->cb > cbData )
			{
			// WARNING: In order to satisfy the node growth, we first try to reclaim
			// any uncommitted freed space (ie. cbUncommittedFreed).  By obtaining
			// the write latch above, we ensure that no one else uses up this freed
			// space before we consume it.
			VERSetCbAdjust( pfucb, prce, pline->cb, cbData, fDoUpdatePage );
			}

		/*	dirty page buffer
		/**/
		PMDirty( &pfucb->ssib );

		if ( !( fFlags & fDIRNoLog ) )
			NDDeltaLog( pfucb, pline, rgbDiff, &cbDiff, fFlags );

		NDIReplaceNodeData( pfucb, pline, fFlags );

		/*	if data reduced in size and versioning enable then
		/*	allocate page space for rollback.
		/**/
		if ( (INT)pline->cb < cbData )
			{
			VERSetCbAdjust( pfucb, prce, pline->cb, cbData, fDoUpdatePage );
			}

		if ( !( fFlags & fDIRNoLog ) )
			{
			/* if log fail return to caller, system should crash by the caller
			/**/
			err = ErrLGReplace( pfucb, pline, fFlags, cbData, rgbDiff, cbDiff );
			NDLGCheckPage( pfucb );
			}
		BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
		}
	else
		{
		/*	if replace with larger then check for free space
		/**/
		if ( (INT)pline->cb > cbData  &&
			!FNDFreePageSpace( &pfucb->ssib, (INT)pline->cb - cbData ) )
			{
			err = ErrERRCheck( errPMOutOfPageSpace );
			goto HandleError;
			}

		/*	write latch page from dirty until log completion
		/**/
		BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

		/*	dirty page buffer
		/**/
		PMDirty( &pfucb->ssib );

		AssertNDGetNode( pfucb, PcsrCurrent( pfucb )->itag );
		
		if ( !( fFlags & fDIRNoLog ) )
			NDDeltaLog( pfucb, pline, rgbDiff, &cbDiff, fFlags );

		NDIReplaceNodeData( pfucb, pline, fFlags );
	
		if ( !( fFlags & fDIRNoLog ) )
			{
			/* if log fail return to caller, system should crash by the caller
			/**/
			err = ErrLGReplace( pfucb, pline, fFlags, cbData, rgbDiff, cbDiff );
			NDLGCheckPage( pfucb );
			}
		BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
		}

HandleError:
	return err;
	}


ERR ErrNDSetNodeHeader( FUCB *pfucb, BYTE bHeader )
	{
	ERR		err = JET_errSuccess;

	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	if ( FDBIDLogOn( pfucb->dbid ) )
		{
		CallR( ErrLGCheckState( ) );
		}

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer.
	/**/
	PMDirty( &pfucb->ssib );

	/*	set node header byte with new value.
	/**/
	*pfucb->ssib.line.pb = bHeader;

	/* if log fail return to caller, system should crash by the caller
	/**/
	err = ErrLGUpdateHeader( pfucb, (int) bHeader );
	NDLGCheckPage( pfucb );
	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	return err;
	}


VOID NDResetNodeVersion( FUCB *pfucb )
	{
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

 	/*	dirty page buffer. but no increment ulDBTime since not logged and
	/*	not affect directory cursor timestamp check.
	/**/
	NDResetVersion( *( pfucb->ssib.line.pb ) );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	}


VOID NDDeferResetNodeVersion( FUCB *pfucb )
	{
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

 	/*	Reset version bit but _do_not_ dirty page buffer.  This is an optimization
 	/*  to cleanup orphaned version bits without forcing extra page writes.
	/**/
	NDResetVersion( *( pfucb->ssib.line.pb ) );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	}


/* called by ver to undo. Undo is logged, so use PMDirty to set ulDBTime
/**/
VOID NDResetNodeDeleted( FUCB *pfucb )
	{
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	/*	write latch page from dirty until log completion
	/**/
	BFSetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );

	/*	dirty page buffer.
	/**/
	PMDirty( &pfucb->ssib );

	AssertNDGet( pfucb, PcsrCurrent( pfucb )->itag );

	/*	reset node delete
	/**/
	NDResetDeleted( *( pfucb->ssib.line.pb ) );

	BFResetWriteLatch( pfucb->ssib.pbf, pfucb->ppib );
	AssertFBFWriteAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );

	return;
	}


/************************************/
/********* item operations **********/
/************************************/
#ifdef DEBUG
VOID NDICheckItemBookmark( FUCB *pfucb, SRID srid )
	{
	SRID	sridT;

	NDIGetBookmark( pfucb, &sridT );

	if( FNDFirstItem( *pfucb->ssib.line.pb ) )
		{
		Assert( srid == sridT );
		}
	else
		{
		Assert( srid != sridT );
		}

	return;
	}
#else
#define NDICheckItemBookmark( pfucb, srid )
#endif

ERR ErrNDGetItem( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SRID	srid;

	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGetNode( pfucb, pcsr->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );
	Assert( pcsr->isrid >= 0 );

	srid = *( (SRID UNALIGNED *)pfucb->lineData.pb + pcsr->isrid );
	pcsr->item = BmNDOfItem( srid );

	if ( FNDItemVersion( srid ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS	ns;

		NDICheckItemBookmark( pfucb, pcsr->bm );
		ns = NsVERAccessItem( pfucb, pcsr->bm );
		if ( ns == nsInvalid || ( ns == nsDatabase && FNDItemDelete( srid ) ) )
			{
			return ErrERRCheck( errNDNoItem );
			}
		}
	else if ( FNDItemDelete( srid ) )
		{
		return ErrERRCheck( errNDNoItem );
		}

	/*	item should already be cached.
	/**/
	Assert( pcsr->item == BmNDOfItem( srid ) );

	return JET_errSuccess;
	}


ERR ErrNDFirstItem( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SRID	srid;

	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGetNode( pfucb, pcsr->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );

	/*	set isrid to first item.
	/**/
	pcsr->isrid = 0;

	srid = *(SRID UNALIGNED *)pfucb->lineData.pb;
	pcsr->item = BmNDOfItem( srid );

	if ( FNDItemVersion( srid ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS	ns;

		NDICheckItemBookmark( pfucb, pcsr->bm );
		ns = NsVERAccessItem( pfucb, pcsr->bm );
		if ( ns == nsInvalid ||
			( ns == nsDatabase && FNDItemDelete( srid ) ) )
			{
			return ErrERRCheck( errNDNoItem );
			}
		}
	else if ( FNDItemDelete( srid ) )
		{
		return ErrERRCheck( errNDNoItem );
		}

	pcsr->item = BmNDOfItem( srid );
	return JET_errSuccess;
	}


ERR ErrNDLastItem( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SRID	srid;

	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGetNode( pfucb, pcsr->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );

	pcsr->isrid = (SHORT) ( pfucb->lineData.cb / sizeof( SRID ) ) - 1;
	Assert( pcsr->isrid >= 0 );
	srid = *( (SRID UNALIGNED *)pfucb->lineData.pb + pcsr->isrid );
	pcsr->item = BmNDOfItem( srid );

	if ( FNDItemVersion( srid ) && !FPIBDirty( pfucb->ppib ) )
		{
		NS		ns;

		NDICheckItemBookmark( pfucb, pcsr->bm );
		ns = NsVERAccessItem( pfucb, pcsr->bm );
		if ( ns == nsInvalid ||	( ns == nsDatabase && FNDItemDelete( srid ) ) )
			{
			return ErrERRCheck( errNDNoItem );
			}
		}
	else if ( FNDItemDelete( srid ) )
		{
		return ErrERRCheck( errNDNoItem );
		}

	pcsr->item = BmNDOfItem( srid );
	return JET_errSuccess;
	}


ERR ErrNDNextItem( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SRID	srid;

	AssertFBFReadAccessPage( pfucb, pcsr->pgno );
	AssertNDGetNode( pfucb, pcsr->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );

	forever
		{
		/*	common case will be no next srid.
		/**/
		Assert( pcsr->isrid < ( INT ) ( pfucb->lineData.cb / sizeof( SRID ) ) );
		if ( pcsr->isrid == ( INT ) ( pfucb->lineData.cb / sizeof( SRID ) ) - 1 )
			{
			return ErrERRCheck( FNDLastItem( *( pfucb->ssib.line.pb ) ) ?
				errNDLastItemNode : errNDNoItem );
			}

		/*	move to next srid.
		/**/
		pcsr->isrid++;
		Assert( pcsr->isrid >= 0 && pcsr->isrid < ( INT ) ( pfucb->lineData.cb / sizeof( SRID ) ) );
		srid = *( (SRID UNALIGNED *)pfucb->lineData.pb + pcsr->isrid );
		pcsr->item = BmNDOfItem( srid );

		/*	break if find valid item.
		/**/
		if ( FNDItemVersion( srid ) && !FPIBDirty( pfucb->ppib ) )
			{
			NS	ns;

			NDICheckItemBookmark( pfucb, pcsr->bm );
			ns = NsVERAccessItem( pfucb, pcsr->bm );
			if ( ns == nsVersion ||
				( ns == nsDatabase && !FNDItemDelete( srid ) ) )
				{
				break;
				}
			}
		else
			{
			if ( !FNDItemDelete( srid ) )
				break;
			}
		}

	return JET_errSuccess;
	}


ERR ErrNDPrevItem( FUCB *pfucb )
	{
	CSR		*pcsr = PcsrCurrent( pfucb );
	SRID	srid;

	AssertFBFReadAccessPage( pfucb, PcsrCurrent( pfucb )->pgno );
	AssertNDGetNode( pfucb, pcsr->itag );
	Assert( pfucb->lineData.cb >= sizeof( SRID ) );

	forever
		{
		/*	common case will be no next srid.
		/**/
		if ( pcsr->isrid < 1 )
			{
			return ErrERRCheck( FNDFirstItem( *( pfucb->ssib.line.pb ) ) ?
				errNDFirstItemNode : errNDNoItem );
			}

		/*	move to next srid.
		/**/
		pcsr->isrid--;
		Assert( pcsr->isrid >= 0 && pcsr->isrid < ( INT ) ( pfucb->lineData.cb / sizeof( SRID ) ) );
		srid = *( (SRID UNALIGNED *)pfucb->lineData.pb + pcsr->isrid );
		pcsr->item = BmNDOfItem( srid );

		/*	break if find valid item.
		/**/
		if ( FNDItemVersion( srid ) && !FPIBDirty( pfucb->ppib ) )
			{
			NS		ns;

			NDICheckItemBookmark( pfucb, pcsr->bm );
			ns = NsVERAccessItem( pfucb, pcsr->bm );
			if ( ns == nsVersion ||
				( ns == nsDatabase && !FNDItemDelete( srid ) ) )
				{
				break;
				}
			}
		else
			{
			if ( !FNDItemDelete( srid ) )
				break;
			}
		}

	return JET_errSuccess;
	}


/* locate th