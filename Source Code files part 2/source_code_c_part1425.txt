_rgCOMRegSchemaDataRW,
	g_cbCOMRegSchemaRW,
	g_rgCOMRegSchemaDataRO,
	g_cbCOMRegSchemaRO,
	g_rgCOMRegSchemaStringHeap,
	g_cbCOMRegSchemaStringHeap
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\comregstructs.h ===
//*****************************************************************************
// Structures for comregStructs.h
// 4/23/1999  16:29:46
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
#include "icmprecs.h"


// Script supplied data.





#define COMRegTABLENAMELIST() \
	TABLENAME( Application ) \
	TABLENAME( ComputerList ) \
	TABLENAME( CustomActivator ) \
	TABLENAME( LocalComputer ) \
	TABLENAME( ClassesInternal ) \
	TABLENAME( RoleDef ) \
	TABLENAME( RoleConfig ) \
	TABLENAME( RoleSDCache ) \
	TABLENAME( ClassItfMethod ) \
	TABLENAME( ClassInterfaceDispID ) \
	TABLENAME( ClassInterface ) \
	TABLENAME( RoleSet ) \
	TABLENAME( StartServices ) \
	TABLENAME( IMDBDataSources ) \
	TABLENAME( IMDB ) \
	TABLENAME( ServerGroup ) 


#undef TABLENAME
#define TABLENAME( TblName ) TABLENUM_COMReg_##TblName, 
enum
{
	COMRegTABLENAMELIST()
};

#define COMReg_TABLE_COUNT 16
extern const GUID DECLSPEC_SELECTANY SCHEMA_COMReg = { 0x00100100, 0x0000, 0x0000, {  0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }};
extern const COMPLIBSCHEMA DECLSPEC_SELECTANY COMRegSchema = 
{
	&SCHEMA_COMReg,
	5
};


#define SCHEMA_COMReg_Name "COMReg"


#include "pshpack1.h"


//*****************************************************************************
//  COMReg.Application
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID ApplID;
    ULONG cbApplNameLen;
    wchar_t ApplName[260];
    unsigned long Flags;
    ULONG cbServerNameLen;
    wchar_t ServerName[260];
    unsigned long ProcessType;
    ULONG cbCommandLineLen;
    wchar_t CommandLine[260];
    ULONG cbServiceNameLen;
    wchar_t ServiceName[256];
    unsigned long RunAsUserType;
    ULONG cbRunAsUserLen;
    wchar_t RunAsUser[260];
    ULONG cbAccessPermissionLen;
    BYTE AccessPermission[260];
    ULONG cbDescriptionLen;
    wchar_t Description[260];
    ULONG cbIsSystemLen;
    wchar_t IsSystem[2];
    unsigned long Authentication;
    unsigned long ShutdownAfter;
    ULONG cbRunForeverLen;
    wchar_t RunForever[2];
    ULONG cbReserved1Len;
    wchar_t Reserved1[81];
    BYTE pad00 [2];
    ULONG cbActivationLen;
    wchar_t Activation[21];
    BYTE pad01 [2];
    ULONG cbChangeableLen;
    wchar_t Changeable[2];
    ULONG cbDeleteableLen;
    wchar_t Deleteable[2];
    ULONG cbCreatedByLen;
    wchar_t CreatedBy[256];
    ULONG cbQueueBlobLen;
    BYTE QueueBlob[260];
    unsigned long RoleBasedSecuritySupported;
    unsigned long RoleBasedSecurityEnabled;
    ULONG cbSecurityDescriptorLen;
    BYTE SecurityDescriptor[260];
    unsigned long ImpersonationLevel;
    unsigned long AuthenticationCapability;
    unsigned long CRMEnabled;
    unsigned long Enable3GigSupport;
    unsigned long IsQueued;
    ULONG cbQCListenerEnabledLen;
    wchar_t QCListenerEnabled[2];
    unsigned long EventsEnabled;
    unsigned long ProcessFlags;
    unsigned long ThreadMax;
    unsigned long IsProxyApp;
    ULONG cbCrmLogFileLen;
    wchar_t CrmLogFile[260];

	inline int IsCrmLogFileNull(void)
	{ return (GetBit(fNullFlags, 35)); }

	inline void SetCrmLogFileNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 35, nullBitVal); }

	inline int IsQCListenerEnabledNull(void)
	{ return (GetBit(fNullFlags, 30)); }

	inline void SetQCListenerEnabledNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 30, nullBitVal); }

	inline int IsSecurityDescriptorNull(void)
	{ return (GetBit(fNullFlags, 24)); }

	inline void SetSecurityDescriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 24, nullBitVal); }

	inline int IsQueueBlobNull(void)
	{ return (GetBit(fNullFlags, 21)); }

	inline void SetQueueBlobNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 21, nullBitVal); }

	inline int IsCreatedByNull(void)
	{ return (GetBit(fNullFlags, 20)); }

	inline void SetCreatedByNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 20, nullBitVal); }

	inline int IsActivationNull(void)
	{ return (GetBit(fNullFlags, 17)); }

	inline void SetActivationNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 17, nullBitVal); }

	inline int IsReserved1Null(void)
	{ return (GetBit(fNullFlags, 16)); }

	inline void SetReserved1Null(int nullBitVal = true)
	{ SetBit(fNullFlags, 16, nullBitVal); }

	inline int IsRunForeverNull(void)
	{ return (GetBit(fNullFlags, 15)); }

	inline void SetRunForeverNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 15, nullBitVal); }

	inline int IsIsSystemNull(void)
	{ return (GetBit(fNullFlags, 12)); }

	inline void SetIsSystemNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 12, nullBitVal); }

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 11)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 11, nullBitVal); }

	inline int IsAccessPermissionNull(void)
	{ return (GetBit(fNullFlags, 10)); }

	inline void SetAccessPermissionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 10, nullBitVal); }

	inline int IsRunAsUserNull(void)
	{ return (GetBit(fNullFlags, 9)); }

	inline void SetRunAsUserNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 9, nullBitVal); }

	inline int IsServiceNameNull(void)
	{ return (GetBit(fNullFlags, 7)); }

	inline void SetServiceNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 7, nullBitVal); }

	inline int IsCommandLineNull(void)
	{ return (GetBit(fNullFlags, 6)); }

	inline void SetCommandLineNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 6, nullBitVal); }

	inline int IsServerNameNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetServerNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsApplNameNull(void)
	{ return (GetBit(fNullFlags, 2)); }

	inline void SetApplNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 2, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_Application));
         fNullFlags = (ULONG) -1;
    }

} COMReg_Application;

#define COLID_COMReg_Application_ApplID 1
#define COLID_COMReg_Application_ApplName 2
#define COLID_COMReg_Application_Flags 3
#define COLID_COMReg_Application_ServerName 4
#define COLID_COMReg_Application_ProcessType 5
#define COLID_COMReg_Application_CommandLine 6
#define COLID_COMReg_Application_ServiceName 7
#define COLID_COMReg_Application_RunAsUserType 8
#define COLID_COMReg_Application_RunAsUser 9
#define COLID_COMReg_Application_AccessPermission 10
#define COLID_COMReg_Application_Description 11
#define COLID_COMReg_Application_IsSystem 12
#define COLID_COMReg_Application_Authentication 13
#define COLID_COMReg_Application_ShutdownAfter 14
#define COLID_COMReg_Application_RunForever 15
#define COLID_COMReg_Application_Reserved1 16
#define COLID_COMReg_Application_Activation 17
#define COLID_COMReg_Application_Changeable 18
#define COLID_COMReg_Application_Deleteable 19
#define COLID_COMReg_Application_CreatedBy 20
#define COLID_COMReg_Application_QueueBlob 21
#define COLID_COMReg_Application_RoleBasedSecuritySupported 22
#define COLID_COMReg_Application_RoleBasedSecurityEnabled 23
#define COLID_COMReg_Application_SecurityDescriptor 24
#define COLID_COMReg_Application_ImpersonationLevel 25
#define COLID_COMReg_Application_AuthenticationCapability 26
#define COLID_COMReg_Application_CRMEnabled 27
#define COLID_COMReg_Application_Enable3GigSupport 28
#define COLID_COMReg_Application_IsQueued 29
#define COLID_COMReg_Application_QCListenerEnabled 30
#define COLID_COMReg_Application_EventsEnabled 31
#define COLID_COMReg_Application_ProcessFlags 32
#define COLID_COMReg_Application_ThreadMax 33
#define COLID_COMReg_Application_IsProxyApp 34
#define COLID_COMReg_Application_CrmLogFile 35




//*****************************************************************************
//  COMReg.ComputerList
//*****************************************************************************
typedef struct
{
    ULONG cbNameLen;
    wchar_t Name[260];

    void Init()
    {
         memset(this, 0, sizeof(COMReg_ComputerList));
    }

} COMReg_ComputerList;

#define COLID_COMReg_ComputerList_Name 1




//*****************************************************************************
//  COMReg.CustomActivator
//*****************************************************************************
typedef struct
{
    GUID CompCLSID;
    unsigned long Stage;
    unsigned long Order;
    GUID ActivatorCLSID;

    void Init()
    {
         memset(this, 0, sizeof(COMReg_CustomActivator));
    }

} COMReg_CustomActivator;

#define COLID_COMReg_CustomActivator_CompCLSID 1
#define COLID_COMReg_CustomActivator_Stage 2
#define COLID_COMReg_CustomActivator_Order 3
#define COLID_COMReg_CustomActivator_ActivatorCLSID 4

#define Index_COMReg_MPK_CustomActivator "COMReg.MPK_CustomActivator"
#define Index_COMReg_Dex_Col0 "COMReg.Dex_Col0"



//*****************************************************************************
//  COMReg.LocalComputer
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    ULONG cbNameLen;
    wchar_t Name[260];
    ULONG cbDescriptionLen;
    wchar_t Description[260];
    unsigned long TransactionTimeout;
    ULONG cbPackageInstallPathLen;
    wchar_t PackageInstallPath[260];
    ULONG cbResourcePoolingEnabledLen;
    wchar_t ResourcePoolingEnabled[5];
    BYTE pad00 [2];
    ULONG cbReplicationShareLen;
    wchar_t ReplicationShare[260];
    ULONG cbRemoteServerNameLen;
    wchar_t RemoteServerName[260];
    unsigned long IMDBMemorySize;
    unsigned long IMDBReservedBlobMemory;
    ULONG cbIMDBLoadTablesDynamicallyLen;
    wchar_t IMDBLoadTablesDynamically[5];
    BYTE pad01 [2];
    ULONG cbIsRouterLen;
    wchar_t IsRouter[5];
    BYTE pad02 [2];
    ULONG cbEnableDCOMLen;
    wchar_t EnableDCOM[5];
    BYTE pad03 [2];
    unsigned long DefaultAuthenticationLevel;
    unsigned long DefaultImpersonationLevel;
    ULONG cbEnableSecurityTrackingLen;
    wchar_t EnableSecurityTracking[5];
    BYTE pad04 [2];
    unsigned long ActivityTimeout;
    ULONG cbIMDBEnabledLen;
    wchar_t IMDBEnabled[5];
    BYTE pad05 [2];

	inline int IsIMDBEnabledNull(void)
	{ return (GetBit(fNullFlags, 17)); }

	inline void SetIMDBEnabledNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 17, nullBitVal); }

	inline int IsEnableSecurityTrackingNull(void)
	{ return (GetBit(fNullFlags, 15)); }

	inline void SetEnableSecurityTrackingNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 15, nullBitVal); }

	inline int IsEnableDCOMNull(void)
	{ return (GetBit(fNullFlags, 12)); }

	inline void SetEnableDCOMNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 12, nullBitVal); }

	inline int IsIsRouterNull(void)
	{ return (GetBit(fNullFlags, 11)); }

	inline void SetIsRouterNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 11, nullBitVal); }

	inline int IsIMDBLoadTablesDynamicallyNull(void)
	{ return (GetBit(fNullFlags, 10)); }

	inline void SetIMDBLoadTablesDynamicallyNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 10, nullBitVal); }

	inline int IsRemoteServerNameNull(void)
	{ return (GetBit(fNullFlags, 7)); }

	inline void SetRemoteServerNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 7, nullBitVal); }

	inline int IsReplicationShareNull(void)
	{ return (GetBit(fNullFlags, 6)); }

	inline void SetReplicationShareNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 6, nullBitVal); }

	inline int IsPackageInstallPathNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetPackageInstallPathNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 2)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 2, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_LocalComputer));
         fNullFlags = (ULONG) -1;
    }

} COMReg_LocalComputer;

#define COLID_COMReg_LocalComputer_Name 1
#define COLID_COMReg_LocalComputer_Description 2
#define COLID_COMReg_LocalComputer_TransactionTimeout 3
#define COLID_COMReg_LocalComputer_PackageInstallPath 4
#define COLID_COMReg_LocalComputer_ResourcePoolingEnabled 5
#define COLID_COMReg_LocalComputer_ReplicationShare 6
#define COLID_COMReg_LocalComputer_RemoteServerName 7
#define COLID_COMReg_LocalComputer_IMDBMemorySize 8
#define COLID_COMReg_LocalComputer_IMDBReservedBlobMemory 9
#define COLID_COMReg_LocalComputer_IMDBLoadTablesDynamically 10
#define COLID_COMReg_LocalComputer_IsRouter 11
#define COLID_COMReg_LocalComputer_EnableDCOM 12
#define COLID_COMReg_LocalComputer_DefaultAuthenticationLevel 13
#define COLID_COMReg_LocalComputer_DefaultImpersonationLevel 14
#define COLID_COMReg_LocalComputer_EnableSecurityTracking 15
#define COLID_COMReg_LocalComputer_ActivityTimeout 16
#define COLID_COMReg_LocalComputer_IMDBEnabled 17




//*****************************************************************************
//  COMReg.ClassesInternal
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID CLSID;
    GUID ApplID;
    GUID ImplCLSID;
    unsigned long VersionMajor;
    unsigned long VersionMinor;
    unsigned long VersionBuild;
    unsigned long VersionSubBuild;
    unsigned long Locale;
    unsigned long ClassCtx;
    unsigned long Transaction;
    unsigned long Syncronization;
    unsigned long LoadBalanced;
    unsigned long IISIntrinsics;
    unsigned long ComTIIntrinsics;
    unsigned long JITActivation;
    unsigned long RoleBasedSecurityEnabled;
    ULONG cbSecurityDescriptorLen;
    BYTE SecurityDescriptor[260];
    GUID RoleSetID;
    unsigned long MinPoolSize;
    unsigned long MaxPoolSize;
    unsigned long CreationTimeout;
    ULONG cbConstructStringLen;
    wchar_t ConstructString[260];
    unsigned long ClassFlags;
    GUID DefaultInterface;
    unsigned long NoSetCompleteEtAlOption;
    ULONG cbSavedProgIdLen;
    wchar_t SavedProgId[260];
    GUID RegistrarCLSID;
    ULONG cbExceptionClassLen;
    wchar_t ExceptionClass[260];
    unsigned long IsSelfRegComponent;
    ULONG cbSelfRegInprocServerLen;
    wchar_t SelfRegInprocServer[260];
    unsigned long SelfRegThreadinModel;
    ULONG cbSelfRegProgIDLen;
    wchar_t SelfRegProgID[260];
    ULONG cbSelfRegDescriptionLen;
    wchar_t SelfRegDescription[260];
    ULONG cbSelfRegVIProgIDLen;
    wchar_t SelfRegVIProgID[260];
    unsigned long VbDebuggingFlags;
    unsigned long IsPublisher;
    ULONG cbPublisherIDLen;
    wchar_t PublisherID[260];
    GUID MIPFilterCLSID;
    unsigned long AllowInprocSubscribers;
    unsigned long FireInParalel;
    unsigned long SavedThreadinModel;
    ULONG cbSavedSelfRegVIProgIdLen;
    wchar_t SavedSelfRegVIProgId[260];

	inline int IsSavedSelfRegVIProgIdNull(void)
	{ return (GetBit(fNullFlags, 42)); }

	inline void SetSavedSelfRegVIProgIdNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 42, nullBitVal); }

	inline int IsMIPFilterCLSIDNull(void)
	{ return (GetBit(fNullFlags, 38)); }

	inline void SetMIPFilterCLSIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 38, nullBitVal); }

	inline int IsPublisherIDNull(void)
	{ return (GetBit(fNullFlags, 37)); }

	inline void SetPublisherIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 37, nullBitVal); }

	inline int IsSelfRegVIProgIDNull(void)
	{ return (GetBit(fNullFlags, 34)); }

	inline void SetSelfRegVIProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 34, nullBitVal); }

	inline int IsSelfRegDescriptionNull(void)
	{ return (GetBit(fNullFlags, 33)); }

	inline void SetSelfRegDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 33, nullBitVal); }

	inline int IsSelfRegProgIDNull(void)
	{ return (GetBit(fNullFlags, 32)); }

	inline void SetSelfRegProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 32, nullBitVal); }

	inline int IsSelfRegInprocServerNull(void)
	{ return (GetBit(fNullFlags, 30)); }

	inline void SetSelfRegInprocServerNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 30, nullBitVal); }

	inline int IsExceptionClassNull(void)
	{ return (GetBit(fNullFlags, 28)); }

	inline void SetExceptionClassNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 28, nullBitVal); }

	inline int IsRegistrarCLSIDNull(void)
	{ return (GetBit(fNullFlags, 27)); }

	inline void SetRegistrarCLSIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 27, nullBitVal); }

	inline int IsSavedProgIdNull(void)
	{ return (GetBit(fNullFlags, 26)); }

	inline void SetSavedProgIdNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 26, nullBitVal); }

	inline int IsDefaultInterfaceNull(void)
	{ return (GetBit(fNullFlags, 24)); }

	inline void SetDefaultInterfaceNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 24, nullBitVal); }

	inline int IsConstructStringNull(void)
	{ return (GetBit(fNullFlags, 22)); }

	inline void SetConstructStringNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 22, nullBitVal); }

	inline int IsRoleSetIDNull(void)
	{ return (GetBit(fNullFlags, 18)); }

	inline void SetRoleSetIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 18, nullBitVal); }

	inline int IsSecurityDescriptorNull(void)
	{ return (GetBit(fNullFlags, 17)); }

	inline void SetSecurityDescriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 17, nullBitVal); }

	inline int IsImplCLSIDNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetImplCLSIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

	inline int IsApplIDNull(void)
	{ return (GetBit(fNullFlags, 2)); }

	inline void SetApplIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 2, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_ClassesInternal));
         fNullFlags = (ULONG) -1;
    }

} COMReg_ClassesInternal;

#define COLID_COMReg_ClassesInternal_CLSID 1
#define COLID_COMReg_ClassesInternal_ApplID 2
#define COLID_COMReg_ClassesInternal_ImplCLSID 3
#define COLID_COMReg_ClassesInternal_VersionMajor 4
#define COLID_COMReg_ClassesInternal_VersionMinor 5
#define COLID_COMReg_ClassesInternal_VersionBuild 6
#define COLID_COMReg_ClassesInternal_VersionSubBuild 7
#define COLID_COMReg_ClassesInternal_Locale 8
#define COLID_COMReg_ClassesInternal_ClassCtx 9
#define COLID_COMReg_ClassesInternal_Transaction 10
#define COLID_COMReg_ClassesInternal_Syncronization 11
#define COLID_COMReg_ClassesInternal_LoadBalanced 12
#define COLID_COMReg_ClassesInternal_IISIntrinsics 13
#define COLID_COMReg_ClassesInternal_ComTIIntrinsics 14
#define COLID_COMReg_ClassesInternal_JITActivation 15
#define COLID_COMReg_ClassesInternal_RoleBasedSecurityEnabled 16
#define COLID_COMReg_ClassesInternal_SecurityDescriptor 17
#define COLID_COMReg_ClassesInternal_RoleSetID 18
#define COLID_COMReg_ClassesInternal_MinPoolSize 19
#define COLID_COMReg_ClassesInternal_MaxPoolSize 20
#define COLID_COMReg_ClassesInternal_CreationTimeout 21
#define COLID_COMReg_ClassesInternal_ConstructString 22
#define COLID_COMReg_ClassesInternal_ClassFlags 23
#define COLID_COMReg_ClassesInternal_DefaultInterface 24
#define COLID_COMReg_ClassesInternal_NoSetCompleteEtAlOption 25
#define COLID_COMReg_ClassesInternal_SavedProgId 26
#define COLID_COMReg_ClassesInternal_RegistrarCLSID 27
#define COLID_COMReg_ClassesInternal_ExceptionClass 28
#define COLID_COMReg_ClassesInternal_IsSelfRegComponent 29
#define COLID_COMReg_ClassesInternal_SelfRegInprocServer 30
#define COLID_COMReg_ClassesInternal_SelfRegThreadinModel 31
#define COLID_COMReg_ClassesInternal_SelfRegProgID 32
#define COLID_COMReg_ClassesInternal_SelfRegDescription 33
#define COLID_COMReg_ClassesInternal_SelfRegVIProgID 34
#define COLID_COMReg_ClassesInternal_VbDebuggingFlags 35
#define COLID_COMReg_ClassesInternal_IsPublisher 36
#define COLID_COMReg_ClassesInternal_PublisherID 37
#define COLID_COMReg_ClassesInternal_MIPFilterCLSID 38
#define COLID_COMReg_ClassesInternal_AllowInprocSubscribers 39
#define COLID_COMReg_ClassesInternal_FireInParalel 40
#define COLID_COMReg_ClassesInternal_SavedThreadinModel 41
#define COLID_COMReg_ClassesInternal_SavedSelfRegVIProgId 42

#define Index_COMReg_Dex_Col31 "COMReg.Dex_Col31"
#define Index_COMReg_Dex_Col33 "COMReg.Dex_Col33"



//*****************************************************************************
//  COMReg.RoleDef
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID Application;
    ULONG cbRoleNameLen;
    wchar_t RoleName[260];
    ULONG cbDescriptionLen;
    wchar_t Description[260];

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_RoleDef));
         fNullFlags = (ULONG) -1;
    }

} COMReg_RoleDef;

#define COLID_COMReg_RoleDef_Application 1
#define COLID_COMReg_RoleDef_RoleName 2
#define COLID_COMReg_RoleDef_Description 3

#define Index_COMReg_MPK_RoleDef "COMReg.MPK_RoleDef"



//*****************************************************************************
//  COMReg.RoleConfig
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID Application;
    ULONG cbRoleNameLen;
    wchar_t RoleName[260];
    ULONG cbRoleMembersLen;
    wchar_t RoleMembers[260];
    ULONG cbUserSIDLen;
    BYTE UserSID[44];

	inline int IsUserSIDNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetUserSIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_RoleConfig));
         fNullFlags = (ULONG) -1;
    }

} COMReg_RoleConfig;

#define COLID_COMReg_RoleConfig_Application 1
#define COLID_COMReg_RoleConfig_RoleName 2
#define COLID_COMReg_RoleConfig_RoleMembers 3
#define COLID_COMReg_RoleConfig_UserSID 4

#define Index_COMReg_MPK_RoleConfig "COMReg.MPK_RoleConfig"



//*****************************************************************************
//  COMReg.RoleSDCache
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID Application;
    ULONG cbRoleNameLen;
    wchar_t RoleName[260];
    ULONG cbSecurityDescriptorLen;
    BYTE SecurityDescriptor[260];

	inline int IsSecurityDescriptorNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetSecurityDescriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_RoleSDCache));
         fNullFlags = (ULONG) -1;
    }

} COMReg_RoleSDCache;

#define COLID_COMReg_RoleSDCache_Application 1
#define COLID_COMReg_RoleSDCache_RoleName 2
#define COLID_COMReg_RoleSDCache_SecurityDescriptor 3

#define Index_COMReg_MPK_RoleSDCache "COMReg.MPK_RoleSDCache"



//*****************************************************************************
//  COMReg.ClassItfMethod
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID ConfigClass;
    GUID Interface;
    unsigned long MethodIndex;
    ULONG cbSecurityDecriptorLen;
    BYTE SecurityDecriptor[260];
    GUID RoleSetID;
    ULONG cbMethodNameLen;
    wchar_t MethodName[260];
    unsigned long DispID;
    unsigned long Flags;
    unsigned long AutoComplete;
    ULONG cbDescriptionLen;
    wchar_t Description[260];

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 10)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 10, nullBitVal); }

	inline int IsFlagsNull(void)
	{ return (GetBit(fNullFlags, 8)); }

	inline void SetFlagsNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 8, nullBitVal); }

	inline int IsMethodNameNull(void)
	{ return (GetBit(fNullFlags, 6)); }

	inline void SetMethodNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 6, nullBitVal); }

	inline int IsRoleSetIDNull(void)
	{ return (GetBit(fNullFlags, 5)); }

	inline void SetRoleSetIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 5, nullBitVal); }

	inline int IsSecurityDecriptorNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetSecurityDecriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_ClassItfMethod));
         fNullFlags = (ULONG) -1;
    }

} COMReg_ClassItfMethod;

#define COLID_COMReg_ClassItfMethod_ConfigClass 1
#define COLID_COMReg_ClassItfMethod_Interface 2
#define COLID_COMReg_ClassItfMethod_MethodIndex 3
#define COLID_COMReg_ClassItfMethod_SecurityDecriptor 4
#define COLID_COMReg_ClassItfMethod_RoleSetID 5
#define COLID_COMReg_ClassItfMethod_MethodName 6
#define COLID_COMReg_ClassItfMethod_DispID 7
#define COLID_COMReg_ClassItfMethod_Flags 8
#define COLID_COMReg_ClassItfMethod_AutoComplete 9
#define COLID_COMReg_ClassItfMethod_Description 10

#define Index_COMReg_MPK_ClassItfMethod "COMReg.MPK_ClassItfMethod"
#define Index_COMReg_Dex_Col0 "COMReg.Dex_Col0"



//*****************************************************************************
//  COMReg.ClassInterfaceDispID
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID ConfigClass;
    GUID Interface;
    unsigned long DispID;
    ULONG cbSecurityDecriptorLen;
    BYTE SecurityDecriptor[260];

	inline int IsSecurityDecriptorNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetSecurityDecriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_ClassInterfaceDispID));
         fNullFlags = (ULONG) -1;
    }

} COMReg_ClassInterfaceDispID;

#define COLID_COMReg_ClassInterfaceDispID_ConfigClass 1
#define COLID_COMReg_ClassInterfaceDispID_Interface 2
#define COLID_COMReg_ClassInterfaceDispID_DispID 3
#define COLID_COMReg_ClassInterfaceDispID_SecurityDecriptor 4

#define Index_COMReg_MPK_ClassInterfaceDispID "COMReg.MPK_ClassInterfaceDispID"
#define Index_COMReg_Dex_Col0 "COMReg.Dex_Col0"



//*****************************************************************************
//  COMReg.ClassInterface
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID ConfigClass;
    GUID Interface;
    ULONG cbInterfaceNameLen;
    wchar_t InterfaceName[260];
    ULONG cbSecurityDecriptorLen;
    BYTE SecurityDecriptor[260];
    GUID RoleSetId;
    unsigned long IsDispatchable;
    unsigned long IsQueueable;
    unsigned long IsQueueingSupported;
    ULONG cbDescriptionLen;
    wchar_t Description[260];

	inline int IsDescriptionNull(void)
	{ return (GetBit(fNullFlags, 9)); }

	inline void SetDescriptionNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 9, nullBitVal); }

	inline int IsRoleSetIdNull(void)
	{ return (GetBit(fNullFlags, 5)); }

	inline void SetRoleSetIdNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 5, nullBitVal); }

	inline int IsSecurityDecriptorNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetSecurityDecriptorNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsInterfaceNameNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetInterfaceNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_ClassInterface));
         fNullFlags = (ULONG) -1;
    }

} COMReg_ClassInterface;

#define COLID_COMReg_ClassInterface_ConfigClass 1
#define COLID_COMReg_ClassInterface_Interface 2
#define COLID_COMReg_ClassInterface_InterfaceName 3
#define COLID_COMReg_ClassInterface_SecurityDecriptor 4
#define COLID_COMReg_ClassInterface_RoleSetId 5
#define COLID_COMReg_ClassInterface_IsDispatchable 6
#define COLID_COMReg_ClassInterface_IsQueueable 7
#define COLID_COMReg_ClassInterface_IsQueueingSupported 8
#define COLID_COMReg_ClassInterface_Description 9

#define Index_COMReg_MPK_ClassInterface "COMReg.MPK_ClassInterface"
#define Index_COMReg_Dex_Col0 "COMReg.Dex_Col0"



//*****************************************************************************
//  COMReg.RoleSet
//*****************************************************************************
typedef struct
{
    GUID RoleSetID;
    ULONG cbRoleNameLen;
    wchar_t RoleName[260];
    GUID Application;

    void Init()
    {
         memset(this, 0, sizeof(COMReg_RoleSet));
    }

} COMReg_RoleSet;

#define COLID_COMReg_RoleSet_RoleSetID 1
#define COLID_COMReg_RoleSet_RoleName 2
#define COLID_COMReg_RoleSet_Application 3

#define Index_COMReg_MPK_RoleSet "COMReg.MPK_RoleSet"



//*****************************************************************************
//  COMReg.StartServices
//*****************************************************************************
typedef struct
{
    GUID ApplOrProcessId;
    GUID ServiceCLSID;

    void Init()
    {
         memset(this, 0, sizeof(COMReg_StartServices));
    }

} COMReg_StartServices;

#define COLID_COMReg_StartServices_ApplOrProcessId 1
#define COLID_COMReg_StartServices_ServiceCLSID 2

#define Index_COMReg_MPK_StartServices "COMReg.MPK_StartServices"
#define Index_COMReg_Dex_Col0 "COMReg.Dex_Col0"



//*****************************************************************************
//  COMReg.IMDBDataSources
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    ULONG cbDataSourceLen;
    wchar_t DataSource[131];
    BYTE pad00 [2];
    ULONG cbOLEDBProviderNameLen;
    wchar_t OLEDBProviderName[131];
    BYTE pad01 [2];
    ULONG cbServerLen;
    wchar_t Server[131];
    BYTE pad02 [2];
    ULONG cbDatabaseLen;
    wchar_t Database[131];
    BYTE pad03 [2];
    ULONG cbProviderSpecificPropertyLen;
    wchar_t ProviderSpecificProperty[260];

	inline int IsProviderSpecificPropertyNull(void)
	{ return (GetBit(fNullFlags, 5)); }

	inline void SetProviderSpecificPropertyNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 5, nullBitVal); }

	inline int IsDatabaseNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetDatabaseNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsServerNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetServerNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

	inline int IsOLEDBProviderNameNull(void)
	{ return (GetBit(fNullFlags, 2)); }

	inline void SetOLEDBProviderNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 2, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_IMDBDataSources));
         fNullFlags = (ULONG) -1;
    }

} COMReg_IMDBDataSources;

#define COLID_COMReg_IMDBDataSources_DataSource 1
#define COLID_COMReg_IMDBDataSources_OLEDBProviderName 2
#define COLID_COMReg_IMDBDataSources_Server 3
#define COLID_COMReg_IMDBDataSources_Database 4
#define COLID_COMReg_IMDBDataSources_ProviderSpecificProperty 5




//*****************************************************************************
//  COMReg.IMDB
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    ULONG cbTableNameLen;
    wchar_t TableName[131];
    BYTE pad00 [2];
    ULONG cbDataSourceLen;
    wchar_t DataSource[131];
    BYTE pad01 [2];
    ULONG cbBLOBonLoadLen;
    wchar_t BLOBonLoad[2];

	inline int IsBLOBonLoadNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetBLOBonLoadNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(COMReg_IMDB));
         fNullFlags = (ULONG) -1;
    }

} COMReg_IMDB;

#define COLID_COMReg_IMDB_TableName 1
#define COLID_COMReg_IMDB_DataSource 2
#define COLID_COMReg_IMDB_BLOBonLoad 3

#define Index_COMReg_MPK_IMDB "COMReg.MPK_IMDB"



//*****************************************************************************
//  COMReg.ServerGroup
//*****************************************************************************
typedef struct
{
    ULONG cbServerNameLen;
    wchar_t ServerName[260];

    void Init()
    {
         memset(this, 0, sizeof(COMReg_ServerGroup));
    }

} COMReg_ServerGroup;

#define COLID_COMReg_ServerGroup_ServerName 1




#include "poppack.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\coremacros.h ===
#ifndef __COREMACROS_H__
#define __COREMACROS_H__

#pragma message("__COREMACROS_H__ included")

//+----------------------------------------------------------------------------
//
//  TRACE  -- send output to the Debugger window
//
//  TRACE() is like printf(), with some exceptions. First, it writes to the
//  debugger window, not to stdout. Second, it disappears when _DEBUG is not
//  set(actually, its arguments turn into a comma expression when _DEBUG is
//  not set, but that usually amounts to the same thing.
//
//	Example
//
//	hr = SomeApi(params, somemoreparams);
//	if(FAILED(hr))
//	{
//		TRACE(L"SomeApi failed with hr = %08x", hr);
//		return hr;
//	}
//
//-----------------------------------------------------------------------------

#include <dbgutil.h>
#include <functracer.h>

#undef TRACE
// #ifdef _DEBUG

//
// Cannot inline with variable # of args
// So, printed line number and filename will be for this file
// and not where trace was called from.
//

static void TRACE(LPWSTR msg, ...)
{
    va_list argsList;

    if (g_fErrorFlags & DEBUG_FLAGS_WARN) 
    {
        __try 
        {
            va_start(argsList, msg);
            VPuDbgPrintW(g_pDebug, __FILE__, __LINE__, msg, argsList);
            va_end(argsList);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }
}

static void TRACE0(LPWSTR msg, ...)
{
    va_list argsList;

    if (g_fErrorFlags & DEBUG_FLAGS_WARN) 
    {
        __try 
        {
            va_start(argsList, msg);
            VPuDbgPrintW(g_pDebug, __FILE__, __LINE__, msg, argsList);
            va_end(argsList);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }
}

static void TRACE1(LPWSTR msg, ...)
{
    va_list argsList;

    if (g_fErrorFlags & DEBUG_FLAGS_WARN) 
    {
        __try 
        {
            va_start(argsList, msg);
            VPuDbgPrintW(g_pDebug, __FILE__, __LINE__, msg, argsList);
            va_end(argsList);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }
}

static void TRACE2(LPWSTR msg, ...)
{
    va_list argsList;

    if (g_fErrorFlags & DEBUG_FLAGS_WARN) 
    {
        __try 
        {
            va_start(argsList, msg);
            VPuDbgPrintW(g_pDebug, __FILE__, __LINE__, msg, argsList);
            va_end(argsList);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }
}

static void TRACE3(LPWSTR msg, ...)
{
    va_list argsList;

    if (g_fErrorFlags & DEBUG_FLAGS_WARN) 
    {
        __try 
        {
            va_start(argsList, msg);
            VPuDbgPrintW(g_pDebug, __FILE__, __LINE__, msg, argsList);
            va_end(argsList);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }
}

// #endif


// helper macro to get the line number and file name
#define JIMBORULES(x) L ## x
#define W(x) JIMBORULES(x)


//+----------------------------------------------------------------------------
//
//  ASSERT  -- displays a dialog box in free builds. It does nothing in 
//	debug builds. The dialog box contains the line number, file name, and the stack
//  if symbols are available
//
//	This macro should be used only to check for conditions that should never occur
//
//-----------------------------------------------------------------------------
#undef ASSERT
#ifdef _DEBUG

    #define ASSERT(bool) \
                { if(!(bool)) Assert(W(#bool), W(__FILE__), __LINE__); }
    #define VERIFY(b) ASSERT(b)

#else //_RELASE build

    #define ASSERT(bool)
    #define VERIFY(b)          ((void)(b))

#endif


//+----------------------------------------------------------------------------
//
// These are the functions that implement the above macros. You shouldn't
//  call them unless you're one of these macros.
//
//-----------------------------------------------------------------------------
void Assert(const wchar_t * szString, const wchar_t * szFile, int nLine);
void Trace(const wchar_t* szPattern, ...);

#if defined(__cplusplus)
//-------------------------------------------------------------------------
//
//	Memory allocation functions: they just point to com memory allocator 
//	functions for now, but we can change them later
//
//-------------------------------------------------------------------------

inline void* __cdecl operator new[] (size_t cb)
{
	return CoTaskMemAlloc(cb);
}

inline void* __cdecl operator new (size_t cb)
{
	return CoTaskMemAlloc(cb);
}

inline void __cdecl operator delete [] (void* pv) 
{
	CoTaskMemFree(pv);
}

inline void __cdecl operator delete (void* pv) 
{
	CoTaskMemFree(pv);
}
#endif

#endif // __COREMACROS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\cor.h ===
//*****************************************************************************
// File: COR.H
//
// Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
// Microsoft Confidential.
//*****************************************************************************
#ifndef _COR_H_
#define _COR_H_
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef __cplusplus
extern "C" {
#endif

#define CUSTOM_VALUE_TYPE	// Define this to give Type semantics to custom values (instead of blob)


//*****************************************************************************
// Required includes
#include <ole2.h>                       // Definitions of OLE types.    
//*****************************************************************************

#ifndef DECLSPEC_SELECT_ANY
#define DECLSPEC_SELECT_ANY __declspec(selectany)
#endif // DECLSPEC_SELECT_ANY

// {BED7F4EA-1A96-11d2-8F08-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY LIBID_ComPlusRuntime = 
{ 0xbed7f4ea, 0x1a96, 0x11d2, { 0x8f, 0x8, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

// {90883F05-3D28-11D2-8F17-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY GUID_ExportedFromComPlus = 
{ 0x90883f05, 0x3d28, 0x11d2, { 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };


// CLSID_CorMetaDataDispenserRuntime: {1EC2DE53-75CC-11d2-9775-00A0C9B4D50C}
//  Dispenser coclass for version 1.5 and 2.0 meta data.  To get the "latest" bind  
//  to CLSID_MetaDataDispenser. 
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserRuntime = 
{ 0x1ec2de53, 0x75cc, 0x11d2, { 0x97, 0x75, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataRuntime: {1EC2DE54-75CC-11d2-9775-00A0C9B4D50C}
//  For COM+ 2.0 Meta Data, managed program meta data.  
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataRuntime = 
{ 0x1ec2de54, 0x75cc, 0x11d2, { 0x97, 0x75, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };



// Use this GUID if you are generating the new local var sig
// {EEED7161-D7FA-11d2-9420-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataRuntime_2 =
{ 0xeeed7161, 0xd7fa, 0x11d2, { 0x94, 0x20, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };



// {90883F06-3D28-11D2-8F17-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY GUID_ImportedToComPlus = 
{ 0x90883f06, 0x3d28, 0x11d2, { 0x8f, 0x17, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };
extern const char DECLSPEC_SELECT_ANY szGUID_ImportedToComPlus[] = "{90883F06-3D28-11D2-8F17-00A0C9A6186D}";
extern const WCHAR DECLSPEC_SELECT_ANY wzGUID_ImportedToComPlus[] = L"{90883F06-3D28-11D2-8F17-00A0C9A6186D}";

// {30FE7BE8-D7D9-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataCheckDuplicatesFor =
{ 0x30fe7be8, 0xd7d9, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

// {DE3856F8-D7D9-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataRefToDefCheck =
{ 0xde3856f8, 0xd7d9, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

// {E5D71A4C-D7DA-11D2-9F80-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataNotificationForTokenMovement = 
{ 0xe5d71a4c, 0xd7da, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };


// {2eee315c-d7db-11d2-9f80-00c04f79a0a3}
extern const GUID DECLSPEC_SELECT_ANY MetaDataSetUpdate = 
{ 0x2eee315c, 0xd7db, 0x11d2, { 0x9f, 0x80, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

#define MetaDataSetENC MetaDataSetUpdate

// Use this guid in SetOption to indicate if the import enumerator should skip over 
// delete items or not. The default is yes.
//
// {79700F36-4AAC-11d3-84C3-009027868CB1}
extern const GUID DECLSPEC_SELECT_ANY MetaDataImportOption = 
{ 0x79700f36, 0x4aac, 0x11d3, { 0x84, 0xc3, 0x0, 0x90, 0x27, 0x86, 0x8c, 0xb1 } };


// Use this guid in the SetOption if compiler wants error when some tokens are emitted out of order
// {1547872D-DC03-11d2-9420-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY MetaDataErrorIfEmitOutOfOrder = 
{ 0x1547872d, 0xdc03, 0x11d2, { 0x94, 0x20, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


// Use this guid in the SetOption to indicate if the tlbimporter should generate the
// TCE adapters for COM connection point containers.
// {DCC9DE90-4151-11d3-88D6-00902754C43A}
extern const GUID DECLSPEC_SELECT_ANY MetaDataGenerateTCEAdapters = 
{ 0xdcc9de90, 0x4151, 0x11d3, { 0x88, 0xd6, 0x0, 0x90, 0x27, 0x54, 0xc4, 0x3a } };


// Use this guid in the SetOption to specifiy a non-default namespace for typelib import.
// {F17FF889-5A63-11d3-9FF2-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY MetaDataTypeLibImportNamespace = 
{ 0xf17ff889, 0x5a63, 0x11d3, { 0x9f, 0xf2, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };


interface IMetaDataImport;
interface IMetaDataEmit;
interface IMetaDataDebugEmit;
interface IMetaDataDebugImport;
interface ICeeGen;


//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C   E N T R Y    P O I N T   D E C L A R A T I O N S   
//
//*****************************************************************************
//*****************************************************************************

#ifdef UNDER_CE
BOOL STDMETHODCALLTYPE _CorDllMain(HINSTANCE hInst,
                                   DWORD dwReason,  
                                   LPVOID lpReserved,   
                                   LPVOID pDllBase, 
                                   DWORD dwRva14,   
                                   DWORD dwSize14); 

__int32 STDMETHODCALLTYPE _CorExeMain(HINSTANCE hInst,
                                      HINSTANCE hPrevInst,  
                                      LPWSTR lpCmdLine, 
                                      int nCmdShow, 
                                      LPVOID pExeBase,  
                                      DWORD dwRva14,    
                                      DWORD dwSize14);  

#else //!UNDER_CE
BOOL STDMETHODCALLTYPE _CorDllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);
__int32 STDMETHODCALLTYPE _CorExeMain();
#endif // UNDER_CE
__int32 STDMETHODCALLTYPE _CorClassMain(LPWSTR entryClassName);

STDAPI          CoInitializeEE(DWORD fFlags);   
STDAPI_(void)   CoUninitializeEE(BOOL fFlags);  

//
// CoInitializeCor flags.
//
typedef enum tagCOINITCOR
{
    COINITCOR_DEFAULT       = 0x0           // Default initialization mode. 
} COINITICOR;

//
// CoInitializeEE flags.
//
typedef enum tagCOINITEE
{
    COINITEE_DEFAULT        = 0x0,          // Default initialization mode. 
    COINITEE_DLL            = 0x1           // Initialization mode for loading DLL. 
} COINITIEE;

//
// CoInitializeEE flags.
//
typedef enum tagCOUNINITEE
{
    COUNINITEE_DEFAULT      = 0x0,          // Default uninitialization mode.   
    COUNINITEE_DLL          = 0x1           // Uninitialization mode for unloading DLL. 
} COUNINITIEE;

//*****************************************************************************
//*****************************************************************************
//
// I L   &   F I L E   F O R M A T   D E C L A R A T I O N S    
//
//*****************************************************************************
//*****************************************************************************


// The following definitions will get moved into <windows.h> by RTM but are
// kept here for the Alpha's and Beta's.
#ifndef _WINDOWS_UDPATES_
#include <corhdr.h>
#endif // <windows.h> updates

//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C	 E N T R Y	  P O I N T   D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************

STDAPI			CoInitializeCor(DWORD fFlags);
STDAPI_(void)	CoUninitializeCor(void);


#include <pshpack1.h>

#include <poppack.h>

//
//*****************************************************************************
//*****************************************************************************

// Forward declaration
typedef struct tagQUERYCONTEXT QUERYCONTEXT;


// CLSID_Cor: {bee00000-ee77-11d0-a015-00c04fbbb884}
extern const GUID DECLSPEC_SELECT_ANY CLSID_Cor = 
{ 0xbee00010, 0xee77, 0x11d0, {0xa0, 0x15, 0x00, 0xc0, 0x4f, 0xbb, 0xb8, 0x84 } };

// CLSID_CorMetaDataDispenser: {E5CB7A31-7512-11d2-89CE-0080C792E5D8}
//	This is the "Master Dispenser", always guaranteed to be the most recent
//	dispenser on the machine.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenser = 
{ 0xe5cb7a31, 0x7512, 0x11d2, { 0x89, 0xce, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };


// CLSID_CorMetaDataDispenserReg: {435755FF-7397-11d2-9771-00A0C9B4D50C}
//	Dispenser coclass for version 1.0 meta data.  To get the "latest" bind
//	to CLSID_CorMetaDataDispenser.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserReg = 
{ 0x435755ff, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataReg: {87F3A1F5-7397-11d2-9771-00A0C9B4D50C}
// For COM+ 1.0 Meta Data, Data Driven Registration
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataReg = 
{ 0x87f3a1f5, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

// IID_IMetaDataInternal {02D601BB-C5B9-11d1-93F9-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataInternal = 
{ 0x2d601bb, 0xc5b9, 0x11d1, {0x93, 0xf9, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };

interface IMetaDataDispenser;

//-------------------------------------
//--- IMetaDataError
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataError =
{ 0xb81ff171, 0x20f3, 0x11d2, { 0x8d, 0xcc, 0x0, 0xa0, 0xc9, 0xb0, 0x9c, 0x19 } };

//---
#undef	INTERFACE
#define INTERFACE IMetaDataError
DECLARE_INTERFACE_(IMetaDataError, IUnknown)
{
	STDMETHOD(OnError)(HRESULT hrError, mdToken token) PURE;
};

//-------------------------------------
//--- IMapToken
//-------------------------------------
//---
// IID_IMapToken: {06A3EA8B-0225-11d1-BF72-00C04FC31E12}
extern const GUID DECLSPEC_SELECT_ANY IID_IMapToken = 
{ 0x6a3ea8b, 0x225, 0x11d1, {0xbf, 0x72, 0x0, 0xc0, 0x4f, 0xc3, 0x1e, 0x12 } };
//---
#undef	INTERFACE
#define INTERFACE IMapToken
DECLARE_INTERFACE_(IMapToken, IUnknown)
{
	STDMETHOD(Map)(ULONG tkImp, ULONG tkEmit) PURE;
};

//-------------------------------------
//--- IMetaDataDispenser
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenser =
{ 0x809c652e, 0x7396, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
#undef	INTERFACE
#define INTERFACE IMetaDataDispenser
DECLARE_INTERFACE_(IMetaDataDispenser, IUnknown)
{
	STDMETHOD(DefineScope)( 				// Return code.
		REFCLSID	rclsid, 				// [in] What version to create.
		DWORD		dwCreateFlags,			// [in] Flags on the create.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

	STDMETHOD(OpenScope)(					// Return code.
		LPCWSTR 	szScope,				// [in] The scope to open.
		DWORD		dwOpenFlags,			// [in] Open mode flags.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

	STDMETHOD(OpenScopeOnMemory)(			// Return code.
		LPCVOID 	pData,					// [in] Location of scope data.
		ULONG		cbData, 				// [in] Size of the data pointed to by pData.
		DWORD		dwOpenFlags,			// [in] Open mode flags.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

};

//-------------------------------------
//--- IMetaDataEmit
//-------------------------------------

// {9ADD31A0-624B-11D3-824A-00902710145E}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataEmit =
{ 0x9add31a0, 0x624b, 0x11d3, { 0x82, 0x4a, 0x0, 0x90, 0x27, 0x10, 0x14, 0x5e } };

// {F3DDD0C2-79A9-11d2-941B-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataEmitOLD =
{ 0xf3ddd0c2, 0x79a9, 0x11d2, { 0x94, 0x1b, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataEmit
DECLARE_INTERFACE_(IMetaDataEmit, IUnknown)
{
    STDMETHOD(SetModuleProps)(              // S_OK or error.
        LPCWSTR     szName,                 // [IN] If not NULL, the name to set.
        const GUID  *ppid,                  // [IN] If not NULL, the GUID to set.
        LCID        lcid) PURE;             // [IN] If not -1, the lcid to set.

    STDMETHOD(Save)(                        // S_OK or error.
        LPCWSTR     szFile,                 // [IN] The filename to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(SaveToStream)(                // S_OK or error.
        IStream     *pIStream,              // [IN] A writable stream to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(GetSaveSize)(                 // S_OK or error.
        CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
        DWORD       *pdwSaveSize) PURE;     // [OUT] Put the size here.

    STDMETHOD(Merge)(                       // S_OK or error.
        IMetaDataImport *pImport,           // [IN] The scope to be merged.
        IMapToken   *pIMap) PURE;           // [IN] An object to receive token remap notices.

// Deprecated               
    STDMETHOD(DefineCustomValueAsBlob)(
        mdToken     tkObj, 
        LPCWSTR     szName, 
        void const  *pCustomValue, 
        ULONG       cbCustomValue, 
        mdCustomValue *pcv) PURE;
// Deprecated               

    STDMETHOD(DefineTypeDef)(               // S_OK or error.
        LPCWSTR     szNamespace,            // [IN] Namespace that the TypeDef is in. Must be 0 in '98
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        const GUID  *pguid,                 // [IN] Optional clsid
        CLASSVERSION *pVer,                 // [IN] Optional version
        DWORD       dwTypeDefFlags,         // [IN] CustomValue flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        DWORD       dwExtendsFlags,         // [IN] Extends flags
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdToken     rtkEvents[],            // [IN] Events interfaces
        mdTypeDef   *ptd) PURE;             // [OUT] Put TypeDef token here

    STDMETHOD(SetHandler)(                  // S_OK.
        IUnknown    *pUnk) PURE;            // [IN] The new error handler.
    
    STDMETHOD(DefineMethod)(                // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwMethodFlags,          // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        ULONG       ulCodeRVA,  
        DWORD       dwImplFlags,    
        mdMethodDef *pmd) PURE;             // Put member token here    

    STDMETHOD(DefineField)(                 // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwFieldFlags,           // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        mdFieldDef     *pmd) PURE;          // Put member token here    

    STDMETHOD(DefineMethodImpl)(            // S_OK or error.   
        mdTypeDef   td,                     // [IN] The class implementing the method   
        mdToken     tk,                     // [IN] MethodDef or MethodRef being implemented    
        ULONG       ulCodeRVA,              // [IN] CodeRVA 
        DWORD       dwImplFlags,            // [IN] Impl. Flags 
        mdMethodImpl *pmi) PURE;            // [OUT] Put methodimpl token here  

    STDMETHOD(SetRVA)(                      // [IN] S_OK or error.  
        mdToken     md,                     // [IN] Member for which to set offset  
        ULONG       ulCodeRVA,              // [IN] The offset  
        DWORD       dwImplFlags) PURE;  

    STDMETHOD(DefineTypeRefByName)(         // S_OK or error.   
        LPCWSTR     szNamespace,            // [IN] Namespace that the Type is in.  
        LPCWSTR     szType,                 // [IN] Name of the type.   
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.    

    STDMETHOD(DefineImportType)(            // S_OK or error.   
        IMetaDataImport *pImport,           // [IN] Scope containing the TypeDef.   
        mdTypeDef   tdImport,               // [IN] The imported TypeDef.   
        DWORD       dwBindFlags,            // [IN] Properties of TypeDef to which to bind. 
        mdTypeRef   *ptr) PURE;             // [OUT] Put TypeRef token here.    

    STDMETHOD(DefineMemberRef)(             // S_OK or error    
        mdToken     tkImport,               // [IN] ClassRef or ClassDef importing a member.    
        LPCWSTR     szName,                 // [IN] member's name   
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] memberref token    

    STDMETHOD(DefineImportMember)(          // S_OK or error.   
        mdToken     tkImport,               // [IN] Classref or classdef importing a member.    
        IMetaDataImport *pImport,           // [IN] Import scope, with member.  
        mdToken     mbMember,               // [IN] Member in emit scope.   
        mdMemberRef *pmr) PURE;             // [OUT] Put member ref here.   

    STDMETHOD(DefineProperty) ( 
        mdTypeDef   td,                     // [IN] the class/interface on which the property is being defined  
        LPCWSTR     szProperty,             // [IN] Name of the property    
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr 
        PCCOR_SIGNATURE pvSig,              // [IN] the required type signature 
        ULONG       cbSig,                  // [IN] the size of the type signature blob 
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        mdMethodDef mdSetter,               // [IN] optional setter of the property 
        mdMethodDef mdGetter,               // [IN] optional getter of the property 
        mdMethodDef mdReset,                // [IN] optional reset meothd of the property   
        mdMethodDef mdTestDefault,          // [IN] optional testing default method of the property 
        mdMethodDef rmdOtherMethods[],      // [IN] an optional array of other methods  
        mdToken     evNotifyChanging,       // [IN] notify changing event   
        mdToken     evNotifyChanged,        // [IN] notify changed event    
        mdFieldDef fdBackingField,          // [IN] optional field   
        mdProperty  *pmdProp) PURE;         // [OUT] output property token  

    STDMETHOD(DefineEvent) (    
        mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
        LPCWSTR     szEvent,                // [IN] Name of the event   
        DWORD       dwEventFlags,           // [IN] CorEventAttr    
        mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
        mdMethodDef mdAddOn,                // [IN] required add method 
        mdMethodDef mdRemoveOn,             // [IN] required remove method  
        mdMethodDef mdFire,                 // [IN] optional fire method    
        mdMethodDef rmdOtherMethods[],      // [IN] optional array of other methods associate with the event    
        mdEvent     *pmdEvent) PURE;        // [OUT] output event token 

    STDMETHOD(SetClassLayout)   (   
        mdTypeDef   td,                     // [IN] typedef 
        DWORD       dwPackSize,             // [IN] packing size specified as 1, 2, 4, 8, or 16 
        COR_FIELD_OFFSET rFieldOffsets[],   // [IN] array of layout specification   
        ULONG       ulClassSize) PURE;      // [IN] size of the class   

    STDMETHOD(SetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a fieldDef or paramDef token  
        PCCOR_SIGNATURE pvNativeType,       // [IN] native type specification   
        ULONG       cbNativeType) PURE;     // [IN] count of bytes of pvNativeType  

    STDMETHOD(DefinePermissionSet) (    
        mdToken     tk,                     // [IN] the object to be decorated. 
        DWORD       dwAction,               // [IN] CorDeclSecurity.    
        void const  *pvPermission,          // [IN] permission blob.    
        ULONG       cbPermission,           // [IN] count of bytes of pvPermission. 
        mdPermission *ppm) PURE;            // [OUT] returned permission token. 

    STDMETHOD(SetMemberIndex)(              // S_OK or error.   
        mdToken     md,                     // [IN] Member for which to set offset  
        ULONG       ulIndex) PURE;          // [IN] The offset    

    STDMETHOD(GetTokenFromSig)(             // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.    
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdSignature *pmsig) PURE;           // [OUT] returned signature token.  

    STDMETHOD(DefineModuleRef)(             // S_OK or error.   
        LPCWSTR     szName,                 // [IN] DLL name    
        const GUID  *pguid,                 // [IN] imported module id  
        const GUID  *pmvid,                 // [IN] mvid of the imported module 
        mdModuleRef *pmur) PURE;            // [OUT] returned   

    // @todo:  This should go away once everyone starts using SetMemberRefProps.
    STDMETHOD(SetParent)(                   // S_OK or error.   
        mdMemberRef mr,                     // [IN] Token for the ref to be fixed up.   
        mdToken     tk) PURE;               // [IN] The ref parent. 

    STDMETHOD(GetTokenFromTypeSpec)(        // S_OK or error.   
        PCCOR_SIGNATURE pvSig,              // [IN] TypeSpec Signature to define.  
        ULONG       cbSig,                  // [IN] Size of signature data. 
        mdTypeSpec *ptypespec) PURE;        // [OUT] returned TypeSpec token.  

    STDMETHOD(SaveToMemory)(                // S_OK or error.
        void        *pbData,                // [OUT] Location to write data.
        ULONG       cbData) PURE;           // [IN] Max size of data buffer.

    STDMETHOD(SetSymbolBindingPath)(        // S_OK or error.
        REFGUID     FormatID,               // [IN] Symbol data format ID.
        LPCWSTR     szSymbolDataPath) PURE; // [IN] URL for the symbols of this module.

// Deprecated               
    STDMETHOD(SetCustomValueAsBlob)(        // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        LPCWSTR     szName,                 // [IN] Name of custom value to set/replace.
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue,          // [IN] The custom value data length.
        mdCustomValue *pcv) PURE;           // [OUT] The custom value token value on return.
// Deprecated               

    STDMETHOD(DefineUserString)(            // Return code.
        LPCWSTR szString,                   // [IN] User literal string.
        ULONG       cchString,              // [IN] Length of string.
        mdString    *pstk) PURE;            // [OUT] String token.

    STDMETHOD(DefineOrdinalMap)(            // Return code.
        ULONG       ulOrdinal) PURE;        // [IN] Ordinal for the p-invoke method.

#if defined(CUSTOM_VALUE_TYPE)
    STDMETHOD(DefineCustomValueByToken)(    // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdToken     tkType,                 // [IN] Type of the CustomValue (TypeRef/TypeDef).
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue,          // [IN] The custom value data length.
        mdCustomValue *pcv) PURE;           // [OUT] The custom value token value on return.

    STDMETHOD(SetCustomValueByToken)(       // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdToken     tkType,                 // [IN] Type of the object.
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue,          // [IN] The custom value data length.
        mdCustomValue *pcv) PURE;           // [OUT] The custom value token value on return.

    STDMETHOD(DefineCustomValueByName)(     // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        LPCWSTR     szName,                 // [IN] Name of the CustomValue (TypeRef).
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue,          // [IN] The custom value data length.
        mdCustomValue *pcv) PURE;           // [OUT] The custom value token value on return.

    STDMETHOD(SetCustomValueByName)(        // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        LPCWSTR     szName,                 // [IN] Name of the CustomValue (TypeRef).
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue,          // [IN] The custom value data length.
        mdCustomValue *pcv) PURE;           // [OUT] The custom value token value on return.
#endif

	STDMETHOD(DeleteToken)(					// Return code.
		mdToken 	tkObj) PURE;            // [IN] The token to be deleted

    STDMETHOD(SetMethodProps)(              // S_OK or error.
        mdMethodDef md,                     // [IN] The MethodDef.
        DWORD       dwMethodFlags,          // [IN] Method attributes.
        ULONG       ulCodeRVA,              // [IN] Code RVA.
        DWORD       dwImplFlags) PURE;      // [IN] MethodImpl flags.

    STDMETHOD(SetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] The TypeDef.
        const GUID  *pguid,                 // [IN] GUID
        CLASSVERSION *pVer,                 // [IN] Class version.
        DWORD       dwTypeDefFlags,         // [IN] TypeDef flags.
        mdToken     tkExtends,              // [IN] Base TypeDef or TypeRef.
        DWORD       dwExtendsFlags,         // [IN] Extends flags.
        mdToken     rtkImplements[],        // [IN] Implemented interfaces.
        mdToken     rtkEvents[]) PURE;      // [IN] Event interfaces.

    STDMETHOD(SetFieldProps)(               // S_OK or error.
        mdFieldDef  fd,                     // [IN] The FieldDef.
        DWORD       dwFieldFlags,           // [IN] Field attributes.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue) PURE;          // [IN] Constant value.

    STDMETHOD(SetMethodImplProps)(          // S_OK or error.
        mdMethodImpl mi,                    // [IN] The MethodImpl.
        ULONG       ulCodeRVA,              // [IN] CodeRVA.
        DWORD       dwImplFlags) PURE;      // [IN] MethodImpl flags.

    STDMETHOD(SetPropertyProps)(            // S_OK or error.
        mdProperty  pr,                     // [IN] Property token.
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        mdMethodDef mdSetter,               // [IN] Setter of the property.
        mdMethodDef mdGetter,               // [IN] Getter of the property.
        mdMethodDef mdReset,                // [IN] Reset meothd of the property.
        mdMethodDef mdTestDefault,          // [IN] Testing default method of the property.
        mdMethodDef rmdOtherMethods[],      // [IN] Array of other methods.
        mdToken     evNotifyChanging,       // [IN] Notify changing event.
        mdToken     evNotifyChanged,        // [IN] Notify changed event.
        mdFieldDef  fdBackingField) PURE;   // [IN] Backing field.

    STDMETHOD(SetEventProps)(               // S_OK or error.
        mdEvent     ev,                     // [IN] The event token.
        DWORD       dwEventFlags,           // [IN] CorEventAttr.
        mdToken     tkEventType,            // [IN] A reference (mdTypeRef or mdTypeRef) to the Event class.
        mdMethodDef mdAddOn,                // [IN] Add method.
        mdMethodDef mdRemoveOn,             // [IN] Remove method.
        mdMethodDef mdFire,                 // [IN] Fire method.
        mdMethodDef rmdOtherMethods[]) PURE;// [IN] Array of other methods associate with the event.

    STDMETHOD(SetPermissionSetProps)(       // S_OK or error.
        mdToken     tk,                     // [IN] The object to be decorated.
        DWORD       dwAction,               // [IN] CorDeclSecurity.
        void const  *pvPermission,          // [IN] Permission blob.
        ULONG       cbPermission,           // [IN] Count of bytes of pvPermission.
        mdPermission *ppm) PURE;            // [OUT] Permission token.

    STDMETHOD(DefineParam)(
        mdMethodDef md,                     // [IN] Owning method   
        ULONG       ulParamSeq,             // [IN] Which param 
        LPCWSTR     szName,                 // [IN] Optional param name 
        DWORD       dwParamFlags,           // [IN] Optional param flags    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        mdParamDef  *ppd) PURE;             // [OUT] Put param token here   

    STDMETHOD(DefinePinvokeMap)(            // Return code.
        mdToken     tk,                     // [IN] FieldDef, MethodDef or MethodImpl.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        ULONG       ulImportOrdinal,        // [IN] Import Ordinal.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(SetPinvokeMap)(               // Return code.
        mdToken     tk,                     // [IN] FieldDef, MethodDef or MethodImpl.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        ULONG       ulImportOrdinal,        // [IN] Import Ordinal.
        mdModuleRef mrImportDLL) PURE;      // [IN] ModuleRef token for the target DLL.

    STDMETHOD(SetParamProps)(               // Return code.
        mdParamDef  pd,                     // [IN] Param token.   
        LPCWSTR     szName,                 // [IN] Param name.
        DWORD       dwParamFlags,           // [IN] Param flags.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
        void const  *pValue) PURE;          // [OUT] Constant value.

    STDMETHOD(MergeEnd)() PURE;             // S_OK or error.

	// New CustomAttribute functions.
    STDMETHOD(DefineCustomAttribute)(		// Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdToken     tkType,                 // [IN] Type of the CustomValue (TypeRef/TypeDef).
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue,          // [IN] The custom value data length.
        mdCustomValue *pcv) PURE;           // [OUT] The custom value token value on return.

    STDMETHOD(SetCustomAttributeValue)(		// Return code.
        mdCustomValue pcv,					// [IN] The custom value token whose value to replace.
        void const  *pCustomValue,          // [IN] The custom value data.
        ULONG       cbCustomValue) PURE;    // [IN] The custom value data length.

    STDMETHOD(DefineFieldEx)(               // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwFieldFlags,           // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cbValue,                // [IN] size of constant value (string, in bytes).
        mdFieldDef  *pmd) PURE;             // [OUT] Put member token here    

    STDMETHOD(DefinePropertyEx)( 
        mdTypeDef   td,                     // [IN] the class/interface on which the property is being defined  
        LPCWSTR     szProperty,             // [IN] Name of the property    
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr 
        PCCOR_SIGNATURE pvSig,              // [IN] the required type signature 
        ULONG       cbSig,                  // [IN] the size of the type signature blob 
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cbValue,                // [IN] size of constant value (string, in bytes).
        mdMethodDef mdSetter,               // [IN] optional setter of the property 
        mdMethodDef mdGetter,               // [IN] optional getter of the property 
        mdMethodDef mdReset,                // [IN] optional reset meothd of the property   
        mdMethodDef mdTestDefault,          // [IN] optional testing default method of the property 
        mdMethodDef rmdOtherMethods[],      // [IN] an optional array of other methods  
        mdToken     evNotifyChanging,       // [IN] notify changing event   
        mdToken     evNotifyChanged,        // [IN] notify changed event    
        mdFieldDef  fdBackingField,         // [IN] optional field   
        mdProperty  *pmdProp) PURE;         // [OUT] output property token  

    STDMETHOD(DefineParamEx)(
        mdMethodDef md,                     // [IN] Owning method   
        ULONG       ulParamSeq,             // [IN] Which param 
        LPCWSTR     szName,                 // [IN] Optional param name 
        DWORD       dwParamFlags,           // [IN] Optional param flags    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cbValue,                // [IN] size of constant value (string, in bytes).
        mdParamDef  *ppd) PURE;             // [OUT] Put param token here   

    STDMETHOD(SetFieldPropsEx)(             // S_OK or error.
        mdFieldDef  fd,                     // [IN] The FieldDef.
        DWORD       dwFieldFlags,           // [IN] Field attributes.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cbValue) PURE;          // [IN] size of constant value (string, in bytes).

    STDMETHOD(SetPropertyPropsEx)(          // S_OK or error.
        mdProperty  pr,                     // [IN] Property token.
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cbValue,                // [IN] size of constant value (string, in bytes).
        mdMethodDef mdSetter,               // [IN] Setter of the property.
        mdMethodDef mdGetter,               // [IN] Getter of the property.
        mdMethodDef mdReset,                // [IN] Reset meothd of the property.
        mdMethodDef mdTestDefault,          // [IN] Testing default method of the property.
        mdMethodDef rmdOtherMethods[],      // [IN] Array of other methods.
        mdToken     evNotifyChanging,       // [IN] Notify changing event.
        mdToken     evNotifyChanged,        // [IN] Notify changed event.
        mdFieldDef  fdBackingField) PURE;   // [IN] Backing field.

    STDMETHOD(SetParamPropsEx)(             // Return code.
        mdParamDef  pd,                     // [IN] Param token.   
        LPCWSTR     szName,                 // [IN] Param name.
        DWORD       dwParamFlags,           // [IN] Param flags.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
        void const  *pValue,                // [OUT] Constant value.
        ULONG       cbValue) PURE;          // [IN] size of constant value (string, in bytes).

};      // IMetaDataEmit


//-------------------------------------
//--- IMetaDataImport
//-------------------------------------

// {e04bc6a0-624b-11d3-824a-00902710145e}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataImport = 
{ 0xe04bc6a0, 0x624b, 0x11d3, { 0x82, 0x4a, 0x0, 0x90, 0x27, 0x10, 0x14, 0x5e } };

// {F3DDD0C6-79A9-11d2-941B-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataImportOLD = 
{ 0xf3ddd0c6, 0x79a9, 0x11d2, { 0x94, 0x1b, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataImport
DECLARE_INTERFACE_(IMetaDataImport, IUnknown)
{
	STDMETHOD_(void, CloseEnum)(HCORENUM hEnum) PURE;
	STDMETHOD(CountEnum)(HCORENUM hEnum, ULONG *pulCount) PURE;
	STDMETHOD(ResetEnum)(HCORENUM hEnum, ULONG ulPos) PURE;
	STDMETHOD(EnumTypeDefs)(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
							ULONG cMax, ULONG *pcTypeDefs) PURE;
	STDMETHOD(EnumInterfaceImpls)(HCORENUM *phEnum, mdTypeDef td,
							mdInterfaceImpl rImpls[], ULONG cMax,
							ULONG* pcImpls) PURE;
	STDMETHOD(EnumTypeRefs)(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
							ULONG cMax, ULONG* pcTypeRefs) PURE;
	STDMETHOD(EnumCustomValues)(HCORENUM *phEnum, mdToken tk,
							mdCustomValue rCustomValues[], ULONG cMax,
							ULONG* pcCustomValues) PURE;

	STDMETHOD(FindTypeDefByName)(			// S_OK or error.
		LPCWSTR 	szNamespace,			// [IN] Namespace with the Type.
		LPCWSTR 	szTypeDef,				// [IN] Name of the Type.
		mdTypeDef	*ptd) PURE; 			// [OUT] Put the TypeDef token here.

	STDMETHOD(FindTypeDefByGUID)(			// S_OK or error.				
		const GUID	*pguid, 				// [IN] The GUID of the Type.
		mdTypeDef	*ptd) PURE; 			// [OUT] Put the TypeDef token here.

// Deprecated				

	STDMETHOD(FindCustomValue)(mdToken tk, LPCWSTR szName, mdCustomValue *pcv, 
							DWORD *pdwValueType) PURE;
// Deprecated				

	STDMETHOD(GetScopeProps)(LPWSTR szName, ULONG cchName, ULONG *pchName,
							GUID *ppid, GUID *pmvid, LCID *pLcid) PURE;

	STDMETHOD(GetModuleFromScope)(			// S_OK.
		mdModule	*pmd) PURE; 			// [OUT] Put mdModule token here.

	STDMETHOD(GetTypeDefProps)( 			// S_OK or error.
		mdTypeDef	td, 					// [IN] TypeDef token for inquiry.
		LPWSTR		szNamespace,			// [OUT] Put Namespace here.
		ULONG		cchNamespace,			// [IN] size of Namespace buffer in wide chars.
		ULONG		*pchNamespace,			// [OUT] put size of Namespace (wide chars) here.
		LPWSTR		szTypeDef,				// [OUT] Put name here.
		ULONG		cchTypeDef, 			// [IN] size of name buffer in wide chars.
		ULONG		*pchTypeDef,			// [OUT] put size of name (wide chars) here.
		GUID		*pguid, 				// [OUT] Put clsid here.
		CLASSVERSION *pver, 				// [OUT] Put version here.
		DWORD		*pdwTypeDefFlags,		// [OUT] Put flags here.
		mdToken 	*ptkExtends,			// [OUT] Put base class TypeDef/TypeRef here.
		DWORD		*pdwExtendsFlags) PURE; // [OUT] Put extends flags here.

	STDMETHOD(GetInterfaceImplProps)(		// S_OK or error.
		mdInterfaceImpl iiImpl, 			// [IN] InterfaceImpl token.
		mdTypeDef	*pClass,				// [OUT] Put implementing class token here.
		mdToken 	*ptkIface,				// [OUT] Put implemented interface token here.
		DWORD		*pdwFlags) PURE;		// [OUT] Put implementation flags here.

// Deprecated				
	STDMETHOD(GetCustomValueProps)(mdCustomValue cv, LPWSTR szName, ULONG cchName,
							ULONG *pchName, DWORD *pdwValueType) PURE;
	STDMETHOD(GetCustomValueAsBlob)(mdCustomValue cv, void const **ppBlob, ULONG *pcbSize) PURE;
// Deprecated				

	STDMETHOD(GetTypeRefProps)(mdTypeRef tr, LPWSTR szTypeRef,
							ULONG cchTypeRef, ULONG *pchTypeRef, GUID *pGuid, DWORD *pdwBind) PURE;

	STDMETHOD(ResolveTypeRef)(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd) PURE;

    STDMETHOD(EnumMembers)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMembersWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethods)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.   
        ULONG       cMax,                   // [IN] Max MethodDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodsWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdMethodDef rMethods[],             // [OU] Put MethodDefs here.    
        ULONG       cMax,                   // [IN] Max MethodDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFields)(                 // S_OK, S_FALSE, or error.  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdFieldDef  rFields[],              // [OUT] Put FieldDefs here.    
        ULONG       cMax,                   // [IN] Max FieldDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFieldsWithName)(         // S_OK, S_FALSE, or error.              
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    


    STDMETHOD(EnumParams)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdParamDef  rParams[],              // [OUT] Put ParamDefs here.    
        ULONG       cMax,                   // [IN] Max ParamDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMemberRefs)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tkParent,               // [IN] Parent token to scope the enumeration.  
        mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.   
        ULONG       cMax,                   // [IN] Max MemberRefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodImpls)(             // S_OK, S_FALSE, or error  
        HCORENUM *phEnum,                   // [IN|OUT] Pointer to the enum.    
        mdTypeRef tr,                       // [IN] TypeRef to scope the enumeration.   
        mdMethodImpl rMethodImpls[],        // [OUT] Put MemberRefs here.   
        ULONG cMax,                         // [IN] Max MemberRefs to put.  
        ULONG* pcMethodImpls) PURE;         // [OUT] Put # put here.    

    STDMETHOD(EnumPermissionSets)(          // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.    
        DWORD       dwActions,              // [IN] if !0, return only these actions.   
        mdPermission rPermission[],         // [OUT] Put Permissions here.  
        ULONG       cMax,                   // [IN] Max Permissions to put. 
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(FindMember)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdToken     *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMethod)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMethodDef *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindField)(   
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdFieldDef  *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMemberRef)(   
        mdTypeRef   td,                     // [IN] given typeRef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] matching memberref 

    STDMETHOD(GetMemberProps)(  
        mdToken     mb,                     // The member for which to get props.   
        mdTypeDef   *pClass,                // Put member's class here. 
        LPWSTR      szMember,               // Put member's name here.  
        ULONG       cchMember,              // Size of szMember buffer in wide chars.   
        ULONG       *pchMember,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue) PURE;        // [OUT] constant value 

    STDMETHOD (GetMethodProps)( 
        mdMethodDef mb,                     // The method for which to get props.   
        mdTypeDef   *pClass,                // Put method's class here. 
        LPWSTR      szMethod,               // Put method's name here.  
        ULONG       cchMethod,              // Size of szMethod buffer in wide chars.   
        ULONG       *pchMethod,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags) PURE;    // [OUT] Impl. Flags    

    STDMETHOD (GetFieldProps)(  
        mdFieldDef  mb,                     // The field for which to get props.    
        mdTypeDef   *pClass,                // Put field's class here.  
        LPWSTR      szField,                // Put field's name here.   
        ULONG       cchField,               // Size of szField buffer in wide chars.    
        ULONG       *pchField,              // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue) PURE;        // [OUT] constant value 

    STDMETHOD(GetMethodImplProps)(          // S_OK or error.   
        mdMethodImpl mi,                    // Put methodimpl token here    
        mdTypeDef   *ptd,                   // The class implementing the method    
        mdToken     *ptk,                   // [OUT] MethodDef or MethodRef being implemented   
        ULONG       *pulCodeRVA,            // [OUT] CodeRVA    
        DWORD       *pdwImplFlags) PURE;    // [OUT] Impl. Flags    

    STDMETHOD(GetMemberRefProps)(           // S_OK or error.   
        mdMemberRef mr,                     // [IN] given memberref 
        mdToken     *ptk,                   // [OUT] Put classref or classdef here. 
        LPWSTR      szMember,               // [OUT] buffer to fill for member's name   
        ULONG       cchMember,              // [IN] the count of char of szMember   
        ULONG       *pchMember,             // [OUT] actual count of char in member name    
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value  
        ULONG       *pbSig) PURE;           // [OUT] actual size of signature blob  

    STDMETHOD(EnumProperties)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdProperty  rProperties[],          // [OUT] Put Properties here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcProperties) PURE;    // [OUT] Put # put here.    

    STDMETHOD(GetPropertyProps)(            // S_OK, S_FALSE, or error. 
        mdProperty  prop,                   // [IN] property token  
        mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
        LPCWSTR     szProperty,             // [OUT] Property name  
        ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
        ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
        DWORD       *pdwPropFlags,          // [OUT] property flags.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
        ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppDefaultValue,           // [OUT] constant value 
        mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
        mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
        mdMethodDef *pmdReset,              // [OUT] reset method of the property   
        mdMethodDef *pmdTestDefault,        // [OUT] test default method of the property    
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod,         // [OUT] total number of other method of this property  
        mdToken     *pevNotifyChanging,     // [OUT] notify changing EventDef or EventRef   
        mdToken     *pevNotifyChanged,      // [OUT] notify changed EventDef or EventRef    
        mdFieldDef  *pmdBackingField) PURE;  // [OUT] backing field 

    STDMETHOD(EnumEvents)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdEvent     rEvents[],              // [OUT] Put events here.   
        ULONG       cMax,                   // [IN] Max events to put.  
        ULONG       *pcEvents) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetEventProps)(               // S_OK, S_FALSE, or error. 
        mdEvent     ev,                     // [IN] event token 
        mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.    
        LPCWSTR     szEvent,                // [OUT] Event name 
        ULONG       cchEvent,               // [IN] the count of wchar of szEvent   
        ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name 
        DWORD       *pdwEventFlags,         // [OUT] Event flags.   
        mdToken     *ptkEventType,          // [OUT] EventType class    
        mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event  
        mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event   
        mdMethodDef *pmdFire,               // [OUT] Fire method of the event   
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event  
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this event 

    STDMETHOD(EnumMethodSemantics)(         // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdToken     rEventProp[],           // [OUT] Put Event/Property here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcEventProp) PURE;     // [OUT] Put # put here.    

    STDMETHOD(GetMethodSemantics)(          // S_OK, S_FALSE, or error. 
        mdMethodDef mb,                     // [IN] method token    
        mdToken     tkEventProp,            // [IN] event/property token.   
        DWORD       *pdwSemanticsFlags) PURE; // [OUT] the role flags for the method/propevent pair 

    STDMETHOD(GetClassLayout) ( 
        mdTypeDef   td,                     // [IN] give typedef    
        DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16  
        COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array 
        ULONG       cMax,                   // [IN] size of the array   
        ULONG       *pcFieldOffset,         // [OUT] needed array size  
        ULONG       *pulClassSize) PURE;        // [OUT] the size of the class  

    STDMETHOD(GetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a field's memberdef   
        PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field  
        ULONG       *pcbNativeType) PURE;   // [OUT] the count of bytes of *ppvNativeType   

    STDMETHOD(GetRVA)(                      // S_OK or error.   
        mdToken     tk,                     // Member for which to set offset   
        ULONG       *pulCodeRVA,            // The offset   
        DWORD       *pdwImplFlags) PURE;    // the implementation flags 

    STDMETHOD(GetPermissionSetProps) (  
        mdPermission pm,                    // [IN] the permission token.   
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.   
        void const  **ppvPermission,        // [OUT] permission blob.   
        ULONG       *pcbPermission) PURE;   // [OUT] count of bytes of pvPermission.    

    STDMETHOD(GetSigFromToken)(             // S_OK or error.   
        mdSignature mdSig,                  // [IN] Signature token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.   
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetModuleRefProps)(           // S_OK or error.   
        mdModuleRef mur,                    // [IN] moduleref token.    
        LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.    
        ULONG       cchName,                // [IN] size of szName in wide characters.  
        ULONG       *pchName,               // [OUT] actual count of characters in the name.    
        GUID        *pguid,                 // [OUT] module identifier of the imported module.  
        GUID        *pmvid) PURE;           // [OUT] system-stamped module identifier for a COM+ module.    

    STDMETHOD(EnumModuleRefs)(              // S_OK or error.   
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.   
        ULONG       cmax,                   // [IN] max memberrefs to put.  
        ULONG       *pcModuleRefs) PURE;    // [OUT] put # put here.    

    STDMETHOD(GetTypeSpecFromToken)(        // S_OK or error.   
        mdTypeSpec typespec,                // [IN] TypeSpec token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to TypeSpec signature  
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetNameFromToken)(            // S_OK or error.
        mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
        MDUTF8CSTR  *pszUtf8NamePtr) PURE;  // [OUT] Return pointer to UTF8 name in heap.

	STDMETHOD(GetSymbolBindingPath)(		// S_OK or error.
		GUID		*pFormatID,				// [OUT] Symbol data format ID.
		LPWSTR		szSymbolDataPath,		// [OUT] Path of symbols.
		ULONG		cchSymbolDataPath,		// [IN] Max characters for output buffer.
		ULONG		*pcbSymbolDataPath) PURE;// [OUT] Number of chars in actual name.

    STDMETHOD(EnumUnresolvedMethods)(       // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

	STDMETHOD(GetUserString)(				// S_OK or error.
		mdString	stk,					// [IN] String token.
		LPWSTR		szString,				// [OUT] Copy of string.
		ULONG		cchString,				// [IN] Max chars of room in szString.
		ULONG		*pchString) PURE;		// [OUT] How many chars in actual string.

	STDMETHOD(GetPinvokeMap)(				// S_OK or error.
		mdToken		tk,						// [IN] FieldDef, MethodDef or MethodImpl.
		DWORD		*pdwMappingFlags,		// [OUT] Flags used for mapping.
		LPWSTR		szImportName,			// [OUT] Import name.
		ULONG		cchImportName,			// [IN] Size of the name buffer.
		ULONG		*pchImportName,			// [OUT] Actual number of characters stored.
		ULONG		*pulImportOrdinal,		// [OUT] Import Ordinal.
		mdModuleRef	*pmrImportDLL) PURE;	// [OUT] ModuleRef token for the target DLL.

	STDMETHOD(FindOrdinal)(					// S_OK or error.
		ULONG		ulIndex,				// [IN] RID into the ordinal map table.
		ULONG		*pulOrdinal) PURE;		// [OUT] Ordinal for the p-invoke method.

	STDMETHOD(EnumSignatures)(				// S_OK or error.
		HCORENUM	*phEnum,				// [IN|OUT] pointer to the enum.    
		mdSignature	rSignatures[],			// [OUT] put signatures here.   
		ULONG		cmax,					// [IN] max signatures to put.  
		ULONG		*pcSignatures) PURE;	// [OUT] put # put here.

	STDMETHOD(EnumTypeSpecs)(				// S_OK or error.
		HCORENUM	*phEnum,				// [IN|OUT] pointer to the enum.    
		mdTypeSpec	rTypeSpecs[],			// [OUT] put TypeSpecs here.   
		ULONG		cmax,					// [IN] max TypeSpecs to put.  
		ULONG		*pcTypeSpecs) PURE;		// [OUT] put # put here.

#if defined(CUSTOM_VALUE_TYPE)
	STDMETHOD(FindCustomValueByToken)(		// S_OK, S_FALSE, or error.
		mdToken		tk, 					// [IN] Object which may have custom value.
		mdToken		typ, 					// [IN] TypeRef/TypeDef of the value's type.
		mdCustomValue *pcv) PURE;			// [OUT] Put the CustomValue token here.

	STDMETHOD(FindCustomValueByName)(		// S_OK, S_FALSE, or error.                 
		mdToken		tk, 					// [IN] Object which may have custom value. 
		LPCWSTR 	szName,					// [IN] Name of the CustomValue (TypeRef).
		mdCustomValue *pcv) PURE;			// [OUT] Put the CustomValue token here.    

	STDMETHOD(GetCustomValuePropsNew)(		// S_OK or error.
		mdCustomValue cv, 					// [IN] CustomValue token.
		mdToken		*ptkType,				// [OUT, OPTIONAL] Put TypeDef/TypeRef token here.
		void const	**ppBlob, 				// [OUT, OPTIONAL] Put pointer to data here.
		ULONG		*pcbSize) PURE;			// [OUT, OPTIONAL] Put size of date here.
#endif

	STDMETHOD(EnumUserStrings)(				// S_OK or error.
		HCORENUM	*phEnum,				// [IN/OUT] pointer to the enum.
		mdString	rStrings[],				// [OUT] put Strings here.
		ULONG		cmax,					// [IN] max Strings to put.
		ULONG		*pcStrings) PURE;		// [OUT] put # put here.

    STDMETHOD(GetParamProps)(               // S_OK or error.
        mdParamDef  tk,                     // [IN]The Parameter.
        mdMethodDef *pmd,                   // [OUT] Parent Method token.
        ULONG       *pulSequence,           // [OUT] Parameter sequence.
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [OUT] Size of name buffer.
        ULONG       *pchName,               // [OUT] Put actual size of name here.
        DWORD       *pdwAttr,               // [OUT] Put flags here.
        DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
        void const  **ppValue) PURE;        // [OUT] Constant value.

    STDMETHOD(GetParamForMethodIndex)(      // S_OK or error.
        mdMethodDef md,                     // [IN] Method token.
        ULONG       ulParamSeq,             // [IN] Parameter sequence.
        mdParamDef  *ppd) PURE;             // [IN] Put Param token here.

	// New Custom Value functions.
	STDMETHOD(EnumCustomAttributes)(		// S_OK or error.
		HCORENUM	*phEnum,				// [IN, OUT] COR enumerator.
		mdToken		tk,						// [IN] Token to scope the enumeration, 0 for all.
		mdToken		tkType,					// [IN] Type of interest, 0 for all.
		mdCustomValue rCustomValues[],		// [OUT] Put custom attribute tokens here.
		ULONG		cMax,					// [IN] Size of rCustomValues.
		ULONG		*pcCustomValues) PURE;	// [OUT, OPTIONAL] Put count of token values here.

	STDMETHOD(GetCustomAttributeProps)(		// S_OK or error.
		mdCustomValue cv, 					// [IN] CustomAttribute token.
		mdToken		*ptkObj,				// [OUT, OPTIONAL] Put object token here.
		mdToken		*ptkType,				// [OUT, OPTIONAL] Put AttrType token here.
		void const	**ppBlob, 				// [OUT, OPTIONAL] Put pointer to data here.
		ULONG		*pcbSize) PURE;			// [OUT, OPTIONAL] Put size of date here.

    STDMETHOD(FindTypeRef)(   
        LPCWSTR     szName,                 // [IN] TypeRef name.
        mdTypeRef	*ptr) PURE;             // [OUT] matching TypeRef.


    STDMETHOD(GetMemberPropsEx)(  
        mdToken     mb,                     // The member for which to get props.   
        mdTypeDef   *pClass,                // Put member's class here. 
        LPWSTR      szMember,               // Put member's name here.  
        ULONG       cchMember,              // Size of szMember buffer in wide chars.   
        ULONG       *pchMember,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcbValue) PURE;        // [OUT] size of constant value

    STDMETHOD(GetFieldPropsEx)(  
        mdFieldDef  mb,                     // The field for which to get props.    
        mdTypeDef   *pClass,                // Put field's class here.  
        LPWSTR      szField,                // Put field's name here.   
        ULONG       cchField,               // Size of szField buffer in wide chars.    
        ULONG       *pchField,              // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcbValue) PURE;        // [OUT] size of constant value

    STDMETHOD(GetPropertyPropsEx)(          // S_OK, S_FALSE, or error. 
        mdProperty  prop,                   // [IN] property token  
        mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
        LPCWSTR     szProperty,             // [OUT] Property name  
        ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
        ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
        DWORD       *pdwPropFlags,          // [OUT] property flags.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
        ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppDefaultValue,       // [OUT] constant value 
        ULONG       *pcbDefaultValue,       // [OUT] size of constant value
        mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
        mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
        mdMethodDef *pmdReset,              // [OUT] reset method of the property   
        mdMethodDef *pmdTestDefault,        // [OUT] test default method of the property    
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod,         // [OUT] total number of other method of this property  
        mdToken     *pevNotifyChanging,     // [OUT] notify changing EventDef or EventRef   
        mdToken     *pevNotifyChanged,      // [OUT] notify changed EventDef or EventRef    
        mdFieldDef  *pmdBackingField) PURE;  // [OUT] backing field 

    STDMETHOD(GetParamPropsEx)(             // S_OK or error.
        mdParamDef  tk,                     // [IN]The Parameter.
        mdMethodDef *pmd,                   // [OUT] Parent Method token.
        ULONG       *pulSequence,           // [OUT] Parameter sequence.
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [OUT] Size of name buffer.
        ULONG       *pchName,               // [OUT] Put actual size of name here.
        DWORD       *pdwAttr,               // [OUT] Put flags here.
        DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
        void const  **ppValue,              // [OUT] Constant value.
        ULONG       *pcbValue) PURE;        //[OUT] size of constant value

	STDMETHOD(GetCustomAttributeByName)(	// S_OK or error.
		mdToken		tkObj,					// [IN] Object with Custom Attribute.
		LPCWSTR		szName,					// [IN] Name of desired Custom Attribute.
		const void	**ppData,				// [OUT] Put pointer to data here.
		ULONG		*pcbData) PURE;			// [OUT] Put size of data here.

};      // IMetaDataImport


//-------------------------------------
//--- IMetaDataFilter
//-------------------------------------

// {D0E80DD1-12D4-11d3-B39D-00C04FF81795}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataFilter = 
{0xd0e80dd1, 0x12d4, 0x11d3, {0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataFilter
DECLARE_INTERFACE_(IMetaDataFilter, IUnknown)
{
	STDMETHOD(UnmarkAll)() PURE;
	STDMETHOD(MarkToken)(mdToken tk) PURE;
	STDMETHOD(IsTokenMarked)(mdToken tk, BOOL *pIsMarked) PURE;
};



//-------------------------------------
//--- IHostFilter
//-------------------------------------

// {D0E80DD3-12D4-11d3-B39D-00C04FF81795}
extern const GUID DECLSPEC_SELECT_ANY IID_IHostFilter = 
{0xd0e80dd3, 0x12d4, 0x11d3, {0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95} };

//---
#undef  INTERFACE   
#define INTERFACE IHostFilter
DECLARE_INTERFACE_(IHostFilter, IUnknown)
{
	STDMETHOD(MarkToken)(mdToken tk) PURE;
};


//-------------------------------------
//--- IMetaDataCFC
//-------------------------------------

// Obsolete Interface ID.  Respond to QI, but assert.

// {BB779E43-0D36-11d3-8C4E-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataCFC = 
{ 0xbb779e43, 0xd36, 0x11d3, { 0x8c, 0x4e, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataCFC
DECLARE_INTERFACE_(IMetaDataCFC, IUnknown)
{
	// obsolete:
    STDMETHOD(GetMethodCode)(		        // return hresult   
        mdMethodDef  mb,                    // [IN] Member definition   
        void         **ppBytes,             // [OUT] Pointer to bytes goes here 
        ULONG        *piSize) PURE;         // [IN] Size of code    

    STDMETHOD(GetMaxIndex)( 
        USHORT      *index) PURE;           // [OUT] Put max constantpool index here    

    STDMETHOD(GetTokenFromIndex)(   
        USHORT      index,                  // [IN] Index into ConstantPool 
        mdCPToken   *pcp) PURE;             // [OUT] Put ConstantPool token here    

    STDMETHOD(GetTokenValue)(   
        mdCPToken   cp,                     // [IN] ConstantPool token  
        VARIANT     *pValue) PURE;          // [OUT] Put token value here   
};


//--------------------------------------
//--- IMetaDataConverter
//--------------------------------------
// {D9DEBD79-2992-11d3-8BC1-0000F8083A57}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataConverter = 
{ 0xd9debd79, 0x2992, 0x11d3, { 0x8b, 0xc1, 0x0, 0x0, 0xf8, 0x8, 0x3a, 0x57 } };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataConverter
DECLARE_INTERFACE_(IMetaDataConverter, IUnknown)
{
	STDMETHOD(GetMetaDataFromTypeInfo)(
		ITypeInfo* pITI,					// [in] Type info
		IMetaDataImport** ppMDI) PURE;		// [out] return IMetaDataImport on success

	STDMETHOD(GetMetaDataFromTypeLib)(
		ITypeLib* pITL,						// [in] Type library
		IMetaDataImport** ppMDI) PURE;		// [out] return IMetaDataImport on success

	STDMETHOD(GetTypeLibFromMetaData)(
		BSTR strModule,						// [in] Module name
		BSTR strTlbName,					// [in] Type library name
		ITypeLib** ppITL) PURE;				// [out] return ITypeLib on success
};

//*****************************************************************************
//*****************************************************************************
//
// D E B U G G E R   S U P P O R T    D E C L A R A T I O N S   
//
//*****************************************************************************
//*****************************************************************************
//-------------------------------------
//--- IMetaDataDebugEmit
//-------------------------------------


// {A3BC1F51-D0C7-11d2-977C-00A0C9B4D50C}
extern const GUID DECLSPEC_SELECT_ANY CORDBG_FormatID_TemporaryMetaDataDbg = 
{ 0xa3bc1f51, 0xd0c7, 0x11d2, { 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// {95FCB629-739C-11d2-9771-00A0C9B4D50C}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDebugEmit = 
{ 0x95fcb629, 0x739c, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

// {E0150176-E37E-11d1-9409-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDebugEmitOLD = 
{ 0xe0150176, 0xe37e, 0x11d1, {0x94, 0x9, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataDebugEmit
DECLARE_INTERFACE_(IMetaDataDebugEmit, IUnknown)
{
    STDMETHOD(DefineSourceFile)(            //  return hresult  
        LPCWSTR     wzFileName,             // [IN] full path file name     
        mdSourceFile *psourcefile) PURE;    // [OUT] return value   

    STDMETHOD(DefineBlock)( 
        mdMethodDef member,                 // [IN] MethodDef where the block belongs to    
        mdSourceFile sourcefile,            // [IN] source file for the block   
        void const  *pAttr,                 // [IN] array of (line#, offset) as blob value  
        ULONG       cbAttr) PURE;           // [IN] number of bytes of the blob 

    STDMETHOD(DefineLocalVarScope)(         // return hresult   
        mdLocalVarScope scopeParent,        // [IN] could be mdLocalVarScopeNil if no parent scope  
        ULONG       ulStartLine,            // [IN] source line where a scope starts    
        ULONG       ulEndLine,              // [IN] source line where a scope ends  
        mdMethodDef member,                 // [IN] MethodDef where the local is contained  
        mdLocalVarScope *plocalvarscope) PURE;// [OUT] return value 

    STDMETHOD(DefineLocalVar)(              // [IN] return hresult  
        mdLocalVarScope localvarscope,      // [IN] the local variable scope    
        LPCWSTR     wzVarName,              // [IN] local variable's name   
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        ULONG       ulSlot,                 // [IN]the slot on method frame for this variable   
        mdLocalVar  *plocalvar) PURE;       // [OUT] return value   

	STDMETHOD(SetSymbolBindingKey)(			// Return code
		mdTypeDef	td,						// [IN] The typedef to set binding data for.
		REFGUID		LanguageType,			// [IN] ID of the language type (C++, VB, etc.)
		REFGUID		VendorID) PURE;			// [IN] ID of the specific vendor.
};





//-------------------------------------
//--- IMetaDataDebugImport
//-------------------------------------

//
// MDCURSOR is a place holder for query result.
// IMPORTANT!!!!  IMetaDataDebugImport will go away and MDCURSOR will too. 
//
typedef struct
{ 
	char b[32];
} MDCURSOR;

typedef struct 
{
    mdSourceFile    m_sourcefile;   
    mdMethodDef     m_methoddef;    
    ULONG           m_cbLineNumberBlobLen;  
    const BYTE      *m_pbLineNumberBlob;    
} BlockProperty;


// {F80E301D-739C-11d2-9771-00A0C9B4D50C}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDebugImport = 
{ 0xf80e301d, 0x739c, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// {A4CD7AE5-2E59-11d2-9415-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDebugImportOLD = 
{ 0xa4cd7ae5, 0x2e59, 0x11d2, 0x94, 0x15, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 };


#undef  INTERFACE   
#define INTERFACE IMetaDataDebugImport
DECLARE_INTERFACE_(IMetaDataDebugImport, IUnknown)
{
    //**********************************************************************    
    // debugging information APIs   
    //**********************************************************************    

    STDMETHOD_(void, CloseCursor) (     
        MDCURSOR    *pmdcursor) PURE;       // [IN] given a cursor  

    // given a source file name, return the sourcefile token    
    STDMETHOD(GetSourceFile)(   
        LPCSTR      szFileName,             // given a file name    
        mdSourceFile *psourcefile) PURE;            // [OUT] find source file   


    // return the property of a given source file token 
    STDMETHOD(GetPropsOfSourceFile) (   
        mdSourceFile sourcefile,            // given source file    
        LPCSTR      *pszFileName) PURE;     // return an UTF8 string pointer    

    // get the count of blocks which belongs to a given methoddef   
    STDMETHOD(GetBlockCountOfMethodDef) (   
        mdMethodDef methoddef,              // given a methoddef    
        ULONG       *pcBlocks,              // [OUT] count of blocks    
        MDCURSOR    *pmdcursor) PURE;       // [OUT] query result   

    // get the count of blocks which belongs to a given sourcefile  
    STDMETHOD(GetBlockCountOfSourceFile) (  
        mdSourceFile sourcefile,            // given a sourcefile   
        ULONG       *pcBlocks,              // [OUT] count of blocks    
        MDCURSOR    *pmdcursor) PURE;       // [OUT] query result   

    // return the properties of all blocks which belongs to a given memberdef   
    STDMETHOD(GetAllBlockProps) (   
        MDCURSOR    *pmdcursor,             // previous query result    
        BlockProperty rgBlockProp[],        // [OUT] buffer to fill in the block perperty   
        ULONG       cBlocks) PURE;          // size of buffer   

    // return the count of LocalVariableScope which belongs to a methoddef  
    STDMETHOD(GetLocalVarScopeCountOfMethodDef) (   
        mdMethodDef methoddef,              // given a memberdef    
        ULONG       *pcScopes,              // [OUT] count of scopes    
        MDCURSOR    *pmdcursor) PURE;       // [OUT] query result   

    // return all of the LocalVarScope tokens which belongs to a memberdef  
    STDMETHOD(GetAllLocalVarScopeOfMemeberDef) (    
        MDCURSOR    *pmdcursor,             // given a query result 
        mdLocalVarScope rgLocalVarScopes[], // [OUT] buffer to fill in  
        ULONG       cLocalVarScope) PURE;   // size of the buffer   

    // return properties of a LocalVarScope 
    STDMETHOD(GetPropsOfLocalVarScope) (    
        mdLocalVarScope localvarscope,      // given a local var scope  
        mdLocalVarScope *plocalvarscopeParent,// [OUT] a local var scope which contains this local variable scope   
        mdMethodDef *methoddef,             // [OUT] the containing methoddef   
        ULONG       *pulStartLine,          // [OUT] starting line of this local variable scope 
        ULONG       *pulEndLine) PURE;      // [OUT] end line of this local variable scope  

    // return the number of local variables that are defined in a LocalVarScope 
    STDMETHOD(GetLocalVarCountOfScope) (    
        mdLocalVarScope localvarscope,      // given a local var scope  
        ULONG       *pcLocalVar,            // [OUT] count of of local variable withen a LocalVarScope  
        MDCURSOR    *pmdcursor) PURE;       // [OUT] query result   

    // return the LocalVar tokens of all local variables that are defined in a LocalVarScope    
    STDMETHOD(GetAllLocalVarOfScope) (  
        MDCURSOR    *pmdcursor,             // query result 
        mdLocalVar  rgLocalVar[],           // [OUT] buffer to fill in localvar tokens  
        ULONG       cLocalVar) PURE;        // size of the buffer   

    // return the properties of a Local Variable    
    STDMETHOD(GetPropsOfLocalVar) ( 
        mdLocalVar  localvar,               // given a local var token  
        mdLocalVarScope *plocalvarscope,    // [OUT] the containing local variable scope    
        LPCSTR      *pszName,               // [OUT] utf8 string of the local variable name 
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature    
        ULONG       *pcbSigBlob,            // [OUT] count of bytes in the signature blob   
        ULONG       *pulSlot) PURE;         // [OUT] the slot number on the frame for this local variable   

	// return the language type and ID for a class
	STDMETHOD(GetSymbolBindingKey)(			// Return code
		mdTypeDef	td,						// [IN] The typedef to set binding data for.
		GUID		*pLanguageType,			// [OUT] ID of the language type (C++, VB, etc.)
		GUID		*pVendorID) PURE;		// [OUT] ID of the specific vendor.

};


//*****************************************************************************
// Assembly Declarations
//*****************************************************************************

typedef struct
{
	DWORD		dwOSPlatformId;			// Operating system platform.
	DWORD		dwOSMajorVersion;		// OS Major version.
	DWORD		dwOSMinorVersion;		// OS Minor version.
} OSINFO;


typedef struct
{
	USHORT		usMajorVersion;			// Major Version.	
	USHORT		usMinorVersion;			// Minor Version.
	USHORT		usRevisionNumber;		// Revision Number.
	USHORT		usBuildNumber;			// Build Number.
	LCID		*rLocale;				// Locale array.
	ULONG		ulLocale;				// [IN/OUT] Size of the locale array/Actual # of entries filled in.
	DWORD		*rProcessor;			// Processor ID array.
	ULONG		ulProcessor;			// [IN/OUT] Size of the Processor ID array/Actual # of entries filled in.
	OSINFO		*rOS;					// OSINFO array.
	ULONG		ulOS;					// [IN/OUT]Size of the OSINFO array/Actual # of entries filled in.
	LPWSTR		szConfiguration;		// Configuration.
	ULONG		cbConfiguration;		// [IN/OUT]Size of the configuration buffer in wide chars/Actual size of configuration.
} ASSEMBLYMETADATA;


// {DB2B81D0-568F-11D3-9FB9-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataAssemblyEmit = 
{ 0xdb2b81d0, 0x568f, 0x11d3, { 0x9f, 0xb9, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3} };


//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyEmit
DECLARE_INTERFACE_(IMetaDataAssemblyEmit, IUnknown)
{
    STDMETHOD(DefineAssembly)(              // S_OK or error.
        const void  *pbOriginator,          // [IN] Originator of the assembly.
        ULONG       cbOriginator,           // [IN] Count of bytes in the Originator blob.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        LPCWSTR     szTitle,                // [IN] Title of the assembly.
        LPCWSTR     szDescription,          // [IN] Description.
        LPCWSTR     szDefaultAlias,         // [IN] Default alias for the Assembly.
        DWORD       dwAssemblyFlags,        // [IN] Flags.
        mdAssembly  *pma) PURE;             // [OUT] Returned Assembly token.

    STDMETHOD(DefineAssemblyRef)(           // S_OK or error.
        LPCWSTR     szAlias,                // [IN] Local alias for referenced assembly.
        const void  *pbOriginator,          // [IN] Originator of the assembly.
        ULONG       cbOriginator,           // [IN] Count of bytes in the Originator blob.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwAssemblyRefFlags,     // [IN] Token for Execution Location.
        mdAssemblyRef *pmdar) PURE;         // [OUT] Returned AssemblyRef token.

    STDMETHOD(DefineFile)(                  // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the file.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags,            // [IN] Flags.
        mdFile      *pmdf) PURE;            // [OUT] Returned File token.

    STDMETHOD(DefineComType)(               // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Com Type.
        LPCWSTR     szDescription,          // [IN] Description,
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the ComType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwComTypeFlags,         // [IN] Flags.
        mdComType   *pmdct) PURE;           // [OUT] Returned ComType token.

    STDMETHOD(DefineManifestResource)(      // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the resource.
        LPCWSTR     szDescription,          // [IN] Description.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        LPCWSTR     szMIMEType,             // [IN] MIMEType of the resource.
        LCID        lcid,                   // [IN] Locale of the resource.
        DWORD       dwResourceFlags,        // [IN] Flags.
        mdManifestResource  *pmdmr) PURE;   // [OUT] Returned ManifestResource token.

    STDMETHOD(DefineLocalizedResource)(     // S_OK or error.
        mdManifestResource tkmr,            // [IN] ManifestResource being localized, required.
        LCID        lcid,                   // [IN] Locale of the resource, required.
        mdFile      tkImplementation,       // [IN] mdFile that provides the localized resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the localized resource within the file, required.
        DWORD       dwFlags,                // [IN] Flags.
        mdLocalizedResource *pmdlr) PURE;   // [OUT] Returned LocalizedResource token.

    STDMETHOD(DefineExecutionLocation)(     // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Execution Location.
        LPCWSTR     szDescription,          // [IN] Description.
        LPCWSTR     szLocation,             // [IN] Location.
        DWORD       dwExecutionLocationFlags, // [IN] Flags.
        mdExecutionLocation *pmdel) PURE;   // [OUT] Returned Execution Location token.

    STDMETHOD(SetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
        const void  *pbOriginator,          // [IN] Originator of the assembly.
        ULONG       cbOriginator,           // [IN] Count of bytes in the Originator blob.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwAssemblyRefFlags) PURE; // [IN] Token for Execution Location.

    STDMETHOD(SetFileProps)(                // S_OK or error.
        mdFile      file,                   // [IN] File token.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags) PURE;      // [IN] Flags.

    STDMETHOD(SetComTypeProps)(             // S_OK or error.
        mdComType   ct,                     // [IN] ComType token.
        LPCWSTR     szDescription,          // [IN] Description,
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the ComType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        mdExecutionLocation tkExecutionLocation, // [IN] The token for Execution Location.
        DWORD       dwComTypeFlags) PURE;   // [IN] Flags.

};


// {C7B04A18-5690-11D3-9FB9-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataAssemblyImport = 
{ 0xc7b04a18, 0x5690, 0x11d3, { 0x9f, 0xb9, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3} };

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyImport
DECLARE_INTERFACE_(IMetaDataAssemblyImport, IUnknown)
{
    STDMETHOD(GetAssemblyProps)(            // S_OK or error.
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbOriginator,        // [OUT] Pointer to the Originator blob.
        ULONG       *pcbOriginator,         // [OUT] Count of bytes in the Originator Blob.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        LPWSTR      szTitle,                // [OUT] Title of the Assembly.
        ULONG       cchTitle,               // [IN] Size of buffer in wide chars.
        ULONG       *pchTitle,              // [OUT] Actual # of wide chars.
        LPWSTR      szDescription,          // [OUT] Description for the Assembly.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Acutal # of wide chars in buffer.
        LPWSTR      szDefaultAlias,         // [OUT] Default alias for the Assembly.
        ULONG       cchDefaultAlias,        // [IN] Size of buffer in wide chars.
        ULONG       *pchDefaultAlias,       // [OUT] Acutal # of wide chars in buffer.
        DWORD       *pdwAssemblyFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        LPWSTR      szAlias,                // [OUT] Local alias for referenced assembly.
        ULONG       cchAlias,               // [IN] Size of buffer in wide chars.
        ULONG       *pchAlias,              // [OUT] Actual # of wide chars.
        const void  **ppbOriginator,        // [OUT] Pointer to the Originator blob.
        ULONG       *pcbOriginator,         // [OUT] Count of bytes in the Originator Blob.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        mdExecutionLocation *ptkExecutionLocation,  // [OUT] Token for Execution Location.
        DWORD       *pdwAssemblyRefFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetFileProps)(                // S_OK or error.
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetComTypeProps)(             // S_OK or error.
        mdComType   mdct,                   // [IN] The ComType for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        LPWSTR      szDescription,          // [OUT] Buffer to fill with description.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Actual # of wide chars in description.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ComType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        mdExecutionLocation *ptkExecutionLocation,  // [OUT] The token for Execution Location.
        DWORD       *pdwComTypeFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        LPWSTR      szDescription,          // [OUT] Buffer to fill with description.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Actual # of wide chars in description.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ComType.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        LPWSTR      szMIMEType,             // [OUT] Buffer to fill with MIMEType.
        ULONG       cchMIMEType,            // [IN] Size of buffer in wide chars.
        ULONG       *pchMIMEType,           // [OUT] Actual # of wide chars in name.
        LCID        *pLcid,                 // [OUT] Locale of the Resource.
        DWORD       *pdwResourceFlags) PURE;// [OUT] Flags.

    STDMETHOD(GetLocalizedResourceProps)(   // S_OK or error.
        mdLocalizedResource mdlr,           // [IN] The LocalizedResource for which to get the properties.
        mdManifestResource  *ptkmr,         // [OUT] ManifestResource being localized.
        LCID        *pLcid,                 // [OUT] Locale of the localized resource.
        mdFile      *ptkImplementation,     // [OUT] File containing the localized resource.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the localized resource within the file.
        DWORD       *pdwFlags) PURE;        // [OUT] Flags.

    STDMETHOD(GetExecutionLocationProps)(   // S_OK or error.
        mdExecutionLocation mdel,           // [IN] The Execution Location for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        LPWSTR      szDescription,          // [OUT] Buffer to fill with description.
        ULONG       cchDescription,         // [IN] Size of buffer in wide chars.
        ULONG       *pchDescription,        // [OUT] Actual # of wide chars in description.
        LPWSTR      szLocation,             // [OUT] Buffer to fill with Location.
        ULONG       cchLocation,            // [IN] Size of buffer in wide chars.
        ULONG       *pchLocation,           // [OUT] Buffer to fill with Location.
        DWORD       *pdwExecutionLocationFlags) PURE;   // [OUT] Flags.

    STDMETHOD(EnumAssemblyRefs)(            // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
        ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumFiles)(                   // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdFile      rFiles[],               // [OUT] Put Files here.
        ULONG       cMax,                   // [IN] Max Files to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumComTypes)(                // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdComType   rComTypes[],            // [OUT] Put ComTypes here.
        ULONG       cMax,                   // [IN] Max ComTypes to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumManifestResources)(       // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
        ULONG       cMax,                   // [IN] Max Resources to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumLocalizedResources)(      // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdManifestResource tkmr,            // [IN] Manifest resource to scope the enumeration.
        mdLocalizedResource  rLocalizedResources[], // [OUT] Put LocalizedResources here.
        ULONG       cMax,                   // [IN] Max Resources to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.
    
    STDMETHOD(EnumExecutionLocations)(      // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdExecutionLocation rExecutionLocations[],  // [OUT] Put ExecutionLocations here.
        ULONG       cMax,                   // [IN] Max ExecutionLocations to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(GetAssemblyFromScope)(        // S_OK or error
        mdAssembly  *ptkAssembly) PURE;     // [OUT] Put token here.

    STDMETHOD(FindComTypeByName)(           // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ComType.
        mdComType   *ptkComType) PURE;      // [OUT] Put the ComType token here.

    STDMETHOD(FindManifestResourceByName)(  // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
        mdManifestResource *ptkManifestResource) PURE;  // [OUT] Put the ManifestResource token here.

    STDMETHOD_(void, CloseEnum)(
        HCORENUM hEnum) PURE;               // Enum to be closed.
};

//*****************************************************************************
// End Assembly Declarations
//*****************************************************************************

//*****************************************************************************
// IMetaDataDispenserEx declarations.
//*****************************************************************************

// {31BCFCE2-DAFB-11D2-9F81-00C04F79A0A3}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenserEx =
{ 0x31bcfce2, 0xdafb, 0x11d2, { 0x9f, 0x81, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3 } };

#undef	INTERFACE
#define INTERFACE IMetaDataDispenserEx
DECLARE_INTERFACE_(IMetaDataDispenserEx, IMetaDataDispenser)
{
	STDMETHOD(SetOption)(					// Return code.
		REFGUID		optionid,				// [in] GUID for the option to be set.
		const VARIANT *value) PURE;			// [in] Value to which the option is to be set.

	STDMETHOD(GetOption)(					// Return code.
		REFGUID		optionid,				// [in] GUID for the option to be set.
		VARIANT *pvalue) PURE;				// [out] Value to which the option is currently set.

	STDMETHOD(OpenScopeOnITypeInfo)(		// Return code.
		ITypeInfo	*pITI,					// [in] ITypeInfo to open.
		DWORD		dwOpenFlags,			// [in] Open mode flags.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.
};

//*****************************************************************************
//*****************************************************************************
//
// Registration declarations.  Will be replace by Services' Registration
//  implementation. 
//
//*****************************************************************************
//*****************************************************************************
// Various flags for use in installing a module or a composite
typedef enum 
{
    regNoCopy = 0x00000001,         // Don't copy files into destination    
    regConfig = 0x00000002,         // Is a configuration   
    regHasRefs = 0x00000004         // Has class references 
} CorRegFlags;

typedef enum 
{
    ctInvalid = 0,  
    ctNative = 1,                   // Native code class    
    ctJava = 2                      // Byte code class 
} CorClassType;


typedef GUID CVID;

typedef struct {
    short Major;    
    short Minor;    
    short Sub;  
    short Build;    
} CVStruct;


//*****************************************************************************
//*****************************************************************************
//
// CeeGen interfaces for generating in-memory COM+ files
//
//*****************************************************************************
//*****************************************************************************

typedef void *HCEESECTION;

typedef enum  {
    sdNone =        0,
    sdReadOnly =    IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA,
    sdReadWrite =   sdReadOnly | IMAGE_SCN_MEM_WRITE,
    sdExecute =     IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE
} CeeSectionAttr;

//
// Relocation types.
//

typedef enum  {
    // generate only a section-relative reloc, nothing into .reloc section
    srRelocAbsolute,
    // generate a .reloc for the top 16-bits of a 32 bit number
    srRelocHigh,
    // generate a .reloc for the bottom 16-bits of a 32 bit number
    srRelocLow,
    // generate a .reloc for a 32 bit number
    srRelocHighLow,
    // generate a .reloc for the top 16-bits of a 32 bit number, where the
    // bottom 16 bits are included in the next word in the .reloc table
    srRelocHighAdj,

    // generate a token map relocation, nothing into .reloc section 
    srRelocMapToken,

	// pre-fixup contents of memory are ptr rather than a section offset
	srRelocPtr = 0x8000,
	// legal enums which include the Ptr flag
	srRelocAbsolutePtr = srRelocAbsolute + srRelocPtr,
	srRelocHighLowPtr = srRelocHighLow + srRelocPtr,

/*
    // these are for compatibility and should not be used by new code

    // address should be added to the .reloc section
    srRelocNone = srRelocHighLow,
    // address should be not go into .reloc section
    srRelocRVA = srRelocAbsolute
*/
} CeeSectionRelocType;

typedef union  {
    USHORT highAdj;
} CeeSectionRelocExtra;

//-------------------------------------
//--- ICeeGen
//-------------------------------------
// {7ED1BDFF-8E36-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICeeGen = 
{ 0x7ed1bdff, 0x8e36, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };

DECLARE_INTERFACE_(ICeeGen, IUnknown)
{
    STDMETHOD (EmitString) (    
        LPWSTR lpString,                    // [IN] String to emit  
        ULONG *RVA) PURE;                   // [OUT] RVA for string emitted string  

    STDMETHOD (GetString) (     
        ULONG RVA,                          // [IN] RVA for string to return    
        LPWSTR *lpString) PURE;             // [OUT] Returned string    

    STDMETHOD (AllocateMethodBuffer) (  
        ULONG cchBuffer,                    // [IN] Length of buffer to create  
        UCHAR **lpBuffer,                   // [OUT] Returned buffer    
        ULONG *RVA) PURE;                   // [OUT] RVA for method 

    STDMETHOD (GetMethodBuffer) (   
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

    STDMETHOD (GetIMapTokenIface) (     
        IUnknown **pIMapToken) PURE;    

    STDMETHOD (GenerateCeeFile) () PURE;

    STDMETHOD (GetIlSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (GetStringSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (AddSectionReloc) (
        HCEESECTION section,    
        ULONG offset,   
        HCEESECTION relativeTo,     
        CeeSectionRelocType relocType) PURE;    

    // use these only if you have special section requirements not handled  
    // by other APIs    
    STDMETHOD (GetSectionCreate) (
        const char *name,   
        DWORD flags,    
        HCEESECTION *section) PURE; 

    STDMETHOD (GetSectionDataLen) (
        HCEESECTION section,    
        ULONG *dataLen) PURE;   

    STDMETHOD (GetSectionBlock) (
        HCEESECTION section,    
        ULONG len,  
        ULONG align=1,  
        void **ppBytes=0) PURE; 

    STDMETHOD (TruncateSection) (
        HCEESECTION section,    
        ULONG len) PURE;  

    STDMETHOD (GenerateCeeMemoryImage) (
        void **ppImage) PURE;
};

//*****************************************************************************
//*****************************************************************************
//
// End of CeeGen declarations.
//
//*****************************************************************************

//*****************************************************************************
//*****************************************************************************
//
// CorModule interfaces for generating in-memory modules
//
//*****************************************************************************
//*****************************************************************************

typedef enum {
    CORMODULE_MATCH             =   0x00,   // find an existing module that matches interfaces supported    
    CORMODULE_NEW               =   0x01,   // always create a new module and interfaces    
} ICorModuleInitializeFlags;

//-------------------------------------
//--- ICorModule
//-------------------------------------
// {2629F8E1-95E5-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICorModule = 
{ 0x2629f8e1, 0x95e5, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };
DECLARE_INTERFACE_(ICorModule, IUnknown)
{
    STDMETHOD (Initialize) (    
        DWORD flags,                        // [IN] flags to control emitter returned   
        REFIID riidCeeGen,                  // [IN] type of cee generator to initialize with    
        REFIID riidEmitter) PURE;           // [IN] type of emitter to initialize with  
    
    STDMETHOD (GetCeeGen) ( 
        ICeeGen **pCeeGen) PURE;            // [OUT] cee generator  

    STDMETHOD (GetMetaDataEmit) (   
        IMetaDataEmit **pEmitter) PURE;     // [OUT] emitter    
};

//*****************************************************************************
//*****************************************************************************
//
// End of CorModule declarations.
//
//*****************************************************************************

//**********************************************************************
//**********************************************************************
//--- IMetaDataTables
//-------------------------------------
// {CE43C120-E856-11d2-8C21-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataTables = 
{ 0xce43c120, 0xe856, 0x11d2, { 0x8c, 0x21, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };

DECLARE_INTERFACE_(IMetaDataTables, IUnknown)
{
	STDMETHOD (GetStringHeapSize) (    
		ULONG	*pcbStrings) PURE;			// [OUT] Size of the string heap.

	STDMETHOD (GetBlobHeapSize) (	 
		ULONG	*pcbBlobs) PURE;			// [OUT] Size of the Blob heap.

	STDMETHOD (GetGuidHeapSize) (	 
		ULONG	*pcbGuids) PURE;			// [OUT] Size of the Guid heap.

	STDMETHOD (GetUserStringHeapSize) (	 
		ULONG	*pcbBlobs) PURE;			// [OUT] Size of the User String heap.

	STDMETHOD (GetNumTables) (	  
		ULONG	*pcTables) PURE;			// [OUT] Count of tables.

	STDMETHOD (GetTableIndex) (	  
		ULONG	token,						// [IN] Token for which to get table index.
		ULONG	*pixTbl) PURE;				// [OUT] Put table index here.

	STDMETHOD (GetTableInfo) (	  
		ULONG	ixTbl,						// [IN] Which table.
		ULONG	*pcbRow,					// [OUT] Size of a row, bytes.
		ULONG	*pcRows,					// [OUT] Number of rows.
		ULONG	*pcCols,					// [OUT] Number of columns in each row.
		ULONG	*piKey,						// [OUT] Key column, or -1 if none.
		const char **ppName) PURE;			// [OUT] Name of the table.

	STDMETHOD (GetColumnInfo) (	  
		ULONG	ixTbl,						// [IN] Which Table
		ULONG	ixCol,						// [IN] Which Column in the table
		ULONG	*poCol,						// [OUT] Offset of the column in the row.
		ULONG	*pcbCol,					// [OUT] Size of a column, bytes.
		ULONG	*pType,						// [OUT] Type of the column.
		const char **ppName) PURE;			// [OUT] Name of the Column.

	STDMETHOD (GetCodedTokenInfo) (	  
		ULONG	ixCdTkn,					// [IN] Which kind of coded token.
		ULONG	*pcTokens,					// [OUT] Count of tokens.
		ULONG	**ppTokens,					// [OUT] List of tokens.
		const char **ppName) PURE;			// [OUT] Name of the CodedToken.

	STDMETHOD (GetRow) (	  
		ULONG	ixTbl,						// [IN] Which table.
		ULONG	rid,						// [IN] Which row.
		void	**ppRow) PURE;				// [OUT] Put pointer to row here.

	STDMETHOD (GetColumn) (	  
		ULONG	ixTbl,						// [IN] Which table.
		ULONG	ixCol,						// [IN] Which column.
		ULONG	rid,						// [IN] Which row.
		ULONG	*pVal) PURE;				// [OUT] Put the column contents here.

	STDMETHOD (GetString) (	  
		ULONG	ixString,					// [IN] Value from a string column.
		const char **ppString) PURE;		// [OUT] Put a pointer to the string here.

	STDMETHOD (GetBlob) (	  
		ULONG	ixBlob,						// [IN] Value from a blob column.
		ULONG	*pcbData,					// [OUT] Put size of the blob here.
		const void **ppData) PURE;			// [OUT] Put a pointer to the blob here.

	STDMETHOD (GetGuid) (	  
		ULONG	ixGuid,						// [IN] Value from a guid column.
		const GUID **ppGUID) PURE;			// [OUT] Put a pointer to the GUID here.

	STDMETHOD (GetUserString) (	  
		ULONG	ixUserString,				// [IN] Value from a UserString column.
		ULONG	*pcbData,					// [OUT] Put size of the UserString here.
		const void **ppData) PURE;			// [OUT] Put a pointer to the UserString here.

};
//**********************************************************************
// End of IMetaDataTables.
//**********************************************************************
//**********************************************************************

//**********************************************************************
//
// Predefined CustomValue and structures for these custom value
//
//**********************************************************************

//
// Native Link method custom value definitions. This is for N-direct support.
//

#define COR_NATIVE_LINK_CUSTOM_VALUE        L"COMPLUS_NativeLink"   
#define COR_NATIVE_LINK_CUSTOM_VALUE_ANSI   "COMPLUS_NativeLink"    

// count of chars for COR_NATIVE_LINK_CUSTOM_VALUE(_ANSI)
#define COR_NATIVE_LINK_CUSTOM_VALUE_CC     18  

#include <pshpack1.h>
typedef struct 
{
    BYTE        m_linkType;       // see CorNativeLinkType below    
    BYTE        m_flags;          // see CorNativeLinkFlags below   
    mdMemberRef m_entryPoint;     // member ref token giving entry point, format is lib:entrypoint  
} COR_NATIVE_LINK;
#include <poppack.h>

typedef enum 
{
    nltNone     = 1,    // none of the keywords are specified   
    nltAnsi     = 2,    // ansi keyword specified   
    nltUnicode  = 3,    // unicode keyword specified    
    nltAuto     = 4,    // auto keyword specified   
    nltOle      = 5,    // ole keyword specified    
} CorNativeLinkType;

typedef enum 
{
    nlfNone         = 0x00,     // no flags 
    nlfLastError    = 0x01,     // setLastError keyword specified   
    nlfNoMangle     = 0x02,     // nomangle keyword specified
} CorNativeLinkFlags;


#define COR_DUAL_CUSTOM_VALUE L"IsDual"
#define COR_DUAL_CUSTOM_VALUE_ANSI "IsDual"

#define COR_DISPATCH_CUSTOM_VALUE L"DISPID"
#define COR_DISPATCH_CUSTOM_VALUE_ANSI "DISPID"

//
// Security custom value definitions
//

#define COR_REQUIRES_SECOBJ_CUSTOM_VALUE L"REQ_SO"
#define COR_REQUIRES_SECOBJ_CUSTOM_VALUE_ANSI "REQ_SO"

#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE L"SecPermReq_Reqd"
#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE_ANSI "SecPermReq_Reqd"

#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE L"SecPermReq_Opt"
#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE_ANSI "SecPermReq_Opt"

#define COR_PERM_REQUEST_DENY_CUSTOM_VALUE L"SecPermReq_Deny"
#define COR_PERM_REQUEST_DENY_CUSTOM_VALUE_ANSI "SecPermReq_Deny"


#ifdef __cplusplus
}

//*****************************************************************************
//*****************************************************************************
//
// C O M +   s i g n a t u r e   s u p p o r t  
//
//*****************************************************************************
//*****************************************************************************

#ifndef FORCEINLINE
 #if defined( UNDER_CE ) || _MSC_VER < 1200
   #define FORCEINLINE inline
 #else
   #define FORCEINLINE __forceinline
 #endif
#endif

// return true if it is a primitive type, i.e. only need to store CorElementType
FORCEINLINE int CorIsPrimitiveType(CorElementType elementtype)
{
    return (elementtype < ELEMENT_TYPE_PTR);    
}


// Return true if element type is a modifier, i.e. ELEMENT_TYPE_MODIFIER bits are 
// turned on. For now, it is checking for ELEMENT_TYPE_PTR and ELEMENT_TYPE_BYREF
// as well. This will be removed when we turn on ELEMENT_TYPE_MODIFIER bits for 
// these two enum members.
//
FORCEINLINE int CorIsModifierElementType(CorElementType elementtype)
{
    if (elementtype == ELEMENT_TYPE_PTR || elementtype == ELEMENT_TYPE_BYREF)   
        return 1;   
    return  (elementtype & ELEMENT_TYPE_MODIFIER);  
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given a compressed integer(*pData), expand the compressed int to *pDataOut.
// Return value is the number of bytes that the integer occupies in the compressed format
// It is caller's responsibility to ensure pDataOut has at least 4 bytes to be written to.
//
// This function returns -1 if pass in with an incorrectly compressed data, such as
// (*pBytes & 0xE0) == 0XE0.
/////////////////////////////////////////////////////////////////////////////////////////////
//@future: BIGENDIAN work here.
inline ULONG CorSigUncompressBigData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    ULONG res;  

    // 1 byte data is handled in CorSigUncompressData   
//  _ASSERTE(*pData & 0x80);    

    // Medium.  
    if ((*pData & 0xC0) == 0x80)  // 10?? ????  
    {   
        res = 0;    
        ((BYTE *) &res)[1] = *pData++ & 0x3f;   
        ((BYTE *) &res)[0] = *pData++;  
    }   
    else // 110? ???? @todo: Should this be 11?? ????   
    {   
        ((BYTE *) &res)[3] = *pData++ & 0x1f;   
        ((BYTE *) &res)[2] = *pData++;  
        ((BYTE *) &res)[1] = *pData++;  
        ((BYTE *) &res)[0] = *pData++;  
    }   
    return res; 
}
FORCEINLINE ULONG CorSigUncompressData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    // Handle smallest data inline. 
    if ((*pData & 0x80) == 0x00)        // 0??? ????    
        return *pData++;    
    return CorSigUncompressBigData(pData);  
}
//@todo: remove this
inline ULONG CorSigUncompressData(      // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    ULONG       *pDataOut)              // [OUT] the expanded *pData    
{   
    ULONG       cb = -1;    
    BYTE const  *pBytes = reinterpret_cast<BYTE const*>(pData); 

    // Smallest.    
    if ((*pBytes & 0x80) == 0x00)       // 0??? ????    
    {   
        *pDataOut = *pBytes;    
        cb = 1; 
    }   
    // Medium.  
    else if ((*pBytes & 0xC0) == 0x80)  // 10?? ????    
    {   
        *pDataOut = ((*pBytes & 0x3f) << 8 | *(pBytes+1));  
        cb = 2; 
    }   
    else if ((*pBytes & 0xE0) == 0xC0)      // 110? ????    
    {   
        *pDataOut = ((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3));  
        cb = 4; 
    }   
    return cb;  

}

const static mdToken g_tkCorEncodeToken[3] ={mdtTypeDef, mdtTypeRef, mdtTypeSpec};

// uncompress a token
inline mdToken CorSigUncompressToken(   // return the token.    
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    mdToken     tk; 
    ULONG       tkType; 

    tk = CorSigUncompressData(pData);   
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    return tk;  
}

//@todo: remove
inline ULONG CorSigUncompressToken(     // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    mdToken     *pToken)                // [OUT] the expanded *pData    
{
    ULONG       cb; 
    mdToken     tk; 
    ULONG       tkType; 

    cb = CorSigUncompressData(pData, (ULONG *)&tk); 
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    *pToken = tk;   
    return cb;  
}

FORCEINLINE ULONG CorSigUncompressCallingConv(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return *pData++;    
}

enum {
    SIGN_MASK_ONEBYTE  = 0xffffffc0,        // Mask the same size as the missing bits.  
    SIGN_MASK_TWOBYTE  = 0xffffe000,        // Mask the same size as the missing bits.  
    SIGN_MASK_FOURBYTE = 0xf0000000,        // Mask the same size as the missing bits.  
};

// uncompress a signed integer
inline ULONG CorSigUncompressSignedInt( // return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    int         *pInt)                  // [OUT] the expanded *pInt 
{
    ULONG       cb; 
    ULONG       ulSigned;   
    ULONG       iData;  

    cb = CorSigUncompressData(pData, &iData);   
    if (cb == -1) return cb;    
    ulSigned = iData & 0x1; 
    iData = iData >> 1; 
    if (ulSigned)   
    {   
        if (cb == 1)    
        {   
            iData |= SIGN_MASK_ONEBYTE; 
        }   
        else if (cb == 2)   
        {   
            iData |= SIGN_MASK_TWOBYTE; 
        }   
        else    
        {   
            iData |= SIGN_MASK_FOURBYTE;    
        }   
    }   
    *pInt = iData;  
    return cb;  
}


// uncompress encoded element type
FORCEINLINE CorElementType CorSigUncompressElementType(//Element type
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return (CorElementType)*pData++;    
}
//@todo: remove
inline ULONG CorSigUncompressElementType(// return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    CorElementType *pElementType)       // [OUT] the expanded *pData    
{   
    *pElementType = (CorElementType)(*pData & 0x7f);    
    return 1;   
}



#pragma warning(disable:4244) // conversion from unsigned long to unsigned char
/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given an uncompressed unsigned integer (iLen), Store it to pDataOut in a compressed format.
// Return value is the number of bytes that the integer occupies in the compressed format.
// It is caller's responsibilityt to ensure *pDataOut has at least 4 bytes to write to.
//
// Note that this function returns -1 if iLen is too big to be compressed. We currently can
// only represent to 0x1FFFFFFF.
//
/////////////////////////////////////////////////////////////////////////////////////////////
inline ULONG CorSigCompressData(        // return number of bytes that compressed form of iLen will take    
    ULONG       iLen,                   // [IN] given uncompressed data 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{   
    BYTE        *pBytes = reinterpret_cast<BYTE *>(pDataOut);   

    if (iLen <= 0x7F)   
    {   
        *pBytes = (iLen & 0xFF);    
        return 1;   
    }   

    if (iLen <= 0x3FFF) 
    {   
        *pBytes = (iLen >> 8) | 0x80;   
        *(pBytes+1) = iLen & 0xFF;  
        return 2;   
    }   

    if (iLen <= 0x1FFFFFFF) 
    {   
        *pBytes = (iLen >> 24) | 0xC0;  
        *(pBytes+1) = (iLen >> 16) & 0xFF;  
        *(pBytes+2) = (iLen >> 8)  & 0xFF;  
        *(pBytes+3) = iLen & 0xFF;  
        return 4;   
    }   
    return -1;  

}

// compress a token
// The least significant bit of the first compress byte will indicate the token type.
//
inline ULONG CorSigCompressToken(       // return number of bytes that compressed form of iLen will take    
    mdToken     tk,                     // [IN] given token 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    RID         rid = RidFromToken(tk); 
    BYTE        *pBytes = reinterpret_cast<BYTE *>(pDataOut);   
    mdToken     ulTyp = TypeFromToken(tk);  

    if (rid > 0x3FFFFFF)    
        // token is too big to be compressed    
        return -1;  

    rid = (rid << 2);   

    // TypeDef is encoded with low bits 00  
    // TypeRef is encoded with low bits 01  
    // TypeSpec is encoded with low bits 10    
    //  
    if (ulTyp == g_tkCorEncodeToken[1]) 
    {   
        // make the last two bits 01    
        rid |= 0x1; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[2])    
    {   
        // make last two bits 0 
        rid |= 0x2; 
    }   
    return CorSigCompressData(rid, pDataOut);   
}

// compress a signed integer
// The least significant bit of the first compress byte will be the signed bit.
//
inline ULONG CorSigCompressSignedInt(   // return number of bytes that compressed form of iData will take   
    int         iData,                  // [IN] given integer   
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    ULONG       isSigned = 0;   

    if (iData < 0)  
        isSigned = 0x1; 

    if ((iData & SIGN_MASK_ONEBYTE) == 0 || (iData & SIGN_MASK_ONEBYTE) == SIGN_MASK_ONEBYTE)   
    {   
        iData &= ~SIGN_MASK_ONEBYTE;    
    }   
    else if ((iData & SIGN_MASK_TWOBYTE) == 0 || (iData & SIGN_MASK_TWOBYTE) == SIGN_MASK_TWOBYTE)  
    {   
        iData &= ~SIGN_MASK_TWOBYTE;    
    }   

    else if ((iData & SIGN_MASK_FOURBYTE) == 0 || (iData & SIGN_MASK_FOURBYTE) == SIGN_MASK_FOURBYTE)   
    {   
        iData &= ~SIGN_MASK_FOURBYTE;   
    }   
    else    
    {   
        // out of compressable range    
        return -1;  
    }   
    iData = iData << 1 | isSigned;  
    return CorSigCompressData(iData, pDataOut); 
}



// uncompress encoded element type
inline ULONG CorSigCompressElementType(// return number of bytes of that compressed data occupied in pData
    CorElementType et,                 // [OUT] the expanded *pData 
    void        *pData)                // [IN] compressed data  
{   
    BYTE        *pBytes = (BYTE *)(pData);  

    *pBytes = et;   
    return 1;   

}

#pragma warning(default:4244) // conversion from unsigned long to unsigned char

#endif	// __cplusplus

#endif // _COR_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\correg.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// File: CorReg.H
//
// Microsoft Confidential.	Public header file for COM+ 1.0 release.
//*****************************************************************************
#ifndef _CORREG_H_
#define _CORREG_H_
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//*****************************************************************************
// Required includes
#include <ole2.h>						// Definitions of OLE types.
//*****************************************************************************

#ifdef __cplusplus
extern "C" {
#endif

// Force 1 byte alignment for structures which must match.
#include <pshpack1.h>

#ifndef NODLLIMPORT
#define DLLIMPORT __declspec(dllimport)
#else
#define DLLIMPORT
#endif


//*****************************************************************************
//*****************************************************************************
//
// D L L   P U B L I C	 E N T R Y	  P O I N T   D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************
#if !defined(_META_DATA_NO_SCOPE_) || defined(_META_DATA_SCOPE_WRAPPER_)
//@todo: take out for RTM
STDAPI			CoGetCor(REFIID riid, void** ppv);
#endif

STDAPI			CoInitializeCor(DWORD fFlags);
STDAPI_(void)	CoUninitializeCor(void);



//*****************************************************************************
//*****************************************************************************
//
// M E T A - D A T A	D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************
// Token  definitions
typedef __int32 mdScope;	 // scope token
#define mdScopeNil ((mdScope)0)

typedef __int32 mdToken;				// Generic token
typedef __int32 mdModule;				// Module token (roughly, a scope)
typedef __int32 mdTypeDef;				// TypeDef in this scope
typedef __int32 mdInterfaceImpl;		// interface implementation token
typedef __int32 mdTypeRef;				// TypeRef reference (this or other scope)
typedef __int32 mdNamespace;			// namespace token
typedef __int32 mdCustomValue;			// attribute token

typedef __int32 mdResource; 			// CompReg.Resource
typedef __int32 mdCocatdef; 			// CompReg.Cocat
typedef __int32 mdCocatImpl;			// CompReg.CoclassCat
typedef __int32 mdMimeTypeImpl; 		// CompReg.CoclassMIME
typedef __int32 mdFormatImpl;			// CompReg.CoclassFormats
typedef __int32 mdProgID;				// CompReg.RedirectProgID
typedef __int32 mdRoleCheck;			// CompReg.RoleCheck

typedef unsigned long RID;

enum CorRegTokenType
{
	mdtTypeDef			= 0x00000000,
	mdtInterfaceImpl	= 0x01000000,
	mdtTypeRef			= 0x03000000,
	mdtNamespace		= 0x06000000,
	mdtCustomValue		= 0x07000000,

	mdtResource 		= 0x0B000000,
	mdtCocatImpl		= 0x0D000000,
	mdtMimeTypeImpl 	= 0x0E000000,
	mdtFormatImpl		= 0x0F000000,
	mdtProgID			= 0x10000000,
	mdtRoleCheck		= 0x11000000,

	mdtModule			= 0x14000000,
};

//
// Build / decompose tokens.
//
#define RidToToken(rid,tktype) ((rid) |= (tktype))
#define TokenFromRid(rid,tktype) ((rid) | (tktype))
#define RidFromToken(tk) ((RID) ((tk) & 0x00ffffff))
#define TypeFromToken(tk) ((tk) & 0xff000000)

#define mdTokenNil			((mdToken)0)
#define mdModuleNil 		((mdModule)mdtModule)
#define mdTypeDefNil		((mdTypeDef)mdtTypeDef)
#define mdInterfaceImplNil	((mdInterfaceImpl)mdtInterfaceImpl)
#define mdTypeRefNil		((mdTypeRef)mdtTypeRef)
#define mdNamespaceNil		((mdNamespace)mdtNamespace)
#define mdCustomValueNil	((mdCustomValue)mdtCustomValue)

#define mdResourceNil		((mdResource)mdtResource)
#define mdCocatImplNil		((mdCocatImpl)mdtCocatImpl)
#define mdMimeTypeImplNil	((mdMimeTypeImpl)mdtMimeTypeImpl)
#define mdFormatImplNil 	((mdFormatImpl)mdtFormatImpl)
#define mdProgIDNil 		((mdProgID)mdtProgID)
#define mdRoleCheckNil		((mdRoleCheck)mdtRoleCheck)

enum CorRegTypeAttr 	// Used by emit_defineclass
{
	tdPublic			=	0x0001, 	// Class is public scope

	// Use this mask to retrieve class layout informaiton
	// 0 is AutoLayout, 0x2 is LayoutSequential, 4 is ExplicitLayout
	tdLayoutMask		=	0x0006, 	
	tdAutoLayout		=	0x0000, 	// Class fields are auto-laid out
	tdLayoutSequential	=	0x0002, 	// Class fields are laid out sequentially
	tdExplicitLayout	=	0x0004, 	// Layout is supplied explicitly

	tdWrapperClass		=	0x0008, 	// This is a wrapper class

	tdFinal 			=	0x0010, 	// Class is final
	tdISSCompat 		=	0x0020, 	// InvokeSpecial backwards compatibility

	// Use tdStringFormatMask to retrieve string information
	tdStringFormatMask	=	0x00c0, 	
	tdAnsiClass 		=	0x0000, 	// LPTSTR is interpreted as ANSI in this class
	tdUnicodeClass		=	0x0040, 	// LPTSTR is interpreted as UNICODE
	tdAutoClass 		=	0x0080, 	// LPTSTR is interpreted automatically

	tdValueClass		=	0x0100, 	// Class has value based semantics
	tdInterface 		=	0x0200, 	// Class is an interface
	tdAbstract			=	0x0400, 	// Class is abstract
	tdImport			=	0x1000, 	// Class / interface is imported
	tdRecord			=	0x2000, 	// Class is a record (no methods or props)
	tdEnum				=	0x4000, 	// Class is an enum; static final values only

	tdReserved1 		=	0x0800, 	// reserve bit for internal use
	// tdReserved2			=	0x8000, 	// reserve bit for internal use
};

enum CorImplementType					// Used internally for implements table
{
	itImplements		=	0x0000, 	// Interfaces implemented or parent ifaces
	itEvents			=	0x0001, 	// Interfaces raised
	itRequires			=	0x0002, 
	itInherits			=	0x0004,
};

//-------------------------------------
//--- Registration support types
//-------------------------------------
enum CorClassActivateAttr 
{ 
	caaDeferCreate		=	0x0001, 			// supports deferred create 
	caaAppObject		=	0x0002, 			// class is AppObject 
	caaFixedIfaceSet	=	0x0004, 			// interface set is open (use QI) 
	caaIndependentlyCreateable	=	0x0100, 
	caaPredefined		=	0x0200,

	// mask for caaLB*
	caaLoadBalancing	=	0x0c00,
	caaLBNotSupported	=	0x0400,
	caaLBSupported		=	0x0800,
	caaLBNotSpecified	=	0x0000,

	// mask for caaOP*
	caaObjectPooling	=	0x3000,
	caaOPNotSupported	=	0x1000,
	caaOPSupported		=	0x2000,
	caaOPNotSpecified	=	0x0000,

	// mask for caaJA*
	caaJITActivation	=	0xc000,
	caaJANotSupported	=	0x4000,
	caaJASupported		=	0x8000,
	caaJANotSpecified	=	0x0000,
}; 

enum CorIfaceSvcAttr 
{
	mlNone				=	0x0001, 			// Not marshalled 
	mlAutomation		=	0x0002, 			// Standard marshalling 
	mlProxyStub 		=	0x0004, 			// Custom marshalling 

	// mask for mlDefer*
	mlDeferrable		=	0x0018, 			// Methods on this interface are queuable
	mlDeferNotSupported =	0x0008,
	mlDeferSupported	=	0x0010,
	mlDeferNotSpecified =	0x0000,
}; 

enum CocatImplAttr 
{ 
	catiaImplements 	=	0x0001, 			// coclass implements this category 
	catiaRequires		=	0x0002				// coclass requires this category 
}; 

enum  CorModuleExportAttr 
{ 
	moUsesGetLastError	=	0x0001				// Module uses GetLastError
}; 

enum CorModuleRegAttr 
{ 
	rmaCustomReg		=	0x0001
}; 

enum CorRegFormatAttr 
{ 
	rfaSupportsFormat	=	0x0001, 
	rfaConvertsFromFormat = 0x0002, 
	rfaConvertsToFormat =	0x0003, 
	rfaDefaultFormat	=	0x0004, 
	rfaIsFileExt		=	0x0005,
	rfaIsFileType		=	0x0006,
	rfaIsDataFormat 	=	0x0007
}; 

enum CorSynchAttr 
{ 
	sySupported 		=	0x0001, 
	syRequired			=	0x0002, 
	syRequiresNew		=	0x0004, 
	syNotSupported		=	0x0008, 
	syThreadAffinity	=	0x0010 
}; 

enum CorThreadingAttr 
{ 
	taMain				=	0x0001, 
	taSTA				=	0x0002, 
	taMTA				=	0x0004, 
	taNeutral			=	0x0008,
	taBoth				=	0x0010	
}; 

enum CorXactionAttr 
{ 
	xaSupported 		=	0x0001, 
	xaRequired			=	0x0002, 
	xaRequiresNew		=	0x0004, 
	xaNotSupported		=	0x0008,
	xaNoVote			=	0x0010
}; 

enum CorRoleCheckAttr
{
	rcChecksFor 		=	0x0001
};


//
// Opaque type for an enumeration handle.
//
typedef void *HCORENUM;

//
// GetSaveSize accuracy
//
#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
enum CorSaveSize
{
	cssAccurate = 0x0000,			// Find exact save size, accurate but slower.
	cssQuick = 0x0001				// Estimate save size, may pad estimate, but faster.
};
#endif
#define 	MAX_CLASS_NAME		255
#define 	MAX_PACKAGE_NAME	255

typedef unsigned __int64 CLASSVERSION;

// %%Prototypes: -------------------------------------------------------------

#ifndef DECLSPEC_SELECT_ANY
#define DECLSPEC_SELECT_ANY __declspec(selectany)
#endif // DECLSPEC_SELECT_ANY

// CLSID_Cor: {bee00000-ee77-11d0-a015-00c04fbbb884}
extern const GUID DECLSPEC_SELECT_ANY CLSID_Cor = 
{ 0xbee00010, 0xee77, 0x11d0, {0xa0, 0x15, 0x00, 0xc0, 0x4f, 0xbb, 0xb8, 0x84 } };

// CLSID_CorMetaDataDispenser: {E5CB7A31-7512-11d2-89CE-0080C792E5D8}
//	This is the "Master Dispenser", always guaranteed to be the most recent
//	dispenser on the machine.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenser = 
{ 0xe5cb7a31, 0x7512, 0x11d2, { 0x89, 0xce, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };


// CLSID_CorMetaDataDispenserReg: {435755FF-7397-11d2-9771-00A0C9B4D50C}
//	Dispenser coclass for version 1.0 meta data.  To get the "latest" bind
//	to CLSID_CorMetaDataDispenser.
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataDispenserReg = 
{ 0x435755ff, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_CorMetaDataReg: {87F3A1F5-7397-11d2-9771-00A0C9B4D50C}
// For COM+ 1.0 Meta Data, Data Driven Registration
extern const GUID DECLSPEC_SELECT_ANY CLSID_CorMetaDataReg = 
{ 0x87f3a1f5, 0x7397, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

// IID_IMetaDataInternal {02D601BB-C5B9-11d1-93F9-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataInternal = 
{ 0x2d601bb, 0xc5b9, 0x11d1, {0x93, 0xf9, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


// {AD93D71D-E1F2-11d1-9409-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataEmitTemp =
{ 0xad93d71d, 0xe1f2, 0x11d1, {0x94, 0x9, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


interface IMetaDataRegEmit;
interface IMetaDataRegImport;
interface IMetaDataDispenser;


// %%Interfaces: -------------------------------------------------------------
//-------------------------------------
//--- IMemory
//-------------------------------------
//---
// IID_IMemory: {06A3EA8A-0225-11d1-BF72-00C04FC31E12}
extern const GUID DECLSPEC_SELECT_ANY IID_IMemory = 
{ 0x6a3ea8a, 0x225, 0x11d1, {0xbf, 0x72, 0x0, 0xc0, 0x4f, 0xc3, 0x1e, 0x12 } };
//---
#undef	INTERFACE
#define INTERFACE IMemory
DECLARE_INTERFACE_(IMemory, IUnknown)
{
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface)	(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;

	// *** IMemory methods ***
	STDMETHOD(GetMemory)(void **pMem, ULONG *iSize) PURE;
	STDMETHOD(SetMemory)(void *pMem, ULONG iSize) PURE;
};

//-------------------------------------
//--- IMetaDataError
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataError =
{ 0xb81ff171, 0x20f3, 0x11d2, { 0x8d, 0xcc, 0x0, 0xa0, 0xc9, 0xb0, 0x9c, 0x19 } };

//---
#undef	INTERFACE
#define INTERFACE IMetaDataError
DECLARE_INTERFACE_(IMetaDataError, IUnknown)
{
	STDMETHOD(OnError)(HRESULT hrError, mdToken token) PURE;
};

//-------------------------------------
//--- IMapToken
//-------------------------------------
//---
// IID_IMapToken: {06A3EA8B-0225-11d1-BF72-00C04FC31E12}
extern const GUID DECLSPEC_SELECT_ANY IID_IMapToken = 
{ 0x6a3ea8b, 0x225, 0x11d1, {0xbf, 0x72, 0x0, 0xc0, 0x4f, 0xc3, 0x1e, 0x12 } };
//---
#undef	INTERFACE
#define INTERFACE IMapToken
DECLARE_INTERFACE_(IMapToken, IUnknown)
{
	STDMETHOD(Map)(ULONG tkImp, ULONG tkEmit) PURE;
};



//-------------------------------------
//--- IMetaDataDispenser
//-------------------------------------
//---
// {B81FF171-20F3-11d2-8DCC-00A0C9B09C19}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataDispenser =
{ 0x809c652e, 0x7396, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };
#undef	INTERFACE
#define INTERFACE IMetaDataDispenser
DECLARE_INTERFACE_(IMetaDataDispenser, IUnknown)
{
	STDMETHOD(DefineScope)( 				// Return code.
		REFCLSID	rclsid, 				// [in] What version to create.
		DWORD		dwCreateFlags,			// [in] Flags on the create.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

	STDMETHOD(OpenScope)(					// Return code.
		LPCWSTR 	szScope,				// [in] The scope to open.
		DWORD		dwOpenFlags,			// [in] Open mode flags.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

	STDMETHOD(OpenScopeOnStream)(			// Return code.
		IStream 	*pIStream,				// [in] The scope to open.
		DWORD		dwOpenFlags,			// [in] Open mode flags.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

	STDMETHOD(OpenScopeOnMemory)(			// Return code.
		LPCVOID 	pData,					// [in] Location of scope data.
		ULONG		cbData, 				// [in] Size of the data pointed to by pData.
		DWORD		dwOpenFlags,			// [in] Open mode flags.
		REFIID		riid,					// [in] The interface desired.
		IUnknown	**ppIUnk) PURE; 		// [out] Return interface on success.

};





//-------------------------------------
//--- IMetaDataRegEmit
//-------------------------------------
//---
#if defined(_META_DATA_NO_SCOPE_) || defined(_META_DATA_SCOPE_WRAPPER_)

// {601C95B9-7398-11d2-9771-00A0C9B4D50C}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegEmit = 
{ 0x601c95b9, 0x7398, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegEmitOld = 
{ 0xf28f419b, 0x62ca, 0x11d2, { 0x8f, 0x2c, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };


//---
#undef	INTERFACE
#define INTERFACE IMetaDataRegEmit
DECLARE_INTERFACE_(IMetaDataRegEmit, IUnknown)
{
	STDMETHOD(SetModuleProps)(				// S_OK or error.
		LPCWSTR 	szName, 				// [IN] If not NULL, the name to set.
		const GUID	*ppid,					// [IN] If not NULL, the GUID to set.
		LCID		lcid) PURE; 			// [IN] If not -1, the lcid to set.

	STDMETHOD(Save)(						// S_OK or error.
		LPCWSTR 	szFile, 				// [IN] The filename to save to.
		DWORD		dwSaveFlags) PURE;		// [IN] Flags for the save.

	STDMETHOD(SaveToStream)(				// S_OK or error.
		IStream 	*pIStream,				// [IN] A writable stream to save to.
		DWORD		dwSaveFlags) PURE;		// [IN] Flags for the save.

	STDMETHOD(GetSaveSize)( 				// S_OK or error.
		CorSaveSize fSave,					// [IN] cssAccurate or cssQuick.
		DWORD		*pdwSaveSize) PURE; 	// [OUT] Put the size here.

	STDMETHOD(Merge)(						// S_OK or error.
		IMetaDataRegImport *pImport,		// [IN] The scope to be merged.
		IMapToken	*pIMap) PURE;			// [IN] An object to receive token remap notices.

	STDMETHOD(DefineCustomValueAsBlob)(
		mdToken 	tkObj, 
		LPCWSTR 	szName, 
		void const	*pCustomValue, 
		ULONG		cbCustomValue, 
		mdCustomValue *pcv) PURE;

	STDMETHOD(DefineTypeDef)(				// S_OK or error.
		LPCWSTR 	szNamespace,			// [IN] Namespace that the TypeDef is in. Must be 0 in '98
		LPCWSTR 	szTypeDef,				// [IN] Name of TypeDef
		const GUID	*pguid, 				// [IN] Optional clsid
		CLASSVERSION *pVer, 				// [IN] Optional version
		DWORD		dwTypeDefFlags, 		// [IN] CustomValue flags
		mdToken 	tkExtends,				// [IN] extends this TypeDef or typeref 
		DWORD		dwExtendsFlags, 		// [IN] Extends flags
		mdToken 	rtkImplements[],		// [IN] Implements interfaces
		mdToken 	rtkEvents[],			// [IN] Events interfaces
		mdTypeDef	*ptd) PURE; 			// [OUT] Put TypeDef token here

	STDMETHOD(SetTypeDefProps)( 			// S_OK or error.
		mdTypeDef	td, 					// [IN] The TypeDef.
		CLASSVERSION *pVer, 				// [IN] Optional version.
		DWORD		dwTypeDefFlags, 		// [IN] TypeDef flags.
		mdToken 	tkExtends,				// [IN] Base TypeDef or TypeRef.
		DWORD		dwExtendsFlags, 		// [IN] Extends flags.
		mdToken 	rtkImplements[],		// [IN] Implemented interfaces.
		mdToken 	rtkEvents[]) PURE;		// [IN] Event interfaces.

	STDMETHOD(SetClassSvcsContext)(mdTypeDef td, DWORD dwClassActivateAttr, DWORD dwClassThreadAttr,
							DWORD dwXactionAttr, DWORD dwSynchAttr) PURE;

	STDMETHOD(DefineTypeRefByGUID)( 			// S_OK or error.			   
		GUID		*pguid, 				// [IN] The Type's GUID.		   
		mdTypeRef	*ptr) PURE; 			// [OUT] Put TypeRef token here.

	STDMETHOD(SetModuleReg)(DWORD dwModuleRegAttr, const GUID *pguid) PURE;
	STDMETHOD(SetClassReg)(mdTypeDef td, LPCWSTR szProgID,
							LPCWSTR szVIProgID, LPCWSTR szIconURL, ULONG ulIconResource, LPCWSTR szSmallIconURL,
							ULONG ulSmallIconResource, LPCWSTR szDefaultDispName) PURE;
	STDMETHOD(SetIfaceReg)(mdTypeDef td, DWORD dwIfaceSvcs, const GUID *proxyStub) PURE;
	STDMETHOD(SetCategoryImpl)(mdTypeDef td, GUID rGuidCoCatImpl[], GUID rGuidCoCatReqd[]) PURE;
	STDMETHOD(SetRedirectProgID)(mdTypeDef td, LPCWSTR rszRedirectProgID[]) PURE;
	STDMETHOD(SetMimeTypeImpl)(mdTypeDef td, LPCWSTR rszMimeType[]) PURE;

	STDMETHOD(SetFormatImpl)(				// S_OK or error.
		mdTypeDef	td, 					// [IN] The TypeDef.
		LPCWSTR 	rszFormatSupported[],	// [IN] If not 0, array of supported formats. 0 for EOL.
		LPCWSTR 	rszFormatConvertsFrom[],// [IN] If not 0, array of ConvertsFrom values.  "
		LPCWSTR 	rszFormatConvertsTo[],	// [IN] If not 0, array of ConvertsTo values.	 "
		LPCWSTR 	rszFormatDefault[], 	// [IN] If not 0, array of Default format.	Only one item.
		LPCWSTR 	rszFileExt[],			// [IN] If not 0, array of file extensions.   0 for EOL.
		LPCWSTR 	rszFileType[]) PURE;	// [IN] If not 0, array of file types.			 "

	STDMETHOD(SetRoleCheck)(				// S_OK or error.
		mdToken 	tk, 					// [IN] Object to place role on.
		LPCWSTR 	rszName[],				// [IN] Name for the role.
		DWORD		rdwRoleFlags[]) PURE;	// [IN] Flags for new role.

	STDMETHOD(SetHandler)(					// S_OK.
		IUnknown	*pUnk) PURE;			// [IN] The new error handler.
	
};

#endif // #if defined(_META_DATA_NO_SCOPE_) || defined(_META_DATA_SCOPE_WRAPPER_)

#if !defined(_META_DATA_NO_SCOPE_)

//@TODO:  $#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
// The following interface definition is being deprecated for COM+ 1.0
// and beyond.	Please convert to the new definition by defining _META_DATA_NO_SCOPE_
// in your build.
//@TODO:  $#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#

#if !defined(_META_DATA_SCOPE_WRAPPER_)
// {F28F419B-62CA-11d2-8F2C-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegEmit = 
{ 0xf28f419b, 0x62ca, 0x11d2, { 0x8f, 0x2c, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };
#endif

#undef	INTERFACE
#if defined(_META_DATA_SCOPE_WRAPPER_)
#define INTERFACE IMetaDataRegEmitOld
#else
#define INTERFACE IMetaDataRegEmit
#endif
DECLARE_INTERFACE_(INTERFACE, IUnknown)
{
	STDMETHOD(DefineScope)( 				// S_OK or error.
		DWORD	dwCreateFlags,				// [IN] Flags on the create.
		mdScope *pscope) PURE;				// [OUT] return scope here.

	STDMETHOD(SetModuleProps)(				// S_OK or error.
		mdScope 	scope,					// [IN] scope for which to set props.
		LPCWSTR 	szName, 				// [IN] If not NULL, the name to set.
		const GUID	*ppid,					// [IN] If not NULL, the GUID to set.
		LCID		lcid) PURE; 			// [IN] If not -1, the lcid to set.

	STDMETHOD(Save)(						// S_OK or error.
		mdScope 	es, 					// [IN] The scope to save.
		LPCWSTR 	szFile, 				// [IN] The filename to save to.
		DWORD		dwSaveFlags) PURE;		// [IN] Flags for the save.

	STDMETHOD(SaveToStream)(				// S_OK or error.
		mdScope 	es, 					// [IN] The scope to save.
		IStream 	*pIStream,				// [IN] A writable stream to save to.
		DWORD		dwSaveFlags) PURE;		// [IN] Flags for the save.

	STDMETHOD(GetSaveSize)( 				// S_OK or error.
		mdScope 	es, 					// [IN] The scope to query.
		CorSaveSize fSave,					// [IN] cssAccurate or cssQuick.
		DWORD		*pdwSaveSize) PURE; 	// [OUT] Put the size here.

	STDMETHOD_(void,Close)( 				// S_OK or error.
		mdScope 	scope) PURE;			// [IN] The scope to close.

	STDMETHOD(Merge)(						// S_OK or error.
		mdScope 	scEmit, 				// [IN] The scope to merge into.
		mdScope 	scImport,				// [IN] The scope to be merged.
		IMapToken	*pIMap) PURE;			// [IN] An object to receive token remap notices.

	STDMETHOD(DefineCustomValueAsBlob)(mdScope es, mdToken tkObj, LPCWSTR szName, 
							void const *pCustomValue, ULONG cbCustomValue, mdCustomValue *pcv) PURE;

	STDMETHOD(DefineTypeDef)(				// S_OK or error.
		mdScope 	es, 					// [IN] Emit scope
		LPCWSTR 	szNamespace,			// [IN] Namespace that the TypeDef is in. Must be 0 in '98
		LPCWSTR 	szTypeDef,				// [IN] Name of TypeDef
		const GUID	*pguid, 				// [IN] Optional clsid
		CLASSVERSION *pVer, 				// [IN] Optional version
		DWORD		dwTypeDefFlags, 		// [IN] CustomValue flags
		mdToken 	tkExtends,				// [IN] extends this TypeDef or typeref 
		DWORD		dwExtendsFlags, 		// [IN] Extends flags
		mdToken 	rtkImplements[],		// [IN] Implements interfaces
		mdToken 	rtkEvents[],			// [IN] Events interfaces
		mdTypeDef	*ptd) PURE; 			// [OUT] Put TypeDef token here

	STDMETHOD(SetTypeDefProps)( 			// S_OK or error.
		mdScope 	es, 					// [IN] The emit scope.
		mdTypeDef	td, 					// [IN] The TypeDef.
		CLASSVERSION *pVer, 				// [IN] Optional version.
		DWORD		dwTypeDefFlags, 		// [IN] TypeDef flags.
		mdToken 	tkExtends,				// [IN] Base TypeDef or TypeRef.
		DWORD		dwExtendsFlags, 		// [IN] Extends flags.
		mdToken 	rtkImplements[],		// [IN] Implemented interfaces.
		mdToken 	rtkEvents[]) PURE;		// [IN] Event interfaces.

	STDMETHOD(SetClassSvcsContext)(mdScope es, mdTypeDef td, DWORD dwClassActivateAttr, DWORD dwClassThreadAttr,
							DWORD dwXactionAttr, DWORD dwSynchAttr) PURE;

	STDMETHOD(DefineTypeRefByGUID)( 			// S_OK or error.			   
		mdScope 	sc, 					// [IN] The emit scope. 	   
		GUID		*pguid, 				// [IN] The Type's GUID.		   
		mdTypeRef	*ptr) PURE; 			// [OUT] Put TypeRef token here.

	STDMETHOD(SetModuleReg)(mdScope es, DWORD dwModuleRegAttr, const GUID *pguid) PURE;
	STDMETHOD(SetClassReg)(mdScope es, mdTypeDef td, LPCWSTR szProgID,
							LPCWSTR szVIProgID, LPCWSTR szIconURL, ULONG ulIconResource, LPCWSTR szSmallIconURL,
							ULONG ulSmallIconResource, LPCWSTR szDefaultDispName) PURE;
	STDMETHOD(SetIfaceReg)(mdScope es, mdTypeDef td, DWORD dwIfaceSvcs, const GUID *proxyStub) PURE;
	STDMETHOD(SetCategoryImpl)(mdScope es, mdTypeDef td, GUID rGuidCoCatImpl[], GUID rGuidCoCatReqd[]) PURE;
	STDMETHOD(SetRedirectProgID)(mdScope es, mdTypeDef td, LPCWSTR rszRedirectProgID[]) PURE;
	STDMETHOD(SetMimeTypeImpl)(mdScope es, mdTypeDef td, LPCWSTR rszMimeType[]) PURE;

	STDMETHOD(SetFormatImpl)(				// S_OK or error.
		mdScope 	es, 					// [IN] The emit scope.
		mdTypeDef	td, 					// [IN] The TypeDef.
		LPCWSTR 	rszFormatSupported[],	// [IN] If not 0, array of supported formats. 0 for EOL.
		LPCWSTR 	rszFormatConvertsFrom[],// [IN] If not 0, array of ConvertsFrom values.  "
		LPCWSTR 	rszFormatConvertsTo[],	// [IN] If not 0, array of ConvertsTo values.	 "
		LPCWSTR 	rszFormatDefault[], 	// [IN] If not 0, array of Default format.	Only one item.
		LPCWSTR 	rszFileExt[],			// [IN] If not 0, array of file extensions.   0 for EOL.
		LPCWSTR 	rszFileType[]) PURE;	// [IN] If not 0, array of file types.			 "

	STDMETHOD(SetRoleCheck)(				// S_OK or error.
		mdScope 	es, 					// [IN] Emit scope.
		mdToken 	tk, 					// [IN] Object to place role on.
		LPCWSTR 	rszName[],				// [IN] Name for the role.
		DWORD		rdwRoleFlags[]) PURE;	// [IN] Flags for new role.

	STDMETHOD(SetHandler)(					// S_OK.
		mdScope 	sc, 					// [IN] The scope.
		IUnknown	*pUnk) PURE;			// [IN] The new error handler.
	
};

#endif // !defined(_META_DATA_NO_SCOPE_)


//-------------------------------------
//--- IMetaDataRegImport
//-------------------------------------

#if defined(_META_DATA_NO_SCOPE_) || defined(_META_DATA_SCOPE_WRAPPER_)

// {4398B4FD-7399-11d2-9771-00A0C9B4D50C}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegImport = 
{ 0x4398b4fd, 0x7399, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// {F28F419A-62CA-11d2-8F2C-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegImportOld = 
{ 0xf28f419a, 0x62ca, 0x11d2, { 0x8f, 0x2c, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };

#undef	INTERFACE
#define INTERFACE IMetaDataRegImport
DECLARE_INTERFACE_(IMetaDataRegImport, IUnknown)
{
	STDMETHOD_(void, CloseEnum)(HCORENUM hEnum) PURE;
	STDMETHOD(CountEnum)(HCORENUM hEnum, ULONG *pulCount) PURE;
	STDMETHOD(ResetEnum)(HCORENUM hEnum, ULONG ulPos) PURE;
	STDMETHOD(EnumTypeDefs)(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
							ULONG cMax, ULONG *pcTypeDefs) PURE;
	STDMETHOD(EnumInterfaceImpls)(HCORENUM *phEnum, mdTypeDef td,
							mdInterfaceImpl rImpls[], ULONG cMax,
							ULONG* pcImpls) PURE;
	STDMETHOD(EnumTypeRefs)(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
							ULONG cMax, ULONG* pcTypeRefs) PURE;
	STDMETHOD(EnumCustomValues)(HCORENUM *phEnum, mdToken tk,
							mdCustomValue rCustomValues[], ULONG cMax,
							ULONG* pcCustomValues) PURE;
	STDMETHOD(EnumResources)(HCORENUM *phEnum, mdResource rResources[],
							ULONG cMax, ULONG* pcResources) PURE;
	STDMETHOD(EnumCategoryImpls)(HCORENUM *phEnum, mdTypeDef td, mdCocatImpl rCocatImpls[],
							ULONG cMax, ULONG* pcCocatImpls) PURE;
	STDMETHOD(EnumRedirectProgIDs)(HCORENUM *phEnum, mdTypeDef td, mdProgID rRedirectProgIDs[],
							ULONG cMax, ULONG* pcRedirectProgIDs) PURE;
	STDMETHOD(EnumMimeTypeImpls)(HCORENUM *phEnum, mdTypeDef td, mdMimeTypeImpl rMimeTypeImpls[],
							ULONG cMax, ULONG* pcMimeTypeImpls) PURE;
	STDMETHOD(EnumFormatImpls)(HCORENUM *phEnum, mdTypeDef td, mdFormatImpl rFormatImpls[],
							ULONG cMax, ULONG* pcFormatImpls) PURE;

	STDMETHOD(EnumRoleChecks)(				// S_OK or error.
		HCORENUM	*phEnum,				// [OUT] Return enumerator.
		mdToken 	tk, 					// [IN] Object to enumerate roles for.
		mdRoleCheck rRoleChecks[],			// [OUT] Place cMax tokens here.
		ULONG		cMax,					// [IN] Max size of rRoleChecks.
		ULONG		*pcRoleChecks) PURE;	// [Out] Place count of returned role checks here.

	STDMETHOD(FindTypeDefByName)(			// S_OK or error.
		LPCWSTR 	szNamespace,			// [IN] Namespace with the Type.
		LPCWSTR 	szTypeDef,				// [IN] Name of the Type.
		mdTypeDef	*ptd) PURE; 			// [OUT] Put the TypeDef token here.

	STDMETHOD(FindTypeDefByGUID)(			// S_OK or error.				
		const GUID	*pguid, 				// [IN] The GUID of the Type.
		mdTypeDef	*ptd) PURE; 			// [OUT] Put the TypeDef token here.

	STDMETHOD(FindCustomValue)(mdToken tk, LPCWSTR szName, mdCustomValue *pcv, 
							DWORD *pdwValueType) PURE;

	STDMETHOD(GetScopeProps)(LPWSTR szName, ULONG cchName, ULONG *pchName,
							GUID *ppid, GUID *pmvid, LCID *pLcid) PURE;

	STDMETHOD(GetModuleFromScope)(			// S_OK.
		mdModule	*pmd) PURE; 			// [OUT] Put mdModule token here.

	STDMETHOD(GetTypeDefProps)( 			// S_OK or error.
		mdTypeDef	td, 					// [IN] TypeDef token for inquiry.
		LPWSTR		szNamespace,			// [OUT] Put Namespace here.
		ULONG		cchNamespace,			// [IN] size of Namespace buffer in wide chars.
		ULONG		*pchNamespace,			// [OUT] put size of Namespace (wide chars) here.
		LPWSTR		szTypeDef,				// [OUT] Put name here.
		ULONG		cchTypeDef, 			// [IN] size of name buffer in wide chars.
		ULONG		*pchTypeDef,			// [OUT] put size of name (wide chars) here.
		GUID		*pguid, 				// [OUT] Put clsid here.
		CLASSVERSION *pver, 				// [OUT] Put version here.
		DWORD		*pdwTypeDefFlags,		// [OUT] Put flags here.
		mdToken 	*ptkExtends,			// [OUT] Put base class TypeDef/TypeRef here.
		DWORD		*pdwExtendsFlags) PURE; // [OUT] Put extends flags here.

	STDMETHOD(GetClassSvcsContext)(mdTypeDef td, DWORD *pdwClassActivateAttr, DWORD *pdwThreadAttr,
							DWORD *pdwXactonAttr, DWORD *pdwSynchAttr) PURE;

	STDMETHOD(GetInterfaceImplProps)(		// S_OK or error.
		mdInterfaceImpl iiImpl, 			// [IN] InterfaceImpl token.
		mdTypeDef	*pClass,				// [OUT] Put implementing class token here.
		mdToken 	*ptkIface,				// [OUT] Put implemented interface token here.
		DWORD		*pdwFlags) PURE;		// [OUT] Put implementation flags here.

	STDMETHOD(GetCustomValueProps)(mdCustomValue cv, LPWSTR szName, ULONG cchName,
							ULONG *pchName, DWORD *pdwValueType) PURE;
	STDMETHOD(GetCustomValueAsBlob)(mdCustomValue cv, void const **ppBlob, ULONG *pcbSize) PURE;

	STDMETHOD(GetTypeRefProps)(mdTypeRef tr, LPWSTR szTypeRef,
							ULONG cchTypeRef, ULONG *pchTypeRef, GUID *pGuid, DWORD *pdwBind) PURE;

	STDMETHOD(GetModuleRegProps)(DWORD *pModuleRegAttr, GUID *pguid) PURE;	
	STDMETHOD(GetClassRegProps)(mdTypeDef td, 
							LPWSTR szProgid, ULONG cchProgid, ULONG *pchProgid, 
							LPWSTR szVIProgid, ULONG cchVIProgid, ULONG *pchVIProgid, 
							LPWSTR szIconURL, ULONG cchIconURL, ULONG *pchIconURL, ULONG *pIconResource, 
							LPWSTR szSmallIconURL, ULONG cchSmallIconURL, ULONG *pchSmallIconURL, ULONG *pSmallIconResource, 
							LPWSTR szDefaultDispname, ULONG cchDefaultDispname, ULONG *pchDefaultDispname) PURE;
	STDMETHOD(GetIfaceRegProps)(mdTypeDef td, DWORD *pdwIfaceSvcs, GUID *pProxyStub) PURE;
	STDMETHOD(GetResourceProps)(mdResource rs, LPWSTR szURL, ULONG cchURL, ULONG *pchURL) PURE;
	STDMETHOD(GetCategoryImplProps)(mdCocatImpl cocat, GUID *pguid, DWORD *pdwCocatImplAttr) PURE;
	STDMETHOD(GetRedirectProgIDProps)(mdProgID progid, 
							LPWSTR szProgID, ULONG cchProgID, ULONG *pchProgID) PURE;
	STDMETHOD(GetMimeTypeImplProps)(mdMimeTypeImpl mime, 
							LPWSTR szMime, ULONG cchMime, ULONG *pchMime) PURE;
	STDMETHOD(GetFormatImplProps)( mdFormatImpl format, 
							LPWSTR szFormat, ULONG cchFormat, ULONG *pchFormat, 
							DWORD *pdwRegFormatAttr) PURE;

	STDMETHOD(GetRoleCheckProps)(			// S_OK or error.
		mdRoleCheck rc, 					// [IN] The role check to get props for.
		LPWSTR		szName, 				// [OUT] Buffer for name.
		ULONG		cchName,				// [IN] Max characters for szName.
		ULONG		*pchName,				// [OUT] Available string chars for szName.
		DWORD		*pdwRoleFlags) PURE;	// [OUT] Role flags go here.

	STDMETHOD(ResolveTypeRef)(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd) PURE;
};

#endif // defined(_META_DATA_NO_SCOPE_) || defined(_META_DATA_SCOPE_WRAPPER_)

#if !defined(_META_DATA_NO_SCOPE_)

//@TODO:  $#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
// The following interface definition is being deprecated for COM+ 1.0
// and beyond.	It still exists to make porting to the new api easier.	If
// you need to, define _META_DATA_NO_SCOPE_ to get the old behavior.
//@TODO:  $#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#


#if !defined(_META_DATA_SCOPE_WRAPPER_)
// {F28F419A-62CA-11d2-8F2C-00A0C9A6186D}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegImport = 
{ 0xf28f419a, 0x62ca, 0x11d2, { 0x8f, 0x2c, 0x0, 0xa0, 0xc9, 0xa6, 0x18, 0x6d } };
#endif

#undef	INTERFACE
#if defined(_META_DATA_SCOPE_WRAPPER_)
#define INTERFACE IMetaDataRegImportOld
#else
#define INTERFACE IMetaDataRegImport
#endif
DECLARE_INTERFACE_(INTERFACE, IUnknown)
{
	STDMETHOD(OpenScope)(LPCWSTR szScope, DWORD dwOpenFlags, mdScope *pscope) PURE;
	STDMETHOD(OpenScopeOnStream)(IStream *pIStream, DWORD dwOpenFlags, mdScope *psc) PURE;
	STDMETHOD(OpenScopeOnMemory)(LPCVOID pData, ULONG cbData, mdScope *psc) PURE;
	STDMETHOD_(void,Close)(mdScope scope) PURE;

	STDMETHOD_(void, CloseEnum)(mdScope scope, HCORENUM hEnum) PURE;
	STDMETHOD(CountEnum)(mdScope scope, HCORENUM hEnum, ULONG *pulCount) PURE;
	STDMETHOD(ResetEnum)(mdScope scope, HCORENUM hEnum, ULONG ulPos) PURE;
	STDMETHOD(EnumTypeDefs)(mdScope scope, HCORENUM *phEnum, mdTypeDef rTypeDefs[],
							ULONG cMax, ULONG *pcTypeDefs) PURE;
	STDMETHOD(EnumInterfaceImpls)(mdScope scope, HCORENUM *phEnum, mdTypeDef td,
							mdInterfaceImpl rImpls[], ULONG cMax,
							ULONG* pcImpls) PURE;
	STDMETHOD(EnumTypeRefs)(mdScope scope, HCORENUM *phEnum, mdTypeRef rTypeRefs[],
							ULONG cMax, ULONG* pcTypeRefs) PURE;
	STDMETHOD(EnumCustomValues)(mdScope scope, HCORENUM *phEnum, mdToken tk,
							mdCustomValue rCustomValues[], ULONG cMax,
							ULONG* pcCustomValues) PURE;
	STDMETHOD(EnumResources)(mdScope scope, HCORENUM *phEnum, mdResource rResources[],
							ULONG cMax, ULONG* pcResources) PURE;
	STDMETHOD(EnumCategoryImpls)(mdScope scope, HCORENUM *phEnum, mdTypeDef td, mdCocatImpl rCocatImpls[],
							ULONG cMax, ULONG* pcCocatImpls) PURE;
	STDMETHOD(EnumRedirectProgIDs)(mdScope scope, HCORENUM *phEnum, mdTypeDef td, mdProgID rRedirectProgIDs[],
							ULONG cMax, ULONG* pcRedirectProgIDs) PURE;
	STDMETHOD(EnumMimeTypeImpls)(mdScope scope, HCORENUM *phEnum, mdTypeDef td, mdMimeTypeImpl rMimeTypeImpls[],
							ULONG cMax, ULONG* pcMimeTypeImpls) PURE;
	STDMETHOD(EnumFormatImpls)(mdScope scope, HCORENUM *phEnum, mdTypeDef td, mdFormatImpl rFormatImpls[],
							ULONG cMax, ULONG* pcFormatImpls) PURE;

	STDMETHOD(EnumRoleChecks)(				// S_OK or error.
		mdScope 	scope,					// [IN] Import scope.
		HCORENUM	*phEnum,				// [OUT] Return enumerator.
		mdToken 	tk, 					// [IN] Object to enumerate roles for.
		mdRoleCheck rRoleChecks[],			// [OUT] Place cMax tokens here.
		ULONG		cMax,					// [IN] Max size of rRoleChecks.
		ULONG		*pcRoleChecks) PURE;	// [Out] Place count of returned role checks here.

	STDMETHOD(FindTypeDefByName)(			// S_OK or error.
		mdScope 	scope,					// [IN] The scope to search.
		LPCWSTR 	szNamespace,			// [IN] Namespace with the Type.
		LPCWSTR 	szTypeDef,				// [IN] Name of the Type.
		mdTypeDef	*ptd) PURE; 			// [OUT] Put the TypeDef token here.

	STDMETHOD(FindTypeDefByGUID)(			// S_OK or error.				
		mdScope 	scope,					// [IN] The scope to search.	
		const GUID	*pguid, 				// [IN] The GUID of the Type.
		mdTypeDef	*ptd) PURE; 			// [OUT] Put the TypeDef token here.

	STDMETHOD(FindCustomValue)(mdScope scope, mdToken tk, LPCWSTR szName, mdCustomValue *pcv, 
							DWORD *pdwValueType) PURE;

	STDMETHOD(GetScopeProps)(mdScope scope, LPWSTR szName, ULONG cchName, ULONG *pchName,
							GUID *ppid, GUID *pmvid, LCID *pLcid) PURE;

	STDMETHOD(GetModuleFromScope)(			// S_OK.
		mdScope 	scope,					// [IN] The scope.
		mdModule	*pmd) PURE; 			// [OUT] Put mdModule token here.

	STDMETHOD(GetTypeDefProps)( 			// S_OK or error.
		mdScope 	scope,					// [IN] The import scope.
		mdTypeDef	td, 					// [IN] TypeDef token for inquiry.
		LPWSTR		szNamespace,			// [OUT] Put Namespace here.
		ULONG		cchNamespace,			// [IN] size of Namespace buffer in wide chars.
		ULONG		*pchNamespace,			// [OUT] put size of Namespace (wide chars) here.
		LPWSTR		szTypeDef,				// [OUT] Put name here.
		ULONG		cchTypeDef, 			// [IN] size of name buffer in wide chars.
		ULONG		*pchTypeDef,			// [OUT] put size of name (wide chars) here.
		GUID		*pguid, 				// [OUT] Put clsid here.
		CLASSVERSION *pver, 				// [OUT] Put version here.
		DWORD		*pdwTypeDefFlags,		// [OUT] Put flags here.
		mdToken 	*ptkExtends,			// [OUT] Put base class TypeDef/TypeRef here.
		DWORD		*pdwExtendsFlags) PURE; // [OUT] Put extends flags here.

	STDMETHOD(GetClassSvcsContext)(mdScope es, mdTypeDef td, DWORD *pdwClassActivateAttr, DWORD *pdwThreadAttr,
							DWORD *pdwXactonAttr, DWORD *pdwSynchAttr) PURE;

	STDMETHOD(GetInterfaceImplProps)(		// S_OK or error.
		mdScope 	scope,					// [IN] The scope.
		mdInterfaceImpl iiImpl, 			// [IN] InterfaceImpl token.
		mdTypeDef	*pClass,				// [OUT] Put implementing class token here.
		mdToken 	*ptkIface,				// [OUT] Put implemented interface token here.
		DWORD		*pdwFlags) PURE;		// [OUT] Put implementation flags here.

	STDMETHOD(GetCustomValueProps)(mdScope scope, mdCustomValue cv, LPWSTR szName, ULONG cchName,
							ULONG *pchName, DWORD *pdwValueType) PURE;
	STDMETHOD(GetCustomValueAsBlob)(mdScope scope, mdCustomValue cv, void const **ppBlob, ULONG *pcbSize) PURE;

	STDMETHOD(GetTypeRefProps)(mdScope scope, mdTypeRef tr, LPWSTR szTypeRef,
							ULONG cchTypeRef, ULONG *pchTypeRef, GUID *pGuid, DWORD *pdwBind) PURE;

	STDMETHOD(GetModuleRegProps)(mdScope scope, DWORD *pModuleRegAttr, GUID *pguid) PURE;	
	STDMETHOD(GetClassRegProps)(mdScope scope, mdTypeDef td, 
							LPWSTR szProgid, ULONG cchProgid, ULONG *pchProgid, 
							LPWSTR szVIProgid, ULONG cchVIProgid, ULONG *pchVIProgid, 
							LPWSTR szIconURL, ULONG cchIconURL, ULONG *pchIconURL, ULONG *pIconResource, 
							LPWSTR szSmallIconURL, ULONG cchSmallIconURL, ULONG *pchSmallIconURL, ULONG *pSmallIconResource, 
							LPWSTR szDefaultDispname, ULONG cchDefaultDispname, ULONG *pchDefaultDispname) PURE;
	STDMETHOD(GetIfaceRegProps)(mdScope scope, mdTypeDef td, DWORD *pdwIfaceSvcs, GUID *pProxyStub) PURE;
	STDMETHOD(GetResourceProps)(mdScope scope, mdResource rs, LPWSTR szURL, ULONG cchURL, ULONG *pchURL) PURE;
	STDMETHOD(GetCategoryImplProps)(mdScope scope, mdCocatImpl cocat, GUID *pguid, DWORD *pdwCocatImplAttr) PURE;
	STDMETHOD(GetRedirectProgIDProps)(mdScope scope, mdProgID progid, 
							LPWSTR szProgID, ULONG cchProgID, ULONG *pchProgID) PURE;
	STDMETHOD(GetMimeTypeImplProps)(mdScope scope, mdMimeTypeImpl mime, 
							LPWSTR szMime, ULONG cchMime, ULONG *pchMime) PURE;
	STDMETHOD(GetFormatImplProps)(mdScope scope, mdFormatImpl format, 
							LPWSTR szFormat, ULONG cchFormat, ULONG *pchFormat, 
							DWORD *pdwRegFormatAttr) PURE;

	STDMETHOD(GetRoleCheckProps)(			// S_OK or error.
		mdScope 	scope,					// [IN] Import scope.
		mdRoleCheck rc, 					// [IN] The role check to get props for.
		LPWSTR		szName, 				// [OUT] Buffer for name.
		ULONG		cchName,				// [IN] Max characters for szName.
		ULONG		*pchName,				// [OUT] Available string chars for szName.
		DWORD		*pdwRoleFlags) PURE;	// [OUT] Role flags go here.

	STDMETHOD(ResolveTypeRef)(mdScope is, mdTypeRef tr, mdScope *pes, mdTypeDef *ptd) PURE;
};

#endif // _META_DATA_NO_SCOPE_



// Return to default padding.
#include <poppack.h>

#ifdef __cplusplus
}
#endif

#endif // _CORREG_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\corregservices.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// CorRegServices.H
//
// This file contains a private set of CLSID's that only COM+ 1.0 Services
// are allowed to use.  This keeps the OS components partioned from the
// Tools.

// Microsoft Confidential.	Public header file for COM+ 1.0 release.
//*****************************************************************************
#ifndef __CORREGSERVICES_H__
#define __CORREGSERVICES_H__
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef DECLSPEC_SELECT_ANY
#define DECLSPEC_SELECT_ANY __declspec(selectany)
#endif // DECLSPEC_SELECT_ANY


// CLSID_ServicesMetaDataDispenser: {063B79F5-7539-11d2-9773-00A0C9B4D50C}
extern const GUID DECLSPEC_SELECT_ANY CLSID_ServicesMetaDataDispenser = 
{ 0x63b79f5, 0x7539, 0x11d2, { 0x97, 0x73, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


// CLSID_ServicesMetaDataReg: {063B79F6-7539-11d2-9773-00A0C9B4D50C}
//	Dispenser coclass for version 1.0 meta data.  To get the "latest" bind
//	to CLSID_MetaDataDispenser.
extern const GUID DECLSPEC_SELECT_ANY CLSID_ServicesMetaDataReg = 
{ 0x63b79f6, 0x7539, 0x11d2, { 0x97, 0x73, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };


extern "C"
{

STDAPI	MetaDataDllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);
STDAPI	MetaDataDllRegisterServer();
STDAPI	MetaDataDllUnregisterServer();

}

#endif // __CORREGSERVICES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

        dbgutil.h

   Abstract:

      This module declares the DEBUG_PRINTS object used for writing trace
      to log files.

   Author:

      Murali R. Krishnan    ( MuraliK )    14-Dec-1994
      Modified to include a and other functions ( 22-Dec-1994)

   Revision History:
      MuraliK  16-May-1995   Added function to read debug flags.
      MuraliK  12-Sept-1996  Added functions to dump the output.
      JasAndre Dec-1998      Replaced tracing mechanism with WMI Eventing
      JasAndre March-2000    Replaced dbgutil.h with this file, formerly 
                             known as pudebug.h

--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

#include <wmistr.h>
#include <evntrace.h>

# ifndef dllexp
# define dllexp   __declspec( dllexport)
# endif // dllexp

/***********************************************************
 *    Macros
 ************************************************************/

# define MAX_LABEL_LENGTH               (100)

// The WINNT defined tests are required so that the ui\setup\osrc project still
// compiles
#if defined(_WINNT_) || defined(WINNT)

#define REG_TRACE_ACS                   TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Tracing\\Standalone")
#define REG_TRACE_ACS_A                 "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Tracing\\Standalone"
#define REG_TRACE_IIS_ENABLED           TEXT("EnableTracing")

#define REG_TRACE_IIS_LOG_FILE_NAME     TEXT("LogFileName")
#define REG_TRACE_IIS_LOG_SESSION_NAME  TEXT("LogSessionName")
#define REG_TRACE_IIS_LOG_BUFFER_SIZE   TEXT("BufferSize")
#define REG_TRACE_IIS_LOG_MIN_BUFFERS   TEXT("MinBuffers")
#define REG_TRACE_IIS_LOG_MAX_BUFFERS   TEXT("MaxBuffers")
#define REG_TRACE_IIS_LOG_MAX_FILESIZE  TEXT("MaxFileSize")
#define REG_TRACE_IIS_LOG_REAL_TIME     TEXT("EnableRealTimeMode")
#define REG_TRACE_IIS_LOG_IN_MEMORY     TEXT("EnableInMemoryMode")
#define REG_TRACE_IIS_LOG_USER_MODE     TEXT("EnableUserMode")

#define REG_TRACE_IIS_ACTIVE            TEXT("Active")
#define REG_TRACE_IIS_CONTROL           TEXT("ControlFlags")
#define REG_TRACE_IIS_LEVEL             TEXT("Level")
#define REG_TRACE_IIS_ODS               TEXT("AlwaysODS")
#define REG_TRACE_IIS_GUID              L"Guid"

// Structure used to send trace information to the WMI eventing mechanism
typedef struct _TRACE_INFO
{
    EVENT_TRACE_HEADER TraceHeader;             // WMI Event header required at start of trace info
    MOF_FIELD MofFields[5];                     // Trace info. A MOF_FIELD is a {pointer, size} pair
} TRACE_INFO, *PTRACE_INFO;

//  class DEBUG_PRINTS
//
//  This class is responsible for printing messages to log file / kernel debugger
//
//  Currently the class supports only member functions for <ANSI> char.
//   ( not unicode-strings).
typedef struct _DEBUG_PRINTS {

    CHAR         m_rgchLabel[MAX_LABEL_LENGTH]; // Name of the module
    BOOL         m_bBreakOnAssert;              // Control flag for DBG_ASSERT
    GUID         m_guidControl;                 // Identifying GUID for the module
    int          m_iControlFlag;                // Control flag used for IF_DEBUG macros
    int          m_fAlwaysODS;                  // AlwaysODS flag for control of output
    int          *m_piErrorFlags;               // Bit mapped error flag used for DBGINFO etc macros
    TRACEHANDLE  m_hRegistration;               // WMI identifying handle for the module
    TRACEHANDLE  m_hLogger;                     // WMI logfile handle for the module

} DEBUG_PRINTS, *LPDEBUG_PRINTS;


// Structure used by IISRTL to maintain the list of GUID's that can be 
// registered with the WMI eventing system
typedef struct _SGuidList {
    enum {
        TRACESIG = (('T') | ('R' << 8) | ('C' << 16) | ('$' << 24)),
    } dwSig;

    LIST_ENTRY   m_leEntry;
    DEBUG_PRINTS m_dpData;
    int          m_iDefaultErrorLevel;
    int          m_iInitializeFlags;
} SGuidList, *PSGuidList;

#else

typedef struct _DEBUG_PRINTS {

    CHAR         m_rgchLabel[MAX_LABEL_LENGTH];
    CHAR         m_rgchLogFilePath[MAX_PATH];
    CHAR         m_rgchLogFileName[MAX_PATH];
    HANDLE       m_LogFileHandle;
    HANDLE       m_StdErrHandle;
    BOOL         m_fInitialized;
    DWORD        m_dwOutputFlags;
    BOOL         m_fBreakOnAssert;

} DEBUG_PRINTS, FAR * LPDEBUG_PRINTS;

#endif


// The WINNT defined tests are required so that the ui\setup\osrc project still
// compiles
#if defined(_WINNT_) || defined(WINNT)

dllexp VOID
__stdcall PuInitiateDebug(VOID);
dllexp VOID
__stdcall PuUninitiateDebug(VOID);

LPDEBUG_PRINTS
__stdcall PuCreateDebugPrintsObject(
    IN const char * pszPrintLabel,
    IN GUID *       ControlGuid,
    IN int *        ErrorFlags,
    IN int          DefaultControlFlags);

// Frees the debug prints object and closes any file if necessary.
// Returns NULL on success or returns pDebugPrints on failure.
VOID
__stdcall PuDeleteDebugPrintsObject(
   IN OUT LPDEBUG_PRINTS  pDebugPrints
   );

VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...);                               // arglist

dllexp VOID
PuDbgPrintW(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const WCHAR *        pszFormat,
   ...);                               // arglist

dllexp VOID
VPuDbgPrintW(
   IN OUT LPDEBUG_PRINTS pDebugPrints,
   IN const char *       pszFilePath,
   IN int                nLineNum,
   IN const WCHAR *      pszFormat,
   IN va_list            argptr
);


// PuDbgDump() does not do any formatting of output.
// It just dumps the given message onto the debug destinations.
VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   );

dllexp VOID
PuDbgDumpW(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const WCHAR *        pszDump
   );

// PuDbgAssertFailed() *must* be __cdecl to properly capture the
// thread context at the time of the failure.
VOID
__cdecl
PuDbgAssertFailed(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszExpression);

VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    );

#else

LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
   IN const char * pszPrintLabel,
   IN DWORD  dwOutputFlags);

// Frees the debug prints object and closes any file if necessary.
// Returns NULL on success or returns pDebugPrints on failure.
LPDEBUG_PRINTS
PuDeleteDebugPrintsObject(
   IN OUT LPDEBUG_PRINTS  pDebugPrints);


VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...);                               // arglist

// PuDbgDump() does not do any formatting of output.
// It just dumps the given message onto the debug destinations.
VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   );

// PuDbgAssertFailed() *must* be __cdecl to properly capture the
// thread context at the time of the failure.
VOID
__cdecl
PuDbgAssertFailed(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszExpression,
   IN const char *         pszMessage);

VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    );

dllexp 
VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    );

dllexp 
VOID
PuSetDbgOutputFlags(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN DWORD                dwFlags);

dllexp 
DWORD
PuGetDbgOutputFlags(
   IN const LPDEBUG_PRINTS       pDebugPrints);

// Following functions return Win32 error codes.
// NO_ERROR if success
dllexp 
DWORD
PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFileName,
   IN const char *         pszPathForFile);

dllexp 
DWORD
PuReOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

dllexp 
DWORD
PuCloseDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

dllexp 
DWORD
PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault, IN LPDEBUG_PRINTS pDebugPrints);

dllexp 
DWORD
PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault, IN LPDEBUG_PRINTS pDebugPrints);

dllexp 
DWORD
PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg);

#endif

# ifdef __cplusplus
};
# endif // __cplusplus

// begin_user_unmodifiable
// The WINNT defined tests are required so that the ui\setup\osrc project still
// compiles
#if defined (_WINNT_) || defined (WINNT)

// The following enumerations are the values supplied by the user to select
// a particular logging level
#define DEBUG_LEVEL_TRC_FUNC  4
#define DEBUG_LEVEL_INFO        3
#define DEBUG_LEVEL_WARN        2
#define DEBUG_LEVEL_ERROR       1

// The following flags are used internally to track what level of tracing we 
// are currently using. Bitmapped for extensibility.
#define DEBUG_FLAG_ODS          0x00000001
#define DEBUG_FLAG_INFO         0x00000002
#define DEBUG_FLAG_WARN         0x00000004
#define DEBUG_FLAG_ERROR        0x00000008
#define DEBUG_FLAG_TRC_FUNC   0x00000010
// The top 8 bits are reserved for control fields, sometimes we need to mask
// these out
#define DEBUG_FLAG_LEVEL_MASK   (DEBUG_FLAG_ODS | DEBUG_FLAG_INFO | DEBUG_FLAG_WARN | DEBUG_FLAG_ERROR|DEBUG_FLAG_TRC_FUNC)
// Deferred means that we have initialized with WMI but not actually loaded the
// module yet, so save the state for later
#define DEBUG_FLAG_DEFERRED_START 0x4000000
// Initialize means that we want to register this with WMI when we start up
#define DEBUG_FLAG_INITIALIZE   0x8000000

// The following are used internally to determine whether to log or not based 
// on what the current state is
#define DEBUG_FLAGS_INFO        (DEBUG_FLAG_INFO | DEBUG_FLAG_TRC_FUNC)
#define DEBUG_FLAGS_WARN        (DEBUG_FLAG_INFO | DEBUG_FLAG_WARN | DEBUG_FLAG_TRC_FUNC)
#define DEBUG_FLAGS_ERROR       (DEBUG_FLAG_INFO | DEBUG_FLAG_WARN | DEBUG_FLAG_ERROR | DEBUG_FLAG_TRC_FUNC)
#define DEBUG_FLAGS_TRC_FUNC  (DEBUG_FLAG_TRC_FUNC)

#define DEBUG_FLAGS_ANY         (DEBUG_FLAG_INFO | DEBUG_FLAG_WARN | DEBUG_FLAG_ERROR|DEBUG_FLAG_TRC_FUNC)

// WMI Tracing allows us to specify a type with a message, so I am using this 
// so that we can specify whether a message is in ASCII or UNICODE. I will do
// this automatically for the caller. Most of the ID's 0x00-0x0F are taken by
// the WMI & OS services
#define EVENT_TRACE_TYPE_ASCII      0x10
#define EVENT_TRACE_TYPE_UNICODE    0x11

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
DEBUG_PRINTS *g_pDebug;         // define a global debug variable

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
int g_fErrorFlags;              // define a global error level variable

# if DBG

// For the CHK build we want ODS enabled. For an explanation of these flags see 
// the comment just after the definition of DBG_CONTEXT
# define DECLARE_DEBUG_PRINTS_OBJECT()                      \
         DEBUG_PRINTS  *  g_pDebug = NULL;                  \
         int              g_fErrorFlags = DEBUG_FLAG_ODS;

#else

# define DECLARE_DEBUG_PRINTS_OBJECT()          \
         DEBUG_PRINTS  *  g_pDebug = NULL;      \
         int              g_fErrorFlags = 0;

#endif

// The DEFAULT_TRACE_FLAGS is used in the CREATE_DEBUG macros to set the start
// up state for the control flags, m_iControlFlag, used in the IF_DEBUG macros.
// This define is added for the cases where there are no default flags.
# ifndef DEFAULT_TRACE_FLAGS
# define DEFAULT_TRACE_FLAGS     0
# endif

// Call the following macro only from the main of you executable, or COM object.
// The aim is to have this called only once per process so at the moment that
// means in Inetinfo, ACSARRAY, ACSREPL etc.
# define CREATE_INITIALIZE_DEBUG()  \
        PuInitiateDebug();

// Call the following macro only from the main of you executable, or COM object.
// This must called only once per process so at the last possible moment that 
// means in Inetinfo, ACSARRAY, ACSREPL etc. Its job is to test to see if a 
// trace file was created in the initiate and if so shut it down now
# define DELETE_INITIALIZE_DEBUG() \
        PuUninitiateDebug();

// Call the following macro as a normal part of your initialization for programs
//  planning to use the debugging class. This should be done inside the 
//  PROCESS_ATTTACH for most DLL's and COM objects
# define CREATE_DEBUG_PRINT_OBJECT(pszLabel, ControlGuid)  \
    { \
        g_pDebug = PuCreateDebugPrintsObject(pszLabel, (LPGUID) &ControlGuid, &g_fErrorFlags, DEFAULT_TRACE_FLAGS);\
    }

// Call the following macro once as part of the termination of programs
//    which uses the debugging class.
# define DELETE_DEBUG_PRINT_OBJECT()  \
    { \
        PuDeleteDebugPrintsObject(g_pDebug); \
        g_pDebug = NULL; \
    }

# define VALID_DEBUG_PRINT_OBJECT()     \
        (NULL != g_pDebug)

// Use the DBG_CONTEXT without any surrounding braces.
// This is used to pass the values for global DebugPrintObject
// and File/Line information
# define DBG_CONTEXT        g_pDebug, __FILE__, __LINE__

// The 4 main tracing macros, each one corresponds to a different level of 
// tracing
# define DBGTRCFUNC(args)   {if (g_fErrorFlags & DEBUG_FLAGS_TRC_FUNC) { PuDbgPrint args; }}
# define DBGINFO(args)      {if (g_fErrorFlags & DEBUG_FLAGS_INFO) { PuDbgPrint args; }}
# define DBGWARN(args)      {if (g_fErrorFlags & DEBUG_FLAGS_WARN) { PuDbgPrint args; }}
# define DBGERROR(args)     {if (g_fErrorFlags & DEBUG_FLAGS_ERROR) { PuDbgPrint args; }}

# define DBGTRCFUNCW(args)  {if (g_fErrorFlags & DEBUG_FLAGS_TRC_FUNC) { PuDbgPrintW args; }}
# define DBGINFOW(args)     {if (g_fErrorFlags & DEBUG_FLAGS_INFO) { PuDbgPrintW args; }}
# define DBGWARNW(args)     {if (g_fErrorFlags & DEBUG_FLAGS_WARN) { PuDbgPrintW args; }}
# define DBGERRORW(args)    {if (g_fErrorFlags & DEBUG_FLAGS_ERROR) { PuDbgPrintW args; }}

# if DBG

// Code is only available in CHK build
# define DBG_CODE(s)        s          

// The same 3 main tracing macros however in this case the macros are only compiled
// into the CHK build. This is necessary because some tracing info used functions or
// variables which are not compiled into the FRE build.
# define CHKTRCFUNC(args)   {if (g_fErrorFlags & DEBUG_FLAGS_TRC_FUNC) { PuDbgPrint args; }}
# define CHKINFO(args)      {if (g_fErrorFlags & DEBUG_FLAGS_INFO) { PuDbgPrint args; }}
# define CHKWARN(args)      {if (g_fErrorFlags & DEBUG_FLAGS_WARN) { PuDbgPrint args; }}
# define CHKERROR(args)     {if (g_fErrorFlags & DEBUG_FLAGS_ERROR) { PuDbgPrint args; }}

# define CHKTRCFUNCW(args)  {if (g_fErrorFlags & DEBUG_FLAGS_TRC_FUNC) { PuDbgPrintW args; }}
# define CHKINFOW(args)     {if (g_fErrorFlags & DEBUG_FLAGS_INFO) { PuDbgPrintW args; }}
# define CHKWARNW(args)     {if (g_fErrorFlags & DEBUG_FLAGS_WARN) { PuDbgPrintW args; }}
# define CHKERRORW(args)    {if (g_fErrorFlags & DEBUG_FLAGS_ERROR) { PuDbgPrintW args; }}

# define DBG_ASSERT(exp)    if ( !(exp)) { \
                                PuDbgAssertFailed( DBG_CONTEXT, #exp); \
                            } else {}

# define DBG_REQUIRE(exp)   DBG_ASSERT(exp)

# else

// Do Nothing
# define DBG_CODE(s)        ((void)0);
# define CHKTRCFUNC(args)   ((void)0);
# define CHKINFO(args)      ((void)0);
# define CHKWARN(args)      ((void)0);
# define CHKERROR(args)     ((void)0);
# define CHKTRCFUNCW(args)     ((void)0);
# define CHKINFOW(args)     ((void)0);
# define CHKWARNW(args)     ((void)0);
# define CHKERRORW(args)    ((void)0);
# define DBG_ASSERT(exp)    ((void)0);

# define DBG_REQUIRE(exp)   ((void) (exp));

# endif // #if DBG

# define DBGDUMP(args)      PuDbgDump  args

# define DBGDUMPW(args)     PuDbgDumpW  args

# endif // #if defined (_WINNT_) || defined (WINNT)

#ifdef UNICODE

#define DBGTRCFUNCT(args)   DBGTRCFUNCW(args)
#define DBGINFOT(args)      DBGINFOW(args)
#define DBGWARNT(args)      DBGINFOW(args)
#define DBGERRORT(args)     DBGERRORW(args)

#define DBGDUMPT(args)      DBGDUMPW(args)

#define CHKTRCFUNCT(args)   CHKTRCFUNCW(args)
#define CHKINFOT(args)      CHKINFOW(args)
#define CHKWARNT(args)      CHKWARNW(args)
#define CHKERRORT(args)     CHKWARNW(args)

#else

#define DBGTRCFUNCT(args)   DBGTRCFUNC(args)
#define DBGINFOT(args)      DBGINFO(args)
#define DBGWARNT(args)      DBGINFO(args)
#define DBGERRORT(args)     DBGERROR(args)

#define DBGDUMPT(args)      DBGDUMP(args)

#define CHKTRCFUNCT(args)   CHKTRCFUNC(args)
#define CHKINFOT(args)      CHKINFO(args)
#define CHKWARNT(args)      CHKWARN(args)
#define CHKERRORT(args)     CHKWARN(args)

#endif // #ifdef UNICODE

// end_user_unmodifiable

// begin_user_unmodifiable

// We want to use OUR ASSERT instead.
// #ifdef ASSERT
// # undef ASSERT
// #endif


// # define ASSERT(exp)        DBG_ASSERT(exp)

// The WINNT defined tests are required so that the ui\setup\osrc project still
// compiles
#if defined(_WINNT_) || defined(WINNT)

# define GET_DEBUG_FLAGS()        ( g_pDebug ? g_pDebug->m_iControlFlag : 0)

# define DEBUG_IF(arg, s)         if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                  } else {}

# define IF_DEBUG(arg)            if ( DEBUG_## arg & GET_DEBUG_FLAGS())

# if DBG

# define CHKDEBUG_IF(arg, s)      if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                  } else {}

# define IF_CHKDEBUG(arg)         if ( DEBUG_## arg & GET_DEBUG_FLAGS())


# else   // !DBG

# define CHKDEBUG_IF(arg, s)      // Do Nothing
# define IF_CHKDEBUG(arg)         if (0)

# endif // !DBG

# endif

// end_user_unmodifiable

// begin_user_modifiable

//
// Predefined DEBUG macros
//

// DLLMAIN      -   Used to log DLL_ATTACH & DLL_DETACH
// INIT_CLEAN   -   Used during DLL_ATTACH & DLL_DETACH for verbose logging
// PERIODIC     -   Used for a modules periodic output. Generally only use 
//                  this is if the module has only one periodic function or
//                  if it has a most frquently used periodic function
// METABASE     -   Used for generic metabase spew, such as Notify received
#define DEBUG_DLLMAIN                   0x80000000
#define DEBUG_INIT_CLEAN                0x40000000
#define DEBUG_PERIODIC                  0x20000000
#define DEBUG_METABASE                  0x10000000

// API_ENTRY    -   Used at the start of a function
// API_EXIT     -   Used at the end of a function
// ERROR        -   Generic controler for verbose error logging
// RELEASE      -   Outputs the count returned from release in the SAFERELEASE
//                  macro
#define DEBUG_API_ENTRY                 0x08000000
#define DEBUG_API_EXIT                  0x04000000
#define DEBUG_ERROR                     0x02000000
#define DEBUG_ADDRELEASE                0x01000000

// end_user_modifiable


/***********************************************************
 *    Platform Type related variables and macros
 ************************************************************/

//
// Enum for product types
//

typedef enum _PLATFORM_TYPE {

    PtInvalid = 0,                 // Invalid
    PtNtWorkstation = 1,           // NT Workstation
    PtNtServer = 2,                // NT Server
    PtWindows95 = 3,               // Windows 95
    PtWindows9x = 4                // Windows 9x - not implemented

} PLATFORM_TYPE;

//
// IISGetPlatformType is the function used to the platform type
//

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        );

//
// External Macros
//

#define InetIsNtServer( _pt )           ((_pt) == PtNtServer)
#define InetIsNtWksta( _pt )            ((_pt) == PtNtWorkstation)
#define InetIsWindows95( _pt )          ((_pt) == PtWindows95)
#define InetIsValidPT(_pt)              ((_pt) != PtInvalid)

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE    g_PlatformType;


// Use the DECLARE_PLATFORM_TYPE macro to declare the platform type
#define DECLARE_PLATFORM_TYPE()  \
   PLATFORM_TYPE    g_PlatformType = PtInvalid;

// Use the INITIALIZE_PLATFORM_TYPE to init the platform type
// This should typically go inside the DLLInit or equivalent place.
#define INITIALIZE_PLATFORM_TYPE()  \
   g_PlatformType = IISGetPlatformType();

//
// Additional Macros to use the Platform Type
//

#define TsIsNtServer( )         InetIsNtServer(g_PlatformType)
#define TsIsNtWksta( )          InetIsNtWksta(g_PlatformType)
#define TsIsWindows95()         InetIsWindows95(g_PlatformType)
#define IISIsValidPlatform()    InetIsValidPT(g_PlatformType)
#define IISPlatformType()       (g_PlatformType)


/***********************************************************
 *    Some utility functions for Critical Sections
 ************************************************************/

//
// IISSetCriticalSectionSpinCount() provides a thunk for the
// original NT4.0sp3 API SetCriticalSectionSpinCount() for CS with Spin counts
// Users of this function should definitely dynlink with kernel32.dll,
// Otherwise errors will surface to a large extent
//
extern
# ifdef __cplusplus
"C"
# endif // _cplusplus
DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
);


//
// Macro for the calls to SetCriticalSectionSpinCount()
//
# define SET_CRITICAL_SECTION_SPIN_COUNT( lpCS, dwSpins) \
  IISSetCriticalSectionSpinCount( (lpCS), (dwSpins))

//
// IIS_DEFAULT_CS_SPIN_COUNT is the default value of spins used by
//  Critical sections defined within IIS.
// NYI: We should have to switch the individual values based on experiments!
// Current value is an arbitrary choice
//
# define IIS_DEFAULT_CS_SPIN_COUNT   (1000)

//
// Initializes a critical section and sets its spin count
// to IIS_DEFAULT_CS_SPIN_COUNT.  Equivalent to
// InitializeCriticalSectionAndSpinCount(lpCS, IIS_DEFAULT_CS_SPIN_COUNT),
// but provides a safe thunking layer for older systems that don't provide
// this API.
//
extern
# ifdef __cplusplus
"C"
# endif // _cplusplus
VOID
MIISInitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

//
// Macro for the calls to InitializeCriticalSection()
//
# define MINITIALIZE_CRITICAL_SECTION(lpCS) MIISInitializeCriticalSection(lpCS)

# endif  // _DEBUG_HXX_

//
// The following macros allow the automatic naming of certain Win32 objects.
// See IIS\SVCS\IISRTL\WIN32OBJ.C for details on the naming convention.
//
// Set IIS_NAMED_WIN32_OBJECTS to a non-zero value to enable named events,
// semaphores, and mutexes.
//

#ifndef IIS_NAMED_WIN32_OBJECTS
  #if DBG
    #define IIS_NAMED_WIN32_OBJECTS 1
  #else
    #define IIS_NAMED_WIN32_OBJECTS 0
  #endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPTSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    );

HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPTSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );

HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPTSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    );

#ifdef __cplusplus
}   // extern "C"
#endif

#if IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    PuDbgCreateEvent(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (manual),                                                           \
        (state)                                                             \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    PuDbgCreateSemaphore(                                                   \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial),                                                          \
        (maximum)                                                           \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    PuDbgCreateMutex(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial)                                                           \
        )

#else   // !IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    CreateEvent(                                                            \
        NULL,                                                               \
        (manual),                                                           \
        (state),                                                            \
        NULL                                                                \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    CreateSemaphore(                                                        \
        NULL,                                                               \
        (initial),                                                          \
        (maximum),                                                          \
        NULL                                                                \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    CreateMutex(                                                            \
        NULL,                                                               \
        (initial),                                                          \
        NULL                                                                \
        )
#endif  // IIS_NAMED_WIN32_OBJECTS

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\comutil.h ===
/***
* comutil.h - Native C++ compiler COM support - BSTR, VARIANT wrappers header
*
*   Copyright (C) 1996-2001 Microsoft Corporation
*   All rights reserved.
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_COMUTIL)
#define _INC_COMUTIL

#include <ole2.h>

#ifdef _DEBUG
#include <assert.h>
#define _COM_ASSERT(x) assert(x)
#else
#define _COM_ASSERT(x) ((void)0)
#endif

#pragma warning(push)
#pragma warning(disable: 4290)
#pragma warning(disable: 4310)

#pragma push_macro("new")
#undef new

class _com_error;

void __stdcall _com_issue_error(HRESULT);

//////////////////////////////////////////////////////////////////////////////
//
// Forward class declarations
//
//////////////////////////////////////////////////////////////////////////////

class _bstr_t;
class _variant_t;

//////////////////////////////////////////////////////////////////////////////
//
// Error checking routines
//
//////////////////////////////////////////////////////////////////////////////

namespace _com_util {
    inline void CheckError(HRESULT hr) throw(_com_error)
    {
        if (FAILED(hr)) {
            _com_issue_error(hr);
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Routines for handling conversions between BSTR and char*
//
//////////////////////////////////////////////////////////////////////////////

namespace _com_util {
    // Convert char * to BSTR
    //
    BSTR __stdcall ConvertStringToBSTR(const char* pSrc) throw(_com_error);

    // Convert BSTR to char *
    //
    char* __stdcall ConvertBSTRToString(BSTR pSrc) throw(_com_error);
}

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for BSTR
//
//////////////////////////////////////////////////////////////////////////////

class _bstr_t {
public:
    // Constructors
    //
    _bstr_t() throw();
    _bstr_t(const _bstr_t& s) throw();
    _bstr_t(const char* s) throw(_com_error);
    _bstr_t(const wchar_t* s) throw(_com_error);
    _bstr_t(const _variant_t& var) throw(_com_error);
    _bstr_t(BSTR bstr, bool fCopy) throw(_com_error);

    // Destructor
    //
    ~_bstr_t() throw();

    // Assignment operators
    //
    _bstr_t& operator=(const _bstr_t& s) throw();
    _bstr_t& operator=(const char* s) throw(_com_error);
    _bstr_t& operator=(const wchar_t* s) throw(_com_error);
    _bstr_t& operator=(const _variant_t& var) throw(_com_error);

    // Operators
    //
    _bstr_t& operator+=(const _bstr_t& s) throw(_com_error);
    _bstr_t operator+(const _bstr_t& s) const throw(_com_error);

    // Friend operators
    //
    friend _bstr_t operator+(const char* s1, const _bstr_t& s2) throw(_com_error);
    friend _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2) throw(_com_error);

    // Extractors
    //
    operator const wchar_t*() const throw();
    operator wchar_t*() const throw();
    operator const char*() const throw(_com_error);
    operator char*() const throw(_com_error);

    // Comparison operators
    //
    bool operator!() const throw();
    bool operator==(const _bstr_t& str) const throw();
    bool operator!=(const _bstr_t& str) const throw();
    bool operator<(const _bstr_t& str) const throw();
    bool operator>(const _bstr_t& str) const throw();
    bool operator<=(const _bstr_t& str) const throw();
    bool operator>=(const _bstr_t& str) const throw();

    // Low-level helper functions
    //
    BSTR copy(bool fCopy = true) const throw(_com_error);
    unsigned int length() const throw();

    // Binary string assign
    //
    void Assign(BSTR s) throw(_com_error);

    // Get the physical BSTR
    //
    BSTR& GetBSTR() throw(_com_error);
    BSTR* GetAddress() throw(_com_error);

    // Attach to the internal BSTR w/o copying
    //
    void Attach(BSTR s) throw(_com_error);

    // Detach the internal BSTR
    //
    BSTR Detach() throw();

private:
    // Referenced counted wrapper
    //
    class Data_t {
    public:
        // Constructors
        //
        Data_t(const char* s) throw(_com_error);
        Data_t(const wchar_t* s) throw(_com_error);
        Data_t(BSTR bstr, bool fCopy) throw(_com_error);
        Data_t(const _bstr_t& s1, const _bstr_t& s2) throw(_com_error);

        // Reference counting routines
        //
        unsigned long AddRef() throw();
        unsigned long Release() throw();

        // Extractors
        //
        operator const wchar_t*() const throw();
        operator const char*() const throw(_com_error);

        // Low-level helper functions
        //
        const wchar_t* GetWString() const throw();
        wchar_t*& GetWString() throw();
        const char* GetString() const throw(_com_error);

        BSTR Copy() const throw(_com_error);
        void Assign(BSTR s) throw(_com_error);
        void Attach(BSTR s) throw();
        unsigned int Length() const throw();
        int Compare(const Data_t& str) const throw();

        // Exception agnostic wrapper for new
        //
        void* operator new(size_t sz);          

    private:
        wchar_t*        m_wstr;
        mutable char*   m_str;
        unsigned long   m_RefCount;

        // Never allow default construction
        //
        Data_t() throw();

        // Never allow copy
        //
        Data_t(const Data_t& s) throw();

        // Prevent deletes from outside. Release() must be used.
        //
        ~Data_t() throw();

        void _Free() throw();
    };

private:
    // Reference counted representation
    //
    Data_t* m_Data;

private:
    // Low-level utilities
    //
    void _AddRef() throw();
    void _Free() throw();
    int _Compare(const _bstr_t& str) const throw();
};

//////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline _bstr_t::_bstr_t() throw()
    : m_Data(NULL)
{
}

// Copy constructor
//
inline _bstr_t::_bstr_t(const _bstr_t& s) throw()
    : m_Data(s.m_Data)
{
    _AddRef();
}

// Construct a _bstr_t from a const char*
//
inline _bstr_t::_bstr_t(const char* s) throw(_com_error)
    : m_Data(new Data_t(s))
{
    if (m_Data == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Construct a _bstr_t from a const whar_t*
//
inline _bstr_t::_bstr_t(const wchar_t* s) throw(_com_error)
    : m_Data(new Data_t(s))
{
    if (m_Data == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Construct a _bstr_t from a BSTR.  If fCopy is FALSE, give control of
// data to the _bstr_t without making a new copy.
//
inline _bstr_t::_bstr_t(BSTR bstr, bool fCopy) throw(_com_error)
    : m_Data(new Data_t(bstr, fCopy))
{
    if (m_Data == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Destructor
//
inline _bstr_t::~_bstr_t() throw()
{
    _Free();
}

//////////////////////////////////////////////////////////////////////////////
//
// Assignment operators
//
//////////////////////////////////////////////////////////////////////////////

// Default assign operator
//
inline _bstr_t& _bstr_t::operator=(const _bstr_t& s) throw()
{
    if (this != &s) {
        _Free();
        m_Data = s.m_Data;
        _AddRef();
    }

    return *this;
}

// Assign a const char* to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const char* s) throw(_com_error)
{
    _COM_ASSERT((const char*) *this != s);

    _Free();
    m_Data = new Data_t(s);
    if (m_Data == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }

    return *this;
}

// Assign a const wchar_t* to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const wchar_t* s) throw(_com_error)
{
    _COM_ASSERT((const wchar_t*) *this != s);

    _Free();
    m_Data = new Data_t(s);
    if (m_Data == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }

    return *this;
}

//////////////////////////////////////////////////////////////////////////////
//
// Operators
//
//////////////////////////////////////////////////////////////////////////////

// Concatenate a _bstr_t onto this _bstr_t
//
inline _bstr_t& _bstr_t::operator+=(const _bstr_t& s) throw(_com_error)
{
    Data_t* newData = new Data_t(*this, s);
    if (newData == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }

    _Free();
    m_Data = newData;

    return *this;
}

// Return the concatenation of this _bstr_t with another _bstr_t
//
inline _bstr_t _bstr_t::operator+(const _bstr_t& s) const throw(_com_error)
{
    _bstr_t b = *this;
    b += s;

    return b;
}

//////////////////////////////////////////////////////////////////////////////
//
// Friend Operators
//
//////////////////////////////////////////////////////////////////////////////

// Return the concatenation of a const char* with a _bstr_t
//
inline _bstr_t operator+(const char* s1, const _bstr_t& s2) throw(_com_error)
{
    _bstr_t b = s1; 
    b += s2;

    return b;
}

// Return the concatenation of a const char* with a _bstr_t
//
inline _bstr_t operator+(const wchar_t* s1, const _bstr_t& s2) throw(_com_error)
{
    _bstr_t b = s1; 
    b += s2;

    return b;
}

//////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////

// Extract a const wchar_t*
//
inline _bstr_t::operator const wchar_t*() const throw()
{
    return (m_Data != NULL) ? m_Data->GetWString() : NULL;
}

// Extract a wchar_t*
//
inline _bstr_t::operator wchar_t*() const throw()
{
    return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);
}

// Extract a const char_t*
//
inline _bstr_t::operator const char*() const throw(_com_error)
{
    return (m_Data != NULL) ? m_Data->GetString() : NULL;
}

// Extract a char_t*
//
inline _bstr_t::operator char*() const throw(_com_error)
{
    return const_cast<char*>((m_Data != NULL) ? m_Data->GetString() : NULL);
}

//////////////////////////////////////////////////////////////////////////////
//
// Comparison operators
//
//////////////////////////////////////////////////////////////////////////////

inline bool _bstr_t::operator!() const throw()
{
    return (m_Data != NULL) ? !m_Data->GetWString() : true;
}

inline bool _bstr_t::operator==(const _bstr_t& str) const throw()
{
    return _Compare(str) == 0;
}

inline bool _bstr_t::operator!=(const _bstr_t& str) const throw()
{
    return _Compare(str) != 0;
}

inline bool _bstr_t::operator<(const _bstr_t& str) const throw()
{
    return _Compare(str) < 0;
}

inline bool _bstr_t::operator>(const _bstr_t& str) const throw()
{
    return _Compare(str) > 0;
}

inline bool _bstr_t::operator<=(const _bstr_t& str) const throw()
{
    return _Compare(str) <= 0;
}

inline bool _bstr_t::operator>=(const _bstr_t& str) const throw()
{
    return _Compare(str) >= 0;
}

//////////////////////////////////////////////////////////////////////////////
//
// Low-level help functions
//
//////////////////////////////////////////////////////////////////////////////

// Extract a copy of the wrapped BSTR
//
inline BSTR _bstr_t::copy(bool fCopy) const throw(_com_error)
{
    return (m_Data != NULL) ? (fCopy ? m_Data->Copy() : m_Data->GetWString()) : NULL;
}

// Return the length of the wrapped BSTR
//
inline unsigned int _bstr_t::length() const throw()
{
    return (m_Data != NULL) ? m_Data->Length() : 0;
}

// Binary string assign
//
inline void _bstr_t::Assign(BSTR s) throw(_com_error)
{
    if (m_Data != NULL) {
        m_Data->Assign(s); 
    } 
    else {
        m_Data = new Data_t(s, TRUE);
        if (m_Data == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }
}

// Get the physical BSTR
//
inline BSTR& _bstr_t::GetBSTR() throw(_com_error) 
{
    if (m_Data == NULL) {
        m_Data = new Data_t(0, FALSE);
        if (m_Data == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }
    return m_Data->GetWString();
}

inline BSTR* _bstr_t::GetAddress() throw(_com_error) 
{
    Attach(0);
    return &m_Data->GetWString();
}

// Attach to the internal BSTR w/o copying
//
inline void _bstr_t::Attach(BSTR s) throw(_com_error)
{
    if (m_Data != NULL) {
        m_Data->Attach(s); 
    } 
    else {
        m_Data = new Data_t(s, FALSE);
        if (m_Data == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }
}

// Detach the internal BSTR
//
inline BSTR _bstr_t::Detach() throw()
{
    BSTR b = m_Data->GetWString();
    m_Data->GetWString() = NULL;
    _Free();
    return b;
}

// AddRef the BSTR
//
inline void _bstr_t::_AddRef() throw()
{
    if (m_Data != NULL) {
        m_Data->AddRef();
    }
}

// Free the BSTR
//
inline void _bstr_t::_Free() throw()
{
    if (m_Data != NULL) {
        m_Data->Release();
        m_Data = NULL;
    }
}

// Compare two _bstr_t objects
//
inline int _bstr_t::_Compare(const _bstr_t& str) const throw()
{
    if (m_Data == str.m_Data) {
        return 0;
    }

    if (m_Data == NULL) {
        return -1;
    }

    if (str.m_Data == NULL) {
        return 1;
    }

    return m_Data->Compare(*str.m_Data);
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - Constructors
//
//////////////////////////////////////////////////////////////////////////////

// Construct a Data_t from a const char*
//
inline _bstr_t::Data_t::Data_t(const char* s) throw(_com_error)
    : m_str(NULL), m_RefCount(1)
{
    m_wstr = _com_util::ConvertStringToBSTR(s);
}

// Construct a Data_t from a const wchar_t*
//
inline _bstr_t::Data_t::Data_t(const wchar_t* s) throw(_com_error)
    : m_str(NULL), m_RefCount(1)
{
    m_wstr = ::SysAllocString(s);

    if (m_wstr == NULL && s != NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Construct a Data_t from a BSTR.  If fCopy is FALSE, give control of
// data to the Data_t without doing a SysAllocStringByteLen.
//
inline _bstr_t::Data_t::Data_t(BSTR bstr, bool fCopy) throw(_com_error)
    : m_str(NULL), m_RefCount(1)
{
    if (fCopy && bstr != NULL) {
        m_wstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
                                         ::SysStringByteLen(bstr));

        if (m_wstr == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }
    else {
        m_wstr = bstr;
    }
}

// Construct a Data_t from the concatenation of two _bstr_t objects
//
inline _bstr_t::Data_t::Data_t(const _bstr_t& s1, const _bstr_t& s2) throw(_com_error)
    : m_str(NULL), m_RefCount(1)
{
    const unsigned int l1 = s1.length();
    const unsigned int l2 = s2.length();

    m_wstr = ::SysAllocStringByteLen(NULL, (l1 + l2) * sizeof(wchar_t));

    if (m_wstr == NULL) {
        if (l1 + l2 == 0) {
            return;
        }
        _com_issue_error(E_OUTOFMEMORY);
    }

    const wchar_t* wstr1 = static_cast<const wchar_t*>(s1);

    if (wstr1 != NULL) {
        memcpy(m_wstr, wstr1, (l1 + 1) * sizeof(wchar_t));
    }

    const wchar_t* wstr2 = static_cast<const wchar_t*>(s2);

    if (wstr2 != NULL) {
        memcpy(m_wstr + l1, wstr2, (l2 + 1) * sizeof(wchar_t));
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - reference counting routines
//
//////////////////////////////////////////////////////////////////////////////

inline unsigned long _bstr_t::Data_t::AddRef() throw()
{
    InterlockedIncrement(reinterpret_cast<long*>(&m_RefCount));
    return m_RefCount;
}

inline unsigned long _bstr_t::Data_t::Release() throw()
{
    if (!InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount))) {
        delete this;
        return 0;
    }

    return m_RefCount;
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - extractors
//
//////////////////////////////////////////////////////////////////////////////

// Extract a const wchar_t*
//
inline _bstr_t::Data_t::operator const wchar_t*() const throw()
{
    return m_wstr;
}

// Extract a const char_t*
//
inline _bstr_t::Data_t::operator const char*() const throw(_com_error)
{
    return GetString();
}

//////////////////////////////////////////////////////////////////////////////
//
// Reference counted wrapper - helper functions
//
//////////////////////////////////////////////////////////////////////////////

inline const wchar_t* _bstr_t::Data_t::GetWString() const throw()
{
    return m_wstr;
}

inline wchar_t*& _bstr_t::Data_t::GetWString() throw()
{
    return m_wstr;
}

inline const char* _bstr_t::Data_t::GetString() const throw(_com_error)
{
    if (m_str == NULL) {
        m_str = _com_util::ConvertBSTRToString(m_wstr);
    }

    return m_str;
}

// Return a copy of the wrapped BSTR
//
inline BSTR _bstr_t::Data_t::Copy() const throw(_com_error)
{
    if (m_wstr != NULL) {
        BSTR bstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(m_wstr), ::SysStringByteLen(m_wstr));

        if (bstr == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }

        return bstr;
    }

    return NULL;
}

inline void _bstr_t::Data_t::Assign(BSTR s) throw(_com_error)
{
    _Free();
    if (s != NULL) {
        m_wstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(s), ::SysStringByteLen(s));
        m_str = 0;
    }
}

inline void _bstr_t::Data_t::Attach(BSTR s) throw()
{
    _Free();
    m_wstr = s;
    m_str = 0;
    m_RefCount = 1;
}

// Return the length of the wrapper BSTR
//
inline unsigned int _bstr_t::Data_t::Length() const throw()
{
    return m_wstr ? ::SysStringLen(m_wstr) : 0;
}

// Compare two wrapped BSTRs
//
inline int _bstr_t::Data_t::Compare(const _bstr_t::Data_t& str) const throw()
{
    if (m_wstr == NULL) {
        return str.m_wstr ? -1 : 0;
    }

    if (str.m_wstr == NULL) {
        return 1;
    }

    const unsigned int l1 = ::SysStringLen(m_wstr);
    const unsigned int l2 = ::SysStringLen(str.m_wstr);

    unsigned int len = l1;
    if (len > l2) {
        len = l2;
    }

    BSTR bstr1 = m_wstr;
    BSTR bstr2 = str.m_wstr;

    while (len-- > 0) {
        if (*bstr1++ != *bstr2++) {
            return bstr1[-1] - bstr2[-1];
        }
    }

    return (l1 < l2) ? -1 : (l1 == l2) ? 0 : 1;
}

// Exception agnostic wrapper for new
//
#ifdef _COM_OPERATOR_NEW_THROWS
inline void* _bstr_t::Data_t::operator new(size_t sz) {
    try {
        return ::operator new(sz);
    } catch (...) {
        return NULL;
    }
}
#else // _COM_OPERATOR_NEW_THROWS
inline void* _bstr_t::Data_t::operator new(size_t sz) {
    return ::operator new(sz);
}
#endif // _COM_OPERATOR_NEW_THROWS

// Destruct this object
//
inline _bstr_t::Data_t::~Data_t() throw()
{
    _Free();
}

// Free up this object
//
inline void _bstr_t::Data_t::_Free() throw()
{
    if (m_wstr != NULL) {
        ::SysFreeString(m_wstr);
    }

    if (m_str != NULL) {
        delete [] m_str;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Wrapper class for VARIANT
//
//////////////////////////////////////////////////////////////////////////////

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 * * [C] - supported by class _variant_t
 *
 *
 *  VT_EMPTY            [V]   [P]        nothing
 *  VT_NULL             [V]   [P]        SQL style Null
 *  VT_I2               [V][T][P][S][C]  2 byte signed int
 *  VT_I4               [V][T][P][S][C]  4 byte signed int
 *  VT_R4               [V][T][P][S][C]  4 byte real
 *  VT_R8               [V][T][P][S][C]  8 byte real
 *  VT_CY               [V][T][P][S][C]  currency
 *  VT_DATE             [V][T][P][S][C]  date
 *  VT_BSTR             [V][T][P][S][C]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S][C]  IDispatch *
 *  VT_ERROR            [V][T]   [S][C]  SCODE
 *  VT_BOOL             [V][T][P][S][C]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]     VARIANT *
 *  VT_UNKNOWN          [V][T]   [S][C]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S][C]  16 byte fixed point
 *  VT_I1                  [T]           signed char
 *  VT_UI1              [V][T][P][S][C]  unsigned char
 *  VT_UI2                 [T][P]        unsigned short
 *  VT_UI4                 [T][P]        unsigned short
 *  VT_I8                  [T][P]        signed 64-bit int
 *  VT_UI8                 [T][P]        unsigned 64-bit int
 *  VT_INT                 [T]           signed machine int
 *  VT_UINT                [T]           unsigned machine int
 *  VT_VOID                [T]           C style void
 *  VT_HRESULT             [T]           Standard return type
 *  VT_PTR                 [T]           pointer type
 *  VT_SAFEARRAY           [T]          (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]           C style array
 *  VT_USERDEFINED         [T]           user defined type
 *  VT_LPSTR               [T][P]        null terminated string
 *  VT_LPWSTR              [T][P]        wide null terminated string
 *  VT_FILETIME               [P]        FILETIME
 *  VT_BLOB                   [P]        Length prefixed bytes
 *  VT_STREAM                 [P]        Name of the stream follows
 *  VT_STORAGE                [P]        Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]        Stream contains an object
 *  VT_STORED_OBJECT          [P]        Storage contains an object
 *  VT_BLOB_OBJECT            [P]        Blob contains an object
 *  VT_CF                     [P]        Clipboard format
 *  VT_CLSID                  [P]        A Class ID
 *  VT_VECTOR                 [P]        simple counted array
 *  VT_ARRAY            [V]              SAFEARRAY*
 *  VT_BYREF            [V]              void* for local use
 */

class _variant_t : public ::tagVARIANT {
public:
    // Constructors
    //
    _variant_t() throw();

    _variant_t(const VARIANT& varSrc) throw(_com_error);
    _variant_t(const VARIANT* pSrc) throw(_com_error);
    _variant_t(const _variant_t& varSrc) throw(_com_error);

    _variant_t(VARIANT& varSrc, bool fCopy) throw(_com_error);          // Attach VARIANT if !fCopy

    _variant_t(short sSrc, VARTYPE vtSrc = VT_I2) throw(_com_error);    // Creates a VT_I2, or a VT_BOOL
    _variant_t(long lSrc, VARTYPE vtSrc = VT_I4) throw(_com_error);     // Creates a VT_I4, a VT_ERROR, or a VT_BOOL
    _variant_t(float fltSrc) throw();                                   // Creates a VT_R4
    _variant_t(double dblSrc, VARTYPE vtSrc = VT_R8) throw(_com_error); // Creates a VT_R8, or a VT_DATE
    _variant_t(const CY& cySrc) throw();                                // Creates a VT_CY
    _variant_t(const _bstr_t& bstrSrc) throw(_com_error);               // Creates a VT_BSTR
    _variant_t(const wchar_t *pSrc) throw(_com_error);                  // Creates a VT_BSTR
    _variant_t(const char* pSrc) throw(_com_error);                     // Creates a VT_BSTR
    _variant_t(IDispatch* pSrc, bool fAddRef = true) throw();           // Creates a VT_DISPATCH
    _variant_t(bool boolSrc) throw();                                   // Creates a VT_BOOL
    _variant_t(IUnknown* pSrc, bool fAddRef = true) throw();            // Creates a VT_UNKNOWN
    _variant_t(const DECIMAL& decSrc) throw();                          // Creates a VT_DECIMAL
    _variant_t(BYTE bSrc) throw();                                      // Creates a VT_UI1

    _variant_t(char cSrc) throw();                                      // Creates a VT_I1
    _variant_t(unsigned short usSrc) throw();                           // Creates a VT_UI2
    _variant_t(unsigned long ulSrc) throw();                            // Creates a VT_UI4
    _variant_t(int iSrc) throw();                                       // Creates a VT_INT
    _variant_t(unsigned int uiSrc) throw();                             // Creates a VT_UINT
    _variant_t(__int64 i8Src) throw();                                  // Creates a VT_I8
    _variant_t(unsigned __int64 ui8Src) throw();                        // Creates a VT_UI8

    // Destructor
    //
    ~_variant_t() throw(_com_error);

    // Extractors
    //
    operator short() const throw(_com_error);                           // Extracts a short from a VT_I2
    operator long() const throw(_com_error);                            // Extracts a long from a VT_I4
    operator float() const throw(_com_error);                           // Extracts a float from a VT_R4
    operator double() const throw(_com_error);                          // Extracts a double from a VT_R8
    operator CY() const throw(_com_error);                              // Extracts a CY from a VT_CY
    operator _bstr_t() const throw(_com_error);                         // Extracts a _bstr_t from a VT_BSTR
    operator IDispatch*() const throw(_com_error);                      // Extracts a IDispatch* from a VT_DISPATCH
    operator bool() const throw(_com_error);                            // Extracts a bool from a VT_BOOL
    operator IUnknown*() const throw(_com_error);                       // Extracts a IUnknown* from a VT_UNKNOWN
    operator DECIMAL() const throw(_com_error);                         // Extracts a DECIMAL from a VT_DECIMAL
    operator BYTE() const throw(_com_error);                            // Extracts a BTYE (unsigned char) from a VT_UI1
    operator VARIANT() const throw();

    operator char() const throw(_com_error);                            // Extracts a char from a VT_I1
    operator unsigned short() const throw(_com_error);                  // Extracts a unsigned short from a VT_UI2
    operator unsigned long() const throw(_com_error);                   // Extracts a unsigned long from a VT_UI4
    operator int() const throw(_com_error);                             // Extracts a int from a VT_INT
    operator unsigned int() const throw(_com_error);                    // Extracts a unsigned int from a VT_UINT
    operator __int64() const throw(_com_error);                         // Extracts a __int64 from a VT_I8
    operator unsigned __int64() const throw(_com_error);                // Extracts a unsigned __int64 from a VT_UI8

    // Assignment operations
    //
    _variant_t& operator=(const VARIANT& varSrc) throw(_com_error);
    _variant_t& operator=(const VARIANT* pSrc) throw(_com_error);
    _variant_t& operator=(const _variant_t& varSrc) throw(_com_error);

    _variant_t& operator=(short sSrc) throw(_com_error);                // Assign a VT_I2, or a VT_BOOL
    _variant_t& operator=(long lSrc) throw(_com_error);                 // Assign a VT_I4, a VT_ERROR or a VT_BOOL
    _variant_t& operator=(float fltSrc) throw(_com_error);              // Assign a VT_R4
    _variant_t& operator=(double dblSrc) throw(_com_error);             // Assign a VT_R8, or a VT_DATE
    _variant_t& operator=(const CY& cySrc) throw(_com_error);           // Assign a VT_CY
    _variant_t& operator=(const _bstr_t& bstrSrc) throw(_com_error);    // Assign a VT_BSTR
    _variant_t& operator=(const wchar_t* pSrc) throw(_com_error);       // Assign a VT_BSTR
    _variant_t& operator=(const char* pSrc) throw(_com_error);          // Assign a VT_BSTR
    _variant_t& operator=(IDispatch* pSrc) throw(_com_error);           // Assign a VT_DISPATCH
    _variant_t& operator=(bool boolSrc) throw(_com_error);              // Assign a VT_BOOL
    _variant_t& operator=(IUnknown* pSrc) throw(_com_error);            // Assign a VT_UNKNOWN
    _variant_t& operator=(const DECIMAL& decSrc) throw(_com_error);     // Assign a VT_DECIMAL
    _variant_t& operator=(BYTE bSrc) throw(_com_error);                 // Assign a VT_UI1

    _variant_t& operator=(char cSrc) throw(_com_error);                 // Assign a VT_I1
    _variant_t& operator=(unsigned short usSrc) throw(_com_error);      // Assign a VT_UI2
    _variant_t& operator=(unsigned long ulSrc) throw(_com_error);       // Assign a VT_UI4
    _variant_t& operator=(int iSrc) throw(_com_error);                  // Assign a VT_INT
    _variant_t& operator=(unsigned int uiSrc) throw(_com_error);        // Assign a VT_UINT
    _variant_t& operator=(__int64 i8Src) throw(_com_error);             // Assign a VT_I8
    _variant_t& operator=(unsigned __int64 ui8Src) throw(_com_error);   // Assign a VT_UI8

    // Comparison operations
    //
    bool operator==(const VARIANT& varSrc) const throw(_com_error);
    bool operator==(const VARIANT* pSrc) const throw(_com_error);

    bool operator!=(const VARIANT& varSrc) const throw(_com_error);
    bool operator!=(const VARIANT* pSrc) const throw(_com_error);

    // Low-level operations
    //
    void Clear() throw(_com_error);

    void Attach(VARIANT& varSrc) throw(_com_error);
    VARIANT Detach() throw(_com_error);

    VARIANT& GetVARIANT() throw();
    VARIANT* GetAddress() throw(_com_error);

    void ChangeType(VARTYPE vartype, const _variant_t* pSrc = NULL) throw(_com_error);

    void SetString(const char* pSrc) throw(_com_error); // used to set ANSI string
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline _variant_t::_variant_t() throw()
{
    ::VariantInit(this);
}

// Construct a _variant_t from a const VARIANT&
//
inline _variant_t::_variant_t(const VARIANT& varSrc) throw(_com_error)
{
    ::VariantInit(this);
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));
}

// Construct a _variant_t from a const VARIANT*
//
inline _variant_t::_variant_t(const VARIANT* pSrc) throw(_com_error)
{
    ::VariantInit(this);
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));
}

// Construct a _variant_t from a const _variant_t&
//
inline _variant_t::_variant_t(const _variant_t& varSrc) throw(_com_error)
{
    ::VariantInit(this);
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));
}

// Construct a _variant_t from a VARIANT&.  If fCopy is FALSE, give control of
// data to the _variant_t without doing a VariantCopy.
//
inline _variant_t::_variant_t(VARIANT& varSrc, bool fCopy) throw(_com_error)
{
    if (fCopy) {
        ::VariantInit(this);
        _com_util::CheckError(::VariantCopy(this, &varSrc));
    } else {
        memcpy(this, &varSrc, sizeof(varSrc));
        V_VT(&varSrc) = VT_EMPTY;
    }
}

// Construct either a VT_I2 VARIANT or a VT_BOOL VARIANT from
// a short (the default is VT_I2)
//
inline _variant_t::_variant_t(short sSrc, VARTYPE vtSrc) throw(_com_error)
{
    if ((vtSrc != VT_I2) && (vtSrc != VT_BOOL)) {
        _com_issue_error(E_INVALIDARG);
    }

    if (vtSrc == VT_BOOL) {
        V_VT(this) = VT_BOOL;
        V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
    }
    else {
        V_VT(this) = VT_I2;
        V_I2(this) = sSrc;
    }
}

// Construct either a VT_I4 VARIANT, a VT_BOOL VARIANT, or a
// VT_ERROR VARIANT from a long (the default is VT_I4)
//
inline _variant_t::_variant_t(long lSrc, VARTYPE vtSrc) throw(_com_error)
{
    if ((vtSrc != VT_I4) && (vtSrc != VT_ERROR) && (vtSrc != VT_BOOL)) {
        _com_issue_error(E_INVALIDARG);
    }

    if (vtSrc == VT_ERROR) {
        V_VT(this) = VT_ERROR;
        V_ERROR(this) = lSrc;
    }
    else if (vtSrc == VT_BOOL) {
        V_VT(this) = VT_BOOL;
        V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
    }
    else {
        V_VT(this) = VT_I4;
        V_I4(this) = lSrc;
    }
}

// Construct a VT_R4 VARIANT from a float
//
inline _variant_t::_variant_t(float fltSrc) throw()
{
    V_VT(this) = VT_R4;
    V_R4(this) = fltSrc;
}

// Construct either a VT_R8 VARIANT, or a VT_DATE VARIANT from
// a double (the default is VT_R8)
//
inline _variant_t::_variant_t(double dblSrc, VARTYPE vtSrc) throw(_com_error)
{
    if ((vtSrc != VT_R8) && (vtSrc != VT_DATE)) {
        _com_issue_error(E_INVALIDARG);
    }

    if (vtSrc == VT_DATE) {
        V_VT(this) = VT_DATE;
        V_DATE(this) = dblSrc;
    }
    else {
        V_VT(this) = VT_R8;
        V_R8(this) = dblSrc;
    }
}

// Construct a VT_CY from a CY
//
inline _variant_t::_variant_t(const CY& cySrc) throw()
{
    V_VT(this) = VT_CY;
    V_CY(this) = cySrc;
}

// Construct a VT_BSTR VARIANT from a const _bstr_t&
//
inline _variant_t::_variant_t(const _bstr_t& bstrSrc) throw(_com_error)
{
    V_VT(this) = VT_BSTR;

    BSTR bstr = static_cast<wchar_t*>(bstrSrc);
    V_BSTR(this) = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
                                           ::SysStringByteLen(bstr));

    if (V_BSTR(this) == NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Construct a VT_BSTR VARIANT from a const wchar_t*
//
inline _variant_t::_variant_t(const wchar_t* pSrc) throw(_com_error)
{
    V_VT(this) = VT_BSTR;
    V_BSTR(this) = ::SysAllocString(pSrc);

    if (V_BSTR(this) == NULL && pSrc != NULL) {
        _com_issue_error(E_OUTOFMEMORY);
    }
}

// Construct a VT_BSTR VARIANT from a const char*
//
inline _variant_t::_variant_t(const char* pSrc) throw(_com_error)
{
    V_VT(this) = VT_BSTR;
    V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);
}

// Construct a VT_DISPATCH VARIANT from an IDispatch*
//
inline _variant_t::_variant_t(IDispatch* pSrc, bool fAddRef) throw()
{
    V_VT(this) = VT_DISPATCH;
    V_DISPATCH(this) = pSrc;

    // Need the AddRef() as VariantClear() calls Release(), unless fAddRef
    // false indicates we're taking ownership
    //
    if (fAddRef) {
        V_DISPATCH(this)->AddRef();
    }
}

// Construct a VT_BOOL VARIANT from a bool
//
inline _variant_t::_variant_t(bool boolSrc) throw()
{
    V_VT(this) = VT_BOOL;
    V_BOOL(this) = (boolSrc ? VARIANT_TRUE : VARIANT_FALSE);
}

// Construct a VT_UNKNOWN VARIANT from an IUnknown*
//
inline _variant_t::_variant_t(IUnknown* pSrc, bool fAddRef) throw()
{
    V_VT(this) = VT_UNKNOWN;
    V_UNKNOWN(this) = pSrc;

    // Need the AddRef() as VariantClear() calls Release(), unless fAddRef
    // false indicates we're taking ownership
    //
    if (fAddRef) {
        V_UNKNOWN(this)->AddRef();
    }
}

// Construct a VT_DECIMAL VARIANT from a DECIMAL
//
inline _variant_t::_variant_t(const DECIMAL& decSrc) throw()
{
    // Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
    //
    V_DECIMAL(this) = decSrc;
    V_VT(this) = VT_DECIMAL;
}

// Construct a VT_UI1 VARIANT from a BYTE (unsigned char)
//
inline _variant_t::_variant_t(BYTE bSrc) throw()
{
    V_VT(this) = VT_UI1;
    V_UI1(this) = bSrc;
}

// Construct a VT_I1 VARIANT from a char 
//
inline _variant_t::_variant_t(char cSrc) throw() 
{
    V_VT(this) = VT_I1;
    V_I1(this) = cSrc;
}

// Construct a VT_UI2 VARIANT from a unsigned short 
//
inline _variant_t::_variant_t(unsigned short usSrc) throw()
{
    V_VT(this) = VT_UI2;
    V_UI2(this) = usSrc;
}

// Construct a VT_UI4 VARIANT from a unsigned long 
//
inline _variant_t::_variant_t(unsigned long ulSrc) throw()
{
    V_VT(this) = VT_UI4;
    V_UI4(this) = ulSrc;
}

// Construct a VT_INT VARIANT from a int 
//
inline _variant_t::_variant_t(int iSrc) throw()
{
    V_VT(this) = VT_INT;
    V_INT(this) = iSrc;
}

// Construct a VT_UINT VARIANT from a unsigned int 
//
inline _variant_t::_variant_t(unsigned int uiSrc) throw()
{
    V_VT(this) = VT_UINT;
    V_UINT(this) = uiSrc;
}

// Construct a VT_I8 VARIANT from a __int64 
//
inline _variant_t::_variant_t(__int64 i8Src) throw()
{
    V_VT(this) = VT_I8;
    V_I8(this) = i8Src;
}

// Construct a VT_UI8 VARIANT from a unsigned __int64 
//
inline _variant_t::_variant_t(unsigned __int64 ui8Src) throw()
{
    V_VT(this) = VT_UI8;
    V_UI8(this) = ui8Src;
}


//////////////////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Extracts a VT_I2 into a short
//
inline _variant_t::operator short() const throw(_com_error)
{
    if (V_VT(this) == VT_I2) {
        return V_I2(this); 
    }

    _variant_t varDest;

    varDest.ChangeType(VT_I2, this);

    return V_I2(&varDest);
}

// Extracts a VT_I4 into a long
//
inline _variant_t::operator long() const throw(_com_error)
{
    if (V_VT(this) == VT_I4) {
        return V_I4(this); 
    }

    _variant_t varDest;

    varDest.ChangeType(VT_I4, this);

    return V_I4(&varDest);
}

// Extracts a VT_R4 into a float
//
inline _variant_t::operator float() const throw(_com_error)
{
    if (V_VT(this) == VT_R4) {
        return V_R4(this); 
    }

    _variant_t varDest;

    varDest.ChangeType(VT_R4, this);

    return V_R4(&varDest);
}

// Extracts a VT_R8 into a double
//
inline _variant_t::operator double() const throw(_com_error)
{
    if (V_VT(this) == VT_R8) {
        return V_R8(this); 
    }

    _variant_t varDest;

    varDest.ChangeType(VT_R8, this);

    return V_R8(&varDest);
}

// Extracts a VT_CY into a CY
//
inline _variant_t::operator CY() const throw(_com_error)
{
    if (V_VT(this) == VT_CY) {
        return V_CY(this); 
    }

    _variant_t varDest;

    varDest.ChangeType(VT_CY, this);

    return V_CY(&varDest);
}

// Extracts a VT_BSTR into a _bstr_t
//
inline _variant_t::operator _bstr_t() const throw(_com_error)
{
    if (V_VT(this) == VT_BSTR) {
        return V_BSTR(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_BSTR, this);

    return V_BSTR(&varDest);
}

// Extracts a VT_DISPATCH into an IDispatch*
//
inline _variant_t::operator IDispatch*() const throw(_com_error)
{
    if (V_VT(this) == VT_DISPATCH) {
        V_DISPATCH(this)->AddRef();
        return V_DISPATCH(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_DISPATCH, this);

    V_DISPATCH(&varDest)->AddRef();
    return V_DISPATCH(&varDest);
}

// Extract a VT_BOOL into a bool
//
inline _variant_t::operator bool() const throw(_com_error)
{
    if (V_VT(this) == VT_BOOL) {
        return V_BOOL(this) ? true : false;
    }

    _variant_t varDest;

    varDest.ChangeType(VT_BOOL, this);

    return V_BOOL(&varDest) ? true : false;
}

// Extracts a VT_UNKNOWN into an IUnknown*
//
inline _variant_t::operator IUnknown*() const throw(_com_error)
{
    if (V_VT(this) == VT_UNKNOWN) {
        V_UNKNOWN(this)->AddRef();
        return V_UNKNOWN(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_UNKNOWN, this);

    V_UNKNOWN(&varDest)->AddRef();
    return V_UNKNOWN(&varDest);
}

// Extracts a VT_DECIMAL into a DECIMAL
//
inline _variant_t::operator DECIMAL() const throw(_com_error)
{
    if (V_VT(this) == VT_DECIMAL) {
        return V_DECIMAL(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_DECIMAL, this);

    return V_DECIMAL(&varDest);
}

// Extracts a VT_UI1 into a BYTE (unsigned char)
//
inline _variant_t::operator BYTE() const throw(_com_error)
{
    if (V_VT(this) == VT_UI1) {
        return V_UI1(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_UI1, this);

    return V_UI1(&varDest);
}

// Extract the physical VARIANT
//
inline _variant_t::operator VARIANT() const throw()
{
    return *(VARIANT*) this;
}

// Extracts a VT_I1 into a char
//
inline _variant_t::operator char() const throw(_com_error) 
{
    if (V_VT(this) == VT_I1) {
        return V_I1(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_I1, this);

    return V_I1(&varDest);
}

// Extracts a VT_UI2 into a unsigned short
//
inline _variant_t::operator unsigned short() const throw(_com_error) 
{
    if (V_VT(this) == VT_UI2) {
        return V_UI2(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_UI2, this);

    return V_UI2(&varDest);
}

// Extracts a VT_UI4 into a unsigned long
//
inline _variant_t::operator unsigned long() const throw(_com_error) 
{
    if (V_VT(this) == VT_UI4) {
        return V_UI4(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_UI4, this);

    return V_UI4(&varDest);
}

// Extracts a VT_INT into a int
//
inline _variant_t::operator int() const throw(_com_error) 
{
    if (V_VT(this) == VT_INT) {
        return V_INT(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_INT, this);

    return V_INT(&varDest);
}

// Extracts a VT_UINT into a unsigned int
//
inline _variant_t::operator unsigned int() const throw(_com_error) 
{
    if (V_VT(this) == VT_UINT) {
        return V_UINT(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_UINT, this);

    return V_UINT(&varDest);
}

// Extracts a VT_I8 into a __int64
//
inline _variant_t::operator __int64() const throw(_com_error) 
{
    if (V_VT(this) == VT_I8) {
        return V_I8(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_I8, this);

    return V_I8(&varDest);
}

// Extracts a VT_UI8 into a unsigned __int64
//
inline _variant_t::operator unsigned __int64() const throw(_com_error) 
{
    if (V_VT(this) == VT_UI8) {
        return V_UI8(this);
    }

    _variant_t varDest;

    varDest.ChangeType(VT_UI8, this);

    return V_UI8(&varDest);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Assignment operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Assign a const VARIANT& (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const VARIANT& varSrc) throw(_com_error)
{
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));

    return *this;
}

// Assign a const VARIANT* (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const VARIANT* pSrc) throw(_com_error)
{
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));

    return *this;
}

// Assign a const _variant_t& (::VariantCopy handles everything)
//
inline _variant_t& _variant_t::operator=(const _variant_t& varSrc) throw(_com_error)
{
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));

    return *this;
}

// Assign a short creating either VT_I2 VARIANT or a 
// VT_BOOL VARIANT (VT_I2 is the default)
//
inline _variant_t& _variant_t::operator=(short sSrc) throw(_com_error)
{
    if (V_VT(this) == VT_I2) {
        V_I2(this) = sSrc;
    }
    else if (V_VT(this) == VT_BOOL) {
        V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
    }
    else {
        // Clear the VARIANT and create a VT_I2
        //
        Clear();

        V_VT(this) = VT_I2;
        V_I2(this) = sSrc;
    }

    return *this;
}

// Assign a long creating either VT_I4 VARIANT, a VT_ERROR VARIANT
// or a VT_BOOL VARIANT (VT_I4 is the default)
//
inline _variant_t& _variant_t::operator=(long lSrc) throw(_com_error)
{
    if (V_VT(this) == VT_I4) {
        V_I4(this) = lSrc;
    }
    else if (V_VT(this) == VT_ERROR) {
        V_ERROR(this) = lSrc;
    }
    else if (V_VT(this) == VT_BOOL) {
        V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
    }
    else {
        // Clear the VARIANT and create a VT_I4
        //
        Clear();

        V_VT(this) = VT_I4;
        V_I4(this) = lSrc;
    }

    return *this;
}

// Assign a float creating a VT_R4 VARIANT 
//
inline _variant_t& _variant_t::operator=(float fltSrc) throw(_com_error)
{
    if (V_VT(this) != VT_R4) {
        // Clear the VARIANT and create a VT_R4
        //
        Clear();

        V_VT(this) = VT_R4;
    }

    V_R4(this) = fltSrc;

    return *this;
}

// Assign a double creating either a VT_R8 VARIANT, or a VT_DATE
// VARIANT (VT_R8 is the default)
//
inline _variant_t& _variant_t::operator=(double dblSrc) throw(_com_error)
{
    if (V_VT(this) == VT_R8) {
        V_R8(this) = dblSrc;
    }
    else if(V_VT(this) == VT_DATE) {
        V_DATE(this) = dblSrc;
    }
    else {
        // Clear the VARIANT and create a VT_R8
        //
        Clear();

        V_VT(this) = VT_R8;
        V_R8(this) = dblSrc;
    }

    return *this;
}

// Assign a CY creating a VT_CY VARIANT 
//
inline _variant_t& _variant_t::operator=(const CY& cySrc) throw(_com_error)
{
    if (V_VT(this) != VT_CY) {
        // Clear the VARIANT and create a VT_CY
        //
        Clear();

        V_VT(this) = VT_CY;
    }

    V_CY(this) = cySrc;

    return *this;
}

// Assign a const _bstr_t& creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const _bstr_t& bstrSrc) throw(_com_error)
{
    // Clear the VARIANT (This will SysFreeString() any previous occupant)
    //
    _COM_ASSERT(V_BSTR(this) != (BSTR) bstrSrc);

    Clear();

    V_VT(this) = VT_BSTR;

    if (!bstrSrc) {
        V_BSTR(this) = NULL;
    }
    else {
        BSTR bstr = static_cast<wchar_t*>(bstrSrc);
        V_BSTR(this) = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
                                               ::SysStringByteLen(bstr));

        if (V_BSTR(this) == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }

    return *this;
}

// Assign a const wchar_t* creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const wchar_t* pSrc) throw(_com_error)
{
    // Clear the VARIANT (This will SysFreeString() any previous occupant)
    //
    _COM_ASSERT(V_BSTR(this) != pSrc);

    Clear();

    V_VT(this) = VT_BSTR;

    if (pSrc == NULL) {
        V_BSTR(this) = NULL;
    }
    else {
        V_BSTR(this) = ::SysAllocString(pSrc);

        if (V_BSTR(this) == NULL) {
            _com_issue_error(E_OUTOFMEMORY);
        }
    }

    return *this;
}

// Assign a const char* creating a VT_BSTR VARIANT
//
inline _variant_t& _variant_t::operator=(const char* pSrc) throw(_com_error)
{
    // Clear the VARIANT (This will SysFreeString() any previous occupant)
    //
    _COM_ASSERT(V_I1REF(this) != pSrc);

    Clear();

    V_VT(this) = VT_BSTR;
    V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

    return *this;
}

// Assign an IDispatch* creating a VT_DISPATCH VARIANT 
//
inline _variant_t& _variant_t::operator=(IDispatch* pSrc) throw(_com_error)
{
    // Clear the VARIANT (This will Release() any previous occupant)
    //
    _COM_ASSERT(V_DISPATCH(this) != pSrc);

    Clear();

    V_VT(this) = VT_DISPATCH;
    V_DISPATCH(this) = pSrc;

    // Need the AddRef() as VariantClear() calls Release()
    //
    V_DISPATCH(this)->AddRef();

    return *this;
}

// Assign a bool creating a VT_BOOL VARIANT 
//
inline _variant_t& _variant_t::operator=(bool boolSrc) throw(_com_error)
{
    if (V_VT(this) != VT_BOOL) {
        // Clear the VARIANT and create a VT_BOOL
        //
        Clear();

        V_VT(this) = VT_BOOL;
    }

    V_BOOL(this) = (boolSrc ? VARIANT_TRUE : VARIANT_FALSE);

    return *this;
}

// Assign an IUnknown* creating a VT_UNKNOWN VARIANT 
//
inline _variant_t& _variant_t::operator=(IUnknown* pSrc) throw(_com_error)
{
    // Clear VARIANT (This will Release() any previous occupant)
    //
    _COM_ASSERT(V_UNKNOWN(this) != pSrc);

    Clear();

    V_VT(this) = VT_UNKNOWN;
    V_UNKNOWN(this) = pSrc;

    // Need the AddRef() as VariantClear() calls Release()
    //
    V_UNKNOWN(this)->AddRef();

    return *this;
}

// Assign a DECIMAL creating a VT_DECIMAL VARIANT
//
inline _variant_t& _variant_t::operator=(const DECIMAL& decSrc) throw(_com_error)
{
    if (V_VT(this) != VT_DECIMAL) {
        // Clear the VARIANT
        //
        Clear();
    }

    // Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
    V_DECIMAL(this) = decSrc;
    V_VT(this) = VT_DECIMAL;

    return *this;
}

// Assign a BTYE (unsigned char) creating a VT_UI1 VARIANT
//
inline _variant_t& _variant_t::operator=(BYTE bSrc) throw(_com_error)
{
    if (V_VT(this) != VT_UI1) {
        // Clear the VARIANT and create a VT_UI1
        //
        Clear();

        V_VT(this) = VT_UI1;
    }

    V_UI1(this) = bSrc;

    return *this;
}

// Assign a char creating a VT_I1 VARIANT
//
inline _variant_t& _variant_t::operator=(char cSrc) throw(_com_error){
    if (V_VT(this) != VT_I1) {
        // Clear the VARIANT and create a VT_I1
        //
        Clear();

        V_VT(this) = VT_I1;
    }

    V_I1(this) = cSrc;

    return *this;
}

// Assign a char creating a VT_UI2 VARIANT
//
inline _variant_t& _variant_t::operator=(unsigned short usSrc) throw(_com_error){
    if (V_VT(this) != VT_UI2) {
        // Clear the VARIANT and create a VT_UI2
        //
        Clear();

        V_VT(this) = VT_UI2;
    }

    V_UI2(this) = usSrc;

    return *this;
}

// Assign a char creating a VT_UI4 VARIANT
//
inline _variant_t& _variant_t::operator=(unsigned long ulSrc) throw(_com_error){
    if (V_VT(this) != VT_UI4) {
        // Clear the VARIANT and create a VT_UI4
        //
        Clear();

        V_VT(this) = VT_UI4;
    }

    V_UI4(this) = ulSrc;

    return *this;
}

// Assign a char creating a VT_INT VARIANT
//
inline _variant_t& _variant_t::operator=(int iSrc) throw(_com_error){
    if (V_VT(this) != VT_INT) {
        // Clear the VARIANT and create a VT_INT
        //
        Clear();

        V_VT(this) = VT_INT;
    }

    V_INT(this) = iSrc;

    return *this;
}

// Assign a char creating a VT_UINT VARIANT
//
inline _variant_t& _variant_t::operator=(unsigned int uiSrc) throw(_com_error){
    if (V_VT(this) != VT_UINT) {
        // Clear the VARIANT and create a VT_UINT
        //
        Clear();

        V_VT(this) = VT_UINT;
    }

    V_UINT(this) = uiSrc;

    return *this;
}

// Assign a char creating a VT_I8 VARIANT
//
inline _variant_t& _variant_t::operator=(__int64 i8Src) throw(_com_error){
    if (V_VT(this) != VT_I8) {
        // Clear the VARIANT and create a VT_I8
        //
        Clear();

        V_VT(this) = VT_I8;
    }

    V_I8(this) = i8Src;

    return *this;
}

// Assign a char creating a VT_UI8 VARIANT
//
inline _variant_t& _variant_t::operator=(unsigned __int64 ui8Src) throw(_com_error){
    if (V_VT(this) != VT_UI8) {
        // Clear the VARIANT and create a VT_UI8
        //
        Clear();

        V_VT(this) = VT_UI8;
    }

    V_UI8(this) = ui8Src;

    return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Comparison operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Compare a _variant_t against a const VARIANT& for equality
//
inline bool _variant_t::operator==(const VARIANT& varSrc) const throw()
{
    return *this == &varSrc;
}

// Compare a _variant_t against a const VARIANT* for equality
//
inline bool _variant_t::operator==(const VARIANT* pSrc) const throw()
{
    if (this == pSrc) {
        return true;
    }

    //
    // Variants not equal if types don't match
    //
    if (V_VT(this) != V_VT(pSrc)) {
        return false;
    }

    //
    // Check type specific values
    //
    switch (V_VT(this)) {
        case VT_EMPTY:
        case VT_NULL:
            return true;

        case VT_I2:
            return V_I2(this) == V_I2(pSrc);

        case VT_I4:
            return V_I4(this) == V_I4(pSrc);

        case VT_R4:
            return V_R4(this) == V_R4(pSrc);

        case VT_R8:
            return V_R8(this) == V_R8(pSrc);

        case VT_CY:
            return memcmp(&(V_CY(this)), &(V_CY(pSrc)), sizeof(CY)) == 0;

        case VT_DATE:
            return V_DATE(this) == V_DATE(pSrc);

        case VT_BSTR:
            return (::SysStringByteLen(V_BSTR(this)) == ::SysStringByteLen(V_BSTR(pSrc))) &&
                    (memcmp(V_BSTR(this), V_BSTR(pSrc), ::SysStringByteLen(V_BSTR(this))) == 0);

        case VT_DISPATCH:
            return V_DISPATCH(this) == V_DISPATCH(pSrc);

        case VT_ERROR:
            return V_ERROR(this) == V_ERROR(pSrc);

        case VT_BOOL:
            return V_BOOL(this) == V_BOOL(pSrc);

        case VT_UNKNOWN:
            return V_UNKNOWN(this) == V_UNKNOWN(pSrc);

        case VT_DECIMAL:
            return memcmp(&(V_DECIMAL(this)), &(V_DECIMAL(pSrc)), sizeof(DECIMAL)) == 0;

        case VT_UI1:
            return V_UI1(this) == V_UI1(pSrc);

        case VT_I1:
            return V_I1(this) == V_I1(pSrc);

        case VT_UI2:
            return V_UI2(this) == V_UI2(pSrc);

        case VT_UI4:
            return V_UI4(this) == V_UI4(pSrc);

        case VT_INT:
            return V_INT(this) == V_INT(pSrc);

        case VT_UINT:
            return V_UINT(this) == V_UINT(pSrc);

        case VT_I8:
            return V_I8(this) == V_I8(pSrc);

        case VT_UI8:
            return V_UI8(this) == V_UI8(pSrc);

        default:
            _com_issue_error(E_INVALIDARG);
            // fall through
    }

    return false;
}

// Compare a _variant_t against a const VARIANT& for in-equality
//
inline bool _variant_t::operator!=(const VARIANT& varSrc) const throw()
{
    return !(*this == &varSrc);
}

// Compare a _variant_t against a const VARIANT* for in-equality
//
inline bool _variant_t::operator!=(const VARIANT* pSrc) const throw()
{
    return !(*this == pSrc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Low-level operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Clear the _variant_t
//
inline void _variant_t::Clear() throw(_com_error)
{
    _com_util::CheckError(::VariantClear(this));
}

inline void _variant_t::Attach(VARIANT& varSrc) throw(_com_error)
{
    //
    // Free up previous VARIANT
    //
    Clear();

    //
    // Give control of data to _variant_t
    //
    memcpy(this, &varSrc, sizeof(varSrc));
    V_VT(&varSrc) = VT_EMPTY;
}

inline VARIANT _variant_t::Detach() throw(_com_error)
{
    VARIANT varResult = *this;
    V_VT(this) = VT_EMPTY;

    return varResult;
}

inline VARIANT& _variant_t::GetVARIANT() throw() 
{
    return *(VARIANT*) this;
}

inline VARIANT* _variant_t::GetAddress() throw(_com_error)
{
    Clear();
    return (VARIANT*) this;
}

// Change the type and contents of this _variant_t to the type vartype and
// contents of pSrc
//
inline void _variant_t::ChangeType(VARTYPE vartype, const _variant_t* pSrc) throw(_com_error)
{
    //
    // If pDest is NULL, convert type in place
    //
    if (pSrc == NULL) {
        pSrc = this;
    }

    if ((this != pSrc) || (vartype != V_VT(this))) {
        _com_util::CheckError(::VariantChangeType(static_cast<VARIANT*>(this),
                                                  const_cast<VARIANT*>(static_cast<const VARIANT*>(pSrc)),
                                                  0, vartype));
    }
}

inline void _variant_t::SetString(const char* pSrc) throw(_com_error)
{
    //
    // Free up previous VARIANT
    //
    Clear();

    V_VT(this) = VT_BSTR;
    V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
//////////////////////////////////////////////////////////////////////////////////////////

inline _variant_t::~_variant_t() throw(_com_error)
{
    _com_util::CheckError(::VariantClear(this));
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Mutually-dependent definitions
//
//////////////////////////////////////////////////////////////////////////////////////////

// Construct a _bstr_t from a const _variant_t&
//
inline _bstr_t::_bstr_t(const _variant_t &var) throw(_com_error)
    : m_Data(NULL)
{
    if (V_VT(&var) == VT_BSTR) {
        *this = V_BSTR(&var);
        return;
    }

    _variant_t varDest;

    varDest.ChangeType(VT_BSTR, &var);

    *this = V_BSTR(&varDest);
}

// Assign a const _variant_t& to a _bstr_t
//
inline _bstr_t& _bstr_t::operator=(const _variant_t &var) throw(_com_error)
{
    if (V_VT(&var) == VT_BSTR) {
        *this = V_BSTR(&var);
        return *this;
    }

    _variant_t varDest;

    varDest.ChangeType(VT_BSTR, &var);

    *this = V_BSTR(&varDest);

    return *this;
}

extern _variant_t vtMissing;

#ifndef _USE_RAW
#define bstr_t _bstr_t
#define variant_t _variant_t
#endif

#pragma pop_macro("new")

#pragma warning(pop)

#endif  // _INC_COMUTIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\corhdr.h ===
//*****************************************************************************
// File: CorHdr.h
//
// Copyright (c) 1996-1999 Microsoft Corporation.  All Rights Reserved.
// Microsoft Confidential.
//*****************************************************************************
#ifndef __CORHDR_H__
#define __CORHDR_H__

// __IMAGE_COR_CPLUSPLUS__ determines whether or not the helper code for
// inlines and other c++ ism's are to be included.  Since these only work
// with a c++ compatible compiler, turn them off right away if you are not
// working as such.  If you do not want the extra helpers and you are using
// c++, then add "#define __IMAGE_COR_CPLUSPLUS__ 0" before including this
// file.
#if !defined(__IMAGE_COR_CPLUSPLUS__) && defined(__cplusplus)
#define __IMAGE_COR_CPLUSPLUS__ 1
#endif


// COM+ Header entry point flags.
#define COMIMAGE_FLAGS_ILONLY               0x00000001
#define COMIMAGE_FLAGS_32BITREQUIRED        0x00000002
#define COMIMAGE_FLAGS_COMPRESSIONDATA      0x00000004
#define COMIMAGE_FLAGS_TRACKDEBUGDATA       0x00010000

// Directory entry macro for COM+ data.
#ifndef IMAGE_DIRECTORY_ENTRY_COMHEADER
#define IMAGE_DIRECTORY_ENTRY_COMHEADER     14
#endif // IMAGE_DIRECTORY_ENTRY_COMHEADER

#if 1
#define _NEW_FLAGS_IMPLEMENTED 1
#define __NEW_FLAGS_IMPLEMENTED 1
#endif


#ifndef __IMAGE_COR20_HEADER_DEFINED__
#define __IMAGE_COR20_HEADER_DEFINED__

// COM+ 2.0 header structure.
#define COR_VERSION_MAJOR_V2        2
typedef struct                   
{
    DWORD                   cb;              
    WORD                    MajorRuntimeVersion;
    WORD                    MinorRuntimeVersion;
    IMAGE_DATA_DIRECTORY    MetaData;        
    DWORD                   Flags;           
    DWORD                   EntryPointToken;
    IMAGE_DATA_DIRECTORY    IPMap;
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
   
    union { 
        struct { // Out of date
            IMAGE_DATA_DIRECTORY    TocManagedVCall;
            IMAGE_DATA_DIRECTORY    TocManagedCall;
            IMAGE_DATA_DIRECTORY    TocHelper;
            IMAGE_DATA_DIRECTORY    TocUnmanagedVCall;
            IMAGE_DATA_DIRECTORY    TocUnmanagedCall;
        };
        struct { // New stuff
            IMAGE_DATA_DIRECTORY    EEInfoTable;
            IMAGE_DATA_DIRECTORY    HelperTable;
            IMAGE_DATA_DIRECTORY    DynamicInfo;
            IMAGE_DATA_DIRECTORY    DelayLoadInfo;
            // temporary home for this field
            IMAGE_DATA_DIRECTORY    ModuleImage;
        };
    };

    IMAGE_DATA_DIRECTORY    CompressionData;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    union {
        IMAGE_DATA_DIRECTORY    Manifest;
        IMAGE_DATA_DIRECTORY    Resources;
    };
} IMAGE_COR20_HEADER;


typedef enum  _CorCompressionType {
    COR_COMPRESS_MACROS = 1,        // compress using macro instructions

        // The rest of these are not used at present
    COR_COMPRESS_BY_GUID = 2,       // what follows is a GUID that tell us what to do
    COR_COMPRESS_BY_URL = 3,        // what follows a null terminated UNICODE string
                                    // that tells us what to do.
} CorCompressionType;

// The 'CompressedData' directory entry points to this header
// The only thing we know about the compression data is that it 
// starts with a byte that tells us what the compression type is
// and another one that indicates the version.  All other fields
// depend on the Compression type.  
#define IMAGE_COR20_COMPRESSION_HEADER_SIZE 2

typedef struct          
{
    enum _CorCompressionType CompressionType : 8;
    unsigned                Version         : 8;
    unsigned                Available       : 16;   // Logically part of data that follows
        // data follows.  
} IMAGE_COR20_COMPRESSION_HEADER;

#endif // __IMAGE_COR20_HEADER_DEFINED__

// The most recent version.
#define COR_VERSION_MAJOR           COR_VERSION_MAJOR_V2
#define COR_VERSION_MINOR           0

#define COR_CTOR_METHOD_NAME        ".ctor"
#define COR_CTOR_METHOD_NAME_W      L".ctor"
#define COR_CCTOR_METHOD_NAME       ".cctor"
#define COR_CCTOR_METHOD_NAME_W     L".cctor"

// The predefined name for deleting a typeDef,MethodDef, FieldDef, Property and Event
#define COR_DELETED_NAME_A          "_Deleted"
#define COR_DELETED_NAME_W          L"_Deleted"
#define COR_DELETED_NAME_LENGTH     8

// We intentionally use memcmp so that we will ignore the suffix any suffix 
#define IsDeletedName(strName)      (memcmp(strName, COR_DELETED_NAME_A, COR_DELETED_NAME_LENGTH) == 0)

// TypeDef attr bits, used by DefineTypeDef.
typedef enum
{
    tdPublic            =   0x0001,     // Class is public scope

    // Use this mask to retrieve class layout informaiton
    // 0 is AutoLayout, 0x2 is LayoutSequential, 4 is ExplicitLayout
    tdLayoutMask        =   0x0006,     
    tdAutoLayout        =   0x0000,     // Class fields are auto-laid out
    tdLayoutSequential  =   0x0002,     // Class fields are laid out sequentially
    tdExplicitLayout    =   0x0004,     // Layout is supplied explicitly
    // end layout mask

	tdSerializable		=	0x0008, 	// The class is Serializable.

    tdSealed            =   0x0010,     // Class is concrete and may not be extended


    // Use tdStringFormatMask to retrieve string information for native interop
    tdStringFormatMask  =   0x00c0,     
    tdAnsiClass         =   0x0000,     // LPTSTR is interpreted as ANSI in this class
    tdUnicodeClass      =   0x0040,     // LPTSTR is interpreted as UNICODE
    tdAutoClass         =   0x0080,     // LPTSTR is interpreted automatically
    // end string format mask

    // Use this mask to distinguish a type declaration as a Class, ValueType or Interface
    tdClassSemanticsMask=   0x0300,
    tdClass             =   0x0000,
    tdValueType         =   0x0100,     // Type has value based semantics
    tdInterface         =   0x0200,     // Type is an interface
    tdUnManagedValueType=   0x0300,     // It is a value type that can not live in the GC heap
    // end semantics mask

    tdAbstract          =   0x0400,     // Class is abstract
    tdReserved1         =   0x0800,     // Reserved as tdHasSecurity
    tdImport            =   0x1000,     // Class / interface is imported

    tdEnum              =   0x4000,     // Class is an enum; static final values only

    tdLazyInit          =   0x0020,     // Class should not be eagerly loaded.
    tdContextful        =   0x2000,     // Class is contextful (else agile).
    tdMarshalByRef      =   0x8000,     // Class is to be marshaled by reference.
} CorTypeAttr;

// Macros for accessing the members of the CorTypeAttr.
#define IsTdPublic(x)                       ((x) & tdPublic)

#define IsTdAutoLayout(x)                   (((x) & tdLayoutMask) == tdAutoLayout)
#define IsTdLayoutSequential(x)             (((x) & tdLayoutMask) == tdLayoutSequential)
#define IsTdExplicitLayout(x)               (((x) & tdLayoutMask) == tdExplicitLayout)

#define IsTdSerializable(x)					((x) & tdSerializable)

#define IsTdSealed(x)                       ((x) & tdSealed)

#define IsTdAnsiClass(x)                    (((x) & tdStringFormatMask) == tdAnsiClass)
#define IsTdUnicodeClass(x)                 (((x) & tdStringFormatMask) == tdUnicodeClass)
#define IsTdAutoClass(x)                    (((x) & tdStringFormatMask) == tdAutoClass)

#define IsTdClass(x)                        (((x) & tdClassSemanticsMask) == tdClass)
#define IsTdInterface(x)                    (((x) & tdClassSemanticsMask) == tdInterface)
#define IsTdValueType(x)                    ((x) & tdValueType) // This can be either tdValueType or tdUnmanagedValueType   
#define IsTdUnmanagedValueType(x)           (((x) & tdClassSemanticsMask) == tdUnManagedValueType)
#define IsTdManagedValueType(x)             (((x) & tdClassSemanticsMask) == tdValueType)

#define IsTdAbstract(x)                     ((x) & tdAbstract)
#define IsTdImport(x)                       ((x) & tdImport)

#define IsTdEnum(x)                         ((x) & tdEnum)

#define IsTdLazyInit(x)                     ((x) & tdLazyInit)
#define IsTdContextful(x)                   ((x) & tdContextful)
#define IsTdMarshalByRef(x)                 ((x) & tdMarshalByRef)


// Used internally for implements table
typedef enum
{
    itImplements        =   0x0000,     // Interfaces implemented or parent ifaces
    itEvents            =   0x0001,     // Interfaces raised
    itRequires          =   0x0002, 
    itInherits          =   0x0004,
} CorImplementType;

// Macros for accessing the members of CorImplementType.
#define IsItImplements(x)                   ((x) & itImplements)
#define IsItEvents(x)                       ((x) & itEvents)
#define IsItRequires(x)                     ((x) & itRequires)
#define IsItInherits(x)                     ((x) & itInherits)

//-------------------------------------
//--- Registration support types
//-------------------------------------
typedef enum  
{ 
    caaDeferCreate      =   0x0001,             // supports deferred create 
    caaAppObject        =   0x0002,             // class is AppObject 
    caaFixedIfaceSet    =   0x0004,             // interface set is open (use QI) 
    caaIndependentlyCreateable  =   0x0100, 
    caaPredefined       =   0x0200,

    // mask for caaLB*
    caaLoadBalancing    =   0x0c00,
    caaLBNotSupported   =   0x0400,
    caaLBSupported      =   0x0800,
    caaLBNotSpecified   =   0x0000,

    // mask for caaOP*
    caaObjectPooling    =   0x3000,
    caaOPNotSupported   =   0x1000,
    caaOPSupported      =   0x2000,
    caaOPNotSpecified   =   0x0000,

    // mask for caaJA*
    caaJITActivation    =   0xc000,
    caaJANotSupported   =   0x4000,
    caaJASupported      =   0x8000,
    caaJANotSpecified   =   0x0000,
} CorClassActivateAttr; 

// Macros for accessing the members of CorClassActivateAttr.
#define IsCaaDeferCreate(x)                 ((x) & caaDeferCreate)
#define IsCaaAppObject(x)                   ((x) & caaAppObject)
#define IsCaaFixedIfaceSet(x)               ((x) & caaFixedIfaceSet)
#define IsCaaIndependentlyCreateable(x)     ((x) & caaIndependentlyCreateable)
#define IsCaaPredefined(x)                  ((x) & caaPredefined)

#define IsCaaLBNotSupported(x)              (((x) & caaLoadBalancing) == caaLBNotSupported)
#define IsCaaLBSupported(x)                 (((x) & caaLoadBalancing) == caaLBSupported)
#define IsCaaLBNotSpecified(x)              (((x) & caaLoadBalancing) == caaLBNotSpecified)

#define IsCaaOPNotSupported(x)              (((x) & caaObjectPooling) == caaOPNotSupported)
#define IsCaaOPSupported(x)                 (((x) & caaObjectPooling) == caaOPSupported)
#define IsCaaOPNotSpecified(x)              (((x) & caaObjectPooling) == caaOPNotSpecified)

#define IsCaaJANotSupported(x)              (((x) & caaJITActivation) == caaJANotSupported)
#define IsCaaJASupported(x)                 (((x) & caaJITActivation) == caaJASupported)
#define IsCaaJANotSpecified(x)              (((x) & caaJANotSpecified) == caaJANotSpecified)


// MethodDef attr bits, Used by DefineMethod.
typedef enum
{
    // member access mask - Use this mask to retrieve accessibility information.
    mdMemberAccessMask  =   0x0007,
    mdPublic            =   0x0001,     // Accessibly by anyone who has visibility to this scope.    
    mdPrivate           =   0x0002,     // Accessible only by the parent type.  
    mdFamily            =   0x0003,     // Accessible only by type and sub-types.    
    mdAssem             =   0x0004,     // Accessibly by anyone in the Assembly.
    mdFamANDAssem       =   0x0005,     // Accessible by sub-types only in this Assembly.
    mdFamORAssem        =   0x0006,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    mdPrivateScope      =   0x0007,     // Member not referenceable.
    // end member access mask

    // method contract attributes.
    mdStatic            =   0x0010,     // Defined on type, else per instance.
    mdFinal             =   0x0020,     // Method may not be overridden.
    mdVirtual           =   0x0040,     // Method virtual.
    mdHideBySig         =   0x0080,     // Method hides by name+sig, else just by name.
    
    // vtable layout mask - Use this mask to retrieve vtable attributes.
    mdVtableLayoutMask  =   0x0100,
    mdReuseSlot         =   0x0000,     // The default.
    mdNewSlot           =   0x0100,     // Method always gets a new slot in the vtable.
    // end vtable layout mask

    // method implementation attributes.
    mdSynchronized      =   0x0200,     // Method synchronized..
    mdAbstract          =   0x0400,     // Method does not provide an implementation.
    mdSpecialName       =   0x0800,     // Method is special.  Name describes how.
    mdRTSpecialName     =   0x1000,     // Runtime should check name encoding.
    
    // interop attributes
    mdPinvokeImpl       =   0x2000,     // Implementation is forwarded through pinvoke.

    mdReserved1         =   0x4000,     // Used internally as mdHasSecurity.
    mdReserved2         =   0x8000,     // Used internally as mdRequiresSecObject.

} CorMethodAttr;

// Macros for accessing the members of CorMethodAttr.
#define IsMdPublic(x)                       (((x) & mdMemberAccessMask) == mdPublic)
#define IsMdPrivate(x)                      (((x) & mdMemberAccessMask) == mdPrivate)
#define IsMdFamily(x)                       (((x) & mdMemberAccessMask) == mdFamily)
#define IsMdAssem(x)                        (((x) & mdMemberAccessMask) == mdAssem)
#define IsMdFamANDAssem(x)                  (((x) & mdMemberAccessMask) == mdFamANDAssem)
#define IsMdFamORAssem(x)                   (((x) & mdMemberAccessMask) == mdFamORAssem)
#define IsMdPrivateScope(x)                 (((x) & mdMemberAccessMask) == mdPrivateScope)

#define IsMdStatic(x)                       ((x) & mdStatic)
#define IsMdFinal(x)                        ((x) & mdFinal)
#define IsMdVirtual(x)                      ((x) & mdVirtual)
#define IsMdHideBySig(x)                    ((x) & mdHideBySig)

#define IsMdReuseSlot(x)                    (((x) & mdVtableLayoutMask) == mdReuseSlot)
#define IsMdNewSlot(x)                      (((x) & mdVtableLayoutMask) == mdNewSlot)

#define IsMdSynchronized(x)                 ((x) & mdSynchronized)
#define IsMdAbstract(x)                     ((x) & mdAbstract)
#define IsMdSpecialName(x)                  ((x) & mdSpecialName)
#define IsMdRTSpecialName(x)                ((x) & mdRTSpecialName)
#define IsMdInstanceInitializer(x, str)     (((x) & mdRTSpecialName) && !strcmp((str), COR_CTOR_METHOD_NAME))
#define IsMdInstanceInitializerW(x, str)    (((x) & mdRTSpecialName) && !wcscmp((str), COR_CTOR_METHOD_NAME_W))
#define IsMdClassConstructor(x, str)        (((x) & mdRTSpecialName) && !strcmp((str), COR_CCTOR_METHOD_NAME))
#define IsMdClassConstructorW(x, str)       (((x) & mdRTSpecialName) && !wcscmp((str), COR_CCTOR_METHOD_NAME_W))

#define IsMdPinvokeImpl(x)                  ((x) & mdPinvokeImpl)


// FieldDef attr bits, used by DefineField.
typedef enum
{
    // member access mask - Use this mask to retrieve accessibility information.
    fdFieldAccessMask   =   0x0007,
    fdPublic            =   0x0001,     // Accessibly by anyone who has visibility to this scope.    
    fdPrivate           =   0x0002,     // Accessible only by the parent type.  
    fdFamily            =   0x0003,     // Accessible only by type and sub-types.    
    fdAssembly          =   0x0004,     // Accessibly by anyone in the Assembly.
    fdFamANDAssem       =   0x0005,     // Accessible by sub-types only in this Assembly.
    fdFamORAssem        =   0x0006,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    fdPrivateScope      =   0x0007,     // Member not referenceable.
    // end member access mask

    // field contract attributes.
    fdStatic            =   0x0010,     // Defined on type, else per instance.
    fdInitOnly          =   0x0020,     // Field may only be initialized, not written to after init.
    fdLiteral           =   0x0040,     // Value is compile time constant.
    fdNotSerialized     =   0x0080,     // Field does not have to be serialized when type is remoted.
    fdVolatile          =   0x0100,     // Field is accessed in an unsynchronized way.

    fdSpecialName       =   0x0200,     // field is special.  Name describes how.
    fdRTSpecialName     =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    
    // interop attributes
    fdPinvokeImpl       =   0x2000,     // Implementation is forwarded through pinvoke.

    fdReserved3         =   0x1000,     // Used internally as fdHasFieldMarhsal
    fdReserved1         =   0x4000,     // Used internally as fdHasSecurity.
    fdReserved2         =   0x8000,     // Used internally as fdHasDefault
} CorFieldAttr;

// Macros for accessing the members of CorFieldAttr.
#define IsFdPublic(x)                       (((x) & fdFieldAccessMask) == fdPublic)
#define IsFdPrivate(x)                      (((x) & fdFieldAccessMask) == fdPrivate)
#define IsFdFamily(x)                       (((x) & fdFieldAccessMask) == fdFamily)
#define IsFdAssembly(x)                     (((x) & fdFieldAccessMask) == fdAssembly)
#define IsFdFamANDAssem(x)                  (((x) & fdFieldAccessMask) == fdFamANDAssem)
#define IsFdFamORAssem(x)                   (((x) & fdFieldAccessMask) == fdFamORAssem)
#define IsFdPrivateScope(x)                 (((x) & fdFieldAccessMask) == fdPrivateScope)

#define IsFdStatic(x)                       ((x) & fdStatic)
#define IsFdInitOnly(x)                     ((x) & fdInitOnly)
#define IsFdLiteral(x)                      ((x) & fdLiteral)
#define IsFdNotSerialized(x)                ((x) & fdNotSerialized)

#define IsFdVolatile(x)                     ((x) & fdVolatile)

#define IsFdPinvokeImpl(x)                  ((x) & fdPinvokeImpl)
#define IsFdSpecialName(x)                  ((x) & fdSpecialName)
#define IsFdRTSpecialName(x)                ((x) & fdRTSpecialName)


// Param attr bits, used by DefineParam. 
typedef enum
{
    pdIn        =   0x0001,     // Param is [In]    
    pdOut       =   0x0002,     // Param is [out]   
    pdLcid      =   0x0004,     // Param is [lcid]  
    pdRetval    =   0x0008,     // Param is [Retval]    
    pdOptional  =   0x0010,     // Param is optional    

    pdReserved1 =   0x1000,     // reserved bit, as pdHasDefault
    pdReserved2 =   0x2000,     // reserved bit, as pdHasFieldMarshal
    pdReserved3 =   0x4000,     // reserved bit
    pdReserved4 =   0x8000      // reserved bit 
} CorParamAttr;

// Macros for accessing the members of CorParamAttr.
#define IsPdIn(x)                           ((x) & pdIn)
#define IsPdOut(x)                          ((x) & pdOut)
#define IsPdLcid(x)                         ((x) & pdLcid)
#define IsPdRetval(x)                       ((x) & pdRetval)
#define IsPdOptional(x)                     ((x) & pdOptional)


// Property attr bits, used by DefineProperty.
typedef enum
{
    prDefaultProperty   =   0x0001,     // This is the default property 
    prReadOnly          =   0x0002,     // property is read only (subclass can't supply a setter)

    prSpecialName       =   0x0200,     // property is special.  Name describes how.
    prRTSpecialName     =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.

	prNotSerialized		=	0x0800,		// The class is not serialized.

    prReserved1         =   0x1000,     // reserved bit, as prHasDefault 
    prReserved2         =   0x2000,     // reserved bit

    prReserved3         =   0x4000,     // reserved bit 
    prReserved4         =   0x8000      // reserved bit 
} CorPropertyAttr;

// Macros for accessing the members of CorPropertyAttr.
#define IsPrDefaultProperty(x)				((x) & prDefaultProperty)
#define IsPrReadOnly(x)						((x) & prReadOnly)
#define IsPrSpecialName(x)				    ((x) & prSpecialName)
#define IsPrRTSpecialName(x)				((x) & prRTSpecialName)
#define IsPrNotSerialized(x)				((x) & prNotSerialized)


// Event attr bits, used by DefineEvent.
typedef enum   
{
    evPublic            =   0x0001,     // public event 
    evPrivate           =   0x0002,     // private event    
    evProtected         =   0x0004,     // protected event  
    evSpecialName       =   0x0200,     // event is special.  Name describes how.
    evRTSpecialName     =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
} CorEventAttr;

// Macros for accessing the members of CorEventAttr.
#define IsEvPublic(x)                       ((x) & evPublic)
#define IsEvPrivate(x)                      ((x) & evPrivate)
#define IsEvProtected(x)                    ((x) & evProtected)
#define IsEvSpecialName(x)                  ((x) & evSpecialName)
#define IsEvRTSpecialName(x)                ((x) & evRTSpecialName)


// MethodSemantic attr bits, used by DefineProperty, DefineEvent.
typedef enum
{
    msSetter    =   0x0001,     // Setter for property  
    msGetter    =   0x0002,     // Getter for property  
    msReset     =   0x0004,     // Reset method for property    
    msTestDefault = 0x0008,     // TestDefault method for property  
    msOther     =   0x0010,     // other method for property or event   
    msAddOn     =   0x0020,     // AddOn method for event   
    msRemoveOn  =   0x0040,     // RemoveOn method for event    
    msFire      =   0x0080,     // Fire method for event    
} CorMethodSemanticsAttr;

// Macros for accessing the members of CorMethodSemanticsAttr.
#define IsMsSetter(x)                       ((x) & msSetter)
#define IsMsGetter(x)                       ((x) & msGetter)
#define IsMsReset(x)                        ((x) & msReset)
#define IsMsTestDefault(x)                  ((x) & msTestDefault)
#define IsMsOther(x)                        ((x) & msOther)
#define IsMsAddOn(x)                        ((x) & msAddOn)
#define IsMsRemoveOn(x)                     ((x) & msRemoveOn)
#define IsMsFire(x)                         ((x) & msFire)


// DeclSecurity attr bits, used by DefinePermissionSet.
typedef enum
{
    dclActionMask       =   0x000f,     // Mask allows growth of enum.
    dclActionNil        =   0x0000, 
    dclRequest          =   0x0001,     //  
    dclDemand           =   0x0002,     //  
    dclAssert           =   0x0003,     //  
    dclDeny             =   0x0004,     //  
    dclPermitOnly       =   0x0005,     //  
    dclLinktimeCheck    =   0x0006,     //  
    dclInheritanceCheck =   0x0007,     //  
    dclMaximumValue     =   0x0007,     // Maximum legal value  
} CorDeclSecurity;

// Macros for accessing the members of CorDeclSecurity.
#define IsDclActionNil(x)                   (((x) & dclActionMask) == dclActionNil)
#define IsDclRequest(x)                     (((x) & dclActionMask) == dclRequest)
#define IsDclDemand(x)                      (((x) & dclActionMask) == dclDemand)
#define IsDclAssert(x)                      (((x) & dclActionMask) == dclAssert)
#define IsDclDeny(x)                        (((x) & dclActionMask) == dclDeny)
#define IsDclPermitOnly(x)                  (((x) & dclActionMask) == dclPermit)
#define IsDclLinktimeCheck(x)               (((x) & dclActionMask) == dclLinktimeCheck)
#define IsDclInheritanceCheck(x)            (((x) & dclActionMask) == dclInheritanceCheck)
#define IsDclMaximumValue(x)                (((x) & dclActionMask) == dclMaximumValue)


// MethodImpl attr bits, used by DefineMethodImpl.
typedef enum  
{
    // code impl mask
    miCodeTypeMask      =   0x0003,   // Flags about code type.   
    miNative            =   0x0000,   // Method impl is native.     
    miIL                =   0x0001,   // Method impl is IL.   
    miOPTIL             =   0x0002,   // Method impl is OPTIL 
    miRuntime           =   0x0003,   // Method impl is provided by the runtime.
    // end code impl mask

    // managed mask
    miManagedMask       =   0x0020,   // Flags specifying whether the code is managed or unmanaged.
    miUnmanaged         =   0x0020,   // Method impl is unmanaged, otherwise managed.
    miManaged           =   0x0000,   // Method impl is managed.
    // end managed mask

    // implementation info and interop
    miImplemented       =   0x0010,   // Indicates method is defined; used primarily in merge scenarios.
    miOLE               =   0x0080,   // Indicates method sig is mangled to return HRESULT, with retval as param 

    miInternalCall      =   0x1000,   // Reserved for internal use.

    miMaxMethodImplVal  =   0xffff,   // Range check value    
} CorMethodImpl; 

// Macros for accesing the members of CorMethodImpl.
#define IsMiNative(x)                       (((x) & miCodeTypeMask) == miNative)
#define IsMiIL(x)                           (((x) & miCodeTypeMask) == miIL)
#define IsMiOPTIL(x)                        (((x) & miCodeTypeMask) == miOPTIL)
#define IsMiRuntime(x)                      (((x) & miCodeTypeMask) == miRuntime)

#define IsMiUnmanaged(x)                    (((x) & miManagedMask) == miUnmanaged)
#define IsMiManaged(x)                      (((x) & miManagedMask) == miManaged)

#define IsMiImplemented(x)                  ((x) & miImplemented)
#define IsMiOLE(x)                          ((x) & miOLE)

#define IsMiInternalCall(x)                 ((x) & miInternalCall)


// PinvokeMap attr bits, used by DefinePinvokeMap.
typedef enum  
{ 
    pmNoMangle          = 0x0001,   // Pinvoke is to use the member name as specified.
    pmCharSetMask       = 0x0008,   // Heuristic used in data type & name mapping.
    pmCharSetNotSpec    = 0x0000,
    pmCharSetAnsi       = 0x0002, 
    pmCharSetUnicode    = 0x0004,
    pmCharSetAuto       = 0x0008,
    pmPinvokeOLE        = 0x0020,   // Heuristic: pinvoke will return hresult, with return value becoming the retval param. Not relevant for fields. 
    pmSupportsLastError = 0x0040,   // Information about target function. Not relevant for fields.
    // None of the calling convention flags is relevant for fields.
    pmCallConvWinapi    = 0x0100,   // Pinvoke will use native callconv appropriate to target windows platform.
    pmCallConvCdecl     = 0x0200,
    pmCallConvStdcall   = 0x0400,
    pmCallConvThiscall  = 0x0800,   // In M9, pinvoke will raise exception.
    pmCallConvFastcall  = 0x1000,
} CorPinvokeMap;

// Macros for accessing the members of CorPinvokeMap
// @todo:  The mask for charset is wrong.  This'll need to be fixed in Flags Part 2.
#define IsPmNoMangle(x)                     ((x) & pmNoMangle)
#define IsPmCharSetAnsi(x)                  ((x) & pmCharSetAnsi)
#define IsPmCharSetUnicode(x)               ((x) & pmCharSetUnicode)
#define IsPmCharSetAuto(x)                  ((x) & pmCharSetAuto)
#define IsPmCharSetNotSpec(x)               (!IsPmCharSetAnsi(x) && !IsPmCharSetUnicode(x) && !IsPmCharSetAuto(x))
#define IsPmPinvokeOLE(x)                   ((x) & pmPinvokeOLE)
#define IsPmSupportsLastError(x)            ((x) & pmSupportsLastError)

#define IsPmCallConvWinapi(x)               ((x) & pmCallConvWinapi)
#define IsPmCallConvCdecl(x)                ((x) & pmCallConvCdecl)
#define IsPmCallConvThiscall(x)             ((x) & pmCallConvThiscall)
#define IsPmCallConvFastcall(x)             ((x) & pmCallConvFastcall)


// Assembly attr bits, used by DefineAssembly.
typedef enum 
{
    afImplicitComTypes      =   0x0001,     // ComType definitions are implicit within the files.
    afImplicitResources     =   0x0002,     // Resource definitions are implicit within the files.

    afCompatibilityMask     =   0x0070,
    afSideBySideCompatible  =   0x0000,      // The assembly is side by side compatible.
    afNonSideBySideAppDomain=   0x0010,     // The assembly cannot execute with other versions if
                                            // they are executing in the same application domain.
    afNonSideBySideProcess  =   0x0020,     // The assembly cannot execute with other versions if
                                            // they are executing in the same process.
    afNonSideBySideMachine  =   0x0030,     // The assembly cannot execute with other versions if
                                            // they are executing on the same machine.
} CorAssemblyFlags;

// Macros for accessing the members of CorAssemblyFlags.
#define IsAfImplicitComTypes(x)             ((x) & afImplicitComTypes)
#define IsAfImplicitResources(x)            ((x) & afImplicitResources)
#define IsAfSideBySideCompatible(x)         (((x) & afCompatibilityMask) == afSideBySideCompatible)
#define IsAfNonSideBySideAppDomain(x)       (((x) & afCompatibilityMask) == afNonSideBySideAppDomain)
#define IsAfNonSideBySideProcess(x)         (((x) & afCompatibilityMask) == afNonSideBySideProcess)
#define IsAfNonSideBySideMachine(x)         (((x) & afCompatibilityMask) == afNonSideBySideMachine)


// AssemblyRef attr bits, used by DefineAssemblyRef.
typedef enum 
{
    arFullOriginator        =   0x0001,     // The assembly ref holds the full (unhashed) originator.
} CorAssemblyRefFlags;

// Macros for accessing the members of CorAssemblyRefFlags.
#define IsArFullOriginator(x)               ((x) & arFullOriginator)


// ComType attr bits, used by DefineComType.
typedef enum
{
    ctVisibilityMask        =   0x0007,
    ctPublic                =   0x0001,     // The ComType is exported from the Assembly.
    ctPrivate               =   0x0002,     // The ComType is private to the Assembly.
} CorComTypeFlags;

// Macros for accessing the members of CorComTypeFlags.
#define IsCtPublic(x)                       (((x) & ctVisibilityMask) == ctPublic)
#define IsCtPrivate(x)                      (((x) & ctVisibilityMask) == ctPrivate)


// ManifestResource attr bits, used by DefineManifestResource.
typedef enum
{
    mrVisibilityMask        =   0x0007,
    mrPublic                =   0x0001,     // The Resource is exported from the Assembly.
    mrPrivate               =   0x0002,     // The Resource is private to the Assembly.
} CorManifestResourceFlags;

// Macros for accessing the members of CorManifestResourceFlags.
#define IsMrPublic(x)                       (((x) & mrVisibilityMask) == mrPublic)
#define IsMrPrivate(x)                      (((x) & mrVisibilityMask) == mrPrivate)


// File attr bits, used by DefineFile.
typedef enum
{
    ffWriteable             =   0x0001,     // The file is writeable post-build.
    ffContainsNoMetaData    =   0x0002,     // The file has no MetaData.
} CorFileFlags;

// Macros for accessing the members of CorFileFlags.
#define IsFfWriteable(x)                    ((x) & ffWriteable)
#define IsFfContainsNoMetaData(x)           ((x) & ffContainsNoMetaData)


// structures and enums moved from COR.H
typedef unsigned __int8 COR_SIGNATURE;

typedef COR_SIGNATURE* PCOR_SIGNATURE;      // pointer to a cor sig.  Not void* so that 
                                            // the bytes can be incremented easily  
typedef const COR_SIGNATURE* PCCOR_SIGNATURE;


typedef const char * MDUTF8CSTR;
typedef char * MDUTF8STR;

//*****************************************************************************
//
// Element type for Cor signature
//
//*****************************************************************************

typedef enum  
{
    ELEMENT_TYPE_END            = 0x0,  
    ELEMENT_TYPE_VOID           = 0x1,  
    ELEMENT_TYPE_BOOLEAN        = 0x2,  
    ELEMENT_TYPE_CHAR           = 0x3,  
    ELEMENT_TYPE_I1             = 0x4,  
    ELEMENT_TYPE_U1             = 0x5, 
    ELEMENT_TYPE_I2             = 0x6,  
    ELEMENT_TYPE_U2             = 0x7,  
    ELEMENT_TYPE_I4             = 0x8,  
    ELEMENT_TYPE_U4             = 0x9,  
    ELEMENT_TYPE_I8             = 0xa,  
    ELEMENT_TYPE_U8             = 0xb,  
    ELEMENT_TYPE_R4             = 0xc,  
    ELEMENT_TYPE_R8             = 0xd,  
    ELEMENT_TYPE_STRING         = 0xe,  

    // every type above PTR will be simple type 
    ELEMENT_TYPE_PTR            = 0xf,      // PTR <type>   
    ELEMENT_TYPE_BYREF          = 0x10,     // BYREF <type> 

    // Please use ELEMENT_TYPE_VALUETYPE. ELEMENT_TYPE_VALUECLASS is deprecated.
    ELEMENT_TYPE_VALUETYPE      = 0x11,     // VALUETYPE <class Token> 
    ELEMENT_TYPE_VALUECLASS     = ELEMENT_TYPE_VALUETYPE, 
    ELEMENT_TYPE_CLASS          = 0x12,     // CLASS <class Token>  

    ELEMENT_TYPE_SDARRAY        = 0x13,     // SDARRAY <type> <bound or 0>  DEPRECATED use ELEMENT_TYPE_SZARRAY
    ELEMENT_TYPE_ARRAY          = 0x14,     // MDARRAY <type> <rank> <bcount> <bound1> ... <lbcount> <lb1> ...  

    ELEMENT_TYPE_COPYCTOR       = 0x15,     // COPYCTOR <type>      // copy construct the argument
    ELEMENT_TYPE_TYPEDBYREF     = 0x16,     // This is a simple type.   

    ELEMENT_TYPE_VALUEARRAY     = 0x17,     // VALUEARRAY <type> <bound>    
    ELEMENT_TYPE_I              = 0x18,     // native integer size  
    ELEMENT_TYPE_U              = 0x19,     // native unsigned integer size 
    ELEMENT_TYPE_R              = 0x1A,     // native real size 
    ELEMENT_TYPE_FNPTR          = 0x1B,     // FNPTR <complete sig for the function including calling convention>
    ELEMENT_TYPE_OBJECT         = 0x1C,     // Shortcut for System.Object
    ELEMENT_TYPE_SZARRAY        = 0x1D,     // Shortcut for single dimension zero lower bound array
                                            // SZARRAY <type>
    ELEMENT_TYPE_GENERICARRAY   = 0x1E,     // Array with unknown rank
                                            // GZARRAY <type>

    // This is only for binding
    ELEMENT_TYPE_CMOD_REQD      = 0x1F,     // required C modifier : E_T_CMOD_REQD <mdTypeRef/mdTypeDef>
    ELEMENT_TYPE_CMOD_OPT       = 0x20,     // optional C modifier : E_T_CMOD_OPT <mdTypeRef/mdTypeDef>

    // Note that this is the max of base type excluding modifiers   
    ELEMENT_TYPE_MAX            = 0x21,     // first invalid element type   

    // These are experimental for internal use only
    ELEMENT_TYPE_VAR            = ELEMENT_TYPE_MAX + 1,     // a type variable VAR <U1> 
    ELEMENT_TYPE_NAME           = ELEMENT_TYPE_MAX + 2,     // class by name NAME <count> <chars>


    ELEMENT_TYPE_MODIFIER       = 0x40, 
    ELEMENT_TYPE_SENTINEL       = 0x01 | ELEMENT_TYPE_MODIFIER, // sentinel for varargs
    ELEMENT_TYPE_CONST          = 0x02 | ELEMENT_TYPE_MODIFIER, 
    ELEMENT_TYPE_VOLATILE       = 0x03 | ELEMENT_TYPE_MODIFIER, 
    ELEMENT_TYPE_READONLY       = 0x04 | ELEMENT_TYPE_MODIFIER,

} CorElementType;

//
// Calling convention flags.
//


typedef enum  
{
    IMAGE_CEE_CS_CALLCONV_DEFAULT   = 0x0,  

    IMAGE_CEE_CS_CALLCONV_C         = 0x1,  
    IMAGE_CEE_CS_CALLCONV_STDCALL   = 0x2,  
    IMAGE_CEE_CS_CALLCONV_THISCALL  = 0x3,  
    IMAGE_CEE_CS_CALLCONV_FASTCALL  = 0x4,  

    IMAGE_CEE_CS_CALLCONV_VARARG    = 0x5,  
    IMAGE_CEE_CS_CALLCONV_FIELD     = 0x6,  
    IMAGE_CEE_CS_CALLCONV_LOCAL_SIG = 0x7,
    IMAGE_CEE_CS_CALLCONV_PROPERTY  = 0x8,
    IMAGE_CEE_CS_CALLCONV_UNMGD     = 0x9,
    IMAGE_CEE_CS_CALLCONV_MAX       = 0x10,  // first invalid calling convention    


        // The high bits of the calling convention convey additional info   
    IMAGE_CEE_CS_CALLCONV_MASK      = 0x0f,  // Calling convention is bottom 4 bits 
    IMAGE_CEE_CS_CALLCONV_HASTHIS   = 0x20,  // Top bit indicates a 'this' parameter    
    IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS = 0x40,  // This parameter is explicitly in the signature
} CorCallingConvention;

#if __IMAGE_COR_CPLUSPLUS__
inline bool isCallConv(unsigned sigByte, CorCallingConvention conv)
{
    return ((sigByte & IMAGE_CEE_CS_CALLCONV_MASK) == (unsigned) conv); 
}
#else
#define isCallConv(A,B) (((A)&IMAGE_CEE_CS_CALLCONV_MASK)==(unsigned)(B))
#endif

typedef enum    
{
    IMAGE_CEE_CS_END        = 0x0,
    IMAGE_CEE_CS_VOID       = 0x1,
    IMAGE_CEE_CS_I4         = 0x2,
    IMAGE_CEE_CS_I8         = 0x3,
    IMAGE_CEE_CS_R4         = 0x4,
    IMAGE_CEE_CS_R8         = 0x5,
    IMAGE_CEE_CS_PTR        = 0x6,
    IMAGE_CEE_CS_OBJECT     = 0x7,
    IMAGE_CEE_CS_STRUCT4    = 0x8,
    IMAGE_CEE_CS_STRUCT32   = 0x9,
    IMAGE_CEE_CS_BYVALUE    = 0xA,
} CorArgType;


//*****************************************************************************
//
// Native type for N-Direct
//
//*****************************************************************************

typedef enum  
{
    NATIVE_TYPE_END         = 0x0,    //DEPRECATED
    NATIVE_TYPE_VOID        = 0x1,    //DEPRECATED
    NATIVE_TYPE_BOOLEAN     = 0x2,    // (4 byte boolean value: TRUE = non-zero, FALSE = 0)
    NATIVE_TYPE_I1          = 0x3,  
    NATIVE_TYPE_U1          = 0x4,  
    NATIVE_TYPE_I2          = 0x5,  
    NATIVE_TYPE_U2          = 0x6,  
    NATIVE_TYPE_I4          = 0x7,  
    NATIVE_TYPE_U4          = 0x8,  
    NATIVE_TYPE_I8          = 0x9,  
    NATIVE_TYPE_U8          = 0xa,  
    NATIVE_TYPE_R4          = 0xb,  
    NATIVE_TYPE_R8          = 0xc,  
    NATIVE_TYPE_SYSCHAR     = 0xd,    //DEPRECATED 
    NATIVE_TYPE_VARIANT     = 0xe,  
    NATIVE_TYPE_CURRENCY    = 0xf,  
    NATIVE_TYPE_PTR         = 0x10,   //DEPRECATED  

    NATIVE_TYPE_DECIMAL     = 0x11, 
    NATIVE_TYPE_DATE        = 0x12, 
    NATIVE_TYPE_BSTR        = 0x13, 
    NATIVE_TYPE_LPSTR       = 0x14, 
    NATIVE_TYPE_LPWSTR      = 0x15, 
    NATIVE_TYPE_LPTSTR      = 0x16, 
    NATIVE_TYPE_FIXEDSYSSTRING  = 0x17, 
    NATIVE_TYPE_OBJECTREF   = 0x18,   //DEPRECATED
    NATIVE_TYPE_IUNKNOWN    = 0x19,   //DEPRECATED
    NATIVE_TYPE_IDISPATCH   = 0x1a, 
    NATIVE_TYPE_STRUCT      = 0x1b, 
    NATIVE_TYPE_INTF        = 0x1c, 
    NATIVE_TYPE_SAFEARRAY   = 0x1d, 
    NATIVE_TYPE_FIXEDARRAY  = 0x1e, 
    NATIVE_TYPE_INT         = 0x1f, 
    NATIVE_TYPE_UINT        = 0x20, 

    //@todo: sync up the spec   
    NATIVE_TYPE_NESTEDSTRUCT  = 0x21, //DEPRECATED (use NATIVE_TYPE_STRUCT)   

    NATIVE_TYPE_BYVALSTR    = 0x22,
                              
    NATIVE_TYPE_ANSIBSTR    = 0x23,

    NATIVE_TYPE_TBSTR       = 0x24, // select BSTR or ANSIBSTR depending on platform


    NATIVE_TYPE_VARIANTBOOL = 0x25, // (2-byte boolean value: TRUE = -1, FALSE = 0)
    NATIVE_TYPE_FUNC        = 0x26,
    NATIVE_TYPE_LPVOID      = 0x27, // blind pointer (no deep marshaling)

    NATIVE_TYPE_ASANY       = 0x28,
    NATIVE_TYPE_R           = 0x29, // agnostic floating point

    NATIVE_TYPE_ARRAY       = 0x2a,
    NATIVE_TYPE_LPSTRUCT    = 0x2b,

    NATIVE_TYPE_MAX         = 0x50,      // first invalid element type   
} CorNativeType;

// Maximum size of a NativeType descriptor.
#define     NATIVE_TYPE_MAX_CB      1   


enum 
{
    DESCR_GROUP_METHODDEF = 0,          // DESCR group for MethodDefs   
    DESCR_GROUP_METHODIMPL,             // DESCR group for MethodImpls  
};
//#include <.h>
/****************************************************************************/
/* old style exceptions.  Big difference is that new style eh has a flags
   field per entry */
//
// IL Exception Clause.
//
typedef struct        // FIX This is deprecated   
{
    DWORD       StartOffset;    
    DWORD       EndOffset;  
    DWORD       HandlerOffset;  
    union { 
        DWORD       ClassToken;     // use for type-based exception handlers    
        DWORD       FilterOffset;   // use for filter-based exception handlers (COR_ILEXCEPTION_FILTER is set)  
    };  
} COR_ILEXCEPTION_CLAUSE;

typedef struct               // FIX this is deprecated   
{
    WORD        Flags;                              // set with CorExceptionFlag enum   
    WORD        Count;                              // number of exceptions that follow 
    COR_ILEXCEPTION_CLAUSE Clauses[1];  // actually of variable size;   
} COR_ILEXCEPTION; 

/***********************************************************************************/
// a COR_ILMETHOD_SECT is a generic container for attributes that are private
// to a particular method.  The COR_ILMETHOD structure points to one of these
// (see GetSect()).  COR_ILMETHOD_SECT can decode the Kind of attribute (but not
// its internal data layout, and can skip past the current attibute to find the
// Next one.   The overhead for COR_ILMETHOD_SECT is a minimum of 2 bytes.  

typedef enum                             // codes that identify attributes   
{
    CorILMethod_Sect_Reserved    = 0,   
    CorILMethod_Sect_EHTable     = 1,   
    CorILMethod_Sect_OptILTable  = 2,   

    CorILMethod_Sect_KindMask    = 0x3F,        // The mask for decoding the type code  
    CorILMethod_Sect_FatFormat   = 0x40,        // fat format   
    CorILMethod_Sect_MoreSects   = 0x80,        // there is another attribute after this one    
} CorILMethodSect;

/************************************/
/* NOTE this structure must be DWORD aligned!! */
#define COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE    0xFF 
typedef struct tagCOR_ILMETHOD_SECT_SMALL {
    BYTE Kind;  
    BYTE DataSize;  

        //Data follows  
#if __IMAGE_COR_CPLUSPLUS__
    const BYTE* Data() const { return(((const BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_SECT_SMALL)); }    
#endif
} COR_ILMETHOD_SECT_SMALL;

/************************************/
/* NOTE this structure must be DWORD aligned!! */
typedef struct tagCOR_ILMETHOD_SECT_FAT {
    unsigned Kind : 8;  
    unsigned DataSize : 24; 

        //Data follows  
#if __IMAGE_COR_CPLUSPLUS__
    const BYTE* Data() const { return(((const BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_SECT_FAT)); }  
#endif
} COR_ILMETHOD_SECT_FAT;

/************************************/
/* NOTE this structure must be DWORD aligned!! */
#if __IMAGE_COR_CPLUSPLUS__
struct COR_ILMETHOD_SECT 
{
    bool More() const           { return((AsSmall()->Kind & CorILMethod_Sect_MoreSects) != 0); }    
    CorILMethodSect Kind() const{ return((CorILMethodSect) (AsSmall()->Kind & CorILMethod_Sect_KindMask)); }    
    const COR_ILMETHOD_SECT* Next() const   {   
        if (!More()) return(0); 
        if (IsFat()) return(((COR_ILMETHOD_SECT*) AsFat()->Data()[AsFat()->DataSize])->Align());    
        return(((COR_ILMETHOD_SECT*) AsSmall()->Data()[AsSmall()->DataSize])->Align()); 
        }   
    const BYTE* Data() const {  
        if (IsFat()) return(AsFat()->Data());   
        return(AsSmall()->Data());  
        }   
    unsigned DataSize() const { 
        if (IsFat()) return(AsFat()->DataSize); 
        return(AsSmall()->DataSize);    
        }   

    friend struct COR_ILMETHOD; 
    friend struct tagCOR_ILMETHOD_FAT; 
    friend struct tagCOR_ILMETHOD_TINY;    
    bool IsFat() const                            { return((AsSmall()->Kind & CorILMethod_Sect_FatFormat) != 0); }  
protected:
    const COR_ILMETHOD_SECT_FAT*   AsFat() const  { return((COR_ILMETHOD_SECT_FAT*) this); }    
    const COR_ILMETHOD_SECT_SMALL* AsSmall() const{ return((COR_ILMETHOD_SECT_SMALL*) this); }  
    const COR_ILMETHOD_SECT* Align() const        { return((COR_ILMETHOD_SECT*) ((((UINT_PTR) this) + 3) & ~3));  } 

    // The body is either a COR_ILMETHOD_SECT_SMALL or COR_ILMETHOD_SECT_FAT    
    // (as indicated by the CorILMethod_Sect_FatFormat bit  
};
#endif

/***********************************************************************************/
/* If COR_ILMETHOD_SECT_HEADER::Kind() = CorILMethod_Sect_EHTable then the attribute
   is a list of exception handling clauses.  There are two formats, fat or small
*/
typedef enum                        // defintitions for the Flags field below (for both big and small)  
{
    COR_ILEXCEPTION_CLAUSE_NONE,                    // This is a typed handler
    COR_ILEXCEPTION_CLAUSE_OFFSETLEN = 0x0000,      // Deprecated
    COR_ILEXCEPTION_CLAUSE_DEPRECATED = 0x0000,     // Deprecated
    COR_ILEXCEPTION_CLAUSE_FILTER  = 0x0001,        // If this bit is on, then this EH entry is for a filter    
    COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002,        // This clause is a finally clause  
} CorExceptionFlag;

/***********************************/
typedef struct  
{
    CorExceptionFlag    Flags;  
    DWORD               TryOffset;    
    DWORD               TryLength;      // relative to start of try block
    DWORD               HandlerOffset;
    DWORD               HandlerLength;  // relative to start of handler
    union {
        DWORD           ClassToken;     // use for type-based exception handlers    
        DWORD           FilterOffset;   // use for filter-based exception handlers (COR_ILEXCEPTION_FILTER is set)  
    };
} COR_ILMETHOD_SECT_EH_CLAUSE_FAT;

/***********************************/
#if __IMAGE_COR_CPLUSPLUS__
struct COR_ILMETHOD_SECT_EH_FAT : public COR_ILMETHOD_SECT_FAT {
    static unsigned Size(unsigned ehCount) {    
        return (sizeof(COR_ILMETHOD_SECT_EH_FAT) +  
                sizeof(COR_ILMETHOD_SECT_EH_CLAUSE_FAT) * (ehCount-1)); 
        }   
                    
    COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size   
};
#else
typedef struct
{
    COR_ILMETHOD_SECT_FAT   SectFat;
    COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size   
} COR_ILMETHOD_SECT_EH_FAT;
#endif

/***********************************/
typedef struct  
{
    CorExceptionFlag    Flags         : 16; 
    unsigned            TryOffset     : 16; 
    unsigned            TryLength     : 8;  // relative to start of try block
    unsigned            HandlerOffset : 16;
    unsigned            HandlerLength : 8;  // relative to start of handler
    union {
        DWORD       ClassToken;
        DWORD       FilterOffset; 
    };
} COR_ILMETHOD_SECT_EH_CLAUSE_SMALL;

/***********************************/
#if __IMAGE_COR_CPLUSPLUS__
struct COR_ILMETHOD_SECT_EH_SMALL : public COR_ILMETHOD_SECT_SMALL {
    static unsigned Size(unsigned ehCount) {    
        return (sizeof(COR_ILMETHOD_SECT_EH_SMALL) +    
                sizeof(COR_ILMETHOD_SECT_EH_CLAUSE_SMALL) * (ehCount-1));   
        }   
                    
    WORD Reserved;                                  // alignment padding    
    COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size   
};
#else
typedef struct
{
    COR_ILMETHOD_SECT_SMALL SectSmall;
    WORD Reserved;
    COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size   
} COR_ILMETHOD_SECT_EH_SMALL;
#endif
/***********************************/
#ifdef __IMAGE_COR_CPLUSPLUS__
extern "C" {
#endif
// exported functions (implementation in Format\Format.cpp:
COR_ILMETHOD_SECT_EH_CLAUSE_FAT* __stdcall SectEH_EHClause(void *pSectEH, unsigned idx, COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff);
        // compute the size of the section (best format)    
        // codeSize is the size of the method   
    // deprecated
unsigned __stdcall SectEH_SizeWithCode(unsigned ehCount, unsigned codeSize);  

    // will return worse-case size and then Emit will return actual size
unsigned __stdcall SectEH_SizeWorst(unsigned ehCount);  

    // will return exact size which will match the size returned by Emit
unsigned __stdcall SectEH_SizeExact(unsigned ehCount, COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses);  

        // emit the section (best format);  
unsigned __stdcall SectEH_Emit(unsigned size, unsigned ehCount,   
                  COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,
                  BOOL moreSections, BYTE* outBuff);

#ifdef __IMAGE_COR_CPLUSPLUS__
}

struct COR_ILMETHOD_SECT_EH : public COR_ILMETHOD_SECT
{
    unsigned EHCount() const {  
        return(IsFat() ? (Fat.DataSize / sizeof(COR_ILMETHOD_SECT_EH_CLAUSE_FAT)) : 
                        (Small.DataSize / sizeof(COR_ILMETHOD_SECT_EH_CLAUSE_SMALL))); 
    }   

        // return one clause in its fat form.  Use 'buff' if needed 
    const COR_ILMETHOD_SECT_EH_CLAUSE_FAT* EHClause(unsigned idx, COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff) const
    { return SectEH_EHClause((void *)this, idx, buff); };
        // compute the size of the section (best format)    
        // codeSize is the size of the method   
    // deprecated
    unsigned static Size(unsigned ehCount, unsigned codeSize)
    { return SectEH_SizeWithCode(ehCount, codeSize); };

    // will return worse-case size and then Emit will return actual size
    unsigned static Size(unsigned ehCount)
    { return SectEH_SizeWorst(ehCount); };

    // will return exact size which will match the size returned by Emit
    unsigned static Size(unsigned ehCount, const COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses)
    { return SectEH_SizeExact(ehCount, (COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)clauses);  };

        // emit the section (best format);  
    unsigned static Emit(unsigned size, unsigned ehCount,   
                  const COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,   
                  bool moreSections, BYTE* outBuff)
    { return SectEH_Emit(size, ehCount, (COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)clauses, moreSections, outBuff); };

//private:

    union { 
        COR_ILMETHOD_SECT_EH_SMALL Small;   
        COR_ILMETHOD_SECT_EH_FAT Fat;   
        };  
};
#else
typedef union 
{
    COR_ILMETHOD_SECT_EH_SMALL Small;   
    COR_ILMETHOD_SECT_EH_FAT Fat;   
} COR_ILMETHOD_SECT_EH;
#endif
/***********************************************************************************/
typedef enum  
{ 
    CorILMethod_InitLocals      = 0x0010,           // call default constructor on all local vars   
    CorILMethod_MoreSects       = 0x0008,           // there is another attribute after this one    

    CorILMethod_CompressedIL    = 0x0040,           // FIX Remove this and do it on a per Module basis  

        // Indicates the format for the COR_ILMETHOD header 
    CorILMethod_FormatShift     = 3,    
    CorILMethod_FormatMask      = ((1 << CorILMethod_FormatShift) - 1), 
    CorILMethod_TinyFormat      = 0x0002,         // use this code if the code size is even 
    CorILMethod_SmallFormat     = 0x0000,           
    CorILMethod_FatFormat       = 0x0003,   
    CorILMethod_TinyFormat1     = 0x0006,         // use this code if the code size is odd  
} CorILMethodFlags;

/***************************************************************************/
/* Used when the method is tiny (< 64 bytes), and there are no local vars */
typedef struct tagCOR_ILMETHOD_TINY
{
#if __IMAGE_COR_CPLUSPLUS__
    bool     IsTiny() const         { return((Flags_CodeSize & (CorILMethod_FormatMask >> 1)) == CorILMethod_TinyFormat); } 
    unsigned GetCodeSize() const    { return(((unsigned) Flags_CodeSize) >> (CorILMethod_FormatShift-1)); } 
    unsigned GetMaxStack() const    { return(8); }  
    BYTE*    GetCode() const        { return(((BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_TINY)); } 
    DWORD    GetLocalVarSigTok() const  { return(0); }  
    COR_ILMETHOD_SECT* GetSect() const { return(0); }   
#endif
    BYTE Flags_CodeSize;    
} COR_ILMETHOD_TINY;

/************************************/
// This strucuture is the 'fat' layout, where no compression is attempted. 
// Note that this structure can be added on at the end, thus making it extensible
typedef struct tagCOR_ILMETHOD_FAT
{
#if __IMAGE_COR_CPLUSPLUS__
    bool     IsFat() const              { return((Flags & CorILMethod_FormatMask) == CorILMethod_FatFormat); }  
    unsigned GetMaxStack() const        { return(MaxStack); }   
    unsigned GetCodeSize() const        { return(CodeSize); }   
    unsigned GetLocalVarSigTok() const      { return(LocalVarSigTok); } 
    BYTE*    GetCode() const            { return(((BYTE*) this) + 4*Size); }    
    const COR_ILMETHOD_SECT* GetSect() const {  
        if (!(Flags & CorILMethod_MoreSects)) return(0);    
        return(((COR_ILMETHOD_SECT*) (GetCode() + GetCodeSize()))->Align());    
        }   
#endif
    unsigned Flags    : 12;     // Flags    
    unsigned Size     :  4;     // size in DWords of this structure (currently 3)   
    unsigned MaxStack : 16;     // maximum number of items (I4, I, I8, obj ...), on the operand stack   
    DWORD   CodeSize;           // size of the code 
    DWORD   LocalVarSigTok;     // token that indicates the signature of the local vars (0 means none)  
} COR_ILMETHOD_FAT;

/************************************/
// exported functions (impl. Format\Format.cpp)
#ifdef __IMAGE_COR_CPLUSPLUS__
extern "C" {
#endif
unsigned __stdcall IlmethodSize(COR_ILMETHOD_FAT* header, BOOL MoreSections);    
        // emit the header (bestFormat) return amount emitted   
unsigned __stdcall IlmethodEmit(unsigned size, COR_ILMETHOD_FAT* header, 
                  BOOL moreSections, BYTE* outBuff);    
#ifdef __IMAGE_COR_CPLUSPLUS__
}

struct COR_ILMETHOD
{
        // a COR_ILMETHOD header should not be decoded by hand.  Instead us 
        // COR_ILMETHOD_DECODER to decode it.   
    friend class COR_ILMETHOD_DECODER;  

        // compute the size of the header (best format) 
    unsigned static Size(const COR_ILMETHOD_FAT* header, bool MoreSections)
    { return IlmethodSize((COR_ILMETHOD_FAT*)header,MoreSections); };
        // emit the header (bestFormat) return amount emitted   
    unsigned static Emit(unsigned size, const COR_ILMETHOD_FAT* header, 
                  bool moreSections, BYTE* outBuff)
    { return IlmethodEmit(size, (COR_ILMETHOD_FAT*)header, moreSections, outBuff); };

//private:
    union   
    {   
        COR_ILMETHOD_TINY       Tiny;   
        COR_ILMETHOD_FAT        Fat;    
    };  
        // Code follows the Header, then immedately after the code comes    
        // any sections (COR_ILMETHOD_SECT).    
};
#else
typedef union 
{
    COR_ILMETHOD_TINY       Tiny;   
    COR_ILMETHOD_FAT        Fat;    
} COR_ILMETHOD;
#endif

/***************************************************************************/
/* COR_ILMETHOD_DECODER is the only way functions internal to the EE should
   fetch data from a COR_ILMETHOD.  This way any dependancy on the file format
   (and the multiple ways of encoding the header) is centralized to the 
   COR_ILMETHOD_DECODER constructor) */
#ifdef __IMAGE_COR_CPLUSPLUS__
extern "C" {
#endif
    void __stdcall DecoderInit(void * pThis, COR_ILMETHOD* header);
    int  __stdcall DecoderGetOnDiskSize(void * pThis, COR_ILMETHOD* header);

#ifdef __IMAGE_COR_CPLUSPLUS__
}

class COR_ILMETHOD_DECODER : public COR_ILMETHOD_FAT  
{
public:
        // Decode the COR header into a more convinient internal form   
        // This is the ONLY way you should access COR_ILMETHOD so format changes are easier 
    COR_ILMETHOD_DECODER(const COR_ILMETHOD* header) { DecoderInit(this,(COR_ILMETHOD*)header); };   

        // The constructor above can not do a 'complete' job, because it    
        // can not look up the local variable signature meta-data token.    
        // This method should be used in s  
    COR_ILMETHOD_DECODER(COR_ILMETHOD* header, void *pInternalImport);  

    unsigned EHCount() const {  
        if (EH == 0) return(0); 
        else return(EH->EHCount()); 
        }   

    // returns total size of method for use in copying
    int GetOnDiskSize(const COR_ILMETHOD* header) { return DecoderGetOnDiskSize(this,(COR_ILMETHOD*)header); };

    // Flags        these are available because we inherit COR_ILMETHOD_FAT 
    // MaxStack 
    // CodeSize 
    const BYTE* Code;   
    PCCOR_SIGNATURE LocalVarSig;        // pointer to signature blob, or 0 if none  
    const COR_ILMETHOD_SECT_EH* EH;     // eh table if any  0 if none   
    const COR_ILMETHOD_SECT* Sect;      // additional sections  0 if none   
};
#else
typedef struct
{
    COR_ILMETHOD_FAT Fat;
    // Flags        these are available because we inherit COR_ILMETHOD_FAT 
    // MaxStack 
    // CodeSize 
    const BYTE* Code;   
    PCCOR_SIGNATURE LocalVarSig;        // pointer to signature blob, or 0 if none  
    const COR_ILMETHOD_SECT_EH* EH;     // eh table if any  0 if none   
//    const COR_ILMETHOD_SECT* Sect;      // additional sections  0 if none   
} COR_ILMETHOD_DECODER;
#endif
//#include <poppack.h>
//
// Native method descriptor.
//

typedef struct 
{
    DWORD       GCInfo; 
    DWORD       EHInfo; 
} COR_NATIVE_DESCRIPTOR;

//@Todo:  this structure is obsoleted by the pdata version right behind it.
// This needs to get deleted as soon as VC/COR are sync'd up.
typedef struct 
{
    ULONG MethodRVA;    
    ULONG MIHRVA;   
} COR_IPMAP_ENTRY;

typedef struct IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY 
{
    ULONG       BeginAddress;			// RVA of start of function
    ULONG       EndAddress;			    // RVA of end of function
    ULONG       MIH;				    // Associated MIH
} IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY;

#pragma warning(disable:4200) // nonstandard extension used : zero-sized array in struct/union.
typedef __int32 mdScope;                // Why is this still needed?
typedef __int32 mdToken;                // Generic token
typedef struct 
{
    ULONG   EHRVA;  
    ULONG   MethodRVA;  
    mdToken Token;  
    BYTE    Flags;  
    BYTE    CodeManager;    
    BYTE    MIHData[0]; 
} COR_MIH_ENTRY;

// #defines for the MIH FLAGS

#define COR_MIH_METHODRVA   0x01    
#define COR_MIH_EHRVA       0x02    

#define COR_MIH_BASICBLOCK  0x08    



//*****************************************************************************
// Non VOS v-table entries.  Define an array of these pointed to by 
// IMAGE_COR20_HEADER.VTableFixups.  Each entry describes a contiguous array of
// v-table slots.  The slots start out initialized to the meta data token value
// for the method they need to call.  At image load time, the COM+ Loader will
// turn each entry into a pointer to machine code for the CPU and can be
// called directly.
//*****************************************************************************

#define COR_VTABLE_32BIT    0x01        // V-table slots are 32-bits in size.   
#define COR_VTABLE_64BIT    0x02        // V-table slots are 64-bits in size.   
#define COR_VTABLE_FROM_UNMANAGED 0x04    // If set, transition from unmanaged.
#define COR_VTABLE_CALL_MOST_DERIVED 0x10 // Call most derived method described by

typedef struct _IMAGE_COR_VTABLEFIXUP
{
    ULONG       RVA;                    // Offset of v-table array in image.    
    USHORT      Count;                  // How many entries at location.    
    USHORT      Type;                   // COR_VTABLE_xxx type of entries.  
} IMAGE_COR_VTABLEFIXUP;





//*****************************************************************************
//*****************************************************************************
//
// M E T A - D A T A    D E C L A R A T I O N S 
//
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
//
// Enums for SetOption API.
//
//*****************************************************************************

// flags for MetaDataCheckDuplicatesFor
typedef enum 
{
	MDDupAll				= 0xffffffff,
	MDDupENC				= MDDupAll,
	MDNoDupChecks			= 0x00000000,
	MDDupTypeDef			= 0x00000001,
	MDDupInterfaceImpl		= 0x00000002,
	MDDupMethodDef			= 0x00000004,
	MDDupTypeRef			= 0x00000008,
	MDDupMemberRef			= 0x00000010,
	MDDupMethodImpl			= 0x00000020,
	MDDupCustomValue		= 0x00000040,
	MDDupCustomAttribute	= 0x00000040,	// Alias for custom value.
	MDDupParamDef			= 0x00000080,
	MDDupPermission			= 0x00000100,
	MDDupProperty			= 0x00000400,
	MDDupEvent				= 0x00000800,
	MDDupFieldDef			= 0x00001000,
	MDDupSignature			= 0x00002000,
	MDDupModuleRef			= 0x00004000,
	MDDupTypeSpec			= 0x00008000,
	MDDupImplMap			= 0x00010000,
	MDDupOrdinalMap			= 0x00020000,
	MDDupAssemblyRef		= 0x00040000,
	MDDupFile				= 0x00080000,
	MDDupComType			= 0x00100000,
	MDDupManifestResource	= 0x00200000,
    MDDupLocalizedResource  = 0x00400000,
    MDDupExecutionLocation  = 0x00800000,

    // @todo: These will go away once the MetaData debug tables are gone.
    MDDupSourceFile         = 0x01000000,
    MDDupBlock              = 0x02000000,
    MDDupLocalVarScope      = 0x04000000,
    MDDupLocalVar           = 0x08000000,

    // This is the default behavior on metadata. It will check duplicates for TypeRef, MemberRef, Signature, and TypeSpec
    MDDupDefault = MDNoDupChecks | MDDupTypeRef | MDDupMemberRef | MDDupSignature | MDDupTypeSpec,
} CorCheckDuplicatesFor;

// flags for MetaDataRefToDefCheck
typedef enum 
{
    // default behavior is to always perform TypeRef to TypeDef and MemberRef to MethodDef/FieldDef optimization
    MDRefToDefDefault       = 0x00000003,
    MDRefToDefAll           = 0xffffffff,
    MDRefToDefNone          = 0x00000000,
    MDTypeRefToDef          = 0x00000001,
    MDMemberRefToDef        = 0x00000002
} CorRefToDefCheck;


// MetaDataNotificationForTokenMovement
typedef enum 
{
    // default behavior is to notify TypeRef, MethodDef, MemberRef, and FieldDef token remaps
    MDNotifyDefault         = 0x0000000f,
    MDNotifyAll             = 0xffffffff,
    MDNotifyNone            = 0x00000000,
    MDNotifyMethodDef       = 0x00000001,
    MDNotifyMemberRef       = 0x00000002,
    MDNotifyFieldDef        = 0x00000004,
    MDNotifyTypeRef         = 0x00000008,

	MDNotifyTypeDef			= 0x00000010,
	MDNotifyParamDef		= 0x00000020,
	MDNotifyMethodImpl		= 0x00000040,
	MDNotifyInterfaceImpl	= 0x00000080,
	MDNotifyProperty		= 0x00000200,
	MDNotifyEvent			= 0x00000400,
	MDNotifySignature		= 0x00000800,
	MDNotifyTypeSpec		= 0x00001000,
	MDNotifyCustomValue		= 0x00002000,
	MDNotifyCustomAttribute	= 0x00002000,	// Alias for custom value
	MDNotifySecurityValue	= 0x00004000,
	MDNotifyPermission		= 0x00008000,
	MDNotifyModuleRef		= 0x00010000,
	
	MDNotifyNameSpace		= 0x00020000,
	MDNotifyDebugTokens		= 0x00800000,	// This covers all Debug tokens, bits are expensive :-)

    MDNotifyAssemblyRef     = 0x01000000,
    MDNotifyFile            = 0x02000000,
    MDNotifyComType         = 0x04000000,
    MDNotifyResource        = 0x08000000,
    MDNotifyExecutionLocation = 0x10000000,
} CorNotificationForTokenMovement;


typedef enum 
{
    MDSetENCOn              = 0x00000001,   // Deprecated name.
    MDSetENCOff             = 0x00000002,   // Deprecated name.

    MDUpdateENC             = 0x00000001,   // ENC mode.  Tokens don't move; can be updated.
    MDUpdateFull            = 0x00000002,   // "Normal" update mode.
    MDUpdateExtension       = 0x00000003,   // Extension mode.  Tokens don't move, adds only.
    MDUpdateIncremental     = 0x00000004,   // Incremental compilation
    MDUpdateMask            = 0x00000007,

    MDUpdateDelta           = 0x00000008,   // If ENC on, save only deltas.

} CorSetENC;


// flags used in SetOption when pair with MetaDataErrorIfEmitOutOfOrder guid
typedef enum 
{
    MDErrorOutOfOrderDefault = 0x00000000,  // default not to generate any error
    MDErrorOutOfOrderNone   = 0x00000000,   // do not generate error for out of order emit
    MDErrorOutOfOrderAll    = 0xffffffff,   // generate out of order emit for method, field, param, property, and event
    MDMethodOutOfOrder      = 0x00000001,   // generate error when methods are emitted out of order
    MDFieldOutOfOrder       = 0x00000002,   // generate error when fields are emitted out of order
    MDParamOutOfOrder       = 0x00000004,   // generate error when params are emitted out of order
    MDPropertyOutOfOrder    = 0x00000008,   // generate error when properties are emitted out of order
    MDEventOutOfOrder       = 0x00000010,   // generate error when events are emitted out of order
} CorErrorIfEmitOutOfOrder;


// flags used in SetOption when pair with MetaDataImportOption guid
typedef enum
{
    MDImportOptionDefault       = 0x00000000,   // default to skip over deleted records
    MDImportOptionAll           = 0xFFFFFFFF,   // Enumerate everything
    MDImportOptionAllTypeDefs   = 0x00000001,   // all of the typedefs including the deleted typedef
    MDImportOptionAllMethodDefs = 0x00000002,   // all of the methoddefs including the deleted ones
    MDImportOptionAllFieldDefs  = 0x00000004,   // all of the fielddefs including the deleted ones
    MDImportOptionAllProperties = 0x00000008,   // all of the properties including the deleted ones
    MDImportOptionAllEvents     = 0x00000010,   // all of the events including the deleted ones
    MDImportOptionAllCustomValues = 0x00000020, // all of the customvalues including the deleted ones
    MDImportOptionAllCustomAttributes = 0x00000020, // all of the customvalues including the deleted ones
    MDImportOptionAllComTypes   = 0x00000040,   // all of the ComTypes including the deleted ones

} CorImportOptions;

// Token  definitions


typedef __int32 mdModule;               // Module token (roughly, a scope)
typedef __int32 mdTypeRef;              // TypeRef reference (this or other scope)
typedef __int32 mdTypeDef;              // TypeDef in this scope
typedef __int32 mdFieldDef;             // Field in this scope  
typedef __int32 mdMethodDef;            // Method in this scope 
typedef __int32 mdParamDef;             // param token  
typedef __int32 mdInterfaceImpl;        // interface implementation token

typedef __int32 mdMemberRef;            // MemberRef (this or other scope)  
typedef __int32 mdCustomAttribute;		// attribute token
typedef mdCustomAttribute mdCustomValue;// attribute token
typedef __int32 mdPermission;           // DeclSecurity 

typedef __int32 mdSignature;            // Signature object 
typedef __int32 mdEvent;                // event token  
typedef __int32 mdProperty;             // property token   
typedef __int32 mdMethodImpl;           // member implementation token  

typedef __int32 mdModuleRef;            // Module reference (for the imported modules)  

// Assembly tokens.
typedef __int32 mdAssembly;             // Assembly token.
typedef __int32 mdAssemblyRef;          // AssemblyRef token.
typedef __int32 mdFile;                 // File token.
typedef __int32 mdComType;              // ComType token.
typedef __int32 mdManifestResource;     // ManifestResource token.
typedef __int32 mdLocalizedResource;    // LocalizedManifestResource token.
typedef __int32 mdExecutionLocation;    // Execution location token.

typedef __int32 mdTypeSpec;             // TypeSpec object 

// Debugger support tokens - deprecated.
typedef __int32 mdSourceFile;           // source file token    
typedef __int32 mdLocalVarScope;        // local variable scope token   
typedef __int32 mdLocalVar;             // local variable token 

// Application string.
typedef __int32 mdString;               // User literal string token.

typedef __int32 mdCPToken;              // constantpool token   

typedef unsigned long RID;


// 
// struct used to retrieve field offset
// used by GetClassLayout and SetClassLayout
//
typedef struct 
{
    mdFieldDef  ridOfField; 
    ULONG       ulOffset;   
} COR_FIELD_OFFSET;

typedef struct 
{
    ULONG ulRVA;    
    ULONG Count;    
} IMAGE_COR_FIXUPENTRY;


//
// Token tags.
//
typedef enum 
{
	mdtModule				= 0x00000000,		// 			
	mdtTypeRef				= 0x01000000,		// 			
	mdtTypeDef				= 0x02000000,		// 			
	mdtFieldDef 			= 0x04000000,		// 			 
	mdtMethodDef			= 0x06000000,		// 		 
	mdtParamDef 			= 0x08000000,		// 			 
	mdtInterfaceImpl		= 0x09000000,		// 	
	mdtMemberRef			= 0x0a000000,		// 		 
	mdtCustomAttribute		= 0x0c000000,		// 		
	mdtCustomValue			= mdtCustomAttribute,		// 		
	mdtPermission			= 0x0e000000,		// 		 
	mdtSignature			= 0x11000000,		// 		 
	mdtEvent				= 0x14000000,		// 			 
	mdtProperty 			= 0x17000000,		// 			 
	mdtMethodImpl			= 0x19000000,		// 		 
	mdtModuleRef			= 0x1a000000,		// 		 
	mdtTypeSpec 			= 0x1b000000,		// 			 
	mdtAssembly				= 0x21000000,		//
	mdtAssemblyRef			= 0x25000000,		//
	mdtFile					= 0x29000000,		//
	mdtComType				= 0x2a000000,		//
	mdtManifestResource		= 0x2b000000,		//
    mdtLocalizedResource    = 0x2c000000,
	mdtExecutionLocation	= 0x2d000000,		//

	mdtSourceFile			= 0x2e000000,		// 		 
	mdtLocalVarScope		= 0x30000000,		// 	 
	mdtLocalVar 			= 0x31000000,		// 			 

    mdtString               = 0x70000000,       //          
    mdtName                 = 0x71000000,       //
} CorTokenType, CorRegTokenType;

//
// Build / decompose tokens.
//
#define RidToToken(rid,tktype) ((rid) |= (tktype))
#define TokenFromRid(rid,tktype) ((rid) | (tktype))
#define RidFromToken(tk) ((RID) ((tk) & 0x00ffffff))
#define TypeFromToken(tk) ((tk) & 0xff000000)
#define IsNilToken(tk) ((RidFromToken(tk)) == 0)

//
// Nil tokens
//
#define mdTokenNil					((mdToken)0)
#define mdModuleNil					((mdModule)mdtModule)				
#define mdTypeRefNil				((mdTypeRef)mdtTypeRef)				
#define mdTypeDefNil				((mdTypeDef)mdtTypeDef)				
#define mdFieldDefNil				((mdFieldDef)mdtFieldDef) 			
#define mdMethodDefNil				((mdMethodDef)mdtMethodDef)			
#define mdParamDefNil				((mdParamDef)mdtParamDef) 			
#define mdInterfaceImplNil			((mdInterfaceImpl)mdtInterfaceImpl)		
#define mdMemberRefNil				((mdMemberRef)mdtMemberRef)			
#define mdCustomAttributeNil		((mdCustomValue)mdtCustomAttribute)			
#define mdCustomValueNil			((mdCustomAttribute)mdtCustomAttribute)			
#define mdPermissionNil				((mdPermission)mdtPermission)			
#define mdSignatureNil				((mdSignature)mdtSignature)			
#define mdEventNil					((mdEvent)mdtEvent)				
#define mdPropertyNil				((mdProperty)mdtProperty) 			
#define mdMethodImplNil				((mdMethodImpl)mdtMethodImpl)			
#define mdModuleRefNil				((mdModuleRef)mdtModuleRef)			
#define mdTypeSpecNil				((mdTypeSpec)mdtTypeSpec) 			
#define mdAssemblyNil				((mdAssembly)mdtAssembly)
#define mdAssemblyRefNil			((mdAssemblyRef)mdtAssemblyRef)
#define mdFileNil					((mdFile)mdtFile)
#define mdComTypeNil				((mdComType)mdtComType)
#define mdManifestResourceNil		((mdManifestResource)mdtManifestResource)
#define mdLocalizedResourceNil      ((mdLocalizedResourceNil)mdtLocalizedResourceNil)
#define mdExecutionLocationNil      ((mdExecutionLocation)mdtExecutionLocation)

#define mdSourceFileNil             ((mdSourceFile)mdtSourceFile)           
#define mdLocalVarScopeNil          ((mdLocalVarScope)mdtLocalVarScope)     
#define mdLocalVarNil               ((mdLocalVar)mdtLocalVar)           

#define mdStringNil                 ((mdString)mdtString)               

//
// Open bits.
//
typedef enum 
{
    ofRead      =   0x00000000,     // Open scope for read
    ofWrite     =   0x00000001,     // Open scope for write.
} CorOpenFlags;

typedef CorTypeAttr CorRegTypeAttr;

//
// Opaque type for an enumeration handle.
//
typedef void *HCORENUM;

//
// Some well-known custom attributes 
//
#define INTEROP_DISPID_TYPE_W				L"System/Interop/Attributes/DispId"
#define INTEROP_DISPID_METHOD_W				COR_CTOR_METHOD_NAME_W
#define INTEROP_DISPID_TYPE					"System/Interop/Attributes/DispId"
#define INTEROP_DISPID_METHOD				COR_CTOR_METHOD_NAME
#define INTEROP_DISPID_SIG					{IMAGE_CEE_CS_CALLCONV_DEFAULT, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_COMIFACETYPE_TYPE_W			L"System/Interop/Attributes/ComInterfaceType"
#define INTEROP_COMIFACETYPE_METHOD_W		COR_CTOR_METHOD_NAME_W
#define INTEROP_COMIFACETYPE_TYPE			"System/Interop/Attributes/ComInterfaceType"
#define INTEROP_COMIFACETYPE_METHOD			COR_CTOR_METHOD_NAME
#define INTEROP_COMIFACETYPE_SIG			{IMAGE_CEE_CS_CALLCONV_DEFAULT, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_IMPORTEDFROMCOM_TYPE_W		L"System/Interop/Attributes/ImportedFromCom"
#define INTEROP_IMPORTEDFROMCOM_METHOD_W	COR_CTOR_METHOD_NAME_W
#define INTEROP_IMPORTEDFROMCOM_TYPE		"System/Interop/Attributes/ImportedFromCom"
#define INTEROP_IMPORTEDFROMCOM_METHOD		COR_CTOR_METHOD_NAME
#define INTEROP_IMPORTEDFROMCOM_SIG			{IMAGE_CEE_CS_CALLCONV_DEFAULT, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_HASDEFAULTIFACE_TYPE_W		L"System/Interop/Attributes/HasDefaultInterface"
#define INTEROP_HASDEFAULTIFACE_METHOD_W	COR_CTOR_METHOD_NAME_W
#define INTEROP_HASDEFAULTIFACE_TYPE		"System/Interop/Attributes/HasDefaultInterface"
#define INTEROP_HASDEFAULTIFACE_METHOD		COR_CTOR_METHOD_NAME
#define INTEROP_HASDEFAULTIFACE_SIG			{IMAGE_CEE_CS_CALLCONV_DEFAULT, 0, ELEMENT_TYPE_VOID}

#define INTEROP_ISNOTVISIBLEFROMCOM_TYPE_W		L"System/Interop/Attributes/IsNotVisibleFromCom"
#define INTEROP_ISNOTVISIBLEFROMCOM_METHOD_W	COR_CTOR_METHOD_NAME_W
#define INTEROP_ISNOTVISIBLEFROMCOM_TYPE		"System/Interop/Attributes/IsNotVisibleFromCom"
#define INTEROP_ISNOTVISIBLEFROMCOM_METHOD		COR_CTOR_METHOD_NAME
#define INTEROP_ISNOTVISIBLEFROMCOM_SIG			{IMAGE_CEE_CS_CALLCONV_DEFAULT, 0, ELEMENT_TYPE_VOID}

#define INTEROP_ISCOMREGISTERFUNCTION_TYPE_W	L"System/Interop/Attributes/IsComRegisterFunction"
#define INTEROP_ISCOMREGISTERFUNCTION_METHOD_W	COR_CTOR_METHOD_NAME_W
#define INTEROP_ISCOMREGISTERFUNCTION_TYPE		"System/Interop/Attributes/IsComRegisterFunction"
#define INTEROP_ISCOMREGISTERFUNCTION_METHOD	COR_CTOR_METHOD_NAME
#define INTEROP_ISCOMREGISTERFUNCTION_SIG		{IMAGE_CEE_CS_CALLCONV_DEFAULT, 0, ELEMENT_TYPE_VOID}

//
// GetSaveSize accuracy
//
#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
typedef enum 
{
    cssAccurate = 0x0000,           // Find exact save size, accurate but slower.
    cssQuick = 0x0001               // Estimate save size, may pad estimate, but faster.
} CorSaveSize;
#endif
#define     MAX_CLASS_NAME      255
#define     MAX_PACKAGE_NAME    255

typedef unsigned __int64 CLASSVERSION;

#define COR_IS_METHOD_MANAGED_IL(flags)         ((flags & 0xf) == (miIL | miManaged))   
#define COR_IS_METHOD_MANAGED_OPTIL(flags)      ((flags & 0xf) == (miOPTIL | miManaged))    
#define COR_IS_METHOD_MANAGED_NATIVE(flags)     ((flags & 0xf) == (miNative | miManaged))   
#define COR_IS_METHOD_UNMANAGED_NATIVE(flags)   ((flags & 0xf) == (miNative | miUnmanaged)) 
#define COR_IS_METHOD_IAT(flags)                (flags & miIAT) 


//
// Opaque types for security properties and values.
//
typedef void  *  PSECURITY_PROPS ;
typedef void  *  PSECURITY_VALUE ;
typedef void ** PPSECURITY_PROPS ;
typedef void ** PPSECURITY_VALUE ;


#endif // __CORHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\csecutil.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------------
// File: csecutil.h
//
// Contents : Declaration of the following security utility classes
//
//		CSecDesc - manage NT security descriptors (& ACLs)
//		CToken   - manage NT security tokens
//		CSid	 - manage NT security identifiers (SIDs)
//
// @doc
//

#ifndef __CSECUTIL_H_
#define __CSECUTIL_H_

#include <winnt.h>
#include <lmcons.h>
#include <svcmem.h>

//---------------------------------------------------------------------------
// @class  Wrapper for NT security descriptors. This class makes it easier
// to create and manipulate NT security descriptors. SD's can be created from
// scratch or initialized from 1) an existing SD, 2) the SD for a given
// kernel object, 3) the process token, or 4) the thread token.
//
class CSecDesc
{
public:		// @access Constructors and initialization methods

	// @cmember Default constructor
	CSecDesc();

	// @cmember Destructor
	~CSecDesc();

	// @cmember Attach to a security descriptor
	HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);

	// @cmember Attach to an object's security descriptor
	HRESULT AttachObject(HANDLE hObject);

	// @cmember Initialize all member data
	HRESULT Initialize();

	// @cmember Initialize from the process token
	HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);

	// @cmember Initialize from the current thread token
	HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);

public:		// @access Conversions

	// @cmember Cast to PSECURITY_DESCRIPTOR
	operator PSECURITY_DESCRIPTOR()
	{
		return m_pSD;
	}

public:		// @access Misc. class manipulation methods

	// @cmember Set the owner SID
	HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);

	// @cmember Set the group SID
	HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);

	// @cmember Add an "access allowed" ACE for a given name
	HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD dwAceFlags = 0);

	// @cmember Add an "access denied" ACE for a given name
	HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD dwAceFlags = 0);

	// @cmember Add an "access allowed" ACE for a given SID
	HRESULT Allow(PSID psidPrincipal, DWORD dwAccessMask, DWORD dwAceFlags = 0);

	// @cmember Add an "access denied" ACE for a given SID
	HRESULT Deny(PSID psidPrincipal, DWORD dwAccessMask, DWORD dwAceFlags = 0);

	// @cmember Remove the ACE for a given name
	HRESULT Revoke(LPCTSTR pszPrincipal);

	// @cmember Remove the ACE for a given SID
	HRESULT Revoke(PSID psidPrincipal);

	// @cmember Set the control bits on the SD (wraps SetSecurityDescriptorControl)
	HRESULT SetControl(SECURITY_DESCRIPTOR_CONTROL sdcMask, SECURITY_DESCRIPTOR_CONTROL sdcValue);

public:		// @access Utility functions

	// @cmember Return the user & group SIDs from a given token
	static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);

	// @cmember Return the user & group SIDs from the process token
	static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);

	// @cmember Return the user & group SIDs from the thread token
	static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);

	// @cmember Copy an ACL
	static HRESULT CopyACL(PACL pDest, PACL pSrc);

	// @cmember Get the user SID for the current process
	static HRESULT GetCurrentUserSID(PSID *ppSid);

	// @cmember Return the SID for a given principal (LookupAccountName)
	static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);

	// @cmember Add an access-allowed ACE to an ACL (given an account name)
	static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD dwAceFlags = 0);

	// @cmember Add an access-denied ACE to an ACL (given an account name)
	static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask, DWORD dwAceFlags = 0);

	// @cmember Remove a principal from an ACL
	static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

	// @cmember Add an access-allowed ACE to an ACL (given a PSID)
	static HRESULT AddAccessAllowedACEToACL(PACL *Acl, PSID psidPrincipal, DWORD dwAccessMask, DWORD dwAceFlags = 0);

	// @cmember Add an access-denied ACE to an ACL (given a PSID)
	static HRESULT AddAccessDeniedACEToACL(PACL *Acl, PSID psidPrincipal, DWORD dwAccessMask, DWORD dwAceFlags = 0);

	// @cmember Remove a given PSID from an ACL
	static HRESULT RemovePrincipalFromACL(PACL Acl, PSID psidPrincipal);

public:		// @access Public member variables

	// @cmember The wrapped security descriptor
	PSECURITY_DESCRIPTOR m_pSD;

	// @cmember The owner SID
	PSID m_pOwner;

	// @cmember The group SID
	PSID m_pGroup;

	// @cmember The discretionary access control list (DACL)
	PACL m_pDACL;

	// @cmember The system access control list (SACL)
	PACL m_pSACL;
};

//---------------------------------------------------------------------------
// @class  Wrapper for NT security tokens. This class makes it easier to
// extract information from an NT security token. CToken objects can be
// initialized from 1) an existing token, 2) the process token, 3) the
// current thread token, or 4) a token representing the current COM client.
//
class CToken
{
public:		// @access Public constructors and initialization methods

	// @cmember Default constructor
	CToken();

	// @cmember Destructor
	~CToken();

	// @cmember Associate a CToken with an existing token handle
	void Attach(HANDLE hToken);

	// @cmember Detach from the currently-wrapped token handle
	HANDLE  Detach();

	// @cmember Initialize using the process token.
	HRESULT InitializeFromProcess();

	// @cmember Initialize using the current thread token
	HRESULT InitializeFromThread(BOOL fOpenAsSelf = FALSE);

	// @cmember Initialize using the current COM client's token (if any)
	HRESULT InitializeFromComClient();

	// @cmember Retrieve the user and primary group SIDs from the token
	HRESULT GetSids(PSID *ppUserSid, PSID *ppGroupSid);

	// @cmember Test the token for membership in the given group.
	HRESULT IsMemberOfGroup(const PSID psidGroup, BOOL *pfIsMember);

	// @cmember Add/remove a given privilege on the token
	HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE);

private:	// @access Private helpers

	// @cmember Initialize all member variables.
	void Initialize();

private:	// @access Private member variables

	// @cmember Handle for the token that we wrap.
	HANDLE			m_hToken;

	enum {
		fGotTokenGroups		= 0x1,
		fTokenAttached		= 0x2
	};

	// @cmember Flags for tracking class state.
	DWORD			m_dwFlags;

	// information extracted from the token

	// @cmember Ptr to the TOKEN_GROUPS structure obtained from the token.
	TOKEN_GROUPS	*m_pTokenGroups;
};



// @const The maximum size of a SID - leaves room for 8 sub-authorities
const DWORD x_cbMaxSidSize = 44;

//---------------------------------------------------------------------------
// @class  Wrapper for NT security identifiers (SIDs). This class simplifies
// the task of manipulating SIDs or converting between principal names and
// SIDs. The class also provides static constants representing several of the
// most common well-known NT SIDs. These can be helpful in constructing
// security descriptors.
//
class CSid
{
public:		// @access Construction and Initialization

	// @cmember Default constructor
	CSid();

	// @cmember Constructor wraps an existing PSID (same as Attach)
	CSid(PSID pSid);

	// @cmember Destructor
	~CSid();

	// @cmember Initialize using the given name (calls LookupAccountName)
	HRESULT InitializeFromName(LPWSTR pwszName);

	// @cmember Wraps the given PSID (doesn't copy the SID)
	void Attach(PSID pSid);

	// @cmember Detaches from the wrapped SID
	PSID Detach();

	// @cmember Cast to a PSID
	operator PSID() const
	{
		return m_psid;
	}

public:		// @access Overloaded operators

	// @cmember equality operator (CSid)
	BOOL operator==(const CSid& csid) const;

	// @cmember equality operator (PSID)
	BOOL operator==(const PSID pSid) const;

	// @cmember inequality operator (CSid)
	BOOL operator!=(const CSid& csid) const;

	// @cmember inequality operator (PSID)
	BOOL operator!=(const PSID pSid) const;

	// @cmember Assignment operator from CSid (copies the SID)
	CSid& operator=(const CSid& src);

	// @cmember Assignment operator from PSID (copies the SID)
	CSid& operator=(const PSID pSid);

public:		// @access Simple derived properties

	// @cmember Return the length of the SID
	DWORD GetLength() const;

	// @cmember Return the number of sub-authorities
	DWORD GetSubAuthorityCount() const;

	// @cmember Return a specific sub-authority
	DWORD GetSubAuthority(DWORD iSubAuthority) const;

	// @cmember Test the validity of the wrapped SID
	BOOL IsValid() const;

	// @cmember Return the account name of the SID
	HRESULT	GetName(LPWSTR *ppwszName);

	// @cmember Return the domain name of the SID
	HRESULT GetDomain(LPWSTR *ppwszDomain);

	// @cmember Return the account type represented by the SID
	HRESULT GetAccountType(PSID_NAME_USE psnu);

private:	// @access Private helper methods

	// @cmember Re-initialize the member variables
	void	Initialize();

	// @cmember Call LookupAccountSid - caches information returned
	// by GetName, GetDomain, and GetAccountType
	HRESULT	DoLookupAccountSid();

private:	// @access Private member variables

	// @cmember The PSID that we wrap. We may or may not own this space.
	PSID			m_psid;

	// Flags for m_dwFlags
	enum {
		fSidAttached	= 0x1,	// SID was attached, we don't own its memory
		fGotAccountName	= 0x2	// flag is set if we called LookupAccountSid
	};

	// @cmember Flags to maintain class state information
	DWORD			m_dwFlags;

	// Information derived from the SID

	// @cmember The account name associated with this SID
	WCHAR			m_szName[UNLEN+1];

	// @cmember The domain name associated with this SID
	WCHAR			m_szDomain[DNLEN+1];

	// @cmember The account type for this SID
	SID_NAME_USE	m_SidNameUse;

private:

	// Private typedefs for SIDs with 1 or 2 subauthorities so we can
	// define constant SIDs of either kind.

	typedef struct _SID1 {
		BYTE  Revision;
		BYTE  SubAuthorityCount;
		SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
		DWORD SubAuthority[1];
	} SID1;

	typedef struct _SID2 {
		BYTE  Revision;
		BYTE  SubAuthorityCount;
		SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
		DWORD SubAuthority[2];
	} SID2;

	// Universal well-known SIDs
	static const SID1 x_sidEveryone;

	// NT well-known SIDs
	static const SID1 x_sidDialup;
	static const SID1 x_sidNetwork;
	static const SID1 x_sidBatch;
	static const SID1 x_sidInteractive;
	static const SID1 x_sidService;
	static const SID1 x_sidAuthenticated;
	static const SID1 x_sidSystem;

	// Well-known domain users
	static const SID2 x_sidAdministrator;

	// Local groups (aliases)
	static const SID2 x_sidLocalAdministrators;
	static const SID2 x_sidLocalUsers;
	static const SID2 x_sidLocalGuests;
	static const SID2 x_sidPowerUsers;

public:		// @access Well-known PSID constants

	// Universal well-known SIDs

	// @cmember PSID constant representing "Everyone"
	static const PSID x_psidEveryone;

	// NT well-known SIDs

	// @cmember PSID constant representing "DIALUP"
	static const PSID x_psidDialup;
	// @cmember PSID constant representing "NETWORK"
	static const PSID x_psidNetwork;
	// @cmember PSID constant representing "BATCH"
	static const PSID x_psidBatch;
	// @cmember PSID constant representing "INTERACTIVE USER"
	static const PSID x_psidInteractive;
	// @cmember PSID constant representing "SERVICE"
	static const PSID x_psidService;
	// @cmember PSID constant representing "AUTHENTICATED USER"
	static const PSID x_psidAuthenticated;
	// @cmember PSID constant representing "SYSTEM"
	static const PSID x_psidSystem;

	// Well-known domain users

	// @cmember PSID constant representing the local administrator
	static const PSID x_psidAdministrator;

	// Local groups (aliases)

	// @cmember PSID constant representing the local "Administrators" group
	static const PSID x_psidLocalAdministrators;
	// @cmember PSID constant representing the local "Users" group
	static const PSID x_psidLocalUsers;
	// @cmember PSID constant representing the local "Guests" group
	static const PSID x_psidLocalGuests;
	// @cmember PSID constant representing the local "Power Users" group
	static const PSID x_psidPowerUsers;
};

#endif // __CSECUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\debug.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// Debug.h -- COM+ Debugging Flags
//
// COM+ 1.0
//
// Jim Lyon, March 1998
//  

/*

Debugging Flags

Class DebugFlags contains a bunch of static methods that return information
about the settings of various debugging switches. These flags are initialized
from the registry at process startup time.

All flags are stored in the registry under key HKLM/Software/Microsoft/COM3/Debug

*/

#ifndef __DEBUG_H__
#define __DEBUG_H__

class DebugFlags
{
	// Public Static Methods
public:
	static BOOL AutoAddTraceToContext()		{ return sm_fAutoAddTraceToContext; }
	static BOOL DebugBreakOnFailFast()		{ return sm_fDebugBreakOnFailFast; }
	static BOOL DebugBreakOnInitComPlus()	{ return sm_fDebugBreakOnInitComPlus;}
	static BOOL DebugBreakOnLoadComsvcs()	{ return sm_fDebugBreakOnLoadComsvcs; }
    static BOOL TraceActivityModule()       { return sm_fTraceActivityModule; }
    static BOOL TraceContextCreation()      { return sm_fTraceContextCreation; }
	static BOOL TraceInfrastructureCalls()	{ return sm_fTraceInfrastructureCalls; }
    static BOOL TraceSTAPool()              { return sm_fTraceSTAPool; }
    static BOOL TraceSecurity()             { return sm_fTraceSecurity; }
	static BOOL TraceSecurityPM()           { return sm_fTraceSecurityPM; }
	static DWORD EventDispatchTime ()		{ return sm_dwEventDispatchTime; }

	// Private goo
private:

	// The data which is returned by the above
	static BOOL		sm_fAutoAddTraceToContext;
	static BOOL		sm_fDebugBreakOnFailFast;
	static BOOL		sm_fDebugBreakOnInitComPlus;
	static BOOL		sm_fDebugBreakOnLoadComsvcs;
    static BOOL     sm_fTraceActivityModule;
    static BOOL     sm_fTraceContextCreation;
	static BOOL		sm_fTraceInfrastructureCalls;
    static BOOL     sm_fTraceSTAPool;
    static BOOL     sm_fTraceSecurity;
	static BOOL     sm_fTraceSecurityPM;
	static DWORD    sm_dwEventDispatchTime;

	static DebugFlags sm_singleton;	// the only instance of this class, causes initialization

	DebugFlags();		// private constructor, causes initialization

	static void InitBoolean (HKEY hKey, const WCHAR* wszValueName, BOOL* pf);
	static void InitDWORD (HKEY hKey, const WCHAR* wszValueName, DWORD* pdw);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\dbtrace.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
//
// Microsoft Viper 96 (Microsoft Confidential)
//
// Project:		DBTrace
// Module:		DBTrace.H
// Description:	Trace macros
// Author:		wilfr
// Create:		03/25/96
//-----------------------------------------------------------------------------
// Notes:
//
//	Use the trace macro for debug builds.  Output can be captured using the
//	debugger, DBMON, or the DBWin32 tool checked in under $\viper\tools\bin\dbwin32.exe
//
//-----------------------------------------------------------------------------
// Issues:
//
//	none
//
//-----------------------------------------------------------------------------
// Architecture:
//
//	none	
//
//
//***********************************************************************************

#ifndef _DBTRACE_H_
#define _DBTRACE_H_

// Global includes

// Local includes

// Local preprocessor constructs

#ifdef _DEBUG

#	ifdef __cplusplus
	extern "C"
#	endif
	void   DebugTrace( TCHAR* tsz, ... );

//
// DEBUGTRACEn MACROS --
//
// you can use this macro if you promise to pass the string using TEXT(), or
#	define DEBUGTRACE								DebugTrace

// use these macros.....
#	define DEBUGTRACE0(msg)												DebugTrace( TEXT(msg) )
#	define DEBUGTRACE1(msg,parm)										DebugTrace( TEXT(msg), parm )
#	define DEBUGTRACE2(msg,parm,parm2)									DebugTrace( TEXT(msg), parm, parm2 )
#	define DEBUGTRACE3(msg,parm,parm2,parm3)							DebugTrace( TEXT(msg), parm, parm2, parm3 )
#	define DEBUGTRACE4(msg,parm,parm2,parm3,parm4)						DebugTrace( TEXT(msg), parm, parm2, parm3, parm4 )
#	define DEBUGTRACE5(msg,parm,parm2,parm3,parm4,parm5)				DebugTrace( TEXT(msg), parm, parm2, parm3, parm4, parm5 )
#	define DEBUGTRACE6(msg,parm,parm2,parm3,parm4,parm5,parm6)			DebugTrace( TEXT(msg), parm, parm2, parm3, parm4, parm5, parm6 )
#	define DEBUGTRACE7(msg,parm,parm2,parm3,parm4,parm5,parm6,parm7)	DebugTrace( TEXT(msg), parm, parm2, parm3, parm4, parm5, parm6, parm7 )

#else	_NDEBUG

#	define DEBUGTRACE
#	define DEBUGTRACE0(msg)
#	define DEBUGTRACE1(msg,parm)
#	define DEBUGTRACE2(msg,parm,parm2)
#	define DEBUGTRACE3(msg,parm,parm2,parm3)
#	define DEBUGTRACE4(msg,parm,parm2,parm3,parm4)
#	define DEBUGTRACE5(msg,parm,parm2,parm3,parm4,parm5)
#	define DEBUGTRACE6(msg,parm,parm2,parm3,parm4,parm5,parm6)
#	define DEBUGTRACE7(msg,parm,parm2,parm3,parm4,parm5,parm6,parm7)

#endif

// Local type definitions

#endif _DBTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\dtc.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
Microsoft	D.T.C (Distributed Transaction Coordinator)

(c)	1995	Microsoft Corporation.	All Rights Reserved

@doc

@module		DTC.H	|

			This is the entire project wide header file that should contain all 
			the project wide constants, common stuff etc.

@devnotes	Currently it only contains the implementation of the Name Service.
			Dependency: Requires CString definition

@rev	1	|	19-Jan-1996	|	GaganC	|	Added RuntimeBreak
@rev	0	|	11-Feb-1995	|	GaganC	|	Created
----------------------------------------------------------------------------- */
#ifndef __DTC_H__
#define __DTC_H__

#ifdef INITGUID
	const unsigned char * pszNULL_GUID	= (const unsigned char *)
										"00000000-0000-0000-0000-000000000000";
	const WCHAR * pwszNULL_GUID	= L"00000000-0000-0000-0000-000000000000";
#else
	extern const unsigned char * pszNULL_GUID;
	extern const WCHAR * pwszNULL_GUID;
#endif

typedef	unsigned long		COM_PROTOCOL;

//***** CONSTANTS
const	COM_PROTOCOL	PROT_IP_TCP		=		0x00000001;
const	COM_PROTOCOL	PROT_SPX		=		0x00000002;
const	COM_PROTOCOL	PROT_NET_BEUI	=		0x00000004;
const	COM_PROTOCOL	PROT_IP_UDP		=		0x00000008;
const	COM_PROTOCOL	PROT_DEC_NET	=		0x00000010;
const	COM_PROTOCOL	PROT_LRPC		=		0x00000020;
const	COM_PROTOCOL	PROT_NAMED_PIPE	=		0x00000040;
const	COM_PROTOCOL	PROT_IPX		=		0x00000080;

const	DWORD	DEFAULT_DTC_MAX_SESSIONS	=	0x00000020; // 32 sessions

const	char	EVENT_ADVERTISE_MSDTC_IS_UP_TS[]		= "Global\\MSDTC_NAMED_EVENT";
const	char	EVENT_ADVERTISE_MSDTC_IS_STARTING_TS[]	= "Global\\EVENT_MSDTC_STARTING";

#define REG_CLIENT_PROTOCOL_A	"ClientNetworkProtocol"
#define REG_CLIENT_PROTOCOL_W	L"ClientNetworkProtocol"

#ifndef UNICODE 
#define	REG_CLIENT_PROTOCOL			REG_CLIENT_PROTOCOL_A
#else
#define	REG_CLIENT_PROTOCOL			REG_CLIENT_PROTOCOL_W
#endif 



BOOL IsProductSuiteInstalledA (LPSTR lpszSuiteName);

// Returns true if terminal server is installed, false otherwise.
// Note: doesnt say much about Terminal server running.
inline BOOL IsTerminalServerPresent()
{
	return IsProductSuiteInstalledA ("Terminal Server");
}

// Given a global named object of the format "Global\\xxxxx"
// this function will return "Global\\xxxxxx" on Terminal Server
// an return "xxxxxx" on non terminal server platforms.  Note:
// the return pointer is just a pointer into the original string
inline char * GetTSAwareGlobalNamedObject (const char * i_pszNamedObject)
{
	if (!IsTerminalServerPresent ())
	{
		return (char*)(i_pszNamedObject+7);
	}
	return (char*)i_pszNamedObject;
}

inline LONG DtcRegCloseKeyIfNotPredefined (HKEY hKeyToClose)
{
	if ((hKeyToClose != HKEY_LOCAL_MACHINE) && 
		(hKeyToClose != HKEY_CLASSES_ROOT) && 
		(hKeyToClose != HKEY_CURRENT_USER) && 
		(hKeyToClose != HKEY_USERS) && 
		(hKeyToClose != HKEY_PERFORMANCE_DATA) && 
		(hKeyToClose != HKEY_DYN_DATA) && 
		(hKeyToClose != HKEY_CURRENT_CONFIG))
	{
		return RegCloseKey (hKeyToClose);
	}
	
	return ERROR_SUCCESS;
}

//*****	Byte Alignement constant ********
//  All the structures are aligned at the following boundary
//  INVARIENT :: For every BYTE_ALIGNEMENT, there exists an x such that
//  (BYTE_ALIGNMENT == 2 ^ x)
const	unsigned long		BYTE_ALIGNMENT				=		8;

//***** InProc Constants
const	DWORD		DTC_INPROC_NO						= 0;
const	DWORD		DTC_INPROC_WITH_FIRST_CALLER		= 1;
const	DWORD		DTC_INPROC_WITH_CALLER_TYPE			= 2;
const	DWORD		DTC_INPROC_WITH_SPECIFIED_CALLER	= 3;


//--------------------------------------
//	Inline functions and prototypes
//--------------------------------------
inline void RuntimeBreak (void)
{
	#ifdef RUNTIMEBREAK
		DebugBreak();
	#endif //RUNTIMEBREAK
}

// This function works as follows
// 1. given the size to be aligned (x) - raise the value of by at most the alignment
//		boundary - 1. This will bump the number to greater than what the aligned size
//		needs to be but less than ALIGN (x,y) + y
// 2. next strip off the extra bits by anding with 1's complement of the alignment
//		so that the number is aligned
#define ALIGN(x,y) ( ( (x) + ( (y) - 1 ) ) & ~( (y) - 1 ) )

inline unsigned int ALIGNED_SPACE (int x)
{
	unsigned int uiTemp;
	if ((x % BYTE_ALIGNMENT) > 0)
	{
		uiTemp =  x + (BYTE_ALIGNMENT - (x % BYTE_ALIGNMENT));
	}
	else
	{
		return x;
	}
	return uiTemp;
}

// Return the actual amount needed to make nBytes aligned to Type.
// For example DTC_ALIGN_SIZE(25, int) will return 28.
#define DTC_ALIGN_SIZE						ALIGN	
// Returns true if nBytes is aligned to Type.
// Example: DTC_IS_SIZE_ALIGNED (25,int) will return FALSE while 
// DTC_IS_SIZE_ALIGNED (24,DWORD) will return TRUE

inline BOOL DTC_IS_SIZE_ALIGNED (unsigned int nBytes, unsigned int Alignment)
{
	return ( (nBytes % Alignment) ? FALSE: TRUE );
}
	
DWORD	GetDTCProfileInt (char * pszRegValue, DWORD dwDefault);
BOOL	SetDTCProfileInt (char * pszRegValue, DWORD dwValue);

#ifndef UNICODE 

#define	GetDTCProfileIntEx			GetDTCProfileIntExA
#define	SetDTCProfileIntEx			SetDTCProfileIntExA
	
#else

#define	GetDTCProfileIntEx			GetDTCProfileIntExW
#define	SetDTCProfileIntEx			SetDTCProfileIntExW

#endif 


DWORD GetDTCProfileIntExW (WCHAR * szHostName, WCHAR * pszRegValue, DWORD dwDefault);
DWORD GetDTCProfileIntExA (char * szHostName, char * pszRegValue, DWORD dwDefault);

BOOL SetDTCProfileIntExW (WCHAR * szHostName, WCHAR * pszRegValue, DWORD dwValue);
BOOL SetDTCProfileIntExA (char * szHostName, char * pszRegValue, DWORD dwValue);

//***** ALL ERRORS GO HERE

#define	E_OUTOFRESOURCES	E_OUTOFMEMORY



// MessageId: E_S_UNAVAILABLE_OR_BUSY
//
// MessageText: The Rpc Server on the receiver side was too busy to service the
//				request or it was unavailable
//
#define E_S_UNAVAILABLE_OR_BUSY						0x80000101L

// MessageId: E_CM_NOTINITIALIZED
//
// MessageText: The initialization on the Connection Manager was either not called
//				or was called but had failed
//
#define E_CM_NOTINITIALIZED							0x80000102L

// MessageId: E_CM_TEARING_DOWN
//
// MessageText: The session is in the middle of UnBinding
//
#define E_CM_TEARING_DOWN							0x80000119L

// MessageId: E_CM_SESSION_DOWN
//
// MessageText: The session went down in the middle of a call
//
#define E_CM_SESSION_DOWN							0x80000120L

// MessageId: E_CM_S_LISTENFAILED
//
// MessageText: The Interface was not registered with RPC runtime, therefore the
//				call to StartListening is being failed
//
#define E_CM_S_LISTENFAILED							0x80000121L

// MessageId: E_CM_S_NOTLISTENING
//
// MessageText: StopListening was called while the server was not listening. This
//				can happen either if StartListening was not called or if it was 
//				called but had failed
//
#define E_CM_S_NOTLISTENING							0x80000122L

// MessageId: E_CM_SERVER_NOT_READY
//
// MessageText: The Poke or Bind failed as the server was not in the PostInit phase

#define E_CM_SERVER_NOT_READY						0x80000123L

// MessageId: E_CM_S_TIMEDOUT
//
// MessageText: The BuildContext call to the partner CM timed out on the Server side

#define E_CM_S_TIMEDOUT								0x80000124L

// MessageId: E_CM_S_BAD_ERROR
//
// MessageText: This realy is a bad error and means an assertion failure

#define	E_CM_S_BAD_ERROR							0x80000125L

// MessageId: E_CM_S_OUTOFRESOURCES
//
// MessageText: The Server Component of CM is out of resources

#define E_CM_S_OUTOFRESOURCES						0x80000126L

// MessageId: E_CM_OUTOFRESOURCES
//
// MessageText: Some sub Component of CM is out of resources

#define E_CM_OUTOFRESOURCES						0x80000127L

// MessageId: E_INVALID_CONTEXT_HANDLE
//
// MessageText: The context handle was not valid

#define E_INVALID_CONTEXT_HANDLE					0x80000128L


// MessageId: E_CM_S_LISTENING
//
// MessageText: StartListening was called and the server was already listening.

#define	E_CM_S_LISTENING							0x80000129L


// MessageId: E_CM_POKE_FAILED
//
// MessageText: The Secondary side had Poked the Primary side with no effect

#define E_CM_POKE_FAILED							0x80000130L

// MessageId:  E_LOAD_NAMESERVICE_FAILED
//
// MessageText: Was unsucessful in obtaining the name service interface

#define	E_LOAD_NAMESERVICE_FAILED					0x80000140L


// MessageId:  E_CM_CONNECTION_SINK_NOTAVAILABLE
//
// MessageText: Can not ask for buffer until a IConnectionSink is registered

#define E_CM_CONNECTION_SINK_NOTAVAILABLE			0x80000150L

// MessageId:  E_INVALIDOBJECT
//
// MessageText: Bad Object pointer

#define E_INVALIDOBJECT								0x80000152L

// MessageId:  E_CM_CONNECTION_DOWN
//
// MessageText: Connection is down operation failed

#define	E_CM_CONNECTION_DOWN						0x80000160L

// MessageId:  E_CM_PENDING_REQUEST
//
// MessageText: Cannot call request buffer while there is a pending request

#define E_CM_PENDING_REQUEST						0x80000162L

// MessageId:  E_CM_NO_MESSAGES
//
// MessageText: Dequeue called when there were no messages waiting to be dequed

#define E_CM_NO_MESSAGES							0x80000164L

// MessageId:  E_CM_USER_GUARDED_CAN_NOT_USE
//
// MessageText: Called if the call is not allowed due to the user being guarded.

#define E_CM_USER_GUARDED_CAN_NOT_USE				0x80000165L


// MessageId:  E_CM_USER_NOT_GUARDED
//
// MessageText: Not allowed to call this, unless user is guarded

#define	E_CM_USER_NOT_GUARDED						0x80000166L


// MessageId:  E_CM_ACCESS_DENIED
//
// MessageText: Wrong thread, calling thread does not have the guard and
//				therefore should not be calling this.

#define E_CM_ACCESS_DENIED							0x80000167L


// MessageId:  E_CM_UNREGISTERING_SIGNLED_SINK
//
// MessageText: A request to unregister a signal sink was made but the sink
//had a signal message that had not been delivered. 

#define E_CM_UNREGISTERING_SIGNLED_SINK				0x80000168L

// MessageId:  E_CM_NO_SIGNAL_SINK
//
// MessageText: There is no ICliqueSignalSink registered for this clique.

#define E_CM_NO_SIGNAL_SINK							0x80000168L


// MessageId:  E_CM_INVALID_TIMER_OBJECT
//
// MessageText: If the user calls CancelTimer on a timer obj and that
//				timer object can not be found

#define E_CM_INVALID_TIMER_OBJECT					0x80000169L

// MessageId:  E_CM_JOIN_DISALLOWED
//
// MessageText: If the user calls ICliqueJoin::Join and the join is causing a 
//				loop in the tree, or if the clique is already joined or if it
//				has a pending join request

#define E_CM_JOIN_DISALLOWED						0x80000170L


// MessageId:  E_S_UNAVAILABLE
//
// MessageText: Could be that either the Rpc Server is not available or else
//				partner is not as yet ready to receive calls. 

#define	E_S_UNAVAILABLE								0x80000171L


// MessageId:  E_CM_VERSION_SET_NOTSUPPORTED
//
// MessageText: At one or more levels the version numbers did not intersect

#define	E_CM_VERSION_SET_NOTSUPPORTED				0x80000172L


// MessageId:  E_CM_S_PROTOCOL_NOT_SUPPORTED
//
// MessageText: Not able to register one or more protocols. Either it is
//				an invalid protocol or it is not supported on this machine

#define E_CM_S_PROTOCOL_NOT_SUPPORTED				0x80000173L


// MessageId:  E_CM_RPC_FAILED
//
// MessageText: The remote proceduce call failed.  The server may or maynot
//				have executed the procedure call to completion.
#define E_CM_RPC_FAILED								0x80000174L


#endif	//__DTC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\dtcmem.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
/******************************************************************************
	FILE : dtcmem.h

	Purpose: Overwrite the new and delete provided by C++ runtime

	Abstract : utmem contains the declarations for the memory manager.  The only 
			   link between the memory manager and the programs that use it are
			   the local new and deletes.  Thus sources that include this file
			   have the option of either using custom memory management or common
			   memory management.  This is easily accomplished by #defining the 
			   symbol _USE_DTC_MEMORY_MANAGER.  NOTE : THIS CODE IS A BIG HACK

-------------------------------------------------------------------------------
Revision History:

[0]		26th Oct.'95		Shaiwals				Created.
*******************************************************************************/

#ifndef __DTCMEM_H_
#define __DTCMEM_H_

#include <windows.h>
#include <objbase.h>
#include "utmem.h"

/*
#ifdef __cplusplus
//Redefine new and delete
__inline void* __cdecl operator new (size_t size)
{
	return malloc(size);		// CoTaskMemAlloc(size);
}

__inline void __cdecl operator delete (void* pv) 
{ 
	free(pv);					// CoTaskMemFree(pv);
}
#endif
*/

__inline void * DtcAllocateMemory (size_t size)
{
	return malloc(size);		// CoTaskMemAlloc(size);
}

__inline void * DtcReallocateMemory (void * pv, size_t size)
{
	return realloc(pv,size);	// CoTaskMemRealloc(pv, size);
}

__inline void DtcFreeMemory (void * pv)
{
	free(pv);					// CoTaskMemFree(pv);
}

#endif __DTCMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\enum_t.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __ENUM_INCLUDED__
#define __ENUM_INCLUDED__

// Expected enumerator usage:
//	XS xs;
//	EnumXS exs(xs);
//	while (exs.next())
//		exs.get(&x);
//	exs.reset();
//	while (exs.next())
//		exs.get(&x)

class Enum {
public:
    virtual void reset() =0;
    virtual BOOL next() =0;
};

#endif // !__ENUM_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\eventlogger.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    EventLogger.h

$Header: $

Abstract: This class implements ICatalogErrorLogger2 interface and
            sends error information to the NT EventLog

Author:
    stephenr 	4/26/2001		Initial Release

Revision History:

--**************************************************************************/

#pragma once

#ifndef __EVENTLOGGER_H__
#define __EVENTLOGGER_H__

#include <windows.h>
#include "catmacros.h"

class EventLogger : public ICatalogErrorLogger2
{
public:
    EventLogger(ICatalogErrorLogger2 *pNextLogger=0) : m_cRef(0), m_hEventSource(0), m_spNextLogger(pNextLogger){}
    virtual ~EventLogger(){}

//IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv)
    {
        if (NULL == ppv) 
            return E_INVALIDARG;
        *ppv = NULL;

        if (riid == IID_ICatalogErrorLogger2)
            *ppv = (ICatalogErrorLogger2*) this;
        else if (riid == IID_IUnknown)
            *ppv = (ICatalogErrorLogger2*) this;

        if (NULL == *ppv)
            return E_NOINTERFACE;

        ((ICatalogErrorLogger2*)this)->AddRef ();
        return S_OK;
    }
	STDMETHOD_(ULONG,AddRef)		()
    {
        return InterlockedIncrement((LONG*) &m_cRef);
    }
	STDMETHOD_(ULONG,Release)		()
    {
        long cref = InterlockedDecrement((LONG*) &m_cRef);
        if (cref == 0)
            delete this;

        return cref;
    }

//ICatalogErrorLogger2
	STDMETHOD(ReportError) (ULONG      i_BaseVersion_DETAILEDERRORS,
                            ULONG      i_ExtendedVersion_DETAILEDERRORS,
                            ULONG      i_cDETAILEDERRORS_NumberOfColumns,
                            ULONG *    i_acbSizes,
                            LPVOID *   i_apvValues);
private:
    ULONG           m_cRef;
    HANDLE          m_hEventSource;
    CComPtr<ICatalogErrorLogger2> m_spNextLogger;

    void Close();
    void Open();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\fixedtableheap.h ===
//  Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
//  Filename:       FixedTableHeap.h
//  Author:         Stephenr
//  Date Created:   6/20/00
//  Description:    The previous implementation of the fixed tables (which mostly included
//                  meta tables like DatabaseMeta, TableMeta etc.) included static arrays
//                  of types DatabaseMeta, TableMeta.  The problem with this method is,
//                  since it is not a heap, the size of each array had to be statically
//                  declared.  Also, each array needed a unique signature so the PE fixup
//                  could identify the location of each array within the DLL.
//
//                  This new approach needs only one unique signature for the entire heap.
//                  Also, the heap needs to be declared as a static size; but the individual
//                  pieces within the heap, like the DatabaseMeta and TableMeta arrays,
//                  aren't presized.  So there's only one thing to resize if we run out of
//                  heap space.


#ifndef __FIXEDTABLEHEAP_H__
#define __FIXEDTABLEHEAP_H__

#ifndef __HASH_H__
    #include "Hash.h"
#endif
#ifndef __METATABLESTRUCTS_H__
    #include "MetaTableStructs.h"
#endif

#ifndef ASSERT
#define ASSERT(x)
#endif


struct ColumnMetaPrivate
{
    ULONG                       ciTagMeta;              //Count of Tags - Only valid for UI4s
    ULONG                       iTagMeta;               //Index into aTagMeta - Only valid for UI4s
    ULONG                       iIndexName;             //IndexName of a single column index (for this column)
};
const kciColumnMetaPrivateColumns   = sizeof(ColumnMetaPrivate)/sizeof(ULONG);

struct ColumnMeta : public ColumnMetaPublic, public ColumnMetaPrivate{};
const kciColumnMetaColumns          = sizeof(ColumnMeta)/sizeof(ULONG);



struct DatabaseMetaPrivate
{
    ULONG                       iSchemaBlob;            //Index into aBytes
    ULONG                       cbSchemaBlob;           //Count of Bytes of the SchemaBlob
    ULONG                       iNameHeapBlob;          //Index into aBytes
    ULONG                       cbNameHeapBlob;         //Count of Bytes of the SchemaBlob
    ULONG                       iTableMeta;             //Index into aTableMeta
    ULONG                       iGuidDid;               //Index to aGuid where the guid is the Database InternalName cast as a GUID and padded with 0x00s.
};
const kciDatabaseMetaPrivateColumns = sizeof(DatabaseMetaPrivate)/sizeof(ULONG);

struct DatabaseMeta : public DatabaseMetaPublic, public DatabaseMetaPrivate{};
const kciDatabaseMetaColumns        = sizeof(DatabaseMeta)/sizeof(ULONG);



struct IndexMetaPrivate
{
    ULONG                       iHashTable;             //Index into the FixedTableHeap where the Hash table
};
const unsigned long kciIndexMetaPrivateColumns = sizeof(IndexMetaPrivate)/sizeof(ULONG);
struct IndexMeta : public IndexMetaPublic, public IndexMetaPrivate{};
const unsigned long kciIndexMetaColumns = sizeof(IndexMeta)/sizeof(ULONG);



const unsigned long kciQueryMetaPrivateColumns = 0;
typedef QueryMetaPublic QueryMeta;
const unsigned long kciQueryMetaColumns = sizeof(QueryMeta)/sizeof(ULONG);



const unsigned long kciRelationMetaPrivateColumns = 0;
typedef RelationMetaPublic RelationMeta;
const unsigned long kciRelationMetaColumns = sizeof(RelationMeta)/sizeof(ULONG);



const unsigned long kciServerWiringMetaPrivateColumns = 0;
typedef ServerWiringMetaPublic ServerWiringMeta;
const unsigned long kciServerWiringMetaColumns = sizeof(ServerWiringMeta)/sizeof(ULONG);



struct TableMetaPrivate
{
    ULONG                       ciRows;                 //Count of Rows in the Fixed Table (which if the fixed table is meta, this is also the number of columns in the table that the meta describes).
    ULONG                       iColumnMeta;            //Index into aColumnMeta
    ULONG                       iFixedTable;            //Index into g_aFixedTable
    ULONG                       cPrivateColumns;        //This is the munber of private columns (private + ciColumns = totalColumns), this is needed for fixed table pointer arithmetic
    ULONG                       cIndexMeta;             //The number of IndexMeta entries in this table
    ULONG                       iIndexMeta;             //Index into aIndexMeta
    ULONG                       iHashTableHeader;       //If the table is a fixed table, then it will have a hash table.
    ULONG                       nTableID;               //This is a 24 bit Hash of the Table name.
    ULONG                       iServerWiring;          //Index into the ServerWiringHeap (this is a temporary hack for CatUtil)
    ULONG                       cServerWiring;          //Count of ServerWiring (this is a temporary hack for CatUtil)
};
const kciTableMetaPrivateColumns    = sizeof(TableMetaPrivate)/sizeof(ULONG);

struct TableMeta : public TableMetaPublic, public TableMetaPrivate{};
const kciTableMetaColumns           = sizeof(TableMeta)/sizeof(ULONG);



const unsigned long kciTagMetaPrivateColumns = 0;
typedef TagMetaPublic TagMeta;
const unsigned long kciTagMetaColumns = sizeof(TagMeta)/sizeof(ULONG);



//All hash tables begin with a HashTableHeader that indicates the Modulo and the total size of the HashTable (in number of HashIndexes that follow
//the HashTableHeader).  The size should be equal to Modulo if there are NO HashIndex collisions.  If there are NO HashIndex collisions, then all
//of the HashedIndex.iNext members should be 0.  If there are collisions, all iNext values should be greater than or equal to Modulo.
struct HashedIndex
{
public:
    HashedIndex() : iNext(-1), iOffset(-1){}

    ULONG       iNext;  //If the hash value is not unique then this points to the next HashedIndex with the same hash value
    ULONG       iOffset;//Index offset into some heap (defined by the hash table itself)
};

class HashTableHeader
{
public:
    ULONG       Modulo;
    ULONG       Size;//This is the size in number of HashedIndexes that follow the HashTableHeader

    const HashedIndex * Get_HashedIndex(ULONG iHash) const
    {
        return (reinterpret_cast<const HashedIndex *>(this) + 1 + iHash%Modulo);
    }
    const HashedIndex * Get_NextHashedIndex(const HashedIndex *pHI) const
    {
        ASSERT(pHI->iNext >= Modulo);
        if(-1 == pHI->iNext)
            return 0;
        else
            return (reinterpret_cast<const HashedIndex *>(this) + 1 + pHI->iNext);
    }

private:
    HashTableHeader(){}//We never construct one of these.  We always cast from some pointer.
};


//The FixedTableHeap is layed out as follows, the fixed length data comes first
//All indexes listed below are byte offsets from the beginning of the FixedTableHeap.  All indexes within the structs are indexes within
//other structs.  For example, DatabaseMeta has a provate column that gives an index to the first table belonging to the database.  That
//index is a TableMeta struct array index (&aTableMeta[index]); it is NOT a byte offset.
/*
0   ULONG           kFixedTableHeapSignature0
1   ULONG           kFixedTableHeapSignature1
2   ULONG           kFixedTableHeapKey
3   ULONG           kFixedTableHeapVersion
4   ULONG           kcbHeap
5   ULONG           EndOfHeap                                       This is the byte offset just beyond the heap.  All indexes should be less than this (this is basically just the size of the heap)

6   ULONG           iColumnMeta                                     This is the byte offset to the aColumnMeta
7   ULONG           cColumnMeta

8   ULONG           iDatabaseMeta
9   ULONG           cDatabaseMeta

A   ULONG           iHashTableHeap
B   ULONG           cbHashTableHeap                                 Size of the HashTableHeap in count of bytes

C   ULONG           iIndexMeta
D   ULONG           cIndexMeta

E   ULONG           iPooledHeap                                     All data is stored in a pooled heap (including UI4s)
F   ULONG           cbPooledHeap                                    Size of the Pooled Heap in count of bytes

10  ULONG           iQueryMeta
11  ULONG           cQueryMeta

12  ULONG           iRelationMeta
13  ULONG           cRelationMeta

14  ULONG           iServerWiringMeta
15  ULONG           cServerWiringMeta

16  ULONG           iTableMeta
17  ULONG           cTableMeta

18  ULONG           iTagMeta
19  ULONG           cTagMeta

1A  ULONG           iULONG                                          Pool For Non Meta Tables
1B  ULONG           cULONG

                              //0x400 ULONGs in a page
    ULONG           aReserved[0x400 - 0x1C]                         This dummy array puts the ULONG pool on a page boundary, this is important for FixedPackedSchema which is located at the beginning of the ULONG pool
------------------------------------Page Boundary------------------------------------
    ULONG               aULONG              [cULONG             ]   FixedPackedSchema pool is always located first in the ULONG pool.
    ColumnMeta          aColumnMeta         [cColumnMeta        ]
    DatabaseMeta        aDatabaseMeta       [cDatabaseMeta      ]
    HashedIndex         HashTableHeap       [cbHashTableHeap    ]
    IndexMeta           aIndexMeta          [cIndexMeta         ]
    unsigned char       PooledDataHeap      [cbPooledDataHeap   ]
    QueryMeta           aQueryMeta          [cQueryMeta         ]
    RelationMeta        aRelationMeta       [cRelationMeta      ]
    ServerWiringMeta    aServerWiringMeta   [cServerWiringMeta  ]
    TableMeta           aTableMeta          [cTableMeta         ]
    TagMeta             aTagMeta            [cTagMeta           ]
*/

//WARNING!! If we changes the following two lines to 'const ULONG', the signatures can appear in two places within Catalog.dll.  So leave them as '#define'.
#define      kFixedTableHeapSignature0   (0x207be016)
#define      kFixedTableHeapSignature1   (0xe0182086)
const ULONG  kFixedTableHeapKey        = sizeof(ColumnMeta) ^ (sizeof(DatabaseMeta)<<3) ^ (sizeof(IndexMeta)<<6) ^ (sizeof(QueryMeta)<<9) ^ (sizeof(RelationMeta)<<12)
                                         ^ (sizeof(ServerWiringMeta)<<15) ^ (sizeof(TableMeta)<<18) ^ (sizeof(TagMeta)<<21);
const ULONG  kFixedTableHeapVersion    = 0x0000000A;
//248392 bytes is the total size reserved for the heap.  EndOfHeap give the amount of use space
const ULONG  kcbFixedTableHeap         = 1250536;

class FixedTableHeap
{
public:
    ULONG                       Get_HeapSignature0      ()              const {return *reinterpret_cast<const ULONG *>(this);}
    ULONG                       Get_HeapSignature1      ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x01);}
    ULONG                       Get_HeapKey             ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x02);}
    ULONG                       Get_HeapVersion         ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x03);}
    ULONG                       Get_cbHeap              ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x04);}
    ULONG                       Get_EndOfHeap           ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x05);}

    ULONG                       Get_iColumnMeta         ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x06);}
    ULONG                       Get_cColumnMeta         ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x07);}

    ULONG                       Get_iDatabaseMeta       ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x08);}
    ULONG                       Get_cDatabaseMeta       ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x09);}

    ULONG                       Get_iHashTableHeap      ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0A);}
    ULONG                       Get_cbHashTableHeap     ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0B);}

    ULONG                       Get_iIndexMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0C);}
    ULONG                       Get_cIndexMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0D);}
                                                 
    ULONG                       Get_iPooledHeap         ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0E);}
    ULONG                       Get_cbPooledHeap        ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x0F);}
                                                 
    ULONG                       Get_iQueryMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x10);}
    ULONG                       Get_cQueryMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x11);}
                                                 
    ULONG                       Get_iRelationMeta       ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x12);}
    ULONG                       Get_cRelationMeta       ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x13);}
                                                 
    ULONG                       Get_iServerWiringMeta   ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x14);}
    ULONG                       Get_cServerWiringMeta   ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x15);}
                                                 
    ULONG                       Get_iTableMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x16);}
    ULONG                       Get_cTableMeta          ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x17);}
                                                 
    ULONG                       Get_iTagMeta            ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x18);}
    ULONG                       Get_cTagMeta            ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x19);}
                                                 
    ULONG                       Get_iULONG              ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x1A);}
    ULONG                       Get_cULONG              ()              const {return *(reinterpret_cast<const ULONG *>(this) + 0x1B);}

    const ULONG *               Get_pReserved           (ULONG i=0)     const {ASSERT(i<(0x400 - 0x1C));return (reinterpret_cast<const ULONG *>(this) + 0x1C + i);}

    //The zeroth entry is reserved for NULL
    const unsigned char    *    Get_PooledDataHeap      ()              const {return  reinterpret_cast<const unsigned char *>(this) + Get_iPooledHeap();}
    const unsigned char    *    Get_PooledData          (ULONG iPool)   const {ASSERT(iPool < Get_cbPooledHeap());return 0==iPool ? 0 : (Get_PooledDataHeap()+iPool);}
    ULONG                       Get_PooledDataSize      (ULONG iPool)   const {ASSERT(iPool < Get_cbPooledHeap());return 0==iPool ? 0 : reinterpret_cast<const ULONG *>(Get_PooledDataHeap()+iPool)[-1];}

    const HashedIndex      *    Get_HashTableHeap       ()              const {return  reinterpret_cast<const HashedIndex *>(reinterpret_cast<const unsigned char *>(this) + Get_iHashTableHeap());}
    const HashTableHeader  *    Get_HashHeader          (ULONG iHash)   const {ASSERT(iHash < Get_cbHashTableHeap());return (reinterpret_cast<const HashTableHeader *>(Get_HashTableHeap()+iHash));}
    const HashedIndex      *    Get_HashedIndex         (ULONG iHash)   const {ASSERT(iHash < Get_cbHashTableHeap());return Get_HashTableHeap()+iHash;}

    const ColumnMeta       *    Get_aColumnMeta         (ULONG iRow=0)  const {ASSERT(iRow < Get_cColumnMeta      ());return reinterpret_cast<const ColumnMeta       *>(reinterpret_cast<const unsigned char *>(this) + Get_iColumnMeta      ()) + iRow;}
    const DatabaseMeta     *    Get_aDatabaseMeta       (ULONG iRow=0)  const {ASSERT(iRow < Get_cDatabaseMeta    ());return reinterpret_cast<const DatabaseMeta     *>(reinterpret_cast<const unsigned char *>(this) + Get_iDatabaseMeta    ()) + iRow;}
    const IndexMeta        *    Get_aIndexMeta          (ULONG iRow=0)  const {ASSERT(iRow < Get_cIndexMeta       ());return reinterpret_cast<const IndexMeta        *>(reinterpret_cast<const unsigned char *>(this) + Get_iIndexMeta       ()) + iRow;}
    const QueryMeta        *    Get_aQueryMeta          (ULONG iRow=0)  const {ASSERT(iRow < Get_cQueryMeta       ());return reinterpret_cast<const QueryMeta        *>(reinterpret_cast<const unsigned char *>(this) + Get_iQueryMeta       ()) + iRow;}
    const RelationMeta     *    Get_aRelationMeta       (ULONG iRow=0)  const {ASSERT(iRow < Get_cRelationMeta    ());return reinterpret_cast<const RelationMeta     *>(reinterpret_cast<const unsigned char *>(this) + Get_iRelationMeta    ()) + iRow;}
    const ServerWiringMeta *    Get_aServerWiringMeta   (ULONG iRow=0)  const {ASSERT(iRow < Get_cServerWiringMeta());return reinterpret_cast<const ServerWiringMeta *>(reinterpret_cast<const unsigned char *>(this) + Get_iServerWiringMeta()) + iRow;}
    const TableMeta        *    Get_aTableMeta          (ULONG iRow=0)  const {ASSERT(iRow < Get_cTableMeta       ());return reinterpret_cast<const TableMeta        *>(reinterpret_cast<const unsigned char *>(this) + Get_iTableMeta       ()) + iRow;}
    const TagMeta          *    Get_aTagMeta            (ULONG iRow=0)  const {ASSERT(iRow < Get_cTagMeta         ());return reinterpret_cast<const TagMeta          *>(reinterpret_cast<const unsigned char *>(this) + Get_iTagMeta         ()) + iRow;}
    const ULONG            *    Get_aULONG              (ULONG iRow=0)  const {ASSERT(iRow < Get_cULONG           ());return reinterpret_cast<const ULONG            *>(reinterpret_cast<const unsigned char *>(this) + Get_iULONG           ()) + iRow;}

    ULONG                       FindTableMetaRow         (LPCWSTR InternalName) const //This should be used to get MetaTables only.  Linear search for other tables will be too expensive.
    {
        ULONG iTableMeta;
        for(iTableMeta=0; iTableMeta<Get_cTableMeta(); ++iTableMeta)
        {
            if(0 == _wcsicmp(reinterpret_cast<const WCHAR *>(Get_PooledData(Get_aTableMeta(iTableMeta)->InternalName)), InternalName))
                return iTableMeta;
        }
        return -1;
    }

    //Utility functions
    ULONG                       UI4FromIndex            (ULONG i)       const {return *reinterpret_cast<const ULONG *>(Get_PooledData(i));}
    const WCHAR *               StringFromIndex         (ULONG i)       const {return  reinterpret_cast<const WCHAR *>(Get_PooledData(i));}
    const unsigned char *       BytesFromIndex          (ULONG i)       const {return Get_PooledData(i);}
    const GUID *                GuidFromIndex           (ULONG i)       const {return  reinterpret_cast<const GUID *>(Get_PooledData(i));}

    bool                        IsValid() const
    {
        if(IsBadReadPtr(this, 4096))
            return false;
        if( reinterpret_cast<const unsigned char *>(this)[0] != 0x16 ||
            reinterpret_cast<const unsigned char *>(this)[1] != 0xe0 ||
            reinterpret_cast<const unsigned char *>(this)[2] != 0x7b ||
            reinterpret_cast<const unsigned char *>(this)[3] != 0x20 ||
            reinterpret_cast<const unsigned char *>(this)[4] != 0x86 ||
            reinterpret_cast<const unsigned char *>(this)[5] != 0x20 ||
            reinterpret_cast<const unsigned char *>(this)[6] != 0x18 ||
            reinterpret_cast<const unsigned char *>(this)[7] != 0xe0)
            return false;
        if( Get_HeapKey()       != kFixedTableHeapKey       ||
            Get_HeapVersion()   != kFixedTableHeapVersion   ||
            IsBadReadPtr(this, Get_EndOfHeap())             ||
            IsBadReadPtr(this, Get_cbHeap()))
            return false;
        if( Get_cColumnMeta() <  (  kciColumnMetaPublicColumns      + 
                                    kciDatabaseMetaPublicColumns    +
                                    kciIndexMetaPublicColumns       +
                                    kciQueryMetaPublicColumns       +
                                    kciRelationMetaPublicColumns    +
                                    kciServerWiringMetaPublicColumns+
                                    kciTableMetaPublicColumns       +
                                    kciTagMetaPublicColumns))
            return false;
        return true;
    }
private:
    FixedTableHeap(){} //This is private bacause we never instantiate one of these objects.  We only cast to one of these.
};

//@@@TODO This should go away
typedef HRESULT( __stdcall *GETFIXEDTABLEHEAPSIGNATURES)(ULONG *signature0, ULONG *signature1, ULONG *cbFixedTableHeap);


#endif //__FIXEDTABLEHEAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\functracer.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    netframeworkprov.h

$Header: $

Abstract:
    Function Tracer

Author:
    marcelv 	05/01/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __FUNCTRACER_H__
#define __FUNCTRACER_H__

#pragma once

#include "dbgutil.h"

class CFuncTracer
{
public:
    CFuncTracer (LPCSTR szFuncName, LPCSTR szFileName, ULONG lineNr)
    {
        // only trace if INFO is wanted
        if (g_fErrorFlags & DEBUG_FLAG_TRC_FUNC)
        {
            m_pszFuncName   = szFuncName;
            m_pszFileName   = szFileName;
            m_lineNr        = lineNr;
            DBGTRCFUNC((g_pDebug, m_pszFileName, m_lineNr, "-> %s\n", m_pszFuncName));
        }
    }
    
    ~CFuncTracer ()
    {
        // only trace if INFO is wanted
        if (g_fErrorFlags & DEBUG_FLAG_TRC_FUNC)
        {
            DBGTRCFUNC((g_pDebug, m_pszFileName, m_lineNr, "<- %s\n", m_pszFuncName));
        }
    }

private:
    LPCSTR m_pszFuncName;           // function name
    LPCSTR m_pszFileName;           // file name
    ULONG  m_lineNr;                // line number
};

// The TRACEFUNC define that should be used in code that uses the tracer
#define TRACEFUNC CFuncTracer __functracer__(__FUNCTION__, __FILE__, __LINE__)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\guidfromname.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef GUIDFROMNAME_H_
#define GUIDFROMNAME_H_

// GuidFromName.h - function prototype

void GuidFromName
(
	GUID *	pGuidResult,		// resulting UUID
	REFGUID	refGuidNsid,		// Name Space UUID, so identical names from
								// different name spaces generate different
								// UUIDs
	const void * pvName,		// the name from which to generate a GUID
	DWORD	dwcbName			// length of the name
);

#endif // GUIDFROMNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\icmprecsts.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// ICmpRecsTS.h
//
// These wrappers provide a thread safe version of the ICR pointer.
//
//*****************************************************************************
#ifndef __icmprecsts_h__
#define __icmprecsts_h__

#include "icmprecs.h"


__declspec(dllexport) HRESULT STDMETHODCALLTYPE CreateComponentLibraryTS(
	LPCWSTR szName,
	long fFlags,
	ITSComponentRecords **ppIComponentRecords);

__declspec(dllexport) HRESULT STDMETHODCALLTYPE OpenComponentLibraryTS(
	LPCWSTR szName,
	long fFlags,
	ITSComponentRecords **ppIComponentRecords);

__declspec(dllexport) HRESULT STDMETHODCALLTYPE OpenComponentLibrarySharedTS(
	LPCWSTR		szName,
	LPCWSTR		szSharedMemory,
	ULONG		cbSize,
	LPSECURITY_ATTRIBUTES pAttributes,
	long		fFlags,
	ITSComponentRecords **ppIComponentRecords);



#endif // __icmprecsts_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\iiscblob.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iiscblob.h

Abstract:

    This include file contains the definition of the IIS_CRYPTO_BLOB
    structure and associated constants.

Author:

    Keith Moore (keithmo)        25-Feb-1997

Revision History:

--*/


#ifndef _IISCBLOB_H_
#define _IISCBLOB_H_

#ifndef _IIS_CRYPTO_BLOB_DEFINED
#define _IIS_CRYPTO_BLOB_DEFINED
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

//
// Structure signatures for the various blob types.
//

#define SALT_BLOB_SIGNATURE         ((DWORD)'bScI')
#define KEY_BLOB_SIGNATURE          ((DWORD)'bKcI')
#define PUBLIC_KEY_BLOB_SIGNATURE   ((DWORD)'bPcI')
#define DATA_BLOB_SIGNATURE         ((DWORD)'bDcI')
#define HASH_BLOB_SIGNATURE         ((DWORD)'bHcI')
#define CLEARTEXT_BLOB_SIGNATURE    ((DWORD)'bCcI')

//
// A crypto blob. Note that this is just the header for the blob.
// The details of the blob internals are private to the IIS Crypto
// package.
//

typedef struct _IIS_CRYPTO_BLOB {

// BUGBUG: Hackety Hack: midl doesn't know about __unaligned, so we don't
// tell it.  At some point, midl should be fixed to know about it.  Also,
// we should ultimately stop using __unaligned
#if defined(MIDL_PASS)
    //
    // The structure signature for this blob.
    //

    DWORD BlobSignature;

    //
    // The total length of this blob, NOT including this header.
    //

    DWORD BlobDataLength;

    //
    // Define the raw data so that MIDL can marshal correctly.
    //

    [size_is(BlobDataLength)] unsigned char BlobData[*];
#else
    //
    // The structure signature for this blob.
    //

    DWORD BlobSignature;

    //
    // The total length of this blob, NOT including this header.
    //

    DWORD BlobDataLength;

#endif  // MIDL_PASS

} IIS_CRYPTO_BLOB, *PIIS_CRYPTO_BLOB;


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus
#endif  // _IIS_CRYPTO_BLOB_DEFINED


#endif  // _IISCBLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\hash.h ===
#ifndef __HASH_H__
#define __HASH_H__

//These functions generate a 32 bit hash value given any variable type.  The only pointer types that are supported are 'LPCWSTR' and 'unsigned char *'.
//Everything else should be passed by reference.  If you pass a pointer type (other than the two supported types), the Hash template will hash the
//pointer itself, NOT its contents.  That may be what you want;  if so, go for it.


//Hashing is done on a case insensitive basis, so this ToLower function uses a lookup table to convert a wide char to its lowercase version without
//the need for an 'if' condition.
inline WCHAR ToLower(WCHAR i_wchar)
{
    //The lower 127 ascii are mapped to their lowercase ascii value.  Note only 0x41('A') - 0x5a('Z') are changed.  And these are mapped to 0x60('a') - 0x7a('z')
    static unsigned char kToLower[128] = 
    { //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
    /*00*/  0x00,   0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,   0x09,   0x0a,   0x0b,   0x0c,   0x0d,   0x0e,   0x0f,
    /*10*/  0x10,   0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,   0x19,   0x1a,   0x1b,   0x1c,   0x1d,   0x1e,   0x1f,
    /*20*/  0x20,   0x21,   0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x29,   0x2a,   0x2b,   0x2c,   0x2d,   0x2e,   0x2f,
    /*30*/  0x30,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39,   0x3a,   0x3b,   0x3c,   0x3d,   0x3e,   0x3f,
    /*40*/  0x40,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,   0x68,   0x69,   0x6a,   0x6b,   0x6c,   0x6d,   0x6e,   0x6f,
    /*50*/  0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7a,   0x5b,   0x5c,   0x5d,   0x5e,   0x5f,
    /*60*/  0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,   0x68,   0x69,   0x6a,   0x6b,   0x6c,   0x6d,   0x6e,   0x6f,
    /*70*/  0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7a,   0x7b,   0x7c,   0x7d,   0x7e,   0x7f,
    };

    return (kToLower[i_wchar & 0x007f] | (i_wchar & ~0x007f));
}


//Warning! For effeciency users should never rotate by more than 32 bits
inline ULONG RotateLeft(ULONG Value, ULONG cBits)
{
#ifdef _X86_
    _asm
    {
        mov         eax, Value
        mov         ecx, cBits
        rol         eax, cl
    }
#else
    return (Value << cBits) | (Value >> (32-cBits));
#endif
}


inline ULONG HashCaseSensitive(LPCWSTR i_pKey, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    //Case sensitive hash
    while(*i_pKey) i_Hash = RotateLeft(i_Hash,2)^(*i_pKey++);
    return i_Hash;
}


inline ULONG HashCaseSensitive(LPWSTR i_pKey, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    return HashCaseSensitive(reinterpret_cast<LPCWSTR>(i_pKey), i_Hash);
}


inline ULONG Hash(LPCWSTR i_pKey, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    //Case insensitive hash
#ifdef _X86_
    while(*i_pKey)
    {
        ToLower(*i_pKey++);//result is in eax
        _asm
        {
            movzx       esi,    ax
            mov         eax,    i_Hash
            mov         ecx,    2
            rol         eax,    cl
            xor         eax,    esi
            mov         i_Hash, eax
        }
    }
#else
    while(*i_pKey) i_Hash = RotateLeft(i_Hash,2)^ToLower(*i_pKey++);
#endif
    return i_Hash;
}


inline ULONG Hash(LPWSTR i_pKey, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    //Case insensitive hash
    return Hash(reinterpret_cast<LPCWSTR>(i_pKey), i_Hash);
}


inline ULONG Hash(const unsigned char *i_pKey, unsigned long i_cb, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    while(i_cb--) i_Hash = RotateLeft(i_Hash,2)^(*i_pKey++);
    return i_Hash;
}


inline ULONG Hash(unsigned char *i_pKey, unsigned long i_cb, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    return Hash(static_cast<const unsigned char *>(i_pKey), i_cb, i_Hash);
}


template<class T> ULONG Hash(T i_Key, ULONG i_Hash=0 /*Starting Hash Value*/)
{
    return Hash(reinterpret_cast<const unsigned char *>(&i_Key), sizeof(T), i_Hash);
}

#endif //__HASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\isthelper.h ===
#ifndef _IST_HELPER_H_
#define _IST_HELPER_H_

HRESULT FillInColumnMeta(ISimpleTableRead2* i_pISTColumnMeta,
						 LPCWSTR            i_wszTable,
						 ULONG              i_iCol,
						 LPVOID*            io_apvColumnMeta);

DWORD GetMetabaseType(DWORD i_dwType,
					  DWORD i_dwMetaFlags);

BOOL IsMetabaseProperty(DWORD i_dwProperty);


#endif // _IST_HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\icmprecs.h ===
//*****************************************************************************
// ICmpRecs.h
//
// This internal file is used to give direct access to the storage engine.	It
// bypasses the OLE DB layer.
//
// Copyright (c) 1996-1997, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#pragma once

#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
enum CorSaveSize
{
	cssAccurate = 0x0000,			// Find exact save size, accurate but slower.
	cssQuick = 0x0001				// Estimate save size, may pad estimate, but faster.
};
#endif

#include <basetsd.h>	 // BUGBUG VC6.0 hack


//********** Types ************************************************************
extern const GUID __declspec(selectany) IID_IComponentRecords =
{ 0x259a8e8, 0xcf25, 0x11d1, { 0x8c, 0xcf, 0x0, 0xc0, 0x4f, 0xc3, 0x1d, 0xf8 } };

extern const GUID __declspec(selectany) IID_ITSComponentRecords =
{ 0x22ad41d1, 0xd96a, 0x11d1, { 0x88, 0xc1, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };

extern const GUID __declspec(selectany) IID_IComponentRecordsSchema =
{ 0x58769c81, 0xa8cc, 0x11d1, { 0x88, 0x46, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };

extern const GUID __declspec(selectany) IID_ITSComponentRecordsSchema =
{ 0x22ad41d2, 0xd96a, 0x11d1, { 0x88, 0xc1, 0x0, 0x80, 0xc7, 0x92, 0xe5, 0xd8 } };


extern const GUID __declspec(selectany) IID_ICallDescrSection =
{ 0x2b137007, 0xf02d, 0x11d1, { 0x8c, 0xe3, 0x0, 0xa0, 0xc9, 0xb0, 0xa0, 0x63 } };


// These data types are basically castable place holders for non-engine code.
// WARNING:  This size represents an internal data structure which can grow on
// different plantforms.
#if !defined(__MSCORCLB_CODE__) && !defined(_STGAPI_H_)
class CRCURSOR
{
	char b[48];
};
class RECORDLIST;
#endif


//*****************************************************************************
// Use the following to give a hint to QueryRowsByColumns.	When passed in, the
// query code will use the index given to do the query.  If a hint is not given,
// then no index is used.  While index choosing code is in the driver (for OLE
// DB clients), internal engine use will be faster if the index is indentified
// up front.
//*****************************************************************************

#define QUERYHINT_PK_MULTICOLUMN	0xffffffff // A multiple column primary key.

enum QUERYHINTTYPE
{
	QH_COLUMN,							// Hint is a RID or primary key column.
	QH_INDEX							// Use the index given.
};

struct QUERYHINT
{
	QUERYHINTTYPE	iType;				// What type of hint to use.
	union
	{
		ULONG		columnid;			// Which column contains the hint.
		const WCHAR	*szIndex;			// Name of index.
	};
};


//*****************************************************************************
// Support for IComponentRecordsSchema, which can be used to get the definition
// of a table, its columns, and indexes.
//*****************************************************************************
#ifndef __ICR_SCHEMA__
#define __ICR_SCHEMA__

#ifndef __COMPLIB_NAME_LENGTHS__
#define __COMPLIB_NAME_LENGTHS__
const int MAXCOLNAME = 64;
const int MAXSCHEMANAME = 32;
const int MAXINDEXNAME = 32 + MAXSCHEMANAME;
const int MAXTABLENAME = 32 + MAXSCHEMANAME;
const int MAXDESC = 256;
const int MAXTYPENAME = 36;
#endif


// Each table is described as follows.
struct ICRSCHEMA_TABLE
{
	WCHAR		rcTable[MAXTABLENAME];	// Name of the table.
	ULONG		fFlags; 				// ICRSCHEMA_TBL_xxx flags.
	USHORT		Columns;				// How many columns are in the table.
	USHORT		Indexes;				// How many indexes are in the table.
	USHORT		RecordStart;			// Start offset for a RID column.
	USHORT		Pad;
};

#define ICRSCHEMA_TBL_TEMPORARY 	0x00000001	// Table is temporary.
#define ICRSCHEMA_TBL_HASPKEYCOL	0x00000008	// Table has a primary key.
#define ICRSCHEMA_TBL_HASRIDCOL 	0x00000010	// Table has a RID column.
#define ICRSCHEMA_TBL_MASK			0x00000019

// Each column is described by the following structure.
struct ICRSCHEMA_COLUMN
{
	WCHAR		rcColumn[MAXCOLNAME];	// Name of the column.
	DBTYPE		wType;					// Type of column.
	USHORT		Ordinal;				// Ordinal of this column.
	ULONG		fFlags; 				// ICRSCHEMA_COL_xxx flags
	ULONG		cbSize; 				// Maximum size a column can be.
};

#define ICRSCHEMA_COL_NULLABLE		0x00000001	// Column allows the NULL value.
#define ICRSCHEMA_COL_PK			0x00000004	// Primary key column.
#define ICRSCHEMA_COL_ROWID 		0x00000008	// Column is the record id for table.
#define ICRSCHEMA_COL_CASEINSEN		0x00000010  // Column is case insensitive
#define ICRSCHEMA_COL_FIXEDLEN		0x00001000	// Column is fixed length.
#define ICRSCHEMA_COL_MASK			0x0000101D


// Each index can be retrieved using this structure.  The Keys field conains
// the size of the rgKeys array on input, and on output contains the total
// number of keys on the index.  If the size is larger on return then going
// in, the array was not large enough.	Simply call again wtih an array of
// the correct size to get the total list.
struct ICRSCHEMA_INDEX
{
	WCHAR		rcIndex[MAXINDEXNAME];	// Name of the index.
	ULONG		fFlags; 				// Flags describing the index.
	USHORT		RowThreshold;			// Minimum rows required before index is built.
	USHORT		IndexOrdinal;			// Ordinal of the index.
	USHORT		Type;					// What type of index is this.
	USHORT		Keys;					// [In] Max size of rgKeys, [Out] Total keys there are
	USHORT		*rgKeys;				// Array of key values to fill out.
};

enum
{
	ICRSCHEMA_TYPE_HASHED			= 0x01, 	// Hashed index.
	ICRSCHEMA_TYPE_SORTED			= 0x02		// Sorted index.
};

#define ICRSCHEMA_DEX_UNIQUE		0x00000002	// Unique index.
#define ICRSCHEMA_DEX_PK			0x00000004	// Primary key.
#define ICRSCHEMA_DEX_MASK			0x00000006	// Mask.


// Used for GetColumnDefinitions.
enum ICRCOLUMN_GET
{
	ICRCOLUMN_GET_ALL,					// Retrieve every column.
	ICRCOLUMN_GET_BYORDINAL 			// Retrieve according to ordinal.
};

#endif // __ICR_SCHEMA__


//*****************************************************************************
// Flags for record creation.
//*****************************************************************************
#define ICR_RECORD_NORMAL	0x00000000			// Normal, persisted record (default).
#define ICR_RECORD_TEMP		0x00000001			// Record is transient.




//********** Macros ***********************************************************

//*****************************************************************************
// Helper macros for Set/GetColumns, Set/GetStruct.
//*****************************************************************************
#ifndef __ColumnBitMacros__
#define __ColumnBitMacros__
#define CheckColumnBit(flags, x)	(flags & (1 << (x)))
#define SetColumnBit(x) 			(1 << (x))
#define UnsetColumnBit(x)			(~(1 << (x)))

#define COLUMN_ORDINAL_MASK			0x80000000
#define COLUMN_ORDINAL_LIST(x)		(COLUMN_ORDINAL_MASK | (x))
inline int IsOrdinalList(ULONG i)
{
	return ((COLUMN_ORDINAL_MASK & i) == COLUMN_ORDINAL_MASK);
}
#endif

inline ULONG SetBit(ULONG &val, int iBit, int bSet)
{
	if (bSet)
		val |= (1 << iBit);
	else
		val &= ~(1 << iBit);
	return (val);
}

inline ULONG GetBit(ULONG val, int iBit)
{
	return (val & (1 << iBit));
}

#ifdef _M_ALPHA
#define DEFAULT_ALIGNMENT			8
#else
#define DEFAULT_ALIGNMENT			4
#endif
#define DFT_MAX_VARCOL				260

#define MAXSHMEM					64

//*****************************************************************************
// This interface is access special data from a record (ie: data that could
// be variable sized or otherwise changed).
//*****************************************************************************
interface IComponentRecords : public IUnknown
{

//*****************************************************************************
//
//********** Record creation functions.
//
//*****************************************************************************

	virtual HRESULT STDMETHODCALLTYPE NewRecord( // Return code.
		TABLEID 	tableid,				// Which table to work on.
		void		**ppData,				// Return new record here.
		OID 		_oid,					// ID of the record.
		ULONG		iOidColumn, 			// Ordinal of OID column, 0 means none.
		ULONG		*pRecordID) = 0;		// Optionally return the record id.

	virtual HRESULT STDMETHODCALLTYPE NewTempRecord( // Return code.
		TABLEID 	tableid,				// Which table to work on.
		void		**ppData,				// Return new record here.
		OID 		_oid,					// ID of the record.
		ULONG		iOidColumn, 			// Ordinal of OID column.
		ULONG		*pRecordID) = 0;		// Optionally return the record id.

//*****************************************************************************
// This function will insert a new record into the given table and set all of
// the data for the columns.  In cases where a primary key and/or unique indexes
// need to be specified, this is the only function that can be used.
//
// Please see the SetColumns function for a description of the rest of the
// parameters to this function.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE NewRecordAndData( // Return code.
		TABLEID 	tableid,				// Which table to work on.
		void		**ppData,				// Return new record here.
		ULONG		*pRecordID, 			// Optionally return the record id.
		int			fFlags,					// ICR_RECORD_xxx value, 0 default.
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		const ULONG cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// [in] DBSTATUS_S_ISNULL array [out] HRESULT array.
		const ULONG	*rgFieldMask) = 0;		// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns



//*****************************************************************************
//
//********** Full struct functions.  The SchemaGen tool will generate a
//				structure for a table that matches the full layout.  Use these
//				structures with the following functions to do very fast get, set,
//				and inserts of data without binding information.
//
//*****************************************************************************

//**************************************************************************************
// GetStruct
//		Retrieve the fields specified by fFieldMask, for the array of iRows row pointers
//		of size cbRowStruct and place it into the memory chunk pointed to by rgpbBuf.
//		rgResult[] is any array of the HRESULTs for each row if the user is interested in
//		knowing.
//		The function will bail bail out on the first error. In this case it is the
//		responsibility of the user to walk through the rgResults[] array to figure out
//		when the error happened. Warnings generated by the lower level functions are placed
//		rgResults[] array, but the function continues with the next row.
//
//**************************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetStruct(	//Return Code
		TABLEID 	tableid,				// Which table to work on.
		int 		iRows,					// number of rows for bulk fetch.
		void		*rgpRowPtr[],			// pointer to array of row pointers.
		int 		cbRowStruct,			// size of <table name>_RS structure.
		void		*rgpbBuf,				// pointer to the chunk of memory where the
											// retrieved data will be placed.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask) = 0;		// mask to specify a subset of fields.

//**************************************************************************************
// SetStruct:
//		given an array of iRows row pointers, set the data the user provided in the
//		specified fields of the row. cbRowStruct has been provided
//		to be able to embed the RowStruct (as defined by pagedump) in a user defined structure.
//		fNullFieldMask specifies fields that the user wants to set to NULL.
//		The user provides rgResult[] array if interested in the outcome of each row.
//
//**************************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SetStruct(	// Return Code
		TABLEID 	tableid,				// table to work on.
		int 		iRows,					// number of Rows for bulk set.
		void		*rgpRowPtr[],			// pointer to array of row pointers.
		int 		cbRowStruct,			// size of <table name>_RS struct.
		void		*rgpbBuf,				// pointer to chunk of memory to set the data from.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask, 			// mask to specify a subset of the fields.
		ULONG		fNullFieldMask) = 0;	// fields which need to be set to null.

//**************************************************************************************
// InsertStruct:
//		Creates new records first and then calls SetStruct.
//		See SetStruct() for details on the parameters.
//**************************************************************************************
	virtual HRESULT STDMETHODCALLTYPE InsertStruct( // Return Code
		TABLEID 	tableid,				// table to work on.
		int 		iRows,					// number of Rows for bulk set.
		void		*rgpRowPtr[],			// Return pointer to new values.
		int 		cbRowStruct,			// size of <table name>_RS struct.
		void		*rgpbBuf,				// pointer to chunk of memory to set the data from.
		HRESULT 	rgResult[], 			// array of HRESULT for iRows.
		ULONG		fFieldMask, 			// mask to specify a subset of the fields.
		ULONG		fNullFieldMask) = 0;	// fields which need to be set to null.



//*****************************************************************************
//
//********** Generic column get and set functions.	Provides fast get and set
//				speed for many columns in your own layout.
//
//*****************************************************************************

//*****************************************************************************
// Similar to GetStruct(), this function retrieves the specified columns 
// of 1 record pointer. The major difference between GetColumns() and 
// GetStruct() is that GetColumns() let's the caller specify a individual 
// buffer for each field. Hence, the caller does not have to allocate the row 
// structure like you would with GetStruct(). Refer to the GetStruct() header 
// for details on the parameters.
//
// fFieldMask can be one of two types.  If you apply the COLUMN_ORDINAL_LIST
// macro to the iCols parameter, then fFieldMask points to an array of 
// ULONG column ordinals.  This consumes more room, but allows column ordinals
// greater than 32.  If the macro is not applied to the count, then fFieldMask
// is a pointer to a bitmaks of columns which are to be touched.  Use the
// SetColumnBit macro to set the correct bits.
//
// DBTYPE_BYREF may be given for the data type on the get.	In this case, 
// rgpbBuf will the address of an array of void * pointers that will be filled
// out with pointers to the actual data for the column.  These pointers point
// to the internal data structures of the engine and must never be written to.
// If the column was null, then the pointer value will be set to NULL.	Finally,
// the pcbBuf entry for the column contains the length of the data pointed to
// by rgpbBuf.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetColumns(	// Return code.
		TABLEID 	tableid,				// table to work on.
		const void	*pRowPtr,				// row pointer
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		ULONG		cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// array of HRESULT for iCols.
		const ULONG	*rgFieldMask) = 0;		// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns

//*****************************************************************************
// Similar to SetStruct(), this function puts the specified columns of 1 record
// pointer. The major difference between SetColumns() and SetStruct() is that 
// SetColumns() let's the caller specify a individual buffer for each field. 
// Hence, the caller does not have to allocate the row structure like you would 
// with SetStruct(). Refer to the SetStruct() hearder for details on the 
// parameters.
//
// fFieldMask can be one of two types.  If you apply the COLUMN_ORDINAL_LIST
// macro to the iCols parameter, then fFieldMask points to an array of 
// ULONG column ordinals.  This consumes more room, but allows column ordinals
// greater than 32.  If the macro is not applied to the count, then fFieldMask
// is a pointer to a bitmaks of columns which are to be touched.  Use the
// SetColumnBit macro to set the correct bits.
//
// DBTYPE_BYREF is not allowed by this function since this function must 
// always make a copy of the data for it to be saved to disk with the database.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SetColumns(	// Return code.
		TABLEID 	tableid,				// table to work on.
		void		*pRowPtr,				// row pointer
		int 		iCols,					// number of columns
		const DBTYPE rgiType[], 			// data types of the columns.
		const void	*rgpbBuf[], 			// pointers to where the data will be stored.
		const ULONG cbBuf[],				// sizes of the data buffers.
		ULONG		pcbBuf[],				// size of data available to be returned.
		HRESULT 	rgResult[], 			// [in] CLDB_S_NULL array [out] HRESULT array.
		const ULONG	*rgFieldMask) = 0;		// IsOrdinalList(iCols) 
											//	? an array of 1 based ordinals
											//	: a bitmask of columns




//*****************************************************************************
//
//********** Query functions.
//
//*****************************************************************************

	virtual HRESULT STDMETHODCALLTYPE GetRecordCount( // Return code.
		TABLEID 	tableid,				// Which table to work on.
		ULONG		*piCount) = 0;			// Not including deletes.

	virtual HRESULT STDMETHODCALLTYPE GetRowByOid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		OID 		_oid,					// Value for keyed lookup.
		ULONG		iColumn,				// 1 based column number (logical).
		void		**ppStruct) = 0;		// Return pointer to record.

	virtual HRESULT STDMETHODCALLTYPE GetRowByRID( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		rid,					// Record id.
		void		**ppStruct) = 0;		// Return pointer to record.

	virtual HRESULT STDMETHODCALLTYPE GetRIDForRow( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		const void	*pRecord,				// The record we want RID for.
		ULONG		*pirid) = 0;			// Return the RID for the given row.

	virtual HRESULT STDMETHODCALLTYPE GetRowByColumn( // S_OK, CLDB_E_RECORD_NOTFOUND, error.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pData, 				// User data.
		ULONG 		cbData, 				// Size of data (blobs)
		DBTYPE		iType,					// What type of data given.
		void		*rgRecords[],			// Return array of records here.
		int 		iMaxRecords,			// Max that will fit in rgRecords.
		RECORDLIST	*pRecords,				// If variable rows desired.
		int 		*piFetched) = 0;		// How many records were fetched.

//*****************************************************************************
// This query function allows you to do lookups on one or more column at a
// time.  It does not expose the full OLE DB view-filter mechanism which is
// very flexible, but rather exposes multiple column AND conditions with
// equality.  A record must match all of the criteria to be returned to
// in the cursor.
//
// User data - For each column, rgiColumn, rgpbData, and rgiType contain the
//		pointer information to the user data to filter on.
//
// Query hints - Queries will run faster if it is known that some of the
//		columns are indexed.  While there is code in the engine to scan query
//		lists for target indexes, this internal function bypasses that code in
//		favor of performance.  If you know that a column is a RID or PK, or that
//		there is an index, then these columns need to be the first set passed
//		in.  Fill out a QUERYHINT and pass this value in.  Pass NULL if you
//		know there is no index information, and the table will be scanned.
//
//		Note that you may follow indexes columns with non-indexed columns,
//		in which case all records in the index are found first, and then those
//		are scanned for the rest of the criteria.
//
// Returned cursor - Data may be returned in two mutually exclusive ways:
//		(1) Pass an array of record pointers in rgRecords and set iMaxRecords
//			to the count of this array.  Only that many rows are brought back.
//			This requires to heap allocations and is good for cases where you
//			can predict cardinality up front.
//		(2) Pass the address of a CRCURSOR to get a dynamic list.  Then use
//			the cursor functions on this interface to fetch data and close
//			the cursor.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE QueryByColumns( // S_OK, CLDB_E_RECORD_NOTFOUND, error.
		TABLEID 	tableid,				// Which table to work with.
		const QUERYHINT *pQryHint,			// What index to use, NULL valid.
		int 		iColumns,				// How many columns to query on.
		const ULONG rgiColumn[],			// 1 based column numbers.
		const DBCOMPAREOP rgfCompare[], 	// Comparison operators, NULL means ==.
		const void	*rgpbData[],			// User data.
		const ULONG rgcbData[], 			// Size of data (blobs)
		const DBTYPE rgiType[], 			// What type of data given.
		void		*rgRecords[],			// Return array of records here.
		int 		iMaxRecords,			// Max that will fit in rgRecords.
		CRCURSOR	*psCursor,				// Buffer for the cursor handle.
		int 		*piFetched) = 0;		// How many records were fetched.

	virtual HRESULT STDMETHODCALLTYPE OpenCursorByColumn( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pData, 				// User data.
		ULONG		cbData, 				// Size of data (blobs)
		DBTYPE		iType,					// What type of data given.
		CRCURSOR	*psCursor) = 0; 		// Buffer for the cursor handle.



//*****************************************************************************
//
//********** Cursor manipulation functions.
//
//*****************************************************************************


//*****************************************************************************
// Reads the next set of records from the cursor into the given buffer.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE ReadCursor(// Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		void		*rgRecords[],			// Return array of records here.
		int 		*piRecords) = 0;		// Max that will fit in rgRecords.

//*****************************************************************************
// Move the cursor location to the index given.  The next ReadCursor will start
// fetching records at that index.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE MoveTo( // Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		ULONG		iIndex) = 0;			// New index.

//*****************************************************************************
// Get the count of items in the cursor.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetCount( // Return code.
		CRCURSOR	*psCursor,				// The cursor handle.
		ULONG		*piCount) = 0;			// Return the count.

//*****************************************************************************
// Close the cursor and clean up the resources we've allocated.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE CloseCursor(// Return code.
		CRCURSOR	*psCursor) = 0; 		// The cursor handle.



//*****************************************************************************
//
//********** Singleton get and put functions for heaped data types.
//
//*****************************************************************************

	virtual HRESULT STDMETHODCALLTYPE GetStringUtf8( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPCSTR		*pszOutBuffer) = 0; 	// Where put string pointer.

	virtual HRESULT STDMETHODCALLTYPE GetStringA( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPSTR		szOutBuffer,			// Where to write string.
		int 		cchOutBuffer,			// Max size, including room for \0.
		int 		*pchString) = 0;		// Size of string is put here.

	virtual HRESULT STDMETHODCALLTYPE GetStringW( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		LPWSTR		szOutBuffer,			// Where to write string.
		int 		cchOutBuffer,			// Max size, including room for \0.
		int 		*pchString) = 0;		// Size of string is put here.

	virtual HRESULT STDMETHODCALLTYPE GetBstr( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		BSTR		*pBstr) = 0;			// Output for bstring on success.

	virtual HRESULT STDMETHODCALLTYPE GetBlob( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		BYTE		*pOutBuffer,			// Where to write blob.
		ULONG		cbOutBuffer,			// Size of output buffer.
		ULONG		*pcbOutBuffer) = 0; 	// Return amount of data available.

	virtual HRESULT STDMETHODCALLTYPE GetBlob( // Return code.
		TABLEID		tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		const BYTE	**ppBlob,				// Pointer to blob.
		ULONG		*pcbSize) = 0;			// Size of blob.

	virtual HRESULT STDMETHODCALLTYPE GetOid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		OID 		*poid) = 0; 			// Return id here.

	virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		VARIANT 	*pValue) = 0;			// The variant to write.

	// Retrieve a variant column that contains a blob.
	virtual HRESULT STDMETHODCALLTYPE GetVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		const void	**ppBlob,				// Put pointer to blob here.
		ULONG		*pcbSize) = 0;			// Put Size of blob.

	virtual HRESULT STDMETHODCALLTYPE GetVARIANTType( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		VARTYPE 	*pType) = 0;			// Put variant type here.

	virtual HRESULT STDMETHODCALLTYPE GetGuid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		const void	*pRecord,				// Record with data.
		GUID		*pGuid) = 0;			// Return guid here.

	virtual HRESULT STDMETHODCALLTYPE IsNull( // S_OK yes, S_FALSE no.
		TABLEID 	tableid,				// Which table to work with.
		const void	*pRecord,				// Record with data.
		ULONG		iColumn) = 0;			// 1 based column number (logical).

	virtual HRESULT STDMETHODCALLTYPE PutStringUtf8( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCSTR		szString,				// String we are writing.
		int 		cbBuffer) = 0;			// Bytes in string, -1 null terminated.

	virtual HRESULT STDMETHODCALLTYPE PutStringA( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCSTR		szString,				// String we are writing.
		int 		cbBuffer) = 0;			// Bytes in string, -1 null terminated.

	virtual HRESULT STDMETHODCALLTYPE PutStringW( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		LPCWSTR 	szString,				// String we are writing.
		int 		cbBuffer) = 0;			// Bytes (not characters) in string, -1 null terminated.

	virtual HRESULT STDMETHODCALLTYPE PutBlob( // Return code.
		TABLEID		tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const BYTE	*pBuffer,				// User data.
		ULONG		cbBuffer) = 0;			// Size of buffer.

	virtual HRESULT STDMETHODCALLTYPE PutOid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		OID 		oid) = 0;				// Return id here.

	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const VARIANT *pValue) = 0; 		// The variant to write.

	// Store a blob in a variant column.
	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		const void	*pBuffer,				// User data.
		ULONG		cbBuffer) = 0;			// Size of buffer.

	virtual HRESULT STDMETHODCALLTYPE PutVARIANT( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		VARTYPE 	vt, 					// Type of data.
		const void	*pValue) = 0;			// The actual data.

	virtual HRESULT STDMETHODCALLTYPE PutGuid( // Return code.
		TABLEID 	tableid,				// Which table to work with.
		ULONG		iColumn,				// 1 based column number (logical).
		void		*pRecord,				// Record with data.
		REFGUID 	guid) = 0;				// Guid to put.

	virtual void STDMETHODCALLTYPE SetNull(
		TABLEID 	tableid,				// Which table to work with.
		void		*pRecord,				// Record with data.
		ULONG		iColumn) = 0;			// 1 based column number (logical).

	virtual HRESULT STDMETHODCALLTYPE DeleteRowByRID(
		TABLEID 	tableid,				// Which table to work with.
		ULONG		rid) = 0;				// Record id.

	virtual HRESULT STDMETHODCALLTYPE GetCPVARIANT( // Return code.
		USHORT		ixCP,					// 1 based Constant Pool index.
		VARIANT 	*pValue) = 0;			// Put the data here.

	virtual HRESULT STDMETHODCALLTYPE AddCPVARIANT( // Return code.
		VARIANT 	*pValue,				// The variant to write.
		ULONG		*pixCP) = 0;			// Put 1 based Constant Pool index here.


//*****************************************************************************
//
//********** Schema functions.
//
//*****************************************************************************


//*****************************************************************************
// Add a refernece to the given schema to the database we have open right now
// You must have the database opened for write for this to work.  If this
// schema extends another schema, then that schema must have been added first
// or an error will occur.	It is not an error to add a schema when it was
// already in the database.
//
// Adding a new version of a schema to the current file is not supported in the
// '98 product.  In the future this ability will be added and will invovle a
// forced migration of the current file into the new format.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SchemaAdd( // Return code.
		const COMPLIBSCHEMABLOB *pSchema) = 0;	// The schema to add.

//*****************************************************************************
// Deletes a reference to a schema from the database.  You must have opened the
// database in write mode for this to work.  An error is returned if another
// schema still exists in the file which extends the schema you are trying to
// remove.	To fix this problem remove any schemas which extend you first.
// All of the table data associated with this schema will be purged from the
// database on Save, so use this function very carefully.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SchemaDelete( // Return code.
		const COMPLIBSCHEMABLOB *pSchema) = 0;	// The schema to add.

//*****************************************************************************
// Returns the list of schema references in the current database.  Only
// iMaxSchemas can be returned to the caller.  *piTotal tells how many were
// actually copied.  If all references schemas were returned in the space
// given, then S_OK is returned.  If there were more to return, S_FALSE is
// returned and *piTotal contains the total number of entries the database has.
// The caller may then make the array of that size and call the function again
// to get all of the entries.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SchemaGetList( // S_OK, S_FALSE, or error.
		int 		iMaxSchemas,			// How many can rgSchema handle.
		int 		*piTotal,				// Return how many we found.
		COMPLIBSCHEMADESC rgSchema[]) = 0;	// Return list here.

//*****************************************************************************
// Before you can work with a table, you must retrieve its TABLEID.  The
// TABLEID changes for each open of the database.  The ID should be retrieved
// only once per open, there is no check for a double open of a table.
// Doing multiple opens will cause unpredictable results.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE OpenTable( // Return code.
		const COMPLIBSCHEMA *pSchema,		// Schema identifier.
		ULONG		iTableNum,				// Table number to open.
		TABLEID 	*pTableID) = 0; 		// Return ID on successful open.


//*****************************************************************************
//
//********** Save/open functions.
//
//*****************************************************************************

//*****************************************************************************
// Figures out how big the persisted version of the current scope would be.
// This is used by the linker to save room in the PE file format.  After
// calling this function, you may only call the SaveToStream or Save method.
// Any other function will product unpredictable results.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetSaveSize(
		CorSaveSize fSave,					// cssQuick or cssAccurate.
		DWORD		*pdwSaveSize) = 0;		// Return size of saved item.

	virtual HRESULT STDMETHODCALLTYPE SaveToStream(// Return code.
		IStream 	*pIStream) = 0; 		// Where to save the data.

	virtual HRESULT STDMETHODCALLTYPE Save( // Return code.
		LPCWSTR 	szFile) = 0;			// Path for save.


//*****************************************************************************
// After a successful open, this function will return the size of the in-memory
// database being used.  This is meant to be used by code that has opened a
// shared memory database and needs the exact size to init the system.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetDBSize( // Return code.
		ULONG		*pcbSize) = 0;			// Return size on success.


//*****************************************************************************
// Call this method only after calling LightWeightClose.  This method will try
// to reaquire the shared view of a database that was given on the call to
// OpenComponentLibrarySharedEx.  If the data is no longer available, then an
// error will result and no data is valid.	If the memory cannot be loaded into
// exactly the same address range as on the open, CLDB_E_RELOCATED will be
// returned.  In either of these cases, the only valid operation is to free
// this instant of the database and redo the OpenComponentLibrarySharedEx.	There
// is no automatic relocation scheme in the engine.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE LightWeightOpen() = 0;


//*****************************************************************************
// This method will close any resources related to the file or shared memory
// which were allocated on the OpenComponentLibrary*Ex call.  No other memory
// or resources are freed.	The intent is solely to free lock handles on the
// disk allowing another process to get in and change the data.  The shared
// view of the file can be reopened by calling LightWeightOpen.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE LightWeightClose() = 0;



//*****************************************************************************
//
//********** Misc.
//
//*****************************************************************************

	virtual HRESULT STDMETHODCALLTYPE NewOid(
		OID *poid) = 0;

//*****************************************************************************
// Return the current total number of objects allocated.  This is essentially
// the highest OID value allocated in the system.  It does not look for deleted
// items, so the count is approximate.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetObjectCount(
		ULONG		*piCount) = 0;

//*****************************************************************************
// Allow the user to create a stream that is independent of the database.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE OpenSection(
		LPCWSTR 	szName, 				// Name of the stream.
		DWORD		dwFlags,				// Open flags.
		REFIID		riid,					// Interface to the stream.
		IUnknown	**ppUnk) = 0;			// Put the interface here.

//*****************************************************************************
// Allow the user to query write state.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE GetOpenFlags(
		DWORD		*pdwFlags) = 0;

//*****************************************************************************
// Allow the user to provide a custom handler.  The purpose of the handler
//  may be determined dynamically.  Initially, it will be for save-time 
//  callback notification to the caller.
//*****************************************************************************
	virtual HRESULT STDMETHODCALLTYPE SetHandler(
		IUnknown	*pHandler) = 0;			// The handler.



};



//*****************************************************************************
// This is a light weight interface that allows an ICR client to get at the
// meta data for a schema.	One can also retrieve this information using the
// format OLE DB interfaces, such as IDBSchemaRowset.
//*****************************************************************************
interface IComponentRecordsSchema : public IUnknown
{

//*****************************************************************************
// Lookup the given table and return its table definition information in
// the given struct.
//*****************************************************************************
	virtual HRESULT GetTableDefinition( 	// Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		ICRSCHEMA_TABLE *pTableDef) = 0;	// Return table definition data.

//*****************************************************************************
// Lookup the list of columns for the given table and return description of
// each of them.  If GetType is ICRCOLUMN_GET_ALL, then this function will
// return the data for each column in ascending order for the table in the
// corresponding rgColumns element.  If it is ICRCOLUMN_GET_BYORDINAL, then
// the caller has initialized the Ordianl field of the column structure to
// indicate which columns data is to be retrieved.	The latter allows for ad-hoc
// retrieval of column definitions.
//*****************************************************************************
	virtual HRESULT GetColumnDefinitions(	// Return code.
		ICRCOLUMN_GET GetType,				// How to retrieve the columns.
		TABLEID 	TableID,				// Return ID on successful open.
		ICRSCHEMA_COLUMN rgColumns[],		// Return array of columns.
		int 		ColCount) = 0;			// Size of the rgColumns array, which
											//	should always match count from GetTableDefinition.

//*****************************************************************************
// Return the description of the given index into the structure.  See the
// ICRSCHEMA_INDEX structure definition for more information.
//*****************************************************************************
	virtual HRESULT GetIndexDefinition( 	// Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		LPCWSTR 	szIndex,				// Name of the index to retrieve.
		ICRSCHEMA_INDEX *pIndex) = 0;		// Return index description here.
											//	should always match count from GetTableDefinition.

//*****************************************************************************
// Return the description of the given index into the structure.  See the
// ICRSCHEMA_INDEX structure definition for more information.
//*****************************************************************************
	virtual HRESULT GetIndexDefinitionByNum( // Return code.
		TABLEID 	TableID,				// Return ID on successful open.
		int 		IndexNum,				// 0 based index to return.
		ICRSCHEMA_INDEX *pIndex) = 0;		// Return index description here.

//*****************************************************************************
// The following three methods allow client to pass in column and index
// definitions, and then get the schema blobs back.
//*****************************************************************************
	virtual HRESULT CreateTableEx(					// Return code.
		LPCWSTR		szTableName,			// Name of new table to create.
		int			iColumns,				// Columns to put in table.
		ICRSCHEMA_COLUMN	rColumnDefs[],	// Array of column definitions.
		USHORT		usFlags, 				// Create values for flags.
		USHORT		iRecordStart,			// Start point for records.
		TABLEID		tableid,				// Hard coded ID if there is one.
		BOOL		bMultiPK) = 0;				// The table has multi-column PK.

	virtual HRESULT CreateIndexEx(					// Return code.
		LPCWSTR		szTableName,					// Name of table to put index on.
		ICRSCHEMA_INDEX	*pInIndexDef,				// Index description.
		const DBINDEXCOLUMNDESC rgInKeys[] ) = 0;		// Which columns make up key.

	virtual HRESULT GetSchemaBlob(					//Return code.
		ULONG* cbSchemaSize,				//schema blob size
		BYTE** pSchema,						//schema blob
		ULONG* cbNameHeap,					//name heap size
		HGLOBAL*  phNameHeap) = 0;				//name heap blob
};


#if 0 // left to show user section interface example
//*****************************************************************************
// Interface definition of a user section for Call Signatures.
//*****************************************************************************
struct _COR_CALLDESCR;
interface ICallDescrSection : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE InsertCallDescr(
		ULONG		ulDescr,				// Index of Descr.
    	ULONG		ulGroup,				// Which group is Descr in?
		ULONG		cDescr,					// Count of descrs to insert.
		_COR_CALLDESCR  **ppDescr) = 0;		// Put pointer to first one here.

    virtual HRESULT STDMETHODCALLTYPE AppendCallDescr(
    	ULONG		ulGroup,				// Which group is Descr in?
		ULONG		*pulDescr,				// Put relative index of first one here.
		_COR_CALLDESCR  **ppDescr) = 0;		// Put pointer to first one here.

    virtual HRESULT STDMETHODCALLTYPE GetCallDescr(
		ULONG		ulDescr,				// Index of Descr.
    	ULONG		ulGroup,				// Which group is Descr in?
		_COR_CALLDESCR  **ppDescr) = 0;		// Put pointer here.

    virtual HRESULT STDMETHODCALLTYPE GetCallDescrGroups(
		ULONG		*pcGroups,				// How many groups?
    	ULONG		**pprcGroup) = 0;		// Count in each group.

    virtual HRESULT STDMETHODCALLTYPE AddCallSig(
        const void  *pVal,                  // The value to store.
        ULONG       iLen,                   // Count of bytes in signature.
        ULONG       *piOffset) = 0;         // The offset of the new item.

    virtual HRESULT STDMETHODCALLTYPE GetCallSig(
        ULONG       iOffset,                // Offset of the item to get.
        const void  **ppVal,                // Put pointer to Signature here.
        ULONG       *piLen) = 0;            // Put length of signature here.

    virtual HRESULT STDMETHODCALLTYPE GetCallSigBuf(
        const void  **ppVal) = 0;           // Put pointer to Signatures here.
};
#endif
//*****************************************************************************
// These interfaces provide a thread safe version of the ICR interfaces.  The
// v-table is exactly the same as the not TS versions.	Calls through the 
// TS interface will serialize calls as required.  To get the TS version,
// simply do a QueryInterface on the ICR pointer returned from the open/create
// function.
//*****************************************************************************
typedef IComponentRecordsSchema ITSComponentRecordsSchema;
typedef IComponentRecords ITSComponentRecords;



// Internal versions of the load functions.

extern "C" {

HRESULT STDMETHODCALLTYPE CreateComponentLibraryEx(
	LPCWSTR szName,
	long fFlags,
	IComponentRecords **ppIComponentRecords,
    LPSECURITY_ATTRIBUTES pAttributes);
	

HRESULT STDMETHODCALLTYPE OpenComponentLibraryEx(
	LPCWSTR szName,
	long fFlags,
	IComponentRecords **ppIComponentRecords,
    LPSECURITY_ATTRIBUTES pAttributes);


//*****************************************************************************
// This version of open will open the component library allows a shared copy
// of the database to be used.	A shared copy reduces overall overhead on the
// system by keeping just one view of the data which can be efficiently shared
// into other processes.
//
// CREATING THE INITIAL VIEW:
//	To do the initial open, pass the name of the file and the DBPROP_TMODEF_SMEMCREATE
//	flag.  This will open the data file on disk and create a file mapping with
//	the name contained in szSharedMemory.
//
// OPENING SECONDARY VIEWS:
//	To open a shared view already in memory, pass the DBPROP_TMODEF_SMEMOPEN
//	flag.  The view must already exist in memory as a shared object.  If not
//	found, an error will occur.
//
// LIGHTWEIGHT CLOSE:
//	A secondary view can be closed by calling LightWeightClose which will free
//	the shared memory handle but leave everything else intact.	Then the
//	database can be "rebound" to the shared memory by calling the
//	LightWeightOpen method.  See these methods in the ICR docs for details.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE OpenComponentLibrarySharedEx(
	LPCWSTR 	szName, 				// Name of file on create, NULL on open.
	LPCWSTR 	szSharedMemory, 		// Name of shared memory.
	ULONG		cbSize, 				// Size of shared memory, 0 on create.
	LPSECURITY_ATTRIBUTES pAttributes,	// Security token.
	long		fFlags, 				// Open modes, must be read only.
	IComponentRecords **ppIComponentRecords); // Return database on success.


HRESULT STDMETHODCALLTYPE OpenComponentLibraryOnStreamEx(
	IStream *pIStream,
	long fFlags,
	IComponentRecords **ppIComponentRecords);


HRESULT STDMETHODCALLTYPE OpenComponentLibraryOnMemEx(
	ULONG cbData,
	LPCVOID pbData,
	IComponentRecords **ppIComponentRecords);


} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\iregnode.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// NOTE: IRegNode, IRegNodeDispenser, GetRegNodeDispenser declarations.

// =======================================================================
/* RegNode.DLL:
   NOTE:	You need to include vencodes.H in your project to name the 
  			hresult	error codes returned from these interfaces and methods.

   NOTE:	RegNode needs the appropriate MEC dll in an established path;
  			otherwise you will receive the following error on startup:
  			OleMainThreadWndNam: Test.exe - Unable To Locate DLL
  			The dynamic link library MEC*.DLL could not be found in
  			the specified path.

   NOTE:	To use GetRegNodeDispenser you must to link with regnode.LIB.

   NOTE:	Programmatic errors are only caught by assertions in the debug
  			build of the RegNode DLL.  Thus you need to develop with it.
			HRESULT's are only returned for non-programmatic failures.
*/

#ifndef __IREGNODE_H
#	define __IREGNODE_H

DEFINE_GUID(IID_IRegNode,0x578B6A8EL,0x628C,0x11CF,0x9D,0xD9,0x00,0xAA,0x00,0xB6,0x77,0x0A);

#undef INTERFACE
#define INTERFACE IRegNode

#define wszRN_LOCAL_MACHINE		(L"?")
#define wszRN_UNNAMED_VALUE		(L"\\")
#define wszRN_CURRENT_KEY		(L"\\")

// brianbec: Try to get the compiler to catch anyone compiled ANSI/MBCS and trying
//           to use the following symbols.  It is a catastrophe for a user of this
//           interface to call it with CHARs if the implementation expects
//           WCHARs.

#ifdef UNICODE
	#define tszRN_LOCAL_MACHINE		(_T("?"))
	#define tszRN_UNNAMED_VALUE		(_T("\\"))
	#define tszRN_CURRENT_KEY		(_T("\\"))
#endif

#define samRN_SAME				(0xFFFF)

// =======================================================================
/* IRegNode:
	NOTE:	The registry is a hierarchical database.  However, it has two
			kinds of nodes: keys and named values.  A key can have any
			number of both child keys and child named values, but named
			values are always leaves.  Each key may have a special value
			called the unnamed value.  The original Win16 registry
			had only keys (each with an unnamed value).  Named values were 
			introduced later as a much less expensive alternative to keys.

			IRegNode necessarily reflects this "two kinds of nodes" design:
			When you move to a descendant you always specify both the 
			key path and the named value (the unnamed value is refered to
			as wszRN_UNNAMED_VALUE).  Also, when counting, enumerating, or
			deleting child nodes, you specify whether the nodes are
			keys or values.  IRegNode is conceptually designed such
			that a registry node is always a combination of a key and named
			value (possibly the unnamed value).  You can navigate upward
			from any registry node, but can only navigate downward from
			the key-unnamed value combination.

			Interface layers above IRegNode can and should remove the
			"two kinds of nodes" design from their interface.

	NOTE:	WARNING: The registry does not support locking so keys you are 
			working with via a RegNode can be changed by someone else!

	NOTE:	You create a registry node via either
			IRegNodeDispenser::GetRegNodeFromRegistry or 
			IRegNode::GetAnotherRegNode.  Both methods require you specify
			the desired security access mask.  That SAM is used until you
			Release the registry node, including to navigate downward and
			upward through the registry.  Thus your navigation will fail
			for security reasons if your SAM is not allowed at that point.
*/
DECLARE_INTERFACE_(IRegNode, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

// -------------------------------
// IRegNode samsara methods:
// -------------------------------

	// =======================================================================
    STDMETHOD (GetAnotherRegNode)			(THIS_ REGSAM i_regsam, IRegNode FAR* FAR* o_ppIRN) PURE;
	/* IRegNode::GetAnotherRegNode: Get a copy of the current registry node.
		NOTE:	The security access mask lets you get a copy of the registry node
				with greater or lesser security privileges.
		NOTE:	See RegOpenKeyEx for the supported security access masks.
		NOTE:	samRN_SAME is also allowed as a security access mask,
				meaning use the same one as the current registry node.
		HR's:	E_CONNECT:	Connecting the new registry node to its registry key path failed.
		
		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		IRegNode*			pIRN2;
*>		IRegNode*			pIRN3;
*>		
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes", wszRN_UNNAMED_VALUE, KEY_ALL_ACCESS, &pIRN);
*>				pIRN->GetAnotherRegNode (KEY_READ, &pIRN2); // pIRN2 is also at L"Microsoft" with KEY_READ privilege.
*>				pIRN->GetAnotherRegNode (samRN_SAME, &pIRN3); // pIRN3 is also at L"Microsoft" with KEY_ALL_ACCESS.
*>				pIRN2->Release ();
*>				pIRN3->Release ();
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

	// =======================================================================
    STDMETHOD (UpdateStore)					(THIS) PURE;
	/* IRegNode::UpdateStore:
		Flush all changes to this registry node and its descendants to disk.
		NOTE:	This method will not return until changes have been written.
		NOTE:	This method calls RegFlushKey whose exact behavior is not 
				documented, but bryanwi informed me the call flushes the
				hive to which the key belongs (hives being major registry
				subtrees).  Thus the call can be very expensive and should 
				not be used extensively.
		HR's:	E_FAIL:		The write failed.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services", wszRN_UNNAMED_VALUE, KEY_ALL_ACCESS, &pIRN);
*>				pIRN->UpdateStore (); // The entire HKEY_LOCAL_MACHINE\SYSTEM hive is flushed.
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
*>
	*/

	// =======================================================================
	STDMETHOD (NotifyOnChange)				(THIS_ HANDLE i_hEvent) PURE;
	/* IRegNode::NotifyOnChange:
		Asynchrnously signal the event on any change to this registry node's
		key or descendants.
		NOTE:	Using this method requires a registry node whose sole purpose
				is notification.  You must not call any other methods on that
				registry node except Release.
		NOTE:	Notifications will continue until Release is called, with a
				final notification being sent after Release as a side-effect
				of releasing the registry node.
		NOTE:	This method only supports notification from the local registry.
		HR's:	E_FAIL:		The asynchronous notification setup failed,
							likely either because the event was invalid or
							the registry node is connected to a remote registry.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		HANDLE				hev;
*>		
*>		GetRegNodeDispenser (&pIRND);
*>			hev = CreateEvent (NULL, FALSE, FALSE, NULL);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\CLSID", wszRN_UNNAMED_VALUE, KEY_READ, &pIRN);
*>				pIRN->NotifyOnChange (hev); // Changes occuring at CLSID or any of its descendants.
*>				WaitForSingleObject (hev, 10000); // Thread waits for a change for 10 sec.
*>			pIRN->Release (); // Event is signalled once more by the registry.
*>			CloseHandle (hev);
*>		pIRND->Release ();
*>
	*/

	// =======================================================================
	STDMETHOD (DeleteChildValue)			(THIS_ LPCWSTR i_wszValueName) PURE;
	STDMETHOD (DeleteChildKeyAndDescendants)(THIS_ LPCWSTR i_wszKey) PURE;
	/*	IRegNode::DeleteChildValue:
		IRegNode::DeleteChildKeyAndDescendants:
			Delete a child of this registry node.
		NOTE:	DeleteChildValue deletes a named value.
				(Specifying wszRN_UNNAMED_VALUE only deletes the content of the 
				unnamed value (and not the key name itself), whereas specifying 
				a named value deletes both its content and name.)
		NOTE:	DeleteChildKeyAndDescendants deletes a child key and all its descendants recursively.
				(You must specify a child key.  wszRN_CURRENT_KEY is not allowed.)
		NOTE:	You need to first navigate to the parent of the child you want to delete.
		HR's:	DeleteChildValue:
				E_DELETE:	The child value could not be deleted.
				E_SET:		The unnamed value was deleted but improperly set
				DeleteChildKeyAndDescendants:
				E_READ:		One of the keys could not be enumerated.
				E_OPEN:		One of the keys could not be opened.
				E_DELETE:	One of the keys could not be deleted.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes", wszRN_UNNAMED_VALUE, KEY_ALL_ACCESS, &pIRN);
*>				pIRN->MoveToDescendantOrCreate (L"FooFoo\\FooFoo", L"Bar");
*>				pIRN->MoveToParentKeyOfValue ();
*>				pIRN->DeleteChildValue (L"Bar");
*>				pIRN->MoveToParentKeyOfKey ();
*>				pIRN->MoveToParentKeyOfKey ();
*>				pIRN->DeleteChildKeyAndDescendants (L"FooFoo");
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

// -------------------------------
// IRegNode property methods:
// -------------------------------

	// =======================================================================
    STDMETHOD_ (void, GetName)				(THIS_ LPWSTR io_wsz, ULONG i_ulc) PURE;
	/* IRegNode::GetName: Get the name of this registry node.
		NOTE:	SetName is not supported.  The only way to change a key or value name
				is to create the new name at the same level, copy everything from the 
				old to new name, then delete the old name with everything beneath it.
				If you have often-changing names then store them as content instead.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		WCHAR				wsz [50];
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\comfile", wszRN_UNNAMED_VALUE, KEY_READ, &pIRN);
*>				pIRN->GetName (wsz, 50);
*>				assert (0 == lstrcmpiW(wsz, L"comfile"));
*>				pIRN->MoveToDescendantOrFail (wszRN_CURRENT_KEY, L"EditFlags");
*>				pIRN->GetName (wsz, 50);
*>				assert (0 == lstrcmpiW(wsz, L"EditFlags"));
*>				pIRN->MoveToParentKeyOfValue ();
*>				pIRN->GetName (wsz, 50);
*>				assert (0 == lstrcmpiW(wsz, L"comfile"));
*>				pIRN->MoveToParentKeyOfKey ();
*>				pIRN->GetName (wsz, 50);
*>				assert (0 == lstrcmpiW(wsz, L"Classes"));
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

	// =======================================================================
    STDMETHOD_ (void, GetType)				(THIS_ DWORD FAR* io_pdwType) PURE;
	/* IRegNode::GetType: Get the type of the content of this registry node.
		NOTE:	The set of possible types is documented in RegQueryValueEx.
				REG_NONE means the named value has no content.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		DWORD				dwType;
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE", L"Verify", KEY_READ, &pIRN);
*>				pIRN->GetType (&dwType);
*>				assert (REG_DWORD == dwType);
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

	// =======================================================================
	STDMETHOD_ (void, GetSize)				(THIS_ ULONG FAR* io_pulcb) PURE;
	/* IRegNode::GetSize: Get the size of the content of this registry node.
		NOTE:	The size is always in bytes and for strings includes the null-terminator.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		ULONG				ulcb;
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE", L"Verify", KEY_READ, &pIRN);
*>				pIRN->GetSize (&ulcb);
*>				assert (4 == ulcb);
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

	// =======================================================================
    STDMETHOD (GetContent)					(THIS_ DWORD i_dwType, ULONG i_ulcbSize, BYTE FAR* io_pbContent) PURE;
	/* IRegNode::GetContent: Get the content of this registry node as an array of bytes.
		NOTE:	If you are at a named value of a key, GetContent gets the content of
				that named value.  If you are at the key itself, GetContent gets the
				content of unnamed value.
		NOTE:	Calling GetContent without correct type and size is a programming error.
				Call GetType and GetSize first.
		NOTE:	Calling GetContent when either the type is REG_NONE or the size is 0 
				is a programming error.
		NOTE:	Since GetContent supplies untyped data it requires you to 
				confirm that you know the type and size of the data.
		HR's:	E_UNEXPECTED:	The content type or size was changed by someone else.
				E_GET:			Getting the content failed.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		DWORD				dwContent;
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE", L"Verify", KEY_READ, &pIRN);
*>				pIRN->GetContent (REG_DWORD, 4, (BYTE*) &dwContent);
*>				assert (0 == dwContent);
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

	// =======================================================================
    STDMETHOD (SetTypeSizeContent)			(THIS_ DWORD i_dwType, ULONG i_ulcbSize, const BYTE FAR* i_pbContent) PURE;
	/* IRegNode::SetTypeSizeContent: Set the type, size, and content of the registry node.
		NOTE: Size must be count of bytes, and for strings must include the null terminator.
		HR's:	E_SET:		Setting either the type, size, and content failed.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		WCHAR				wszBAR [] = L"BarBarBar";
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes", wszRN_UNNAMED_VALUE, KEY_ALL_ACCESS, &pIRN);
*>				pIRN->MoveToDescendantOrCreate (L"FooFooFoo", wszRN_UNNAMED_VALUE);
*>				pIRN->SetTypeSizeContent (REG_SZ, (lstrlenW(wszBAR) + 1) * sizeof WCHAR, (const BYTE*) wszBAR);
*>				pIRN->MoveToParentKeyOfKey ();
*>				pIRN->DeleteChildKeyAndDescendants (L"FooFooFoo");
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

	// =======================================================================
	STDMETHOD (GetNumberOfChildren)			(THIS_ ULONG FAR* io_pulcKeys, ULONG FAR* io_pulcValueNames) PURE;
	/* IRegNode::GetNumberOfChildren: Get the number of child keys and values of the registry node.
		NOTE: If you are at named value, both numbers will be 0.
		NOTE: You can specify NULL for either the number of keys or values.
		HR's:	E_GET:		Querying for the number of children failed.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		ULONG				ulcKeys, ulcValues;
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", wszRN_UNNAMED_VALUE, KEY_ALL_ACCESS, &pIRN);
*>				pIRN->GetNumberOfChildren (&ulcKeys, &ulcValues);
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

	// =======================================================================
	STDMETHOD (GetSecurity)					(THIS_ SECURITY_INFORMATION i_secinfo, PSECURITY_DESCRIPTOR io_psecdes, LPDWORD io_pcbsecdes) PURE;
	STDMETHOD (SetSecurity)					(THIS_ SECURITY_INFORMATION i_secinfo, PSECURITY_DESCRIPTOR i_psecdes) PURE;
	/*	IRegNode::GetSecurity:
		IRegNode::SetSecurity:
			Get and set the security of the current registry node.
		NOTE:	GetSecurity returns E_EXCEEDED and sets the byte count to the
				required size if the security descriptor buffer is too small.
		HR's:	E_GET/E_SET:	Getting or setting security failed.
				GetSecurity:
				E_EXCEEDED:		(Programmatic error)
								The security description buffer is too small.
								The byte count is set to the requisite size.
		EG:		See Dave Reed.
	*/

// -------------------------------
// IRegNode navigation methods:
// -------------------------------

	// =======================================================================
	STDMETHOD (MoveToDescendantOrFail)		(THIS_ LPCWSTR i_wszKeyPath, LPCWSTR i_wszValueName) PURE;
	STDMETHOD (MoveToDescendantOrReply)		(THIS_ LPCWSTR i_wszKeyPath, LPCWSTR i_wszValueName) PURE;
	STDMETHOD (MoveToDescendantOrCreate)	(THIS_ LPCWSTR i_wszKeyPath, LPCWSTR i_wszValueName) PURE;
	/*	IRegNode::MoveToDescendantOrFail:
		IRegNode::MoveToDescendantOrReply:
		IRegNode::MoveToDescendantOrCreate:
			Move to the requested descendant of the current registry node.

		NOTE:	If the descendant does not exist: 
				MoveToDescendantOrFail fails,
				MoveToDescendantOrReply returns S_FALSE, and 
				MoveToDescendantOrCreate creates the descendant and then 
				moves to it.
		NOTE:	Any unsuccessful move leaves the registry node unchanged.
		NOTE:	To move to a descendant, you specify its key path and one
				of its named values.  To move to a named value of the 
				current key, specify wszRN_CURRENT_KEY as the key path.
				To move the unnamed value of any key, specify 
				wszRN_UNNAMED_VALUE as the named value.
		NOTE:	MoveToDescendantOrCreate can be used for registry locking.
				First designate a key with an established parent as the 
				lock indicator.  Get a registry node to the parent using
				IRegNodeDispenser::GetRegNodeFromRegistry.  To attempt to
				take the lock, move to the key with MoveToDescendantOrCreate.
				If S_CREATED is returned you have the lock.  Do your work.
				When you are finished, delete the key to release the lock.
				If S_OK is returned someone else has the lock.
				Important! If a crash occurs while a lock is taken the key
				may remain after the crash, leaving the lock incorrectly
				taken.  The key needs deleted to correct the lock.
		HR's:	S_OK/S_CREATED:	The move to descendant succeeded.
				E_OPEN/E_GET:	Opening the key / named value failed.
				MoveToDescendantOrCreate:
				S_CREATED:		The keypath was not found and was created.
				E_CREATE/E_SET:	Creating the key / named value failed.
				MoveToDescendantOrReply:
				S_FALSE:		The key or named value does not exist.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		WCHAR				wszBAR [] = L"BarBarBar";
*>		HRESULT				hr;
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes", wszRN_UNNAMED_VALUE, KEY_ALL_ACCESS, &pIRN);
*>				hr = pIRN->MoveToDescendantOrReply (L"FooFooFoo", wszRN_UNNAMED_VALUE);
*>				assert (SUCCEEDED (hr));
*>				if (S_FALSE == hr)
*>				{
*>					pIRN->MoveToDescendantOrCreate (L"FooFooFoo", wszRN_UNNAMED_VALUE);
*>				}
*>				pIRN->MoveToParentKeyOfKey ();
*>				pIRN->MoveToDescendantOrFail (L"FooFooFoo", wszRN_UNNAMED_VALUE);
*>				pIRN->MoveToParentKeyOfKey ();
*>				pIRN->DeleteChildKeyAndDescendants (L"FooFooFoo");
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

	// =======================================================================
    STDMETHOD (MoveToChildKeyByPosition)	(THIS_ ULONG i_uli) PURE;
	STDMETHOD (MoveToChildValueByPosition)	(THIS_ ULONG i_uli) PURE;
	/*	IRegNode::MoveToChildKeyByPosition:
			Moves the registry node from the unnamed value of the current key to
			the unnamed value of its child key specified by a 0-based index.
		IRegNode::MoveToChildValueByPosition:
			Moves the registry node to one of the values (including the unnamed
			value) of the current key specified by a 0-based index.
		
		NOTE:	Use GetNumberOfChildren to get the number of child keys first.
		NOTE:	Remember that named values (except the unnamed value) are 
				always leaves.  If the registry node is at a named value,
				it must first be moved to the unnamed value via MoveToParent
				before it can be moved to another child key or value.
		NOTE:	Registry keys and named values are not sorted so you cannot
				assume a key or value will be at a specific position.
		HR's:	Errors are the same as MoveToDescendantOrFail plus:
				E_READ:		Enumerating the requested key or value failed.
				
		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		ULONG				ulcKeys, ulcValues;
*>		ULONG				ulcCur;
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", wszRN_UNNAMED_VALUE, KEY_ALL_ACCESS, &pIRN);
*>				pIRN->GetNumberOfChildren (&ulcKeys, &ulcValues);
*>				for (ulcCur = 0; ulcCur < ulcKeys; ulcCur++)
*>				{
*>					pIRN->MoveToChildKeyByPosition (ulcCur);
*>					pIRN->MoveToParentKeyOfKey ();
*>				}
*>				for (ulcCur = 0; ulcCur < ulcValues; ulcCur++)
*>				{
*>					pIRN->MoveToChildValueByPosition (ulcCur);
*>					pIRN->MoveToParentKeyOfValue ();
*>				}
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

	// =======================================================================
    STDMETHOD (MoveToParentKeyOfValue)		(THIS) PURE;
    STDMETHOD (MoveToParentKeyOfKey)		(THIS) PURE;
	/*	IRegNode::MoveToParentKeyOfValue:
		IRegNode::MoveToParentKeyOfKey:
		Move the registry node from its current position to its parent.
		NOTE:	MoveToParentKeyOfValue moves the registry node from the
				current value to its parent key.  The method does nothing
				when we are at the unnamed value, since we are also already
				at the parent key.
		NOTE:	MoveToParentKeyOfKey moves the registry node from the unnamed
				value of the current key to the unnamed value of its parent key.
				Moving above the root key is a programmatic error.
		NOTE:	It is a programming error to call MoveToParentKeyOfKey
				when at a named value (E_INVALID is returned).  First 
				MoveToParentKeyOfValue.  It is a programming error to call
				this method when at a child of a root key (E_UNAVAILABLE
				is returned).  In either case the registry node remains at
				its current position.
		NOTE:	To enumerate the named values of a key, first call
				GetNumberOfChildren to get the number of named values.  To
				enumerate the children call MoveToChildValueByPosition.
				Between each such call, call MoveToParentKeyOfValue.
				The same applies for enumerating keys, except use 
				GetNumberOfChildren to get the number of keys and
				MoveToChildKeyByPosition and MoveToParentKeyOfKey instead.
		HR's:	Errors are the same as MoveToDescendantOrFail plus:
				MoveToParentKeyOfKey: E_COPY: Key copying failed.

		EG:
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>
*>		GetRegNodeDispenser (&pIRND);
*>			pIRND->GetRegNodeFromRegistry (wszRN_LOCAL_MACHINE, HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\comfile", L"EditFlags", KEY_ALL_ACCESS, &pIRN);
*>				pIRN->MoveToParentKeyOfValue (); // moves from the EditFlags value to the unnamed value of the comfile key.
*>				pIRN->MoveToParentKeyOfKey (); // moves from the comfile key to the Classes key.
*>			pIRN->Release ();
*>		pIRND->Release ();
*>
	*/

// -------------------------------
// IRegNode extension methods:
// -------------------------------

	// =======================================================================
	STDMETHOD (CopyChildKeyAndDescendants)(THIS_ LPCWSTR i_wszKey, IRegNode FAR* i_pIRNDest) PURE;
	STDMETHOD (MoveChildKeyAndDescendants)(THIS_ LPCWSTR i_wszKey, IRegNode FAR* i_pIRNDest) PURE;
	/*	IRegNode::CopyChildKeyAndDescendants:
		IRegNode::MoveChildKeyAndDescendants:
		Copy or move the child and all its descendants under the destination regnode.
	*/

	// =======================================================================
	STDMETHOD (FlushCache)() PURE;
	/*	IRegNode::FlushCache:
			Reduce the number of costly RegOpenKeyEx calls by caching hkeys.
		NOTE:	The first call the FlushCache initiates hkey caching; subsequent
				calls clear the accumulated cache of hkeys.
		NOTE:	For iterations over child keys and their descendants, call
				FlushCache before moving to each child key.
	*/

	// =======================================================================
    STDMETHOD_ (void, GetNameSize)	(THIS_ LPWSTR io_wsz, ULONG i_ulc, ULONG * o_ulc) PURE;
	/* IRegNode::GetNameSize: Get the name and sizeof this registry node.
		NOTE:	Does the same thing as GetName, but also returns the real size of the name
	*/

};

DEFINE_GUID(CLSID_RegNode,0x578B6A90L,0x628C,0x11CF,0x9D,0xD9,0x00,0xAA,0x00,0xB6,0x77,0x0A);

#ifdef __cplusplus
class RegNode;
#endif

DEFINE_GUID(IID_IRegNodeDispenser,0x578B6A92L,0x628C,0x11CF,0x9D,0xD9,0x00,0xAA,0x00,0xB6,0x77,0x0A);

/* Definition of interface: IRegNodeDispenser */
#undef INTERFACE
#define INTERFACE IRegNodeDispenser

DECLARE_INTERFACE_(IRegNodeDispenser, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

// -------------------------------
// IRegNodeDispenser methods:
// -------------------------------

	// =======================================================================
	STDMETHOD (GetRegNodeFromRegistry)
	(
		THIS_ 
		LPCWSTR		i_wszHost,		// Host computer name.  Must begin with L"\\\\".  
									// Use wszRN_LOCAL_MACHINE for the local computer.
		HKEY		i_hkeyRoot,		// Registry root key.  Must be either HKEY_LOCAL_MACHINE or HKEY_USERS.
									// NOTE: HKEY_CLASSES_ROOT == HKEY_LOCAL_MACHINE\SOFTWARE\Classes; 
		LPCWSTR		i_wszKeyPath,	// Registry key path.  
									// The path to any key under HKEY_LOCAL_MACHINE or HKEY_USERS; required.
		LPCWSTR		i_wszValueName,	// Any named value of the key.  
									// Specify wszRN_UNNAMED_VALUE for the unnamed value of the key.
		REGSAM		i_regsam,		// Desired security access mask for the key.
									// See RegOpenKeyEx.
		IRegNode**	io_ppIRN
	) PURE;
	/* IRegNodeDispenser::GetRegNodeFromRegistry:
		Get a registry node from the registry.
		NOTE:	If you want to create a registry node that does not exist,
				first call IRegNodeDispenser::GetRegNodeFromRegistry
				on an already existant ancestor, then call 
				IRegNode::MoveToExistingOrNewDescendentByName.
		NOTE:	Each registry node can have a single unnamed value and an
				unlimited number of named values.
				If you do not specify a named value, the unnamed value is
				your current value.  The unnamed value may or may not be empty.
		NOTE:	Errors are the same as IRegNode::MoveToDescendantOrFail, plus:
				E_CONNECT:	Connecting to the requested registry failed.

		EG:	
*>		IRegNodeDispenser*	pIRND;
*>		IRegNode*			pIRN;
*>		HRESULT				hr;
*>
*>		GetRegNodeDispenser (&pIRND);
*>			hr = pIRND->GetRegNodeFromRegistry 
*>			(
*>				L"\\\\rcraig0", 
*>				HKEY_LOCAL_MACHINE, 
*>				L"SOFTWARE\\Classes\\rcfile", 
*>				L"AlwaysShowExt", 
*>				KEY_ALL_ACCESS, 
*>				&pIRN
*>			);
*>			if (SUCCEEDED (hr))
*>			{
*>				pIRN->Release ();
*>			}
*>		pIRND->Release ();
*>
	*/
};

DEFINE_GUID(CLSID_RegNodeDispenser,0x578B6A94L,0x628C,0x11CF,0x9D,0xD9,0x00,0xAA,0x00,0xB6,0x77,0x0A);

#ifdef __cplusplus
class RegNodeDispenser;
#endif

// =======================================================================
__declspec(dllexport) HRESULT __stdcall GetRegNodeDispenser (IRegNodeDispenser** i_pIRegNodeDispenser);
/* GetRegNodeDispenser: Gets a single-instance-per-process RegNodeDispenser 
						without using the COM libraries.

	NOTE:	Each call to CoGetClassObject for a RegNodeDispenser results
			in a new instance, whereas all calls to GetRegNodeDispenser
			result in a single instance per process.
	NOTE:	To use GetRegNodeDispenser you must link with regnode.lib.

	EG:
*>	IRegNodeDispenser*	pIRND;
*>	IRegNode*			pIRN;
*>
*>	GetRegNodeDispenser (&pIRND);
*>	pIRND->Release ();
*>
*/

#endif !__IREGNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\iiscrypt.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iiscrypt.h

Abstract:

    This include file contains public constants, type definitions, and
    function prototypes for the IIS cryptographic routines.

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


#ifndef _IISCRYPT_H_
#define _IISCRYPT_H_


//
// Get the dependent include files.
//

#include <windows.h>
#include <wincrypt.h>
#include <iiscblob.h>


//
// Define API decoration, should we ever move these routines into a DLL.
//

#define IIS_CRYPTO_API


#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


//
// A NULL crypto handle, mysteriously absent from wincrypt.h.
//

#define CRYPT_NULL 0


//
// Initialization/termination functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoInitialize(
    VOID
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoTerminate(
    VOID
    );



// special function for programatically disabling encryption for French case
VOID 
WINAPI
IISCryptoInitializeOverride(
    BOOL flag
    );



//
// Memory allocation functions. Clients may provide their own
// definitions of these routines if necessary.
//

PVOID
WINAPI
IISCryptoAllocMemory(
    IN DWORD Size
    );

VOID
WINAPI
IISCryptoFreeMemory(
    IN PVOID Buffer
    );


//
// Container functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetStandardContainer(
    OUT HCRYPTPROV * phProv,
    IN DWORD dwAdditionalFlags
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetStandardContainer2(
    OUT HCRYPTPROV * phProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetContainerByName(
    OUT HCRYPTPROV * phProv,
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags,
    IN BOOL fApplyAcl
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDeleteStandardContainer(
    IN DWORD dwAdditionalFlags
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDeleteContainerByName(
    IN LPTSTR pszContainerName,
    IN DWORD dwAdditionalFlags
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloseContainer(
    IN HCRYPTPROV hProv
    );


//
// Key manipulation functions.
//
IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetKeyDeriveKey2(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv,
    IN HCRYPTHASH hHash
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetKeyExchangeKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGetSignatureKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoGenerateSessionKey(
    OUT HCRYPTKEY * phKey,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloseKey(
    IN HCRYPTKEY hKey
    );


//
// Hash manipulation functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCreateHash(
    OUT HCRYPTHASH * phHash,
    IN HCRYPTPROV hProv
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDestroyHash(
    IN HCRYPTHASH hHash
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoHashData(
    IN HCRYPTHASH hHash,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoHashSessionKey(
    IN HCRYPTHASH hHash,
    IN HCRYPTKEY hSessionKey
    );


//
// Generic blob manipulators.
//

#define IISCryptoGetBlobLength(p) (((p)->BlobDataLength) + sizeof(*(p)))

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoReadBlobFromRegistry(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN HKEY hRegistryKey,
    IN LPCTSTR pszRegistryValueName
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoWriteBlobToRegistry(
    IN PIIS_CRYPTO_BLOB pBlob,
    IN HKEY hRegistryKey,
    IN LPCTSTR pszRegistryValueName
    );

IIS_CRYPTO_API
BOOL
WINAPI
IISCryptoIsValidBlob(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
BOOL
WINAPI
IISCryptoIsValidBlob2(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoFreeBlob(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoFreeBlob2(
    IN PIIS_CRYPTO_BLOB pBlob
    );

IIS_CRYPTO_API
BOOL
WINAPI
IISCryptoCompareBlobs(
    IN PIIS_CRYPTO_BLOB pBlob1,
    IN PIIS_CRYPTO_BLOB pBlob2
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloneBlobFromRawData(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pRawBlob,
    IN DWORD dwRawBlobLength
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCloneBlobFromRawData2(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PBYTE pRawBlob,
    IN DWORD dwRawBlobLength
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoCreateCleartextBlob(
    OUT PIIS_CRYPTO_BLOB * ppBlob,
    IN PVOID pBlobData,
    IN DWORD dwBlobDataLength
    );


//
// Key blob functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportSessionKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hKeyExchangeKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportSessionKeyBlob2(
    OUT PIIS_CRYPTO_BLOB * ppSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN LPSTR pszPasswd
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoImportSessionKeyBlob(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSignatureKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoImportSessionKeyBlob2(
    OUT HCRYPTKEY * phSessionKey,
    IN PIIS_CRYPTO_BLOB pSessionKeyBlob,
    IN HCRYPTPROV hProv,
    IN LPSTR pszPasswd
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportPublicKeyBlob(
    OUT PIIS_CRYPTO_BLOB * ppPublicKeyBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hPublicKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoImportPublicKeyBlob(
    OUT HCRYPTKEY * phPublicKey,
    IN PIIS_CRYPTO_BLOB pPublicKeyBlob,
    IN HCRYPTPROV hProv
    );


//
// Data blob functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoEncryptDataBlob(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoEncryptDataBlob2(
    OUT PIIS_CRYPTO_BLOB * ppDataBlob,
    IN PVOID pBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwRegType,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDecryptDataBlob(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey,
    IN HCRYPTKEY hSignatureKey
    );

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoDecryptDataBlob2(
    OUT PVOID * ppBuffer,
    OUT LPDWORD pdwBufferLength,
    OUT LPDWORD pdwRegType,
    IN PIIS_CRYPTO_BLOB pDataBlob,
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSessionKey
    );


//
// Hash blob functions.
//

IIS_CRYPTO_API
HRESULT
WINAPI
IISCryptoExportHashBlob(
    OUT PIIS_CRYPTO_BLOB * ppHashBlob,
    IN HCRYPTHASH hHash
    );



//
// Simple check function for some special French case
//

BOOL
WINAPI
IISCryptoIsClearTextSignature (
    IIS_CRYPTO_BLOB UNALIGNED *pBlob
    );


#ifdef __cplusplus
}   // extern "C"
#endif  // __cplusplus


#endif  // _IISCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\linkable.h ===
/* -----------------------------------------------------------------------
   Microsoft Application Server (Microsoft Confidential)
   Copyright 1997 Microsoft Corporation.  All Rights Reserved.

   @rev 0 | 3/23/97 | jimbo | Sherpa-M3
   ----------------------------------------------------------------------- */

#ifndef _LINKABLE_H_
#define _LINKABLE_H_

#include <windows.h>

//
// Class -- CLinkable
//		Base class for objects that can be placed onto cheap circular doubly-linked lists.
//
class CLinkable
{
public:

	// Constructor
	CLinkable() { m_pNext = m_pPrev = this; }

	// Destructor
	~CLinkable() { Remove(); }

	// return TRUE iff on a list
	BOOL			IsLinked() { return ( m_pNext != this ); }

	// return next element on list
	CLinkable*		Next() { return m_pNext; }

	// return previous element on list
	CLinkable*		Previous() { return m_pPrev; }

	// insert parameter onto list after this, removing it first if necessary
	void			InsertAfter( CLinkable* other );

	// insert parameter onto list before this, removing it first if necessary
	void			InsertBefore( CLinkable* other );

	// remove us from list, if any
	void			Remove();

private:
	CLinkable*		m_pNext;		// next element on list
	CLinkable*		m_pPrev;		// previous element on list
};


//
// Class - CListHeader
//		List header for list of CLinkable's. This is merely a CLinkable with
//		some methods renamed for better readability.
//
class CListHeader : public CLinkable
{

public:

	// Constructor
	CListHeader() {}

	// Destructor
	~CListHeader() {};

	// return TRUE iff list is empty
	BOOL			IsEmpty()	{ return !IsLinked(); }

	// return first element on list
	CLinkable*		First()		{ return Next(); }

	// return last element on list
	CLinkable*		Last()		{ return Previous(); }

	// insert parameter at head of list
	void			InsertFirst ( CLinkable* other )	{ InsertAfter( other ); }

	// insert parameter at tail of list
	void			InsertLast ( CLinkable* other )		{ InsertBefore( other ); }
};

#endif _LINKABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\locationwriter.h ===
#ifndef _LOCATIONWRITER_H
#define _LOCATIONWRITER_H


class CLocationWriter
{
	public:

		CLocationWriter();
		~CLocationWriter();

		//
		// Both SaveAllData and ApplyChangesToBackupFile use this.
		//

		HRESULT	WriteLocation(BOOL bSort);

		HRESULT Initialize(CWriter* pCWriter,
						   LPCWSTR   wszLocation);

		//
		// SaveAllData uses these interfaces
		//

		HRESULT	InitializeKeyType(DWORD	dwKeyTypeIdentifier,
								  DWORD	dwKeyTypeAttributes,
								  DWORD	dwKeyTypeUserType,
								  DWORD	dwKeyTypeDataType,
								  PBYTE	pbKeyTypeData,
								  DWORD	cbKeyTypeData);

		HRESULT AddProperty(DWORD	dwIdentifier,
							DWORD	dwAttributes,
							DWORD	dwUserType,
							DWORD	dwDataType,
							PBYTE	pbData,
							DWORD   cbData);	// Computes Name and Group (For which keytype needs to be initialized)

		//
		// ApplyChangesToBackupFile uses these interfaces
		//

		HRESULT AddProperty(LPVOID*	a_pvProperty,
							ULONG*   a_cbSize);	

	private:

		DWORD GetMetabaseType(DWORD dwType,
						      DWORD dwMetaFlags);

		HRESULT AssignKeyType(LPWSTR wszKeyType);

		HRESULT GetGroupEnum(LPWSTR             wszGroup,
							 eMBProperty_Group* peGroup);

		HRESULT CreateUnknownName(DWORD    dwID,
							      LPWSTR*	pwszUnknownName);

		HRESULT Sort(ULONG** paiRowSorted,
                     ULONG*  pcRowSorted);

		HRESULT WriteBeginLocation(LPCWSTR  wszLocation);

		HRESULT WriteEndLocation();

		HRESULT WriteCustomProperty(LPVOID*  a_pv,
									ULONG*   a_cbSize);

		HRESULT WriteEndWellKnownGroup();

		HRESULT WriteWellKnownProperty(LPVOID*   a_pv,
						               ULONG*    a_cbSize);
/*
		HRESULT ToString(PBYTE   pbData,
						 DWORD   cbData,
						 DWORD   dwIdentifier,
						 DWORD   dwDataType,
						 DWORD   dwAttributes,
						 LPWSTR* pwszData);

		HRESULT FlagValueToString(DWORD      dwValue,
					              ULONG*     piCol,
							      LPWSTR*    pwszData);

		HRESULT FlagAttributeToString(DWORD   dwValue,
					                  LPWSTR* pwszData);

		HRESULT FlagToString(DWORD      dwValue,
					         LPWSTR*    pwszData,
						     LPWSTR     wszTable,
						     ULONG      iColFlag);

		HRESULT BoolToString(DWORD      dwValue,
			                 LPWSTR*    pwszData);

		HRESULT EscapeString(LPCWSTR wszString,
                             BOOL*   pbEscaped,
							 LPWSTR* pwszEscapedString);

		HRESULT GetStartRowIndex(LPWSTR    wszTable,
                                 ULONG     iColFlag,
							     ULONG*    piStartRow);

		inline int  StringInsensitiveCompare(LPCWSTR wsz1, LPCWSTR wsz2) const {if(wsz1 == wsz2) return 0; else return _wcsicmp(wsz1, wsz2);}
*/
	public:

		LPWSTR                      m_wszLocation;

	private:
	
		LPWSTR						m_wszKeyType;
		eMBProperty_Group			m_eKeyTypeGroup;
		ISimpleTableWrite2*			m_pISTWrite;
		CWriter*					m_pCWriter;
		CWriterGlobalHelper*		m_pCWriterGlobalHelper;

}; // class CLocationWriter

#endif // _LOCATIONWRITER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\map_t.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
//  Updated 3/27/01 Murate - Added exceptions on out of memory conditions.  This class should only throw HRESULTs.
//
#pragma once

#include <enum_t.h>
#include <Linkable.h>


typedef unsigned long HASH;

//
// Several common Hasher classes: HashGUID, HashWSTR, HashInt, HashVoidPtr
//
class HashGUID {
    // "The best hash of a GUID is its first word" -- jimbo
public:
    static HASH Hash(const GUID& g) { return *(unsigned long*)&g; }
	static BOOL Equals(const GUID& g1, const GUID& g2) { return g1 == g2; }
};

class HashWSTR {
public:
	static HASH Hash(const WCHAR* pwc) {
		unsigned long hash = 0x01234567;
		while (*pwc) hash = (hash << 5) + (hash >> 27) + *pwc++;
		return hash;
	}
	static BOOL Equals(const WCHAR* pwc1, const WCHAR* pwc2) { 
		if (pwc1 == pwc2) return TRUE;
		if (!pwc1 || !pwc2) return FALSE;
		while (*pwc1 == *pwc2) {
			if (*pwc1 == 0) return TRUE;
			pwc1++, pwc2++;
		}
		return FALSE;
	}
};

class HashInt {
public:
	static HASH Hash(int i) { return i; }
	static BOOL Equals(int i, int j) { return i == j; }
};

class HashVoidPtr {
public:
	static HASH Hash(const void* pv) { return PtrToUlong(pv); }
	static BOOL Equals(const void* pv1, const void* pv2) { return pv1 == pv2; }
};

// empty class used as default base
class EmptyMapBase {};

// fwd decl template enum class used as friend
template <class D, class R, class H, class Base> class EnumMap;

//
// Map class
// Map<D,R,H> defines a hash table that maps from instances of 'D' to instances of 'R',
// using hashing class H.
// Map<D,R,H,Base> does the same thing, except that memory allocators are inherited from 'Base'.
//
// Class H should contain methods compatible with the following:
//		static HASH Hash(D);
//		static BOOL Equals(D,D);
//		if you prefer, any of the D's above can be "D&", "const D" or "const D&".
//
// If a 'Base' class is defined, it should contain nothing but "operator new" and "operator delete".
// So far as the present code is concerned, it is explicitly OK for said "operator new" to throw on 
// OOM. One must, of course, also understand if clients are expecting such behaviour.

template <class D, class R, class H, class Base=EmptyMapBase>
class Map : public Base {	// map from Domain type to Range type
public:
	Map(unsigned cBucketsInitial =17);
	~Map();

	// Remove all elements from the table
	void reset();

	// Find mapping for 'd' if any. If found, sets *pr. Return TRUE iff found.
	BOOL map (const D& d, R* pr) const;

	// Find mapping for 'd' if any. If found, sets *ppr. Return TRUE iff found.
	BOOL map (const D& d, R** ppr) const;

	// Return TRUE iff mapping for 'd' exists. If 'pd' supplied, also return a copy
	// of the 'd' that is mapped. (When we return TRUE, H::Equals(d,*pd) is true, but
	// not necessarily d==*pd).
	BOOL contains (const D& d, D* pd=NULL) const;

	// Add new mapping for 'd' -> 'r'. Delete previous mapping for 'd' if any.
	void add (const D& d, const R& r);
	
	// Remove mapping for 'd' if any.
	void remove (const D& d);

	// Return number of entries currently mapped.
	unsigned count() const;

	// If mapping for 'd' already exists, set *prFound to the mapped value and return FALSE.
	// Otherwise, add mapping for 'd' -> 'r', set *prFound = r, and return TRUE.
	BOOL addIfAbsent (const D& d, const R& r, R* prFound);

	// Perform internal consistency checks. Return TRUE iff hash table is healthy.
	BOOL invariants();

private:
	class Assoc : private CLinkable {
	private:
		Assoc* m_pAssocNext;
		long m_lcUse;
		D m_d;
		R m_r;

		Assoc (const D& d, const R& r) : m_pAssocNext(NULL), m_lcUse(0), m_d(d), m_r(r) {}
		BOOL isPresent() const	{ return m_lcUse < 0; }
		void setPresent()		{ m_lcUse |= 0x80000000; }
		void clearPresent()		{ m_lcUse &= 0x7FFFFFFF; }
		void* operator new (size_t n, Assoc* p) { return p; }	// for re-initializing a previously allocated Assoc
		friend class Map<D,R,H,Base>;
		friend class EnumMap<D,R,H,Base>;
	};

	Assoc** m_rgpAssoc;		// hash buckets. Linked list of elements (through Assoc::m_pAssocNext) that hash to the same value.
	unsigned m_cAssoc;		// number of hash buckets.
	unsigned m_cPresent;	// number of currently mapped entries.
	Assoc* m_pAssocFree;	// linked list (through Assoc::m_pAssocNext) of unused elements.
	CListHeader m_listInUse; // doubly linked list (through CLinkable) of elements that are either mapped, or referred to by an enumerator.

	// Find mapping for 'd'. If found, set *pppAssoc to the pointer to the pointer to the mapping element, and return TRUE.
	// If not found, set *pppAssoc to the pointer to where to store a pointer to a mapping element if you're going to create one, and return FALSE.
	BOOL find (const D& d, Assoc*** pppAssoc) const;

	// Rehash, using a number of buckets which is larger than the current number of elements.
	void grow ();

	// Create a new mapping for 'd' -> 'r', linking it into the linked list at 'ppAssoc'.
	void newAssoc (const D& d, const R& r, Assoc** ppAssoc);

	// Add an enumerator's reference to an Assoc.
	void addRefAssoc (Assoc* pAssoc);

	// Remove an enumerator's reference to an Assoc.
	void releaseAssoc (Assoc* pAssoc);

	// "Free" an Assoc (put it onto our free list).
	void freeAssoc (Assoc* pAssoc);

	friend class EnumMap<D,R,H,Base>;
};


template <class D, class R, class H, class Base> inline
Map<D,R,H,Base>::Map<D,R,H,Base> (unsigned cBucketsInitial)
:
	m_rgpAssoc(NULL),
	m_cAssoc(cBucketsInitial > 0 ? cBucketsInitial : 17),
	m_cPresent(0),
	m_pAssocFree(NULL)
{
	m_rgpAssoc = (Assoc**) operator new (sizeof(Assoc*) * m_cAssoc);	// uses Base::operator new, if any
    if(0 == m_rgpAssoc)
		throw(static_cast<HRESULT>(E_OUTOFMEMORY));

	for (unsigned i = 0; i < m_cAssoc; i++)
		m_rgpAssoc[i] = NULL;
}

template <class D, class R, class H, class Base> inline
Map<D,R,H,Base>::~Map<D,R,H,Base> () {
	Assoc* pAssoc;

	while (!m_listInUse.IsEmpty()) {
		pAssoc = (Assoc*) m_listInUse.First();
		delete pAssoc;
	}

	while (m_pAssocFree != NULL) {
		pAssoc = m_pAssocFree;
		m_pAssocFree = pAssoc->m_pAssocNext;
		operator delete (pAssoc);	// uses Base::operator delete, if any
	}

	operator delete (m_rgpAssoc);	// uses Base::operator delete, if any
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::reset() {
	Assoc* pAssoc;
	CLinkable* pLinkable;

	pLinkable = m_listInUse.First();
	while (pLinkable != &m_listInUse) {
		pAssoc = (Assoc*)pLinkable;
		pLinkable = pLinkable->Next();
		pAssoc->clearPresent();
		if (pAssoc->m_lcUse == 0) {
			freeAssoc (pAssoc);
		}
	}

	for (unsigned i = 0; i < m_cAssoc; i++) {
		m_rgpAssoc[i] = NULL;
	}
	m_cPresent = 0;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::map (const D& d, R* pr) const {
	R* pr2;
	if (map(d, &pr2)) {
		*pr = *pr2;
		return TRUE;
	}
	return FALSE;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::map (const D& d, R** ppr) const {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		*ppr = &(*ppAssoc)->m_r;
		return TRUE;
	}
	else
		return FALSE;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::contains (const D& d, D* pd) const {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		if (pd) *pd = (*ppAssoc)->m_d;
		return TRUE;
	}
	else {
		return FALSE;
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::add (const D& d, const R& r) {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		// some mapping d->r2 already exists, replace with d->r
		(*ppAssoc)->m_d = d;
		(*ppAssoc)->m_r = r;
	}
	else {
		newAssoc(d,r,ppAssoc);
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::remove (const D& d) {
	Assoc** ppAssoc;
	Assoc* pAssoc;
	if (find(d, &ppAssoc)) {
		pAssoc = *ppAssoc;
		*ppAssoc = pAssoc->m_pAssocNext;

		pAssoc->clearPresent();
		if (pAssoc->m_lcUse == 0) {
			freeAssoc (pAssoc);
		}

		m_cPresent--;
	}
}

// Return the count of elements
template <class D, class R, class H, class Base> inline
unsigned Map<D,R,H,Base>::count() const {
	return m_cPresent;
}

// Lookup at d.
// If absent, return TRUE
// In any case, establish *prFound.
template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::addIfAbsent(const D& d, const R& r, R* prFound) {
	Assoc** ppAssoc;
	if (find(d, &ppAssoc)) {
		// some mapping d->r2 already exists; return r2
		*prFound = (*ppAssoc)->m_r;
		return FALSE;
	}
	else {
		// establish a new mapping d->r in the first unused entry
		newAssoc(d,r,ppAssoc);
		*prFound = r;
		return TRUE;
	}
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::invariants() {
	Assoc* pAssoc;
	Assoc** ppAssoc;
	CLinkable* pLinkable;
	unsigned cPresent = 0;

#define INVARIANTASSERT(x) { if (!(x)) { DebugBreak(); return FALSE; } }

	// Verify each Assoc on the inuse list
	for (pLinkable = m_listInUse.First(); pLinkable != &m_listInUse; pLinkable = pLinkable->Next()) {
		pAssoc = (Assoc*) pLinkable;
		INVARIANTASSERT (pAssoc == ((Assoc*)pLinkable->Next())->Previous());
		INVARIANTASSERT (pAssoc->m_lcUse != 0);
		find (pAssoc->m_d, &ppAssoc);
		if (pAssoc->isPresent()) {
			cPresent++;
			INVARIANTASSERT (pAssoc == *ppAssoc);
		}
		else {
			INVARIANTASSERT (pAssoc != *ppAssoc);
		}
	}
	INVARIANTASSERT (m_cPresent == cPresent);

	// Verify each Assoc on the hash lists
	cPresent = 0;
	for (unsigned i = 0; i < m_cAssoc; i++) {
		for (pAssoc = m_rgpAssoc[i]; pAssoc != NULL; pAssoc = pAssoc->m_pAssocNext) {
			INVARIANTASSERT (pAssoc != pAssoc->Next());
			INVARIANTASSERT (pAssoc->isPresent());
			find (pAssoc->m_d, &ppAssoc);
			INVARIANTASSERT (pAssoc == *ppAssoc);
			cPresent++;
		}
	}
	INVARIANTASSERT (m_cPresent == cPresent);

	// Verify each Assoc on the free list
	for (pAssoc = m_pAssocFree; pAssoc != NULL; pAssoc = pAssoc->m_pAssocNext) {
		INVARIANTASSERT (pAssoc == pAssoc->Next());
		INVARIANTASSERT (pAssoc->m_lcUse == 0);
	}

#undef INVARIANTASSERT
	return TRUE;
}

template <class D, class R, class H, class Base> inline
BOOL Map<D,R,H,Base>::find (const D& d, Assoc*** pppAssoc) const {  
	unsigned h		= H::Hash(d) % m_cAssoc;

	*pppAssoc = &m_rgpAssoc[h];
	for (;;) {
		if (**pppAssoc == NULL)
			return FALSE;
		else if (H::Equals((**pppAssoc)->m_d,d))
			return TRUE;
		else
			*pppAssoc = &(**pppAssoc)->m_pAssocNext;
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::grow () {
	CLinkable* pLinkable;
	Assoc* pAssoc;
	Assoc** ppAssoc;
	unsigned i;

	static unsigned int rgprime[] = { 17, 37, 79, 163, 331, 673, 1361, 2729, 5471, 10949,
		21911, 43853, 87719, 175447, 350899, 701819, 1403641, 2807303, 5614657, 11229331,
		22458671, 44917381, 89834777, 179669557, 359339171, 718678369, 1437356741, 2874713497 };

	operator delete(m_rgpAssoc);	// uses Base::operator delete, if any
    m_rgpAssoc = NULL;              // in case the 'new' below throws, and we end up in our dtor

	for (i = 0; m_cPresent >= rgprime[i]; i++) /*nothing*/ ;
	m_rgpAssoc = (Assoc**)operator new(sizeof(Assoc*) * rgprime[i]);	// uses Base::operator new, if any
    if(0 == m_rgpAssoc)
        throw(static_cast<HRESULT>(E_OUTOFMEMORY));

	m_cAssoc = rgprime[i];
	for (i = 0; i < m_cAssoc; i++)
		m_rgpAssoc[i] = NULL;

	pLinkable = m_listInUse.First();
	while (pLinkable != &m_listInUse) {
		pAssoc = (Assoc*) pLinkable;
		if (pAssoc->isPresent()) {
			find(pAssoc->m_d, &ppAssoc);
			pAssoc->m_pAssocNext = *ppAssoc;
			*ppAssoc = pAssoc;
		}
		pLinkable = pLinkable->Next();
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::newAssoc (const D& d, const R& r, Assoc** ppAssoc) {
	Assoc* pAssoc;
	if (m_pAssocFree == NULL) {
		pAssoc = (Assoc*) operator new(sizeof Assoc); // uses Base::operator new, if any
        if(0 == pAssoc)
            throw(static_cast<HRESULT>(E_OUTOFMEMORY));
	}
	else {
		pAssoc = m_pAssocFree;
		m_pAssocFree = pAssoc->m_pAssocNext;
	}

	new(pAssoc) Assoc(d,r);	// run Assoc constructor on existing memory: ("yuck-o-rama!" -- BobAtk)
	pAssoc->setPresent();
	pAssoc->m_pAssocNext = *ppAssoc;
	*ppAssoc = pAssoc;
	m_listInUse.InsertLast(pAssoc);
	if (++m_cPresent > m_cAssoc)
		grow();
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::addRefAssoc (Assoc* pAssoc) {
	pAssoc->m_lcUse++;
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::releaseAssoc (Assoc* pAssoc) {
	pAssoc->m_lcUse--;
	if (pAssoc->m_lcUse == 0) {
		freeAssoc (pAssoc);
	}
}

template <class D, class R, class H, class Base> inline
void Map<D,R,H,Base>::freeAssoc (Assoc* pAssoc) {
	pAssoc->~Assoc();		// run Assoc destructor
	pAssoc->m_pAssocNext = m_pAssocFree;
	m_pAssocFree = pAssoc;
}



// EnumMap must continue to enumerate correctly in the presence of Map<foo>::add()
// or Map<foo>::remove() being called in the midst of the enumeration.
template <class D, class R, class H, class Base=EmptyMapBase>
class EnumMap : public Enum, public Base {
public:
	EnumMap ();
	EnumMap (const Map<D,R,H,Base>& map);
	EnumMap (const EnumMap<D,R,H,Base>& e);
	~EnumMap ();

	void reset ();
	BOOL next ();
	void get (OUT D* pd, OUT R* pr) const;
	void get (OUT D* pd, OUT R** ppr) const;
    void get (OUT D** ppd, OUT R** ppr) const;
    void get (OUT D** ppd, OUT R* pr) const;

	EnumMap<D,R,H,Base>& operator= (const EnumMap<D,R,H,Base>& e);

    BOOL operator==(const EnumMap<D,R,H,Base>& enum2) const {
        return m_pmap == enum2.m_pmap && m_pLinkable == enum2.m_pLinkable;
    }

    BOOL operator!=(const EnumMap<D,R,H,Base>& enum2) const {
        return ! this->operator==(enum2);
    }

private:
	typedef Map<D,R,H,Base>::Assoc Assoc;

	Map<D,R,H,Base>* m_pmap;
	CLinkable* m_pLinkable;
};	



template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::EnumMap () {
	m_pmap = NULL;
	m_pLinkable = &m_pmap->m_listInUse;
	// The above is NOT a bug. It makes the mantra "if (m_pLinkable != &m_pmap->m_listInUse)" return the right answer for null enum's.
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::EnumMap (const Map<D,R,H,Base>& map) {
	m_pmap = const_cast<Map<D,R,H,Base>*> (&map);
	m_pLinkable = &m_pmap->m_listInUse;
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::EnumMap (const EnumMap<D,R,H,Base>& e) {
	m_pmap = e.m_pmap;
	m_pLinkable = e.m_pLinkable;
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->addRefAssoc((Assoc*)m_pLinkable);
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>::~EnumMap () {
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::reset () {
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);
	m_pLinkable = &m_pmap->m_listInUse;
}

template <class D, class R, class H, class Base> inline
BOOL EnumMap<D,R,H,Base>::next () {
	CLinkable* pLink2 = m_pLinkable->Next();
	Assoc* pAssoc;
	
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);

	for(;;) {
		if (pLink2 == &m_pmap->m_listInUse) {
			m_pLinkable = pLink2;
			return FALSE;
		}
		pAssoc = (Assoc*)pLink2;
		if (pAssoc->isPresent()) {
			m_pmap->addRefAssoc(pAssoc);
			m_pLinkable = pLink2;
			return TRUE;
		}
		pLink2 = pLink2->Next();
	}
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D* pd, OUT R* pr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*pd = pAssoc->m_d;
	*pr = pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D* pd, OUT R** ppr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*pd = pAssoc->m_d;
	*ppr = &pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D** ppd, OUT R** ppr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*ppd = &pAssoc->m_d;
	*ppr = &pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
void EnumMap<D,R,H,Base>::get (OUT D** ppd, OUT R* pr) const {
	Assoc* pAssoc = (Assoc*)m_pLinkable;

	*ppd = &pAssoc->m_d;
	*pr  = pAssoc->m_r;
}

template <class D, class R, class H, class Base> inline
EnumMap<D,R,H,Base>& EnumMap<D,R,H,Base>::operator= (const EnumMap<D,R,H,Base>& e) {
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->releaseAssoc((Assoc*)m_pLinkable);
	m_pmap = e.m_pmap;
	m_pLinkable = e.m_pLinkable;
	if (m_pLinkable != &m_pmap->m_listInUse)
		m_pmap->addRefAssoc((Assoc*)m_pLinkable);
	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\mblisten.h ===
#ifndef __MBLISTEN_H__
#define __MBLISTEN_H__

#include "iadmw.h"
#include "array_t.h"
#include "utsem.h"

#define MAX_ROOT_PATH_LEN	 17  //(decimal represenation of MAX_ULONG) + 7 ("/<id>/ROOT")
#define TABLEMASK(x)	(1 << (x))

enum WASTABLETYPE 
{
	wttUNKNOWN,
	wttIRRELEVANT,
	wttRELEVANT,    // The change can affect multiple rows in a table.
    wttFINAL,
	wttAPPPOOL,		 
	wttSITE,								
	wttAPP,
	wttGLOBALW3SVC,
	wttMAX			// Leave this as the last enum.
};

struct METABASEID_MAP
{
	DWORD*		pdwIDs;
	ULONG		cIDs;
};

struct WAS_CHANGE_OBJECT
{
	LPWSTR				wszPath; // One of AppPath, VirtualSiteKeyName or AppPoolPath
	DWORD				dwWASTableType;
	DWORD				dwMDChangeType;
	ULONG				iVirtualSiteID;
	WCHAR				wszSiteRootPath[MAX_ROOT_PATH_LEN];
	DWORD				dwMDNumDataIDs;
	DWORD				*pdwMDDataIDs;
};

class CMetabaseListener : public IMSAdminBaseSink
{
	enum 
	{
		m_eDone,
		m_eMetabaseChange,
		m_eReceivedFinalChange,
		m_eHandleCount
	};

public:
	CMetabaseListener() 
		: m_cRef(0), m_dwCookie(0), m_hThread(NULL), m_dwLatency(1000)
	{
		m_aHandles[m_eDone] = NULL; 
		m_aHandles[m_eMetabaseChange] = NULL;
		m_aHandles[m_eReceivedFinalChange] = NULL;
		ZeroMemory(m_mmIDs, sizeof(METABASEID_MAP) * wttMAX);
	}

	~CMetabaseListener() 
	{
		ULONG		i;

		// Close the event handles.
	    for (i = 0; i < m_eHandleCount; i++)
	    {
		    if (m_aHandles[i] != NULL)
		    {
			    CloseHandle(m_aHandles[i]);
			    m_aHandles[i] = NULL;
		    }
	    }

        for (i = 0; i < m_aCookdownQueue.size(); i++)
		{
			ASSERT(m_aCookdownQueue[i]);
			UninitChangeList(*m_aCookdownQueue[i]);
			delete m_aCookdownQueue[i];
		}
		m_aCookdownQueue.reset();

		// Delete the metabase property id arrays.
		for (i = 0; i < wttMAX; i++)
		{
			if (m_mmIDs[i].pdwIDs)
			{
				delete [] m_mmIDs[i].pdwIDs;
			}
		}
		ZeroMemory(m_mmIDs, sizeof(METABASEID_MAP) * wttMAX);
	}

	// IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release) 		();

	// IMSAdminBaseSink:
	STDMETHOD(SinkNotify)			(DWORD dwMDNumElements, MD_CHANGE_OBJECT_W pcoChangeList[]);
	STDMETHOD(ShutdownNotify)		();

	// Internal methods.
	HRESULT Init();
	HRESULT Uninit();
	HRESULT RehookNotifications();

private:
	static UINT CookdownQueueThreadStart(LPVOID i_lpParam);
	HRESULT Main();
	HRESULT CondenseChanges(Array<WAS_CHANGE_OBJECT> *paChangeList);
	HRESULT AddChangeObjectToList(WAS_CHANGE_OBJECT *i_pwcoChange, Array<WAS_CHANGE_OBJECT>& i_aChangeList);
	void UninitChangeList(Array<WAS_CHANGE_OBJECT>& i_aChangeList);
	void UninitChangeObject(WAS_CHANGE_OBJECT *i_pChangeObj); 
	HRESULT AddChangeListToCookdownQueue(Array<WAS_CHANGE_OBJECT>* i_aChangeList);
	HRESULT FilterChangeObject(MD_CHANGE_OBJECT_W* i_pChangeObject, WAS_CHANGE_OBJECT *o_pwcoChange);
	HRESULT InitPropertyIDs(WASTABLETYPE i_wttTable, ISimpleTableDispenser2	*i_pISTDisp, LPCWSTR i_wszTableName, DWORD *i_pdwAdditionalIDs = NULL,	ULONG i_cAdditionalIDs = 0);
    HRESULT SetFinalPropertyID();
	void GetCookdownLatency(DWORD *o_pdwCookdownLatency);
	void GetNextNode(LPCWSTR i_szSource, LPWSTR o_szNext, ULONG *o_pcbNext);

private:
	ULONG		m_cRef;
	HANDLE		m_aHandles[m_eHandleCount];
	HANDLE		m_hThread;
	CComPtr<IConnectionPoint> m_spICP;
	CComPtr<IConnectionPointContainer> m_spICPC;
	DWORD		m_dwCookie;
	DWORD		m_dwLatency;			// In milliseconds.

	CSemExclusive m_seCookdownQueueLock;
	Array<Array<WAS_CHANGE_OBJECT>*>	m_aCookdownQueue;

	METABASEID_MAP m_mmIDs[wttMAX];

	
};

#endif // __MBLISTEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\mbschemacompilation.h ===
// Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
// Filename:        MBSchemaCompilation,h
// Author:          Stephenr
// Date Created:    10/16/2000
// Description:     This function takes an MBSchema.Xml (or MBExtensionsSchema.Xml) and merges the Metabase Schema with
//                  the shipped schema and generates a MBSchema.bin file.  From that new bin file, a merged MBSchema.Xml
//                  is generated.
//

#ifndef __MBSCHEMACOMPILATION_H__
#define __MBSCHEMACOMPILATION_H__

#ifndef __TFILEMAPPING_H__
    #include "TFileMapping.h"
#endif
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif
#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif

class TMBSchemaCompilation
{
public:
    TMBSchemaCompilation();
    ~TMBSchemaCompilation();
    
    //After the user calls Compile, they will need to GetBinFileName - I didn't want to add more params and make this function do double duty
    HRESULT Compile                (ISimpleTableDispenser2 *i_pISTDispenser,
                                    LPCWSTR                 i_wszExtensionsXmlFile,
                                    LPCWSTR                 i_wszResultingOutputXmlFile,
                                    const FixedTableHeap *  i_pFixedTableHeap
                                   );
    //This function returns the BinFileName to be used for getting all of the IST meta tables used by the Metabase.
    //This file name changes as new versions get compiled; but this abstraction guarentees that the filename returned
    //exists AND is lock into memory and thus cannot be deleted by some other process or thread.  It isn't released
    //until another file has been compiled and locked into memory, OR when the process shuts down.
    HRESULT GetBinFileName         (LPWSTR                  o_wszBinFileName,
                                    ULONG *                 io_pcchSizeBinFileName//this is a SIZE param so it always INCLUDE the NULL - unlike wcslen
                                   );

    //This is broken out into a separate method because on start up, we'll be called to GetMBSchemaBinFileName without first an MBSchemaCompilation
    HRESULT SetBinPath             (LPCWSTR                 i_wszBinPath
                                   );
    HRESULT ReleaseBinFileName     (LPCWSTR                 i_wszBinFileName
                                   );


private:
    struct TBinFileName : public TFileMapping
    {
        TBinFileName() : m_cRef(0), m_lBinFileVersion(-1){}
        HRESULT LoadBinFile(LPCTSTR filename, LONG lVersion)
        {
            if(m_cRef>0)
            {
                ASSERT(m_lBinFileVersion==lVersion && "Do we really need more than 64 versions of the BinFile hanging around?");
                ++m_cRef;
                return S_OK;
            }

            m_cRef = 1;
            m_lBinFileVersion = lVersion;
            return TFileMapping::Load(filename, false);
        }
        void UnloadBinFile()
        {
            if(0 == m_cRef)
                return;

            --m_cRef;
            if(0 == m_cRef)
            {
                m_lBinFileVersion = -1;
                TFileMapping::Unload();
            }
        }
        ULONG   m_cRef;
        LONG    m_lBinFileVersion;
    };

    TBinFileName                    m_aBinFile[0x40];
    SIZE_T                          m_cchFullyQualifiedBinFileName;
    TSmartPointerArray<WCHAR>       m_saBinPath;                          //The user specifies the path (we supply the file name)
    LONG                            m_lBinFileVersion;                    //Modifying the version is done through InterlockedExchange

    //This just takes the numeric extension and converts from hex string to a ULONG (file is assumed to be in the form L"*.*.xxxxxxxx", where L"xxxxxxxx" is a hex number)
    HRESULT BinFileToBinVersion    (LONG &                  i_lVersion,
                                    LPCWSTR                 i_wszBinFileName
                                   ) const;
    HRESULT DeleteBinFileVersion   (LONG i_lBinFileVersion
                                   );

    //This checks the validity of the FixedTableHeap mapped into memory
    bool    IsValidBin             (TFileMapping &          i_mapping
                                   ) const;
    HRESULT RenameBinFileVersion   (LONG                    i_lSourceVersion,
                                    LONG                    i_lDestinationVersion
                                   );
    HRESULT SetBinFileVersion      (LONG                    i_lBinFileVersion
                                   );
    HRESULT WalkTheFileSystemToFindTheLatestBinFileName();




};

#endif //__MBSCHEMACOMPILATION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\metaerrors.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// MetaErrors.h
//
// This file contains the errors that a Meta Store object may return.
//
//*****************************************************************************
#ifndef __MetaErrors_h__
#define __MetaErrors_h__

#ifndef EMAKEHR
#define SMAKEHR(val)			MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, val)
#define EMAKEHR(val)			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, val)
#endif

//**** Generic errors.
#define CLDB_E_FILE_BADREAD		EMAKEHR(0x1000)		// Error occured during a read.
#define CLDB_E_FILE_BADWRITE	EMAKEHR(0x1001)		// Error occured during a write.
#define CLDB_E_FILE_READONLY	EMAKEHR(0x1003)		// File is read only.
#define CLDB_E_NAME_ERROR		EMAKEHR(0x1005)		// An ill-formed name was given.
#define CLDB_S_TRUNCATION		SMAKEHR(0x1006)		// STATUS: Data value was truncated.
#define CLDB_E_TRUNCATION		EMAKEHR(0x1006)		// ERROR:  Data value was truncated.
#define CLDB_E_FILE_OLDVER		EMAKEHR(0x1007)		// Old version error.
#define CLDB_E_RELOCATED		EMAKEHR(0x1008)		// A shared mem open failed to open at the originally
													//	assigned memory address.
#define CLDB_S_NULL				SMAKEHR(0x1009)		// NULL data value.
#define CLDB_E_SMDUPLICATE		EMAKEHR(0x1010)		// Create of shared memory failed.  A memory mapping of the same name already exists.
#define CLDB_E_NO_DATA			EMAKEHR(0x1011)		// There isn't .CLB data in the memory or stream.
#define CLDB_E_READONLY			EMAKEHR(0x1012)		// Database is read only.
#define CLDB_E_NOTNULLABLE		EMAKEHR(0x1013)		// Data for a non-nullable column hasn't been set.

//**** Schema errors.
#define CLDB_E_FILE_CORRUPT		EMAKEHR(0x1015)		// File is corrupt.
#define CLDB_E_SCHEMA_VERNOTFOUND EMAKEHR(0x1016)	// Version %d of schema '%s' not found.
#define CLDB_E_SCHEMA_VERMISMATCH EMAKEHR(0x1017)	// Version mismatch. The version number stored in clb file and the version
													// catalog.dll expects are different.


//**** Index errors.
#define CLDB_E_INDEX_NONULLKEYS	EMAKEHR(0x1021)		// Null value not allowed in unique index or primary key.
#define CLDB_E_INDEX_DUPLICATE	EMAKEHR(0x1022)		// Unique index %s has been violated.
#define CLDB_E_INDEX_BADTYPE	EMAKEHR(0x1023)		// The columns data type is not allowed in an index.
#define CLDB_E_INDEX_NOTFOUND	EMAKEHR(0x1024)		// Index %s not found.
#define CLDB_S_INDEX_TABLESCANREQUIRED EMAKEHR(0x1025) // Table scan required to run query.

//**** Record errors.
#define CLDB_E_RECORD_NOTFOUND	EMAKEHR(0x1030)		// Record wasn't found on lookup.
#define CLDB_E_RECORD_OVERFLOW	EMAKEHR(0x1031)		// Too many records were returned for criteria.
#define CLDB_E_RECORD_DUPLICATE	EMAKEHR(0x1032)		// Record is a duplicate.
#define CLDB_E_RECORD_PKREQUIRED EMAKEHR(0x1033)	// Primary key value is required.
#define CLDB_E_RECORD_DELETED	EMAKEHR(0x1034)		// Record is valid but deleted.

//**** Column errors.
#define CLDB_E_COLUMN_OVERFLOW	EMAKEHR(0x1040)		// Data too large.
#define CLDB_E_COLUMN_READONLY	EMAKEHR(0x1041)		// Column cannot be changed.
#define CLDB_E_COLUMN_SPECIALCOL EMAKEHR(0x1042)	// Too many RID or primary key columns, 1 is max.
#define CLDB_E_COLUMN_PKNONULLS	EMAKEHR(0x1043)		// Primary key column %s may not allow the null value.

//**** Table errors.
#define CLDB_E_TABLE_CANTDROP	EMAKEHR(0x1050)		// Can't auto-drop table while open.

//**** Object errors.
#define CLDB_E_OBJECT_NOTFOUND	EMAKEHR(0x1060)		// Object was not found in the database.
#define CLDB_E_OBJECT_COLNOTFOUND EMAKEHR(0x1061)	// The column was not found.

//**** Vector errors.
#define CLDB_E_VECTOR_BADINDEX	EMAKEHR(0x1062)		// The index given was invalid.

//**** Heap errors;
#define CLDB_E_TOO_BIG			EMAKEHR(0x1070)		// A blob or string was too big.

//**** ICeeFileGen errors.
#define CEE_E_ENTRYPOINT		EMAKEHR(0x1100)		// The entry point info is invalid.

//**** IMeta* errors.
#define META_E_DUPLICATE		EMAKEHR(0x1200)		// Attempt to define an object that already exists.
#define META_E_GUID_REQUIRED	EMAKEHR(0x1201)		// A guid was not provided where one was required.
#define META_E_TYPEDEF_MISMATCH	EMAKEHR(0x1202)		// Merge: an import typedef matched ns.name, but not version and guid.
#define META_E_MERGE_COLLISION  EMAKEHR(0x1203)		// Merge: conflict between import and emit
#define META_E_DEBUGSCOPE_MISMATCH  EMAKEHR(0x1204)	// Merge: mismatch of LocalVarScope given duplicated memberdef
#define META_E_LOCALVAR_MISMATCH  EMAKEHR(0x1205)	// Merge: mismatch of local variable declaration
#define META_E_EXCEPTION_MISMATCH  EMAKEHR(0x1206)	// Merge: mismatch of exception declaration

#define META_E_METHD_NOT_FOUND			EMAKEHR(0x1207) // Merge: Class already in emit scope, but member not found
#define META_E_FIELD_NOT_FOUND			EMAKEHR(0x1208) // Merge: Class already in emit scope, but member not found
#define META_E_PARAM_NOT_FOUND			EMAKEHR(0x1209) // Merge: member already in emit scope, but param not found
#define META_E_METHDIMPL_NOT_FOUND		EMAKEHR(0x1210) // Merge: Class already in emit scope, but MethodImpl not found
#define META_E_INTFCEIMPL_NOT_FOUND		EMAKEHR(0x1211) // Merge: Class already in emit scope, but interfaceimpl not found
#define META_E_EXCEPT_NOT_FOUND			EMAKEHR(0x1212) // Merge: Method is duplicated but we cannot find a matching exception
#define META_E_CLASS_LAYOUT_NOT_FOUND	EMAKEHR(0x1213) // Merge: Class is duplicated but we cannot find the matching class layout information
#define META_E_FIELD_MARSHAL_NOT_FOUND	EMAKEHR(0x1214) // Merge: Field is duplicated but we cannot find the matching FieldMarshal information
#define META_E_METHODSEM_NOT_FOUND		EMAKEHR(0x1215) // Merge: 
#define META_E_EVENT_NOT_FOUND			EMAKEHR(0x1216) // Merge: Method is duplicated but we cannot find the matching event info.
#define META_E_PROP_NOT_FOUND			EMAKEHR(0x1217) // Merge: Method is duplicated but we cannot find the maching property info.
#define META_E_BAD_SIGNATURE			EMAKEHR(0x1218) // Bad binary signature
#define META_E_BAD_INPUT_PARAMETER		EMAKEHR(0x1219) // Bad input parameters
#define META_E_MD_INCONSISTENCY			EMAKEHR(0x1220) // Merge: Inconsistency in meta data

#define META_E_UNEXPECTED_REMAP			EMAKEHR(0x1280) // A TokenRemap occurred which we weren't prepared to handle.

#define TLBX_E_CANT_LOAD_MODULE			EMAKEHR(0x1301) // TypeLib export: can't open the module to export.
#define TLBX_E_CANT_LOAD_CLASS			EMAKEHR(0x1302) // TypeLib export: can't load a class.	
#define TLBX_E_NULL_MODULE				EMAKEHR(0x1303) // TypeLib export: the hMod of a loaded class is 0; can't export it.
#define TLBX_E_NO_CLSID_KEY				EMAKEHR(0x1305) // TypeLib export: no CLSID or Interface subkey to HKCR.
#define TLBX_E_CIRCULAR_EXPORT			EMAKEHR(0x1306) // TypeLib export: attempt to export a CLB imported from a TLB.
#define TLBX_E_CIRCULAR_IMPORT			EMAKEHR(0x1307) // TypeLib import: attempt to import a TLB exported from a CLB.

//**** EE errors
#define MSEE_E_LOADLIBFAILED	EMAKEHR(0xEE00)		// Failed to delay load library %s (Win32 error: %d).
#define MSEE_E_GETPROCFAILED	EMAKEHR(0xEE01)		// Failed to get entry point %s (Win32 error: %d).

//**** COM+ Debugging Servies errors
#define CORDBG_E_UNRECOVERABLE_ERROR  EMAKEHR(0xED00) // Unrecoverable API error.
#define CORDBG_E_PROCESS_TERMINATED   EMAKEHR(0xED01) // Process was terminated.
#define CORDBG_E_PROCESS_NOT_SYNCHRONIZED EMAKEHR(0xED02) // Process not synchronized.
#define CORDBG_E_CLASS_NOT_LOADED EMAKEHR(0xED03) // A class is not loaded.

//**** Reserved.
#define CLDB_E_INTERNALERROR	EMAKEHR(0xffff)

#endif // __REPERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\metatablestructs.h ===
//  Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
//  Filename:       MetaTableStructs.h
//  Author:         Stephenr
//  Date Created:   6/20/00
//  Description:    All fixed tables store their column values as ULONGs.  These ULONGs are either
//                  interpretted as ULONGs or indexes into some pool that contains the actual data.
//                  The columns' type defines the type of data pointed to.  And in the past it has
//                  also determined which pool the data came from (we had a separate pool for each
//                  type of data).  Either way, the fixed table columns are always stored as ULONGs.
//
//                  Currently there are two fixed table formats:  the TableSchema format and the
//                  FixedTable format.  Each solves a slightly different problem.  They each store
//                  extra information on a per column basis.  Also the TableSchema stores UI4s
//                  directly as ULONG.  The FixedTable format stores UI4s as indexes into a pool.
//                  This is necessary so we can represent a UI4 column as NULL.
//
//                  All meta, regardless of the specifics of the fixed storage format, must derive
//                  from the tables below.  This reduces the change points when updating meta for
//                  the meta tables.  Currently there are several places that need to be updated,
//                  when updating meta-meta:
//                      MetaTableStructs.h
//                      CatMeta_Core.xml
//
//                  This assumes the most simple case meta-meta change is being made.  Like a column
//                  being added to ColumnMeta that does not require any inferrance rules.  Obviously
//                  anything beyond this would require changes to the CatUtil code.

#ifndef __METATABLESTRUCTS_H__
#define __METATABLESTRUCTS_H__


//  These signatures are used to verify the position of each of structures within the PE file.  The
//  0th entry of each of these arrays starts with Signature0 followed by Signature1.  This 0th element is
//  not considered as part of the array so the count of elements in the array is always minus this 0th
//  element.  Thus element 1 becomes the 0th element after this signature verification is done.  Since we
//  always use indexes to reference into these structs, it is sometimes useful to reserve an element to
//  indicate NULL.  An index to this reserved element is interpreted as NULL (and NOT as a pointer to
//  a NULL element).  This reserved element is usually element 1 which gets translated as the 0th element.
//  This is particularly useful in the above arrays, where a 0 index into the WChar array indicates NULL
//  and not a pointer to the 0th element.
#define FixedTableHeap0         0x207be016
#define FixedTableHeap1         0xe0182086

//The numbers below can be used as signatures (a histogram of catinpro revealed that none of the WORDs appeared in the bin).
//When we run out of signatures, we can generate some more by writing a program that searches for unique WORDs within Catalog.dll, and combining two of them.
//0x208ee01b    0xe0222093    0x209de027    0xe028209e
//0x209fe042    0xe04c20a5    0x20aae04f    0xe05220ae
//0x20b2e054    0xe05e20d6    0x20dbe05f    0xe07220dd
//0x20dee07a    0xe07b20e6    0x20e7e07c    0xe08f20ed
//0x20f5e096    0xe09720f7    0x20fbe098    0xe09920fd
//0x210de09a    0xe09b2115    0x211be09c    0xe09d2126


#define PRIMARYKEY
#define FOREIGNKEY

struct ColumnMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            Index;                  //UI4       Column Index
    ULONG                       InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Type;                   //UI4       These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    ULONG                       Size;                   //UI4
    ULONG                       MetaFlags;              //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       DefaultValue;           //Bytes
    ULONG                       FlagMask;               //UI4       Only valid for flags
    ULONG                       StartingNumber;         //UI4       Only valid for UI4s
    ULONG                       EndingNumber;           //UI4       Only valid for UI4s
    ULONG                       CharacterSet;           //String    Only valid for Strings
    ULONG                       SchemaGeneratorFlags;   //UI4       ColumnMetaFlags defined in CatMeta.xml
    ULONG                       ID;                     //UI4       Metabase ID
    ULONG                       UserType;               //UI4       One of the Metabase UserTypes
    ULONG                       Attributes;             //UI4       Metabase Attribute flags
    ULONG                       Description;            //String
    ULONG                       PublicColumnName;       //String
};
const kciColumnMetaPublicColumns = sizeof(ColumnMetaPublic)/sizeof(ULONG);

struct DatabaseMetaPublic
{
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       BaseVersion;            //UI4
    ULONG                       ExtendedVersion;        //UI4
    ULONG                       CountOfTables;          //UI4       Count of tables in database
    ULONG                       Description;            //String
};
const kciDatabaseMetaPublicColumns = sizeof(DatabaseMetaPublic)/sizeof(ULONG);

struct IndexMetaPublic
{
    ULONG PRIMARYKEY    Table;                          //String
    ULONG PRIMARYKEY    InternalName;                   //String
    ULONG               PublicName;                     //String
    ULONG PRIMARYKEY    ColumnIndex;                    //UI4       This is the iOrder member of the ColumnMeta
    ULONG               ColumnInternalName;             //String
    ULONG               MetaFlags;                      //UI4       Index Flag
};
const kciIndexMetaPublicColumns = sizeof(IndexMetaPublic)/sizeof(ULONG);

struct QueryMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Index;                  //UI4
    ULONG                       CellName;               //String
    ULONG                       Operator;               //UI4
    ULONG                       MetaFlags;              //UI4
};
const kciQueryMetaPublicColumns = sizeof(QueryMetaPublic)/sizeof(ULONG);

struct RelationMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY PrimaryTable;           //String
    ULONG                       PrimaryColumns;         //Bytes
    ULONG PRIMARYKEY FOREIGNKEY ForeignTable;           //String
    ULONG                       ForeignColumns;         //Bytes
    ULONG                       MetaFlags;
};
const kciRelationMetaPublicColumns = sizeof(RelationMetaPublic)/sizeof(ULONG);

struct ServerWiringMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY            Order;                  //UI4
    ULONG                       ReadPlugin;             //UI4
    ULONG                       ReadPluginDLLName;      //String
    ULONG                       WritePlugin;            //UI4
    ULONG                       WritePluginDLLName;     //String
    ULONG                       Interceptor;            //UI4
    ULONG                       InterceptorDLLName;     //String
    ULONG                       Flags;                  //UI4       Last, NoNext, First, Next
    ULONG                       Locator;                //String
    ULONG                       Reserved;               //UI4       for Protocol.  Protocol may be needed for managed property support
    ULONG                       Merger;                 //UI4
    ULONG                       MergerDLLName;          //String
};
const kciServerWiringMetaPublicColumns = sizeof(ServerWiringMetaPublic)/sizeof(ULONG);

struct TableMetaPublic
{
    ULONG FOREIGNKEY            Database;               //String
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       PublicRowName;          //String
    ULONG                       BaseVersion;            //UI4
    ULONG                       ExtendedVersion;        //UI4
    ULONG                       NameColumn;             //UI4       iOrder of the NameColumn
    ULONG                       NavColumn;              //UI4       iOrder of the NavColumn
    union
    {
    ULONG                       CountOfColumns;         //UI4       Count of Columns
    ULONG                       CountOfProperties;      //UI4       Count of Columns
    };
    ULONG                       MetaFlags;              //UI4       TableMetaFlags are defined in CatInpro.meta
    ULONG                       SchemaGeneratorFlags;   //UI4       SchemaGenFlags are defined in CatInpro.meta
    ULONG                       ConfigItemName;         //String
    ULONG                       ConfigCollectionName;   //String
    ULONG                       PublicRowNameColumn;    //UI4       If PublicRowName is NULL, this specifies the column whose enum values represent possible PublicRowNames
    ULONG                       ContainerClassList;     //String    This is a comma delimited list of classes
    ULONG                       Description;            //String
    ULONG                       ChildElementName;       //String    This should be NULL unless one or more columns has the VALUEINCHILDELEMENT flag set on it.
};
const kciTableMetaPublicColumns = sizeof(TableMetaPublic)/sizeof(ULONG);

struct TagMetaPublic
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //String
    ULONG PRIMARYKEY FOREIGNKEY ColumnIndex;            //UI4       This is the iOrder member of the ColumnMeta
    ULONG PRIMARYKEY            InternalName;           //String
    ULONG                       PublicName;             //String
    ULONG                       Value;                  //UI4
    ULONG                       ID;                     //UI4
};
const kciTagMetaPublicColumns = sizeof(TagMetaPublic)/sizeof(ULONG);



#endif //__METATABLESTRUCTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\md5.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// md5.h
//
// A pretty-darned fast implementation of MD5
//

#ifndef __MD5_H__
#define __MD5_H__

/////////////////////////////////////////////////////////////////////////////////////
//
// Declaration of the central transform function
//
void __stdcall MD5Transform(ULONG state[4], const ULONG* data);
        
/////////////////////////////////////////////////////////////////////////////////////

#pragma pack(push, 1)


// This structure is used to return the final resulting hash.
// 
struct MD5HASHDATA
    {
    union
        {
        BYTE rgb[16];
        struct
            {
            ULONGLONG ullLow;
            ULONGLONG ullHigh;
            };
        struct
            {
            ULONG     u0;
            ULONG     u1;
            ULONG     u2;
            ULONG     u3;
            };
        };
    };

inline BOOL operator==(const MD5HASHDATA& me, const MD5HASHDATA& him)
    {
    return memcmp(&me, &him, sizeof(MD5HASHDATA)) == 0;
    }

inline BOOL operator!=(const MD5HASHDATA& me, const MD5HASHDATA& him)
    {
    return memcmp(&me, &him, sizeof(MD5HASHDATA)) != 0;
    }


// The engine that carries out the hash
//
class MD5
    {
    // These four values must be contiguous, and in this order
    union
        {
        ULONG       m_state[4];
        struct
            {
            ULONG       m_a;              // state 
            ULONG       m_b;              //     ... variables
            ULONG       m_c;              //            ... as found in
            ULONG       m_d;              //                    ... RFC1321
            };
        };
    
    BYTE        m_data[64];       // where to accumulate the data as we are passed it
    ULONGLONG   m_cbitHashed;     // amount of data that we've hashed
    ULONG       m_cbData;         // number of bytes presently in data
    
    BYTE        m_padding[64];    // padding data, used if length data not = 0 mod 64

public:

    /////////////////////////////////////////////////////////////////////////////////////

    void Hash(const BYTE* pbData, ULONG cbData, MD5HASHDATA* phash, BOOL fConstructed = FALSE)
        {
        Init(fConstructed);
        HashMore(pbData, cbData);
        GetHashValue(phash);
        }

    /////////////////////////////////////////////////////////////////////////////////////

    void Hash(const BYTE* pbData, ULONGLONG cbData, MD5HASHDATA* phash, BOOL fConstructed = FALSE)
        {
        Init(fConstructed);

        ULARGE_INTEGER ul;
        ul.QuadPart = cbData;

        while (ul.HighPart)
            {
            ULONG cbHash = 0xFFFFFFFF;                      // Hash as much as we can at once
            HashMore(pbData, cbHash);
            pbData      += cbHash;
            ul.QuadPart -= cbHash;
            }
        
        HashMore(pbData, ul.LowPart);                       // Hash whatever is left

        GetHashValue(phash);
        }

    /////////////////////////////////////////////////////////////////////////////////////

    void Init(BOOL fConstructed = FALSE);

    /////////////////////////////////////////////////////////////////////////////////////

    void HashMore(const void* pvInput, ULONG cbInput);

    /////////////////////////////////////////////////////////////////////////////////////

    void GetHashValue(MD5HASHDATA* phash);

    /////////////////////////////////////////////////////////////////////////////////////

    };

#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\pefixup.h ===
#ifndef __PEFIXUP_H__
#define __PEFIXUP_H__

// -----------------------------------------
// struct typedefs:
// -----------------------------------------


//  The meta tables
#define ciTotal_ColumnMeta              0x0800
#define ciUnmodifyable_ColumnMeta       56
#define ciTotal_DatabaseMeta            0x0010
#define ciUnmodifyable_DatabaseMeta     2
#define ciTotal_IndexMeta               0x0010
#define ciUnmodifyable_IndexMeta        1
#define ciTotal_QueryMeta               0x0030
#define ciUnmodifyable_QueryMeta        1
#define ciTotal_RelationMeta            0x0080
#define ciUnmodifyable_RelationMeta     1
#define ciTotal_TableMeta               0x0800
#define ciUnmodifyable_TableMeta        8
#define ciTotal_TagMeta                 0x0400
#define ciUnmodifyable_TagMeta          1

//  These are the pools for types that usually exist as pointers.  Instead they're stored as indexes into
//  these pools.  The ULong pool (since obviously ULongs aren't usually stored as pointers) is used as the
//  fixed table pool.  This is where the wiring and any other fixed tables end up once the XML is parsed.
//  The only fixed tables that don't end up in the ULong pool are those needed to bootstrap the process.
//  For now this consists of only the meta tables; but in the future, even these might go into the ULong
//  pool.
#define ciTotal_Guids                   0x0020
#define ciUnmodifyable_Guids            2
#define ciTotal_WChar                   0x8000
#define ciUnmodifyable_WChar            102
#define ciTotal_Bytes                   0x4000
#define ciUnmodifyable_Bytes            4
#define ciTotal_ULong                   0x4000
#define ciUnmodifyable_ULong            1
#define ciTotal_UI4                     0x4000
#define ciUnmodifyable_UI4              257
#define ciTotal_HashedIndex             0xE000
#define ciUnmodifyable_HashedIndex      1

#define kcbDataHeap                     ((ciTotal_Guids)*sizeof(GUID) + (ciTotal_WChar)*sizeof(WCHAR) + (ciTotal_Bytes))

//  These signatures are used to verify the position of each of htese structures within the PE file.  The
//  0th entry of each of these arrays starts with Signature0 followed by Signature1.  This 0th element is
//  not considered as part of the array so the count of elements in the array is always minus this 0th
//  element.  Thus element 1 becomes the 0th element after this signature verification is done.  Since we
//  always use indexes to reference into these structs, it is sometimes useful to reserve an element to
//  indicate NULL.  An index to this reserved element is interpreted as NULL (and NOT as a pointer to
//  a NULL element).  This reserved element is usually element 1 which gets translated as the 0th element.
//  This is particularly useful in the above arrays, where a 0 index into the WChar array indicates NULL
//  and not a pointer to the 0th element.
#define ColumnMetaSignature0    0x204fe00e
#define ColumnMetaSignature1    0xe00f205f

#define DatabaseMetaSignature0  0xfd961035
#define DatabaseMetaSignature1  0x1037fd9d

#define GlobalSignature0        0x104bfdc1
#define GlobalSignature1        0xfdc7104e

#define IndexMetaSignature0     0x103efdb3
#define IndexMetaSignature1     0xfdb6103f

#define QueryMetaSignature0     0x109dfdea
#define QueryMetaSignature1     0xfdf510a5

#define RelationMetaSignature0  0x1057fdd2
#define RelationMetaSignature1  0xfdd3105f

#define TableMetaSignature0     0xfd5c1027
#define TableMetaSignature1     0x102bfd95

#define TagMetaSignature0       0xfda3103a
#define TagMetaSignature1       0x103bfdae

#define UI4Signature0           0x10adfdfa
#define UI4Signature1           0xfe0310b1

#define ULongSignature0         0x106bfdd9
#define ULongSignature1         0xfddb1071

#define HashedIndexSignature0   0x1061fdd5
#define HashedIndexSignature1   0xfdd61066

#define DataHeapSignature0      0x208ee01b
#define DataHeapSignature1      0xe0222093

//The numbers below can be used as signatures (a histogram of catinpro revealed that none of the WORDs appeared in the bin).
//When we run out of signatures, we can generate some more by writing a program that searches for unique WORDs within Catalog.dll, and combining two of them.
//0x209de027
//0xe028209e
//0x209fe042
//0xe04c20a5
//0x20aae04f
//0xe05220ae
//0x20b2e054
//0xe05e20d6
//0x20dbe05f
//0xe07220dd
//0x20dee07a
//0xe07b20e6
//0x20e7e07c
//0xe08f20ed
//0x20f5e096
//0xe09720f7
//0x20fbe098
//0xe09920fd
//0x210de09a
//0xe09b2115
//0x211be09c
//0xe09d2126
//0x2127e0a2


//These are the 7 metas and their placement in the TableMeta table.  This is useful so we don't have to search
//for meta since it's hard coded to these locations.
#define g_iColumnMetas_TableMeta    1
#define g_iDatabaseMetas_TableMeta  2
#define g_iIndexMetas_TableMeta     3
#define g_iTableMetas_TableMeta     4
#define g_iTagMetas_TableMeta       5
#define g_iRelationMetas_TableMeta  6
#define g_iQueryMetas_TableMeta     7


#define PRIVATE         //A private member is not exposed as part of the table but accessed directly by some piece of code. 
#define PRIVATE_INDEX   //A private index is not exposed through the SimpleTable; but is used internally to provide fast access and minimize searches. 
#define PRIMARYKEY
#define FOREIGNKEY

struct ColumnMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //Index into aWChar
    ULONG PRIMARYKEY            Index;                  //Column Index
    ULONG                       InternalName;           //Index into aWChar
    ULONG                       PublicName;             //Index into aWChar
    ULONG                       Type;                   //These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
    ULONG                       Size;                   //
    ULONG                       MetaFlags;              //ColumnMetaFlags defined in CatMeta.xml
    ULONG                       DefaultValue;           //Index into whatever pool the 'Type' member indicates
    ULONG                       FlagMask;               //Only valid for flags
    ULONG                       StartingNumber;         //Only valid for UI4s
    ULONG                       EndingNumber;           //Only valid for UI4s
    ULONG                       CharacterSet;           //Index into aWChar - Only valid for WSTRs
    ULONG                       SchemaGeneratorFlags;   //ColumnMetaFlags defined in CatMeta.xml
    ULONG PRIVATE               ciTagMeta;              //Count of Tags - Only valid for UI4s
    ULONG PRIVATE_INDEX         iTagMeta;               //Index into aTagMeta - Only valid for UI4s
    ULONG PRIVATE_INDEX         iIndexName;             //IndexName of a single column index (for this column)
};
#define ciColumnMetaPublicColumns   13             //This is for verification in within the PE
#define ciColumnMetaPrivateColumns  3              //This is for verification in within the PE

struct DatabaseMeta
{
    ULONG PRIMARYKEY            InternalName;       //Index into aWChar
    ULONG                       PublicName;         //Index into aWChar
    ULONG                       BaseVersion;        //
    ULONG                       ExtendedVersion;    //
    ULONG                       CountOfTables;      //Count of tables in database
    ULONG PRIVATE               iSchemaBlob;        //Index into aBytes
    ULONG PRIVATE               cbSchemaBlob;       //Count of Bytes of the SchemaBlob
    ULONG PRIVATE               iNameHeapBlob;      //Index into aBytes
    ULONG PRIVATE               cbNameHeapBlob;     //Count of Bytes of the SchemaBlob
    ULONG PRIVATE_INDEX         iTableMeta;         //Index into aTableMeta
    ULONG PRIVATE               iGuidDid;           //Index to aGuid where the guid is the Database InternalName cast as a GUID and padded with 0x00s.
};
#define ciDatabaseMetaPublicColumns   5             //This is for verification in within the PE
#define ciDatabaseMetaPrivateColumns  6             //This is for verification in within the PE

struct IndexMeta
{
    ULONG PRIMARYKEY    Table;              //Index into aWChar
    ULONG PRIMARYKEY    InternalName;       //Index into aWChar
    ULONG               PublicName;         //Index into aWChar
    ULONG PRIMARYKEY    ColumnIndex;        //This is the iOrder member of the ColumnMeta
    ULONG               ColumnInternalName; //Index into aWChar
    ULONG               MetaFlags;          //Index Flag
};
#define ciIndexMetaPublicColumns  6
#define ciIndexMetaPrivateColumns 0


struct RelationMeta
{
    ULONG PRIMARYKEY FOREIGNKEY PrimaryTable;           //Index into aWChar
    ULONG                       PrimaryColumns;         //Index into aBytes
    ULONG PRIMARYKEY FOREIGNKEY ForeignTable;           //Index into aWChar
    ULONG                       ForeignColumns;         //Index into aBytes
    ULONG                       MetaFlags;
};
#define ciRelationMetaPublicColumns  5
#define ciRelationMetaPrivateColumns 0


struct QueryMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;                  //Index into aWChar
    ULONG PRIMARYKEY            InternalName;           //Index into aWChar
    ULONG                       PublicName;             //Index into aWChar
    ULONG                       Index;
    ULONG                       CellName;               //Index into aWChar
    ULONG                       Operator;
    ULONG                       MetaFlags;
};
#define ciQueryMetaPublicColumns  7
#define ciQueryMetaPrivateColumns 0


struct TableMeta
{
    ULONG FOREIGNKEY            Database;               //Index into aWChar
    ULONG PRIMARYKEY            InternalName;           //Index into aWChar
    ULONG                       PublicName;             //Index into aWChar
    ULONG                       PublicRowName;          //Index into aWChar
    ULONG                       BaseVersion;            //
    ULONG                       ExtendedVersion;        //
    ULONG                       NameColumn;             //iOrder of the NameColumn
    ULONG                       NavColumn;              //iOrder of the NavColumn
    ULONG                       CountOfColumns;         //Count of Columns
    ULONG                       MetaFlags;              //TableMetaFlags are defined in CatInpro.meta
    ULONG                       SchemaGeneratorFlags;   //SchemaGenFlags are defined in CatInpro.meta
    ULONG                       ConfigItemName;
    ULONG                       ConfigCollectionName;
    ULONG                       PublicRowNameColumn;    //If PublicRowName is NULL, this specifies the column whose enum values represent possible PublicRowNames
    ULONG PRIVATE               ciRows;                 //Count of Rows in the Fixed Table (which if the fixed table is meta, this is also the number of columns in the table that the meta describes).
    ULONG PRIVATE_INDEX         iColumnMeta;            //Index into aColumnMeta
    ULONG PRIVATE_INDEX         iFixedTable;            //Index into g_aFixedTable
    ULONG PRIVATE               cPrivateColumns;        //This is the munber of private columns (private + ciColumns = totalColumns), this is needed for fixed table pointer arithmetic
    ULONG PRIVATE               cIndexMeta;             //The number of IndexMeta entries in this table
    ULONG PRIVATE_INDEX         iIndexMeta;             //Index into aIndexMeta
    ULONG PRIVATE_INDEX         iHashTableHeader;       //If the table is a fixed table, then it will have a hash table.
    ULONG PRIVATE               nTableID;               //This is a 24 bit Hash of the Table name.
    ULONG PRIVATE_INDEX         iServerWiring;          //Index into the ServerWiringHeap (this is a temporary hack for CatUtil)
    ULONG PRIVATE               cServerWiring;          //Count of ServerWiring (this is a temporary hack for CatUtil)
};
#define ciTableMetaPublicColumns   14               //This is for verification in within the PE
#define ciTableMetaPrivateColumns  10                //This is for verification in within the PE

struct TagMeta
{
    ULONG PRIMARYKEY FOREIGNKEY Table;              //Index into aWChar
    ULONG PRIMARYKEY FOREIGNKEY ColumnIndex;        //This is the iOrder member of the ColumnMeta
    ULONG PRIMARYKEY            InternalName;       //Index into aWChar
    ULONG                       PublicName;         //Index into aWChar
    ULONG                       Value;
};
#define ciTagMetaPublicColumns   5             //This is for verification in within the PE
#define ciTagMetaPrivateColumns  0             //This is for verification in within the PE



//All hash tables begin with a HashTableHeader that indicates the Modulo and the total size of the HashTable (in number of HashIndexes that follow
//the HashTableHeader).  The size should be equal to Modulo if there are NO HashIndex collisions.  If there are NO HashIndex collisions, then all
//of the HashedIndex.iNext members should be 0.  If there are collisions, all iNext values should be greater than or equal to Modulo.
struct HashedIndex
{
    ULONG       iNext;  //If the hash value is not unique then this points to the next HashedIndex with the same hash value
    ULONG       iRow;   //Index to the Meta table row for which the hash was calculated
};

struct HashTableHeader
{
    ULONG       Modulo;
    ULONG       Size;//This is the size in number of HashedIndexes that follow the HashTableHeader
};


struct PointersNeededToFixupThePE
{
    ULONG                ulSizeOfThisStruct;//This is for versioning
    ULONG                ulSignature;
    ULONG         *      pulSignature;
    DatabaseMeta  *      aDatabaseMeta;
    ULONG         *      pciDatabaseMetas;
    ULONG         *      pciTotalDatabaseMetas;
    TableMeta     *      aTableMeta;
    ULONG         *      pciTableMetas;
    ULONG         *      pciTotalTableMetas;
    ColumnMeta    *      aColumnMeta;
    ULONG         *      pciColumnMetas;
    ULONG         *      pciTotalColumnMetas;
    GUID          *      aGuid;
    ULONG         *      pciGuid;
    ULONG         *      pciTotalGuid;
    WCHAR         *      aWChar;
    ULONG         *      pciWChar;
    ULONG         *      pciTotalWChar;
    TagMeta       *      aTagMeta;
    ULONG         *      pciTagMeta;
    ULONG         *      pciTotalTagMeta;
    unsigned char *      aBytes;
    ULONG         *      pciBytes;
    ULONG         *      pciTotalBytes;
    IndexMeta     *      aIndexMeta;
    ULONG         *      pciIndexMeta;
    ULONG         *      pciTotalIndexMeta;
    ULONG         *      aULong;                //This is where fixed tables go (in the ULong pool)
    ULONG         *      pciULong;
    ULONG         *      pciTotalULong;
    QueryMeta     *      aQueryMeta;        
    ULONG         *      pciQueryMeta;
    ULONG         *      pciTotalQueryMeta;
    RelationMeta  *      aRelationMeta;        
    ULONG         *      pciRelationMeta;
    ULONG         *      pciTotalRelationMeta;
    ULONG         *      aUI4;        
    ULONG         *      pciUI4;
    ULONG         *      pciTotalUI4;
    HashedIndex   *      aHashedIndex;
    ULONG         *      pciHashedIndex;
    ULONG         *      pciTotalHashedIndex;
};


#endif //__PEFIXUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\mmgr.h ===
#ifndef __MMGR_H__
#define __MMGR_H__

/******************************************************************************
Microsoft D.T.C. (Distributed Transaction Coordinator)

Copyright 1996 Microsoft Corporation.  All Rights Reserved.

@doc

@module MMgr.h  |

	Contains memory manager. 

@devnote None
-------------------------------------------------------------------------------
	@rev 0	| 15th July | SamarS	| Created
*******************************************************************************/


//---------------------------------------------------------
//					TYPEDEFS
//---------------------------------------------------------
typedef unsigned long	DWORD;
typedef unsigned short	WORD;

// Information that need to be associated with each object 
// in MemMgrSimple. Equivalent to CABSTRACT_OBJECT in MemMgr.
typedef struct	 _ObjectBlob
{
	void 	*	pvPageStart;	// Start address of the page

}	OBJECT_BLOB;

typedef enum _PageState
{
	PSTATE_INCOMPLETE,
	PSTATE_COMPLETE,
	PSTATE_CAN_BE_DELETED

}	PAGE_STATE;
//---------------------------------------------------------
//					INCLUDES GO HERE
//---------------------------------------------------------
//#include <windows.h>
#include "dtc.h"
#include "dtcmem.h"
#include "UTList.h"
#include <stddef.h>
#include "UTAssert.h"
#include "UtSem.H"

//---------------------------------------------------------------------------
// A comment on the comments :
//		In the following, the words Inactive, free and not-in-use have 
//		been used interchangeably. They all refer to the memory objects 
//		which are not being used, i.e. either they are brand new, or have 
//		been recycled.
//
//---------------------------------------------------------
//					FORWARD  DECLARATIONS
//---------------------------------------------------------
template <class T> class MemMgr;

// for example, T can be CClique


//---------------------------------------------------------
//					CONSTANTS
//---------------------------------------------------------
#ifndef		DEFAULT_PAGE_SIZE
#define		DEFAULT_PAGE_SIZE		4096
#endif

const	DWORD		MAX_CACHE_COUNT		=	10;

#define	MAX (x,y)	(x > y) ? x : y


//---------------------------------------------------------
//					FUNCTION PROTOTYPES GO HERE
//---------------------------------------------------------
void * ObtainMemPage (void);
void FreeMemPage (void * pv);

 
//-----**************************************************************-----
// @class template class
//		The CMemMgrObj is an ABSTRACT BASE CLASS for ALL objects which use 
//		this memory manager. This class defines the basic operation that 
//		all objects must support regardless of what type they are.
//
//-----**************************************************************-----
class CABSTRACT_OBJECT
{
// @access Public members

public:
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// member functions
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember	Overloading the new operator
	//			and not implementing it
	void	*	operator	new (unsigned int s);

	// @cmember	Overloading the delete operator
	//			and not implementing it
	void		operator	delete (void * pv);

	// @cmember	Action to be performed at shut down request
	virtual		HRESULT		ShutDown (void);

	// @cmember	Action to be performed at Initialization (exactly once)
	void					MMInit (void * pvPageAddress);

	// @cmember	Action to be performed every time a reset needs to be done
	virtual		void		Recycle (void);

	// @cmember	Remove this from the list of objects
	void					RemoveFromList(	UTStaticList <CABSTRACT_OBJECT *>
											* plistObjects);


	// The object for which memory is being managed, say CFoo
	// needs to have a function of the following form
	//		CFoo *  CFoo::CreateInstance()
	//		{
	//			return (g_MMCFoo.GetNewObject() );
	//		}
	//
	// where g_MMCFoo is a global object :
	//		MemMgr <CFoo *> g_MMCFoo;
	//

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// data members
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Embedded Link object
	//			for use in keeping Inactive list and 
	//			(possibly) active list
	// Note that the object needs to have a separate UTLink embedded 
	// in it, if a list of objects need to be maintained
	// For example, CNameService maintains a list of CNameObjects
	// which is different from the Active list maintained by Memory Manager
	UTLink <CABSTRACT_OBJECT *>	m_MMListLink;

	// Store the address of the page to which the object belongs
	void					*	m_pvMMPageAddress;

}; //	End class CABSTRACT_OBJECT


/* ----------------------------------------------------------------------------
@class CPageInfo
	Stores a pointer to a page (memory) and the total size of the page
@hunagrian	CPageInfo
----------------------------------------------------------------------------- */
class CPageInfo
{
private:
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// data members
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// The first two are redundant
	DWORD				m_dwcbTotal;		//Total number of bytes in this page

	unsigned char *		m_puch;				//Pointer to the begining of page

	// @cmember Start address where the objects reside
	void			*		m_pvMMPageStart;		

	// @cmember Pointer to the starting free location in the page
	char			*		m_pchFreeLocation;		

	// @cmember Size of the page
	DWORD					m_cbPageSize;

	// @cmember Link to maintain a list of Page Info objects
	UTLink <CPageInfo *>	m_linkPageInfo;

	// @cmember Number of open ref counts on this page
	DWORD					m_dwcOpenRefCount;

	// @cmember Number of closed ref counts on this page
	DWORD					m_dwcClosedRefCount;

	// @cmember Current state of this page
	PAGE_STATE				m_STATE;

	// @cmember The Ref count for this page
	long					m_lcRefCount;

	// @cmember Size of the largest object on this page
	// DWORD					m_dwcbMaxSize;

public:

	DWORD					m_dwcbAlloted;		//Count given out

	CRITICAL_SECTION		m_csForwcbAlloted;

public:
	CPageInfo 	( void );
	~CPageInfo 	( void );

	void			Init (void);
	void			AddRef ( void );
	void			Release ( void );
	void			MMInit ( void );
	void			Recycle ( void );
	void *			AllocBuffer ( size_t size, BOOL fLock );
	size_t			SpaceAvailable (void);
	BOOL			FreeSpaceAvailable (size_t	cbSize);
	BOOL			IsInThisPage(void * pvFreememSpace);
	BOOL			IsFreePage (void);
	unsigned char *	GetBeginingOfBuffer(void);

	// @cmember	Remove this from the list of pages
	void			RemoveFromList(UTStaticList <CPageInfo *> * plistPageInfo);

	// @cmember	Allocate a chunk of memory and increment the open ref count
	void		*	AllocateMemory(size_t cbSize);

	// Allocate memory and call the constructor
	void	*	operator	new ( unsigned int s )
	{
		// Allocate space for the page
		return ObtainMemPage ();

	};

	// Deallocate memory and call the destructor
	void	operator	delete (void * pvMMPage)
	{
		AssertSz (pvMMPage, "Delete operator called on a NULL pointer");
 		FreeMemPage (pvMMPage);

	};



private:
	friend class CResourceManager;
	friend class CQueueManagerInIP;
	friend class CQueueManagerOutIP;
	friend class COutQueueIP;
	friend class MemMgrSimple;
}; //End class CPageInfo




 /* ----------------------------------------------------------------------------
 @class CMemCache
 
 ---------------------------------------------------------------------------- */
 class CMemCache
 {
 private:	
 	CSemExclusive		m_semexcPageSet;
 	
 	DWORD				m_dwcInCache;
 	void	*			m_rgpv [MAX_CACHE_COUNT];
 
 
 public:
 	CMemCache(void);
 	~CMemCache (void);
 
 	void * ObtainMemPage (void);
 	void FreeMemPage (void * pv);

 }; //end class CMemCache

//-----**************************************************************-----
// @class	Class containing infomation about active pages
//			Note that the memory manager keeps only active pages
//			An active page is defined to be one which has at least one 
//			active (in-use) object.
//			Thus the memory manager maintains a pool of inactive
//			objects of the active pages.
//			It also maintains a static list of Active Objects. 
//			This may be useful for operations such as shutdown.
//						
//			A page is called Complete if all its objects are in-use;
//			otherwise it is called Incomplete.
//
//			Page Info has the following data members :
//				The address of the real page
//				Size of the page (later, this could be made state dependent)
//				A UTLink object (to keep the list of pages)
//				A pointer to the coresponding free list	
//				A pointer to the active list	
//
// @tcarg class | T | data type for which memory is being managed
//-----**************************************************************-----

template <class T> class	CMMPageInfo
{

public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// constructors/destructor
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Constructor
	CMMPageInfo (void);
	
	// @cmember Constructor
	CMMPageInfo (size_t cbPageSize);

	// @cmember Destructor
	~CMMPageInfo (void);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// action protocol
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Check if the page is Complete
	BOOL			IsCompletePage(void);

	// @cmember Create an Inactive list for a new page
	void			CreateInactiveList(void);

	// @cmember Allocate space for the page, and create Inactive list
	void			Init(void);

	// @cmember Delete the space corresponding to a page.
	static BOOL		DeletePage(void * pvFreePage);

	// @cmember 
	void *			ObtainMemory (DWORD dwSize);

	// @cmember	Remove this from the list of pages
	void			RemoveFromList(	UTStaticList <CMMPageInfo <T> *> 
									* plistPageInfo);

	// Allocate memory and call the constructor
	void	*	operator	new ( unsigned int s )
	{
		// Allocate space for the page
 		return ObtainMemPage ();

	};


protected:
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// friends
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	friend class MemMgr< T >;

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// data members
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Pointer to the actual page in memory is 'this'
	// m_linkPageInfo.m_value  is also the same

	// @cmember Start address where the objects reside
	void				*		m_pvMMPageStart;		

	// @cmember Size of the page
	//			This is the total size (includes space for PageInfo)	
	DWORD						m_cbPageSize;

	// @cmember Size of the Object
	// not being used in current code
	// size_t						m_cbObjectSize;

	// @cmember Link to maintain a list of Page Info objects
	UTLink <CMMPageInfo <T> *>	m_linkPageInfo;

#ifdef _DEBUG
	// @cmember Pointer to the list of in-use objects
	//UTStaticList <T *>	*		m_plistActiveObjects;	
#endif

	// @cmember Pointer to the list of not-in-use objects
	UTStaticList <T *>			m_listInactiveObjects;

	// @cmember Number of active objects on this page
	DWORD						m_dwcActiveObjects;

	// @cmember Total number of objects on this page
	DWORD						m_dwcNumObjects;

	void	*					m_pvNextToAllocate;

};	//	End class CMMPageInfo


//-----**************************************************************-----
// @class	The MemMgrSimple class consists of a collection of pages, a part of 
//			each of which is in-use. 
//			Each page has the following associated with it :
//				The address of the real page
//				Size of the page (later, this could be made state dependent)
//				The count of open references
//				The count of closed references
//				A UTLink object (to keep the list of pages)
//
//			This is mainly used to allocate variable size memory chunks.
//	
//-----**************************************************************-----

class MemMgrSimple
{
// @access Public members
public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// constructors/destructor
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Consructor
	MemMgrSimple	(void);

	// @cmember Consructor
	MemMgrSimple	(DWORD dwPageSize);

	// @cmember Destructor
	~MemMgrSimple (void);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// action protocol
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Obtain Memory space from the memory manager
	void	*	GetMemSpace	(size_t	cbSize);
	
	// @cmember Free memory space by giving it to memory manager
	void		FreeMemSpace(void	* pvFreeMemSpace);

protected:

	// @cmember Find the page to which the object belongs
	CPageInfo *	FindPage(void	* ptObject);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// data members
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	// @cmember An exclusive lock for this Memory Manager
	CSemExclusive				m_semexcForMemMgr;

#ifdef _DEBUG
	// @cmember A static list of CPageInfo objects
	//			Each CPageInfo object corresponds to a page in memory
	UTStaticList <CPageInfo *>	m_listPageInfo;
#endif

	// @cmember Size of each Page
	//			This is the total size (includes space for PageInfo)	
	//			Not required if decided dynamically for each page
	DWORD						m_cbPageSize;

	// @cmember The CPageInfo object from which memory is currently 
	//			being given out
	CPageInfo		*			m_pCurrentPage;	

};	//	End class MemMgrSimple



//-----**************************************************************-----
// @class	Template class
//			The MemMgr class consists of a collection of pages, a part of 
//			each of which is in-use. Each page is maintained as an Inactive 
//			list of objects. Each page has the following associated with it :
//				The address of the real page
//				Size of the page (later, this could be made state dependent)
//				A pointer to the coresponding free list	
//				A UTLink object (to keep the list of pages)
//
//
// @tcarg class | T | data type for which memory is being managed
//-----**************************************************************-----

template <class T> class MemMgr : public MemMgrSimple
{
// @access Public members
public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// constructors/destructor
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Consructor
	MemMgr	(void);

	// @cmember Consructor
	MemMgr	(DWORD dwPageSize);

	// @cmember Destructor
	~MemMgr (void);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// action protocol
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Obtain an object from the memory manager
	T	*	GetNewObject	(void);
	
	// @cmember Free an object by giving it to memory manager
	void	FreeObject		(T	* ptFreeObject);

	void *	ObtainMemory	(DWORD dwSize);

protected:

	// @cmember Find the page to which the object belongs
	CMMPageInfo <T> *	FindPage(T	* ptObject);

	// @cmember Find an Incomplete Page
	CMMPageInfo <T> *	FindIncompletePage(void);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// data members
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	// @cmember A static list of CMMPageInfo objects
	//			Each CMMPageInfo object corresponds to a page in memory
	UTStaticList <CMMPageInfo <T> *>	m_listPageInfo;

	#ifdef _DEBUG
	// @cmember A static list of Active Objects
	//UTStaticList <T *>				m_listActiveObjects;	
	#endif

	// @cmember Size of the Object for which memory is being managed
	DWORD							m_cbObjectSize;

	// @cmember The page from which a new inactive list is being created
	CMMPageInfo <T>		*			m_pCMMPageBeingBuilt;

};	//	End class MemMgr



//-----------------------------------------------------------------------------
//
//			IMPLEMENTATION of CABSTRACT_OBJECT
//
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// @mfunc	This function is invoked at a shut down request
//			It is a pure virtual function
//-----------------------------------------------------------------------------
inline HRESULT		CABSTRACT_OBJECT::ShutDown(void)
{
	return S_OK;
}


//-----------------------------------------------------------------------------
// @mfunc	This function is invoked for initialization (exactly once)
//-----------------------------------------------------------------------------
inline void		CABSTRACT_OBJECT::MMInit(void * pvPageAddress)
{
	m_MMListLink.m_Value	= this;
	m_pvMMPageAddress		= pvPageAddress;
}


//-----------------------------------------------------------------------------
// @mfunc	This function is invoked for resetting
//-----------------------------------------------------------------------------
inline void		CABSTRACT_OBJECT::Recycle(void)
{
		
}


//---------------------------------------------------------------------------
// @mfunc	Remove this object from the list of objects
//---------------------------------------------------------------------------
inline void	CABSTRACT_OBJECT::RemoveFromList(UTStaticList <CABSTRACT_OBJECT *>
											 * plistObjects)												
{
	UTLink <CABSTRACT_OBJECT *> *	pPrevLink;
	UTLink <CABSTRACT_OBJECT *> *	pNextLink;
	

	pPrevLink = (UTLink <CABSTRACT_OBJECT *> *)m_MMListLink.m_pPrevLink;
	pNextLink = (UTLink <CABSTRACT_OBJECT *> *)m_MMListLink.m_pNextLink;

	if ((pPrevLink == 0x0 ) && (pNextLink == 0x0)) 
	{
		plistObjects->m_pLastLink	= 0x0;
		plistObjects->m_pFirstLink	= 0x0;
	}
	else if (pPrevLink == 0x0 )
	{
		plistObjects->m_pFirstLink = pNextLink;
		pNextLink->m_pPrevLink		= 0x0;
	}
	else if (pNextLink == 0x0 )
	{
		plistObjects->m_pLastLink	= pPrevLink;
		pPrevLink->m_pNextLink		= 0x0;
	}
	else
	{
		pNextLink->m_pPrevLink = pPrevLink; 
		pPrevLink->m_pNextLink = pNextLink; 
	}
	
	// Update the number of objects in the list 
	plistObjects->m_ulCount--;

}	// End RemoveFromList






//-----------------------------------------------------------------------------
//
//			IMPLEMENTATION of CMMPageInfo
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// @mfunc	Constructor.
//
// @tcarg	class | T | data type for which memory is being managed
//
//-----------------------------------------------------------------------------
template <class T> CMMPageInfo<T>::CMMPageInfo(void)
{

}


//-----------------------------------------------------------------------------
// @mfunc	Constructor.
//
// @tcarg	class | T | data type for which memory is being managed
//
//-----------------------------------------------------------------------------
template <class T> CMMPageInfo<T>::CMMPageInfo(size_t cbPageSize)
{
	m_cbPageSize = cbPageSize;
}




//-----------------------------------------------------------------------------
// @mfunc	Destructor.
//
// @tcarg	class | T | data type for which memory is being managed
//
//-----------------------------------------------------------------------------
template <class T> CMMPageInfo<T>::~CMMPageInfo(void)
{
}


//-----------------------------------------------------------------------------
// @mfunc	Check if this is a Complete Page.
//
// @tcarg	class | T | data type for which memory is being managed
//
//-----------------------------------------------------------------------------
template <class T> BOOL	CMMPageInfo<T>::IsCompletePage(void)
{
	return (m_dwcActiveObjects == m_dwcNumObjects);

}	// End IsCompletePage


//---------------------------------------------------------------------------
// @mfunc	Creates the Inactive List for this page.
//
// @tcarg	class | T | data type for which memory is being managed
//
//---------------------------------------------------------------------------
template <class T> void CMMPageInfo<T>::CreateInactiveList(void)
{
	DWORD				dwc;
	T			*		pTNext;

	m_dwcActiveObjects	= 0;

	// Start with the begining of the page
	m_pvNextToAllocate	=  m_pvMMPageStart;

	// note that m_cbPageSize includes the size of the header portion
	m_dwcNumObjects		= (	m_cbPageSize - ALIGNED_SPACE(sizeof(CMMPageInfo<T>)))
							/ (ALIGNED_SPACE (sizeof (T)));

	//for the N number of objects that can be chopped out of the page, invoke
	//new on the object T, the new call will come back to this page
	for (dwc = 0; dwc < m_dwcNumObjects; dwc++)
	{
		pTNext = new T;		

		AssertSz (pTNext, "new T can not fail.");

		m_listInactiveObjects.InsertLast((UTLink <T *> *)(&(pTNext->m_MMListLink)));
		
		// set the m_Value to this object
		// and the Page Address to this page
		pTNext->MMInit((void *)this);

	} //end for loop

}	// End CreateInactiveList
 

//---------------------------------------------------------------------------
// @mfunc	Allocate space for the page, and other initializations
//			Only E_OUTOFRESOURCES should cause this to fail.
//
// @tcarg	class | T | data type for which memory is being managed
//
//---------------------------------------------------------------------------
template <class T>	void CMMPageInfo<T>::Init(// DWORD dwcbPageSize
											  void)
{
	BOOL				fRetVal			=	TRUE;

	// UNDONE : m_cbPageSize should be changed dynamically
	m_cbPageSize = DEFAULT_PAGE_SIZE * sizeof(char);

	m_linkPageInfo.m_Value = this;

	// Set the start address of the Page :
	m_pvMMPageStart	= (void *)((char *) this + ALIGNED_SPACE(sizeof(CMMPageInfo<T>)));

	CreateInactiveList();			

}	// End Init


/* ----------------------------------------------------------------------------
@mfunc <>
---------------------------------------------------------------------------- */
template <class T> inline void *	CMMPageInfo<T>::ObtainMemory	(DWORD dwSize)
{
	void *	pv;

	AssertSz (dwSize == sizeof (T), "Unexpected size requested");

	AssertSz (m_pvNextToAllocate, "Should have space to return");

	pv =  m_pvNextToAllocate;

	m_pvNextToAllocate = (void *)((char *)m_pvNextToAllocate +
							 ALIGNED_SPACE(sizeof(T)));

	AssertSz(pv, "Falied to find space -- ObtainMemory");

	return pv;

} //end ObtainMemory


//---------------------------------------------------------------------------
// @mfunc	Remove this page from the list of pages
//
// @tcarg	class | T | data type for which memory is being managed
//
//---------------------------------------------------------------------------
template <class T> inline void	CMMPageInfo<T>::RemoveFromList
						(
							UTStaticList  <CMMPageInfo <T> *> * plistPageInfo
						)
{
	UTLink <CMMPageInfo <T> *> *	pPrevLink;
	UTLink <CMMPageInfo <T> *> *	pNextLink;
	

	pPrevLink = m_linkPageInfo.m_pPrevLink;
	pNextLink = m_linkPageInfo.m_pNextLink;

	if ((pPrevLink == 0x0 ) && (pNextLink == 0x0)) 
	{
		plistPageInfo->m_pLastLink	= 0x0;
		plistPageInfo->m_pFirstLink	= 0x0;
	}
	else if (pPrevLink == 0x0 )
	{
		plistPageInfo->m_pFirstLink = pNextLink;
		pNextLink->m_pPrevLink		= 0x0;
	}
	else if (pNextLink == 0x0 )
	{
		plistPageInfo->m_pLastLink	= pPrevLink;
		pPrevLink->m_pNextLink		= 0x0;
	}
	else
	{
		pNextLink->m_pPrevLink = pPrevLink; 
		pPrevLink->m_pNextLink = pNextLink; 
	}
	
	// Update the number of page headers in the list 
	plistPageInfo->m_ulCount--;

}	// End RemoveFromList


//---------------------------------------------------------------------------
// @mfunc	Free the memory space used by this Page.
//
// @tcarg	class | T | data type for which memory is being managed
//
//---------------------------------------------------------------------------
template <class T> BOOL	CMMPageInfo<T>::DeletePage(void * pvFreePage)
{
	BOOL fRetVal = TRUE;
	AssertSz(pvFreePage, "Start address invalid -- DeletePage");
 	FreeMemPage (pvFreePage);

	return fRetVal;

}	// End DeletePage


//-----------------------------------------------------------------------------
//
//			IMPLEMENTATION of MemMgrSimple 
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// @mfunc	Constructor.
//-----------------------------------------------------------------------------
inline MemMgrSimple::MemMgrSimple(void)
{
	m_pCurrentPage	= 0x0;
	m_cbPageSize	= DEFAULT_PAGE_SIZE;
}


//-----------------------------------------------------------------------------
// @mfunc	Constructor.
//-----------------------------------------------------------------------------
inline MemMgrSimple::MemMgrSimple(DWORD cbPageSize)
{
	m_pCurrentPage	= 0x0;
	m_cbPageSize	= cbPageSize;
}


//-----------------------------------------------------------------------------
// @mfunc	Destructor.
//-----------------------------------------------------------------------------
inline MemMgrSimple::~MemMgrSimple(void)
{
	//do nothing
}



//---------------------------------------------------------------------------
// @mfunc	Obtain Memory space from the simple memory manager
//
//			Algorithm :
//			1. Find out if the current page has free space
//
//			2. It it has free space
//				Then
//					(a)	Allocate a chunk of memory
//				Else
//				If this page does not have any open references
//				Then 
//					(a) Recycle it
//				Else
//					(a) Create a new Page
//					(b) Put this Page into the list of active pages
//					
//			3. Increment the number of open ref counts in this page
//			4. Allocate a chunk of memory from the current page.
//			5. Return a pointer to this chunk of memory space.
//
//			If the system is out of memory (allocation fails), then a NULL
//			pointer is returned.
//		
//---------------------------------------------------------------------------
	
inline void  *	MemMgrSimple::GetMemSpace (size_t	cbSize)
{
	void		*	pvMemSpace;		
	BOOL			fSpaceAvailable;


	cbSize = ALIGNED_SPACE (cbSize + sizeof(OBJECT_BLOB));

	AssertSz (cbSize % BYTE_ALIGNMENT == 0, "Non aligned size -- GetMemSpace");

	fSpaceAvailable = FALSE;
	
	// Acquire an exclusive lock
	m_semexcForMemMgr.Lock();

	if (m_pCurrentPage != 0x0)
	{
		//--------------------------------------------------------------------
		//	1. Find out if the current page has free space
		fSpaceAvailable = m_pCurrentPage->FreeSpaceAvailable(cbSize);

		//--------------------------------------------------------------------
		//	2. It it has free space
		//		Then
		//			(a)	Allocate a chunk of memory
		//
		//		Else
		//			If this page does not have any open references
		//			Then 
		//				(a) Recycle it
		//			Else
		//				(a) Create a new Page
		//				(b) Put this Page into the list of active pages
		//					
		if (fSpaceAvailable == TRUE)
		{
			goto AllocateMemSpace;
		}

		// The current page does not have 'significant' amount of space
		m_pCurrentPage->m_STATE = PSTATE_COMPLETE;
			
		// Check if the current page can be recycled
		if (m_pCurrentPage->IsFreePage())
		{				

			m_pCurrentPage->Recycle();
				
			goto AllocateMemSpace;

		} //end if the current page is complete
		else 
		{
			m_pCurrentPage = 0x0;
		}
		
	} //end if there is a current page

	// Create a new page in either of the 2 cases :
	// (a) There is no current page
	// (b) The current page exists, is Complete, but can't be recycled
	//     (because of open references) 
	AssertSz (	(m_pCurrentPage == 0x0), 
				"Current page is not NULL -- GetMemSpace");
	
	// Create a new page info object
	// It becomes the current page
	m_pCurrentPage = new CPageInfo;
	
	if (m_pCurrentPage == 0x0)
	{
		pvMemSpace = 0x0;
		// The goto is used to keep the critical section as a block
		// with only one entry and exit point
		goto ReturnFromGetMemSpace;
	}

	// Initialize the page
	m_pCurrentPage->MMInit();

#ifdef _DEBUG
	m_listPageInfo.InsertFirst(&(m_pCurrentPage->m_linkPageInfo));
#endif

	

AllocateMemSpace:

	//---------------------------------------------------------------------------
	//	3. Increment the number of open ref counts in this page	
	//	4. Allocate a chunk of memory from the current page.
	pvMemSpace = m_pCurrentPage->AllocateMemory(cbSize);

ReturnFromGetMemSpace:
	
	// Release the lock
	m_semexcForMemMgr.UnLock();
	
	//---------------------------------------------------------------------------
	//	5. Return a pointer to this chunk of memory space.
	return pvMemSpace;

}	// End GetMemSpace


//---------------------------------------------------------------------------
// @mfunc	Find the page to which a memory chunk belongs.
//---------------------------------------------------------------------------
inline CPageInfo *	MemMgrSimple::FindPage (void * pvFreeSpace)
{
	OBJECT_BLOB	*	pObjectBlob;

	// Validate that the input parameter is not NULL
	AssertSz (	pvFreeSpace, "Invalid input parameter -- FindPage");

	pObjectBlob	= (OBJECT_BLOB *)((char *)pvFreeSpace - sizeof(OBJECT_BLOB));

	return (CPageInfo *) (pObjectBlob->pvPageStart);

}	// End function MemMgrSimple::FindPage


//---------------------------------------------------------------------------
// @mfunc	Free memory space by giving it to memory manager
//
//			Algorithm :
//			1. Find out which page does this object belong to.
//			2. Increment the closed ref count on this page
//			3. If returning this object makes the page inactive,
//			   Then
//				(a) Free the memory used by the page
//				(b) Remove the CPageInfo object corresponding to 
//					this page from the list of pages
//
//---------------------------------------------------------------------------

inline void	MemMgrSimple::FreeMemSpace (void * pvFreeSpace)
{
/*	CPageInfo	  *	pCPageInfo;

	AssertSz(pvFreeSpace, "Invalid argument pvFreeSpace");

	//---------------------------------------------------------------------------
	//	1. Find out which page does this object belong to.
	pCPageInfo = FindPage(pvFreeSpace);


	//---------------------------------------------------------------------------
	//	2. Increment the closed ref count on this page
	//	3. If returning this object makes the page inactive,
	//	   Then
	//			(a) Free the memory used by the page
	//			(b) Remove the CPageInfo object corresponding to 
	//				this page from the list of pages
	//
	AssertSz(pCPageInfo, "Object to be recycled not found by the mem manager");
	
	pCPageInfo->AddRef();

	//	Increment the closed ref count on this page
	InterlockedIncrement((long *)(&(pCPageInfo->m_dwcClosedRefCount)));

	if (pCPageInfo->IsFreePage())
	{			

		// Acquire an exclusive lock
		m_semexcForMemMgr.Lock();

		// Check if the state is PSTATE_COMPLETE and there 
		// are no open References
		if (pCPageInfo->IsFreePage())
		{			

			// if this is the current page, then only need to recycle it.
			if (pCPageInfo == m_pCurrentPage)
			{
				m_pCurrentPage->Recycle();
			}
			else
			{

#ifdef _DEBUG
				pCPageInfo->RemoveFromList(&m_listPageInfo);
#endif

				pCPageInfo->m_STATE = PSTATE_CAN_BE_DELETED;
	
			}

		}
	
		// Release the lock
		m_semexcForMemMgr.UnLock();
	
		// deallocate the page if the ref count is 0 and 
		// the page is in the state PSTATE_CAN_BE_DELETED
		pCPageInfo->Release();

	}

*/

	// ALITER : Obtain lock first
	CPageInfo			  *	pCPageInfo;

	AssertSz(pvFreeSpace, "Invalid argument pvFreeSpace");

	// Acquire an exclusive lock
	m_semexcForMemMgr.Lock();

	//---------------------------------------------------------------------------
	//	1. Find out which page does this object belong to.
	pCPageInfo = FindPage(pvFreeSpace);


	//---------------------------------------------------------------------------
	//	2. Increment the closed ref count on this page
	//	3. If returning this object makes the page inactive,
	//	   Then
	//			(a) Free the memory used by the page
	//			(b) Remove the CPageInfo object corresponding to 
	//				this page from the list of pages
	//
	AssertSz(pCPageInfo, "Object to be recycled not found by the mem manager");
	if (pCPageInfo)
	{

		//	Increment the closed ref count on this page
		(pCPageInfo->m_dwcClosedRefCount)++;

		if (pCPageInfo->IsFreePage())
		{			

			if (pCPageInfo == m_pCurrentPage)
			{
				m_pCurrentPage->Recycle();
			}
			else
			{

				#ifdef _DEBUG
					pCPageInfo->RemoveFromList(&m_listPageInfo);
				#endif
				
				delete pCPageInfo;
			}
		}
	
	}

	// Release the lock
	m_semexcForMemMgr.UnLock();


	
}	// End FreeMemSpace



//-----------------------------------------------------------------------------
//
//			IMPLEMENTATION of MemMgr<T>
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// @mfunc	Constructor.
//
// @tcarg	class | T | data type for which memory is being managed
//
//-----------------------------------------------------------------------------
template <class T> MemMgr<T>::MemMgr(void)
{
	m_pCMMPageBeingBuilt	= 0x0;
}


//-----------------------------------------------------------------------------
// @mfunc	Constructor.
//
// @tcarg	class | T | data type for which memory is being managed
//
//-----------------------------------------------------------------------------
template <class T> MemMgr<T>::MemMgr(DWORD cbPageSize)
{
	m_cbPageSize			= cbPageSize;
	m_pCMMPageBeingBuilt 	= 0x0;
}


//-----------------------------------------------------------------------------
// @mfunc	Destructor.
//
// @tcarg	class | T | data type for which memory is being managed
//
//-----------------------------------------------------------------------------
template <class T> MemMgr<T>::~MemMgr(void)
{

	//UNDONE -- gaganc
	//Removing the following code as it was causing problems. There is some bug
	//in here that needs to be looked at and fixed.
	#ifdef _DEBUG 
	#ifdef _IGNORE_FOR_NOW
	UTStaticListIterator<T *>	listActiveItor(m_listActiveObjects);
	T						*	ptObject;
	DWORD						dwcActiveObjects = 0;	
	HRESULT						hr;

	// Iterate through the list of Active objects, 
	// calling ShutDown on each of them. 
	// Also  maintain a count of active objects. 
	// Init for the iterator is called by its constructor.
	for ( ; !listActiveItor ; listActiveItor++)
	{
		ptObject = listActiveItor();

		AssertSz (ptObject, "Invalid pointer returned by List Iterator");

		dwcActiveObjects++;

		hr		= ptObject->ShutDown();

	}

	#endif _IGNORE_FOR_NOW
	#endif // _DEBUG

}	// End ~MemMgr


//-----------------------------------------------------------------------------
// @mfunc	Find an Incomplete Page.
//
// @tcarg	class | T | data type for which memory is being managed
//
//-----------------------------------------------------------------------------
template <class T> CMMPageInfo<T> *	MemMgr<T>::FindIncompletePage (void)
{
	UTStaticListIterator <CMMPageInfo <T> *>	listCPIItor(m_listPageInfo);
	CMMPageInfo	<T>		*					pCPageInfo;
	BOOL									fRetValue;
	BOOL									fFound;
	UTLink		<CMMPageInfo <T> *>	*		pLink;
	fFound	=	FALSE;

	// Iterate through the list, looking for an Incomplete page
	// Init for the iterator is called by its constructor.
	for ( ; !listCPIItor ; listCPIItor++)
	{
		pCPageInfo = listCPIItor();

		AssertSz (pCPageInfo, "Invalid pointer returned by List Iterator");

		if ((pCPageInfo->IsCompletePage()) == FALSE)
		{
			// remove the page from the list, so that it can be inserted
			// at the front later on.
			fRetValue	= listCPIItor.RemoveCurrent( &pLink );
			AssertSz(pLink->m_Value == pCPageInfo, "Error in FindIncompletePage");
			fFound		= TRUE;
			break;
		}
	}
	
	// if not found then null
	if (fFound)
	{
		return pCPageInfo;
	}
	else
	{
		return (CMMPageInfo <T> *) 0;
	}

}	// End function FindIncompletePage


//---------------------------------------------------------------------------
// @mfunc	Obtain an object from the memory manager
//
//			Algorithm :
//			1. Find out a page with an inactive object
//			2. If no such page exists, then 
//				(a)	allocate memory for a new page
//				(b) if this allocation succeeds, 
//					Then
//						(i)	  create CMMPageInfo object for this page	
//						(ii)  Put this CMMPageInfo object into the list 
//							  of active pages
//						(iii) Create an Inactive 	list for this page
//							  Be lazy, don't initialize the objects now.
//					Else
//						(i)   return NULL:
//					
//			3. Put the most recently used page in front of the list.
//			   It may be in memory when a new request comes.	 
//			4. Increment the number of active objects in this page.
//			5. Put it in the active list
//			6. Return a pointer to this object
//
//			If the system is out of memory (allocation fails), then a NULL
//			pointer is returned.
//		
// @tcarg	class | T | data type for which memory is being managed
//---------------------------------------------------------------------------
	
template <class T> T  *	MemMgr<T>::GetNewObject (void)
{
	CMMPageInfo <T>	*	pCPageInfo;
	T				*	ptObject;		
	BOOL				fRetValue;		// return value from RemoveFirst
	UTLink	<T *>	*	pLink;

	// Acquire an exclusive lock
	m_semexcForMemMgr.Lock();

	//---------------------------------------------------------------------------
	//	1. Find out a page with an inactive object
	//	   If found then delete it from the list	
	pCPageInfo = FindIncompletePage();

	//---------------------------------------------------------------------------
	//		2. If no such page exists, then 
	//			(a)	allocate memory for a new page
	//			(b) if this allocation succeeds, 
	//				Then
	//				(i)	  create CMMPageInfo object for this page	
	//				(ii)  Put this CMMPageInfo object into the list 
	//					  of active pages
	//				(iii) Create an Inactive list for this page
	//					  Be lazy, don't initialize the objects now.
	//					  i.e., call the constructor when giving out the object
	//				Else
	//				(i)   return NULL:
	
	if (pCPageInfo == 0x0)
	{
		// Allocate space for the page	
		pCPageInfo = new CMMPageInfo<T>();

		if (pCPageInfo == 0x0)
		{
			ptObject = 0x0;
			// The goto is used to keep the critical section as a block
			// with only one entry and exit point
			goto ReturnFromGetNewObject;
		}

		//Remember the Page being built
		m_pCMMPageBeingBuilt = pCPageInfo;

		// Call constructor for the page, and create the Inactive List.
		pCPageInfo->Init();
	
		//set the page being built to NULL
		m_pCMMPageBeingBuilt = 0x0;

	#ifdef _DEBUG
		//pCPageInfo->m_plistActiveObjects = &m_listActiveObjects;
	#endif

	}

	//---------------------------------------------------------------------------
	//	3. Put the most recently used page in front of the list.
	m_listPageInfo.InsertFirst(&(pCPageInfo->m_linkPageInfo));
	
	fRetValue = (pCPageInfo->m_listInactiveObjects).RemoveFirst(& pLink);
	AssertSz(pLink, "Invalid Link returned in GetNewObject");

	//---------------------------------------------------------------------------
	//	4. Increment the number of active objects in this page.
	(pCPageInfo->m_dwcActiveObjects)++;

	ptObject = (T *) (pLink->m_Value);	
	AssertSz(ptObject, "Invalid object contained in Link -- GetNewObject");

	#ifdef _DEBUG
	//---------------------------------------------------------------------------
	//	5. Put it in the active list	
	//m_listActiveObjects.Add((UTLink <T *> *) (&(ptObject->m_MMListLink)));
	#endif

ReturnFromGetNewObject:

	// Release the lock
	m_semexcForMemMgr.UnLock();

	//---------------------------------------------------------------------------
	//	6 return a pointer to this object
	return ptObject;

}	// End GetNewObject


//---------------------------------------------------------------------------
// @mfunc	Used to get around the call constructor problem
//			Aliter : Have a function CallConstructor
//
// @tcarg	class | T | data type for which memory is being managed
//
//---------------------------------------------------------------------------
template <class T> inline void *	MemMgr<T>::ObtainMemory	(DWORD dwSize)
{
	void *			pv;

	AssertSz (m_pCMMPageBeingBuilt, "Should have a page under construction");

	pv =  m_pCMMPageBeingBuilt->ObtainMemory (dwSize);

	AssertSz (pv, "Should have returned a valid pv.");

	return pv;
} //end ObtainMemory


//---------------------------------------------------------------------------
// @mfunc	Find the page to which an object belongs.
//
// @tcarg	class | T | data type for which memory is being managed
//
//---------------------------------------------------------------------------
template <class T> inline CMMPageInfo<T> *	MemMgr<T>::FindPage (T * ptFreeObject)
{
	CMMPageInfo	<T>		*	pCPageInfo;

	AssertSz(ptFreeObject, "Invalid argument freeObject");

	pCPageInfo = (CMMPageInfo <T> *)(ptFreeObject->m_pvMMPageAddress);

	AssertSz (	pCPageInfo, "Invalid page address -- FindPage");
	
	pCPageInfo->RemoveFromList(&m_listPageInfo);

	return (pCPageInfo);

}	// End function FindPage




//---------------------------------------------------------------------------
// @mfunc	Free an object by giving it to memory manager
//
//			Algorithm :
//			1. Remove the object from the active list.
//			2. Find out which page does this object belong to.
//			3. If returning this object makes the page inactive,
//			   Then
//				(a) Free the memory used by the page
//				(b) Remove the CMMPageInfo object corresponding to 
//					this page from the list of pages
//			   Else
//				(a) Put the object in the Inactive list for the page
//					Put it in the front, it may be in the cache when new
//					request comes
//				(b) Decrement the number of active objects on this page
//
//			4. Put the most recently used page in front of the list   
//
// @tcarg	class | T | data type for which memory is being managed
//---------------------------------------------------------------------------

template <class T> void	MemMgr<T>::FreeObject (T * ptFreeObject)
{
	CMMPageInfo			<T>	*	pCPageInfo;

	AssertSz(ptFreeObject, "Invalid argument ptFreeObject");

	
	//-------------------------------------------------------------------------
	//Make the object go back to it's nascent state
	ptFreeObject->Recycle();

	// Acquire an exclusive lock
	m_semexcForMemMgr.Lock();

	#ifdef _DEBUG
	//---------------------------------------------------------------------------
	//	1. Remove the object from the active list.
	//ptFreeObject->RemoveFromList (	(UTStaticList <CABSTRACT_OBJECT *> * )
	//								(&m_listActiveObjects));
	#endif

	//---------------------------------------------------------------------------
	//	2. Find out which page does this object belong to.
	pCPageInfo = FindPage(ptFreeObject);

	//---------------------------------------------------------------------------
	//	3. If returning this object makes the page inactive,
	//	   Then   
	//		(a) Free the memory used by the page
	//		(b) Remove the CMMPageInfo object corresponding to 
	//			this page from the list of pages
	//	   Else
	//		(a) Put the object in the Inactive list for the page
	//			Put it in the front, it may be in the cache when new
	//			request comes
	//		(b) Decrement the number of active objects on this page
	//
	AssertSz(pCPageInfo, "Object to be recycled not found by the mem manager");
	if (pCPageInfo)
	{

	//	UNDONE : Delete the page if too many inactive pages around			
	/*	if ((pCPageInfo->m_dwcActiveObjects)== 1)
		{
			BOOL		fRetVal;
			void	*	pvFreePage;
			pvFreePage	=	pCPageInfo;

			// UNDONE : remove from the list of pages
			//			Also, Call the destructor
			fRetVal = pCPageInfo::DeletePage (pvFreePage);
			AssertSz(fRetVal == TRUE, " DeletePage failed -- FreeObject");
		}
		else
		{
	*/		(pCPageInfo->m_listInactiveObjects).InsertFirst(
							(UTLink <T *> *)(&(ptFreeObject->m_MMListLink)));
			(pCPageInfo->m_dwcActiveObjects)--;
	//	}	
	
	}
	
	//---------------------------------------------------------------------------
	//	4. Put the most recently used page in front of the list   
	m_listPageInfo.InsertFirst(&(pCPageInfo->m_linkPageInfo));
	
	// Release the lock
	m_semexcForMemMgr.UnLock();

}	// End FreeObject



//-----------------------------------------------------------------------------
//
//				IMPLEMENTATION of CPageInfo
//
//-----------------------------------------------------------------------------


/******************************************************************************
@mfunc	CPageInfo::CPageInfo
******************************************************************************/
inline CPageInfo::CPageInfo (void)
{
	m_dwcbTotal 		= 0;
	m_dwcbAlloted 	= 0;
	m_puch			= 0;

//	InitializeCriticalSection (&m_csForwcbAlloted);

	//Initialize the link objects
	m_linkPageInfo.Init (this);
} //End CPageInfo::CPageInfo


/******************************************************************************
@mfunc	CPageInfo::~CPageInfo
******************************************************************************/
inline CPageInfo::~CPageInfo (void)
{
//	DeleteCriticalSection (&m_csForwcbAlloted);
} //End CPageInfo::~CPageInfo


/******************************************************************************
@mfunc	CPageInfo::Init
******************************************************************************/
inline void	CPageInfo::Init (void)
{
	//Other info should remain intact as those don't change after being set once
	m_dwcbAlloted 	= 0;
	
	#ifdef _DEBUG
		memset (m_puch, 0xcd, m_dwcbTotal);
	#endif _DEBUG

} //End CPageInfo::Init


/******************************************************************************
@mfunc	CPageInfo::AddRef
******************************************************************************/
inline void CPageInfo::AddRef (void)
{
	InterlockedIncrement (&m_lcRefCount);

}	//End CPageInfo::AddRef


/******************************************************************************
@mfunc	CPageInfo::Release
******************************************************************************/
inline void CPageInfo::Release (void)
{
	if ((InterlockedDecrement (&m_lcRefCount) == 0) &&
		(m_STATE == PSTATE_CAN_BE_DELETED))
	{
		delete this;
	}

}	//End CPageInfo::Release


/******************************************************************************
@mfunc	CPageInfo::MMInit
******************************************************************************/
inline void	CPageInfo::MMInit (void)
{

	// UNDONE : m_cbPageSize should be changed dynamically
	m_cbPageSize			= DEFAULT_PAGE_SIZE	* sizeof(char);

	// m_dwcbMaxSize		= 0;

#ifdef _DEBUG
	m_linkPageInfo.m_Value	= this;
#endif	

	m_dwcOpenRefCount		= 0;

	m_dwcClosedRefCount		= 0;

	// Set the start address of the Page :
	m_pvMMPageStart			= (void *)((char *) this + ALIGNED_SPACE(sizeof(CPageInfo)));

	m_pchFreeLocation		= (char *)m_pvMMPageStart;

	m_STATE					= PSTATE_INCOMPLETE;


	#ifdef _DEBUG
		memset (m_pvMMPageStart, 0xcd, m_cbPageSize - sizeof (CPageInfo));
	#endif _DEBUG
} //End CPageInfo::MMInit


/******************************************************************************
@mfunc	CPageInfo::Recycle
******************************************************************************/
inline void	CPageInfo::Recycle (void)
{

	// m_dwcbMaxSize		= 0;
	
	m_dwcOpenRefCount		= 0;

	m_dwcClosedRefCount		= 0;

	// Set the start address of the Page :   (This line can go away after various clients stop bastardizing CPageInfo objects by diddling their internal pointers to point to memory outside the page).  --Jcargill
	m_pvMMPageStart			= (void *)((char *) this + ALIGNED_SPACE(sizeof(CPageInfo)));

	m_pchFreeLocation		= (char *)m_pvMMPageStart;

	m_STATE					= PSTATE_INCOMPLETE;

	#ifdef _DEBUG
		memset (m_pvMMPageStart, 0xcd, m_cbPageSize - sizeof (CPageInfo));
	#endif _DEBUG
} //End CPageInfo::Recycle


/******************************************************************************
@mfunc	CPageInfo::AllocBuffer
******************************************************************************/
inline void * CPageInfo::AllocBuffer (size_t size, BOOL fLock = TRUE)
{
	unsigned char * 	puch = 0;

	AssertSz (size % BYTE_ALIGNMENT == 0, "Non aligned size");


	//-------------------------------------------------
	//Lock the variable
	if (fLock == TRUE)
	{
		EnterCriticalSection (&m_csForwcbAlloted);
	}
	
	//-------------------------------------------------
	//check to see if there is space available
	if ( ( m_dwcbAlloted + size ) <= m_dwcbTotal)
	{
		puch = m_puch + m_dwcbAlloted;		
		m_dwcbAlloted = m_dwcbAlloted + size;
	}

	//-------------------------------------------------
	//Unlock the variable
	if (fLock == TRUE)
	{
		LeaveCriticalSection (&m_csForwcbAlloted);
	}

	return (void *)puch;
} //End CPageInfo::Release


/******************************************************************************
@mfunc	CPageInfo::SpaceAvailable
******************************************************************************/
inline size_t CPageInfo::SpaceAvailable (void)
{
	return (m_dwcbTotal - m_dwcbAlloted);
} //End CPageInfo::SpaceAvailable


/******************************************************************************
@mfunc	CPageInfo::FreeSpaceAvailable
******************************************************************************/
inline BOOL CPageInfo::FreeSpaceAvailable (size_t	cbSize)
{
	AssertSz (	(m_dwcOpenRefCount >= m_dwcClosedRefCount),
				"Error in ref counts -- FreeSpaceAvailable");

	return ((m_pchFreeLocation + cbSize) < ((char *)this + m_cbPageSize));

} //End CPageInfo::FreeSpaceAvailable


//---------------------------------------------------------------------------
// @mfunc	Check if Memory chunk belongs to this Page.
//---------------------------------------------------------------------------
inline BOOL	CPageInfo::IsInThisPage(void * pvFreeSpace)
{
	char			*	pchMinMMPage;
	char			*	pchMaxMMPage;
	pchMinMMPage	=	(char *) m_pvMMPageStart;
	pchMaxMMPage	=	(char *) ((char *)this + m_cbPageSize);

	AssertSz(pvFreeSpace, "Invalid argument ptFreeObject");
	if (	((char *)pvFreeSpace < pchMaxMMPage) 
							&& 
			((char *)pvFreeSpace >= pchMinMMPage))
	{
		return TRUE;
	}


	return FALSE;
}	// End CPageInfo::IsInThisPage


//---------------------------------------------------------------------------
// @mfunc	Check if this page is inactive
//---------------------------------------------------------------------------
inline BOOL	CPageInfo::IsFreePage(void)
{
	AssertSz (	(m_dwcOpenRefCount >= m_dwcClosedRefCount),
				"Error in ref counts -- IsFreePage");

	return ( (m_dwcOpenRefCount == m_dwcClosedRefCount) 
			 && (m_STATE == PSTATE_COMPLETE));

}	// End CPageInfo::IsFreePage


#ifdef _DEBUG
//---------------------------------------------------------------------------
// @mfunc	Remove this page from the list of pages
//
// @tcarg	class | T | data type for which memory is being managed
//
//---------------------------------------------------------------------------
inline void	CPageInfo::RemoveFromList(UTStaticList <CPageInfo *> * plistPageInfo)
{
	UTLink <CPageInfo *> *	pPrevLink;
	UTLink <CPageInfo *> *	pNextLink;
	

	pPrevLink = m_linkPageInfo.m_pPrevLink;
	pNextLink = m_linkPageInfo.m_pNextLink;

	if ((pPrevLink == 0x0 ) && (pNextLink == 0x0)) 
	{
		plistPageInfo->m_pLastLink	= 0x0;
		plistPageInfo->m_pFirstLink	= 0x0;
	}
	else if (pPrevLink == 0x0 )
	{
		plistPageInfo->m_pFirstLink = pNextLink;
		pNextLink->m_pPrevLink		= 0x0;
	}
	else if (pNextLink == 0x0 )
	{
		plistPageInfo->m_pLastLink	= pPrevLink;
		pPrevLink->m_pNextLink		= 0x0;
	}
	else
	{
		pNextLink->m_pPrevLink = pPrevLink; 
		pPrevLink->m_pNextLink = pNextLink; 
	}
	
	// Update the number of page headers in the list 
	plistPageInfo->m_ulCount--;

}	// End RemoveFromList

#endif	// _DEBUG

/******************************************************************************
@mfunc	CPageInfo::GetBeginingOfBuffer
******************************************************************************/
inline unsigned char *	CPageInfo::GetBeginingOfBuffer(void)
{
	return m_puch;
}


/******************************************************************************
@mfunc	CPageInfo::AllocateMemory
******************************************************************************/
inline void	* CPageInfo::AllocateMemory(size_t cbSize)
{	
	void		*	pvMemSpace;
	OBJECT_BLOB	*	pObjectBlob;

	// cbSize is the aligned size
	// m_dwcbMaxSize = MAX (m_dwcbMaxSize, cbSize);

	AssertSz (	m_dwcOpenRefCount >= m_dwcClosedRefCount,
				"Error in ref counts -- AllocateMemory");

	//---------------------------------------------------------------------------
	//	Increment the number of open ref counts in this page
	m_dwcOpenRefCount++;
	
	pObjectBlob				 = (OBJECT_BLOB *)m_pchFreeLocation;

	pObjectBlob->pvPageStart = (void *)this;

	//---------------------------------------------------------------------------
	//	Allocate a chunk of memory from the current page.
	pvMemSpace				 = (void *)(m_pchFreeLocation + sizeof(OBJECT_BLOB));

	m_pchFreeLocation		 += cbSize;

	// Assert that current free location is within page boundary
	AssertSz (	m_pchFreeLocation <= ((char *)(this) + m_cbPageSize),
				"Error in memory allocation -- AllocateMemory");

	return pvMemSpace;

}


#endif		// __MMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\opstructs.h ===
//*****************************************************************************
// Structures for opStructs.h
// 5/28/1999  10:40:16
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
#include "icmprecs.h"


// Script supplied data.





#define OPTABLENAMELIST() \
	TABLENAME( TblNameSpaceIds ) \
	TABLENAME( TblNodePropertyBagInfo ) \
	TABLENAME( TblNodeObjectBagInfo ) \
	TABLENAME( TblAssemblySetting ) \
	TABLENAME( TblSettingTmp1 ) \
	TABLENAME( TblSettingTmp2 ) \
	TABLENAME( TblSettingTmp3 ) \
	TABLENAME( TblSettingTmp4 ) \
	TABLENAME( TblSettingTmp5 ) \
	TABLENAME( TblSimpleSetting ) 


#undef TABLENAME
#define TABLENAME( TblName ) TABLENUM_OP_##TblName, 
enum
{
	OPTABLENAMELIST()
};

#define OP_TABLE_COUNT 10
extern const GUID DECLSPEC_SELECTANY SCHEMA_OP = { 0x985F9200, 0x026C, 0x11D3, {  0x8A, 0xD2, 0x00, 0xC0, 0x4F, 0x79, 0x78, 0xBE }};
extern const COMPLIBSCHEMA DECLSPEC_SELECTANY OPSchema = 
{
	&SCHEMA_OP,
	1
};


#define SCHEMA_OP_Name "OP"


#include "pshpack1.h"


//*****************************************************************************
//  OP.TblNameSpaceIds
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    unsigned long ID;
    ULONG cbLogicalNameLen;
    wchar_t LogicalName[260];
    unsigned long ParentID;

	inline int IsParentIDNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetParentIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(OP_TblNameSpaceIds));
         fNullFlags = (ULONG) -1;
    }

} OP_TblNameSpaceIds;

#define COLID_OP_TblNameSpaceIds_ID 1
#define COLID_OP_TblNameSpaceIds_LogicalName 2
#define COLID_OP_TblNameSpaceIds_ParentID 3

#define Index_OP_Dex_Col1 "OP.Dex_Col1"



//*****************************************************************************
//  OP.TblNodePropertyBagInfo
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    unsigned long NodeID;
    ULONG cbPropertyNameLen;
    wchar_t PropertyName[260];
    ULONG cbPropertyValueLen;
    wchar_t PropertyValue[260];

	inline int IsPropertyValueNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetPropertyValueNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(OP_TblNodePropertyBagInfo));
         fNullFlags = (ULONG) -1;
    }

} OP_TblNodePropertyBagInfo;

#define COLID_OP_TblNodePropertyBagInfo_NodeID 1
#define COLID_OP_TblNodePropertyBagInfo_PropertyName 2
#define COLID_OP_TblNodePropertyBagInfo_PropertyValue 3

#define Index_OP_MPK_TblNodePropertyBagInfo "OP.MPK_TblNodePropertyBagInfo"
#define Index_OP_Dex_Col0 "OP.Dex_Col0"



//*****************************************************************************
//  OP.TblNodeObjectBagInfo
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    unsigned long NodeID;
    ULONG cbObjectNameLen;
    wchar_t ObjectName[260];
    ULONG cbObjectBLOBLen;
    BYTE ObjectBLOB[260];

	inline int IsObjectBLOBNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetObjectBLOBNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(OP_TblNodeObjectBagInfo));
         fNullFlags = (ULONG) -1;
    }

} OP_TblNodeObjectBagInfo;

#define COLID_OP_TblNodeObjectBagInfo_NodeID 1
#define COLID_OP_TblNodeObjectBagInfo_ObjectName 2
#define COLID_OP_TblNodeObjectBagInfo_ObjectBLOB 3

#define Index_OP_MPK_TblNodeObjectBagInfo "OP.MPK_TblNodeObjectBagInfo"
#define Index_OP_Dex_Col0 "OP.Dex_Col0"



//*****************************************************************************
//  OP.TblAssemblySetting
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    ULONG cbwzNameLen;
    wchar_t wzName[257];
    BYTE pad00 [2];
    unsigned long dwType;
    unsigned long dwFlag;
    ULONG cbpValueLen;
    BYTE pValue[260];

	inline int IspValueNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetpValueNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(OP_TblAssemblySetting));
         fNullFlags = (ULONG) -1;
    }

} OP_TblAssemblySetting;

#define COLID_OP_TblAssemblySetting_wzName 1
#define COLID_OP_TblAssemblySetting_dwType 2
#define COLID_OP_TblAssemblySetting_dwFlag 3
#define COLID_OP_TblAssemblySetting_pValue 4




//*****************************************************************************
//  OP.TblSettingTmp1
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    ULONG cbwzNameLen;
    wchar_t wzName[257];
    BYTE pad00 [2];
    unsigned long dwType;
    unsigned long dwFlag;
    ULONG cbpValueLen;
    BYTE pValue[260];

	inline int IspValueNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetpValueNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(OP_TblSettingTmp1));
         fNullFlags = (ULONG) -1;
    }

} OP_TblSettingTmp1;

#define COLID_OP_TblSettingTmp1_wzName 1
#define COLID_OP_TblSettingTmp1_dwType 2
#define COLID_OP_TblSettingTmp1_dwFlag 3
#define COLID_OP_TblSettingTmp1_pValue 4




//*****************************************************************************
//  OP.TblSettingTmp2
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    ULONG cbwzNameLen;
    wchar_t wzName[257];
    BYTE pad00 [2];
    unsigned long dwType;
    unsigned long dwFlag;
    ULONG cbpValueLen;
    BYTE pValue[260];

	inline int IspValueNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetpValueNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(OP_TblSettingTmp2));
         fNullFlags = (ULONG) -1;
    }

} OP_TblSettingTmp2;

#define COLID_OP_TblSettingTmp2_wzName 1
#define COLID_OP_TblSettingTmp2_dwType 2
#define COLID_OP_TblSettingTmp2_dwFlag 3
#define COLID_OP_TblSettingTmp2_pValue 4




//*****************************************************************************
//  OP.TblSettingTmp3
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    ULONG cbwzNameLen;
    wchar_t wzName[257];
    BYTE pad00 [2];
    unsigned long dwType;
    unsigned long dwFlag;
    ULONG cbpValueLen;
    BYTE pValue[260];

	inline int IspValueNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetpValueNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(OP_TblSettingTmp3));
         fNullFlags = (ULONG) -1;
    }

} OP_TblSettingTmp3;

#define COLID_OP_TblSettingTmp3_wzName 1
#define COLID_OP_TblSettingTmp3_dwType 2
#define COLID_OP_TblSettingTmp3_dwFlag 3
#define COLID_OP_TblSettingTmp3_pValue 4




//*****************************************************************************
//  OP.TblSettingTmp4
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    ULONG cbwzNameLen;
    wchar_t wzName[257];
    BYTE pad00 [2];
    unsigned long dwType;
    unsigned long dwFlag;
    ULONG cbpValueLen;
    BYTE pValue[260];

	inline int IspValueNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetpValueNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(OP_TblSettingTmp4));
         fNullFlags = (ULONG) -1;
    }

} OP_TblSettingTmp4;

#define COLID_OP_TblSettingTmp4_wzName 1
#define COLID_OP_TblSettingTmp4_dwType 2
#define COLID_OP_TblSettingTmp4_dwFlag 3
#define COLID_OP_TblSettingTmp4_pValue 4




//*****************************************************************************
//  OP.TblSettingTmp5
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    ULONG cbwzNameLen;
    wchar_t wzName[257];
    BYTE pad00 [2];
    unsigned long dwType;
    unsigned long dwFlag;
    ULONG cbpValueLen;
    BYTE pValue[260];

	inline int IspValueNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetpValueNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(OP_TblSettingTmp5));
         fNullFlags = (ULONG) -1;
    }

} OP_TblSettingTmp5;

#define COLID_OP_TblSettingTmp5_wzName 1
#define COLID_OP_TblSettingTmp5_dwType 2
#define COLID_OP_TblSettingTmp5_dwFlag 3
#define COLID_OP_TblSettingTmp5_pValue 4




//*****************************************************************************
//  OP.TblSimpleSetting
//*****************************************************************************
typedef struct
{
    ULONG cbwzNameLen;
    wchar_t wzName[257];
    BYTE pad00 [2];
    unsigned long dwFlag;
    ULONG cbwzValueLen;
    wchar_t wzValue[260];

    void Init()
    {
         memset(this, 0, sizeof(OP_TblSimpleSetting));
    }

} OP_TblSimpleSetting;

#define COLID_OP_TblSimpleSetting_wzName 1
#define COLID_OP_TblSimpleSetting_dwFlag 2
#define COLID_OP_TblSimpleSetting_wzValue 3




#include "poppack.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\mtsexcept.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// MTSExcept.h
//
// Macros etc for controlling thowing and catching of exceptions such that we 
// actually ever do same.
//

#define MTS_THROW(x)        RaiseException(x, EXCEPTION_NONCONTINUABLE_EXCEPTION, 0, NULL)
#define THROW_NO_MEMORY     MTS_THROW(STATUS_NO_MEMORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\opblobs.h ===
//*****************************************************************************
// Structures for op.clb
// 5/28/1999  10:40:16
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
extern const DECLSPEC_SELECTANY int g_iOPTables = 10;
extern const BYTE DECLSPEC_SELECTANY g_rgOPSchemaDataRW[] = 
{
	0x0A,0x00,0x00,0x00,0x08,0x04,0x00,0x00,0x30,0x00,0x00,0x00,0x94,0x00,0x00,0x00,0xF8,0x00,0x00,0x00,
	0x5C,0x01,0x00,0x00,0xC0,0x01,0x00,0x00,0x24,0x02,0x00,0x00,0x88,0x02,0x00,0x00,0xEC,0x02,0x00,0x00,
	0x50,0x03,0x00,0x00,0xB4,0x03,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x02,0x28,0x03,0x01,0x01,0x54,
	0x00,0x00,0x0C,0x00,0x18,0x00,0x64,0x00,0x14,0x00,0x00,0x00,0x01,0x04,0x13,0x00,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x17,0x00,0x00,0x00,0x02,0x02,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x23,0x00,0x00,0x00,0x03,0x01,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x43,0x2C,0x00,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0x45,0x00,0x00,0x00,0x08,0x10,0x02,0x01,
	0x11,0x05,0x14,0x00,0x01,0x02,0x00,0x58,0x51,0x00,0x00,0x00,0x01,0x00,0x02,0x20,0x03,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x6B,0x00,0x00,0x00,0x01,0x82,0x13,0x00,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x72,0x00,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x7F,0x00,0x00,0x00,0x03,0x01,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x8D,0x00,0x00,0x00,
	0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0xAB,0x00,0x00,0x00,0x08,0x10,0x02,0x01,
	0x11,0x05,0x10,0x00,0x01,0x01,0x00,0x58,0xB7,0x00,0x00,0x00,0x02,0x00,0x02,0x20,0x03,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x6B,0x00,0x00,0x00,0x01,0x82,0x13,0x00,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xCF,0x00,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xDA,0x00,0x00,0x00,0x03,0x01,0x80,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xE5,0x00,0x00,0x00,
	0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0xAB,0x00,0x00,0x00,0x08,0x10,0x02,0x01,
	0x11,0x05,0x10,0x00,0x01,0x01,0x00,0x58,0x01,0x01,0x00,0x00,0x03,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x33,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0x4F,0x01,0x00,0x00,0x04,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x61,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0x79,0x01,0x00,0x00,0x05,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x8B,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0xA3,0x01,0x00,0x00,0x06,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xB5,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0xCD,0x01,0x00,0x00,0x07,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xDF,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0xF7,0x01,0x00,0x00,0x08,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x09,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0x21,0x02,0x00,0x00,0x09,0x00,0x01,0x28,0x03,0x00,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x04,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x25,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x35,0x02,0x00,0x00,0x03,0x00,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x3D,0x02,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,0x01,0x01,0x00,0x58,
};
extern const DECLSPEC_SELECTANY int g_cbOPSchemaRW = 1032;
extern const DECLSPEC_SELECTANY BYTE g_rgOPSchemaStringHeap[] = 
{
	0x00,0x4F,0x50,0x2E,0x54,0x62,0x6C,0x4E,0x61,0x6D,0x65,0x53,0x70,0x61,0x63,0x65,0x49,0x64,0x73,0x00,
	0x49,0x44,0x00,0x4C,0x6F,0x67,0x69,0x63,0x61,0x6C,0x4E,0x61,0x6D,0x65,0x00,0x50,0x61,0x72,0x65,0x6E,
	0x74,0x49,0x44,0x00,0x23,0x23,0x4F,0x50,0x2E,0x54,0x62,0x6C,0x4E,0x61,0x6D,0x65,0x53,0x70,0x61,0x63,
	0x65,0x49,0x64,0x73,0x5F,0x44,0x65,0x78,0x00,0x4F,0x50,0x2E,0x44,0x65,0x78,0x5F,0x43,0x6F,0x6C,0x31,
	0x00,0x4F,0x50,0x2E,0x54,0x62,0x6C,0x4E,0x6F,0x64,0x65,0x50,0x72,0x6F,0x70,0x65,0x72,0x74,0x79,0x42,
	0x61,0x67,0x49,0x6E,0x66,0x6F,0x00,0x4E,0x6F,0x64,0x65,0x49,0x44,0x00,0x50,0x72,0x6F,0x70,0x65,0x72,
	0x74,0x79,0x4E,0x61,0x6D,0x65,0x00,0x50,0x72,0x6F,0x70,0x65,0x72,0x74,0x79,0x56,0x61,0x6C,0x75,0x65,
	0x00,0x4F,0x50,0x2E,0x4D,0x50,0x4B,0x5F,0x54,0x62,0x6C,0x4E,0x6F,0x64,0x65,0x50,0x72,0x6F,0x70,0x65,
	0x72,0x74,0x79,0x42,0x61,0x67,0x49,0x6E,0x66,0x6F,0x00,0x4F,0x50,0x2E,0x44,0x65,0x78,0x5F,0x43,0x6F,
	0x6C,0x30,0x00,0x4F,0x50,0x2E,0x54,0x62,0x6C,0x4E,0x6F,0x64,0x65,0x4F,0x62,0x6A,0x65,0x63,0x74,0x42,
	0x61,0x67,0x49,0x6E,0x66,0x6F,0x00,0x4F,0x62,0x6A,0x65,0x63,0x74,0x4E,0x61,0x6D,0x65,0x00,0x4F,0x62,
	0x6A,0x65,0x63,0x74,0x42,0x4C,0x4F,0x42,0x00,0x4F,0x50,0x2E,0x4D,0x50,0x4B,0x5F,0x54,0x62,0x6C,0x4E,
	0x6F,0x64,0x65,0x4F,0x62,0x6A,0x65,0x63,0x74,0x42,0x61,0x67,0x49,0x6E,0x66,0x6F,0x00,0x4F,0x50,0x2E,
	0x54,0x62,0x6C,0x41,0x73,0x73,0x65,0x6D,0x62,0x6C,0x79,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x00,0x77,
	0x7A,0x4E,0x61,0x6D,0x65,0x00,0x64,0x77,0x54,0x79,0x70,0x65,0x00,0x64,0x77,0x46,0x6C,0x61,0x67,0x00,
	0x70,0x56,0x61,0x6C,0x75,0x65,0x00,0x23,0x23,0x4F,0x50,0x2E,0x54,0x62,0x6C,0x41,0x73,0x73,0x65,0x6D,
	0x62,0x6C,0x79,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x5F,0x44,0x65,0x78,0x00,0x4F,0x50,0x2E,0x54,0x62,
	0x6C,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x54,0x6D,0x70,0x31,0x00,0x23,0x23,0x4F,0x50,0x2E,0x54,0x62,
	0x6C,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x54,0x6D,0x70,0x31,0x5F,0x44,0x65,0x78,0x00,0x4F,0x50,0x2E,
	0x54,0x62,0x6C,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x54,0x6D,0x70,0x32,0x00,0x23,0x23,0x4F,0x50,0x2E,
	0x54,0x62,0x6C,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x54,0x6D,0x70,0x32,0x5F,0x44,0x65,0x78,0x00,0x4F,
	0x50,0x2E,0x54,0x62,0x6C,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x54,0x6D,0x70,0x33,0x00,0x23,0x23,0x4F,
	0x50,0x2E,0x54,0x62,0x6C,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x54,0x6D,0x70,0x33,0x5F,0x44,0x65,0x78,
	0x00,0x4F,0x50,0x2E,0x54,0x62,0x6C,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x54,0x6D,0x70,0x34,0x00,0x23,
	0x23,0x4F,0x50,0x2E,0x54,0x62,0x6C,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x54,0x6D,0x70,0x34,0x5F,0x44,
	0x65,0x78,0x00,0x4F,0x50,0x2E,0x54,0x62,0x6C,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x54,0x6D,0x70,0x35,
	0x00,0x23,0x23,0x4F,0x50,0x2E,0x54,0x62,0x6C,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x54,0x6D,0x70,0x35,
	0x5F,0x44,0x65,0x78,0x00,0x4F,0x50,0x2E,0x54,0x62,0x6C,0x53,0x69,0x6D,0x70,0x6C,0x65,0x53,0x65,0x74,
	0x74,0x69,0x6E,0x67,0x00,0x77,0x7A,0x56,0x61,0x6C,0x75,0x65,0x00,0x23,0x23,0x4F,0x50,0x2E,0x54,0x62,
	0x6C,0x53,0x69,0x6D,0x70,0x6C,0x65,0x53,0x65,0x74,0x74,0x69,0x6E,0x67,0x5F,0x44,0x65,0x78,0x00,0x00,
};
extern const DECLSPEC_SELECTANY BYTE * g_pbOPSchemaStringHeap = g_rgOPSchemaStringHeap;
extern const DECLSPEC_SELECTANY int g_cbOPSchemaStringHeap = 600;
extern const BYTE DECLSPEC_SELECTANY g_rgOPSchemaDataRO[] = 
{
	0x0A,0x00,0x00,0x00,0x08,0x04,0x00,0x00,0x30,0x00,0x00,0x00,0x94,0x00,0x00,0x00,0xF8,0x00,0x00,0x00,
	0x5C,0x01,0x00,0x00,0xC0,0x01,0x00,0x00,0x24,0x02,0x00,0x00,0x88,0x02,0x00,0x00,0xEC,0x02,0x00,0x00,
	0x50,0x03,0x00,0x00,0xB4,0x03,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x02,0x28,0x03,0x01,0x01,0x54,
	0x00,0x00,0x0C,0x00,0x18,0x00,0x64,0x00,0x14,0x00,0x00,0x00,0x01,0x04,0x13,0x00,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x17,0x00,0x00,0x00,0x02,0x02,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x23,0x00,0x00,0x00,0x03,0x01,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x43,0x2C,0x00,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0x45,0x00,0x00,0x00,0x08,0x10,0x02,0x01,
	0x11,0x05,0x14,0x00,0x01,0x02,0x00,0x58,0x51,0x00,0x00,0x00,0x01,0x00,0x02,0x20,0x03,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x6B,0x00,0x00,0x00,0x01,0x82,0x13,0x00,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x72,0x00,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0x7F,0x00,0x00,0x00,0x03,0x01,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x8D,0x00,0x00,0x00,
	0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0xAB,0x00,0x00,0x00,0x08,0x10,0x02,0x01,
	0x11,0x05,0x10,0x00,0x01,0x01,0x00,0x58,0xB7,0x00,0x00,0x00,0x02,0x00,0x02,0x20,0x03,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x6B,0x00,0x00,0x00,0x01,0x82,0x13,0x00,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xCF,0x00,0x00,0x00,0x02,0x82,0x82,0x00,0x04,0x00,0x04,0x00,0x00,0x02,0xFF,0x43,
	0xDA,0x00,0x00,0x00,0x03,0x01,0x80,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xE5,0x00,0x00,0x00,
	0x0E,0x10,0x01,0x01,0x11,0x05,0x0C,0x00,0x02,0x01,0x02,0x58,0xAB,0x00,0x00,0x00,0x08,0x10,0x02,0x01,
	0x11,0x05,0x10,0x00,0x01,0x01,0x00,0x58,0x01,0x01,0x00,0x00,0x03,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x33,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0x4F,0x01,0x00,0x00,0x04,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x61,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0x79,0x01,0x00,0x00,0x05,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x8B,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0xA3,0x01,0x00,0x00,0x06,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xB5,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0xCD,0x01,0x00,0x00,0x07,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xDF,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0xF7,0x01,0x00,0x00,0x08,0x00,0x01,0x28,0x04,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x08,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x1E,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x25,0x01,0x00,0x00,0x03,0x00,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2C,0x01,0x00,0x00,
	0x04,0x01,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x09,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,0x21,0x02,0x00,0x00,0x09,0x00,0x01,0x28,0x03,0x00,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0x17,0x01,0x00,0x00,0x01,0x04,0x82,0x00,0x04,0x00,0x04,0x00,
	0x00,0x01,0xFF,0x43,0x25,0x01,0x00,0x00,0x02,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x35,0x02,0x00,0x00,0x03,0x00,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x3D,0x02,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,0x01,0x01,0x00,0x58,
};
extern const DECLSPEC_SELECTANY int g_cbOPSchemaRO = 1032;
extern const COMPLIBSCHEMABLOB DECLSPEC_SELECTANY OPSchemaBlob = 
{
	&OPSchema,
	OP_TABLE_COUNT,
	0,
	g_rgOPSchemaDataRW,
	g_cbOPSchemaRW,
	g_rgOPSchemaDataRO,
	g_cbOPSchemaRO,
	g_rgOPSchemaStringHeap,
	g_cbOPSchemaStringHeap
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\safecs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.h
//
// Contents:    CSafeAutoCriticalSection, protects CriticalSection against AV via try,catch
//
//------------------------------------------------------------------------
#ifndef _SAFECS_H_
#define _SAFECS_H_

class CSafeAutoCriticalSection
{
public:


    CSafeAutoCriticalSection();
    ~CSafeAutoCriticalSection();

    DWORD Lock();
    DWORD  Unlock();

    BOOL IsInitialized() { return (STATE_INITIALIZED == m_lState);}

private:

    enum
    {
        STATE_UNINITIALIZED = 0,
        STATE_INITIALIZED   = 1
    };

    CRITICAL_SECTION    m_cs;
    LONG                m_lState;
	DWORD               m_dwError;

};

class CSafeLock 
{
public:
	CSafeLock (CSafeAutoCriticalSection* val);
	CSafeLock (CSafeAutoCriticalSection& val);

	~CSafeLock ();

	DWORD Lock ();
	DWORD Unlock ();
private:

private:
	BOOL m_locked;
	CSafeAutoCriticalSection* m_pSem;
};

#endif // _SAFECS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\regcontrol.h ===
//*****************************************************************************
// RegControl.h
//
// This header file contains the structures used to share memory between
// the RegDB process and the clients which read the data.
//
// Copyright (c) 1997-1998, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#pragma once

// Lock code.
#include "utsem.h"
//#include "..\regdb\utsemxp.h"

extern "C" {

// Force 1 byte alignment for structures which must match.
#include "pshpack1.h"


//********** Errors. **********************************************************
//#include "..\regdb\regdbmsg.h"

//********** Macros. **********************************************************

// internal name of the service
#define SZSERVICENAME        "COMReg"
// displayed name of the service
#define SZSERVICEDISPLAYNAME "COM+ Registration Service"
// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""

#define	SZWORKING_NAME					_T("RegDBWrt.clb")

#define SZEVENTLOCKNAME					"ComRegDBEvent"
#define SZSEMAPHORELOCKNAME				"ComRegDBSemaphore"

#define SZEVENTINNAME					"ComPlusCOMRegEventIn"
#define SZEVENTOUTNAME					"ComPlusCOMRegEventOut"
#define REGISTRATION_TABLE_NAME			"ComPlusCOMRegTable"
#define MAX_COMREG_TABLES				25
#define MAX_SHARED_NAME					32
#define MAX_VERSION_NUMBER				0xffffffffffff

#define COMREG_MAGIC_VALUE				0x62646772	// "rgdb"
#define COMREG_MAJOR_VERSION				1
#define	COMREG_MINOR_VERSION				0

#define WM_REGSRVROPENFORWRITE	(WM_USER+1)
#define WM_REGSRVRSAVE			(WM_USER+2)
#define WM_REGSRVRCANCELWRITE	(WM_USER+3)
#define WM_REGSRVRRELEASEDB		(WM_USER+4)

#define VERSION_CHECK_INTERVAL	1000	// milliseconds ellapsed time on cache
#define SHAREDMEMORY_STALE_CHECK	120 * 1000 
// If the difference between current tick count and the timestamp set on the 
// shared memory is greater than this value, we believe server process is down.

#define COM3_KEY L"Software\\Microsoft\\COM3"
#define REGDBVER L"REGDBVersion"
#define REGDBAUTOBACKUP L"RegDBAutoBackUp"
#define MAX_AUTOBACKTUP_VERSIONS 10

#define SZREGDIR_NAME				_T("\\Registration")
#define SZEMPTYREGDB_NAME			_T("\\emptyregdb.dat")


struct IComponentRecords;

//*****************************************************************************
// This structure is used to track global information about the registration
// process.  This includes enough information to send write requests and find
// loaded registration databases.
//*****************************************************************************
struct REGISTRATION_PROCESS
{
	// Lock for the table list (this is up front to allow clear of all data afterword).

	// Header data.
	ULONG		Magic;					// Signature (sanity check).
	USHORT		Major;					// Major version number for this data.
	USHORT		Minor;					// Minor version number for this data.
	long		COMRegPresent;			// Semaphore for reg process.

	// Timestamp to show I am still alive
	DWORD		dwLastLive;

	__int64		LatestVersion;		

};




//********** Prototypes. ******************************************************

STDAPI			CoRegInitialize();
STDAPI_(void)	CoRegUnInitialize();
STDAPI			CoRegGetICR(IComponentRecords **ppICR);
STDAPI_(void)	CoRegReleaseICR(IComponentRecords **ppICR);
STDAPI_(void)	CoRegReleaseCache();


BOOL _GetRegistrationDirectory( LPTSTR szRegDir );
UINT InternalGetSystemWindowsDirectory(LPTSTR lpBuffer, UINT uSize);

// Return to default padding.
#include "poppack.h"


} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\mofgen.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    MofGen.h

$Header: $

Abstract:
    This is the file that all mof generators include.

Author:
    mohits     5/8/2001        Initial Release

Revision History:

--**************************************************************************/

#ifndef __MOFGEN_H__
#define __MOFGEN_H__

#pragma once

#include <wbemcli.h>
#include <stdio.h>
#include "cfgarray.h"

//
// IWMIObject
//
class IWMIObject : public IUnknown
{
public:
    virtual HRESULT WriteToFile(FILE* i_pFile) = 0;
};

//
// IWMIQualifier
//
class IWMIQualifier : public IWMIObject
{
public:
    virtual HRESULT Set(
        LPCWSTR          i_wszName,
        const VARIANT*   i_pvValue,
        ULONG            i_ulFlavors) = 0;

    virtual LPCWSTR        GetName()    const = 0;
    virtual const VARIANT* GetValue()   const = 0;
    virtual ULONG          GetFlavors() const = 0;
};

//
// IWMIProperty
//
class IWMIProperty : public IWMIObject
{
public:
    virtual HRESULT AddQualifier(
        IWMIQualifier* i_pQualifier) = 0;

    virtual HRESULT AddQualifier(
        LPCWSTR         i_wszName,
        const VARIANT*  i_pvValue,
        ULONG           i_ulFlavors,
        IWMIQualifier** o_ppQualifier=NULL) = 0;

    virtual HRESULT SetNameValue(
        LPCWSTR        i_wszName,
        CIMTYPE        i_cimtype,
        const VARIANT* i_pvValue) = 0;

    virtual HRESULT SetExtraTypeInfo(
        LPCWSTR        i_wszInfo) = 0;
};

//
// IWMIClass
//
class IWMIClass : public IWMIObject
{
public:
    virtual HRESULT AddQualifier(
        IWMIQualifier* i_pQualifier) = 0;

    virtual HRESULT AddQualifier(
        LPCWSTR         i_wszName,
        const VARIANT*  i_pvValue,
        ULONG           i_ulFlavors,
        IWMIQualifier** o_ppQualifier=NULL) = 0;

    virtual HRESULT AddProperty(
        IWMIProperty*  i_pProperty) = 0;

    virtual HRESULT AddProperty(
        LPCWSTR         i_wszName,
        VARTYPE         i_vartype,
        const VARIANT*  i_pvValue,
        IWMIProperty**  o_ppProperty=NULL) = 0;

    virtual HRESULT SetName(
        LPCWSTR        i_wszName) = 0;

    virtual HRESULT SetBaseClass(
        LPCWSTR        i_wszBaseClass) = 0;

    virtual void    SetPragmaDelete(
        bool           i_bDelete) = 0;
};

//
// CMofGenerator
//
class CMofGenerator
{
public:
    CMofGenerator();
    ~CMofGenerator();

    HRESULT Generate(
        FILE*           i_pFile);

    HRESULT AddClass(
        IWMIClass*      i_pClass);

    static HRESULT SpawnClassInstance(
        IWMIClass**     o_ppClass);

    static HRESULT SpawnQualifierInstance(
        IWMIQualifier** o_ppQualifier);

    static HRESULT SpawnPropertyInstance(
        IWMIProperty**  o_ppProperty);

private:
    CMofGenerator(const CMofGenerator& );
    CMofGenerator& operator= (const CMofGenerator& );

protected:
    virtual HRESULT WriteClasses(
        FILE*           i_pFile);

    virtual HRESULT WriteHeader(
        FILE*           i_pFile);

    virtual HRESULT WriteFooter(
        FILE*           i_pFile);

    CCfgArray<IWMIClass*> m_apClasses;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\smartpointer.h ===
//  Copyright (C) 1999 Microsoft Corporation.  All rights reserved.

//This pointer class wraps a pointer so that delete happens automatically when the TSmartPointer goes out of scope
//If this is not the behavior you want then don't use this wrapper class


#ifndef __SMARTPOINTER_H__
#define __SMARTPOINTER_H__

#ifndef ASSERT
    #define ASSERT(x)
#endif

//Destructor is NOT virtual bacause I don't see why anyone would ever treat a TSmartPointerArray as a TSmartPointer

#pragma warning(disable : 4284)//It's OK to use this SmartPointer class with native types; but the -> operator doesn't make sense.  Compiler warns of this.

template <class T> class TSmartPointer
{
public:
    TSmartPointer()                     : m_p(0) {}
    TSmartPointer(T* p)                 : m_p(p) {}
    ~TSmartPointer()                    { Delete();}

    operator T*() const                 { return m_p; }
    T& operator*() const                { ASSERT(0!=m_p); return *m_p; }

    T** operator&()                     { ASSERT(0==m_p); return &m_p; }
    T* operator->() const               { ASSERT(0!=m_p); return m_p; }
    T* operator=(T* p)                  { return (m_p = p); }
    bool operator!() const              { return (0 == m_p); }
    bool operator==(const T* p) const   { return m_p == p; }

    void Delete()                       { delete m_p; m_p=0; }

    T* m_p;
private:
    TSmartPointer(const TSmartPointer<T>& p)    {}//This is private bacause it doesn't make sense to automatically clean up a copy of the pointer
};


template <class T> class TSmartPointerArray : public TSmartPointer<T>
{
public:
    TSmartPointerArray(T *p)            : TSmartPointer<T>(p) {}
    TSmartPointerArray()                : TSmartPointer<T>() {}
    ~TSmartPointerArray()               { Delete();}

    T* operator++()                     { ASSERT(0!=m_p); return ++m_p; }
    T* operator+=(int n)                { ASSERT(0!=m_p); return (m_p+=n); }
    T* operator-=(int n)                { ASSERT(0!=m_p); return (m_p-=n); }
    T* operator--()                     { ASSERT(0!=m_p); return --m_p; }
//    T& operator[](int n) const          { ASSERT(0!=m_p); return m_p[n]; }
    bool operator<(const T* p) const    { return m_p < p; }
    bool operator>(const T* p) const    { return m_p > p; }
    bool operator<=(const T* p) const   { return m_p <= p; }
    bool operator>=(const T* p) const   { return m_p >= p; }
    T* operator=(T p[])                 { return (m_p = p); }

    void Delete()                       { delete [] m_p; m_p=0; }
private:
    TSmartPointerArray(const TSmartPointerArray<T>& p)    {}//This is private bacause it doesn't make sense to automatically clean up a copy of the pointer
};


#endif //__SMARTPOINTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\sdtclb4ui.h ===
#ifndef __sdtclb4ui_h__
#define __sdtclb4ui_h__
#include "catalog.h"

DEFINE_GUID(CLSID_CLBDTDispenser,  0xA9D563FE, 0xBC65, 0x11D2, 0xB7, 0xF5, 0x00, 0xC0, 0x4F, 0x79, 0x78, 0xBE);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\stackdlgids.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// StackDlgIds.h - resource Ids for the assertion failure dialog

// IDS for StackDlg
#define IDD_STACKDLG                    601
#define IDC_MSG                         601
#define IDC_STACK                       602
#define IDC_DEBUG_BREAK                 603
#define IDC_IGNORE                      604
#define	IDC_ABORT						605
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\sdtclb.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __sdtcorclb_h__
#define __sdtcorclb_h__
#include "catalog.h"
DEFINE_GUID(CLSID_CLBDTDispRuntime,  0x07D26616, 0x6136, 0x11D1, 0x8C, 0x9C, 0x00, 0xC0, 0x4F, 0xC3, 0x26, 0x1D);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\remoteutil.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef _REMOTEUTIL_H
#define _REMOTEUTIL_H

HRESULT GetSecureCatalogServerInterface(LPCWSTR i_wszComputer, REFIID i_iid, float* o_pVersion, DWORD * o_dwImpersonationLevel, void** o_ppItf);

// Note this function assume that it is given a valid string and will break if it is not.
LPTSTR SZStripLastBS(LPTSTR ptszDir);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\shared.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __SHARED_INCLUDED__
#define __SHARED_INCLUDED__

#include <catmacros.h>

#ifndef precondition

#if defined(NDEBUG)
#define precondition(x)
#define postcondition(x)
#else
#define precondition(x) ASSERT(x)
#define postcondition(x) ASSERT(x)
#endif // defined(NDEBUG)

#endif // precondition

#ifndef self
#define self (*this)
#endif

#ifndef traceOnly
#define traceOnly(x)
#endif

#ifndef debug
# if defined(NDEBUG)
#define debug(x)
# else
#define debug(x) x
# endif
#endif

typedef BYTE*	        PB;		    // pointer to some bytes
typedef long    	    CB;		    // count of bytes
typedef unsigned long   ulong;	    // count of bytes
typedef wchar_t         CH;
typedef CH*             SZ;         // wide char string
typedef const CH*       SZ_CONST;   // const wide char string
typedef unsigned long   HASH;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\svcerr.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef _SVCERR_H_
#define _SVCERR_H_

#include <wtypes.h>
#include <objbase.h>
//#include <coguid.h>
//#include <tchar.h>
#include <svcmsg.h>
#include "catmacros.h"

//=============================================================================
//
//  Note: you need to stutter-define this macro so that the preprocessor has
//  a chance to replace __FILE__ with the string version of the file name
//  *before* it munges an L onto the stringification. Believe it or else,
//  this is how _T() is defined in TCHAR.H.
//
//-----------------------------------------------------------------------------

#define JIMBORULES(x) L ## x
#define W(x) JIMBORULES(x)

// forward reference - can't include utsem.h because it includes us
class CSemExclusive;


// We have a lot of code that assumes ASSERTs will be active in both free and
// checked builds and could yield unpredictable results if this weren't the
// case. To phase out this incorrect use of ASSERT, we provide an alternative
// that works in the traditional way. The name (Win4Assert) is taken from COM
// with the idea that someday we'll converge on common tools in both trees.
#ifdef _DEBUG
#define	Win4Assert(expr)	ASSERT(expr)
#define DEBUG_ASSERT(expr)	ASSERT(expr)
#define DEBUG_ASSERTHROK(str, hr) \
		    { if((hr) != S_OK) FAILHR(str, hr); }

#else
#define	Win4Assert(expr)
#define DEBUG_ASSERT(expr)
#define DEBUG_ASSERTHROK(str, hr)
#endif

// Legacy support...


#ifdef _DEBUG
	#define DEBUG_ERROR_CHECK(cond) \
			INTERNAL_ERROR_CHECK(cond)
#else
	#define DEBUG_ERROR_CHECK(cond)
#endif






///////////////////////////////////////////////////////////////////////////////
// The following is mostly legacy code that needs to be removed. Unfortunately,
// some of the pollution has spread outside of the comsvcs dir, so we'll have
// to work at phasing this stuff out over time.
///////////////////////////////////////////////////////////////////////////////


//+----------------------------------------------------------------------------
// FAIL functions -- log information, abort the process
//
// FAIL() is like LOG(), above, but aborts the process too
// FAILLASTWINERR() is like LOGLASTWINERR(), above, but aborts the process too
//  
//-----------------------------------------------------------------------------

#define FAIL(str) \
		    { LogString(W(str), W(__FILE__), __LINE__); FailFastStr(W(str), W(__FILE__), __LINE__); }


#define FAILLASTWINERR(str) \
		    { LogWinError(W(str), GetLastError(), W(__FILE__), __LINE__);; FailFastStr(W(str), W(__FILE__), __LINE__); }

//+----------------------------------------------------------------------------
//
// ASSERT/CHECK functions -- FAIL if a condition holds
//
// ASSERT works like FAIL(), but only if "bool" is true; if so, it fails
//   with its condition "bool" turned into a string
// CHECKBOOL works like FAIL(), but only if "bool" is true.
//
//-----------------------------------------------------------------------------


#define CHECKBOOL(str, bool) \
		    { if(!(bool)) FAIL(str); }


//+----------------------------------------------------------------------------
//
// These are the functions that implement the above macros. You shouldn't
//  call them unless you're one of these macros.
//
//-----------------------------------------------------------------------------

// Logging functions
void LogString(const wchar_t* szString, const wchar_t* szFile, int iLine);
void LogWinError(const wchar_t* szString, int rc, const wchar_t* szFile, int iLine);

// Failfast functions
void FailFastStr(const wchar_t * szString, const wchar_t * szFile, int nLine);

//  Trace functions
void Trace(const wchar_t* szPattern, ...);


//+----------------------------------------------------------------------------
//
// These macros help port MTS2 code into the new source tree. We need to
// decide which set of macros we like. The old ones distinguished between
// a larger set of error situations, so blindly switching to the new macros
// would result in a loss of information.
//
// TODO: Pick one set of error support macros and use them universally.
// 
//-----------------------------------------------------------------------------
#ifndef DEBUGTRACE0
#define	DEBUGTRACE0(x)					TRACE(L##x)
#endif
#ifndef DEBUGTRACE1
#define	DEBUGTRACE1(x, a1)				TRACE(L##x, a1)
#endif


#endif // _SVCERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\sdtfst.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.

#if !defined(AFX_STBASE_H__14A33215_096C_11D1_965A_00C04FB9473F__INCLUDED_)
#define AFX_STBASE_H__14A33215_096C_11D1_965A_00C04FB9473F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "windef.h"
#include "catalog.h"



typedef struct							// Column data offsets:
{
	WORD	obStatus;						// Offset in bytes to column data status.
	WORD	oulSize;						// Offset in ulongs to column data size.
	ULONG	opvValue;						// Offset in void*s to column data value.
} ColumnDataOffsets;
										// Forward declarations:

// ------------------------------------------------------------------
// class CMemoryTable:
// ------------------------------------------------------------------
// Base class for implementing simple data tables for various datastores.
// This base class uses the in-memory marshallable Fox rowset as its table cache.
// Data table implementors using this base class must derive from it privately.
//
// Complete or partial method implementations are provided for the interfaces 
// ISimpleTable, ISimpleTableMeta, ISimpleTableRowset, ISimpleDataTableDispenser.
// Methods which operate exclusively on the cache are fully implemented.
// The derived class must implement datastore-dependent methods, but
// helper methods are provided to support the associated cache-specific work.
//
// Method names of these base implementations begin with "Internal".
// These methods should be called as appropriate from the derived class.
// 
class CMemoryTable :
	public ISimpleTableInterceptor,
	public ISimpleTableWrite2,
	public ISimpleTableController,
	public ISimpleTableMarshall	

{
// -----------------------------------------
// samsara
// -----------------------------------------
public:
			CMemoryTable	();
			~CMemoryTable	();

// -----------------------------------------
// IUnknown, IClassFactory, ISimpleLogicTableDispenser:
// -----------------------------------------

//IUnknown
public:
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

//ISimpleLogicTableDispenser
public:
	STDMETHOD(Intercept) (
						LPCWSTR					i_wszDatabase,
						LPCWSTR 				i_wszTable, 
						ULONG					i_TableID,
						LPVOID					i_QueryData,
						LPVOID					i_QueryMeta,
						DWORD					i_eQueryFormat,
						DWORD					i_fTable,
						IAdvancedTableDispenser* i_pISTDisp,
						LPCWSTR					i_wszLocator,
						LPVOID					i_pv,
						LPVOID*					o_ppv
						);

// -----------------------------------------
// ISimpleTable*:
// -----------------------------------------

//ISimpleTableRead2
public:

	STDMETHOD (GetRowIndexByIdentity)	(ULONG * i_cb, LPVOID * i_pv, ULONG* o_piRow);

    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);

	STDMETHOD (GetColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);

	STDMETHOD (GetTableMeta) (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG *o_pcRows, ULONG* o_pcColumns);

	STDMETHOD (GetColumnMetas)		(ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas);
//ISimpleTableWrite2
public:
	STDMETHOD (AddRowForDelete)			(ULONG i_iReadRow);

	STDMETHOD (AddRowForInsert)	(ULONG* o_piWriteRow);
	STDMETHOD (AddRowForUpdate)	(ULONG i_iReadRow, ULONG* o_piWriteRow);

	STDMETHOD (GetWriteColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues);
	STDMETHOD (SetWriteColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* i_apvValues);

	STDMETHOD (GetWriteRowIndexByIdentity)	(ULONG * i_cbSizes, LPVOID * i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetWriteRowIndexBySearch)	(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetErrorTable)               (DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable);

	STDMETHOD (UpdateStore)				();
	
//ISimpleTableController
public:
	STDMETHOD (ShapeCache)				(DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes);
	STDMETHOD (PrePopulateCache)		(DWORD i_fControl);
	STDMETHOD (PostPopulateCache)		();
	STDMETHOD (DiscardPendingWrites)	();

	STDMETHOD (GetWriteRowAction)		(ULONG i_iRow, DWORD* o_peAction);
	STDMETHOD (SetWriteRowAction)		(ULONG i_iRow, DWORD i_eAction);
	STDMETHOD (ChangeWriteColumnStatus)	(ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus);

	STDMETHOD (AddDetailedError)		(STErr* o_pSTErr);

	STDMETHOD (GetMarshallingInterface) (IID * o_piid, LPVOID * o_ppItf);

//ISimpleTableAdvanced
public:
	STDMETHOD (PopulateCache)		();
	STDMETHOD (GetDetailedErrorCount)	(ULONG* o_pcErrs);
	STDMETHOD (GetDetailedError)		(ULONG i_iErr, STErr* o_pSTErr);

//ISimpleTableMarshall
public:
	STDMETHOD (SupplyMarshallable) (DWORD i_fReadNotWrite,
		char **	o_ppv1,	ULONG *	o_pcb1,	char **	o_ppv2, ULONG *	o_pcb2, char **	o_ppv3,
		ULONG *	o_pcb3, char **	o_ppv4, ULONG *	o_pcb4, char **	o_ppv5,	ULONG *	o_pcb5);

	STDMETHOD (ConsumeMarshallable) (DWORD i_fReadNotWrite,
		char * i_pv1, ULONG i_cb1,	char * i_pv2, ULONG i_cb2,	char * i_pv3, 
		ULONG i_cb3, char * i_pv4, ULONG i_cb4,	char * i_pv5, ULONG i_cb5);


private:
	void	BeginAddRow				();
	void	EndAddRow				();

// -----------------------------------------
// read/write helpers:
// -----------------------------------------
	void	RestartEitherRow		(DWORD i_eReadOrWrite);
	HRESULT MoveToEitherRowByIdentity(DWORD i_eReadOrWrite, ULONG* i_acb, LPVOID* i_apv, ULONG* o_piRow);
	HRESULT GetEitherRowIndexBySearch(DWORD i_eReadOrWrite, ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
	HRESULT GetEitherColumnValues	(ULONG i_iRow, DWORD i_eReadOrWrite, ULONG i_cColumns, ULONG *i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes , LPVOID* o_apvValues);
	HRESULT AddWriteRow				(DWORD fAction, ULONG* o_piWriteRow);
	HRESULT CopyWriteRowFromReadRow	(ULONG i_iReadRow, ULONG i_iWriteRow);
	HRESULT GetRowFromIndex			(DWORD i_eReadOrWrite, ULONG i_iRow, VOID** o_ppvRow);

	void PostMerge (ULONG i_iStartRow, ULONG i_cMergeRows, ULONG i_iDelta);
// -----------------------------------------
// Derived class helpers:
// -----------------------------------------
public:
	static BOOL	InternalMatchValues		(DWORD eOperator, DWORD dbType, DWORD fMeta, ULONG size1, ULONG size2, void *pv1, void *pv2);
public:

// -----------------------------------------
// interface ISimpleDataTableDispenser:
// -----------------------------------------
// Method implementations: 1 partial: 1 total.
// GetTable:	All information necessary to create an empty shaped cache is specified
//				once via InternalSimpleInitialize prior to calling any other methods,
//				including ConsumeMarshallable.
//				The derived class specifies the table flags from the dispenser, 
//				count of columns, and an array of column meta, which the base copies.
//

// -----------------------------------------
// interface ISimpleTableRead2
// -----------------------------------------
// Method implementations:  4 complete, 1 partial: 5 total.
//
// Partial implementations of the following methods are provided:
// GetTableMeta:	The table id and query is not known to the base implementation.	
//
// The remaining methods are completely implemented and should be directly delegated.
//
	
// -----------------------------------------
// interface ISimpleTableWrite2
// -----------------------------------------
// Method implementations:  8 complete, 1 notimpl: 9 total.
//
// The following methods must be exclusively implemented by the derived class:
// UpdateStore:			The derived class must call InternalPreUpdateStore immediately
//						preceding their update, then must write all pending updates, 
//						insertions,	and deletions to the datastore and must call 
//						InternalPostUpdateStore when done (which clears the write cache).
//InternalAbortAddRow:	This is not yet implemented and will return E_NOTIMPL for now
// The remaining methods are completely implemented and should be directly delegated.
//
	HRESULT	InternalPreUpdateStore			();
	
// -----------------------------------------
// interface ISimpleTableAdvanced
// -----------------------------------------
// Method implementations:  7 complete: 7 total.
//
// Partial implementations of the following methods are provided:
// PopulateCache:				The derived class must call InternalPrePopulateCache
//								immediately preceding their population and must call
//								InternalPostPopulateCache immediately following.
//								While populating, AddRowForInsert, SetWriteColumn, and
//								ValidateRow all act on the read cache.
// CloneCursor:					The derived class must create a copy of itself first.
//								InternalCloneCursor takes that copy and copies all base members.
//								This results in another cursor to the same cache.
// The following methods must be exclusively implemented by the derived class:
// ChangeQuery.
//
// The remaining methods are completely implemented and should be directly delegated.
//
	HRESULT InternalMoveToWriteRowByIdentity(ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);

// -----------------------------------------
// interface ISimpleTableController
// -----------------------------------------
// Method implementations:	4 complete : 9 total.
//
// The following methods must be exclusively implemented by the derived class:
// GetMarshallingInterface.
//
// The remaining methods are completely implemented and should be directly delegated.
//
// Use InternalSimpleInitialize for ShapeCache (many implementors will opt to E_NOTIMPL this method).
// Use InternalPre/PostPopulateCache for Pre/PostPopulateCache.
// Use InternalPostUpdateStore for DiscardPendingWrites.
//
// -----------------------------------------
// interface ISimpleTableMarshall
// -----------------------------------------
// Method implementations:  2 complete : 2 total.
//
//	InternalSupplyMarshallable: supplies the data for marshalling the cache
//  InternalConsumeMarshallable: initializes the cache with data from marshalling
//
	
// -----------------------------------------
// Methods that used to be seperate on CSimpleDataTableCache
// -----------------------------------------
private:
	HRESULT	SetupMeta					(DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbDefSizes);

// -----------------------------------------
// Cache management:
// -----------------------------------------

	void	CleanupCaches				();
	HRESULT	ResizeCache					(DWORD i_fCache, ULONG i_cbNewSize);
	void	CleanupReadCache			();
	void	CleanupWriteCache			();
	void	CleanupErrorCache			();
	HRESULT	ShrinkWriteCache			();
	HRESULT	AddRowToWriteCache			(ULONG* o_piRow, LPVOID* o_ppvRow);
	HRESULT	AddVarDataToWriteCache		(ULONG i_cb, LPVOID i_pv, ULONG** o_pib);
	HRESULT	AddErrorToErrorCache		(STErr* i_pSTErr);
	void	BeginReadCacheLoading		();
	void	ContinueReadCacheLoading	();
	void	EndReadCacheLoading			();
	void	RemoveDeletedRows			();

// -----------------------------------------
// Offset and pointer calculation helpers:
// -----------------------------------------

	ULONG	cbWithPadding				(ULONG i_cb, ULONG i_cbPadTo);

	ULONG	cbDataTotalParts			();

	ULONG	cDataStatusParts			();
	ULONG	cDataSizeParts				();
	ULONG	cDataValueParts				();
	ULONG	cDataTotalParts				();
	
	ULONG	obDataStatusPart			(ULONG i_iColumn);
	ULONG	obDataSizePart				(ULONG i_iColumn);
	ULONG	obDataValuePart				(ULONG i_iColumn);

	ULONG	oulDataSizePart				(ULONG i_iColumn);
	ULONG	opvDataValuePart			(ULONG i_iColumn);
	ULONG	odwDataActionPart			();

	BYTE*	pbDataStatusPart			(LPVOID i_pv, ULONG i_iColumn);
	ULONG*	pulDataSizePart				(LPVOID i_pv, ULONG i_iColumn);
	LPVOID*	ppvDataValuePart			(LPVOID i_pv, ULONG i_iColumn);
	DWORD*	pdwDataActionPart			(LPVOID i_pv);

	LPVOID	pvVarDataFromIndex			(BYTE i_statusIndex, LPVOID i_pv, ULONG i_iColumn);

	LPVOID	pvDefaultFromIndex			(ULONG i_iColumn);
	ULONG	lDefaultSize				(ULONG i_iColumn);

	STErr*	pSTErrPart					(ULONG i_iErr);

private:
	// Helper functions
	SIZE_T GetMultiStringLength (LPCWSTR i_wszMS) const;
	static BOOL  MultiStringCompare (LPCWSTR i_wszLHS, LPCWSTR i_wszRHS, BOOL fCaseInsensitive);
// -----------------------------------------
// Member data:
// -----------------------------------------
private:
										// Meta information:	
	DWORD				m_fTable;			// Table flags.
	ULONG				m_cColumns;			// Count of columns.
	ULONG				m_cUnknownSizes;	// Count of columns with unknown sizes.
	ULONG				m_cStatusParts;		// Count of status parts in 32-bit units.
	ULONG				m_cValueParts;		// Count of value parts in 32-bit units.
	SimpleColumnMeta*	m_acolmetas;		// Simple column meta.
	ColumnDataOffsets*	m_acoloffsets;		// Column offsets.
	LPVOID*				m_acolDefaults;		// Column default values.
	ULONG*				m_alDefSizes;		// Column default sizes.
	ULONG				m_cbMinCache;		// Count of bytes of minimum cache size.

										// Cursor interaction:
	DWORD				m_fCache;			// Cache flags.
	ULONG				m_cRefs;			// Reference count of cursors.

										// Read cache:
	ULONG				m_cReadRows;		// Count of read cache rows filled.
	ULONG				m_cbReadVarData;	// Count of bytes of read cache variable data filled.
	LPVOID				m_pvReadVarData;	// Void pointer to read cache variable data.

	LPVOID				m_pvReadCache;		// Void pointer to the read cache.
	ULONG				m_cbReadCache;		// Count of bytes of read cache data filled.
	ULONG				m_cbmaxReadCache;	// Count of bytes of read cache allocated.
										// Write cache:
	ULONG				m_cWriteRows;		// Count of write cache rows filled.
	ULONG				m_cbWriteVarData;	// Count of bytes of write cache variable data filled.
	LPVOID				m_pvWriteVarData;	// Void pointer to write cache variable data.

	LPVOID				m_pvWriteCache;		// Void pointer to the write cache.
	ULONG				m_cbWriteCache;		// Count of bytes of write cache data filled.
	ULONG				m_cbmaxWriteCache;	// Count of bytes of write cache allocated.

										// Detailed errors:
	ULONG				m_cErrs;			// Count of detailed errors filled.
	ULONG				m_cmaxErrs;			// Count of detailed errors allocated.
	LPVOID				m_pvErrs;			// Void pointer to detailed errors.

	// Formerly lived in sltshp.
	ULONG				m_cRef;						// Interface reference count.
	DWORD				m_fIsDataTable;				// Either component is posing as class factory / dispenser or data table.
	DWORD				m_fTable2;					// Table flags.
};

#endif // !defined(AFX_STBASE_H__14A33215_096C_11D1_965A_00C04FB9473F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\svcmem.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef _SVCMEM_H_
#define _SVCMEM_H_

#ifndef DO_NOT_USE_FAILFAST_ALLOCATIONS
#include <svcerr.h>
#endif

#include <objbase.h>
#ifndef _CATALOGMACROS
    #include "CatMacros.h"
#endif

// Memory Allocation:
//
// We use COM's allocator. These are just simple wrappers.
//
//	If you don't want it to return when there is no memory:
//		p = new(SAFE) CFoo();	or
//		p = SafeMalloc(size);
//	If you want it to return NULL when there is no memory:
//		p = new(UNSAFE) CFoo();	or
//		p = UnsafeMalloc(size);
//	To deallocate memory, use:
//		delete p;				or
//		SafeFree(p);			or
//		UnsafeFree(p);
//	For deallocation, SAFE and UNSAFE are exactly equivalent.
//

enum ESafeness { SAFE, UNSAFE };

inline void* UnsafeMalloc (size_t ulcBytes)
{
	return CoTaskMemAlloc(ulcBytes);
}

#ifndef DO_NOT_USE_FAILFAST_ALLOCATIONS
inline void* SafeMalloc (size_t cb)
{
	void* ptr = UnsafeMalloc(cb);
	if (ptr == NULL) {
		FAILLASTWINERR("Out of memory");
	}
	return ptr;
}
#endif

inline void SafeFree (void* pv)
{
	CoTaskMemFree(pv);
}

inline void UnsafeFree (void* pv)
{
	SafeFree (pv);
}

inline void* operator new (size_t cb, ESafeness safeness)
{
#ifndef DO_NOT_USE_FAILFAST_ALLOCATIONS
	if (safeness == SAFE)
		return SafeMalloc (cb);
	else
#endif
		return UnsafeMalloc (cb);
}
/*
// Naked new's can come from ATL so we need to allow for them...
inline void* __cdecl operator new (size_t cb)
{
	return UnsafeMalloc (cb);
}
inline void __cdecl operator delete (void* pv) { SafeFree (pv); }
*/

#endif // _SVCMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\tfilemapping.h ===
#ifndef __TFILEMAPPING_H__
#define __TFILEMAPPING_H__


#define E_ERROR_OPENING_FILE    0x80000004

#include "WinWrap.h"

//  TFileMapping
//  
//  This class abstracts the mapping process and guarentees cleanup.
class TFileMapping
{
public:
    TFileMapping() : m_hFile(0), m_hMapping(0), m_pMapping(0), m_Size(0) {}
    ~TFileMapping(){Unload();}

    HRESULT Load(LPCTSTR filename, bool bReadWrite = false)
    {
        ASSERT(0 == m_hFile);
        //We don't do any error checking because the API functions should deal with NULL hFile & hMapping.  Use should check
        //m_pMapping (via Mapping()) before using the object.
        m_hFile = CreateFile(filename, GENERIC_READ | (bReadWrite ? GENERIC_WRITE : 0), FILE_SHARE_READ | (bReadWrite ?  0 : FILE_SHARE_WRITE), NULL, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
        m_hMapping = CreateFileMappingA(m_hFile, NULL, (bReadWrite ? PAGE_READWRITE : PAGE_READONLY), 0, 0, NULL);
        m_pMapping = reinterpret_cast<char *>(MapViewOfFile(m_hMapping, (bReadWrite ? FILE_MAP_WRITE : FILE_MAP_READ), 0, 0, 0));
        m_Size = GetFileSize(m_hFile, 0);
        return (0 == m_pMapping) ? E_ERROR_OPENING_FILE : S_OK;
    }
    HRESULT Unload()
    {
        if(m_pMapping)
        {
            if(0 == FlushViewOfFile(m_pMapping,0))
            {
                ASSERT(false && "ERROR - UNABLE TO FLUSH TO DISK");
            }
            UnmapViewOfFile(m_pMapping);
        }
        if(m_hMapping)
            CloseHandle(m_hMapping);
        if(m_hFile)
            CloseHandle(m_hFile);

        m_pMapping  = 0;
        m_hMapping  = 0;
        m_hFile     = 0;
        m_Size      = 0;

		return S_OK;
    }
    unsigned long   Size() const {return m_Size;}
    char *          Mapping() const {return m_pMapping;}
    char *          EndOfFile() const {return (m_pMapping + m_Size);}

private:
    HANDLE          m_hFile;
    HANDLE          m_hMapping;
    char *          m_pMapping;
    unsigned long   m_Size;
};

#endif //__TFILEMAPPING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\textfilelogger.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    TextFileLogger.h

$Header: $

Abstract:
    This is text file log complements the event file logging.

Author:
    ???             ???

Revision History:
    mohits          4/19/01

--**************************************************************************/

#pragma once

#ifndef _TEXTFILELOGGER_H_
#define _TEXTFILELOGGER_H_

#include <windows.h>
#include "catmacros.h"

// This is specific to our log file format.  It provides the following
// additional functionality: verify if log file is full and version
// number stuff.
struct TLogData : public WIN32_FIND_DATA
{
public:
    TLogData(
        ULONG   i_ulIdxNumPart,
        ULONG   i_ulFullSize) : WIN32_FIND_DATA()
    /*++

    Synopsis: 
        Constructor, class is useless until passed to Find*File.

    Arguments: [i_ulIdxNumPart] - The idx of the num part (i.e. where version starts)
               [i_ulFullSize]   - The size of a full log

    --*/
    {
        m_ulVersion  = 0;
        m_ulFullSize = i_ulFullSize;
        nFileSizeLow = 0;

        cFileName[0] = L'\0';
        m_idxNumPart = i_ulIdxNumPart;
    }

    TLogData(
        ULONG   i_ulIdxNumPart,
        ULONG   i_ulFullSize,
        LPCWSTR i_wszFileName,
        ULONG   i_ulFileSize) : WIN32_FIND_DATA()
    /*++

    Synopsis: 
        Constructor, lets user start out with a file.

    Arguments: [i_ulIdxNumPart] - The idx of the num part (i.e. where version starts)
               [i_ulFullSize]   - The size of a full log
               [i_wszFileName]  - The file name
               [i_ulFileSize]   - The current size of file on disk

    --*/
    {
        ASSERT(i_wszFileName);
        ASSERT(wcslen(i_wszFileName) < MAX_PATH);

        m_ulVersion  = 0;
        m_ulFullSize = i_ulFullSize;
        nFileSizeLow = i_ulFileSize;

        wcscpy(cFileName, i_wszFileName);
        m_idxNumPart = i_ulIdxNumPart;
    }

    bool ContainsData()
    /*++

    Synopsis: 
        Verifies that TLogData actually is referring to a file.  
        (i.e. this obj was passed to Find*File)

    Return Value: 
        bool

    --*/
    {
        return (cFileName[0] != L'\0');
    }


    bool IsFull()
    /*++

    Synopsis: 
        Sees if log is full

    Return Value: 
        bool

    --*/
    {
        ASSERT(*cFileName);
        return (nFileSizeLow >= m_ulFullSize);
    }

    bool SyncVersion()
    /*++

    Synopsis: 
        Syncs ulVersion with the version number from the file.
        Needs to be run after filename changes (i.e. thru Find*File)

    Return Value: 

    --*/
    {
        ASSERT(*cFileName);
        return WstrToUl(
            &cFileName[m_idxNumPart],
            L'.',
            &m_ulVersion);
    }

    ULONG GetVersion()
    {
        ASSERT(*cFileName);
        return m_ulVersion;
    }

    void IncrementVersion()
    {
        ASSERT(*cFileName);
        m_ulVersion++;
        SetVersion(m_ulVersion);
    }

    void SetVersion(
        ULONG i_ulVersion)
    {
        ASSERT(*cFileName);
        m_ulVersion = i_ulVersion;
        _snwprintf(&cFileName[m_idxNumPart], 10, L"%010lu", m_ulVersion);
    }

private:
    ULONG m_idxNumPart;   // The array index into cFileName where version starts
    ULONG m_ulVersion;
    ULONG m_ulFullSize;

    bool WstrToUl(
        LPCWSTR  i_wszSrc,
        WCHAR    i_wcTerminator,
        ULONG*   o_pul);
};

class CMutexCreator
{
public:
    CMutexCreator(LPTSTR tszName)
    {
        DBG_ASSERT(tszName);

        _hMutex = CreateMutex(NULL, FALSE, tszName);
    }

    HANDLE GetHandle()
    {
        return _hMutex;
    }

    ~CMutexCreator()
    {
        if(_hMutex != NULL)
        {
            CloseHandle(_hMutex);
        }
    }

private:
    HANDLE          _hMutex;
};

class TextFileLogger : public ICatalogErrorLogger2
{
public:
    TextFileLogger(
                    const WCHAR* wszEventSource, 
                    HMODULE      hMsgModule,
                    DWORD        dwNumFiles=4);
    TextFileLogger( const WCHAR* wszProductID, 
                    ICatalogErrorLogger2 *pNext=0,
                    DWORD        dwNumFiles=4);

    virtual ~TextFileLogger();

//IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

//ICatalogErrorLogger2
	STDMETHOD(ReportError) (ULONG      i_BaseVersion_DETAILEDERRORS,
                            ULONG      i_ExtendedVersion_DETAILEDERRORS,
                            ULONG      i_cDETAILEDERRORS_NumberOfColumns,
                            ULONG *    i_acbSizes,
                            LPVOID *   i_apvValues);
    
    void Init(
        const WCHAR* wszEventSource, 
        HMODULE      hMsgModule=0);

    void Report(
        WORD         wType,
        WORD         wCategory,
        DWORD        dwEventID,
        WORD         wNumStrings,
        size_t       dwDataSize,
        LPCTSTR*     lpStrings,
        LPVOID       lpRawData,
        LPCWSTR      wszCategory=0,      //if NULL the category is looked up in this module using wCategory
        LPCWSTR      wszMessageString=0);//if NULL the message is looked up in this module using dwEventID

private:
    void Lock() {
        // Serialize access to the file by synchronizing on a machine-wide named mutex.
        WaitForSingleObject(_hMutex, INFINITE);
    }
    void Unlock() {
        ReleaseMutex(_hMutex);
    }

    // helper routine called by Report (determines correct file, opens it)
    void InitFile();

    // helper routine called by InitFile
    HRESULT DetermineFile();

    // Called by DetermineFile
    HRESULT GetFirstAvailableFile(
        LPWSTR     wszBuf,                                              
        LPWSTR     wszFilePartOfBuf,
        TLogData*  io_pFileData);

    // Called by DetermineFile
    bool ConstructSearchString(
        LPWSTR     o_wszSearchPath,
        LPWSTR*    o_ppFilePartOfSearchPath,
        LPWSTR*    o_ppNumPartOfSearchPath);

    // Called by DetermineFile
    void SetGlobalFile(
        LPCWSTR    i_wszSearchString,
        ULONG      i_ulIdxNumPart,
        ULONG      i_ulVersion);

private:
    DWORD                _dwMaxSize;    // Total size (in bytes) of _dwNumFiles files
    const DWORD          _dwNumFiles;   // Number of files log is divided into
    const WCHAR*         _eventSource;
    HANDLE               _hFile;
    HMODULE              _hMsgModule;
    HANDLE               _hMutex;
    static CMutexCreator _MutexCreator;

    ULONG           m_cRef;
    WCHAR           m_wszProductID[64];
    CComPtr<ICatalogErrorLogger2> m_spNextLogger;
};

class NULL_Logger : public ICatalogErrorLogger2
{
public:
    NULL_Logger() : m_cRef(0){}
    virtual ~NULL_Logger(){}

//IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv)
    {
        if (NULL == ppv) 
            return E_INVALIDARG;
        *ppv = NULL;

        if (riid == IID_ICatalogErrorLogger2)
            *ppv = (ICatalogErrorLogger2*) this;
        else if (riid == IID_IUnknown)
            *ppv = (ICatalogErrorLogger2*) this;

        if (NULL == *ppv)
            return E_NOINTERFACE;

        ((ICatalogErrorLogger2*)this)->AddRef ();
        return S_OK;
    }
	STDMETHOD_(ULONG,AddRef)		()
    {
        return InterlockedIncrement((LONG*) &m_cRef);
    }
	STDMETHOD_(ULONG,Release)		()
    {
        long cref = InterlockedDecrement((LONG*) &m_cRef);
        if (cref == 0)
            delete this;

        return cref;
    }

//ICatalogErrorLogger2
	STDMETHOD(ReportError) (ULONG      i_BaseVersion_DETAILEDERRORS,
                            ULONG      i_ExtendedVersion_DETAILEDERRORS,
                            ULONG      i_cDETAILEDERRORS_NumberOfColumns,
                            ULONG *    i_acbSizes,
                            LPVOID *   i_apvValues){return S_OK;}
private:
    ULONG           m_cRef;
};

#endif //_TEXTFILELOGGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\transact.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0158 */
/* at Mon Mar 15 19:30:31 1999
 */
/* Compiler settings for transact.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __transact_h__
#define __transact_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITransaction_FWD_DEFINED__
#define __ITransaction_FWD_DEFINED__
typedef interface ITransaction ITransaction;
#endif 	/* __ITransaction_FWD_DEFINED__ */


#ifndef __ITransactionDispenser_FWD_DEFINED__
#define __ITransactionDispenser_FWD_DEFINED__
typedef interface ITransactionDispenser ITransactionDispenser;
#endif 	/* __ITransactionDispenser_FWD_DEFINED__ */


#ifndef __ITransactionOptions_FWD_DEFINED__
#define __ITransactionOptions_FWD_DEFINED__
typedef interface ITransactionOptions ITransactionOptions;
#endif 	/* __ITransactionOptions_FWD_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_FWD_DEFINED__
#define __ITransactionOutcomeEvents_FWD_DEFINED__
typedef interface ITransactionOutcomeEvents ITransactionOutcomeEvents;
#endif 	/* __ITransactionOutcomeEvents_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_transact_0000 */
/* [local] */ 






#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_transact_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_transact_0000_v0_0_s_ifspec;

#ifndef __BasicTransactionTypes_INTERFACE_DEFINED__
#define __BasicTransactionTypes_INTERFACE_DEFINED__

/* interface BasicTransactionTypes */
/* [unique][local] */ 

typedef struct  BOID
    {
    byte rgb[ 16 ];
    }	BOID;

#define BOID_NULL (*((BOID*)(&IID_NULL)))
#ifndef MAX_TRAN_DESC_DEFINED
#define MAX_TRAN_DESC_DEFINED
typedef 
enum TX_MISC_CONSTANTS
    {	MAX_TRAN_DESC	= 40
    }	TX_MISC_CONSTANTS;

#endif
typedef BOID XACTUOW;

typedef LONG ISOLEVEL;

typedef 
enum ISOLATIONLEVEL
    {	ISOLATIONLEVEL_UNSPECIFIED	= 0xffffffff,
	ISOLATIONLEVEL_CHAOS	= 0x10,
	ISOLATIONLEVEL_READUNCOMMITTED	= 0x100,
	ISOLATIONLEVEL_BROWSE	= 0x100,
	ISOLATIONLEVEL_CURSORSTABILITY	= 0x1000,
	ISOLATIONLEVEL_READCOMMITTED	= 0x1000,
	ISOLATIONLEVEL_REPEATABLEREAD	= 0x10000,
	ISOLATIONLEVEL_SERIALIZABLE	= 0x100000,
	ISOLATIONLEVEL_ISOLATED	= 0x100000
    }	ISOLATIONLEVEL;

typedef struct  XACTTRANSINFO
    {
    XACTUOW uow;
    ISOLEVEL isoLevel;
    ULONG isoFlags;
    DWORD grfTCSupported;
    DWORD grfRMSupported;
    DWORD grfTCSupportedRetaining;
    DWORD grfRMSupportedRetaining;
    }	XACTTRANSINFO;

typedef struct  XACTSTATS
    {
    ULONG cOpen;
    ULONG cCommitting;
    ULONG cCommitted;
    ULONG cAborting;
    ULONG cAborted;
    ULONG cInDoubt;
    ULONG cHeuristicDecision;
    FILETIME timeTransactionsUp;
    }	XACTSTATS;

typedef 
enum ISOFLAG
    {	ISOFLAG_RETAIN_COMMIT_DC	= 1,
	ISOFLAG_RETAIN_COMMIT	= 2,
	ISOFLAG_RETAIN_COMMIT_NO	= 3,
	ISOFLAG_RETAIN_ABORT_DC	= 4,
	ISOFLAG_RETAIN_ABORT	= 8,
	ISOFLAG_RETAIN_ABORT_NO	= 12,
	ISOFLAG_RETAIN_DONTCARE	= ISOFLAG_RETAIN_COMMIT_DC | ISOFLAG_RETAIN_ABORT_DC,
	ISOFLAG_RETAIN_BOTH	= ISOFLAG_RETAIN_COMMIT | ISOFLAG_RETAIN_ABORT,
	ISOFLAG_RETAIN_NONE	= ISOFLAG_RETAIN_COMMIT_NO | ISOFLAG_RETAIN_ABORT_NO,
	ISOFLAG_OPTIMISTIC	= 16,
	ISOFLAG_READONLY	= 32
    }	ISOFLAG;

typedef 
enum XACTTC
    {	XACTTC_SYNC_PHASEONE	= 1,
	XACTTC_SYNC_PHASETWO	= 2,
	XACTTC_SYNC	= 2,
	XACTTC_ASYNC_PHASEONE	= 4,
	XACTTC_ASYNC	= 4
    }	XACTTC;

typedef 
enum XACTRM
    {	XACTRM_OPTIMISTICLASTWINS	= 1,
	XACTRM_NOREADONLYPREPARES	= 2
    }	XACTRM;

typedef 
enum XACTCONST
    {	XACTCONST_TIMEOUTINFINITE	= 0
    }	XACTCONST;

typedef 
enum XACTHEURISTIC
    {	XACTHEURISTIC_ABORT	= 1,
	XACTHEURISTIC_COMMIT	= 2,
	XACTHEURISTIC_DAMAGE	= 3,
	XACTHEURISTIC_DANGER	= 4
    }	XACTHEURISTIC;

typedef 
enum XACTSTAT
    {	XACTSTAT_NONE	= 0,
	XACTSTAT_OPENNORMAL	= 0x1,
	XACTSTAT_OPENREFUSED	= 0x2,
	XACTSTAT_PREPARING	= 0x4,
	XACTSTAT_PREPARED	= 0x8,
	XACTSTAT_PREPARERETAINING	= 0x10,
	XACTSTAT_PREPARERETAINED	= 0x20,
	XACTSTAT_COMMITTING	= 0x40,
	XACTSTAT_COMMITRETAINING	= 0x80,
	XACTSTAT_ABORTING	= 0x100,
	XACTSTAT_ABORTED	= 0x200,
	XACTSTAT_COMMITTED	= 0x400,
	XACTSTAT_HEURISTIC_ABORT	= 0x800,
	XACTSTAT_HEURISTIC_COMMIT	= 0x1000,
	XACTSTAT_HEURISTIC_DAMAGE	= 0x2000,
	XACTSTAT_HEURISTIC_DANGER	= 0x4000,
	XACTSTAT_FORCED_ABORT	= 0x8000,
	XACTSTAT_FORCED_COMMIT	= 0x10000,
	XACTSTAT_INDOUBT	= 0x20000,
	XACTSTAT_CLOSED	= 0x40000,
	XACTSTAT_OPEN	= 0x3,
	XACTSTAT_NOTPREPARED	= 0x7ffc3,
	XACTSTAT_ALL	= 0x7ffff
    }	XACTSTAT;

typedef struct  XACTOPT
    {
    ULONG ulTimeout;
    char szDescription[ 40 ];
    }	XACTOPT;

typedef 
enum XACT_E
    {	XACT_E_FIRST	= 0x8004d000,
	XACT_E_LAST	= 0x8004d022,
	XACT_S_FIRST	= 0x4d000,
	XACT_S_LAST	= 0x4d009,
	XACT_E_ALREADYOTHERSINGLEPHASE	= 0x8004d000,
	XACT_E_CANTRETAIN	= 0x8004d001,
	XACT_E_COMMITFAILED	= 0x8004d002,
	XACT_E_COMMITPREVENTED	= 0x8004d003,
	XACT_E_HEURISTICABORT	= 0x8004d004,
	XACT_E_HEURISTICCOMMIT	= 0x8004d005,
	XACT_E_HEURISTICDAMAGE	= 0x8004d006,
	XACT_E_HEURISTICDANGER	= 0x8004d007,
	XACT_E_ISOLATIONLEVEL	= 0x8004d008,
	XACT_E_NOASYNC	= 0x8004d009,
	XACT_E_NOENLIST	= 0x8004d00a,
	XACT_E_NOISORETAIN	= 0x8004d00b,
	XACT_E_NORESOURCE	= 0x8004d00c,
	XACT_E_NOTCURRENT	= 0x8004d00d,
	XACT_E_NOTRANSACTION	= 0x8004d00e,
	XACT_E_NOTSUPPORTED	= 0x8004d00f,
	XACT_E_UNKNOWNRMGRID	= 0x8004d010,
	XACT_E_WRONGSTATE	= 0x8004d011,
	XACT_E_WRONGUOW	= 0x8004d012,
	XACT_E_XTIONEXISTS	= 0x8004d013,
	XACT_E_NOIMPORTOBJECT	= 0x8004d014,
	XACT_E_INVALIDCOOKIE	= 0x8004d015,
	XACT_E_INDOUBT	= 0x8004d016,
	XACT_E_NOTIMEOUT	= 0x8004d017,
	XACT_E_ALREADYINPROGRESS	= 0x8004d018,
	XACT_E_ABORTED	= 0x8004d019,
	XACT_E_LOGFULL	= 0x8004d01a,
	XACT_E_TMNOTAVAILABLE	= 0x8004d01b,
	XACT_E_CONNECTION_DOWN	= 0x8004d01c,
	XACT_E_CONNECTION_DENIED	= 0x8004d01d,
	XACT_E_REENLISTTIMEOUT	= 0x8004d01e,
	XACT_E_TIP_CONNECT_FAILED	= 0x8004d01f,
	XACT_E_TIP_PROTOCOL_ERROR	= 0x8004d020,
	XACT_E_TIP_PULL_FAILED	= 0x8004d021,
	XACT_E_DEST_TMNOTAVAILABLE	= 0x8004d022,
	XACT_E_CLERKNOTFOUND	= 0x8004d080,
	XACT_E_CLERKEXISTS	= 0x8004d081,
	XACT_E_RECOVERYINPROGRESS	= 0x8004d082,
	XACT_E_TRANSACTIONCLOSED	= 0x8004d083,
	XACT_E_INVALIDLSN	= 0x8004d084,
	XACT_E_REPLAYREQUEST	= 0x8004d085,
	XACT_S_ASYNC	= 0x4d000,
	XACT_S_DEFECT	= 0x4d001,
	XACT_S_READONLY	= 0x4d002,
	XACT_S_SOMENORETAIN	= 0x4d003,
	XACT_S_OKINFORM	= 0x4d004,
	XACT_S_MADECHANGESCONTENT	= 0x4d005,
	XACT_S_MADECHANGESINFORM	= 0x4d006,
	XACT_S_ALLNORETAIN	= 0x4d007,
	XACT_S_ABORTING	= 0x4d008,
	XACT_S_SINGLEPHASE	= 0x4d009
    }	XACT_E;



extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_s_ifspec;
#endif /* __BasicTransactionTypes_INTERFACE_DEFINED__ */

#ifndef __ITransaction_INTERFACE_DEFINED__
#define __ITransaction_INTERFACE_DEFINED__

/* interface ITransaction */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0fb15084-af41-11ce-bd2b-204c4f4f5020")
    ITransaction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransactionInfo( 
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransaction __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransaction __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            ITransaction __RPC_FAR * This,
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransactionInfo )( 
            ITransaction __RPC_FAR * This,
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);
        
        END_INTERFACE
    } ITransactionVtbl;

    interface ITransaction
    {
        CONST_VTBL struct ITransactionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransaction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransaction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransaction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransaction_Commit(This,fRetaining,grfTC,grfRM)	\
    (This)->lpVtbl -> Commit(This,fRetaining,grfTC,grfRM)

#define ITransaction_Abort(This,pboidReason,fRetaining,fAsync)	\
    (This)->lpVtbl -> Abort(This,pboidReason,fRetaining,fAsync)

#define ITransaction_GetTransactionInfo(This,pinfo)	\
    (This)->lpVtbl -> GetTransactionInfo(This,pinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransaction_Commit_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ DWORD grfTC,
    /* [in] */ DWORD grfRM);


void __RPC_STUB ITransaction_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransaction_Abort_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [unique][in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ BOOL fAsync);


void __RPC_STUB ITransaction_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransaction_GetTransactionInfo_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);


void __RPC_STUB ITransaction_GetTransactionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransaction_INTERFACE_DEFINED__ */


#ifndef __ITransactionDispenser_INTERFACE_DEFINED__
#define __ITransactionDispenser_INTERFACE_DEFINED__

/* interface ITransactionDispenser */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionDispenser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3A6AD9E1-23B9-11cf-AD60-00AA00A74CCD")
    ITransactionDispenser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOptionsObject( 
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginTransaction( 
            /* [unique][in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [unique][in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionDispenserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionDispenser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionDispenser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptionsObject )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginTransaction )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [unique][in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [unique][in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);
        
        END_INTERFACE
    } ITransactionDispenserVtbl;

    interface ITransactionDispenser
    {
        CONST_VTBL struct ITransactionDispenserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionDispenser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionDispenser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionDispenser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionDispenser_GetOptionsObject(This,ppOptions)	\
    (This)->lpVtbl -> GetOptionsObject(This,ppOptions)

#define ITransactionDispenser_BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionDispenser_GetOptionsObject_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);


void __RPC_STUB ITransactionDispenser_GetOptionsObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionDispenser_BeginTransaction_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [unique][in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [unique][in] */ ITransactionOptions __RPC_FAR *pOptions,
    /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);


void __RPC_STUB ITransactionDispenser_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionDispenser_INTERFACE_DEFINED__ */


#ifndef __ITransactionOptions_INTERFACE_DEFINED__
#define __ITransactionOptions_INTERFACE_DEFINED__

/* interface ITransactionOptions */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3A6AD9E0-23B9-11cf-AD60-00AA00A74CCD")
    ITransactionOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionOptions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionOptions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ XACTOPT __RPC_FAR *pOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions);
        
        END_INTERFACE
    } ITransactionOptionsVtbl;

    interface ITransactionOptions
    {
        CONST_VTBL struct ITransactionOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOptions_SetOptions(This,pOptions)	\
    (This)->lpVtbl -> SetOptions(This,pOptions)

#define ITransactionOptions_GetOptions(This,pOptions)	\
    (This)->lpVtbl -> GetOptions(This,pOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionOptions_SetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_SetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOptions_GetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [out][in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_GetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOptions_INTERFACE_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_INTERFACE_DEFINED__
#define __ITransactionOutcomeEvents_INTERFACE_DEFINED__

/* interface ITransactionOutcomeEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITransactionOutcomeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3A6AD9E2-23B9-11cf-AD60-00AA00A74CCD")
    ITransactionOutcomeEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Committed( 
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Aborted( 
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Indoubt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOutcomeEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Committed )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Aborted )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HeuristicDecision )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ DWORD dwDecision,
            /* [unique][in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Indoubt )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        END_INTERFACE
    } ITransactionOutcomeEventsVtbl;

    interface ITransactionOutcomeEvents
    {
        CONST_VTBL struct ITransactionOutcomeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOutcomeEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOutcomeEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOutcomeEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOutcomeEvents_Committed(This,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr)

#define ITransactionOutcomeEvents_Indoubt(This)	\
    (This)->lpVtbl -> Indoubt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_Committed_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Committed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_Aborted_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [unique][in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [unique][in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Aborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_HeuristicDecision_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ DWORD dwDecision,
    /* [unique][in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_HeuristicDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_Indoubt_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This);


void __RPC_STUB ITransactionOutcomeEvents_Indoubt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOutcomeEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_transact_0011 */
/* [local] */ 



#if _MSC_VER < 1100 || !defined(__cplusplus)

DEFINE_GUID(IID_ITransaction,				0x0fb15084, 0xaf41, 0x11ce, 0xbd, 0x2b, 0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20);
DEFINE_GUID(IID_ITransactionDispenser,		0x3A6AD9E1, 0x23B9, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);
DEFINE_GUID(IID_ITransactionOptions,			0x3A6AD9E0, 0x23B9, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);
DEFINE_GUID(IID_ITransactionOutcomeEvents,	0x3A6AD9E2, 0x23B9, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);

#else

#define  IID_ITransaction                    __uuidof(ITransaction)
#define  IID_ITransactionDispenser           __uuidof(ITransactionDispenser)
#define  IID_ITransactionOptions             __uuidof(ITransactionOptions)
#define  IID_ITransactionOutcomeEvents       __uuidof(ITransactionOutcomeEvents)

#endif


extern RPC_IF_HANDLE __MIDL_itf_transact_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_transact_0011_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\tlist.h ===
#ifndef __TLIST_H__
#define __TLIST_H__

//  TList
//
//  This template deals with lists of any type of object.  The object is wrapped in a private linked
//  list class.  The routine adding items to the list should allocate the item, then add it.  The list
//  will delete the Node.  This list object also contains iterator functionality built in (rather
//  than a separate iterator class).
//
//  This class does NOT delete the items when removing them from the list.  A derived class could
//  implement this functionality.

template<class T> class TList
{
//Consumer methods
public:
    T   operator ++() { return Next();}
    T   operator --() { return Previous();}
    bool  IsAtHead() const {return (0 == m_pCurrent);}
    bool  IsAtTail() const {return (0 == m_pCurrent);}
    bool  IsEmpty()  const {return (0 == m_pHead);}
	ULONG Size()	 const {return m_cSize;}
    T   Next()
    {
        if(0 == m_pHead)//if the list is empty
            return 0;

        m_pCurrent = m_pCurrent ? m_pCurrent->m_pNext : m_pHead;

        if(0 == m_pCurrent)//if the Next is NULL then it has no value
            return 0;

        return m_pCurrent->m_Value;
    }
    T   Previous()
    {
        if(0 == m_pHead)//if the list is empty
            return 0;

        //if we're already at the beginning then wrap around to the Tail
        m_pCurrent = m_pCurrent ? m_pCurrent->m_pPrev : m_pTail;

        if(0 == m_pCurrent)//if the current is NULL then there is no Prev
            return 0;

        return m_pCurrent->m_Value;
    }
    void Reset(){m_pCurrent = 0;}

//Creator methods
public:
    TList() : m_pCurrent(0), m_pHead(0), m_pTail(0), m_cSize (0){}
    virtual ~TList(){}
    HRESULT InsertAfterCurrent(T i_Value)
    {
        if(0 == m_pHead)//if an empty list then just PushFront
            return PushFront(i_Value);

        if(0 == m_pCurrent)
        {   //if we're pointing at the beginning then PushFront
            TListNode * pNode = new TListNode(i_Value);
            if(0 == pNode)
                return E_OUTOFMEMORY;
            pNode->InsertAfter(*m_pHead);
        }
        else
        {   //if we're pointing at the end
            if(m_pCurrent == m_pTail)
                return PushBack(i_Value);

            TListNode * pNode = new TListNode(i_Value);
            if(0 == pNode)
                return E_OUTOFMEMORY;
            pNode->InsertAfter(*m_pCurrent);
        }
		m_cSize++;
        return S_OK;
    }
    HRESULT InsertBeforeCurrent(T i_Value)
    {
        if(0 == m_pHead || 0 == m_pCurrent)//if empty or we're pointing at the 0th item then PushFront
            return PushFront(i_Value);
        return S_OK;
    }
    T PopFront()
    {
        ASSERT(!IsEmpty());//The calling routine is responsible for keeping track of whether the list is empty before calling this (since there's no error handling)

        T rtn = m_pHead->m_Value;
        if(m_pHead->m_pNext)//if this is not the only one in the list
        {
            m_pHead = m_pHead->m_pNext;//Make the next one the head.
            delete m_pHead->m_pPrev;//delete the previous head
            if(m_pCurrent == m_pHead->m_pPrev)
                m_pCurrent = 0;
            m_pHead->m_pPrev = 0;//and make sure the new head points back to NULL
        }
        else
        {
            delete m_pHead;
            m_pHead     = 0;
            m_pTail     = 0;
            m_pCurrent  = 0;
        }
		m_cSize--;

        return rtn;
    }
    HRESULT PushBack(T i_Value)
    {
        if(0 == m_pTail)
        {   //if the list is empty then Push_Back is the same as Push_Front
            ASSERT(0 == m_pHead);
            return PushFront(i_Value);
        }
        else
        {
            ASSERT(0 == m_pTail->m_pNext);
            TListNode * pNode = new TListNode(i_Value);
            if(0 == pNode)
                return E_OUTOFMEMORY;
            pNode->InsertAfter(*m_pTail);
            m_pTail = pNode;//This is the new tail
        }
		m_cSize++;
        return S_OK;
    }
    HRESULT PushFront(T i_Value)
    {
        TListNode * pNode = new TListNode(i_Value);
        if(0 == pNode)
            return E_OUTOFMEMORY;

        if(0 == m_pHead)
        {
            ASSERT(0 == m_pTail);
            m_pCurrent  = 0;
            m_pHead     = pNode;
            m_pTail     = pNode;
        }
        else
        {
            ASSERT(0 == m_pHead->m_pPrev);
            pNode->InsertBefore(*m_pHead);
            m_pHead = pNode;//This is the new head
        }
		m_cSize++;

        return S_OK;
    }

private:
    class TListNode
    {
    public:
        TListNode(T i_Value) : m_Value(i_Value), m_pNext(0), m_pPrev(0){}
        ~TListNode()
        {
            if(m_pPrev)//Remove us from the list
                m_pPrev->m_pNext = m_pNext;
            if(m_pNext)
                m_pNext->m_pPrev = m_pPrev;
        }
        void InsertAfter(TListNode &i_Node)
        {
            m_pNext = i_Node.m_pNext;
            m_pPrev = &i_Node;

            i_Node.m_pNext = this;
        }
        void InsertBefore(TListNode &i_Node)
        {
            m_pPrev = i_Node.m_pPrev;
            m_pNext = &i_Node;

            i_Node.m_pPrev = this;
        }
        T           m_Value;
        TListNode * m_pNext;
        TListNode * m_pPrev;
    };

    TListNode * m_pCurrent;//This actually points to the item before the current and 0 is reserved to indicate the beginning of the list.
    TListNode * m_pHead;
    TListNode * m_pTail;
	ULONG       m_cSize;
};

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\tmsxmlbase.h ===
#ifndef __TMSXMLBASE_H__
#define __TMSXMLBASE_H__

#ifndef __ATLBASE_H__
    #include <atlbase.h>
#endif
#ifndef _CATALOGMACROS
    #include "catmacros.h"
#endif

#ifndef INITPRIVATEGUID
#define DEFINE_PRIVATEGUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#else

#define DEFINE_PRIVATEGUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#endif // INITGUID

DEFINE_PRIVATEGUID (_CLSID_DOMDocument,    0x2933BF90, 0x7B36, 0x11d2, 0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60);
DEFINE_PRIVATEGUID (_IID_IXMLDOMDocument,  0x2933BF81, 0x7B36, 0x11d2, 0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60);
DEFINE_PRIVATEGUID (_IID_IXMLDOMElement,   0x2933BF86, 0x7B36, 0x11d2, 0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60);

class TMSXMLBase
{
public:
    TMSXMLBase()  {}
    ~TMSXMLBase();

protected:
    //protected methods
    virtual HRESULT  CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const;
};

#endif // __TMSXMLBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\tableschema.h ===
//  Copyright (C) 2000 Microsoft Corporation.  All rights reserved.
//  Filename:       TableSchema.h
//  Author:         Stephenr
//  Date Created:   1/27/00
//  Description:    Table Schema contains all the information needed to access a table.  This
//                  includes CollectionMeta, PropertyMeta, TagMeta, Wiring etc.  Several meta
//                  tables are NOT needed for the core requirement of describing a table.
//                  These include DatabaseMeta, RelationMeta, QueryMeta, and hash tables.
//
//                  It is important to cram all of this information together to reduce the
//                  working set.  TableSchema attempts to place all of the table schema into
//                  a single page (assuming 4096 bytes).  If possible, two or more tables
//                  should fit into a single page.
//
//                  In addition to the core meta information, the string values for the meta
//                  are stored within the TableSchema.  This combined with the variable number
//                  wiring entries, and ColumnMeta rows make TableSchema a variable sized
//                  structure.
//
//                  The tables' rows are represented by a series of ULONGs.  Each ULONG repre-
//                  sents a column.  The ColumnMeta (or PropertyMeta) identifies the type of
//                  each column.  UI4s are stored directly in the ULONG.  All other types are
//                  stored in the TableSchemaHeap.  The heap is ULONG_PTR alligned (32 bit
//                  alligned on 32 bit platform / 64 bit alligned on a 64 bit platform).
//
//                  The TableSchema structure lends itself to a compact binary file format.
//                  This may become the file format for describing extensible schema.
//
//                  Indexes are byte offset from the beginning of the TableSchema.  These indexes
//                  include: iFixedTableRows, iTagMeta, iServerWiring, iClientWiring, iHeap

#ifndef __TABLESCHEMA_H__
#define __TABLESCHEMA_H__

#ifndef __HASH_H__
    #include "Hash.h"
#endif
#ifndef __METATABLESTRUCTS_H__
    #include "MetaTableStructs.h"
#endif


#ifndef ASSERT
#define ASSERT(x)
#endif
//This generates a TableID whose upper 24 bits are unique (this has to be confirmed by some routine at meta compilation time).
inline ULONG TableIDFromTableName(LPCWSTR TableName)
{
    ULONG TableID = ::Hash(TableName);
    return (TableID<<8) ^ ((TableID & 0xFF000000)>>1);//This yield a slightly lower collision rate than just bit shifting alone.
}

namespace TableSchema
{
#define INDEX           //INDEX is a column that is NOT UI4 and thus is an index into a heap (iHeap is the index to the heap from the beginning of the TableSchema)


struct CollectionMetaPrivate
{
    ULONG               CountOfTags;            //UI4
    ULONG               nTableID;               //We may make this public
    ULONG INDEX         iFixedTableRows;        //Index into the Heap (from the beginning of the heap) Fixed Table (We will put the fixed data immediately following the meta.  This way, for small tables, only one page will be faulted in.)
    ULONG               cFixedTableRows;        //Count of Rows in the Fixed Table.
    ULONG INDEX         iIndexMeta;             //Index into aIndexMeta
    ULONG               cIndexMeta;             //The number of IndexMeta entries in this table
    ULONG INDEX         iHashTableHeader;       //If the table is a fixed table, then it will have a hash table for accessing rows by primarykey(s) (ie GetRowByIdentity) Note, accessing the Fixed data may not cause a page fault; but GetRowByIdentity will since it accesses the HashTable.  For now the hash table exists in a separate heap.
    ULONG INDEX         iTagMeta;               //ULONG  offset (NOT byte offset) from the beginning of the TableSchemaHeader
    ULONG INDEX         iServerWiring;          //ULONG  offset (NOT byte offset) from the beginning of the TableSchemaHeader
    ULONG               cServerWiring;          //Count of interceptors in ServerWiring
    ULONG INDEX         iHeap;                  //ULONG  offset (NOT byte offset) from the beginning of the TableSchemaHeader
    ULONG               cbHeap;                 //Count of BYTES in the heap.  This number MUST be divisible by sizeof(int) since everything gets alligned
};
const kciCollectionMetaPrivateColumns = sizeof(CollectionMetaPrivate)/sizeof(ULONG);

struct CollectionMeta : public TableMetaPublic, public CollectionMetaPrivate{};
const kciCollectionMetaColumns = sizeof(CollectionMeta)/sizeof(ULONG);



struct PropertyMetaPrivate
{
    ULONG               CountOfTags;            //Count of Tags - Only valid for UI4s
    ULONG INDEX         iTagMeta;               //Index into aTagMeta - Only valid for UI4s
    ULONG INDEX         iIndexName;             //IndexName of a single column index (for this column)
};
const unsigned long kciPropertyMetaPrivateColumns = sizeof(PropertyMetaPrivate)/sizeof(ULONG);

struct PropertyMeta : public ColumnMetaPublic, public PropertyMetaPrivate{};
const unsigned long kciPropertyMetaColumns = sizeof(PropertyMeta)/sizeof(ULONG);



const unsigned long kciTagMetaPrivateColumns = 0;
typedef TagMetaPublic TagMeta;
const unsigned long kciTagMetaColumns = sizeof(TagMeta)/sizeof(ULONG);



const unsigned long kciServerWiringMetaPrivateColumns = 0;
typedef ServerWiringMetaPublic ServerWiringMeta;
const unsigned long kciServerWiringMetaColumns = sizeof(ServerWiringMeta)/sizeof(ULONG);






//All hash tables begin with a HashTableHeader that indicates the Modulo and the total size of the HashTable (in number of HashIndexes that follow
//the HashTableHeader).  The size should be equal to Modulo if there are NO HashIndex collisions.  If there are NO HashIndex collisions, then all
//of the HashedIndex.iNext members should be 0.  If there are collisions, all iNext values should be greater than or equal to Modulo.
struct HashedIndex
{
public:
    HashedIndex() : iNext(-1), iOffset(-1){}

    ULONG       iNext;  //If the hash value is not unique then this points to the next HashedIndex with the same hash value
    ULONG       iOffset;//Index offset into some heap (defined by the hash table itself)
};

class HashTableHeader
{
public:
    ULONG       Modulo;
    ULONG       Size;//This is the size in number of HashedIndexes that follow the HashTableHeader

    const HashedIndex * Get_HashedIndex(ULONG iHash) const
    {
        return (reinterpret_cast<const HashedIndex *>(this) + 1 + iHash%Modulo);
    }
    const HashedIndex * Get_NextHashedIndex(const HashedIndex *pHI) const
    {
        ASSERT(pHI->iNext >= Modulo);
        if(-1 == pHI->iNext)
            return 0;
        else
            return (reinterpret_cast<const HashedIndex *>(this) + 1 + pHI->iNext);
    }

private:
    HashTableHeader(){}//We never construct one of these.  We always cast from some pointer.
};

//The TableSchemaHeap is layed out as follows, the fixed length data comes first
/*
    ULONG           TableSchemaHeapSignature0
    ULONG           TableSchemaHeapSignature1
    ULONG           CountOfTables                       This is interesting only when no query is supplied and we want to walk through every table (this won't be efficient)
    ULONG           TableSchemaRowIndex                 This is the byte offset just beyond the last TableSchema entry.
    ULONG           EndOfHeap                           This is the byte offset just beyond the heap.  All indexes should be less than this
    ULONG           iSimpleColumnMetaHeap               This is described below
    ULONG           Reserved2
    ULONG           Reserved3
    HashTableHeader TableNameHashHeader                 This is the hash table that map a TableID to its aTableSchema byte offset (from the beginning of TableSchemaHeap)
    HashedIndex     aHashedIndex[507]                   The HashTableHeader contains the modulo (503 is the largest prime number less than the hash table size) for the hash table; but the table can never grow beyond this pre-allocated space.
                                                        This size was chosen so that the entire hash table would fit into the same page in memory.
---------------------------<Page Boundary>---------------------------
    unsigned char   aTableSchema[]                      This is where each Table's TableSchema goes.  FirstTableID (4096) == &aTableSchema[0] - &TableSchemaHeap, LastTableID == &aTableSchema[CountOfTables-1] - &TableSchemaHeap
    ULONG           aTableSchemaRowIndex[CountOfTables] This is used to walk ALL of the tables.  Presumably, someone will get all the CollectionMeta and iterate through all of them

---------------------------<SimpleColumnMetaHeap>---------------------
    ULONG           iCollectionMeta                     ULONG index from the beginning of the TableSchemaHeap
    ULONG           cCollectionMeta                     count of SimpleColumnMetas there are for CollectionMeta
    ULONG           iPropertyMeta
    ULONG           cPropertyMeta
    ULONG           iServerWiringMeta
    ULONG           cServerWiringMeta
    ULONG           iTagMeta
    ULONG           cTagMeta
    SimpleColumnMeta aSimpleColumnMeta[cCollectionMeta]
    SimpleColumnMeta aSimpleColumnMeta[cPropertyMeta]
    SimpleColumnMeta aSimpleColumnMeta[cServerWiringMeta]
    SimpleColumnMeta aSimpleColumnMeta[cTagMeta]

One optimization we could do is to make sure that every table's schema (whose size is <=4096) fits into one page.  In other words, minimize TableSchema crossing a page boundary
*/
const ULONG kMaxHashTableSize         = 507;
const ULONG TableSchemaHeapSignature0 = 0x2145e0aa;
const ULONG TableSchemaHeapSignature1 = 0xe0a8212b;

class TableSchemaHeap
{
public:
    enum TableEnum //These are the offsets to the indexes
    {
        eCollectionMeta   = 0,
        ePropertyMeta     = 2,
        eServerWiringMeta = 4,
        eTagMeta          = 6
    };

    ULONG                   Get_TableSchemaHeapSignature0()     const {return *reinterpret_cast<const ULONG *>(this);}
    ULONG                   Get_TableSchemaHeapSignature1()     const {return *(reinterpret_cast<const ULONG *>(this) + 1);}
    ULONG                   Get_CountOfTables()                 const {return *(reinterpret_cast<const ULONG *>(this) + 2);}
    ULONG                   Get_TableSchemaRowIndex()           const {return *(reinterpret_cast<const ULONG *>(this) + 3);}
    ULONG                   Get_EndOfaTableSchema()             const {return Get_TableSchemaRowIndex();}
    ULONG                   Get_EndOfHeap()                     const {return *(reinterpret_cast<const ULONG *>(this) + 4);}
    ULONG                   Get_iSimpleColumnMeta()             const {return *(reinterpret_cast<const ULONG *>(this) + 5);}
    ULONG                   Get_Reserved0()                     const {return *(reinterpret_cast<const ULONG *>(this) + 6);}
    ULONG                   Get_Reserved1()                     const {return *(reinterpret_cast<const ULONG *>(this) + 7);}
    const HashTableHeader & Get_TableNameHashHeader()           const {return *reinterpret_cast<const HashTableHeader *>(reinterpret_cast<const ULONG *>(this) + 8);}
    const HashedIndex     * Get_aHashedIndex()                  const {return reinterpret_cast<const HashedIndex *>(reinterpret_cast<const ULONG *>(this) + 8 + sizeof(HashTableHeader));}
    const ULONG           * Get_aTableSchemaRowIndex()          const {return reinterpret_cast<const ULONG *>(reinterpret_cast<const unsigned char *>(this) + Get_TableSchemaRowIndex());}
    const SimpleColumnMeta* Get_aSimpleColumnMeta(TableEnum e)  const
    {
        const ULONG * pSimpleColumnMetaHeap = reinterpret_cast<const ULONG *>(reinterpret_cast<const unsigned char *>(this) + Get_iSimpleColumnMeta());
        ULONG iSimpleColumnMeta = pSimpleColumnMetaHeap[e];
        return reinterpret_cast<const SimpleColumnMeta *>(pSimpleColumnMetaHeap+iSimpleColumnMeta);
    }

    const unsigned char   * Get_TableSchema(LPCWSTR TableName) const;
    const unsigned char   * Get_TableSchema(ULONG TableID) const;
    LPCWSTR                 Get_TableName(ULONG TableID) const;
private:
    TableSchemaHeap(){}//We never construct one of these.  We always cast from some pointer.
};

class TTableSchema
{
public:
    TTableSchema() : m_pCollectionMeta(0), m_pHeap(0), m_pPropertyMeta(0), m_pServerWiring(0), m_pTableDataHeap(0), m_pTagMeta(0){}
    HRESULT Init(const unsigned char *pTableSchema);

    const CollectionMeta      * GetCollectionMeta() const
    {
        ASSERT(0 != m_pCollectionMeta);
        return m_pCollectionMeta;
    }

    const PropertyMeta        * GetPropertyMeta(ULONG iOrder) const
    {
        ASSERT(0 != m_pCollectionMeta);
        ASSERT(iOrder<m_pCollectionMeta->CountOfProperties || 0==m_pCollectionMeta->CountOfProperties);
        return m_pPropertyMeta+iOrder;
    }

    const ServerWiringMeta    * GetServerWiringMeta() const
    {
        ASSERT(0 != m_pCollectionMeta);
        return m_pServerWiring;
    }

    //This GetTagMeta gets the first TagMeta in the table
    //Note: This will return NULL if there are no tags in the table.
    const TagMeta             * GetTagMeta() const
    {
        ASSERT(0 != m_pCollectionMeta);
        return m_pTagMeta;
    }

    //This GetTagMeta gets the first TagMeta for a given Property
    const TagMeta             * GetTagMeta(ULONG iOrder) const
    {
        ASSERT(0 != m_pCollectionMeta);
        if(-1 == iOrder)//This is reserved to mean the same as GetTagMeta for the whole table
            return GetTagMeta();

        ASSERT(iOrder<m_pCollectionMeta->CountOfProperties || 0==m_pCollectionMeta->CountOfProperties);
        return reinterpret_cast<const TagMeta *>(reinterpret_cast<const unsigned char *>(m_pCollectionMeta) + m_pPropertyMeta[iOrder].iTagMeta);
    }

    const unsigned char       * GetPointerFromIndex(ULONG index) const
    {
        ASSERT(0 != m_pCollectionMeta);
        return (0 == index ? 0 : m_pHeap + index);
    }

    const WCHAR               * GetWCharPointerFromIndex(ULONG index) const
    {
        ASSERT(0 != m_pCollectionMeta);
        return (0 == index ? 0 : reinterpret_cast<const WCHAR *>(m_pHeap + index));
    }

    const GUID                * GetGuidPointerFromIndex(ULONG index) const
    {
        ASSERT(0 != m_pCollectionMeta);
        return (0 == index ? 0 : reinterpret_cast<const GUID *>(m_pHeap + index));
    }

    ULONG                       GetPointerSizeFromIndex(ULONG index) const
    {
        return (0==index ? 0 : *(reinterpret_cast<const ULONG *>(GetPointerFromIndex(index)) - 1));
    }
    ULONG                       GetPooledHeapPointerSize(const unsigned char *p) const;

private:
    const CollectionMeta      * m_pCollectionMeta;
    const PropertyMeta        * m_pPropertyMeta;
    const TagMeta             * m_pTagMeta;
    const ServerWiringMeta    * m_pServerWiring;
    const unsigned char       * m_pHeap;
    const ULONG               * m_pTableDataHeap;
};

}//end of namespace

const ULONG  kTableSchemaSignature0 = 0xe0222093;
const ULONG  kTableSchemaSignature1 = 0x208ee01b;
typedef HRESULT( __stdcall *GETTABLESCHEMAHEAPSIGNATURES)(ULONG *signature0, ULONG *signature1, ULONG *cbTableSchemaHeap);


#endif //__TABLESCHEMA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\unicode.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// unicode.h
//
// Header file that forcibly turns on a unicode compile
//

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#undef MBCS
#undef _MBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\tslist.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.

#pragma once
#ifndef	__TSLIST__H__
#define __TSLIST__H__
#include "utsem.h"
#include "cmpxchg.h"

class ListRoot
{
public:
	union {
		__int64  i64;  // ensure 8-byte alignment
		struct Element {
			void * pvFirst;			// ptr to user data of first free block;
			unsigned long ulFlag;		// flag word, see below.
		} m_element;
	};
	// default constructor:
	ListRoot() 
	{		
		m_element.pvFirst = NULL;
		m_element.ulFlag = 0;
	}

	// conversions to/from __int64:
	ListRoot(__int64 n) { i64 = n;}
	operator __int64() { return i64;}


};



class StackNode
{
public:
	void * pNext;
	void * data;
	StackNode (){pNext = NULL; data = NULL;}
	StackNode (void * pd, void * pn)
	{
		data = pd;
		pNext = pn;
	}
};



//
//	a class that allocates Nodes off of a stack
//
//	useful if you have a LOT of nodes in your stack
//	and you don't want to allocate/free them with the default allocator.
//	
//	you might wonder why we bother, instead of just using vipMalloc -- 
//	the answer is that we are 14X (1,400 %) faster than VipMalloc.
//
class CNodeStackAllocator
{

private:
	static CInterlockedCompareExchange * sm_pInterlockedExchange64; 
	static volatile ListRoot sm_list;   	

public:
	
	static void PutNode(StackNode * pNode)
	{
		
		ListRoot ListComp;
		ListRoot ListExch;
		for (;;) // make it thread safe
		{
			ListComp.m_element.pvFirst = sm_list.m_element.pvFirst;
			ListComp.m_element.ulFlag  = sm_list.m_element.ulFlag;           			
            pNode -> data = (void *)NULL;
			pNode -> pNext = (void *)ListComp.m_element.pvFirst;
			ListExch.m_element.pvFirst = pNode;
			ListExch.m_element.ulFlag = ListComp.m_element.ulFlag + 1;
			if (ListComp == sm_pInterlockedExchange64 -> InterlockedCompareExchange64  ((volatile __int64*) &sm_list, (__int64) ListExch, (__int64) ListComp))
			{				
				return;

			}
		}
	}

	static StackNode * GetNode()
	{
		StackNode * pNode = NULL;
		ListRoot ListComp;
		ListRoot ListExch;
		for (;;)
		{
			ListComp.m_element.pvFirst = sm_list.m_element.pvFirst;
			ListComp.m_element.ulFlag  = sm_list.m_element.ulFlag;
			pNode = (StackNode *)ListComp.m_element.pvFirst;
			if (pNode == NULL) // stack empty
			{
				return new (SAFE) StackNode;
			}
			
			ListExch.m_element.pvFirst = pNode -> pNext;
			ListExch.m_element.ulFlag = ListComp.m_element.ulFlag + 1;
			if (ListComp == sm_pInterlockedExchange64 -> InterlockedCompareExchange64  ((volatile __int64*) &sm_list, (__int64) ListExch, (__int64) ListComp))
			{
				return  pNode;   				
			}
		
		}
	}
	

};

class CStack
{
protected:
	
	volatile ListRoot m_list;   
	CInterlockedCompareExchange * m_pInterlockedExchange64;


public:
	CStack()
	{
		m_pInterlockedExchange64 = GetSafeInterlockedExchange64();
	}
	
	~CStack()
	{
		delete m_pInterlockedExchange64;		
	}


	void push(void * pv);	
	void * pop();
	

	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\txmldocument.h ===
//  File:           TXmlDocument.h
//
//  Description:    Here are a set of classes that deal with Xml files.  None
//                  of the classes throws exceptions.  All errors are returned
//                  as HRESULTS.  All error values a listed below.
//
//                  These classes do a minimum of copying of data.  When
//                  reading the file, a view of it is mapped into memory.  Then
//                  all elements and attributes reference directly into the
//                  mapping.  So element and attribute names are NOT null
//                  terminated.  This is kind of a hassle for the user but
//                  it eliminate the need for copies.
//
//                  When the Value is updated, a copy IS made.  This way the
//                  Xml SimpleTable implementer is not obligated to keep the
//                  (often) temporary string variable around until the Save.
//
//  Author:         Stephen Rakonza (stephenr x63199)
//
//  Date / Change:  9-15-1999   /   Created
//

#ifndef __TXMLDOCUMENT_H__
#define __TXMLDOCUMENT_H__

#ifndef __SMARTPOINTER_H__
#include "SmartPointer.h"
#endif
#ifndef __TLIST_H__
#include "TList.h"
#endif


class TXmlAttribute;
class TXmlDocument;
class TXmlElement;
class TXmlElementList;
class TXmlNode;

#ifndef ASSERT
    #define ASSERT(x)
#endif

//Error codes
//E_OUTOFMEMORY
#define E_NODENOTFOUND          0x80000001
#define E_ERROR_PARSING_XML     0x80000002
#define E_ATTRIBUTE_NOT_FOUND   0x80000003
#define E_ERROR_OPENING_FILE    0x80000004


//  TFileMapping
//  
//  This class is the base class for Attributes and Elements.
class TFileMapping
{
public:
    TFileMapping() : m_hFile(0), m_hMapping(0), m_pMapping(0), m_Size(0) {}
    ~TFileMapping()
    {
        if(m_pMapping)
        {
            if(0 == FlushViewOfFile(m_pMapping,0))
            {
                ASSERT(false && "ERROR - UNABLE TO FLUSH TO DISK");
            }
            UnmapViewOfFile(m_pMapping);
        }
        if(m_hMapping)
            CloseHandle(m_hMapping);
        if(m_hFile)
            CloseHandle(m_hFile);
    }
    HRESULT Load(LPCTSTR filename, bool bReadWrite = false)
    {   //We don't do any error checking because the API functions should deal with NULL hFile & hMapping.  Use should check
        //m_pMapping (via Mapping()) before using the object.
        m_hFile = CreateFile(filename, GENERIC_READ | (bReadWrite ? GENERIC_WRITE : 0), 0, NULL, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
        m_hMapping = CreateFileMapping(m_hFile, NULL, (bReadWrite ? PAGE_READWRITE : PAGE_READONLY), 0, 0, NULL);
        m_pMapping = reinterpret_cast<char *>(MapViewOfFile(m_hMapping, (bReadWrite ? FILE_MAP_WRITE : FILE_MAP_READ), 0, 0, 0));
        m_Size = GetFileSize(m_hFile, 0);
        return (0 == m_pMapping) ? E_ERROR_OPENING_FILE : S_OK;
    }
    unsigned long   Size() const {return m_Size;}
    char *          Mapping() const {return m_pMapping;}
    char *          EOF() const {return (m_pMapping + m_Size);}

private:
    HANDLE          m_hFile;
    HANDLE          m_hMapping;
    char *          m_pMapping;
    unsigned long   m_Size;
};


//  TXmlNode
//  
//  This class is the base class for Attributes and Elements.
class TXmlNode
{
public:
    TXmlNode();
    virtual ~TXmlNode();

    
    void GetName(LPCSTR &o_pNodeName, size_t &o_cStringLengthName)  const;//Length is returned because pNodeName is NOT necessarily NULL terminated.
    void GetValue(LPCSTR &o_pNodeValue, size_t &o_cStringLengthValue) const;//Length is returned because pNodeName is NOT necessarily NULL terminated.

    //The name is stored as a pointer only.  This is because the Xml SimpleTable presumably
    //gets the Meta and stores the element and attribute names as memeber variables.  So they
    //should be around for the life time of the XmlDocument object.
    void SetValue(LPCSTR i_szNodeValue);         //This one makes a copy of the data
public:
    enum Change
    {
        eUnchanged,
        eModify,
        eInsert,
        eRemove
    };
    Change                      m_change;
    size_t                      m_cStringLengthName;
    size_t                      m_cStringLengthValue;
    TFileMapping *              m_pMap;             //Pointer to the whole document.  Needed for checking begin and end of file.  If 0 then Node is not attached to a Doc.
    LPCSTR                      m_pNodeName;        //Here we store the pointer directly
    LPCSTR                      m_pNodeValue;       //Here we store the pointer directly
    LPCSTR                      m_szUpdatedName;    //Here's where we store the updated name pointer
    TSmartPointerArray<char>    m_szUpdatedValue;   //Here's where we store a copy of the updated value

    LPCSTR  AdvancePastWhitespaces(LPCSTR i_pString);
    void SetName(LPCSTR i_szNodeName);           //This stores the pointer and does NOT make a copy of the string
    void SetName(LPCSTR i_pNodeName, LPCSTR i_szStringEndToken);//Use this one if you want SetName to search for then end token to determine
                                                    //the length of the name.
    void SetValue(LPCSTR i_pNodeValue, LPCSTR i_szStringEndToken);
};


//  TXmlAttribute
//
//  This class represents a singe Attribute
class TXmlAttribute : public TXmlNode
{
public:
    TXmlAttribute() : m_bSingleQuotes(false){}

    bool    IsUsingSingleQuote() const {return m_bSingleQuotes;}
    void    UseSingleQuote(bool bSingeQuote=true){m_bSingleQuotes = bSingeQuote;}

//XmlDocument methods
public:
    TXmlAttribute(LPCSTR i_pLeadingSpace, TFileMapping &i_pMap) : m_bSingleQuotes(false){}
    HRESULT Init(LPCSTR i_pLeadingSpace, TFileMapping *i_pMap);

    bool    m_bSingleQuotes;    //false indicates double quotes

    //Whitespace management
    LPCSTR  m_pNodeBeginning;   //This is a pointer to where the node starts (this is the first whitespace following the element name or preceeding attribute.
    LPCSTR  m_pNodeEnd;         //This is a pointer to where the node ends (pointer just past the quote)  If the node is marked as Changed, then this is the
                                //range of bytes that is replaced.
};


//  TXmlElement
//
//  This class represents a singe Element
class TXmlElement : public TXmlNode
{

//Consumer methods
public:
    //Attribute Methods
    HRESULT GetAttributeValue(LPCSTR i_szName, LPCSTR &o_pValue, size_t &o_StringLength);
    HRESULT SetAttributeValue(LPCSTR i_szName, LPCSTR i_szValue);

    //Child Element Methods
    HRESULT GetChildList(TList<TXmlElement *> *&o_XmlElementList);
    HRESULT InsertAsLastChild(TXmlElement &i_XmlElement);

    //This Element Methods
    void SetValue(LPCSTR i_szValue);     //This sets the bEndingTag flag and calls the base class

//XmlDocument methods
public:
    TXmlElement();
    TXmlElement(LPCSTR i_pOpenBracket);
    HRESULT Init(LPCSTR i_pOpenBracket, TFileMapping *i_pMap);

private:
    TList<TXmlAttribute *>  m_AttributeList;    //This is filled in when the first Attribute method is called
    bool                    m_bAttributeListInited;
    bool                    m_bChildListInited;
    bool                    m_bEndingTag;       //This is set at ctor time.  Or it can be set to true at SetValue or InsertAsLastChild time.
    TList<TXmlElement *>    m_ChildList;        //This is filled in when the first Child Element method is called.
    //Whitespace management
    LPCSTR                  m_pNodeBeginning;   //This is a pointer to where the node starts (the first white space following the previous nodes' '>')
    LPCSTR                  m_pNodeEnd;         //This is a pointer to where the node ends (pointer just past the '>')  If the node is marked as Changed,
                                                //then this is the range of bytes that is replaced.

    TXmlAttribute *         GetAttribute(LPCSTR i_pName, size_t i_cbName);
    HRESULT                 PopulateAttributeList();
};


//Handling TXmlElement pointer - In order to reduce the number of copies, the consumer of pointer should delete the
//pointer UNLESS changes are made.  If changes are made to an XmlElement, it goes into the write cache and will be
//cleaned up either at Save time or upon deletion of the XmlDocument.
class TXmlDocument
{
public:
    TXmlDocument() {}
    ~TXmlDocument() {}

    HRESULT CreateElement(LPCSTR i_szElementName, TXmlElement *&o_pElement);//Creates a new element but does NOT put it into the XmlDocument
    //GetElement is designed specifically to get a Table element from an XML file.  It scans from the beginning of the document
    //in search of the tag name.  If there is more than one element of this name, only the first one will be acknowledged.
    HRESULT DeleteElement(TXmlElement &i_pElement);//Removes the element
    HRESULT GetElementList(LPCSTR i_szElementName, TList<TXmlElement *> *&o_pElementList);//Find the first matching element.  Fails if the element is not found.
    void    ReleaseElementList(TList<TXmlElement *> * &i_pElementList);//Element is no longer used by the consumer.  If no changes have been made to the Element
                                                    //it will be deleted.

    HRESULT Load(LPCWSTR i_wszXMLFileName, bool bReadWrite=false);//Maps the file into memory
    HRESULT Parse(bool i_bValidate=false);//Check the file for well formity and validates against XML Schema if bValidate is true
    HRESULT Save();//Saves the xml file with all of the updates
private:
    TFileMapping    m_FileMapping;
};

#endif // __TXMLDOCUMENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\txmlparsedfile.h ===
#ifndef __TXMLPARSEDFILE_H__
#define __TXMLPARSEDFILE_H__

#ifndef _OBJBASE_H_
    #include <objbase.h>
#endif
#ifndef __ATLBASE_H__
    #include <atlbase.h>
#endif
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif
#ifndef __xmlparser_h__
    #include "xmlparser.h"
#endif
#ifndef __TFILEMAPPING_H__
    #include "TFileMapping.h"
#endif
#ifndef _UNKNOWN_HXX
    #include "unknown.hxx"
#endif
#ifndef __HASH_H__
    #include "Hash.h"
#endif
#ifndef __catalog_h__
    #include "catalog.h"
#endif

#include "safecs.h"

typedef VOID (__stdcall * INTERLOCKEDEXCHANGEADD)(PLONG, LONG);

//These classes are used to cache any XML files that have already been parsed.
struct TAttribute
{
    TAttribute() : m_NameLength(0), m_Name(0), m_ValueLength(0), m_Value(0){}
    DWORD   m_NameLength;
    LPCWSTR m_Name;
    DWORD   m_ValueLength;
    LPCWSTR m_Value;
};

enum XmlNodeFlags
{
    fNone           = 0x00,
    fBeginTag       = 0x01,
    fEndTag         = 0x02,
    fBeginEndTag    = 0x03,
};

struct TElement
{
    TElement() : m_LevelOfElement(0), m_ElementNameLength(0), m_ElementName(0), m_NumberOfAttributes(0), m_ElementType(XML_ELEMENT){}
    DWORD           m_LevelOfElement;
    union
    {
        DWORD           m_ElementNameLength;
        DWORD           m_cchElementValue;
        DWORD           m_cchComment;
        DWORD           m_cchWhiteSpace;
    };
    union
    {
        LPCWSTR         m_ElementName;
        LPCWSTR         m_ElementValue;
        LPCWSTR         m_Comment;
        LPCWSTR         m_WhiteSpace;
    };
    DWORD           m_NodeFlags;//OR of any of the XmlNodeFlags flags
    DWORD           m_NumberOfAttributes;//This can be non zero for XML_ELEMENTs only
    XML_NODE_TYPE   m_ElementType;//only XML_ELEMENT(1), XML_PCDATA(13), XML_COMMENT(16) & XML_WHITESPACE(18) are supported
    TAttribute  m_aAttribute[1];

    TElement * Next() const {return const_cast<TElement *>(reinterpret_cast<const TElement *>(reinterpret_cast<const unsigned char *>(this + 1) + (static_cast<int>(m_NumberOfAttributes)-1) * sizeof(TAttribute)));}
    bool        IsValid() const {return (m_LevelOfElement>0 && m_ElementType>0);}
};


//This class is a callback interface.  It is passed into the TXmlParsedFile::Parse method.
class TXmlParsedFileNodeFactory
{
public:
    virtual HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const {return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);}
    virtual HRESULT CreateNode(const TElement &Element) = 0;
};


class TXmlParsedFileCache;


/*The data is layed out in the following structure:
[DWORD-Level of Element][DWORD-String Length of Element Name][LPCWSTR-Element Name][DWORD-Number Of Attributes][DWORD-Length of Attribute Name][LPCWSTR-Attribute Name][DWORD-Length of Attribute Value][LPCWSTR-Attribute Value]...[DWORD-Length of Attribute Name][LPCWSTR-Attribute Name][DWORD-Length of Attribute Value][LPCWSTR-Attribute Value]

The strings are NOT NULL terminated
The 'Number Of Attributes' DWORD allows for skipping over elements.
The structures above allow for easier access to the pool of TElements.
*/

class TXmlParsedFile : public _unknown<IXMLNodeFactory>, public TFileMapping
{
public:
    TXmlParsedFile();
    ~TXmlParsedFile();

    //If the file hasn't already been parsed, it calls into the CLSID_XMLParser, otherwise it just calls back TXmlParsedFileNodeFactory for
    //each element under the root (excluding the root element).  By putting the XmlParsedNodeFactory as a parameter we don't have to synchronize
    //call pairs like (SetFactory and Parse).
    virtual HRESULT         Parse(TXmlParsedFileNodeFactory &i_XmlParsedFileNodeFactory, LPCTSTR i_filename, bool bOnlyIfInCache=false);
    virtual HRESULT            Unload();

//This method is only called FROM the cache itself.
    void                    SetCache(TXmlParsedFileCache &cache){m_pCache = &cache;}//If NO cache is set then the object won't be cached.  You can remove it from the cache once added.
    DWORD                   GetLastParseTime() const {return m_dwTickCountOfLastParse;}
    bool                    IsCompletedParse() const {return !!m_ElementPool;}
    unsigned long           PoolSize() const {return m_cbElementPool + m_cbStringPool;}


//IXMLNodeFactory methods
private:
    HRESULT STDMETHODCALLTYPE BeginChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);

    HRESULT STDMETHODCALLTYPE CreateNode( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ PVOID pNodeParent,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

    HRESULT STDMETHODCALLTYPE EndChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ BOOL fEmptyNode,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);
    
    HRESULT STDMETHODCALLTYPE Error( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ HRESULT hrErrorCode,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

	HRESULT STDMETHODCALLTYPE NotifyEvent( 
			/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
			/* [in] */ XML_NODEFACTORY_EVENT iEvt);


//helper functions
private:
    LPCWSTR         AddStringToPool(LPCWSTR i_String, unsigned long i_Length);
    HRESULT         AllocateAndCopyElementList(unsigned long i_Length);
    void            AppendToLastStringInPool(LPCWSTR i_String, unsigned long i_Length);
    HRESULT         Load(LPCTSTR i_filename);
    VOID            MemberInterlockedExchangeAdd(PLONG Addend, LONG Increment);

//member variables
private:
    unsigned long                               m_cbElementPool;
    unsigned long                               m_cbStringPool;
    unsigned long                               m_cElements;                    //Count of elements in this XML file.
    CSafeAutoCriticalSection                    m_SACriticalSectionThis;        //While accessing this object, users should ask for the critical section and lock it.
    unsigned long                               m_CurrentLevelBelowRootElement; //This is used while MSXML parsing to keep track of the level below the root element (0 indicating root element level)
    unsigned long                               m_cWcharsInStringPool;          //This is the offset just beyond the last String in the pool.  This is where the next string would be added.
    TSmartPointerArray<unsigned char>           m_ElementPool;                  //We build the element pool into a growable buffer, then we know how big it needs to be and slam it into here.
    WCHAR                                       m_FileName[MAX_PATH];           //XML file name
    FILETIME                                    m_ftLastWriteTime;              //Remember the last time the file was written so we can deterime whether to reparse
    TElement           *                        m_pElement;                     //Reused.  While MSXML parsing it points into the GrowableBuffer, after calling AllocateAndCopyElementList it points to the allocated space
    TElement           *                        m_pLastBeginTagElement;
    TSmartPointerArray<WCHAR>                   m_StringPool;                   //To make sure we have enough pool space, we allocate the same size as the file.

    //These members are needed to make the TXmlParsedFile cache aware
    DWORD                                       m_dwTickCountOfLastParse;
    TXmlParsedFileCache *                       m_pCache;

//static member variables
private:
    static TSmartPointerArray<unsigned char>    m_aGrowableBuffer;              //This is a shared buffer used while MSXML parsing of the file.
    static CSafeAutoCriticalSection             m_SACriticalSectionStaticBuffers; //This is to guard the shared buffers.  This means only one XML file can be parsing via MSXML at once.
    static unsigned long                        m_SizeOfGrowableBuffer;         //Size of the Growable buffer.
    static int                                  m_OSSupportForInterLockedExchangeAdd;
    static INTERLOCKEDEXCHANGEADD               m_pfnInterLockedExchangeAdd;
    enum
    {
        Undetermined = -1,
        Supported    = 0,
        Unsupported  = 1
    };

};


class TXmlParsedFileCache
{

public:
    enum CacheSize
    {
        CacheSize_mini    = 3,
        CacheSize_small   = 97    ,
        CacheSize_medium  = 331   ,
        CacheSize_large   = 997
    };
    TXmlParsedFileCache() : m_cCacheEntry(CacheSize_mini), m_cbTotalCache(0){}

    void AgeOutCache(DWORD dwKeepAliveTime)
    {
        DWORD dwTimeToAgeOutCacheEntry = GetTickCount() - (dwKeepAliveTime ? dwKeepAliveTime : static_cast<DWORD>(kTimeToAgeOutCacheEntry));
        for(int iCacheEntry=0;iCacheEntry<m_cCacheEntry;++iCacheEntry)
        {
            if(m_aCacheEntry[iCacheEntry].GetLastParseTime() < dwTimeToAgeOutCacheEntry)
                m_aCacheEntry[iCacheEntry].Unload();
        }
    }
    TXmlParsedFile * GetXmlParsedFile(LPCWSTR filename)
    {
        ASSERT(IsInitialized());

        unsigned int iCache = Hash(filename) % m_cCacheEntry;
        m_aCacheEntry[iCache].SetCache(*this);//Each cache entry needs a pointer to the cache itself, if we don't call SetCache the TXmlParsedFile won't be considered part of the cache
        return (m_aCacheEntry + iCache);
    }
    HRESULT Initialize(CacheSize size=CacheSize_small)
    {
        if(IsInitialized())
            return S_OK;
        m_cCacheEntry = size;

        m_aCacheEntry = new TXmlParsedFile[m_cCacheEntry];
        if(!m_aCacheEntry)
            return E_OUTOFMEMORY;
        return S_OK;
    }
    bool IsInitialized() const {return !!m_aCacheEntry;}

    long                                m_cbTotalCache;//This is update by the TXmlParsedFile object when it does an MSXML parse (or an Unload).
private:
    enum
    {
        kTimeToAgeOutCacheEntry = 5*60*1000 //5 minutes
    };
    TSmartPointerArray<TXmlParsedFile>  m_aCacheEntry;
    CacheSize                           m_cCacheEntry;
};


class TXmlParsedFile_NoCache : public _unknown<IXMLNodeFactory>, public TFileMapping
{
public:
    TXmlParsedFile_NoCache();
    ~TXmlParsedFile_NoCache();

    virtual HRESULT         Parse(TXmlParsedFileNodeFactory &i_XmlParsedFileNodeFactory, LPCTSTR i_filename);

//IXMLNodeFactory methods
private:
    HRESULT STDMETHODCALLTYPE BeginChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);

    HRESULT STDMETHODCALLTYPE CreateNode( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ PVOID pNodeParent,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

    HRESULT STDMETHODCALLTYPE EndChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ BOOL fEmptyNode,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);
    
    HRESULT STDMETHODCALLTYPE Error( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ HRESULT hrErrorCode,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

	HRESULT STDMETHODCALLTYPE NotifyEvent( 
			/* [in] */ IXMLNodeSource __RPC_FAR *pSource,
			/* [in] */ XML_NODEFACTORY_EVENT iEvt);

//member variables
private:
    ULONG                                   m_CurrentLevelBelowRootElement;
    TElement                              * m_pElement;
    TXmlParsedFileNodeFactory             * m_pXmlParsedFileNodeFactory;
    TSmartPointerArray<unsigned char>       m_ScratchBuffer;
};

#endif //__TXMLPARSEDFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\utlist.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __UTLIST_H__
#define __UTLIST_H__
/******************************************************************************
Microsoft D.T.C. (Distributed Transaction Coordinator)


@doc

@module UTList.h  |

	Contains list ADT. 

@devnote None
-------------------------------------------------------------------------------
	@rev 1 | 12th Apr,95 | GaganC | Added StaticList & StaticListIterator	
	@rev 0 | 24th Jan,95 | GaganC | Created
*******************************************************************************/

#include "MTSExcept.h"

//---------- Forward Declarations -------------------------------------------
template <class T> class UTLink;
template <class T> class UTList;
template <class T> class UTListIterator;
template <class T> class UTStaticList;
template <class T> class UTStaticListIterator;

//-----**************************************************************-----
// @class template class
//		The UTIterator is an ABSTRACT BASE CLASS for ALL iterators. This
//		class defines the basic operation that all iterators must support
//		regardless of what type of collection it operates upon.
//
//-----**************************************************************-----
template <class T> class UTIterator
{
// @access Public members

public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// initialize iterator
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Initializes the iterator to the first position
	virtual BOOL	Init	(void) =0;

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// operators
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Retrieves the current element (pointed to by iterator)
	virtual T		operator()	(void) const =0;
	// @cmember Checks to see if iterator is in a valid position
	virtual BOOL	operator !	(void) const =0;
	// @cmember Moves the iterator forward
	virtual BOOL	operator ++ (int dummy) =0;
	// @cmember Assigns the current element a new value
	virtual void	operator =	(T	newValue) =0;
};

//-----**************************************************************-----
// @class Template class
//		The UTLink class is the backbone of a linked list. It holds the
//		actual data of type T (which is the list's data type) and points
//		to the next and previous elements in the list.
//		The class is entirely private to hide all functions and data from
//		everyone but it's friends - which are the UTList and UTListIterator.
//
// @tcarg class | T | data type to store in the link
//-----**************************************************************-----
template <class T> class UTLink
{
// @access Public members
public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// constructors/destructor
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Constructor
	UTLink (void);
	// @cmember Constructor
	UTLink (const T& LinkValue,UTLink< T > * Prev = NULL,UTLink< T > * Next = NULL);
	// @cmember Copy Constructor
	UTLink (const UTLink< T >&	CopyLink);
	// @cmember Destructor
	virtual ~UTLink (void);

	void Init (const T& LinkValue,UTLink< T > * Prev = NULL,UTLink< T > * Next = NULL);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// operators
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Assignment operator
	virtual UTLink< T >& operator =	(const UTLink< T >&	AssignLink);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// action protocol
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Adds a new element before this object
	UTLink< T > * AddBefore	(const T& newValue);
	// @cmember Adds a new element after this object
	UTLink< T > * AddAfter	(const T& newValue);

	// @cmember Remove this link from the specified list
	void		RemoveFromList (UTStaticList < T > * pStaticList);

public:
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// friends
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	friend class UTList< T >;
	friend class UTStaticList < T >;
	friend class UTListIterator< T >;
	friend class UTStaticListIterator <T>;

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// data members
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Value held in the link of type T
	T				m_Value;
	// @cmember Pointer to next link (in list)
	UTLink< T > *	m_pNextLink;
	// @cmember Pointer to previous link (in list)
	UTLink< T > *	m_pPrevLink;
};

//-----**************************************************************-----
// @class Template class
//		The UTList class consists of a pointer to the first and last
//		links along with a count of the number of elements in the list.
//		The Add method simply appends to the end of the list.
//		To add elements to a specific location in the list other than
//		the first or last positions, use the UTListIterator methods.
//		To create an ordered list, a user could inherit from the UTList
//		class and override Add to add elements in the correct order.
//		Of course, you would want to do something about the other
//		methods of adding members to the list.
//
// @tcarg class | T | data type to store in the list
//-----**************************************************************-----

template <class T> class UTList
{
// @access Public members
public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// constructors/destructor
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Consructor
	UTList	(void);
	// @cmember Copy Constructor
	UTList	(const UTList< T >& CopyList);
	// @cmember Destructor
	virtual ~UTList (void);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// operators
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Assignment operator
	virtual UTList< T >&		operator =	(const UTList< T >& AssignList);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// action protocol
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Add new value to the list
	virtual void			Add			(const T& newValue);
	// @cmember Insert new value at the front of the list
	virtual void			InsertFirst (const T& newValue);
	// @cmember Insert new value at the end of the list
	virtual void			InsertLast	(const T& newValue);
	// @cmember Remove all elements from the list
	virtual void			RemoveAll	(void);
	// @cmember Remove first element from the list
	virtual BOOL			RemoveFirst (T* pType);
	// @cmember Remove last element from the list
	virtual BOOL			RemoveLast	(T* pType);
	// @cmember Duplicate contents of entire list
	virtual UTList< T > *	Duplicate	(void);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// state protocol
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Retrieve the first value via the out parameter
	virtual BOOL	FirstElement(T* pType) const;
	// @cmember Retrieve the last value via the out parameter
	virtual BOOL	LastElement (T* pType) const;
	// @cmember Does the list include this value?
	virtual BOOL	Includes	(const T& value);
	// @cmember Is the list empty?
	virtual BOOL	IsEmpty		(void) const;
	// @cmember Return the count of elements in the list
	virtual ULONG	GetCount	(void) const;

	virtual void	Init (void);
// @access Protected members
protected:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// friends
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	friend class UTListIterator< T >;

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// data members
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Count of elements in the list
	ULONG			m_ulCount;
	// @cmember Pointer to the first link in the list
	UTLink< T > *	m_pFirstLink;
	// @cmember Pointer to the last link in the list
	UTLink< T > *	m_pLastLink;
};

//-----**************************************************************-----
// @class Template class
//		The UTStaticList class. This is similar to the UTList class except 
//		that it in this the links are all static. Links are provided, to
//		the various methods, they are never created or destroyed as they
//		have been preallocated.
//
// @tcarg class | T | data type to store in the list
//-----**************************************************************-----
template <class T> class UTStaticList
{
// @access Public members
public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// constructors/destructor
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Consructor
	UTStaticList	(void);
	// @cmember Copy Constructor
//	UTStaticList	(const UTStaticList< T >& CopyList);
	// @cmember Destructor
	virtual ~UTStaticList (void);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// operators
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Assignment operator
//	virtual UTStaticList< T >&		operator =	(const UTStaticList< T >& AssignList);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// action protocol
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Add new link to the list
	virtual void			Add			(UTLink <T> * pLink);
	// @cmember Insert new link at the front of the list
	virtual void			InsertFirst (UTLink <T> * pLink);
	// @cmember Insert new link at the end of the list
	virtual void			InsertLast	(UTLink <T> * pLink);
	// @cmember Remove all elements from the list
	virtual void			RemoveAll	(void);
	// @cmember Remove first element from the list
	virtual BOOL			RemoveFirst (UTLink <T> ** ppLink);
	// @cmember Remove last element from the list
	virtual BOOL			RemoveLast	(UTLink <T> ** ppLink);
	// @cmember Duplicate contents of entire list
//	virtual UTStaticList< T > *	Duplicate	(void);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// state protocol
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Retrieve the first link via the out parameter
	virtual BOOL	FirstElement(UTLink <T> ** ppLink);
	// @cmember Retrieve the last link via the out parameter
	virtual BOOL	LastElement (UTLink <T> ** ppLink);
	// @cmember Does the list include this value?
//	virtual BOOL	Includes	(const UTLink <T> * pLink);
	// @cmember Is the list empty?
	virtual BOOL	IsEmpty		(void) const;
	// @cmember Return the count of elements in the list
	virtual ULONG	GetCount	(void) const;


	virtual void	Init (void);

// @access Protected members
public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// friends
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	friend class UTStaticListIterator <T>;

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// data members
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Count of elements in the list
	ULONG			m_ulCount;
	// @cmember Pointer to the first link in the list
	UTLink< T > *	m_pFirstLink;
	// @cmember Pointer to the last link in the list
	UTLink< T > *	m_pLastLink;
}; //End class UTStaticList





//-----**************************************************************-----
// @class Template class
//		The UTListIterator class implements the operations that an
//		iterator must support and includes some additional operations
//		that are useful in the context of a linked list.
//		Use AddBefore & AddAfter to add elements to a list based on the
//		iterator's current position within the list.
//
// @tcarg class | T | data type stored in list and type for iterator
// @base public | UTIterator
//-----**************************************************************-----
template <class T> class UTListIterator : public UTIterator< T >
{
// @access Public members
public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// constructors/destructor
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Constructor
	UTListIterator (UTList< T >&	List);
	// @cmember Copy constructor
	UTListIterator (const UTListIterator< T >&	CopyListItr);
	// @cmember Destructor
	virtual ~UTListIterator(void);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// iterator protocol
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Initialize the iterator to the first link in list
	virtual BOOL	Init		(void);
	// @cmember Retrieve the value from the current link
	virtual T		operator () (void) const;
	// @cmember Does the iterator point to a valid link
	virtual BOOL	operator !	(void) const;
	// @cmember Move the iterator to the next link
	virtual BOOL	operator ++ (int dummy);
	// @cmember Assign the current link a new value
	virtual void	operator =	(T newValue);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// additional protocol for list iterator
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Assignment operator
	virtual UTListIterator< T >& operator =	(const UTListIterator< T >& AssignListItr);
	// @cmember Move the iterator to the previous link
	virtual BOOL	operator --		(int dummy);
	// @cmember Remove the current link from the list
	virtual BOOL	RemoveCurrent	(T* pType);
	// @cmember Insert a new value before the iterator
	virtual void	InsertBefore	(const T& newValue);
	// @cmember Insert a new value after the iterator
	virtual void	InsertAfter		(const T& newValue);
	// @cmember Set the iterator at the first element of this value
	virtual BOOL	SetPosAt		(const T& value);

// @access Protected members
public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// data members
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Position of iterator in list
	UTLink< T > *	m_pCurrentLink;
	// @cmember One position before the current position
	UTLink< T > *	m_pPreviousLink;
	// @cmember List that is being iterated upon
	UTList< T >&		m_List;
};

//-----**************************************************************-----
// @class Template class
//		The UTStaticListIterator class implements the operations that an
//		iterator must support and includes some additional operations
//		that are useful in the context of a static linked list.
//		Use AddBefore & AddAfter to add elements to a list based on the
//		iterator's current position within the list.
//
// @tcarg class | T | data type stored in list and type for iterator
// @base public | UTIterator
//-----**************************************************************-----
template <class T> class UTStaticListIterator : public UTIterator< T >
{
// @access Public members
public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// constructors/destructor
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Constructor
	UTStaticListIterator (UTStaticList< T >&	StaticList);
	// @cmember Copy constructor
//	UTStaticListIterator (const UTStaticListIterator< T >&	CopyListItr);
	// @cmember Destructor
	virtual ~UTStaticListIterator(void);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// iterator protocol
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Initialize the iterator to the first link in list
	virtual BOOL	Init		(void);

	// @cmember Retrieve the value from the current link
	virtual T		operator () (void) const;

	// @cmember Does the iterator point to a valid link
	virtual BOOL	operator !	(void) const;

	// @cmember Move the iterator to the next link
	virtual BOOL	operator ++ (int dummy);

	// @cmember Assign the current link a new value
	virtual void	operator =	(T newValue);

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// additional protocol for list iterator
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Assignment operator
//	virtual UTListIterator< T >& operator =	(const UTListIterator< T >& AssignListItr);
	// @cmember Move the iterator to the previous link
	virtual BOOL	operator --		(int dummy);
	// @cmember Remove the current link from the list
	virtual BOOL	RemoveCurrent	(UTLink<T> ** ppLink);
	// @cmember Insert a new value before the iterator
//	virtual void	InsertBefore	(UTLink<T> * pLink);
	// @cmember Insert a new value after the iterator
//	virtual void	InsertAfter		(UTLink<T> * pLink);
	// @cmember Set the iterator at the first element of this value
	virtual BOOL	SetPosAt		(const T& Value);

// @access Protected members
public:

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// data members
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// @cmember Position of iterator in list
	UTLink< T > *	m_pCurrentLink;
	// @cmember One position before the current position
	UTLink< T > *	m_pPreviousLink;
	// @cmember List that is being iterated upon
	UTStaticList< T >&		m_StaticList;
};	//End UTStaticListIterator


//---------- Inline Functions -----------------------------------------------

//---------------------------------------------------------------------------
// @mfunc	Constructors
//
// @tcarg None.
//
//
// @rdesc None.
//
//---------------------------------------------------------------------------

template <class T> UTLink< T >::UTLink
	(
		void
	)
	{
	// do nothing
	m_pPrevLink = NULL;
	m_pNextLink = NULL;
	}



//---------------------------------------------------------------------------
// @mfunc	Constructors
//
// @tcarg class | T | data type to store in the link
//
//
// @rdesc None.
//
//---------------------------------------------------------------------------

template <class T> UTLink< T >::UTLink(
		const T&		LinkValue,	// @parm [in] Value to be stored with link
		UTLink< T > *	Prev,		// @parm [in] pointer to previous link
		UTLink< T > *	Next		// @parm [in] pointer to next link
		)
: m_Value(LinkValue),
	m_pPrevLink(Prev),
	m_pNextLink(Next)
	{
	// do nothing
	}

//---------------------------------------------------------------------------
// @tcarg class | T | data type to store in the link
//
// @rdesc None.
//
//---------------------------------------------------------------------------

template <class T> UTLink< T >::UTLink(
		const UTLink< T >&	CopyLink	// @parm [in] value to copy into this object
		)
	{
	m_Value		= CopyLink.m_Value;
	m_pPrevLink = CopyLink.m_pPrevLink;
	m_pNextLink = CopyLink.m_pNextLink;
	}

//---------------------------------------------------------------------------
// @mfunc	This is the destructor. Currently, it does nothing.
//
// @tcarg class | T | data type to store in the link
//
// @rdesc None.
//
//---------------------------------------------------------------------------

template <class T> UTLink< T >::~UTLink(
		void
		)
	{
	// do nothing
	}


//---------------------------------------------------------------------------
// @mfunc	This is the assignment operator for <c UTLink>.
//
// @tcarg class | T | data type to store in the link
//
// @rdesc	Returns a reference to the newly assigned object
//
//---------------------------------------------------------------------------
template <class T> void UTLink<T>::Init
	 (
	 	const T& LinkValue,UTLink< T > * Prev, UTLink< T > * Next
	 )
{
	m_Value 	= LinkValue;
	m_pPrevLink = Prev;
	m_pNextLink = Next;
}



//---------------------------------------------------------------------------
// @mfunc	This is the assignment operator for <c UTLink>.
//
// @tcarg class | T | data type to store in the link
//
// @rdesc	Returns a reference to the newly assigned object
//
//---------------------------------------------------------------------------

template <class T> UTLink< T >& UTLink< T >::operator =(
		const UTLink< T >&	AssignLink	// @parm [in] value to assign into this object
		)
	{
	m_Value		= AssignLink.m_Value;
	m_pPrevLink = AssignLink.m_pPrevLink;
	m_pNextLink = AssignLink.m_pNextLink;
	return *this;
	}

//---------------------------------------------------------------------------
// @mfunc	This method takes a value of type T and creates a new link
//			containing that value. It fixes all pointers surrounding the
//			current link so that it assumes the position just before the
//			current link. It then returns the new link pointer.
//
// @tcarg class | T | data type to store in the link
//
// @rdesc Pointer to the newly added link
//
//---------------------------------------------------------------------------

template <class T> UTLink< T > * UTLink< T >::AddBefore(
		const T&	newValue	// @parm [in] Value for new link just after the current link
		)
	{
	// allocate memory for new link
	UTLink< T > * newLink;

	newLink = new UTLink< T >(newValue, m_pPrevLink, this);
	if (newLink)
	{
		// if this isn't front of list, have old prev link point to new link
		if (m_pPrevLink)
			{
			m_pPrevLink->m_pNextLink = newLink;
			}

		// make sure this link points back to new link added just before it
		m_pPrevLink = newLink;
	}
	else
		THROW_NO_MEMORY;

	return (newLink);
	}

//---------------------------------------------------------------------------
// @mfunc	This method takes a value of type T and creates a new link
//			containing that value. It fixes all pointers surrounding the
//			current link so that it assumes the position just after the
//			current link. It then returns the new link pointer.
//
// @tcarg class | T | data type to store in the link
//
// @rdesc Pointer to the newly added link
//
//---------------------------------------------------------------------------

template <class T> UTLink< T > * UTLink< T >::AddAfter(
		const T&	newValue	// @parm [in] Value for new link just after the current link
		)
	{
	// allocate memory for new link
	UTLink< T > * newLink;
	newLink = new UTLink< T >(newValue, this, m_pNextLink);

	if (newLink)
	{
		// if this isn't end of list, have old next link point back to new link
		if (m_pNextLink)
			{
			m_pNextLink->m_pPrevLink = newLink;
			}

		// make sure this link points forward to new link added just after it
		m_pNextLink = newLink;
	}
	else
		THROW_NO_MEMORY;

	return (newLink);
	}



//---------------------------------------------------------------------------
// @mfunc	This method takes a pointer to a static list and removes this
//			link from the list.
//
// @tcarg class | T | data type stored in the link
//
// @rdesc	none
//
//---------------------------------------------------------------------------
template <class T> void		UTLink< T >::RemoveFromList (
											UTStaticList < T > * pStaticList)
{
	if ((m_pPrevLink == 0x0 ) && (m_pNextLink == 0x0)) 
	{
		pStaticList->m_pLastLink	= 0x0;
		pStaticList->m_pFirstLink	= 0x0;
	}
	else if (m_pPrevLink == 0x0 )
	{
		pStaticList->m_pFirstLink	= m_pNextLink;
		m_pNextLink->m_pPrevLink	= 0x0;
	}
	else if (m_pNextLink == 0x0 )
	{
		pStaticList->m_pLastLink	= m_pPrevLink;
		m_pPrevLink->m_pNextLink	= 0x0;
	}
	else
	{
		m_pNextLink->m_pPrevLink	= m_pPrevLink; 
		m_pPrevLink->m_pNextLink	= m_pNextLink; 
	}
	
	m_pNextLink = 0x0;
	m_pPrevLink = 0x0;


	// Update the number of link objects in the list 
	pStaticList->m_ulCount--;

}	// End	RemoveFromList




//---------------------------------------------------------------------------
// @mfunc	Constructors
//
// @tcarg class | T | data type to store in the list
//
// @syntax	UTList< T >::UTList()
//
// @rdesc	None.
//
//---------------------------------------------------------------------------

template <class T> UTList< T >::UTList(
		void
		)
: m_ulCount(0), m_pFirstLink(NULL), m_pLastLink(NULL)
	{
	// do nothing
	}

//---------------------------------------------------------------------------
// @tcarg class | T | data type to store in the list
//
// @syntax	UTList< T >::UTList(const UTList< T >&)
//
// @rdesc	None.
//
//---------------------------------------------------------------------------

template <class T> UTList< T >::UTList(
		const UTList< T >&	CopyList	// @parm [in] list to be copied
		)
	{
	UTListIterator< T >	itr((UTList< T >&)CopyList);

	m_pFirstLink = NULL;
	m_pLastLink = NULL;
	m_ulCount = 0;
	for (itr.Init(); !itr; itr++)
		InsertLast(itr());
	}

//---------------------------------------------------------------------------
// @mfunc	This destructor calls <mf UTList::RemoveAll> on the list to
//			delete all links and the memory associated with them.
//
// @tcarg class | T | data type to store in the list
//
//---------------------------------------------------------------------------

template <class T> UTList< T >::~UTList(
		void
		)
	{
	RemoveAll();
	}



//---------------------------------------------------------------------------
// @mfunc	Reinitializes the list
//
// @tcarg class | T | data type to store in the list
//
//---------------------------------------------------------------------------
template <class T> void UTList< T >::Init (void)
{
	m_ulCount		= 0x0;    
	m_pFirstLink	= 0x0; 
	m_pLastLink		= 0x0;	  
}

//---------------------------------------------------------------------------
// @mfunc	This is the assignment operator for <c UTList>. All elements
//			are first removed from this list and then the list is generated
//			by copying the assigned list. Assignment to self is prevented.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a reference to the newly assigned object
//---------------------------------------------------------------------------

template <class T> UTList< T >& UTList< T >::operator =(
		const UTList< T >&	AssignList	// @parm [in] list to be copied (assigned from)
		)
	{
	UTListIterator< T >	itr((UTList< T >&)AssignList);

	// make sure we're not assigning list to itself first
	if (m_pFirstLink != AssignList.m_pFirstLink)
		{
		RemoveAll();	// remove all from this list first
		for (itr.Init(); !itr; itr++)
			InsertLast(itr());
		}
	return *this;
	}
	
//---------------------------------------------------------------------------
// @mfunc	This method duplicates the list into an entirely new list and
//			returns a pointer to the new list.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc Pointer to the newly createe list
//---------------------------------------------------------------------------

template <class T> UTList< T > * UTList< T >::Duplicate(
		void
		)
{
	UTListIterator< T >	itr((UTList< T >&) *this);
	UTList< T > *		pNewList = new UTList();
	if (pNewList)
	{
		for (itr.Init(); !itr; itr++)
			pNewList->InsertLast(itr());
	}
	else
		THROW_NO_MEMORY;

	return pNewList;
}
	
//---------------------------------------------------------------------------
// @mfunc	This method adds the value to the end of the list by calling
//			<mf UTList::InsertLast>.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTList< T >::Add(
		const T& newValue	// @parm [in] value to be added to list
		)
	{
	InsertLast(newValue);
	}

//---------------------------------------------------------------------------
// @mfunc	This method inserts the new value at the beginning of the
//			list.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTList< T >::InsertFirst(
		const T& newValue	// @parm [in] value to be inserted at beginning of list
		)
{
	UTLink< T > * pLink = m_pFirstLink;		// save ptr to link
	if (pLink)	// list is not empty
		{
		m_pFirstLink = pLink->AddBefore(newValue);
		}
	else		// list is empty
	{
		m_pLastLink = new UTLink< T >(newValue, NULL, NULL);
		if (m_pLastLink)
		{
			m_pFirstLink = m_pLastLink;
		}
		else
			THROW_NO_MEMORY;
	}
	m_ulCount++;
}

//---------------------------------------------------------------------------
// @mfunc	This method inserts the new value at the end of the list.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTList< T >::InsertLast(
		const T& newValue	// @parm [in] value to be inserted at end of list
		)
{
	UTLink< T > * pLink = m_pLastLink;	// save ptr to link
	if (pLink)	// list is not empty
		m_pLastLink = pLink->AddAfter(newValue);
	else		// list is empty
	{
		m_pLastLink = new UTLink< T >(newValue, NULL, NULL);
		if (m_pLastLink)
		{
			m_pFirstLink = m_pLastLink;
		}
		else
			THROW_NO_MEMORY;
	}
	m_ulCount++;
}

//---------------------------------------------------------------------------
// @mfunc	This method moves through the list and deletes each link and
//			then resets the list count and pointers as they were set in
//			the constructor.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTList< T >::RemoveAll(
		void
		)
	{
	UTListIterator< T >	itr((UTList< T >&) *this);
	T					tValue;			// required for RemoveCurrent()

	while (!itr)
		itr.RemoveCurrent(&tValue);		// this will reset itr to valid pos
	}

//---------------------------------------------------------------------------
// @mfunc	This method removes the first element from the list and fixes
//			the pointer to the first element according to what remains
//			of the list. The former first element is returned through a
//			CALLER allocated variable.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if first element exists and is deleted
// @flag FALSE	| otherwise
//---------------------------------------------------------------------------

template <class T> BOOL UTList< T >::RemoveFirst(
		T*	pType	// @parm [out] location to put first element if available
		)
	{
	BOOL			bReturn = FALSE;
	UTLink< T > *	pLink = m_pFirstLink;

	if (pLink)
		{
		// isolate the link that is about to be deleted
		m_pFirstLink = m_pFirstLink->m_pNextLink;
		if (m_pFirstLink)
			m_pFirstLink->m_pPrevLink = NULL;
		if (m_pLastLink == pLink)
			m_pLastLink = NULL;

		// prepare return value and delete node
		*pType = pLink->m_Value;
		bReturn = TRUE;
		delete pLink;
		m_ulCount--;
		}
	return bReturn;
	}

//---------------------------------------------------------------------------
// @mfunc	This method removes the last element from the list and fixes
//			the pointer to the last element according to what remains
//			of the list. The former last element is returned through a
//			CALLER allocated variable.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if last element exists and is deleted
// @flag FALSE	| otherwise
//
//---------------------------------------------------------------------------

template <class T> BOOL UTList< T >::RemoveLast(
		T*	pType	// @parm [out] location to put first element if available
		)
	{
	BOOL			bReturn = FALSE;
	UTLink< T > * pLink = m_pLastLink;

	if (pLink)
		{
		// isolate the link that is about to be deleted
		m_pLastLink = m_pLastLink->m_pPrevLink;
		if (m_pLastLink)
			m_pLastLink->m_pNextLink = NULL;
		if (m_pFirstLink == pLink)
			m_pFirstLink = NULL;

		// prepare return value and delete node
		*pType = pLink->m_Value;
		bReturn = TRUE;
		delete pLink;
		m_ulCount--;
		}
	return bReturn;
	}

//---------------------------------------------------------------------------
// @mfunc	This method returns TRUE if there is a first element in the
//			list and fills the out argument (CALLER allocated) with that
//			first element value.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if first element exists
// @flag FALSE	| otherwise
//
//---------------------------------------------------------------------------

template <class T> BOOL UTList< T >::FirstElement(
		T*	pType	// @parm [out] location to put first element if available
		) const
	{
	BOOL	bReturn = FALSE;
	if (m_pFirstLink)
		{
		*pType = m_pFirstLink->m_Value;
		bReturn = TRUE;
		}
	return bReturn;
	}

//---------------------------------------------------------------------------
// @mfunc	This method returns TRUE if there is a last element in the
//			list and fills the out argument (CALLER allocated) with that
//			last element value.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if last element exists
// @flag FALSE	| otherwise
//
//---------------------------------------------------------------------------

template <class T> BOOL UTList< T >::LastElement(
		T*	pType	// @parm [out] location to put last element if available
		) const
	{
	BOOL	bReturn = FALSE;
	if (m_pLastLink)
		{
		*pType = m_pLastLink->m_Value;
		bReturn = TRUE;
		}
	return bReturn;
	}

//---------------------------------------------------------------------------
// @mfunc	This method checks the list for the given value and returns
//			TRUE if that value is in the list.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if element exists in list
// @flag FALSE	| otherwise
//
//---------------------------------------------------------------------------

template <class T> BOOL UTList< T >::Includes(
		const T& value	// @parm [in] does list include this value?
		)
	{
	UTListIterator< T >	itr((UTList< T >&) *this);

	while (!itr && (itr() != value))
		itr++;
	return (!itr);
	}

//---------------------------------------------------------------------------
// @mfunc	This method returns TRUE if the count of elements in the list
//			is ZERO.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if list is empty
// @flag FALSE	| list is not empty
//---------------------------------------------------------------------------

template <class T> BOOL UTList< T >::IsEmpty(
		void
		) const
	{
	return (m_ulCount == 0);
	}

//---------------------------------------------------------------------------
// @mfunc	This method returns the member variable that indicates the
//			count of elements. It is incremented whenever values are added
//			and decremented whenever values are removed.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	ULONG
//---------------------------------------------------------------------------

template <class T> ULONG UTList< T >::GetCount(
		void
		) const
	{
	return (m_ulCount);
	}


//---------------------------------------------------------------------------
// @mfunc	Constructors
//
// @tcarg class | T | data type to iterate over
//
// @syntax UTListIterator< T >::UTListIterator(UTList< T >&)
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> UTListIterator< T >::UTListIterator(
		UTList< T >& List	// @parm [in] list reference for list to be iterated upon
		)
: m_List(List)
	{
	Init();
	}

//---------------------------------------------------------------------------
// @tcarg class | T | data type to iterate over
//
// @syntax UTListIterator< T >::UTListIterator(const UTListIterator< T >&)
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> UTListIterator< T >::UTListIterator(
		const UTListIterator< T >&	CopyListItr	// @parm [in] value to copy into this obj
		)
: m_List(CopyListItr.m_List),
	m_pPreviousLink(CopyListItr.m_pPreviousLink),
	m_pCurrentLink(CopyListItr.m_pCurrentLink)
	{
	}

//---------------------------------------------------------------------------
// @mfunc	This destruct does nothing because no memory needs to be deleted.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> UTListIterator< T >::~UTListIterator(
		void
		)
	{
	// do nothing
	}

//---------------------------------------------------------------------------
// @mfunc	This is the assignment operator.
//
// @tcarg class | T | data type to iterate over
//
// @syntax	UTListIterator< T >& UTListIterator< T >::operator =(const UTListIterator< T >&)
//
// @rdesc	Returns a reference to the newly assigned object
//---------------------------------------------------------------------------

template <class T> UTListIterator< T >& UTListIterator< T >::operator =(
		const UTListIterator< T >&	AssignListItr // @parm [in] value to copy into this obj
		)
	{
	// make sure iterators don't already point to the same thing
	if (m_pCurrentLink != AssignListItr.m_pCurrentLink)
		{
		m_List = AssignListItr.m_List;
		m_pPreviousLink = AssignListItr.m_pPreviousLink;
		m_pCurrentLink = AssignListItr.m_pCurrentLink;
		}
	return *this;
	}

//---------------------------------------------------------------------------
// @tcarg class | T | data type to iterate over
//
// @syntax	UTListIterator< T >& UTListIterator< T >::operator =(T)
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTListIterator< T >::operator =(
		T	newValue	// @parm [in] value to place in link at current position
		)
	{
	if (m_pCurrentLink)
		m_pCurrentLink->m_Value = newValue;
	}

//---------------------------------------------------------------------------
// @mfunc	This method sets up the iterator by making its internal state
//			point to the first element in the list.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if there is at least on element in the list which means
//					there is something to iterate over
// @flag FALSE	| if no elements are to be iterated upon
//---------------------------------------------------------------------------

template <class T> BOOL UTListIterator< T >::Init(
		void
		)
	{
	m_pPreviousLink = NULL;
	m_pCurrentLink = m_List.m_pFirstLink;
	return (m_pCurrentLink != NULL);
	}

//---------------------------------------------------------------------------
// @mfunc	This operator retrieves the element from the current position
//			of the iterator.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	T	- current value where iterator is located
//---------------------------------------------------------------------------

template <class T> T UTListIterator< T >::operator ()(
		void
		) const
	{
	//UNDONE:
	//assert(m_pCurrentLink != NULL);
	if (m_pCurrentLink)
		return (m_pCurrentLink->m_Value);
	else	// incorrect use of iterator, return "bogus" default value
		{
		T	tBogusDefault = (T) 0;
		return tBogusDefault;
		}
	}

//---------------------------------------------------------------------------
// @mfunc	This operator determines if the current position is valid.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if iterator is in a valid position
// @flag FALSE	| if iterator is NOT in a valid position
//---------------------------------------------------------------------------

template <class T> BOOL UTListIterator< T >::operator !(
		void
		) const
	{
	return (m_pCurrentLink != NULL);
	}

//---------------------------------------------------------------------------
// @mfunc	This operator increments the iterator to the next element in the
//			list and returns an indication of whether or not the end of the
//			list has been passed.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if new position is valid
// @flag FALSE	| if new position is NOT valid (i.e. end of the list)
//---------------------------------------------------------------------------

template <class T> BOOL UTListIterator< T >::operator ++(
		int dummy	// @parm [in] dummy so that operator is on right hand side
		)
	{
	if (m_pCurrentLink)
		{
		m_pPreviousLink = m_pCurrentLink;
		m_pCurrentLink = m_pCurrentLink->m_pNextLink;
		}
	return (m_pCurrentLink != NULL);
	}

//---------------------------------------------------------------------------
// @mfunc	This operator decrements the iterator to the prev element in the
//			list and returns an indication of whether or not the front of the
//			list has been passed.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if new position is valid
// @flag FALSE	| if new position is NOT valid
//---------------------------------------------------------------------------

template <class T> BOOL UTListIterator< T >::operator --(
		int dummy	// @parm [in] dummy so that operator is on right hand side
		)
	{
	m_pCurrentLink = m_pPreviousLink;
	if (m_pCurrentLink)
		{
		m_pPreviousLink = m_pCurrentLink->m_pPrevLink;
		}
	return (m_pCurrentLink != NULL);
	}

//---------------------------------------------------------------------------
// @mfunc	RemoveCurrent deletes the element at the position of the
//			iterator returning the deleted value through a CALLER
//			allocated parameter. <nl>
//			It then fixes the current position to the following: <nl><nl>
//		If we...							The we... <nl>
//		1) removed any link but 1st one		old previous position->next <nl>
//		2) removed first link(links remain) new first position <nl>
//		3) removed only link				NULL (no current position) <nl>
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if current element exists and was removed
// @flag FALSE	| otherwise
//---------------------------------------------------------------------------

template <class T> BOOL UTListIterator< T >::RemoveCurrent(
		T*	pType	// @parm [out] location to put current element if available
		)
	{
	BOOL	bReturn = FALSE;

	if (m_pCurrentLink) // remove ONLY if iterator is still in valid position
		{
		if (m_pPreviousLink == NULL)	// removing first element
			{
			if (m_pCurrentLink->m_pNextLink == NULL)	// ONLY element
				{
				m_List.m_pFirstLink = m_List.m_pLastLink = NULL;
				}
			else	// first, but not last element
				{
				m_List.m_pFirstLink = m_pCurrentLink->m_pNextLink;
				m_pCurrentLink->m_pNextLink->m_pPrevLink = NULL;
				}
			}
		else		// not removing first element
			{
			if (m_pCurrentLink->m_pNextLink == NULL)	// last element
				{
				m_List.m_pLastLink = m_pPreviousLink;
				m_pPreviousLink->m_pNextLink = NULL;
				}
			else	// neither first nor last element
				{
				m_pPreviousLink->m_pNextLink = m_pCurrentLink->m_pNextLink;
				m_pCurrentLink->m_pNextLink->m_pPrevLink = m_pPreviousLink;
				}
			}
		*pType = m_pCurrentLink->m_Value;
		bReturn = TRUE;
		delete m_pCurrentLink;
		m_List.m_ulCount--;

		// now fix up the current iterator pointer
		if (m_pPreviousLink)
			m_pCurrentLink = m_pPreviousLink->m_pNextLink;
		else if (m_List.m_pFirstLink)
			m_pCurrentLink = m_List.m_pFirstLink;
		else
			m_pCurrentLink = NULL;
		}
	return bReturn;
	}

//---------------------------------------------------------------------------
// @mfunc	This method adds a new link to the list (using data passed as
//			an argument) in a position just before the current position
//			of the iterator.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTListIterator< T >::InsertBefore(
		const T& newValue	// @parm [in] new data to be added before the current position
		)
	{
	if (m_pCurrentLink)		// add ONLY if iterator is still in valid position
		{
		if (m_pPreviousLink)	// not at beginning
			{
			m_pCurrentLink->AddBefore(newValue);
			}
		else	// at beginning of list
			{
			m_List.m_pFirstLink = m_pCurrentLink->AddBefore(newValue);
			}
		m_List.m_ulCount++;
		// fix prev pointer which is now two links away
		m_pPreviousLink = m_pCurrentLink->m_pPrevLink;
		}
	}

//---------------------------------------------------------------------------
// @mfunc	This method adds a new link to the list (using data passed as
//			an argument) in a position immediately following the current
//			position of the iterator.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTListIterator< T >::InsertAfter(
		const T& newValue	// @parm [in] new data to be added after the current position
		)
	{
	if (m_pCurrentLink)		// add ONLY if iterator is still in valid position
		{
		if (m_pCurrentLink->m_pNextLink)	// not at end
			{
			m_pCurrentLink->AddAfter(newValue);
			}
		else	// at end of list
			{
			m_List.m_pLastLink = m_pCurrentLink->AddAfter(newValue);
			}
		m_List.m_ulCount++;
		}
	}

//---------------------------------------------------------------------------
// @mfunc	This method resets the iterator at the value passed
//			in as an argument if it exists in the list and returns
//			TRUE in that case indicating that it did change position.
//			If the value does not exist, the position remains
//			unchanged, and FALSE is returned to indicate this.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if posistion has changed
// @flag FALSE	| otherwise
//---------------------------------------------------------------------------

template <class T> BOOL UTListIterator< T >::SetPosAt(
		const T& value	//@parm [in] if this value is in list, set up iterator at its location
		)
	{
	BOOL bReturn = FALSE;
	UTLink< T > *	pLink = m_List.m_pFirstLink;
	
	while (pLink && pLink->m_Value != value)
		pLink = pLink->m_pNextLink;
	if (pLink)	// found value in list
		{
		m_pCurrentLink = pLink;
		m_pPreviousLink = pLink->m_pPrevLink;
		bReturn = TRUE;
		}
	return bReturn;
	}



//---------------------------------------------------------------------------
// @mfunc	Constructors
//
// @tcarg class | T | data type to store in the list
//
// @syntax	UTStaticList< T >::UTStaticList()
//
// @rdesc	None.
//
//---------------------------------------------------------------------------

template <class T> UTStaticList< T >::UTStaticList(
		void
		)
: m_ulCount(0), m_pFirstLink(NULL), m_pLastLink(NULL)
	{
	// do nothing
	}


//---------------------------------------------------------------------------
// @mfunc	This destructor does nothing
//
// @tcarg class | T | data type to store in the list
//
//---------------------------------------------------------------------------

template <class T> UTStaticList< T >::~UTStaticList(
		void
		)
	{
		//Do nothing
	}

//---------------------------------------------------------------------------
// @mfunc	Reinitializes the list
//
// @tcarg class | T | data type to store in the list
//
//---------------------------------------------------------------------------
template <class T> void UTStaticList< T >::Init (void)
{
	m_ulCount		= 0x0;    
	m_pFirstLink	= 0x0; 
	m_pLastLink		= 0x0;	  
}


//---------------------------------------------------------------------------
// @mfunc	This method adds the link to the end of the list by calling
//			<mf UTStaticList::InsertLast>.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTStaticList< T >::Add(
		 UTLink <T> * pLink	// @parm [in] Link to be added to list
		)
	{
	InsertLast(pLink);
	}


//---------------------------------------------------------------------------
// @mfunc	This method inserts the new value at the beginning of the
//			list.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTStaticList< T >::InsertFirst(
		 UTLink <T> * pLink	// @parm [in] link to be inserted at beginning of list
		)
{
	if (m_pFirstLink)	// list is not empty
	{
		pLink->m_pPrevLink	 		= (UTLink<T> *) 0;
		pLink->m_pNextLink 			= m_pFirstLink;
		m_pFirstLink->m_pPrevLink 	= pLink;
		m_pFirstLink				= pLink;
	}
	else		// list is empty
	{
		m_pFirstLink = pLink;
		m_pLastLink = pLink;

        pLink->m_pNextLink	 		= NULL;
		pLink->m_pPrevLink 			= NULL;
	}

	m_ulCount++;
} //End UTStaticList::InsertFirst


//---------------------------------------------------------------------------
// @mfunc	This method inserts the new link at the end of the list.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTStaticList< T >::InsertLast(
		 UTLink <T> * pLink	// @parm [in] link to be inserted at end of list
		)
{
	if (m_pLastLink)	// list is not empty
	{
		pLink->m_pNextLink	 		= (UTLink<T> *) 0;
		pLink->m_pPrevLink 			= m_pLastLink;
		m_pLastLink->m_pNextLink 	= pLink;
		m_pLastLink					= pLink;
	}
	else		// list is empty
	{
		m_pFirstLink = pLink;
		m_pLastLink = pLink;

        pLink->m_pNextLink	 		= NULL;
		pLink->m_pPrevLink 			= NULL;
	}
	
	//Increment the count
	m_ulCount++;

} //End UTStaticList::InsertLast





//---------------------------------------------------------------------------
// @mfunc	This method  resets the list count and pointers as they were set in
//			the constructor.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTStaticList< T >::RemoveAll
	(
		void
	)
{
	//UNDONE - gaganc Need to reset the pointers of all the links to NULL
		m_pFirstLink 	= NULL;
		m_pLastLink  	= NULL;
		m_ulCount 		= 0;

} //End UTStaticList::RemoveAll


//---------------------------------------------------------------------------
// @mfunc	This method removes the first element from the list and fixes
//			the pointer to the first element according to what remains
//			of the list. The former first element is returned through a
//			CALLER allocated variable.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if first element exists and is deleted
// @flag FALSE	| otherwise
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticList< T >::RemoveFirst(
		UTLink<T> **	ppLink	// @parm [out] location to put first element if available
		)
{
	BOOL			bReturn = FALSE;

	//Assign the out param the first link
	*ppLink 	= m_pFirstLink;

	if (m_pFirstLink)
	{
		// Reset the first link
		m_pFirstLink = m_pFirstLink->m_pNextLink;

		if (m_pFirstLink)
			m_pFirstLink->m_pPrevLink = NULL;

		if (m_pLastLink == *ppLink)
			m_pLastLink = NULL;

		bReturn = TRUE;

		m_ulCount--;
	}

	//Remember to clear previous and the next pointers in the link
	if (*ppLink)
	{
		(*ppLink)->m_pNextLink = NULL;
		(*ppLink)->m_pPrevLink = NULL;
	}

	return bReturn;
} //End UTStaticList::RemoveFirst

//---------------------------------------------------------------------------
// @mfunc	This method removes the last element from the list and fixes
//			the pointer to the last element according to what remains
//			of the list. The former last element is returned through a
//			CALLER allocated variable.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if last element exists and is deleted
// @flag FALSE	| otherwise
//
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticList< T >::RemoveLast(
		UTLink<T> **	ppLink	// @parm [out] location to put first element if available
		)
{
	BOOL			bReturn = FALSE;

	*ppLink = m_pLastLink;

	if (m_pLastLink)
	{
		// isolate the link that is about to be deleted
		m_pLastLink = m_pLastLink->m_pPrevLink;

		if (m_pLastLink)
			m_pLastLink->m_pNextLink = NULL;

		if (m_pFirstLink == *ppLink)
			m_pFirstLink = NULL;

		bReturn = TRUE;
		m_ulCount--;
	}

	//Remember to clear previous and the next pointers in the link
	if (*ppLink)
	{
		(*ppLink)->m_pNextLink = NULL;
		(*ppLink)->m_pPrevLink = NULL;
	}

	return bReturn;
} //End UTStaticList::RemoveLast

//---------------------------------------------------------------------------
// @mfunc	This method returns TRUE if there is a first element in the
//			list and fills the out argument (CALLER allocated) with that
//			first element value.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if first element exists
// @flag FALSE	| otherwise
//
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticList< T >::FirstElement
	(
		UTLink <T> **	ppLink	// @parm [out] location to put first element if available
	)
{
	BOOL	bReturn = FALSE;

	//If the first elment exists then return TRUE else FALSE
	if (m_pFirstLink)
		{
			*ppLink = m_pFirstLink;
			bReturn = TRUE;
		}

	return bReturn;
}


//---------------------------------------------------------------------------
// @mfunc	This method returns TRUE if there is a last element in the
//			list and fills the out argument (CALLER allocated) with that
//			last element value.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if last element exists
// @flag FALSE	| otherwise
//
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticList< T >::LastElement
	(
		UTLink<T> **	ppLink	// @parm [out] location to put last element if available
	) 
{
	BOOL	bReturn = FALSE;

	if (m_pLastLink)
	{
		*ppLink = m_pLastLink;
		bReturn = TRUE;
	}
	return bReturn;
}


//---------------------------------------------------------------------------
// @mfunc	This method returns TRUE if the count of elements in the list
//			is ZERO.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if list is empty
// @flag FALSE	| list is not empty
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticList< T >::IsEmpty
	(
		void
	) const
{
	return (m_ulCount == 0);
} //End UTStaticList::IsEmpty

//---------------------------------------------------------------------------
// @mfunc	This method returns the member variable that indicates the
//			count of elements. It is incremented whenever values are added
//			and decremented whenever values are removed.
//
// @tcarg class | T | data type to store in the list
//
// @rdesc	ULONG
//---------------------------------------------------------------------------

template <class T> ULONG UTStaticList< T >::GetCount
	(
		void
	) const
{
	return (m_ulCount);
} //End UTStaticList::GetCount






//---------------------------------------------------------------------------
// @mfunc	Constructors
//
// @tcarg class | T | data type to iterate over
//
// @syntax UTStaticListIterator< T >::UTStaticListIterator(UTStaticList< T >&)
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> UTStaticListIterator< T >::UTStaticListIterator
	(
		UTStaticList< T >& StaticList	// @parm [in] list reference for list to be iterated upon
	)
	: m_StaticList(StaticList)
{
	Init();
}


//---------------------------------------------------------------------------
// @mfunc	This destruct does nothing because no memory needs to be deleted.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> UTStaticListIterator< T >::~UTStaticListIterator
	(
		void
	)
{
	// do nothing
}

//---------------------------------------------------------------------------
// @mfunc	This is the assignment operator.
//
// @tcarg class | T | data type to iterate over
//
// @syntax	UTStaticListIterator< T >& UTStaticListIterator< T >
//				::operator =(const UTListIterator< T >&)
//
// @rdesc	Returns a reference to the newly assigned object
//---------------------------------------------------------------------------

/*
template <class T> UTStaticListIterator< T > & UTStaticListIterator< T >::operator =
	(
		const UTStaticListIterator< T >	& AssignListItr 
									// @parm [in] value to copy into this obj
	)
{
	// make sure iterators don't already point to the same thing
	if (m_pCurrentLink != AssignListItr.m_pCurrentLink)
	{
		m_StaticList 	= AssignListItr.m_StaticList;
		m_pPreviousLink = AssignListItr.m_pPreviousLink;
		m_pCurrentLink 	= AssignListItr.m_pCurrentLink;
	}

} //End UTStaticListIterator

*/

//---------------------------------------------------------------------------
// @tcarg class | T | data type to iterate over
//
// @syntax	UTStaticListIterator< T >& UTStaticListIterator< T >::operator =(T)
//
// @rdesc	None.
//---------------------------------------------------------------------------

template <class T> void UTStaticListIterator< T >::operator =(
		T	newValue	// @parm [in] value to place in link at current position
		)
{
	//CAUTION : -- Don't use this THIS WILL CRASH
	UTLink <short> * pLink = 0;
	
	pLink->m_Value;
}

//---------------------------------------------------------------------------
// @mfunc	This method sets up the iterator by making its internal state
//			point to the first element in the list.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if there is at least on element in the list which means
//					there is something to iterate over
// @flag FALSE	| if no elements are to be iterated upon
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticListIterator< T >::Init
	(
		void
	)
{
	m_pPreviousLink = NULL;
	m_pCurrentLink = m_StaticList.m_pFirstLink;

	return (m_pCurrentLink != NULL);
}

//---------------------------------------------------------------------------
// @mfunc	This operator retrieves the element from the current position
//			of the iterator.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	T	- current value where iterator is located
//---------------------------------------------------------------------------

template <class T> T UTStaticListIterator< T >::operator ()
	(
		void
	) const
{
	if (m_pCurrentLink)
		return (m_pCurrentLink->m_Value);
	else	// incorrect use of iterator, return "bogus" default value
	{
		T tBogusDefault = (T) 0;
		return tBogusDefault;
	}
}

//---------------------------------------------------------------------------
// @mfunc	This operator determines if the current position is valid.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if iterator is in a valid position
// @flag FALSE	| if iterator is NOT in a valid position
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticListIterator< T >::operator !
	(
		void
	) const
{
	return (m_pCurrentLink != NULL);
}

//---------------------------------------------------------------------------
// @mfunc	This operator increments the iterator to the next element in the
//			list and returns an indication of whether or not the end of the
//			list has been passed.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if new position is valid
// @flag FALSE	| if new position is NOT valid (i.e. end of the list)
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticListIterator< T >::operator ++
	(
		int dummy	// @parm [in] dummy so that operator is on right hand side
	)
{
	if (m_pCurrentLink)
	{
		m_pPreviousLink = m_pCurrentLink;
		m_pCurrentLink = m_pCurrentLink->m_pNextLink;
	}
	return (m_pCurrentLink != NULL);
}

//---------------------------------------------------------------------------
// @mfunc	This operator decrements the iterator to the prev element in the
//			list and returns an indication of whether or not the front of the
//			list has been passed.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if new position is valid
// @flag FALSE	| if new position is NOT valid
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticListIterator< T >::operator --
	(
		int dummy	// @parm [in] dummy so that operator is on right hand side
	)
{
	m_pCurrentLink = m_pPreviousLink;
	if (m_pCurrentLink)
	{
		m_pPreviousLink = m_pCurrentLink->m_pPrevLink;
	}
	return (m_pCurrentLink != NULL);
}


//---------------------------------------------------------------------------
// @mfunc	RemoveCurrent deletes the element at the position of the
//			iterator returning the deleted value through a CALLER
//			allocated parameter. <nl>
//			It then fixes the current position to the following: <nl><nl>
//		If we...							The we... <nl>
//		1) removed any link but 1st one		old previous position->next <nl>
//		2) removed first link(links remain) new first position <nl>
//		3) removed only link				NULL (no current position) <nl>
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if current element exists and was removed
// @flag FALSE	| otherwise
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticListIterator< T >::RemoveCurrent
	(
		UTLink <T> ** ppLink // @parm [out] location to put current element if available
	)
{
	BOOL	bReturn = FALSE;

	if (m_pCurrentLink) // remove ONLY if iterator is still in valid position
		{
		if (m_pPreviousLink == NULL)	// removing first element
		{
			if (m_pCurrentLink->m_pNextLink == NULL)	// ONLY element
			{
				m_StaticList.m_pFirstLink = m_StaticList.m_pLastLink = NULL;
			}
			else	// first, but not last element
			{
				m_StaticList.m_pFirstLink = m_pCurrentLink->m_pNextLink;
				m_pCurrentLink->m_pNextLink->m_pPrevLink = NULL;
			}
		}
		else		// not removing first element
		{
			if (m_pCurrentLink->m_pNextLink == NULL)	// last element
			{
				m_StaticList.m_pLastLink = m_pPreviousLink;
				m_pPreviousLink->m_pNextLink = NULL;
			}
			else	// neither first nor last element
			{
				m_pPreviousLink->m_pNextLink = m_pCurrentLink->m_pNextLink;
				m_pCurrentLink->m_pNextLink->m_pPrevLink = m_pPreviousLink;
			}
		}
		*ppLink = m_pCurrentLink;
		(*ppLink)->m_pNextLink = 0;
		(*ppLink)->m_pPrevLink = 0;

		bReturn = TRUE;

		m_StaticList.m_ulCount--;

		// now fix up the current iterator pointer
		if (m_pPreviousLink)
		{
			m_pCurrentLink = m_pPreviousLink->m_pNextLink;
		}
		else if (m_StaticList.m_pFirstLink)
		{
			m_pCurrentLink = m_StaticList.m_pFirstLink;
		}
		else
		{
			m_pCurrentLink = NULL;
		}
	}
	return bReturn;
} //End RemoveCurrent

//---------------------------------------------------------------------------
// @mfunc	This method resets the iterator at the value passed
//			in as an argument if it exists in the list and returns
//			TRUE in that case indicating that it did change position.
//			If the value does not exist, the position remains
//			unchanged, and FALSE is returned to indicate this.
//
// @tcarg class | T | data type to iterate over
//
// @rdesc	Returns a BOOL
// @flag TRUE	| if posistion has changed
// @flag FALSE	| otherwise
//---------------------------------------------------------------------------

template <class T> BOOL UTStaticListIterator< T >::SetPosAt
	(
		const T& value	//@parm [in] if this value is in list, set up iterator at its location
	)
{
	BOOL bReturn = FALSE;
	UTLink< T > *	pLink = m_StaticList.m_pFirstLink;
	
	while (pLink && pLink->m_Value != value)
		pLink = pLink->m_pNextLink;
	if (pLink)	// found value in list
		{
		m_pCurrentLink = pLink;
		m_pPreviousLink = pLink->m_pPrevLink;
		bReturn = TRUE;
		}
	return bReturn;
} //End SetPosAt



#endif	// __UTLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\utmem.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// This file to be deleted when remaining references to it are removed...
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\utsem.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __UTSEM_H__
#define __UTSEM_H__

#include "CatMacros.h"

//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       UTSem.h
//
//  Contents:   This file defines a variety of classes used to coordinate
//              control flow between threads in an application. 
//
//  Classes:    CEventSem		- A barrier (build on win32 Events)
//				CSemExclusive	- Exclusive lock (CriticalSection wrapper)
//				CLock			- Object wrapper around CSemExclusive; lock 
//								  is released when object is destroyed
//				UTGuard			- Non-blocking exclusive lock
//				UTSem			- counting blocking lock (semaphore wrapper)
//				UTSemReadWrite	- Multi-reader, one-writer lock
//				UTSemRWMgrRead  - Object wrapper for read access to
//						          UTSemReadWrite (lock released when object
//								  is destroyed)
//				UTSemRWMgrWrite	- Object wrapper for write access to
//						          UTSemReadWrite (lock released when object
//								  is destroyed)	
//
//  Functions:
//				LOCKON(x)		- create a CLock for CSemExclusive *x
//				LOCK()			- create a CLock for a CSemExclusive 
//								  named m_semCritical
//				READYLOCKON(x)	- create an unlocked CLock for *x
//				READYLOCK()		- create an unlocked CLock for m_semCritical
//				UNLOCK()		- unlock the CLock created above
//				RELOCK()		- lock the CLock created above
//
//	Note:		The functions are provided for Windows95 portability (even 
//				though portable versions are not provided in the current
//				implementation for all functions)
//
//  History:    10-Nov-97   stevesw				Stolen from MTS
//              19-Nov-97   stevesw				Cleanup
//              13-Jan-98	stevesw				Moved into ComSvcs
//              17-Sep-98   a-olegi              Sundown changes
//              24-Sep-98   a-olegi              Common version for both DTC and ComSvcs
//
//---------------------------------------------------------------------------

// These two inline functions isolate error handling engine from
// header file and header file customers. They're implemented in UTSEM.CPP.
VOID UtsemWin32Error(LPWSTR pwszMessage, LPWSTR pwszFile, DWORD dwLine);
VOID UtsemCheckBool(LPWSTR pwszMessage, BOOL bCondition, LPWSTR pwszFile, DWORD dwLine);

#define _JIMBORULES(x) L ## x
#define _UTSEM_WIDEN(x) _JIMBORULES(x)

//+--------------------------------------------------------------------------
//              
//							FORWARD DECLARATIONS
//              
//---------------------------------------------------------------------------

class CEventSem;
class CSemExclusive;
class CLock;
class UTGuard;
class UTSem;
class UTSemReadWrite;
class UTSemRWMgrRead;
class UTSemRWMgrWrite;

//+---------------------------------------------------------------------------
//
//  Class:      CEventSem
//
//  Purpose:    Barrier services
//
//  Interface:  Wait            - wait for barrier to be lowered
//              Set             - set signalled state (lower barrier)
//              Reset           - clear signalled state (raise barrier)
//              Pulse           - set and immediately clear barrier
//
//  Notes:      Used for communication between consumers and producers.
//              Consumer threads block by calling Wait. A producer calls Set
//              waking up all the consumers who go ahead and consume until
//              there's nothing left. They call Reset, release whatever lock
//              protected the resources, and call Wait. There has to be a
//              separate lock to protect the shared resources.  Remember:
//              call Reset under lock.  don't call Wait under lock.
//
//----------------------------------------------------------------------------

class CEventSem
{
public:
    CEventSem(BOOL fStartSignaled=FALSE, 
			  const LPSECURITY_ATTRIBUTES lpsa=NULL,
			  BOOL fManualReset=TRUE) {
		m_hEvent = CreateEvent (lpsa, fManualReset, fStartSignaled, 0);
		if (m_hEvent == NULL) {
			UtsemWin32Error(L"CreateEvent returned a NULL handle.", _UTSEM_WIDEN(__FILE__), __LINE__);
		}
	}
    CEventSem( HANDLE hEvent ) : m_hEvent( hEvent ) {
		UtsemCheckBool(L"Trying to create a CEventSem with a NULL handle.",
				  m_hEvent != NULL, _UTSEM_WIDEN(__FILE__), __LINE__);
	}
    ~CEventSem() { 
		CloseHandle (m_hEvent);
	}

    void Wait(DWORD dwMilliseconds=INFINITE, BOOL fAlertable=FALSE ) {
		if (WaitForSingleObjectEx (m_hEvent, dwMilliseconds, fAlertable) == 0xffffffff) {
			UtsemWin32Error(L"WaitForSingleObjectEx fails in CEventSem::Wait()", _UTSEM_WIDEN(__FILE__), __LINE__);
		}
	}

    void Set(void) {
		if (!SetEvent (m_hEvent)) {
			UtsemWin32Error(L"SetEvent fails in CEventSem::Set()", _UTSEM_WIDEN(__FILE__), __LINE__);
		}
	}
    void Reset(void) {
		if (!ResetEvent(m_hEvent)) {
			UtsemWin32Error(L"ResetEvent fails in CEventSem::Reset()", _UTSEM_WIDEN(__FILE__), __LINE__);
		}
	}
    void Pulse(void) {
		if (!PulseEvent(m_hEvent)) {
			UtsemWin32Error(L"PulseEvent fails in CEventSem::Pulse()", _UTSEM_WIDEN(__FILE__), __LINE__);
		}
	}

private:
    HANDLE      m_hEvent;
};


//+--------------------------------------------------------------------------
//
//  Class:      CSemExclusive
//
//  Purpose:    Critical-section services
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//
//  Note:		Used to guarantee that only one thread is accessing an
//              exclusive resource at a time. For instance, if you're
//              maintaining a shared queue, you might need to lock access to
//              the queue whenever you fiddle with some of the queue
//              pointers. 
//
//				CLock provides a nice exception-safe wrapper around a
//				CSemExclusive.
//
//---------------------------------------------------------------------------

class CSemExclusive {
public:
	CSemExclusive (unsigned long ulcSpinCount = 500);
	~CSemExclusive (void) {
		DeleteCriticalSection (&m_csx); 
	}
	void Lock (void) {
		EnterCriticalSection (&m_csx); 
	}
	void UnLock (void) {
		LeaveCriticalSection (&m_csx); 
	}
	void Unlock (void) {  // to please DTC
		LeaveCriticalSection (&m_csx);
	}

private:
	CRITICAL_SECTION m_csx;
};


/* ----------------------------------------------------------------------------
@class CSemExclusiveSL:

	A subclass of CSemExclusive with a different default constructor.
	This subclass is appropriate for locks that are:
	*	Frequently Lock'd and Unlock'd, and
	*	Are held for very brief intervals.


	@rev 	1 	| 6th Jun 97 | JimLyon 		| Rewritten to use CSemExclusive
	@rev 	0 	| ???		 | ???	 		| Created
---------------------------------------------------------------------------- */
class CSemExclusiveSL : public CSemExclusive
{
public:
	CSemExclusiveSL (unsigned long ulcSpinCount = 400) : CSemExclusive (ulcSpinCount) {}
};


//+--------------------------------------------------------------------------
//
//  Class:      CLock
//
//  Purpose:    Auto-unlocking critical-section services
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- locks the critical section (unless told 
//								  otherwise)
//				Detructor		- unlocks the critical section if its locked
//
//  Notes:		This provides a convenient way to ensure that you're
//              unlocking a CSemExclusive, which is useful if your routine
//              can be left via several returns and/or via exceptions....
//
//---------------------------------------------------------------------------

class CLock {
public:
	CLock (CSemExclusive* val) : m_pSem(val), m_locked(TRUE) { m_pSem->Lock(); }
	CLock (CSemExclusive& val) : m_pSem(&val), m_locked(TRUE) { m_pSem->Lock(); }
	CLock (CSemExclusive* val, BOOL fLockMe) : m_pSem(val), m_locked(fLockMe) { if (fLockMe) m_pSem->Lock(); }

	~CLock () {	if (m_locked) m_pSem->UnLock(); }

	void UnLock () { if (m_locked) { m_pSem->UnLock(); m_locked = FALSE; }}
	void Lock () { if (!m_locked) { m_pSem->Lock(); m_locked = TRUE; }}

	// DTC likes Unlock better
	void Unlock () { if (m_locked) { m_pSem->UnLock(); m_locked = FALSE; }}

private:
	BOOL m_locked;
	CSemExclusive* m_pSem;
};


//+--------------------------------------------------------------------------
//
//				CONVENIENCE MACROS For CLock & CSemExclusive
//
//---------------------------------------------------------------------------

#define LOCKON(x)		CLock _ll1(x)
#define LOCK()			CLock _ll1(&m_semCritical)
#define READYLOCKON(x)	CLock _ll1(x, FALSE)
#define READYLOCK()		CLock _ll1(&m_semCritical, FALSE)
#define UNLOCK()		_ll1.UnLock()
#define RELOCK()		_ll1.Lock()


//+--------------------------------------------------------------------------
//
//  Class:      UTGuard
//
//  Purpose:    Non-hanging critical-section services
//
//  Interface:  AcquireGuard	- tries to lock critical section; returns
//							      TRUE if it worked, FALSE if someone else
//								  has already locked it
//				ReleaseGuard	- releases the lock on the critical section
//              
//  Note:		Used to guarantee that only one thread is accessing an
//				exclusive resource at a time. It tells you not to use the
//              resource, rather than just letting you hang. Also, it doesn't
//              keep you from unlocking the guard if you weren't the one who
//              locked it. So, you have to behave if you use this.
//
//---------------------------------------------------------------------------

class UTGuard {
public:
	UTGuard (void) : m_lVal(0) { }
	~UTGuard (void)	{ }
	BOOL AcquireGuard (void) { return 0 == InterlockedExchange(&m_lVal, 1); }
	void ReleaseGuard (void) { m_lVal = 0;  }
	void Init (void) { m_lVal = 0; }

private:
	long m_lVal;
};


//+--------------------------------------------------------------------------
//
//  Class:      UTSem
//
//  Purpose:    Semaphore services
//
//  Interface:  Wait			- hangs 'til semaphore value is non-zero,
//								  then atomistically returns and decrements
//								  semaphore value
//				Incr			- increments sempahore value
//
//	Notes:		This class provides a convenient resource-guard semaphore. 
//				The UTSem is associated with a long value (and a maximum
//				value). You set these initial values with the constructor.
//				When you Wait() on the UTSem, if the value is 0 the Wait()
//				will hang. When the value grows larger than 0, Wait() will
//				atomistically decrement the value and return. You can
//				increment this value (and potentially cause a hanging wait to
//				release) by calling Incr().
//
//				Named semaphores can be used cross-process (unlike many of
//				these resources...). 
//              
//---------------------------------------------------------------------------

class UTSem {
public:
	UTSem(LONG initCount=1,
		  LONG maxCount=0,
		  LPCTSTR name=NULL,
		  LPSECURITY_ATTRIBUTES attrs=NULL) : m_sem(NULL){
		m_sem = CreateSemaphore (attrs,
								 initCount,
								 maxCount == 0 ? initCount : maxCount,
								 name);
		if (m_sem == NULL) {
			UtsemWin32Error(L"CreateSempahore returned a NULL handle.", _UTSEM_WIDEN(__FILE__), __LINE__);
		}
	}
	UTSem (HANDLE hSem) : m_sem(hSem) {
		UtsemCheckBool(L"Trying to create a UTSem with a NULL semaphore", 
				  m_sem != NULL, _UTSEM_WIDEN(__FILE__), __LINE__);
	}
	~UTSem() {
		CloseHandle(m_sem);
	}
    void Wait(DWORD dwMilliseconds=INFINITE, BOOL fAlertable=FALSE ) {
		if (WaitForSingleObjectEx (m_sem, dwMilliseconds, fAlertable) == 0xffffffff) {
			UtsemWin32Error(L"WaitForSingleObjectEx fails in UTSem::Wait()", _UTSEM_WIDEN(__FILE__), __LINE__);
		}
	}
	void Incr(ULONG cnt=1) {
		if (! ReleaseSemaphore(m_sem, cnt, NULL)) {
			UtsemWin32Error(L"ReleaseSemaphore fails in UTSem::Incr()", _UTSEM_WIDEN(__FILE__), __LINE__);
		}
	}

private:
	HANDLE m_sem;
};	



//+--------------------------------------------------------------------------
//
//  Class:      UTSemReadWrite
//
//  Purpose:    Shared/Exclusive access services
//
//  Interface:  LockRead		- Grab shared access to resource
//				LockWrite		- Grab exclusive access to resource
//				UnlockRead		- Release shared access to resource
//				UnlockWrite		- Release exclusive access to resource
//				Lock			- Grab shared or exclusive access
//				Unlock			- Release shared or exclusive access
//				
//	Notes:		This class guards a resource in such a way that it can have
//				multiple readers XOR one writer at any one time. It's clever,
//				and won't let writers be starved by a constant flow of
//				readers. Another way of saying this is, it can guard a
//				resource in a way that offers both shared and exclusive
//				access to it.
//				
//				If any thread holds a lock of one sort on a UTSemReadWrite,
//				it had better not grab a second. That way could lay deadlock,
//				matey! Har har har.....
//
//---------------------------------------------------------------------------

typedef enum {SLT_READ, SLT_READPROMOTE, SLT_WRITE}
			 SYNCH_LOCK_TYPE;

class UTSemReadWrite {
public:
	UTSemReadWrite(unsigned long ulcSpinCount = 0);
	~UTSemReadWrite(void);

	void LockRead(void);
	void LockWrite(void);
	void UnlockRead(void);
	void UnlockWrite(void);

	BOOL Lock(SYNCH_LOCK_TYPE t)			// Lock the object, mode specified by parameter
	{
		if (t == SLT_READ)
			LockRead();
		else if (t == SLT_WRITE)
			LockWrite();
		else
			return FALSE;
		return TRUE;
	}

	BOOL UnLock(SYNCH_LOCK_TYPE t)			// Unlock the object, mode specified by parameter
	{
		if (t == SLT_READ)
			UnlockRead();
		else if (t == SLT_WRITE)
			UnlockWrite();
		else
			return FALSE;
		return TRUE;
	}

private:
	HANDLE GetReadWaiterSemaphore(void);
	HANDLE GetWriteWaiterEvent (void);

private:
	unsigned long m_ulcSpinCount;		// spin counter
	volatile unsigned long m_dwFlag;	// internal state, see implementation
	HANDLE m_hReadWaiterSemaphore;		// semaphore for awakening read waiters
	HANDLE m_hWriteWaiterEvent;			// event for awakening write waiters
};


//+--------------------------------------------------------------------------
//
//  Class:      UTSemRWMgrRead
//
//  Purpose:    Holds a read lock on a UTSemReadWrite for the life of object
//
//  Interface:  none
//
//---------------------------------------------------------------------------

class UTSemRWMgrRead {
public:
	UTSemRWMgrRead (UTSemReadWrite* pSemRW) : m_pSemRW(pSemRW) { pSemRW->LockRead(); }
	~UTSemRWMgrRead () { m_pSemRW->UnlockRead(); }

private:
	UTSemReadWrite* m_pSemRW;
};


//+--------------------------------------------------------------------------
//
//  Class:      UTSemRWMgrWrite
//
//  Purpose:    Holds a write lock on a UTSemReadWrite for the life of object
//
//  Interface:  none
//
//---------------------------------------------------------------------------

class UTSemRWMgrWrite
{
public:
	UTSemRWMgrWrite (UTSemReadWrite* pSemRW) : m_pSemRW(pSemRW) { m_pSemRW->LockWrite(); }
	inline ~UTSemRWMgrWrite () { m_pSemRW->UnlockWrite(); }

private:
	UTSemReadWrite* m_pSemRW;
};


#endif __UTSEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\vencodes.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// NOTE: Commonly applicable scodes.

// NOTE: Important! The "*_on_failed_*" macros must not fail-fast.

#ifndef __VENCODES_H_
#	define _VENCODES_H_

// ===============================
// INCLUDES:
// ===============================

#ifdef WIN32								// OLE inclusions:
#	include <objbase.h>                                         
#else
#	include <windows.h>
#	include <ole2.h>
#endif WIN32

// ===============================
// CONSTANTS AND TYPES:
// ===============================

											// @comm HRESULT FIELD VALUES:
// TODO: We need to register our ownership of this facility code with MS OLE!
#define FACILITY_VEN		17				// Venom facility.
#define HR_E				SEVERITY_ERROR	// Error severity alias.
#define HR_S				SEVERITY_SUCCESS// Success severity alias.
#define HR_FAC				FACILITY_VEN	// Our facility alias.

typedef	HRESULT				SRESULT;		// An hr guaranteed to only return S_ codes.

// ===============================
// CONSTANTS AND TYPES: OLE STANDARD ERROR CODES:
// ===============================

											// @comm REMINDER OF THE OLE STANDARD ERROR CODES:
/*
		E_UNEXPECTED						// Unexpected error.
		E_NOTIMPL							// Not implemented.
		E_OUTOFMEMORY						// Out of memory.
		E_INVALIDARG						// Invalid argument.
		E_NOINTERFACE						// No such interface.
		E_POINTER							// Invalid pointer.
		E_HANDLE							// Invalid handle.
		E_ABORT								// Abort.
		E_FAIL								// Fail.
		E_ACCESSDENIED						// Access denied.
*/

// ===============================
// CONSTANTS AND TYPES: MSDTC STANDARD ERROR CODES:
// ===============================

											// @comm SUCCESS CODES:
#define S_CHANGED			MAKE_SCODE (HR_S, HR_FAC, 0x0001)	// Successful change.
#define S_CREATED			MAKE_SCODE (HR_S, HR_FAC, 0x0002)	// Successful creation.
#define S_EXISTS			MAKE_SCODE (HR_S, HR_FAC, 0x0003)	// Successful existence.

											// @comm PARAMETER-BY-ORDER ERROR CODES:
#define E_PARAM1			MAKE_SCODE (HR_E, HR_FAC, 0x0001)	// Parameter 1 verification failed.
#define E_PARAM2			MAKE_SCODE (HR_E, HR_FAC, 0x0002)	// Parameter 2 verification failed.
#define E_PARAM3			MAKE_SCODE (HR_E, HR_FAC, 0x0003)	// Parameter 3 verification failed.
#define E_PARAM4			MAKE_SCODE (HR_E, HR_FAC, 0x0004)	// Parameter 4 verification failed.
#define E_PARAM5			MAKE_SCODE (HR_E, HR_FAC, 0x0005)	// Parameter 5 verification failed.
#define E_PARAM6			MAKE_SCODE (HR_E, HR_FAC, 0x0006)	// Parameter 6 verification failed.
#define E_PARAM7			MAKE_SCODE (HR_E, HR_FAC, 0x0007)	// Parameter 7 verification failed.
#define E_PARAM8			MAKE_SCODE (HR_E, HR_FAC, 0x0008)	// Parameter 8 verification failed.
#define E_PARAM9			MAKE_SCODE (HR_E, HR_FAC, 0x0009)	// Parameter 9 verification failed.
#define E_PARAM10			MAKE_SCODE (HR_E, HR_FAC, 0x000A)	// Parameter 10 verification failed.

											// @comm ALGORITHM PHASE ERROR CODES:
#define E_PRECONDITION		MAKE_SCODE (HR_E, HR_FAC, 0x0011)	// Precondition verification failed.
#define E_INITIALIZATION	MAKE_SCODE (HR_E, HR_FAC, 0x0012)	// Initialization phase failed.
#define	E_OPERATION			MAKE_SCODE (HR_E, HR_FAC, 0x0013)	// Operation itself failed.
#define E_DEINITIALIZATION	MAKE_SCODE (HR_E, HR_FAC, 0x0014)	// De-initialization phase failed.
#define E_POSTCONDITIION	MAKE_SCODE (HR_E, HR_FAC, 0x0015)	// Postcondition verification failed.

											// @comm GENERIC OPERATION ERROR CODES:
#define E_CREATE			MAKE_SCODE (HR_E, HR_FAC, 0x0021)	// Create failed.
#define E_DELETE			MAKE_SCODE (HR_E, HR_FAC, 0x0022)	// Delete failed.
#define E_TRANSFORM			MAKE_SCODE (HR_E, HR_FAC, 0x0023)	// Transform failed.
#define E_SELECT			MAKE_SCODE (HR_E, HR_FAC, 0x0024)	// Select failed.
#define E_COPY				MAKE_SCODE (HR_E, HR_FAC, 0x0025)	// Copy failed.
#define E_MOVE				MAKE_SCODE (HR_E, HR_FAC, 0x0026)	// Move failed.
#define E_GET				MAKE_SCODE (HR_E, HR_FAC, 0x0027)	// Get failed.
#define E_SET				MAKE_SCODE (HR_E, HR_FAC, 0x0028)	// Set failed.
#define E_VIEW				MAKE_SCODE (HR_E, HR_FAC, 0x0029)	// View failed.
#define E_PRINT				MAKE_SCODE (HR_E, HR_FAC, 0x002A)	// Print failed.
#define E_READ				MAKE_SCODE (HR_E, HR_FAC, 0x002B)	// Read failed.
#define E_WRITE				MAKE_SCODE (HR_E, HR_FAC, 0x002C)	// Write failed.
#define E_LOCK				MAKE_SCODE (HR_E, HR_FAC, 0x002D)	// Lock failed.
#define E_UNLOCK			MAKE_SCODE (HR_E, HR_FAC, 0x002E)	// Unlock failed.
#define E_BEGIN				MAKE_SCODE (HR_E, HR_FAC, 0x002F)	// Begin failed.
#define E_END				MAKE_SCODE (HR_E, HR_FAC, 0x0030)	// End failed.
#define E_OPEN				MAKE_SCODE (HR_E, HR_FAC, 0x0031)	// Open failed.
#define E_CLOSE				MAKE_SCODE (HR_E, HR_FAC, 0x0032)	// Close failed.
#define E_CONNECT			MAKE_SCODE (HR_E, HR_FAC, 0x0033)	// Connect failed.
#define E_DISCONNECT		MAKE_SCODE (HR_E, HR_FAC, 0x0034)	// Disconnect failed.
#define E_NEW				MAKE_SCODE (HR_E, HR_FAC, 0x0035)	// new operation failed.

											// @comm RESOURCE ERROR CODES:
#define E_FULL				MAKE_SCODE (HR_E, HR_FAC, 0x0041)	// Capacity is full.
#define E_EXCEEDED			MAKE_SCODE (HR_E, HR_FAC, 0x0042)	// Request exceeded capacity.
#define E_OVERFLOWED		MAKE_SCODE (HR_E, HR_FAC, 0x0043)	// Request overflowed capacity.
#define E_INVALID			MAKE_SCODE (HR_E, HR_FAC, 0x0044)	// Something was invalid.
#define E_UNAVAILABLE		MAKE_SCODE (HR_E, HR_FAC, 0x0045)	// Something was unavailable.
#define E_DENIED			MAKE_SCODE (HR_E, HR_FAC, 0x0046)	// Something was denied.
#define E_EXISTS			MAKE_SCODE (HR_E, HR_FAC, 0x0047)	// Something already exists.

											// @comm ITEM ERROR CODES:
#define E_VALUE				MAKE_SCODE (HR_E, HR_FAC, 0x0051)	// Error with value.
#define E_TYPE				MAKE_SCODE (HR_E, HR_FAC, 0x0052)	// Error with type.
#define E_FORMAT			MAKE_SCODE (HR_E, HR_FAC, 0x0053)	// Error with format.
#define E_CALL				MAKE_SCODE (HR_E, HR_FAC, 0x0054)	// Error with call.
#define E_RETURN			MAKE_SCODE (HR_E, HR_FAC, 0x0055)	// Error with return.

// ===============================
// CONSTANTS AND TYPES: PROJECT SPECIFIC ERROR CODES:
// ===============================

											// @comm ADME codes:
#define S_INPROC			MAKE_SCODE (HR_S, HR_FAC, 0x0101)	// In the process.
#define S_INHOST			MAKE_SCODE (HR_S, HR_FAC, 0x0102)	// In the local host machine.
#define S_INLAN 			MAKE_SCODE (HR_S, HR_FAC, 0x0103)	// In the local area network.
#define S_INNET 			MAKE_SCODE (HR_S, HR_FAC, 0x0104)	// In the world network.

#define E_CR_NOCONTACT		MAKE_SCODE (HR_E, HR_FAC, 0x0101)	// Contact not found.

											// @comm ASPMAN S_CODES 0x0200-0x02FF
#define S_DOINGIT			MAKE_SCODE (HR_S, HR_FAC, 0x0201)
#define S_DIDIT				MAKE_SCODE (HR_S, HR_FAC, 0x0202)

											// Registry collection success codes:
#define S_RCO_ITEMS_INVALID					MAKE_SCODE (HR_S, HR_FAC, 0x0301)

											// Registry collection error codes:
#define E_RCO_ROOT_CONNECT					MAKE_SCODE (HR_E, HR_FAC, 0x0301)
#define E_RCO_ROOT_NOTFOUND					MAKE_SCODE (HR_E, HR_FAC, 0x0302)
#define E_RCO_ROOT_UNEXPECTED				MAKE_SCODE (HR_E, HR_FAC, 0x0303)
#define E_RCO_COUNT_UNEXPECTED				MAKE_SCODE (HR_E, HR_FAC, 0x0304)
#define E_RCO_COUNT_DECREASED				MAKE_SCODE (HR_E, HR_FAC, 0x0305)
#define E_RCO_ITEM_KEYROOT_UNEXPECTED		MAKE_SCODE (HR_E, HR_FAC, 0x0306)
#define E_RCO_ITEM_NONKEYROOT_UNEXPECTED	MAKE_SCODE (HR_E, HR_FAC, 0x0307)
#define E_RCO_ITEM_ASCEND_UNEXPECTED		MAKE_SCODE (HR_E, HR_FAC, 0x0308)
#define E_RCO_PROP_DESCEND_UNEXPECTED		MAKE_SCODE (HR_E, HR_FAC, 0x0309)
#define E_RCO_PROP_CONTENT_UNEXPECTED		MAKE_SCODE (HR_E, HR_FAC, 0x030A)
#define E_RCO_PROP_ASCEND_UNEXPECTED		MAKE_SCODE (HR_E, HR_FAC, 0x030B)

											// Catalog error codes:
// the S-Code version of CAT_OBJECTERRORS is returned from the internal
// catalog interfaces so extended error information can be returned
// on the same call via out-parms
// the E-Code version is issued by the Admin SDK interfaces for
// compatability with VB error handling (see the Admin SDK for detailed
// on how extended error information is obtained)
#define S_CAT_OBJECTERRORS			MAKE_SCODE (HR_S, HR_FAC, 0x0401)	// Some object-level errors occurred
#define E_CAT_OBJECTERRORS			MAKE_SCODE (HR_E, HR_FAC, 0x0401)	// Some object-level errors occurred

#define E_CAT_OBJECTINVALID			MAKE_SCODE (HR_E, HR_FAC, 0x0402)	// Object is inconsistent or damaged
#define E_CAT_KEYMISSING			MAKE_SCODE (HR_E, HR_FAC, 0x0403)	// Object could not be found
#define E_CAT_ALREADYINSTALLED		MAKE_SCODE (HR_E, HR_FAC, 0x0404)	// Component is already installed
#define E_CAT_DOWNLOADFAILED		MAKE_SCODE (HR_E, HR_FAC, 0x0405)	// Could not download files
#define E_CAT_NOINTERFACEINFO		MAKE_SCODE (HR_E, HR_FAC, 0x0406)	// No interface info to download
#define E_CAT_PDFWRITEFAIL			MAKE_SCODE (HR_E, HR_FAC, 0x0407)	// Failure writing to PDF file
#define E_CAT_PDFREADFAIL			MAKE_SCODE (HR_E, HR_FAC, 0x0408)	// Failure reading from PDF file
#define E_CAT_PDFVERSION			MAKE_SCODE (HR_E, HR_FAC, 0x0409)	// Version mismatch in PDF file
#define E_CAT_COREQCOMPINSTALLED	MAKE_SCODE (HR_E, HR_FAC, 0x0435)	// A co-requisite Component is already installed
#define E_CAT_BADPATH				MAKE_SCODE (HR_E, HR_FAC, 0x040A)	// Invalid or no access to source or destination path
#define E_CAT_PACKAGEEXISTS			MAKE_SCODE (HR_E, HR_FAC, 0x040B)	// Installing package already exists
#define E_CAT_ROLEEXISTS			MAKE_SCODE (HR_E, HR_FAC, 0x040C)	// Installing role already exists
#define E_CAT_CANTCOPYFILE			MAKE_SCODE (HR_E, HR_FAC, 0x040D)	// A file cannot be copied 
#define E_CAT_NOTYPELIB				MAKE_SCODE (HR_E, HR_FAC, 0x040E)	// export without typelib fails
#define E_CAT_NOUSER				MAKE_SCODE (HR_E, HR_FAC, 0x040F)	// no such NT user

// same relationship as S_CAT_OBJECTERRORS to E_CAT_OBJECTERRORS above
#define S_CAT_INVALIDUSERIDS		MAKE_SCODE (HR_S, HR_FAC, 0x0410)	// one or all userids in a package (import) are invalid
#define E_CAT_INVALIDUSERIDS		MAKE_SCODE (HR_E, HR_FAC, 0x0410)	// one or all userids in a package (import) are invalid

#define E_CAT_NOREGISTRYCLSID		MAKE_SCODE (HR_E, HR_FAC, 0x0411)
#define E_CAT_BADREGISTRYPROGID		MAKE_SCODE (HR_E, HR_FAC, 0x0412)
#define E_SEC_SETBLANKETFAILED		MAKE_SCODE (HR_E, HR_FAC, 0x0413)
#define E_SEC_USERPASSWDNOTVALID	MAKE_SCODE (HR_E, HR_FAC, 0x0414)	// user/password validation failed.
#define E_CAT_NOREGISTRYREAD		MAKE_SCODE (HR_E, HR_FAC, 0x0415)
#define E_CAT_NOREGISTRYWRITE		MAKE_SCODE (HR_E, HR_FAC, 0x0416)
#define E_CAT_NOREGISTRYREPAIR		MAKE_SCODE (HR_E, HR_FAC, 0x0417)
#define E_CAT_CLSIDORIIDMISMATCH	MAKE_SCODE (HR_E, HR_FAC, 0x0418)	// the GUIDs in the package don't match the component's GUIDs
#define E_CAT_REMOTEINTERFACE		MAKE_SCODE (HR_E, HR_FAC, 0x0419)
#define E_CAT_DLLREGISTERSERVER		MAKE_SCODE (HR_E, HR_FAC, 0x041A)
#define E_CAT_NOSERVERSHARE			MAKE_SCODE (HR_E, HR_FAC, 0x041B)
#define E_CAT_NOACCESSTOUNC			MAKE_SCODE (HR_E, HR_FAC, 0x041C)
#define E_CAT_DLLLOADFAILED			MAKE_SCODE (HR_E, HR_FAC, 0x041D)
#define E_CAT_BADREGISTRYLIBID		MAKE_SCODE (HR_E, HR_FAC, 0x041E)
#define E_CAT_PACKDIRNOTFOUND		MAKE_SCODE (HR_E, HR_FAC, 0x041F)
#define E_CAT_TREATAS				MAKE_SCODE (HR_E, HR_FAC, 0x0420)
#define E_CAT_BADFORWARD			MAKE_SCODE (HR_E, HR_FAC, 0x0421)
#define E_CAT_BADIID				MAKE_SCODE (HR_E, HR_FAC, 0x0422)
#define E_CAT_REGISTRARFAILED		MAKE_SCODE (HR_E, HR_FAC, 0x0423)

// new codes for admin SDK to reflect component install file flags
#define E_CAT_COMPFILE_DOESNOTEXIST		MAKE_SCODE (HR_E, HR_FAC, 0x0424)
#define E_CAT_COMPFILE_LOADDLLFAIL		MAKE_SCODE (HR_E, HR_FAC, 0x0425)
#define E_CAT_COMPFILE_GETCLASSOBJ		MAKE_SCODE (HR_E, HR_FAC, 0x0426)
#define E_CAT_COMPFILE_CLASSNOTAVAIL	MAKE_SCODE (HR_E, HR_FAC, 0x0427)
#define E_CAT_COMPFILE_BADTLB			MAKE_SCODE (HR_E, HR_FAC, 0x0428)
#define E_CAT_COMPFILE_NOTINSTALLABLE	MAKE_SCODE (HR_E, HR_FAC, 0x0429)

#define E_CAT_NOTCHANGEABLE				MAKE_SCODE (HR_E, HR_FAC, 0x042A)
#define E_CAT_NOTDELETEABLE				MAKE_SCODE (HR_E, HR_FAC, 0x042B)
#define E_CAT_SESSVERSION				MAKE_SCODE (HR_E, HR_FAC, 0x042C)
#define E_CAT_COMPMOVELOCKED			MAKE_SCODE (HR_E, HR_FAC, 0x042D)
#define E_CAT_COMPMOVEBADDEST			MAKE_SCODE (HR_E, HR_FAC, 0x042E)
#define E_CAT_PACKACTONLY				MAKE_SCODE (HR_E, HR_FAC, 0x042F)
#define E_CAT_REGISTERTLB				MAKE_SCODE (HR_E, HR_FAC, 0x0430)
#define E_CAT_BADPACKACT				MAKE_SCODE (HR_E, HR_FAC, 0x0431)
#define E_CAT_NOINTERFACEHELPER			MAKE_SCODE (HR_E, HR_FAC, 0x0432)
#define E_CAT_SYSPACKLOCKOUT			MAKE_SCODE (HR_E, HR_FAC, 0x0433)

// another admin SDK code
#define E_CAT_COMPFILE_NOREGISTRAR		MAKE_SCODE (HR_E, HR_FAC, 0x0434)
// Note (defined above):  #define E_CAT_COREQCOMPINSTALLED	MAKE_SCODE (HR_E, HR_FAC, 0x0435)	// A co-requisite Component is already installed

// new codes for secadmin TODO's (Bug 1003 was the impetus).  The conditions
// under which these HRs are issued can be found in password.cpp
#define E_SECADM_LSAOPENPOLICY			MAKE_SCODE (HR_E, HR_FAC, 0x0501)
#define E_SECADM_GETUSERSID				MAKE_SCODE (HR_E, HR_FAC, 0x0502)
#define E_SECADM_EXPECTED_BDC			MAKE_SCODE (HR_E, HR_FAC, 0x0503)
#define E_SECADM_MISSING_NETAPI32		MAKE_SCODE (HR_E, HR_FAC, 0x0504)
#define E_SECADM_NO_PDC_NAME			MAKE_SCODE (HR_E, HR_FAC, 0x0505)
#define E_SECADM_LSAACCOUNTRIGHTS		MAKE_SCODE (HR_E, HR_FAC, 0x0506)

// NOTE: CAT_IS_OBJECT_ERROR should test for any of the object level error codes
#define CAT_IS_OBJECT_ERROR( code )	( \
	   code == E_CAT_KEYMISSING			\
	|| code == E_CAT_OBJECTINVALID		\
	|| code == E_CAT_DOWNLOADFAILED		\
	|| code == E_CAT_ALREADYINSTALLED	\
	|| code == E_CAT_NOINTERFACEINFO	\
	|| code == E_CAT_COREQCOMPINSTALLED \
	|| code == E_CAT_NOREGISTRYCLSID	\
	|| code == E_CAT_BADREGISTRYPROGID	\
	|| code == E_CAT_REMOTEINTERFACE	\
	|| code == E_CAT_NOSERVERSHARE		\
	|| code == E_CAT_NOACCESSTOUNC		\
	|| code == E_CAT_DLLREGISTERSERVER	\
	|| code == E_CAT_DLLLOADFAILED		\
	|| code == E_CAT_BADREGISTRYLIBID	\
	|| code == E_CAT_TREATAS			\
	|| code == E_CAT_BADIID				\
	|| code == E_CAT_BADFORWARD			\
	|| code == E_CAT_REGISTRARFAILED	\
	|| code == E_CAT_NOTCHANGEABLE		\
	|| code == E_CAT_NOTDELETEABLE		\
	|| code == E_CAT_COMPMOVELOCKED		\
	|| code == E_CAT_COMPMOVEBADDEST	\
	|| code == E_CAT_PACKACTONLY		\
	|| code == E_CAT_REGISTERTLB		\
	|| code == E_CAT_BADPACKACT			\
	|| code == E_CAT_NOINTERFACEHELPER	\
	|| code == E_CAT_SYSPACKLOCKOUT		\
	)
//NOTE: CAT_IS_PACKINSTALL_ERROR should test for any of the package install error codes
#define CAT_IS_PACKINSTALL_ERROR( code )	( code == E_CAT_PDFREADFAIL || code == E_CAT_PDFVERSION || code == E_CAT_BADPATH || code == E_CAT_PACKAGEEXISTS || code == E_CAT_ROLEEXISTS || code == E_CAT_CANTCOPYFILE  || code == E_CAT_CLSIDORIIDMISMATCH || code == E_CAT_NOREGISTRYCLSID )
//NOTE: CAT_IS_PACKEXPORT_ERROR should test for any of the package export error codes
#define CAT_IS_PACKEXPORT_ERROR( code )		( code == E_CAT_PDFWRITEFAIL || code == E_CAT_BADPATH || code == E_CAT_CANTCOPYFILE  || code == E_CAT_NOTYPELIB )

											// Regnode error codes:
#define E_RN_NOPERMISSION			MAKE_SCODE (HR_E, HR_FAC, 0x0501)	// Insufficient permission for request.

// ===============================
// MACROS AND INLINES:
// ===============================

// NOTE: These macros do not assert:

#define return_on_error(hr) if (FAILED (hr)) { return hr; }

#define goto_on_error(hr, label) if (FAILED (hr)) { goto label; }

#define return_on_false(assertion, hr) if (!(assertion)) { return hr; }

#define goto_on_false(assertion, hr, ecode, label) if (!(assertion)) { hr = ecode; goto label; }

// NOTE: The *_on_failed_* macros both assert and return:

#define return_on_failed_assertion(assertion, hr) ADMINASSERT (assertion); if (!(assertion)) { return (hr); }

#define return_on_failed_lresult(lr, hr) ADMINASSERT (ERROR_SUCCESS == lr); if (ERROR_SUCCESS != lr) { return (hr); }

#define return_on_failed_hresult(hr) ADMINASSERT (SUCCEEDED (hr)); if (FAILED (hr)) { return (hr); }

#define goto_on_failed_hresult(hr, label) ADMINASSERT (SUCCEEDED (hr)); if (FAILED (hr)) { goto label; }

#define goto_on_failed_assertion(assertion, hr, ecode, label) ADMINASSERT (assertion); if (!(assertion)) { hr = ecode; goto label; }

#endif // ifndef _VENCODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\venstr.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// NOTE: String routines.

#ifndef __VENSTR_H
#	define __VENSTR_H

#include <windows.h>
#include <tchar.h>
#include "vencodes.h"

// TODO: Insure new is of our memory manager and that it asserts.

// -------------------------------
// Function declarations:
// -------------------------------

// VString_CreateCopy: Copy Src to Dest after allocating enough space at Dest with new.
void	VString_CreateCopy (LPCTSTR i_tszSrc, LPTSTR* o_ptszDest);

/* VString_GetNumberOfTChars: 
	Return the number of TCHARs in tsz (whether Unicode, DBCS, or char) excluding the terminator:
		EG:	tsz in Unicode has 3 TCHARs each always of 2 bytes each: 3 is returned.
			tsz in DBCS has 3 DBCS characters, 2 of 1 byte and 1 of 2 bytes: 4 is returned.
			tsz in char has 3 TCHARs each always of 1 byte each: 3 is returned.
*/
size_t	VString_GetNumberOfTChars (LPCTSTR i_tsz);

// -------------------------------
// Function definitions:
// -------------------------------

#ifdef USE_ADMINASSERT
inline void VString_CreateCopy 
(
	LPCTSTR i_tszSrc, 
	LPTSTR* o_ptszDest
)
{
	LPTSTR	tszr;
	
	ADMINASSERT (NULL != i_tszSrc);
	ADMINASSERT (NULL != o_ptszDest);
	*o_ptszDest = new TCHAR [VString_GetNumberOfTChars (i_tszSrc) + 1];
	ADMINASSERT (NULL != *o_ptszDest);
	tszr = lstrcpy (*o_ptszDest, i_tszSrc);
	ADMINASSERT (NULL != tszr);
}
#else
inline void VString_CreateCopy 
(
	LPCTSTR i_tszSrc, 
	LPTSTR* o_ptszDest
)
{
	LPTSTR	tszr;
	
	assert (NULL != i_tszSrc);
	assert (NULL != o_ptszDest);
	*o_ptszDest = new TCHAR [VString_GetNumberOfTChars (i_tszSrc) + 1];
	assert (NULL != *o_ptszDest);
	tszr = lstrcpy (*o_ptszDest, i_tszSrc);
	assert (NULL != tszr);
}
#endif

inline size_t VString_GetNumberOfTChars
(
	LPCTSTR	i_tsz
)
{
	if (NULL != i_tsz)
	{
#ifdef _UNICODE
		return (size_t) lstrlen (i_tsz);
#else
		return (size_t) strlen (i_tsz);
#endif _UNICODE
	}
	else
	{
		return (size_t) 0;
	}
}

#endif !__VENSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\vipinterlockedcompareexchange.h ===
#ifndef __VIPINTERLOCKEDCOMPAREEXCHANGE_H__
#define __VIPINTERLOCKEDCOMPAREEXCHANGE_H__

#ifdef __cplusplus

#ifndef _WIN64

#undef InterlockedCompareExchange
#undef InterlockedCompareExchangePointer

#define InterlockedCompareExchange          VipInterlockedCompareExchange
#define InterlockedCompareExchangePointer   VipInterlockedCompareExchange

#endif
/* ----------------------------------------------------------------------------
@function VipInterlockedCompareExchange:
    This function is exactly equivalent to the system-defined InterlockedCompareExchange,
    except that it is inline, and therefore works on Win95.

    It does the following atomically:
    {
        temp = *Destination;
        if (*Destination == Comperand)
            *Destination = Exchange;
        return temp;
    }

    This function occufrs in three variations, for parameters of type void*,
    long, and unsigned long.

    @rev    0   | 13 Jun 97 | JimLyon       | Created
                | 14 May 98 | Brianbec      | for IA64, the 1st one is really equivalent
                                            | to I.C.E.Pointer in wdm.h, not to 
                                            | I.C.E. raw, itself, alone.  Note 
                                            | that the SDK64 version doesn't understand
                                            | volatile, so I crossed my fingers and
                                            | casted it away. 
---------------------------------------------------------------------------- */

#pragma warning(disable:4035)
#pragma warning(disable:4717)     // function doesn't return value warning.
inline void* VipInterlockedCompareExchange (void*volatile* Destination, void* Exchange, void* Comparand)
{
#   ifdef _X86_
        __asm
        {
            mov     eax, Comparand
            mov     ecx, Destination
            mov     edx, Exchange
            lock cmpxchg [ecx], edx
        }           // function result is in eax
#   else
#       ifdef _WIN64
            return InterlockedCompareExchangePointer
            (
                (void**)Destination, Exchange, Comparand
            ) ;
#       else
            return (void *)InterlockedCompareExchange ((void**) Destination, Exchange, Comparand);
#       endif // _WIN64
#   endif // _X86_
}
#pragma warning (default: 4035; disable: 4717)     // function doesn't return value warning

inline long VipInterlockedCompareExchange (volatile long* Destination, long Exchange, long Comparand)
{
    return PtrToLong(VipInterlockedCompareExchange ((void*volatile*) Destination, LongToPtr(Exchange), LongToPtr(Comparand)));
}

inline unsigned long VipInterlockedCompareExchange (volatile unsigned long* Destination, unsigned long Exchange, unsigned long Comparand)
{
    return PtrToUlong(VipInterlockedCompareExchange ((void*volatile*) Destination, ULongToPtr(Exchange), ULongToPtr(Comparand)));
}
#endif

#endif __VIPINTERLOCKEDCOMPAREEXCHANGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\waitfncs.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#pragma once

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500
#define _WIN32_IE	 0x0500
#endif // !defined(_WIN32_WINNT)



#ifndef WT_EXECUTEDEFAUT
	#define WT_EXECUTEDEFAULT       0x00000000                           // winnt
	#define WT_EXECUTEINIOTHREAD    0x00000001                           // winnt
	#define WT_EXECUTEINUITHREAD    0x00000002                           // winnt
	#define WT_EXECUTEINWAITTHREAD  0x00000004                           // winnt
	#define WT_EXECUTEONLYONCE      0x00000008                           // winnt
	#define WT_EXECUTEINTIMERTHREAD 0x00000020                           // winnt
	#define WT_EXECUTELONGFUNCTION  0x00000010                           // winnt
#endif

typedef VOID   (NTAPI * WAITORTIMERCALLBACK )(PVOID, BOOLEAN);
typedef HANDLE (WINAPI * PFN_SetTimerQueueTimer)(HANDLE, WAITORTIMERCALLBACK, PVOID, DWORD, DWORD, BOOL);
typedef HANDLE (WINAPI * PFN_RegisterWaitForSingleObjectEx)(HANDLE, WAITORTIMERCALLBACK, PVOID, ULONG, ULONG);
typedef BOOL   (WINAPI * PFN_RegisterWaitForSingleObject)(PHANDLE, HANDLE, WAITORTIMERCALLBACK, PVOID, ULONG, ULONG);
typedef BOOL   (WINAPI * PFN_UnregisterWait)(HANDLE);
typedef BOOL   (WINAPI * PFN_ChangeTimerQueueTimer)(HANDLE, HANDLE, ULONG, ULONG);
typedef BOOL   (WINAPI * PFN_CancelTimerQueueTimer)(HANDLE, HANDLE);



#define NT_BUILD_WHERE_REGWAIT_CHANGED	1960	 // needs to be updated when they actually checkin

//
//	new versions of the above APIs
//
class CWaitFunctions
{
private:

	static PFN_RegisterWaitForSingleObjectEx    sm_pfnRegWaitEx;    
	static PFN_UnregisterWait                   sm_pfnUnRegWait;    
	static PFN_RegisterWaitForSingleObject      sm_pfnRegWait;      
	static PFN_SetTimerQueueTimer               sm_pfnSetTimerQueueTimer;
	static PFN_ChangeTimerQueueTimer            sm_pfnChangeTimerQueueTimer;
	static PFN_CancelTimerQueueTimer            sm_pfnCancelTimerQueueTimer;
	


public:

    CWaitFunctions();
	
	static BOOL RegisterWaitForSingleObject(   HANDLE * phRet,
										HANDLE hObject, 
										WAITORTIMERCALLBACK pfnCb, 
										PVOID pv, 
										DWORD dwMS, 
										DWORD dwFlags);

	static HANDLE SetTimerQueueTimer( HANDLE hTimer, 
							   WAITORTIMERCALLBACK pfnCB, 
							   PVOID pv, 
							   DWORD dwStart, 
							   DWORD dwInterval, 
							   BOOL bUseIo)
	{
		return  sm_pfnSetTimerQueueTimer(hTimer, pfnCB, pv, dwStart, dwInterval, bUseIo);
	}

	static BOOL UnRegisterWait(HANDLE hWait){return sm_pfnUnRegWait(hWait);}


	static BOOL ChangeTimerQueueTimer(
							  HANDLE TimerQueue,
							  HANDLE Timer,
							  ULONG DueTime,
							  ULONG Period
							  )
	{
		return sm_pfnChangeTimerQueueTimer(TimerQueue, Timer, DueTime, Period);
	}

	static BOOL CancelTimerQueueTimer(HANDLE TimerQueue,
							   HANDLE Timer
							  )
	{
		return  sm_pfnCancelTimerQueueTimer(TimerQueue, Timer);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\wassec.h ===
#pragma once

// this class providers security attributes to acl files such that only local 
// system and admins can have access to them.
class CWASSecurity
{
public:
	CWASSecurity() : 	m_psidSystem(0), m_psidAdmin(0), m_paclDiscretionary(0), m_psdStorage(0)
	{}

	~CWASSecurity();
	HRESULT Init();

	PSECURITY_DESCRIPTOR GetSecurityDescriptor()
	{
		return m_psdStorage;
	}

	PACL GetDacl()
	{
		return m_paclDiscretionary;
	}

private:
	PSID		m_psidSystem;
	PSID		m_psidAdmin;
	PACL		m_paclDiscretionary;
	PSECURITY_DESCRIPTOR m_psdStorage;
};

extern CWASSecurity g_WASSecurity;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\writer.h ===
#ifndef _WRITER_H
#define _WRITER_H

//
// Forward declaration 
//
class CLocationWriter;
class CCatalogSchemaWriter;

enum eWriter
{
	eWriter_Schema,
	eWriter_Metabase
};

class CWriter
{

	public:

		CWriter();

		~CWriter();

		HRESULT Initialize(LPCWSTR wszFile,
						   HANDLE  hFile);

		HRESULT WriteToFile(LPVOID	pvData,
							SIZE_T	cchData,
							BOOL    bForceFlush = FALSE);

		HRESULT BeginWrite(eWriter eType);

		HRESULT GetLocationWriter(CLocationWriter** ppLocationWriter,
								  LPCWSTR           wszLocation);

		HRESULT GetCatalogSchemaWriter(CCatalogSchemaWriter** ppSchemaWriter);

		HRESULT EndWrite(eWriter eType);

	private:
		HRESULT FlushBufferToDisk();

		HRESULT SetSecurityDescriptor();

	private:
		LPWSTR				m_wszFile;
		BOOL				m_bCreatedFile;

	public:
		HANDLE					m_hFile;
		CWriterGlobalHelper*	m_pCWriterGlobalHelper;
		PSID                    m_psidSystem;
		PSID                    m_psidAdmin;
		PACL                    m_paclDiscretionary;
		PSECURITY_DESCRIPTOR    m_psdStorage;

}; // Class CWriter

#endif // _WRITER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\writerglobalhelper.h ===
#ifndef _WRITER_GLOBAL_HELPER_H_
#define _WRITER_GLOBAL_HELPER_H_

enum eESCAPE{
	eNoESCAPE=0,
	eESCAPEgt,
	eESCAPElt,
	eESCAPEquote,
	eESCAPEamp,
	eESCAPEashex,
	eESCAPEillegalxml
};

class CWriterGlobalHelper
{
	public:

		CWriterGlobalHelper();
		~CWriterGlobalHelper();
		HRESULT InitializeGlobals();

	private:
		
		HRESULT InitializeGlobalLengths();
		HRESULT GetInternalTableName(ISimpleTableDispenser2*  i_pISTDisp,
								     LPCWSTR                  i_wszTableName,
									 LPWSTR*                  o_wszInternalTableName);

	public:

		HRESULT ToString(PBYTE   pbData,
						 DWORD   cbData,
						 DWORD   dwIdentifier,
						 DWORD   dwDataType,
						 DWORD   dwAttributes,
						 LPWSTR* pwszData);

		HRESULT FlagToString(DWORD      dwValue,
					         LPWSTR*    pwszData,
						     LPWSTR     wszTable,
						     ULONG      iColFlag);

		HRESULT EnumToString(DWORD      dwValue,
					         LPWSTR*    pwszData,
						     LPWSTR     wszTable,
						     ULONG      iColEnum);

		HRESULT EscapeString(LPCWSTR wszString,
                             BOOL*   pbEscaped,
							 LPWSTR* pwszEscapedString);

		HRESULT GetUserType(DWORD   i_dwUserType,
                            LPWSTR* o_pwszUserType,
						    ULONG*  o_cchUserType,
						    BOOL*   o_bAllocedUserType);
	private:

		HRESULT BoolToString(DWORD      dwValue,
			                 LPWSTR*    pwszData);


		HRESULT GetStartRowIndex(LPWSTR    wszTable,
                                 ULONG     iColFlag,
							     ULONG*    piStartRow);

		inline int  StringInsensitiveCompare(LPCWSTR wsz1, LPCWSTR wsz2) const {if(wsz1 == wsz2) return 0; else return _wcsicmp(wsz1, wsz2);}

		eESCAPE GetEscapeType(WCHAR i_wChar);

	public:
		
		ISimpleTableRead2*	m_pISTTagMetaMBPropertyIndx1;
		ISimpleTableRead2*	m_pISTTagMetaMBPropertyIndx2;
		ISimpleTableRead2*	m_pISTTagMetaIIsConfigObject;
		ISimpleTableRead2*	m_pISTColumnMeta;
		ISimpleTableRead2*  m_pISTColumnMetaForFlags;
		ULONG	            m_cColKeyTypeMetaData;
//		ULONG				m_aColKeyTypeMetaData[cCOLUMNMETA_NumberOfColumns];
		LPVOID				m_apvKeyTypeMetaData[cCOLUMNMETA_NumberOfColumns];
		LPWSTR              m_wszTABLE_MBProperty;
		LPWSTR              m_wszTABLE_IIsConfigObject;
		int					m_iStartRowForAttributes;               
		LPWSTR              m_wszIIS_MD_UT_SERVER;
		ULONG	            m_cchIIS_MD_UT_SERVER;
		LPWSTR              m_wszIIS_MD_UT_FILE;
		ULONG	            m_cchIIS_MD_UT_FILE;
		LPWSTR              m_wszIIS_MD_UT_WAM;
		ULONG	            m_cchIIS_MD_UT_WAM;
		LPWSTR              m_wszASP_MD_UT_APP;
		ULONG	            m_cchASP_MD_UT_APP;

}; // CWriterGlobalHelper

#endif _WRITER_GLOBAL_HELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\writerglobals.h ===
extern LPCWSTR	g_wszBeginFile;					
extern SIZE_T	g_cchBeginFile;					
extern LPCWSTR	g_wszEndFile;					
extern SIZE_T	g_cchEndFile;					
extern LPCWSTR	g_BeginLocation;
extern SIZE_T	g_cchBeginLocation;				
extern LPCWSTR	g_Location;						
extern SIZE_T	g_cchLocation;					
extern LPCWSTR	g_EndLocationBegin;				
extern SIZE_T	g_cchEndLocationBegin;			
extern LPCWSTR	g_EndLocationEnd;				
extern SIZE_T	g_cchEndLocationEnd;				
extern LPCWSTR  g_CloseQuoteBraceRtn;			
extern SIZE_T	g_cchCloseQuoteBraceRtn;			
extern LPCWSTR  g_Rtn;							
extern SIZE_T	g_cchRtn;						
extern LPCWSTR  g_EqQuote;						
extern SIZE_T	g_cchEqQuote;					
extern LPCWSTR  g_QuoteRtn;						
extern SIZE_T	g_cchQuoteRtn;					
extern LPCWSTR  g_TwoTabs;						
extern SIZE_T	g_cchTwoTabs;					
extern LPCWSTR	g_NameEq;						
extern SIZE_T	g_cchNameEq;						
extern LPCWSTR	g_IDEq;							
extern SIZE_T	g_cchIDEq;						
extern LPCWSTR	g_ValueEq;						
extern SIZE_T	g_cchValueEq;					
extern LPCWSTR	g_TypeEq;						
extern SIZE_T	g_cchTypeEq;						
extern LPCWSTR	g_UserTypeEq;					
extern SIZE_T	g_cchUserTypeEq;					
extern LPCWSTR	g_AttributesEq;					
extern SIZE_T	g_cchAttributesEq;				
extern LPCWSTR	g_BeginGroup;					
extern SIZE_T	g_cchBeginGroup;					
extern LPCWSTR	g_EndGroup;						
extern SIZE_T	g_cchEndGroup;					
extern LPCWSTR	g_BeginCustomProperty;			
extern SIZE_T	g_cchBeginCustomProperty;		
extern LPCWSTR	g_EndCustomProperty;				
extern SIZE_T	g_cchEndCustomProperty;			
extern LPCWSTR	g_ZeroHex;						
extern SIZE_T	g_cchZeroHex;
extern LPCWSTR	g_wszIIsConfigObject;

extern WORD    BYTE_ORDER_MASK;
extern DWORD	UTF8_SIGNATURE;

extern LPWSTR  g_wszByID;
extern LPWSTR  g_wszByTableAndColumnIndexOnly;
extern LPWSTR  g_wszByTableAndColumnIndexAndNameOnly;
extern LPWSTR  g_wszByTableAndColumnIndexAndValueOnly;
extern LPWSTR  g_wszUnknownName;
extern SIZE_T  g_cchUnknownName;             
extern LPWSTR  g_UT_Unknown;
extern SIZE_T  g_cchUT_Unknown;
extern LPWSTR  g_T_Unknown;
extern LPWSTR  g_wszTrue;
extern LPWSTR  g_wszFalse;
extern SIZE_T  g_cchMaxBoolStr;

extern SIZE_T g_cchTemp;
extern WCHAR  g_wszTemp[];
extern LPCWSTR g_wszBeginSchema;
extern SIZE_T  g_cchBeginSchema;
extern LPCWSTR g_wszEndSchema;
extern SIZE_T  g_cchEndSchema;
extern LPCWSTR g_wszBeginCollection;
extern SIZE_T  g_cchBeginCollection;
extern LPCWSTR g_wszSchemaGen;
extern SIZE_T  g_cchSchemaGen;
extern LPCWSTR g_wszInheritsFrom;
extern SIZE_T  g_cchInheritsFrom;
extern LPCWSTR g_wszEndCollection;
extern SIZE_T  g_cchEndCollection;
extern LPCWSTR g_wszBeginPropertyShort; 
extern SIZE_T  g_cchBeginPropertyShort;
extern LPCWSTR g_wszMetaFlagsExEq;
extern SIZE_T  g_cchMetaFlagsExEq;
extern LPCWSTR g_wszMetaFlagsEq;
extern SIZE_T  g_cchMetaFlagsEq;
extern LPCWSTR g_wszEndPropertyShort; 
extern SIZE_T  g_cchEndPropertyShort; 
extern LPCWSTR g_wszBeginPropertyLong;
extern SIZE_T  g_cchBeginPropertyLong;
extern LPCWSTR g_wszPropIDEq;
extern SIZE_T  g_cchPropIDEq;
extern LPCWSTR g_wszPropTypeEq;
extern SIZE_T  g_cchPropTypeEq;
extern LPCWSTR g_wszPropUserTypeEq;
extern SIZE_T  g_cchPropUserTypeEq;
extern LPCWSTR g_wszPropAttributeEq;
extern SIZE_T  g_cchPropAttributeEq;
extern LPWSTR  g_wszPropMetaFlagsEq; 
extern SIZE_T  g_cchPropMetaFlagsEq; 
extern LPWSTR  g_wszPropMetaFlagsExEq;
extern SIZE_T  g_cchPropMetaFlagsExEq;
extern LPWSTR  g_wszPropDefaultEq;    
extern SIZE_T  g_cchPropDefaultEq;    
extern LPWSTR  g_wszPropMinValueEq;   
extern SIZE_T  g_cchPropMinValueEq;   
extern LPWSTR  g_wszPropMaxValueEq;   
extern SIZE_T  g_cchPropMaxValueEq;  
extern LPWSTR  g_wszEndPropertyLongNoFlag;
extern SIZE_T  g_cchEndPropertyLongNoFlag;
extern LPWSTR  g_wszEndPropertyLongBeforeFlag;
extern SIZE_T  g_cchEndPropertyLongBeforeFlag;
extern LPWSTR  g_wszEndPropertyLongAfterFlag;
extern SIZE_T  g_cchEndPropertyLongAfterFlag; 
extern LPCWSTR g_wszBeginFlag; 
extern SIZE_T  g_cchBeginFlag; 
extern LPCWSTR g_wszFlagValueEq;   
extern SIZE_T  g_cchFlagValueEq;   
extern LPCWSTR g_wszEndFlag;
extern SIZE_T  g_cchEndFlag;
extern LPCWSTR g_wszEndPropertyShort;
extern LPCWSTR g_wszContainerClassListEq;
extern SIZE_T  g_cchContainerClassListEq;
extern LPCWSTR g_wszFlagIDEq;
extern SIZE_T  g_cchFlagIDEq;
extern LPCWSTR g_aSynIDToWszType[];
extern LPCWSTR g_wszOr;
extern SIZE_T  g_cchOr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\winwrap.h ===
//*****************************************************************************
// WinWrap.h
//
// This file contains wrapper functions for Win32 API's that take strings.
// Support on each platform works as follows:
//      OS          Behavior
//      ---------   -------------------------------------------------------
//      NT          Fully supports both W and A funtions.
//      Win 9x      Supports on A functions, stubs out the W functions but
//                      then fails silently on you with no warning.
//      CE          Only has the W entry points.
//
// COM+ internally uses UNICODE as the internal state and string format.  This
// file will undef the mapping macros so that one cannot mistakingly call a
// method that isn't going to work.  Instead, you have to call the correct
// wrapper API.
//
// Copyright (c) 1997-1998, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#pragma once


//********** Macros. **********************************************************
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif
#if !defined(WIN32_LEAN_AND_MEAN)
#define INC_OLE2
#endif




//********** Includes. ********************************************************


#include "..\complib\inc\crtwrap.h"
#include <windows.h>
#include "VipInterlockedCompareExchange.h"

#if (!defined(__TODO_PORT_TO_WRAPPERS__) && !defined( UNDER_CE ))
//*****************************************************************************
// Undefine all of the windows wrappers so you can't use them.
//*****************************************************************************

// winbase.h
#undef GetBinaryType
#undef GetShortPathName
#undef GetLongPathName
#undef GetEnvironmentStrings  
#undef FreeEnvironmentStrings  
#undef FormatMessage  
#undef CreateMailslot  
#undef EncryptFile  
#undef DecryptFile  
#undef OpenRaw  
#undef QueryRecoveryAgents  
#undef lstrcmp  
#undef lstrcmpi  
#undef lstrcpyn  
#undef lstrcpy  
#undef lstrcat
  
#ifndef _WIN64
#undef InterlockedCompareExchange
#undef InterlockedCompareExchangePointer
#endif // _WIN64

//#undef lstrlen	Note: lstrlenW works on Win9x
#undef CreateMutex  
#undef OpenMutex  
#undef CreateEvent  
#undef OpenEvent  
#undef CreateSemaphore  
#undef OpenSemaphore  
#undef CreateWaitableTimer  
#undef OpenWaitableTimer  
#undef CreateFileMapping  
#undef OpenFileMapping  
#undef GetLogicalDriveStrings  
#undef LoadLibrary  
#undef LoadLibraryEx  
#undef GetModuleFileName  
#undef GetModuleHandle  
#undef CreateProcess  
#undef FatalAppExit  
#undef GetStartupInfo  
#undef GetCommandLine  
#undef GetEnvironmentVariable  
#undef SetEnvironmentVariable  
#undef ExpandEnvironmentStrings  
#undef OutputDebugString  
#undef FindResource  
#undef FindResourceEx  
#undef EnumResourceTypes  
#undef EnumResourceNames  
#undef EnumResourceLanguages  
#undef BeginUpdateResource  
#undef UpdateResource  
#undef EndUpdateResource  
#undef GlobalAddAtom  
#undef GlobalFindAtom  
#undef GlobalGetAtomName  
#undef AddAtom  
#undef FindAtom  
#undef GetAtomName  
#undef GetProfileInt  
#undef GetProfileString  
#undef WriteProfileString  
#undef GetProfileSection  
#undef WriteProfileSection  
#undef GetPrivateProfileInt  
#undef GetPrivateProfileString  
#undef WritePrivateProfileString  
#undef GetPrivateProfileSection  
#undef WritePrivateProfileSection  
#undef GetPrivateProfileSectionNames  
#undef GetPrivateProfileStruct  
#undef WritePrivateProfileStruct  
#undef GetDriveType  
#undef GetSystemDirectory  
#undef GetTempPath  
#undef GetTempFileName  
#undef GetWindowsDirectory  
#undef SetCurrentDirectory  
#undef GetCurrentDirectory  
#undef GetDiskFreeSpace  
#undef GetDiskFreeSpaceEx  
#undef CreateDirectory  
#undef CreateDirectoryEx  
#undef RemoveDirectory  
#undef GetFullPathName  
#undef DefineDosDevice  
#undef QueryDosDevice  
#undef CreateFile  
#undef SetFileAttributes  
#undef GetFileAttributes  
#undef GetFileAttributesEx  
#undef GetCompressedFileSize  
#undef DeleteFile  
#undef FindFirstFileEx  
#undef FindFirstFile  
#undef FindNextFile  
#undef SearchPath  
#undef CopyFile  
#undef CopyFileEx  
#undef MoveFile  
#undef MoveFileEx  
#undef MoveFileWithProgress  
#undef CreateSymbolicLink  
#undef QuerySymbolicLink  
#undef CreateHardLink  
#undef CreateNamedPipe  
#undef GetNamedPipeHandleState  
#undef CallNamedPipe  
#undef WaitNamedPipe  
#undef SetVolumeLabel  
#undef GetVolumeInformation  
#undef ClearEventLog  
#undef BackupEventLog  
#undef OpenEventLog  
#undef RegisterEventSource  
#undef OpenBackupEventLog  
#undef ReadEventLog  
#undef ReportEvent  
#undef AccessCheckAndAuditAlarm  
#undef AccessCheckByTypeAndAuditAlarm  
#undef AccessCheckByTypeResultListAndAuditAlarm  
#undef ObjectOpenAuditAlarm  
#undef ObjectPrivilegeAuditAlarm  
#undef ObjectCloseAuditAlarm  
#undef ObjectDeleteAuditAlarm  
#undef PrivilegedServiceAuditAlarm  
#undef SetFileSecurity  
#undef GetFileSecurity  
#undef FindFirstChangeNotification  
#undef IsBadStringPtr  
#undef LookupAccountSid  
#undef LookupAccountName  
#undef LookupPrivilegeValue  
#undef LookupPrivilegeName  
#undef LookupPrivilegeDisplayName  
#undef BuildCommDCB  
#undef BuildCommDCBAndTimeouts  
#undef CommConfigDialog  
#undef GetDefaultCommConfig  
#undef SetDefaultCommConfig  
#undef GetComputerName  
#undef SetComputerName  
#undef GetUserName  
#undef LogonUser  
#undef CreateProcessAsUser  
#undef GetCurrentHwProfile  
#undef GetVersionEx  
#undef CreateJobObject  
#undef OpenJobObject  

// winuser.h
#undef MAKEINTRESOURCE  
#undef wvsprintf  
#undef wsprintf  
#undef LoadKeyboardLayout  
#undef GetKeyboardLayoutName  
#undef CreateDesktop  
#undef OpenDesktop  
#undef EnumDesktops  
#undef CreateWindowStation  
#undef OpenWindowStation  
#undef EnumWindowStations  
#undef GetUserObjectInformation  
#undef SetUserObjectInformation  
#undef RegisterWindowMessage  
#undef SIZEZOOMSHOW        
#undef WS_TILEDWINDOW      
#undef GetMessage  
#undef DispatchMessage  
#undef PeekMessage  
#undef SendMessage  
#undef SendMessageTimeout  
#undef SendNotifyMessage  
#undef SendMessageCallback  
#undef BroadcastSystemMessage  
#undef RegisterDeviceNotification  
#undef PostMessage  
#undef PostThreadMessage  
#undef PostAppMessage  
#undef DefWindowProc  
#undef CallWindowProc  
#undef CallWindowProc  
#undef RegisterClass  
#undef UnregisterClass  
#undef GetClassInfo  
#undef RegisterClassEx  
#undef GetClassInfoEx  
#undef CreateWindowEx  
#undef CreateWindow  
#undef CreateDialogParam  
#undef CreateDialogIndirectParam  
#undef CreateDialog  
#undef CreateDialogIndirect  
#undef DialogBoxParam  
#undef DialogBoxIndirectParam  
#undef DialogBox  
#undef DialogBoxIndirect  
#undef SetDlgItemText  
#undef GetDlgItemText  
#undef SendDlgItemMessage  
#undef DefDlgProc  
#undef CallMsgFilter  
#undef RegisterClipboardFormat  
#undef GetClipboardFormatName  
#undef CharToOem  
#undef OemToChar  
#undef CharToOemBuff  
#undef OemToCharBuff  
#undef CharUpper  
#undef CharUpperBuff  
#undef CharLower  
#undef CharLowerBuff  
#undef CharNext  
//@todo: Does 95 support this? #undef CharPrev  
#undef IsCharAlpha  
#undef IsCharAlphaNumeric  
#undef IsCharUpper  
#undef IsCharLower  
#undef GetKeyNameText  
#undef VkKeyScan  
#undef VkKeyScanEx  
#undef MapVirtualKey  
#undef MapVirtualKeyEx  
#undef LoadAccelerators  
#undef CreateAcceleratorTable  
#undef CopyAcceleratorTable  
#undef TranslateAccelerator  
#undef LoadMenu  
#undef LoadMenuIndirect  
#undef ChangeMenu  
#undef GetMenuString  
#undef InsertMenu  
#undef AppendMenu  
#undef ModifyMenu  
#undef InsertMenuItem  
#undef GetMenuItemInfo  
#undef SetMenuItemInfo  
#undef DrawText  
#undef DrawTextEx  
#undef GrayString  
#undef DrawState  
#undef TabbedTextOut  
#undef GetTabbedTextExtent  
#undef SetProp  
#undef GetProp  
#undef RemoveProp  
#undef EnumPropsEx  
#undef EnumProps  
#undef SetWindowText  
#undef GetWindowText  
#undef GetWindowTextLength  
#undef MessageBox  
#undef MessageBoxEx  
#undef MessageBoxIndirect  
#undef COLOR_3DSHADOW          
#undef GetWindowLong  
#undef SetWindowLong  
#undef GetClassLong  
#undef SetClassLong  
#undef FindWindow  
#undef FindWindowEx  
#undef GetClassName  
#undef SetWindowsHook  
#undef SetWindowsHook  
#undef SetWindowsHookEx  
#undef MFT_OWNERDRAW       
#undef LoadBitmap  
#undef LoadCursor  
#undef LoadCursorFromFile  
#undef LoadIcon  
#undef LoadImage  
#undef LoadString  
#undef IsDialogMessage  
#undef DlgDirList  
#undef DlgDirSelectEx  
#undef DlgDirListComboBox  
#undef DlgDirSelectComboBoxEx  
#undef DefFrameProc  
#undef DefMDIChildProc  
#undef CreateMDIWindow  
#undef WinHelp  
#undef ChangeDisplaySettings  
#undef ChangeDisplaySettingsEx  
#undef EnumDisplaySettings  
#undef EnumDisplayDevices  
#undef SystemParametersInfo  
#undef GetMonitorInfo  
#undef GetWindowModuleFileName  
#undef RealGetWindowClass  
#undef GetAltTabInfo

#undef RegOpenKeyEx 
#undef RegOpenKey 
#undef RegEnumKeyEx 
#undef RegDeleteKey 
#undef RegSetValueEx
#undef RegCreateKeyEx 
#undef RegDeleteKey 
#undef RegQueryValue
#undef RegQueryValueEx 

//
// Win CE only supports the wide entry points, no ANSI.  So we redefine
// the wrappers right back to the *W entry points as macros.  This way no
// client code needs a wrapper on CE.
//
#elif defined( UNDER_CE )
// winbase.h
#define WszGetBinaryType GetBinaryTypeW
#define WszGetShortPathName GetShortPathNameW
#define WszGetLongPathName GetLongPathNameW
#define WszGetEnvironmentStrings   GetEnvironmentStringsW
#define WszFreeEnvironmentStrings   FreeEnvironmentStringsW
#define WszFormatMessage   FormatMessageW
#define WszCreateMailslot   CreateMailslotW
#define WszEncryptFile   EncryptFileW
#define WszDecryptFile   DecryptFileW
#define WszOpenRaw   OpenRawW
#define WszQueryRecoveryAgents   QueryRecoveryAgentsW
#define Wszlstrcmp   lstrcmpW
#define Wszlstrcmpi   lstrcmpiW
#define Wszlstrcpy lstrcpyW
#define Wszlstrcat lstrcatW
#define WszCreateMutex CreateMutexW
#define WszOpenMutex OpenMutexW
#define WszCreateEvent CreateEventW
#define WszOpenEvent OpenEventW
#define WszCreateWaitableTimer CreateWaitableTimerW
#define WszOpenWaitableTimer OpenWaitableTimerW
#define WszCreateFileMapping CreateFileMappingW
#define WszOpenFileMapping OpenFileMappingW
#define WszGetLogicalDriveStrings GetLogicalDriveStringsW
#define WszLoadLibrary LoadLibraryW
#define WszLoadLibraryEx LoadLibraryExW
#define WszGetModuleFileName GetModuleFileNameW
#define WszGetModuleHandle GetModuleHandleW
#define WszCreateProcess CreateProcessW
#define WszFatalAppExit FatalAppExitW
#define WszGetStartupInfo GetStartupInfoW
#define WszGetCommandLine GetCommandLineW
#define WszGetEnvironmentVariable GetEnvironmentVariableW
#define WszSetEnvironmentVariable SetEnvironmentVariableW
#define WszExpandEnvironmentStrings ExpandEnvironmentStringsW
#define WszOutputDebugString OutputDebugStringW
#define WszFindResource FindResourceW
#define WszFindResourceEx FindResourceExW
#define WszEnumResourceTypes EnumResourceTypesW
#define WszEnumResourceNames EnumResourceNamesW
#define WszEnumResourceLanguages EnumResourceLanguagesW
#define WszBeginUpdateResource BeginUpdateResourceW
#define WszUpdateResource UpdateResourceW
#define WszEndUpdateResource EndUpdateResourceW
#define WszGlobalAddAtom GlobalAddAtomW
#define WszGlobalFindAtom GlobalFindAtomW
#define WszGlobalGetAtomName GlobalGetAtomNameW
#define WszAddAtom AddAtomW
#define WszFindAtom FindAtomW
#define WszGetAtomName GetAtomNameW
#define WszGetProfileInt GetProfileIntW
#define WszGetProfileString GetProfileStringW
#define WszWriteProfileString WriteProfileStringW
#define WszGetProfileSection GetProfileSectionW
#define WszWriteProfileSection WriteProfileSectionW
#define WszGetPrivateProfileInt GetPrivateProfileIntW
#define WszGetPrivateProfileString GetPrivateProfileStringW
#define WszWritePrivateProfileString WritePrivateProfileStringW
#define WszGetPrivateProfileSection GetPrivateProfileSectionW
#define WszWritePrivateProfileSection WritePrivateProfileSectionW
#define WszGetPrivateProfileSectionNames GetPrivateProfileSectionNamesW
#define WszGetPrivateProfileStruct GetPrivateProfileStructW
#define WszWritePrivateProfileStruct WritePrivateProfileStructW
#define WszGetDriveType GetDriveTypeW
#define WszGetSystemDirectory GetSystemDirectoryW
#define WszGetTempPath GetTempPathW
#define WszGetTempFileName GetTempFileNameW
#define WszGetWindowsDirectory GetWindowsDirectoryW
#define WszSetCurrentDirectory SetCurrentDirectoryW
#define WszGetCurrentDirectory GetCurrentDirectoryW
#define WszGetDiskFreeSpace GetDiskFreeSpaceW
#define WszGetDiskFreeSpaceEx GetDiskFreeSpaceExW
#define WszCreateDirectory CreateDirectoryW
#define WszCreateDirectoryEx CreateDirectoryExW
#define WszRemoveDirectory RemoveDirectoryW
#define WszGetFullPathName GetFullPathNameW
#define WszDefineDosDevice DefineDosDeviceW
#define WszQueryDosDevice QueryDosDeviceW
#define WszCreateFile CreateFileW
#define WszSetFileAttributes SetFileAttributesW
#define WszGetFileAttributes GetFileAttributesW
#define WszGetFileAttributesEx GetFileAttributesExW
#define WszGetCompressedFileSize GetCompressedFileSizeW
#define WszDeleteFile DeleteFileW
#define WszFindFirstFileEx FindFirstFileExW
#define WszFindFirstFile FindFirstFileW
#define WszFindNextFile FindNextFileW
#define WszSearchPath SearchPathW
#define WszCopyFile CopyFileW
#define WszCopyFileEx CopyFileExW
#define WszMoveFile MoveFileW
#define WszMoveFileEx MoveFileExW
#define WszMoveFileWithProgress MoveFileWithProgressW
#define WszCreateSymbolicLink CreateSymbolicLinkW
#define WszQuerySymbolicLink QuerySymbolicLinkW
#define WszCreateHardLink CreateHardLinkW
#define WszCreateNamedPipe CreateNamedPipeW
#define WszGetNamedPipeHandleState GetNamedPipeHandleStateW
#define WszCallNamedPipe CallNamedPipeW
#define WszWaitNamedPipe WaitNamedPipeW
#define WszSetVolumeLabel SetVolumeLabelW
#define WszGetVolumeInformation GetVolumeInformationW
#define WszClearEventLog ClearEventLogW
#define WszBackupEventLog BackupEventLogW
#define WszOpenEventLog OpenEventLogW
#define WszRegisterEventSource RegisterEventSourceW
#define WszOpenBackupEventLog OpenBackupEventLogW
#define WszReadEventLog ReadEventLogW
#define WszReportEvent ReportEventW
#define WszAccessCheckAndAuditAlarm AccessCheckAndAuditAlarmW
#define WszAccessCheckByTypeAndAuditAlarm AccessCheckByTypeAndAuditAlarmW
#define WszAccessCheckByTypeResultListAndAuditAlarm AccessCheckByTypeResultListAndAuditAlarmW
#define WszObjectOpenAuditAlarm ObjectOpenAuditAlarmW
#define WszObjectPrivilegeAuditAlarm ObjectPrivilegeAuditAlarmW
#define WszObjectCloseAuditAlarm ObjectCloseAuditAlarmW
#define WszObjectDeleteAuditAlarm ObjectDeleteAuditAlarmW
#define WszPrivilegedServiceAuditAlarm PrivilegedServiceAuditAlarmW
#define WszSetFileSecurity SetFileSecurityW
#define WszGetFileSecurity GetFileSecurityW
#define WszFindFirstChangeNotification FindFirstChangeNotificationW
#define WszIsBadStringPtr IsBadStringPtrW
#define WszLookupAccountSid LookupAccountSidW
#define WszLookupAccountName LookupAccountNameW
#define WszLookupPrivilegeValue LookupPrivilegeValueW
#define WszLookupPrivilegeName LookupPrivilegeNameW
#define WszLookupPrivilegeDisplayName LookupPrivilegeDisplayNameW
#define WszBuildCommDCB BuildCommDCBW
#define WszBuildCommDCBAndTimeouts BuildCommDCBAndTimeoutsW
#define WszCommConfigDialog CommConfigDialogW
#define WszGetDefaultCommConfig GetDefaultCommConfigW
#define WszSetDefaultCommConfig SetDefaultCommConfigW
#define WszGetComputerName GetComputerNameW
#define WszSetComputerName SetComputerNameW
#define WszGetUserName GetUserNameW
#define WszLogonUser LogonUserW
#define WszCreateProcessAsUser CreateProcessAsUserW
#define WszGetCurrentHwProfile GetCurrentHwProfileW
#define WszGetVersionEx GetVersionExW
#define WszCreateJobObject CreateJobObjectW
#define WszOpenJobObject OpenJobObjectW
// Mem functions

#define EqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#define MoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define CopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define FillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define ZeroMemory(Destination,Length) memset((Destination),0,(Length))

// winuser.h
#define WszMAKEINTRESOURCE MAKEINTRESOURCEW
#define Wszwvsprintf wvsprintfW
#define Wszwsprintf wsprintfW
#define WszLoadKeyboardLayout LoadKeyboardLayoutW
#define WszGetKeyboardLayoutName GetKeyboardLayoutNameW
#define WszCreateDesktop CreateDesktopW
#define WszOpenDesktop OpenDesktopW
#define WszEnumDesktops EnumDesktopsW
#define WszCreateWindowStation CreateWindowStationW
#define WszOpenWindowStation OpenWindowStationW
#define WszEnumWindowStations EnumWindowStationsW
#define WszGetUserObjectInformation GetUserObjectInformationW
#define WszSetUserObjectInformation SetUserObjectInformationW
#define WszRegisterWindowMessage RegisterWindowMessageW
#define WszSIZEZOOMSHOW SIZEZOOMSHOWW
#define WszWS_TILEDWINDOW WS_TILEDWINDOWW
#define WszGetMessage GetMessageW
#define WszDispatchMessage DispatchMessageW
#define WszPeekMessage PeekMessageW
#define WszSendMessage SendMessageW
#define WszSendMessageTimeout SendMessageTimeoutW
#define WszSendNotifyMessage SendNotifyMessageW
#define WszSendMessageCallback SendMessageCallbackW
#define WszBroadcastSystemMessage BroadcastSystemMessageW
#define WszRegisterDeviceNotification RegisterDeviceNotificationW
#define WszPostMessage PostMessageW
#define WszPostThreadMessage PostThreadMessageW
#define WszPostAppMessage PostAppMessageW
#define WszDefWindowProc DefWindowProcW
#define WszCallWindowProc CallWindowProcW
#define WszCallWindowProc CallWindowProcW
#define WszRegisterClass RegisterClassW
#define WszUnregisterClass UnregisterClassW
#define WszGetClassInfo GetClassInfoW
#define WszRegisterClassEx RegisterClassExW
#define WszGetClassInfoEx GetClassInfoExW
#define WszCreateWindowEx CreateWindowExW
#define WszCreateWindow CreateWindowW
#define WszCreateDialogParam CreateDialogParamW
#define WszCreateDialogIndirectParam CreateDialogIndirectParamW
#define WszCreateDialog CreateDialogW
#define WszCreateDialogIndirect CreateDialogIndirectW
#define WszDialogBoxParam DialogBoxParamW
#define WszDialogBoxIndirectParam DialogBoxIndirectParamW
#define WszDialogBox DialogBoxW
#define WszDialogBoxIndirect DialogBoxIndirectW
#define WszSetDlgItemText SetDlgItemTextW
#define WszGetDlgItemText GetDlgItemTextW
#define WszSendDlgItemMessage SendDlgItemMessageW
#define WszDefDlgProc DefDlgProcW
#define WszCallMsgFilter CallMsgFilterW
#define WszRegisterClipboardFormat RegisterClipboardFormatW
#define WszGetClipboardFormatName GetClipboardFormatNameW
#define WszCharToOem CharToOemW
#define WszOemToChar OemToCharW
#define WszCharToOemBuff CharToOemBuffW
#define WszOemToCharBuff OemToCharBuffW
#define WszCharUpper CharUpperW
#define WszCharUpperBuff CharUpperBuffW
#define WszCharLower CharLowerW
#define WszCharLowerBuff CharLowerBuffW
#define WszCharNext CharNextW
//@todo: Does 95 support this? #define WszCharPrev CharPrevW
#define WszIsCharAlpha IsCharAlphaW
#define WszIsCharAlphaNumeric IsCharAlphaNumericW
#define WszIsCharUpper IsCharUpperW
#define WszIsCharLower IsCharLowerW
#define WszGetKeyNameText GetKeyNameTextW
#define WszVkKeyScan VkKeyScanW
#define WszVkKeyScanEx VkKeyScanExW
#define WszMapVirtualKey MapVirtualKeyW
#define WszMapVirtualKeyEx MapVirtualKeyExW
#define WszLoadAccelerators LoadAcceleratorsW
#define WszCreateAcceleratorTable CreateAcceleratorTableW
#define WszCopyAcceleratorTable CopyAcceleratorTableW
#define WszTranslateAccelerator TranslateAcceleratorW
#define WszLoadMenu LoadMenuW
#define WszLoadMenuIndirect LoadMenuIndirectW
#define WszChangeMenu ChangeMenuW
#define WszGetMenuString GetMenuStringW
#define WszInsertMenu InsertMenuW
#define WszAppendMenu AppendMenuW
#define WszModifyMenu ModifyMenuW
#define WszInsertMenuItem InsertMenuItemW
#define WszGetMenuItemInfo GetMenuItemInfoW
#define WszSetMenuItemInfo SetMenuItemInfoW
#define WszDrawText DrawTextW
#define WszDrawTextEx DrawTextExW
#define WszGrayString GrayStringW
#define WszDrawState DrawStateW
#define WszTabbedTextOut TabbedTextOutW
#define WszGetTabbedTextExtent GetTabbedTextExtentW
#define WszSetProp SetPropW
#define WszGetProp GetPropW
#define WszRemoveProp RemovePropW
#define WszEnumPropsEx EnumPropsExW
#define WszEnumProps EnumPropsW
#define WszSetWindowText SetWindowTextW
#define WszGetWindowText GetWindowTextW
#define WszGetWindowTextLength GetWindowTextLengthW
#define WszMessageBox MessageBoxW
#define WszMessageBoxEx MessageBoxExW
#define WszMessageBoxIndirect MessageBoxIndirectW
#define WszGetWindowLong GetWindowLongW
#define WszSetWindowLong SetWindowLongW
#define WszGetClassLong GetClassLongW
#define WszSetClassLong SetClassLongW
#define WszFindWindow FindWindowW
#define WszFindWindowEx FindWindowExW
#define WszGetClassName GetClassNameW
#define WszSetWindowsHook SetWindowsHookW
#define WszSetWindowsHook SetWindowsHookW
#define WszSetWindowsHookEx SetWindowsHookExW
#define WszLoadBitmap LoadBitmapW
#define WszLoadCursor LoadCursorW
#define WszLoadCursorFromFile LoadCursorFromFileW
#define WszLoadIcon LoadIconW
#define WszLoadImage LoadImageW
#define WszLoadString LoadStringW
#define WszIsDialogMessage IsDialogMessageW
#define WszDlgDirList DlgDirListW
#define WszDlgDirSelectEx DlgDirSelectExW
#define WszDlgDirListComboBox DlgDirListComboBoxW
#define WszDlgDirSelectComboBoxEx DlgDirSelectComboBoxExW
#define WszDefFrameProc DefFrameProcW
#define WszDefMDIChildProc DefMDIChildProcW
#define WszCreateMDIWindow CreateMDIWindowW
#define WszWinHelp WinHelpW
#define WszChangeDisplaySettings ChangeDisplaySettingsW
#define WszChangeDisplaySettingsEx ChangeDisplaySettingsExW
#define WszEnumDisplaySettings EnumDisplaySettingsW
#define WszEnumDisplayDevices EnumDisplayDevicesW
#define WszSystemParametersInfo SystemParametersInfoW
#define WszGetMonitorInfo GetMonitorInfoW
#define WszGetWindowModuleFileName GetWindowModuleFileNameW
#define WszRealGetWindowClass RealGetWindowClassW
#define WszGetAltTabInfo GetAltTabInfoW
#define WszRegOpenKeyEx RegOpenKeyEx
#define WszRegOpenKey(hKey, wszSubKey, phkRes) RegOpenKeyEx(hKey, wszSubKey, 0, KEY_ALL_ACCESS, phkRes)
#define WszRegQueryValueEx RegQueryValueEx
#define WszRegQueryStringValueEx RegQueryValueEx
#define WszRegDeleteKey RegDeleteKey
#define WszRegCreateKeyEx RegCreateKeyEx
#define WszRegSetValueEx RegSetValueEx
#define WszRegDeleteValue RegDeleteValue
#define WszRegLoadKey RegRegLoadKey
#define WszRegUnLoadKey RegUnLoadKey
#define WszRegRestoreKey RegRestoreKey
#define WszRegReplaceKey RegRegReplaceKey
#define WszRegQueryInfoKey RegQueryInfoKey
#define WszRegEnumValue RegEnumValue
#define WszRegEnumKeyEx RegEnumKeyEx

#undef GetProcAddress
#define GetProcAddress(handle, szProc) WszGetProcAddress(handle, szProc)

HRESULT WszConvertToUnicode(LPCSTR pszIn, LONG cbIn, LPWSTR* lpwszOut,
    ULONG* lpcchOut, BOOL fAlloc);

HRESULT WszConvertToAnsi(LPCWSTR pwszIn, LPSTR* lpszOut,
    ULONG cbOutMax, ULONG* lpcbOut, BOOL fAlloc);

// map stdio functions as approp
#define STD_INPUT_HANDLE    (DWORD)-10
#define STD_OUTPUT_HANDLE   (DWORD)-11
#define STD_ERROR_HANDLE    (DWORD)-12
#define GetStdHandle(x) \
    ((HANDLE*)_fileno( \
        ((x==STD_INPUT_HANDLE) ? stdin : \
        ((x==STD_OUTPUT_HANDLE) ? stdout : \
        ((x==STD_ERROR_HANDLE) ? stderr : NULL))) ))
            
#endif


#ifndef _T
#define _T(str) L ## str
#endif


//#define Wszlstrcmp      lstrcmpW
//#define Wszlstrcmpi     lstrcmpiW
//#define Wszlstrcpyn     lstrcpynW
//#define Wszlstrcpy      lstrcpyW
//#define Wszlstrcat      lstrcatW
#define Wszlstrlen      (size_t) lstrlenW
//#define Wszwsprintf     wsprintfW

//#define _tcslen           lstrlenW
//#define _tcscpy           lstrcpyW
//#define _tcscat           lstrcatW
//#define _tcsncpy      lstrcpynW


// The W95 names are going away, don't use them.
#define W95LoadLibraryEx WszLoadLibraryEx
#define W95LoadString WszLoadString
#define W95FormatMessage WszFormatMessage
#define W95GetModuleFileName WszGetModuleFileName
#define W95ConvertToUnicode WszConvertToUnicode
#define W95ConvertToAnsi WszConvertToAnsi
#define W95RegOpenKeyEx WszRegOpenKeyEx
#define W95RegOpenKey WszRegOpenKey
#define W95RegEnumKeyEx WszRegEnumKeyEx
#define W95RegDeleteKey WszRegDeleteKey
#define W95RegSetValueEx WszRegSetValueEx
#define W95RegCreateKeyEx WszRegCreateKeyEx
#define W95RegDeleteKey WszRegDeleteKey
#define W95RegQueryValue WszRegQueryValue
#define W95RegQueryValueEx WszRegQueryValueEx
#define W95GetPrivateProfileString WszGetPrivateProfileString
#define W95WritePrivateProfileString WszWritePrivateProfileString
#define W95CreateFile WszCreateFile
#define W95CopyFile WszCopyFile
#define W95MoveFileEx WszMoveFileEx
#define W95DeleteFile WszDeleteFile
#define W95MultiByteToWideChar WszMultiByteToWideChar
#define W95WideCharToMultiByte WszWideCharToMultiByte


//*****************************************************************************
// Prototypes for API's.
//*****************************************************************************

BOOL OnUnicodeSystem();

int WszMultiByteToWideChar(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCSTR   lpMultiByteStr,
    int      cchMultiByte,
    LPWSTR   lpWideCharStr,
    int      cchWideChar);

int WszWideCharToMultiByte(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCWSTR  lpWideCharStr,
    int      cchWideChar,
    LPSTR    lpMultiByteStr,
    int      cchMultiByte,
    LPCSTR   lpDefaultChar,
    LPBOOL   lpUsedDefaultChar);


#ifndef UNDER_CE

HINSTANCE WszLoadLibraryEx(LPCWSTR lpLibFileName, HANDLE hFile,
    DWORD dwFlags);

#ifndef WszLoadLibrary
#define WszLoadLibrary(lpFileName) WszLoadLibraryEx(lpFileName, NULL, 0)
#endif

int WszLoadString(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer,
    int nBufferMax);

DWORD WszFormatMessage(DWORD dwFlags, LPCVOID lpSource, 
    DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize,
    va_list *Arguments);

DWORD WszSearchPath(LPWSTR pwzPath, LPWSTR pwzFileName, LPWSTR pwzExtension, 
    DWORD nBufferLength, LPWSTR pwzBuffer, LPWSTR *pwzFilePart);

DWORD WszGetModuleFileName(HMODULE hModule, LPWSTR lpwszFilename, DWORD nSize);

HRESULT WszConvertToUnicode(LPCSTR pszIn, LONG cbIn, LPWSTR* lpwszOut,
    ULONG* lpcchOut, BOOL fAlloc);

HRESULT WszConvertToAnsi(LPCWSTR pwszIn, LPSTR* lpszOut,
    ULONG cbOutMax, ULONG* lpcbOut, BOOL fAlloc);

LONG WszRegOpenKeyEx(HKEY hKey, LPCWSTR wszSub, 
    DWORD dwRes, REGSAM sam, PHKEY phkRes);

#ifndef WszRegOpenKey
#define WszRegOpenKey(hKey, wszSubKey, phkRes) WszRegOpenKeyEx(hKey, wszSubKey, 0, KEY_ALL_ACCESS, phkRes)
#endif

LONG WszRegEnumKeyEx(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName,
    LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);

LONG WszRegDeleteKey(HKEY hKey, LPCWSTR lpSubKey);

LONG WszRegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD dwReserved,
    DWORD dwType, CONST BYTE* lpData, DWORD cbData);

LONG WszRegCreateKeyEx(HKEY hKey, LPCWSTR lpSubKey, DWORD dwReserved,
    LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);

LONG WszRegQueryValue(HKEY hKey, LPCWSTR lpSubKey,
    LPWSTR lpValue, PLONG lpcbValue);

LONG WszRegQueryValueEx(HKEY hKey, LPCWSTR lpValueName,
    LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
    LPDWORD lpcbData);

LONG WszRegQueryStringValueEx(HKEY hKey, LPCWSTR lpValueName,
                              LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
                              LPDWORD lpcbData);

DWORD WszRegDeleteKeyAndSubKeys(                // Return code.
    HKEY        hStartKey,              // The key to start with.
    LPCWSTR     wzKeyName);             // Subkey to delete.

LONG WszRegDeleteValue(
    HKEY    hKey,
    LPCWSTR lpValueName);

LONG WszRegLoadKey(
    HKEY     hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpFile);

LONG WszRegUnLoadKey(
    HKEY    hKey,
    LPCWSTR lpSubKey);

LONG WszRegRestoreKey(
    HKEY    hKey,
    LPCWSTR lpFile,
    DWORD   dwFlags);

LONG WszRegReplaceKey(
    HKEY     hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpNewFile,
    LPCWSTR  lpOldFile);

LONG WszRegQueryInfoKey(
    HKEY    hKey,
    LPWSTR  lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime);

LONG WszRegEnumValue(
    HKEY    hKey,
    DWORD   dwIndex,
    LPWSTR  lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData);

DWORD WszGetPrivateProfileString(LPCWSTR lpwszSection, LPCWSTR lpwszEntry,
    LPCWSTR lpwszDefault, LPWSTR lpwszRetBuffer, DWORD cchRetBuffer,
    LPCWSTR lpszFile);

BOOL WszWritePrivateProfileString(LPCWSTR lpwszSection, LPCWSTR lpwszKey,
    LPCWSTR lpwszString, LPCWSTR lpwszFile);

HANDLE WszCreateFile(
    LPCWSTR pwszFileName,   // pointer to name of the file 
    DWORD dwDesiredAccess,  // access (read-write) mode 
    DWORD dwShareMode,  // share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // pointer to security descriptor 
    DWORD dwCreationDistribution,   // how to create 
    DWORD dwFlagsAndAttributes, // file attributes 
    HANDLE hTemplateFile );     // handle to file with attributes to copy  

BOOL WszGetUserName(
    LPTSTR lpBuffer,  // name buffer
    LPDWORD nSize     // size of name buffer
);

BOOL WszGetComputerName(
    LPTSTR lpBuffer,  // computer name
    LPDWORD lpnSize   // size of name buffer
);

BOOL WszPeekMessage(
  LPMSG lpMsg,         // message information
  HWND hWnd,           // handle to window
  UINT wMsgFilterMin,  // first message
  UINT wMsgFilterMax,  // last message
  UINT wRemoveMsg      // removal options
);

LPTSTR WszCharNext(
  LPCTSTR lpsz   // current character
);

LRESULT WszDispatchMessage(
  CONST MSG *lpmsg   // message information
);


BOOL WszCopyFile(
    LPCWSTR pwszExistingFileName,   // pointer to name of an existing file 
    LPCWSTR pwszNewFileName,    // pointer to filename to copy to 
    BOOL bFailIfExists );   // flag for operation if file exists 

BOOL WszMoveFileEx(
    LPCWSTR pwszExistingFileName,   // address of name of the existing file  
    LPCWSTR pwszNewFileName,    // address of new name for the file 
    DWORD dwFlags );    // flag to determine how to move file 


BOOL WszDeleteFile(
    LPCWSTR pwszFileName ); // address of name of the existing file  

BOOL WszGetVersionEx(
    LPOSVERSIONINFOW lpVersionInformation);

void WszOutputDebugString(
    LPCWSTR lpOutputString
    );

void WszFatalAppExit(
    UINT uAction,
    LPCWSTR lpMessageText
    );

int WszMessageBox(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType);

HANDLE WszCreateMutex(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    );

HANDLE WszCreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

HANDLE WszOpenEvent(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

HMODULE WszGetModuleHandle(
    LPCWSTR lpModuleName
    );

DWORD
WszGetFileAttributes(
    LPCWSTR lpFileName
    );

DWORD
WszGetCurrentDirectory(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );

BOOL
WszSetCurrentDirectory(
  LPWSTR lpPathName  
);

DWORD
WszGetTempPath(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );

UINT
WszGetTempFileName(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    );

DWORD
WszGetEnvironmentVariable(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    );

BOOL
WINAPI
WszSetEnvironmentVariable(
    LPCWSTR lpName,
    LPCWSTR lpValue
    );

DWORD
WszGetFullPathName(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

HANDLE
WszCreateFileMapping(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );

HANDLE
WszOpenFileMapping(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

HANDLE WszRegisterEventSource(
  LPCWSTR lpUNCServerName,
  LPCWSTR lpSourceName
);

int Wszwvsprintf(
  LPTSTR lpOutput,
  LPCTSTR lpFormat,
  va_list arglist
);

BOOL WszReportEvent(
  HANDLE    hEventLog,  // handle returned by RegisterEventSource
  WORD      wType,      // event type to log
  WORD      wCategory,  // event category
  DWORD     dwEventID,  // event identifier
  PSID      lpUserSid,  // user security identifier (optional)
  WORD      wNumStrings,// number of strings to merge with message
  DWORD     dwDataSize, // size of binary data, in bytes
  LPCTSTR * lpStrings,  // array of strings to merge with message
  LPVOID    lpRawData   // address of binary data
);

BOOL
WszCreateProcess(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

DWORD 
WszExpandEnvironmentStrings( 
	LPCWSTR lpSrc,
	LPWSTR lpDst, 
	DWORD nSize );

HANDLE
WszFindFirstFile( 
	LPCWSTR lpFileName, 
	LPWIN32_FIND_DATAW lpFindFileData );

BOOL 
WszFindNextFile( 
	HANDLE hFindFile, 
	LPWIN32_FIND_DATAW 
	lpFindFileData );

UINT 
WszGetWindowsDirectory( 
	LPWSTR lpBuffer, 
	UINT uSize );

UINT 
WszGetSystemDirectory( 
	LPWSTR lpBuffer, 
	UINT uSize );

int 
Wszlstrcmpi( 
	LPCWSTR lpString1,
	LPCWSTR lpString2);

int 
Wszlstrcmp( 
	LPCWSTR lpString1,
	LPCWSTR lpString2);

BOOL
WszCreateDirectory(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL 
WszMoveFile(
    LPCWSTR pwszExistingFileName,   
    LPCWSTR pwszNewFileName
	);

BOOL
WszGetFileAttributesEx(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
	);

LPWSTR
Wszlstrcpy( 
	LPWSTR lpString1, 
	LPCWSTR lpString2
	);

LPWSTR
Wszlstrcpyn( 
	LPWSTR lpString1, 
	LPCWSTR lpString2,
    int iMaxLength
	);

LPWSTR
Wszlstrcat( 
   LPWSTR lpString1, 
   LPCWSTR lpString2
   );

HANDLE
WszCreateSemaphore(
   LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
   LONG lInitialCount,
   LONG lMaximumCount,
   LPCWSTR lpName
   );

LPWSTR 
WszCharUpper(
	LPWSTR	lpwsz
	);

#endif // UNDER_CE


#if ( !defined(UNDER_CE) && defined(UNICODE) )
/*
#define LoadString WszLoadString
#define FormatMessage WszFormatMessage
#define ConvertToUnicode WszConvertToUnicode
#define ConvertToAnsi WszConvertToAnsi
#define GetPrivateProfileString WszGetPrivateProfileString
#define WritePrivateProfileString WszWritePrivateProfileString
#define MultiByteToWideChar WszMultiByteToWideChar
#define WideCharToMultiByte WszWideCharToMultiByte
*/
#define GetUserName WszGetUserName
#define GetComputerName WszGetComputerName
#define PeekMessage WszPeekMessage
#define DispatchMessage WszDispatchMessage
#define CharNext WszCharNext
#define CreateFile WszCreateFile
#define CreateFileMapping WszCreateFileMapping
#define DeleteFile WszDeleteFile
#define CreateMutex WszCreateMutex
#define GetFileAttributes WszGetFileAttributes
#define GetFileAttributesEx WszGetFileAttributesEx
#define GetVersionEx WszGetVersionEx
#define MoveFileEx WszMoveFileEx
#define MoveFile WszMoveFile
#define LoadLibraryEx WszLoadLibraryEx
#define LoadLibrary WszLoadLibrary
#define OutputDebugString WszOutputDebugString
#define GetModuleFileName WszGetModuleFileName
#define CopyFile WszCopyFile
#define RegOpenKeyEx WszRegOpenKeyEx
#define RegOpenKey WszRegOpenKey
#define RegEnumKeyEx WszRegEnumKeyEx
#define RegDeleteKey WszRegDeleteKey
#define RegSetValueEx WszRegSetValueEx
#define RegCreateKeyEx WszRegCreateKeyEx
#define RegDeleteKey WszRegDeleteKey
#define RegQueryValue WszRegQueryValue
#define RegQueryValueEx WszRegQueryValueEx
#define ExpandEnvironmentStrings WszExpandEnvironmentStrings   
#define GetWindowsDirectory WszGetWindowsDirectory
#define GetSystemDirectory WszGetSystemDirectory
#define FindFirstFile WszFindFirstFile
#define FindNextFile WszFindNextFile
#define CreateEvent WszCreateEvent
#define lstrcmpi Wszlstrcmpi
#define wsprintf swprintf		//map to CRT counterpart, temporary solution!!
#define CreateDirectory WszCreateDirectory
#define CreateSemaphore WszCreateSemaphore
#define GetModuleHandle WszGetModuleHandle
#define LoadString      WszLoadString
#define lstrcpyn        Wszlstrcpyn
#define lstrcpy         Wszlstrcpy
#define lstrcat         Wszlstrcat
#define FormatMessage   WszFormatMessage
#define RegisterEventSource WszRegisterEventSource
#define wvsprintf       Wszwvsprintf
#define MessageBox      WszMessageBox
#define ReportEvent     WszReportEvent

#ifndef _WIN64
#define InterlockedCompareExchange        VipInterlockedCompareExchange
#define InterlockedCompareExchangePointer VipInterlockedCompareExchange
#endif // _WIN64

#endif	// !defined(UNDER_CE) && defined(UNICODE)

#ifndef Wsz_mbstowcs
#define Wsz_mbstowcs(szOut, szIn, iSize) WszMultiByteToWideChar(CP_ACP, 0, szIn, -1, szOut, iSize)
#endif


#ifndef Wsz_wcstombs
#define Wsz_wcstombs(szOut, szIn, iSize) WszWideCharToMultiByte(CP_ACP, 0, szIn, -1, szOut, iSize, 0, 0)
#endif


// For all platforms:

LPWSTR
Wszltow(
    LONG val,
    LPWSTR buf,
    int radix
    );

LPWSTR
Wszultow(
    ULONG val,
    LPWSTR buf,
    int radix
    );

#ifdef UNDER_CE
FARPROC WszGetProcAddress(HMODULE hMod, LPCSTR szProcName);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\warningcontrol.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// warningcontrol.h
//
// Header file to globally control the warning settings for the entire Viper build.
// You do not need to explicitly include this file; rather, it gets included
// on the command line with a /FI (force include) directive. This is controlled 
// in sources.vip.
//
#pragma warning(disable: 4291)   // delete operator required for EH (Sundown compiler specific)

#pragma warning(disable :4001)   // "nonstandard extension 'single line comment' was used"
#pragma warning(error   :4007)   // 'main' : must be __cdecl
#pragma warning(disable :4010)   // "single-line comment contains line-continuation character"		
#pragma warning(error   :4013)   // 'function' undefined - assuming extern returning int
#pragma warning(disable :4022)   // "'%s' : pointer mismatch for actual parameter %d"
#pragma warning(disable :4047)   // "'%$L' : '%$T' differs in levels of indirection from '%$T'"
#pragma warning(disable :4053)   // "one void operand for '?:'"
#pragma warning(disable :4056)   // "overflow in floating-point constant arithmetic"
#pragma warning(disable :4061)   // "enumerate '%$S' in switch of enum '%$S' is not explicitly handled by a case label"
#pragma warning(error   :4071)   // no function prototype given
#pragma warning(error   :4072)   // no function prototype given (fastcall)
#pragma warning(3       :4092)   // sizeof returns 'unsigned long'
#pragma warning(disable :4100)   // "'%$S' : unreferenced formal parameter"
#pragma warning(disable :4101)   // "'%$S' : unreferenced local variable"
#pragma warning(disable :4102)   // "'%$S' : unreferenced label"
#pragma warning(3       :4121)   // structure is sensitive to alignment
#pragma warning(disable :4127)   // "conditional expression is constant"
#pragma warning(3       :4125)   // decimal digit in octal sequence
#pragma warning(3       :4130)   // logical operation on address of string constant
#pragma warning(3       :4132)   // const object should be initialized
#pragma warning(error   :4171)   // no function prototype given (old style)
#pragma warning(4       :4177)   // pragma data_seg s/b at global scope
#pragma warning(4       :4206)   // Source File is empty
#pragma warning(4       :4101)   // Unreferenced local variable
#pragma warning(disable :4201)   // "nonstandard extension used : nameless struct/union"
#pragma warning(disable :4204)   // "nonstandard extension used : non-constant aggregate initializer"
#pragma warning(3       :4212)   // function declaration used ellipsis
#pragma warning(error   :4259)   // pure virtual function was not defined
#pragma warning(4       :4267)   // convertion from size_t to smaller type
#pragma warning(error   :4551)   // Function call missing argument list

#pragma warning(3       :4509)   // "nonstandard extension used: '%$S' uses SEH and '%$S' has destructor"
                                 //
                                 // But beware of doing a return from inside such a try block:
                                 //     
                                 //     int foo()
                                 //         {
                                 //         ClassWithDestructor c;
                                 //         __try {
                                 //             return 0;
                                 //         } __finally {
                                 //             printf("in finally");
                                 //         }
                                 //
                                 // as (it's a bug) the return value gets toasted. So DON'T casually 
                                 // dismiss this warning if you're compiling w/o CXX EH turned on (the default).

#pragma warning(3       :4530)   // C++ exception handler used, but unwind semantics are not enabled. Specify -GX

#pragma warning(error   :4700)   // Local used w/o being initialized
#pragma warning(disable :4786)   // identifier was truncated to '255' characters in the browser (or debug) information
#pragma warning(error   :4806)   // unsafe operation involving type 'bool'
#pragma warning(3		:4701)   // variable may be used w/o being initialized

#if _DEBUG
#pragma warning(disable :4124)   // __fastcall with stack checking is inefficient
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\version\configver.h ===
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"system.config.dll"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\version\compprov.h ===
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK

#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILEOS               VOS__WINDOWS32
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft(R) is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0"


// Windows Specific

#if defined( MIPS) || defined(_MIPS_)
	#define VER_PLATFORMINFO_STR         "MIPS\0"
#endif

#if defined(ALPHA) || defined(_ALPHA_)
	#define VER_PLATFORMINFO_STR         "ALPHA-AXP\0"
#endif

#if defined(_PPC_) || defined(PPC)
	#define VER_PLATFORMINFO_STR         "POWER PC\0"
#endif

// By default use Intel (_X86_)
#ifndef VER_PLATFORMINFO_STR
	#define VER_PLATFORMINFO_STR         "INTEL X86\0"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\wstring.h ===
#ifndef __WSTRING_H__
#define __WSTRING_H__


// wstring class is a minimal version of std::wstring.  sdt::wstring requires the entire stl.
// Be warned! this class throws exceptions so wrap non-const calls in try-catch
class wstring
{
public:
    wstring() : pstr(0){}
    wstring(wstring &str) : pstr(0){assign(str.c_str());}
    wstring(const wchar_t *psz) : pstr(0){assign(psz);}
    ~wstring(){if(pstr)CoTaskMemFree(pstr);}

    const wchar_t * c_str() const {return pstr;}
    operator const wchar_t*() const {return pstr;}

    wstring & operator =(const wstring &str){return assign(str.c_str());}
    wstring & operator +=(const wstring &str){return append(str.c_str());}
    wstring & operator =(const wchar_t *psz){return assign(psz);}
    wstring & operator +=(const wchar_t *psz){return append(psz);}
    bool      operator ==(const wstring &str) const {return isequal(str.c_str());}
    bool      operator ==(const wchar_t *psz) const {return isequal(psz);}
    bool      operator !=(const wstring &str) const {return !isequal(str.c_str());}
    bool      operator !=(const wchar_t *psz) const {return !isequal(psz);}

    size_t length()const {return (0==pstr) ? 0 : wcslen(pstr);}
    void   truncate(size_t i){if(i<length())pstr[i]=0x00;}
private:
    wchar_t *pstr;

    wstring & append(const wchar_t *psz)
    {
        if(!pstr)
            assign(psz);
        else if(psz)
        {
            pstr = reinterpret_cast<wchar_t *>(CoTaskMemRealloc(pstr, sizeof(wchar_t)*(wcslen(pstr)+wcslen(psz)+1)));
            if(pstr)
                wcscat(pstr, psz);
        }
        return *this;
    }
    wstring & assign(const wchar_t *psz)
    {
        if(psz)
        {
            pstr = reinterpret_cast<wchar_t *>(CoTaskMemRealloc(pstr, sizeof(wchar_t)*(wcslen(psz)+1)));
            if(pstr)
                wcscpy(pstr, psz);
        }
        return *this;
    }
    bool      isequal(const wchar_t *psz) const {return (0==wcscmp(pstr, psz));}
};

#endif // __WSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\version\catalog42ver.h ===
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright (C) Microsoft Corp. 1995-2000\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft(R) is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0"

#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK

#define VER_PRODUCTNAME_STR      "COM Services\0"


// Windows Specific

// BUG #1634 WGR: #define VER_PLATFORMINFO_STR         "Windows\0"
#define VER_FILEOS               VOS__WINDOWS32


#if defined( MIPS) || defined(_MIPS_)
	#define VER_PLATFORMINFO_STR         "MIPS\0"
#endif

#if defined(ALPHA) || defined(_ALPHA_)
	#define VER_PLATFORMINFO_STR         "ALPHA-AXP\0"
#endif

#if defined(_PPC_) || defined(PPC)
	#define VER_PLATFORMINFO_STR         "POWER PC\0"
#endif

// By default use Intel (_X86_)
#ifndef VER_PLATFORMINFO_STR
	#define VER_PLATFORMINFO_STR         "INTEL X86\0"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\version\catinproc.h ===
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"CatInPro.DLL"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\version\managementver.h ===
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"System.Management.dll"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\xmlparser.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Thu Mar 04 16:31:06 1999
 */
/* Compiler settings for xmlparser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __xmlparser_h__
#define __xmlparser_h__

/* Forward Declarations */ 

#ifndef __IXMLNodeSource_FWD_DEFINED__
#define __IXMLNodeSource_FWD_DEFINED__
typedef interface IXMLNodeSource IXMLNodeSource;
#endif 	/* __IXMLNodeSource_FWD_DEFINED__ */


#ifndef __IXMLParser_FWD_DEFINED__
#define __IXMLParser_FWD_DEFINED__
typedef interface IXMLParser IXMLParser;
#endif 	/* __IXMLParser_FWD_DEFINED__ */


#ifndef __IXMLNodeFactory_FWD_DEFINED__
#define __IXMLNodeFactory_FWD_DEFINED__
typedef interface IXMLNodeFactory IXMLNodeFactory;
#endif 	/* __IXMLNodeFactory_FWD_DEFINED__ */


#ifndef __XMLParser_FWD_DEFINED__
#define __XMLParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser XMLParser;
#else
typedef struct XMLParser XMLParser;
#endif /* __cplusplus */

#endif 	/* __XMLParser_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_xmlparser_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//--------------------------------------------------------------------------




typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0001
    {	XML_ELEMENT	= 1,
	XML_ATTRIBUTE	= XML_ELEMENT + 1,
	XML_PI	= XML_ATTRIBUTE + 1,
	XML_XMLDECL	= XML_PI + 1,
	XML_DOCTYPE	= XML_XMLDECL + 1,
	XML_DTDATTRIBUTE	= XML_DOCTYPE + 1,
	XML_ENTITYDECL	= XML_DTDATTRIBUTE + 1,
	XML_ELEMENTDECL	= XML_ENTITYDECL + 1,
	XML_ATTLISTDECL	= XML_ELEMENTDECL + 1,
	XML_NOTATION	= XML_ATTLISTDECL + 1,
	XML_GROUP	= XML_NOTATION + 1,
	XML_INCLUDESECT	= XML_GROUP + 1,
	XML_PCDATA	= XML_INCLUDESECT + 1,
	XML_CDATA	= XML_PCDATA + 1,
	XML_IGNORESECT	= XML_CDATA + 1,
	XML_COMMENT	= XML_IGNORESECT + 1,
	XML_ENTITYREF	= XML_COMMENT + 1,
	XML_WHITESPACE	= XML_ENTITYREF + 1,
	XML_NAME	= XML_WHITESPACE + 1,
	XML_NMTOKEN	= XML_NAME + 1,
	XML_STRING	= XML_NMTOKEN + 1,
	XML_PEREF	= XML_STRING + 1,
	XML_MODEL	= XML_PEREF + 1,
	XML_ATTDEF	= XML_MODEL + 1,
	XML_ATTTYPE	= XML_ATTDEF + 1,
	XML_ATTPRESENCE	= XML_ATTTYPE + 1,
	XML_DTDSUBSET	= XML_ATTPRESENCE + 1,
	XML_LASTNODETYPE	= XML_DTDSUBSET + 1
    }	XML_NODE_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0002
    {	XML_VERSION	= XML_LASTNODETYPE,
	XML_ENCODING	= XML_VERSION + 1,
	XML_STANDALONE	= XML_ENCODING + 1,
	XML_NS	= XML_STANDALONE + 1,
	XML_XMLSPACE	= XML_NS + 1,
	XML_XMLLANG	= XML_XMLSPACE + 1,
	XML_SYSTEM	= XML_XMLLANG + 1,
	XML_PUBLIC	= XML_SYSTEM + 1,
	XML_NDATA	= XML_PUBLIC + 1,
	XML_AT_CDATA	= XML_NDATA + 1,
	XML_AT_ID	= XML_AT_CDATA + 1,
	XML_AT_IDREF	= XML_AT_ID + 1,
	XML_AT_IDREFS	= XML_AT_IDREF + 1,
	XML_AT_ENTITY	= XML_AT_IDREFS + 1,
	XML_AT_ENTITIES	= XML_AT_ENTITY + 1,
	XML_AT_NMTOKEN	= XML_AT_ENTITIES + 1,
	XML_AT_NMTOKENS	= XML_AT_NMTOKEN + 1,
	XML_AT_NOTATION	= XML_AT_NMTOKENS + 1,
	XML_AT_REQUIRED	= XML_AT_NOTATION + 1,
	XML_AT_IMPLIED	= XML_AT_REQUIRED + 1,
	XML_AT_FIXED	= XML_AT_IMPLIED + 1,
	XML_PENTITYDECL	= XML_AT_FIXED + 1,
	XML_EMPTY	= XML_PENTITYDECL + 1,
	XML_ANY	= XML_EMPTY + 1,
	XML_MIXED	= XML_ANY + 1,
	XML_SEQUENCE	= XML_MIXED + 1,
	XML_CHOICE	= XML_SEQUENCE + 1,
	XML_STAR	= XML_CHOICE + 1,
	XML_PLUS	= XML_STAR + 1,
	XML_QUESTIONMARK	= XML_PLUS + 1,
	XML_LASTSUBNODETYPE	= XML_QUESTIONMARK + 1
    }	XML_NODE_SUBTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0003
    {	XML_E_PARSEERRORBASE	= 0xc00ce500L,
	XML_E_ENDOFINPUT	= XML_E_PARSEERRORBASE,
	XML_E_MISSINGEQUALS	= XML_E_ENDOFINPUT + 1,
	XML_E_MISSINGQUOTE	= XML_E_MISSINGEQUALS + 1,
	XML_E_COMMENTSYNTAX	= XML_E_MISSINGQUOTE + 1,
	XML_E_BADSTARTNAMECHAR	= XML_E_COMMENTSYNTAX + 1,
	XML_E_BADNAMECHAR	= XML_E_BADSTARTNAMECHAR + 1,
	XML_E_BADCHARINSTRING	= XML_E_BADNAMECHAR + 1,
	XML_E_XMLDECLSYNTAX	= XML_E_BADCHARINSTRING + 1,
	XML_E_BADCHARDATA	= XML_E_XMLDECLSYNTAX + 1,
	XML_E_MISSINGWHITESPACE	= XML_E_BADCHARDATA + 1,
	XML_E_EXPECTINGTAGEND	= XML_E_MISSINGWHITESPACE + 1,
	XML_E_BADCHARINDTD	= XML_E_EXPECTINGTAGEND + 1,
	XML_E_BADCHARINDECL	= XML_E_BADCHARINDTD + 1,
	XML_E_MISSINGSEMICOLON	= XML_E_BADCHARINDECL + 1,
	XML_E_BADCHARINENTREF	= XML_E_MISSINGSEMICOLON + 1,
	XML_E_UNBALANCEDPAREN	= XML_E_BADCHARINENTREF + 1,
	XML_E_EXPECTINGOPENBRACKET	= XML_E_UNBALANCEDPAREN + 1,
	XML_E_BADENDCONDSECT	= XML_E_EXPECTINGOPENBRACKET + 1,
	XML_E_INTERNALERROR	= XML_E_BADENDCONDSECT + 1,
	XML_E_UNEXPECTED_WHITESPACE	= XML_E_INTERNALERROR + 1,
	XML_E_INCOMPLETE_ENCODING	= XML_E_UNEXPECTED_WHITESPACE + 1,
	XML_E_BADCHARINMIXEDMODEL	= XML_E_INCOMPLETE_ENCODING + 1,
	XML_E_MISSING_STAR	= XML_E_BADCHARINMIXEDMODEL + 1,
	XML_E_BADCHARINMODEL	= XML_E_MISSING_STAR + 1,
	XML_E_MISSING_PAREN	= XML_E_BADCHARINMODEL + 1,
	XML_E_BADCHARINENUMERATION	= XML_E_MISSING_PAREN + 1,
	XML_E_PIDECLSYNTAX	= XML_E_BADCHARINENUMERATION + 1,
	XML_E_EXPECTINGCLOSEQUOTE	= XML_E_PIDECLSYNTAX + 1,
	XML_E_MULTIPLE_COLONS	= XML_E_EXPECTINGCLOSEQUOTE + 1,
	XML_E_INVALID_DECIMAL	= XML_E_MULTIPLE_COLONS + 1,
	XML_E_INVALID_HEXIDECIMAL	= XML_E_INVALID_DECIMAL + 1,
	XML_E_INVALID_UNICODE	= XML_E_INVALID_HEXIDECIMAL + 1,
	XML_E_WHITESPACEORQUESTIONMARK	= XML_E_INVALID_UNICODE + 1,
	XML_E_TOKEN_ERROR	= XML_E_PARSEERRORBASE + 0x50,
	XML_E_SUSPENDED	= XML_E_TOKEN_ERROR,
	XML_E_STOPPED	= XML_E_SUSPENDED + 1,
	XML_E_UNEXPECTEDENDTAG	= XML_E_STOPPED + 1,
	XML_E_UNCLOSEDTAG	= XML_E_UNEXPECTEDENDTAG + 1,
	XML_E_DUPLICATEATTRIBUTE	= XML_E_UNCLOSEDTAG + 1,
	XML_E_MULTIPLEROOTS	= XML_E_DUPLICATEATTRIBUTE + 1,
	XML_E_INVALIDATROOTLEVEL	= XML_E_MULTIPLEROOTS + 1,
	XML_E_BADXMLDECL	= XML_E_INVALIDATROOTLEVEL + 1,
	XML_E_MISSINGROOT	= XML_E_BADXMLDECL + 1,
	XML_E_UNEXPECTEDEOF	= XML_E_MISSINGROOT + 1,
	XML_E_BADPEREFINSUBSET	= XML_E_UNEXPECTEDEOF + 1,
	XML_E_PE_NESTING	= XML_E_BADPEREFINSUBSET + 1,
	XML_E_INVALID_CDATACLOSINGTAG	= XML_E_PE_NESTING + 1,
	XML_E_UNCLOSEDPI	= XML_E_INVALID_CDATACLOSINGTAG + 1,
	XML_E_UNCLOSEDSTARTTAG	= XML_E_UNCLOSEDPI + 1,
	XML_E_UNCLOSEDENDTAG	= XML_E_UNCLOSEDSTARTTAG + 1,
	XML_E_UNCLOSEDSTRING	= XML_E_UNCLOSEDENDTAG + 1,
	XML_E_UNCLOSEDCOMMENT	= XML_E_UNCLOSEDSTRING + 1,
	XML_E_UNCLOSEDDECL	= XML_E_UNCLOSEDCOMMENT + 1,
	XML_E_UNCLOSEDMARKUPDECL	= XML_E_UNCLOSEDDECL + 1,
	XML_E_UNCLOSEDCDATA	= XML_E_UNCLOSEDMARKUPDECL + 1,
	XML_E_BADDECLNAME	= XML_E_UNCLOSEDCDATA + 1,
	XML_E_BADEXTERNALID	= XML_E_BADDECLNAME + 1,
	XML_E_BADELEMENTINDTD	= XML_E_BADEXTERNALID + 1,
	XML_E_RESERVEDNAMESPACE	= XML_E_BADELEMENTINDTD + 1,
	XML_E_EXPECTING_VERSION	= XML_E_RESERVEDNAMESPACE + 1,
	XML_E_EXPECTING_ENCODING	= XML_E_EXPECTING_VERSION + 1,
	XML_E_EXPECTING_NAME	= XML_E_EXPECTING_ENCODING + 1,
	XML_E_UNEXPECTED_ATTRIBUTE	= XML_E_EXPECTING_NAME + 1,
	XML_E_ENDTAGMISMATCH	= XML_E_UNEXPECTED_ATTRIBUTE + 1,
	XML_E_INVALIDENCODING	= XML_E_ENDTAGMISMATCH + 1,
	XML_E_INVALIDSWITCH	= XML_E_INVALIDENCODING + 1,
	XML_E_EXPECTING_NDATA	= XML_E_INVALIDSWITCH + 1,
	XML_E_INVALID_MODEL	= XML_E_EXPECTING_NDATA + 1,
	XML_E_INVALID_TYPE	= XML_E_INVALID_MODEL + 1,
	XML_E_INVALIDXMLSPACE	= XML_E_INVALID_TYPE + 1,
	XML_E_MULTI_ATTR_VALUE	= XML_E_INVALIDXMLSPACE + 1,
	XML_E_INVALID_PRESENCE	= XML_E_MULTI_ATTR_VALUE + 1,
	XML_E_BADXMLCASE	= XML_E_INVALID_PRESENCE + 1,
	XML_E_CONDSECTINSUBSET	= XML_E_BADXMLCASE + 1,
	XML_E_CDATAINVALID	= XML_E_CONDSECTINSUBSET + 1,
	XML_E_INVALID_STANDALONE	= XML_E_CDATAINVALID + 1,
	XML_E_UNEXPECTED_STANDALONE	= XML_E_INVALID_STANDALONE + 1,
	XML_E_DOCTYPE_IN_DTD	= XML_E_UNEXPECTED_STANDALONE + 1,
	XML_E_MISSING_ENTITY	= XML_E_DOCTYPE_IN_DTD + 1,
	XML_E_ENTITYREF_INNAME	= XML_E_MISSING_ENTITY + 1,
	XML_E_DOCTYPE_OUTSIDE_PROLOG	= XML_E_ENTITYREF_INNAME + 1,
	XML_E_INVALID_VERSION	= XML_E_DOCTYPE_OUTSIDE_PROLOG + 1,
	XML_E_DTDELEMENT_OUTSIDE_DTD	= XML_E_INVALID_VERSION + 1,
	XML_E_DUPLICATEDOCTYPE	= XML_E_DTDELEMENT_OUTSIDE_DTD + 1,
	XML_E_RESOURCE	= XML_E_DUPLICATEDOCTYPE + 1,
	XML_E_LASTERROR	= XML_E_RESOURCE + 1
    }	XML_ERROR_CODE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0004
    {	XMLPARSER_IDLE	= 0,
	XMLPARSER_WAITING	= XMLPARSER_IDLE + 1,
	XMLPARSER_BUSY	= XMLPARSER_WAITING + 1,
	XMLPARSER_ERROR	= XMLPARSER_BUSY + 1,
	XMLPARSER_STOPPED	= XMLPARSER_ERROR + 1,
	XMLPARSER_SUSPENDED	= XMLPARSER_STOPPED + 1
    }	XML_PARSER_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0005
    {	XMLFLAG_FLOATINGAMP	= 1,
	XMLFLAG_SHORTENDTAGS	= 2,
	XMLFLAG_CASEINSENSITIVE	= 4,
	XMLFLAG_NONAMESPACES	= 8,
	XMLFLAG_NOWHITESPACE	= 16,
	XMLFLAG_IE4QUIRKS	= 32,
	XMLFLAG_NODTDNODES	= 64,
	XMLFLAG_IE4COMPATIBILITY	= 255
    }	XML_PARSER_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0006
    {	XMLNF_STARTDOCUMENT	= 0,
	XMLNF_STARTDTD	= XMLNF_STARTDOCUMENT + 1,
	XMLNF_ENDDTD	= XMLNF_STARTDTD + 1,
	XMLNF_STARTDTDSUBSET	= XMLNF_ENDDTD + 1,
	XMLNF_ENDDTDSUBSET	= XMLNF_STARTDTDSUBSET + 1,
	XMLNF_ENDPROLOG	= XMLNF_ENDDTDSUBSET + 1,
	XMLNF_STARTENTITY	= XMLNF_ENDPROLOG + 1,
	XMLNF_ENDENTITY	= XMLNF_STARTENTITY + 1,
	XMLNF_ENDDOCUMENT	= XMLNF_ENDENTITY + 1,
	XMLNF_DATAAVAILABLE	= XMLNF_ENDDOCUMENT + 1,
	XMLNF_LASTEVENT	= XMLNF_DATAAVAILABLE
    }	XML_NODEFACTORY_EVENT;

typedef struct _XML_NODE_INFO
    {
    DWORD dwSize;
    DWORD dwType;
    DWORD dwSubType;
    BOOL fTerminal;
    const WCHAR __RPC_FAR *pwcText;
    ULONG ulLen;
    ULONG ulNsPrefixLen;
    PVOID pNode;
    PVOID pReserved;
    }	XML_NODE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_s_ifspec;


#ifndef __XMLPSR_LIBRARY_DEFINED__
#define __XMLPSR_LIBRARY_DEFINED__

/* library XMLPSR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_XMLPSR;

#ifndef __IXMLNodeSource_INTERFACE_DEFINED__
#define __IXMLNodeSource_INTERFACE_DEFINED__

/* interface IXMLNodeSource */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361d-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory( 
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLineNumber( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLNodeSourceVtbl;

    interface IXMLNodeSource
    {
        CONST_VTBL struct IXMLNodeSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeSource_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLNodeSource_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLNodeSource_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLNodeSource_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLNodeSource_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLNodeSource_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLNodeSource_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLNodeSource_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLNodeSource_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLNodeSource_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLNodeSource_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeSource_SetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);


void __RPC_STUB IXMLNodeSource_SetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);


void __RPC_STUB IXMLNodeSource_GetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_Abort_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ BSTR bstrErrorInfo);


void __RPC_STUB IXMLNodeSource_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLineNumber_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLinePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLinePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetAbsolutePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetAbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLineBuffer_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
    /* [out] */ ULONG __RPC_FAR *pulLen,
    /* [out] */ ULONG __RPC_FAR *pulStartPos);


void __RPC_STUB IXMLNodeSource_GetLineBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLastError_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetErrorInfo_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);


void __RPC_STUB IXMLNodeSource_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetFlags_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetURL_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLNodeSource_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeSource_INTERFACE_DEFINED__ */


#ifndef __IXMLParser_INTERFACE_DEFINED__
#define __IXMLParser_INTERFACE_DEFINED__

/* interface IXMLParser */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361e-51a0-11d2-9caf-0060b0ec3d39")
    IXMLParser : public IXMLNodeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown __RPC_FAR *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID __RPC_FAR *ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInput )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PushData )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadDTD )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExpandEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID __RPC_FAR *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParserState )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLParserVtbl;

    interface IXMLParser
    {
        CONST_VTBL struct IXMLParserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLParser_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLParser_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLParser_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLParser_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLParser_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLParser_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLParser_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLParser_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLParser_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLParser_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLParser_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)


#define IXMLParser_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)

#define IXMLParser_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IXMLParser_SetInput(This,pStm)	\
    (This)->lpVtbl -> SetInput(This,pStm)

#define IXMLParser_PushData(This,pData,ulChars,fLastBuffer)	\
    (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer)

#define IXMLParser_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl)

#define IXMLParser_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)

#define IXMLParser_ParseEntity(This,pwcText,ulLen,fpe)	\
    (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe)

#define IXMLParser_ExpandEntity(This,pwcText,ulLen)	\
    (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen)

#define IXMLParser_SetRoot(This,pRoot)	\
    (This)->lpVtbl -> SetRoot(This,pRoot)

#define IXMLParser_GetRoot(This,ppRoot)	\
    (This)->lpVtbl -> GetRoot(This,ppRoot)

#define IXMLParser_Run(This,lChars)	\
    (This)->lpVtbl -> Run(This,lChars)

#define IXMLParser_GetParserState(This)	\
    (This)->lpVtbl -> GetParserState(This)

#define IXMLParser_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IXMLParser_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXMLParser_SetFlags(This,iFlags)	\
    (This)->lpVtbl -> SetFlags(This,iFlags)

#define IXMLParser_SetSecureBaseURL(This,pszBaseUrl)	\
    (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl)

#define IXMLParser_GetSecureBaseURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLParser_SetURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fAsync);


void __RPC_STUB IXMLParser_SetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Load_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker __RPC_FAR *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IXMLParser_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetInput_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pStm);


void __RPC_STUB IXMLParser_SetInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_PushData_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const char __RPC_FAR *pData,
    /* [in] */ ULONG ulChars,
    /* [in] */ BOOL fLastBuffer);


void __RPC_STUB IXMLParser_PushData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadDTD_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);


void __RPC_STUB IXMLParser_LoadDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_LoadEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ParseEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_ParseEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ExpandEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen);


void __RPC_STUB IXMLParser_ExpandEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID pRoot);


void __RPC_STUB IXMLParser_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID __RPC_FAR *ppRoot);


void __RPC_STUB IXMLParser_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Run_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ long lChars);


void __RPC_STUB IXMLParser_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetParserState_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_GetParserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Suspend_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Reset_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetFlags_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ ULONG iFlags);


void __RPC_STUB IXMLParser_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);


void __RPC_STUB IXMLParser_SetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLParser_GetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLParser_INTERFACE_DEFINED__ */


#ifndef __IXMLNodeFactory_INTERFACE_DEFINED__
#define __IXMLNodeFactory_INTERFACE_DEFINED__

/* interface IXMLNodeFactory */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361f-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyEvent )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Error )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNode )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        END_INTERFACE
    } IXMLNodeFactoryVtbl;

    interface IXMLNodeFactory
    {
        CONST_VTBL struct IXMLNodeFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeFactory_NotifyEvent(This,pSource,iEvt)	\
    (This)->lpVtbl -> NotifyEvent(This,pSource,iEvt)

#define IXMLNodeFactory_BeginChildren(This,pSource,pNodeInfo)	\
    (This)->lpVtbl -> BeginChildren(This,pSource,pNodeInfo)

#define IXMLNodeFactory_EndChildren(This,pSource,fEmpty,pNodeInfo)	\
    (This)->lpVtbl -> EndChildren(This,pSource,fEmpty,pNodeInfo)

#define IXMLNodeFactory_Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)

#define IXMLNodeFactory_CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeFactory_NotifyEvent_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODEFACTORY_EVENT iEvt);


void __RPC_STUB IXMLNodeFactory_NotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_BeginChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_BeginChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_EndChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmpty,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_EndChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_Error_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ HRESULT hrErrorCode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_CreateNode_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNodeParent,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLParser;

#ifdef __cplusplus

class DECLSPEC_UUID("d2423620-51a0-11d2-9caf-0060b0ec3d39")
XMLParser;
#endif
#endif /* __XMLPSR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\version\netprovver.h ===
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright (C) Microsoft Corp. 1995-2000\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft(R) is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0"

#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK

#define VER_PRODUCTNAME_STR      "Net Frameworks WMI Provider\0"

#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        	VFT_DLL

// Windows Specific

// BUG #1634 WGR: #define VER_PLATFORMINFO_STR         "Windows\0"
#define VER_FILEOS               VOS__WINDOWS32


#if defined( MIPS) || defined(_MIPS_)
	#define VER_PLATFORMINFO_STR         "MIPS\0"
#endif

#if defined(ALPHA) || defined(_ALPHA_)
	#define VER_PLATFORMINFO_STR         "ALPHA-AXP\0"
#endif

#if defined(_PPC_) || defined(PPC)
	#define VER_PLATFORMINFO_STR         "POWER PC\0"
#endif

// By default use Intel (_X86_)
#ifndef VER_PLATFORMINFO_STR
	#define VER_PLATFORMINFO_STR         "INTEL X86\0"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\version\mngdistver.h ===
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"mngdist.dll"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\version\wmisecver.h ===
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"WmiSec.dll"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\inc\version\wminet_utilsver.h ===
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"WMINet_Utils.dll"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\plugins\addremoveclear\addremoveclearplugin.h ===
//+--------------------------------------------------------------------------
//  Microsoft Genesis 
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File: addremoveclearplugin.h
//
//  $Header: $
//
//  Contents:
//
//  Classes:    Name                Description
//              -----------------   ---------------------------------------------
//
//
//  Functions:  Name                Description
//              ----------------    ---------------------------------------------
//
//
//---------------------------------------------------------------------------------
#ifndef __ADDREMOVECLEARPLUGIN_H__
#define __ADDREMOVECLEARPLUGIN_H__

#pragma once

#include "catalog.h"
#include "catmeta.h"
#include "catmacros.h"

class CAddRemoveClearPlugin: public ISimplePlugin
{
public:
	CAddRemoveClearPlugin();
	~CAddRemoveClearPlugin ();

    // IUnknown
    STDMETHOD (QueryInterface) (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)   ();
    STDMETHOD_(ULONG,Release)  ();

    // ISimplePlugin
    STDMETHOD (OnInsert)(ISimpleTableDispenser2* i_pDisp2, LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, DWORD i_fLOS, ULONG i_iRow, ISimpleTableWrite2* i_pISTW2);
    STDMETHOD (OnUpdate)(ISimpleTableDispenser2* i_pDisp2, LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, DWORD i_fLOS, ULONG i_iRow, ISimpleTableWrite2* i_pISTW2);
    STDMETHOD (OnDelete)(ISimpleTableDispenser2* i_pDisp2, LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, DWORD i_fLOS, ULONG i_iRow, ISimpleTableWrite2* i_pISTW2);
private:
	HRESULT Init (LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2 * pISTWrite, ISimpleTableDispenser2* i_pDisp2);
	HRESULT	ValidateRow (ISimpleTableWrite2 * pISTWrite, ULONG iRow);
	bool EqualDefaultValue (LPVOID pvValue, tCOLUMNMETARow * pColumnMeta);

	ULONG m_cRef;					 // reference count
	ULONG m_cNrColumns;				 // number of columns
	tCOLUMNMETARow * m_aColumnMeta;  // column meta information
	ULONG m_cClearValue;             // enum value of clear
	LPWSTR m_wszDatabase;			 // database name
	LPWSTR m_wszTable;				 // table name
	bool m_fInitialized;			 // are we initialized?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\plugins\directives\dirplug.cpp ===
// Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
// MERGE DIRECTIVES PLUGIN SAMPLE: TODO: BUGBUG: This is sample code: some work required to make it production quality!
/* E.g.:
<FavoriteColors>
	<FavoriteColor command="FinalAdd" color="black" />
	<FavoriteColor command="Add" color="red" />
		<FavoriteColor command="Remove" color="black" />
		<FavoriteColor command="FinalRemove" color="red" />
			<FavoriteColor command="Add" color="red" />
			<FavoriteColor command="Add" color="green" />
			<FavoriteColor command="Add" color="blue" />
				<FavoriteColor command="Clear" />
				<FavoriteColor command="Add" color="yellow" />
</FavoriteColors>

	black
	red
		black
			black
			green
			blue
				black
				yellow				
*/

#include "dirplug.h"
#include "catmacros.h"

#define cmaxCOLUMNS		20
#define cmaxDIRECTIVES	100
#define cmaxLEVELS		20

typedef enum
{
	eDIRECTIVE_ADD = 1,
	eDIRECTIVE_REMOVE,
	eDIRECTIVE_CLEAR,
	eDIRECTIVE_FINALADD,
	eDIRECTIVE_FINALREMOVE
};

// =======================================================================
CMergeDirectives::CMergeDirectives() :
	m_pISTDisp		(NULL),
	m_pISTMeta		(NULL),
	m_wszDatabase	(NULL),
	m_wszTable		(NULL),
	m_wszPath		(NULL),
	m_wszTmpPath	(NULL),
	m_apvValues		(NULL),
	m_acbSizes		(NULL),
	m_cColumns		(0),	// not allocated.
	m_iDirective	(~0),	// not allocated.
	m_iNavcolumn	(~0),	// not allocated.
	m_wszFile		(NULL), // not allocated.
	m_wszSub		(NULL), // not allocated.
	m_fLOS			(0),	// not allocated.
	m_cRef			(0)		// not allocated.

{
}
CMergeDirectives::~CMergeDirectives()
{
	m_pISTDisp->Release ();
	m_pISTMeta->Release ();
	delete [] m_wszDatabase;
	delete [] m_wszTable;
	delete [] m_wszPath;
	delete [] m_wszTmpPath;
	delete [] m_apvValues;
	delete [] m_acbSizes;
}

// =======================================================================
// IInterceptorPlugin:

HRESULT	CMergeDirectives::Intercept (LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat, DWORD i_fLOS, IAdvancedTableDispenser* i_pISTDisp, LPCWSTR i_wszLocator, LPVOID i_pSimpleTable, LPVOID* o_ppv)
{
	STQueryCell				aCells [] = {	{NULL, eST_OP_EQUAL, ~0, DBTYPE_WSTR, 0},
											{NULL, eST_OP_EQUAL, ~0, DBTYPE_WSTR, 0}	};
	STQueryCell*			pCell;
	ULONG					cCells, iColumn, iCell;
	DWORD*					pfMeta;
	ULONG*					pcColumns;
	LPWSTR					wszTmp;
	SimpleColumnMeta		aColumnMeta [cmaxCOLUMNS];
	HRESULT					hr = S_OK;

// Parameter validation:
	if (o_ppv == NULL || *o_ppv != NULL) return E_UNEXPECTED;
	if (i_pISTDisp == NULL) return E_UNEXPECTED;
	if (i_pSimpleTable == NULL) return E_UNEXPECTED;
	if (i_QueryData == NULL || *((ULONG*) i_QueryMeta) == 0) return E_UNEXPECTED;
	m_pISTDisp = i_pISTDisp;

// Deintercept when merging is not wanted:
	if (i_fLOS & fST_LOS_NOMERGE) return E_ST_OMITDISPENSER;

// Determine whether this table has directives:
	aCells[0].pData = (void*) i_wszDatabase;
	aCells[0].iCell = iTABLEMETA_Database;
	aCells[1].pData = (void*) i_wszTable;
	aCells[1].iCell = iTABLEMETA_InternalName;
	cCells = 2;
	hr = m_pISTDisp->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA, aCells, &cCells, eST_QUERYFORMAT_CELLS, 0, (void**) &m_pISTMeta);
	if (FAILED (hr)) return hr;
	iColumn = iTABLEMETA_MetaFlags;
	hr = m_pISTMeta->GetColumnValues (0, 1, &iColumn, NULL, (void**) &pfMeta);
	if (FAILED (hr)) return hr;
	if (!(*pfMeta & fTABLEMETA_HASDIRECTIVES)) return E_ST_OMITDISPENSER;

// Determine column count:
	iColumn = iTABLEMETA_CountOfColumns;
	hr = m_pISTMeta->GetColumnValues (0, 1, &iColumn, NULL, (void**) &pcColumns);
	if (FAILED (hr)) return hr;
	m_cColumns = *pcColumns;

// Find directives and navigation column:
	if (m_cColumns > cmaxCOLUMNS) return E_OUTOFMEMORY; // TODO: BUGBUG: Support unlimited columns...
	hr = ((ISimpleTableRead2*) i_pSimpleTable)->GetColumnMetas (m_cColumns, NULL, aColumnMeta);
	if (FAILED (hr)) return hr;
	for (iColumn = 0; iColumn < m_cColumns; iColumn++)
	{
		if (aColumnMeta[iColumn].fMeta & fCOLUMNMETA_DIRECTIVE)
		{
			m_iDirective = iColumn;
		}
		if (aColumnMeta[iColumn].fMeta & fCOLUMNMETA_NAVCOLUMN)
		{
			if (aColumnMeta[iColumn].dbType != DBTYPE_WSTR) return E_UNEXPECTED; // TODO: BUGBUG: Support non-string key merges...
			m_iNavcolumn = iColumn;
		}
	}

// Verify file path specified:
	for (iCell = 0, cCells = *((ULONG*) i_QueryMeta), pCell = (STQueryCell*) i_QueryData; iCell < cCells; iCell++, pCell++)
	{
		if (pCell->iCell == iST_CELL_FILE) break;
	}
	if (iCell == cCells) return E_ST_INVALIDQUERY;
	if (pCell->dbType != DBTYPE_WSTR) return E_ST_INVALIDQUERY;
	if (pCell->pData == NULL) return E_ST_INVALIDQUERY;
	wszTmp = wcsstr ((LPWSTR) pCell->pData, L":\\");
	if (wszTmp == NULL || (wszTmp - 1) != pCell->pData)
	{
		wszTmp = wcsstr ((LPWSTR) pCell->pData, L":\\");
		if (wszTmp == NULL || wszTmp != pCell->pData)
		{
			return E_ST_INVALIDQUERY;
		}
	}
	if (wcsstr ((LPWSTR) pCell->pData, L"*") != NULL) return E_ST_INVALIDQUERY;

// Store file path, tmp path, name, and subpath:
	m_wszPath = new WCHAR [lstrlen ((LPWSTR) pCell->pData) + 1];
	if (m_wszPath == NULL) return E_OUTOFMEMORY;
	m_wszTmpPath = new WCHAR [lstrlen ((LPWSTR) pCell->pData) + 1];
	if (m_wszTmpPath == NULL) return E_OUTOFMEMORY;
	wcscpy (m_wszPath, (LPWSTR) pCell->pData);
	m_wszFile = wcsrchr (m_wszPath, L'\\') + 1;
	m_wszSub = wcschr (m_wszPath, L'\\') + 1;
	if (*m_wszSub == L'\\')
	{
		m_wszSub = wcschr (m_wszSub + 1, L'\\') + 1;
	}

// Store database, table, and level of service:
	m_wszDatabase = new WCHAR [lstrlen (i_wszDatabase) + 1];
	if (m_wszDatabase == NULL) return E_OUTOFMEMORY;
	wcscpy (m_wszDatabase, (LPWSTR) i_wszDatabase);
	m_wszTable = new WCHAR [lstrlen (i_wszTable) + 1];
	if (m_wszTable == NULL) return E_OUTOFMEMORY;
	wcscpy (m_wszTable, (LPWSTR) i_wszTable);
	m_fLOS = i_fLOS;

// Allocate sizes and values array arrays:
	// TODO: BUGBUG: Should support ulimited directives:
	m_apvValues = new LPVOID [m_cColumns * cmaxDIRECTIVES];
	if (m_apvValues == NULL) return E_OUTOFMEMORY;
	m_acbSizes = new ULONG [m_cColumns * cmaxDIRECTIVES];
	if (m_acbSizes == NULL) return E_OUTOFMEMORY;
	
// Return received cache and addref self:
	*o_ppv = i_pSimpleTable;
    AddRef ();
	return S_OK;
}

HRESULT CMergeDirectives::OnPopulateCache(ISimpleTableWrite2* i_pISTShell)
{
	STQueryCell				aCells [] = {{NULL, eST_OP_EQUAL, iST_CELL_FILE, DBTYPE_WSTR, 0}};
	ULONG					cCells, iRow, iRoam, cDirectives, cLevels;
	LPWSTR					wszSub;
	LPWSTR					wszPath = NULL;
	WCHAR					wchSub;
	ISimpleTableRead2*		apISTRead [cmaxLEVELS];
	ISimpleTableController*	pISTControl = NULL;
	HRESULT					hr = S_OK;

	if (i_pISTShell == NULL) return E_UNEXPECTED;

// Accumulate directives:
	cDirectives = 0;
	for (wszSub = m_wszSub, cLevels = 0; wszSub != NULL; wszSub = wcschr (wszSub, L'\\'))
	{
		if (cLevels > cmaxLEVELS) return E_OUTOFMEMORY;

	// Build sub-path in query cell:
		wszSub++;
		wchSub = *wszSub;
		*wszSub = L'\0';
		wcscpy (m_wszTmpPath, m_wszPath);
		*wszSub = wchSub;
		wcscat (m_wszTmpPath, m_wszFile);

	// Get table:
		aCells[0].pData = m_wszTmpPath;
		cCells = 1;
		apISTRead[cLevels] = NULL;
		hr= m_pISTDisp->GetTable (m_wszDatabase, m_wszTable, aCells, &cCells, eST_QUERYFORMAT_CELLS, m_fLOS | fST_LOS_NOMERGE, (void**) &(apISTRead[cLevels])); // TODO: BUGBUG: Not passing whole query through.
		if (FAILED (hr)) continue;
		cLevels++;

	// Accumulate directives:
		for (iRow = 0;; iRow++)
		{
			if (cDirectives == cmaxDIRECTIVES) return E_OUTOFMEMORY;
			hr = (apISTRead[cLevels-1])->GetColumnValues (iRow, m_cColumns, NULL, &(m_acbSizes [cDirectives*m_cColumns]), &(m_apvValues [cDirectives*m_cColumns]));
			if (E_ST_NOMOREROWS == hr) break;
			if (FAILED (hr)) return hr;
			cDirectives++;
		}
	}

// Process directives:
	for (iRow = 0; iRow < cDirectives; iRow++)
	{
		switch (*((DWORD*) m_apvValues[(iRow * m_cColumns) + m_iDirective]))
		{
			case eDIRECTIVE_FINALADD:
			case eDIRECTIVE_ADD: // ie: Add except on a prior final remove:
				for (iRoam = 0; iRoam < iRow; iRoam++)
				{
					if (*((DWORD*) m_apvValues[(iRoam * m_cColumns) + m_iDirective]) == eDIRECTIVE_FINALREMOVE)
					{
						if (0 == lstrcmpi ((LPWSTR) m_apvValues[(iRoam * m_cColumns) + m_iNavcolumn], (LPWSTR) m_apvValues[(iRow * m_cColumns) + m_iNavcolumn]))
						{
							*((DWORD*) m_apvValues[(iRow * m_cColumns) + m_iDirective]) = 0;
						}
					}
				}
			break;
			case eDIRECTIVE_FINALREMOVE:
			case eDIRECTIVE_REMOVE: // ie: Remove all prior except on a prior final add:
				for (iRoam = 0; iRoam < iRow; iRoam++)
				{
					if (*((DWORD*) m_apvValues[(iRoam * m_cColumns) + m_iDirective]) == eDIRECTIVE_FINALADD)
					{
						if (0 == lstrcmpi ((LPWSTR) m_apvValues[(iRoam * m_cColumns) + m_iNavcolumn], (LPWSTR) m_apvValues[(iRow * m_cColumns) + m_iNavcolumn]))
						{
							*((DWORD*) m_apvValues[(iRow * m_cColumns) + m_iDirective]) = 0;
						}
					}
				}
				if (*((DWORD*) m_apvValues[(iRow * m_cColumns) + m_iDirective]) != 0)
				{
					for (iRoam = 0; iRoam < iRow; iRoam++)
					{
						if (*((DWORD*) m_apvValues[(iRoam * m_cColumns) + m_iDirective]) == eDIRECTIVE_ADD)
						{
							if (0 == lstrcmpi ((LPWSTR) m_apvValues[(iRoam * m_cColumns) + m_iNavcolumn], (LPWSTR) m_apvValues[(iRow * m_cColumns) + m_iNavcolumn]))
							{
								*((DWORD*) m_apvValues[(iRoam * m_cColumns) + m_iDirective]) = 0;
							}
						}
					}
					if (*((DWORD*) m_apvValues[(iRow * m_cColumns) + m_iDirective]) == eDIRECTIVE_REMOVE)
					{
						*((DWORD*) m_apvValues[(iRow * m_cColumns) + m_iDirective]) = 0;
					}
				}
			break;
			case eDIRECTIVE_CLEAR: // ie: Clear all prior except final adds and removes:
				for (iRoam = 0; iRoam < iRow; iRoam++)
				{
					if (*((DWORD*) m_apvValues[(iRoam * m_cColumns) + m_iDirective]) == eDIRECTIVE_FINALADD || *((DWORD*) m_apvValues[(iRoam * m_cColumns) + m_iDirective]) == eDIRECTIVE_FINALREMOVE)
					{
						continue;
					}
					*((DWORD*) m_apvValues[(iRoam * m_cColumns) + m_iDirective]) = 0;
				}
			break;
			default:
				*((DWORD*) m_apvValues[(iRow * m_cColumns) + m_iDirective]) = 0;
			break;
		}
	}
	// TODO: Remove duplicates here...

// Construct merged view:
	hr = i_pISTShell->QueryInterface (IID_ISimpleTableController, (void**) &pISTControl);
	if (FAILED (hr)) return hr;
	hr = pISTControl->PrePopulateCache (0);
	if (FAILED (hr)) return hr;
	for (iRow = 0; iRow < cDirectives; iRow++)
	{
		if (*((DWORD*) m_apvValues[(iRow * m_cColumns) + m_iDirective]) == eDIRECTIVE_ADD || *((DWORD*) m_apvValues[(iRow * m_cColumns) + m_iDirective]) == eDIRECTIVE_FINALADD)
		{
			*((DWORD*) m_apvValues[(iRow * m_cColumns) + m_iDirective]) = 0;
			hr = i_pISTShell->AddRowForInsert (&iRoam);
			if (FAILED (hr)) return hr;
			hr = i_pISTShell->SetWriteColumnValues (iRoam, m_cColumns, NULL, &(m_acbSizes[iRow * m_cColumns]), &(m_apvValues[iRow * m_cColumns]));
			if (FAILED (hr)) return hr;
		}		
	}
	hr = pISTControl->PostPopulateCache ();
	if (FAILED (hr)) return hr;
	pISTControl->Release ();


// Release tables:
	for (iRoam = 0; iRoam < cLevels; iRoam++)
	{
		(apISTRead[iRoam])->Release ();
	}
	return hr;
}

HRESULT CMergeDirectives::OnUpdateStore(ISimpleTableWrite2* i_pISTShell)
{
	return E_NOTIMPL;
}

// =======================================================================
// IUnknown:

STDMETHODIMP CMergeDirectives::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_ISimpleTableInterceptor)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}
	else if (riid == IID_IInterceptorPlugin)
	{
		*ppv = (IInterceptorPlugin*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (IInterceptorPlugin*) this;
	}

	if (NULL != *ppv)
	{
		((IInterceptorPlugin*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
	
}

STDMETHODIMP_(ULONG) CMergeDirectives::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

STDMETHODIMP_(ULONG) CMergeDirectives::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\plugins\directives\dirplug.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.

#ifndef __DIRPLUG_H_
#define __DIRPLUG_H_

#include "catalog.h"
#include "catmeta.h"

class CMergeDirectives: public IInterceptorPlugin
{
public:
	CMergeDirectives ();
	~CMergeDirectives ();

public:

	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

	STDMETHOD(Intercept)				(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat, DWORD i_fTable, IAdvancedTableDispenser* i_pISTDisp, LPCWSTR i_wszLocator, LPVOID i_pSimpleTable, LPVOID* o_ppv);
	STDMETHOD(OnPopulateCache)		    (ISimpleTableWrite2* i_pISTShell);
	STDMETHOD(OnUpdateStore)		    (ISimpleTableWrite2* i_pISTShell);
	
private:
	IAdvancedTableDispenser*		m_pISTDisp;
	ISimpleTableRead2*				m_pISTMeta;
	LPWSTR							m_wszDatabase;
	LPWSTR							m_wszTable;
	LPWSTR							m_wszPath;
	LPWSTR							m_wszTmpPath;
	LPVOID*							m_apvValues;
	ULONG*							m_acbSizes;
	ULONG							m_cColumns;
	ULONG							m_iDirective;
	ULONG							m_iNavcolumn;
	LPWSTR							m_wszFile;
	LPWSTR							m_wszSub;
	DWORD							m_fLOS;
	ULONG							m_cRef;
};

#endif // __DIRPLUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\plugins\addremoveclear\addremoveclearplugin.cpp ===
//+--------------------------------------------------------------------------
//  Microsoft Genesis 
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File: addremoveclearplugin.cpp
//
//  $Header: $
//
//  Contents:
//
//  Classes:    Name                Description
//              -----------------   ---------------------------------------------
//
//
//  Functions:  Name                Description
//              ----------------    ---------------------------------------------
//
//
//  History: marcelv 	8/31/2000		Initial Release
//
//---------------------------------------------------------------------------------

#include "addremoveclearplugin.h"
#include "smartpointer.h"

//=================================================================================
// Function: CAddRemoveClearPlugin::CAddRemoveClearPlugin
//
// Synopsis: Constructor
//=================================================================================
CAddRemoveClearPlugin::CAddRemoveClearPlugin ()
{
	m_cRef			= 0;
	m_cNrColumns	= 0;
	m_aColumnMeta   = 0;
	m_cClearValue	= 0;
	m_wszDatabase	= 0;
	m_wszTable		= 0;
	m_fInitialized	= false;
}

//=================================================================================
// Function: CAddRemoveClearPlugin::~CAddRemoveClearPlugin
//
// Synopsis: Destructor
//=================================================================================
CAddRemoveClearPlugin::~CAddRemoveClearPlugin ()
{
	delete [] m_aColumnMeta;
	m_aColumnMeta = 0;

	delete [] m_wszDatabase;
	m_wszDatabase = 0;

	delete [] m_wszTable;
	m_wszTable = 0;
}

//=================================================================================
// Function: CAddRemoveClearPlugin::QueryInterface
//
// Synopsis: Default implementation
//=================================================================================
STDMETHODIMP 
CAddRemoveClearPlugin::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv)
	{
		return E_INVALIDARG;
	}
	*ppv = NULL;

	if (riid == IID_ISimplePlugin)
	{
		*ppv = (ISimplePlugin*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (ISimplePlugin*) this;
	}
	else
	{
		return E_NOINTERFACE;
	}

	((ISimplePlugin*)this)->AddRef ();

	return S_OK;
}

//=================================================================================
// Function: CAddRemoveClearPlugin::AddRef
//
// Synopsis: Addref
//=================================================================================
ULONG
CAddRemoveClearPlugin::AddRef()
{
	return InterlockedIncrement ((LONG *)&m_cRef);
}

//=================================================================================
// Function: CAddRemoveClearPlugin::Release
//
// Synopsis: Release
//=================================================================================
ULONG
CAddRemoveClearPlugin::Release()
{
	ULONG cRef = InterlockedDecrement((LONG *)&m_cRef);
	if (cRef == 0)
	{
		delete this;
	}
	return cRef;
}

//=================================================================================
// Function: CAddRemoveClearPlugin::OnInsert
//
// Synopsis: Verify that a row is valid. Calls the ValidateRow function to do the dirty work
//
// Arguments: [i_wszDatabase] - database
//            [i_wszTable] - table
//            [i_fLOS] - LOS
//            [i_Row] - row to check in the write cache
//            [i_pISTW2] - pointer to use to get to write cache
//            [i_pDisp2] - dispenser
//            
// Return Value: S_OK if row is logically consistent, error else
//=================================================================================
HRESULT
CAddRemoveClearPlugin::OnInsert(ISimpleTableDispenser2* i_pDisp2, LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, DWORD /*i_fLOS*/, ULONG i_Row, ISimpleTableWrite2* i_pISTW2)
{
	HRESULT hr = Init (i_wszDatabase, i_wszTable, i_pISTW2, i_pDisp2);
	if (FAILED (hr))
	{
		TRACE (L"Init failed in CAddRemoveClearPlugin");
		return hr;
	}

	hr = ValidateRow (i_pISTW2, i_Row);
	if (FAILED (hr))
	{
		TRACE (L"ValidateRow failed for row %d in CAddRemoveClearPlugin", i_Row);
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CAddRemoveClearPlugin::OnUpdate
//
// Synopsis: Checks if row is consistent when a row is updated
//
// Arguments: [i_wszDatabase] - database
//            [i_wszTable] - table
//            [i_fLOS] - LOS
//            [i_Row] - row in write cache that got updated
//            [i_pISTW2] - pointer to get to write cache
//            [i_pDisp2] - dispenser
//            
// Return Value: S_OK if row is logically consistent, error else
//=================================================================================
HRESULT
CAddRemoveClearPlugin::OnUpdate(ISimpleTableDispenser2* i_pDisp2, LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, DWORD /*i_fLOS*/, ULONG i_Row, ISimpleTableWrite2* i_pISTW2)
{
	HRESULT hr = Init (i_wszDatabase, i_wszTable, i_pISTW2, i_pDisp2);
	if (FAILED (hr))
	{
		TRACE (L"Init failed in CAddRemoveClearPlugin");
		return hr;
	}

	hr = ValidateRow (i_pISTW2, i_Row);
	if (FAILED (hr))
	{
		TRACE (L"ValidateRow failed for row %d in CAddRemoveClearPlugin", i_Row);
		return hr;
	}

	return S_OK;
}

//=================================================================================
// Function: CAddRemoveClearPlugin::OnDelete
//
// Synopsis: Does nothing, because we always allow deletes
//=================================================================================
HRESULT
CAddRemoveClearPlugin::OnDelete(ISimpleTableDispenser2* /*i_pDisp2*/, LPCWSTR /*i_wszDatabase*/, LPCWSTR /*i_wszTable*/, DWORD /*i_fLOS*/, ULONG /*i_Row*/, ISimpleTableWrite2* /*i_pISTW2*/)
{
    return S_OK;
}

HRESULT
CAddRemoveClearPlugin::Init (LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2 * i_pISTWrite, ISimpleTableDispenser2* i_pDisp2)
{
	ASSERT (i_wszDatabase != 0);
	ASSERT (i_wszTable != 0);
	ASSERT (i_pISTWrite != 0);
	ASSERT (i_pDisp2 != 0);

	// If we are already initialized, we return immediately. This prevent lots of overhead of retrieving
	// meta information.
	if (m_fInitialized)
	{
		ASSERT (wcscmp (i_wszDatabase, m_wszDatabase) == 0);
		ASSERT (wcscmp (i_wszTable, m_wszTable) == 0);
		return S_OK;
	}

	// Get number of columns for the table
	HRESULT hr = i_pISTWrite->GetTableMeta (0,0,0, &m_cNrColumns);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get table meta");
		return hr;
	}

	// if no columns, nothing to check, so get out of here
	if (m_cNrColumns == 0)
	{
		m_fInitialized = true;
		return S_OK;
	}

	// Get the meta information for all the columns
	m_aColumnMeta = new tCOLUMNMETARow[m_cNrColumns];
	if (m_aColumnMeta == 0)
	{
		return E_OUTOFMEMORY;
	}

	STQueryCell cell;
	cell.pData		= (void *) i_wszTable;
	cell.eOperator	= eST_OP_EQUAL;
	cell.iCell		= iCOLUMNMETA_Table;
	cell.dbType		= DBTYPE_WSTR;
	cell.cbSize		= 0;
	ULONG cCell		= 1;

	CComPtr<ISimpleTableRead2> spRead;
	hr = i_pDisp2->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, &cell, &cCell, eST_QUERYFORMAT_CELLS, 0, (void **) &spRead);
	if (FAILED (hr))
	{
		TRACE (L"GetTable failed for database META, table COLUMNMETA");
		return hr;
	}

	for (ULONG idx=0; idx < m_cNrColumns; ++idx)
	{
		hr = spRead->GetColumnValues (idx, cCOLUMNMETA_NumberOfColumns, 0, 0, (LPVOID *)(m_aColumnMeta + idx));
		if (FAILED (hr))
		{
			TRACE (L"GetColumnValues failed for column %d of COLUMNMETA", idx);
			return hr;
		}
	}

	ASSERT (*m_aColumnMeta[0].pMetaFlags & fCOLUMNMETA_DIRECTIVE); // catutil should be enforcing this

	ULONG zero = 0;
	STQueryCell tagcell[2];
	tagcell[0].pData		= (void *) i_wszTable;
	tagcell[0].eOperator	= eST_OP_EQUAL;
	tagcell[0].iCell		= iTAGMETA_Table;
	tagcell[0].dbType		= DBTYPE_WSTR;
	tagcell[0].cbSize		= 0;
	tagcell[1].pData		= (void *) &zero;
	tagcell[1].eOperator	= eST_OP_EQUAL;
	tagcell[1].iCell		= iTAGMETA_ColumnIndex;
	tagcell[1].dbType		= DBTYPE_UI4;
	tagcell[1].cbSize		= 0;
	ULONG ctagCell			= 2;

	CComPtr<ISimpleTableRead2> spTagRead;
	hr = i_pDisp2->GetTable (wszDATABASE_META, wszTABLE_TAGMETA, &tagcell, &ctagCell, eST_QUERYFORMAT_CELLS, 0, (void **) & spTagRead);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get TAGMETA information");
		return hr;
	}

	for (idx=0; ;++idx)
	{
		tTAGMETARow tagMeta;
		hr = spTagRead->GetColumnValues (idx, cTAGMETA_NumberOfColumns, 0, 0, (LPVOID *)&tagMeta);
		if (FAILED (hr))
		{	// E_ST_NOMOREROWS is error condition
			TRACE (L"GetColumnValues failed for TAGMETA information");
			return hr;
		}

		if (wcscmp ((LPWSTR)tagMeta.pPublicName, L"clear") == 0)
		{
			m_cClearValue = *((ULONG *)tagMeta.pValue);
			break;
		}
	}

	// Save the database and table name so that we can assert in the beginning of this function
	m_wszDatabase = new WCHAR [wcslen(i_wszDatabase) + 1];
	if (m_wszDatabase == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszDatabase, i_wszDatabase);

	m_wszTable = new WCHAR [wcslen(i_wszTable) + 1];
	if (m_wszTable == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszTable, i_wszTable);

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CAddRemoveClearPlugin::ValidateRow
//
// Synopsis: A row is valid if:
//           1) if it is </clear>, only the directive column is present. All other PK
//              columns have default values (cannot be null because of catutil enforcement), and
//              all non-PK column are null (or default value)
//           2) if is is not </clear>, all PK values that are persisted and are not a directive
//              should have values other than the default value
//
// Arguments: [pISTWrite] - 
//            [iRow] - 
//            
// Return Value: 
//=================================================================================
HRESULT
CAddRemoveClearPlugin::ValidateRow (ISimpleTableWrite2 *i_pISTWrite, ULONG i_iRow)
{
	ASSERT (m_fInitialized);
	ASSERT (i_pISTWrite != 0);

	TSmartPointerArray<LPVOID> apvValues = new LPVOID[m_cNrColumns];
	if (apvValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	// always read from the write cache, because when validate row is called during populate, the
	// records are still store in the write cache. For writing, it is normal to use GetWriteColumnValues.
	HRESULT hr = i_pISTWrite->GetWriteColumnValues (i_iRow, m_cNrColumns, 0, 0, 0, apvValues);
	if (FAILED (hr))
	{
		TRACE (L"GetColumnValues failed");
		return hr;
	}

	// go through all the colums and verify that:
	// if column is persistable PK column, and column does not have DIRECTIVE metaflag, the
	// value of the PK column need to be different

	// BUGBUG(marcelv) HARDCODED clear

	ASSERT (apvValues[0] != 0);

	ULONG cValDirectiveColumn = *((ULONG *)apvValues[0]);
	// HARDCODED TO 2. NEED TO USE TAGMETA INSTEAD !!!!

	if (cValDirectiveColumn == m_cClearValue) // </clear>
	{
		// all values should be empty for non-PKs
		// all values should be defaultValue for PKs
		for (ULONG idx=1; idx < m_cNrColumns; ++idx)
		{
			ULONG metaFlags = *m_aColumnMeta[idx].pMetaFlags;
			// PK values always have default (catutil enforces this). Further, they
			// have to be the same as default value in the </clear> case
			if (  (metaFlags & fCOLUMNMETA_PRIMARYKEY)		&&
				 !(metaFlags & fCOLUMNMETA_NOTPERSISTABLE)	&&
				 !(metaFlags & fCOLUMNMETA_DIRECTIVE)		&&
				 !EqualDefaultValue (apvValues[idx], m_aColumnMeta + idx))
			{
				TRACE (L"Invalid value encountered for column %d", idx);
				return E_ST_VALUEINVALID;
			}
			// non-PK must be 0, or must be equal to default value if not null
			else if (!(metaFlags & fCOLUMNMETA_PRIMARYKEY)	&&
					 apvValues[idx] != 0					&& 
					 !EqualDefaultValue (apvValues[idx], m_aColumnMeta + idx))
			{
				TRACE (L"Invalid value encountered for column %d", idx);
				return E_ST_VALUEINVALID;
			}
		}
	}
	else
	{
		// all values should be different then default values for PK that are persistable, and
		// that are not enum column

		for (ULONG idx=1; idx < m_cNrColumns; ++idx)
		{
			ULONG metaFlags = *m_aColumnMeta[idx].pMetaFlags;
			if (  (metaFlags & fCOLUMNMETA_PRIMARYKEY)		&&
				 !(metaFlags & fCOLUMNMETA_NOTPERSISTABLE)	&&
				 !(metaFlags & fCOLUMNMETA_DIRECTIVE)       &&
				 EqualDefaultValue (apvValues[idx], m_aColumnMeta + idx))
			{
				TRACE (L"Invalid value encountered for column %d", idx);
				return E_ST_VALUEINVALID;
			}
		}
	}

	return hr;
}


//=================================================================================
// Function: CAddRemoveClearPlugin::EqualDefaultValue
//
// Synopsis: Is the value (pvValue) equal to the default value. When either pvValue is null
//            or the defaulg value is null, the result is false (i.e. not equal).
//
// Arguments: [pvValue] - value to compare against default value
//            [pColumnMeta] - column meta for column that we want to compare against
//            
// Return Value: true when pvValue has the same value as default, false else
//=================================================================================
bool
CAddRemoveClearPlugin::EqualDefaultValue (LPVOID pvValue, tCOLUMNMETARow * pColumnMeta)
{
	ASSERT (pColumnMeta != 0);

	if (pvValue == 0 || pColumnMeta->pDefaultValue == 0)
	{
		return false;
	}

	bool fEqual = false;
	switch (*(pColumnMeta->pType))
	{
		case DBTYPE_WSTR:
			if (*(pColumnMeta->pMetaFlags) & fCOLUMNMETA_CASEINSENSITIVE)
			{
				fEqual = (_wcsicmp ((LPWSTR)pvValue, (LPWSTR)pColumnMeta->pDefaultValue) == 0);
			}
			else
			{
				fEqual = (wcscmp ((LPWSTR)pvValue, (LPWSTR)pColumnMeta->pDefaultValue) == 0);
			}
		break;

		case DBTYPE_UI4:
			fEqual = ((*(ULONG *)pvValue) == (*(ULONG*)pColumnMeta->pDefaultValue));
		break;

		default:
			ASSERT (FALSE && "Unsupported datatype");
			break;
	}

	return fEqual;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\plugins\metabasedifferencing\metabasedifferencing.h ===
//  Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.

#ifndef __METABASEDIFFERENCING_H__
#define __METABASEDIFFERENCING_H__

#ifndef __catalog_h__
    #include "catalog.h"
#endif
#ifndef AFX_STBASE_H__14A33215_096C_11D1_965A_00C04FB9473F__INCLUDED_
    #include "sdtfst.h"
#endif
#ifndef __TABLEINFO_H__  
    #include "catmeta.h"
#endif
#ifndef __ATLBASE_H__
    #include <atlbase.h>
#endif

class TMetabaseDifferencing: public IInterceptorPlugin
{
public:
	TMetabaseDifferencing ();
	~TMetabaseDifferencing ();

public:

	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

	STDMETHOD(Intercept)				(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat, DWORD i_fTable, IAdvancedTableDispenser* i_pISTDisp, LPCWSTR i_wszLocator, LPVOID i_pSimpleTable, LPVOID* o_ppv);
	STDMETHOD(OnPopulateCache)		    (ISimpleTableWrite2* i_pISTShell);
	STDMETHOD(OnUpdateStore)		    (ISimpleTableWrite2* i_pISTShell);
	
private:
    static ULONG                    m_kInsert;
    static ULONG                    m_kUpdate;
    static ULONG                    m_kDelete;
    static ULONG                    m_kDeleteNode;
    static ULONG                    m_kOne;
    static ULONG                    m_kTwo;
    static ULONG                    m_kZero;

	ULONG							m_cRef;
    long                            m_IsIntercepted;

    CComPtr<ISimpleTableWrite2>     m_ISTOriginal;
    CComPtr<ISimpleTableWrite2>     m_ISTUpdated;

    HRESULT DeleteNodeRow   (tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pIST);
    HRESULT DeleteRow       (tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pIST);
    HRESULT InsertRow       (tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pIST);
    HRESULT UpdateRow       (tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pIST);

    HRESULT GetColumnValues_AsMBPropertyDiff(ISimpleTableWrite2 *i_pISTWrite, ULONG i_iRow, ULONG o_aSizes[], tMBPropertyDiffRow &o_DiffRow);
};

#endif // __METABASEDIFFERENCING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\plugins\metabasedifferencing\metabasedifferencing.cpp ===
//  Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
#include "MetabaseDifferencing.h"
#include "catmacros.h"


ULONG   TMetabaseDifferencing::m_kInsert      = eMBPropertyDiff_Insert;
ULONG   TMetabaseDifferencing::m_kUpdate      = eMBPropertyDiff_Update;
ULONG   TMetabaseDifferencing::m_kDelete      = eMBPropertyDiff_Delete;
ULONG   TMetabaseDifferencing::m_kDeleteNode  = eMBPropertyDiff_DeleteNode;
ULONG   TMetabaseDifferencing::m_kOne         = 1;
ULONG   TMetabaseDifferencing::m_kTwo         = 1;
ULONG   TMetabaseDifferencing::m_kZero        = 0;


// =======================================================================
TMetabaseDifferencing::TMetabaseDifferencing() :
                 m_cRef         (0)
                ,m_IsIntercepted(0)
{
    ASSERT(cMBProperty_NumberOfColumns == (cMBPropertyDiff_NumberOfColumns - 1));
}

TMetabaseDifferencing::~TMetabaseDifferencing()
{
}

// =======================================================================
// IInterceptorPlugin:

HRESULT TMetabaseDifferencing::Intercept (LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat,
                                          DWORD i_fLOS, IAdvancedTableDispenser* i_pISTDisp,LPCWSTR /*i_wszLocator unused*/, LPVOID i_pSimpleTable, LPVOID* o_ppv)
{
// Parameter validation:
    if (_wcsicmp(i_wszDatabase,    wszDATABASE_METABASE)                    )return E_ST_INVALIDTABLE;
    if (_wcsicmp(   i_wszTable,    wszTABLE_MBPropertyDiff)                 )return E_ST_INVALIDTABLE;
    if (TABLEID_MBPropertyDiff != i_TableID                                 )return E_ST_INVALIDTABLE;
    if (                  NULL == i_QueryData                               )return E_INVALIDARG;
    if (                  NULL == i_QueryMeta                               )return E_INVALIDARG;
    if (                     2 >  *reinterpret_cast<ULONG *>(i_QueryMeta)   )return E_INVALIDARG;
    if ( eST_QUERYFORMAT_CELLS != i_eQueryFormat                            )return E_INVALIDARG;
    if (    ~fST_LOS_READWRITE &  i_fLOS                                    )return E_ST_LOSNOTSUPPORTED;
    if (                  NULL == i_pISTDisp                                )return E_INVALIDARG;
    if (                  NULL != i_pSimpleTable                            )return E_INVALIDARG;
    if (                  NULL == o_ppv                                     )return E_INVALIDARG;
    if (                  NULL != *o_ppv                                    )return E_INVALIDARG;

//Check the object state
    if(m_IsIntercepted) return E_ST_INVALIDCALL;

    STQueryCell *   pQueryCell  = (STQueryCell*) i_QueryData;    // Query cell array from caller.
    STQueryCell     aQueryCellOriginalFile[2];//this holds the query with the OriginalFileName and optionally the SchemaFileName
    STQueryCell     aQueryCellUpdatedFile[2]; //this holds the query with the UpdatedFileName and optionally the SchemaFileName

    memset(aQueryCellOriginalFile, 0x00, 2*sizeof(STQueryCell));
    memset(aQueryCellUpdatedFile,  0x00, 2*sizeof(STQueryCell));

    ULONG           cQueryCount = i_QueryMeta ? *reinterpret_cast<ULONG *>(i_QueryMeta) : 0;
    for(ULONG iQueryCell=0; iQueryCell<cQueryCount; ++iQueryCell)//Get the only query cells we care about, and save the information.
    {
        if(pQueryCell[iQueryCell].iCell & iST_CELL_SPECIAL)
        {
            if(pQueryCell[iQueryCell].pData     != 0                  &&
               pQueryCell[iQueryCell].eOperator == eST_OP_EQUAL       &&
               pQueryCell[iQueryCell].iCell     == iST_CELL_FILE      &&
               pQueryCell[iQueryCell].dbType    == DBTYPE_WSTR        )
            {
                //The first iST_CELL_FILE should be the OriginalFile, the second should be the UpdatedFile.
                if(0 == aQueryCellOriginalFile[0].pData)
                    memcpy(&aQueryCellOriginalFile[0], &pQueryCell[iQueryCell], sizeof(STQueryCell));
                else if(0 == aQueryCellUpdatedFile[0].pData)
                    memcpy(&aQueryCellUpdatedFile[0], &pQueryCell[iQueryCell], sizeof(STQueryCell));
                else
                    return E_ST_INVALIDQUERY;//More than two file names?  Hmm, what would I do with that?
            }
            else if(pQueryCell[iQueryCell].pData!= 0                   &&
               pQueryCell[iQueryCell].eOperator == eST_OP_EQUAL        &&
               pQueryCell[iQueryCell].iCell     == iST_CELL_SCHEMAFILE &&
               pQueryCell[iQueryCell].dbType    == DBTYPE_WSTR        /*&&
               pQueryCell[iQueryCell].cbSize    == (wcslen(reinterpret_cast<WCHAR *>(pQueryCell[iQueryCell].pData))+1)*sizeof(WCHAR)*/)
            {
                memcpy(&aQueryCellOriginalFile[1], &pQueryCell[iQueryCell], sizeof(STQueryCell));
                memcpy(&aQueryCellUpdatedFile[1],  &pQueryCell[iQueryCell], sizeof(STQueryCell));
            }
        }
        else//Any query other than iST_CELL_SPECIAL is an INVALIDQUERY
            return E_ST_INVALIDQUERY;
    }
    if(0 == aQueryCellUpdatedFile[0].pData)//The user must supply two URLPaths.
        return E_ST_INVALIDQUERY;

    //Get the IST to the Original Metabase file
    HRESULT hr;
    if(FAILED(hr = i_pISTDisp->GetTable(wszDATABASE_METABASE, wszTABLE_MBProperty, aQueryCellOriginalFile, reinterpret_cast<LPVOID>(0==aQueryCellOriginalFile[1].pData ? &m_kOne : &m_kTwo),
                         eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<void **>(&m_ISTOriginal))))return hr;

    //Get the IST to the Update Metabase file
    if(FAILED(hr = i_pISTDisp->GetTable(wszDATABASE_METABASE, wszTABLE_MBProperty, aQueryCellUpdatedFile,  reinterpret_cast<LPVOID>(0==aQueryCellUpdatedFile[1].pData ? &m_kOne : &m_kTwo),
                         eST_QUERYFORMAT_CELLS, fST_LOS_NONE, reinterpret_cast<void **>(&m_ISTUpdated))))return hr;

    //Finally create the fast cache that will hold the difference of these two Metabase files/tables.
    if(FAILED(hr = i_pISTDisp->GetMemoryTable(i_wszDatabase, i_wszTable, i_TableID, 0, 0, i_eQueryFormat, i_fLOS, reinterpret_cast<ISimpleTableWrite2 **>(o_ppv))))
        return hr;

    InterlockedIncrement(&m_IsIntercepted);//We can only be called to Intercept once.

    return S_OK;
}

HRESULT TMetabaseDifferencing::OnPopulateCache(ISimpleTableWrite2* i_pISTW2)
{
// Construct merged view:
    CComQIPtr<ISimpleTableController, &IID_ISimpleTableController> pISTController = i_pISTW2;
    if(0 == pISTController.p)return E_UNEXPECTED;

    HRESULT hr;
	if (FAILED(hr = pISTController->PrePopulateCache (0))) return hr;


    ULONG aOriginalSize[cMBPropertyDiff_NumberOfColumns];
    ULONG aUpdatedSize[cMBPropertyDiff_NumberOfColumns];

    memset(aOriginalSize, 0x00, sizeof(aOriginalSize));
    memset(aUpdatedSize,  0x00, sizeof(aUpdatedSize));

    ULONG iRowOriginal=0;
    ULONG iRowUpdated =0;
    ULONG cRowOriginal=0;
    ULONG cRowUpdated =0;

    if(FAILED(hr = m_ISTOriginal->GetTableMeta(0, 0, &cRowOriginal, 0)))return hr;
    if(FAILED(hr = m_ISTUpdated->GetTableMeta(0, 0, &cRowUpdated,  0)))return hr;

//         WCHAR *     pName;
//         ULONG *     pType;
//         ULONG *     pAttributes;
// unsigned char *     pValue;
//         ULONG *     pGroup;
//         WCHAR *     pLocation;
//         ULONG *     pID;
//         ULONG *     pUserType;
//         ULONG *     pLocationID;
//         ULONG *     pDirective;

    tMBPropertyDiffRow OriginalRow;
    ULONG PrevOriginalLocationID = 0;
    if(cRowOriginal > 0)
    {
        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
            return hr;
    }
	else
	{
		//initialize it
		memset (&OriginalRow, 0x00, sizeof (tMBPropertyDiffRow));
	}

    tMBPropertyDiffRow UpdatedRow;
    if(cRowUpdated > 0)
    {
        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
            return hr;
    }
	else
	{
		//initialize it
		memset (&UpdatedRow, 0x00, sizeof (tMBPropertyDiffRow));
	}

    while(iRowOriginal < cRowOriginal && iRowUpdated < cRowUpdated)
    {


        int iLocationCompare = _wcsicmp(OriginalRow.pLocation, UpdatedRow.pLocation);

        if(iLocationCompare == 0)
        {
            ULONG LocationIDOriginal = *OriginalRow.pLocationID;
            ULONG LocationIDUpdated  = *UpdatedRow.pLocationID;
            while(*OriginalRow.pLocationID==LocationIDOriginal || *UpdatedRow.pLocationID==LocationIDUpdated)
            {
                //There are three cases we need to handle.  The current Rows we are comparing are:
                //  1> Both Original metabase and Updated metabase are at the same location (always true the first time through the loop)
                //  2> The Updated metabase row now points to a different location.  This means all remaining of the Original metabase rows for the
                //          location should be marked as Deleted.
                //  3> The Original metabase row now points to a different location.  This means all remaining of the Updated metabase rows for the
                //          location should be marked as Inserted.

                if(*OriginalRow.pLocationID==LocationIDOriginal && *UpdatedRow.pLocationID==LocationIDUpdated)
                {
                    //Now go through all of the properties for this location and compare them
                    int iNameCompare = _wcsicmp(OriginalRow.pName, UpdatedRow.pName);

                    if(iNameCompare == 0)
                    {   //Now go through each of the attributes of this property to see if this property has changed
                        if(     *OriginalRow.pType              != *UpdatedRow.pType
                            ||  *OriginalRow.pAttributes        != *UpdatedRow.pAttributes
                            ||  *OriginalRow.pGroup             != *UpdatedRow.pGroup
                            ||  *OriginalRow.pID                != *UpdatedRow.pID
                            ||  *OriginalRow.pUserType          != *UpdatedRow.pUserType
                            ||  aOriginalSize[iMBProperty_Value]!= aUpdatedSize[iMBProperty_Value]
                            ||  memcmp(OriginalRow.pValue ? reinterpret_cast<void *>(OriginalRow.pValue) : reinterpret_cast<void *>(&m_kZero),
                                       UpdatedRow.pValue  ? reinterpret_cast<void *>(UpdatedRow.pValue)  : reinterpret_cast<void *>(&m_kZero), aOriginalSize[iMBProperty_Value]))
                        {//The row needs to be updated
                            if(FAILED(hr = UpdateRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;
                        }

                        ++iRowOriginal;
                        if(iRowOriginal < cRowOriginal)
                        {
                            PrevOriginalLocationID = *OriginalRow.pLocationID;
                            if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                                return hr;
                        }

                        ++iRowUpdated;
                        if(iRowUpdated < cRowUpdated)
                        {
                            if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
                                return hr;
                        }
                        if(iRowUpdated == cRowUpdated || iRowOriginal == cRowOriginal)
                            break;
                    }
                    else if(iNameCompare < 0)
                    {   //The OriginalRow.pName property was removed
                        OriginalRow.pLocationID = UpdatedRow.pLocationID;//This makes the LocationID match the UpdatedRow
                        //This is important so an Insert followed by a Delete  (of the same location) have the same LocationID

                        if(FAILED(hr = DeleteRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;

                        ++iRowOriginal;
                        if(iRowOriginal == cRowOriginal)//if we reached the end of the Original properties then bail the while loop
                            break;
                        PrevOriginalLocationID = *OriginalRow.pLocationID;
                        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                            return hr;
                    }
                    else //if(iNameCompare > 0)
                    {   //The UpdatedRow.pName property was added
                        if(FAILED(hr = InsertRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;

                        ++iRowUpdated;
                        if(iRowUpdated == cRowUpdated)//if we reached the end of the Updated property list then bail the while loop
                            break;
                        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
                            return hr;
                    }
                }
                else if(*UpdatedRow.pLocationID!=LocationIDUpdated)
                {   //While walking through the properties within this location, we reached the end of the Updated location but NOT the original location.
                    //So we need to mark all of the remaining Original properties under this location as 'Deleted'
                    while(*OriginalRow.pLocationID==LocationIDOriginal)
                    {
                        OriginalRow.pLocationID = &LocationIDUpdated;//This makes the LocationID match the UpdatedRow
                        //This is important so an Insert followed by a Delete  (of the same location) have the same LocationID

                        if(FAILED(hr = DeleteRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;

                        ++iRowOriginal;
                        if(iRowOriginal == cRowOriginal)//if we reached the end of the Original properties then bail the while loop
                            break;
                        PrevOriginalLocationID = *OriginalRow.pLocationID;
                        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                            return hr;
                    }
                }
                else 
                {
                    ASSERT(*OriginalRow.pLocationID!=LocationIDOriginal);
                    //While walking through the properties within this location, we reached the end of the Original location but NOT the Update location.
                    //So we need to mark all of the remaining Update properties in this locations as Inserted
                    while(*UpdatedRow.pLocationID==LocationIDUpdated)
                    {
                        if(FAILED(hr = InsertRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;

                        ++iRowUpdated;
                        if(iRowUpdated == cRowUpdated)//if we reached the end of the Updated property list then bail the while loop
                            break;
                        if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
                            return hr;
                    }
                }
            }
        }
        else if(iLocationCompare < 0)
        {   //The OriginalRow.pLocation was removed
            //Add a row to the cache indicating this location was Deleted (a DeleteNode)
            if(FAILED(hr = DeleteNodeRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;

            ULONG LocationID = *OriginalRow.pLocationID;
            PrevOriginalLocationID = *OriginalRow.pLocationID;
            while(LocationID == *OriginalRow.pLocationID && ++iRowOriginal<cRowOriginal)
            {
                if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                    return hr;
            }
        }
        else// if(iLocationCompare > 0)
        {   //The UpdatedRow,pLocation was added 
            ULONG LocationID = *UpdatedRow.pLocationID;
            UpdatedRow.pDirective = &m_kInsert;//It's OK to set this outside the loop since GetColumnValues won't overwrite it (since we're doing cMBProperty_NumberOfColumns)

            while(LocationID == *UpdatedRow.pLocationID)
            {//For each property within this location add a row to the cache indicating an Insert
                if(FAILED(hr = InsertRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;

                ++iRowUpdated;
                if(iRowUpdated == cRowUpdated)//if we just inserted the last row then bail the while loop
                    break;
                if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
                    return hr;
            }
        }
    }

    //Now unless both iRowOriginal==cRowOriginal && iRowUpdated==cRowUpdated
    //we still have work to do.
    //If iRowOriginal!=cRowOriginal, then we have to Delete the remaining Original rows.
    if(iRowOriginal!=cRowOriginal)
    {
        if(PrevOriginalLocationID == *OriginalRow.pLocationID)
        {
            if(FAILED(hr = DeleteRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;

            //This first while loop deletes each property within the current LocationID
            while(++iRowOriginal<cRowOriginal && PrevOriginalLocationID==*OriginalRow.pLocationID)
            {
                if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                    return hr;

                if(PrevOriginalLocationID != *OriginalRow.pLocationID)
                    break;
                if(FAILED(hr = DeleteRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;
            }
        }
        //This loop adds Deleted Nodes rows
        while(iRowOriginal<cRowOriginal)
        {
            ASSERT(PrevOriginalLocationID != *OriginalRow.pLocationID);//The only way the above or below loops can exit is iRow==cRow OR this condition

            OriginalRow.pID = &m_kZero;
            if(FAILED(hr = DeleteNodeRow(OriginalRow, aOriginalSize, i_pISTW2)))return hr;
            PrevOriginalLocationID = *OriginalRow.pLocationID;

            while(PrevOriginalLocationID == *OriginalRow.pLocationID && ++iRowOriginal<cRowOriginal)
            {
                if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTOriginal, iRowOriginal, aOriginalSize, OriginalRow)))
                    return hr;
            }
        }
    }
    //If iRowUpdated!=cRowUpdated, then we need to Insert the remaining Updated rows.
    else if(iRowUpdated!=cRowUpdated)
    {
        if(FAILED(hr = InsertRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;
        while(++iRowUpdated<cRowUpdated)
        {
            if(FAILED(hr = GetColumnValues_AsMBPropertyDiff(m_ISTUpdated, iRowUpdated, aUpdatedSize, UpdatedRow)))
                return hr;

            if(FAILED(hr = InsertRow(UpdatedRow, aUpdatedSize, i_pISTW2)))return hr;
        }
    }

	return pISTController->PostPopulateCache ();
}

HRESULT TMetabaseDifferencing::OnUpdateStore(ISimpleTableWrite2* i_pISTShell)
{
    return E_NOTIMPL;
}

// =======================================================================
// IUnknown:

STDMETHODIMP TMetabaseDifferencing::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv) 
        return E_INVALIDARG;
    *ppv = NULL;

    if (riid == IID_ISimpleTableInterceptor)
    {
        *ppv = (ISimpleTableInterceptor*) this;
    }
    else if (riid == IID_IInterceptorPlugin)
    {
        *ppv = (IInterceptorPlugin*) this;
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = (IInterceptorPlugin*) this;
    }

    if (NULL != *ppv)
    {
        ((IInterceptorPlugin*)this)->AddRef ();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
    
}

STDMETHODIMP_(ULONG) TMetabaseDifferencing::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);
    
}

STDMETHODIMP_(ULONG) TMetabaseDifferencing::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
    {
        delete this;
    }
    return cref;
}

//private members
HRESULT TMetabaseDifferencing::DeleteNodeRow(tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;
    ULONG iCacheRow;
    if(FAILED(hr = i_pISTW2->AddRowForInsert(&iCacheRow)))return hr;

    row.pName      = reinterpret_cast<WCHAR *>(&m_kZero);
    row.pType      = &m_kZero;
    row.pAttributes= &m_kZero;
    row.pValue     = reinterpret_cast<unsigned char *>(&m_kZero);
    row.pGroup     = &m_kZero;
    //row.pLocation leave location alone
    row.pID        = &m_kZero;
    row.pUserType  = &m_kZero;
    row.pDirective = &m_kDeleteNode;
    aSize[iMBPropertyDiff_Value] = 1;//No need to copy the entire value since it's not going to be accessed anyway.
    return i_pISTW2->SetWriteColumnValues(iCacheRow, cMBPropertyDiff_NumberOfColumns, 0, aSize, reinterpret_cast<void **>(&row));
}

HRESULT TMetabaseDifferencing::DeleteRow(tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;
    ULONG iCacheRow;
    if(FAILED(hr = i_pISTW2->AddRowForInsert(&iCacheRow)))return hr;

    row.pDirective = &m_kDelete;
    aSize[iMBPropertyDiff_Value] = 1;//No need to copy the entire value since it's not going to be accessed anyway.
    return i_pISTW2->SetWriteColumnValues(iCacheRow, cMBPropertyDiff_NumberOfColumns, 0, aSize, reinterpret_cast<void **>(&row));
}

HRESULT TMetabaseDifferencing::InsertRow(tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;
    ULONG iCacheRow;
    if(FAILED(hr = i_pISTW2->AddRowForInsert(&iCacheRow)))return hr;

    row.pDirective = &m_kInsert;
    return i_pISTW2->SetWriteColumnValues(iCacheRow, cMBPropertyDiff_NumberOfColumns, 0, aSize, reinterpret_cast<void **>(&row));
}

HRESULT TMetabaseDifferencing::UpdateRow(tMBPropertyDiffRow &row, ULONG *aSize, ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;
    ULONG iCacheRow;
    if(FAILED(hr = i_pISTW2->AddRowForInsert(&iCacheRow)))return hr;

    row.pDirective = &m_kUpdate;
    return i_pISTW2->SetWriteColumnValues(iCacheRow, cMBPropertyDiff_NumberOfColumns, 0, aSize, reinterpret_cast<void **>(&row));
}

HRESULT TMetabaseDifferencing::GetColumnValues_AsMBPropertyDiff(ISimpleTableWrite2 *i_pISTWrite, ULONG i_iRow, ULONG o_aSizes[], tMBPropertyDiffRow &o_DiffRow)
{
    HRESULT hr;
    tMBPropertyRow mbpropertyRow;

    if(FAILED(hr = i_pISTWrite->GetColumnValues(i_iRow, cMBProperty_NumberOfColumns, 0, o_aSizes, reinterpret_cast<void **>(&mbpropertyRow))))
        return hr;

    //The MBProperty table has the Same columns as MBPropertyDiff.  MBPropertyDiff has one additional column (Directive)
    //BUT!!! The columns are NOT in the exact same order.  So we need to map the columns correctly.

    o_DiffRow.pName       = mbpropertyRow.pName      ;
    o_DiffRow.pType       = mbpropertyRow.pType      ;
    o_DiffRow.pAttributes = mbpropertyRow.pAttributes;
    o_DiffRow.pValue      = mbpropertyRow.pValue     ;
    o_DiffRow.pLocation   = mbpropertyRow.pLocation  ;
    o_DiffRow.pID         = mbpropertyRow.pID        ;
    o_DiffRow.pUserType   = mbpropertyRow.pUserType  ;
    o_DiffRow.pLocationID = mbpropertyRow.pLocationID;

    o_DiffRow.pGroup      = mbpropertyRow.pGroup     ;
    o_DiffRow.pDirective  = 0                        ;

    ASSERT(o_DiffRow.pName      );
    ASSERT(o_DiffRow.pType      );
    ASSERT(o_DiffRow.pAttributes);
    //ASSERT(o_DiffRow.pValue);There doesn't have to be a Value
    ASSERT(o_DiffRow.pLocation  );
    ASSERT(o_DiffRow.pID        );
    ASSERT(o_DiffRow.pUserType  );
    ASSERT(o_DiffRow.pLocationID);
    ASSERT(o_DiffRow.pGroup     );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\chkstk\alpha\hitchhiker.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.

// An unlikely external name.
void Oh_Freddled_Gruntbuggly() {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\chkstk\i386\chkstk.asm ===
TITLE	vtable.asm
.386P
.model FLAT

	
_PAGESIZE_      equ     4096	; Intel x86 pages are 4K
	
	
_TEXT SEGMENT

	PUBLIC __chkstk
	PUBLIC __alloca_probe
	
__chkstk PROC NEAR
__alloca_probe:
	or	eax,eax
	jnz	nonzero		; Non-zero alloc
	ret			; Just return if zero was requested
	
nonzero:	
	push	eax		; Save alloc count
	push	edi		; Save non-volatile EDI
	lea	edi,[esp+12]	; Adjust for return address + saved registers
	cmp	eax,_PAGESIZE_	; More than one page requested?
	jb	short lastpage

probepages:
	sub	edi,_PAGESIZE_	; Move down a page
	sub	eax,_PAGESIZE_	; Decrease requested amount
	test	[edi],eax	; Probe it
	cmp	eax,_PAGESIZE_	; Still more than one page requested?
	jae	probepages

lastpage:
	sub	edi,eax		; Move down leftover amount on this page
	test	[edi],eax	; Probe it
	
	mov	eax,esp		; EAX = current top of stack
	mov	esp,edi		; Set the new stack pointer
	mov	edi,[eax+0]	; Recover EDI
	
	push	[eax+4]		; Save alloc count again
	push	[eax+8]		; Save return address again
	push	edi		; Save EDI again
	push	ecx		; Save ECX
	
	lea	edi,[esp+16]	; EDI = start of local variables
	mov	ecx,[esp+12]	; ECX = alloc count
	shr	ecx,2		; Convert bytes to DWORDS
	mov	eax,0deadbeefH	; EAX = fill value
	rep stosd [edi]

	pop	ecx
	pop	edi
	pop	eax
	add	esp,4		; Discard saved alloc count
	jmp	eax
			
__chkstk ENDP
	
	
		
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\hash\hash.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    Hash.cpp

$Header: $

--**************************************************************************/

// Hash.cpp : Defines the entry point for the console application.
//
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include "catmacros.h"
#include "Hash.h"

FILE		*stream;
typedef LPWSTR DATA;
#define MAXPRIME 151

int _cdecl main(int argc, char* argv[])
{
	WCHAR wszName[120];
	WCHAR wszMethod[120][MAXPRIME];
	DATA adIntIDTable[MAXPRIME];
	ULONG i = 0;

	memset(adIntIDTable, 0, sizeof(DATA)*MAXPRIME);

	stream = fopen( "interceptor.txt", "r" );
	if( stream == NULL )
		printf( "The file fscanf.out was not opened\n" );
	else
	{
		/* Set pointer to beginning of file: */
		fseek( stream, 0L, SEEK_SET );

		/* Read data back from file: */
		while (fwscanf( stream, L"%s %s", wszName, wszMethod[i]))
		{
			wprintf(L"%s %s\n", wszName, wszMethod[i]);
			if (adIntIDTable[Hash(wszName) % MAXPRIME] != NULL)
				throw;
			adIntIDTable[Hash(wszName) % MAXPRIME] = wszMethod[i++];
		}

		wprintf(L"PFNGETINTERCEPTOR auInterceptorHash[MAXPRIME] = {\n\t\t");
		for (i = 0; i < MAXPRIME-1; i++)
		{
			wprintf(L"%s, ", adIntIDTable[i] == NULL ? L"NULL" : adIntIDTable[i]);
			if (((i+1) % 10) == 0)
				wprintf(L"\n\t\t");
		}
		wprintf(L"%s};", adIntIDTable[MAXPRIME-1] == NULL ? L"NULL" : adIntIDTable[MAXPRIME-1]);

		fclose( stream );
	}
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\mofgen\commoninclude.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    CommonInclude.h

$Header: $

Abstract:

Author:
    mohits  5/9/2001        Initial Release

Revision History:

--**************************************************************************/

#ifndef __COMMONINCLUDE_H__
#define __COMMONINCLUDE_H__

#pragma once

#include <SmartPointer.h>
#include <wbemcli.h>

struct CimTypeStringMapping
{
    CIMTYPE cimtype;
    LPCWSTR wszString;
    LPCWSTR wszFormatString;
};

static CimTypeStringMapping CimTypeStringMappingData[] =
{
    { CIM_SINT8,        L"sint8"    ,    NULL      },
    { CIM_UINT8,        L"unit8"    ,    NULL      },
    { CIM_SINT16,       L"sint16"   ,    L"%hd"    },
    { CIM_UINT16,       L"uint16"   ,    L"%hu"    },
    { CIM_SINT32,       L"sint32"   ,    L"%d"     },
    { CIM_UINT32,       L"uint32"   ,    L"%u"     },
    { CIM_SINT64,       L"sint64"   ,    L"%I64d"  },
    { CIM_UINT64,       L"uint64"   ,    L"%I64u"  },
    { CIM_REAL32,       L"real32"   ,    NULL      },
    { CIM_REAL64,       L"real64"   ,    NULL      },
    { CIM_BOOLEAN,      L"boolean"  ,    NULL      },
    { CIM_STRING,       L"string"   ,    L"%s"     },
    { CIM_DATETIME,     L"datetime" ,    NULL      },
    { CIM_REFERENCE,    L"reference",    NULL      },
    { CIM_CHAR16,       L"char16"   ,    NULL      },
    { CIM_OBJECT,       L"object"   ,    NULL      },
    { 0,                NULL        ,    NULL      }
};

class CUtils
{
public:
    static CimTypeStringMapping* LookupCimType(
        CIMTYPE cimtype)
    {
        for(ULONG i = 0; CimTypeStringMappingData[i].wszString != NULL; i++)
        {
            if(cimtype == CimTypeStringMappingData[i].cimtype)
            {
                return &CimTypeStringMappingData[i];
            }
        }

        return NULL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\dbtrace\dbtrace.cpp ===
//*****************************************************************************
//
// Microsoft Viper 96 (Microsoft Confidential)
// Copyright 1995 - 2001 Microsoft Corporation.  All Rights Reserved.
//
// Project:	DBTrace
// Module:	DBTrace.CPP
// Description:	Supports the DBTrace.H macros
// Author:		wilfr
// Create:		3/25/96
//-----------------------------------------------------------------------------
// Notes:
//
//	Use the trace macro for debug builds.  Output can be captured using the
//	debugger, DBMON, or the DBWin32 tool checked in under $\viper\tools\bin\dbwin32.exe
//	Only used during _DEBUG builds.
//
//-----------------------------------------------------------------------------
// Issues:
//
//	none
//
//-----------------------------------------------------------------------------
// Architecture:
//
//	All output is sent to OutputDebugString.
//
//
//*****************************************************************************

// Global includes
#include <unicode.h>
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdarg.h>

#include <dbtrace.h>

// Local includes

// Local preprocessor constructs

// Local type definitions

// Global variables.

// Static variables.
	
// Local function prototypes

//*****************************************************************************
// Function:	DebugTrace
// Implements:	tracing
// Description:	Formats a message and sends to OutputDebugString
// Inputs:		( TCHAR* tszMsg, ... ) Msg format specification and parameters (ala printf)
// Outputs:		none
// Return:		none
// Exceptions:	none
// Process:		n/a
//*****************************************************************************	

// warning: mtxdm's dllmain.cpp has a modified copy of this, so if you change this, you may want to change the other too.

#define BANNER_TEXT		_T("MTx: ")
#define BANNER_LENGTH	5				// must match length of banner
#define MSG_LEN			200

static BOOL FTracingEnabled();

void DebugTrace( TCHAR* tsz, ... )
{
	if (!FTracingEnabled())
		return;

	TCHAR	tszMsg[ BANNER_LENGTH + MSG_LEN + 1 ];
	va_list	args;

	va_start( args, tsz );

	_tcscpy(tszMsg, BANNER_TEXT);
	_vsntprintf( tszMsg + BANNER_LENGTH, MSG_LEN, tsz, args );
	OutputDebugString( tszMsg );

	va_end( args );
}

static BOOL FTracingEnabled()
{
	static BOOL fInitialized = FALSE;
	static BOOL fEnabled = FALSE;
	static wchar_t key[] = L"Software\\Microsoft\\Transaction Server\\Debug\\Trace";

	if (!fInitialized) {
		// There is a small, benign race in here -- in a very unlikely case
		// multiple concurrent callers could enter here.  But note the body
		// of the function is idempotent.
 		HKEY hkey;
		if (RegOpenKey(HKEY_LOCAL_MACHINE, key, &hkey) == ERROR_SUCCESS) {
			RegCloseKey(hkey);
			fEnabled = TRUE;
		}
		fInitialized = TRUE;
	}
	return fEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\mofgen\wmiclasses.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WMIClasses.h

$Header: $

Abstract:

Author:
    mohits     5/8/2001        Initial Release

Revision History:

--**************************************************************************/

#ifndef __WMICLASSES_H__
#define __WMICLASSES_H__

#pragma once

#include "mofgen.h"
#include "CommonInclude.h"
#include "WMIObjectBase.h"

//
// CWMIClass
//
class CWMIClass : public IWMIClass, public CWMIClassAndPropertyBase
{
public:
    CWMIClass();
    ~CWMIClass();

    STDMETHODIMP_(ULONG) AddRef()  { return CWMIClassAndPropertyBase::AddRef();  }
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP_(HRESULT) QueryInterface(
        REFIID riid, 
        void** ppvObject)
    {
        return CWMIClassAndPropertyBase::QueryInterface(riid, ppvObject);
    }

    HRESULT AddQualifier(
        IWMIQualifier*  i_pQualifier)
    {
        return CWMIClassAndPropertyBase::AddQualifier(i_pQualifier);
    }

    HRESULT AddQualifier(
        LPCWSTR         i_wszName,
        const VARIANT*  i_pvValue,
        ULONG           i_ulFlavors,
        IWMIQualifier** o_ppQualifier=NULL)
    {
        return CWMIClassAndPropertyBase::AddQualifier(
            i_wszName, i_pvValue, i_ulFlavors, o_ppQualifier);
    }

    HRESULT AddProperty(
        IWMIProperty*  i_pProperty);

    HRESULT AddProperty(
        LPCWSTR         i_wszName,
        VARTYPE         i_vartype,
        const VARIANT*  i_pvValue,
        IWMIProperty**  o_ppProperty=NULL);

    HRESULT SetName(
        LPCWSTR        i_wszName);

    HRESULT SetBaseClass(
        LPCWSTR        i_wszBaseClass);

    void SetPragmaDelete(bool i_bDelete) { m_bPragmaDelete = i_bDelete; }

    HRESULT WriteToFile(
        FILE*          i_pFile);

private:
    CWMIClass(const CWMIClass& );
    CWMIClass& operator= (const CWMIClass& );

    TSmartPointerArray<WCHAR> m_swszName;
    TSmartPointerArray<WCHAR> m_swszBaseClass;
    bool                      m_bPragmaDelete;

    CCfgArray<IWMIProperty*>  m_apProperties;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\mofgen\wmiobjectbase.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WMIObjectBase.cpp

$Header: $

Abstract:

Author:
    mohits     5/8/2001        Initial Release

Revision History:

--**************************************************************************/

#include "MofGen.h"
#include "WMIObjectBase.h"

//
// CWMIObjectBase
//

CWMIObjectBase::CWMIObjectBase()
{
    m_cRef = 0;
}

CWMIObjectBase::~CWMIObjectBase()
{
}

STDMETHODIMP_(ULONG) CWMIObjectBase::AddRef()
{
    return InterlockedIncrement((LPLONG) &m_cRef);
}

STDMETHODIMP_(HRESULT) CWMIObjectBase::QueryInterface(
    REFIID riid, 
    void** ppvObject)
{
    ASSERT(ppvObject);

    *ppvObject = NULL;

    if(riid == IID_IUnknown)
    {
        *ppvObject = this;
    }

    if(*ppvObject != NULL)
    {
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

//
// CWMIClassAndPropertyBase
//

CWMIClassAndPropertyBase::CWMIClassAndPropertyBase()
{
}

CWMIClassAndPropertyBase::~CWMIClassAndPropertyBase()
{
    ULONG cQualifiers = m_apQualifiers.Count();
    for(ULONG i = 0; i < cQualifiers; i++)
    {
        m_apQualifiers[i]->Release();
    }
}

HRESULT CWMIClassAndPropertyBase::AddQualifier(
    IWMIQualifier* i_pQualifier)
{
    ASSERT(i_pQualifier);

    HRESULT hr = m_apQualifiers.Append(i_pQualifier);
    if(FAILED(hr))
    {
        return hr;
    }
    i_pQualifier->AddRef();

    return S_OK;
}

HRESULT CWMIClassAndPropertyBase::AddQualifier(
    LPCWSTR         i_wszName,
    const VARIANT*  i_pvValue,
    ULONG           i_ulFlavors,
    IWMIQualifier** o_ppQualifier) //defaultvalue(NULL)
{
    CComPtr<IWMIQualifier> spQualifier;

    HRESULT hr = CMofGenerator::SpawnQualifierInstance(&spQualifier);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = spQualifier->Set(i_wszName, i_pvValue, i_ulFlavors);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = AddQualifier(spQualifier);
    if(FAILED(hr))
    {
        return hr;
    }

    if(o_ppQualifier)
    {
        ASSERT(*o_ppQualifier == NULL);
        *o_ppQualifier = spQualifier;
        (*o_ppQualifier)->AddRef();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\mofgen\mofgen.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    MofGen.cpp

$Header: $

Abstract:

Author:
    mohits     5/8/2001        Initial Release

Revision History:

--**************************************************************************/

#include "mofgen.h"
#include "WMIProperties.h"
#include "WMIQualifiers.h"
#include "WMIClasses.h"

//
// public, non-virtual methods
//

CMofGenerator::CMofGenerator()
{
}

CMofGenerator::~CMofGenerator()
{
    ULONG cClasses = m_apClasses.Count();
    for(ULONG i = 0; i < cClasses; i++)
    {
        m_apClasses[i]->Release();
    }
}

/*++

Synopsis: 
    Call this guy after you've added all your classes.

Arguments: [i_pFile] - Must be an open file with write perms.
           
Return Value: 
    HRESULT

--*/
HRESULT CMofGenerator::Generate(
    FILE*   i_pFile)
{
    ASSERT(i_pFile);

    HRESULT hr = S_OK;

    hr = WriteHeader(i_pFile);
    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "[%s] WriteHeader failed, hr=0x%x\n", __FUNCTION__, hr));
        return hr;
    }

    hr = WriteClasses(i_pFile);
    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "[%s] WriteClasses failed, hr=0x%x\n", __FUNCTION__, hr));
        return hr;
    }

    hr = WriteFooter(i_pFile);
    if(FAILED(hr))
    {
        DBGERROR((DBG_CONTEXT, "[%s] WriteFooter failed, hr=0x%x\n", __FUNCTION__, hr));
        return hr;
    }

    return hr;
}

/*++

Synopsis: 
    Before calling generate, add all your classes.

Arguments: [i_pClass] - 
           
Return Value: 
    HRESULT

--*/
HRESULT CMofGenerator::AddClass(
    IWMIClass* i_pClass)
{
    ASSERT(i_pClass);
    
    HRESULT hr = m_apClasses.Append(i_pClass);
    if(FAILED(hr))
    {
        return hr;
    }
    i_pClass->AddRef();

    return S_OK;
}

/*++

Synopsis: Creates a new IWMIClass with refcount = 1

Arguments: [o_ppClass] - 
           
Return Value: 
    HRESULT

--*/
HRESULT CMofGenerator::SpawnClassInstance(
    IWMIClass** o_ppClass)
{
    ASSERT(o_ppClass);
    ASSERT(*o_ppClass == NULL);

    CWMIClass* pClass = new CWMIClass;
    if(pClass == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pClass->AddRef();
    *o_ppClass = pClass;

    return S_OK;
}

/*++

Synopsis: Creates a new IWMIProperty with refcount = 1

Arguments: [o_ppProperty] - 
           
Return Value: 
    HRESULT

--*/
HRESULT CMofGenerator::SpawnPropertyInstance(
    IWMIProperty** o_ppProperty)
{
    ASSERT(o_ppProperty);
    ASSERT(*o_ppProperty == NULL);

    CWMIProperty* pProperty = new CWMIProperty;
    if(pProperty == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pProperty->AddRef();
    *o_ppProperty = pProperty;

    return S_OK;
}

/*++

Synopsis: Creates a new IWMIQualifier with refcount = 1

Arguments: [o_ppQualifier] - 
           
Return Value: 
    HRESULT

--*/
HRESULT CMofGenerator::SpawnQualifierInstance(
    IWMIQualifier** o_ppQualifier)
{
    ASSERT(o_ppQualifier);
    ASSERT(*o_ppQualifier == NULL);

    CWMIQualifier* pQualifier = new CWMIQualifier;
    if(pQualifier == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pQualifier->AddRef();
    *o_ppQualifier = pQualifier;

    return S_OK;
}

//
// protected, virtual methods
//

/*++

Synopsis: Called by Generate.
          Default implementation calls WriteToFile on all classes.
          Override if needed.

Arguments: [i_pFile] - 
           
Return Value: 

--*/
HRESULT CMofGenerator::WriteClasses(
    FILE*           i_pFile)
{
    HRESULT hr = S_OK;

    ULONG cClasses = m_apClasses.Count();
    for(ULONG i = 0; i < cClasses; i++)
    {
        hr = m_apClasses[i]->WriteToFile(i_pFile);
        if(FAILED(hr))
        {
            DBGERROR((DBG_CONTEXT, "[%s] Failure, hr=0x%x\n", __FUNCTION__, hr));
            return hr;
        }
    }

    return hr;
}

/*++

Synopsis: Called by Generate.
          Default implementation does nothing.  Override if needed.

Arguments: [i_pFile] - 
           
Return Value: 

--*/
HRESULT CMofGenerator::WriteFooter(
    FILE*           i_pFile)
{
    return S_OK;
}

/*++

Synopsis: Called by Generate.
          Default implementation does nothing.  Override if needed.

Arguments: [i_pFile] - 
           
Return Value: 

--*/
HRESULT CMofGenerator::WriteHeader(
    FILE*           i_pFile)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\mofgen\wmiobjectbase.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WMIObjectBase.h

$Header: $

Abstract:

Author:
    mohits     5/8/2001        Initial Release

Revision History:

--**************************************************************************/

#ifndef __WMIOBJECTBASE_H__
#define __WMIOBJECTBASE_H__

#pragma once

#include "mofgen.h"
#include "CommonInclude.h"

//
// CWMIObjectBase
//
class CWMIObjectBase
{
public:
    CWMIObjectBase();
    ~CWMIObjectBase();

    STDMETHODIMP_(ULONG)   AddRef();
    STDMETHODIMP_(HRESULT) QueryInterface(
        REFIID riid, 
        void** ppvObject);

private:
    CWMIObjectBase(const CWMIObjectBase& );
    CWMIObjectBase& operator= (const CWMIObjectBase& );

protected:
    ULONG       m_cRef;
};

//
// CWMIClassAndPropertyBase
//
class CWMIClassAndPropertyBase : public CWMIObjectBase
{
public:
    CWMIClassAndPropertyBase();
    ~CWMIClassAndPropertyBase();

    HRESULT AddQualifier(
        IWMIQualifier*  i_pQualifier);

    HRESULT AddQualifier(
        LPCWSTR         i_wszName,
        const VARIANT*  i_pvValue,
        ULONG           i_ulFlavors,
        IWMIQualifier** o_ppQualifier=NULL);

private:
    CWMIClassAndPropertyBase(const CWMIClassAndPropertyBase& );
    CWMIClassAndPropertyBase& operator= (const CWMIClassAndPropertyBase& );

protected:
    CCfgArray<IWMIQualifier*> m_apQualifiers;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\mofgen\wmiclasses.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WMIClasses.cpp

$Header: $

Abstract:

Author:
    mohits     5/8/2001        Initial Release

Revision History:

--**************************************************************************/

#include "MofGen.h"
#include "WMIClasses.h"

static const WCHAR wszTab[] = L"    ";

CWMIClass::CWMIClass()
{
    m_bPragmaDelete = false;
}

CWMIClass::~CWMIClass()
{
    ULONG i;
    ULONG cProperties = m_apProperties.Count();
    for(i = 0; i < cProperties; i++)
    {
        m_apProperties[i]->Release();
    }
}

STDMETHODIMP_(ULONG) CWMIClass::Release()
{
    long lNewCount = InterlockedDecrement((long *)&m_cRef);

    if (0L == lNewCount)
    {
        delete this;
    }
    
    return (lNewCount > 0) ? lNewCount : 0;
}

HRESULT CWMIClass::SetName(
    LPCWSTR i_wszName)
{
    ASSERT(i_wszName);
    ASSERT(m_swszName == NULL);

    m_swszName = new WCHAR[wcslen(i_wszName)+1];
    if(m_swszName == NULL)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(m_swszName, i_wszName);

    return S_OK;
}

HRESULT CWMIClass::SetBaseClass(
    LPCWSTR i_wszBaseClass)
{
    ASSERT(i_wszBaseClass);

    m_swszBaseClass = new WCHAR[wcslen(i_wszBaseClass)+1];
    if(m_swszBaseClass == NULL)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(m_swszBaseClass, i_wszBaseClass);

    return S_OK;
}

HRESULT CWMIClass::AddProperty(
    IWMIProperty*  i_pProperty)
{
    ASSERT(i_pProperty);

    HRESULT hr = m_apProperties.Append(i_pProperty);
    if(FAILED(hr))
    {
        return hr;
    }
    i_pProperty->AddRef();

    return S_OK;
}

HRESULT CWMIClass::AddProperty(
    LPCWSTR        i_wszName,
    VARTYPE        i_vartype,
    const VARIANT* i_pvValue,
    IWMIProperty** o_ppProperty) //defaultvalue(NULL)
{
    CComPtr<IWMIProperty> spProperty;

    HRESULT hr = CMofGenerator::SpawnPropertyInstance(&spProperty);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = spProperty->SetNameValue(i_wszName, i_vartype, i_pvValue);
    if(FAILED(hr))
    {
        return hr;
    }

    hr = AddProperty(spProperty);
    if(FAILED(hr))
    {
        return hr;
    }

    if(o_ppProperty)
    {
        ASSERT(*o_ppProperty == NULL);
        *o_ppProperty = spProperty;
        (*o_ppProperty)->AddRef();
    }

    return S_OK;
}

HRESULT CWMIClass::WriteToFile(
    FILE*          i_pFile)
{
    ASSERT(i_pFile);
    ASSERT(m_swszName);

    //
    // pragma delete
    //
    if(m_bPragmaDelete)
    {
        fwprintf(i_pFile, L"#pragma deleteclass(\"%s\", NOFAIL)\n\n", m_swszName);
    }

    //
    // Qualifiers
    //
    ULONG cQualifiers = m_apQualifiers.Count();
    if(cQualifiers > 0)
    {
        fputws(L"[", i_pFile);
        for(ULONG i = 0; i < cQualifiers; i++)
        {
            m_apQualifiers[i]->WriteToFile(i_pFile);
            fputws((i != cQualifiers-1) ? L"," : L"]", i_pFile);
        }
        fputws(L"\n", i_pFile);
    }

    //
    // Class start
    //
    fwprintf(i_pFile, L"class %s", m_swszName);
    if(m_swszBaseClass)
    {
        fwprintf(i_pFile, L": %s", m_swszBaseClass);
    }
    fputws(L"\n{\n", i_pFile);

    //
    // Properties
    //
    ULONG cProperties = m_apProperties.Count();
    for(ULONG i = 0; i < cProperties; i++)
    {
        fputws(wszTab, i_pFile);
        m_apProperties[i]->WriteToFile(i_pFile);
        fputws(L";\n", i_pFile);
    }
    
    //
    // Class end
    //
    fputws(L"};\n\n", i_pFile);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\mofgen\wmiproperties.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WMIProperties.cpp

$Header: $

Abstract:

Author:
    mohits     5/8/2001        Initial Release

Revision History:

--**************************************************************************/

#include "MofGen.h"
#include "WMIProperties.h"
#include "WMIObjectBase.h"

CWMIProperty::CWMIProperty()
{
    VariantInit(&m_vValue);
    m_cimtype = 0;
}

CWMIProperty::~CWMIProperty()
{
    m_cimtype = 0;
}

STDMETHODIMP_(ULONG) CWMIProperty::Release()
{
    long lNewCount = InterlockedDecrement((long *)&m_cRef);

    if (0L == lNewCount)
    {
        delete this;
    }
    
    return (lNewCount > 0) ? lNewCount : 0;
}

HRESULT CWMIProperty::SetNameValue(
    LPCWSTR        i_wszName,
    CIMTYPE        i_cimtype,
    const VARIANT* i_pvValue)
{
    if(i_pvValue == NULL)
    {
        m_cimtype = i_cimtype;
    }
    else
    {
        HRESULT hr = VariantCopy(&m_vValue, (VARIANT *)i_pvValue);
        if(FAILED(hr))
        {
            DBGERROR((DBG_CONTEXT, "[%s] VariantCopy failed, hr=0x%x\n", __FUNCTION__, hr));
            return hr;
        }
    }

    m_swszName = new WCHAR[wcslen(i_wszName)+1];
    if(m_swszName == NULL)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(m_swszName, i_wszName);

    return S_OK;
}

/*++

Synopsis: 
    Used for CIM_OBJECT and CIM_REFERENCE types

Arguments: [i_wszInfo] - Generally the name of a WMI class
           
Return Value: 
    HRESULT

--*/
HRESULT CWMIProperty::SetExtraTypeInfo(
    LPCWSTR        i_wszInfo)
{
    ASSERT(i_wszInfo);

    //
    // Determine type
    //
    CIMTYPE cimtype = (m_vValue.vt == VT_EMPTY || m_vValue.vt == VT_NULL) ? 
        m_cimtype : m_vValue.vt;

    ASSERT(cimtype == CIM_OBJECT || cimtype == CIM_REFERENCE);

    m_swszExtraTypeInfo = new WCHAR[wcslen(i_wszInfo)+1];
    if(m_swszExtraTypeInfo == NULL)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(m_swszExtraTypeInfo, i_wszInfo);
        
    return S_OK;
}

HRESULT CWMIProperty::WriteToFile(
    FILE*          i_pFile)
{
    ASSERT(i_pFile);
    ASSERT(m_swszName);

    //
    // Determine type
    //
    CIMTYPE cimtype = (m_vValue.vt == VT_EMPTY || m_vValue.vt == VT_NULL) ? 
        m_cimtype : m_vValue.vt;

    //
    // Qualifiers
    //
    ULONG           cQualifiers  = m_apQualifiers.Count();
    if(cQualifiers > 0)
    {
        fputws(L"[", i_pFile);
        for(ULONG i = 0; i < cQualifiers; i++)
        {
            m_apQualifiers[i]->WriteToFile(i_pFile);
            fputws((i != cQualifiers-1) ? L"," : L"]", i_pFile);
        }
        fputws(L" ", i_pFile);
    }

    //
    // Type, Without the array part
    //
    CimTypeStringMapping* pctsm = CUtils::LookupCimType(cimtype & ~VT_ARRAY);
    if(!pctsm)
    {
        ASSERT(false && L"Unsupported property type");
        return E_FAIL;
    }
    if(pctsm->cimtype == CIM_REFERENCE)
    {
        if(!m_swszExtraTypeInfo)
        {
            ASSERT(false && L"Need to provide class you are reffing to");
            return E_FAIL;
        }
        fwprintf(i_pFile, L"%s ref ", m_swszExtraTypeInfo);
    }
    else if(pctsm->cimtype == CIM_OBJECT && m_swszExtraTypeInfo)
    {
        fwprintf(i_pFile, L"%s ", m_swszExtraTypeInfo);
    }
    else
    {
        fwprintf(i_pFile, L"%s ", pctsm->wszString);
    }

    //
    // The property name
    //
    fputws(m_swszName, i_pFile);

    //
    // Put in the array part
    //
    if(cimtype & VT_ARRAY)
    {
        fputws(L"[]", i_pFile);
    }

    //
    // Default value
    //
    if(m_vValue.vt != VT_EMPTY && m_vValue.vt != VT_NULL)
    {
        fputws(L"=", i_pFile);

        if(cimtype & VT_ARRAY)
        {
            ASSERT(false && L"Default value for arrays currently unsupported");
            return E_FAIL;
        }

        bool bDone = true;
        switch(cimtype)
        {
        case VT_BOOL:
            if(m_vValue.boolVal)
            {
                fwprintf(i_pFile, L"true");
            }
            else
            {
                fwprintf(i_pFile, L"false");
            }
            break;
        default:
            bDone = false;
        }

        if(!bDone)
        {
            if(pctsm->wszFormatString)
            {
                fwprintf(i_pFile, pctsm->wszFormatString, m_vValue.byref);
            }
            else
            {
                ASSERT(false && L"Default value for this type is unsupported");
                return E_FAIL;
            }
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\pudebug\initwmi.cpp ===
/*++

    Copyright (c) 2001  Microsoft Corporation

    Module  Name :
        initwmi.h

    Abstract:
        This code wraps the WMI initialization and unitialization

    Author:
         MohitS   22-Feb-2001

    Revisions:
--*/

#include "initwmi.h"
#include <dbgutil.h>

CInitWmi::CInitWmi()
{
    m_dwError      = ERROR_SUCCESS;
    m_bInitialized = false;
    __try
    {
        InitializeCriticalSection(&m_cs);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        m_dwError = _exception_code();
    }
}

CInitWmi::~CInitWmi()
{
    if(m_dwError == ERROR_SUCCESS)
    {
        DeleteCriticalSection(&m_cs);
    }   
}

HRESULT CInitWmi::InitIfNecessary()
{
    HRESULT hr = S_OK;

    if(m_dwError != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(m_dwError);
    }

    if(!m_bInitialized)
    {
        EnterCriticalSection(&m_cs);
        if(!m_bInitialized)
        {
            CREATE_INITIALIZE_DEBUG();
            m_bInitialized = true;
        }
        LeaveCriticalSection(&m_cs);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\mofgen\wmiproperties.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WMIProperties.h

$Header: $

Abstract:

Author:
    mohits     5/8/2001        Initial Release

Revision History:

--**************************************************************************/

#ifndef __WMIPROPERTIES_H__
#define __WMIPROPERTIES_H__

#pragma once

#include "MofGen.h"
#include "CommonInclude.h"
#include "WMIObjectBase.h"

//
// CWMIProperty
//
class CWMIProperty : public IWMIProperty, public CWMIClassAndPropertyBase
{
public:
    CWMIProperty();
    ~CWMIProperty();

    STDMETHODIMP_(ULONG) AddRef()  { return CWMIClassAndPropertyBase::AddRef();  }
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP_(HRESULT) QueryInterface(
        REFIID riid, 
        void** ppvObject)
    {
        return CWMIClassAndPropertyBase::QueryInterface(riid, ppvObject);
    }

    HRESULT AddQualifier(
        IWMIQualifier*  i_pQualifier)
    {
        return CWMIClassAndPropertyBase::AddQualifier(i_pQualifier);
    }

    HRESULT AddQualifier(
        LPCWSTR         i_wszName,
        const VARIANT*  i_pvValue,
        ULONG           i_ulFlavors,
        IWMIQualifier** o_ppQualifier=NULL)
    {
        return CWMIClassAndPropertyBase::AddQualifier(
            i_wszName, i_pvValue, i_ulFlavors, o_ppQualifier);
    }

    HRESULT SetNameValue(
        LPCWSTR        i_wszName,
        CIMTYPE        i_cimttype,
        const VARIANT* i_pvValue);

    HRESULT SetExtraTypeInfo(
        LPCWSTR        i_wszInfo);

    HRESULT WriteToFile(
        FILE*          i_pFile);

private:
    CWMIProperty(const CWMIProperty& );
    CWMIProperty& operator= (const CWMIProperty& );

    VARIANT                    m_vValue;
    CIMTYPE                    m_cimtype;
    TSmartPointerArray<WCHAR>  m_swszName;
    TSmartPointerArray<WCHAR>  m_swszExtraTypeInfo;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\mofgen\wmiqualifiers.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WMIQualifiers.h

$Header: $

Abstract:

Author:
    mohits     5/8/2001        Initial Release

Revision History:

--**************************************************************************/

#ifndef __WMIQUALIFIERS_H__
#define __WMIQUALIFIERS_H__

#pragma once

#include "MofGen.h"
#include "CommonInclude.h"
#include "WMIObjectBase.h"

//
// CWMIQualifier
//
class CWMIQualifier : public IWMIQualifier, public CWMIObjectBase
{
public:
    CWMIQualifier();
    ~CWMIQualifier();

    STDMETHODIMP_(ULONG) AddRef()  { return CWMIObjectBase::AddRef();  }
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP_(HRESULT) QueryInterface(
        REFIID riid, 
        void** ppvObject)
    {
        return CWMIObjectBase::QueryInterface(riid, ppvObject);
    }

    HRESULT Set(
        LPCWSTR          i_wszName,
        const VARIANT*   i_pvValue,
        ULONG            i_ulFlavor);

    HRESULT WriteToFile(
        FILE*          i_pFile);

    //
    // accessors
    //
    LPCWSTR        GetName()    const { return m_swszName;  }
    const VARIANT* GetValue()   const { return &m_vValue;   }
    ULONG          GetFlavors() const { return m_ulFlavors; }

private:
    CWMIQualifier(const CWMIQualifier& );
    CWMIQualifier& operator= (const CWMIQualifier& );

    TSmartPointerArray<WCHAR>   m_swszName;
    VARIANT                     m_vValue;

    ULONG                       m_ulFlavors;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\mofgen\wmiqualifiers.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    wmiqualifiers.cpp

$Header: $

Abstract:

Author:
    mohits     5/8/2001 14:58:47       Initial Release

Revision History:

--**************************************************************************/

#include "MofGen.h"
#include "WMIQualifiers.h"

CWMIQualifier::CWMIQualifier()
{
    VariantInit(&m_vValue);
}

CWMIQualifier::~CWMIQualifier()
{
    VariantClear(&m_vValue);
}

STDMETHODIMP_(ULONG) CWMIQualifier::Release()
{
    long lNewCount = InterlockedDecrement((long *)&m_cRef);

    if (0L == lNewCount)
    {
        delete this;
    }
    
    return (lNewCount > 0) ? lNewCount : 0;
}

/*++

Synopsis: 

Arguments: [i_wszName]  - cannot be NULL.
           [i_wszValue] - cannot be NULL.
                        - WMI supports VT_I4, VT_R8, VT_BSTR, VT_BOOL
           
Return Value: 

--*/
HRESULT CWMIQualifier::Set(
    LPCWSTR        i_wszName,
    const VARIANT* i_pvValue,
    ULONG          i_ulFlavors)
{
    ASSERT(i_wszName);
    ASSERT(i_pvValue);
    ASSERT(i_pvValue->vt == VT_I4   ||
           i_pvValue->vt == VT_R8   ||
           i_pvValue->vt == VT_BSTR ||
           i_pvValue->vt == VT_BOOL);

    m_swszName = new WCHAR [wcslen(i_wszName) + 1];
    if (m_swszName == 0)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy (m_swszName, i_wszName);
     
    HRESULT hr = VariantCopy(&m_vValue, (VARIANT*)i_pvValue);
    if (FAILED(hr))
    {
        return hr;
    }

    m_ulFlavors = i_ulFlavors;

    return S_OK;
}

HRESULT CWMIQualifier::WriteToFile (FILE *pFile)
{
    ASSERT(pFile);

    fputws(m_swszName, pFile);

    switch(m_vValue.vt)
    {
    case VT_I4:
        fwprintf(pFile, L"(%d)", m_vValue.lVal);
        break;
    case VT_R8:
        ASSERT(false && L"Unsupported");
        break;
    case VT_BSTR:
        ASSERT(m_vValue.bstrVal);
        fwprintf(pFile, L"(\"%s\")", m_vValue.bstrVal);
        break;
    case VT_BOOL:
        if(!m_vValue.boolVal)
        {
            fwprintf(pFile, L"(FALSE)");
        }
        break;
    default:
        ASSERT(false && L"Unknown qualifier type specified");
    }

    //
    // print all the flavors
    // TODO: might need to add qualifiers for NotToInstance and NotToSubClass cases
    //
    ULONG ulMask = 
        WBEM_FLAVOR_DONT_PROPAGATE                  |
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE      |
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS |
        WBEM_FLAVOR_NOT_OVERRIDABLE                 |
        WBEM_FLAVOR_AMENDED;

    if(m_ulFlavors & ~ulMask)
    {        
        ASSERT (false && L"Unknown flavor specified");
    }
    else if(m_ulFlavors != 0)
    {
        fputws(L":", pFile);

        if(m_ulFlavors & WBEM_FLAVOR_DONT_PROPAGATE)
        {
            fputws(L"Restricted ", pFile);
        }
        if(m_ulFlavors & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE)
        {
            fputws(L"ToInstance ", pFile);
        }
        if(m_ulFlavors & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS)
        {
            fputws(L"ToSubClass ", pFile);
        }
        if(m_ulFlavors & WBEM_FLAVOR_NOT_OVERRIDABLE)
        {
            fputws(L"DisableOverride ", pFile);
        }
        if(m_ulFlavors & WBEM_FLAVOR_AMENDED)
        {
            fputws(L"Amended ", pFile);
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\pudebug\initwmi.h ===
/*++

    Copyright (c) 2001  Microsoft Corporation

    Module  Name :
        initwmi.h

    Abstract:
        This code wraps the WMI initialization and unitialization

    Author:
         MohitS   22-Feb-2001

    Revisions:
--*/

#ifndef __initwmi_h__
#define __initwmi_h__

#include <windows.h>

class CInitWmi
{
public:
    CInitWmi();
    ~CInitWmi();

    HRESULT InitIfNecessary();

private:
    CInitWmi(const CInitWmi&);
    CInitWmi& operator= (const CInitWmi&);

    DWORD            m_dwError;
    bool             m_bInitialized;
    CRITICAL_SECTION m_cs;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\catalogschemawriter.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    CatalogSchemaWriter.cpp

$Header: $

Abstract:

--**************************************************************************/

#include "catalog.h"
#include "catmeta.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "CatalogPropertyWriter.h"
#include "CatalogCollectionWriter.h"
#include "CatalogSchemaWriter.h"
#include "WriterGlobals.h"

#define  cMaxCCollection 50		// TODO: Set to max number of ADSI classes

typedef CCatalogCollectionWriter* LP_CCatalogCollectionWriter;

CCatalogSchemaWriter::CCatalogSchemaWriter(CWriter*	i_pcWriter):
m_apCollection(NULL),
m_cCollection(0),
m_iCollection(0),
m_pCWriter(i_pcWriter)
{

} // CCatalogSchemaWriter


CCatalogSchemaWriter::~CCatalogSchemaWriter()
{
	if(NULL != m_apCollection)
	{
		for(ULONG i=0; i<m_iCollection; i++)
		{	
			if(NULL != m_apCollection[i])
			{
				delete m_apCollection[i];
				m_apCollection[i] = NULL;
			}
		}

		delete [] m_apCollection;
		m_apCollection = NULL;
	}

	m_cCollection = 0;
	m_iCollection = 0;

} // ~CCatalogSchemaWriter


HRESULT CCatalogSchemaWriter::GetCollectionWriter(tTABLEMETARow*				i_pCollection,
												  CCatalogCollectionWriter**    o_pCollectionWriter)
{
	HRESULT hr = S_OK;

	if(m_iCollection == m_cCollection)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	m_apCollection[m_iCollection++] = new CCatalogCollectionWriter();

	if(NULL == m_apCollection[m_iCollection-1])
	{
		return E_OUTOFMEMORY;
	}

	m_apCollection[m_iCollection-1]->Initialize(i_pCollection,
											    m_pCWriter);

	*o_pCollectionWriter = m_apCollection[m_iCollection-1];
	
	return hr;

} // CCatalogSchemaWriter::GetCollectionWriter


HRESULT CCatalogSchemaWriter::ReAllocate()
{
	CCatalogCollectionWriter** pSav = m_apCollection;

	m_apCollection = new LP_CCatalogCollectionWriter[m_cCollection + cMaxCCollection];
	if(NULL == m_apCollection)
	{
		return E_OUTOFMEMORY;
	}
	memset(m_apCollection, 0, (sizeof(LP_CCatalogCollectionWriter))*(m_cCollection + cMaxCCollection));

	if(NULL != pSav)
	{
		memcpy(m_apCollection, pSav, (sizeof(LP_CCatalogCollectionWriter))*(m_cCollection));
		delete [] pSav;
	}

	m_cCollection = m_cCollection + cMaxCCollection;

	return S_OK;

} // CCatalogSchemaWriter::ReAllocate


HRESULT CCatalogSchemaWriter::WriteSchema()
{
	HRESULT hr = S_OK;

	hr = BeginWriteSchema();

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_iCollection; i++)
	{
		hr = m_apCollection[i]->WriteCollection();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	hr = EndWriteSchema();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CCatalogSchemaWriter::WriteSchema


HRESULT CCatalogSchemaWriter::BeginWriteSchema()
{
	HRESULT		hr      = S_OK;
	WCHAR*		wszTemp = g_wszTemp;

	if((g_cchBeginSchema+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[g_cchBeginSchema+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	memcpy(wszTemp, g_wszBeginSchema, (g_cchBeginSchema+1)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         g_cchBeginSchema);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CCatalogSchemaWriter::BeginWriteSchema


HRESULT CCatalogSchemaWriter::EndWriteSchema()
{
	HRESULT		hr      = S_OK;
	WCHAR*		wszTemp = g_wszTemp;

	if((g_cchEndSchema+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[g_cchBeginSchema+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	memcpy(wszTemp, g_wszEndSchema, (g_cchEndSchema+1)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         g_cchEndSchema,
								 TRUE);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CCatalogSchemaWriter::EndWriteSchema
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\catalogcollectionwriter.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    CatalogCollectionWriter.cpp

$Header: $

Abstract:


--**************************************************************************/

#include "catalog.h"
#include "catmeta.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "CatalogPropertyWriter.h"
#include "CatalogCollectionWriter.h"
#include "WriterGlobals.h"

#define  cMaxProperty 700 // TODO Check max property count.

typedef CCatalogPropertyWriter* LP_CCatalogPropertyWriter;

CCatalogCollectionWriter::CCatalogCollectionWriter():
m_pCWriter(NULL),
m_apProperty(NULL),
m_cProperty(0),
m_iProperty(0)
{
	memset(&m_Collection, 0, sizeof(tTABLEMETARow));

} // CCatalogCollectionWriter


CCatalogCollectionWriter::~CCatalogCollectionWriter()
{
	if(NULL != m_apProperty)
	{
		for(ULONG i=0; i<m_iProperty; i++)
		{
			if(NULL != m_apProperty[i])
			{
				delete m_apProperty[i];
				m_apProperty[i] = NULL;
			}
		}

		delete [] m_apProperty;
		m_apProperty = NULL;
	}
	m_cProperty = 0;
	m_iProperty = 0;

} // ~CCatalogCollectionWriter


void CCatalogCollectionWriter::Initialize(tTABLEMETARow*	i_pCollection,
										  CWriter*			i_pcWriter)
{
	memcpy(&m_Collection, i_pCollection, sizeof(tTABLEMETARow));
	m_pCWriter    = i_pcWriter;

} // CCatalogCollectionWriter::Initialize


HRESULT CCatalogCollectionWriter::GetPropertyWriter(tCOLUMNMETARow*				i_pProperty,
                                                    ULONG*                      i_aPropertySize,
											        CCatalogPropertyWriter**     o_pProperty)
{
	HRESULT hr = S_OK;

	if(m_iProperty == m_cProperty)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	m_apProperty[m_iProperty++] = new CCatalogPropertyWriter();

	if(NULL == m_apProperty[m_iProperty-1])
	{
		return E_OUTOFMEMORY;
	}

	m_apProperty[m_iProperty-1]->Initialize(i_pProperty,
                                            i_aPropertySize,
		                                    &m_Collection,
		                                    m_pCWriter);

	*o_pProperty = m_apProperty[m_iProperty-1];
	
	return hr;

} // CCatalogCollectionWriter::GetPropertyWriter


HRESULT CCatalogCollectionWriter::ReAllocate()
{
	CCatalogPropertyWriter** pSav = m_apProperty;

	m_apProperty = new LP_CCatalogPropertyWriter[m_cProperty + cMaxProperty];
	if(NULL == m_apProperty)
	{
		return E_OUTOFMEMORY;
	}
	memset(m_apProperty, 0, (sizeof(LP_CCatalogPropertyWriter))*(m_cProperty + cMaxProperty));

	if(NULL != pSav)
	{
		memcpy(m_apProperty, pSav, (sizeof(LP_CCatalogPropertyWriter))*(m_cProperty));
		delete [] pSav;
	}

	m_cProperty = m_cProperty + cMaxProperty;

	return S_OK;

} // CCatalogCollectionWriter::ReAllocate


HRESULT CCatalogCollectionWriter::WriteCollection()
{
	HRESULT hr = S_OK;

	hr = BeginWriteCollection();

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_iProperty; i++)
	{
		hr = m_apProperty[i]->WriteProperty();

		if(FAILED(hr))
		{
			return hr;
		}

	}

	hr = EndWriteCollection();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CCatalogCollectionWriter::WriteCollection


HRESULT CCatalogCollectionWriter::BeginWriteCollection()
{
	HRESULT		hr						= S_OK;
	WCHAR*		wszTemp					= g_wszTemp;
	WCHAR*      wszEnd					= NULL;

	SIZE_T      cchCollectionName		= wcslen(m_Collection.pInternalName);

	LPWSTR      wszMetaFlagsEx          = NULL;
	LPWSTR      wszMetaFlags            = NULL;
	LPWSTR      wszEndBeginCollection	= NULL;
	SIZE_T      cchEndBeginCollection	= 0;
	SIZE_T      cch						= 0;
	SIZE_T      cchMetaFlagsExEq			= 0; // For Container
	SIZE_T      cchMetaFlagsEx				= 0; // For Container
	SIZE_T      cchMetaFlagsEq			    = 0; // For Container
	SIZE_T      cchMetaFlags				= 0; // For Container
	SIZE_T      cchContainerClassListEq		= 0; // For ContainerList
	SIZE_T      cchContainerClassList		= 0; // For ContainerList
	ULONG       iColMetaFlagsEx	            = iTABLEMETA_SchemaGeneratorFlags;
	ULONG       iColMetaFlags               = iTABLEMETA_MetaFlags;
	DWORD       dwMetaFlagsEx            = 0;
	DWORD       dwValidMetaFlagsExMask   =  fTABLEMETA_EMITXMLSCHEMA            |
											fTABLEMETA_EMITCLBBLOB        	    |
											fTABLEMETA_NOTSCOPEDBYTABLENAME	    |
											fTABLEMETA_GENERATECONFIGOBJECTS	|
											fTABLEMETA_NOTABLESCHEMAHEAPENTRY	|
											fTABLEMETA_CONTAINERCLASS;

	
	if(0 == _wcsicmp(m_Collection.pInternalName, wszTABLE_IIsConfigObject))
	{
		wszEndBeginCollection = (LPWSTR)g_wszSchemaGen;
		cchEndBeginCollection = g_cchSchemaGen;
	}
	else
	{
		wszEndBeginCollection = (LPWSTR)g_wszInheritsFrom;
		cchEndBeginCollection = g_cchInheritsFrom;
	}

	dwMetaFlagsEx = *(m_Collection.pSchemaGeneratorFlags);
	dwMetaFlagsEx = dwMetaFlagsEx & dwValidMetaFlagsExMask; // Zero out any non-valid bits. (i.e. bits that must be inferred)

	if(dwMetaFlagsEx != 0)
	{
		cchMetaFlagsExEq = g_cchMetaFlagsExEq;
		hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlagsEx, 
															  &wszMetaFlagsEx,
															  wszTABLE_TABLEMETA,
										            		  iColMetaFlagsEx);

		if(FAILED(hr))
		{
			goto exit;
		}
		cchMetaFlagsEx = wcslen(wszMetaFlagsEx);
	}

	if((*(m_Collection.pMetaFlags)) != 0)
	{
		cchMetaFlagsEq = g_cchMetaFlagsEq;
		hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(*(m_Collection.pMetaFlags), 
															  &wszMetaFlags,
															  wszTABLE_TABLEMETA,
										            		  iColMetaFlags);

		if(FAILED(hr))
		{
			goto exit;
		}
		cchMetaFlags = wcslen(wszMetaFlags);
	}

	if(m_Collection.pContainerClassList != NULL)
	{
		cchContainerClassListEq = g_cchContainerClassListEq;
		cchContainerClassList = wcslen(m_Collection.pContainerClassList);

	}

	cch = g_cchBeginCollection		 +
	      cchCollectionName			 +
		  cchMetaFlagsExEq			 + 
		  cchMetaFlagsEx			 +  
		  cchMetaFlagsEq			 + 
		  cchMetaFlags	  		     +  
		  cchContainerClassListEq    + 
		  cchContainerClassList      +  
		  cchEndBeginCollection;
	                  
	if((cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
	}

	wszEnd = wszTemp;
	memcpy(wszEnd, g_wszBeginCollection, (g_cchBeginCollection)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginCollection;
	memcpy(wszEnd, m_Collection.pInternalName, (cchCollectionName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchCollectionName;
	if(dwMetaFlagsEx != 0)
	{
		memcpy(wszEnd, g_wszMetaFlagsExEq, (cchMetaFlagsExEq)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlagsExEq;
		memcpy(wszEnd, wszMetaFlagsEx, (cchMetaFlagsEx)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlagsEx;
	}

	if((*(m_Collection.pMetaFlags)) != 0)
	{
		memcpy(wszEnd, g_wszMetaFlagsEq, (cchMetaFlagsEq)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlagsEq;
		memcpy(wszEnd, wszMetaFlags, (cchMetaFlags)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlags;
	}

	if(m_Collection.pContainerClassList != NULL)
	{
		memcpy(wszEnd, g_wszContainerClassListEq, (cchContainerClassListEq)*sizeof(WCHAR));
		wszEnd = wszEnd + cchContainerClassListEq;
		memcpy(wszEnd, m_Collection.pContainerClassList, (cchContainerClassList)*sizeof(WCHAR));
		wszEnd = wszEnd + cchContainerClassList;

	}
	memcpy(wszEnd, wszEndBeginCollection, (cchEndBeginCollection)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

exit:

	if(NULL != wszMetaFlagsEx)
	{
		delete [] wszMetaFlagsEx;
		wszMetaFlagsEx = NULL;
	}

	if(NULL != wszMetaFlags)
	{
		delete [] wszMetaFlags;
		wszMetaFlags = NULL;
	}

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CCatalogCollectionWriter::BeginWriteCollection


HRESULT CCatalogCollectionWriter::EndWriteCollection()
{
	HRESULT		hr						= S_OK;
	WCHAR*		wszTemp					= g_wszTemp;
	WCHAR*      wszEnd					= NULL;

	if((g_cchEndCollection+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[g_cchEndCollection+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	memcpy(wszTemp, g_wszEndCollection, (g_cchEndCollection)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         g_cchEndCollection);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CCatalogCollectionWriter::EndWriteCollection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\dtcini.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <malloc.h>

#include "UTAssert.H"
DeclAssertFile ;			//NEED THIS FOR THE ASSERT MACROS.
#include "dtc.h"


DWORD GetDTCProfileInt (char * pszRegValue, DWORD dwDefault)
{
	HKEY	hkDTCProfile = NULL;
	DWORD	dwKeyType	 = 0;
	DWORD	dwValue;
	DWORD	cbValue = sizeof (DWORD);


	if (RegOpenKeyEx(
						HKEY_LOCAL_MACHINE, 
						"Software\\Microsoft\\MSDTC",
						0,
						KEY_READ,
						&hkDTCProfile
					)  != ERROR_SUCCESS)
	{
		return dwDefault;
	}

	Assert (hkDTCProfile);

	if (RegQueryValueEx(
							hkDTCProfile, 
							pszRegValue, 
							NULL, 
							&dwKeyType, 
							(LPBYTE)&dwValue, 
							&cbValue
						) != ERROR_SUCCESS)
	{
		if (dwKeyType != REG_DWORD)
		{
			dwValue = dwDefault;
		}
	}

	RegCloseKey (hkDTCProfile);
	return dwValue;
}


DWORD GetDTCProfileIntExW (WCHAR * szHostName, WCHAR * szRegValue, DWORD dwDefault)
{
	HKEY	hkeyMachine		= NULL;
	HKEY	hkDTCProfile	= NULL;
	DWORD	dwKeyType		= 0;
	DWORD	dwValue;
	DWORD	cbValue = sizeof (DWORD);


	if	(
		RegConnectRegistryW (szHostName, HKEY_LOCAL_MACHINE, &hkeyMachine)
		!=
		ERROR_SUCCESS
		)
	{
		return dwDefault;
	}

	if (RegOpenKeyExW (
						hkeyMachine, 
						L"Software\\Microsoft\\MSDTC",
						0,
						KEY_READ,
						&hkDTCProfile
					)  != ERROR_SUCCESS)
	{
		dwValue = dwDefault;
		goto DONE;
	}

	Assert (hkDTCProfile);

	if (RegQueryValueExW(
							hkDTCProfile, 
							szRegValue, 
							NULL, 
							&dwKeyType, 
							(LPBYTE)&dwValue, 
							&cbValue
						) != ERROR_SUCCESS)
	{
		dwValue = dwDefault;
		goto DONE;
	}

	if (dwKeyType != REG_DWORD)
	{
		dwValue = dwDefault;
	}

DONE:
	if (hkDTCProfile)
	{
		RegCloseKey (hkDTCProfile);
	}

	if (hkeyMachine)
	{
		RegCloseKey (hkeyMachine);
	}
	return dwValue;
}


DWORD GetDTCProfileIntExA (CHAR * szHostName, CHAR * szRegValue, DWORD dwDefault)
{
	HKEY	hkeyMachine		= NULL;
	HKEY	hkDTCProfile	= NULL;
	DWORD	dwKeyType		= 0;
	DWORD	dwValue;
	DWORD	cbValue = sizeof (DWORD);


	if	(
		RegConnectRegistry (szHostName, HKEY_LOCAL_MACHINE, &hkeyMachine)
		!=
		ERROR_SUCCESS
		)
	{
		return dwDefault;
	}

	if (RegOpenKeyEx (
						hkeyMachine, 
						"Software\\Microsoft\\MSDTC",
						0,
						KEY_READ,
						&hkDTCProfile
					)  != ERROR_SUCCESS)
	{
		dwValue = dwDefault;
		goto DONE;
	}

	Assert (hkDTCProfile);

	if (RegQueryValueEx	(
							hkDTCProfile, 
							szRegValue, 
							NULL, 
							&dwKeyType, 
							(LPBYTE)&dwValue, 
							&cbValue
						) != ERROR_SUCCESS)
	{
		dwValue = dwDefault;
		goto DONE;
	}

	if (dwKeyType != REG_DWORD)
	{
		dwValue = dwDefault;
	}

DONE:
	if (hkDTCProfile)
	{
		RegCloseKey (hkDTCProfile);
	}

	if (hkeyMachine)
	{
		RegCloseKey (hkeyMachine);
	}
	return dwValue;
}


BOOL SetDTCProfileInt (char * pszRegValue, DWORD dwValue)
{
	HKEY	hkDTCProfile = NULL;
	DWORD	dwDisp;
	DWORD	cbValue = sizeof (DWORD);


	if (RegCreateKeyEx(
						HKEY_LOCAL_MACHINE, 
						"Software\\Microsoft\\MSDTC",
						0,
						NULL,
						REG_OPTION_NON_VOLATILE,
						KEY_WRITE,
						NULL,
						&hkDTCProfile,
						&dwDisp
					)  != ERROR_SUCCESS)
					
	{
		return FALSE;
	}

	Assert (hkDTCProfile);

	if (RegSetValueEx(
							hkDTCProfile, 
							pszRegValue, 
							NULL, 
							REG_DWORD, 
							(LPBYTE)&dwValue, 
							cbValue
						) != ERROR_SUCCESS)
	{
		RegCloseKey (hkDTCProfile);
		return FALSE;
	}

	RegCloseKey (hkDTCProfile);
	return TRUE;
}

BOOL SetDTCProfileIntExA (CHAR * szHostName, CHAR * szRegValue, DWORD dwValue)
{
	HKEY	hkeyMachine		= NULL;
	HKEY	hkDTCProfile	= NULL;
	DWORD	cbValue			= sizeof ( dwValue );
	DWORD	dwDisp;
	BOOL	fResult			= FALSE;
	
	do
	{
		if	( ERROR_SUCCESS != RegConnectRegistry (szHostName, HKEY_LOCAL_MACHINE, &hkeyMachine ) )
		{
			break;
		}
	
		if (ERROR_SUCCESS != RegCreateKeyEx(
							hkeyMachine, 
							"Software\\Microsoft\\MSDTC",
							0,
							NULL,
							REG_OPTION_NON_VOLATILE,
							KEY_WRITE,
							NULL,
							&hkDTCProfile,
							&dwDisp
						) )
						
		{
			break;
		}

		Assert (hkDTCProfile);

		if (ERROR_SUCCESS != RegSetValueEx(
								hkDTCProfile, 
								szRegValue, 
								NULL, 
								REG_DWORD, 
								(LPBYTE)&dwValue, 
								cbValue
							) )
		{
			break;
		}

		fResult = TRUE;
	}
	while( FALSE );

	if (hkDTCProfile)
	{
		RegCloseKey (hkDTCProfile);
	}

	if (hkeyMachine)
	{
		RegCloseKey (hkeyMachine);
	}

	return ( fResult );
}

BOOL SetDTCProfileIntExW (WCHAR * szHostName, WCHAR * szRegValue, DWORD dwValue)
{
	HKEY	hkeyMachine		= NULL;
	HKEY	hkDTCProfile	= NULL;
	DWORD	cbValue			= sizeof ( dwValue );
	DWORD	dwDisp;
	BOOL	fResult			= FALSE;
	
	do
	{
		if	( ERROR_SUCCESS != RegConnectRegistryW (szHostName, HKEY_LOCAL_MACHINE, &hkeyMachine ) )
		{
			break;
		}
	
		if (ERROR_SUCCESS != RegCreateKeyExW(
							hkeyMachine, 
							L"Software\\Microsoft\\MSDTC",
							0,
							NULL,
							REG_OPTION_NON_VOLATILE,
							KEY_WRITE,
							NULL,
							&hkDTCProfile,
							&dwDisp
						) )
						
		{
			break;
		}

		Assert (hkDTCProfile);

		if (ERROR_SUCCESS != RegSetValueExW(
								hkDTCProfile, 
								szRegValue, 
								NULL, 
								REG_DWORD, 
								(LPBYTE)&dwValue, 
								cbValue
							) )
		{
			break;
		}

		fResult = TRUE;
	}
	while( FALSE );

	if (hkDTCProfile)
	{
		RegCloseKey (hkDTCProfile);
	}

	if (hkeyMachine)
	{
		RegCloseKey (hkeyMachine);
	}

	return ( fResult );
}

BOOL IsProductSuiteInstalledA (LPSTR lpszSuiteName)
{
    BOOL fInstalled = FALSE;
    LONG lResult;
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    LPSTR lpszProductSuites = NULL;
    LPSTR lpszSuite;

	// Open the ProductOptions key.
    lResult = RegOpenKey
			(
				HKEY_LOCAL_MACHINE,
				TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
				&hKey
	        );
    if (lResult != ERROR_SUCCESS) 
	{
        goto exit;
    }

	// Determine required size of ProductSuites buffer.
    lResult = RegQueryValueEx
		(
			hKey,
			TEXT("ProductSuite"),
			NULL,
			&dwType,
			NULL,
			&dwSize
        );
    if (lResult != ERROR_SUCCESS) 
	{
        goto exit;
    }

    if (!dwSize) 
	{
        goto exit;
    }

	// Allocate buffer.
    lpszProductSuites = (LPTSTR) _alloca(dwSize);
    if (!lpszProductSuites) 
	{
        goto exit;
    }

	// Retrieve array of product suite strings.
    lResult = RegQueryValueEx
		(
			hKey,
			TEXT("ProductSuite"),
			NULL,
			&dwType,
			(LPBYTE) lpszProductSuites,
			&dwSize
        );
    if (lResult != ERROR_SUCCESS) 
	{
        goto exit;
    }

    if (dwType != REG_MULTI_SZ) 
	{
        goto exit;
    }

	// Search for suite name in array of strings.
    lpszSuite = lpszProductSuites;
    while (*lpszSuite) 
	{
        if (_tcscmp( lpszSuite, lpszSuiteName ) == 0) 
		{
            fInstalled = TRUE;
            break;
        }
        lpszSuite += (_tcslen( lpszSuite ) + 1);
    }

exit:
    if (hKey) {
        RegCloseKey( hKey );
    }

    return fInstalled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\debug.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//
// Debug.cpp -- COM+ Debugging Flags
//
// COM+ 1.0
//
// Jim Lyon, March 1998.
//  

#include <unicode.h>
#include <windows.h>
#include <debug.h>

// The data returned by this module:

BOOL        DebugFlags::sm_fAutoAddTraceToContext   = FALSE;
#ifdef _DEBUG
BOOL        DebugFlags::sm_fDebugBreakOnFailFast    = TRUE;
#else
BOOL        DebugFlags::sm_fDebugBreakOnFailFast    = FALSE;
#endif
BOOL        DebugFlags::sm_fDebugBreakOnInitComPlus = FALSE;
BOOL        DebugFlags::sm_fDebugBreakOnLoadComsvcs = FALSE;
BOOL        DebugFlags::sm_fTraceActivityModule     = FALSE;
BOOL        DebugFlags::sm_fTraceContextCreation    = FALSE;
BOOL        DebugFlags::sm_fTraceInfrastructureCalls= FALSE;
BOOL        DebugFlags::sm_fTraceSTAPool            = FALSE;
BOOL        DebugFlags::sm_fTraceSecurity           = FALSE;
BOOL        DebugFlags::sm_fTraceSecurityPM         = FALSE;
DWORD       DebugFlags::sm_dwEventDispatchTime = 1000;


DebugFlags DebugFlags::sm_singleton;        // the only object of this class

// Constructor: Its job is to initialize the static members of this class
DebugFlags::DebugFlags()
{
    HKEY hKey;

    if ( ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\COM3\\Debug", 0, KEY_ALL_ACCESS, &hKey) )
    {
        if ( ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\COM3\\Debug", 0, KEY_READ, &hKey) )
        {
            return;         // no further initialization possible
        }
    }

    InitBoolean (hKey, L"AutoAddTraceToContext",    &sm_fAutoAddTraceToContext);
    InitBoolean (hKey, L"DebugBreakOnFailFast",     &sm_fDebugBreakOnFailFast);
    InitBoolean (hKey, L"DebugBreakOnInitComPlus",  &sm_fDebugBreakOnInitComPlus);
    InitBoolean (hKey, L"DebugBreakOnLoadComsvcs",  &sm_fDebugBreakOnLoadComsvcs);
    InitBoolean (hKey, L"TraceActivityModule",      &sm_fTraceActivityModule);
    InitBoolean (hKey, L"TraceContextCreation",     &sm_fTraceContextCreation);
    InitBoolean (hKey, L"TraceInfrastructureCalls", &sm_fTraceInfrastructureCalls);
    InitBoolean (hKey, L"TraceSTAPool",             &sm_fTraceSTAPool);
    InitBoolean (hKey, L"TraceSecurity",            &sm_fTraceSecurity);
	InitBoolean (hKey, L"TraceSecurityPM",          &sm_fTraceSecurityPM);
	InitDWORD   (hKey, L"EventDispatchTtime",       &sm_dwEventDispatchTime);

    RegCloseKey (hKey);
}


// InitBoolean will initialize a boolean depending on a particular value in the registry.
// If the value starts with "Y" or "y", the boolean will be set to TRUE.
// If the value starts with "N" or "n", the boolean will be set to FALSE.
// If the value doesn't exist, or starts with anything else, the boolean will be unchanged.
void DebugFlags::InitBoolean (HKEY hKey, const WCHAR* wszValueName, BOOL* pf)
{
    WCHAR wszValue[120];
    unsigned long cbData = sizeof (wszValue);

    if ( ERROR_SUCCESS == RegQueryValueEx (hKey, wszValueName, NULL, NULL, (BYTE*)wszValue, &cbData) )
    {

        if ( (wszValue[0] & 0xFFDF) == 'Y' )
        {
            *pf = TRUE;
        }

        if ( (wszValue[0] & 0xFFDF) == 'N' )
        {
            *pf = FALSE;
        }
    }
    else
    {
        wszValue[0] = *pf ? 'Y' : 'N';
        wszValue[1] = '\0';
        LONG lrc = RegSetValueEx(hKey, wszValueName, 0, REG_SZ, (BYTE*) wszValue, 4 );
    }
}

//
// InitDWORD - reads a DWORD value from the registry into a DWORD
//
void DebugFlags::InitDWORD (HKEY hKey, const WCHAR* wszValueName, DWORD* pdw)
{
	
	DWORD cbSize = sizeof( *pdw );
	DWORD dwType = REG_DWORD;

	// If it can't be read, create the value.
	if ( ERROR_SUCCESS != RegQueryValueEx (hKey, wszValueName, NULL, &dwType, (BYTE*)pdw, &cbSize))
	{
		LONG lrc = RegSetValueEx(hKey, wszValueName, 0, REG_DWORD, (BYTE*) pdw, cbSize );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\csecutil.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//---------------------------------------------------------------------------
// @doc
//
// @module csecutil.cpp |
//
// Implementation of the following security utility classes <nl>
//
//	<c CSecDesc> - manage NT security descriptors (& ACLs) <nl>
//	<c CToken>   - manage NT security tokens (not yet implemented) <nl>
//	<c CSid>     - manage NT security identifiers <nl>
//

#include <unicode.h>
#include <windows.h>
#include <stdlib.h>
#include "svcmem.h"
#include "csecutil.h"


//---------------------------------------------------------------------------
// @mfunc Constructor - clears all member variables
//
CSecDesc::CSecDesc()
	: m_pSD(NULL)
	, m_pOwner(NULL)
	, m_pGroup(NULL)
	, m_pDACL(NULL)
	, m_pSACL(NULL)
{
}


//---------------------------------------------------------------------------
// @mfunc Destructor - frees allocated memory
//
CSecDesc::~CSecDesc()
{
	if (m_pSD)
		delete m_pSD;
	if (m_pOwner)
		free(m_pOwner);
	if (m_pGroup)
		free(m_pGroup);
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSACL)
		free(m_pSACL);
}


//---------------------------------------------------------------------------
// @mfunc Initializes all member variables, allocates space for the security
// descriptor and initializes the SD with a NULL DACL.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::Initialize()
{
	if (m_pSD)
	{
		delete m_pSD;
		m_pSD = NULL;
	}
	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}
	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSACL)
	{
		free(m_pSACL);
		m_pSACL = NULL;
	}

	m_pSD = new SECURITY_DESCRIPTOR;
	if (!m_pSD)
		return E_OUTOFMEMORY;

	if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		delete m_pSD;
		m_pSD = NULL;
		Win4Assert(FALSE);
		return hr;
	}
	// Set the DACL to allow EVERYONE
	SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);
	return S_OK;
}


//---------------------------------------------------------------------------
// @mfunc Initializes the wrapper, using the process token to set the user
// and group SIDs of the security descriptor.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::InitializeFromProcessToken
(
	BOOL bDefaulted		// @parm (IN) sets the SD's "defaulted" flag
)
{
	PSID pUserSid;
	PSID pGroupSid;
	HRESULT hr;

	hr = Initialize();
	if (FAILED(hr))
		return hr;
	hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (FAILED(hr))
		return hr;
	hr = SetOwner(pUserSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	hr = SetGroup(pGroupSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	return S_OK;
}


//---------------------------------------------------------------------------
// @mfunc Initializes the wrapper, using the thread token to set the user
// and group SIDs of the security descriptor. If bRevertToProcessToken is
// TRUE, then we use the process token if the thread is not impersonating.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::InitializeFromThreadToken
(
	BOOL bDefaulted,			// @parm (IN) sets the SD's "defaulted" flag
	BOOL bRevertToProcessToken	// @parm (IN) use process token if not imp?
)
{
	PSID pUserSid;
	PSID pGroupSid;
	HRESULT hr;

	hr = Initialize();
	if (FAILED(hr))
		return hr;
	hr = GetThreadSids(&pUserSid, &pGroupSid);
	if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
		hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (FAILED(hr))
		return hr;
	hr = SetOwner(pUserSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	hr = SetGroup(pGroupSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	return S_OK;
}


//---------------------------------------------------------------------------
// @mfunc Sets the owner SID of the security descriptor.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::SetOwner
(
	PSID pOwnerSid,		// @parm (IN) the new owner SID
	BOOL bDefaulted		// @parm (IN) sets the SD's "defaulted" flag
)
{
	Win4Assert(m_pSD);

	// Mark the SD as having no owner
	if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
		return hr;
	}

	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}

	// If they asked for no owner don't do the copy
	if (pOwnerSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pOwnerSid);

	m_pOwner = (PSID) malloc(dwSize);
	if (!m_pOwner)
	{
		// Insufficient memory to allocate Sid
		Win4Assert(FALSE);
		return E_OUTOFMEMORY;
	}
	if (!CopySid(dwSize, m_pOwner, pOwnerSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	Win4Assert(IsValidSid(m_pOwner));

	if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	return S_OK;
}


//---------------------------------------------------------------------------
// @mfunc Sets the group SID of the security descriptor.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::SetGroup
(
	PSID pGroupSid,		// @parm (IN) the new group SID
	BOOL bDefaulted		// @parm (IN) sets the SD's "defaulted" flag
)
{
	Win4Assert(m_pSD);

	// Mark the SD as having no Group
	if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
		return hr;
	}

	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}

	// If they asked for no Group don't do the copy
	if (pGroupSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pGroupSid);

	m_pGroup = (PSID) malloc(dwSize);
	if (!m_pGroup)
	{
		// Insufficient memory to allocate Sid
		Win4Assert(FALSE);
		return E_OUTOFMEMORY;
	}
	if (!CopySid(dwSize, m_pGroup, pGroupSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	Win4Assert(IsValidSid(m_pGroup));

	if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	return S_OK;
}


//---------------------------------------------------------------------------
// @mfunc Set the control bits on the SD.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::SetControl
(
	SECURITY_DESCRIPTOR_CONTROL sdcMask,	// @parm (IN) which bits to set
	SECURITY_DESCRIPTOR_CONTROL sdcValue	// @parm (IN) value of modified bits
)
{
	if (SetSecurityDescriptorControl(m_pSD, sdcMask, sdcValue))
		return S_OK;
	else
		return HRESULT_FROM_WIN32(GetLastError());
}


//---------------------------------------------------------------------------
// @mfunc Adds an access-allowed ACE to the DACL for the security descriptor.
// The given principal name is found with LookupAccountName and the account's
// SID and the given access mask are used to form the new ACE.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::Allow
(
	LPCTSTR pszPrincipal,	// @parm (IN) account to be granted access
	DWORD dwAccessMask,		// @parm (IN) specifies the access to be given
	DWORD dwAceFlags		// @parm (IN) optional flags related to inheritance
)
{
	HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask, dwAceFlags);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Adds an access-denied ACE to the DACL for the security descriptor.
// The given principal name is found with LookupAccountName and the account's
// SID and the given access mask are used to form the new ACE.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::Deny
(
	LPCTSTR pszPrincipal,	// @parm (IN) account to be denied access
	DWORD dwAccessMask,		// @parm (IN) specifies the access to be denied
	DWORD dwAceFlags		// @parm (IN) optional flags related to inheritance
)
{
	HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask, dwAceFlags);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Removes an access-allowed or access-denied ACE from the DACL for
// the security descriptor. The given principal name is found with
// LookupAccountName and the account's SID is removed from the DACL.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::Revoke
(
	LPCTSTR pszPrincipal	// @parm (IN) account to be removed from the ACL
)
{
	HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Adds an access-allowed ACE to the DACL for the security descriptor.
// The given SID and access mask are used to form the new ACE.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::Allow
(
	PSID psidPrincipal,		// @parm (IN) account to be granted access
	DWORD dwAccessMask,		// @parm (IN) specifies the access to be granted
	DWORD dwAceFlags		// @parm (IN) optional flags related to inheritance
)
{
	HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, psidPrincipal, dwAccessMask, dwAceFlags);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Adds an access-denied ACE to the DACL for the security descriptor.
// The given SID and access mask are used to form the new ACE.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::Deny
(
	PSID psidPrincipal,		// @parm (IN) account to be denied access
	DWORD dwAccessMask,		// @parm (IN) specifies the access to be denied
	DWORD dwAceFlags		// @parm (IN) optional flags related to inheritance
)
{
	HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, psidPrincipal, dwAccessMask, dwAceFlags);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Removes an access-allowed or access-denied ACE from the DACL for
// the security descriptor.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::Revoke
(
	PSID psidPrincipal		// @parm (IN) account to be removed from the ACL
)
{
	HRESULT hr = RemovePrincipalFromACL(m_pDACL, psidPrincipal);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Retrieves the user and primary group SIDs from the current process
// token. Either input parameter may be NULL to indicate that the associated
// SID should not be returned.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::GetProcessSids
(
	PSID* ppUserSid,	// @parm (OUT) returns the process token user SID
	PSID* ppGroupSid	// @parm (OUT) returns the process token group SID
)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	if (!bRes)
	{
		// Couldn't open process token
		hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Retrieves the user and primary group SIDs from the current thread
// token (if any). Either input parameter may be NULL to indicate that the
// associated SID should not be returned.
//
// @rdesc Returns a standard HRESULT. Fails if the current thread is not
// impersonating.
//
HRESULT CSecDesc::GetThreadSids
(
	PSID* ppUserSid,	// @parm (OUT) returns the thread token user SID
	PSID* ppGroupSid,	// @parm (OUT) returns the thread token group SID
	BOOL bOpenAsSelf	// @parm (IN) used in call to OpenThreadToken
)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
	if (!bRes)
	{
		// Couldn't open thread token
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Retrieves the user and primary group SIDs from the given token.
// Either input parameter may be NULL to indicate that the associated SID
// should not be returned.
//
// @rdesc Returns a standard HRESULT. Fails if the current thread is not
// impersonating.
//
HRESULT CSecDesc::GetTokenSids
(
	HANDLE hToken,		// @parm (IN) token whose SIDs are to be returned
	PSID* ppUserSid,	// @parm (OUT) returns the token user SID
	PSID* ppGroupSid	// @parm (OUT) returns the token group SID
)
{
	DWORD dwSize;
	HRESULT hr;
	PTOKEN_USER ptkUser = NULL;
	PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;

	if (ppUserSid)
	{
		// Get length required for TokenUser by specifying buffer length of 0
		GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			Win4Assert(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkUser = (TOKEN_USER*) malloc(dwSize);
		if (!ptkUser)
		{
			// Insufficient memory to allocate TOKEN_USER
			Win4Assert(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			Win4Assert(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkUser->User.Sid);

		PSID pSid = (PSID) malloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			Win4Assert(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			Win4Assert(FALSE);
			goto failed;
		}

		Win4Assert(IsValidSid(pSid));
		*ppUserSid = pSid;
		free(ptkUser);
	}
	if (ppGroupSid)
	{
		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			Win4Assert(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
		if (!ptkGroup)
		{
			// Insufficient memory to allocate TOKEN_USER
			Win4Assert(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			Win4Assert(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

		PSID pSid = (PSID) malloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			Win4Assert(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			Win4Assert(FALSE);
			goto failed;
		}

		Win4Assert(IsValidSid(pSid));

		*ppGroupSid = pSid;
		free(ptkGroup);
	}

	return S_OK;

failed:
	if (ptkUser)
		free(ptkUser);
	if (ptkGroup)
		free (ptkGroup);
	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Returns the user SID associated with the current process.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::GetCurrentUserSID
(
	PSID *ppSid		// @parm (OUT) returns the user SID
)
{
	HANDLE tkHandle;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
	{
		TOKEN_USER *tkUser;
		DWORD tkSize;
		DWORD sidLength;

		// Call to get size information for alloc
		GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
		tkUser = (TOKEN_USER *) malloc(tkSize);

		// Now make the real call
		if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
		{
			sidLength = GetLengthSid(tkUser->User.Sid);
			*ppSid = (PSID) malloc(sidLength);

			memcpy(*ppSid, tkUser->User.Sid, sidLength);
			CloseHandle(tkHandle);

			free(tkUser);
			return S_OK;
		}
		else
		{
			free(tkUser);
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}
	return HRESULT_FROM_WIN32(GetLastError());
}


//---------------------------------------------------------------------------
// @mfunc Returns the user SID associated with the given principal name. This
// is basically a wrapper around LookupAccountName. This is made obsolete by
// CSid::InitializeFromName().
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::GetPrincipalSID
(
	LPCTSTR pszPrincipal,	// @parm (IN) principal name whose SID is desired
	PSID *ppSid				// @parm (OUT) returns the desired SID
)
{
	HRESULT hr;
	LPTSTR pszRefDomain = NULL;
	DWORD dwDomainSize = 0;
	DWORD dwSidSize = 0;
	SID_NAME_USE snu;

	// Call to get size info for alloc
	LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pszRefDomain = new TCHAR[dwDomainSize];
	if (pszRefDomain == NULL)
		return E_OUTOFMEMORY;

	*ppSid = (PSID) malloc(dwSidSize);
	if (*ppSid != NULL)
	{
		if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
		{
			free(*ppSid);
			*ppSid = NULL;
			delete[] pszRefDomain;
			return HRESULT_FROM_WIN32(GetLastError());
		}
		delete[] pszRefDomain;
		return S_OK;
	}
	delete[] pszRefDomain;
	return E_OUTOFMEMORY;
}


//---------------------------------------------------------------------------
// @mfunc Initializes the CSecDesc object from the given security descriptor.
// There is no corresponding Detach method because we don't actually wrap the
// given SD and take ownership of its memory.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::Attach
(
	PSECURITY_DESCRIPTOR pSelfRelativeSD	// @parm (IN) SD to initialize from
)
{
	PACL    pDACL = NULL;
	PACL    pSACL = NULL;
	BOOL    bDACLPresent, bSACLPresent;
	BOOL    bDefaulted;
	PACL    m_pDACL = NULL;
	ACCESS_ALLOWED_ACE* pACE;
	HRESULT hr;
	PSID    pUserSid;
	PSID    pGroupSid;

	hr = Initialize();
	if(FAILED(hr))
		return hr;

	// get the existing DACL.
	if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
		goto failed;

	if (bDACLPresent)
	{
		if (pDACL)
		{
			// allocate new DACL.
			m_pDACL = (PACL) malloc(pDACL->AclSize);
			if (!m_pDACL)
				goto failed;

			// initialize the DACL
			if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pDACL->AceCount; i++)
			{
				if (!GetAce(pDACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pDACL))
				goto failed;
		}

		// set the DACL
		if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
			goto failed;
	}

	// get the existing SACL.
	if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
		goto failed;

	if (bSACLPresent)
	{
		if (pSACL)
		{
			// allocate new SACL.
			m_pSACL = (PACL) malloc(pSACL->AclSize);
			if (!m_pSACL)
				goto failed;

			// initialize the SACL
			if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pSACL->AceCount; i++)
			{
				if (!GetAce(pSACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pSACL))
				goto failed;
		}

		// set the SACL
		if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
			goto failed;
	}

	if (!GetSecurityDescriptorOwner(pSelfRelativeSD, &pUserSid, &bDefaulted))
		goto failed;

	if (FAILED(SetOwner(pUserSid, bDefaulted)))
		goto failed;

	if (!GetSecurityDescriptorGroup(pSelfRelativeSD, &pGroupSid, &bDefaulted))
		goto failed;

	if (FAILED(SetGroup(pGroupSid, bDefaulted)))
		goto failed;

	if (!IsValidSecurityDescriptor(m_pSD))
		goto failed;

	return hr;

failed:
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSD)
		free(m_pSD);
	return E_UNEXPECTED;
}


//---------------------------------------------------------------------------
// @mfunc Initializes the CSecDesc object using the security descriptor for
// the given kernel object. There is no corresponding Detach method because
// we don't actually wrap the given SD and take ownership of its memory.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::AttachObject
(
	HANDLE hObject		// @parm (IN) the object whose SD we initialize with
)
{
	HRESULT hr;
	DWORD dwSize = 0;
	PSECURITY_DESCRIPTOR pSD = NULL;

	GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);

	if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		free(pSD);
		return hr;
	}

	hr = Attach(pSD);
	free(pSD);
	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Copies the ACEs from one ACL to another.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::CopyACL
(
	PACL pDest,		// @parm (OUT) ptr to destination ACL
	PACL pSrc		// @parm (IN) ptr to source ACL
)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	LPVOID pAce;
	ACE_HEADER *aceHeader;

	if (pSrc == NULL)
		return S_OK;

	if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		return HRESULT_FROM_WIN32(GetLastError());

	// Copy all of the ACEs to the new ACL
	for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pSrc, i, &pAce))
			return HRESULT_FROM_WIN32(GetLastError());

		aceHeader = (ACE_HEADER *) pAce;

		if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
			return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}


//---------------------------------------------------------------------------
// @mfunc Adds an access-denied ACE to an ACL given a principal's SID.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::AddAccessDeniedACEToACL
(
	PACL *ppAcl,			// @parm (IN/OUT) ACL to be amended
	PSID psidPrincipal,		// @parm (IN) principal to be added to the ACL
	DWORD dwAccessMask,		// @parm (IN) the desired access mask
	DWORD dwAceFlags		// @parm (IN) optional flags related to inheritance
)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PACL oldACL, newACL;

	oldACL = *ppAcl;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(psidPrincipal) - sizeof(DWORD);

	newACL = (PACL) malloc(aclSize);

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
		return HRESULT_FROM_WIN32(GetLastError());

	if (!AddAccessDeniedAceEx(newACL, ACL_REVISION2, dwAceFlags, dwAccessMask, psidPrincipal))
		return HRESULT_FROM_WIN32(GetLastError());

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
		return returnValue;

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	return S_OK;
}


//---------------------------------------------------------------------------
// @mfunc Adds an access-denied ACE to an ACL given a principal's name.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::AddAccessDeniedACEToACL
(
	PACL *ppAcl,			// @parm (IN/OUT) ACL to be amended
	LPCTSTR pszPrincipal,	// @parm (IN) principal to be added to the ACL
	DWORD dwAccessMask,		// @parm (IN) the desired access mask
	DWORD dwAceFlags		// @parm (IN) optional flags related to inheritance
)
{
	DWORD returnValue;
	PSID principalSID;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	returnValue = AddAccessDeniedACEToACL(ppAcl, principalSID, dwAccessMask, dwAceFlags);
	free(principalSID);

	return returnValue;
}


//---------------------------------------------------------------------------
// @mfunc Adds an access-allowed ACE to an ACL given a principal's SID.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::AddAccessAllowedACEToACL
(
	PACL *ppAcl,			// @parm (IN/OUT) ACL to be amended
	PSID psidPrincipal,		// @parm (IN) principal to be added to the ACL
	DWORD dwAccessMask,		// @parm (IN) the desired access mask
	DWORD dwAceFlags		// @parm (IN) optional flags related to inheritance
)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PACL oldACL, newACL;

	oldACL = *ppAcl;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidPrincipal) - sizeof(DWORD);

	newACL = (PACL) malloc(aclSize);

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
		return HRESULT_FROM_WIN32(GetLastError());

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
		return returnValue;

	if (!AddAccessAllowedAceEx(newACL, ACL_REVISION2, dwAceFlags, dwAccessMask, psidPrincipal))
		return HRESULT_FROM_WIN32(GetLastError());

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	return S_OK;
}


//---------------------------------------------------------------------------
// @mfunc Adds an access-allowed ACE to an ACL given a principal's name.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSecDesc::AddAccessAllowedACEToACL
(
	PACL *ppAcl,			// @parm (IN/OUT) ACL to be amended
	LPCTSTR pszPrincipal,	// @parm (IN) principal to be added to the ACL
	DWORD dwAccessMask,		// @parm (IN) the desired access mask
	DWORD dwAceFlags		// @parm (IN) optional flags related to inheritance
)
{
	DWORD returnValue;
	PSID principalSID;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	returnValue = AddAccessAllowedACEToACL(ppAcl, principalSID, dwAccessMask, dwAceFlags);
	free(principalSID);

	return returnValue;
}


//---------------------------------------------------------------------------
// @mfunc Removes the first ACE matching the specified principal SID from the
// given ACL.
//
// @rdesc Returns a standard HRESULT. Returns S_OK if the given SID isn't
// found in the ACL.
//
HRESULT CSecDesc::RemovePrincipalFromACL
(
	PACL pAcl,			// @parm (IN/OUT) the ACL to be modified
	PSID psidPrincipal	// @parm (IN) the SID whose ACE should be removed
)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	ULONG i;
	LPVOID ace;
	ACCESS_ALLOWED_ACE *accessAllowedAce;
	ACCESS_DENIED_ACE *accessDeniedAce;
	SYSTEM_AUDIT_ACE *systemAuditAce;
	DWORD returnValue;
	ACE_HEADER *aceHeader;

	GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	for (i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pAcl, i, &ace))
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}

		aceHeader = (ACE_HEADER *) ace;

		if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
		{
			accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

			if (EqualSid(psidPrincipal, (PSID) &accessAllowedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
		{
			accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

			if (EqualSid(psidPrincipal, (PSID) &accessDeniedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
		{
			systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

			if (EqualSid(psidPrincipal, (PSID) &systemAuditAce->SidStart))
			{
				DeleteAce(pAcl, i);
				return S_OK;
			}
		}
	}
	return S_OK;
}


//---------------------------------------------------------------------------
// @mfunc Removes the first ACE matching the specified principal name from
// the given ACL.
//
// @rdesc Returns a standard HRESULT. Returns S_OK if the given principal
// isn't found in the ACL.
//
HRESULT CSecDesc::RemovePrincipalFromACL
(
	PACL pAcl,				// @parm (IN/OUT) the ACL to be modified
	LPCTSTR pszPrincipal	// @parm (IN) the account whose ACE should be removed
)
{
	PSID principalSID;
	DWORD returnValue;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	returnValue = RemovePrincipalFromACL(pAcl, principalSID);
	free(principalSID);

	return returnValue;
}


// CToken implementation


//---------------------------------------------------------------------------
// @mfunc Constructor - clears all member variables
//
CToken::CToken()
	: m_hToken(INVALID_HANDLE_VALUE)
	, m_dwFlags(0)
	, m_pTokenGroups(NULL)
{
}


//---------------------------------------------------------------------------
// @mfunc Destructor - closes the token handle (if present) and releases any
// memory we hold.
//
CToken::~CToken()
{
	if (INVALID_HANDLE_VALUE != m_hToken)
		CloseHandle(m_hToken);

	m_hToken = INVALID_HANDLE_VALUE;

	delete [] m_pTokenGroups;
	m_pTokenGroups = 0;
}


//---------------------------------------------------------------------------
// @mfunc Associates the CToken object with the given token. The
// corresponding Detach call removes the association. If the CToken object
// is destroyed while attached to a token, the token handle is closed. If the
// Detach call is made, then ownership of the token handle returns to the
// caller who is then responsible for calling CloseHandle.
//
void CToken::Attach(HANDLE hToken)
{
	Initialize();

	m_hToken = hToken;
	m_dwFlags |= fTokenAttached;
}


//---------------------------------------------------------------------------
// @mfunc Removes the association between the CToken object and a handle.
// The handle must have been obtained by a previous call to Attach.
//
// @rdesc Returns the token handle to the caller, who is now responsible for
// calling CloseHandle().
//
HANDLE CToken::Detach()
{
	HANDLE h;

	if (m_dwFlags & fTokenAttached)
	{
		h = m_hToken;
		m_hToken = INVALID_HANDLE_VALUE;

		Initialize();

		return h;
	}
	else
	{
		Win4Assert(0 && "CToken: Detach w/o Attach");
		return INVALID_HANDLE_VALUE;
	}
}


//---------------------------------------------------------------------------
// @mfunc Helper function initializes all member variables. Any token handle
// is closed, and dynamically allocated memory is freed.
//
void CToken::Initialize()
{
	if (INVALID_HANDLE_VALUE != m_hToken)
		CloseHandle(m_hToken);

	m_hToken = INVALID_HANDLE_VALUE;

	delete [] m_pTokenGroups;
	m_pTokenGroups = 0;

	m_dwFlags = 0;
}


//---------------------------------------------------------------------------
// @mfunc Initializes the CToken object to wrap the current process token.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CToken::InitializeFromProcess()
{
	HRESULT	hr = S_OK;

	Initialize();

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &m_hToken))
	{
		// Couldn't open process token
		hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
	}

	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Initializes the CToken object to wrap the current thread token (if
// any). Returns an error if the current thread is not impersonating.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CToken::InitializeFromThread
(
	BOOL fOpenAsSelf	// @parm (IN) used in the call to OpenThreadToken
)
{
	HRESULT	hr = S_OK;

	Initialize();

	if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, fOpenAsSelf, &m_hToken))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
	}

	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Initializes the CToken object to wrap the token for the current COM
// client. Returns an error if not called in the context of a COM method call.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CToken::InitializeFromComClient()
{
	HRESULT	hr;

	// TODO: Could add an assert to confirm that we aren't already impersonating.

	Initialize();

	hr = CoImpersonateClient();

	if (S_OK == hr)
	{
		if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &m_hToken))
			hr = HRESULT_FROM_WIN32(GetLastError());

		RevertToSelf();
	}

	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Retrieves the user and primary group SIDs from the wrapped token.
// Either input parameter may be NULL to indicate that the associated SID
// should not be returned.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CToken::GetSids
(
	PSID* ppUserSid,	// @parm (OUT) returns the token user SID
	PSID* ppGroupSid	// @parm (OUT) returns the token group SID
)
{
	DWORD		dwSize;
	HRESULT		hr;
	PTOKEN_USER ptkUser = NULL;
	PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;

	if (INVALID_HANDLE_VALUE == m_hToken)
	{
		Win4Assert(0 && "CToken::GetSids - no token");
		return E_UNEXPECTED;
	}

	if (ppUserSid)
	{
		// Get length required for TokenUser by specifying buffer length of 0
		GetTokenInformation(m_hToken, TokenUser, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			Win4Assert(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkUser = (TOKEN_USER*) UnsafeMalloc(dwSize);
		if (!ptkUser)
		{
			// Insufficient memory to allocate TOKEN_USER
			Win4Assert(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(m_hToken, TokenUser, ptkUser, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			Win4Assert(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkUser->User.Sid);

		PSID pSid = (PSID) UnsafeMalloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			Win4Assert(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			Win4Assert(FALSE);
			goto failed;
		}

		Win4Assert(IsValidSid(pSid));
		*ppUserSid = pSid;
		UnsafeFree(ptkUser);
	}

	if (ppGroupSid)
	{
		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(m_hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			Win4Assert(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkGroup = (TOKEN_PRIMARY_GROUP*) UnsafeMalloc(dwSize);
		if (!ptkGroup)
		{
			// Insufficient memory to allocate TOKEN_USER
			Win4Assert(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(m_hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			Win4Assert(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

		PSID pSid = (PSID) UnsafeMalloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			Win4Assert(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			Win4Assert(FALSE);
			goto failed;
		}

		Win4Assert(IsValidSid(pSid));

		*ppGroupSid = pSid;
		UnsafeFree(ptkGroup);
	}

	return S_OK;

failed:
	if (ptkUser)
		UnsafeFree(ptkUser);
	if (ptkGroup)
		UnsafeFree(ptkGroup);
	return hr;

}


//---------------------------------------------------------------------------
// @mfunc Examines the group information in the token to test for membership
// in a given group. The given group must be present and enabled to qualify
// for membership.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CToken::IsMemberOfGroup
(
	const PSID psidGroup,	// @parm (IN) Is token is a member of this group?
	BOOL *pfIsMember		// @parm (OUT) Returns TRUE if token is a member
)
{
	if (NULL == pfIsMember)
		return E_INVALIDARG;

	if (NULL == psidGroup)
		return E_INVALIDARG;

	Win4Assert(IsValidSid(psidGroup));
	*pfIsMember = FALSE;

	if (INVALID_HANDLE_VALUE == m_hToken)
	{
		Win4Assert(0 && "CToken::IsMemberOfGroup - no token");
		return E_UNEXPECTED;
	}

	// See if we already extracted the groups from the token
	if (! (m_dwFlags & fGotTokenGroups))
	{
		DWORD	cbTokenGroups = 0;
		BOOL	fSuccess;

		Win4Assert(NULL == m_pTokenGroups);

		// Call GetTokenInformation to see how much space we need

		fSuccess = GetTokenInformation(m_hToken, TokenGroups, NULL, 0
						, &cbTokenGroups);

		if (fSuccess)
		{
			Win4Assert(0 && "CToken: unexpected success in GetTokenInformation!");
			return E_UNEXPECTED;
		}

		Win4Assert(cbTokenGroups > 0);

		m_pTokenGroups = (TOKEN_GROUPS *) new (UNSAFE) BYTE[cbTokenGroups];

		if (NULL == m_pTokenGroups)
			return E_OUTOFMEMORY;

		// Call GetTokenInformation again to get the desired information

		fSuccess = GetTokenInformation(m_hToken, TokenGroups, m_pTokenGroups
						, cbTokenGroups, &cbTokenGroups);

		if (fSuccess)
			m_dwFlags |= fGotTokenGroups;
		else
		{
			delete [] m_pTokenGroups;
			m_pTokenGroups = NULL;

			return HRESULT_FROM_WIN32(GetLastError());
		}
	}

	// Scan the group list to see if the desired group is present and enabled.

	for (DWORD i = 0; i < m_pTokenGroups->GroupCount ;i++)
	{
		if ((m_pTokenGroups->Groups[i].Attributes & SE_GROUP_ENABLED) &&
			(EqualSid(m_pTokenGroups->Groups[i].Sid, psidGroup)))
		{
			*pfIsMember = TRUE;
			break;
		}
	}

	return S_OK;
}


//---------------------------------------------------------------------------
// @mfunc Enable or disable a privilege in the wrapped token.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CToken::SetPrivilege
(
	LPCTSTR	privilege,		// @parm (IN) Name of the privilege
	BOOL	bEnable			// @parm (IN) TRUE to enable, FALSE to disable
)
{
	TOKEN_PRIVILEGES tpPrevious;
	TOKEN_PRIVILEGES tp;
	HRESULT hr;
	DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
	LUID luid;

	if (INVALID_HANDLE_VALUE == m_hToken)
	{
		Win4Assert(0 && "CToken::SetPrivilege - no token");
		return E_UNEXPECTED;
	}

	if (!LookupPrivilegeValue(NULL, privilege, &luid ))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
		return hr;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = 0;

	if (!AdjustTokenPrivileges(m_hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
		return hr;
	}

	tpPrevious.PrivilegeCount = 1;
	tpPrevious.Privileges[0].Luid = luid;

	if (bEnable)
		tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
	else
		tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

	if (!AdjustTokenPrivileges(m_hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		Win4Assert(FALSE);
		return hr;
	}

	return S_OK;
}


// CSid implementation


//---------------------------------------------------------------------------
// @mfunc Default constructor - clears all member variables
//
CSid::CSid()
	: m_psid(NULL)
	, m_dwFlags(0)
{
}


//---------------------------------------------------------------------------
// @mfunc Constructor - wraps the given SID. Same as calling Attach(pSid).
//
CSid::CSid
(
	PSID pSid		// @parm (IN) the PSID to which we attach
)
	: m_psid(pSid)
	, m_dwFlags(fSidAttached)
{
}


//---------------------------------------------------------------------------
// @mfunc Destructor - frees any allocated memory
//
CSid::~CSid()
{
	Initialize();
}


//---------------------------------------------------------------------------
// @mfunc Initializes the CSid object from the given principal name (by
// calling LookupAccountName).
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSid::InitializeFromName
(
	LPWSTR pwszName		// @parm (IN) the principal name whose SID we wrap
)
{
	HRESULT			hr = S_OK;
	WCHAR			szDomain[DNLEN+1];
	DWORD			cbSid, cchDomain;
	SID_NAME_USE	eUse;
	BYTE			Sid[x_cbMaxSidSize];

	Initialize();

	cbSid = sizeof Sid;
	cchDomain = sizeof(szDomain) / sizeof(WCHAR);

	if (!LookupAccountName(NULL, pwszName, (PSID) Sid
			, &cbSid, szDomain, &cchDomain, &eUse))
	{
		hr = GetLastError();
	}

	if (SUCCEEDED(hr))
	{
		m_psid = (PSID) new BYTE[cbSid];

		if (NULL == m_psid)
			hr = E_OUTOFMEMORY;
	}

	if (SUCCEEDED(hr))
	{
		if (!CopySid(cbSid, m_psid, (PSID) &Sid))
			hr = GetLastError();
	}

	if (SUCCEEDED(hr))
	{
		lstrcpyn(m_szName, pwszName, sizeof(m_szName)/sizeof(WCHAR));
		lstrcpyn(m_szDomain, szDomain, sizeof(m_szDomain)/sizeof(WCHAR));
		m_SidNameUse = eUse;
	}

	// If anything failed, reinitialize our member variables
	if (FAILED(hr))
		Initialize();

	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Assocates the CSid object with the given PSID. Should be matched
// with a call to Detach.
//
// @rdesc Returns a standard HRESULT.
//
void CSid::Attach
(
	PSID pSid		// @parm (IN) the PSID to which we attach
)
{
	Initialize();
	
	m_psid = pSid;
	m_dwFlags = fSidAttached;
}


//---------------------------------------------------------------------------
// @mfunc Ends the association with an attached PSID. Ownership of the PSID
// reverts to the caller who then becomes responsible for freeing this memory
// if required.
//
// @rdesc Returns the PSID that was previously attached.
//
PSID CSid::Detach()
{
	PSID	psid = m_psid;

	Initialize();

	return psid;
}


//---------------------------------------------------------------------------
// @mfunc Tests for equality with another CSid
//
// @rdesc Returns the boolean result.
//
BOOL CSid::operator==
(
	const CSid& csid	// @parm (IN) CSid to test against
) const
{
	Win4Assert(this->IsValid());
	Win4Assert(csid.IsValid());

	return EqualSid(m_psid, csid.m_psid);
}


//---------------------------------------------------------------------------
// @mfunc Tests for equality with another PSID
//
// @rdesc Returns the boolean result.
//
BOOL CSid::operator==
(
	const PSID pSid		// @parm (IN) PSID to test against
) const
{
	Win4Assert(this->IsValid());
	Win4Assert(IsValidSid(pSid));

	return EqualSid(m_psid, pSid);
}


//---------------------------------------------------------------------------
// @mfunc Tests for inequality with another CSid
//
// @rdesc Returns the boolean result.
//
BOOL CSid::operator!=
(
	const CSid& csid	// @parm (IN) CSid to test against
) const
{
	return !operator==(csid);
}


//---------------------------------------------------------------------------
// @mfunc Tests for inequality with another PSID
//
// @rdesc Returns the boolean result.
//
BOOL CSid::operator!=
(
	const PSID pSid		// @parm (IN) PSID to test against
) const
{
	return !operator==(pSid);
}


//---------------------------------------------------------------------------
// @mfunc Assignment from a CSid - allocates space for the SID and copies it.
//
// @rdesc Returns the LHS.
//
CSid& CSid::operator=
(
	const CSid& src		// @parm (IN) the RHS
)
{
	Win4Assert(src.IsValid());

	int	cbSid = src.GetLength();

	Initialize();
	m_psid = (PSID) new BYTE[cbSid];

	if (NULL == m_psid)
		throw E_OUTOFMEMORY;

	if (!CopySid(cbSid, m_psid, (PSID) src))
		throw GetLastError();

	return *this;
}


//---------------------------------------------------------------------------
// @mfunc Assignment from a PSID - allocates space for the SID and copies it.
//
// @rdesc Returns the LHS.
//
CSid& CSid::operator=
(
	const PSID pSid		// @parm (IN) the RHS
)
{
	CSid src(pSid);

	*this = src;

	return *this;
}


//---------------------------------------------------------------------------
// @mfunc Returns the length of the SID (wraps the call to GetLengthSid).
//
// @rdesc Returns the SID length.
//
DWORD CSid::GetLength() const
{
	if (NULL == m_psid)
		return 0;

	Win4Assert(IsValid());

	return GetLengthSid(m_psid);
}


//---------------------------------------------------------------------------
// @mfunc Returns the sub-authority count of the SID (wraps the call to
// GetSidSubAuthorityCount).
//
// @rdesc Returns the SID subauthority count.
//
DWORD CSid::GetSubAuthorityCount() const
{
	if (NULL == m_psid)
		return 0;

	Win4Assert(IsValid());

	return (DWORD) *GetSidSubAuthorityCount(m_psid);
}


//---------------------------------------------------------------------------
// @mfunc Returns a sub-authority value from the SID (wraps the call to
// GetSidSubAuthority).
//
// @rdesc Returns the SID subauthority.
//
DWORD CSid::GetSubAuthority
(
	DWORD iSubAuthority		// @parm (IN) number of the subauthority requested
) const
{
	if (NULL == m_psid)
		return 0;

	Win4Assert(IsValid());
	Win4Assert(iSubAuthority < GetSubAuthorityCount());

	return *GetSidSubAuthority(m_psid, iSubAuthority);
}


//---------------------------------------------------------------------------
// @mfunc Tests the validity of the wrapped SID.
//
// @rdesc Returns TRUE if the SID is valid, FALSE otherwise.
//
BOOL CSid::IsValid() const
{
	return IsValidSid(m_psid);
}


//---------------------------------------------------------------------------
// @mfunc Returns the (unqualified) account name associated with the SID. The
// output parameter returns a pointer to space owned by the CSid object - it
// should not be freed by the caller.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT	CSid::GetName
(
	LPWSTR *ppwszName		// @parm (OUT) Returns a ptr to the account name
)
{
	HRESULT hr = S_OK;

	if (NULL == ppwszName)
		hr = E_INVALIDARG;

	if (SUCCEEDED(hr) && !(m_dwFlags & fGotAccountName))
	{
		hr = DoLookupAccountSid();
	}

	if (SUCCEEDED(hr))
	{
		*ppwszName = m_szName;
	}

	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Returns the domain name associated with the SID. The output
// parameter returns a pointer to space owned by the CSid object - it
// should not be freed by the caller.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSid::GetDomain
(
	LPWSTR *ppwszDomain		// @parm (OUT) Returns a ptr to the domain name
)
{
	HRESULT hr = S_OK;

	if (NULL == ppwszDomain)
		hr = E_INVALIDARG;

	if (SUCCEEDED(hr) && !(m_dwFlags & fGotAccountName))
	{
		hr = DoLookupAccountSid();
	}

	if (SUCCEEDED(hr))
	{
		*ppwszDomain = m_szDomain;
	}

	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Returns the account type associated with the SID.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT CSid::GetAccountType
(
	PSID_NAME_USE psnu		// @parm (OUT) Returns the account type
)
{
	HRESULT hr = S_OK;

	if (NULL == psnu)
		hr = E_INVALIDARG;

	if (SUCCEEDED(hr) && !(m_dwFlags & fGotAccountName))
	{
		hr = DoLookupAccountSid();
	}

	if (SUCCEEDED(hr))
	{
		*psnu = m_SidNameUse;
	}

	return hr;
}


//---------------------------------------------------------------------------
// @mfunc Initializes the CSid member variables, releasing memory as needed.
//
void CSid::Initialize()
{
	if (m_psid && !(m_dwFlags & fSidAttached))
		delete [] m_psid;

	m_psid = NULL;
	m_dwFlags = 0;
}


//---------------------------------------------------------------------------
// @mfunc Helper function to make the call to LookupAccountSid. The account
// name, domain, and type are cached.
//
// @rdesc Returns a standard HRESULT.
//
HRESULT	CSid::DoLookupAccountSid()
{
	HRESULT			hr;
	DWORD			cchName = sizeof(m_szName)/sizeof(WCHAR);
	DWORD			cchDomain = sizeof(m_szDomain)/sizeof(WCHAR);

	if (LookupAccountSid(NULL, m_psid, m_szName, &cchName, m_szDomain
			, &cchDomain, &m_SidNameUse))
	{
		m_dwFlags |= fGotAccountName;
		hr = S_OK;
	}
	else
	{
		hr = GetLastError();
	}

	return hr;
}


// SID constants


// Universal well-known SIDs
const CSid::SID1 CSid::x_sidEveryone =
			{SID_REVISION, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };

// NT well-known SIDs
const CSid::SID1 CSid::x_sidDialup =
			{SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_DIALUP_RID };

const CSid::SID1 CSid::x_sidNetwork =
			{SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_NETWORK_RID };

const CSid::SID1 CSid::x_sidBatch =
			{SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_BATCH_RID };

const CSid::SID1 CSid::x_sidInteractive =
			{SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_INTERACTIVE_RID };

const CSid::SID1 CSid::x_sidService =
			{SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_SERVICE_RID };

const CSid::SID1 CSid::x_sidAuthenticated =
			{SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_AUTHENTICATED_USER_RID };

const CSid::SID1 CSid::x_sidSystem =
			{SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };

// Well-known domain users
const CSid::SID2 CSid::x_sidAdministrator =
			{SID_REVISION, 2, SECURITY_NT_AUTHORITY,
				SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_USER_RID_ADMIN };

// Local groups (aliases)
const CSid::SID2 CSid::x_sidLocalAdministrators =
			{SID_REVISION, 2, SECURITY_NT_AUTHORITY,
				SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS };

const CSid::SID2 CSid::x_sidLocalUsers =
			{SID_REVISION, 2, SECURITY_NT_AUTHORITY,
				SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS };

const CSid::SID2 CSid::x_sidLocalGuests =
			{SID_REVISION, 2, SECURITY_NT_AUTHORITY,
				SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_GUESTS };

const CSid::SID2 CSid::x_sidPowerUsers =
			{SID_REVISION, 2, SECURITY_NT_AUTHORITY,
				SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS };



// Public PSIDs for well-known users/groups

const PSID CSid::x_psidEveryone            = (PSID) &CSid::x_sidEveryone;

// NT well-known SIDs
const PSID CSid::x_psidDialup              = (PSID) &CSid::x_sidDialup;
const PSID CSid::x_psidNetwork             = (PSID) &CSid::x_sidNetwork;
const PSID CSid::x_psidBatch               = (PSID) &CSid::x_sidBatch;
const PSID CSid::x_psidInteractive         = (PSID) &CSid::x_sidInteractive;
const PSID CSid::x_psidService             = (PSID) &CSid::x_sidService;
const PSID CSid::x_psidAuthenticated       = (PSID) &CSid::x_sidAuthenticated;
const PSID CSid::x_psidSystem              = (PSID) &CSid::x_sidSystem;

// Well-known domain users
const PSID CSid::x_psidAdministrator       = (PSID) &CSid::x_psidAdministrator;

// Local groups (aliases)
const PSID CSid::x_psidLocalAdministrators = (PSID) &CSid::x_sidLocalAdministrators;
const PSID CSid::x_psidLocalUsers          = (PSID) &CSid::x_sidLocalUsers;
const PSID CSid::x_psidLocalGuests         = (PSID) &CSid::x_sidLocalGuests;
const PSID CSid::x_psidPowerUsers          = (PSID) &CSid::x_sidPowerUsers;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\pudebug\pudebug.cpp ===
/*++

    Copyright (c) 1994  Microsoft Corporation

    Module  Name :
        pudebug.c

    Abstract:

        This module defines functions required for
         Debugging and logging messages for a dynamic program.

    Author:
         Murali R. Krishnan ( MuraliK )    10-Sept-1994
         Modified to be moved to common dll in 22-Dec-1994.

    Revisions:
         MuraliK  16-May-1995  Code to load and save debug flags from registry
         MuraliK  16-Nov-1995  Remove DbgPrint (undoc api)
         JasAndre Jan-1998     Replaced tracing mechanism with WMI Tracing
         MohitS   Feb-2001     Put code in standalone lib
--*/

/************************************************************
 * Include Headers
 ************************************************************/

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
# include <stdio.h>
# include <stdlib.h>
# include <stdarg.h>
# include <string.h>

# include <coguid.h>
# include <objbase.h>

# include <winwrap.h>

# define OutputDebugStringW WszOutputDebugString
# define RegQueryValueExW   WszRegQueryValueEx
# define RegSetValueExW     WszRegSetValueEx

# include "dbgutil.h"
# include "initwmi.h"

/*************************************************************
 * Default Values
 *************************************************************/

#define sizeofw(param)                  ( sizeof(param) / sizeof(WCHAR) )

# define SHORT_PRINTF_OUTPUT        (1024)
# define MAX_PRINTF_OUTPUT          (SHORT_PRINTF_OUTPUT * 10)
# define DEFAULT_DEBUG_FLAGS_VALUE  (0)

/*************************************************************
 * Function definitions for WMI
 *
 * The WMI dll and these functions are loaded at first use so 
 * that this DLL will work with NT 4
 *************************************************************/

typedef ULONG (WINAPI *PFPREGISTERTRACEGUIDSW)(
    IN WMIDPREQUEST  RequestAddress,
    IN PVOID         RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG         GuidCount,
    IN PTRACE_GUID_REGISTRATION TraceGuidReg,
    IN LPCWSTR       MofImagePath,
    IN LPCWSTR       MofResourceName,
    OUT PTRACEHANDLE RegistrationHandle
    );

typedef TRACEHANDLE (WINAPI *PFPGETTRACELOGGERHANDLE)(
    IN PVOID Buffer
    );

typedef UCHAR (WINAPI *PFPGETTRACEENABLELEVEL)(
    IN TRACEHANDLE TraceHandle
    );

typedef ULONG (WINAPI *PFPGETTRACEENABLEFLAGS)(
    IN TRACEHANDLE TraceHandle
    );

typedef ULONG (WINAPI *PFPCONTROLTRACEW)(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG ControlCode
    );

typedef ULONG (WINAPI *PFPENABLETRACE)(
    IN ULONG Enable,
    IN ULONG EnableFlag,
    IN ULONG EnableLevel,
    IN LPCGUID ControlGuid,
    IN TRACEHANDLE TraceHandle
    );

typedef ULONG (WINAPI *PFPSTARTTRACEW)(
    OUT PTRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

typedef ULONG (WINAPI *PFPTRACEEVENT)(
    IN TRACEHANDLE  TraceHandle,
    IN PEVENT_TRACE_HEADER EventTrace
    );

/*************************************************************
 *   Global variables
 *************************************************************/

// The unique GUID which identifies this runtime library
DEFINE_GUID(AsRtlGuid, 
0x784d8940, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

// Used to make sure we initialize only once
CInitWmi    g_InitWmi;
// Critical section used to control access to the list of known guids used for 
// WMI tracing
SGuidList   g_GuidList;
// The sequence number of the trace message we are about to log
LONG        g_dwSequenceNumber = 0;
// This flag tells us whether or not to do any WMI handling
BOOL        g_bTracingEnabled = FALSE;
// This flag tells us if we had to start WMI tracing
BOOL        g_bStartedTracing = FALSE;
TRACEHANDLE g_hLoggerHandle = 0;
// This flag tells us whether to enable the guids as they are defined or to
// wait for an enable command from WMI
BOOL        g_bTracingActive = FALSE;
// This flag tells us whether or not to log info to OutputDebugString, this is
// SLOW
BOOL        g_ODSEnabled = FALSE;
// The filename and session name to use for the WMI Tracing file
WCHAR       g_szwLogFileName[MAX_PATH] = L"";
WCHAR       g_szwLogSessionName[MAX_PATH] = L"";
// The WMI Tracing buffer size, in KB, and the min and max number of buffers
// that are permitted, and max file size, 0 means use default
// If max file size is set then circular buffers are used
ULONG       g_ulBufferSize = 0;
ULONG       g_ulMinBuffers = 0;
ULONG       g_ulMaxBuffers = 0;
ULONG       g_ulMaxFileSize = 0;
// Three special modes that it is possible to start the logger in
BOOL        g_bRealTimeMode = FALSE;
BOOL        g_bInMemoryMode = FALSE;
BOOL        g_bUserMode = FALSE;
// The default values used for control flags and the error level. These 
// settings are only used for modules that have their active flags set
DWORD       g_dwDefaultControlFlag = 0;
DWORD       g_dwDefaultErrorLevel = 0;
// This flag tells us if we have done the registry initialization, we can't 
// register with WMI until this has been done
BOOL        g_bHaveDoneInit = FALSE;
// This flag tells us whether we have registered with WMI or not
BOOL        g_bHadARegister = FALSE;
// The WMI library instance handle
HINSTANCE   g_hLibInstance = NULL;

// Pointers to the WMI functions I use
PFPREGISTERTRACEGUIDSW pFPRegisterTraceGuidsW = NULL;
PFPGETTRACELOGGERHANDLE pFPGetTraceLoggerHandle = NULL;
PFPGETTRACEENABLELEVEL pFPGetTraceEnableLevel = NULL;
PFPGETTRACEENABLEFLAGS pFPGetTraceEnableFlags = NULL;
PFPCONTROLTRACEW pFPControlTraceW = NULL;
PFPENABLETRACE pFPEnableTrace = NULL;
PFPSTARTTRACEW pFPStartTraceW = NULL;
PFPTRACEEVENT pFPTraceEvent = NULL;

/*************************************************************
 *   Functions
 *************************************************************/

void SetLevel(
    int iDefaultErrorLevel, 
    BOOL fAlwaysODS,
    int *piErrorFlags
    ) 
/*++
   Support function used by all and sundry to convert the level, ie. 1, 2 or 3
   into the bitmapped format used in the error flags variable

   Arguments:
      iDefaultErrorLevel    new value to decode for the error level
      fAlwaysODS            new value for the AlwaysODS bit
      *piErrorFlags         pointer to the variable to set the error level in

   Returns:
        
--*/
{
    if (piErrorFlags) {

        // Set the AlwaysODS bit
        if (fAlwaysODS || g_ODSEnabled) {
            *piErrorFlags = DEBUG_FLAG_ODS;
        }
        else {
            *piErrorFlags = 0;
        }

        // Then or in the appropriate bit
        switch (iDefaultErrorLevel) {
            case DEBUG_LEVEL_ERROR: 
                *piErrorFlags |= DEBUG_FLAG_ERROR;
                break;

            case DEBUG_LEVEL_WARN:  
                *piErrorFlags |= DEBUG_FLAG_WARN;
                break;

            case DEBUG_LEVEL_INFO:
                *piErrorFlags |= DEBUG_FLAG_INFO;
                break;

			case DEBUG_LEVEL_TRC_FUNC:
				*piErrorFlags |= DEBUG_FLAG_TRC_FUNC;
				break;

            default: 
                break;
        };
    }
}


SGuidList *FindGuid(
    IN GUID *ControlGuid
    )
/*++
   Support function used by all and sundry to find a guid in the guid list.
   NOTE: It is the responsibility of the caller to enter the guid list
         critical section before calling this function

   Arguments:
      *ControlGuid   pointer to the guid that we are looking for

   Returns:
      NULL           if the guid is not in the list
      *DEBUG_PRINTS  the data relating to the guid if it is in the list
        
--*/
{
    BOOL bFound = FALSE;

    bFound = IsEqualGUID(*ControlGuid, g_GuidList.m_dpData.m_guidControl);
    return bFound ? &g_GuidList : NULL;
}


dllexp ULONG IISTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
/*++
   Callback function supplied to WMI so that it can notify me when the user 
   requests a change to the level or control flags for logging

   Arguments:
      RequestCode       control code used to determine what function to perform
      RequestContext    not used
      InOutBufferSize   size of the buffer supplied by WMI, set to 0 as we don't
                        send any data back to WMI through this mechanism
      Buffer            contains EVENT_TRACE_HEADER needed to identify whom a 
                        request is for

   Returns:
        
--*/
{
    PEVENT_TRACE_HEADER pHeader = (PEVENT_TRACE_HEADER) Buffer;
    LPGUID pGuid = &pHeader->Guid;
    ULONG Status = ERROR_SUCCESS;
    SGuidList *pGE = NULL;
    TRACEHANDLE hTrace;

    if (!pFPGetTraceLoggerHandle ||
        !pFPGetTraceEnableFlags ||
        !pFPGetTraceEnableLevel) 
    {
        return Status;
    }

    hTrace = pFPGetTraceLoggerHandle(Buffer);

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            ASSERT(pGuid);
            DBG_REQUIRE(pGE = FindGuid(pGuid));

            if (pGuid && pGE) {

                DEBUG_PRINTS *pGEData = &pGE->m_dpData;

                pGEData->m_iControlFlag = pFPGetTraceEnableFlags(hTrace);
                pGEData->m_hLogger = hTrace;

                if (pGEData->m_piErrorFlags) {

                    SetLevel(pFPGetTraceEnableLevel(hTrace), 
                             pGEData->m_fAlwaysODS,
                             pGEData->m_piErrorFlags);

                    // Flag us as no longer needing an initialize, important 
                    // step to prevent re-initialization attempts in 
                    // PuInitiateDebug
                    pGE->m_iInitializeFlags &= ~DEBUG_FLAG_INITIALIZE;
                    pGE->m_iDefaultErrorLevel = pFPGetTraceEnableLevel(hTrace);
                }
                else {
                    pGE->m_iInitializeFlags = DEBUG_FLAG_DEFERRED_START;
                    pGE->m_iDefaultErrorLevel = pFPGetTraceEnableLevel(hTrace);
                }
            }
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            if (pGuid && (NULL != (pGE = FindGuid(pGuid)))) {

                DEBUG_PRINTS *pGEData = &pGE->m_dpData;

                pGEData->m_iControlFlag = 0;
                pGEData->m_hLogger = hTrace;

                if (pGEData->m_piErrorFlags) {
                    SetLevel(0, 
                             pGEData->m_fAlwaysODS,
                             pGEData->m_piErrorFlags);
                    pGE->m_iDefaultErrorLevel = 0;
                }
            }
            break;
        }

        default:
        {
            char szTemp[MAX_PATH];

            _snprintf(szTemp, sizeof(szTemp), 
                      "ACSTRACE:\t%s(%d), IISTraceControlCallback: Invalid parameter\n", 
                      __FILE__, __LINE__);
            OutputDebugStringA(szTemp);
            Status = ERROR_INVALID_PARAMETER;
            break;
        }
    }
    *InOutBufferSize = 0;
    return Status;
}


bool LoadGuidFromRegistry(
    char* pszModuleName,
    GUID* pGuid)
/*++
   This function is used to load all the information stored in the registry
   about a module and to allocate an entry in the guid list for it
   NOTE: It is the responsibility of the caller to enter the guid list
         critical section before calling this function

   Arguments:
      pszModuleName  pointer to the name of the module we are about to process

   Returns:
        
--*/
{
    ASSERT(pGuid != NULL);

    WCHAR szwKeyName[MAX_PATH] = REG_TRACE_ACS L"\\";
    WCHAR *pszwKeyEnd = &szwKeyName[sizeofw(REG_TRACE_ACS)];
    DWORD dwSizeLeft = sizeofw(szwKeyName) - sizeofw(REG_TRACE_ACS);
    HKEY hk = 0;

    bool bFound = false;

    // Create the name of the key for this GUID using the english name, we 
    // need to convert the ASCII name to UNICODE for this to work
    if (!MultiByteToWideChar(CP_ACP, 0, 
                             pszModuleName, -1, 
                             pszwKeyEnd, dwSizeLeft))
    {
        char szTemp[MAX_PATH];

        sprintf(szTemp, "Unable to convert module name (%s)to unicode\n",
                        pszModuleName);
        OutputDebugStringA(szTemp);
        return bFound;
    }

    // Open the GUIDs key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szwKeyName, 0, KEY_READ, &hk)) {
        WCHAR szwTemp[MAX_PATH];
        DWORD dwReadSize;

        // 1. Load the guid number from the registry, we can only continue 
        // processing this module if we find a guid for it
        dwReadSize = sizeof(szwTemp);
        if (ERROR_SUCCESS == RegQueryValueExW(hk, REG_TRACE_IIS_GUID, 
                                             NULL, NULL,
                                             (BYTE *) szwTemp, 
                                             &dwReadSize)) {
            CLSID ControlGuid;

            // 2. Convert the guid string into a guid
            if (SUCCEEDED(CLSIDFromString(szwTemp, &ControlGuid))) {

                // 3. Ensure it matches the pGuid passed in
                if(IsEqualGUID(*pGuid, ControlGuid)) {
                    DEBUG_PRINTS *pGEData = NULL;
                    BOOL bGuidEnabled;
                    int iTemp;

                    // 4. We've found what we wanted.  Set g_GuidList
                    SGuidList *pGE = &g_GuidList;

                    pGEData = &pGE->m_dpData;

                    // Set the GuidList signature
                    pGE->dwSig = _SGuidList::TRACESIG;

                    // Set the SGuidList.m_dpData member variables
                    strncpy(pGEData->m_rgchLabel,
                            pszModuleName, MAX_LABEL_LENGTH - 1);
                    pGEData->m_guidControl = ControlGuid;
                    pGEData->m_bBreakOnAssert = TRUE;   // Default - Break if Assert Fails

                    // 5. Try to load any previous control settings from the registry
                    // 5.1 See if the guid is enabled, if so flag us as needing 
                    // to start this guid when we initialize with WMI
                    dwReadSize = sizeof(bGuidEnabled);
                    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_ACTIVE, 
                                                         NULL, NULL,
                                                         (BYTE *) &bGuidEnabled, 
                                                         &dwReadSize)) {
                        if (bGuidEnabled)
                            pGE->m_iInitializeFlags = DEBUG_FLAG_INITIALIZE;
                    }
                    // Otherwise use the global setting to determine this
                    else if (g_bTracingActive) 
                        pGE->m_iInitializeFlags = DEBUG_FLAG_INITIALIZE;

                    // If it is enabled then load the remaining flags
                    if (pGE->m_iInitializeFlags & DEBUG_FLAG_INITIALIZE) {

                        // 5.2 So next load the ControlFlags, the flags default 
                        // to the global setting
                        dwReadSize = sizeof(&iTemp);
                        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_CONTROL, 
                                                             NULL, NULL, 
                                                             (BYTE *) &iTemp, 
                                                             &dwReadSize))
                            pGEData->m_iControlFlag = iTemp;
                        else
                            pGEData->m_iControlFlag = g_dwDefaultControlFlag;

                        // 5.3 Then load the Level, it also defaults to the global 
                        // setting
                        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LEVEL, 
                                                             NULL, NULL,
                                                             (BYTE *) &iTemp, 
                                                             &dwReadSize)) {
                            pGE->m_iDefaultErrorLevel = iTemp;
                        }
                        else
                            pGE->m_iDefaultErrorLevel = g_dwDefaultErrorLevel;

                        // 5.4 And finally load the local AlwaysODS setting
                        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_ODS, 
                                                             NULL, NULL, 
                                                             (BYTE *) &iTemp, 
                                                             &dwReadSize))
                            pGEData->m_fAlwaysODS = iTemp;
                        else
                            pGEData->m_fAlwaysODS = g_ODSEnabled;
                    }
                    bFound = true;
                }

            }

        }
        RegCloseKey(hk);
    }

    return bFound;
}


dllexp void
AddToRegistry(
    IN SGuidList *pGE
    )
/*++
   This function creates new registry entries for this module so that it will
   be correctly loaded next time ACS is started
   NOTE: It is the responsibility of the caller to enter the guid list
         critical section before calling this function

   Arguments:
      *pGE                  pointer to the SGuidList entry which has all the 
                            information about the guid to add

   Returns:
      This returns void as it does not matter to the running program whether 
      this works or not, it just improves restart performance if it does.

--*/
{
    HKEY hk = 0;
    HKEY hkNew = 0;

    // Open the Trace registry key
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REG_TRACE_ACS, &hk)) {

        DEBUG_PRINTS *pGEData = &pGE->m_dpData;
        BOOL bCreatedGuid = FALSE;
        DWORD dwDisposition;

        // 1. Create a new key for the module
        if (ERROR_SUCCESS == RegCreateKeyExA(hk, pGEData->m_rgchLabel, 
                                             0, NULL, 
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_ALL_ACCESS,
                                             NULL, &hkNew, &dwDisposition))
        {
            WCHAR szwTemp[MAX_PATH];

            // 2. Convert the guid to a string so that we can add it to the 
            // registry, the format is E.g.
            // {37EABAF0-7FB6-11D0-8817-00A0C903B83C}
            if (StringFromGUID2(pGEData->m_guidControl, 
                                (WCHAR *) szwTemp,
                                MAX_PATH)) {

                // 3. Add the guid string to the module information
                // WARNING: Possible data loss on IA64
                if (ERROR_SUCCESS == RegSetValueExW(hkNew, 
                                                    REG_TRACE_IIS_GUID, 
                                                    0, 
                                                    REG_SZ, 
                                                    (BYTE *) szwTemp, 
                                                    (ULONG)(wcslen(szwTemp) + 1) * 
                                                            sizeof(WCHAR))) {
                    bCreatedGuid = TRUE;
                }
            }

            RegCloseKey(hkNew);

            if (!bCreatedGuid && (REG_CREATED_NEW_KEY == dwDisposition)) {

                RegDeleteKeyA(hk, pGEData->m_rgchLabel);
            }
        }

        RegCloseKey(hk);
    }
}

TRACEHANDLE
GetTraceFileHandle(
    VOID)
/*++
   This function create the tracing file for the current log file. It only does
   this if a module that has the DEBUG_FLAG_INITIALIZE bit is successfully 
   registered with WMI.

   Arguments:

   Returns:
--*/
{
    TRACEHANDLE hLogger = 0;

    // There must be a valid log file name and session name in order to create
    // the trace file
    if (g_szwLogFileName[0] && g_szwLogSessionName[0]) {

        struct {
            EVENT_TRACE_PROPERTIES Header;
            WCHAR LogFileName[MAX_PATH];
            WCHAR LoggerName[MAX_PATH];
        } Properties;

        PEVENT_TRACE_PROPERTIES LoggerInfo;
        ULONG Status = ERROR_SUCCESS;
    
        LoggerInfo = (PEVENT_TRACE_PROPERTIES)&Properties.Header;

        // Set up the request structure
        RtlZeroMemory(&Properties, sizeof(Properties));
        LoggerInfo->Wnode.BufferSize = sizeof(Properties);
        LoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
        if (0 == g_ulMaxFileSize)
            LoggerInfo->LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
        else {
            LoggerInfo->LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;
            LoggerInfo->MaximumFileSize = g_ulMaxFileSize;
        }
        if (g_bRealTimeMode)
            LoggerInfo->LogFileMode |= EVENT_TRACE_REAL_TIME_MODE;
        else if (g_bInMemoryMode)
            LoggerInfo->LogFileMode |= EVENT_TRACE_BUFFERING_MODE;
        else if (g_bUserMode)
            LoggerInfo->LogFileMode |= EVENT_TRACE_PRIVATE_LOGGER_MODE;

        wcscpy(&Properties.LoggerName[0], g_szwLogSessionName);
        wcscpy(&Properties.LogFileName[0], g_szwLogFileName);
        LoggerInfo->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
        LoggerInfo->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + 
                                       sizeof(Properties.LoggerName);

        LoggerInfo->BufferSize = g_ulBufferSize;

        LoggerInfo->MinimumBuffers = g_ulMinBuffers;
        LoggerInfo->MaximumBuffers = g_ulMaxBuffers;

        if (pFPControlTraceW && pFPStartTraceW) 
        {
            Status = pFPControlTraceW(0,
                                      g_szwLogSessionName,
                                      (PEVENT_TRACE_PROPERTIES) LoggerInfo,
                                      EVENT_TRACE_CONTROL_QUERY);
            if (ERROR_SUCCESS == Status)
                hLogger = LoggerInfo->Wnode.HistoricalContext;
            else if (ERROR_WMI_INSTANCE_NOT_FOUND == Status) {
                // The logger is not already started so try to start it now
                Status = pFPStartTraceW(&hLogger,
                                        g_szwLogSessionName,
                                        LoggerInfo);
            }
            if (ERROR_SUCCESS == Status) {
                g_bStartedTracing = TRUE;
                wcscpy(g_szwLogSessionName, &Properties.LoggerName[0]);
                wcscpy(g_szwLogFileName, &Properties.LogFileName[0]);
            }
            else {
                WCHAR szwTemp[MAX_PATH];
                char szTemp[MAX_PATH];

                _snprintf(szTemp, sizeof(szTemp),
                          "ACSRTL:\t%s(%d), Unable to get the Logger Handle, "
                          "return code = %d\n",
                          __FILE__, __LINE__,
                          Status);
                OutputDebugStringA(szTemp);
                _snwprintf(szwTemp, sizeofw(szwTemp), 
                           L"Filename = %s, SessionName = %s\n",
                           g_szwLogFileName,
                           g_szwLogSessionName);
                OutputDebugStringW(szwTemp);
            }
        }
    }

    return hLogger;
}

void UnloadTracingDLL()
{
    // Unload the WMI library
    if (g_hLibInstance) {
        //FreeLibrary(g_hLibInstance);
    }
    // And clear all the pointers
    pFPRegisterTraceGuidsW = NULL;
    pFPGetTraceLoggerHandle = NULL;
    pFPGetTraceEnableLevel = NULL;
    pFPGetTraceEnableFlags = NULL;
    pFPControlTraceW = NULL;
    pFPEnableTrace = NULL;
    pFPStartTraceW = NULL;
    pFPTraceEvent = NULL;

    // And clear the instance handle
    g_hLibInstance = NULL;
}

void LoadTracingDLL()
{
    if (!g_hLibInstance) {

        // Load the WMI dll
        //if (NULL != (g_hLibInstance = LoadLibrary(TEXT("advapi32.dll")))) 
        if(NULL != (g_hLibInstance = GetModuleHandle(TEXT("advapi32.dll"))))
        {
            BOOL bOK = TRUE;

            // Load each of the APIs
            pFPRegisterTraceGuidsW = (PFPREGISTERTRACEGUIDSW)
                       GetProcAddress(g_hLibInstance, "RegisterTraceGuidsW");
            pFPGetTraceLoggerHandle = (PFPGETTRACELOGGERHANDLE)
                       GetProcAddress(g_hLibInstance, "GetTraceLoggerHandle");
            pFPGetTraceEnableLevel = (PFPGETTRACEENABLELEVEL)
                       GetProcAddress(g_hLibInstance, "GetTraceEnableLevel");
            pFPGetTraceEnableFlags = (PFPGETTRACEENABLEFLAGS)
                       GetProcAddress(g_hLibInstance, "GetTraceEnableFlags");
            pFPControlTraceW = (PFPCONTROLTRACEW)
                       GetProcAddress(g_hLibInstance, "ControlTraceW");
            pFPEnableTrace = (PFPENABLETRACE)
                       GetProcAddress(g_hLibInstance, "EnableTrace");
            pFPStartTraceW = (PFPSTARTTRACEW)
                       GetProcAddress(g_hLibInstance, "StartTraceW");
            pFPTraceEvent = (PFPTRACEEVENT)
                       GetProcAddress(g_hLibInstance, "TraceEvent");

            // Verify that all entry point were found, assume that this works
            if (!pFPRegisterTraceGuidsW) {
                DBGWARN((DBG_CONTEXT, 
                         "Couldn't find pFPRegisterTraceGuidsW in wmi.dll\n"));
                bOK = FALSE;
            }
            if (!pFPGetTraceLoggerHandle) {
                DBGWARN((DBG_CONTEXT, 
                         "Couldn't find pFPGetTraceLoggerHandle in wmi.dll\n"));
                bOK = FALSE;
            }
            if (!pFPGetTraceEnableLevel) {
                DBGWARN((DBG_CONTEXT, 
                         "Couldn't find pFPGetTraceEnableLevel in wmi.dll\n"));
                bOK = FALSE;
            }
            if (!pFPGetTraceEnableFlags) {
                DBGWARN((DBG_CONTEXT, 
                         "Couldn't find pFPGetTraceEnableFlags in wmi.dll\n"));
                bOK = FALSE;
            }
            if (!pFPControlTraceW) {
                DBGWARN((DBG_CONTEXT, 
                         "Couldn't find pFPControlTraceW in wmi.dll\n"));
                bOK = FALSE;
            }
            if (!pFPEnableTrace) {
                DBGWARN((DBG_CONTEXT, 
                         "Couldn't find pFPEnableTrace in wmi.dll\n"));
                bOK = FALSE;
            }
            if (!pFPStartTraceW) {
                DBGWARN((DBG_CONTEXT, 
                         "Couldn't find pFPStartTraceW in wmi.dll\n"));
                bOK = FALSE;
            }
            if (!pFPTraceEvent) {
                DBGWARN((DBG_CONTEXT, 
                         "Couldn't find pFPTraceEvent in wmi.dll\n"));
                bOK = FALSE;
            }

            // If this fails then we should free all the APIs
            if (!bOK) {
                UnloadTracingDLL();
            }
        }
    }
}

dllexp VOID
PuUninitiateDebug(
    VOID)
/*++
   This function stops tracing for the current log file but only if we started
   the tracing in the initiate debug

   Arguments:

   Returns:
--*/
{
/*
    BOOL bStartedTracing = FALSE;
    DWORD dwError;

    EnterCriticalSection(&g_csGuidList);

    bStartedTracing = g_bStartedTracing;
    g_bStartedTracing = FALSE;

    LeaveCriticalSection(&g_csGuidList);
    
    if (bStartedTracing) {

        struct {
            EVENT_TRACE_PROPERTIES Header;
            WCHAR LogFileName[MAX_PATH];
            WCHAR LoggerName[MAX_PATH];
        } Properties;
        PEVENT_TRACE_PROPERTIES LoggerInfo;

        LoggerInfo = (PEVENT_TRACE_PROPERTIES) &Properties.Header;
        RtlZeroMemory(&Properties, sizeof(Properties));
        LoggerInfo->Wnode.BufferSize = sizeof(Properties);
        LoggerInfo->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
        LoggerInfo->LogFileNameOffset  = sizeof(EVENT_TRACE_PROPERTIES);
        LoggerInfo->LoggerNameOffset= sizeof(EVENT_TRACE_PROPERTIES) +
                                      sizeof(Properties.LoggerName);

        // Stop tracing to the log file, if possible
        if (pFPControlTraceW) {

            dwError = pFPControlTraceW(g_hLoggerHandle, 
                                       g_szwLogSessionName, 
                                       LoggerInfo,
                                       EVENT_TRACE_CONTROL_STOP);
            if (dwError == ERROR_SUCCESS) {
                wcscpy(g_szwLogFileName, &Properties.LogFileName[0]);
                wcscpy(g_szwLogSessionName, &Properties.LoggerName[0]);
            }
        }
    }
*/
    UnloadTracingDLL();
}

dllexp VOID
PuInitiateDebug(
    VOID
    )
/*++
   This function iterates through the list of modules in the guid list 
   registering all of them and starting up logging if that is the state that
   was stored in the registry

   Arguments:

   Returns:
--*/
{
    BOOL bStartedLogger = FALSE;

    LoadTracingDLL();

    if (!g_bHadARegister) {

        LIST_ENTRY lRegList;
        SGuidList   GEReg;
        LIST_ENTRY *pEntry;
        char szTemp[MAX_PATH];

        // Flag us as having done this so that we can later leave this
        // critical section
        g_bHadARegister = TRUE;

        // Only do the WMI registration if tracing is enabled
        if (g_bTracingEnabled) {

            // Iterate through the guid list and make copies
            memcpy(&GEReg, &g_GuidList, sizeof(SGuidList));

            if (pFPRegisterTraceGuidsW && pFPEnableTrace)
            {
                // Now iterate through our local copy of the list and register 
                // all the guids with WMI
                ASSERT(_SGuidList::TRACESIG == GEReg.dwSig);

                // Initialise the GUID registration structure
                TRACE_GUID_REGISTRATION RegGuids;
                ULONG Status = ERROR_SUCCESS;
                memset(&RegGuids, 0x00, sizeof(RegGuids));
                RegGuids.Guid = (LPGUID) &GEReg.m_dpData.m_guidControl;

                // And then register the guid
                Status = pFPRegisterTraceGuidsW
                                (IISTraceControlCallback,
                                 NULL,
                                 (LPGUID) &GEReg.m_dpData.m_guidControl,
                                 1,
                                 &RegGuids,
                                 NULL,
                                 NULL,
                                 &GEReg.m_dpData.m_hRegistration);

                if (ERROR_SUCCESS != Status) 
                {
                    _snprintf(szTemp, sizeof(szTemp),
                              "%16s:\t%s(%d), RegisterTraceGuids returned "
                              "%d, main ID = %08X\n",
                              GEReg.m_dpData.m_rgchLabel,
                              __FILE__, __LINE__,
                              Status, 
                              GEReg.m_dpData.m_guidControl.Data1);
                    OutputDebugStringA(szTemp);
                }
                else if (GEReg.m_iInitializeFlags & 
                                              DEBUG_FLAG_INITIALIZE) {

                    // Turn off the initialize flag
                    GEReg.m_iInitializeFlags &= ~DEBUG_FLAG_INITIALIZE;

                    // Get the trace file handle if necessary
                    if (!bStartedLogger) {

                        bStartedLogger = TRUE;
                        g_hLoggerHandle = GetTraceFileHandle();
                    }

                    // And enable tracing for the module. If this is 
                    // successful then WMI will call the Trace control
                    // callback
                    Status = pFPEnableTrace(
                                  TRUE, 
                                  GEReg.m_dpData.m_iControlFlag, 
                                  GEReg.m_iDefaultErrorLevel,
                                  (LPGUID) &GEReg.m_dpData.m_guidControl,
                                  g_hLoggerHandle);
                    if ((ERROR_SUCCESS != Status) && 
                        (ERROR_WMI_ALREADY_ENABLED != Status)) 
                    {
                        _snprintf(szTemp, sizeof(szTemp), 
                                  "%16s:\t%s(%d), Unable to EnableTrace, "
                                  "return code = %d\n", 
                                  GEReg.m_dpData.m_rgchLabel, 
                                  __FILE__, __LINE__, 
                                  Status);
                        OutputDebugStringA(szTemp);
                    }
                }

                // Now re-enter the critical section so that we can save the 
                // results back to our global data structure
                // Save the only two things that could have changed
                g_GuidList.m_iInitializeFlags = GEReg.m_iInitializeFlags;
                g_GuidList.m_dpData.m_hRegistration = GEReg.m_dpData.m_hRegistration;
            }
        }
    }
} // PuInitiateDebug()


bool
PuLoadRegistryInfo(
    GUID* pGuid
    )
/*++
   This function loads all the registry settings for the project and adds all
   the known modules to the Guid list
   NOTE: It is the responsibility of the caller to enter the guid list
         critical section before calling this function

   Arguments:

   Returns:
       bool indicating whether guid was found

--*/
{
    ASSERT(pGuid != NULL);

    HKEY hk = 0;
    bool bGuidFound = false;

    // Get the global settings which need only be read once, and only for 
    // the master
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_TRACE_ACS, 0, KEY_READ, &hk)) {

        DWORD dwIndex = 0;
        ULONG ulTemp = 0;
        LONG iRegRes = 0;
        WCHAR szwTemp[MAX_PATH];
        char szModuleName[MAX_PATH];
        DWORD dwReadSize = sizeof(ulTemp);
        DWORD dwSizeOfModuleName = sizeof(szModuleName);

        // 1. Get the enabled flag, if this is false we do not do any WMI 
        // processing, by default this is FALSE
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_ENABLED, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_bTracingEnabled = ulTemp;

        // 2. Get the AlwaysODS flag, if this is true we will always write 
        // trace out with OutputDebugString, effectively CHK build  
        // compatability mode
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_ODS, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_ODSEnabled = ulTemp;

        // 3. Determine if the active flag is set, if it was then it means 
        // that something was active at shut down, so for each module load
        // read the appropriate registry entries at start up
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_ACTIVE, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_bTracingActive = ulTemp;

        // 4. Get the trace configuration information, log file name, 
        // logging session name, min/max number of buffers, buffer size & mode
        dwReadSize = sizeof(szwTemp);
        if (ERROR_SUCCESS == (iRegRes = RegQueryValueEx(hk, 
                                                        REG_TRACE_IIS_LOG_FILE_NAME, 
                                                        NULL, 
                                                        NULL, 
                                                       (BYTE *) &szwTemp, 
                                                       &dwReadSize)))
            wcscpy(g_szwLogFileName, szwTemp);
        else if (ERROR_MORE_DATA == iRegRes) {
            DBGERROR((DBG_CONTEXT, 
                     "Unable to load tracing logfile name, name too long.\n"));
        }
        else if (ERROR_FILE_NOT_FOUND != iRegRes) {
            DBGWARN((DBG_CONTEXT, 
                    "Unable to load tracing logfile name, Windows error %d\n",
                    iRegRes));
        }
        dwReadSize = sizeof(szwTemp);
        if (ERROR_SUCCESS == (iRegRes = RegQueryValueEx(hk, 
                                                       REG_TRACE_IIS_LOG_SESSION_NAME, 
                                                       NULL, 
                                                       NULL, 
                                                       (BYTE *) &szwTemp, 
                                                       &dwReadSize)))
            wcscpy(g_szwLogSessionName, szwTemp);
        else if (ERROR_MORE_DATA == iRegRes) {
            DBGERROR((DBG_CONTEXT, 
                     "Unable to load tracing log session name, name too long.\n"));
        }
        else if (ERROR_FILE_NOT_FOUND != iRegRes) {
            DBGWARN((DBG_CONTEXT, 
                    "Unable to load tracing log session name, Windows error %d\n",
                    iRegRes));
        }
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_BUFFER_SIZE, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_ulBufferSize = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_MIN_BUFFERS, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_ulMinBuffers = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_MAX_BUFFERS, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_ulMaxBuffers = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_MAX_FILESIZE, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_ulMaxFileSize = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_REAL_TIME, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_bRealTimeMode = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_IN_MEMORY, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_bInMemoryMode = ulTemp;
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LOG_USER_MODE, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_bUserMode = ulTemp;

        // 5. Load the ControlFlags and Level. Both default to 0, off
        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_CONTROL, 
                                             NULL, NULL, 
                                             (BYTE *) &ulTemp, &dwReadSize))
            g_dwDefaultControlFlag = ulTemp;

        dwReadSize = sizeof(ulTemp);
        if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_IIS_LEVEL, 
                                             NULL, NULL,
                                             (BYTE *) &ulTemp, 
                                             &dwReadSize)) {
            g_dwDefaultErrorLevel = ulTemp;
        }

        // Enumerate all the modules listed in the registry for IIS
        while (ERROR_NO_MORE_ITEMS != RegEnumKeyExA(hk, dwIndex, 
                                                    szModuleName, 
                                                    &dwSizeOfModuleName,
                                                    NULL, NULL, NULL, NULL))
        {
            // Then load the setting for this guid from the registry and
            // set up any defaults that are needed
            bGuidFound = LoadGuidFromRegistry(szModuleName, pGuid);
            if(bGuidFound)
            {
                break;
            }

            dwSizeOfModuleName = sizeof(szModuleName);
            ++dwIndex;
        }

        RegCloseKey(hk);
    }
    return bGuidFound;
} // PuLoadRegistryInfo()


LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
    IN const char * pszPrintLabel,
    IN GUID *       ControlGuid,
    IN int *        ErrorFlags,
    IN int          DefaultControlFlags
    )
/*++
   This function looks for and if necessary creates a new DEBUG_PRINTS object 
   for the required module

   Arguments:
      *pszPrintLabel        pointer to null-terminated string containing the 
                            label for program's debugging output
      *ControlGuid          the unique GUID used to identify this module
      *ErrorFlags           pointer to the error flags variable used by the 
                            module to determine whether or not to log something
      DefaultControlFlags   default flags used by IF_DEBUG

   Returns:
       pointer to a new DEBUG_PRINTS object on success.
       Returns NULL on failure.
--*/
{
    DEBUG_PRINTS *pGEData        = NULL;
    SGuidList    *pGE            = NULL;
    static bool  bCreatedAlready = false;
    bool         bGuidFoundInReg = false;

    ASSERT(NULL != ErrorFlags);
    ASSERT(0    != pszPrintLabel[0]);
    ASSERT(true != bCreatedAlready);

    // See if we have done the registry initialization stuff, if we have then
    // we should have the guid list. The initialization need only be done once
    if (!g_bHaveDoneInit) {
        g_bHaveDoneInit = TRUE;
        bGuidFoundInReg = PuLoadRegistryInfo(ControlGuid);
    }

    pGE = &g_GuidList;
    
    //
    // Use default settings
    //
    if(!bGuidFoundInReg) {
        pGEData = &pGE->m_dpData;

        // Set the SGuidList member variables
        pGE->dwSig = _SGuidList::TRACESIG;
        pGE->m_iDefaultErrorLevel = g_dwDefaultErrorLevel;

        // Set the SGuidList.m_dpData member variables
        strncpy(pGEData->m_rgchLabel,
                pszPrintLabel, MAX_LABEL_LENGTH - 1);
        pGEData->m_rgchLabel[MAX_LABEL_LENGTH-1] = '\0';
        pGEData->m_guidControl = *ControlGuid;
        pGEData->m_bBreakOnAssert = TRUE;   // Default - Break if Assert Fails
        pGEData->m_iControlFlag = g_dwDefaultControlFlag;
        pGEData->m_fAlwaysODS = g_ODSEnabled;

        // And now update the registry with the information about the guid
        // so that we don't have to do this again. While we have already
        // done a ASSERT above we should still verify that the module
        // has a name before calling this in case of new components
        if (pGEData->m_rgchLabel[0])
            AddToRegistry(pGE);
    }
    //
    // Use settings from registry
    //
    else
        pGEData = &pGE->m_dpData;

    // And then if we have the member initialize its data members with the
    // parameters supplied by the caller
    if (NULL != pGEData) {

#if DBG
        if (strncmp(pGEData->m_rgchLabel, 
                    pszPrintLabel, 
                    MAX_LABEL_LENGTH - 1) != 0) 
        {
            WCHAR szwGUID[50];
            char temp[1000];

            StringFromGUID2((REFGUID) ControlGuid, szwGUID, sizeofw(szwGUID));
            wsprintfA(temp, 
                      "A request was made for the module whose registry entry "
                      "is " REG_TRACE_ACS_A "\\%s\n",
                      pszPrintLabel);
            OutputDebugStringA(temp);
            OutputDebugStringA("The GUID supplied with the request was ");
            OutputDebugStringW(szwGUID);
            wsprintfA(temp, 
                      "\nHowever this GUID is already in use by module %s\n",
                      pGEData->m_rgchLabel);
            OutputDebugStringA(temp);

            ASSERT(FALSE);
        }
#endif

        // Check to see if we had a deferred start waiting, this would happen
        // if we received a WMI initialize during the main phase but we had not 
        // yet loaded this module
        if (pGE->m_iInitializeFlags & DEBUG_FLAG_DEFERRED_START) {

            pGE->m_iInitializeFlags &= ~(DEBUG_FLAG_DEFERRED_START | DEBUG_FLAG_INITIALIZE);
        }
        // Otherwise load the default control flags, but only if we are not 
        // waiting for initialization. When we are waiting, the registry 
        // entries we have already loaded are to take precedence
        else if (!(pGE->m_iInitializeFlags & DEBUG_FLAG_INITIALIZE)) {

            // Set the SGuidList.m_dpData member variables
            // Note: That the global setting will override the default if it
            // is set
            if (g_dwDefaultControlFlag) {
                pGEData->m_iControlFlag = g_dwDefaultControlFlag;
            }
            else {
                pGEData->m_iControlFlag = DefaultControlFlags;
            }
        }

        // Save the pointer to the error flags and set the level
        pGEData->m_piErrorFlags = ErrorFlags;
        SetLevel(pGE->m_iDefaultErrorLevel, 
                 pGEData->m_fAlwaysODS,
                 pGEData->m_piErrorFlags);
    }

    if (NULL == pGEData) {
        char szTemp[MAX_PATH];

        _snprintf(szTemp, sizeof(szTemp), 
                  "%16s:\t%s(%d), Unable to find in or add a Guid to the trace list, return code = %d\n", 
                  pszPrintLabel, __FILE__, __LINE__, 
                  GetLastError());
        OutputDebugStringA(szTemp);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        bCreatedAlready = true;
    }

    return pGEData;

} // PuCreateDebugPrintsObject()


VOID
PuDeleteDebugPrintsObject(
    IN OUT LPDEBUG_PRINTS pDebugPrints
    )
/*++
    This function cleans up the pDebugPrints object and does an frees of
    allocated memory that may be required.

    Arguments:
       pDebugPrints         pointer to the DEBUG_PRINTS object.

    Returns:

--*/
{
    if (NULL != pDebugPrints) {

        // Since we no longer delete anything or bother to shut it down all we
        // need to do here is clear the pointer to the error flag
        pDebugPrints->m_piErrorFlags = NULL;
    }

} // PuDeleteDebugPrintsObject()

VOID
PuDbgPrintMain(
   IN OUT LPDEBUG_PRINTS pDebugPrints,
   IN const BOOL         bUnicodeRequest,
   IN const char *       pszFilePath,
   IN int                nLineNum,
   IN const char *       pszFormat,
   IN va_list            argptr
)
/*++
    Main function that examines the incoming message and works out what to do 
    with the header and the message.

    Arguments:
       pDebugPrints         pointer to the DEBUG_PRINTS object.
       pszFilePath          null terminated string which is the file name
       nLineNum             the number of the line where the tracing is coming from
       pszFormat & ...      the format and arguments to be written out

    Returns:

--*/
{
    LPCSTR pszFileName = strrchr( pszFilePath, '\\');
    WCHAR szwOutput[SHORT_PRINTF_OUTPUT + 2];
    WCHAR *pszwOutput = szwOutput;
    WCHAR *pszwAlloc = NULL;
    char *pszOutput = (char *) szwOutput;
    char rgchLabel[MAX_LABEL_LENGTH + 1] = "";
    TRACEHANDLE hLogger = 0;
    TRACE_INFO tiTraceInfo;
    DWORD dwSequenceNumber;
    DWORD dwOutputSize = 0;
    BOOL bUseODS = FALSE;
    int cchOutput = 0;
    int iRetry;

    // Init Wmi if we have not yet
    g_InitWmi.InitIfNecessary();

    // Save the current error state so that we don't disrupt it
    DWORD dwErr = GetLastError();

    // Skip the '\' and retain only the file name in pszFileName
    if (pszFileName)
        ++pszFileName;
    else
        pszFileName = pszFilePath;

    // Determine if we are to do an OutputDebugString
    if (pDebugPrints &&
        pDebugPrints->m_piErrorFlags &&
        (*pDebugPrints->m_piErrorFlags & DEBUG_FLAG_ODS))
    {
        bUseODS = TRUE;
    }

    if (NULL != pDebugPrints) {
        // Save local copies of the data needed for the ODS case
        if (bUseODS) {
            strncpy(rgchLabel, pDebugPrints->m_rgchLabel, sizeof(rgchLabel));
        }

        // Save local copies of the data needed for the WMI Tracing case
        if (pDebugPrints->m_hLogger) {

            dwSequenceNumber = ++g_dwSequenceNumber;
            hLogger = pDebugPrints->m_hLogger;

            // Initialize our traceinfo structure
            memset(&tiTraceInfo, 0x00, sizeof(tiTraceInfo));
            tiTraceInfo.TraceHeader.Guid = pDebugPrints->m_guidControl;
        }
    }

    if (hLogger && pFPTraceEvent) {

        int pid = GetCurrentProcessId();

        // We will attempt the formatting twice, once with a small default 
        // buffer on the stack, and a second time with a large one from the
        // heap
        for (iRetry = 0; iRetry < 2; iRetry++)
        {
            if (!iRetry) {
                dwOutputSize = SHORT_PRINTF_OUTPUT;
            }
            else {
                dwOutputSize = MAX_PRINTF_OUTPUT;
                if (NULL == (pszwAlloc = (WCHAR *) malloc(sizeof(WCHAR) * dwOutputSize+2))) 
                {
                    OutputDebugStringA("Couldn't allocate WCHAR output buffer\n");
                    break;
                }
                pszwOutput = pszwAlloc;
                pszOutput = (char *) pszwAlloc;
            }
            // Format the incoming message using vsnprintf() so that we don't exceed
            // the buffer length
            if (bUnicodeRequest) {
                cchOutput = _vsnwprintf(pszwOutput, dwOutputSize, (WCHAR *) pszFormat, argptr);
                // If the string is too long, we get back a length of -1, so just use the
                // partial data that fits in the string
                if ((-1 == cchOutput) && !iRetry) {
                    continue;
                }
                else {
                    // Terminate the string properly since _vsnprintf() does not terminate 
                    // properly on failure.
                    cchOutput = dwOutputSize - 1;
                    pszwOutput[cchOutput] = '\0';
                }
                ++cchOutput;
                cchOutput *= sizeof(WCHAR);
                break;
            }
            else {
                cchOutput = _vsnprintf(pszOutput, dwOutputSize, pszFormat, argptr);
                // If the string is too long, we get back a length of -1, so just use the
                // partial data that fits in the string
                if ((-1 == cchOutput) && !iRetry) {
                    continue;
                }
                else {
                    // Terminate the string properly since _vsnprintf() does not terminate 
                    // properly on failure.
                    cchOutput = dwOutputSize - 1;
                    pszOutput[cchOutput] = '\0';
                }
                ++cchOutput;
                break;
            }
        }

        // Fill out the Tracing structure
        tiTraceInfo.TraceHeader.Size = sizeof(TRACE_INFO);
        if (bUnicodeRequest)
            tiTraceInfo.TraceHeader.Class.Type = EVENT_TRACE_TYPE_UNICODE;
        else
            tiTraceInfo.TraceHeader.Class.Type = EVENT_TRACE_TYPE_ASCII;
        tiTraceInfo.TraceHeader.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
        tiTraceInfo.TraceHeader.ThreadId = GetCurrentThreadId();
        tiTraceInfo.MofFields[0].DataPtr = (ULONGLONG) &dwSequenceNumber;
        tiTraceInfo.MofFields[0].Length = sizeof(int);
        tiTraceInfo.MofFields[1].DataPtr = (ULONGLONG) &pid;
        tiTraceInfo.MofFields[1].Length = sizeof(int);
        tiTraceInfo.MofFields[2].DataPtr = (ULONGLONG) &nLineNum;
        tiTraceInfo.MofFields[2].Length = sizeof(int);
        tiTraceInfo.MofFields[3].DataPtr = (ULONGLONG) pszFileName;
        // WARNING: Possible data loss on IA64
        tiTraceInfo.MofFields[3].Length = (ULONG)strlen(pszFileName) + 1;
        if (pszwAlloc) {
            tiTraceInfo.MofFields[4].DataPtr = (ULONGLONG) pszwAlloc;
        } 
        else {
            tiTraceInfo.MofFields[4].DataPtr = (ULONGLONG) szwOutput;
        }
        tiTraceInfo.MofFields[4].Length = cchOutput;
        // Send the trace information to the trace class
        pFPTraceEvent(hLogger, (PEVENT_TRACE_HEADER) &tiTraceInfo);
    }

    if (bUseODS) {
        LONG cchBuffer; // Num of characters in output buffer

        // Create the prologue
        if (bUnicodeRequest) {
            WCHAR wszLabel[MAX_LABEL_LENGTH + 1];
            WCHAR wszFileName[MAX_PATH + 1];

            if (MultiByteToWideChar(CP_ACP, 0, rgchLabel, -1, wszLabel, sizeofw(wszLabel)) &&
                MultiByteToWideChar(CP_ACP, 0, pszFileName, -1, wszFileName, sizeofw(wszFileName))) 
            {
                for (iRetry = pszwAlloc ? 1 : 0; iRetry < 2; iRetry++)
                {
                    if (!iRetry) {
                        dwOutputSize = SHORT_PRINTF_OUTPUT;
                    }
                    else if (!pszwAlloc) {
                        dwOutputSize = MAX_PRINTF_OUTPUT;
                        if (NULL == (pszwAlloc = (WCHAR *) malloc(sizeof(WCHAR) * dwOutputSize+2))) 
                        {
                            OutputDebugStringA("Couldn't allocate WCHAR output buffer\n");
                            break;
                        }
                        pszwOutput = pszwAlloc;
                        pszOutput = (char *) pszwAlloc;
                    }
                    cchOutput = _snwprintf(pszwOutput,
                                           dwOutputSize,
                                           L"%lu, %s, %s, (%d), ", 
                                           GetCurrentThreadId(),
                                           wszLabel,
                                           wszFileName, 
                                           nLineNum);
                    cchBuffer = (cchOutput == -1) ? (LONG)dwOutputSize : cchOutput;
                    if(cchOutput != -1) {
                        cchOutput = _vsnwprintf(pszwOutput + cchOutput,
                                               dwOutputSize - cchOutput - 1,
                                               (WCHAR *) pszFormat,
                                               argptr);
                        cchBuffer += (cchOutput == -1) ? (dwOutputSize - cchOutput - 1) : cchOutput;
                    }
                    // If the string is too long, we get back -1. So we get the string 
                    // length for partial data.
                    if ((-1 == cchOutput) && !iRetry) {
                        continue;
                    }
                    else {
                        // Terminate the string properly, since _vsnprintf() does not 
                        // terminate properly on failure.
                        cchOutput = dwOutputSize - 1;
                        pszwOutput[cchOutput] = '\0';
                        if(cchBuffer == (LONG)dwOutputSize) {
                            cchBuffer--;
                        }
                    }
                    // Added by Mohit because catalog code depends on this
                    // Probably should remove at some point
                    if(pszwOutput[cchBuffer-1] != L'\n') {
                        ASSERT(pszwOutput[cchBuffer] == L'\0');
                        ASSERT(cchBuffer+1 < (LONG)dwOutputSize+2); // buffer size is dwOutputSize+2
                        pszwOutput[cchBuffer]   = L'\n';
                        pszwOutput[cchBuffer+1] = L'\0';
                    }
                    OutputDebugStringW(pszwOutput);
                    break;
                }
            }
        }
        else {
            for (iRetry = pszwAlloc ? 1 : 0; iRetry < 2; iRetry++)
            {
                int cchPrologue;

                if (!iRetry) {
                    dwOutputSize = SHORT_PRINTF_OUTPUT;
                }
                else if (!pszwAlloc) {
                    dwOutputSize = MAX_PRINTF_OUTPUT;
                    if (NULL == (pszwAlloc = (WCHAR *) malloc(sizeof(WCHAR) * dwOutputSize+2))) 
                    {
                        OutputDebugStringA("Couldn't allocate WCHAR output buffer\n");
                        break;
                    }
                    pszwOutput = pszwAlloc;
                    pszOutput = (char *) pszwAlloc;
                }
                // Create the prologue
                cchPrologue = _snprintf(pszOutput, 
                                        dwOutputSize,
                                        "%lu, %s, %s, (%d), ",
                                        GetCurrentThreadId(),
                                        rgchLabel,
                                        pszFileName, 
                                        nLineNum);
                cchBuffer = (cchPrologue == -1) ? dwOutputSize : cchPrologue;
                if(cchPrologue != -1)
                {
                    // Format the incoming message using vsnprintf() so that the overflows are
                    //  captured
                    cchOutput = _vsnprintf(pszOutput + cchPrologue,
                                           dwOutputSize - cchPrologue - 1,
                                           pszFormat, 
                                           argptr);
                    cchBuffer += (cchOutput == -1) ? dwOutputSize - cchPrologue - 1 : cchOutput;
                }
                // If the string is too long, we get back -1. So we get the string
                // length for partial data.
                if ((-1 == cchPrologue || -1 == cchOutput) && !iRetry) {
                    continue;
                }
                else {
                    // Terminate the string properly, since _vsnprintf() does not
                    // terminate properly on failure.
                    cchOutput = dwOutputSize - 1;
                    pszOutput[cchOutput] = '\0';
                    if(cchBuffer == (LONG)dwOutputSize) {
                        cchBuffer--;
                    }
                }
                // Added by Mohit because catalog code depends on this
                // Probably should remove at some point
                if(pszOutput[cchBuffer-1] != '\n') {
                    ASSERT(pszOutput[cchBuffer] == '\0');
                    ASSERT(cchBuffer+1 < (LONG)dwOutputSize+2); // buffer size is dwOutputSize+2
                    pszOutput[cchBuffer]   = '\n';
                    pszOutput[cchBuffer+1] = '\0';
                }
                OutputDebugStringA(pszOutput);
                break;
            }
        }
    }

    if (pszwAlloc) {
        free(pszwAlloc);
        pszwAlloc = NULL;
    }

    // Restore the error state
    SetLastError( dwErr );
} // PuDbgPrintMain()

VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS pDebugPrints,
   IN const char *       pszFilePath,
   IN int                nLineNum,
   IN const char *       pszFormat,
   ...)
{
    va_list argsList;

    __try 
    {
        va_start(argsList, pszFormat);
        PuDbgPrintMain(pDebugPrints, FALSE, pszFilePath, nLineNum, pszFormat, argsList);
        va_end(argsList);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
}

dllexp VOID
PuDbgPrintW(
   IN OUT LPDEBUG_PRINTS pDebugPrints,
   IN const char *       pszFilePath,
   IN int                nLineNum,
   IN const WCHAR *      pszFormat,
   ...)
{
    va_list argsList;

    __try
    {
        va_start(argsList, pszFormat);
        PuDbgPrintMain(pDebugPrints, TRUE, pszFilePath, nLineNum, (char *)pszFormat, argsList);
        va_end(argsList);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
}

dllexp VOID
VPuDbgPrintW(
   IN OUT LPDEBUG_PRINTS pDebugPrints,
   IN const char *       pszFilePath,
   IN int                nLineNum,
   IN const WCHAR *      pszFormat,
   IN va_list            argptr
)
{
    PuDbgPrintMain(pDebugPrints, TRUE, pszFilePath, nLineNum, (char *)pszFormat, argptr);
}

VOID
PuDbgDumpMain(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN BOOL                 bUnicodeRequest,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   )
/*++
    Function that write a dump of a buffer out to the trace file.

    Arguments:
       pDebugPrints         pointer to the DEBUG_PRINTS object.
       pszFilePath          null terminated string which is the file name
       nLineNum             the number of the line where the tracing is coming from
       pszDump              the dump to be written out

    Returns:

--*/
{
    LPCSTR pszFileName = strrchr( pszFilePath, '\\');
    TRACEHANDLE hLogger = 0;
    TRACE_INFO tiTraceInfo;
    DWORD dwSequenceNumber;
    BOOL bUseODS = FALSE;
    SIZE_T cbDump = 0;

    // Save the current error state so that we don't disrupt it
    DWORD dwErr = GetLastError();

    // Skip the complete path name and retain only the file name in pszFileName
    if ( pszFileName)
        ++pszFileName;
    else
        pszFileName = pszFilePath;

    // Determine if we are to do an OutputDebugString
    if (pDebugPrints &&
        pDebugPrints->m_piErrorFlags &&
        (*pDebugPrints->m_piErrorFlags & DEBUG_FLAG_ODS))
    {
        bUseODS = TRUE;
    }

    // Save local copies of the data needed for the WMI Tracing case
    if ((NULL != pDebugPrints) && pDebugPrints->m_hLogger) {

        dwSequenceNumber = ++g_dwSequenceNumber;
        hLogger = pDebugPrints->m_hLogger;

        if (bUnicodeRequest)
            cbDump = (wcslen((WCHAR *) pszDump) + 1) * sizeof(WCHAR);
        else
            cbDump = strlen( pszDump) + 1;

        // Initialize our traceinfo structure
        memset(&tiTraceInfo, 0x00, sizeof(tiTraceInfo));
        tiTraceInfo.TraceHeader.Guid = pDebugPrints->m_guidControl;
    }

    // Send the outputs to respective files.
    if (hLogger && pFPTraceEvent) {
        int pid = GetCurrentProcessId();
        // Fill out the Tracing structure
        tiTraceInfo.TraceHeader.Size = sizeof(TRACE_INFO);
        tiTraceInfo.TraceHeader.Class.Type = EVENT_TRACE_TYPE_INFO;
        tiTraceInfo.TraceHeader.Flags = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
        tiTraceInfo.TraceHeader.ThreadId = GetCurrentThreadId();
        tiTraceInfo.MofFields[0].DataPtr = (ULONGLONG) &dwSequenceNumber;
        tiTraceInfo.MofFields[0].Length = sizeof(int);
        tiTraceInfo.MofFields[1].DataPtr = (ULONGLONG) &pid;
        tiTraceInfo.MofFields[1].Length = sizeof(int);
        tiTraceInfo.MofFields[2].DataPtr = (ULONGLONG) &nLineNum;
        tiTraceInfo.MofFields[2].Length = sizeof(int);
        tiTraceInfo.MofFields[3].DataPtr = (ULONGLONG) pszFileName;
        // WARNING: Possible data loss on IA64
        tiTraceInfo.MofFields[3].Length = (ULONG)strlen(pszFileName) + 1;
        tiTraceInfo.MofFields[4].DataPtr = (ULONGLONG) pszDump;
        // WARNING: Possible data loss on IA64
        tiTraceInfo.MofFields[4].Length = (ULONG)cbDump;
        // Send the trace information to the trace class
        pFPTraceEvent(hLogger, (PEVENT_TRACE_HEADER) &tiTraceInfo);
    }

    if (bUseODS) {
        if (bUnicodeRequest)
            OutputDebugStringW((WCHAR *) pszDump);
        else
            OutputDebugStringA(pszDump);
    }

    // Restore the error state
    SetLastError( dwErr );
} // PuDbgDumpMain()

VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   )
{
    PuDbgDumpMain(pDebugPrints, FALSE, pszFilePath, nLineNum, pszDump);
}

dllexp VOID
PuDbgDumpW(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const WCHAR *        pszDump
   )
{
    PuDbgDumpMain(pDebugPrints, TRUE, pszFilePath, nLineNum, (char *) pszDump);
}

//
// N.B. For PuDbgCaptureContext() to work properly, the calling function
// *must* be __cdecl, and must have a "normal" stack frame. So, we decorate
// PuDbgAssertFailed() with the __cdecl modifier and disable the frame pointer
// omission (FPO) optimization.
//

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

VOID
__cdecl
PuDbgAssertFailed(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum,
    IN const char *               pszExpression)
/*++
    This function calls assertion failure and records assertion failure
     in log file.

--*/
{
    CONTEXT context;

    PuDbgCaptureContext( &context );

    PuDbgPrint(pDebugPrints, pszFilePath, nLineNum,
               " Assertion (%s) Failed\n"
               " use !cxr %p to dump context\n",
               pszExpression,
               &context);

    if (( NULL == pDebugPrints) || (TRUE == pDebugPrints->m_bBreakOnAssert))
    {
        DebugBreak();
    }
} // PuDbgAssertFailed()

#pragma optimize( "", on )      // restore frame pointer omission (FPO)

//
// Dummy PuDbgCaptureContext(), only used if we're ever built for
// a target processor other than x86 or alpha.
//

//#if !defined(_X86_) && !defined(_ALPHA_)
VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    )
{
    //
    // This space intentionally left blank.
    //

}   // PuDbgCaptureContext
//#endif

/****************************** End of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\catalogpropertywriter.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    CatalogPropertyWriter.cpp

$Header: $

Abstract:


--**************************************************************************/

#include "catalog.h"
#include "catmeta.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "CatalogPropertyWriter.h"
#include "CatalogCollectionWriter.h"
#include "WriterGlobals.h"
#include "mddefw.h"
#include "iiscnfg.h"


#define cMaxFlag 32	// TODO: Check if max flag is ok.

typedef tTAGMETARow* LP_tTAGMETARow;

//
// TODO: Delete after getting from schema
//

LPWSTR g_wszDWORD			= L"DWORD";
LPWSTR g_wszBINARY			= L"BINARY";
LPWSTR g_wszSTRING			= L"STRING";
LPWSTR g_wszGUID			= L"GUID";
LPWSTR g_wszDBTIMESTAMP		= L"DBTIMESTAMP";

HRESULT GetTypeFromSynID(DWORD		i_dwSynID,
						 LPWSTR*	o_pwszType)
{
	if((i_dwSynID < 1) || (i_dwSynID > 12))
	{
		return E_INVALIDARG;
	}
	else
	{
		*o_pwszType = (LPWSTR)g_aSynIDToWszType[i_dwSynID];
	}

	return S_OK;
}

HRESULT GetType(DWORD   i_dwType,
				LPWSTR* o_pwszType)
{
	switch(i_dwType)
	{
	case 19:
		*o_pwszType = g_wszDWORD;
		break;
	case 128:
		*o_pwszType = g_wszBINARY;
		break;
	case 130:
		*o_pwszType = g_wszSTRING;
		break;
	case 72:
		*o_pwszType = g_wszGUID;
		break;
	case 135:
		*o_pwszType = g_wszDBTIMESTAMP;
		break;
	default:
		return E_INVALIDARG;
	}

	return S_OK;
}


CCatalogPropertyWriter::CCatalogPropertyWriter():
m_pCWriter(NULL),
m_pCollection(NULL),
m_aFlag(NULL),
m_cFlag(0),
m_iFlag(0)
{
	memset(&m_Property, 0, sizeof(tCOLUMNMETARow));

} // CCatalogPropertyWriter::CCatalogPropertyWriter


CCatalogPropertyWriter::~CCatalogPropertyWriter()
{
	if(NULL != m_aFlag)
	{
		delete [] m_aFlag;
		m_aFlag = NULL;
	}

} // CCatalogPropertyWriter::CCatalogPropertyWriter


void CCatalogPropertyWriter::Initialize(tCOLUMNMETARow*	i_pProperty,
                                        ULONG*          i_aPropertySize,
										tTABLEMETARow*	i_pCollection,
										CWriter*		i_pcWriter)
{
	m_pCWriter    = i_pcWriter;
	m_pCollection = i_pCollection;

	memcpy(&m_Property, i_pProperty, sizeof(tCOLUMNMETARow));
    memcpy(&m_PropertySize, i_aPropertySize, sizeof(m_PropertySize));

} // CCatalogPropertyWriter::Initialize


HRESULT CCatalogPropertyWriter::AddFlag(tTAGMETARow*		i_pFlag)
{
	HRESULT hr = S_OK;

	if(m_iFlag == m_cFlag)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	memcpy(&(m_aFlag[m_iFlag++]), i_pFlag, sizeof(tTAGMETARow));

	return hr;

} // CCatalogPropertyWriter::AddFlag


HRESULT CCatalogPropertyWriter::ReAllocate()
{
	tTAGMETARow* pSav = m_aFlag;

	m_aFlag = new tTAGMETARow[m_cFlag + cMaxFlag];
	if(NULL == m_aFlag)
	{
		return E_OUTOFMEMORY;
	}
	memset(m_aFlag, 0, (sizeof(tTAGMETARow))*(m_cFlag + cMaxFlag));

	if(NULL != pSav)
	{
		memcpy(m_aFlag, pSav, (sizeof(tTAGMETARow))*(m_cFlag));
		delete [] pSav;
	}

	m_cFlag = m_cFlag + cMaxFlag;

	return S_OK;

} // CCatalogPropertyWriter::ReAllocate


HRESULT CCatalogPropertyWriter::WriteProperty()
{
	HRESULT hr = S_OK;

	if(0 == _wcsicmp(m_pCollection->pInternalName, wszTABLE_IIsConfigObject))
	{
		hr = WritePropertyLong();
	}
	else 
	{
		hr = WritePropertyShort();
	}

	return hr;

} // CCatalogPropertyWriter::WriteProperty


HRESULT CCatalogPropertyWriter::WritePropertyShort()
{
	HRESULT		hr               = S_OK;
	WCHAR*		wszTemp          = g_wszTemp;
	WCHAR*		wszMetaFlagsEx   = NULL;
	WCHAR*      wszEnd           = NULL;

	SIZE_T      cchPropertyName  = wcslen(m_Property.pInternalName);
	SIZE_T      cchMetaFlagsExEq = 0;
	SIZE_T      cchMetaFlagsEx   = 0;
	SIZE_T      cchOr            = 0;
	SIZE_T      cch              = 0;
	DWORD       dwMetaFlagsEx    = fCOLUMNMETA_MANDATORY;
	DWORD	    iColMetaFlagsEx  = iCOLUMNMETA_SchemaGeneratorFlags;
	
	if(fCOLUMNMETA_MANDATORY & (*(m_Property.pSchemaGeneratorFlags)))
	{

		cchMetaFlagsExEq = g_cchMetaFlagsExEq;
		cchOr = g_cchOr;

		hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlagsEx,
															  &wszMetaFlagsEx,
															  wszTABLE_COLUMNMETA,
															  iColMetaFlagsEx);

		if(FAILED(hr))
		{
			goto exit;
		}
		cchMetaFlagsEx = wcslen(wszMetaFlagsEx);
	}

	cch = g_cchBeginPropertyShort +
	      cchPropertyName +
		  cchMetaFlagsExEq + 
		  cchOr + 
		  cchMetaFlagsEx +
		  g_cchEndPropertyShort;
	                  
	if((cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
	}

	wszEnd = wszTemp;
	cch = 0;
	memcpy(wszEnd, g_wszBeginPropertyShort, (g_cchBeginPropertyShort)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginPropertyShort;
	cch += g_cchBeginPropertyShort;
	memcpy(wszEnd, m_Property.pInternalName, (cchPropertyName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchPropertyName;
	cch += cchPropertyName;
	if(fCOLUMNMETA_MANDATORY & (*(m_Property.pSchemaGeneratorFlags)))
	{
		memcpy(wszEnd, g_wszMetaFlagsExEq, (g_cchMetaFlagsExEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMetaFlagsExEq;
		cch += g_cchMetaFlagsExEq;

		memcpy(wszEnd, g_wszOr, (g_cchOr)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchOr;
		cch += g_cchOr;

		memcpy(wszEnd, wszMetaFlagsEx, (cchMetaFlagsEx)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlagsEx;
		cch += cchMetaFlagsEx;

	}
	memcpy(wszEnd, g_wszEndPropertyShort, (g_cchEndPropertyShort)*sizeof(WCHAR));
	cch += g_cchEndPropertyShort;

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

exit:

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	if(NULL != wszMetaFlagsEx)
	{
		delete [] wszMetaFlagsEx;
		wszMetaFlagsEx = NULL;
	}

	return hr;

} // CCatalogPropertyWriter::WritePropertyShort


HRESULT CCatalogPropertyWriter::WritePropertyLong()
{
	HRESULT hr = S_OK;

	hr = BeginWritePropertyLong();

	if(FAILED(hr))
	{
		return hr;
	}

	if(NULL != m_aFlag)
	{	
		for(ULONG i=0; i<m_iFlag; i++)
		{
			hr = WriteFlag(i);

			if(FAILED(hr))
			{
				return hr;
			}
		}
	}

	hr = EndWritePropertyLong();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CCatalogPropertyWriter::WritePropertyLong


HRESULT CCatalogPropertyWriter::BeginWritePropertyLong()
{
	HRESULT		hr                       = S_OK;
	WCHAR*		wszTemp                  = g_wszTemp;
	WCHAR*      wszEnd                   = NULL;
	SIZE_T      cchPropertyName          = 0;
	WCHAR       wszID[25];
	SIZE_T      cchID                    = 0;
	WCHAR*      wszType                  = NULL;
	SIZE_T      cchType                  = 0;
	DWORD		iColType                 = iCOLUMNMETA_Type;
	WCHAR*      wszUserType              = NULL;
	SIZE_T      cchUserType              = 0;
	BOOL        bAllocedUserType         = FALSE;
	WCHAR*      wszAttribute             = NULL;
	SIZE_T      cchAttribute             = 0;
	DWORD		iColAttribute            = iCOLUMNMETA_Attributes;
	WCHAR*      wszMetaFlags             = NULL;
	SIZE_T      cchMetaFlags             = 0;
	SIZE_T      cchPropMetaFlagsEq       = 0;
	DWORD		iColMetaFlags            = iCOLUMNMETA_MetaFlags;
	WCHAR*      wszMetaFlagsEx           = NULL;
	SIZE_T      cchMetaFlagsEx           = 0;
	SIZE_T      cchPropMetaFlagsExEq     = 0;
	DWORD		iColMetaFlagsEx          = iCOLUMNMETA_SchemaGeneratorFlags;
	WCHAR*      wszDefaultValue          = NULL;
	SIZE_T      cchDefaultValue          = 0;
	WCHAR       wszMinValue[25];
	SIZE_T      cchMinValue              = 0;
	WCHAR       wszMaxValue[25];
	SIZE_T      cchMaxValue              = 0;
	SIZE_T      cch                      = 0;
	DWORD       dwMetaFlags              = 0;
	DWORD       dwValidMetaFlagsMask     = fCOLUMNMETA_PRIMARYKEY        	|
                                           fCOLUMNMETA_DIRECTIVE         	|
                                           fCOLUMNMETA_WRITENEVER        	|
                                           fCOLUMNMETA_WRITEONCHANGE     	|
                                           fCOLUMNMETA_WRITEONINSERT     	|
                                           fCOLUMNMETA_NOTPUBLIC         	|
                                           fCOLUMNMETA_NOTDOCD           	|
                                           fCOLUMNMETA_PUBLICREADONLY    	|
                                           fCOLUMNMETA_PUBLICWRITEONLY   	|
                                           fCOLUMNMETA_INSERTGENERATE    	|
                                           fCOLUMNMETA_INSERTUNIQUE      	|
                                           fCOLUMNMETA_INSERTPARENT      	|
                                           fCOLUMNMETA_LEGALCHARSET      	|
                                           fCOLUMNMETA_ILLEGALCHARSET    	|
                                           fCOLUMNMETA_NOTPERSISTABLE    	|
                                           fCOLUMNMETA_CASEINSENSITIVE   	|
                                           fCOLUMNMETA_TOLOWERCASE;
	DWORD       dwMetaFlagsEx            = 0;
	DWORD       dwValidMetaFlagsExMask   = fCOLUMNMETA_CACHE_PROPERTY_MODIFIED	|
                                           fCOLUMNMETA_CACHE_PROPERTY_CLEARED	|
                                           fCOLUMNMETA_PROPERTYISINHERITED	    |
                                           fCOLUMNMETA_USEASPUBLICROWNAME	    |
                                           fCOLUMNMETA_MANDATORY         	    |
                                           fCOLUMNMETA_WAS_NOTIFICATION  	    |
                                           fCOLUMNMETA_HIDDEN;
	DWORD       dwSynID                  = 0;

	//
	// Compute the individual strings and lengths.
	//

	//
	// Name
	//

	cchPropertyName = wcslen(m_Property.pInternalName);

	//
	// ID
	// 

	wszID[0] = 0;
	_ultow(*(m_Property.pID), wszID, 10);
	cchID = wcslen(wszID);

	//
	// Type
	// TODO: Get FromSchema
	//

	// 
	// The type should always be derived from the SynID
	//

	dwSynID = SynIDFromMetaFlagsEx(*(m_Property.pSchemaGeneratorFlags));

	hr = GetTypeFromSynID(dwSynID,
		                  &wszType);

	/*
	hr = GetType(*(m_Property.pType),
		         &wszType);

	hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(*(m_Property.pType),
		                                                  &wszType,
														  wszTABLE_COLUMNMETA,
										            	  iColType);
	*/
	if(FAILED(hr))
	{
		goto exit;
	}
	cchType = wcslen(wszType);

	//
	// UserType
	//

	hr = m_pCWriter->m_pCWriterGlobalHelper->GetUserType(*(m_Property.pUserType),
		                                                 &wszUserType,
														 (ULONG*)&cchUserType,
														 &bAllocedUserType);
	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Attribute
	//

	hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(*(m_Property.pAttributes),
		                                                  &wszAttribute,
														  wszTABLE_COLUMNMETA,
										            	  iColAttribute);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchAttribute = wcslen(wszAttribute);

	//
	// MetaFlags (only the relavant ones - PRIMARYKEY, BOOL, MULTISTRING, EXPANDSTRING)
	//

	dwMetaFlags = *(m_Property.pMetaFlags);
	dwMetaFlags = dwMetaFlags & dwValidMetaFlagsMask; // Zero out any non-valid bits. (i.e. bits that must be inferred)

	if(0 != dwMetaFlags)
	{
	    cchPropMetaFlagsEq = g_cchPropMetaFlagsEq;
		hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlags,
															  &wszMetaFlags,
															  wszTABLE_COLUMNMETA,
										            		  iColMetaFlags);

		if(FAILED(hr))
		{
			goto exit;
		}
		cchMetaFlags = wcslen(wszMetaFlags);
	}

	//
	// MetaFlagsEx (only the relavant ones - CACHE_PROPERTY_MODIFIED, CACHE_PROPERTY_CLEARED, EXTENDEDTYPE0-3, MANDATORY)
	//

	dwMetaFlagsEx = *(m_Property.pSchemaGeneratorFlags);
	dwMetaFlagsEx = dwMetaFlagsEx & dwValidMetaFlagsExMask; // Zero out any non-valid bits. (i.e. bits that must be inferred)

	if(0 != dwMetaFlagsEx)
	{
		cchPropMetaFlagsExEq = g_cchPropMetaFlagsExEq;
		hr = m_pCWriter->m_pCWriterGlobalHelper->FlagToString(dwMetaFlagsEx,
															  &wszMetaFlagsEx,
															  wszTABLE_COLUMNMETA,
										            		  iColMetaFlagsEx);

		if(FAILED(hr))
		{
			goto exit;
		}
		cchMetaFlagsEx = wcslen(wszMetaFlagsEx);
	}

	//
	// DefaultValue
	//

	if(NULL != m_Property.pDefaultValue)
	{
		hr = m_pCWriter->m_pCWriterGlobalHelper->ToString(m_Property.pDefaultValue,
														  m_PropertySize[iCOLUMNMETA_DefaultValue],
									            		  *(m_Property.pID),
									            		  MetabaseTypeFromColumnMetaType(),
														  METADATA_NO_ATTRIBUTES,			// Do not check for attributes while applying defaults
														  &wszDefaultValue);
		cchDefaultValue = wcslen(wszDefaultValue);
	}

	if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Min and Max only for DWORDs
	//

	// TODO: Change to DBTYPE_DWORD

	wszMinValue[0] = 0;
	wszMaxValue[0] = 0;

	if(19 == *(m_Property.pType))
	{
		if(NULL != m_Property.pStartingNumber && 0 != *m_Property.pStartingNumber)
		{
			_ultow(*(m_Property.pStartingNumber), wszMinValue, 10);
			cchMinValue = wcslen(wszMinValue);
		}

		if(NULL != m_Property.pEndingNumber && -1 != *m_Property.pEndingNumber)
		{
			_ultow(*(m_Property.pEndingNumber), wszMaxValue, 10);
			cchMaxValue = wcslen(wszMaxValue);
		}
	}

	//
	// Confirm that the total length is less than buffer. If not, reallocate.
	//

	cch = g_cchBeginPropertyLong +
	      cchPropertyName + 
		  g_cchPropIDEq + 
		  cchID + 
		  g_cchPropTypeEq +
		  cchType + 
		  g_cchPropUserTypeEq +
		  cchUserType + 
		  g_cchPropAttributeEq + 
		  cchAttribute + 
		  cchPropMetaFlagsEq +
		  cchMetaFlags + 
		  cchPropMetaFlagsExEq + 
		  cchMetaFlagsEx + 
		  g_cchPropDefaultEq + 
		  cchDefaultValue + 
		  g_cchPropMinValueEq + 
		  cchMinValue + 
		  g_cchPropMaxValueEq + 
		  cchMaxValue + 
		  g_cchEndPropertyLongBeforeFlag;
	     
	if((cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	//
	// Construct the string.
	//

	wszEnd = wszTemp;
	cch    = 0;
	memcpy(wszEnd, g_wszBeginPropertyLong, (g_cchBeginPropertyLong)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginPropertyLong;
	cch    += g_cchBeginPropertyLong;
	memcpy(wszEnd, m_Property.pInternalName, (cchPropertyName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchPropertyName;
	cch    += cchPropertyName;
	memcpy(wszEnd, g_wszPropIDEq, (g_cchPropIDEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchPropIDEq;
	cch    += g_cchPropIDEq;
	memcpy(wszEnd, wszID, (cchID)*sizeof(WCHAR));
	wszEnd = wszEnd + cchID;
	cch    += cchID;
	memcpy(wszEnd, g_wszPropTypeEq, (g_cchPropTypeEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchPropTypeEq;
	cch    += g_cchPropTypeEq;
	memcpy(wszEnd, wszType, (cchType)*sizeof(WCHAR));
	wszEnd = wszEnd + cchType;
	cch    += cchType;
	memcpy(wszEnd, g_wszPropUserTypeEq, (g_cchPropUserTypeEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchPropUserTypeEq;
	cch    += g_cchPropUserTypeEq;
	memcpy(wszEnd, wszUserType, (cchUserType)*sizeof(WCHAR));
	wszEnd = wszEnd + cchUserType;
	cch    += cchUserType;
	if(NULL != wszAttribute)
	{
		memcpy(wszEnd, g_wszPropAttributeEq, (g_cchPropAttributeEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchPropAttributeEq;
		cch    += g_cchPropAttributeEq;
		memcpy(wszEnd, wszAttribute, (cchAttribute)*sizeof(WCHAR));
		wszEnd = wszEnd + cchAttribute;
		cch    += cchAttribute;
	}
	if(NULL != wszMetaFlags)
	{
		memcpy(wszEnd, g_wszPropMetaFlagsEq, (g_cchPropMetaFlagsEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchPropMetaFlagsEq;
		cch    += g_cchPropMetaFlagsEq;
		memcpy(wszEnd, wszMetaFlags, (cchMetaFlags)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlags;
		cch    += cchMetaFlags;
	}
	if(NULL != wszMetaFlagsEx)
	{
		memcpy(wszEnd, g_wszPropMetaFlagsExEq, (g_cchPropMetaFlagsExEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchPropMetaFlagsExEq;
		cch    += g_cchPropMetaFlagsExEq;
		memcpy(wszEnd, wszMetaFlagsEx, (cchMetaFlagsEx)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlagsEx;
		cch    += cchMetaFlagsEx;
	}
	if(NULL != wszDefaultValue)
	{
		memcpy(wszEnd, g_wszPropDefaultEq, (g_cchPropDefaultEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchPropDefaultEq;
		cch    += g_cchPropDefaultEq;
		memcpy(wszEnd, wszDefaultValue, (cchDefaultValue)*sizeof(WCHAR));
		wszEnd = wszEnd + cchDefaultValue;
		cch    += cchDefaultValue;
	}
	if(0 != wszMinValue[0])
	{
		memcpy(wszEnd, g_wszPropMinValueEq, (g_cchPropMinValueEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchPropMinValueEq;
		cch    += g_cchPropMinValueEq;
		memcpy(wszEnd, wszMinValue, (cchMinValue)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMinValue;
		cch    += cchMinValue;
	}
	if(0 != wszMaxValue[0])
	{
		memcpy(wszEnd, g_wszPropMaxValueEq, (g_cchPropMaxValueEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchPropMaxValueEq;
		cch    += g_cchPropMaxValueEq;
		memcpy(wszEnd, wszMaxValue, (cchMaxValue)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMaxValue;
		cch    += cchMaxValue;
	}
	if(NULL != m_aFlag)
	{
		memcpy(wszEnd, g_wszEndPropertyLongBeforeFlag, (g_cchEndPropertyLongBeforeFlag)*sizeof(WCHAR));
		cch    += g_cchEndPropertyLongBeforeFlag;
	}

	//
	// Write the string into the file.
	//

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

exit:

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}
	
	/*
	if(NULL != wszType)
	{
		delete [] wszType;
	}
	*/
	if((NULL != wszUserType) && bAllocedUserType)
	{
		delete [] wszUserType;
	}
	if(NULL != wszAttribute)
	{
		delete [] wszAttribute;
	}
	if(NULL != wszMetaFlags)
	{
		delete [] wszMetaFlags;
	}
	if(NULL != wszMetaFlagsEx)
	{
		delete [] wszMetaFlagsEx;
	}
	if(NULL != wszDefaultValue)
	{
		delete [] wszDefaultValue;
	}

	return hr;

} // CCatalogPropertyWriter::BeginWritePropertyLong


HRESULT CCatalogPropertyWriter::EndWritePropertyLong()
{
	HRESULT		hr				= S_OK;
	WCHAR*		wszTemp			= g_wszTemp;
	WCHAR*      wszEndProperty	= NULL;
	SIZE_T      cch             = 0;

	if(NULL != m_aFlag)
	{
		wszEndProperty = (LPWSTR)g_wszEndPropertyLongAfterFlag;
	}
	else
	{
		wszEndProperty = (LPWSTR)g_wszEndPropertyShort;
	}

	cch = wcslen(wszEndProperty);
	                  
	if((cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	memcpy(wszTemp, wszEndProperty, (cch)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

}


HRESULT CCatalogPropertyWriter::WriteFlag(ULONG i_iFlag)
{
	//tTAGMETARow*		pFlag       = m_aFlag[i_iFlag];
	HRESULT				hr          = S_OK;
	WCHAR*				wszTemp     = g_wszTemp;
	WCHAR*				wszEnd      = NULL;
	WCHAR               wszValue[25];
	SIZE_T				cchFlagName = 0;
	SIZE_T				cchValue    = 0;
	SIZE_T				cch         = 0;
	WCHAR               wszID[11];
	SIZE_T				cchID       = 0;

	cchFlagName = wcslen(m_aFlag[i_iFlag].pInternalName);
	
	wszValue[0] = 0;
	_ultow(*(m_aFlag[i_iFlag].pValue), wszValue, 10);
	cchValue  = wcslen(wszValue);

	wszID[0] = 0;
	_ultow(*(m_aFlag[i_iFlag].pID), wszID, 10);
	cchID  = wcslen(wszID);

	cch = g_cchBeginFlag +
		  cchFlagName + 
		  g_cchFlagValueEq +
		  cchValue + 
		  g_cchFlagIDEq + 
		  cchID + 
		  g_cchEndFlag;
	                  
	if((cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	wszEnd = wszTemp;
	memcpy(wszEnd, g_wszBeginFlag, (g_cchBeginFlag)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginFlag;
	memcpy(wszEnd, m_aFlag[i_iFlag].pInternalName, (cchFlagName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchFlagName;
	memcpy(wszEnd, g_wszFlagValueEq, (g_cchFlagValueEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchFlagValueEq;
	memcpy(wszEnd, wszValue, (cchValue)*sizeof(WCHAR));
	wszEnd = wszEnd + cchValue;
	memcpy(wszEnd, g_wszFlagIDEq, (g_cchFlagIDEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchFlagIDEq;
	memcpy(wszEnd, wszID, (cchID)*sizeof(WCHAR));
	wszEnd = wszEnd + cchID;
	memcpy(wszEnd, g_wszEndFlag, (g_cchEndFlag)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CCatalogPropertyWriter::WriteFlag


DWORD CCatalogPropertyWriter::MetabaseTypeFromColumnMetaType()
{
    switch(*(m_Property.pType))
    {
    case eCOLUMNMETA_UI4:
        return eMBProperty_DWORD;
    case eCOLUMNMETA_BYTES:
        return eMBProperty_BINARY;
    case eCOLUMNMETA_WSTR:
        if(*(m_Property.pMetaFlags) & fCOLUMNMETA_EXPANDSTRING)
            return eMBProperty_EXPANDSZ;
        else if(*(m_Property.pMetaFlags) & fCOLUMNMETA_MULTISTRING)
            return eMBProperty_MULTISZ;
        return eMBProperty_STRING;
    default:
		;
      //  ASSERT(false && L"This type is not allow in the Metabase. MetaMigrate should not have create a column of this type");
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\eventlogger.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    EventLogger.h

$Header: $

Abstract: This class implements ICatalogErrorLogger2 interface and
            sends error information to the NT EventLog

Author:
    stephenr 	4/26/2001		Initial Release

Revision History:

--**************************************************************************/

#include "EventLogger.h"


//=================================================================================
// Function: ReportError
//
// Synopsis: Mechanism for reporting errors to the NT EventLog
//
// Arguments: [i_BaseVersion_DETAILEDERRORS] - 
//            [i_ExtendedVersion_DETAILEDERRORS] - 
//            [i_cDETAILEDERRORS_NumberOfColumns] - 
//            [i_acbSizes] - 
//            [i_apvValues] - 
//            
// Return Value: 
//=================================================================================
HRESULT
EventLogger::ReportError
(
    ULONG      i_BaseVersion_DETAILEDERRORS,
    ULONG      i_ExtendedVersion_DETAILEDERRORS,
    ULONG      i_cDETAILEDERRORS_NumberOfColumns,
    ULONG *    i_acbSizes,
    LPVOID *   i_apvValues
)
{
    if(i_BaseVersion_DETAILEDERRORS != BaseVersion_DETAILEDERRORS)
        return E_ST_BADVERSION;
    if(0 == i_apvValues)
        return E_INVALIDARG;
    if(i_cDETAILEDERRORS_NumberOfColumns <= iDETAILEDERRORS_ErrorCode)//we need at least this many columns
        return E_INVALIDARG;

    tDETAILEDERRORSRow errorRow;
    memset(&errorRow, 0x00, sizeof(tDETAILEDERRORSRow));
    memcpy(&errorRow, i_apvValues, i_cDETAILEDERRORS_NumberOfColumns * sizeof(void *));

    if(0 == errorRow.pType)
        return E_INVALIDARG;
    if(0 == errorRow.pCategory)
        return E_INVALIDARG;
    if(0 == errorRow.pEvent)
        return E_INVALIDARG;
    if(0 == errorRow.pSource)
        return E_INVALIDARG;

    WCHAR wszInsertionString5[1024];
    if(0 == errorRow.pString5)
        FillInInsertionString5(wszInsertionString5, 1024, errorRow);

    LPCTSTR pInsertionStrings[5];
    pInsertionStrings[4] = errorRow.pString5 ? errorRow.pString5 : L"";
    pInsertionStrings[3] = errorRow.pString5 ? errorRow.pString4 : L"";
    pInsertionStrings[2] = errorRow.pString5 ? errorRow.pString3 : L"";
    pInsertionStrings[1] = errorRow.pString5 ? errorRow.pString2 : L"";
    pInsertionStrings[0] = errorRow.pString5 ? errorRow.pString1 : L"";

    HANDLE hEventSource = RegisterEventSource(NULL, errorRow.pSource);
    ReportEvent(hEventSource, LOWORD(*errorRow.pType), LOWORD(*errorRow.pCategory), *errorRow.pEvent, 0, 5, 0, pInsertionStrings, 0);
    DeregisterEventSource(hEventSource);

    if(m_spNextLogger)//is there a chain of loggers
    {
        return m_spNextLogger->ReportError(i_BaseVersion_DETAILEDERRORS,
                                          i_ExtendedVersion_DETAILEDERRORS,
                                          i_cDETAILEDERRORS_NumberOfColumns,
                                          i_acbSizes,
                                          reinterpret_cast<LPVOID *>(&errorRow));//instead of passing forward i_apvValues, let's use errorRow since it has String5
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\linkable.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
/* -----------------------------------------------------------------------
   Microsoft Application Server (Microsoft Confidential)

   @rev 0 | 3/23/97 | jimbo | Sherpa-M3
   ----------------------------------------------------------------------- */

//
// Includes
//
#include <windows.h>
#include <Linkable.h>


//
// Class -- CLinkable
//		Elements on a linked list
//


//
// Member Function (public) -- InsertAfter
//		Insert 'that' onto the list after 'this'. Remove 'other' from its current
//		list, if necessary.
//
void CLinkable::InsertAfter( CLinkable* that )
{
	CLinkable* prev = that->m_pPrev;
	CLinkable* next = that->m_pNext;

	prev->m_pNext = next;
	next->m_pPrev = prev;

	next = this->m_pNext;

	this->m_pNext = that;
	that->m_pPrev = this;
	that->m_pNext = next;
	next->m_pPrev = that;
}


//
// Member Function (public) -- InsertBefore
//		Insert 'that' onto the list before 'this'. Remove 'other' from its current
//		list, if necessary.
//
void CLinkable::InsertBefore( CLinkable* that )
{
	CLinkable* prev = that->m_pPrev;
	CLinkable* next = that->m_pNext;

	prev->m_pNext = next;
	next->m_pPrev = prev;

	prev = this->m_pPrev;

	prev->m_pNext = that;
	that->m_pPrev = prev;
	that->m_pNext = this;
	this->m_pPrev = that;
}


//
// Member Function (public) -- Remove
//		Remove element from its current list, if any.
//
void CLinkable::Remove()
{
	CLinkable* prev = m_pPrev;
	CLinkable* next = m_pNext;

	prev->m_pNext = next;
	next->m_pPrev = prev;

	m_pPrev = m_pNext = this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\memmgr.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------
Microsoft	D.T.C (Distributed Transaction Coordinator)

(c)	1995	Microsoft Corporation.	All Rights Reserved

@ doc

@module		MemMgr.CPP	|

			This manages sets of pages obtained from the OS

-------------------------------------------------------------------------------
@rev	0	|	7th-Aug-1996	|	GaganC	|	Created
----------------------------------------------------------------------------- */

//---------------------------------------------------------
//			File Includes
//---------------------------------------------------------
#include <windows.h>
#include "UTAssert.H"
DeclAssertFile;					//Is needed for Assert macros.

#include "UTSem.h"
#include "mmgr.h"


//---------------------------------------------------------
//			All forwards go here
//---------------------------------------------------------
class CMemCache;


//---------------------------------------------------------
//			All globals go here
//---------------------------------------------------------
CMemCache		sg_CMemCache;



/* ----------------------------------------------------------------------------
@func

	This is a globally available API for anyone to call. There however
	will be only one memory manager per dll
---------------------------------------------------------------------------- */
void * ObtainMemPage (void)
{
	return sg_CMemCache.ObtainMemPage ();
}


/* ----------------------------------------------------------------------------
@func 

---------------------------------------------------------------------------- */
void FreeMemPage (void * pv)
{
	sg_CMemCache.FreeMemPage (pv);
}



//-----------------------------------------------------------------------------
//
//		IMPLEMENTATION of class CMemCache
//
//-----------------------------------------------------------------------------

/* ----------------------------------------------------------------------------
@mfunc 

---------------------------------------------------------------------------- */
CMemCache::CMemCache (void)
{
	
	m_dwcInCache = 0x0;

	for (DWORD dwc = 0; dwc < MAX_CACHE_COUNT; dwc++)
	{
		m_rgpv[dwc] = 0x0;	
	}	
} //end CMemCache::CMemCache



/* ----------------------------------------------------------------------------
@mfunc 

---------------------------------------------------------------------------- */
CMemCache::~CMemCache (void)
{			 
	BOOL		fRet;
	DWORD		dwc;	

	for (dwc = 0; dwc < MAX_CACHE_COUNT; dwc++)
	{
		if (m_rgpv[dwc])
		{
#if defined(_DEBUG) || defined(NO_VIRTUAL_ALLOC)
			DtcFreeMemory (m_rgpv[dwc]);
#else
			fRet = VirtualFree (m_rgpv[dwc], 0x0, MEM_RELEASE);
			AssertSz (fRet, "VirtualFree failed");
#endif
			m_rgpv[dwc] = 0x0;
		}
	}
} //end CMemCache::~CMemCache



/* ----------------------------------------------------------------------------
@mfunc 

---------------------------------------------------------------------------- */
inline void * CMemCache::ObtainMemPage (void)
{
	void	*	pv	= 0x0;
	DWORD		dwc;
	
	//-------------------------------------------------------------------------
	//Lock the cache
	m_semexcPageSet.Lock();


	//-------------------------------------------------------------------------
	//if the cache is empty then simply ask the os for a page and return that
	if (m_dwcInCache == 0)
	{
#if defined(_DEBUG) || defined(NO_VIRTUAL_ALLOC)
		pv = DtcAllocateMemory	(DEFAULT_PAGE_SIZE);	
		memset (pv, 0, DEFAULT_PAGE_SIZE);
#else
		pv = VirtualAlloc	(
								NULL, 
								DEFAULT_PAGE_SIZE,
								MEM_COMMIT,
								PAGE_READWRITE																	
							);	
#endif

		goto DONE;								
	}

	
	//-------------------------------------------------------------------------
	//Reaching this point implies that the cache is not empty. Find the first
	//page in the cache and return that
	Assert (m_dwcInCache > 0);

	for (dwc = 0; dwc < MAX_CACHE_COUNT; dwc++)
	{
		if (m_rgpv[dwc] != 0x0)
		{
			pv			= m_rgpv[dwc];

			m_rgpv[dwc] = 0x0;

			m_dwcInCache--;

			break;				//from the for loop
		}
	} //end for loop

	Assert (pv);

	((CPageInfo *)pv)->Recycle();


DONE:
	//-------------------------------------------------------------------------
	//Prepare to return
		
	m_semexcPageSet.UnLock();	

	return pv;
} //end CMemCache::ObtainMemPage



/* ----------------------------------------------------------------------------
@mfunc 

---------------------------------------------------------------------------- */
inline void CMemCache::FreeMemPage (void * pv)
{
	BOOL		fRet;
	DWORD		dwc;

	Assert (pv);

	//-------------------------------------------------------------------------
	//Lock the cache
	m_semexcPageSet.Lock();

	if (m_dwcInCache == MAX_CACHE_COUNT)
	{
#if defined(_DEBUG) || defined(NO_VIRTUAL_ALLOC)
		DtcFreeMemory (pv);
#else
		fRet = VirtualFree (pv, 0x0, MEM_RELEASE);
		AssertSz (fRet, "VirtualFree failed");
#endif
		goto DONE;
	}
	

	//-------------------------------------------------------------------------
	//There is space in the cache
	for (dwc = 0; dwc < MAX_CACHE_COUNT; dwc++)
	{
		if (m_rgpv[dwc] == 0x0)
		{
			m_rgpv[dwc] = pv;

			m_dwcInCache++;

			pv = 0x0;

			break;				//from the for loop
		}
	} //end for loop

	Assert (pv == 0x0);


DONE:
	//-------------------------------------------------------------------------
	//release the lock		
	m_semexcPageSet.UnLock();	
} //end CMemCache::FreeMemPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\md5.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//
// md5.cpp
//
#include <windows.h>
#include <stdlib.h>
#include "md5.h"

void MD5::Init(BOOL fConstructed)
    {
    // These two fields are read only, and so initialization thereof can be 
    // omitted on the second and subsequent hashes using this same instance.
    //
    if (!fConstructed)
        {
        memset(m_padding, 0, 64);
        m_padding[0]=0x80;
        }

    m_cbitHashed = 0;
    m_cbData     = 0;
    m_a = 0x67452301;   // magic
    m_b = 0xefcdab89;   //      ... constants
    m_c = 0x98badcfe;   //              ... per
    m_d = 0x10325476;   //                      .. RFC1321
    }


void MD5::HashMore(const void* pvInput, ULONG cbInput)
// Hash the additional data into the state
    {
    const BYTE* pbInput = (const BYTE*)pvInput;

    m_cbitHashed += (cbInput<<3);

    ULONG cbRemaining = 64 - m_cbData;
    if (cbInput < cbRemaining)
        {
        // It doesn't fill up the buffer, so just store it
        memcpy(&m_data[m_cbData], pbInput, cbInput);
        m_cbData += cbInput;
        }
    else
        {
        // It does fill up the buffer. Fill up all that it will take
        memcpy(&m_data[m_cbData], pbInput, cbRemaining);

        // Hash the now-full buffer
        MD5Transform(m_state, (ULONG*)&m_data[0]);
        cbInput -= cbRemaining;
        pbInput += cbRemaining;

        // Hash the data in 64-byte runs, starting just after what we've copied
        while (cbInput >= 64)
            {
            MD5Transform(m_state, (ULONG*)pbInput);
            pbInput += 64;
            cbInput -= 64;
            }

        // Store the tail of the input into the buffer
        memcpy(&m_data[0], pbInput, cbInput);
        m_cbData = cbInput;
        }
    }


void MD5::GetHashValue(MD5HASHDATA* phash)
// Finalize the hash by appending the necessary padding and length count. Then
// return the final hash value.
    {
    union {
        ULONGLONG cbitHashed;
        BYTE      rgb[8];
        }u;

    // Remember how many bits there were in the input data
    u.cbitHashed = m_cbitHashed;

    // Calculate amount of padding needed. Enough so total byte count hashed is 56 mod 64
    ULONG cbPad = (m_cbData < 56 ? 56-m_cbData : 120-m_cbData);

    // Hash the padding
    HashMore(&m_padding[0], cbPad);

    // Hash the (before padding) bit length
    HashMore(&u.rgb[0], 8);

    // Return the hash value
    memcpy(phash, &m_a, 16);
    }




// We have two implementations of the core 'transform' at the heart
// of this hash: one in C, another in x86 assembler.
//
#ifndef _X86_
    #define USE_C_MD5_TRANSFORM
#endif

#ifdef USE_C_MD5_TRANSFORM

    ////////////////////////////////////////////////////////////////
    //
    // ROTATE_LEFT should be a macro that updates its first operand
    // with its present value rotated left by the amount of its 
    // second operand, which is always a constant.
    // 
    // One way to portably do it would be
    //
    //      #define ROL(x, n)        (((x) << (n)) | ((x) >> (32-(n))))
    //      #define ROTATE_LEFT(x,n) (x) = ROL(x,n)
    //
    // but our compiler has an intrinsic!

    #define ROTATE_LEFT(x,n) (x) = _lrotl(x,n)

    ////////////////////////////////////////////////////////////////
    //
    // Constants used in each of the various rounds

    #define MD5_S11 7
    #define MD5_S12 12
    #define MD5_S13 17
    #define MD5_S14 22
    #define MD5_S21 5
    #define MD5_S22 9
    #define MD5_S23 14
    #define MD5_S24 20
    #define MD5_S31 4
    #define MD5_S32 11
    #define MD5_S33 16
    #define MD5_S34 23
    #define MD5_S41 6
    #define MD5_S42 10
    #define MD5_S43 15
    #define MD5_S44 21

    ////////////////////////////////////////////////////////////////
    //
    // The core twiddle functions

//  #define F(x, y, z) (((x) & (y)) | ((~x) & (z)))         // the function per the standard
    #define F(x, y, z) ((((z) ^ (y)) & (x)) ^ (z))          // an alternate encoding

//  #define G(x, y, z) (((x) & (z)) | ((y) & (~z)))         // the function per the standard
    #define G(x, y, z) ((((x) ^ (y)) & (z)) ^ (y))          // an alternate encoding

    #define H(x, y, z) ((x) ^ (y) ^ (z))

    #define I(x, y, z) ((y) ^ ((x) | (~z)))

    #define AC(ac)  ((ULONG)(ac))
    
    ////////////////////////////////////////////////////////////////

    #define FF(a, b, c, d, x, s, ac) { \
        (a) += F (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }
    
    ////////////////////////////////////////////////////////////////
    
    #define GG(a, b, c, d, x, s, ac) { \
        (a) += G (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }

    ////////////////////////////////////////////////////////////////

    #define HH(a, b, c, d, x, s, ac) { \
        (a) += H (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }
    
    ////////////////////////////////////////////////////////////////
    
    #define II(a, b, c, d, x, s, ac) { \
        (a) += I (b,c,d) + (x) + (AC(ac)); \
        ROTATE_LEFT (a, s); \
        (a) += (b); \
        }

    void __stdcall MD5Transform(ULONG state[4], const ULONG* data)
        {
        ULONG a=state[0];
        ULONG b=state[1];
        ULONG c=state[2];
        ULONG d=state[3];

        // Round 1
        FF (a, b, c, d, data[ 0], MD5_S11, 0xd76aa478); // 1 
        FF (d, a, b, c, data[ 1], MD5_S12, 0xe8c7b756); // 2 
        FF (c, d, a, b, data[ 2], MD5_S13, 0x242070db); // 3 
        FF (b, c, d, a, data[ 3], MD5_S14, 0xc1bdceee); // 4 
        FF (a, b, c, d, data[ 4], MD5_S11, 0xf57c0faf); // 5 
        FF (d, a, b, c, data[ 5], MD5_S12, 0x4787c62a); // 6 
        FF (c, d, a, b, data[ 6], MD5_S13, 0xa8304613); // 7 
        FF (b, c, d, a, data[ 7], MD5_S14, 0xfd469501); // 8 
        FF (a, b, c, d, data[ 8], MD5_S11, 0x698098d8); // 9 
        FF (d, a, b, c, data[ 9], MD5_S12, 0x8b44f7af); // 10 
        FF (c, d, a, b, data[10], MD5_S13, 0xffff5bb1); // 11 
        FF (b, c, d, a, data[11], MD5_S14, 0x895cd7be); // 12 
        FF (a, b, c, d, data[12], MD5_S11, 0x6b901122); // 13 
        FF (d, a, b, c, data[13], MD5_S12, 0xfd987193); // 14 
        FF (c, d, a, b, data[14], MD5_S13, 0xa679438e); // 15 
        FF (b, c, d, a, data[15], MD5_S14, 0x49b40821); // 16 

        // Round 2
        GG (a, b, c, d, data[ 1], MD5_S21, 0xf61e2562); // 17 
        GG (d, a, b, c, data[ 6], MD5_S22, 0xc040b340); // 18 
        GG (c, d, a, b, data[11], MD5_S23, 0x265e5a51); // 19 
        GG (b, c, d, a, data[ 0], MD5_S24, 0xe9b6c7aa); // 20 
        GG (a, b, c, d, data[ 5], MD5_S21, 0xd62f105d); // 21 
        GG (d, a, b, c, data[10], MD5_S22,  0x2441453); // 22 
        GG (c, d, a, b, data[15], MD5_S23, 0xd8a1e681); // 23 
        GG (b, c, d, a, data[ 4], MD5_S24, 0xe7d3fbc8); // 24 
        GG (a, b, c, d, data[ 9], MD5_S21, 0x21e1cde6); // 25 
        GG (d, a, b, c, data[14], MD5_S22, 0xc33707d6); // 26 
        GG (c, d, a, b, data[ 3], MD5_S23, 0xf4d50d87); // 27 
        GG (b, c, d, a, data[ 8], MD5_S24, 0x455a14ed); // 28 
        GG (a, b, c, d, data[13], MD5_S21, 0xa9e3e905); // 29 
        GG (d, a, b, c, data[ 2], MD5_S22, 0xfcefa3f8); // 30 
        GG (c, d, a, b, data[ 7], MD5_S23, 0x676f02d9); // 31 
        GG (b, c, d, a, data[12], MD5_S24, 0x8d2a4c8a); // 32 

        // Round 3
        HH (a, b, c, d, data[ 5], MD5_S31, 0xfffa3942); // 33 
        HH (d, a, b, c, data[ 8], MD5_S32, 0x8771f681); // 34 
        HH (c, d, a, b, data[11], MD5_S33, 0x6d9d6122); // 35 
        HH (b, c, d, a, data[14], MD5_S34, 0xfde5380c); // 36 
        HH (a, b, c, d, data[ 1], MD5_S31, 0xa4beea44); // 37 
        HH (d, a, b, c, data[ 4], MD5_S32, 0x4bdecfa9); // 38 
        HH (c, d, a, b, data[ 7], MD5_S33, 0xf6bb4b60); // 39 
        HH (b, c, d, a, data[10], MD5_S34, 0xbebfbc70); // 40 
        HH (a, b, c, d, data[13], MD5_S31, 0x289b7ec6); // 41 
        HH (d, a, b, c, data[ 0], MD5_S32, 0xeaa127fa); // 42 
        HH (c, d, a, b, data[ 3], MD5_S33, 0xd4ef3085); // 43 
        HH (b, c, d, a, data[ 6], MD5_S34,  0x4881d05); // 44 
        HH (a, b, c, d, data[ 9], MD5_S31, 0xd9d4d039); // 45 
        HH (d, a, b, c, data[12], MD5_S32, 0xe6db99e5); // 46 
        HH (c, d, a, b, data[15], MD5_S33, 0x1fa27cf8); // 47 
        HH (b, c, d, a, data[ 2], MD5_S34, 0xc4ac5665); // 48 

        // Round 4
        II (a, b, c, d, data[ 0], MD5_S41, 0xf4292244); // 49 
        II (d, a, b, c, data[ 7], MD5_S42, 0x432aff97); // 50 
        II (c, d, a, b, data[14], MD5_S43, 0xab9423a7); // 51 
        II (b, c, d, a, data[ 5], MD5_S44, 0xfc93a039); // 52 
        II (a, b, c, d, data[12], MD5_S41, 0x655b59c3); // 53 
        II (d, a, b, c, data[ 3], MD5_S42, 0x8f0ccc92); // 54 
        II (c, d, a, b, data[10], MD5_S43, 0xffeff47d); // 55 
        II (b, c, d, a, data[ 1], MD5_S44, 0x85845dd1); // 56 
        II (a, b, c, d, data[ 8], MD5_S41, 0x6fa87e4f); // 57 
        II (d, a, b, c, data[15], MD5_S42, 0xfe2ce6e0); // 58 
        II (c, d, a, b, data[ 6], MD5_S43, 0xa3014314); // 59 
        II (b, c, d, a, data[13], MD5_S44, 0x4e0811a1); // 60 
        II (a, b, c, d, data[ 4], MD5_S41, 0xf7537e82); // 61 
        II (d, a, b, c, data[11], MD5_S42, 0xbd3af235); // 62 
        II (c, d, a, b, data[ 2], MD5_S43, 0x2ad7d2bb); // 63 
        II (b, c, d, a, data[ 9], MD5_S44, 0xeb86d391); // 64 

        state[0] += a;
        state[1] += b;
        state[2] += c;
        state[3] += d;
        }

#else

    __declspec(naked) void __stdcall MD5Transform(ULONG state[4], const ULONG* data)
    // This implementation uses some pretty funky arithmetic identities
    // to effect its logic. Way cool! Kudos to whomever came up with this.
    //
        {
        __asm
            {
            push        ebx
            push        esi
            
            mov         ecx,dword ptr [esp+10h]     // data pointer to ecx
            
            push        edi
            mov         edi,dword ptr [esp+10h]     // state pointer to edi
            
            push        ebp
            mov         ebx,dword ptr [edi+4]       // ebx = b
            mov         ebp,dword ptr [edi+8]       // ebp = c
            mov         edx,dword ptr [edi+0Ch]     // edx = d
            
            mov         eax,edx                     // eax = d
            xor         eax,ebp                     // eax =    d xor c
            and         eax,ebx                     // eax =   (d xor c) ^ b
            xor         eax,edx                     // eax =  ((d xor c) ^ b) xor d
            add         eax,dword ptr [ecx]         // eax = (((d xor c) ^ b) xor d) + data[0]
            add         eax,dword ptr [edi]         // eax = (((d xor c) ^ b) xor d) + data[0] + a
            sub         eax,28955B88h               // eax = (((d xor c) ^ b) xor d) + data[0] + a + ac
            rol         eax,7                       // rotated left in the standard way
            lea         esi,dword ptr [eax+ebx]     // store temp sum in esi
            
            mov         eax,ebp                     // eax =        c
            xor         eax,ebx                     // eax =  b xor c
            and         eax,esi                     // eax = (b xor c) ^ ...
            xor         eax,ebp
            add         eax,dword ptr [ecx+4]
            lea         eax,dword ptr [edx+eax-173848AAh]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+8]
            lea         eax,dword ptr [ebp+eax+242070DBh]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+0Ch]
            lea         eax,dword ptr [ebx+eax-3E423112h]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edx
            xor         eax,edi
            and         eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+10h]
            lea         eax,dword ptr [esi+eax-0A83F051h]
            rol         eax,7
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,esi
            xor         eax,edi
            add         eax,dword ptr [ecx+14h]
            lea         eax,dword ptr [edx+eax+4787C62Ah]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+18h]
            lea         eax,dword ptr [edi+eax-57CFB9EDh]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+1Ch]
            lea         eax,dword ptr [ebx+eax-2B96AFFh]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edx
            xor         eax,edi
            and         eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+20h]
            lea         eax,dword ptr [esi+eax+698098D8h]
            rol         eax,7
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,esi
            xor         eax,edi
            add         eax,dword ptr [ecx+24h]
            lea         eax,dword ptr [edx+eax-74BB0851h]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+28h]
            lea         eax,dword ptr [edi+eax-0A44Fh]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+2Ch]
            lea         eax,dword ptr [ebx+eax-76A32842h]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edx
            xor         eax,edi
            and         eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+30h]
            lea         eax,dword ptr [esi+eax+6B901122h]
            rol         eax,7
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,esi
            xor         eax,edi
            add         eax,dword ptr [ecx+34h]
            lea         eax,dword ptr [edx+eax-2678E6Dh]
            rol         eax,0Ch
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,ebx
            add         eax,dword ptr [ecx+38h]
            lea         eax,dword ptr [edi+eax-5986BC72h]
            rol         eax,11h
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,edi
            xor         eax,esi
            add         eax,dword ptr [ecx+3Ch]
            lea         eax,dword ptr [ebx+eax+49B40821h]
            rol         eax,16h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,edx
            xor         eax,edi
            add         eax,dword ptr [ecx+4]
            lea         eax,dword ptr [esi+eax-9E1DA9Eh]
            rol         eax,5
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edi
            xor         eax,ebx
            add         eax,dword ptr [ecx+18h]
            lea         eax,dword ptr [edx+eax-3FBF4CC0h]
            rol         eax,9
            add         eax,esi
            
            mov         edx,eax                             // edx =    x
            xor         edx,esi                             // edx =   (x xor y)
            and         edx,ebx                             // edx =  ((x xor y) and z)
            xor         edx,esi                             // edx = (((x xor y) and z) xor y)
            add         edx,dword ptr [ecx+2Ch]             // edx = (((x xor y) and z) xor y) + data
            lea         edx,dword ptr [edi+edx+265E5A51h]   // edx = (((x xor y) and z) xor y) + data + ...
            rol         edx,0Eh
            lea         edi,dword ptr [eax+edx]
            
            mov         edx,eax
            xor         edx,edi
            and         edx,esi
            xor         edx,eax
            add         edx,dword ptr [ecx]
            lea         edx,dword ptr [ebx+edx-16493856h]
            mov         ebx,edi
            rol         edx,14h
            add         edx,edi

            xor         ebx,edx
            and         ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+14h]
            lea         esi,dword ptr [esi+ebx-29D0EFA3h]
            mov         ebx,edx
            rol         esi,5
            add         esi,edx

            xor         ebx,esi
            and         ebx,edi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+28h]
            lea         eax,dword ptr [eax+ebx+2441453h]
            rol         eax,9
            lea         ebx,dword ptr [esi+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edx
            xor         eax,esi
            add         eax,dword ptr [ecx+3Ch]
            lea         eax,dword ptr [edi+eax-275E197Fh]
            rol         eax,0Eh
            lea         edi,dword ptr [ebx+eax]
            
            mov         eax,ebx
            xor         eax,edi
            and         eax,esi
            xor         eax,ebx
            add         eax,dword ptr [ecx+10h]
            lea         eax,dword ptr [edx+eax-182C0438h]
            mov         edx,edi
            rol         eax,14h
            add         eax,edi
            
            xor         edx,eax
            and         edx,ebx
            xor         edx,edi
            add         edx,dword ptr [ecx+24h]
            lea         edx,dword ptr [esi+edx+21E1CDE6h]
            rol         edx,5
            lea         esi,dword ptr [eax+edx]
            
            mov         edx,eax
            xor         edx,esi
            and         edx,edi
            xor         edx,eax
            add         edx,dword ptr [ecx+38h]
            lea         edx,dword ptr [ebx+edx-3CC8F82Ah]
            rol         edx,9
            add         edx,esi
            
            mov         ebx,edx
            xor         ebx,esi
            and         ebx,eax
            xor         ebx,esi
            add         ebx,dword ptr [ecx+0Ch]
            lea         edi,dword ptr [edi+ebx-0B2AF279h]
            mov         ebx,edx
            rol         edi,0Eh
            add         edi,edx
            
            xor         ebx,edi
            and         ebx,esi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+20h]
            lea         eax,dword ptr [eax+ebx+455A14EDh]
            rol         eax,14h
            lea         ebx,dword ptr [edi+eax]
            
            mov         eax,edi
            xor         eax,ebx
            and         eax,edx
            xor         eax,edi
            add         eax,dword ptr [ecx+34h]
            lea         eax,dword ptr [esi+eax-561C16FBh]
            rol         eax,5
            lea         esi,dword ptr [ebx+eax]
            
            mov         eax,ebx
            xor         eax,esi
            and         eax,edi
            xor         eax,ebx
            add         eax,dword ptr [ecx+8]
            lea         eax,dword ptr [edx+eax-3105C08h]
            rol         eax,9
            lea         edx,dword ptr [esi+eax]
            
            mov         eax,edx
            xor         eax,esi
            and         eax,ebx
            xor         eax,esi
            add         eax,dword ptr [ecx+1Ch]
            lea         eax,dword ptr [edi+eax+676F02D9h]
            rol         eax,0Eh
            lea         edi,dword ptr [edx+eax]
            
            mov         eax,edx
            xor         eax,edi
            mov         ebp,eax
            and         ebp,esi
            xor         ebp,edx
            add         ebp,dword ptr [ecx+30h]
            lea         ebx,dword ptr [ebx+ebp-72D5B376h]
            rol         ebx,14h
            add         ebx,edi
            
            mov         ebp,ebx
            xor         ebp,eax
            add         ebp,dword ptr [ecx+14h]
            lea         eax,dword ptr [esi+ebp-5C6BEh]
            mov         esi,edi
            rol         eax,4
            add         eax,ebx
            
            xor         esi,ebx
            xor         esi,eax
            add         esi,dword ptr [ecx+20h]
            lea         edx,dword ptr [edx+esi-788E097Fh]
            rol         edx,0Bh
            add         edx,eax
            
            mov         esi,edx
            mov         ebp,edx
            xor         esi,ebx
            xor         esi,eax
            add         esi,dword ptr [ecx+2Ch]
            lea         esi,dword ptr [edi+esi+6D9D6122h]
            rol         esi,10h
            add         esi,edx
            
            xor         ebp,esi
            mov         edi,ebp
            xor         edi,eax
            add         edi,dword ptr [ecx+38h]
            lea         edi,dword ptr [ebx+edi-21AC7F4h]
            rol         edi,17h
            add         edi,esi
            
            mov         ebx,edi
            xor         ebx,ebp
            add         ebx,dword ptr [ecx+4]
            lea         eax,dword ptr [eax+ebx-5B4115BCh]
            mov         ebx,esi
            rol         eax,4
            add         eax,edi
            
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+10h]
            lea         edx,dword ptr [edx+ebx+4BDECFA9h]
            rol         edx,0Bh
            add         edx,eax
            
            mov         ebx,edx
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+1Ch]
            lea         esi,dword ptr [esi+ebx-944B4A0h]
            mov         ebx,edx
            rol         esi,10h
            add         esi,edx
            
            xor         ebx,esi
            mov         ebp,ebx
            xor         ebp,eax
            add         ebp,dword ptr [ecx+28h]
            lea         edi,dword ptr [edi+ebp-41404390h]
            rol         edi,17h
            add         edi,esi
            
            mov         ebp,edi
            xor         ebp,ebx
            mov         ebx,esi
            add         ebp,dword ptr [ecx+34h]
            xor         ebx,edi
            lea         eax,dword ptr [eax+ebp+289B7EC6h]
            rol         eax,4
            add         eax,edi
            
            xor         ebx,eax
            add         ebx,dword ptr [ecx]
            lea         edx,dword ptr [edx+ebx-155ED806h]
            rol         edx,0Bh
            add         edx,eax
            
            mov         ebx,edx
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+0Ch]
            lea         esi,dword ptr [esi+ebx-2B10CF7Bh]
            mov         ebx,edx
            rol         esi,10h
            add         esi,edx
            
            xor         ebx,esi
            mov         ebp,ebx
            xor         ebp,eax
            add         ebp,dword ptr [ecx+18h]
            lea         edi,dword ptr [edi+ebp+4881D05h]
            rol         edi,17h
            add         edi,esi
            
            mov         ebp,edi
            xor         ebp,ebx
            mov         ebx,esi
            add         ebp,dword ptr [ecx+24h]
            xor         ebx,edi
            lea         eax,dword ptr [eax+ebp-262B2FC7h]
            rol         eax,4
            add         eax,edi

            xor         ebx,eax
            add         ebx,dword ptr [ecx+30h]
            lea         edx,dword ptr [edx+ebx-1924661Bh]
            rol         edx,0Bh
            add         edx,eax
            
            mov         ebx,edx
            xor         ebx,edi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+3Ch]
            lea         esi,dword ptr [esi+ebx+1FA27CF8h]
            mov         ebx,edx
            rol         esi,10h
            add         esi,edx
            
            xor         ebx,esi
            xor         ebx,eax
            add         ebx,dword ptr [ecx+8]
            lea         edi,dword ptr [edi+ebx-3B53A99Bh]
            mov         ebx,edx
            rol         edi,17h
            not         ebx
            add         edi,esi
            
            or          ebx,edi
            xor         ebx,esi
            add         ebx,dword ptr [ecx]
            lea         eax,dword ptr [eax+ebx-0BD6DDBCh]
            mov         ebx,esi
            rol         eax,6
            not         ebx
            add         eax,edi
            
            or          ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+1Ch]
            lea         edx,dword ptr [edx+ebx+432AFF97h]
            mov         ebx,edi
            rol         edx,0Ah
            not         ebx
            add         edx,eax
            
            or          ebx,edx
            xor         ebx,eax
            add         ebx,dword ptr [ecx+38h]
            lea         esi,dword ptr [esi+ebx-546BDC59h]
            mov         ebx,eax
            rol         esi,0Fh
            not         ebx
            add         esi,edx
            
            or          ebx,esi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+14h]
            lea         edi,dword ptr [edi+ebx-36C5FC7h]
            mov         ebx,edx
            rol         edi,15h
            not         ebx
            add         edi,esi
            
            or          ebx,edi
            xor         ebx,esi
            add         ebx,dword ptr [ecx+30h]
            lea         eax,dword ptr [eax+ebx+655B59C3h]
            mov         ebx,esi
            rol         eax,6
            not         ebx
            add         eax,edi
            
            or          ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+0Ch]
            lea         edx,dword ptr [edx+ebx-70F3336Eh]
            rol         edx,0Ah
            add         edx,eax
            mov         ebx,edi
            not         ebx
            
            or          ebx,edx
            xor         ebx,eax
            add         ebx,dword ptr [ecx+28h]
            lea         esi,dword ptr [esi+ebx-100B83h]
            mov         ebx,eax
            rol         esi,0Fh
            not         ebx
            add         esi,edx
            
            or          ebx,esi
            xor         ebx,edx
            add         ebx,dword ptr [ecx+4]
            lea         edi,dword ptr [edi+ebx-7A7BA22Fh]
            mov         ebx,edx
            rol         edi,15h
            not         ebx
            add         edi,esi
            
            or          ebx,edi
            xor         ebx,esi
            add         ebx,dword ptr [ecx+20h]
            lea         eax,dword ptr [eax+ebx+6FA87E4Fh]
            mov         ebx,esi
            rol         eax,6
            not         ebx
            add         eax,edi
            
            or          ebx,eax
            xor         ebx,edi
            add         ebx,dword ptr [ecx+3Ch]
            lea         edx,dword ptr [edx+ebx-1D31920h]
            rol        edx,0Ah
            lea         ebx,dword ptr [eax+edx]
            mov         edx,edi
            not         edx
            
            or          edx,ebx
            xor         edx,eax
            add         edx,dword ptr [ecx+18h]
            lea         edx,dword ptr [esi+edx-5CFEBCECh]
            rol         edx,0Fh
            lea         esi,dword ptr [ebx+edx]
            mov         edx,eax
            not         edx
            
            or          edx,esi
            xor         edx,ebx
            add         edx,dword ptr [ecx+34h]
            lea         edx,dword ptr [edi+edx+4E0811A1h]
            rol         edx,15h
            lea         edi,dword ptr [esi+edx]
            mov         edx,ebx
            not         edx
            
            or          edx,edi
            xor         edx,esi
            add         edx,dword ptr [ecx+10h]
            lea         eax,dword ptr [eax+edx-8AC817Eh]
            rol         eax,6
            lea         edx,dword ptr [edi+eax]
            mov         eax,esi
            not         eax
            
            or          eax,edx
            xor         eax,edi
            add         eax,dword ptr [ecx+2Ch]
            lea         eax,dword ptr [ebx+eax-42C50DCBh]
            rol         eax,0Ah
            lea         ebx,dword ptr [edx+eax]
            mov         eax,edi
            not         eax
            
            or          eax,ebx
            xor         eax,edx
            add         eax,dword ptr [ecx+8]
            lea         eax,dword ptr [esi+eax+2AD7D2BBh]
            rol         eax,0Fh
            lea         esi,dword ptr [ebx+eax]
            mov         eax,edx
            not         eax
            
            or          eax,esi
            xor         eax,ebx
            add         eax,dword ptr [ecx+24h]
            lea         eax,dword ptr [edi+eax-14792C6Fh]
            mov         edi,dword ptr [esp+14h]
            rol         eax,15h
            add         eax,esi
            
            add         edx,dword ptr [edi]             // add in starting state
            add         eax,dword ptr [edi+4]
            add         esi,dword ptr [edi+8]
            add         ebx,dword ptr [edi+0Ch]
            
            pop         ebp
            mov         dword ptr [edi],edx             // store back new state
            mov         dword ptr [edi+4],eax
            mov         dword ptr [edi+8],esi
            mov         dword ptr [edi+0Ch],ebx

            pop         edi
            pop         esi
            pop         ebx
            ret         8
            }
        }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\mbschemawriter.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    MBSchemaWriter.cpp

$Header: $

Abstract:

--**************************************************************************/

class CMBSchemaWriter
{
	public:
		
		CMBSchemaWriter();
		~CMBSchemaWriter();

		void Initialize(CWriter* pcWriter);

		HRESULT GetCollectionWriter(LPWSTR				  i_wszTable,
									CMBCollectionWriter** o_pMBCollectionWriter);

		HRESULT AddCollectionWriter(CMBCollectionWriter*	i_pCMBCollectionWriter);

		HRESULT WriteSchema();

	private:

		HRESULT ReAllocate();

		CMBCollectionWriter**	m_apCollection;
		ULONG					m_cCollection;
		ULONG					m_iCollection;
		CWriter*				m_pCWriter;

} // CMBSchemaWriter


CMBSchemaWriter::CMBSchemaWriter:
m_aCollection(NULL),
m_cCollection(0),
m_iCollection(0),
m_pCWriter(NULL)
{

} // CMBSchemaWriter::CMBSchemaWriter


CMBSchemaWriter::~CMBSchemaWriter()
{
	if(NULL != m_aCollection)
	{
		for(ULONG i=0; i<m_iCollection; i++)
		{
			delete m_apCollection[i];
			m_apCollection[i] = NULL;
		}

		delete [] m_apCollection;
		m_apCollection = NULL;
	}

	m_cCollection = 0;
	m_iCollection = 0;

} // CMBSchemaWriter::~CMBSchemaWriter


void CMBSchemaWriter::Initialize(CWriter* i_pcWriter)
{
	m_pCWriter = i_pcWriter;

} // CMBSchemaWriter::Initialize


HRESULT CMBSchemaWriter::GetCollectionWriter(LPWSTR					i_wszTable,
										    CMBCollectionWriter**	o_pMBCollectionWriter)
{
	CMBCollectionWriter*	pCMBCollectionWriter = NULL;

	*o_pMBCollectionWriter = NULL;

	pCMBCollectionWriter = new CMBCollectionWriter();
	if(NULL == pCMBCollectionWriter)
	{
		return E_OUTOFMEMORY;
	}

	pCMBCollectionWriter->Initialize(i_wszTable,
	                                 m_pCWriter);

	*o_pMBCollectionWriter = pCMBCollectionWriter;

	return S_OK;

} // CMBSchemaWriter::GetCollectionWriter


HRESULT CSchemaWriter::AddCollectionWriter(CMBCollectionWriter*	i_pCMBCollectionWriter)
{
	HRESULT hr = S_OK;

	if(m_iCollection == m_cCollection)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	m_aCollection[m_iCollection++] = i_pCMBCollectionWriter;

	return hr;

} // CMBSchemaWriter::AddCollectionWriter


HRESULT CMBSchemaWriter::ReAllocate()
{
	CMBCollectionWriter** pSav = m_aCollection;

	m_aCollection = new CMBCollectionWriter*[m_cCollection + cMaxCCollection];
	if(NULL == m_aCollection)
	{
		return E_OUTOFMEMORY;
	}
	memset(m_aCollection, 0, (sizeof(CMBCollectionWriter*))*(m_cCollection + cMaxCCollection));

	if(NULL != pSav)
	{
		memcpy(m_aCollection, pSav, (sizeof(CMBCollectionWriter*))*(m_cCollection));
		delete [] pSav;
	}

	m_cCollection = m_cCollection + cMaxCCollection;

	return S_OK;

} // CMBSchemaWriter::ReAllocate


HRESULT CMBSchemaWriter::WriteSchema()
{
	HRESULT hr = S_OK;

	hr = BeginWriteSchema();

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_iCollection; i++)
	{
		hr = (m_aCollection[i])->WriteCollection();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	hr = EndWriteSchema();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CMBSchemaWriter::WriteSchema


HRESULT CMBSchemaWriter::BeginWriteSchema()
{
	HRESULT		hr      = S_OK;
	WCHAR*		wszTemp = g_wszTemp;

	if(g_cchBeginSchema+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[g_cchBeginSchema+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	memcpy(wszTemp, g_wszBeginSchema, (g_cchBeginSchema+1)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         g_cchBeginSchema);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CMBSchemaWriter::BeginWriteSchema


HRESULT CMBSchemaWriter::EndWriteSchema()
{
	HRESULT		hr      = S_OK;
	WCHAR*		wszTemp = g_wszTemp;

	if(g_cchEndSchema+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[g_cchBeginSchema+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	memcpy(wszTemp, g_wszEndSchema, (g_cchEndSchema+1)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         g_cchEndSchema);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CMBSchemaWriter::EndWriteSchema


class CMBCollectionWriter
{
	public:
		
		CMBCollectionWriter();
		~CMBCollectionWriter();

		HRESULT Initialize(LPCWSTR					i_wszTable,
			               CWriter*					i_pcWriter);

		HRESULT GetPropertyWriter(DWORD				     i_dwID,
								  CMBPropertyWriter**    o_pMBPropertyWriter);

		HRESULT AddProperty(CMBPropertyWriter*	i_pProperty);

		HRESULT WriteCollection();

	private:

		HRESULT ReAllocate();

		CWriter*					m_pCWriter;
		struct tTABLEMETARow*		m_pCollection;

		CMBPropertyWriter*			m_aProperty;
		ULONG						m_cProperty;
		ULONG						m_iProperty;
		CMBPropertyWriter**         m_aIndexToProperty;

} // CMBCollectionWriter


CMBCollectionWriter::CMBCollectionWriter():
m_pCWriter(NULL),
m_wszTable(NULL),
m_aProperty(NULL),
m_cProperty(0),
m_iProperty(0),
m_aIndexToProperty(NULL)
{

} // CCollectionWriter


CMBCollectionWriter::~CMBCollectionWriter()
{
	if(NULL != m_aProperty)
	{
		delete [] m_aProperty;
		m_aProperty = NULL;
	}
	m_cProperty = 0;
	m_iProperty = 0;

} // ~CCollectionWriter


void CCollectionWriter::Initialize(LPCWSTR		i_wszTable,
								   CWriter*		i_pcWriter)
{
	m_wszTable = i_wszTable;
	m_pCWriter = i_pcWriter;

} // CCollectionWriter::Initialize


HRESULT CMBCollectionWriter::GetMBPropertyWriter(DWORD					i_dwID,
											     CMBPropertyWriter**    o_pProperty)
{
	HRESULT hr = S_OK;

	if(NULL == m_aIndexToProperty) 
	{
		hr = GetNewMBPropertyWriter(i_dwID,
		                            o_pProperty);
	}
	else if((i_dwID > m_LargenstID) ||
			(NULL == m_aIndexToProperty[i_dwID])
		   )
	{
		hr = GetNewMBPropertyWriter(i_dwID,
		                            o_pProperty);

		if(SUCCEEDED(hr))
		{
			if(i_dwID > m_LargestID)
			{
				hr = ReAllocateIndex(i_dwID);
			}

			if(SUCCEEDED(hr))
			{
				m_aIndexToProperty[i_dwID] = *o_pProperty;
			}
		}
	}
	else
	{
		*o_pProperty = m_aIndexToProperty[i_dwID];
	}

	return hr;

} // CMBCollectionWriter::GetMBPropertyWriter


HRESULT CMBCollectionWriter::GetNewMBPropertyWriter(DWORD					i_dwID,
													CMBPropertyWriter**     o_pProperty)
{
	HRESULT hr = S_OK;

	if(m_iProperty == m_cProperty)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	m_aProperty[m_iProperty++].Initialize(i_dwID,
									      this,
	                                      m_pcWriter);

	*o_pProperty = &m_aProperty[m_iProperty-1];

	return hr;

} // CMBCollectionWriter::GetNewMBPropertyWriter


HRESULT CMBCollectionWriter::ReAllocate()
{
	CMBPropertyWriter* pSav = m_aProperty;

	m_aProperty = new CMBPropertyWriter[m_cProperty + cMaxProperty];
	if(NULL == m_aProperty)
	{
		return E_OUTOFMEMORY;
	}
	memset(m_aProperty, 0, (sizeof(CMBPropertyWriter))*(m_cProperty + cMaxProperty));

	if(NULL != pSav)
	{
		memcpy(m_aProperty, pSav, (sizeof(CMBPropertyWriter))*(m_cProperty));
		delete [] pSav;
	}

	m_cProperty = m_cProperty + cMaxProperty;

	return S_OK;

} // CMBCollectionWriter::ReAllocate


HRESULT CMBCollectionWriter::ReAllocateIndex(DWORD i_dwLargestID)
{
	CMBPropertyWriter** pSav = m_aIndexToProperty;

	m_aIndexToProperty = new CMBPropertyWriter*[i_dwLargestID];
	if(NULL == m_aIndexToProperty)
	{
		return E_OUTOFMEMORY;
	}
	memset(m_aIndexToProperty, 0, (sizeof(CMBPropertyWriter*))*(i_dwLargestID));

	if(NULL != pSav)
	{
		memcpy(m_aIndexToProperty, pSav, (sizeof(CMBPropertyWriter*))*(m_dwLargestID));
		delete [] pSav;
	}

	m_dwLargestID = i_dwLargestID;

	return S_OK;

} // CMBCollectionWriter::ReAllocateIndex


HRESULT CMBCollectionWriter::CreateIndex()
{
	HRESULT hr = S_OK;

	hr = ReAllocateIndex(m_dwLargestID);

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_iProperty; i++)
	{
		m_aIndexToProperty[m_aProperty[i]->m_dwID] = m_aProperty[i]
	}

	return hr;

} // CMBCollectionWriter::CreateIndex


HRESULT CMBCollectionWriter::WriteCollection()
{
	HRESULT hr = S_OK;

	hr = BeginWriteCollection();

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_iProperty; i++)
	{
		hr = m_aProperty[i]->WriteProperty();

		if(FAILED(hr))
		{
			return hr;
		}

	}

	hr = EndWriteCollection();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CMBCollectionWriter::WriteCollection

class CPropertyWriter
{
	public:
		
		CPropertyWriter();
		~CPropertyWriter();

		HRESULT Initialize(DWORD	i_dwID,
			               CWriter*	i_pcWriter);

		HRESULT AddNameToProperty(LPCWSTR       i_wszName);
		HRESULT AddTypeToProperty(PropValue*    i_wszType);
		HRESULT AddDefaultToProperty(BYTE*      i_bDefault,
		                             ULONG      i_cbDefault);

		HRESULT WriteProperty();

	public:
		DWORD                       m_dwID;

	private:

		HRESULT ReAllocate();

		CWriter*					m_pCWriter;
		LPCWSTR						m_wszName;
		PropValue*					m_pType;
		BYTE*						m_bDefault;
		ULONG                       m_cbDefault;
		
} // CPropertyWriter


CPropertyWriter::CPropertyWriter:
m_pCWriter(NULL),
m_dwID(0),
m_wszName(NULL),
m_pType(NULL),
m_bDefault(NULL),
m_cbDefault(0),
m_IsProperty(TRUE),
m_aFlag(NULL),
m_cFlag(0),
m_iFlag(0)
{

} // CPropertyWriter::CPropertyWriter


CPropertyWriter::~CPropertyWriter()
{
	if(NULL != m_aFlag)
	{
		delete [] m_aFlag;
		m_aFlag = NULL;
	}

	m_cFlag = 0;
	m_iFlag = 0;
	
} // CPropertyWriter::CPropertyWriter


void CPropertyWriter::Initialize(DWORD					i_dwID,
								 CMBCollectionWriter*	i_pCollection
			                     CWriter*				i_pcWriter)
{
	m_pCWriter		= i_pcWriter;
	m_dwID			= i_dwID;
	m_pCollection	= i_pCollection;

	return;

} // CPropertyWriter::Initialize


HRESULT CPropertyWriter::AddNameToProperty(DWORD	i_wszName)
{
	m_wszName  = i_wszName;

	return S_OK;

} // CPropertyWriter::Initialize


HRESULT CPropertyWriter::AddTypeToProperty(PropValue*	i_pType)
{
	HRESULT hr = S_OK;

	if(i_pType->dwMetaID != i_pType->dwPropID)
	{
		//
		// This is a flag. Add it as a flag to its property
		//
		
		//
		// TODO: Assert that the ID of this object is the same as the propID.
		//

		CMBPropertyWriter*	pPropertyWriter = NULL;

		hr = m_pCollection->GetMBPropertyWriter(i_pType->dwMetaID,
												&pPropertyWriter);

		if(FAILED(hr))
		{
			return hr;
		}

		hr = pPropertyWriter->GetMBFlagWriter(i_pType->dwPropID,
											  &pFlagWriter);
		if(FAILED(hr))
		{
			return hr;
		}

		pFlagWriter->AddNameToFlag(m_wszName);

		pFlagWriter->AddTypeToFlag(i_pType);

		m_IsProperty = FALSE;

	}
	else
	{
		m_pType = i_pType;
	}

	return S_OK;

} // CPropertyWriter::Initialize


HRESULT CPropertyWriter::AddDefaultToProperty(BYTE*      i_bDefault,
											  ULONG      i_cbDefault)
{
	m_bDefault = i_bDefault;
	m_cbDefault = i_cbDefault;

	return S_OK;

} // CPropertyWriter::Initialize


HREUSULT CPropertyWriter::GetMBFlagWriter(DWORD              i_dwPropID,
                                          CMBFlagWriter**    o_pCMBFlagWriter)
{
	//
	// ASSUMPTION: A meta ID will have only one occurance of a Prop ID. i.e. flag
	//

	HRESULT hr = S_OK;

	if(m_iFlag == m_cFlag)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	m_aFlag[m_iFlag++].Initialize(i_dwPropID,
                                  m_pcWriter);

	*o_pCMBFlagWriter = &m_aFlag[m_iFlag-1];

	return hr;

} // CPropertyWriter::GetMBFlagWriter


HRESULT CPropertyWriter::ReAllocate()
{
	CMBFlagWriter* pSav = m_aFlag;

	m_aFlag = new CMBFlagWriter[m_cFlag + cMaxFlag];
	if(NULL == m_aFlag)
	{
		return E_OUTOFMEMORY;
	}
	memset(m_aFlag, 0, (sizeof(CMBFlagWriter))*(m_cFlag + cMaxFlag));

	if(NULL != pSav)
	{
		memcpy(m_aFlag, pSav, (sizeof(CMBFlagWriter))*(m_cFlag));
		delete [] pSav;
	}

	m_cFlag = m_cFlag + cMaxFlag;

	return S_OK;

} // CPropertyWriter::ReAllocate


HRESULT CPropertyWriter::WritePropertyLong()
{
	HRESULT hr = S_OK;

	hr = BeginWritePropertyLong();

	if(FAILED(hr))
	{
		return hr;
	}

	if(NULL != m_aFlag)
	{	
		for(ULONG i=0; i<m_iFlag; i++)
		{
			hr = m_aFlag[i]->WriteFlag;

			if(FAILED(hr))
			{
				return hr;
			}
		}
	}

	hr = EndWritePropertyLong();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CPropertyWriter::WritePropertyLong


HRESULT CPropertyWriter::WritePropertyShort()
{
	HRESULT		hr      = S_OK;
	WCHAR*		wszTemp = g_wszTemp;
	WCHAR*      wszEnd  = NULL;

	ULONG       cchPropertyName = wcslen(m_pProperty->pInternalName);
	ULONG       cch = g_cchBeginPropertyShort +
	                  cchPropertyName
					  g_cchEndPropertyShort;
	                  
	if(cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	wszEnd = wszTemp;
	memcpy(wszEnd, g_wszBeginPropertyShort, (g_cchBeginPropertyShort)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginPropertyShort;
	memcpy(wszEnd, m_pProperty->pInternalName, (cchPropertyName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchPropertyName;
	if(fCOLUMNMETA_MANDATORY & m_pProperty->pSchemaGeneratorFlags)
	{
		//
		// TODO: Fetch the mandatory flag from the schema.
		//

		memcpy(wszEnd, g_wszMetaFlagsExEq, (g_cchMetaFlagsExEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMetaFlagsExEq;

	}
	memcpy(wszEnd, g_wszEndPropertyShort, (g_cchEndPropertyShort)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CPropertyWriter::WritePropertyShort


HRESULT CPropertyWriter::WriteProperty()
{
	HRESULT hr = S_OK;

	if(0 == wcscmpi(m_pCollection->Name(), wszTABLE_IIsConfigObject))
	{
		hr = WritePropertyLong();
	}
	else 
	{
		hr = WritePropertyShort();
	}

	return hr;

} // CPropertyWriter::WriteProperty


HRESULT CPropertyWriter::BeginWritePropertyLong()
{
	HRESULT		hr              = S_OK;
	WCHAR*		wszTemp         = g_wszTemp;
	WCHAR*      wszEnd          = NULL;
	ULONG       cchPropertyName = 0;
	WCHAR       wszID[25]       = NULL;
	ULONG       cchID           = 0;
	WCHAR*      wszType         = NULL;
	ULONG       cchType         = 0;
	WCHAR*      wszUserType     = NULL;
	ULONG       cchUserType     = 0;
	WCHAR*      wszAttribute    = NULL;
	ULONG       cchAttribute    = 0;
	WCHAR*      wszMetaFlags    = NULL;
	ULONG       cchMetaFlags    = 0;
	WCHAR*      wszMetaFlagsEx  = NULL;
	ULONG       cchMetaFlagsEx  = 0;
	WCHAR*      wszDefault      = NULL;
	ULONG       cchDefault      = 0;
	WCHAR*      wszMin          = NULL;
	ULONG       cchMin          = 0;
	WCHAR*      wszMax          = NULL;
	ULONG       cchMax          = 0;

	//
	// Compute the individual strings and lengths.
	//

	//
	// Name
	//

	cchPropertyName = wcslen(m_pProperty->pInternalName);

	//
	// ID
	// 

	wszID[0] = 0;
	_itow(*(m_pProperty->pID), wszID, 10);
	cchID = wcslen(wszID);

	//
	// Type
	//

	hr = m_pCWriterGlobalHelper->GetTypeTag(*(m_pProperty->pType),
	                                        &wszType);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchType = wcslen(wszType);

	//
	// UserType
	//

	hr = m_pCWriterGlobalHelper->GetUserTypeTag(*(m_pProperty->pUserType),
	                                            &wszUserType);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchUserType = wcslen(wszUserType);

	//
	// Attribute
	//

	hr = m_pCWriterGlobalHelper->GetAttributeTag(*(m_pProperty->pAttributes),
	                                             &wszAttribute);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchUserType = wcslen(wszUserType);

	//
	// MetaFlags (only the relavant ones - PRIMARYKEY, BOOL, MULTISTRING, EXPANDSTRING)
	//

	hr = m_pCWriterGlobalHelper->GetMetaFlagsTag(*(m_pProperty->pMetaFlags),
	                                             &wszMetaFlags);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchMetaFlags = wcslen(wszMetaFlags);

	//
	// MetaFlagsEx (only the relavant ones - CACHE_PROPERTY_MODIFIED, CACHE_PROPERTY_CLEARED, EXTENDEDTYPE0-3)
	//

	hr = m_pCWriterGlobalHelper->GetMetaFlagsExTag(*(m_pProperty->pMetaFlagsEx),
	                                               &wszAttribute);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchMetaFlags = wcslen(wszMetaFlagsEx);

	//
	// DefaultValue
	//

	hr = m_pCWriterGlobalHelper->ToString(m_pProperty->pDefaultValue,
	                                      m_pProperty->pSize,
										  m_pProperty,
										  &wszDefaultValue);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchMetaFlags = wcslen(wszMetaFlagsEx);

	//
	// Confirm that the total length is less than buffer. If not, reallocate.
	//

	ULONG       cch = g_cchBeginPropertyLong +
	                  cchPropertyName + 
					  g_cchIDEq + 
					  cchID + 
					  g_cchTypeEq +
					  cchType + 
					  g_cchUserTypeEq +
					  cchUserType + 
					  g_cchAttributeEq + 
					  cchAttribute + 
					  g_cchMetaFlagsEq +
					  cchMetaFlags + 
					  g_cchMetaFlagsExEq + 
					  cchMetaFlagsEx
					  g_cchDefaultEq + 
					  cchDefault + 
					  g_cchMinValueEq + 
					  cchMinValue + 
					  g_cchMaxValueEq + 
					  cchMaxValue + 
					  g_cchEndPropertyLongBeforeFlag;
	                  
	if(cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	//
	// Construct the string.
	//

	wszEnd = wszTemp;
	memcpy(wszEnd, g_wszBeginPropertyLong, (g_cchBeginPropertyLong)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginPropertyLong;
	memcpy(wszEnd, m_pProperty->pInternalName, (cchPropertyName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchPropertyName;
	memcpy(wszEnd, g_wszIDEq, (g_cchIDEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchIDEq;
	memcpy(wszEnd, wszID, (cchID)*sizeof(WCHAR));
	wszEnd = wszEnd + cchID;
	memcpy(wszEnd, g_wszTypeEq, (g_cchTypeEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchTypeEq;
	memcpy(wszEnd, wszType, (cchType)*sizeof(WCHAR));
	wszEnd = wszEnd + cchType;
	memcpy(wszEnd, g_wszUserTypeEq, (g_cchUserTypeEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchUserTypeEq;
	memcpy(wszEnd, wszUserType, (cchUserType)*sizeof(WCHAR));
	wszEnd = wszEnd + cchUserType;
	if(NULL != wszAttributes)
	{
		memcpy(wszEnd, g_wszAttributeEq, (g_cchAttributeEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchAttributeEq;
		memcpy(wszEnd, wszAttributes, (cchAttributes)*sizeof(WCHAR));
		wszEnd = wszEnd + cchAttributes;
	}
	if(NULL != wszMetaFlags)
	{
		memcpy(wszEnd, g_wszMetaFlagsEq, (g_cchMetaFlagsEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMetaFlagsEq;
		memcpy(wszEnd, wszMetaFlags, (cchMetaFlags)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlags;
	}
	if(NULL != wszMetaFlagsEx)
	{
		memcpy(wszEnd, g_wszMetaFlagsExEq, (g_cchMetaFlagsExEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMetaFlagsExEq;
		memcpy(wszEnd, wszMetaFlagsEx, (cchMetaFlagsEx)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlagsEx;
	}
	if(NULL != wszDefault)
	{
		memcpy(wszEnd, g_wszDefaultEq, (g_cchDefaultEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchDefaultEq;
		memcpy(wszEnd, wszDefault, (cchDefault)*sizeof(WCHAR));
		wszEnd = wszEnd + cchDefault;
	}
	if(NULL != wszMinValue)
	{
		memcpy(wszEnd, g_wszMinValueEq, (g_cchMinValueEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMinValueEq;
		memcpy(wszEnd, wszMinValue, (cchMinValue)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMinValue;
	}
	if(NULL != wszMaxValue)
	{
		memcpy(wszEnd, g_wszMaxValueEq, (g_cchMaxValueEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMaxValueEq;
		memcpy(wszEnd, wszMaxValue, (cchDefault)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMaxValue;
	}
	if(NULL != m_apFlag)
	{
		memcpy(wszEnd, g_wszEndPropertyLongBeforeFlag, (g_cchEndPropertyLongBeforeFlag)*sizeof(WCHAR));
	}

	//
	// Write the string into the file.
	//

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CPropertyWriter::BeginWritePropertyLong


class CFlagWriter
{
	public:
		
		CFlagWriter();
		~CFlagWriter();

		HRESULT Initialize(DWORD	i_dwPropID,
			               CWriter*	i_pcWriter);

		HRESULT AddTypeToFlag(PropValue*    i_wszType);

		HRESULT WriteFlag();

	private:

		HRESULT ReAllocate();
		CWriter*					m_pCWriter;
		ULONG                       m_dwPropID;
		PropValue*				    m_pType;
		LPCWSTR						m_wszName;
		
} // CFlagWriter


CFlagWriter::CFlagWriter():
m_pCWriter(NULL),
m_dwPropID(0),
m_pType(NULL),
m_wszName(NULL)
{

} // CFlagWriter::CFlagWriter


CFlagWriter::~CFlagWriter()
{

} // CFlagWriter::~CFlagWriter

void CFlagWriter::Initialize(DWORD		i_dwPropID,
							CWriter*	i_pcWriter)
{
	m_dwPropID = i_dwPropID;
	m_pCWriter = i_pcWriter;

} // CFlagWriter::Initialize

void CFlagWriter::AddNameToFlag(LPCWSTR    i_wszName)
{
	m_wszName = i_wszName;

} // CFlagWriter::AddTypeToFlag

void CFlagWriter::AddTypeToFlag(PropValue*    i_wszType)
{
	m_pType = i_wszType;

} // CFlagWriter::AddTypeToFlag


HRESULT CFlagWriter::WriteFlag()
{
	HRESULT					hr      = S_OK;
	WCHAR*					wszTemp = g_wszTemp;
	WCHAR*					wszEnd  = NULL;
	WCHAR                   wszValue[25];
	ULONG					cchFlagName = 0;
	ULONG					cchValue = 0;
	ULONG					cch      = 0;

	cchFlagName = wcslen(m_wszName);
	
	wszValue[0] = 0;
	_itow(*(m_pType->dwMask), wszValue, 10);
	cchValue  = wcslen(wszValue);

	cch = g_cchBeginFlag +
		  cchFlagName + 
		  g_cchValueEq +
		  cchValue + 
		  g_cchEndFlag;
	                  
	if(cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	wszEnd = wszTemp;
	memcpy(wszEnd, g_wszBeginFlag, (g_cchBeginFlag)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginFlag;
	memcpy(wszEnd, m_wszName, (cchFlagName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchFlagName;
	memcpy(wszEnd, g_wszValueEq, (g_cchValueEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchValueEq;
	memcpy(wszEnd, wszValue, (cchValue)*sizeof(WCHAR));
	wszEnd = wszEnd + cchValue;
	memcpy(wszEnd, g_wszEndFlag, (g_cchEndFlag)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CFlagWriter::WriteFlag
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\guidfromname.cpp ===
// GuidFromName

// Algorithm from Internet Draft document "UUIDs and GUIDs"
// By Paul J. Leach and Rich Sals, February 4, 1998.

// This function has been adapted from the routines in the document
//	uuid_create_from_name and format_uuid_v3

// Changes from documented routines:
// 1. Changed all instances of uuid_t to GUID.
//		uuid_t field time_low is GUID field Data1.
//		uuid_t field time_mid is GUID field Data2.
//		uuid_t field time_hi_and_version is GUID field Data3.
//		uuid_t field clock_seq_hi_and_reserved is GUID field Data4[0].
//		uuid_t field clock_seq_low is GUID field Data4[1].
//		uuid_t field node[6] is GUID field Data4[2] through Data4[8].
//
// 2. Use a c++ implementation of the md5 cryptographic hash function.
//
// 3. Implemented the htonl, htons, ntohl, ntohs socket routines as inlines.
//
// 4. Renamed variables and types to suit my biases.

/*
** Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
** Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &
** Digital Equipment Corporation, Maynard, Mass.
** Copyright (c) 1995-1999 Microsoft.  All rights reserved.
** To anyone who acknowledges that this file is provided "AS IS"
** without any express or implied warranty: permission to use, copy,
** modify, and distribute this file for any purpose is hereby
** granted without fee, provided that the above copyright notices and
** this notice appears in all source code copies, and that none of
** the names of Open Software Foundation, Inc., Hewlett-Packard
** Company, or Digital Equipment Corporation be used in advertising
** or publicity pertaining to distribution of the software without
** specific, written prior permission.  Neither Open Software
** Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital Equipment
** Corporation makes any representations about the suitability of
** this software for any purpose.
*/

#include <windows.h>				// windows standard includes
#include <wtypes.h>
#include <md5.h>				// cryptographic hash function
#include <GuidFromName.h>		// verify our function signature

// Figure out if we're compiling for a big- or little-endian machine.
// This is evaluated at compile time in retail builds.

inline bool BigEndian()
{
	unsigned long n = 0xff000000L;

	return 0 != *reinterpret_cast<unsigned char *>(&n);
}

//=============================================================================
// htons, htonl, ntohs, ntohl equivalents copied and adapted from socket library.
//=============================================================================

// HostToNetworkLong converts a 32-bit long to network byte order

inline ULONG HostToNetworkLong(ULONG hostlong)
{
	if (BigEndian())
		return hostlong;
	else
		return	( (hostlong >> 24) & 0x000000FFL) |
				( (hostlong >>  8) & 0x0000FF00L) |
				( (hostlong <<  8) & 0x00FF0000L) |
				( (hostlong << 24) & 0xFF000000L);
}

// HostToNetworkLong converts a 16-bit short to network byte order

inline USHORT HostToNetworkShort(USHORT hostshort)
{
	if (BigEndian())
		return hostshort;
	else
		return ((hostshort >> 8) & 0x00FF) | ((hostshort << 8) & 0xFF00);
}

// NetworkToHostLong converts a 32-bit long to local host byte order

inline ULONG NetworkToHostLong(ULONG netlong)
{
	if (BigEndian())
		return netlong;
	else
		return	( (netlong >> 24) & 0x000000FFL) |
				( (netlong >>  8) & 0x0000FF00L) |
				( (netlong <<  8) & 0x00FF0000L) |
				( (netlong << 24) & 0xFF000000L);
}

// NetworkToHostShort converts a 16-bit short to local host byte order

inline USHORT NetworkToHostShort(USHORT netshort)
{
	if (BigEndian())
		return netshort;
	else
		return ((netshort >> 8) & 0x00FF) | ((netshort << 8) & 0xFF00);
}

//=============================================================================
// GuidFromName(GUID * pGuidResult, REFGUID refGuidNsid, 
//				const void * pvName, DWORD dwcbName);
//=============================================================================

void GuidFromName
(
	GUID *	pGuidResult,		// resulting GUID
	REFGUID	refGuidNsid,		// Name Space GUID, so identical names from
								// different name spaces generate different GUIDs
	const void * pvName,		// the name from which to generate a GUID
	DWORD dwcbName				// name length in bytes
)
{
	MD5			md5;			// Cryptographic hash class instance
	MD5HASHDATA	md5HashData;	// 128-bit hash result
	GUID		guidNsid;		// context NameSpace GUID in network byte order


	// put name space ID in network byte order so it hashes the same
	// no matter what endian machine we're on

	guidNsid = refGuidNsid;

	// The sample code in the IETF draft document discards the result of
	// htonl and htons.  I've implemented what I think is meant and I've
	// sent a note to the author asking for confirmation that this is
	// his intent.

	if (!BigEndian())	// evaluated at compile time in retail builds
	{
		guidNsid.Data1 = HostToNetworkLong (guidNsid.Data1);
		guidNsid.Data2 = HostToNetworkShort(guidNsid.Data2);
		guidNsid.Data3 = HostToNetworkShort(guidNsid.Data3);
	}

	md5.Init();
	md5.HashMore(&guidNsid, sizeof(GUID));
	md5.HashMore(pvName, dwcbName);
	md5.GetHashValue(&md5HashData);

	// the hash is in network byte order at this point

	memcpy(pGuidResult, &md5HashData, sizeof(GUID));

	// Remainder adapted from function "format_uuid_v3" in IETF draft document

	// Construct a version 3 uuid with the pseudo-random number plus a few constants.

	// convert GUID from network order to local byte order

	if (!BigEndian())	// evaluated at compile time in retail builds
	{
		pGuidResult->Data1 = NetworkToHostLong (pGuidResult->Data1);
		pGuidResult->Data2 = NetworkToHostShort(pGuidResult->Data2);
		pGuidResult->Data3 = NetworkToHostShort(pGuidResult->Data3);
	}

	// set version number 
	pGuidResult->Data3 &= 0x0FFF;	// clear version number nibble
	pGuidResult->Data3 |= (3 << 12);// set version 3 = name-based

	// set variant field
	pGuidResult->Data4[0] &= 0x3F;	// clear variant bits
	pGuidResult->Data4[0] |= 0x80;	// set variant = 100b
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\stackdlg.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
// StackDlg.cpp : Implementation of CStackDlg
//#include "stdafx.h"
#include <unicode.h>
#include <windows.h>
#include "StackDlg.h"

extern HMODULE g_hModule;  // from catinproc.cpp
extern BOOL    g_bOnWinnt; // from createdispenser.cpp

CStackDlg::CStackDlg(WCHAR * szMsg)
{
	m_szMsg = szMsg;
}

CStackDlg::~CStackDlg()
{
}

LONG_PTR CStackDlg::DoModal()
{

	if ( !g_bOnWinnt || (g_bOnWinnt && SwitchToInteractiveDesktop()) )
	{
		// HINSTANCE hInst = LoadLibraryEx(L"catalog.dll", NULL, 0);
		LONG_PTR nRet = DialogBoxParam(g_hModule, MAKEINTRESOURCE(IDD), NULL, (DLGPROC) StackDlgProc, (LPARAM)m_szMsg);
		// FreeLibrary(hInst);
		ResetDesktop();
		return nRet;
	}

	return -1;


}


LONG_PTR CStackDlg::StackDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{

	switch (msg)
	{
		case WM_INITDIALOG:
			SetDlgItemText(hDlg, IDC_MSG, (WCHAR *)lParam);
			CStackDlg::CenterWindow(hDlg);
			
			break;
		case WM_COMMAND:
		{
			if (HIWORD(wParam) == BN_CLICKED)
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
		}
		break;
		default:
			break;
	}


	return FALSE;
}

BOOL CStackDlg::CenterWindow(HWND hWnd)
{
	
	HWND hWndParent = GetDesktopWindow();

	// get coordinates of the window relative to its parent
	RECT rcDlg;
	::GetWindowRect(hWnd, &rcDlg);
	RECT rcArea;
	RECT rcCenter;

	::GetClientRect(hWndParent, &rcArea);
	::GetClientRect(hWndParent, &rcCenter);
	::MapWindowPoints(hWndParent, hWndParent, (POINT*)&rcCenter, 2);

	int DlgWidth = rcDlg.right - rcDlg.left;
	int DlgHeight = rcDlg.bottom - rcDlg.top;

	// find dialog's upper left based on rcCenter
	int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
	int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

	// if the dialog is outside the screen, move it inside
	if(xLeft < rcArea.left)
		xLeft = rcArea.left;
	else if(xLeft + DlgWidth > rcArea.right)
		xLeft = rcArea.right - DlgWidth;

	if(yTop < rcArea.top)
		yTop = rcArea.top;
	else if(yTop + DlgHeight > rcArea.bottom)
		yTop = rcArea.bottom - DlgHeight;

	// map screen coordinates to child coordinates
	return ::SetWindowPos(hWnd, HWND_TOP, xLeft, yTop, -1, -1, SWP_NOSIZE);
}

BOOL CStackDlg::SwitchToInteractiveDesktop()
{
 
	//  
	// Save the current Window station      
	//
    m_hwinstaCurrent = GetProcessWindowStation();
    if (m_hwinstaCurrent == NULL)
		return FALSE;      
	//      
	// Save the current desktop      
	//
      
	m_hdeskCurrent = GetThreadDesktop(GetCurrentThreadId());
      
	if (m_hdeskCurrent == NULL)         
		  return FALSE;

    //
    // If we already are running in winsta0, 
    // do nothing else.  This means we're
    // not running in a service.
    //
    ULONG   lNeededLength;
    wchar_t wszTemp[10];
    GetUserObjectInformation(m_hwinstaCurrent, UOI_NAME, wszTemp, 20, &lNeededLength);
    if(lNeededLength <= 20 && _wcsicmp(wszTemp, L"winsta0") == 0)
        return true;

	//
	// Obtain a handle to WinSta0 - service must be running
	// in the LocalSystem account      
	//
	m_hwinsta = OpenWindowStation(L"winsta0", FALSE,
							  WINSTA_ACCESSCLIPBOARD   |
							  WINSTA_ACCESSGLOBALATOMS |
							  WINSTA_CREATEDESKTOP     |
							  WINSTA_ENUMDESKTOPS      |
							  WINSTA_ENUMERATE         |
							  WINSTA_EXITWINDOWS       |
							  WINSTA_READATTRIBUTES    |
							  WINSTA_READSCREEN        |
							  WINSTA_WRITEATTRIBUTES);
	if (m_hwinsta == NULL)
	  return FALSE;      
	//
	// Set the windowstation to be winsta0      
	//
	if (!SetProcessWindowStation(m_hwinsta))         
	  return FALSE;      
	//
	// Get the desktop      
	//
	m_hdeskTest = GetThreadDesktop(GetCurrentThreadId());

	if (m_hdeskTest == NULL)
	  return FALSE;      
	//
	// Get the default desktop on winsta0      
	//
	m_hDesk = OpenDesktop(L"default", 0, FALSE,
						DESKTOP_CREATEWINDOW |
						DESKTOP_SWITCHDESKTOP |
						DESKTOP_WRITEOBJECTS);   
	if (m_hDesk == NULL)
	   return FALSE;   
	//   
	// Set the desktop to be "default"   
	//
	if (!SetThreadDesktop(m_hDesk))
	return FALSE;   


return TRUE;
  
}

BOOL CStackDlg::ResetDesktop()
{
	if (!SetProcessWindowStation(m_hwinstaCurrent))           
	   return FALSE;
   if (!SetThreadDesktop(m_hdeskCurrent))      
	   return FALSE;   //
   // Close the windowstation and desktop handles   //
   if (!CloseWindowStation(m_hwinsta))      
	   return FALSE;
   if (!CloseDesktop(m_hDesk))           
	   return FALSE;      
   return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\locationwriter.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    LocationWriter.cpp

$Header: $

Abstract:


--**************************************************************************/

#include "catalog.h"
#include "catmeta.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "LocationWriter.h"
#include "WriterGlobals.h"
#include "mddefw.h"
#include "iiscnfg.h"
#include "wchar.h"

typedef struct _MBProperty
{	
	LPWSTR wszPropertyName;
	ULONG  iRow;
} MBProperty;

typedef MBProperty* PMBProperty;

int _cdecl MyCompare(const void *a,
			         const void *b)
{
	return wcscmp(((PMBProperty)a)->wszPropertyName, ((PMBProperty)b)->wszPropertyName);
}

CLocationWriter::CLocationWriter()
{
	m_wszKeyType = NULL;
	m_pISTWrite = NULL;
	m_pCWriter = NULL;
	m_pCWriterGlobalHelper = NULL;
	m_wszLocation = NULL;

} // CLocationWriter::CLocationWriter


CLocationWriter::~CLocationWriter()
{
	if(NULL != m_wszKeyType)
	{
		delete [] m_wszKeyType;
		m_wszKeyType = NULL;
	}

	if(NULL != m_pISTWrite)
	{
		m_pISTWrite->Release();
		m_pISTWrite = NULL;
	}

	if(NULL != m_wszLocation)
	{
		delete [] m_wszLocation;
		m_wszLocation = NULL;
	}

} // CLocationWriter::CLocationWriter


HRESULT CLocationWriter::Initialize(CWriter* pCWriter,
									LPCWSTR  wszLocation)
{
	ISimpleTableDispenser2*		pISTDisp      = NULL;
	IAdvancedTableDispenser*	pISTAdvanced  = NULL;
	HRESULT                     hr            = S_OK;

	if(NULL != m_pISTWrite)
		return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

	if(FAILED(hr))
		goto exit;

	hr = pISTDisp->QueryInterface(IID_IAdvancedTableDispenser, (LPVOID*)&pISTAdvanced);
	
	if(FAILED(hr))
		goto exit;

	hr = pISTAdvanced->GetMemoryTable(wszDATABASE_METABASE, 
		                              wszTABLE_MBProperty, 
								      0, 
								      NULL, 
								      NULL, 
								      eST_QUERYFORMAT_CELLS, 
								      fST_LOS_READWRITE, 
								      &m_pISTWrite);

	if (FAILED(hr))
		goto exit;

	m_pCWriter = pCWriter;

	m_wszLocation = new WCHAR[wcslen(wszLocation)+1];
	if(NULL == m_wszLocation)
		hr = E_OUTOFMEMORY;
	else
		wcscpy(m_wszLocation, wszLocation);

	m_pCWriterGlobalHelper = m_pCWriter->m_pCWriterGlobalHelper;

exit:

	if(NULL != pISTAdvanced)
	{
		pISTAdvanced->Release();
		pISTAdvanced = NULL;
	}

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
		pISTDisp = NULL;
	}
	
	return hr;

} // CLocationWriter::Initialize


HRESULT CLocationWriter::InitializeKeyType(DWORD	dwKeyTypeID,
										   DWORD	dwKeyTypeAttributes,
										   DWORD	dwKeyTypeUserType,
										   DWORD	dwKeyTypeDataType,
										   PBYTE	pbKeyTypeValue,
										   DWORD	cbKeyType)
{
	HRESULT hr = S_OK;

	if(NULL != m_wszKeyType)
		return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);

	if(NULL == pbKeyTypeValue)
	{
		//
		// If KeyType is NULL then assign IIsConfigObject
		//
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto exit;
	}

	if((dwKeyTypeAttributes == *(DWORD*)((m_pCWriterGlobalHelper->m_apvKeyTypeMetaData)[iCOLUMNMETA_Attributes])) &&
	        (dwKeyTypeUserType   == *(DWORD*)((m_pCWriterGlobalHelper->m_apvKeyTypeMetaData)[iCOLUMNMETA_UserType])) &&
	        (dwKeyTypeDataType   == GetMetabaseType(*(DWORD*)(m_pCWriterGlobalHelper->m_apvKeyTypeMetaData[iCOLUMNMETA_Type]),
													*(DWORD*)(m_pCWriterGlobalHelper->m_apvKeyTypeMetaData[iCOLUMNMETA_MetaFlags])
			                                       )
			)
	       )
	{
		hr = AssignKeyType((LPWSTR)pbKeyTypeValue);
		
		if(FAILED(hr))
			goto exit;

	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto exit;
	}
	
exit:

	if(FAILED(hr))
	{
		//
		// TODO: Log error that KeyType could  not be initialized,
		//       and default  it to IIsConfigObject.
		//

		hr = AssignKeyType(NULL);

	}
	
	return hr;

} // CLocationWriter::InitializeKeyType


HRESULT CLocationWriter::AssignKeyType(LPWSTR wszKeyType)
{
	HRESULT hr = S_OK;
	eMBProperty_Group eGroup;

	if(NULL != m_wszKeyType)
	{
		delete [] m_wszKeyType;
		m_wszKeyType = NULL;
	}

	if(NULL == wszKeyType)
	{
		wszKeyType = wszTABLE_IIsConfigObject;
		m_eKeyTypeGroup = eMBProperty_IIsConfigObject;
	}
	else
	{
		hr = GetGroupEnum(wszKeyType,
						  &eGroup);

		if(FAILED(hr))
			return hr;

		if(eMBProperty_Custom == eGroup)
		{
			wszKeyType = wszTABLE_IIsConfigObject;
			m_eKeyTypeGroup = eMBProperty_IIsConfigObject;
		}
		else
			m_eKeyTypeGroup = eGroup;
	}
		
	m_wszKeyType = new WCHAR [wcslen(wszKeyType)+1];
	if(NULL == m_wszKeyType)
		return E_OUTOFMEMORY;
	wcscpy(m_wszKeyType, wszKeyType);

	return hr;

} // CLocationWriter::AssignKeyType

HRESULT CLocationWriter::AddProperty(DWORD	dwID,
									 DWORD	dwAttributes,
									 DWORD	dwUserType,
									 DWORD	dwDataType,
									 PBYTE	pbData,
									 DWORD  cbData)
{
	HRESULT             hr                = S_OK;
	ULONG               iStartRow         = 0;
	ULONG               aColSearchName[]  = {iCOLUMNMETA_Table,
		                                     iCOLUMNMETA_ID
		                                    };
	ULONG               cColSearchName    = sizeof(aColSearchName)/sizeof(ULONG);
	LPVOID apvSearchName[cCOLUMNMETA_NumberOfColumns];
	apvSearchName[iCOLUMNMETA_Table]      = (LPVOID)m_pCWriterGlobalHelper->m_wszTABLE_IIsConfigObject;
	apvSearchName[iCOLUMNMETA_ID]         = (LPVOID)&dwID;
	ULONG               aColSearchGroup[] = {iCOLUMNMETA_Table,
		                                     iCOLUMNMETA_ID
		                                    };
	ULONG               cColSearchGroup   = sizeof(aColSearchGroup)/sizeof(ULONG);
	LPVOID apvSearchGroup[cCOLUMNMETA_NumberOfColumns];
	apvSearchGroup[iCOLUMNMETA_Table]     = (LPVOID)m_wszKeyType;
	apvSearchGroup[iCOLUMNMETA_ID]        = (LPVOID)&dwID;
	ULONG               iColColumnMeta    = {iCOLUMNMETA_InternalName};
	LPWSTR              wszColumnName     = NULL;
	ULONG               iRow              = 0;
	LPWSTR              wszName           = NULL;
	LPWSTR              wszUnknownName    = NULL;
	eMBProperty_Group	eGroup;
	ULONG               aColWrite[]       = {iMBProperty_Name,
                                             iMBProperty_Type,
                                             iMBProperty_Attributes,
                                             iMBProperty_Value,
                                             iMBProperty_Group,
                                             iMBProperty_ID,
                                             iMBProperty_UserType,
											};
	ULONG               cColWrite         = sizeof(aColWrite)/sizeof(ULONG);
	ULONG               acbSizeWrite[cMBProperty_NumberOfColumns];          
	LPVOID              apvWrite[cMBProperty_NumberOfColumns];          
	DWORD               iWriteRow         = 0;


	if((NULL == m_wszKeyType) || (NULL == m_pISTWrite))
		return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);	// TODO: Need to return a better error code if this function is called out of order

	if((MD_KEY_TYPE == dwID) &&
	   (m_eKeyTypeGroup != eMBProperty_IIsConfigObject)
	  )
		return S_OK; // Do not add KeyType, if it is a well-known KeyType.

	//
	// Fetch the Name for this ID
	//

	hr = (m_pCWriterGlobalHelper->m_pISTColumnMeta)->GetRowIndexBySearch(iStartRow, 
											                             cColSearchName, 
																	     aColSearchName,
																		 NULL, 
																		 apvSearchName,
																		 &iRow);

	if(E_ST_NOMOREROWS == hr)
	{
		hr  = CreateUnknownName(dwID,
								&wszUnknownName);

		if(FAILED(hr))
			goto exit;

		wszName = wszUnknownName;
	}
	else if(FAILED(hr))
		goto exit;
	else
	{
		hr = (m_pCWriterGlobalHelper->m_pISTColumnMeta)->GetColumnValues(iRow,
																	     1,
																		 &iColColumnMeta,
																		 NULL,
																		 (LPVOID*)&wszColumnName);

		if(E_ST_NOMOREROWS == hr)
		{
			hr  = CreateUnknownName(dwID,
									&wszUnknownName);

			if(FAILED(hr))
				goto exit;

			wszName = wszUnknownName;

		}
		else if(FAILED(hr))
			goto exit;
		else
			wszName = wszColumnName;

	}

	//
	// Compute the group for this ID.
	//

	if(eMBProperty_IIsConfigObject == m_eKeyTypeGroup)
	{
		//
		// If the KeyType is IIsConfigObject, then directly assign custom group for this ID.
		//

		eGroup = eMBProperty_Custom;

	}
	else
	{
		//
		// 	Check if this ID belogs to its KeyType collection.
		//

		hr = (m_pCWriterGlobalHelper->m_pISTColumnMeta)->GetRowIndexBySearch(iStartRow, 
																		     cColSearchGroup, 
																			 aColSearchGroup,
																			 NULL, 
																			 apvSearchGroup,
																			 &iRow);

		if(E_ST_NOMOREROWS == hr)
			eGroup = eMBProperty_Custom ;
		else if(FAILED(hr))
			goto exit;
		else
		{
			//
			// Match the type, usertype, and attributes of this property.
			// Assign to KeyType group only if they match. Else assign
			// to custom.
			//
			ULONG aColMetaInfo[] = {iCOLUMNMETA_Type,
									iCOLUMNMETA_MetaFlags,
									iCOLUMNMETA_UserType,
									iCOLUMNMETA_Attributes
								   };

			ULONG cColMetaInfo = sizeof(aColMetaInfo)/sizeof(ULONG);
			LPVOID apvMetaInfo[cCOLUMNMETA_NumberOfColumns];

			hr = (m_pCWriterGlobalHelper->m_pISTColumnMeta)->GetColumnValues(iRow,
																		     cColMetaInfo,
																			 aColMetaInfo,
																			 NULL,
																			 apvMetaInfo);
			if(FAILED(hr))
				goto exit;

			if((dwUserType == *(DWORD*)apvMetaInfo[iCOLUMNMETA_UserType]) &&
			   (dwAttributes == *(DWORD*)apvMetaInfo[iCOLUMNMETA_Attributes]) && 
			   (dwDataType == GetMetabaseType(*(DWORD*)apvMetaInfo[iCOLUMNMETA_Type],
										  *(DWORD*)apvMetaInfo[iCOLUMNMETA_MetaFlags])
			   )
			  )
			{			
				eGroup = m_eKeyTypeGroup;
			}
			else
				eGroup = eMBProperty_Custom;		

		}
	}

	//
	// Save the property to the table. 
	//

//	dwType = GetMBPropertyType(dwDataType);

	if(0 == cbData)
		pbData = NULL;  // TODO: Debug this special case. sometimes pbData was valid when cbData was 0 and it was asserting.

	apvWrite[iMBProperty_Name]       = (LPVOID)wszName;
	apvWrite[iMBProperty_Type]       = (LPVOID)&dwDataType;
	apvWrite[iMBProperty_Attributes] = (LPVOID)&dwAttributes;
	apvWrite[iMBProperty_Value]      = (LPVOID)pbData;
	apvWrite[iMBProperty_Group]      = (LPVOID)&eGroup;
	apvWrite[iMBProperty_Location]   = (LPVOID)NULL;
	apvWrite[iMBProperty_ID]         = (LPVOID)&dwID;
	apvWrite[iMBProperty_UserType]   = (LPVOID)&dwUserType;
	apvWrite[iMBProperty_LocationID] = (LPVOID)NULL;

	acbSizeWrite[iMBProperty_Name]       = 0;
	acbSizeWrite[iMBProperty_Type]       = 0;
	acbSizeWrite[iMBProperty_Attributes] = 0;
	acbSizeWrite[iMBProperty_Value]      = cbData;
	acbSizeWrite[iMBProperty_Group]      = 0;
	acbSizeWrite[iMBProperty_Location]   = 0;
	acbSizeWrite[iMBProperty_ID]         = 0;
	acbSizeWrite[iMBProperty_UserType]   = 0;
	acbSizeWrite[iMBProperty_LocationID] = 0;

	hr = m_pISTWrite->AddRowForInsert(&iWriteRow);

	if(FAILED(hr))
		goto exit;

	hr = m_pISTWrite->SetWriteColumnValues(iWriteRow,
										   cColWrite,
										   aColWrite,
										   acbSizeWrite,
										   apvWrite);

	if(FAILED(hr))
		goto exit;
	  
exit:

	if(NULL != wszUnknownName)
	{
		delete [] wszUnknownName;
		wszUnknownName = NULL;
	}
	
	return hr;	

} // CLocationWriter::AddProperty


HRESULT CLocationWriter::AddProperty(LPVOID*	a_pv,
									 ULONG*     a_cbSize)
{
	HRESULT hr = S_OK;
	ULONG   iRow = 0;
	ULONG   cCol = cMBProperty_NumberOfColumns;

	if(MD_KEY_TYPE == *(DWORD*)a_pv[iMBProperty_ID]) 
	{
		//
		// Initialize the KeyType, only if it is not custom.
		//

		if(eMBProperty_Custom != (*(DWORD*)a_pv[iMBProperty_Group]))
		{
			hr = AssignKeyType((LPWSTR)a_pv[iMBProperty_Value]);
			return hr;
		}
	}

	hr = m_pISTWrite->AddRowForInsert(&iRow);

	if(FAILED(hr))
		return hr;

	hr = m_pISTWrite->SetWriteColumnValues(iRow,
			                               cCol,
										   NULL,
										   a_cbSize,
										   a_pv);

	return hr;

}	


HRESULT CLocationWriter::CreateUnknownName(DWORD    dwID,
										   LPWSTR*	pwszUnknownName)
{
	WCHAR wszID[25];
	SIZE_T cchID = 0;
	WCHAR* wszEnd = NULL;

	_itow(dwID, wszID, 10);

	cchID = wcslen(wszID);

	*pwszUnknownName = new WCHAR[cchID+g_cchUnknownName+1];
	if(NULL == *pwszUnknownName)
		return E_OUTOFMEMORY;

	wszEnd = *pwszUnknownName;
	memcpy(wszEnd, g_wszUnknownName, ((g_cchUnknownName+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchUnknownName;
	memcpy(wszEnd, wszID, ((cchID+1)*sizeof(WCHAR)));

	return S_OK;

} // CLocationWriter::CreateUnknownName


HRESULT CLocationWriter::GetGroupEnum(LPWSTR             wszGroup,
									  eMBProperty_Group* peGroup)
{

//	ULONG iCol = iMBProperty_Group;
	ULONG iReadRow = 0;
	DWORD* pdwGroup = NULL;
	HRESULT hr = S_OK;

/*
	LPVOID	aIdentity[] = {(LPVOID)wszTABLE_MBProperty,
	                       (LPVOID)&iCol,
						   (LPVOID)wszGroup
						  };

	hr = (m_pCWriterGlobalHelper->m_pISTTagMetaMBProperty)->GetRowIndexByIdentity(NULL,
																				  aIdentity,
																				  &iReadRow);
*/
	ULONG aColSearch[] = {iTAGMETA_Table,
						  iTAGMETA_ColumnIndex,
						  iTAGMETA_InternalName
						 };
	ULONG cColSearch = sizeof(aColSearch)/sizeof(ULONG);
	ULONG iCol       = iMBProperty_Group;
	LPVOID apvSearch[cTAGMETA_NumberOfColumns];
	apvSearch[iTAGMETA_Table]       = (LPVOID)m_pCWriterGlobalHelper->m_wszTABLE_MBProperty;
	apvSearch[iTAGMETA_ColumnIndex] = (LPVOID)&iCol;
	apvSearch[iTAGMETA_InternalName]= (LPVOID)wszGroup;
	ULONG iStartRow = 0;

	hr = (m_pCWriterGlobalHelper->m_pISTTagMetaMBPropertyIndx1)->GetRowIndexBySearch(iStartRow, 
																				     cColSearch, 
																				     aColSearch,
																				     NULL, 
																				     apvSearch,
																				     &iReadRow);
	if(E_ST_NOMOREROWS == hr)
	{
		//
		// Value does not match any known group. Return Custom
		//
		*peGroup = eMBProperty_Custom;
		hr = S_OK;
		goto exit;
	}
	else if(FAILED(hr))
	{
		goto exit;
	}

	iCol = iTAGMETA_Value;

	hr = (m_pCWriterGlobalHelper->m_pISTTagMetaMBPropertyIndx1)->GetColumnValues (iReadRow, 
																			      1, 
																			      &iCol, 
																			      NULL, 
																			      (LPVOID*)&pdwGroup);
							
	if(E_ST_NOMOREROWS == hr)
	{
		//
		// Value does not match any known group. Return Custom
		//
		*peGroup = eMBProperty_Custom;
		hr = S_OK;
		goto exit;
	}
	else if(FAILED(hr))
	{
		goto exit;
	}
	else
		*peGroup = (eMBProperty_Group)(*pdwGroup);
exit:

	return hr;

} // CLocationWriter::GetGroupEnum


HRESULT CLocationWriter::WriteLocation(BOOL bSort)
{

	HRESULT hr          = S_OK;
	ULONG*  aiRowSorted = NULL;
	ULONG   cRowSorted  = 0;
	ULONG   i           = 0;
	DWORD   bFirstCustomPropertyFound = FALSE; 

	//
	// KeyType has to be initialized, if not initialize it
	//
	
	if(NULL == m_wszKeyType)
	{
		hr = AssignKeyType(NULL);

		if(FAILED(hr))
			return hr;
	}
	
	if(bSort)
	{
		hr = Sort(&aiRowSorted,
				  &cRowSorted);
		if(FAILED(hr))
			goto exit;	
	
	}

	hr = WriteBeginLocation(m_wszLocation);

	if(FAILED(hr))
		return hr;

	for(i=0; ;i++)
	{

		ULONG   iRow = 0;
		ULONG   cCol = cMBProperty_NumberOfColumns;
		ULONG   a_cbSize[cMBProperty_NumberOfColumns];
		LPVOID  a_pv[cMBProperty_NumberOfColumns];

		if(bSort && (NULL != aiRowSorted))
		{
			if(cRowSorted == i)
				break;

			iRow =  aiRowSorted[i];
		}
		else 
			iRow = i;

		hr = m_pISTWrite->GetWriteColumnValues(iRow,
											   cCol,
											   NULL,
											   NULL,
											   a_cbSize,
											   a_pv);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
			goto exit;

		//
		// Ignore the location with no property property.
		//

		if((*(DWORD*)a_pv[iMBProperty_ID] == 0) && (*(LPWSTR)a_pv[iMBProperty_Name] == L'#'))
			continue;

/*
		if(0 == i)
		{
			hr = WriteBeginLocation(m_wszLocation);

			if(FAILED(hr))
				return hr;
		}
*/
		if(!bFirstCustomPropertyFound)
		{
			if(eMBProperty_Custom == *(DWORD*)(a_pv[iMBProperty_Group]))
			{
				hr = WriteEndWellKnownGroup();
				
				if(FAILED(hr))
					return hr;

				bFirstCustomPropertyFound = TRUE;

			}
		}
			
		if(eMBProperty_Custom == *(DWORD*)(a_pv[iMBProperty_Group]))
			hr = WriteCustomProperty(a_pv,
									 a_cbSize);
		else
			hr = WriteWellKnownProperty(a_pv,
									    a_cbSize);

		if(FAILED(hr))
			return hr;


	}

	if(!bFirstCustomPropertyFound)
	{
		hr = WriteEndWellKnownGroup();
		
		if(FAILED(hr))
			goto exit;	
	}

	hr = WriteEndLocation();

	if(FAILED(hr))
		goto exit;	

exit:

	if(NULL != aiRowSorted)
	{
		delete [] aiRowSorted;
		aiRowSorted = NULL;
	}

	return hr;

} // CLocationWriter::WriteLocation


HRESULT CLocationWriter::Sort(ULONG** paiRowSorted,
                              ULONG*  pcRowSorted)
{

	HRESULT hr = S_OK;
	ULONG iCustom = 0;
	ULONG iWellKnown = 0;
	ULONG iRow = 0;
	ULONG i=0;

	MBProperty* aWellKnownProperty = NULL;
	MBProperty*	aCustomProperty = NULL;
	ULONG       cCustomProperty = 0;
	ULONG       cWellKnownProperty = 0;

	//
	// Count the Custom properties / Well known properties.
	// 

	for(iRow=0;;iRow++)
	{
	
		DWORD* pdwGroup = NULL;
		ULONG  iCol = iMBProperty_Group;

		hr = m_pISTWrite->GetWriteColumnValues(iRow,
											   1,
											   &iCol,
											   NULL,
											   NULL,
											   (LPVOID*)&pdwGroup);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
			goto exit;

		if(eMBProperty_Custom == *pdwGroup)
			cCustomProperty++;
		else
			cWellKnownProperty++;

	}

	//
	// Allocate arrays to hold Cusom property / Well known property.
	// 

	if(cCustomProperty > 0)
	{
		aCustomProperty = new MBProperty[cCustomProperty];
		if(NULL == aCustomProperty)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
	}

	if(cWellKnownProperty > 0)
	{
		aWellKnownProperty = new MBProperty[cWellKnownProperty];
		if(NULL == aWellKnownProperty)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
	}
	
	//
	// Populate the arrays
	//

	for(iRow=0;;iRow++)
	{
	
		DWORD* pdwGroup = NULL;
		ULONG  aCol[] = {iMBProperty_Group,
		                 iMBProperty_Name
						};
		ULONG  cCol = sizeof(aCol)/sizeof(ULONG);
		LPVOID apv[cMBProperty_NumberOfColumns];

		hr = m_pISTWrite->GetWriteColumnValues(iRow,
											   cCol,
											   aCol,
											   NULL,
											   NULL,
											   apv);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
			goto exit;

		if(eMBProperty_Custom == *(DWORD*)apv[iMBProperty_Group])
		{
			//
			// TODO: Assert that iCustom is within count
			//
			aCustomProperty[iCustom].iRow = iRow;
			aCustomProperty[iCustom++].wszPropertyName = (LPWSTR)apv[iMBProperty_Name];
		}
		else
		{
			//
			// TODO: Assert that iWellKnown is within count
			//
			aWellKnownProperty[iWellKnown].iRow = iRow;
			aWellKnownProperty[iWellKnown++].wszPropertyName = (LPWSTR)apv[iMBProperty_Name];
		}

	}

	
	//
	// Sort the individual arrays.
	//

	if(cCustomProperty > 0)
		qsort((void*)aCustomProperty, cCustomProperty, sizeof(MBProperty), MyCompare);
	if(cWellKnownProperty > 0)
		qsort((void*)aWellKnownProperty, cWellKnownProperty, sizeof(MBProperty), MyCompare);

	//
	// Create the new array of indicies. First add well known, then custom
	//

	*paiRowSorted = new ULONG [cCustomProperty + cWellKnownProperty];
	if(NULL == *paiRowSorted)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	for(i=0, iRow=0; iRow<cWellKnownProperty; iRow++, i++)
		(*paiRowSorted)[i] = (aWellKnownProperty[iRow]).iRow;

	for(iRow=0; iRow<cCustomProperty; iRow++, i++)
		(*paiRowSorted)[i] = (aCustomProperty[iRow]).iRow;

	*pcRowSorted = cCustomProperty + cWellKnownProperty;

exit:

	if(NULL != aCustomProperty)
	{
		delete [] aCustomProperty;
		aCustomProperty = NULL;
	}
	if(NULL != aWellKnownProperty)
	{
		delete [] aWellKnownProperty;
		aWellKnownProperty = NULL;
	}

	return hr;

} // CLocationWriter::Sort


HRESULT CLocationWriter::WriteBeginLocation(LPCWSTR  wszLocation)
{
	HRESULT hr= S_OK;
	WCHAR*	wszTemp = NULL;
	SIZE_T	iLastChar = wcslen(wszLocation)-1;
	BOOL	bEscapedLocation = FALSE;
	LPWSTR  wszEscapedLocation = NULL;
	SIZE_T  cchKeyType = 0;
	SIZE_T  cchEscapedLocation = 0;
	WCHAR*  wszEnd  = NULL;
	
	hr = m_pCWriterGlobalHelper->EscapeString(wszLocation,
                                              &bEscapedLocation,
					                          &wszEscapedLocation);

	if(FAILED(hr))
		goto exit;

	cchKeyType = wcslen(m_wszKeyType);
	cchEscapedLocation = wcslen(wszEscapedLocation);

	wszTemp = new WCHAR[g_cchBeginLocation
					  + cchKeyType	
					  + g_cchLocation 
		              + cchEscapedLocation
					  + g_cchQuoteRtn
					  + 1];

	if(NULL == wszTemp)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}
	wszEnd = wszTemp;
	memcpy(wszEnd, g_BeginLocation, ((g_cchBeginLocation+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchBeginLocation;
	memcpy(wszEnd, m_wszKeyType, ((cchKeyType+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + cchKeyType;
	memcpy(wszEnd, g_Location, ((g_cchLocation+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchLocation;

	memcpy(wszEnd, wszEscapedLocation, ((cchEscapedLocation+1)*sizeof(WCHAR)));
	if((0 != iLastChar) && (L'/' == wszLocation[iLastChar]))
	{
		wszTemp[wcslen(wszTemp)-1] = 0;
		cchEscapedLocation--;
	}
	wszEnd = wszEnd + cchEscapedLocation;

	memcpy(wszEnd, g_QuoteRtn, ((g_cchQuoteRtn+1)*sizeof(WCHAR)));

	hr = m_pCWriter->WriteToFile((LPVOID)wszTemp,
								wcslen(wszTemp));

	if(FAILED(hr))
		goto exit;

exit:

	if(NULL != wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	if(bEscapedLocation && (NULL != wszEscapedLocation))
	{
		delete [] wszEscapedLocation;
		wszEscapedLocation = NULL;
	}

	return hr;

} // CLocationWriter::WriteBeginLocation


HRESULT CLocationWriter::WriteEndLocation()
{
	HRESULT hr= S_OK;
	WCHAR*	wszTemp = NULL;
	WCHAR*  wszEnd = NULL;
	SIZE_T  cchKeyType = 0;

	cchKeyType = wcslen(m_wszKeyType);
	wszTemp = new WCHAR[g_cchEndLocationBegin
					  + cchKeyType			
					  + g_cchEndLocationEnd 
					  + 1];
	if(NULL == wszTemp)
		return E_OUTOFMEMORY;

	wszEnd = wszTemp;
	memcpy(wszEnd, g_EndLocationBegin, ((g_cchEndLocationBegin+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchEndLocationBegin;
	memcpy(wszEnd, m_wszKeyType, ((cchKeyType+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + cchKeyType;
	memcpy(wszEnd, g_EndLocationEnd, ((g_cchEndLocationEnd+1)*sizeof(WCHAR)));

	hr =  m_pCWriter->WriteToFile((LPVOID)wszTemp,
					              wcslen(wszTemp));

	if(FAILED(hr))
		goto exit;

exit:

	if(NULL != wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;	

} // CLocationWriter::WriteEndLocation


HRESULT CLocationWriter::WriteCustomProperty(LPVOID*  a_pv,
											 ULONG*   a_cbSize)
{

	ULONG	dwBytesWritten = 0;
	WCHAR*	wszTemp = NULL;
	HRESULT hr = S_OK;

	DWORD	dwType      = *(DWORD*)a_pv[iMBProperty_Type];
	LPWSTR	wszType     = g_T_Unknown;
	DWORD	dwUserType  = *(DWORD*)a_pv[iMBProperty_UserType];
	LPWSTR	wszUserType = g_UT_Unknown;
	LPWSTR	wszValue    = NULL;
	SIZE_T  cchName     = 0;
	SIZE_T  cchID       = 0;
	SIZE_T  cchValue    = 0;
	SIZE_T  cchType     = 0;
	SIZE_T  cchUserType = 0;
	SIZE_T  cchAttributes = 0;
	WCHAR*  wszEnd      = NULL;

	WCHAR wszID[25];
	LPWSTR wszAttributes = NULL;

	ULONG aColSearchUserType[] = {iTAGMETA_Table,
						          iTAGMETA_ColumnIndex,
						          iTAGMETA_Value
						         };
	ULONG cColSearchUserType   = sizeof(aColSearchUserType)/sizeof(ULONG);
	ULONG iColUserType         = iMBProperty_UserType;
	LPVOID apvSearchUserType[cTAGMETA_NumberOfColumns];
	apvSearchUserType[iTAGMETA_Table]       = (LPVOID)m_pCWriterGlobalHelper->m_wszTABLE_MBProperty;
	apvSearchUserType[iTAGMETA_ColumnIndex] = (LPVOID)&iColUserType;
	apvSearchUserType[iTAGMETA_Value]       = (LPVOID)&dwUserType;

	ULONG aColSearchType[] = {iTAGMETA_Table,
					          iTAGMETA_ColumnIndex,
					          iTAGMETA_Value
					         };
	ULONG cColSearchType   = sizeof(aColSearchType)/sizeof(ULONG);
	ULONG iColType         = iMBProperty_Type;
	LPVOID apvSearchType[cTAGMETA_NumberOfColumns];
	apvSearchType[iTAGMETA_Table]       = (LPVOID)m_pCWriterGlobalHelper->m_wszTABLE_MBProperty;
	apvSearchType[iTAGMETA_ColumnIndex] = (LPVOID)&iColType;
	apvSearchType[iTAGMETA_Value]       = (LPVOID)&dwType;

	ULONG iRow           = 0;
	ULONG iStartRow      = 0;
	ULONG iColAttributes = iMBProperty_Attributes;

	_itow(*(DWORD*)a_pv[iMBProperty_ID], wszID, 10);
//	_itow(*(DWORD*)a_pv[iMBProperty_Attributes], wszAttributes, 10);

	//
	// Get the tag for UserType from meta
	//

	hr = (m_pCWriterGlobalHelper->m_pISTTagMetaMBPropertyIndx2)->GetRowIndexBySearch(iStartRow, 
																				     cColSearchUserType,
																				     aColSearchUserType,
																				     NULL, 
																				     apvSearchUserType,
																				     &iRow);

	if(E_ST_NOMOREROWS == hr)
	{	
		hr = S_OK;
		wszUserType = g_UT_Unknown;
	}
	else if(FAILED(hr))
		goto exit;	
	else 
	{
		iColUserType = iTAGMETA_InternalName;

		hr = (m_pCWriterGlobalHelper->m_pISTTagMetaMBPropertyIndx2)->GetColumnValues(iRow,
																				     1,
																				     &iColUserType,
																				     NULL,
																				     (LPVOID*)&wszUserType);

		if(E_ST_NOMOREROWS == hr)
		{	
			hr = S_OK;
			wszUserType = g_UT_Unknown;
		}
		else if(FAILED(hr))
			goto exit;
	}

	//
	// Get the tag for Type from meta
	//

	hr = (m_pCWriterGlobalHelper->m_pISTTagMetaMBPropertyIndx2)->GetRowIndexBySearch(iStartRow, 
																				     cColSearchType,
																				     aColSearchType,
																				     NULL, 
																				     apvSearchType,
																				     &iRow);

	if(E_ST_NOMOREROWS == hr)
	{	
		hr = S_OK;
		wszType = g_T_Unknown;
	}
	else if(FAILED(hr))
		goto exit;	
	else 
	{
		iColType = iTAGMETA_InternalName;

		hr = (m_pCWriterGlobalHelper->m_pISTTagMetaMBPropertyIndx2)->GetColumnValues(iRow,
																				     1,
																				     &iColType,
																				     NULL,
																				     (LPVOID*)&wszType);

		if(E_ST_NOMOREROWS == hr)
		{	
			hr = S_OK;
			wszType = g_T_Unknown;
		}
		else if(FAILED(hr))
			goto exit;
	}

	//
	// Construct the tag for Attributes from meta
	//
/*
	hr = FlagAttributeToString(*(DWORD*)a_pv[iMBProperty_Attributes],
	                           &wszAttributes);
*/
	hr = m_pCWriterGlobalHelper->FlagToString(*(DWORD*)a_pv[iMBProperty_Attributes],
										      &wszAttributes,
											  m_pCWriterGlobalHelper->m_wszTABLE_MBProperty,
											  iColAttributes);
	if(FAILED(hr))
		goto exit;

	hr = m_pCWriterGlobalHelper->ToString((PBYTE)a_pv[iMBProperty_Value],
										  a_cbSize[iMBProperty_Value],
										  *(DWORD*)a_pv[iMBProperty_ID],
										  dwType,
										  *(DWORD*)a_pv[iMBProperty_Attributes],
										  &wszValue);

	if(FAILED(hr))
		goto exit;

	cchName = wcslen((LPWSTR)a_pv[iMBProperty_Name]);
	cchID = wcslen(wszID);
	cchValue = wcslen(wszValue);
	cchType = wcslen(wszType);
	cchUserType = wcslen(wszUserType);
	cchAttributes = wcslen(wszAttributes);
	
	wszTemp = new WCHAR[g_cchBeginCustomProperty 
					    + g_cchNameEq
					    + cchName 
					    + g_cchQuoteRtn
					    + g_cchIDEq
					    + cchID 
					    + g_cchQuoteRtn 
					    + g_cchValueEq
					    + cchValue 
					    + g_cchQuoteRtn
					    + g_cchTypeEq
					    + cchType
					    + g_cchQuoteRtn
					    + g_cchUserTypeEq
					    + cchUserType
					    + g_cchQuoteRtn
					    + g_cchAttributesEq
					    + cchAttributes
					    + g_cchQuoteRtn
					    + g_cchEndCustomProperty
					    + 1];
	if(NULL == wszTemp)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	wszEnd = wszTemp;
	memcpy(wszEnd, g_BeginCustomProperty, ((g_cchBeginCustomProperty+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchBeginCustomProperty;
	memcpy(wszEnd, g_NameEq, ((g_cchNameEq+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchNameEq;
	memcpy(wszEnd, (LPWSTR)a_pv[iMBProperty_Name], ((cchName+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + cchName;
	memcpy(wszEnd, g_QuoteRtn, ((g_cchQuoteRtn+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchQuoteRtn;
	memcpy(wszEnd, g_IDEq, ((g_cchIDEq+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchIDEq;
	memcpy(wszEnd, wszID, ((cchID+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + cchID;
	memcpy(wszEnd, g_QuoteRtn, ((g_cchQuoteRtn+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchQuoteRtn;
	memcpy(wszEnd, g_ValueEq, ((g_cchValueEq+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchValueEq;
	memcpy(wszEnd, wszValue, ((cchValue+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + cchValue;
	memcpy(wszEnd, g_QuoteRtn, ((g_cchQuoteRtn+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchQuoteRtn;
	memcpy(wszEnd, g_TypeEq, ((g_cchTypeEq+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchTypeEq;
	memcpy(wszEnd, wszType, ((cchType+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + cchType;
	memcpy(wszEnd, g_QuoteRtn, ((g_cchQuoteRtn+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchQuoteRtn;
	memcpy(wszEnd, g_UserTypeEq, ((g_cchUserTypeEq+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchUserTypeEq;
	memcpy(wszEnd, wszUserType, ((cchUserType+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + cchUserType;
	memcpy(wszEnd, g_QuoteRtn, ((g_cchQuoteRtn+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchQuoteRtn;
	memcpy(wszEnd, g_AttributesEq, ((g_cchAttributesEq+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchAttributesEq;
	memcpy(wszEnd, wszAttributes, ((cchAttributes+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + cchAttributes;
	memcpy(wszEnd, g_QuoteRtn, ((g_cchQuoteRtn+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchQuoteRtn;
	memcpy(wszEnd, g_EndCustomProperty, ((g_cchEndCustomProperty+1)*sizeof(WCHAR)));
	
	hr = m_pCWriter->WriteToFile((LPVOID)wszTemp,
								 wcslen(wszTemp));

exit:

	if(NULL != wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	if(NULL != wszValue)
	{
		delete [] wszValue;
		wszValue = NULL;
	}

	if(NULL != wszAttributes)
	{
		delete [] wszAttributes;
		wszAttributes = NULL;
	}

	return hr;

} // CLocationWriter::WriteCustomProperty


HRESULT CLocationWriter::WriteEndWellKnownGroup()
{
	return m_pCWriter->WriteToFile((LPVOID)g_EndGroup,
								   wcslen(g_EndGroup));

} // CLocationWriter::WriteEndWellKnownGroup


HRESULT CLocationWriter::WriteWellKnownProperty(LPVOID*   a_pv,
									            ULONG*    a_cbSize)
{
	WCHAR*	wszTemp = NULL;
	HRESULT hr = S_OK;
	LPWSTR	wszValue = NULL;
	WCHAR*  wszEnd = NULL;
	SIZE_T  cchName = 0;
	SIZE_T  cchValue = 0;
	
	hr = m_pCWriterGlobalHelper->ToString((PBYTE)a_pv[iMBProperty_Value],
										  a_cbSize[iMBProperty_Value],
										  *(DWORD*)a_pv[iMBProperty_ID],
										  *(DWORD*)a_pv[iMBProperty_Type],
										  *(DWORD*)a_pv[iMBProperty_Attributes],
										  &wszValue);

	if(FAILED(hr))
		return hr;

	cchName = wcslen((LPWSTR)a_pv[iMBProperty_Name]) ;
	cchValue = wcslen(wszValue);

	wszTemp = new WCHAR[g_cchTwoTabs 
		                + cchName
					    + g_cchEqQuote 
					    + cchValue
					    + g_cchQuoteRtn 
					    + 1];

	if(NULL == wszTemp)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	wszEnd = wszTemp;
	memcpy(wszEnd, g_TwoTabs, ((g_cchTwoTabs+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchTwoTabs;
	memcpy(wszEnd, (LPWSTR)a_pv[iMBProperty_Name], ((cchName+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + cchName;
	memcpy(wszEnd, g_EqQuote, ((g_cchEqQuote+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + g_cchEqQuote;
	memcpy(wszEnd, wszValue, ((cchValue+1)*sizeof(WCHAR)));
	wszEnd = wszEnd + cchValue;
	memcpy(wszEnd, g_QuoteRtn, ((g_cchQuoteRtn+1)*sizeof(WCHAR)));

	hr = m_pCWriter->WriteToFile((LPVOID)wszTemp,
								 wcslen(wszTemp));

exit:

	if(NULL != wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	if(NULL != wszValue)
	{
		delete [] wszValue;
		wszValue = NULL;
	}

	return hr;

} // CLocationWriter::WriteWellKnownProperty

/*
HRESULT CLocationWriter::ToString(PBYTE   pbData,
								  DWORD   cbData,
								  DWORD   dwIdentifier,
								  DWORD   dwDataType,
								  DWORD   dwAttributes,
								  LPWSTR* pwszData)
{
	HRESULT hr              = S_OK;
	ULONG	i				= 0;
	ULONG	j				= 0;
	WCHAR*	wszBufferBin	= NULL;
	WCHAR*	wszTemp			= NULL;
	BYTE*	a_Bytes			= NULL;
	WCHAR*	wszMultisz      = NULL;
	ULONG   cMultisz        = 0;
	ULONG   cchMultisz      = 0;
	ULONG   cchBuffer       = 0;
	DWORD	dwValue			= 0;
	WCHAR	wszBufferDW[20];
	WCHAR	wszBufferDWTemp[20];
	
	ULONG   aColSearch[]    = {iCOLUMNMETA_Table,
							   iCOLUMNMETA_ID
						      };
	ULONG   cColSearch      = sizeof(aColSearch)/sizeof(ULONG);
	LPVOID  apvSearch[cCOLUMNMETA_NumberOfColumns];
	apvSearch[iCOLUMNMETA_Table] = (LPVOID)m_pCWriterGlobalHelper->m_wszTABLE_IIsConfigObject;
	apvSearch[iCOLUMNMETA_ID] = (LPVOID)&dwIdentifier; 

	ULONG   iRow            = 0;
	ULONG   iStartRow            = 0;

	LPWSTR  wszEscaped = NULL;
	BOOL    bEscaped = FALSE;

	*pwszData = NULL;

	if(IsSecureMetadata(dwIdentifier, dwAttributes))
		dwDataType = BINARY_METADATA;

	switch(dwDataType)
	{
		case BINARY_METADATA:

			wszBufferBin	= new WCHAR[(cbData*2)+1]; // Each byte is represented by 2 chars. Add extra char for null termination
			if(NULL == wszBufferBin)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}
			wszTemp			= wszBufferBin;
			a_Bytes			= (BYTE*)(pbData);

			for(i=0; i<cbData; i++)
			{
                wszTemp[0] = kByteToWchar[a_Bytes[i]][0];
                wszTemp[1] = kByteToWchar[a_Bytes[i]][1];
                wszTemp += 2;
			}

			*wszTemp	= 0; // Add the terminating NULL
			*pwszData  	= wszBufferBin;
			break;

		case DWORD_METADATA :

			// TODO: After Stephen supports hex, convert these to hex.

			dwValue = *(DWORD*)(pbData);

			//
			// First check to see if it is a flag or bool type.
			//

			hr = (m_pCWriterGlobalHelper->m_pISTColumnMeta)->GetRowIndexBySearch(iStartRow, 
																				 cColSearch, 
																				 aColSearch,
																				 NULL, 
																				 apvSearch,
																				 &iRow);

			if(SUCCEEDED(hr))
			{
			    ULONG  aCol [] = {iCOLUMNMETA_Index,
				                 iCOLUMNMETA_MetaFlags
							    };
				ULONG  cCol = sizeof(aCol)/sizeof(ULONG);
				LPVOID apv[cCOLUMNMETA_NumberOfColumns];

//				ULONG  iCol = iCOLUMNMETA_Index;
//				DWORD* piCol = NULL;

				hr = (m_pCWriterGlobalHelper->m_pISTColumnMeta)->GetColumnValues(iRow,
														                         cCol,
																				 aCol,
																				 NULL,
																				 apv);

				if(FAILED(hr))
					goto exit;
				
				if(0 != (fCOLUMNMETA_FLAG & (*(DWORD*)apv[iCOLUMNMETA_MetaFlags])))
				{
					//
					// This is a flag property convert it.
					//

					hr = FlagValueToString(dwValue,
									       (ULONG*)apv[iCOLUMNMETA_Index],
									       pwszData);
	
					goto exit;
				}
				else if(0 != (fCOLUMNMETA_BOOL & (*(DWORD*)apv[iCOLUMNMETA_MetaFlags])))
				{
					//
					// This is a bool property
					//

					hr = BoolToString(dwValue,
					                  pwszData);

					goto exit;
				}
				

			}
			else if((E_ST_NOMOREROWS != hr) && FAILED(hr))
				goto exit;
//			else
//			{
			hr = S_OK;
			_itow(dwValue, wszBufferDW, 10);
			*pwszData = new WCHAR[wcslen(wszBufferDW)+1];
			if(NULL == *pwszData)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}
			wcscpy(*pwszData, wszBufferDW);
//			}

			break;

		case MULTISZ_METADATA :

			//
			// Count the number of multisz
			//

			wszMultisz = (WCHAR*)(pbData);
//			wszMultisz = wszMultisz + wcslen(wszMultisz) + 1;
//			cMultisz = 1;
			while((0 != *wszMultisz) && ((BYTE*)wszMultisz < (pbData + cbData)))			
			{
				cMultisz++;

				hr = EscapeString(wszMultisz,
								  &bEscaped,
								  &wszEscaped);

				if(FAILED(hr))
					goto exit;

				cchMultisz = cchMultisz + wcslen(wszEscaped);

				if(bEscaped && (NULL != wszEscaped))	// reset for next string in multisz
				{
					delete [] wszEscaped;
					wszEscaped = NULL;
					bEscaped = FALSE;
				}

				wszMultisz = wszMultisz + wcslen(wszMultisz) + 1;
			}

						
//			*pwszData = new WCHAR[(cbData / sizeof(WCHAR)) + (5*(cMultisz-1))]; // (5*(cMultisz-1) => \r\n\t\t\t. \n is included in the null.

			if(cMultisz > 0)
				cchBuffer = cchMultisz + (5*(cMultisz-1)) + 1;    // (5*(cMultisz-1) => \r\n\t\t\t. 
			else
				cchBuffer = 1;

			*pwszData = new WCHAR[cchBuffer]; 
			if(NULL == *pwszData)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}
			**pwszData = 0;

			wszMultisz = (WCHAR*)(pbData);
			wszTemp = *pwszData;

			hr = EscapeString(wszMultisz,
							  &bEscaped,
							  &wszEscaped);

			if(FAILED(hr))
				goto exit;

//			wcscat(wszTemp, wszMultisz);
			wcscat(wszTemp, wszEscaped);

			wszMultisz = wszMultisz + wcslen(wszMultisz) + 1;

			while((0 != *wszMultisz) && ((BYTE*)wszMultisz < (pbData + cbData)))			
			{
				wcscat(wszTemp, L"\r\n\t\t\t");

				if(bEscaped && (NULL != wszEscaped))	// reset for next string in multisz
				{
					delete [] wszEscaped;
					wszEscaped = NULL;
					bEscaped = FALSE;
				}

				hr = EscapeString(wszMultisz,
								  &bEscaped,
								  &wszEscaped);

				if(FAILED(hr))
					goto exit;

//				wcscat(wszTemp, wszMultisz);

				wcscat(wszTemp, wszEscaped);

				wszMultisz = wszMultisz + wcslen(wszMultisz) + 1;
			}

			break;

		case EXPANDSZ_METADATA :
		case STRING_METADATA :

			hr = EscapeString((WCHAR*)pbData,
							  &bEscaped,
							  &wszEscaped);

			if(FAILED(hr))
				goto exit;

			*pwszData = new WCHAR[wcslen(wszEscaped) + 1];
			if(NULL == *pwszData)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}
			wcscpy(*pwszData, wszEscaped);
			break;

		default:
			hr = E_INVALIDARG;
			break;
			
	}

exit:

	if(bEscaped && (NULL != wszEscaped))
	{
		delete [] wszEscaped;
		wszEscaped = NULL;
		bEscaped = FALSE;
	}

	return hr;

} // CLocationWriter::ToString


HRESULT CLocationWriter::FlagValueToString(DWORD      dwValue,
								           ULONG*     piCol,
								           LPWSTR*    pwszData)
{

	return FlagToString(dwValue,
					    pwszData,
					    m_pCWriterGlobalHelper->m_wszTABLE_IIsConfigObject,
					    *piCol);

} // CLocationWriter::FlagValueToString


HRESULT CLocationWriter::FlagAttributeToString(DWORD      dwValue,
								               LPWSTR*    pwszData)
{
	ULONG   iCol       = iMBProperty_Attributes;
	
	return FlagToString(dwValue,
					    pwszData,
					    m_pCWriterGlobalHelper->m_wszTABLE_MBProperty,
					    iCol);

} // CLocationWriter::FlagAttributeToString


HRESULT CLocationWriter::FlagToString(DWORD      dwValue,
								      LPWSTR*    pwszData,
									  LPWSTR     wszTable,
									  ULONG      iColFlag)
{

	DWORD	dwAllFlags = 0;
	HRESULT hr         = S_OK;
	ULONG   iStartRow  = 0;
	ULONG   iRow       = 0;
	WCHAR	wszBufferDW[20];
	ULONG   iCol       = 0;
	LPWSTR	wszFlag	   = NULL;

	ULONG   aCol[]     = {iTAGMETA_Value,
					      iTAGMETA_InternalName,
						  iTAGMETA_Table,
						  iTAGMETA_ColumnIndex
				         };
	ULONG   cCol       = sizeof(aCol)/sizeof(ULONG);
	LPVOID  apv[cTAGMETA_NumberOfColumns];
	ULONG   cch        = 0;
	LPVOID  apvIdentity [] = {(LPVOID)wszTable,
							  (LPVOID)&iColFlag
	};
	ULONG   iColFlagMask = iCOLUMNMETA_FlagMask;
	DWORD*  pdwFlagMask = NULL;

	DWORD   dwZero = 0;
	ULONG   aColSearchByValue[] = {iTAGMETA_Table,
							       iTAGMETA_ColumnIndex,
							       iTAGMETA_Value
	};
	ULONG   cColSearchByValue = sizeof(aColSearchByValue)/sizeof(ULONG);
	LPVOID  apvSearchByValue[cTAGMETA_NumberOfColumns];
	apvSearchByValue[iTAGMETA_Table] = (LPVOID)wszTable;
	apvSearchByValue[iTAGMETA_ColumnIndex] = (LPVOID)&iColFlag;
	apvSearchByValue[iTAGMETA_Value] = (LPVOID)&dwZero;


	//
	// Make one pass and compute all flag values for this property.
	//

	hr = (m_pCWriterGlobalHelper->m_pISTColumnMetaForFlags)->GetRowIndexByIdentity(NULL,
		                                                                           apvIdentity,
																				   &iRow);

	if(SUCCEEDED(hr))
	{
		hr = (m_pCWriterGlobalHelper->m_pISTColumnMetaForFlags)->GetColumnValues(iRow,
																				 1,
																				 &iColFlagMask,
																				 NULL,
																				 (LPVOID*)&pdwFlagMask);

		if(FAILED(hr))
			return hr;
	}
	else if(E_ST_NOMOREROWS != hr)
		return hr;


	if((E_ST_NOMOREROWS == hr) || 
	   (0 != (dwValue & (~(dwValue & (*pdwFlagMask))))))
	{
		//
		//	There was no mask associated with this property, or there are one
		//  or more unknown bits set. Spit out a regular number.
		//

		_itow(dwValue, wszBufferDW, 10);
		*pwszData = new WCHAR[wcslen(wszBufferDW)+1];
		if(NULL == *pwszData)
			return E_OUTOFMEMORY;
		wcscpy(*pwszData, wszBufferDW);
		return S_OK;

	}
	else if(0 == dwValue)
	{
		//
		// See if there is a flag with 0 as its value.
		//

		hr = (m_pCWriterGlobalHelper->m_pISTTagMetaMBPropertyIndx2)->GetRowIndexBySearch(iStartRow, 
																					     cColSearchByValue, 
																					     aColSearchByValue,
																					     NULL, 
																					     apvSearchByValue,
																					     &iRow);

		if(E_ST_NOMOREROWS == hr)
		{
			//
			// There was no flag associated with the value zero. Spit out a 
			// regular number
			//

			_itow(dwValue, wszBufferDW, 10);
			*pwszData = new WCHAR[wcslen(wszBufferDW)+1];
			if(NULL == *pwszData)
				return E_OUTOFMEMORY;
			wcscpy(*pwszData, wszBufferDW);
			return S_OK;

		}
		else if(FAILED(hr))
			return hr;
		else
		{
			iCol = iTAGMETA_InternalName;

			hr = (m_pCWriterGlobalHelper->m_pISTTagMetaMBPropertyIndx2)->GetColumnValues(iRow,
																			             1,
																				         &iCol,
																				         NULL,
																				         (LPVOID*)&wszFlag);

			if(FAILED(hr))
				return hr;

			*pwszData = new WCHAR[wcslen(wszFlag)+1];
			if(NULL == *pwszData)
				return E_OUTOFMEMORY;
			**pwszData = 0;
			wcscat(*pwszData, wszFlag);
			return S_OK;
		}

	}
	else 
	{
		//
		// Make another pass, and convert flag to string.
		//

		ULONG cchFlagString = cMaxFlagString;
		LPWSTR wszExtension = L" | ";
		ULONG  cchExtension = wcslen(wszExtension);
		ULONG cchFlagStringUsed = 0;

		*pwszData = new WCHAR[cchFlagString+1];
		if(NULL == *pwszData)
			return E_OUTOFMEMORY;
		**pwszData = 0;
		
		hr = GetStartRowIndex(wszTable,
			                  iColFlag,
							  &iStartRow);

		if(FAILED(hr) || (iStartRow == -1))
			return hr;

		for(iRow=iStartRow;;iRow++)
		{
			hr = (m_pCWriterGlobalHelper->m_pISTTagMetaIIsConfigObject)->GetColumnValues(iRow,
																			             cCol,
																			             aCol,
																			             NULL,
																			             apv);
			if((E_ST_NOMOREROWS == hr) ||
			   (iColFlag != *(DWORD*)apv[iTAGMETA_ColumnIndex]) ||
			   (0 != StringInsensitiveCompare(wszTable, (LPWSTR)apv[iTAGMETA_Table]))
			  )
			{
				hr = S_OK;
				break;
			}
			else if(FAILED(hr))
				return hr;

			if(0 != (dwValue & (*(DWORD*)apv[iTAGMETA_Value])))
			{
				ULONG strlen = wcslen((LPWSTR)apv[iTAGMETA_InternalName]);

				if(cchFlagStringUsed + cchExtension + strlen > cchFlagString)
				{
					LPWSTR wszTemp = NULL;
					cchFlagString = cchFlagString + cMaxFlagString;
					wszTemp = new WCHAR[cchFlagString+1];
					if(NULL == wszTemp)
						return E_OUTOFMEMORY;
					wcscpy(wszTemp, *pwszData);

					if(NULL != *pwszData)
						delete [] (*pwszData);

					*pwszData = wszTemp;
				}

				if(**pwszData != 0)
				{
					wcscat(*pwszData, wszExtension);
					cchFlagStringUsed = cchFlagStringUsed + cchExtension;
				}

				wcscat(*pwszData, (LPWSTR)apv[iTAGMETA_InternalName]);
				cchFlagStringUsed = cchFlagStringUsed + strlen;

				// Clear out that bit

				dwValue = dwValue & (~(*(DWORD*)apv[iTAGMETA_Value]));
			}

		}

	}

	return S_OK;

} // CLocationWriter::FlagToString


HRESULT CLocationWriter::GetStartRowIndex(LPWSTR    wszTable,
			                              ULONG     iColFlag,
							              ULONG*    piStartRow)
{
	HRESULT hr = S_OK;
	ULONG   aColSearch[] = {iTAGMETA_Table,
	                        iTAGMETA_ColumnIndex
						   };
	ULONG   cColSearch = sizeof(aColSearch)/sizeof(ULONG);
	LPVOID  apvSearch[cTAGMETA_NumberOfColumns];
	apvSearch[iTAGMETA_Table] = (LPVOID)wszTable;
	apvSearch[iTAGMETA_ColumnIndex] = (LPVOID)&iColFlag;

	*piStartRow = 0;

	if((0 == StringInsensitiveCompare(wszTable, m_pCWriterGlobalHelper->m_wszTABLE_MBProperty)) &&
	   (iMBProperty_Attributes == iColFlag))
	{
		*piStartRow = m_pCWriterGlobalHelper->m_iStartRowForAttributes;
	}
	else
	{
		hr = (m_pCWriterGlobalHelper->m_pISTTagMetaIIsConfigObject)->GetRowIndexBySearch(*piStartRow, 
																						 cColSearch, 
																						 aColSearch,
																						 NULL, 
																						 apvSearch,
																						 piStartRow);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			*piStartRow = -1;
		}
	}

	return hr;

} // CLocationWriter::GetStartRowIndex


HRESULT CLocationWriter::FlagToString(DWORD      dwValue,
								      LPWSTR*    pwszData,
									  ULONG      cColSearch,
									  ULONG*     aColSearch,
									  LPVOID*    apvSearch)
{

	DWORD	dwAllFlags = 0;
	HRESULT hr         = S_OK;
	ULONG   iStartRow  = 0;
	ULONG   iRow       = 0;
	WCHAR	wszBufferDW[20];
	DWORD   iRowZeroFlag = -1;
	ULONG   iCol       = 0;
	LPWSTR	wszFlag	   = NULL;

	ULONG   aCol[]     = {iTAGMETA_Value,
					      iTAGMETA_InternalName
				         };
	ULONG   cCol       = sizeof(aCol)/sizeof(ULONG);
	LPVOID  apv[cTAGMETA_NumberOfColumns];
	ULONG   cch        = 0;

	//
	// Make one pass and compute all flag values for this property.
	//

	for(iStartRow=0,iRow=0;;iStartRow=++iRow)
	{

		hr = (m_pCWriterGlobalHelper->m_pISTTagMetaIIsConfigObject)->GetRowIndexBySearch(iStartRow, 
																						 cColSearch, 
																						 aColSearch,
																						 NULL, 
																						 apvSearch,
																						 &iRow);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
			return hr;

		hr = (m_pCWriterGlobalHelper->m_pISTTagMetaIIsConfigObject)->GetColumnValues(iRow,
																					 cCol,
																					 aCol,
																					 NULL,
																					 apv);

		if(FAILED(hr))
			return hr;

		dwAllFlags = dwAllFlags | *(DWORD*)apv[iTAGMETA_Value];

		if(0 == *(DWORD*)apv[iTAGMETA_Value])
			iRowZeroFlag = iRow;

		cch = cch + wcslen((LPWSTR)apv[iTAGMETA_InternalName]) + 3;

	}

	if(0 != (dwValue & (~(dwValue & dwAllFlags))))
	{
		//
		//	There are one or more unknown bits set. Spit out a regular number.
		//

		_itow(dwValue, wszBufferDW, 10);
		*pwszData = new WCHAR[wcslen(wszBufferDW)+1];
		if(NULL == *pwszData)
			return E_OUTOFMEMORY;
		wcscpy(*pwszData, wszBufferDW);
		return S_OK;

	}
	else if(0 == dwValue)
	{
		if(-1 == iRowZeroFlag)
		{
			_itow(dwValue, wszBufferDW, 10);
			*pwszData = new WCHAR[wcslen(wszBufferDW)+1];
			if(NULL == *pwszData)
				return E_OUTOFMEMORY;
			wcscpy(*pwszData, wszBufferDW);
			return S_OK;
		}
		else
		{
			iCol = iTAGMETA_InternalName;

			hr = (m_pCWriterGlobalHelper->m_pISTTagMetaIIsConfigObject)->GetColumnValues(iRowZeroFlag,
																						 1,
																						 &iCol,
																						 NULL,
																						 (LPVOID*)&wszFlag);

			if(FAILED(hr))
				return hr;


			*pwszData = new WCHAR[wcslen(wszFlag)+1];
			if(NULL == *pwszData)
				return E_OUTOFMEMORY;
			**pwszData = 0;
			wcscat(*pwszData, wszFlag);
			return S_OK;

		}
	}
	else
	{
		//
		// Make another pass, and convert flag to string.
		//

		*pwszData = new WCHAR[cch+1];
		if(NULL == *pwszData)
			return E_OUTOFMEMORY;
		**pwszData = 0;
		
		for(iStartRow=0,iRow=0;;iStartRow=++iRow)
		{

			hr = (m_pCWriterGlobalHelper->m_pISTTagMetaIIsConfigObject)->GetRowIndexBySearch(iStartRow, 
																							 cColSearch, 
																							 aColSearch,
																							 NULL, 
																							 apvSearch,
																							 &iRow);

			if(E_ST_NOMOREROWS == hr)
			{
				hr = S_OK;
				break;
			}
			else if(FAILED(hr))
				return hr;

			hr = (m_pCWriterGlobalHelper->m_pISTTagMetaIIsConfigObject)->GetColumnValues(iRow,
																						 cCol,
																						 aCol,
																						 NULL,
																						 apv);

			if(FAILED(hr))
				return hr;

			if(0 != (dwValue & (*(DWORD*)apv[iTAGMETA_Value])))
			{
				if(**pwszData != 0)
					wcscat(*pwszData, L" | ");

				wcscat(*pwszData, (LPWSTR)apv[iTAGMETA_InternalName]);
			}

		}

	}

	return S_OK;

} // CLocationWriter::FlagToString


HRESULT CLocationWriter::BoolToString(DWORD      dwValue,
					                  LPWSTR*    pwszData)
{
	*pwszData = new WCHAR[g_cchMaxBoolStr+1];
	if(NULL == *pwszData)
		return E_OUTOFMEMORY;

	if(dwValue)
		wcscpy(*pwszData, g_wszTrue);
	else
		wcscpy(*pwszData, g_wszFalse);

	return S_OK;

} // CLocationWriter::BoolToString
*/

DWORD CLocationWriter::GetMetabaseType(DWORD dwType,
									   DWORD dwMetaFlags)
{
	if(dwType <= 5)
		return dwType;  // Already metabase type.

	switch(dwType)
	{
		case 19:
			return DWORD_METADATA;
		case 128:
			return BINARY_METADATA;
		case 130:
			if(0 != (dwMetaFlags & fCOLUMNMETA_MULTISTRING))
				return MULTISZ_METADATA;
			else if(0 != (dwMetaFlags & fCOLUMNMETA_EXPANDSTRING))
				return EXPANDSZ_METADATA;
			else
				return STRING_METADATA;
		default:
			break;
	}

	return -1;

} //  CLocationWriter::GetMetabaseType

/*
HRESULT CLocationWriter::EscapeString(LPCWSTR wszString,
                                      BOOL*   pbEscaped,
									  LPWSTR* pwszEscaped)
{

	HRESULT hr = S_OK;

	//
	// Escape the string only if it has characters that are unreadable in text
	// editors such as notepad etc.
	//

	ULONG lenwsz = wcslen(wszString);
	ULONG cchAdditional = 0;

	const ULONG   cchCharAsHex = (sizeof(WCHAR)*2) + 4; // Each byte is represented as 2 WCHARs plu 4 additional escape chars.
	WCHAR   wszCharAsHex[cchCharAsHex];			
	LPWSTR  wszQuote = L"&quot;";
	ULONG   cchQuote = wcslen(wszQuote);
	LPWSTR  wszAmp = L"&amp;";
	ULONG   cchAmp = wcslen(wszAmp);
	LPWSTR  wszlt = L"&lt;";
	ULONG   cchlt = wcslen(wszlt);
	LPWSTR  wszgt = L"&gt;";
	ULONG   cchgt = wcslen(wszgt);

	*pbEscaped = FALSE;

	for(ULONG i=0; i<lenwsz; i++)
	{

		BYTE* pByte = (BYTE*)&(wszString[i]);

		switch(pByte[1])
		{
		
			case 0:

				//
				// 2nd byte is 0. Now check if the 1st byte has readable 
				// characters.
				// 

				if(pByte[0] >= 127)
					cchAdditional = cchAdditional + cchCharAsHex;
				else
				{
					switch(pByte[0])
					{
						case 1:
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7:
						case 8:
						case 11:
						case 12:
						case 14:
						case 15:
						case 16:
						case 17:
						case 18:
						case 19:
						case 20:
						case 21:
						case 22:
						case 23:
						case 24:
						case 25:
						case 26:
						case 27:
						case 28:
						case 29:
						case 30:
						case 31:
							cchAdditional = cchAdditional + cchCharAsHex;
							*pbEscaped = TRUE;
							break;
						case 34:	// "
							cchAdditional = cchAdditional + cchQuote;
							*pbEscaped = TRUE;
							break;
						case 38:	// &
							cchAdditional = cchAdditional + cchAmp;
							*pbEscaped = TRUE;
							break;
						case 60:	// <
							cchAdditional = cchAdditional + cchlt;
							*pbEscaped = TRUE;
							break;
						case 62:	// >
							cchAdditional = cchAdditional + cchgt;
							*pbEscaped = TRUE;
							break;
						case 44:	// '
						case  9:	// Tab
						case 10:	// Line feed
						case 13:    // Carriage return
						default:
							break;
					} // End of switch of 1st byte for char
				}
				
				break;

			default:

				//
				// 2nd byte has a value. Hence needs escaping.
				//
				cchAdditional = cchAdditional + cchCharAsHex;
				*pbEscaped = TRUE;
				break;

		} // End of switch for 2nd byte of char

	} // End of For all chars in string

	if(*pbEscaped)
	{
		*pwszEscaped = new WCHAR[lenwsz+cchAdditional+1];
		if(NULL == *pwszEscaped)
			return E_OUTOFMEMORY;
		**pwszEscaped = 0;

		for(ULONG i=0; i<lenwsz; i++)
		{

			BYTE* pByte = (BYTE*)&(wszString[i]);

			switch(pByte[1])
			{
			
				case 0:

					//
					// 2nd byte is 0. Now check if the 1st byte has readable 
					// characters.
					// 

					if(pByte[0] >= 127)
					{
						_snwprintf(wszCharAsHex, cchCharAsHex, L"&#x%04hX;", wszString[i]);
					    wcsncat(*pwszEscaped, (WCHAR*)wszCharAsHex, cchCharAsHex);
                    }
					else
					{
						switch(pByte[0])
						{
							case 1:
							case 2:
							case 3:
							case 4:
							case 5:
							case 6:
							case 7:
							case 8:
							case 11:
							case 12:
							case 14:
							case 15:
							case 16:
							case 17:
							case 18:
							case 19:
							case 20:
							case 21:
							case 22:
							case 23:
							case 24:
							case 25:
							case 26:
							case 27:
							case 28:
							case 29:
							case 30:
							case 31:
								_snwprintf(wszCharAsHex, cchCharAsHex, L"&#x%04hX;", wszString[i]);
								wcsncat(*pwszEscaped, (WCHAR*)wszCharAsHex, cchCharAsHex);
								break;
							case 34:	// "
							    wcsncat(*pwszEscaped, wszQuote, cchQuote);
								break;
							case 38:	// &
							    wcsncat(*pwszEscaped, wszAmp, cchAmp);
								break;
							case 60:	// <
							    wcsncat(*pwszEscaped, wszlt, cchlt);
								break;
							case 62:	// >
							    wcsncat(*pwszEscaped, wszgt, cchgt);
								break;
							case 44:	// '
							case  9:	// Tab
							case 10:	// Line feed
							case 13:    // Carriage return
							default:
							    wcsncat(*pwszEscaped, (WCHAR*)&(wszString[i]), sizeof(WCHAR));
								break;
						}
					}
					
					break;

				default:

					//
					// 2nd byte has a value. Hence needs escaping.
					//
					_snwprintf(wszCharAsHex, cchCharAsHex, L"&#x%04hX;", wszString[i]);
					wcsncat(*pwszEscaped, (WCHAR*)wszCharAsHex, cchCharAsHex);
					break;
			}

		}

	} // End of if(*pbEscaped)
	else
		*pwszEscaped = (LPWSTR)wszString;

	return S_OK;

} // CLocationWriter::EscapeString
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\stackdlg.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
// StackDlg.h : Declaration of the CStackDlg

#ifndef __STACKDLG_H_
#define __STACKDLG_H_

#include <StackDlgIds.h>

/////////////////////////////////////////////////////////////////////////////
// CDialog - Implements a dialog box

/////////////////////////////////////////////////////////////////////////////
// CStackDlg

class CStackDlg 
{

private:
		HWND m_hWnd;
		WCHAR * m_szMsg;
		HDESK   m_hdeskCurrent;      
		HDESK   m_hdeskTest;
		HDESK   m_hDesk;      
		HWINSTA m_hwinstaCurrent;      
		HWINSTA m_hwinsta;   
		BOOL SwitchToInteractiveDesktop();
		BOOL ResetDesktop();


public:

	CStackDlg(WCHAR * sz);
	~CStackDlg();

	enum { IDD = IDD_STACKDLG };
	static LONG_PTR StackDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

	LONG_PTR DoModal();
	static BOOL CenterWindow(HWND hWnd);

};



#endif //__STACKDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\svcerr.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include <unicode.h>
#include <windows.h>
#include <stdarg.h>
#include <malloc.h>
#include <svcerr.h>
#include <utsem.h>
#include <Debug.h>
#include <svcmsg.h>
#include "stackwalk.h"
#include "stackdlg.h"
#include "WinWrap.h"
#include "TextFileLogger.h"

#include "..\..\core\catinproc\resource.h"
#include "catmacros.h"
#ifndef __HASH_H__
    #include "hash.h"
#endif

extern HMODULE g_hModule;// Module handle
LPWSTR  g_wszDefaultProduct = L"";//this can be changed by CatInProc or whomever knows best what the default product ID is.
bool    g_bReportErrorsToEventLog = true;
bool    g_bReportErrorsToTextFile = true;

// static function pointers - These functions are available in only some of the OSes, so we need to GetProcAddress for them (ie Win95 doesn't support IsDebuggerPresent)
typedef BOOL (__stdcall * ISDEBUGGERPRESENT)();
static ISDEBUGGERPRESENT pfnIsDebuggerPresent = 0;

// functions

void Load_IsDebuggerPresent()
{
    HINSTANCE hKernel32 = LoadLibraryA("kernel32.dll");
    pfnIsDebuggerPresent = reinterpret_cast<ISDEBUGGERPRESENT>(GetProcAddress(hKernel32, "IsDebuggerPresent"));//GetProcAddress tolerates NULL instance handles
    FreeLibrary(hKernel32);
}

void LogWinError (const wchar_t* szMsg,
                  int   rc,
                  const wchar_t* szFile, 
                  int   iLine)
{
    CErrorInterceptor(  0                           ,//ISimpleTableWrite2 **           ppErrInterceptor,
                        0                           ,//IAdvancedTableDispenser *       pDisp,
                        static_cast<HRESULT>(rc)    ,//HRESULT                         hrErrorCode,
                        ID_CAT_CAT                  ,//ULONG                           ulCategory,
                        IDS_CATALOG_INTERNAL_ERROR  ,//ULONG                           ulEvent,
                        szMsg                       ,//LPCWSTR                         szString1,
                        0                           ,//ULONG                           ulInterceptor=0,
                        0                           ,//LPCWSTR                         szTable=0,
                        eDETAILEDERRORS_Unspecified ,//eDETAILEDERRORS_OperationType   OperationType=eDETAILEDERRORS_Unspecified,
                        iLine                       ,//ULONG                           ulRow=-1,
                        -1                          ,//ULONG                           ulColumn=-1,
                        szFile                       //LPCWSTR                         szConfigurationSource=0,
                        ).WriteToLog(szFile, iLine);
}

void LogString (const wchar_t* szMsg, const wchar_t* szFile, int iLine)
{
    LogWinError(szMsg, E_FAIL, szFile, iLine);
}

// Failfast tools
void FailFastStr(const wchar_t * szString, const wchar_t * szFile, int nLine)
{
    if (DebugFlags::DebugBreakOnFailFast())
    {
        if(0 == pfnIsDebuggerPresent)
            Load_IsDebuggerPresent();

        if(pfnIsDebuggerPresent && pfnIsDebuggerPresent())
        {
            DebugBreak();
            return;
        }
        else
        {
            LONG_PTR mbRet; 
            int nLen = 0;
            int nSize = 0;
            StackWalker resolver(GetCurrentProcess());
            Symbol* symbol = NULL;
            CONTEXT ctx;
            ZeroMemory(&ctx, sizeof ctx);
            ctx.ContextFlags = CONTEXT_CONTROL;
            GetThreadContext(GetCurrentThread(), &ctx);
            symbol = resolver.CreateStackTrace(&ctx);
            nLen = resolver.GetCallStackSize(symbol);
            WCHAR * szStack = new WCHAR[nLen];
            if(0 == szStack)
                return;//cannot continue, and since this is the error handling code, no sense in returning an error code
            resolver.GetCallStack(symbol, nLen, szStack);
            WCHAR szExeName[MAX_PATH];
            *szExeName = NULL;
            nLen = lstrlen(szStack);
            nLen +=   GetModuleFileName(NULL, szExeName, MAX_PATH);
            WCHAR * sz = new WCHAR[512 + nLen];
            if(0 == sz)
            {
                delete [] szStack;
                return;//cannot continue, and since this is the error handling code, no sense in returning an error code
            }
            WCHAR szTime[16];
            WCHAR szDate[16];
            DWORD pid = GetCurrentProcessId();
            DWORD tid = GetCurrentThreadId();
            wsprintf(sz, L"File:\t\t\t%s\r\n"
                         L"Line:\t\t\t%d\r\n"
                         L"EXE Name:\t\t%s\r\n"
                         L"ThreadId:\t\t\t0x%08X (%u)\r\n"
                         L"ProcessId:\t\t0x%08X (%u)\r\n"
                         L"Time:\t\t\t%s\r\n"
                         L"Date:\t\t\t%s\r\n"
                         L"Message:\t\t\t%s\r\n\r\n"
                         L"Callstack:\r\n", 
                     szFile, nLine,
                     szExeName, 
                     tid, tid, 
                     pid, pid, 
                     _wstrtime(szTime),
                     _wstrdate(szDate),
                      szString); 

            lstrcat(sz, szStack);
            CStackDlg dlg(sz);
            mbRet = dlg.DoModal();
            delete [] szStack;
            delete [] sz;

            if (mbRet == IDC_DEBUG_BREAK)
            {
                DebugBreak();
                return;
            }       
            else if (mbRet == IDC_IGNORE)
            {
                return;
            }
            // else fall through and terminate

        }
    }

    TerminateProcess(GetCurrentProcess(), 666);
}
// Tracing tools

void Trace (const wchar_t* szPattern, ...)
{
    wchar_t     szMsgBuf[500];
    wchar_t     szOutBuf[550];
    va_list     arguments;

    va_start(arguments, szPattern);
    int rc = wvsprintf(szMsgBuf, szPattern, arguments);
    va_end(arguments);

    // Add a final CRLF only if it wasn't supplied by the caller

    wsprintf(szOutBuf, L"%d.%d> Config: %s%s",
        GetCurrentProcessId(), GetCurrentThreadId(), szMsgBuf,
        (szMsgBuf[lstrlen(szMsgBuf) - 1] != L'\n') ? L"\r\n" : L""
    );

    OutputDebugString(szOutBuf);
}

void Assert(const wchar_t * szString, const wchar_t * szFile, int nLine)
{
    if(0 == pfnIsDebuggerPresent)
        Load_IsDebuggerPresent();

    if(pfnIsDebuggerPresent && pfnIsDebuggerPresent())
    {
        DebugBreak();
        return;
    }
    else
    {
        LONG_PTR mbRet; 
        int nLen = 0;
        int nSize = 0;

        StackWalker resolver(GetCurrentProcess());
        Symbol* symbol = NULL;
        CONTEXT ctx;
        ZeroMemory(&ctx, sizeof ctx);
        ctx.ContextFlags = CONTEXT_CONTROL;
        GetThreadContext(GetCurrentThread(), &ctx);
        symbol = resolver.CreateStackTrace(&ctx);
        nLen = resolver.GetCallStackSize(symbol);
        WCHAR * szStack = new WCHAR[nLen];
        if(0 == szStack)
            return;
        resolver.GetCallStack(symbol, nLen, szStack);

        WCHAR szExeName[MAX_PATH];
        *szExeName = NULL;
        nLen = lstrlen(szStack);
        nLen +=   GetModuleFileName(NULL, szExeName, MAX_PATH);
        WCHAR * sz = new WCHAR[4096 + nLen + wcslen(szString)];
        if(0 == sz)
        {
            delete [] szStack;
            return;
        }
        WCHAR szTime[16];
        WCHAR szDate[16];
        DWORD pid = GetCurrentProcessId();
        DWORD tid = GetCurrentThreadId();

        wsprintf(sz, L"File:\t\t\t%s\r\n"
                     L"Line:\t\t\t%d\r\n"
                     L"EXE Name:\t\t%s\r\n"
                     L"ThreadId:\t\t\t0x%08X (%u)\r\n"
                     L"ProcessId:\t\t0x%08X (%u)\r\n"
                     L"Time:\t\t\t%s\r\n"
                     L"Date:\t\t\t%s\r\n"
                     L"Message:\t\t\t%s\r\n\r\n"
                     L"Callstack:\r\n", 
                 szFile, nLine,
                 szExeName, 
                 tid, tid, 
                 pid, pid, 
                 _wstrtime(szTime),
                 _wstrdate(szDate),
                  szString); 

        lstrcat(sz, szStack);
        CStackDlg dlg(sz);
        mbRet = dlg.DoModal();
        delete [] szStack;
        delete [] sz;

        if (mbRet == IDC_DEBUG_BREAK)
        {
            DebugBreak();
            return;
        }       
        else if (mbRet == IDC_IGNORE)
        {
            return;
        }
        else if (mbRet == IDC_ABORT)
        {
            TerminateProcess(GetCurrentProcess(), 666);
        }
    }
}


// this function returns non-zero if it expects the caller to break in the debugger via Sytem.Debug.Break
// this function should only be called by the managed code layer
int Assert2(const wchar_t * szString, const wchar_t * szStack)
{
    LONG_PTR mbRet; 
    int nLen = 0;
    int nSize = 0;

    WCHAR szExeName[MAX_PATH];
    *szExeName = NULL;
    nLen = lstrlen(szStack);
    nLen +=   GetModuleFileName(NULL, szExeName, MAX_PATH);
    WCHAR * sz = new WCHAR[4096 + nLen + wcslen(szString)];
    if(0 == sz)
        return 0;
    WCHAR szTime[16];
    WCHAR szDate[16];
    DWORD pid = GetCurrentProcessId();
    DWORD tid = GetCurrentThreadId();

    // prepare the string that's going to be displayed in the window
    wchar_t *szTemp = const_cast<wchar_t *>(szString);
    if (szTemp == NULL) szTemp = L"";

    wsprintf(sz, L"EXE Name:\t\t%s\r\n"
                 L"ThreadId:\t\t\t0x%08X (%u)\r\n"
                 L"ProcessId:\t\t0x%08X (%u)\r\n"
                 L"Time:\t\t\t%s\r\n"
                 L"Date:\t\t\t%s\r\n"
                 L"Message:\t\t\t%s\r\n\r\n"
                 L"Callstack:\r\n", 
             szExeName, 
             tid, tid, 
             pid, pid, 
             _wstrtime(szTime),
             _wstrdate(szDate),
              szTemp); 

    lstrcat(sz, szStack);
    CStackDlg dlg(sz);
    mbRet = dlg.DoModal();
    delete [] sz;

    if (mbRet == IDC_DEBUG_BREAK)
    {
        return 1;
    }       
    else if (mbRet == IDC_IGNORE)
    {
        return 0;
    }
    else if (mbRet == IDC_ABORT)
    {
        TerminateProcess(GetCurrentProcess(), 666);
    }
    return 0; // this should never execute - it's here to stop the compiler from complaining
}


/////////////////////////////////////////////////////
//
// TErrorLogWriter
//
// This object writes an entry into the EventLog and
// one into the CatalogEventLog XML file.
//
class TErrorLogWriter
{
public:
    TErrorLogWriter() : m_hEventSource(0)
    {
    }
    ~TErrorLogWriter()
    {
        Close();
    }
    HRESULT WriteDetailedErrors(tDETAILEDERRORSRow &row, ULONG * aSizes=0, ULONG cSizes=0);
private:
    void TraceEvent(tDETAILEDERRORSRow &row, LPCWSTR* lpStrings);
    HRESULT Open(LPCWSTR wszSourceName);
    HRESULT Close();

    HANDLE m_hEventSource;
};

TErrorLogWriter g_ErrorLogWriter;

HRESULT TErrorLogWriter::Open(LPCWSTR wszSourceName)
{
    m_hEventSource = RegisterEventSource(NULL, wszSourceName);
    return S_OK;
}

HRESULT TErrorLogWriter::Close()
{
    if(0 != m_hEventSource)
        DeregisterEventSource(m_hEventSource);
    return S_OK;
}

HRESULT TErrorLogWriter::WriteDetailedErrors(tDETAILEDERRORSRow &row, ULONG * aSizes, ULONG cSizes)
{
    HRESULT hr;

    if(0==m_hEventSource)
        if(FAILED(hr = Open(row.pSource)))
            return hr;

    ASSERT(row.pString1);
    ASSERT(row.pString2);
    ASSERT(row.pString3);
    ASSERT(row.pString4);
    ASSERT(row.pString5);

    LPCWSTR pStrings[5];
    pStrings[0] = row.pString1;
    pStrings[1] = row.pString2;
    pStrings[2] = row.pString3;
    pStrings[3] = row.pString4;
    pStrings[4] = row.pString5;

    if(g_bReportErrorsToEventLog)
        ReportEvent(m_hEventSource, LOWORD(*row.pType), LOWORD(*row.pCategory), *row.pEvent, 0, 5, 0, pStrings, 0);
    //TraceEvent(row, pStrings);

    if(g_bReportErrorsToTextFile)
        TextFileLogger(row.pSource, g_hModule).Report(LOWORD(*row.pType), LOWORD(*row.pCategory), *row.pEvent, 5, 0, pStrings, 0);

    return S_OK;
}

void TErrorLogWriter::TraceEvent(tDETAILEDERRORSRow &row, LPCWSTR* lpStrings)
{
    //TRACE can only handle about 500 bytes, so we'll just OutpuDebugString

    static LPCWSTR pwszType[17]={L"Success", L"Error", L"Warning", L"unknown", L"Information", L"unknown", L"unknown", L"unknown", L"AuditSuccess"
        , L"unknown", L"unknown", L"unknown", L"unknown", L"unknown", L"unknown", L"unknown", L"AuditFailure"};

    WCHAR wszTraceTempBuf[1024];
    wsprintf(wszTraceTempBuf, L"-----Event Logged-----\r\n%-20s\t: %s", L"Type", pwszType[*row.pType]);
    OutputDebugString(wszTraceTempBuf);

    int len;
    
    // Write the message category.
    WCHAR szBuf[2048];
    len = FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK | 
                        FORMAT_MESSAGE_FROM_HMODULE |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        g_hModule,
                        *row.pCategory,
                        0,
                        szBuf,
                        sizeof(szBuf)/sizeof(WCHAR),
                        (va_list*)lpStrings);
    if (len == 0)
        wsprintf(wszTraceTempBuf, L"\r\n%-20s\t: %d", L"Catagory", *row.pCategory);
    else
        wsprintf(wszTraceTempBuf, L"\r\n%-20s\t: %s", L"Catagory", szBuf);
    OutputDebugString(wszTraceTempBuf);
    
    // Write the event ID.
    wsprintf(wszTraceTempBuf, L"\r\n%-20s\t: 0x%04X\r\n", L"Event", (*row.pEvent & 0xFFFF));
    OutputDebugString(wszTraceTempBuf);
    
    // Write out the formatted message.
    len = FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK |
                        FORMAT_MESSAGE_FROM_HMODULE |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        g_hModule, 
                        *row.pEvent,
                        0,
                        szBuf,
                        sizeof(szBuf)/sizeof(WCHAR),
                        (va_list*)lpStrings);
    if (len == 0)
    {
        wsprintf(wszTraceTempBuf, L"\r\nWARNING!!!! Message String Not Found - Make sure the MC file is updated!!");
        OutputDebugString(wszTraceTempBuf);
        for (WORD i = 0; i < 5; ++i)
        {
            wsprintf(wszTraceTempBuf, L"\r\nString%d             :\t", i);
            OutputDebugString(wszTraceTempBuf);
            OutputDebugString(lpStrings[i]);
        }
    }
    else
    {
        OutputDebugString(szBuf);
    }
    OutputDebugString(L"\r\n");
}


//class CErrorInterceptor implementation
ULONG CErrorInterceptor::cError=0;
CErrorInterceptor::CErrorInterceptor(
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        LPCWSTR                         szString4,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        BOOL                            bNotUsed)
                        : m_pStorage(0)
{
    Init(   0,   0,    hrErrorCode,    ulCategory,    ulEvent,    szString1, szString2, szString3, szString4,
            0,   0,    eDETAILEDERRORS_Unspecified,   -1,         -1,        0,         eType);
}
CErrorInterceptor::CErrorInterceptor(
                        ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        ULONG                           ulInterceptor,
                        LPCWSTR                         szTable,
                        eDETAILEDERRORS_OperationType   OperationType,
                        ULONG                           ulRow,
                        ULONG                           ulColumn,
                        LPCWSTR                         szConfigurationSource,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        ULONG                           MajorVersion,
                        ULONG                           MinorVersion)
                        : m_pStorage(0)
{
    Init(   ppErrInterceptor,   pDisp,    hrErrorCode,    ulCategory,    ulEvent,    szString1,     0,      0,      0,
            ulInterceptor,      szTable,  OperationType,  ulRow,         ulColumn,   szConfigurationSource, eType,  pData,  cbData, MajorVersion, MinorVersion);
}
CErrorInterceptor::CErrorInterceptor(
                        ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        ULONG                           ulInterceptor,
                        LPCWSTR                         szTable,
                        eDETAILEDERRORS_OperationType   OperationType,
                        ULONG                           ulRow,
                        ULONG                           ulColumn,
                        LPCWSTR                         szConfigurationSource,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        ULONG                           MajorVersion,
                        ULONG                           MinorVersion)
                        : m_pStorage(0)
{
    Init(   ppErrInterceptor,   pDisp,    hrErrorCode,    ulCategory,    ulEvent,    szString1,    szString2,    0,    0,
            ulInterceptor,      szTable,  OperationType,  ulRow,         ulColumn,   szConfigurationSource,      eType,         pData,        cbData, MajorVersion, MinorVersion);
}
CErrorInterceptor::CErrorInterceptor(
                        ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        ULONG                           ulInterceptor,
                        LPCWSTR                         szTable,
                        eDETAILEDERRORS_OperationType   OperationType,
                        ULONG                           ulRow,
                        ULONG                           ulColumn,
                        LPCWSTR                         szConfigurationSource,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        ULONG                           MajorVersion,
                        ULONG                           MinorVersion)
                        : m_pStorage(0)
{
    Init(   ppErrInterceptor,   pDisp,    hrErrorCode,    ulCategory,    ulEvent,    szString1,    szString2,    szString3,    0,
            ulInterceptor,      szTable,  OperationType,  ulRow,         ulColumn,   szConfigurationSource,      eType,         pData,        cbData, MajorVersion, MinorVersion);
}
CErrorInterceptor::CErrorInterceptor(
                        ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        LPCWSTR                         szString4,
                        ULONG                           ulInterceptor,
                        LPCWSTR                         szTable,
                        eDETAILEDERRORS_OperationType   OperationType,
                        ULONG                           ulRow,
                        ULONG                           ulColumn,
                        LPCWSTR                         szConfigurationSource,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        ULONG                           MajorVersion,
                        ULONG                           MinorVersion)
                        : m_pStorage(0)
{
    Init(   ppErrInterceptor,   pDisp,    hrErrorCode,    ulCategory,    ulEvent,    szString1,    szString2,    szString3,    szString4,
            ulInterceptor,      szTable,  OperationType,  ulRow,         ulColumn,   szConfigurationSource,      eType,         pData,        cbData, MajorVersion, MinorVersion);
}
void CErrorInterceptor::Init(
                        ISimpleTableWrite2 **           ppErrInterceptor,
                        IAdvancedTableDispenser *       pDisp,
                        HRESULT                         hrErrorCode,
                        ULONG                           ulCategory,
                        ULONG                           ulEvent,
                        LPCWSTR                         szString1,
                        LPCWSTR                         szString2,
                        LPCWSTR                         szString3,
                        LPCWSTR                         szString4,
                        ULONG                           ulInterceptor,
                        LPCWSTR                         szTable,
                        eDETAILEDERRORS_OperationType   OperationType,
                        ULONG                           ulRow,
                        ULONG                           ulColumn,
                        LPCWSTR                         szConfigurationSource,
                        eDETAILEDERRORS_Type            eType,
                        unsigned char *                 pData,
                        ULONG                           cbData,
                        ULONG                           MajorVersion,
                        ULONG                           MinorVersion)
{
    m_pStorage = new ErrorInterceptorStorage;
    if(0 == m_pStorage)
    {
        m_hr = E_OUTOFMEMORY;
        return;
    }

    m_pStorage->m_pIErrorInfo = 0;
    m_pStorage->m_pISTWriteError = 0;
    m_pStorage->m_pISTControllerError = 0;

    m_hr = S_OK;

    if(0 != ppErrInterceptor)
    {
        if(0 == *ppErrInterceptor)//If the user passed us a valid pp but *p is zero then we need to
        {                         //instantiate an error table.
            if(FAILED(m_hr = pDisp->GetTable(wszDATABASE_ERRORS, wszTABLE_DETAILEDERRORS, 0, 0, eST_QUERYFORMAT_CELLS,
                                fST_LOS_UNPOPULATED, reinterpret_cast<LPVOID *>(&m_pStorage->m_pISTWriteError))))
                return;
            *ppErrInterceptor = m_pStorage->m_pISTWriteError;//we don't keep a ref count, the caller is responsible for that
        }
        else
        {
            m_pStorage->m_pISTWriteError = *ppErrInterceptor;//we don't keep a ref count, the caller is responsible for that
        }

        if(FAILED(m_hr = m_pStorage->m_pISTWriteError->QueryInterface(IID_ISimpleTableController, reinterpret_cast<LPVOID *>(&m_pStorage->m_pISTControllerError))))
            return;
        if(FAILED(m_hr = m_pStorage->m_pISTWriteError->QueryInterface(IID_ISimpleTableController, reinterpret_cast<LPVOID *>(&m_pStorage->m_pIErrorInfo))))
            return;
    }


/*
struct tDETAILEDERRORSRow {
         ULONG *     pErrorID;              //Inferred as some unique increasing value
         WCHAR *     pDescription;          //Inferred from the other columns
         WCHAR *     pDate;                 //Inferred from API call
         WCHAR *     pTime;                 //Inferred from API call
         WCHAR *     pSource;               //Passed in or obtained from the Dispenser
         ULONG *     pType;                 //Inferred from the Upper 2 bits of the HRESULT ErrorCode
         ULONG *     pCategory;             //Passed in / defaulted to ID_CAT_CAT
         WCHAR *     pUser;                 //Inferred from API call - This is the user account that was running or N/A
         WCHAR *     pComputer;             //Interred from API call
 unsigned char *     pData;                 //User binary data may be passed in
         ULONG *     pEvent;                //MessageID
         WCHAR *     pString1;              //Passed in - defaulted to "" - perhaps an example of the offending XML
         WCHAR *     pString2;              //Passed in - defaulted to "" - perhaps an explaination of what's wrong with the XML
         WCHAR *     pString3;              //Passed in - defaulted to ""
         WCHAR *     pString4;              //Passed in - defaulted to ""
         ULONG *     pErrorCode;            //Passed in - HRESULT
         ULONG *     pInterceptor;          //Passed in - Interceptor enum
         WCHAR *     pInterceptorSource;    //Inferred __FILE__ __LINE__
         ULONG *     pOperationType;        //Passed in - enum (Unspecified (default), Populate or UpdateStore)
         WCHAR *     pTable;                //Passed in - TableName
         WCHAR *     pConfigurationSource;  //Passed in - filename
         ULONG *     pRow;                  //Passed in - fast cache row, or XML line number
         ULONG *     pColumn;               //Passed in - fast cache column or XML column
         ULONG *     pMajorVersion;         //Passed in - Usually the Metabase Edit While Running MajorVersion
         ULONG *     pMinorVersion;         //Passed in - Usually the Metabase Edit While Running MinorVersion
};
*/
    SYSTEMTIME  systime;
    GetSystemTime(&systime);

    SetSourceFileName();
    SetErrorID(systime);
    //SetDescription();This must be set last since it's the consolidation of all the other information
    SetDate(systime);
    SetTime(systime);
    SetSource(pDisp);
    SetType(hrErrorCode, eType);
    SetCategory(ulCategory);
    SetUser();
    SetComputer();
    SetData();
    SetEvent(ulEvent);
    SetMessageString();//This must be called after SetEvent
    SetString1(const_cast<LPWSTR>(szString1));
    SetString2(const_cast<LPWSTR>(szString2));
    SetString3(const_cast<LPWSTR>(szString3));
    SetString4(const_cast<LPWSTR>(szString4));
    SetErrorCode(hrErrorCode);
    SetInterceptor(ulInterceptor);
    //SetInterceptorSource();//This is filled in by WriteToLog
    SetOperationType(OperationType);
    SetTable(const_cast<LPWSTR>(szTable));
    SetConfigurationSource(const_cast<LPWSTR>(szConfigurationSource));
    SetRow(ulRow);
    SetColumn(ulColumn);
    SetMajorVersion(MajorVersion);
    SetMinorVersion(MinorVersion);
}

HRESULT CErrorInterceptor::WriteToLog(LPCWSTR szSource, ULONG Line, ULONG los)
{
    if(FAILED(m_hr))//if the construction failed, then bail.
        return m_hr;

    SetInterceptorSource(szSource, Line);
    SetString5();
    SetDescription();

    //if an ISTWrite was provided and LOS says to SetErrorInfo
    if(m_pStorage->m_pISTWriteError && (los & fST_LOS_DETAILED_ERROR_TABLE))
    {
        ASSERT(0 != m_pStorage->m_pISTControllerError);//we can't have an ISTWrite without an ISTController

        ULONG iRow;
        if(FAILED(m_hr = m_pStorage->m_pISTControllerError->PrePopulateCache(fST_POPCONTROL_RETAINREAD)))
            return m_hr;
        if(FAILED(m_hr = m_pStorage->m_pISTWriteError->AddRowForInsert(&iRow)))
            return m_hr;
        if(FAILED(m_hr = m_pStorage->m_pISTWriteError->SetWriteColumnValues(iRow, cDETAILEDERRORS_NumberOfColumns, 0, 0,
            reinterpret_cast<LPVOID *>(&m_pStorage->m_errRow))))
            return m_hr;
        if(FAILED(m_hr = m_pStorage->m_pISTControllerError->PostPopulateCache()))
            return m_hr;

        if(FAILED(m_hr = SetErrorInfo(0, m_pStorage->m_pIErrorInfo)))
            return m_hr;
    }

    if(m_pStorage->m_pDispenser)
    {   //if a dispenser is provided (all code that has a dispenser should do this) then use the logger associated with it.
        if(0 == (los & fST_LOS_NO_LOGGING))//only log if this LOS is NOT specified
        {
            CComPtr<ICatalogErrorLogger2> spErrorLogger;
            if(FAILED(m_hr = m_pStorage->m_pDispenser->GetCatalogErrorLogger(&spErrorLogger)))
                return m_hr;
            ASSERT(0 != spErrorLogger.p);
            if(FAILED(m_hr = spErrorLogger->ReportError(
                                 BaseVersion_DETAILEDERRORS
                                ,ExtendedVersion_DETAILEDERRORS
                                ,cDETAILEDERRORS_NumberOfColumns
                                ,0//currently don't support data param
                                ,reinterpret_cast<LPVOID *>(&m_pStorage->m_errRow))))
                return m_hr;
        }
    }
    else
    {   //Some code can't provide a dispenser so we have to default to the g_ErrorLogWriter
        //There is very little control over how things are logged when no dispenser is provided.
        return g_ErrorLogWriter.WriteDetailedErrors(m_pStorage->m_errRow);
    }
    return S_OK;
}


void CErrorInterceptor::SetCategory(ULONG ulCategory)
{
    m_pStorage->m_Category = ulCategory;
    m_pStorage->m_errRow.pCategory = &m_pStorage->m_Category;

    DWORD len = FormatMessage(  FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                g_hModule, 
                                *m_pStorage->m_errRow.pCategory,
                                0,
                                m_pStorage->m_szCategoryString,
                                cchCategoryString,
                                (va_list*)0);
    if(0==len)
    {
        _ultow(*m_pStorage->m_errRow.pCategory, m_pStorage->m_szCategoryString, 10);
    }
    m_pStorage->m_szCategoryString[(len < cchCategoryString) ? len : cchCategoryString-1] = 0x00;//make sure it's NULL terminated (boundary condition)
    m_pStorage->m_errRow.pCategoryString = m_pStorage->m_szCategoryString;
}


void CErrorInterceptor::SetColumn(ULONG ulColumn)
{
    m_pStorage->m_Column = ulColumn;
    m_pStorage->m_errRow.pColumn = (-1 == m_pStorage->m_Column ? 0 : &m_pStorage->m_Column);
}


void CErrorInterceptor::SetComputer()
{
    DWORD _cchComputerName = cchComputerName;
    m_pStorage->m_errRow.pComputer = GetComputerName(m_pStorage->m_szComputerName,  &_cchComputerName) ? m_pStorage->m_szComputerName : 0;
}

void CErrorInterceptor::SetConfigurationSource(LPWSTR wszConfigurationSource)
{
    m_pStorage->m_errRow.pConfigurationSource = wszConfigurationSource;
}

void CErrorInterceptor::SetData()
{
    m_pStorage->m_errRow.pData = 0;
}


void CErrorInterceptor::SetDate(SYSTEMTIME &systime)
{
    m_pStorage->m_errRow.pDate = GetDateFormat(0, DATE_SHORTDATE | LOCALE_NOUSEROVERRIDE, &systime, 0, m_pStorage->m_szDate, cchDate) ? m_pStorage->m_szDate : 0;
}


void CErrorInterceptor::SetDescription()
{
    ASSERT(m_pStorage->m_errRow.pEvent);
    ASSERT(m_pStorage->m_errRow.pString1);
    ASSERT(m_pStorage->m_errRow.pString2);
    ASSERT(m_pStorage->m_errRow.pString3);
    ASSERT(m_pStorage->m_errRow.pString4);
    ASSERT(m_pStorage->m_errRow.pString5);

    LPWSTR lpStrings[5];
    lpStrings[0] = m_pStorage->m_errRow.pString1;
    lpStrings[1] = m_pStorage->m_errRow.pString2;
    lpStrings[2] = m_pStorage->m_errRow.pString3;
    lpStrings[3] = m_pStorage->m_errRow.pString4;
    lpStrings[4] = m_pStorage->m_errRow.pString5;

    DWORD len = FormatMessage(  FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                m_pStorage->m_errRow.pMessageString, 
                                0 /* Event ID is ignored becuase we're loading from the pMessageString*/,
                                0,
                                m_pStorage->m_szDescription,
                                cchDescription,
                                (va_list*)lpStrings);

    m_pStorage->m_szDescription[(len < cchDescription) ? len : cchDescription-1] = 0x00;//make sure it's NULL terminated (boundary condition)
    m_pStorage->m_errRow.pDescription = m_pStorage->m_szDescription;
}


void CErrorInterceptor::SetErrorCode(HRESULT hrErrorCode)
{
    m_pStorage->m_ErrorCode = static_cast<ULONG>(hrErrorCode);
    m_pStorage->m_errRow.pErrorCode = (S_OK==m_pStorage->m_ErrorCode ? 0 : &m_pStorage->m_ErrorCode);
}


void CErrorInterceptor::SetErrorID(SYSTEMTIME &systime)
{
    /*
    typedef struct _SYSTEMTIME { 
        WORD wYear; 
        WORD wMonth; 
        WORD wDayOfWeek; 
        WORD wDay; 
        WORD wHour; 
        WORD wMinute; 
        WORD wSecond; 
        WORD wMilliseconds; 
    } SYSTEMTIME, *PSYSTEMTIME; 
    */

    m_pStorage->m_ErrorID = Hash(m_pStorage->m_szSourceFileName     , 0);
    m_pStorage->m_ErrorID = Hash(systime.wYear          , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wMonth         , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wDayOfWeek     , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wDay           , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wHour          , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wMinute        , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wSecond        , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(systime.wMilliseconds  , m_pStorage->m_ErrorID);
    m_pStorage->m_ErrorID = Hash(++cError               , m_pStorage->m_ErrorID);

    m_pStorage->m_errRow.pErrorID = &m_pStorage->m_ErrorID;
}


void CErrorInterceptor::SetEvent(ULONG ulEvent)
{
    m_pStorage->m_Event = ulEvent;
    m_pStorage->m_errRow.pEvent = &m_pStorage->m_Event;
}


void CErrorInterceptor::SetInterceptor(ULONG ulInterceptor)
{
    m_pStorage->m_Interceptor = ulInterceptor;
    m_pStorage->m_errRow.pInterceptor = (0 == m_pStorage->m_Interceptor ? 0 : &m_pStorage->m_Interceptor);
}


void CErrorInterceptor::SetInterceptorSource(LPCWSTR file, ULONG line)
{
    ASSERT(0 != file);
    wsprintf(m_pStorage->m_szInterceptorSource, L"%s (%d)", file, line);
    m_pStorage->m_errRow.pInterceptorSource = m_pStorage->m_szInterceptorSource;
}


void CErrorInterceptor::SetMajorVersion(ULONG ulMajorVersion)
{
    m_pStorage->m_MajorVersion = ulMajorVersion;
    m_pStorage->m_errRow.pMajorVersion = (-1 == m_pStorage->m_MajorVersion) ? 0 : &m_pStorage->m_MajorVersion;
}


void CErrorInterceptor::SetMessageString()
{
    DWORD len = FormatMessage(  FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                g_hModule, 
                                *m_pStorage->m_errRow.pEvent,
                                0,
                                m_pStorage->m_szMessageString,
                                cchMessageString,
                                (va_list*)0);
    if(0==len)
    {
        len = FormatMessage(    FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                L"The description for this event could not be found.  "
                                L"It contains the following insertion string(s):\r\n%1\r\n%2\r\n%3\r\n%4\r\n%5\r\n%0",
                                *m_pStorage->m_errRow.pEvent,
                                0,
                                m_pStorage->m_szMessageString,
                                cchMessageString,
                                (va_list*)0);
    }
    m_pStorage->m_szMessageString[(len < cchMessageString) ? len : cchMessageString-1] = 0x00;//make sure it's NULL terminated (boundary condition)
    m_pStorage->m_errRow.pMessageString = m_pStorage->m_szMessageString;
}


void CErrorInterceptor::SetMinorVersion(ULONG ulMinorVersion)
{
    m_pStorage->m_MinorVersion = ulMinorVersion;
    m_pStorage->m_errRow.pMinorVersion = (-1 == m_pStorage->m_MajorVersion) ? 0 : &m_pStorage->m_MinorVersion;
}


void CErrorInterceptor::SetOperationType(eDETAILEDERRORS_OperationType OperationType)
{
    m_pStorage->m_OperationType = static_cast<ULONG>(OperationType);
    m_pStorage->m_errRow.pOperationType = (0 == m_pStorage->m_OperationType ? 0 : &m_pStorage->m_OperationType);
}


void CErrorInterceptor::SetRow(ULONG ulRow)
{
    m_pStorage->m_Row = ulRow;
    m_pStorage->m_errRow.pRow = (-1 == m_pStorage->m_Row ? 0 : &m_pStorage->m_Row);
}


void CErrorInterceptor::SetSource(IAdvancedTableDispenser *pDisp)
{
    m_pStorage->m_pDispenser = pDisp;
    ULONG cch = cchSource-14;
    if(0==pDisp || FAILED(pDisp->GetProductID(m_pStorage->m_szSource, &cch)))// count of bytes for L" Config"
        wcscpy(m_pStorage->m_szSource, g_wszDefaultProduct);//Default to " Config"
    wcscat(m_pStorage->m_szSource, L" Config");//The result should be something like "IIS Config", " Config" etc
    m_pStorage->m_errRow.pSource = m_pStorage->m_szSource;

    if((g_bReportErrorsToTextFile || g_bReportErrorsToEventLog) && 0==_wcsicmp(g_wszDefaultProduct, WSZ_PRODUCT_NETFRAMEWORKV1))
    {
        g_bReportErrorsToEventLog = false;
        g_bReportErrorsToTextFile = false;
    }
}

void CErrorInterceptor::SetSourceFileName()
{
    m_pStorage->m_szSourceFileName[0] = 0x00;//just in case GetModuleFileName fails, we'll have a 0 length string as the SourceFilename
    GetModuleFileName(g_hModule, m_pStorage->m_szSourceFileName, cchSourceFileName);
    m_pStorage->m_szSourceFileName[cchSourceFileName-1] = 0x00;//I don't think GetModuleFileName

    m_pStorage->m_errRow.pSourceModuleName = m_pStorage->m_szSourceFileName;
}


void CErrorInterceptor::SetString1(LPWSTR wsz)
{
    wcsncpy(m_pStorage->m_szString1, wsz  ? wsz : L"", cchString1);
    m_pStorage->m_szString1[cchString1 - 1] = 0x00;//NULL terminate it in case the string is too big
    m_pStorage->m_errRow.pString1 = m_pStorage->m_szString1;
}


void CErrorInterceptor::SetString2(LPWSTR wsz)
{
    wcsncpy(m_pStorage->m_szString2, wsz  ? wsz : L"", cchString2);
    m_pStorage->m_szString2[cchString2 - 1] = 0x00;//NULL terminate it in case the string is too big
    m_pStorage->m_errRow.pString2 = m_pStorage->m_szString2;
}


void CErrorInterceptor::SetString3(LPWSTR wsz)
{
    wcsncpy(m_pStorage->m_szString3, wsz  ? wsz : L"", cchString3);
    m_pStorage->m_szString3[cchString3 - 1] = 0x00;//NULL terminate it in case the string is too big
    m_pStorage->m_errRow.pString3 = m_pStorage->m_szString3;
}


void CErrorInterceptor::SetString4(LPWSTR wsz)
{
    wcsncpy(m_pStorage->m_szString4, wsz  ? wsz : L"", cchString4);
    m_pStorage->m_szString4[cchString4 - 1] = 0x00;//NULL terminate it in case the string is too big
    m_pStorage->m_errRow.pString4 = m_pStorage->m_szString4;
}

void CErrorInterceptor::SetString5()
{
    m_pStorage->m_errRow.pString5 = 0;
    FillInInsertionString5(m_pStorage->m_szString5, cchString5, m_pStorage->m_errRow);
}


void CErrorInterceptor::SetTable(LPWSTR wszTable)
{
    m_pStorage->m_errRow.pTable = wszTable;
}



void CErrorInterceptor::SetTime(SYSTEMTIME &systime)
{
    m_pStorage->m_errRow.pTime = GetTimeFormat(0, LOCALE_NOUSEROVERRIDE, &systime, 0, m_pStorage->m_szTime, cchTime) ? m_pStorage->m_szTime : 0;
}


void CErrorInterceptor::SetType(HRESULT hrErrorCode, eDETAILEDERRORS_Type eType)
{                                                                                         //We'll consider hrs of the form 0x80000000, errors since most errors are defined that way
    static ULONG hrToEventType[4] = {eDETAILEDERRORS_SUCCESS, eDETAILEDERRORS_INFORMATION, eDETAILEDERRORS_ERROR/*eDETAILEDERRORS_WARNING*/, eDETAILEDERRORS_ERROR};

    if(eDETAILEDERRORS_SUCCESS == eType)//if SUCCESS then user the error code
        m_pStorage->m_Type = hrToEventType[(hrErrorCode >> 30) & 3];
    else
        m_pStorage->m_Type = eType;//otherwise use what was passed in

    m_pStorage->m_errRow.pType = &m_pStorage->m_Type;
}


void CErrorInterceptor::SetUser()
{
    DWORD _cchUserName = cchUserName;
    m_pStorage->m_errRow.pUser = GetUserName(m_pStorage->m_szUserName,  &_cchUserName) ? m_pStorage->m_szUserName : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\scemawriter.cxx ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    ScemaWriter.cxx

$Header: $

Abstract:


--**************************************************************************/

//
// Some sample code
//

{
	CWriter* pCWriter = new CWriter();

	if(NULL == pcWriter)
	{
		return E_OUTOFMEMORY;
	}

	hr = pcWriter->Initialize(L"MBSchema.XML",
	                          NULL);

	if(FAILED(hr))
	{
		goto exit;
	}

	hr = pCWriter->GetSchemaWriter(&pCSchemaWriter);

	if(FAILED(hr))
	{
		goto exit;
	}

	for(i=0; i<cCollection; i++)
	{
		hr = pCSchemaWriter->GetCollectionWriter(pCollection,
												 &pCCollectionWriter);

		if(FAILED(hr))
		{
			goto exit;
		}
	
		for(j=0; j<cProperty; j++)
		{
			hr = pCCollectionWriter->GetPropertyWriter(&pcPropertyWriter);

			if(FAILED(hr))
			{
				goto exit;
			}

			for(k=0; k<cTag; k++)
			{
				hr = pcPropertyWriter->AddTag()
			}

			hr = pCCollectionWriter->AddProperty(pcPropertyWriter)

		}

		hr = pCSchemaWriter->AddCollectionWriter(pCCollectionWriter);

		if(FAILED(hr))
		{
			goto exit;
		}
	}

	pCSchemaWriter->WriteSchema();

}



class CSchemaWriter
{
	public:
		
		CSchemaWriter();
		~CSchemaWriter();

		HRESULT Initialize(CWriter* pcWriter);

		HRESULT GetCollectionWriter(struct tTABLEMETARow*  i_pCollection,
									CCollectionWriter** o_pCollectionWriter);

		HRESULT AddCollectionWriter(CCollectionWriter*	i_pCCollectionWriter);

		HRESULT WriteSchema();

	private:

		HRESULT ReAllocate();

		CCollectionWriter**	m_apCollection;
		ULONG				m_cCollection;
		ULONG				m_iCollection;
		CWriter*			m_pCWriter;

} // CSchemaWriter


CSchemaWriter::CSchemaWriter:
m_aCollection(NULL),
m_cCollection(0),
m_iCollection(0),
m_pCWriter(NULL)
{

} // CSchemaWriter


CSchemaWriter::~CSchemaWriter()
{
	if(NULL != m_aCollection)
	{
		for(ULONG i=0; i<m_iCollection; i++)
		{
			delete m_apCollection[i];
			m_apCollection[i] = NULL;
		}

		delete [] m_apCollection;
		m_apCollection = NULL;
	}

	m_cCollection = 0;
	m_iCollection = 0;

} // ~CSchemaWriter


HRESULT CSchemaWriter::Initialize(CWriter* i_pcWriter)
{
	m_pCWriter = i_pcWriter;

} // CSchemaWriter::Initialize


HRESULT CSchemaWriter::GetCollectionWriter(struct tTABLEMETARow*  i_pCollection,
										   CCollectionWriter**    o_pCollectionWriter)
{
	HRESULT				hr                 = S_OK;
	CCollectionWriter*	pCCollectionWriter = NULL;

	*o_pCollectionWriter = NULL;

	pCCollectionWriter = new CCollectionWriter();
	if(NULL == pCCollectionWriter)
	{
		return E_OUTOFMEMORY;
	}

	hr = pCCollectionWriter->Initialize(i_pCollection,
		                                m_pCWriter);

	if(FAILED(hr))
	{
		delete pCCollectionWriter;
		pCCollectionWriter = NULL;
	
		return hr;
	}
	else
	{
		*o_pCollectionWriter = pCCollectionWriter;
	}

	return hr;

} // CSchemaWriter::GetCollectionWriter


HRESULT CSchemaWriter::AddCollectionWriter(CCollectionWriter*	i_pCCollectionWriter)
{
	HRESULT hr = S_OK;

	if(m_iCollection == m_cCollection)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	m_aCollection[m_iCollection++] = i_pCCollectionWriter;

	return hr;

} // CSchemaWriter::AddCollectionWriter


HRESULT CSchemaWriter::ReAllocate()
{
	CCollectionWriter** pSav = m_aCollection;

	m_aCollection = new CCollectionWriter*[m_cCollection + cMaxCCollection];
	if(NULL == m_aCollection)
	{
		return E_OUTOFMEMORY;
	}
	memset(m_aCollection, 0, (sizeof(CCollectionWriter*))*(m_cCollection + cMaxCCollection));

	if(NULL != pSav)
	{
		memcpy(m_aCollection, pSav, (sizeof(CCollectionWriter*))*(m_cCollection));
	}

	m_cCollection = m_cCollection + cMaxCCollection;

	return S_OK;

} // CSchemaWriter::ReAllocate


HRESULT CSchemaWriter::WriteSchema()
{
	HRESULT hr = S_OK;

	hr = BeginWriteSchema();

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_iCollection; i++)
	{
		hr = (m_aCollection[i])->WriteCollection();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	hr = EndWriteSchema();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CSchemaWriter::WriteSchema


HRESULT CSchemaWriter::BeginWriteSchema()
{
	HRESULT		hr      = S_OK;
	WCHAR*		wszTemp = g_wszTemp;

	if(g_cchBeginSchema+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[g_cchBeginSchema+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	memcpy(wszTemp, g_wszBeginSchema, (g_cchBeginSchema+1)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         g_cchBeginSchema);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CSchemaWriter::BeginWriteSchema


HRESULT CSchemaWriter::EndWriteSchema()
{
	HRESULT		hr      = S_OK;
	WCHAR*		wszTemp = g_wszTemp;

	if(g_cchEndSchema+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[g_cchBeginSchema+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	memcpy(wszTemp, g_wszEndSchema, (g_cchEndSchema+1)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         g_cchEndSchema);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CSchemaWriter::EndWriteSchema


class CCollectionWriter
{
	public:
		
		CCollectionWriter();
		~CCollectionWriter();

		HRESULT Initialize(struct tTABLEMETARow*	i_pCollection,
			               CWriter*					i_pcWriter);

		HRESULT AddProperty(struct tCOLUMNMETARow*	i_pProperty);

		HRESULT WriteCollection();

	private:

		HRESULT WriteProperty(struct tCOLUMNMETARow* i_pProperty);
		HRESULT ReAllocate();
		HRESULT BeginWriteCollection();
		HRESULT EndWriteCollection();

		CWriter*					m_pCWriter;
		struct tTABLEMETARow*		m_pCollection;

		CPropertyWriter*			m_aProperty;
		ULONG						m_cProperty;
		ULONG						m_iProperty;

} // CCollectionWriter


CCollectionWriter::CCollectionWriter():
m_pCWriter(NULL),
m_pCollection(NULL),
m_aProperty(NULL),
m_cProperty(0),
m_iProperty(0)
{

} // CCollectionWriter


CCollectionWriter::~CCollectionWriter()
{
	if(NULL != m_aProperty)
	{
		delete [] m_aProperty;
		m_aProperty = NULL;
	}
	m_cProperty = 0;
	m_iProperty = 0;

} // ~CCollectionWriter


HRESULT CCollectionWriter::Initialize(struct tTABLEMETARow*	i_pCollection,
									  CWriter*				i_pcWriter)
{
	m_pCollection = i_pCollection;
	m_pCWriter = i_pcWriter;

} // CCollectionWriter::Initialize


HRESULT CCollectionWriter::GetPropertyWriter(struct tCOLUMNMETARow*	i_pProperty,
											 CPropertyWriter**      o_pProperty)
{
	HRESULT hr = S_OK;

	switch(m_iState)
	{
	case eState_AddingProperty:
		return E_INVALIDARG;
	case eState_DoneAddingProperty:
	default:
		m_iState = eState_AddingProperty;
	}

	if(m_iProperty == m_cProperty)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	hr = m_aProperty[m_iProperty++].Initialize(i_pProperty);

	if(SUCCEEDED(hr))
	{
		*o_pProperty = &m_aProperty[m_iProperty-1];
	}

	return hr;

} // CCollectionWriter::GetPropertyWriter


HRESULT CCollectionWriter::AddProperty(struct tCOLUMNMETARow*	i_pProperty)
{
	switch(m_iState)
	{
	case eState_AddingProperty:
		m_iState = eState_DoneAddingProperty;
	case eState_DoneAddingProperty:
	default:
		m_iState = eState_DoneAddingProperty;
	}

	return S_OK;

} // CCollectionWriter::AddProperty

HRESULT CCollectionWriter::DiscardProperty(struct tCOLUMNMETARow*	i_pProperty)
{
	switch(m_iState)
	{
	case eState_AddingProperty:
		m_iState = eState_DoneAddingProperty;
	case eState_DoneAddingProperty:
	default:
		m_iState = eState_DoneAddingProperty;
		return S_OK
	}

	memset(i_pProperty, 0, (sizeof(CPropertyWriter));

	m_iProperty--;

	return S_OK;

} // CCollectionWriter::DiscardProperty


HRESULT CCollectionWriter::ReAllocate()
{
	m_aProperty** pSav = m_aCollection;

	m_aProperty = new CPropertyWriter[m_cProperty + cMaxProperty];
	if(NULL == m_apProperty)
	{
		return E_OUTOFMEMORY;
	}
	memset(m_aProperty, 0, (sizeof(CPropertyWriter))*(m_cProperty + cMaxProperty));

	if(NULL != pSav)
	{
		memcpy(m_aProperty, pSav, (sizeof(CPropertyWriter))*(m_cProperty));
	}

	m_cProperty = m_cProperty + cMaxProperty;

	return S_OK;

} // CCollectionWriter::ReAllocate


HRESULT CCollectionWriter::WriteCollection()
{
	HRESULT hr = S_OK;

	hr = BeginWriteCollection();

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_iProperty; i++)
	{
		hr = m_aProperty[i]->WriteProperty();

		if(FAILED(hr))
		{
			return hr;
		}

	}

	hr = EndWriteCollection();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CCollectionWriter::WriteCollection


HRESULT CCollectionWriter::BeginWriteCollection()
{
	HRESULT		hr						= S_OK;
	WCHAR*		wszTemp					= g_wszTemp;
	WCHAR*      wszEnd					= NULL;

	ULONG       cchCollectionName		= wcslen(m_pCollection->pInternalName);

	LPWSTR      wszEndBeginCollection	= NULL;
	ULONG       cchEndBeginCollection	= 0;
	ULONG       cch						= 0;
	
	if(0 == wcscmpi(m_pCollection->pInternalName, wszTABLE_IIsConfigObject)
	{
		wszEndBeginCollection = g_wszSchemaGen;
		cchEndBeginCollection = g_cchSchemaGen;
	}
	else
	{
		wszEndBeginCollection = g_wszInheritsFrom;
		cchEndBeginCollection = g_cchInheritsFrom;
	}

	cch = g_cchBeginCollection +
	      cchCollectionName + 
		  cchEndBeginCollection;
	                  
	if(cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	wszEnd = wszTemp;
	memcpy(wszEnd, g_wszBeginCollection, (g_cchBeginCollection)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginCollection;
	memcpy(wszEnd, m_pCollection->pInternalName, (cchCollectionName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchCollectionName;
	memcpy(wszEnd, wszEndBeginCollection, (cchEndBeginCollection)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CCollectionWriter::BeginWriteCollection


HRESULT CCollectionWriter::EndWriteCollection()
{
	HRESULT		hr						= S_OK;
	WCHAR*		wszTemp					= g_wszTemp;
	WCHAR*      wszEnd					= NULL;

	if(g_cchEndCollection+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[g_cchEndCollection+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	memcpy(wszTemp, g_wszEndCollection, (g_cchEndCollection)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CCollectionWriter::EndWriteCollection


HRESULT CCollectionWriter::EndWriteCollection()
{
	HRESULT	hr = S_OK;


} // CCollectionWriter::EndWriteCollection


class CPropertyWriter
{
	public:
		
		CPropertyWriter();
		~CPropertyWriter();

		HRESULT Initialize(struct tCOLUMNMETARow*	i_pProperty,
			               CWriter*					i_pcWriter);

		HRESULT AddFlag(struct tTAGMETARow*		    i_pFlag);

		HRESULT WriteProperty();

	private:

		HRESULT WriteFlag(struct tTAGMETARow*		i_pFlag);
		HRESULT ReAllocate();
		HRESULT MetabaseTypeFromColumnMetaType();

		CWriter*					m_pCWriter;
		struct tCOLUMNMETARow*		m_pProperty;

		struct tTAGMETARow**		m_apFlag;
		ULONG						m_cFlag;
		ULONG						m_iFlag;

} // CPropertyWriter


CPropertyWriter::CPropertyWriter:
m_pCWriter(NULL),
m_pProperty(NULL),
m_apFlag(NULL),
m_cFlag(0),
m_iFlag(0)
{

} // CPropertyWriter::CPropertyWriter


CPropertyWriter::~CPropertyWriter()
{
	if(NULL != m_apFlag)
	{
		delete [] m_apFlag;
		m_apFlag = NULL;
	}

} // CPropertyWriter::CPropertyWriter


HRESULT CPropertyWriter::Initialize(struct tCOLUMNMETARow*	i_pProperty,
			                        CWriter*				i_pcWriter)
{
	HRESULT hr  = S_OK;

	m_pCWriter  = i_pcWriter;
	m_pProperty = i_pProperty;

} // CPropertyWriter::Initialize


HRESULT CPropertyWriter::AddFlag(struct tTAGMETARow*		i_pFlag)
{
	HRESULT hr = S_OK;

	if(m_iFlag == m_cFlag)
	{
		hr = ReAllocate();

		if(FAILED(hr))
		{
			return hr;
		}
	}

	m_apFlag[m_iFlag++] = i_pFlag;

	return hr;

} // CPropertyWriter::AddFlag


HRESULT CPropertyWriter::ReAllocate()
{
	struct tTAGMETARow** pSav = m_apFlag;

	m_apFlag = new struct tTAGMETARow*[m_cFlag + cMaxFlag];
	if(NULL == m_apFlag)
	{
		return E_OUTOFMEMORY;
	}
	memset(m_apFlag, 0, (sizeof(struct tTAGMETARow*))*(m_cFlag + cMaxFlag));

	if(NULL != pSav)
	{
		memcpy(m_apFlag, pSav, (sizeof(CPropertyWriter))*(m_cFlag));
	}

	m_cFlag = m_cFlag + cMaxFlag;

	return S_OK;

} // CPropertyWriter::ReAllocate


HRESULT CPropertyWriter::WriteProperty()
{
	HRESULT hr = S_OK;

	if(0 == wcscmpi(m_pCollection->Name(), wszTABLE_IIsConfigObject))
	{
		hr = WritePropertyLong();
	}
	else 
	{
		hr = WritePropertyShort();
	}

	return hr;

} // CPropertyWriter::WriteProperty


HRESULT CPropertyWriter::WritePropertyLong()
{
	HRESULT hr = S_OK;

	hr = BeginWritePropertyLong();

	if(FAILED(hr))
	{
		return hr;
	}

	if(NULL != m_apFlag)
	{	
		for(ULONG i=0; i<m_iFlag; i++)
		{
			hr = WriteFlag(i);

			if(FAILED(hr))
			{
				return hr;
			}
		}
	}

	hr = EndWritePropertyLong();

	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // CPropertyWriter::WritePropertyLong


HRESULT CPropertyWriter::WritePropertyShort()
{
	HRESULT		hr      = S_OK;
	WCHAR*		wszTemp = g_wszTemp;
	WCHAR*      wszEnd  = NULL;

	ULONG       cchPropertyName = wcslen(m_pProperty->pInternalName);
	ULONG       cch = g_cchBeginPropertyShort +
	                  cchPropertyName +
					  g_cchEndPropertyShort;
	                  
	if(cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	wszEnd = wszTemp;
	memcpy(wszEnd, g_wszBeginPropertyShort, (g_cchBeginPropertyShort)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginPropertyShort;
	memcpy(wszEnd, m_pProperty->pInternalName, (cchPropertyName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchPropertyName;
	if(fCOLUMNMETA_MANDATORY & m_pProperty->pSchemaGeneratorFlags)
	{
		//
		// TODO: Fetch the mandatory flag from the schema.
		//

		memcpy(wszEnd, g_wszMetaFlagsExEq, (g_cchMetaFlagsExEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMetaFlagsExEq;

	}
	memcpy(wszEnd, g_wszEndPropertyShort, (g_cchEndPropertyShort)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CPropertyWriter::WritePropertyShort


HRESULT CPropertyWriter::BeginWritePropertyLong()
{
	HRESULT		hr              = S_OK;
	WCHAR*		wszTemp         = g_wszTemp;
	WCHAR*      wszEnd          = NULL;
	ULONG       cchPropertyName = 0;
	WCHAR       wszID[25]       = NULL;
	ULONG       cchID           = 0;
	WCHAR*      wszType         = NULL;
	ULONG       cchType         = 0;
	DWORD		iColType        = iCOLUMNMETA_Type;
	WCHAR*      wszUserType     = NULL;
	ULONG       cchUserType     = 0;
	DWORD		iColUserType    = iCOLUMNMETA_UserType;
	WCHAR*      wszAttribute    = NULL;
	ULONG       cchAttribute    = 0;
	DWORD		iColAttribute   = iCOLUMNMETA_Attribute;
	WCHAR*      wszMetaFlags    = NULL;
	ULONG       cchMetaFlags    = 0;
	DWORD		iColMetaFlags   = iCOLUMNMETA_MetaFlags;
	WCHAR*      wszMetaFlagsEx  = NULL;
	ULONG       cchMetaFlagsEx  = 0;
	DWORD		iColMetaFlagsEx = iCOLUMNMETA_SchemaGeneratorFlags;
	WCHAR*      wszDefault      = NULL;
	ULONG       cchDefault      = 0;
	WCHAR*      wszMin          = NULL;
	ULONG       cchMin          = 0;
	WCHAR*      wszMax          = NULL;
	ULONG       cchMax          = 0;

	//
	// Compute the individual strings and lengths.
	//

	//
	// Name
	//

	cchPropertyName = wcslen(m_pProperty->pInternalName);

	//
	// ID
	// 

	wszID[0] = 0;
	_itow(*(m_pProperty->pID), wszID, 10);
	cchID = wcslen(wszID);

	//
	// Type
	//

	hr = m_pCWriterGlobalHelper->GetTagName(wszTABLE_COLUMNMETA,
											iColType
		                                    *(m_pProperty->pType),
	                                        &wszType);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchType = wcslen(wszType);

	//
	// UserType
	//

	hr =  m_pCWriterGlobalHelper->GetTagName(wszTABLE_COLUMNMETA,
											 iColUserType,
											 *(m_pProperty->pUserType),
	                                         &wszUserType);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchUserType = wcslen(wszUserType);

	//
	// Attribute
	//

	hr = m_pCWriterGlobalHelper->GetTagName(wszTABLE_COLUMNMETA,
											iColAttribute,
											*(m_pProperty->pAttributes),
	                                        &wszAttribute);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchAttribute = wcslen(wszAttribute);

	//
	// MetaFlags (only the relavant ones - PRIMARYKEY, BOOL, MULTISTRING, EXPANDSTRING)
	//

	hr = m_pCWriterGlobalHelper->GetTagName(wszTABLE_COLUMNMETA,
											iColMetaFlags,
											*(m_pProperty->pMetaFlags),
	                                        &wszMetaFlags);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchMetaFlags = wcslen(wszMetaFlags);

	//
	// MetaFlagsEx (only the relavant ones - CACHE_PROPERTY_MODIFIED, CACHE_PROPERTY_CLEARED, EXTENDEDTYPE0-3)
	//

	hr = m_pCWriterGlobalHelper->GetTagName(wszTABLE_COLUMNMETA,
											iColMetaFlagsEx,
											*(m_pProperty->pMetaFlagsEx),
	                                         &wszMetaFlagsEx);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchMetaFlagsEx = wcslen(wszMetaFlagsEx);

	//
	// DefaultValue
	//

	hr = m_pCWriterGlobalHelper->ToString(m_pProperty->pDefaultValue,
	                                      m_pProperty->pSize,
										  *(m_pProperty->pID),
										  MetabaseTypeFromColumnMetaType(),
										  *(m_pProperty->pAttributes),
										  &wszDefaultValue);

	if(FAILED(hr))
	{
		goto exit;
	}
	cchMetaFlags = wcslen(wszMetaFlagsEx);

	//
	// Confirm that the total length is less than buffer. If not, reallocate.
	//

	ULONG       cch = g_cchBeginPropertyLong +
	                  cchPropertyName + 
					  g_cchIDEq + 
					  cchID + 
					  g_cchTypeEq +
					  cchType + 
					  g_cchUserTypeEq +
					  cchUserType + 
					  g_cchAttributeEq + 
					  cchAttribute + 
					  g_cchMetaFlagsEq +
					  cchMetaFlags + 
					  g_cchMetaFlagsExEq + 
					  cchMetaFlagsEx
					  g_cchDefaultEq + 
					  cchDefault + 
					  g_cchMinValueEq + 
					  cchMinValue + 
					  g_cchMaxValueEq + 
					  cchMaxValue + 
					  g_cchEndPropertyLongBeforeFlag;
	                  
	if(cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	//
	// Construct the string.
	//

	wszEnd = wszTemp;
	memcpy(wszEnd, g_wszBeginPropertyLong, (g_cchBeginPropertyLong)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginPropertyLong;
	memcpy(wszEnd, m_pProperty->pInternalName, (cchPropertyName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchPropertyName;
	memcpy(wszEnd, g_wszIDEq, (g_cchIDEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchIDEq;
	memcpy(wszEnd, wszID, (cchID)*sizeof(WCHAR));
	wszEnd = wszEnd + cchID;
	memcpy(wszEnd, g_wszTypeEq, (g_cchTypeEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchTypeEq;
	memcpy(wszEnd, wszType, (cchType)*sizeof(WCHAR));
	wszEnd = wszEnd + cchType;
	memcpy(wszEnd, g_wszUserTypeEq, (g_cchUserTypeEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchUserTypeEq;
	memcpy(wszEnd, wszUserType, (cchUserType)*sizeof(WCHAR));
	wszEnd = wszEnd + cchUserType;
	if(NULL != wszAttributes)
	{
		memcpy(wszEnd, g_wszAttributeEq, (g_cchAttributeEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchAttributeEq;
		memcpy(wszEnd, wszAttributes, (cchAttributes)*sizeof(WCHAR));
		wszEnd = wszEnd + cchAttributes;
	}
	if(NULL != wszMetaFlags)
	{
		memcpy(wszEnd, g_wszMetaFlagsEq, (g_cchMetaFlagsEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMetaFlagsEq;
		memcpy(wszEnd, wszMetaFlags, (cchMetaFlags)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlags;
	}
	if(NULL != wszMetaFlagsEx)
	{
		memcpy(wszEnd, g_wszMetaFlagsExEq, (g_cchMetaFlagsExEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMetaFlagsExEq;
		memcpy(wszEnd, wszMetaFlagsEx, (cchMetaFlagsEx)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMetaFlagsEx;
	}
	if(NULL != wszDefault)
	{
		memcpy(wszEnd, g_wszDefaultEq, (g_cchDefaultEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchDefaultEq;
		memcpy(wszEnd, wszDefault, (cchDefault)*sizeof(WCHAR));
		wszEnd = wszEnd + cchDefault;
	}
	if(NULL != wszMinValue)
	{
		memcpy(wszEnd, g_wszMinValueEq, (g_cchMinValueEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMinValueEq;
		memcpy(wszEnd, wszMinValue, (cchMinValue)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMinValue;
	}
	if(NULL != wszMaxValue)
	{
		memcpy(wszEnd, g_wszMaxValueEq, (g_cchMaxValueEq)*sizeof(WCHAR));
		wszEnd = wszEnd + g_cchMaxValueEq;
		memcpy(wszEnd, wszMaxValue, (cchDefault)*sizeof(WCHAR));
		wszEnd = wszEnd + cchMaxValue;
	}
	if(NULL != m_apFlag)
	{
		memcpy(wszEnd, g_wszEndPropertyLongBeforeFlag, (g_cchEndPropertyLongBeforeFlag)*sizeof(WCHAR));
	}

	//
	// Write the string into the file.
	//

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CPropertyWriter::BeginWritePropertyLong


HRESULT CPropertyWriter::WriteFlag(ULONG i_iFlag)
{
	struct tTAGMETARow*		pFlag   = m_apFlag[i];
	HRESULT					hr      = S_OK;
	WCHAR*					wszTemp = g_wszTemp;
	WCHAR*					wszEnd  = NULL;
	WCHAR                   wszValue[25];
	ULONG					cchFlagName = 0;
	ULONG					cchValue = 0;
	ULONG					cch      = 0;

	cchFlagName = wcslen(pFlag->pInternalName);
	
	wszValue[0] = 0;
	_itow(*(pFlag->pValue), wszValue, 10);
	cchValue  = wcslen(wszValue);

	cch = g_cchBeginFlag +
		  cchFlagName + 
		  g_cchValueEq +
		  cchValue + 
		  g_cchEndFlag;
	                  
	if(cch+1) > g_cchTemp)
	{
		wszTemp = new WCHAR[cch+1];
		if(NULL == wszTemp)
		{
			return E_OUTOFMEMORY;
		}
	}

	wszEnd = wszTemp;
	memcpy(wszEnd, g_wszBeginFlag, (g_cchBeginFlag)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchBeginFlag;
	memcpy(wszEnd, pFlag->pInternalName, (cchFlagName)*sizeof(WCHAR));
	wszEnd = wszEnd + cchFlagName;
	memcpy(wszEnd, g_wszValueEq, (g_cchValueEq)*sizeof(WCHAR));
	wszEnd = wszEnd + g_cchValueEq;
	memcpy(wszEnd, wszValue, (cchValue)*sizeof(WCHAR));
	wszEnd = wszEnd + cchValue;
	memcpy(wszEnd, g_wszEndFlag, (g_cchEndFlag)*sizeof(WCHAR));

	hr = m_pCWriter->WriteToFile(wszTemp,
		                         cch);

	if(wszTemp != g_wszTemp)
	{
		delete [] wszTemp;
		wszTemp = NULL;
	}

	return hr;

} // CPropertyWriter::WriteFlag


CPropertyWriter::MetabaseTypeFromColumnMetaType()
{
    switch(*(m_Property->pType))
    {
    case eCOLUMNMETA_UI4:
        return eMBProperty_DWORD;
    case eCOLUMNMETA_BYTES:
        return eMBProperty_BINARY;
    case eCOLUMNMETA_WSTR:
        if(*(m_Property->pMetaFlags) & fCOLUMNMETA_EXPANDSTRING)
            return eMBProperty_EXPANDSZ;
        else if(*(m_Property->pMetaFlags) & fCOLUMNMETA_MULTISTRING)
            return eMBProperty_MULTISZ;
        return eMBProperty_STRING;
    default:
        ASSERT(false && L"This type is not allow in the Metabase. MetaMigrate should not have create a column of this type");
    }
    return 0;
}

GetTagName(LPCWSTR	i_wszTable,
	       DWORD	i_dwColumnIndex,
		   DWORD	i_dwTagValue,
		   LPWSTR*	o_pwszTag)
{
	HRESULT hr                             = S_OK;
	ULONG   iStartRow                      = 0;
	ULONG   iColTagName					   = iTAGMETA_InternalName;
	ULONG   iRow                           = 0;
	ULONG   aColSearchByValue[]            = {iTAGMETA_Table,
							                  iTAGMETA_ColumnIndex,
							                  iTAGMETA_Value
	};
	ULONG   cColSearchByValue              = sizeof(aColSearchByValue)/sizeof(ULONG);

	LPVOID  apvSearchByValue[cTAGMETA_NumberOfColumns];
	apvSearchByValue[iTAGMETA_Table]       = (LPVOID)i_wszTable;
	apvSearchByValue[iTAGMETA_ColumnIndex] = (LPVOID)&i_dwColumnIndex;
	apvSearchByValue[iTAGMETA_Value]       = (LPVOID)&i_dwTagValue;

	hr = m_pISTTagMetaMBPropertyIndx2->GetRowIndexBySearch(iStartRow, 
															cColSearchByValue, 
															aColSearchByValue,
															NULL, 
															apvSearchByValue,
															&iRow);
	if(FAILED(hr))
	{
		return hr;
	}

	hr = m_pISTTagMetaMBPropertyIndx2->GetColumnValues(iRow,
													   1,
													   &iColTagName,
													   NULL,
													  (LPVOID*)o_pwszTag);
	return hr;


} // GetTagName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\stackwalk.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#ifndef StackWalk_H
#define StackWalk_H  1

#include <imagehlp.h>
#include <wtypes.h>


class Symbol {
	friend class StackWalker;

private:
	Symbol(const char* moduleName, const char* symbolName, DWORD_PTR displacement);
	void Append(Symbol*);
	

public:
	~Symbol();

	const char* moduleName() const { return _moduleName; }
	const char* symbolName() const { return _symbolName; }
	DWORD_PTR displacement() const { return _displacement; }
	void AppendDisplacement(char * sz)
	{
		char szDisp[16];
		wsprintfA(szDisp, " + 0x%X", _displacement);
		lstrcatA(sz, szDisp);
	}

	Symbol* next() const { return _next; }

private:
	char*	_moduleName;
	char*	_symbolName;
	DWORD_PTR _displacement;

	Symbol*	_next;
};


class StackWalker {
public:
	StackWalker(HANDLE hProcess);
	~StackWalker();

	Symbol* ResolveAddress(DWORD_PTR addr);
	Symbol* CreateStackTrace(CONTEXT*);
	BOOL GetCallStack(Symbol * symbol, int nChars, WCHAR * sz);
	int GetCallStackSize(Symbol* symbol);

private:
	static DWORD_PTR __stdcall GetModuleBase(HANDLE hProcess, DWORD_PTR address);
	static DWORD_PTR LoadModule(HANDLE hProcess, DWORD_PTR address);

private:
	typedef BOOL (__stdcall *SymGetModuleInfoFunc)(HANDLE hProcess,
												   DWORD_PTR dwAddr,
												   PIMAGEHLP_MODULE ModuleInfo);
	typedef BOOL (__stdcall *SymGetSymFromAddrFunc)(HANDLE hProcess,
													DWORD_PTR dwAddr,
													DWORD_PTR *pdwDisplacement,
													PIMAGEHLP_SYMBOL Symbol);
	typedef DWORD (__stdcall *SymLoadModuleFunc)(HANDLE hProcess,
												 HANDLE hFile,
												 PSTR ImageName,
												 PSTR ModuleName,
												 DWORD_PTR BaseOfDll,
												 DWORD_PTR SizeOfDll);
	typedef BOOL (__stdcall *StackWalkFunc)(DWORD MachineType,
											HANDLE hProcess,
											HANDLE hThread,
											LPSTACKFRAME StackFrame,
											LPVOID ContextRecord,
											PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
											PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
											PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
											PTRANSLATE_ADDRESS_ROUTINE TranslateAddress);
	typedef BOOL (__stdcall *UndecorateSymbolNameFunc)(LPSTR DecName,
												 LPSTR UnDecName,
												 DWORD UnDecNameLength,
												 DWORD Flags);

private:
	HMODULE							_imageHlpDLL;
	HANDLE							_hProcess;
	EXCEPTION_POINTERS				m_exceptionpts;

	static SymGetModuleInfoFunc				_SymGetModuleInfo;
	static SymGetSymFromAddrFunc			_SymGetSymFromAddr;
	static SymLoadModuleFunc				_SymLoadModule;
	static StackWalkFunc					_StackWalk;
	static UndecorateSymbolNameFunc			_UndecorateSymbolName;
	static PFUNCTION_TABLE_ACCESS_ROUTINE	_SymFunctionTableAccess;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\tmsxmlbase.cpp ===
// Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
// Filename:        TMSXmlBase.cpp
// Author:          Stephenr
// Date Created:    10/16/2000
// Description:     This abstracts how (and which) MSXML dll we load.
//                  This is important becuase we never call CoCreateInstance
//                  on MSXML.
//

#define INITPRIVATEGUID
#include "Windows.h"
#include <objbase.h>

#ifndef __xmlparser_h__
    #include "xmlparser.h"
#endif
#ifndef __TMSXMLBASE_H__
    #include "TMSXMLBase.h"
#endif
#ifndef __catalog_h__
    #include "catalog.h"
#endif

#include "safecs.h"

class TSmartLibInstance
{
public:
	TSmartLibInstance () { m_hInst = 0;}
	~TSmartLibInstance () {if (m_hInst != 0) FreeLibrary (m_hInst); m_hInst=0;}

	HMODULE GetInstance () const { return m_hInst;}
	void SetInstance (HMODULE hInst) {ASSERT(m_hInst == 0); m_hInst = hInst;}
private:
	HMODULE m_hInst;
};
    
//type declarations
typedef HRESULT( __stdcall *DLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID FAR*);

static TSmartLibInstance g_hInstMSXML;  // Instance handle to the XML Parsing class DLL
static DLLGETCLASSOBJECT g_fnDllGetClassObject = 0;
static CSafeAutoCriticalSection  g_SAMSXML;

TMSXMLBase::~TMSXMLBase()
{
}

extern LPWSTR g_wszDefaultProduct;//this can be changed by CatInProc or whomever knows best what the default product ID is.

HRESULT TMSXMLBase::CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const
{
	ASSERT(NULL != ppv);

	*ppv = NULL;

    if(rclsid != _CLSID_DOMDocument && rclsid != CLSID_XMLParser)
        return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid,  ppv);//If MSXML.DLL isn't in our directory then get object from the registered one.

    HRESULT hr;
	CComPtr<IClassFactory> pClassFactory;

    if(0 == g_hInstMSXML.GetInstance())
    {
		CSafeLock MSXMLLock (g_SAMSXML);
		DWORD dwRes = MSXMLLock.Lock ();
	    if(ERROR_SUCCESS != dwRes)
		{
			return HRESULT_FROM_WIN32(dwRes);
		}

		if (g_hInstMSXML.GetInstance() == 0)
		{
			bool  bFoundMSXML = false;
			WCHAR szMSXMLPath[MAX_PATH];
			WCHAR szMSXML[MAX_PATH];

			if(!bFoundMSXML)
			{
				*szMSXMLPath = 0x00;
				if(0 != GetModuleFileName(0, szMSXMLPath, sizeof(szMSXMLPath)/sizeof(WCHAR)-12))//Have to have room for \shlwapi.dll so subtract 12
				{   //Look for MSXML in the catalog directory
					*(wcsrchr(szMSXMLPath, L'\\')+1) = 0x00;

					wcscpy(szMSXML, szMSXMLPath);
	#ifdef _IA64_
					wcscat(szMSXML, L"msxml3.dll");//We only do our own CoCreateInstance for CLSIDs in MSXML.DLL
	#else
					wcscat(szMSXML, 0==_wcsicmp(g_wszDefaultProduct, L"urt") ? L"msxml.dll" : L"msxml3.dll");//We only do our own CoCreateInstance for CLSIDs in MSXML.DLL
	#endif
					if(-1 != GetFileAttributes(szMSXML))//if GetFileAttributes fails then the file does not exist
						bFoundMSXML = true;
				}
			}

			if(!bFoundMSXML)
			{   //OK, if MSXML is NOT in the Catalog directory, look for it in the system32 directory
				*szMSXMLPath = 0x00;
				if(0 != GetSystemDirectory(szMSXMLPath, sizeof(szMSXMLPath)/sizeof(WCHAR)))
				{
					wcscat(szMSXMLPath, L"\\");

					wcscpy(szMSXML, szMSXMLPath);
	#ifdef _IA64_
					wcscat(szMSXML, L"msxml3.dll");//We only do our own CoCreateInstance for CLSIDs in MSXML.DLL
	#else
					wcscat(szMSXML, 0==_wcsicmp(g_wszDefaultProduct, WSZ_PRODUCT_NETFRAMEWORKV1) ? L"msxml.dll" : L"msxml3.dll");//We only do our own CoCreateInstance for CLSIDs in MSXML.DLL
	#endif
					if(-1 != GetFileAttributes(szMSXML))//if GetFileAttributes fails then the file does not exist
						bFoundMSXML = true;
				}
			}

			if(!bFoundMSXML)
				return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid,  ppv);//If MSXML.DLL isn't in our directory then get object from the registered one.

			//if we don't explicitly load this dll, MSXML will get it out of the system32 directory
			WCHAR szSHLWAPI[MAX_PATH];
			wcscpy(szSHLWAPI, szMSXMLPath);
			wcscat(szSHLWAPI, L"shlwapi.dll");
			HINSTANCE hInstSHLWAPI = LoadLibrary(szSHLWAPI);

			g_hInstMSXML.SetInstance(LoadLibrary(szMSXML));
			FreeLibrary(hInstSHLWAPI);//We just needed this long enough to load MSXML.DLL
			if(0 == g_hInstMSXML.GetInstance())
				return E_SDTXML_UNEXPECTED;
    
			if(0 == g_fnDllGetClassObject)
			{
				g_fnDllGetClassObject = reinterpret_cast<DLLGETCLASSOBJECT>(GetProcAddress(g_hInstMSXML.GetInstance(), "DllGetClassObject"));

				if(0 == g_fnDllGetClassObject)
					return E_SDTXML_UNEXPECTED;
			}
		}
	}

    VERIFY(SUCCEEDED(hr = g_fnDllGetClassObject(rclsid, IID_IClassFactory, (LPVOID*) &pClassFactory)));// get the class factory object
    if(FAILED(hr))
        return hr;
    if(!pClassFactory)
        return E_SDTXML_UNEXPECTED;

    return pClassFactory->CreateInstance (NULL, riid, (LPVOID*) ppv);// create a instance of the object we want
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\textfilelogger.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    TextFileLogger.cpp

$Header: $

Abstract:
    Text file log complements event file logging.

Author:
    ???             Legacy code from COM+ 1.0 time frame (or before)

Revision History:
    mohits          4/19/01

--**************************************************************************/

#include "TextFileLogger.h"

// Module handle
extern HMODULE g_hModule;

// Defined in svcerr.cpp (i.e. "IIS")
extern LPWSTR  g_wszDefaultProduct;

// TODO: Get from a central place instead
static const ULONG   MAX_PRODUCT_CCH = 64;

// Relevant registry stuff
static const LPCWSTR WSZ_REG_CAT42   = L"Software\\Microsoft\\Catalog42\\";
static const ULONG   CCH_REG_CAT42   = sizeof(WSZ_REG_CAT42)/sizeof(WCHAR)-1;
static const LPCWSTR WSZ_REG_LOGSIZE = L"TextFileLogSize";

// Current filename we are logging to is shared across processes
// This is to prevent expensive Find*File calls every time we need
// to log.  Protected by Lock()/Unlock() methods of TextFileLogger.
#pragma data_seg(".shared")
WCHAR g_wszFileCur[MAX_PATH] = {0};
ULONG g_idxNumPart           = 0;
#pragma data_seg()
#pragma comment(linker,"/SECTION:.shared,RWS")

// TLogData: private methods

bool TLogData::WstrToUl(
    LPCWSTR     i_wszSrc,
    WCHAR       i_wcTerminator,
    ULONG*      o_pul)
/*++

Synopsis: 
    Converts a WstrToUl.
    We need this because neither swscanf nor atoi indicate error cases correctly.

Arguments: [i_wszSrc]       - The str to be converted
           [i_wcTerminator] - At what char we should stop searching
           [o_pul]          - The result, only set on success.
           
Return Value: 
    bool - true if succeeded, false otherwise

--*/
{
    ASSERT(o_pul);
    ASSERT(i_wszSrc);

    static const ULONG  ulMax  = 0xFFFFFFFF;
    ULONG               ulCur  = 0;
    _int64              i64Out = 0;

    for(LPCWSTR pCur = i_wszSrc; *pCur != L'\0' && *pCur != i_wcTerminator; pCur++)
    {
        ulCur = *pCur - L'0';
        if(ulCur > 9)
        {
            DBGINFO((DBG_CONTEXT, "[WstrToUl] Invalid char encountered\n"));
            return false;
        }

        i64Out = i64Out*10 + ulCur;
        if(i64Out > ulMax)
        {
            DBGINFO((DBG_CONTEXT, "[WstrToUl] Number is too big\n"));
            return false;
        }
    }

    ASSERT(i64Out <= ulMax);
    *o_pul = (ULONG)i64Out;
    return true;
}

// TextFileLogger: public methods

CMutexCreator TextFileLogger::_MutexCreator(L"fba30532-d5bb-11d2-a40b-3078302c2030");

TextFileLogger::TextFileLogger(
    LPCWSTR wszEventSource, 
    HMODULE hMsgModule,
    DWORD dwNumFiles) :  _hFile(INVALID_HANDLE_VALUE)
                        ,_hMutex(NULL)
                        ,_hMsgModule(hMsgModule)
                        ,_eventSource(wszEventSource)
                        ,_dwMaxSize(524288)
                        ,_dwNumFiles(dwNumFiles)
                        ,m_cRef(0)
{
    wcscpy(m_wszProductID, g_wszDefaultProduct);

    _hMutex = _MutexCreator.GetHandle();
    if(_hMutex == NULL)
    {
        return;
    }

    Init(wszEventSource, hMsgModule);
}

TextFileLogger::TextFileLogger(
    LPCWSTR wszProductID,
    ICatalogErrorLogger2 *pNext,
    DWORD dwNumFiles) :
                         _hFile(INVALID_HANDLE_VALUE)
                        ,_hMutex(NULL)
                        ,_hMsgModule(0)
                        ,_eventSource(0)
                        ,_dwMaxSize(524288)
                        ,_dwNumFiles(dwNumFiles)
                        ,m_cRef(0)
                        ,m_spNextLogger(pNext)
{
    wcscpy(m_wszProductID, wszProductID);

    _hMutex = _MutexCreator.GetHandle();
    if(_hMutex == NULL)
    {
        return;
    }
}

void TextFileLogger::Init(
    LPCWSTR wszEventSource, 
    HMODULE hMsgModule)
{
    _hMsgModule     = hMsgModule;
    _eventSource    = wszEventSource;

    ASSERT(_dwNumFiles > 0);

    // Open the message module (comsvcs.dll).
    if(0 == _hMsgModule)
    {
        _hMsgModule = LoadLibraryEx(L"comsvcs.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
    }

    // Open the registry to get the maxfile size.
    WCHAR wszRegPath[CCH_REG_CAT42 + 1 + MAX_PRODUCT_CCH + 1];
    wcscpy(wszRegPath,  WSZ_REG_CAT42);
    wcsncat(wszRegPath, m_wszProductID, MAX_PRODUCT_CCH);

    // First, open the path
    HKEY  hkProd = NULL;
    DWORD dw     = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wszRegPath, 0, KEY_READ, &hkProd);
    if (dw != ERROR_SUCCESS)
    {
        DBGWARN((
            DBG_CONTEXT, 
            "Could not open regkey: %ws, err=%u\n", wszRegPath, dw));
        return;
    }

    // Then, get the value
    DWORD dwType   = 0;
    DWORD dwData   = 0;
    DWORD dwcbData = 4;
    dw = RegQueryValueEx(hkProd, WSZ_REG_LOGSIZE, NULL, &dwType, (LPBYTE)&dwData, &dwcbData);
    RegCloseKey(hkProd);

    // Error conditions
    if (dw != ERROR_SUCCESS)
    {
        DBGINFO((
            DBG_CONTEXT, 
            "Could not fetch %ws, err=%u.  Using default of %u\n", 
            WSZ_REG_LOGSIZE, 
            dw,
            _dwMaxSize));
        return;
    }
    if (dwType != REG_DWORD)
    {
        DBGWARN((
            DBG_CONTEXT,
            "%ws found, but type is not REG_DWORD.  Using %u instead\n", 
            WSZ_REG_LOGSIZE, 
            _dwMaxSize));
        return;
    }
    if (dwData < _dwMaxSize)
    {
        DBGWARN((
            DBG_CONTEXT,
            "%u is too small.  Using %u instead\n", 
            dwData, 
            _dwMaxSize));
        return;
    }

    // If none of the error conditions hold, ...
    _dwMaxSize = dwData;
}

TextFileLogger::~TextFileLogger() 
{
    if (_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(_hFile);
    if (_hMsgModule != NULL && _hMsgModule!=g_hModule)
        FreeLibrary(_hMsgModule);
}

//IUnknown
// =======================================================================

STDMETHODIMP TextFileLogger::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv) 
        return E_INVALIDARG;
    *ppv = NULL;

    if (riid == IID_ICatalogErrorLogger2)
    {
        *ppv = (ICatalogErrorLogger2*) this;
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = (ICatalogErrorLogger2*) this;
    }

    if (NULL != *ppv)
    {
        ((ICatalogErrorLogger2*)this)->AddRef ();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
    
}

STDMETHODIMP_(ULONG) TextFileLogger::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);
    
}

STDMETHODIMP_(ULONG) TextFileLogger::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
    {
        delete this;
    }
    return cref;
}

//ICatalogErrorLogger2
//=================================================================================
// Function: ReportError
//
// Synopsis: Machanism for reporting errors to a text file in IIS
//
// Arguments: [i_BaseVersion_DETAILEDERRORS] - Must be BaseVersion_DETAILEDERRORS
//            [i_ExtendedVersion_DETAILEDERRORS] - May be any value, used for debug purposes only
//            [i_cDETAILEDERRORS_NumberOfColumns] - indicates the size of the apvValue array
//            [i_acbSizes] - may be NULL if no BYTES columns are used
//            [i_apvValues] - columns in the DETAILEDERRORS table
//            
// Return Value: 
//=================================================================================
HRESULT TextFileLogger::ReportError(ULONG      i_BaseVersion_DETAILEDERRORS,
                                    ULONG      i_ExtendedVersion_DETAILEDERRORS,
                                    ULONG      i_cDETAILEDERRORS_NumberOfColumns,
                                    ULONG *    i_acbSizes,
                                    LPVOID *   i_apvValues)
{
    if(i_BaseVersion_DETAILEDERRORS != BaseVersion_DETAILEDERRORS)
        return E_ST_BADVERSION;
    if(0 == i_apvValues)
        return E_INVALIDARG;
    if(i_cDETAILEDERRORS_NumberOfColumns <= iDETAILEDERRORS_ErrorCode)//we need at least this many columns
        return E_INVALIDARG;

    tDETAILEDERRORSRow errorRow;
    memset(&errorRow, 0x00, sizeof(tDETAILEDERRORSRow));
    memcpy(&errorRow, i_apvValues, i_cDETAILEDERRORS_NumberOfColumns * sizeof(void *));

    if(0 == errorRow.pType)
        return E_INVALIDARG;
    if(0 == errorRow.pCategory)
        return E_INVALIDARG;
    if(0 == errorRow.pEvent)
        return E_INVALIDARG;
    if(0 == errorRow.pSource)
        return E_INVALIDARG;

    WCHAR wszInsertionString5[1024];
    if(0 == errorRow.pString5)
        FillInInsertionString5(wszInsertionString5, 1024, errorRow);

    LPCTSTR pInsertionStrings[5];
    pInsertionStrings[4] = errorRow.pString5 ? errorRow.pString5 : L"";
    pInsertionStrings[3] = errorRow.pString5 ? errorRow.pString4 : L"";
    pInsertionStrings[2] = errorRow.pString5 ? errorRow.pString3 : L"";
    pInsertionStrings[1] = errorRow.pString5 ? errorRow.pString2 : L"";
    pInsertionStrings[0] = errorRow.pString5 ? errorRow.pString1 : L"";

    Init(errorRow.pSource, g_hModule);

    Report(
        LOWORD(*errorRow.pType),
        LOWORD(*errorRow.pCategory),
        *errorRow.pEvent,
        5,
        (errorRow.pData && i_acbSizes) ? i_acbSizes[iDETAILEDERRORS_Data] : 0,
        pInsertionStrings,
        errorRow.pData,
        errorRow.pCategoryString,
        errorRow.pMessageString);

    if(m_spNextLogger)//is there a chain of loggers
    {
        return m_spNextLogger->ReportError(i_BaseVersion_DETAILEDERRORS,
                                          i_ExtendedVersion_DETAILEDERRORS,
                                          i_cDETAILEDERRORS_NumberOfColumns,
                                          i_acbSizes,
                                          reinterpret_cast<LPVOID *>(&errorRow));//instead of passing forward i_apvValues, let's use errorRow since it has String5
    }

    return S_OK;
}

// TextFileLogger: private methods

void TextFileLogger::Report(
    WORD     wType,
    WORD     wCategory,
    DWORD    dwEventID,
    WORD     wNumStrings,
    size_t   dwDataSize,
    LPCTSTR* lpStrings,
    LPVOID   lpRawData,
    LPCWSTR  wszCategory,
    LPCWSTR  wszMessageString) 
{
    WCHAR szBuf[2048]; // documented maximum size for wsprintf is 1024; but FormatMessage can be longer
    int len;
    DWORD written;

    if (_hMutex == NULL)
        return;
    
    Lock();

    if (_hFile == INVALID_HANDLE_VALUE)
    {
        InitFile();
    }

    if (_hFile == INVALID_HANDLE_VALUE)
    {
        Unlock();
        DBGERROR((DBG_CONTEXT, "Not logging due to error\n"));
        return;
    }
    
    // Set the file handle, and position the pointer to the end of
    // the file (we append).
    SetFilePointer(_hFile, 0, NULL, FILE_END);

    // Write a separator line.
    ASSERT(0 != _eventSource);
    len = wsprintf(szBuf, L"===================== %s =====================\r\n", _eventSource);
    WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);
    
    // Write the time/date stamp.
    SYSTEMTIME st;
    GetLocalTime(&st);
    len = wsprintf(szBuf, L"Time:  %d/%d/%d  %02d:%02d:%02d.%03d\r\n",
                   st.wMonth, st.wDay, st.wYear,
                   st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);
    
    // Write the message type.
    WCHAR* szType = NULL;
    switch(wType) {
    case EVENTLOG_ERROR_TYPE:
        szType = L"Error";
        break;
    case EVENTLOG_WARNING_TYPE:
        szType = L"Warning";
        break;
    case EVENTLOG_INFORMATION_TYPE:
        szType = L"Information";
        break;
    default:
        szType = L"Unknown Type";
        break;
    }
    len = wsprintf(szBuf, L"Type: %s\r\n", szType);
    WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);

    WCHAR szCat[80];
    LPCWSTR pBuf = wszCategory;
    if(0 == wszCategory)
    {
        // Write the message category.
        len = FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK | 
                            FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            _hMsgModule,
                            wCategory,
                            0,
                            szCat,
                            sizeof(szCat)/sizeof(WCHAR),
                            (va_list*)lpStrings);
        pBuf = szCat;
    }
    else
    {
        if(wcslen(wszCategory)>80)
            len = 0;
    }
    if (len == 0)
        len = wsprintf(szBuf, L"Category: %hd\r\n", wCategory);
    else
        len = wsprintf(szBuf, L"Category: %s\r\n", pBuf);
    WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);
    
    // Write the event ID.
    len = wsprintf(szBuf, L"Event ID: %d\r\n", dwEventID & 0xffff);
    WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);
    
    // Write out the formatted message.
    len = FormatMessage(FORMAT_MESSAGE_MAX_WIDTH_MASK |
        (wszMessageString ? FORMAT_MESSAGE_FROM_STRING : FORMAT_MESSAGE_FROM_HMODULE) |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        reinterpret_cast<LPCVOID>(wszMessageString) ? reinterpret_cast<LPCVOID>(wszMessageString)
                                        : reinterpret_cast<LPCVOID>(_hMsgModule), //we get errors when using (A ? B : C) when A,B & C are not the same type
                        dwEventID,
                        0,
                        szBuf,
                        sizeof(szBuf)/sizeof(WCHAR),
                        (va_list*)lpStrings);

    szBuf[(len < sizeof(szBuf)/sizeof(WCHAR)) ? len : (sizeof(szBuf)/sizeof(WCHAR))-1] = 0x00;

    if (len == 0)
    {
        // Unable to get message... dump the insertion strings.
        len = wsprintf(szBuf, L"The description for this event could not be found. "
                       L"It contains the following insertion string(s):\r\n");
        WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);
        
        for (WORD i = 0; i < wNumStrings; ++i) {
            len = lstrlen(lpStrings[i]);
            WriteFile(_hFile, lpStrings[i], len * sizeof lpStrings[0][0], &written, NULL);
            WriteFile(_hFile, L"\r\n", sizeof L"\r\n" - sizeof L'\0', &written, NULL);
        }
    }
    else {
        // Got the message...
        WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);
        WriteFile(_hFile, L"\r\n", sizeof L"\r\n" - sizeof L'\0', &written, NULL);
    }
    
    // If necessary, write out the raw data bytes.
    if (dwDataSize > 0) {
        WriteFile(_hFile, L"Raw data: ", sizeof L"Raw data: " - sizeof L'\0', &written, NULL);
        for (DWORD dw = 0; dw < dwDataSize; ++dw) {
            BYTE* b = (BYTE*)lpRawData + dw;
            len = wsprintf(szBuf, L"%02x ", *b);
            WriteFile(_hFile, szBuf, len * sizeof szBuf[0], &written, NULL);
        }
        WriteFile(_hFile, L"\r\n", sizeof L"\r\n" - sizeof L'\0', &written, NULL);
    }

    if(_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFile);
        _hFile = INVALID_HANDLE_VALUE;
    }
    
    Unlock();
}

void TextFileLogger::InitFile()
/*++

Synopsis: 
    Sets _hFile based on what DetermineFile returns.
    We do not call DetermineFile if
    - Our current log file is not full
    - We have a current log file.  We just increment and clean up stale file.
      
    Caller should Lock() before calling this.

--*/
{
    bool bDetermineFile = false;

    // We have already set g_wszFileCur
    if(g_wszFileCur[0] != L'\0')
    {
        WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

        // If we could not fetch attributes, then call DetermineFile.
        if(0 == GetFileAttributesEx(g_wszFileCur, GetFileExInfoStandard, &FileAttrData))
        {
            bDetermineFile = true;
        }

        // Just use the next file if we're full.
        else if(FileAttrData.nFileSizeLow >= _dwMaxSize/_dwNumFiles)
        {
            // Construct so we can use conversion features.
            TLogData LogData(
                g_idxNumPart, _dwMaxSize/_dwNumFiles, g_wszFileCur, FileAttrData.nFileSizeLow);

            // When we set g_wszFileCur in first place, we validated then.
            // So, this will always succeed
            bool bSync = LogData.SyncVersion();
            ASSERT(bSync);

            // Set g_wszFileCur to next version
            SetGlobalFile(g_wszFileCur, g_idxNumPart, LogData.GetVersion()+1);

            // Delete stale file.  We don't care if it doesn't exist.
            LogData.SetVersion(LogData.GetVersion()+1 - _dwNumFiles);
            DeleteFile(LogData.cFileName);
        }
    }

    // Has not been set yet, so we need to determine.
    else
    {
        bDetermineFile = true;
    }

    if(bDetermineFile)
    {
        HRESULT hr = DetermineFile();
        if(FAILED(hr))
        {
            DBGERROR((DBG_CONTEXT, "DetermineFile failed, hr=0x%x\n", hr));
            return;
        }
    }

    // g_wszFileCur is now set
    
    _hFile = CreateFile(g_wszFileCur,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, // security attributes
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                        NULL);
    if (_hFile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    if(ERROR_ALREADY_EXISTS != GetLastError())//If the file was just created, then write FF FE to indicate UNICODE text file
    {
        WCHAR wchUnicodeSignature = 0xFEFF;
        DWORD written;
        WriteFile(_hFile, &wchUnicodeSignature, sizeof(WCHAR), &written, NULL);
    }
}


HRESULT TextFileLogger::DetermineFile()
/*++

Synopsis: 
    Finds the file to log to.
    1) Find the highest file (<= MAX_ULONG).
    2) If we don't find a single valid file, just set version to 0.
    3) If the file we found is full
        - Normally, just use next.  
        - In case of rollover, look for first non-full file.
    4) Once a file has been picked, delete file# (new version-_dwNumFiles).

    Caller should Lock() before calling this.

Return Value: 
    HRESULT

--*/
{
    WCHAR   wszSearchPath[MAX_PATH];

    // This is actually a pointer to somewhere in wszSearchPath
    LPWSTR pNumPart  = NULL;
    LPWSTR pFilePart = NULL;

    if( !ConstructSearchString(wszSearchPath, &pFilePart, &pNumPart) )
    {
        DBGERROR((DBG_CONTEXT, "ConstructSearchString failed\n"));
        return E_FAIL;
    }
    ASSERT(pFilePart >= wszSearchPath);
    ASSERT(pNumPart  >= pFilePart);

    // pFileDataHighest and pFileDataCurrent should never point to same memory.
    TLogData  FindFileData1((ULONG)(pNumPart-pFilePart), _dwMaxSize/_dwNumFiles);
    TLogData  FindFileData2((ULONG)(pNumPart-pFilePart), _dwMaxSize/_dwNumFiles);
    TLogData* pFileDataHighest       = &FindFileData1;
    TLogData* pFileDataCurrent       = &FindFileData2;

    HANDLE     hFindFile = FindFirstFile(wszSearchPath, pFileDataCurrent);

    // special case when no files are found: just set g_wszFileCur to ver 0.
    if( hFindFile == INVALID_HANDLE_VALUE )
    {
        SetGlobalFile(wszSearchPath, pNumPart-wszSearchPath, 0);
        return S_OK;
    }

    DWORD dw = ERROR_SUCCESS;
    do
    {
        // Only consider file if we can determine the version number
        if( pFileDataCurrent->SyncVersion() )
        {
            // only check full if we haven't found a "lowest" yet or this file is
            // smaller than the current "lowest"
            if( !pFileDataHighest->ContainsData() ||
                pFileDataCurrent->GetVersion() > pFileDataHighest->GetVersion())
            {
                TLogData* pFindTemp    = pFileDataHighest;
                pFileDataHighest       = pFileDataCurrent;
                pFileDataCurrent       = pFindTemp;
            }
        }

        // Move to next file
        dw = FindNextFile(hFindFile, pFileDataCurrent);
        if(0 == dw)
        {
            dw = GetLastError();
            if(dw == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                FindClose(hFindFile);
                DBGERROR((DBG_CONTEXT, "FindNextFile returned err=%u\n", dw));
                return HRESULT_FROM_WIN32(dw);
            }
        }
    }
    while(1);
    FindClose(hFindFile);

    // If we didn't find a highest, just set g_wszFileCur to 0.
    if(!pFileDataHighest->ContainsData())
    {
        SetGlobalFile(wszSearchPath, pNumPart-wszSearchPath, 0);
        return S_OK;
    }

    else if(pFileDataHighest->IsFull())
    {
        if(pFileDataHighest->GetVersion() == 0xFFFFFFFF)
        {
            HRESULT hr = GetFirstAvailableFile(wszSearchPath, pFilePart, pFileDataHighest);
            if(FAILED(hr))
            {
                DBGERROR((DBG_CONTEXT, "GetFirstAvailableFile returned hr=0x%x\n", hr));
                return hr;
            }
        }
        else
        {
            pFileDataHighest->IncrementVersion();
        }

        // Delete the obsolete log file.
        _snwprintf(pNumPart, 10, L"%010lu", pFileDataHighest->GetVersion() - _dwNumFiles);
        DeleteFile(wszSearchPath);
    }

    SetGlobalFile(wszSearchPath, pNumPart-wszSearchPath, pFileDataHighest->GetVersion());

    return S_OK;
}

HRESULT TextFileLogger::GetFirstAvailableFile(
    LPWSTR    wszBuf,                                              
    LPWSTR    wszFilePartOfBuf,
    TLogData* io_pFileData)
/*++

Synopsis: 
    Should only be called when we have a file of version MAX_ULONG.
    Caller should Lock().

Arguments: [wszBuf] - 
           [wszFilePartOfBuf] - 
           [io_pFileData] - 
           
Return Value: 

--*/
{
    ASSERT(wszBuf);
    ASSERT(wszFilePartOfBuf);
    ASSERT(wszFilePartOfBuf >= wszBuf);
    ASSERT(io_pFileData);

    WIN32_FILE_ATTRIBUTE_DATA FileData;

    for(ULONG i = 0; i < 0xFFFFFFFF; i++)
    {
        io_pFileData->SetVersion(i);

        wcscpy(wszFilePartOfBuf, io_pFileData->cFileName);

        if(0 == GetFileAttributesEx(wszBuf, GetFileExInfoStandard, &FileData))
        {
            HRESULT hr = GetLastError();
            hr = HRESULT_FROM_WIN32(hr);
            if(hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                DBGERROR((DBG_CONTEXT, "Could not fetch attributes, hr=0x%x\n", hr));
                return hr;
            }
            io_pFileData->nFileSizeLow = 0;
            return S_OK;
        }

        if(FileData.nFileSizeLow < _dwMaxSize/_dwNumFiles)
        {
            io_pFileData->nFileSizeLow = FileData.nFileSizeLow;
            return S_OK;
        }
    }

    DBGERROR((DBG_CONTEXT, "Could not find an available file\n"));
    return HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES);
}

bool TextFileLogger::ConstructSearchString(
    LPWSTR  o_wszSearchPath,
    LPWSTR* o_ppFilePartOfSearchPath,
    LPWSTR* o_ppNumPartOfSearchPath)
/*++

Synopsis: 
    Constructs the search string.

Arguments: [o_wszSearchPath] -           The search string
           [o_ppFilePartOfSearchPath] -  Ptr into search string
           [o_ppNumPartOfSearchPath] -   Ptr into search string
           
Return Value: 

--*/
{   
    ASSERT(o_wszSearchPath);
    ASSERT(o_ppNumPartOfSearchPath);
    ASSERT(*o_ppNumPartOfSearchPath == NULL);
    ASSERT(o_ppFilePartOfSearchPath);
    ASSERT(*o_ppFilePartOfSearchPath == NULL);

    ULONG cchWinDir = GetSystemDirectory(o_wszSearchPath, MAX_PATH);
    if(cchWinDir == 0 || cchWinDir > MAX_PATH)
    {
        DBGERROR((DBG_CONTEXT, "Path of windows dir is larger than MAX_PATH\n"));
        return false;
    }

    static LPCWSTR     wszBackSlash  = L"\\";
    static const ULONG cchBackSlash  = 1;

    static WCHAR       wszInetSrv[]  = L"inetsrv\\";
    static const ULONG cchInetSrv    = sizeof(wszInetSrv)/sizeof(WCHAR) - 1;

    ULONG              cchEventSrc   = wcslen(_eventSource);

    static WCHAR       wszSuffix[]   = L"_??????????.log";
    static const ULONG cchSuffix     = sizeof(wszSuffix)/sizeof(WCHAR) - 1;

    if((cchWinDir + cchBackSlash + cchInetSrv + cchEventSrc + cchSuffix) >= MAX_PATH)
    {
        DBGERROR((DBG_CONTEXT, "Path + logfile exceeds MAX_PATH\n"));
        return false;
    }

    LPWSTR pEnd = o_wszSearchPath + cchWinDir;
    
    if((pEnd != o_wszSearchPath) && (*(pEnd-1) != L'\\'))
    {
        memcpy(pEnd, wszBackSlash, cchBackSlash*sizeof(WCHAR));
        pEnd += cchBackSlash;
    }

    memcpy(pEnd, wszInetSrv, cchInetSrv*sizeof(WCHAR));
    pEnd += cchInetSrv;

    *o_ppFilePartOfSearchPath = pEnd;

    memcpy(pEnd, _eventSource, cchEventSrc*sizeof(WCHAR));
    pEnd += cchEventSrc;

    memcpy(pEnd, wszSuffix,    cchSuffix*sizeof(WCHAR));
    *o_ppNumPartOfSearchPath = pEnd+1;
    pEnd += cchSuffix;

    *pEnd = L'\0';
    return true;
}

void TextFileLogger::SetGlobalFile(
    LPCWSTR i_wszSearchString,
    ULONG   i_ulIdxNumPart,
    ULONG   i_ulVersion)
/*++

Synopsis: 
    Sets g_wszFileCur and g_idxNumPart.
    Caller should Lock().

Arguments: [i_wszSearchString] - The search string
           [i_ulIdxNumPart] -    Index into search string where version starts
           [i_ulVersion] -       The version we want to set.
           
--*/
{
    ASSERT(i_wszSearchString);

    g_idxNumPart = i_ulIdxNumPart;
    
    if(g_wszFileCur != i_wszSearchString)
    {
        wcscpy(g_wszFileCur, i_wszSearchString);
    }
    _snwprintf(g_wszFileCur + g_idxNumPart, 10, L"%010lu", i_ulVersion);
}

// end TextFileLogger
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\tslist.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include <svcerr.h>
#include <svcmem.h>
#include "tslist.h"


CInterlockedCompareExchange * CNodeStackAllocator::sm_pInterlockedExchange64 = GetSafeInterlockedExchange64();

volatile ListRoot CNodeStackAllocator::sm_list;

//
//	returns a pointer to the function supported by the current hardware
//	for doing interlocked exchanges
//
CInterlockedCompareExchange * GetSafeInterlockedExchange64()
{	
	if (CanUseCompareExchange64())
	{
		return (CInterlockedCompareExchange * )new (SAFE) CHWInterlockedCompareExchange;	
	}

	return (CInterlockedCompareExchange * ) new (SAFE) CSlowCompareExchange;	
}

   	

void CStack::push(void * pv)
{
	StackNode * pNode = CNodeStackAllocator::GetNode();
	ListRoot ListComp;
	ListRoot ListExch;
	for (;;) // make it thread safe
	{
		ListComp.m_element.pvFirst = m_list.m_element.pvFirst;
		ListComp.m_element.ulFlag  = m_list.m_element.ulFlag;           			
        pNode -> data = (void *)pv;
		pNode -> pNext = (void *)ListComp.m_element.pvFirst;
		ListExch.m_element.pvFirst = pNode;
		ListExch.m_element.ulFlag = ListComp.m_element.ulFlag + 1;
		if (ListComp == m_pInterlockedExchange64 -> InterlockedCompareExchange64((volatile __int64*) &m_list, (__int64) ListExch, (__int64) ListComp))
		{				
			return;
		}
	}
}


void * CStack::pop()
{
	StackNode * pNode = NULL;
	ListRoot ListComp;
	ListRoot ListExch;
	for (;;)
	{
		ListComp.m_element.pvFirst = m_list.m_element.pvFirst;
		ListComp.m_element.ulFlag  = m_list.m_element.ulFlag;
		pNode = (StackNode *)ListComp.m_element.pvFirst;
		if (pNode == NULL) // stack empty
			return NULL;

		ListExch.m_element.pvFirst = pNode -> pNext;
		ListExch.m_element.ulFlag = ListComp.m_element.ulFlag + 1;
		if (ListComp == m_pInterlockedExchange64 -> InterlockedCompareExchange64  ((volatile __int64*) &m_list, (__int64) ListExch, (__int64) ListComp))
		{
			void * pData = pNode -> data;
			CNodeStackAllocator::PutNode(pNode);
			return pData;
		}

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\stackwalk.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <unicode.h>
#include <windows.h>
#include <objbase.h>
#include <malloc.h>
#include "StackWalk.h"
char * mystrdup(const char * sz)
{
	int nLen = lstrlenA(sz) + 1;
	char * tmp = (char *)malloc(nLen);
	lstrcpyA(tmp, sz);
	return tmp;
}


StackWalker::SymGetModuleInfoFunc		StackWalker::_SymGetModuleInfo;
StackWalker::SymGetSymFromAddrFunc		StackWalker::_SymGetSymFromAddr;
StackWalker::SymLoadModuleFunc			StackWalker::_SymLoadModule;
StackWalker::StackWalkFunc				StackWalker::_StackWalk;
StackWalker::UndecorateSymbolNameFunc	StackWalker::_UndecorateSymbolName;
PFUNCTION_TABLE_ACCESS_ROUTINE				StackWalker::_SymFunctionTableAccess;

StackWalker::StackWalker(HANDLE hProcess)
	: _imageHlpDLL(NULL),
	  _hProcess(hProcess)
{
	_imageHlpDLL = LoadLibrary(L"imagehlp.dll");
	if (_imageHlpDLL != NULL) {
		// Get commonly used Sym* functions.
		if (_StackWalk == NULL) {
			// If one of them are null, assume
			// they all are.  Benign race here.

			_StackWalk = (StackWalkFunc)GetProcAddress(_imageHlpDLL, "StackWalk");
			if (_StackWalk == NULL)
				return;
			_SymGetModuleInfo = (SymGetModuleInfoFunc)GetProcAddress(_imageHlpDLL,
																	 "SymGetModuleInfo");
			if (_SymGetModuleInfo == NULL)
				return;
			_SymGetSymFromAddr = (SymGetSymFromAddrFunc)GetProcAddress(_imageHlpDLL,
																	   "SymGetSymFromAddr");
			if (_SymGetSymFromAddr == NULL)
				return;
			_SymLoadModule = (SymLoadModuleFunc)GetProcAddress(_imageHlpDLL,
															   "SymLoadModule");
			if (_SymLoadModule == NULL)
				return;
			_UndecorateSymbolName = (UndecorateSymbolNameFunc)GetProcAddress(_imageHlpDLL,
																			 "UnDecorateSymbolName");
			if (_UndecorateSymbolName == NULL)
				return;
			_SymFunctionTableAccess = (PFUNCTION_TABLE_ACCESS_ROUTINE)GetProcAddress(_imageHlpDLL,
																						 "SymFunctionTableAccess");
			if (_SymFunctionTableAccess == NULL)
				return;
		}

		// Sym* functions that we're only going to use locally.
		typedef BOOL (__stdcall *SymInitializeFunc)(HANDLE hProcess,
													LPSTR path,
													BOOL invadeProcess);
		typedef DWORD (__stdcall *SymSetOptionsFunc)(DWORD);

		SymInitializeFunc SymInitialize = (SymInitializeFunc)GetProcAddress(_imageHlpDLL,
																			"SymInitialize");
		if (SymInitialize == NULL)
			return;
		SymSetOptionsFunc SymSetOptions = (SymSetOptionsFunc)GetProcAddress(_imageHlpDLL,
																			"SymSetOptions");
		if (SymSetOptions == NULL)
			return;

		if (SymInitialize(hProcess, NULL, FALSE))
			SymSetOptions(0);
	}
}


StackWalker::~StackWalker() {
	if (_imageHlpDLL != NULL) {
		typedef BOOL (__stdcall *SymCleanupFunc)(HANDLE hProcess);

		SymCleanupFunc SymCleanup = (SymCleanupFunc)GetProcAddress(_imageHlpDLL,
																   "SymCleanup");
		if (SymCleanup != NULL)
			SymCleanup(_hProcess);

		FreeLibrary(_imageHlpDLL);
	}
}

DWORD_PTR StackWalker::LoadModule(HANDLE hProcess, DWORD_PTR address) {
    MEMORY_BASIC_INFORMATION mbi;

    if (VirtualQueryEx(hProcess, (void*)address, &mbi, sizeof mbi)) {
        if (mbi.Type & MEM_IMAGE) {
            char module[MAX_PATH];
            DWORD cch = GetModuleFileNameA((HINSTANCE)mbi.AllocationBase,
                                           module,
                                           MAX_PATH);

            // Ignore the return code since we can't do anything with it.
            (void)_SymLoadModule(hProcess,
                                 NULL,
                                 ((cch) ? module : NULL),
                                 NULL,
                                 (DWORD_PTR) mbi.AllocationBase,
                                 0);
            return (DWORD_PTR) mbi.AllocationBase;
        }
    }

    return 0;
}

Symbol* StackWalker::ResolveAddress(DWORD_PTR addr) {
	if (_imageHlpDLL == NULL)
		return NULL;

	// Find out what module the address lies in.
	char* module = NULL;
	IMAGEHLP_MODULE moduleInfo;
	moduleInfo.SizeOfStruct = sizeof moduleInfo;

	if (_SymGetModuleInfo(_hProcess, addr, &moduleInfo)) {
		module = moduleInfo.ModuleName;
	}
	else {
		// First attempt failed, load the module info.
		LoadModule(_hProcess, addr);
		if (_SymGetModuleInfo(_hProcess, addr, &moduleInfo))
			module = moduleInfo.ModuleName;
	}

	char* symbolName = NULL;
    char undecoratedName[512];
	IMAGEHLP_SYMBOL* symbolInfo = (IMAGEHLP_SYMBOL*)_alloca(sizeof(IMAGEHLP_SYMBOL) + 512);
	symbolInfo->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL) + 512;
	symbolInfo->MaxNameLength = 512;
	DWORD_PTR displacement = 0;
	if (_SymGetSymFromAddr(_hProcess, addr, &displacement, symbolInfo)) {
		DWORD flags = UNDNAME_NO_MS_KEYWORDS 
			| UNDNAME_NO_ACCESS_SPECIFIERS
			| UNDNAME_NO_FUNCTION_RETURNS
			| UNDNAME_NO_MEMBER_TYPE;
		if (_UndecorateSymbolName(symbolInfo->Name, undecoratedName, 512, flags))
			symbolName = undecoratedName;
		else
			symbolName = symbolInfo->Name;
	}
	else {
		displacement = addr - moduleInfo.BaseOfImage;
	}

	return new Symbol(module, symbolName, displacement);
}



DWORD_PTR __stdcall StackWalker::GetModuleBase(HANDLE hProcess, DWORD_PTR address) {
    IMAGEHLP_MODULE moduleInfo;
	moduleInfo.SizeOfStruct = sizeof moduleInfo;
	
    if (_SymGetModuleInfo(hProcess, address, &moduleInfo))
        return moduleInfo.BaseOfImage;
    else
		return LoadModule(hProcess, address);

}

Symbol* StackWalker::CreateStackTrace(CONTEXT* context) {
	if (_imageHlpDLL == NULL)
		return NULL;

	HANDLE hThread = GetCurrentThread();

	DWORD dwMachineType;
	STACKFRAME frame = {0};
	frame.AddrPC.Mode = AddrModeFlat;
#if defined(_M_IX86)
	dwMachineType          = IMAGE_FILE_MACHINE_I386;
	frame.AddrPC.Offset    = context->Eip;  // Program Counter
	
	frame.AddrStack.Offset = context->Esp;  // Stack Pointer
	frame.AddrStack.Mode   = AddrModeFlat;
	frame.AddrFrame.Offset = context->Ebp;  // Frame Pointer
#elif defined(_M_AMD64)
	dwMachineType          = IMAGE_FILE_MACHINE_AMD64;
	frame.AddrPC.Offset    = (DWORD_PTR) context->Rip;			// Program Counter
	frame.AddrStack.Offset = (DWORD_PTR) context->Rsp;	    	// Stack Pointer
	frame.AddrFrame.Offset = (DWORD_PTR) context->Rbp;	    	// Frame Pointer

#elif defined(_M_IA64)     // BUGBUG: check for correctness

	dwMachineType          = IMAGE_FILE_MACHINE_IA64;
	frame.AddrPC.Offset    = context->StIIP;  // Program Counter
	
	frame.AddrStack.Offset = context->IntSp; //Stack Pointer
	frame.AddrStack.Mode   = AddrModeFlat;
    // No Frame pointer information for IA64 (per Intel folks)
	//frame.AddrFrame.Offset = context->Ebp;  // Frame Pointer
#else
#error Unknown Target Machine
#endif
	
	// These variables are used to count the number of consecutive frames 
	// with the exact same PC returned by StackWalk().  On the Alpha infinite
	// loops (and infinite lists!) were being caused by StackWalk() never 
	// returning FALSE (see Raid Bug #8354 for details).
	const DWORD dwMaxNumRepetitions = 40;
	DWORD dwRepetitions	= 0;
	ADDRESS addrRepeated = {0, 0, AddrModeFlat};

	// Walk the stack...
	Symbol* prev = NULL;
	Symbol* head = NULL;

	for (;;) {
		if (!_StackWalk(dwMachineType,
						_hProcess,
						hThread,
						&frame,
						&context,
						NULL,
						_SymFunctionTableAccess,
						GetModuleBase,
						NULL))
			break;
		if (frame.AddrPC.Offset == 0)
			break;

		// Check for repeated addresses;  if dwMaxNumRepetitions are found,
		// then we break out of the loop and exit the stack walk
		if (addrRepeated.Offset == frame.AddrPC.Offset &&
			addrRepeated.Mode == frame.AddrPC.Mode) {
			dwRepetitions ++;
			if (dwRepetitions == dwMaxNumRepetitions) {
				break;
			}
		} else {
			dwRepetitions = 0;
			addrRepeated.Offset = frame.AddrPC.Offset;
			addrRepeated.Mode = frame.AddrPC.Mode;
		}

		Symbol* sym = ResolveAddress(frame.AddrPC.Offset);
		if (sym == NULL)
			break;

		// Append this symbol to the previous one, if any.
		if (prev == NULL) {
			prev = sym;
			head = sym;
		}
		else {
			prev->Append(sym);
			prev = sym;
		}
	}

	return head;
}

int StackWalker::GetCallStackSize(Symbol* symbol)
{
	int nSize = 2; // Start with a "\r\n".
	const char* module = NULL;
	const char* symbolName = NULL;	
	Symbol * sym = symbol;
	while (sym != NULL)
	{
		module = sym->moduleName();
		symbolName = sym->symbolName();	
		nSize += lstrlenA(module);
		nSize += lstrlenA(symbolName);
		nSize += 32; // displacement, spaces, etc.
		sym = sym -> next();
	}

	return nSize;
}
BOOL StackWalker::GetCallStack(Symbol * symbol, int nChars, WCHAR * sz)
{
	if (!symbol || !nChars)
		return FALSE;

	Symbol* sym = symbol;
	
	//	for (int i=0;i<3;i++)
	//	{
	//		Symbol* tmp = sym;
	//		sym = sym->next();
	//		delete tmp;
	//		if (!sym)
	//			break;
	//	}

	const char* module = NULL;
	const char* symbolName = NULL;	
	char * szStack = (char * )CoTaskMemAlloc(nChars);
	ZeroMemory(szStack, nChars);
	lstrcpyA(szStack, "\r\n"); // Start with a CR-LF.
	Symbol* tmp  = NULL;
	while (sym != NULL) 
	{	
		module = sym->moduleName();
		symbolName = sym->symbolName();			
		if (module != NULL) 
		{
			lstrcatA(szStack, module);
			if (symbolName != NULL)
				lstrcatA(szStack, "!");
		}

		if (symbolName != NULL)
			lstrcatA(szStack, symbolName);

		sym -> AppendDisplacement(szStack);

		lstrcatA(szStack, "\r\n");
		tmp = sym;
		sym = sym->next();
		delete tmp;
	}

	int nLen = lstrlenA(szStack);
	nLen++;		
	MultiByteToWideChar(CP_ACP, 0, szStack, nLen, sz, nLen);
	CoTaskMemFree(szStack);
	return TRUE;
	
}



Symbol::Symbol(const char* moduleName, const char* symbolName, DWORD_PTR displacement)
	: _moduleName(NULL),
	  _symbolName(NULL),
	  _displacement(displacement),
	  _next(NULL)
{
	if (moduleName != NULL)
		_moduleName = mystrdup(moduleName);
	if (symbolName != NULL)
		_symbolName = mystrdup(symbolName);
}

Symbol::~Symbol() {
	free(_moduleName);
	free(_symbolName);
}

void Symbol::Append(Symbol* sym) {
	_next = sym;
}


#if 0
#include <iostream.h>
DWORD filter(EXCEPTION_POINTERS* exp) {
	StackWalker resolver(GetCurrentProcess());
	Symbol* symbol = resolver.CreateStackTrace(exp->ContextRecord);
	if (symbol == NULL) {
		cout << "Couldn't get stack trace" << endl;
	}
	else {
		cout << "Stack trace:" << endl;

		Symbol* sym = symbol;
		while (sym != NULL) {
			const char* module = sym->moduleName();
			const char* symbolName = sym->symbolName();

			if (module != NULL) {
				cout << module;
				if (symbolName != NULL)
					cout << '!';
			}
			if (symbolName != NULL)
				cout << symbolName;
			cout << "+0x" << hex << sym->displacement() << dec << endl;

			Symbol* tmp = sym;
			sym = sym->next();

			delete tmp;
		}
	}

	return EXCEPTION_EXECUTE_HANDLER;
}


int bar(int x, int* p) {
	*p = x;
	return 5;
}

void foo(int* p) {
	bar(5, p);
}

int main() {
	__try {
		int* p = (int*)0xdeadbeef;
		foo(p);
	}
	__except (filter(GetExceptionInformation())) {

	}

	return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\txmlparsedfile.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
//  TXmlParsedFile.cpp : Implementation of TXmlParsedFile, TAttribute and TElement

//  This is a read only data table that comes from an XML document.  It contains metadata.
//  It can be used in place of sdtfxd, which has the meta data hard coded into structures.

#ifndef _OBJBASE_H_
    #include <objbase.h>
#endif
#include "winwrap.h"
#ifndef __TXMLPARSEDFILE_H__
    #include "TXmlParsedFile.h"
#endif

//Public Methods
TXmlParsedFile::TXmlParsedFile() : m_cbElementPool(0), m_cbStringPool(0), m_cElements(0), m_CurrentLevelBelowRootElement(0), m_cWcharsInStringPool(0),
                m_dwTickCountOfLastParse(0), m_pElement(0), m_pLastBeginTagElement(0), m_pCache(0)
{
    m_FileName[0] = 0x00;
    memset(&m_ftLastWriteTime, 0x00, sizeof(FILETIME));
    if(TXmlParsedFile::Undetermined == m_OSSupportForInterLockedExchangeAdd)
    {
        OSVERSIONINFO osvi;

        memset(&osvi, 0x00, sizeof(osvi));
        osvi.dwOSVersionInfoSize = sizeof(osvi);

        GetVersionEx(&osvi);
        if(((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osvi.dwMajorVersion >= 4)) || 
            ((osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && ((osvi.dwMajorVersion > 4) || ((osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion > 0)))))
        {
            HINSTANCE hKernel32 = LoadLibraryA("kernel32.dll");
            m_pfnInterLockedExchangeAdd = reinterpret_cast<INTERLOCKEDEXCHANGEADD>(GetProcAddress(hKernel32, "InterlockedExchangeAdd"));//GetProcAddress tolerates NULL instance handles
			if (m_pfnInterLockedExchangeAdd)
			{
	            m_OSSupportForInterLockedExchangeAdd = Supported;
			}
			else
			{
	            m_OSSupportForInterLockedExchangeAdd = Unsupported;
			}
            FreeLibrary(hKernel32);
        }
        else
        {   // Win95 doesn't have this function
            m_OSSupportForInterLockedExchangeAdd = Unsupported;
        }
    }
}


TXmlParsedFile::~TXmlParsedFile()
{
    //Warning! This object is thread safe but don't delete it while another thread is parsing.  This shouldn't be an issue.
}

    
HRESULT TXmlParsedFile::Parse(TXmlParsedFileNodeFactory &i_XmlParsedFileNodeFactory, LPCTSTR i_filename, bool bOnlyIfInCache)
{
    HRESULT hr;

    //We have to guard this method with a critical section, otherwise two threads might try to Parse (or Unload) at the same time.
    CSafeLock ThisObject(m_SACriticalSectionThis);
	DWORD dwRes = ThisObject.Lock();
    if(ERROR_SUCCESS != dwRes)
    {
        return HRESULT_FROM_WIN32(dwRes);
    }

    //If we haven't already parsed this file, then parse it into a form that can be scanned quicker.
    WIN32_FILE_ATTRIBUTE_DATA FileInfo;
    GetFileAttributesEx(i_filename, GetFileExInfoStandard, &FileInfo);
 
    //If this XmlParsedFile is not a complete parse OR the filenames don't match OR the LastWriteTime has changed...
    if(!IsCompletedParse() || 0 != _wcsicmp(i_filename, m_FileName) || 0 != memcmp(&FileInfo.ftLastWriteTime, &m_ftLastWriteTime, sizeof(FILETIME)))
    {
        if(bOnlyIfInCache)
            return E_SDTXML_NOT_IN_CACHE;

        //...then we need to re MSXML Parse
        Unload();//If a file was loaded into this object, unload it.
        if(FAILED(hr = Load(i_filename)))return hr;

        //Remember the LastWriteTime for comparison next time
        memcpy(&m_ftLastWriteTime, &FileInfo.ftLastWriteTime, sizeof(FILETIME));

        //We're getting ready to access the GrowableBuffer, so we need to lock it.
        CSafeLock StaticBuffers(m_SACriticalSectionStaticBuffers);
		dwRes = StaticBuffers.Lock ();
		if(ERROR_SUCCESS != dwRes)
		{
			return HRESULT_FROM_WIN32(dwRes);
		}

        //If the GrowableBuffer isn't big enough, make it bigger.
        if(m_SizeOfGrowableBuffer/2 < ((sizeof(LPVOID)/sizeof(ULONG))*Size()*sizeof(WCHAR))) // for 64 bits we need a larger memory block to store the pointers
        {
            m_aGrowableBuffer.Delete();          //@@@TODO We should check the size as we're adding elements into this buffer and realloc if necessary.  But for now 3 times the size should be big enough for the worst case (excluding contrived enum public row name worst case).
            m_aGrowableBuffer = new unsigned char [3*(sizeof(LPVOID)/sizeof(ULONG))*Size()*sizeof(WCHAR)];
            if(!m_aGrowableBuffer)
                return E_OUTOFMEMORY;
            m_SizeOfGrowableBuffer = 3*(sizeof(LPVOID)/sizeof(ULONG))*Size()*sizeof(WCHAR);
        }

        //Start creating the list of TElement at the beginning of the buffer
        m_cElements     = 0;
        m_cbElementPool = 0;
        m_pElement  = reinterpret_cast<TElement *>(m_aGrowableBuffer.m_p);

        //Node Factory is a stream line way of parsing XML.  It does not validate the XML, nor is it capable of writing.  So populating
        //read only XML tables should be faster than populating writable tables.
        CComPtr<IXMLParser> pXMLParser;
        if(FAILED(hr = i_XmlParsedFileNodeFactory.CoCreateInstance(CLSID_XMLParser, NULL, CLSCTX_INPROC_SERVER, IID_IXMLParser, (void**)&pXMLParser)))return hr;

        if(FAILED(hr = pXMLParser->SetFactory(this)))return hr;

        if(FAILED(hr = pXMLParser->SetFlags( XMLFLAG_NOWHITESPACE )))return hr;
        if(FAILED(hr = pXMLParser->PushData(Mapping(), Size(), true)))return hr;

        hr = pXMLParser->Run(-1);//Run can return with E_SDTXML_DONE, which is a special case.

        //We're now done with the file so unmap it as soon as possible.
        TFileMapping::Unload();

        if(S_OK != hr && E_SDTXML_DONE != hr)return hr;

        if(!m_pCache)
        {
            //Now that we have a XmlParsedFile, we can scan through the elements quicker
            m_pElement = reinterpret_cast<TElement *>(m_aGrowableBuffer.m_p);
            hr=S_OK;
            for(unsigned int i=0;i<m_cElements && S_OK==hr;++i)
            {
                hr = i_XmlParsedFileNodeFactory.CreateNode(*m_pElement);
                m_pElement = m_pElement->Next();
            }
            Unload();
            return hr;
        }
        
        //If this object belongs to a cache then allocate and copy the element list from the growable buffer to the member element list
        if(FAILED(hr = AllocateAndCopyElementList((ULONG)(reinterpret_cast<unsigned char *>(m_pElement) + sizeof(DWORD) - m_aGrowableBuffer))))return hr;
                                                                                                //Leave room for the zero terminating m_LevelOfElement
        //If this object belongs to a cache and the parse completed, then accumulate the size
        MemberInterlockedExchangeAdd(&m_pCache->m_cbTotalCache, PoolSize());
    }
    //Now the StaticBuffers are unlocked, but this object is still locked

    //Always keep track of the tick count
    m_dwTickCountOfLastParse = GetTickCount();

    //Now that we have a XmlParsedFile, we can scan through the elements quicker
    m_pElement = reinterpret_cast<TElement *>(m_ElementPool.m_p);
    hr=S_OK;
    for(unsigned int i=0;i<m_cElements && S_OK==hr;++i)
    {
        hr = i_XmlParsedFileNodeFactory.CreateNode(*m_pElement);
        m_pElement = m_pElement->Next();
    }

    return hr;//If XmlParsedFileNodeFactory.CreateNode returned anything but S_OK, return that back out
    //Release this object's critical section as we leave the function
}


HRESULT 
TXmlParsedFile::Unload()
{
    CSafeLock ThisObject(m_SACriticalSectionThis);
	DWORD dwRes = ThisObject.Lock();
	if(ERROR_SUCCESS != dwRes)
    {
        return HRESULT_FROM_WIN32(dwRes);
    }

    if(m_pCache)
    {
        MemberInterlockedExchangeAdd(&m_pCache->m_cbTotalCache, -static_cast<long>(PoolSize()));
    }

    m_cbElementPool         = 0;
    m_cbStringPool          = 0;
    m_cElements             = 0;
    m_cWcharsInStringPool   = 0;
    m_FileName[0]           = 0;

    m_ElementPool.Delete();
    m_StringPool.Delete();
    TFileMapping::Unload();

	return S_OK;
}


//Private static variables
TSmartPointerArray<unsigned char>    TXmlParsedFile::m_aGrowableBuffer;
CSafeAutoCriticalSection             TXmlParsedFile::m_SACriticalSectionStaticBuffers;
unsigned long                        TXmlParsedFile::m_SizeOfGrowableBuffer = 0;
int                                  TXmlParsedFile::m_OSSupportForInterLockedExchangeAdd = TXmlParsedFile::Undetermined;
INTERLOCKEDEXCHANGEADD               TXmlParsedFile::m_pfnInterLockedExchangeAdd = NULL;

//IXMLNodeFactory methods
STDMETHODIMP TXmlParsedFile::BeginChildren(IXMLNodeSource __RPC_FAR *i_pSource, XML_NODE_INFO* __RPC_FAR i_pNodeInfo)\
{
    return S_OK;
}


STDMETHODIMP TXmlParsedFile::CreateNode(IXMLNodeSource __RPC_FAR *i_pSource, PVOID i_pNodeParent, USHORT i_cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR i_apNodeInfo)
{
    unsigned long CurrentLevel  = m_CurrentLevelBelowRootElement;

    if (!i_apNodeInfo[0]->fTerminal )
        ++m_CurrentLevelBelowRootElement;

    if(0 == CurrentLevel)
        return S_OK;//We never care about the Root element

    switch(i_apNodeInfo[0]->dwType)
    {
    case XML_ELEMENT:
        {
            if(0 == i_apNodeInfo[0]->pwcText)
                return S_OK;

            m_pElement->m_ElementType         = static_cast<XML_NODE_TYPE>(i_apNodeInfo[0]->dwType);
            m_pElement->m_LevelOfElement      = CurrentLevel;
            m_pElement->m_ElementNameLength   = i_apNodeInfo[0]->ulLen; 
            m_pElement->m_ElementName         = AddStringToPool(i_apNodeInfo[0]->pwcText + i_apNodeInfo[0]->ulNsPrefixLen, i_apNodeInfo[0]->ulLen);
            m_pElement->m_NumberOfAttributes  = 0;
            m_pElement->m_NodeFlags           = fBeginTag;
            m_pLastBeginTagElement = m_pElement;

        //    unsigned long len = wcslen(m_pElement->m_ElementName);

            for(unsigned long iNodeInfo=1; iNodeInfo<i_cNumRecs; ++iNodeInfo)
            {
                if(XML_ATTRIBUTE != i_apNodeInfo[iNodeInfo]->dwType)
                    continue;

                m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_NameLength   = i_apNodeInfo[iNodeInfo]->ulLen;
                m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Name         = AddStringToPool(i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen, i_apNodeInfo[iNodeInfo]->ulLen);

                if((iNodeInfo+1) == i_cNumRecs || XML_PCDATA != i_apNodeInfo[iNodeInfo+1]->dwType)
                {   //We don't want to increment iNodeInfo if we're at the last one OR if the next NodeInfo isn't an XML_PCDATA type.
                    m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  = 0;//Zero length string
                    m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Value        = AddStringToPool(0,0);
                }
                else
                {
                    ++iNodeInfo;
                    m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  = i_apNodeInfo[iNodeInfo]->ulLen;
                    m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Value        = AddStringToPool(i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen, i_apNodeInfo[iNodeInfo]->ulLen);

                    while((iNodeInfo+1)<i_cNumRecs && XML_PCDATA==i_apNodeInfo[iNodeInfo+1]->dwType)
                    {
                        ++iNodeInfo;
                        m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  += i_apNodeInfo[iNodeInfo]->ulLen;
                        AppendToLastStringInPool(i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen, i_apNodeInfo[iNodeInfo]->ulLen);
                    }
                }
                ++m_pElement->m_NumberOfAttributes;
            }
        }
        break;
    case XML_COMMENT://These three are exactly the same but with different types
    case XML_PCDATA:
    case XML_WHITESPACE:
        {
            ASSERT(0 != i_apNodeInfo[0]->pwcText && "I don't think this can happen for this type; but I handle it for XML_ELEMENTs so there must have been a reason");
            if(0 == i_apNodeInfo[0]->pwcText)
                return S_OK;

            m_pElement->m_ElementType         = static_cast<XML_NODE_TYPE>(i_apNodeInfo[0]->dwType);
            m_pElement->m_LevelOfElement      = CurrentLevel;
            m_pElement->m_cchComment          = i_apNodeInfo[0]->ulLen; 
            m_pElement->m_Comment             = AddStringToPool(i_apNodeInfo[0]->pwcText + i_apNodeInfo[0]->ulNsPrefixLen, i_apNodeInfo[0]->ulLen);
            m_pElement->m_NumberOfAttributes  = 0;
            m_pElement->m_NodeFlags           = fNone;
        }
        break;
    default://ignore all other node types
        return S_OK;
    }


    ++m_cElements;
    m_pElement = m_pElement->Next();
    m_pElement->m_LevelOfElement = 0;//This is my way of zero terminating the linked list.  It is only used by people who have a pElement and want to know
                                     //if it's the last one.  They check if(0 == pElement->Next()->m_LevelOfElement){//last element}
    return S_OK;
}


STDMETHODIMP TXmlParsedFile::EndChildren(IXMLNodeSource __RPC_FAR *i_pSource, BOOL i_fEmptyNode,XML_NODE_INFO* __RPC_FAR i_pNodeInfo)
{
    --m_CurrentLevelBelowRootElement;
    if(0 == m_pLastBeginTagElement || XML_PI == i_pNodeInfo->dwType || XML_XMLDECL == i_pNodeInfo->dwType)
        return S_OK;//This is needed to handle the <?xml version="1.0" encoding="UTF-8" ?>

    if(i_fEmptyNode)
    {
        ASSERT(fBeginTag == m_pLastBeginTagElement->m_NodeFlags);
        m_pLastBeginTagElement->m_NodeFlags |= fEndTag;
    }
    else
    {   //We need to create a new node for the EndTag
            m_pElement->m_ElementType         = static_cast<XML_NODE_TYPE>(i_pNodeInfo->dwType);
            m_pElement->m_LevelOfElement      = m_CurrentLevelBelowRootElement;
            m_pElement->m_cchComment          = i_pNodeInfo->ulLen; 
            m_pElement->m_Comment             = AddStringToPool(i_pNodeInfo->pwcText + i_pNodeInfo->ulNsPrefixLen, i_pNodeInfo->ulLen);
            m_pElement->m_NumberOfAttributes  = 0;
            m_pElement->m_NodeFlags           = fEndTag;

            ++m_cElements;
            m_pElement = m_pElement->Next();
            m_pElement->m_LevelOfElement = 0;//This is my way of zero terminating the linked list.  It is only used by people who have a pElement and want to know
                                             //if it's the last one.  They check if(0 == pElement->Next()->m_LevelOfElement){//last element}
    }
    return S_OK;
}


STDMETHODIMP TXmlParsedFile::Error(IXMLNodeSource __RPC_FAR *i_pSource, HRESULT i_hrErrorCode, USHORT i_cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR i_apNodeInfo)
{
    return i_hrErrorCode;
}


STDMETHODIMP TXmlParsedFile::NotifyEvent(IXMLNodeSource __RPC_FAR *i_pSource, XML_NODEFACTORY_EVENT i_iEvt)
{
    return S_OK;
}



//private methods
LPCWSTR TXmlParsedFile::AddStringToPool(LPCWSTR i_String, unsigned long i_Length)
{
    if(0 == i_String || 0 == i_Length)
        return m_StringPool;

    LPCWSTR rtn = m_StringPool + m_cWcharsInStringPool;

    memcpy(m_StringPool + m_cWcharsInStringPool, i_String, i_Length * sizeof(WCHAR));
    m_cWcharsInStringPool += i_Length;
    m_StringPool[m_cWcharsInStringPool++] = 0x00;//may as well NULL terminate it.
    return rtn;
}


HRESULT TXmlParsedFile::AllocateAndCopyElementList(unsigned long i_Length)
{
    m_ElementPool = new unsigned char [i_Length];
    if(0 == m_ElementPool.m_p)
        return E_OUTOFMEMORY;
    m_cbElementPool = i_Length;
    memcpy(m_ElementPool, m_aGrowableBuffer, i_Length);
    TFileMapping::Unload();
    return S_OK;
}

void TXmlParsedFile::AppendToLastStringInPool(LPCWSTR i_String, unsigned long i_Length)
{
    if(0 == i_String || 0 == i_Length)
        return;

    --m_cWcharsInStringPool;
    memcpy(m_StringPool + m_cWcharsInStringPool, i_String, i_Length * sizeof(WCHAR));
    m_cWcharsInStringPool += i_Length;
    m_StringPool[m_cWcharsInStringPool++] = 0x00;//may as well NULL terminate it.
}

HRESULT TXmlParsedFile::Load(LPCTSTR i_filename)
{
    ASSERT(0 == m_StringPool.m_p);

    HRESULT hr;
    m_FileName[MAX_PATH-1] = 0;
    wcsncpy(m_FileName, i_filename, MAX_PATH-1);//This is probably unnecessary, but this will prevent buffer overrun when i_filename is greater than MAX_PATH.
    if(FAILED(hr = TFileMapping::Load(i_filename, false)))return hr;

    m_StringPool = new WCHAR[Size()];
    if(0 == m_StringPool.m_p)
        return E_OUTOFMEMORY;
    m_cbStringPool = Size();
    m_StringPool[m_cWcharsInStringPool++] = 0x00;//reserve the first WCHAR as a zero length string
    return S_OK;
}

VOID TXmlParsedFile::MemberInterlockedExchangeAdd(PLONG Addend, LONG Increment)
{
        if(Supported == m_OSSupportForInterLockedExchangeAdd)
        {
            ASSERT(m_pfnInterLockedExchangeAdd != NULL);
            m_pfnInterLockedExchangeAdd(Addend, Increment);
        }
        else
        {
            //TODO Take a criticalsection instead
            InterlockedExchange(Addend, (LONG)(*Addend) + Increment);
        }
}



TXmlParsedFile_NoCache::TXmlParsedFile_NoCache() : m_CurrentLevelBelowRootElement(0), m_pElement(0), m_pXmlParsedFileNodeFactory(0)
{
}
TXmlParsedFile_NoCache::~TXmlParsedFile_NoCache()
{
}

HRESULT TXmlParsedFile_NoCache::Parse(TXmlParsedFileNodeFactory &i_XmlParsedFileNodeFactory, LPCTSTR i_filename)
{
    HRESULT hr;

    if(0 == m_ScratchBuffer.m_p)
    {
        m_ScratchBuffer = new unsigned char[0x4000];
        if(0 == m_ScratchBuffer.m_p)
            return E_OUTOFMEMORY;
    }

    m_pElement = reinterpret_cast<TElement *>(m_ScratchBuffer.m_p);
    m_CurrentLevelBelowRootElement = 0;
    m_pXmlParsedFileNodeFactory = &i_XmlParsedFileNodeFactory;

    //Node Factory is a stream line way of parsing XML.  It does not validate the XML, nor is it capable of writing.  So populating
    //read only XML tables should be faster than populating writable tables.
    CComPtr<IXMLParser> pXMLParser;
    if(FAILED(hr = i_XmlParsedFileNodeFactory.CoCreateInstance(CLSID_XMLParser, NULL, CLSCTX_INPROC_SERVER, IID_IXMLParser, (void**)&pXMLParser)))return hr;

    if(FAILED(hr = pXMLParser->SetFactory(this)))return hr;
    if(FAILED(hr = pXMLParser->SetFlags( XMLFLAG_NOWHITESPACE )))return hr;
    if(FAILED(hr = pXMLParser->SetURL(0, i_filename, FALSE)))return hr;

    hr = pXMLParser->Run(-1);

    m_ScratchBuffer.Delete();
    m_pElement = 0;

    return hr;
}

STDMETHODIMP TXmlParsedFile_NoCache::BeginChildren(IXMLNodeSource __RPC_FAR *i_pSource, XML_NODE_INFO* __RPC_FAR i_pNodeInfo)\
{
    return S_OK;
}

STDMETHODIMP TXmlParsedFile_NoCache::CreateNode(IXMLNodeSource __RPC_FAR *i_pSource, PVOID i_pNodeParent, USHORT i_cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR i_apNodeInfo)
{
    HRESULT hr;
    try
    {
        unsigned long CurrentLevel  = m_CurrentLevelBelowRootElement;

        if (!i_apNodeInfo[0]->fTerminal )
            ++m_CurrentLevelBelowRootElement;

        if(0 == CurrentLevel)
            return S_OK;//We never care about the Root element

        switch(i_apNodeInfo[0]->dwType)
        {
        case XML_COMMENT:
            m_pElement->m_ElementType         = XML_COMMENT;
            m_pElement->m_LevelOfElement      = CurrentLevel;
            m_pElement->m_ElementNameLength   = i_apNodeInfo[0]->ulLen; 
            m_pElement->m_ElementName         = i_apNodeInfo[0]->pwcText + i_apNodeInfo[0]->ulNsPrefixLen;
            m_pElement->m_NumberOfAttributes  = 0;
            m_pElement->m_NodeFlags           = fNone;
            return m_pXmlParsedFileNodeFactory->CreateNode(*m_pElement);
        case XML_ELEMENT:
            if(0 == i_apNodeInfo[0]->pwcText)
                return S_OK;
            break;
        default://ignore all other node types
            return S_OK;
        }

        if(XML_ELEMENT != i_apNodeInfo[0]->dwType ||//if this node is not an element, then ignore it
            0 == i_apNodeInfo[0]->pwcText)
            return S_OK;

        m_pElement->m_ElementType         = XML_ELEMENT;
        m_pElement->m_LevelOfElement      = CurrentLevel;
        m_pElement->m_ElementNameLength   = i_apNodeInfo[0]->ulLen; 
        m_pElement->m_ElementName         = i_apNodeInfo[0]->pwcText + i_apNodeInfo[0]->ulNsPrefixLen;
        m_pElement->m_NumberOfAttributes  = 0;
        m_pElement->m_NodeFlags           = fBeginTag;

        TSmartPointerArray<TSmartPointerArray<WCHAR> > ppWcharForEscapedAttributeValues;

        for(unsigned long iNodeInfo=1; iNodeInfo<i_cNumRecs; ++iNodeInfo)
        {
            if(XML_ATTRIBUTE != i_apNodeInfo[iNodeInfo]->dwType)
                continue;

            m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_NameLength   = i_apNodeInfo[iNodeInfo]->ulLen;
            m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Name         = i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen;

            if((iNodeInfo+1) == i_cNumRecs || XML_PCDATA != i_apNodeInfo[iNodeInfo+1]->dwType)
            {   //We don't want to increment iNodeInfo if we're at the last one OR if the next NodeInfo isn't an XML_PCDATA type.
                m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  = 0;//Zero length string
                m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Value        = 0;
            }
            else
            {
                ++iNodeInfo;
                m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  = i_apNodeInfo[iNodeInfo]->ulLen;
                m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Value        = i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen;

                if((iNodeInfo+1)<i_cNumRecs && XML_PCDATA==i_apNodeInfo[iNodeInfo+1]->dwType)
                {
                    //When the attribute has an escape sequence in it, we get it as multiple PCDATAs
                    //we need to paste them into one string before passing to the XmlParsedFileNodeFactory.

                    for(unsigned long iNodeInfoTemp=iNodeInfo+1; iNodeInfoTemp<i_cNumRecs && XML_PCDATA==i_apNodeInfo[iNodeInfoTemp]->dwType;++iNodeInfoTemp)
                    {   //Here we determine the length of the resulting attr value (after cat'ing all of the escapes together).
                        m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength  += i_apNodeInfo[iNodeInfoTemp]->ulLen;
                    }
                    if(0 == ppWcharForEscapedAttributeValues.m_p)//if this is the first Escaped attribute value we've seen for this element, then allocate
                    {                                            //enoung smartpointersarrays for all attributes (which can be no more that i_cNumRecs).
                        ppWcharForEscapedAttributeValues = new TSmartPointerArray<WCHAR> [i_cNumRecs];
                        if(0 == ppWcharForEscapedAttributeValues.m_p)
                            return E_OUTOFMEMORY;
                    }
                    //No need to allocate enough space for the NULL since we don't guarentee that string are NULL terminated
                    ppWcharForEscapedAttributeValues[iNodeInfo] = new WCHAR [m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_ValueLength + 0x100];
                    if(0 == ppWcharForEscapedAttributeValues[iNodeInfo].m_p)
                        return E_OUTOFMEMORY;

                    m_pElement->m_aAttribute[m_pElement->m_NumberOfAttributes].m_Value = ppWcharForEscapedAttributeValues[iNodeInfo];

                    //memcpy the portion of the string that we already have.
                    WCHAR *pDestination = ppWcharForEscapedAttributeValues[iNodeInfo];
                    memcpy(pDestination, (i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen),
                                    sizeof(WCHAR)*(i_apNodeInfo[iNodeInfo]->ulLen));
                    pDestination += (i_apNodeInfo[iNodeInfo]->ulLen);

                    while((iNodeInfo+1)<i_cNumRecs && XML_PCDATA==i_apNodeInfo[iNodeInfo+1]->dwType)
                    {
                        ++iNodeInfo;
                        memcpy(pDestination, i_apNodeInfo[iNodeInfo]->pwcText + i_apNodeInfo[iNodeInfo]->ulNsPrefixLen, sizeof(WCHAR)*i_apNodeInfo[iNodeInfo]->ulLen);
                        pDestination += i_apNodeInfo[iNodeInfo]->ulLen;
                    }
                }
            }
            ++m_pElement->m_NumberOfAttributes;
        }
        hr = m_pXmlParsedFileNodeFactory->CreateNode(*m_pElement);
    }
    catch(HRESULT e)//m_pXmlParsedFileNodeFactory->CreateNode may throw an exception
    {
        hr = e;
    }
    return hr;
}

STDMETHODIMP TXmlParsedFile_NoCache::EndChildren(IXMLNodeSource __RPC_FAR *i_pSource, BOOL i_fEmptyNode,XML_NODE_INFO* __RPC_FAR i_pNodeInfo)
{
    --m_CurrentLevelBelowRootElement;
    if(XML_PI == i_pNodeInfo->dwType || XML_XMLDECL == i_pNodeInfo->dwType)
        return S_OK;//This is needed to handle the <?xml version="1.0" encoding="UTF-8" ?>

    if(0 == i_fEmptyNode)
    {   //We need to create a new node for the EndTag
        m_pElement->m_ElementType         = static_cast<XML_NODE_TYPE>(i_pNodeInfo->dwType);
        m_pElement->m_LevelOfElement      = m_CurrentLevelBelowRootElement;
        m_pElement->m_cchComment          = i_pNodeInfo->ulLen; 
        m_pElement->m_Comment             = i_pNodeInfo->pwcText + i_pNodeInfo->ulNsPrefixLen;
        m_pElement->m_NumberOfAttributes  = 0;
        m_pElement->m_NodeFlags           = fEndTag;
        return m_pXmlParsedFileNodeFactory->CreateNode(*m_pElement);
    }
    return S_OK;
}

STDMETHODIMP TXmlParsedFile_NoCache::Error(IXMLNodeSource __RPC_FAR *i_pSource, HRESULT i_hrErrorCode, USHORT i_cNumRecs, XML_NODE_INFO* __RPC_FAR * __RPC_FAR i_apNodeInfo)
{
    return i_hrErrorCode;
}

STDMETHODIMP TXmlParsedFile_NoCache::NotifyEvent(IXMLNodeSource __RPC_FAR *i_pSource, XML_NODEFACTORY_EVENT i_iEvt)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\utsem.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       UTSem.cpp
//
//  Contents:   Implementation of methods declared but not defined inline
//				in UTSem.h, which are all tools to support inter-thread and
//				inter-process coordination.
//
//  Classes:    
//
//  Functions:  
//
//  History:    19-Nov-97   stevesw:	Stolen from MTS
//				20-Nov-97	stevesw:	Cleaned up
//				13-Jan-98   stevesw:    Added to ComSvcs
//				23-Sep-98   dickd:		Don't call GetLastError when no error
//
//---------------------------------------------------------------------------

#include <wtypes.h>
#include "VipInterlockedCompareExchange.h"
#include "svcerr.h"
#include "UTSem.h"

VOID UtsemWin32Error(LPWSTR pwszMessage, LPWSTR pwszFile, DWORD dwLine) {
	LogWinError(pwszMessage, GetLastError(), pwszFile, dwLine);
	FailFastStr(pwszMessage, pwszFile, dwLine);
}

VOID UtsemCheckBool(LPWSTR pwszMessage, BOOL bCondition, LPWSTR pwszFile, DWORD dwLine) {
	if(bCondition == FALSE) {
		LogString(pwszMessage, pwszFile, dwLine);
		FailFastStr(pwszMessage, pwszFile, dwLine);
	}
}

//+--------------------------------------------------------------------------
//
//  Function:   InitializeCriticalSectionIgnoreSpinCount
//
//  Synopsis:   The function lives in the same footprint as the NT4SP3
//				routine InitializeCriticalSectionAndSpinCount, but drops its
//				arguments on the floor and just does an
//				InitializeCriticalSection. The point is to make all this work
//				on both OS's. 
//
//  Arguments:  cs			- the CRITICAL_SECTION being initialized
//				lcCount		- the spin count
//
//  Returns:    TRUE/FALSE	- did it work? Yep, it always works....
//
//  Algorithm:  This is just a pass-through function. Look at the
//				implementation to the CSemExclusive Constructor, for
//				instance, to see what's really going on....
//
//---------------------------------------------------------------------------

static BOOL InitializeCriticalSectionIgnoreSpinCount (CRITICAL_SECTION* cs,
													  unsigned long lcCount) {
	__try
	{
		InitializeCriticalSection (cs);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return FALSE;
	}
	return TRUE;
}


//+==========================================================================
//
//					 -- CSemExclusive implementation --
//
//-==========================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CSemExclusive::CSemExclusive
//
//  Synopsis:   constructs an exclusive lock object
//
//  Arguments:  ulcSpinCount	- spin count, for machines on which it's
//								  relevant
//
//  Returns:    none
//
//  Algorithm:  What's going on here is, we cache a function pointer that
//				has the signiture of the Win32 system call that initializes
//				critical sections with spin locks turned on. The default is
//				a pointer to our local function that ignores spin locks
//				(which you need to do pre-NT4SP3, or on Win95). If we find
//				we're on a system that has the appropriate API, we use it
//				(and it handles spin locks). The tricky stuff is here for
//				two reasons: to avoid having to do the test every time we
//				create an object, and to avoid a static reference from this
//				routine to an entry point that might not exist on the target
//				system.
//
//				Spin locks are only really relevant on multi-processor
//				machines. What happens is, before calling the operating
//				system to sleep when a critical section is busy, you will
//				try to acquire it "spincount" times. Only if all of these
//				fail will you call the operating system. The goal here
//				is to avoid trapping out to the OS if the other user of
//				the critical section is about to surrender it. You want to
//				use spin locks if you imagine that your critical section is
//				going to be used frequently for very short periods of time.
//				Your spin count needs to be set to a value such that you'll
//				give the requesting thread enough time to outwait the thread
//				that currently holds the lock. You want to set spin count to
//				some percentage of the # of cycles your average lock-holder
//				will hold the lock. Too high a percentage, and you'll be
//				spinning needlessly. Too low a percentage, and you might as
//				well not spin. Maybe half the # of cycles? People seem to use
//				values ranging from 500 (for very short-duration locks) to
//				several thousands (in the "average" case).
//
// Notes: (1)	If the system is a uniprocessor, it will summarily ignore the
//				spin count. There is never any advantage to spinning on a
//				uniprocessor.
//
//		  (2)	Win98, in its infintesimal wisdom, implements
//				InitializeCriticalSectionAndSpinCount, but returns an error
//				when you call it.
//
//		  (3)	Win95 and Win98 are always uniprocessor.
//
//		  (4)	Therefore, we only attempt to locate
//				InitializeCriticalSectionAndSpinCount when running on NT.
//
//		  (5)	We explicitly use the ASCII versions of GetVersionEx and
//				GetModuleHandle because the Unicode versions don't work
//				on Win95 / Win98, and that's 2 fewer routines to thunk.
//
//---------------------------------------------------------------------------

CSemExclusive::CSemExclusive (unsigned long ulcSpinCount)
{

	typedef BOOL (*TpInitCSSpin) (CRITICAL_SECTION* cs, unsigned long lcCount);

	static TpInitCSSpin pInitCSSpin = InitializeCriticalSectionIgnoreSpinCount;
	static BOOL fInitialized = FALSE;

	if (!fInitialized) {
		HMODULE hModule;
		FARPROC pProc;

		OSVERSIONINFOA	osVer ;
		osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA) ;
		GetVersionExA(&osVer) ;

		// TODO - enable this for Memphis once 
		// InitializeCriticalSectionAndSpinCount works properly
		if (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT) {
			hModule = GetModuleHandleA ("KERNEL32.DLL");
			if (hModule != NULL) {
				pProc = GetProcAddress (hModule, "InitializeCriticalSectionAndSpinCount");
				if (pProc != NULL)
					pInitCSSpin = (TpInitCSSpin) pProc;
			}
		}

		fInitialized = TRUE;
	}

	if (!(*pInitCSSpin) (&m_csx, ulcSpinCount))
		FAILLASTWINERR ("InitializeCriticalSectionAndSpinCount");

}


//+==========================================================================
//
//					 -- CSemReadWrite implementation --
//
//-==========================================================================


//+--------------------------------------------------------------------------
//
//		  Definitions of the bit fields in UTSemReadWrite::m_dwFlag
//		 The goal here is to avoid the shifts that bitfields involve
//
//								-- WARNING --
//				
//				 The code assumes that READER_MASK is in the
//						low-order bits of the DWORD.
//
//			 Also, the WRITERS_MASK has two bits so you can see
//						 an overflow when it happens
//
//			 Finally, the use of the SafeCompareExchange routine
//		insures that every attempt to change the state of the object
//				either does what was intended, or is a no-op
//
//---------------------------------------------------------------------------

const ULONG READERS_MASK      = 0x000003FF;	// # of reader threads
const ULONG READERS_INCR      = 0x00000001;	// increment for # of readers

const ULONG WRITERS_MASK      = 0x00000C00;	// # of writer threads
const ULONG WRITERS_INCR      = 0x00000400;	// increment for # of writers

const ULONG READWAITERS_MASK  = 0x003FF000;	// # of threads waiting to read
const ULONG READWAITERS_INCR  = 0x00001000;	// increment for # of read waiters

const ULONG WRITEWAITERS_MASK = 0xFFC00000;	// # of threads waiting to write
const ULONG WRITEWAITERS_INCR = 0x00400000;	// increment for # of write waiters


//+--------------------------------------------------------------------------
//
//  Member:     UTSemReadWrite::UTSemReadWrite
//
//  Synopsis:   constructs a exclusive/shared lock object
//
//  Arguments:  ulcSpinCount	- spin count, for machines on which it's
//								  relevant
//
//  Returns:    nothing
//
//  Algorithm:  The first trick here, with the static values, is to make sure
//				you only go out to figure out whether or not you're on a
//				multiprocessor machine once. You need to know because,
//				there's no reason to do spin counts on a single-processor
//				machine. Once you've checked, the answer you need is cached
//				in maskMultiProcessor (which is used to zero out the spin
//				count in a single-processor world, and pass it on in a
//				multiprocessor one).
//
//				Other than that, this just fills in the members with initial
//				values. We don't create the semaphore and event here; there
//				are helper routines which create/return them when they're
//				needed. 
//
//---------------------------------------------------------------------------

UTSemReadWrite::UTSemReadWrite (unsigned long ulcSpinCount) :
	 m_dwFlag(0),
	 m_hReadWaiterSemaphore(NULL),
	 m_hWriteWaiterEvent(NULL) {

	static BOOL fInitialized = FALSE;
	static unsigned long maskMultiProcessor;

	if (!fInitialized) {
		SYSTEM_INFO SysInfo;

		GetSystemInfo (&SysInfo);
		if (SysInfo.dwNumberOfProcessors > 1) {
			maskMultiProcessor = 0xFFFFFFFF;
		}
		else {
			maskMultiProcessor = 0;
		}

		fInitialized = TRUE;
	}

	m_ulcSpinCount = ulcSpinCount & maskMultiProcessor;
}


//+--------------------------------------------------------------------------
//
//  Member:     UTSemReadWrite::~UTSemReadWrite
//
//  Synopsis:   destructs a exclusive/shared lock object
//
//  Arguments:  none
//
//  Returns:    none
//
//  Algorithm:  What's done here is to check to make sure nobody's using
//				the object (no readers, writers, or waiters). Once that's
//				checked, we just close the handles of the synchronization
//				objects we use here....
//
//---------------------------------------------------------------------------

UTSemReadWrite::~UTSemReadWrite () {

	CHECKBOOL ("Destroying UTSemReadWrite object on which folks are still waiting",
			   m_dwFlag == 0);

	if (m_hReadWaiterSemaphore != NULL) {
		CloseHandle (m_hReadWaiterSemaphore);
	}

	if (m_hWriteWaiterEvent != NULL) {
		CloseHandle (m_hWriteWaiterEvent);
	}
}


/******************************************************************************
Function : UTSemReadWrite::LockRead

Abstract: Obtain a shared lock
//  reader count is zero after acquiring read lock
//  writer count is nonzero after acquiring write lock
******************************************************************************/


//+--------------------------------------------------------------------------
//
//  Member:     UTSemReadWrite::LockRead 
//
//  Synopsis:   grabs a read (shared) lock on an object
//
//  Arguments:  none
//
//  Returns:    none
//
//  Algorithm:  This loops, checking on a series of conditions at each
//				iteration:
//
//				- If there's only readers, and room for more, become one by 
//				  incrementing the reader count
//				- It may be that we've hit the max # of readers. If so,
//				  sleep a bit.
//				- Otherwise, there's writers or threads waiting for write
//				  access. If we can't add any more read waiters, sleep a bit.
//				- If we've some spin looping to do, now is the time to do it.
//				- We've finished spin looping, and there's room, so we can
//				  add ourselves as a read waiter. Do it, and then hang
//				  until the WriteUnlock() releases us all....
//
//				On the way out, make sure there's no writers and at least one
//				reader (us!) 
//
//				The effect of this is, if there's only readers using the
//				object, we go ahead and grab read access. If anyone is doing
//				a write-wait, though, then we go into read-wait, making sure
//				one writer will get it before us.
//
//---------------------------------------------------------------------------

void UTSemReadWrite::LockRead (void) {

	unsigned long dwFlag;
	unsigned long ulcLoopCount = 0;

	for (;;) {
		dwFlag = m_dwFlag;

		if (dwFlag < READERS_MASK) {
			if (dwFlag == (ULONG) InterlockedCompareExchange ( (LONG*) &m_dwFlag,
											   (dwFlag + READERS_INCR),
											   dwFlag)) {
				break;
			}
		}
		else if ((dwFlag & READERS_MASK) == READERS_MASK) {
			Sleep(1000);
		}
		else if ((dwFlag & READWAITERS_MASK) == READWAITERS_MASK) {
			Sleep(1000);
		}
		else if (ulcLoopCount++ < m_ulcSpinCount) {
			;
		}
		else {
			if (dwFlag == (ULONG) InterlockedCompareExchange ( (LONG*) &m_dwFlag,
											   (dwFlag + READWAITERS_INCR),
											   dwFlag)) {
				if (WAIT_FAILED == WaitForSingleObject (GetReadWaiterSemaphore(), INFINITE))
					FAILLASTWINERR("WaitForSingleObject failed in UTSemReadWrite:LockRead");
				break;
			}
		}
	}

	CHECKBOOL ("Problem with Reader info in UTSemReadWrite::LockRead",
			   (m_dwFlag & READERS_MASK) != 0); 
	CHECKBOOL ("Problem with Writer info in UTSemReadWrite::LockRead",
			   (m_dwFlag & WRITERS_MASK) == 0);
}


//+--------------------------------------------------------------------------
//
//  Member:     UTSemReadWrite::LockWrite
//
//  Synopsis:   grab a write (exclusive) lock on this object
//
//  Arguments:  none
//
//  Returns:    none
//
//  Algorithm:  What we do is loop, each time checking a series of conditions
//				until one matches:
//
//				- if nobody's using the object, grab the exclusive lock
//				- if the maximum # of threads are already waiting for
//				  exclusive access, sleep a bit
//				- if we've spin counting to do, count spins
//				- otherwise, add ourselves as a write waiter, and hang on the
//				  write wait event (which will let one write waiter pass
//				  through each time an UnlockRead() lets readers pass)
//
//				Once we've finished, we check to make sure that there are no
//				reader and one writer using the object.
//
//				The effect of this is, we grab write access if there's nobody
//				using the object. If anyone is using it, we wait for it.
//
//---------------------------------------------------------------------------

void UTSemReadWrite::LockWrite (void) {

	unsigned long dwFlag;
	unsigned long ulcLoopCount = 0;

	for (;;) {
		dwFlag = m_dwFlag;

		if (dwFlag == 0) {
			if (dwFlag == (ULONG) InterlockedCompareExchange ( (LONG*) &m_dwFlag,
											   WRITERS_INCR,
											   dwFlag)) {
				break;
			}
		}

		else if ((dwFlag & WRITEWAITERS_MASK) == WRITEWAITERS_MASK) {
			Sleep(1000);
		}

		else if (ulcLoopCount++ < m_ulcSpinCount) {
			;
		}
		else {
			if (dwFlag == (ULONG) InterlockedCompareExchange ( (LONG*) &m_dwFlag,
											   (dwFlag + WRITEWAITERS_INCR),
											   dwFlag)) {
				if (WAIT_FAILED == WaitForSingleObject (GetWriteWaiterEvent(), INFINITE))  {
					FAILLASTWINERR("WaitForSingleObject failed in UTSemReadWrite:LockWrite");
				}
				break;
			}
		}
	}

	CHECKBOOL ("Problem with Reader info in UTSemReadWrite::LockWrite",
			   (m_dwFlag & READERS_MASK) == 0);
	CHECKBOOL ("Problem with Writer info in UTSemReadWrite::LockWrite",
			   (m_dwFlag & WRITERS_MASK) == WRITERS_INCR);
}


//+--------------------------------------------------------------------------
//
//  Member:     UTSemReadWrite::UnlockRead
//
//  Synopsis:   Releases a read (shared) lock on the object
//
//  Arguments:  none
//
//  Returns:    none
//
//  Algorithm:  Again, there's a loop checking a variety of conditions....
//
//				- If it's just us reading, with no write-waiters, set the
//				  flags to 0
//				- If there are other readers, just decrement the flag
//				- If it's just me reading, but there are write-waiters,
//				  then remove me and the write-waiter, add them as a writer,
//				  and release (one of) them using the event.
//
//				We check to make sure we're in the right state before doing
//				this last, relatively complex operation (one reader; at least
//				one write waiter). We let the hanging writer check to make
//				sure, on the way out, that there's just one writer and no
//				readers....
//
//				The effect of all this is, if there's at least one thread
//				waiting for a write, all the current readers will drain, and
//				then the one writer will get access to the object. Otherwise
//				we just let go....
//
//---------------------------------------------------------------------------

void UTSemReadWrite::UnlockRead (void) {
	unsigned long dwFlag;

	CHECKBOOL ("Problem with Reader info in UTSemReadWrite::UnlockRead",
			   (m_dwFlag & READERS_MASK) != 0); 
	CHECKBOOL ("Problem with Writer info in UTSemReadWrite::UnlockRead",
			   (m_dwFlag & WRITERS_MASK) == 0);

	for (;;) {
		dwFlag = m_dwFlag;

		if (dwFlag == READERS_INCR) {
			if (dwFlag == (ULONG) InterlockedCompareExchange ( (LONG*) &m_dwFlag, 0, dwFlag)) {
				break;
			}
		}

		else if ((dwFlag & READERS_MASK) > READERS_INCR) {
			if (dwFlag == (ULONG) InterlockedCompareExchange ( (LONG*) &m_dwFlag,
											   (dwFlag - READERS_INCR),
											   dwFlag)) {
				break;
			}
		}

		else {
			CHECKBOOL ("Problem with Reader info in UTSemReadWrite::UnlockRead",
					   (dwFlag & READERS_MASK) == READERS_INCR);
			CHECKBOOL ("Problem with WriteWatier info in UTSemReadWrite::UnlockRead",
					   (dwFlag & WRITEWAITERS_MASK) != 0);

			if (dwFlag == (ULONG) InterlockedCompareExchange ( (LONG*) &m_dwFlag,
											   (dwFlag - 
											   READERS_INCR - 
											   WRITEWAITERS_INCR + 
											   WRITERS_INCR), 
											   dwFlag)) {
				if (!SetEvent (GetWriteWaiterEvent())) {
					FAILLASTWINERR("SetEvent failed in UTSemReadWrite:UnlockRead");
				}
				break;
			}
		}
	}
}


//+--------------------------------------------------------------------------
//
//  Member:     UTSemReadWrite::UnlockWrite
//
//  Synopsis:   lets go of exclusive (write) access
//
//  Arguments:  none
//
//  Returns:    none
//
//  Algorithm:  We're in a loop, waiting for one or another thing to happen
//				
//				- If it's just us writing, and nothing else is going on, we
//				  let go and scram.
//				- If threads are waiting for read access, we fiddle with the
//				  dwFlag to release them all (by decrementing the writer
//				  count and read-waiter count, and incrementing the reader
//				  count, and then incrementing the semaphore enough so that
//				  all those read-waiters will be released). 
//				- If there are only threads waiting for write access, let one
//				  of them through.... Don't have to fiddle with the write
//				  count, 'cause there will still be one.
//
//				The upshot of all this is, we make sure that the next threads
//				to get access after we let go will be readers, if there are
//				any. The whole scene makes it go from one writer to many
//				readers, back to one writer and then to many readers again.
//				Sharing. Isn't that nice.
//
//---------------------------------------------------------------------------

void UTSemReadWrite::UnlockWrite (void) {

	unsigned long dwFlag;
	unsigned long count;

	CHECKBOOL ("Problem with Reader info in UTSemReadWrite::LockWrite",
			   (m_dwFlag & READERS_MASK) == 0);
	CHECKBOOL ("Problem with Writer info in UTSemReadWrite::LockWrite",
			   (m_dwFlag & WRITERS_MASK) == WRITERS_INCR);

	for (;;) {
		dwFlag = m_dwFlag;

		if (dwFlag == WRITERS_INCR) {
			if (dwFlag == (ULONG) InterlockedCompareExchange ( (LONG*) &m_dwFlag, 0, dwFlag)) {
				break;
			}
		}

		else if ((dwFlag & READWAITERS_MASK) != 0) {
			count = (dwFlag & READWAITERS_MASK) / READWAITERS_INCR;
			if (dwFlag == (ULONG) InterlockedCompareExchange ( (LONG*) &m_dwFlag,
											   (dwFlag - 
											   WRITERS_INCR - 
											   count * READWAITERS_INCR + 
											   count * READERS_INCR), 
											   dwFlag)) {
				if (!ReleaseSemaphore (GetReadWaiterSemaphore(), count, NULL)) {
					FAILLASTWINERR("ReleaseSemaphore failed in UTSemReadWrite:UnlockWrite");
				}
				break;
			}
		}

		else {
			CHECKBOOL ("Problem with WriteWatier info in UTSemReadWrite::UnlockWrite",
					   (dwFlag & WRITEWAITERS_MASK) != 0);
			if (dwFlag == (ULONG) InterlockedCompareExchange ( (LONG*) &m_dwFlag,
											   (dwFlag - WRITEWAITERS_INCR),
											   dwFlag)) {
				if (!SetEvent (GetWriteWaiterEvent())) {
					FAILLASTWINERR("SetEvent failed in UTSemReadWrite:UnlockWrite");
				}
				break;
			}
		}
	}
}


//+--------------------------------------------------------------------------
//
//  Member:     UTSemReadWrite::GetReadWaiterSemaphore
//
//  Synopsis:   private member function to get the read-waiting semaphore,
//				creating it if necessary
//
//  Arguments:  none
//
//  Returns:    semaphore handle (never NULL)
//
//  Algorithm:  This is a thread-safe, virtually lockless routine that
//				creates a semaphore if there's not one there, safely tries to
//				shove it into the shared member variable, and cleans up if
//				someone snuck in there with a second semaphore from another
//				thread. 
//
//---------------------------------------------------------------------------

HANDLE UTSemReadWrite::GetReadWaiterSemaphore(void) {

	HANDLE h;

	if (m_hReadWaiterSemaphore == NULL) {
		h = CreateSemaphore (NULL, 0, MAXLONG, NULL);
		if (h == NULL) {
			FAILLASTWINERR("CreateSemaphore returned NULL in UTSemReadWrite::GetReadWaiterSemaphore");
		}
		if (NULL != InterlockedCompareExchangePointer ( (PVOID*) &m_hReadWaiterSemaphore, h, NULL)) {
			CloseHandle (h);
		}
	}

	return m_hReadWaiterSemaphore;
}


//+--------------------------------------------------------------------------
//
//  Member:     UTSemReadWrite::GetWriteWaiterEvent
//
//  Synopsis:   private member function to get the write-waiting barrier, 
//				creating it if necessary
//
//  Arguments:  none
//
//  Returns:    event handle (never NULL)
//
//  Algorithm:  This is a thread-safe, virtually lockless routine that
//				creates an event if there's not one there, safely tries to
//				shove it into the shared member variable, and cleans up if
//				someone snuck in there with a second event from another
//				thread. 
//
//---------------------------------------------------------------------------

HANDLE UTSemReadWrite::GetWriteWaiterEvent(void) {

	HANDLE h;

	if (m_hWriteWaiterEvent == NULL) {
		h = CreateEvent (NULL, FALSE, FALSE, NULL);
		if (h == NULL) {
			FAILLASTWINERR("CreateSemaphore returned NULL in UTSemReadWrite::GetReadWaiterSemaphore");
		}
		if (NULL != InterlockedCompareExchangePointer ( (PVOID*) &m_hWriteWaiterEvent, h, NULL)) {
			CloseHandle (h);
		}
	}

	return m_hWriteWaiterEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\utassert.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
/* ----------------------------------------------------------------------------	
Microsoft	D.T.C (Distributed Transaction Coordinator)

(c)	1995	Microsoft Corporation.	All Rights Reserved

@ doc

@module UTAssert.H.h  |

	This file contains some macros for asserts.

 This file contains some assert functions that are called by
				Assert macros
@devnote None

@rev 	0 	| 24th Jan,95 | GaganC 		| Created
*******************************************************************************/
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#include "VipInterlockedCompareExchange.h"
#include "utassert.h"

#ifdef _DEBUG

typedef struct _UTASSERT_INFO
{
	DWORD			dwAssertAction;
	DWORD			dwAssertTrigger;
	OSVERSIONINFO	versionInformation;
} UTASSERT_INFO;

static UTASSERT_INFO * g_pAssertInfo = NULL;
static UTASSERT_INFO   g_AssertInfoDefault = {DTCAssertMsgBox, UTASSERT_ALL};

void InterlockedSetAssertInfo(void) ;

/******************************************************************************
Function :	AssertSzFail

Abstract:	When called from inside Assert macros, it does the following:
			1. Opens up a file called Assert.txt, creates it if not found
			2. Writes the Assert header, the Assert message and line number
				in the assert file.
			3. Based on the Assert Level, it either quits, or quits with a 
				message box, showing where the Assert happened.
*******************************************************************************/
void AssertSzFail(DWORD bmaskAssert, const char *sz, const char *szFilename, unsigned Line)
{
   int	 hf;
   char  szLine[6];
   char  szMessage[1024];
   int	 id;
   char  szAssertCap [256];
   char  szModuleName[256] ;
   
   char szDateTime[64];
   SYSTEMTIME  SystemTime ;

   DWORD dwProcId = 0;

   DWORD dw = GetLastError();

   // Atomically set the structure to store the assert information
   InterlockedSetAssertInfo ();

   if (!(g_pAssertInfo->dwAssertTrigger & bmaskAssert))
   {
	   return;
   }
  
   GetModuleFileName(GetModuleHandle(NULL), szModuleName, sizeof(szModuleName)) ;
   GetLocalTime(&SystemTime) ;

   wsprintf(szDateTime, " %02ld-%02ld-%04ld %02ld:%02ld : ", 
   			(ULONG) SystemTime.wMonth,
		    (ULONG) SystemTime.wDay,
			(ULONG) SystemTime.wYear,
		    (ULONG) SystemTime.wHour,
		    (ULONG) SystemTime.wMinute
		    ) ;

#ifdef WIN32   
   dwProcId = GetCurrentProcessId();
   sprintf (szAssertCap, "%s   ProcId = 0x%x", 	szAssertCaption, dwProcId);
#endif

   hf = _lopen((LPSTR) szAssertFile, OF_READWRITE);

   if (hf == HFILE_ERROR)	       /* Open failed, assume no such file */
      hf = _lcreat((LPSTR) szAssertFile, 0);
   else
      _llseek(hf, 0, 2);	       /* Seek to end of file. */

   _lwrite(hf, (LPSTR) szAssertHdr, sizeof(szAssertHdr)-1);
   _lwrite(hf, (LPSTR) szDateTime, lstrlen((LPSTR) szDateTime));
   _lwrite(hf, (LPSTR) szFilename, lstrlen((LPSTR) szFilename));
   lstrcpy(szMessage, (LPSTR) szFilename);

   _ultoa(Line, szLine, 10);	    /* Convert line number to ASCII */
   _lwrite(hf, (LPSTR) szLineHdr, sizeof(szLineHdr)-1);
   lstrcat(szMessage, (LPSTR) szLineHdr);
   _lwrite(hf, szLine, lstrlen(szLine));
   lstrcat(szMessage, szLine);

   if (sz != NULL)
   {
      _lwrite(hf, (LPSTR) szMsgHdr, sizeof(szMsgHdr)-1);
      lstrcat(szMessage, (LPSTR) szMsgHdr);
      _lwrite(hf, (LPSTR) sz, lstrlen((LPSTR) sz));
      lstrcat(szMessage, (LPSTR) sz);
   }

   *szLine = '(';
   _ultoa(dw, szLine+1, 10);	    /* Convert last error number to ASCII */
   szLine[lstrlen(szLine) + 1] = '\0';
   szLine[lstrlen(szLine)] = ')';
   _lwrite(hf, szLine, lstrlen(szLine));
   lstrcat(szMessage, szLine);

   _lwrite(hf, (LPSTR) szAssertEnd, sizeof(szAssertEnd)-1);
   _lclose(hf);

   // do the required assert action

   if (g_pAssertInfo->dwAssertAction & DTCAssertExit)
   {
      FatalExit(0x68636952);
   }

   else if (g_pAssertInfo->dwAssertAction & DTCAssertBreak)
   {
      DebugBreak();
   }

   else if (g_pAssertInfo->dwAssertAction & DTCAssertMsgBox)
   {
   		char			szBuf[1024] ;

	   	wsprintf(szBuf, "\n"
						"Process Name\t = %s\n"
						"ProcessId\t = %d (0x%x)\n"
						"ThreadId\t = %d (0x%x)\n"
						"Time\t\t = %02ld-%02ld-%04ld %02ld:%02ld:%02ld.%03ld\n",
			szModuleName,
			GetCurrentProcessId(), GetCurrentProcessId(),
			GetCurrentThreadId(),  GetCurrentThreadId(),
		
		    (ULONG) SystemTime.wMonth,
		    (ULONG) SystemTime.wDay,
			(ULONG) SystemTime.wYear,
		    (ULONG) SystemTime.wHour,
		    (ULONG) SystemTime.wMinute,
		    (ULONG) SystemTime.wSecond,
			(ULONG) SystemTime.wMilliseconds
		    ) ;

			strcat(szMessage, szBuf) ;

		//  for NT 4 or higher
		if ( g_pAssertInfo->versionInformation.dwMajorVersion >= 0x4 )
		{
      		id = MessageBox(NULL, 
      						(LPTSTR) szMessage,
							szAssertCap,
      						MB_SYSTEMMODAL |
							MB_ICONSTOP |
							MB_OKCANCEL | 
							MB_SERVICE_NOTIFICATION
							);

		}

		//  for NT 3.x
		else if ( g_pAssertInfo->versionInformation.dwMajorVersion == 0x3 )
		{
      		id = MessageBox(NULL, 
      						(LPTSTR) szMessage,
							szAssertCap,
      						MB_SYSTEMMODAL |
							MB_ICONSTOP |
							MB_OKCANCEL |
							MB_SERVICE_NOTIFICATION_NT3X
							);
		}

		//  for anything else, including the default case of 0x0
		else
		{
      		id = MessageBox(NULL, 
      						(LPTSTR) szMessage,
							szAssertCap,
      						MB_SYSTEMMODAL |
							MB_ICONSTOP |
							MB_OKCANCEL 
							);
		}


		if (id == IDCANCEL)
		{
		  	DebugBreak();
		}
   }
}



/******************************************************************************
Function :	AssertFail

Abstract:	Called from inside the Assert macros when the assert fails.
*******************************************************************************/
void AssertFail(DWORD bmaskAssert, const char *szFilename, unsigned Line)
{
	AssertSzFail(bmaskAssert, NULL, szFilename, Line);
}


// ---------------------------------------------------------------------------
#define 	DTC_SERVICE_KEY					"SYSTEM\\CurrentControlSet\\Services\\MSDTC"
#define		DTC_ASSERT_FLAG_VALUE			"AssertFlag"
#define		DTC_ASSERT_TRIGGER_VALUE		"AssertTriggerBitmask"
   	

void InterlockedSetAssertInfo(void) 
{	
	DWORD	rc=0 ;	
	HKEY	hKey ;
	DWORD	dwType ;

	UTASSERT_INFO * pAssertInfoLocal;
	DWORD	dwcbBuf;

	if (g_pAssertInfo != NULL)
	{
		return;
	}

	pAssertInfoLocal = new UTASSERT_INFO;
	if (pAssertInfoLocal)
	{
		pAssertInfoLocal->dwAssertAction = DTCAssertMsgBox;
		pAssertInfoLocal->dwAssertTrigger = UTASSERT_ALL;

		rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, DTC_SERVICE_KEY, 0, KEY_READ, &hKey) ;
		if (rc == ERROR_SUCCESS) 
		{
			dwcbBuf = sizeof(pAssertInfoLocal->dwAssertAction);

			rc = RegQueryValueEx
							(
								hKey, DTC_ASSERT_FLAG_VALUE, 
								0, &dwType, 
								(UCHAR *)&(pAssertInfoLocal->dwAssertAction), 
								&dwcbBuf
							);
			if (rc == ERROR_SUCCESS) 
			{
				if (DTCAssertNone == pAssertInfoLocal->dwAssertAction)
				{
					pAssertInfoLocal->dwAssertAction = DTCAssertMsgBox;
				}
			}

			dwcbBuf = sizeof(pAssertInfoLocal->dwAssertTrigger);

			rc = RegQueryValueEx
							(
								hKey, DTC_ASSERT_TRIGGER_VALUE, 
								0, &dwType, 
								(UCHAR *)&(pAssertInfoLocal->dwAssertTrigger), 
								&dwcbBuf
							);
			RegCloseKey(hKey);
		}

		pAssertInfoLocal->versionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		if ( FALSE == GetVersionEx( & (pAssertInfoLocal->versionInformation) ) )
		{
			memset( &(pAssertInfoLocal->versionInformation), 0, sizeof(OSVERSIONINFO));
		}
	}
	else
	{
		pAssertInfoLocal = &g_AssertInfoDefault;
	}

	if (NULL != InterlockedCompareExchangePointer
					((PVOID *)&g_pAssertInfo, (PVOID)pAssertInfoLocal, NULL))
	{
		if (pAssertInfoLocal != &g_AssertInfoDefault)
		{
			delete pAssertInfoLocal;
		}
	}
}


// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\waitfncs.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include <windows.h>				// windows standard includes
#include "svcerr.h"
#include "waitfncs.h"

CWaitFunctions g_WaitFunctions;
		
PFN_RegisterWaitForSingleObjectEx    CWaitFunctions::sm_pfnRegWaitEx=NULL;    
PFN_UnregisterWait                   CWaitFunctions::sm_pfnUnRegWait=NULL;    
PFN_RegisterWaitForSingleObject      CWaitFunctions::sm_pfnRegWait=NULL;      
PFN_SetTimerQueueTimer               CWaitFunctions::sm_pfnSetTimerQueueTimer=NULL;
PFN_ChangeTimerQueueTimer            CWaitFunctions::sm_pfnChangeTimerQueueTimer=NULL;
PFN_CancelTimerQueueTimer            CWaitFunctions::sm_pfnCancelTimerQueueTimer=NULL;


			
CWaitFunctions::CWaitFunctions()
{
    
	HINSTANCE hInst = GetModuleHandleA("kernel32.dll");
	ASSERT(hInst);
     
	sm_pfnRegWaitEx = (PFN_RegisterWaitForSingleObjectEx) GetProcAddress(hInst, "RegisterWaitForSingleObjectEx");
	if (!sm_pfnRegWaitEx)
	{	
		sm_pfnRegWait = (PFN_RegisterWaitForSingleObject) GetProcAddress(hInst, "RegisterWaitForSingleObject");
		if (!sm_pfnRegWait)
			FAIL("CProcessWatch::CProcessWatch failed.  RegisterWaitForSingleObject not implemented");
	}
	

    sm_pfnUnRegWait = (PFN_UnregisterWait) GetProcAddress(hInst, "UnregisterWait");
	if (!sm_pfnUnRegWait)
		FAIL("CProcessWatch::CProcessWatch failed.  UnregisterWait probably not implemented");

	sm_pfnSetTimerQueueTimer = (PFN_SetTimerQueueTimer) GetProcAddress(hInst, "SetTimerQueueTimer");
	if (!sm_pfnSetTimerQueueTimer)
		FAIL("CProcessWatch::CProcessWatch failed.  SetTimerQueueTimer not implemented");

   sm_pfnChangeTimerQueueTimer = (PFN_ChangeTimerQueueTimer)GetProcAddress(hInst, "ChangeTimerQueueTimer");
   if (!sm_pfnChangeTimerQueueTimer)
       FAIL("CPoolMgr::FinalConstruct failed.  ChangeTimerQueueTimer not implemented on this version of the OS.");

   sm_pfnCancelTimerQueueTimer = (PFN_CancelTimerQueueTimer)GetProcAddress(hInst, "CancelTimerQueueTimer");
   if (!sm_pfnCancelTimerQueueTimer)
       FAIL("CPoolMgr::FinalConstruct failed.  CancelTimerQueueTimer not implemented on this version of the OS.");


}

BOOL CWaitFunctions::RegisterWaitForSingleObject(	HANDLE * phRet,
									HANDLE hObject, 
									WAITORTIMERCALLBACK pfnCb, 
									PVOID pv, 
									DWORD dwMS, 
									DWORD dwFlags)
{

	if (sm_pfnRegWait)
	{
		return sm_pfnRegWait(phRet, hObject, pfnCb, pv, dwMS, dwFlags);
	}

	*phRet = sm_pfnRegWaitEx(hObject, pfnCb, pv, dwMS, dwFlags);

	return (*phRet != NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\writerglobals.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WriterGlobals.cpp

$Header: $

Abstract:

--**************************************************************************/

LPCWSTR	g_wszBeginFile					= L"<?xml version =\"1.0\"?>\r\n<configuration xmlns=\"urn:microsoft-catalog:null-placeholder\">\r\n<MBProperty>\r\n";
SIZE_T	g_cchBeginFile					= wcslen(g_wszBeginFile);
LPCWSTR	g_wszEndFile					= L"</MBProperty>\r\n</configuration>\r\n";
SIZE_T	g_cchEndFile					= wcslen(g_wszEndFile);
LPCWSTR	g_BeginLocation					= L"<";
SIZE_T	g_cchBeginLocation				= wcslen(g_BeginLocation);
LPCWSTR	g_Location						= L"\tLocation =\"";
SIZE_T	g_cchLocation					= wcslen(g_Location);
LPCWSTR	g_EndLocationBegin				= L"</";
SIZE_T	g_cchEndLocationBegin			= wcslen(g_EndLocationBegin);
LPCWSTR	g_EndLocationEnd				= L">\r\n";
SIZE_T	g_cchEndLocationEnd				= wcslen(g_EndLocationEnd);
LPCWSTR g_CloseQuoteBraceRtn			= L"\">\r\n";
SIZE_T	g_cchCloseQuoteBraceRtn			= wcslen(g_CloseQuoteBraceRtn);
LPCWSTR g_Rtn							= L"\r\n";
SIZE_T	g_cchRtn						= wcslen(g_Rtn);
LPCWSTR g_EqQuote						= L"=\"";
SIZE_T	g_cchEqQuote					= wcslen(g_EqQuote);
LPCWSTR g_QuoteRtn						= L"\"\r\n";
SIZE_T	g_cchQuoteRtn					= wcslen(g_QuoteRtn);
LPCWSTR g_TwoTabs						= L"\t\t";
SIZE_T	g_cchTwoTabs					= wcslen(g_TwoTabs);
LPCWSTR	g_NameEq						= L"\t\tName=\"";
SIZE_T	g_cchNameEq						= wcslen(g_NameEq);
LPCWSTR	g_IDEq							= L"\t\tID=\"";
SIZE_T	g_cchIDEq						= wcslen(g_IDEq);
LPCWSTR	g_ValueEq						= L"\t\tValue=\"";
SIZE_T	g_cchValueEq					= wcslen(g_ValueEq);
LPCWSTR	g_TypeEq						= L"\t\tType=\"";
SIZE_T	g_cchTypeEq						= wcslen(g_TypeEq);
LPCWSTR	g_UserTypeEq					= L"\t\tUserType=\"";
SIZE_T	g_cchUserTypeEq					= wcslen(g_UserTypeEq);
LPCWSTR	g_AttributesEq					= L"\t\tAttributes=\"";
SIZE_T	g_cchAttributesEq				= wcslen(g_AttributesEq);
LPCWSTR	g_BeginGroup					= L"\t<";
SIZE_T	g_cchBeginGroup					= wcslen(g_BeginGroup);
LPCWSTR	g_EndGroup						= L"\t>\r\n";
SIZE_T	g_cchEndGroup					= wcslen(g_EndGroup);
LPCWSTR	g_BeginCustomProperty			= L"\t<Custom\r\n";
SIZE_T	g_cchBeginCustomProperty		= wcslen(g_BeginCustomProperty);
LPCWSTR	g_EndCustomProperty				= L"\t/>\r\n";
SIZE_T	g_cchEndCustomProperty			= wcslen(g_EndCustomProperty);
LPCWSTR	g_ZeroHex						= L"0x00000000";
SIZE_T	g_cchZeroHex					= wcslen(g_ZeroHex);
LPCWSTR	g_wszIIsConfigObject			= L"IIsConfigObject";

WORD    BYTE_ORDER_MASK                 = 0xFEFF;
DWORD	UTF8_SIGNATURE                  = 0x00BFBBEF;

LPWSTR  g_wszByID	                    = L"ByID";
LPWSTR  g_wszByTableAndColumnIndexOnly        = L"ByTableAndColumnIndexOnly";
LPWSTR  g_wszByTableAndColumnIndexAndNameOnly = L"ByTableAndColumnIndexAndNameOnly";
LPWSTR  g_wszByTableAndColumnIndexAndValueOnly = L"ByTableAndColumnIndexAndValueOnly";
LPWSTR  g_wszUnknownName                = L"UnknownName_";
SIZE_T  g_cchUnknownName                = wcslen(g_wszUnknownName);
LPWSTR  g_UT_Unknown                    = L"Unknown_User_Type";
SIZE_T  g_cchUT_Unknown                 = wcslen(g_UT_Unknown);
LPWSTR  g_T_Unknown                     = L"Unknown_Type";
LPWSTR  g_wszTrue						= L"TRUE";
LPWSTR  g_wszFalse						= L"FALSE";
SIZE_T  g_cchMaxBoolStr					= wcslen(g_wszFalse);

SIZE_T  g_cchTemp						= 1024;
WCHAR   g_wszTemp[1024];
LPCWSTR g_wszBeginSchema				= L"<?xml version =\"1.0\"?>\r\n<!-- WARNING, DO NOT EDIT THIS FILE. -->\r\n<MetaData xmlns=\"x-schema:CatMeta.xms\">\r\n\r\n\t<DatabaseMeta               InternalName =\"METABASE\">\r\n\t\t<ServerWiring           Interceptor  =\"Core_XMLInterceptor\"/>\r\n\t\t<Collection         InternalName =\"MetabaseBaseClass\"    MetaFlagsEx=\"NOTABLESCHEMAHEAPENTRY\"  MetaFlags=\"HIDDEN\">\r\n\t\t\t<Property       InternalName =\"Location\"                                    Type=\"WSTR\"   MetaFlags=\"PRIMARYKEY\"/>\r\n\t\t</Collection>\r\n";
SIZE_T  g_cchBeginSchema                = wcslen(g_wszBeginSchema);
LPCWSTR g_wszEndSchema				    = L"\t</DatabaseMeta>\r\n</MetaData>\r\n";
SIZE_T  g_cchEndSchema                  = wcslen(g_wszEndSchema);
LPCWSTR g_wszBeginCollection            = L"\t\t<Collection         InternalName =\"";
SIZE_T  g_cchBeginCollection            = wcslen(g_wszBeginCollection);
LPCWSTR g_wszSchemaGen                  = L"\">\r\n";
SIZE_T  g_cchSchemaGen                  = wcslen(g_wszSchemaGen);
LPCWSTR g_wszInheritsFrom               = L"\"    InheritsPropertiesFrom=\"MetabaseBaseClass\" >\r\n";
SIZE_T  g_cchInheritsFrom               = wcslen(g_wszInheritsFrom);
LPCWSTR g_wszEndCollection              = L"\t\t</Collection>\r\n";
SIZE_T  g_cchEndCollection              = wcslen(g_wszEndCollection);
LPCWSTR g_wszBeginPropertyShort         = L"\t\t\t<Property       InheritsPropertiesFrom =\"IIsConfigObject:";
SIZE_T  g_cchBeginPropertyShort         = wcslen(g_wszBeginPropertyShort);
LPCWSTR g_wszMetaFlagsExEq              = L"\"  MetaFlagsEx=\"";
SIZE_T  g_cchMetaFlagsExEq              = wcslen(g_wszMetaFlagsExEq);
LPCWSTR g_wszMetaFlagsEq                = L"\"  MetaFlags=\"";
SIZE_T  g_cchMetaFlagsEq                = wcslen(g_wszMetaFlagsEq);
LPCWSTR g_wszEndPropertyShort           = L"\"/>\r\n";
SIZE_T  g_cchEndPropertyShort           = wcslen(g_wszEndPropertyShort);
LPCWSTR g_wszBeginPropertyLong          = L"\t\t\t<Property       InternalName =\"";
SIZE_T  g_cchBeginPropertyLong          = wcslen(g_wszBeginPropertyLong);
LPCWSTR g_wszPropIDEq                   = L"\"\t\t\tID=\"";
SIZE_T  g_cchPropIDEq                   = wcslen(g_wszPropIDEq);
LPCWSTR g_wszPropTypeEq                 = L"\"\t\t\tType=\"";
SIZE_T  g_cchPropTypeEq                 = wcslen(g_wszPropTypeEq);
LPCWSTR g_wszPropUserTypeEq             = L"\"\t\t\tUserType=\"";
SIZE_T  g_cchPropUserTypeEq             = wcslen(g_wszPropUserTypeEq);
LPCWSTR g_wszPropAttributeEq            = L"\"\t\t\tAttributes=\"";
SIZE_T  g_cchPropAttributeEq            = wcslen(g_wszPropAttributeEq);

LPWSTR  g_wszPropMetaFlagsEq            = L"\"\t\t\tMetaFlags=\"";
SIZE_T  g_cchPropMetaFlagsEq            = wcslen(g_wszPropMetaFlagsEq);
LPWSTR  g_wszPropMetaFlagsExEq          = L"\"\t\t\tMetaFlagsEx=\"";
SIZE_T  g_cchPropMetaFlagsExEq          = wcslen(g_wszPropMetaFlagsExEq);
LPWSTR  g_wszPropDefaultEq              = L"\"\t\t\tDefaultValue=\"";
SIZE_T  g_cchPropDefaultEq              = wcslen(g_wszPropDefaultEq);
LPWSTR  g_wszPropMinValueEq             = L"\"\t\t\tStartingNumber=\"";
SIZE_T  g_cchPropMinValueEq             = wcslen(g_wszPropMinValueEq);
LPWSTR  g_wszPropMaxValueEq             = L"\"\t\t\tEndingNumber=\"";
SIZE_T  g_cchPropMaxValueEq             = wcslen(g_wszPropMaxValueEq);
LPWSTR  g_wszEndPropertyLongNoFlag      = L"\"/>\r\n";
SIZE_T  g_cchEndPropertyLongNoFlag      = wcslen(g_wszEndPropertyLongNoFlag);
LPWSTR  g_wszEndPropertyLongBeforeFlag  = L"\">\r\n";
SIZE_T  g_cchEndPropertyLongBeforeFlag  = wcslen(g_wszEndPropertyLongBeforeFlag);
LPWSTR  g_wszEndPropertyLongAfterFlag   = L"\t\t\t</Property>\r\n";
SIZE_T  g_cchEndPropertyLongAfterFlag   = wcslen(g_wszEndPropertyLongAfterFlag);
LPCWSTR g_wszBeginFlag                  = L"\t\t\t\t<Flag       InternalName =\"";
SIZE_T  g_cchBeginFlag                  = wcslen(g_wszBeginFlag);
LPCWSTR g_wszFlagValueEq                = L"\"\t\tValue=\"";
SIZE_T  g_cchFlagValueEq                = wcslen(g_wszFlagValueEq);
LPCWSTR g_wszEndFlag                    = L"\"\t/>\r\n";
SIZE_T  g_cchEndFlag                    = wcslen(g_wszEndFlag);
LPCWSTR g_wszContainerClassListEq       = L"\"    ContainerClassList=\"";
SIZE_T  g_cchContainerClassListEq       = wcslen(g_wszContainerClassListEq);
LPCWSTR g_wszFlagIDEq					= L"\"\t\tID=\"";
SIZE_T  g_cchFlagIDEq			        = wcslen(g_wszFlagIDEq);
LPCWSTR g_aSynIDToWszType []            ={NULL,
										  L"DWORD",
										  L"STRING",
										  L"EXPANDSZ",
										  L"MULTISZ",
										  L"BINARY",
										  L"BOOL",
										  L"BOOL_BITMASK",
										  L"MIMEMAP",
										  L"IPSECLIST",
										  L"NTACL",
										  L"HTTPERRORS",
										  L"HTTPHEADERS"
};

LPCWSTR g_wszOr                         = L"| ";
SIZE_T  g_cchOr              			= wcslen(g_wszOr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\wassec.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WasSec.cpp

$Header: $

Abstract:

--**************************************************************************/

#include <windows.h>
#include "WasSec.h"

CWASSecurity::~CWASSecurity()
{
	if (m_paclDiscretionary != NULL)
	{
		LocalFree(m_paclDiscretionary);
		m_paclDiscretionary = NULL;
	}

	if (m_psidAdmin != NULL)
	{
		FreeSid(m_psidAdmin);
		m_psidAdmin = NULL;
	}

	if (m_psidSystem != NULL)
	{
		FreeSid(m_psidSystem);
		m_psidSystem = NULL;
	}

	if (m_psdStorage != NULL)
	{
		LocalFree(m_psdStorage);
		m_psdStorage = NULL;
	}

}

HRESULT CWASSecurity::Init()
{
    HRESULT                  hresReturn  = ERROR_SUCCESS;
    BOOL                     status;
    DWORD                    dwDaclSize;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
//    PLATFORM_TYPE            platformType;

	// If already initialized, no work needs to be done.
	if (m_psdStorage)
		return S_OK;

    //
    // Of course, we only need to do this under NT...
    //

//    platformType = IISGetPlatformType();

//    if( (platformType == PtNtWorkstation) || (platformType == PtNtServer ) ) {


        m_psdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (m_psdStorage == NULL) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        //
        // Initialize the security descriptor.
        //

        status = InitializeSecurityDescriptor(
                     m_psdStorage,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        status = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &m_psidSystem
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }
        status=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &m_psidAdmin
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        dwDaclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(m_psidAdmin)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(m_psidSystem)
                       - sizeof(DWORD);

        m_paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

        if( m_paclDiscretionary == NULL ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        status = InitializeAcl(
                     m_paclDiscretionary,
                     dwDaclSize,
                     ACL_REVISION
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     m_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     m_psidSystem
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     m_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     m_psidAdmin
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;

        }

        //
        // Set the DACL into the security descriptor.
        //

        status = SetSecurityDescriptorDacl(
                     m_psdStorage,
                     TRUE,
                     m_paclDiscretionary,
                     FALSE
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;

        }
//    }

fatal:

    if (FAILED(hresReturn)) {
        
		if( m_paclDiscretionary != NULL ) {
			LocalFree( m_paclDiscretionary );
			m_paclDiscretionary = NULL;
		}

		if( m_psidAdmin != NULL ) {
			FreeSid( m_psidAdmin );
			m_psidAdmin = NULL;

		}

		if( m_psidSystem != NULL ) {
			FreeSid( m_psidSystem );
			m_psidSystem = NULL;
		}

		if( m_psdStorage != NULL ) {
			LocalFree( m_psdStorage );
			m_psdStorage = NULL;
		}


    }

    return hresReturn;
}

// Global WAS Security object.
CWASSecurity g_WASSecurity;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\writer.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    Writer.cpp

$Header: $

Abstract:


--**************************************************************************/

#include "catalog.h"
#include "catmeta.h"
#include "WriterGlobalHelper.h"
#include "Writer.h"
#include "LocationWriter.h"
#include "CatalogPropertyWriter.h"
#include "CatalogCollectionWriter.h"
#include "CatalogSchemaWriter.h"
#include "WriterGlobals.h"

#define MAX_BUFFER	2048

#define g_cbMaxBuffer			32768		
#define g_cchMaxBuffer			g_cbMaxBuffer/sizeof(WCHAR)
#define g_cbMaxBufferMultiByte  32768

SIZE_T  g_cbBufferUsed = 0;
BYTE    g_Buffer[g_cbMaxBuffer];
BYTE    g_BufferMultiByte[g_cbMaxBufferMultiByte];

//
// Forward declaration
//

HRESULT GetGlobalHelper(CWriterGlobalHelper** ppCWriterGlobalHelper);


CWriter::CWriter()
{
	m_wszFile = NULL;
	m_hFile = INVALID_HANDLE_VALUE;
	m_bCreatedFile = FALSE;
	m_pCWriterGlobalHelper = NULL;
    m_psidSystem = NULL;
    m_psidAdmin = NULL;
    m_paclDiscretionary = NULL;
    m_psdStorage = NULL;

		
} // Constructor  CWriter


CWriter::~CWriter()
{
	if(NULL != m_wszFile)
	{	
		delete [] m_wszFile;
		m_wszFile = NULL;
	}
	if(m_bCreatedFile && 
	   (INVALID_HANDLE_VALUE != m_hFile || NULL != m_hFile)
	  )
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}
	else
		m_hFile = INVALID_HANDLE_VALUE;

    if( m_paclDiscretionary != NULL ) {
        LocalFree( m_paclDiscretionary );
        m_paclDiscretionary = NULL;
    }

    if( m_psidAdmin != NULL ) {
        FreeSid( m_psidAdmin );
        m_psidAdmin = NULL;

    }

    if( m_psidSystem != NULL ) {
        FreeSid( m_psidSystem );
        m_psidSystem = NULL;
    }

    if( m_psdStorage != NULL ) {
        LocalFree( m_psdStorage );
        m_psdStorage = NULL;
    }


} // Constructor  CWriter


HRESULT CWriter::Initialize(LPCWSTR wszFile,
							HANDLE  hFile)
{

	HRESULT                 hr            = S_OK;

	//
	// TODO: Assert that everything is NULL
	//

	//
	// Save file name and handle.
	//

	m_wszFile = new WCHAR[wcslen(wszFile)+1];
	if(NULL == m_wszFile)
		return E_OUTOFMEMORY;
	wcscpy(m_wszFile, wszFile);

	if((INVALID_HANDLE_VALUE == hFile) || 
	   (NULL == hFile)
	  )
	{
        SECURITY_ATTRIBUTES saStorage;
        PSECURITY_ATTRIBUTES psaStorage = NULL;

		SetSecurityDescriptor();

        if (m_psdStorage != NULL) {
            saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
            saStorage.lpSecurityDescriptor = m_psdStorage;
            saStorage.bInheritHandle = FALSE;
            psaStorage = &saStorage;
        }

		m_hFile = CreateFile(wszFile, 
							 GENERIC_WRITE,
							 0,
							 psaStorage, 
							 CREATE_ALWAYS, 
							 FILE_ATTRIBUTE_NORMAL, 
							 NULL);

		if(INVALID_HANDLE_VALUE == m_hFile)
			return HRESULT_FROM_WIN32(GetLastError());

		m_bCreatedFile = TRUE;
	}
	else
		m_hFile = hFile;

	g_cbBufferUsed = 0;

	hr = ::GetGlobalHelper(&m_pCWriterGlobalHelper);

	return hr;

} // CWriter::Initialize


HRESULT CWriter::BeginWrite(eWriter eType)
{
	ULONG	dwBytesWritten = 0;
	HRESULT hr = S_OK;

	if(!WriteFile(m_hFile,
				  (LPVOID)&UTF8_SIGNATURE,
				  sizeof(BYTE)*3,
				  &dwBytesWritten,
				  NULL))
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	if(eWriter_Metabase == eType)
	{
		return WriteToFile((LPVOID)g_wszBeginFile,
						   g_cchBeginFile);
	}

	return S_OK;

} // CWriter::BeginWrite


HRESULT CWriter::EndWrite(eWriter eType)
{
	if(eWriter_Metabase == eType)
	{
		return WriteToFile((LPVOID)g_wszEndFile,
						   g_cchEndFile,
						   TRUE);
	}

	return S_OK;

} // CWriter::EndWrite

HRESULT CWriter::WriteToFile(LPVOID	pvData,
						     SIZE_T	cchData,
							 BOOL   bForceFlush)
{
	HRESULT	hr        = S_OK;
	SIZE_T  cbData    = cchData *sizeof(WCHAR);

	if((g_cbBufferUsed + cbData) > g_cbMaxBuffer)
	{
		ULONG iData = 0;
		//
		// If the data cannot be put in the global buffer, flush the contents
		// of the global buffer to disk.
		//

		hr = FlushBufferToDisk();

		if(FAILED(hr))
			goto exit;

		//
		// g_cbBufferUsed should be zero now. If you still cannot accomodate 
		// the data split it up write into buffer.
		//

		while( (g_cbBufferUsed + cbData) > g_cbMaxBuffer)
		{

			hr = WriteToFile(&(((LPWSTR)pvData)[iData]),
							 g_cchMaxBuffer,
							 bForceFlush);

			if(FAILED(hr))
				goto exit;

			iData = iData + g_cchMaxBuffer;
			cbData = cbData - g_cbMaxBuffer;
							 
		}

		memcpy( (&(g_Buffer[g_cbBufferUsed])), &(((LPWSTR)pvData)[iData]), cbData);
		g_cbBufferUsed = g_cbBufferUsed + cbData;

	}
	else
	{
		memcpy( (&(g_Buffer[g_cbBufferUsed])), pvData, cbData);
		g_cbBufferUsed = g_cbBufferUsed + cbData;
	}

	if(TRUE == bForceFlush)
	{
		hr = FlushBufferToDisk();

		if(FAILED(hr))
			goto exit;
	}

exit:

	return hr;

} // CWriter::WriteToFile


HRESULT CWriter::FlushBufferToDisk()
{
	DWORD	dwBytesWritten	= 0;
	int		cb				= 0;
	HRESULT	hr				= S_OK;

	cb = WideCharToMultiByte(CP_UTF8,								// Convert to UTF8
							 NULL,									// Must be NULL
							 LPWSTR(g_Buffer),						// Unicode string to convert.
							 (int)g_cbBufferUsed/sizeof(WCHAR),		// number of chars in string.
							 (LPSTR)g_BufferMultiByte,				// buffer for new string
							 (int)g_cbMaxBufferMultiByte,				// size of buffer
							 NULL,
							 NULL);
	if(!cb)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto exit;
	}

	if(!WriteFile(m_hFile,
				  (LPVOID)g_BufferMultiByte,
				  cb,
				  &dwBytesWritten,
				  NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto exit;
	}

	g_cbBufferUsed = 0;

exit:

	return hr;

} // CWriter::FlushBufferToDisk


HRESULT CWriter::GetLocationWriter(CLocationWriter** ppCLocationWriter,
								   LPCWSTR            wszLocation)
{
	HRESULT hr = S_OK;

	*ppCLocationWriter = new CLocationWriter();
	if(NULL == *ppCLocationWriter)
		return E_OUTOFMEMORY;

	hr = (*ppCLocationWriter)->Initialize((CWriter*)(this),
	                                      wszLocation);

	return hr;

} // CWriter::GetLocationWriter

HRESULT CWriter::GetCatalogSchemaWriter(CCatalogSchemaWriter** ppSchemaWriter)
{
	*ppSchemaWriter = new CCatalogSchemaWriter((CWriter*)(this));
	if(NULL == *ppSchemaWriter)
		return E_OUTOFMEMORY;

	return S_OK;
} // CWriter::GetCatalogSchemaWriter


HRESULT CWriter::SetSecurityDescriptor()
{

    HRESULT                  hresReturn  = ERROR_SUCCESS;
    BOOL                     status;
    DWORD                    dwDaclSize;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
//    PLATFORM_TYPE            platformType;

    //
    // Of course, we only need to do this under NT...
    //

//    platformType = IISGetPlatformType();

//    if( (platformType == PtNtWorkstation) || (platformType == PtNtServer ) ) {


        m_psdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (m_psdStorage == NULL) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        //
        // Initialize the security descriptor.
        //

        status = InitializeSecurityDescriptor(
                     m_psdStorage,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        status = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &m_psidSystem
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }
        status=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &m_psidAdmin
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        dwDaclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(m_psidAdmin)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(m_psidSystem)
                       - sizeof(DWORD);

        m_paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

        if( m_paclDiscretionary == NULL ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        status = InitializeAcl(
                     m_paclDiscretionary,
                     dwDaclSize,
                     ACL_REVISION
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     m_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     m_psidSystem
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;
        }

        status = AddAccessAllowedAce(
                     m_paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     m_psidAdmin
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;

        }

        //
        // Set the DACL into the security descriptor.
        //

        status = SetSecurityDescriptorDacl(
                     m_psdStorage,
                     TRUE,
                     m_paclDiscretionary,
                     FALSE
                     );

        if( !status ) {
            hresReturn = HRESULT_FROM_WIN32(GetLastError());
            goto fatal;

        }
//    }

fatal:

    if (FAILED(hresReturn)) {
        
		if( m_paclDiscretionary != NULL ) {
			LocalFree( m_paclDiscretionary );
			m_paclDiscretionary = NULL;
		}

		if( m_psidAdmin != NULL ) {
			FreeSid( m_psidAdmin );
			m_psidAdmin = NULL;

		}

		if( m_psidSystem != NULL ) {
			FreeSid( m_psidSystem );
			m_psidSystem = NULL;
		}

		if( m_psdStorage != NULL ) {
			LocalFree( m_psdStorage );
			m_psdStorage = NULL;
		}


    }

    return hresReturn;

} // CWriter::SetSecurityDescriptor


HRESULT GetGlobalHelper(CWriterGlobalHelper** ppCWriterGlobalHelper)
{
	static CWriterGlobalHelper* pCWriterGlobalHelper = NULL;
	HRESULT hr = S_OK;

	if(NULL == pCWriterGlobalHelper)
	{
		pCWriterGlobalHelper = new CWriterGlobalHelper();
		if(NULL == pCWriterGlobalHelper)
			return E_OUTOFMEMORY;

		hr = pCWriterGlobalHelper->InitializeGlobals();

		if(FAILED(hr))
		{
			delete pCWriterGlobalHelper;
			pCWriterGlobalHelper = NULL;
			return hr;
		}
	}

	*ppCWriterGlobalHelper = pCWriterGlobalHelper;

	return S_OK;

} // GetGlobalHelper
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\shared\util\writerglobalhelper.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    WriterGlobalHelper.cpp

$Header: $

Abstract:


--**************************************************************************/

#include "catalog.h"
#include "catmeta.h"
#include "WriterGlobalHelper.h"
#include "WriterGlobals.cpp"
#include "mddefw.h"
#include "iiscnfg.h"
#include "wchar.h"

#define cMaxFlagString 1024

//
// TODO: Since XML table also uses this, cant we reduce to one definition?
//

static WCHAR * kByteToWchar[256] = 
{
    L"00",    L"01",    L"02",    L"03",    L"04",    L"05",    L"06",    L"07",    L"08",    L"09",    L"0a",    L"0b",    L"0c",    L"0d",    L"0e",    L"0f",
    L"10",    L"11",    L"12",    L"13",    L"14",    L"15",    L"16",    L"17",    L"18",    L"19",    L"1a",    L"1b",    L"1c",    L"1d",    L"1e",    L"1f",
    L"20",    L"21",    L"22",    L"23",    L"24",    L"25",    L"26",    L"27",    L"28",    L"29",    L"2a",    L"2b",    L"2c",    L"2d",    L"2e",    L"2f",
    L"30",    L"31",    L"32",    L"33",    L"34",    L"35",    L"36",    L"37",    L"38",    L"39",    L"3a",    L"3b",    L"3c",    L"3d",    L"3e",    L"3f",
    L"40",    L"41",    L"42",    L"43",    L"44",    L"45",    L"46",    L"47",    L"48",    L"49",    L"4a",    L"4b",    L"4c",    L"4d",    L"4e",    L"4f",
    L"50",    L"51",    L"52",    L"53",    L"54",    L"55",    L"56",    L"57",    L"58",    L"59",    L"5a",    L"5b",    L"5c",    L"5d",    L"5e",    L"5f",
    L"60",    L"61",    L"62",    L"63",    L"64",    L"65",    L"66",    L"67",    L"68",    L"69",    L"6a",    L"6b",    L"6c",    L"6d",    L"6e",    L"6f",
    L"70",    L"71",    L"72",    L"73",    L"74",    L"75",    L"76",    L"77",    L"78",    L"79",    L"7a",    L"7b",    L"7c",    L"7d",    L"7e",    L"7f",
    L"80",    L"81",    L"82",    L"83",    L"84",    L"85",    L"86",    L"87",    L"88",    L"89",    L"8a",    L"8b",    L"8c",    L"8d",    L"8e",    L"8f",
    L"90",    L"91",    L"92",    L"93",    L"94",    L"95",    L"96",    L"97",    L"98",    L"99",    L"9a",    L"9b",    L"9c",    L"9d",    L"9e",    L"9f",
    L"a0",    L"a1",    L"a2",    L"a3",    L"a4",    L"a5",    L"a6",    L"a7",    L"a8",    L"a9",    L"aa",    L"ab",    L"ac",    L"ad",    L"ae",    L"af",
    L"b0",    L"b1",    L"b2",    L"b3",    L"b4",    L"b5",    L"b6",    L"b7",    L"b8",    L"b9",    L"ba",    L"bb",    L"bc",    L"bd",    L"be",    L"bf",
    L"c0",    L"c1",    L"c2",    L"c3",    L"c4",    L"c5",    L"c6",    L"c7",    L"c8",    L"c9",    L"ca",    L"cb",    L"cc",    L"cd",    L"ce",    L"cf",
    L"d0",    L"d1",    L"d2",    L"d3",    L"d4",    L"d5",    L"d6",    L"d7",    L"d8",    L"d9",    L"da",    L"db",    L"dc",    L"dd",    L"de",    L"df",
    L"e0",    L"e1",    L"e2",    L"e3",    L"e4",    L"e5",    L"e6",    L"e7",    L"e8",    L"e9",    L"ea",    L"eb",    L"ec",    L"ed",    L"ee",    L"ef",
    L"f0",    L"f1",    L"f2",    L"f3",    L"f4",    L"f5",    L"f6",    L"f7",    L"f8",    L"f9",    L"fa",    L"fb",    L"fc",    L"fd",    L"fe",    L"ff"
};

static eESCAPE kWcharToEscape[256] = 
{
  /* 00-0F */ eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eNoESCAPE,            eNoESCAPE,            eESCAPEillegalxml,    eESCAPEillegalxml,    eNoESCAPE,            eESCAPEillegalxml,    eESCAPEillegalxml,
  /* 10-1F */ eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,
  /* 20-2F */ eNoESCAPE,            eNoESCAPE,            eESCAPEquote,         eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eESCAPEamp,           eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 30-3F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eESCAPElt,            eNoESCAPE,            eESCAPEgt,            eNoESCAPE,
  /* 40-4F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 50-5F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 60-6F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,
  /* 70-7F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE, 
  /* 80-8F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* 90-9F */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* A0-AF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* B0-BF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* C0-CF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* D0-DF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* E0-EF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,   
  /* F0-FF */ eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE,            eNoESCAPE
};

#define IsSecureMetadata(id,att) (((DWORD)(att) & METADATA_SECURE) != 0)


CWriterGlobalHelper::CWriterGlobalHelper()
{
	m_pISTTagMetaMBPropertyIndx1	= NULL;
	m_pISTTagMetaMBPropertyIndx2    = NULL;
	m_pISTTagMetaIIsConfigObject	= NULL;
	m_pISTColumnMeta				= NULL;
	m_pISTColumnMetaForFlags        = NULL;
	m_cColKeyTypeMetaData			= cCOLUMNMETA_NumberOfColumns;
	m_wszTABLE_IIsConfigObject      = wszTABLE_IIsConfigObject;
	m_wszTABLE_MBProperty           = wszTABLE_MBProperty;
	m_iStartRowForAttributes        = -1;
	m_wszIIS_MD_UT_SERVER           = NULL;
	m_cchIIS_MD_UT_SERVER           = 0;
	m_wszIIS_MD_UT_FILE             = NULL;
	m_cchIIS_MD_UT_FILE             = 0;
	m_wszIIS_MD_UT_WAM              = NULL;
	m_cchIIS_MD_UT_WAM              = 0;
	m_wszASP_MD_UT_APP              = NULL;
	m_cchASP_MD_UT_APP              = 0;

} // Constructor

CWriterGlobalHelper::~CWriterGlobalHelper()
{
	if(NULL != m_pISTTagMetaMBPropertyIndx1)
	{
		m_pISTTagMetaMBPropertyIndx1->Release();
		m_pISTTagMetaMBPropertyIndx1 = NULL;
	}
	if(NULL != m_pISTTagMetaMBPropertyIndx2)
	{
		m_pISTTagMetaMBPropertyIndx2->Release();
		m_pISTTagMetaMBPropertyIndx2 = NULL;
	}
	if(NULL != m_pISTTagMetaIIsConfigObject)
	{
		m_pISTTagMetaIIsConfigObject->Release();
		m_pISTTagMetaIIsConfigObject = NULL;
	}
	if(NULL != m_pISTColumnMeta)
	{
		m_pISTColumnMeta->Release();
		m_pISTColumnMeta = NULL;
	}
	if(NULL != m_pISTColumnMetaForFlags)
	{
		m_pISTColumnMetaForFlags->Release();
		m_pISTColumnMetaForFlags = NULL;
	}
	if(NULL != m_wszIIS_MD_UT_SERVER)
	{
		delete [] m_wszIIS_MD_UT_SERVER;
		m_wszIIS_MD_UT_SERVER           = NULL;
	}
	m_cchIIS_MD_UT_SERVER               = 0;
	if(NULL != m_wszIIS_MD_UT_FILE)
	{
		delete [] m_wszIIS_MD_UT_FILE;
		m_wszIIS_MD_UT_FILE             = NULL;
	}
	m_cchIIS_MD_UT_FILE                 = 0;
	if(NULL != m_wszIIS_MD_UT_WAM)
	{
		delete [] m_wszIIS_MD_UT_WAM;
		m_wszIIS_MD_UT_WAM              = NULL;
	}
	m_cchIIS_MD_UT_WAM                  = 0;
	if(NULL != m_wszASP_MD_UT_APP)
	{
		delete [] m_wszASP_MD_UT_APP;
		m_wszASP_MD_UT_APP              = NULL;
	}
	m_cchASP_MD_UT_APP                  = 0;

} // Destructor

HRESULT CWriterGlobalHelper::InitializeGlobals()
{
	ISimpleTableDispenser2*	pISTDisp      = NULL;
	HRESULT                 hr            = S_OK;
	LPWSTR					g_wszByID	  = L"ByID";
	STQueryCell				Query[1];
	ULONG					cCell         = sizeof(Query)/sizeof(STQueryCell);
	ULONG                   iStartRow     = 0;
	DWORD					dwKeyTypeID   = MD_KEY_TYPE;
	ULONG                   aColSearch [] = {iCOLUMNMETA_Table,
		                                     iCOLUMNMETA_ID
		                                    };
	ULONG                   cColSearch    = sizeof(aColSearch)/sizeof(ULONG);
	ULONG                   iRow          = 0;
	ULONG                   iCol          = iMBProperty_Attributes;
	LPVOID                  apvSearch[cCOLUMNMETA_NumberOfColumns];
	ULONG                   aColSearchFlags[] = {iTAGMETA_Table,
	                                             iTAGMETA_ColumnIndex
	};
	ULONG                   cColSearchFlags = sizeof(aColSearchFlags)/sizeof(ULONG);
	LPVOID                  apvSearchFlags[cTAGMETA_NumberOfColumns];
	apvSearchFlags[iTAGMETA_ColumnIndex] = (LPVOID)&iCol;

	hr = InitializeGlobalLengths();

	if(FAILED(hr))
		goto exit;

	//
	// Get the dispenser
	//

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

	if(FAILED(hr))
		goto exit;

	//
	// Fetch the internal pointers to relevant table names. This is a perf
	// optimization. When you use internal pointers to strings in 
	// GetRowIndexBySearch, then you avoid a string compare
	//

	hr = GetInternalTableName(pISTDisp,
		                      wszTABLE_IIsConfigObject,
							  &m_wszTABLE_IIsConfigObject);

	if(FAILED(hr))
		goto exit; //
	               // TODO: Must we fail? We could log and ignore, it would 
	               // just be slower.

	hr = GetInternalTableName(pISTDisp,
		                      wszTABLE_MBProperty,
							  &m_wszTABLE_MBProperty);

	if(FAILED(hr))
		goto exit; //
	               // TODO: Must we fail? We could log and ignore, it would 
	               // just be slower.

	apvSearch[iCOLUMNMETA_Table] = (LPVOID)m_wszTABLE_IIsConfigObject;
	apvSearch[iCOLUMNMETA_ID] = (LPVOID)&dwKeyTypeID;
	
	//
	// Save pointer to the TagMeta table for tags from MBProperty.
	//
/*
	Query[0].pData		= (void*) wszTABLE_MBProperty;
	Query[0].eOperator	= eST_OP_EQUAL;
	Query[0].iCell		= iTAGMETA_Table;
	Query[0].dbType		= DBTYPE_WSTR;
	Query[0].cbSize		= 0;
*/
	Query[0].pData		= (void*)g_wszByTableAndColumnIndexAndNameOnly;
	Query[0].eOperator	= eST_OP_EQUAL;
	Query[0].iCell		= iST_CELL_INDEXHINT;
	Query[0].dbType		= DBTYPE_WSTR;
	Query[0].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_TAGMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTTagMetaMBPropertyIndx1);

	if(FAILED(hr))
		goto exit;

	Query[0].pData		= (void*)g_wszByTableAndColumnIndexAndValueOnly;
	Query[0].eOperator	= eST_OP_EQUAL;
	Query[0].iCell		= iST_CELL_INDEXHINT;
	Query[0].dbType		= DBTYPE_WSTR;
	Query[0].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_TAGMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTTagMetaMBPropertyIndx2);

	if(FAILED(hr))
		goto exit;

	//
	// Save pointer to the TagMeta table for tags from IIsConfigObject.
	//
/*
	Query[0].pData		= (void*) wszTABLE_IIsConfigObject;
	Query[0].eOperator	= eST_OP_EQUAL;
	Query[0].iCell		= iTAGMETA_Table;
	Query[0].dbType		= DBTYPE_WSTR;
	Query[0].cbSize		= 0;
*/

	Query[0].pData		= (void*)g_wszByTableAndColumnIndexOnly;
	Query[0].eOperator	= eST_OP_EQUAL;
	Query[0].iCell		= iST_CELL_INDEXHINT;
	Query[0].dbType		= DBTYPE_WSTR;
	Query[0].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_TAGMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTTagMetaIIsConfigObject);

	if(FAILED(hr))
		goto exit;

	//
	// Save pointer to ColumnMeta table
	//

	Query[0].pData		= (void*)g_wszByID;
	Query[0].eOperator	= eST_OP_EQUAL;
	Query[0].iCell		= iST_CELL_INDEXHINT;
	Query[0].dbType		= DBTYPE_WSTR;
	Query[0].cbSize		= 0;

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_COLUMNMETA,
							(LPVOID)Query,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTColumnMeta);

	if(FAILED(hr))
		goto exit;

	//
	// Save pointer to comlumn meta with different index hint.
	//

	hr = pISTDisp->GetTable(wszDATABASE_META,
							wszTABLE_COLUMNMETA,
							(LPVOID)NULL,
							(LPVOID)NULL,
							eST_QUERYFORMAT_CELLS,
							0,
							(LPVOID*)&m_pISTColumnMetaForFlags);

	if(FAILED(hr))
		goto exit;


	//
	// Save meta information about the KeyType property.
	//

	hr = m_pISTColumnMeta->GetRowIndexBySearch(iStartRow, 
		                                       cColSearch, 
											   aColSearch,
											   NULL, 
											   apvSearch,
											   &iRow);

	if(FAILED(hr))
		goto exit;


	hr = m_pISTColumnMeta->GetColumnValues(iRow,
		                                   m_cColKeyTypeMetaData,
										   NULL,
										   NULL,
										   m_apvKeyTypeMetaData);

	if(FAILED(hr))
		goto exit;

	//
	// Save start row index in tagmeta table for the attributes column 
	// in MBproperty table.
	//

	apvSearchFlags[iTAGMETA_Table] = m_wszTABLE_MBProperty;

	hr = m_pISTTagMetaIIsConfigObject->GetRowIndexBySearch(iStartRow, 
												           cColSearchFlags, 
												           aColSearchFlags,
												           NULL, 
												           apvSearchFlags,
												           (ULONG*)&m_iStartRowForAttributes);
	
	if(FAILED(hr))
		goto exit; // TODO: Can log and continue. Will be slower

exit:

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
		pISTDisp = NULL;
	}

	return hr;


	
} // CWriterGlobalHelper::InitializeGlobals


HRESULT CWriterGlobalHelper::GetInternalTableName(ISimpleTableDispenser2*  i_pISTDisp,
												  LPCWSTR                  i_wszTableName,
												  LPWSTR*                  o_wszInternalTableName)
{
	HRESULT               hr            = S_OK;
	ISimpleTableRead2*    pISTTableMeta = NULL;
/*
	STQueryCell			  Query[1];
	ULONG				  cCell         = sizeof(Query)/sizeof(STQueryCell);
*/
	ULONG                 iCol          = iTABLEMETA_InternalName;
	ULONG                 iRow          = 0;
/*
	Query[0].pData		= (void*) i_wszTableName;
	Query[0].eOperator	= eST_OP_EQUAL;
	Query[0].iCell		= iTABLEMETA_InternalName;
	Query[0].dbType		= DBTYPE_WSTR;
	Query[0].cbSize		= 0;
*/	
	hr = i_pISTDisp->GetTable(wszDATABASE_META,
							  wszTABLE_TABLEMETA,
							  (LPVOID)NULL,
							  (LPVOID)NULL,
							  eST_QUERYFORMAT_CELLS,
							  0,
							  (LPVOID*)&pISTTableMeta);

	if(FAILED(hr))
		goto exit;

	hr = pISTTableMeta->GetRowIndexByIdentity(NULL,
											  (LPVOID*)&i_wszTableName,
											  &iRow);

	if(FAILED(hr))
		goto exit;

	hr = pISTTableMeta->GetColumnValues(iRow,
		                                1,
										&iCol,
										NULL,
										(LPVOID*)o_wszInternalTableName);

	if(FAILED(hr))
		goto exit; //
	               // TODO: Must we fail? We could log and ignore, it would 
	               // just be slower.
exit:

	if(NULL != pISTTableMeta)
	{	
		pISTTableMeta->Release();
		pISTTableMeta = NULL;
	}

	return hr;

} // CWriterGlobalHelper::GetInternalTableName


HRESULT CWriterGlobalHelper::InitializeGlobalLengths()
{
	g_cchBeginFile					= wcslen(g_wszBeginFile);
	g_cchEndFile					= wcslen(g_wszEndFile);
	g_cchBeginLocation				= wcslen(g_BeginLocation);
	g_cchLocation					= wcslen(g_Location);
	g_cchEndLocationBegin			= wcslen(g_EndLocationBegin);
	g_cchEndLocationEnd				= wcslen(g_EndLocationEnd);
	g_cchCloseQuoteBraceRtn			= wcslen(g_CloseQuoteBraceRtn);
	g_cchRtn						= wcslen(g_Rtn);
	g_cchEqQuote					= wcslen(g_EqQuote);
	g_cchQuoteRtn					= wcslen(g_QuoteRtn);
	g_cchTwoTabs					= wcslen(g_TwoTabs);
	g_cchNameEq						= wcslen(g_NameEq);
	g_cchIDEq						= wcslen(g_IDEq);
	g_cchValueEq					= wcslen(g_ValueEq);
	g_cchTypeEq						= wcslen(g_TypeEq);
	g_cchUserTypeEq					= wcslen(g_UserTypeEq);
	g_cchAttributesEq				= wcslen(g_AttributesEq);
	g_cchBeginGroup					= wcslen(g_BeginGroup);
	g_cchEndGroup					= wcslen(g_EndGroup);
	g_cchBeginCustomProperty		= wcslen(g_BeginCustomProperty);
	g_cchEndCustomProperty			= wcslen(g_EndCustomProperty);
	g_cchZeroHex					= wcslen(g_ZeroHex);

	BYTE_ORDER_MASK =	0xFEFF;
	UTF8_SIGNATURE = 0x00BFBBEF;

	g_cchUnknownName                = wcslen(g_wszUnknownName);
	g_cchUT_Unknown                 = wcslen(g_UT_Unknown);
	g_cchMaxBoolStr					= wcslen(g_wszFalse);

	return S_OK;

} // CWriterGlobalHelper::InitializeGlobalLengths


HRESULT CWriterGlobalHelper::FlagToString(DWORD      dwValue,
								          LPWSTR*    pwszData,
									      LPWSTR     wszTable,
									      ULONG      iColFlag)
{

	DWORD	dwAllFlags = 0;
	HRESULT hr         = S_OK;
	ULONG   iStartRow  = 0;
	ULONG   iRow       = 0;
	WCHAR	wszBufferDW[20];
	ULONG   iCol       = 0;
	LPWSTR	wszFlag	   = NULL;

	ULONG   aCol[]     = {iTAGMETA_Value,
					      iTAGMETA_InternalName,
						  iTAGMETA_Table,
						  iTAGMETA_ColumnIndex
				         };
	ULONG   cCol       = sizeof(aCol)/sizeof(ULONG);
	LPVOID  apv[cTAGMETA_NumberOfColumns];
	ULONG   cch        = 0;
	LPVOID  apvIdentity [] = {(LPVOID)wszTable,
							  (LPVOID)&iColFlag
	};
	ULONG   iColFlagMask = iCOLUMNMETA_FlagMask;
	DWORD*  pdwFlagMask = NULL;

	DWORD   dwZero = 0;
	ULONG   aColSearchByValue[] = {iTAGMETA_Table,
							       iTAGMETA_ColumnIndex,
							       iTAGMETA_Value
	};
	ULONG   cColSearchByValue = sizeof(aColSearchByValue)/sizeof(ULONG);
	LPVOID  apvSearchByValue[cTAGMETA_NumberOfColumns];
	apvSearchByValue[iTAGMETA_Table] = (LPVOID)wszTable;
	apvSearchByValue[iTAGMETA_ColumnIndex] = (LPVOID)&iColFlag;
	apvSearchByValue[iTAGMETA_Value] = (LPVOID)&dwZero;


	//
	// Make one pass and compute all flag values for this property.
	//

	hr = m_pISTColumnMetaForFlags->GetRowIndexByIdentity(NULL,
		                                                 apvIdentity,
										 			     &iRow);

	if(SUCCEEDED(hr))
	{
		hr = m_pISTColumnMetaForFlags->GetColumnValues(iRow,
													   1,
													   &iColFlagMask,
													   NULL,
													   (LPVOID*)&pdwFlagMask);

		if(FAILED(hr))
			return hr;
	}
	else if(E_ST_NOMOREROWS != hr)
		return hr;


	if((E_ST_NOMOREROWS == hr) || 
	   (0 != (dwValue & (~(dwValue & (*pdwFlagMask))))))
	{
		//
		//	There was no mask associated with this property, or there are one
		//  or more unknown bits set. Spit out a regular number.
		//

		_ultow(dwValue, wszBufferDW, 10);
		*pwszData = new WCHAR[wcslen(wszBufferDW)+1];
		if(NULL == *pwszData)
			return E_OUTOFMEMORY;
		wcscpy(*pwszData, wszBufferDW);
		return S_OK;

	}
	else if(0 == dwValue)
	{
		//
		// See if there is a flag with 0 as its value.
		//

		hr = m_pISTTagMetaMBPropertyIndx2->GetRowIndexBySearch(iStartRow, 
														       cColSearchByValue, 
															   aColSearchByValue,
															   NULL, 
															   apvSearchByValue,
															   &iRow);

		if(E_ST_NOMOREROWS == hr)
		{
			//
			// There was no flag associated with the value zero. Spit out a 
			// regular number
			//

			_ultow(dwValue, wszBufferDW, 10);
			*pwszData = new WCHAR[wcslen(wszBufferDW)+1];
			if(NULL == *pwszData)
				return E_OUTOFMEMORY;
			wcscpy(*pwszData, wszBufferDW);
			return S_OK;

		}
		else if(FAILED(hr))
			return hr;
		else
		{
			iCol = iTAGMETA_InternalName;

			hr = m_pISTTagMetaMBPropertyIndx2->GetColumnValues(iRow,
												               1,
															   &iCol,
															   NULL,
															   (LPVOID*)&wszFlag);
			if(FAILED(hr))
				return hr;

			*pwszData = new WCHAR[wcslen(wszFlag)+1];
			if(NULL == *pwszData)
				return E_OUTOFMEMORY;
			**pwszData = 0;
			wcscat(*pwszData, wszFlag);
			return S_OK;
		}

	}
	else 
	{
		//
		// Make another pass, and convert flag to string.
		//

		SIZE_T cchFlagString = cMaxFlagString;
		LPWSTR wszExtension = L" | ";
		SIZE_T cchExtension = wcslen(wszExtension);
		SIZE_T cchFlagStringUsed = 0;

		*pwszData = new WCHAR[cchFlagString+1];
		if(NULL == *pwszData)
			return E_OUTOFMEMORY;
		**pwszData = 0;
		
		hr = GetStartRowIndex(wszTable,
			                  iColFlag,
							  &iStartRow);

		if(FAILED(hr) || (iStartRow == -1))
			return hr;

		for(iRow=iStartRow;;iRow++)
		{
			hr = m_pISTTagMetaIIsConfigObject->GetColumnValues(iRow,
												               cCol,
															   aCol,
															   NULL,
															   apv);
			if((E_ST_NOMOREROWS == hr) ||
			   (iColFlag != *(DWORD*)apv[iTAGMETA_ColumnIndex]) ||
			   (0 != StringInsensitiveCompare(wszTable, (LPWSTR)apv[iTAGMETA_Table]))
			  )
			{
				hr = S_OK;
				break;
			}
			else if(FAILED(hr))
				return hr;

			if(0 != (dwValue & (*(DWORD*)apv[iTAGMETA_Value])))
			{
				SIZE_T strlen = wcslen((LPWSTR)apv[iTAGMETA_InternalName]);

				if(cchFlagStringUsed + cchExtension + strlen > cchFlagString)
				{
					LPWSTR wszTemp = NULL;
					cchFlagString = cchFlagString + cMaxFlagString;
					wszTemp = new WCHAR[cchFlagString+1];
					if(NULL == wszTemp)
						return E_OUTOFMEMORY;
					wcscpy(wszTemp, *pwszData);

					if(NULL != *pwszData)
						delete [] (*pwszData);

					*pwszData = wszTemp;
				}

				if(**pwszData != 0)
				{
					wcscat(*pwszData, wszExtension);
					cchFlagStringUsed = cchFlagStringUsed + cchExtension;
				}

				wcscat(*pwszData, (LPWSTR)apv[iTAGMETA_InternalName]);
				cchFlagStringUsed = cchFlagStringUsed + strlen;

				// Clear out that bit

				dwValue = dwValue & (~(*(DWORD*)apv[iTAGMETA_Value]));
			}

		}

	}

	return S_OK;

} // CWriterGlobalHelper::FlagToString


HRESULT CWriterGlobalHelper::EnumToString(DWORD      dwValue,
								          LPWSTR*    pwszData,
									      LPWSTR     wszTable,
									      ULONG      iColEnum)
{

	HRESULT hr             = S_OK;
	ULONG   iStartRow      = 0;
	ULONG   iRow           = 0;
	ULONG   iColEnumString = iTAGMETA_InternalName;
	LPWSTR  wszEnum        = NULL;
	ULONG   aColSearch[]   = {iTAGMETA_Table,
		                      iTAGMETA_ColumnIndex,
							  iTAGMETA_Value};
	ULONG   cColSearch     = sizeof(aColSearch)/sizeof(ULONG);
	LPVOID  apvSearch[cTAGMETA_NumberOfColumns];
    apvSearch[iTAGMETA_Table]       = (LPVOID)wszTable;
    apvSearch[iTAGMETA_ColumnIndex] = (LPVOID)&iColEnum;
	apvSearch[iTAGMETA_Value]       = (LPVOID)&dwValue;
	

	hr = m_pISTTagMetaMBPropertyIndx2->GetRowIndexBySearch(iStartRow,
		                                                   cColSearch,
														   aColSearch,
														   NULL,
														   apvSearch,
														   &iRow);

	if(E_ST_NOMOREROWS == hr)
	{
		//
		// Convert to a number
		//
		WCHAR	wszBufferDW[20];
		_ultow(dwValue, wszBufferDW, 10);
		*pwszData = new WCHAR[wcslen(wszBufferDW)+1];
		if(NULL == *pwszData)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy(*pwszData, wszBufferDW);
		return S_OK;

	}
	else if(FAILED(hr))
	{
		return hr;
	}
	else
	{
		hr = m_pISTTagMetaMBPropertyIndx2->GetColumnValues(iRow,
														   1,
														   &iColEnumString,
														   NULL,
														   (LPVOID*)&wszEnum);
		if(FAILED(hr))
		{
			return hr;
		}

		*pwszData = new WCHAR[wcslen(wszEnum)+1];
		if(NULL == *pwszData)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy(*pwszData, wszEnum);
	}

	return S_OK;

} // CWiterGlobalHelper::EnumToString


HRESULT CWriterGlobalHelper::ToString(PBYTE   pbData,
								      DWORD   cbData,
								      DWORD   dwIdentifier,
								      DWORD   dwDataType,
								      DWORD   dwAttributes,
								      LPWSTR* pwszData)
{
	HRESULT hr              = S_OK;
	ULONG	i				= 0;
	ULONG	j				= 0;
	WCHAR*	wszBufferBin	= NULL;
	WCHAR*	wszTemp			= NULL;
	BYTE*	a_Bytes			= NULL;
	WCHAR*	wszMultisz      = NULL;
	ULONG   cMultisz        = 0;
	SIZE_T  cchMultisz      = 0;
	SIZE_T  cchBuffer       = 0;
	DWORD	dwValue			= 0;
	WCHAR	wszBufferDW[20];
	WCHAR	wszBufferDWTemp[20];
	
	ULONG   aColSearch[]    = {iCOLUMNMETA_Table,
							   iCOLUMNMETA_ID
						      };
	ULONG   cColSearch      = sizeof(aColSearch)/sizeof(ULONG);
	LPVOID  apvSearch[cCOLUMNMETA_NumberOfColumns];
	apvSearch[iCOLUMNMETA_Table] = (LPVOID)m_wszTABLE_IIsConfigObject;
	apvSearch[iCOLUMNMETA_ID] = (LPVOID)&dwIdentifier; 

	ULONG   iRow            = 0;
	ULONG   iStartRow            = 0;

	LPWSTR  wszEscaped = NULL;
	BOOL    bEscaped = FALSE;

	*pwszData = NULL;

	if(IsSecureMetadata(dwIdentifier, dwAttributes))
		dwDataType = BINARY_METADATA;

	switch(dwDataType)
	{
		case BINARY_METADATA:

			wszBufferBin	= new WCHAR[(cbData*2)+1]; // Each byte is represented by 2 chars. Add extra char for null termination
			if(NULL == wszBufferBin)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}
			wszTemp			= wszBufferBin;
			a_Bytes			= (BYTE*)(pbData);

			for(i=0; i<cbData; i++)
			{
                wszTemp[0] = kByteToWchar[a_Bytes[i]][0];
                wszTemp[1] = kByteToWchar[a_Bytes[i]][1];
                wszTemp += 2;
			}

			*wszTemp	= 0; // Add the terminating NULL
			*pwszData  	= wszBufferBin;
			break;

		case DWORD_METADATA :

			// TODO: After Stephen supports hex, convert these to hex.

			dwValue = *(DWORD*)(pbData);

			//
			// First check to see if it is a flag or bool type.
			//

			hr = m_pISTColumnMeta->GetRowIndexBySearch(iStartRow, 
													   cColSearch, 
													   aColSearch,
													   NULL, 
													   apvSearch,
													   &iRow);

			if(SUCCEEDED(hr))
			{
			    ULONG  aCol [] = {iCOLUMNMETA_Index,
				                 iCOLUMNMETA_MetaFlags
							    };
				ULONG  cCol = sizeof(aCol)/sizeof(ULONG);
				LPVOID apv[cCOLUMNMETA_NumberOfColumns];

//				ULONG  iCol = iCOLUMNMETA_Index;
//				DWORD* piCol = NULL;

				hr = m_pISTColumnMeta->GetColumnValues(iRow,
									                   cCol,
													   aCol,
													   NULL,
													   apv);

				if(FAILED(hr))
					goto exit;
				
				if(0 != (fCOLUMNMETA_FLAG & (*(DWORD*)apv[iCOLUMNMETA_MetaFlags])))
				{
					//
					// This is a flag property convert it.
					//
/*
					hr = FlagValueToString(dwValue,
									       (ULONG*)apv[iCOLUMNMETA_Index],
									       pwszData);
*/					hr = FlagToString(dwValue,
								      pwszData,
								      m_wszTABLE_IIsConfigObject,
							          *(ULONG*)apv[iCOLUMNMETA_Index]);
	
					goto exit;
				}
				else if(0 != (fCOLUMNMETA_BOOL & (*(DWORD*)apv[iCOLUMNMETA_MetaFlags])))
				{
					//
					// This is a bool property
					//

					hr = BoolToString(dwValue,
					                  pwszData);

					goto exit;
				}
				

			}
			else if((E_ST_NOMOREROWS != hr) && FAILED(hr))
				goto exit;
//			else
//			{
			hr = S_OK;
			_ultow(dwValue, wszBufferDW, 10);
			*pwszData = new WCHAR[wcslen(wszBufferDW)+1];
			if(NULL == *pwszData)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}
			wcscpy(*pwszData, wszBufferDW);
//			}

			break;

		case MULTISZ_METADATA :

			//
			// Count the number of multisz
			//

			wszMultisz = (WCHAR*)(pbData);
//			wszMultisz = wszMultisz + wcslen(wszMultisz) + 1;
//			cMultisz = 1;
			while((0 != *wszMultisz))
			{
				cMultisz++;

				hr = EscapeString(wszMultisz,
								  &bEscaped,
								  &wszEscaped);

				if(FAILED(hr))
					goto exit;

				cchMultisz = cchMultisz + wcslen(wszEscaped);

				if(bEscaped && (NULL != wszEscaped))	// reset for next string in multisz
				{
					delete [] wszEscaped;
					wszEscaped = NULL;
					bEscaped = FALSE;
				}

				wszMultisz = wszMultisz + wcslen(wszMultisz) + 1;
			}

						
//			*pwszData = new WCHAR[(cbData / sizeof(WCHAR)) + (5*(cMultisz-1))]; // (5*(cMultisz-1) => \r\n\t\t\t. \n is included in the null.

			if(cMultisz > 0)
				cchBuffer = cchMultisz + (5*(cMultisz-1)) + 1;    // (5*(cMultisz-1) => \r\n\t\t\t. 
			else
				cchBuffer = 1;

			*pwszData = new WCHAR[cchBuffer]; 
			if(NULL == *pwszData)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}
			**pwszData = 0;

			wszMultisz = (WCHAR*)(pbData);
			wszTemp = *pwszData;

			hr = EscapeString(wszMultisz,
							  &bEscaped,
							  &wszEscaped);

			if(FAILED(hr))
				goto exit;

//			wcscat(wszTemp, wszMultisz);
			wcscat(wszTemp, wszEscaped);

			wszMultisz = wszMultisz + wcslen(wszMultisz) + 1;

			while((0 != *wszMultisz) && ((BYTE*)wszMultisz < (pbData + cbData)))			
			{
				wcscat(wszTemp, L"\r\n\t\t\t");

				if(bEscaped && (NULL != wszEscaped))	// reset for next string in multisz
				{
					delete [] wszEscaped;
					wszEscaped = NULL;
					bEscaped = FALSE;
				}

				hr = EscapeString(wszMultisz,
								  &bEscaped,
								  &wszEscaped);

				if(FAILED(hr))
					goto exit;

//				wcscat(wszTemp, wszMultisz);

				wcscat(wszTemp, wszEscaped);

				wszMultisz = wszMultisz + wcslen(wszMultisz) + 1;
			}

			break;

		case EXPANDSZ_METADATA :
		case STRING_METADATA :

			hr = EscapeString((WCHAR*)pbData,
							  &bEscaped,
							  &wszEscaped);

			if(FAILED(hr))
				goto exit;

			*pwszData = new WCHAR[wcslen(wszEscaped) + 1];
			if(NULL == *pwszData)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}
			wcscpy(*pwszData, wszEscaped);
			break;

		default:
			hr = E_INVALIDARG;
			break;
			
	}

exit:

	if(bEscaped && (NULL != wszEscaped))
	{
		delete [] wszEscaped;
		wszEscaped = NULL;
		bEscaped = FALSE;
	}

	return hr;

} // CWriterGlobalHelper::ToString


HRESULT CWriterGlobalHelper::BoolToString(DWORD      dwValue,
					                  LPWSTR*    pwszData)
{
	*pwszData = new WCHAR[g_cchMaxBoolStr+1];
	if(NULL == *pwszData)
		return E_OUTOFMEMORY;

	if(dwValue)
		wcscpy(*pwszData, g_wszTrue);
	else
		wcscpy(*pwszData, g_wszFalse);

	return S_OK;

} // CWriterGlobalHelper::BoolToString


HRESULT CWriterGlobalHelper::GetStartRowIndex(LPWSTR    wszTable,
			                                  ULONG     iColFlag,
							                  ULONG*    piStartRow)
{
	HRESULT hr = S_OK;
	ULONG   aColSearch[] = {iTAGMETA_Table,
	                        iTAGMETA_ColumnIndex
						   };
	ULONG   cColSearch = sizeof(aColSearch)/sizeof(ULONG);
	LPVOID  apvSearch[cTAGMETA_NumberOfColumns];
	apvSearch[iTAGMETA_Table] = (LPVOID)wszTable;
	apvSearch[iTAGMETA_ColumnIndex] = (LPVOID)&iColFlag;

	*piStartRow = 0;

	if((0 == StringInsensitiveCompare(wszTable, m_wszTABLE_MBProperty)) &&
	   (iMBProperty_Attributes == iColFlag))
	{
		*piStartRow = m_iStartRowForAttributes;
	}
	else
	{
		hr = m_pISTTagMetaIIsConfigObject->GetRowIndexBySearch(*piStartRow, 
															   cColSearch, 
															   aColSearch,
															   NULL, 
															   apvSearch,
														       piStartRow);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			*piStartRow = -1;
		}
	}

	return hr;

} // CWriterGlobalHelper::GetStartRowIndex


/***************************************************************************++

Routine Description:

    Create a new String and NULL terminate it.

Arguments:

    [in]   Count of chars (assume without null terminator) 
    [out]  New string

Return Value:

    HRESULT

--***************************************************************************/
HRESULT NewString(ULONG    cch,
                  LPWSTR*  o_wsz)
{
	*o_wsz = new WCHAR[cch+1];
	if(NULL == *o_wsz)
	{
		return E_OUTOFMEMORY;
	}
	**o_wsz = 0;

	return S_OK;

} // NewString

/***************************************************************************++

Routine Description:

    Function that escapes a string according to the following ruules:

    ************************************************************************
    ESCAPING LEGAL XML
    ************************************************************************

    Following characters are legal in XML:
    #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | 
    [#x10000-#x10FFFF] 

    Out of this legal set, following need special escaping:
    Quote         => " => 34 => Escaped as: &quot;	
    Ampersand     => & => 38 => Escaped as: &amp;	
    Less than     => < => 60 => Escaped as: &lt;
    Gretater than => > => 62 => Escaped as: &gt;

    Note there may be chars in the legal set that may appear legal in certain 
	languages and not in others. All such chars are not escaped. We could 
	escape them as hex numbers Eg 0xA as &#x000A, but we do not want to 
	do this because editors may be able to render these chars, when we change 
	the language.
    Following are the hex values of such chars.

    #x9 | #xA | #xD | [#x7F-#xD7FF] | [#xE000-#xFFFD]

    Note we disregard the range [#x10000-#x10FFFF] because it is not 2 bytes

    ************************************************************************
    ESCAPING ILLEGAL XML
    ************************************************************************

    Illegal XML is also escaped in the following manner

    We add 0x10000 to the char value and escape it as hex. the XML 
    interceptor will render these chars correctly. Note that we are using
    the fact unicode chars are not > 0x10000 and hence we can make this 
    assumption.

Arguments:

    [in]   String to be escaped
    [out]  Bool indicating if escaping happened
    [out]  Escaped string - If no escaping occured, it will just point to
           the original string. If escaping occured it will point to a newly
           allocated string that the caller needs to free. The caller can 
           use the bool to determine what action he needs to take.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT CWriterGlobalHelper::EscapeString(LPCWSTR wszString,
                                          BOOL*   pbEscaped,
									      LPWSTR* pwszEscaped)
{
	ULONG              lenwsz               = wcslen(wszString);
	ULONG              cchAdditional        = 0;
	HRESULT            hr                   = S_OK;
	WORD               wChar                = 0;
    eESCAPE            eEscapeType          = eNoESCAPE;
	const ULONG        cchLegalCharAsHex    = (sizeof(WCHAR)*2) + 4; // Each byte is represented as 2 WCHARs plus 4 additional escape chars (&#x;)
	WCHAR              wszLegalCharAsHex[cchLegalCharAsHex];			
	const ULONG        cchIllegalCharAsHex  = cchLegalCharAsHex + 1; // illegal xml has an extra char because we are adding 0x10000 to it.
	WCHAR              wszIllegalCharAsHex[cchIllegalCharAsHex];		
	DWORD              dwIllegalChar        = 0;
	static LPCWSTR      wszQuote            = L"&quot;";
	static const ULONG  cchQuote            = wcslen(wszQuote);
	static LPCWSTR      wszAmp              = L"&amp;";
	static const ULONG  cchAmp              = wcslen(wszAmp);
	static LPCWSTR      wszlt               = L"&lt;";
	static const ULONG  cchlt               = wcslen(wszlt);
	static LPCWSTR      wszgt               = L"&gt;";
	static const ULONG  cchgt               = wcslen(wszgt);

	*pbEscaped = FALSE;

	//
	// Go through each char and compute the addtional chars needed to escape
	//

	for(ULONG i=0; i<lenwsz; i++)
	{
		eEscapeType = GetEscapeType(wszString[i]);

		switch(eEscapeType)
		{
		case eNoESCAPE:
			break;
		case eESCAPEgt:
			cchAdditional = cchAdditional + cchgt;
			*pbEscaped = TRUE;
			break;
		case eESCAPElt:
			cchAdditional = cchAdditional + cchlt;
			*pbEscaped = TRUE;
			break;
		case eESCAPEquote:
			cchAdditional = cchAdditional + cchQuote;
			*pbEscaped = TRUE;
			break;
		case eESCAPEamp:
			cchAdditional = cchAdditional + cchAmp;
			*pbEscaped = TRUE;
			break;
		case eESCAPEashex:
			cchAdditional = cchAdditional + cchLegalCharAsHex;
			*pbEscaped = TRUE;
			break;
		case eESCAPEillegalxml:
			cchAdditional = cchAdditional + cchIllegalCharAsHex;
			*pbEscaped = TRUE;
			break;
		default:
			return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			break;
		}
	}

	if(*pbEscaped)
	{
		//
		// String needs to be escaped, allocate the extra memory
		//

        hr = NewString(lenwsz+cchAdditional,
		               pwszEscaped);

		if(FAILED(hr))
		{
		    return hr;
		}

		//
		// Escape string
		//

		for(ULONG i=0; i<lenwsz; i++)
		{
			eEscapeType = GetEscapeType(wszString[i]);

			switch(eEscapeType)
			{
			case eNoESCAPE:
			    wcsncat(*pwszEscaped, (WCHAR*)&(wszString[i]), 1);
				break;
			case eESCAPEgt:
			    wcsncat(*pwszEscaped, wszgt, cchgt);
				break;
			case eESCAPElt:
			    wcsncat(*pwszEscaped, wszlt, cchlt);
				break;
			case eESCAPEquote:
			    wcsncat(*pwszEscaped, wszQuote, cchQuote);
				break;
			case eESCAPEamp:
			    wcsncat(*pwszEscaped, wszAmp, cchAmp);
				break;
			case eESCAPEashex:
				_snwprintf(wszLegalCharAsHex, cchLegalCharAsHex, L"&#x%04hX;", wszString[i]);
				wcsncat(*pwszEscaped, (WCHAR*)wszLegalCharAsHex, cchLegalCharAsHex);
				break;
			case eESCAPEillegalxml:
				dwIllegalChar = 0x10000 + wszString[i];
				_snwprintf(wszIllegalCharAsHex, cchIllegalCharAsHex, L"&#x%05X;", dwIllegalChar);
				wcsncat(*pwszEscaped, (WCHAR*)wszIllegalCharAsHex, cchIllegalCharAsHex);
				break;
			default:
				return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				break;
			}
		}

	}
	else
	{
		//
		// String need not be escaped, just pass the string out.
		//

		*pwszEscaped = (LPWSTR)wszString;
	}

	return S_OK;

} // CWriterGlobalHelper::EscapeString


eESCAPE CWriterGlobalHelper::GetEscapeType(WCHAR i_wChar)
{
	WORD    wChar       = i_wChar;
	eESCAPE eEscapeType = eNoESCAPE;

	if(wChar <= 0xFF)
	{
		eEscapeType = kWcharToEscape[wChar];
	}
	else if( (wChar <= 0xD7FF) ||
		     ((wChar >= 0xE000) && (wChar <= 0xFFFD))
		   )
	{
		eEscapeType = eNoESCAPE;
	}
	else
	{
		eEscapeType = eESCAPEillegalxml;
	}

	return eEscapeType;

} // CWriterGlobalHelper::GetEscapeType

HRESULT CWriterGlobalHelper::GetUserType(DWORD   i_dwUserType,
				                         LPWSTR* o_pwszUserType,
										 ULONG*  o_cchUserType,
										 BOOL*   o_bAllocedUserType)
{
	HRESULT hr            = S_OK;
	DWORD	iColUserType  = iCOLUMNMETA_UserType;

	*o_bAllocedUserType = FALSE;

	switch(i_dwUserType)
	{

	case IIS_MD_UT_SERVER:

		if(NULL == m_wszIIS_MD_UT_SERVER)
		{
			hr = EnumToString(i_dwUserType,
				              &m_wszIIS_MD_UT_SERVER,
				              wszTABLE_COLUMNMETA,
				              iColUserType);
			if(FAILED(hr))
			{
				return hr;
			}

			m_cchIIS_MD_UT_SERVER = wcslen(m_wszIIS_MD_UT_SERVER);
		}

		*o_pwszUserType = m_wszIIS_MD_UT_SERVER;
		*o_cchUserType  = m_cchIIS_MD_UT_SERVER;

		break;

	case IIS_MD_UT_FILE:

		if(NULL == m_wszIIS_MD_UT_FILE)
		{
			hr = EnumToString(i_dwUserType,
				              &m_wszIIS_MD_UT_FILE,
				              wszTABLE_COLUMNMETA,
				              iColUserType);
			if(FAILED(hr))
			{
				return hr;
			}

			m_cchIIS_MD_UT_FILE = wcslen(m_wszIIS_MD_UT_FILE);
		}

		*o_pwszUserType = m_wszIIS_MD_UT_FILE;
		*o_cchUserType  = m_cchIIS_MD_UT_FILE;

		break;

	case IIS_MD_UT_WAM:

		if(NULL == m_wszIIS_MD_UT_WAM)
		{
			hr = EnumToString(i_dwUserType,
				              &m_wszIIS_MD_UT_WAM,
				              wszTABLE_COLUMNMETA,
				              iColUserType);
			if(FAILED(hr))
			{
				return hr;
			}

			m_cchIIS_MD_UT_WAM = wcslen(m_wszIIS_MD_UT_WAM);
		}

		*o_pwszUserType = m_wszIIS_MD_UT_WAM;
		*o_cchUserType  = m_cchIIS_MD_UT_WAM;

		break;

	case ASP_MD_UT_APP:

		if(NULL == m_wszASP_MD_UT_APP)
		{
			hr = EnumToString(i_dwUserType,
				              &m_wszASP_MD_UT_APP,
				              wszTABLE_COLUMNMETA,
				              iColUserType);
			if(FAILED(hr))
			{
				return hr;
			}

			m_cchASP_MD_UT_APP = wcslen(m_wszASP_MD_UT_APP);
		}

		*o_pwszUserType = m_wszASP_MD_UT_APP;
		*o_cchUserType  = m_cchASP_MD_UT_APP;

		break;

	default:

		hr = EnumToString(i_dwUserType,
				          o_pwszUserType,
				          wszTABLE_COLUMNMETA,
				          iColUserType);
		if(FAILED(hr))
		{
			return hr;
		}

		*o_cchUserType = wcslen(*o_pwszUserType);
		*o_bAllocedUserType = TRUE;

		break;

	}

	return S_OK;

} // CWriterGlobalHelper::GetUserType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\asaitable\traverse.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    traverse.h

Abstract:

    Header file for the general purpose class used to traverse ASAI 
    collections and objects

Author:

    Murat Ersan (MuratE)        August 2000

Revision History:

--*/

#pragma once

#include "appcntadm.h"
#include "catalog.h"
#include "ASAITable.h"

#define MAX_DEPTH   5

// A helper class that encapsulates the namespace traversal via ASAI.
class CAsaiTraverse
{
public:
    CAsaiTraverse()
    :   m_pwszCollection(NULL),
        m_cProperties(0)
    {
        //NOP
    }

	~CAsaiTraverse() 
	{
		if (m_pwszCollection)
		{
			delete [] m_pwszCollection;
            m_pwszCollection = NULL;
		}

        VariantClear(&m_varProperties);
	}

    HRESULT 
    Init(
        IN LPCWSTR  i_pwszCollection,
        IN ASAIMETA *i_pamMeta,
        IN DWORD    i_cProperties
        );

    HRESULT 
    StartTraverse( 
    	OUT ISimpleTableWrite2* o_pISTW2
        );

    HRESULT 
    FilterByType(
        IN IAppCenterObj    *i_pIObj,
        IN LPCWSTR          i_pwszASAIClassName,
        OUT BOOL            *o_pbCorrectType
        );

    virtual HRESULT 
    ProcessCollection(
        IN IAppCenterCol* pParentObj,
    	OUT ISimpleTableWrite2* o_pISTW2
        ) = 0;

private:

    HRESULT Traverse( 
        IN IAppCenterObj    *i_pParentObj,
        IN DWORD            i_dwDepth,
        IN OUT BOOL         *io_pfDone,
	    OUT ISimpleTableWrite2* o_pISTW2
        );

protected:
    VARIANT     m_varProperties;

private:
    LPWSTR      m_pwszCollection;
    LPWSTR      m_rgpwszPath[MAX_DEPTH+1];
    LPWSTR      m_rgpwszKey[MAX_DEPTH+1];
    DWORD       m_cProperties;
};


class CPopulateCacheAsaiTraverse : public CAsaiTraverse
{
public:

    virtual HRESULT
    ProcessCollection(
        IN IAppCenterCol* i_pCol,
    	OUT ISimpleTableWrite2* o_pISTW2
        );

};

class CUpdateStoreAsaiTraverse : public CAsaiTraverse
{
public:

    virtual HRESULT
    ProcessCollection(
        IN IAppCenterCol* i_pCol,
    	OUT ISimpleTableWrite2* o_pISTW2
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\asaitable\asaitable.cpp ===
/********************************************************************++
 
Copyright (c) 2001 Microsoft Corporation
 
Module Name:
 
    ASAITable.cpp
 
Abstract:
 
    This file contains the implementation of the ASAI interceptor. This
	interceptor is implemented as an InterceptorPlugin, therefore needs
	to implement only three methods: Intercept, OnPopulateCache, and 
	OnUpdateStore.
    
Author:
 
    Murat Ersan (murate)        10-Apr-2001
 
Revision History:
 
--********************************************************************/

#include "ASAITable.h"
#include "coremacros.h"
#include "catmeta.h"
#include "appcntadm.h"
#include "traverse.h"

//
// -----------------------------------------
// CAsaiTable: IUnknown
// -----------------------------------------
//

/********************************************************************++
 
Routine Description:
 
    QueryInterface.
 
Arguments:
 
    riid - The interface being asked for.
 
    ppv - Receives the interface pointer if successfull.
 
Notes:
 
    
Return Value:
 
    E_NOINTERFACE - Interface is not supported by this object.
 
--********************************************************************/
STDMETHODIMP 
CAsaiTable::QueryInterface(
    IN REFIID  riid, 
    OUT void   **ppv
    )
{
    if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_IInterceptorPlugin)
	{
		*ppv = (IInterceptorPlugin*) this;
	}
	else if (riid == IID_ISimpleTableInterceptor)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (IInterceptorPlugin*) this;
	}

	if (NULL != *ppv)
	{
		((IInterceptorPlugin*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

/********************************************************************++
 
Routine Description:
 
    Increments the refcount of the object by one.
 
Arguments:
 
Notes:
 
Return Value:
 
    New refcount.
 
--********************************************************************/
STDMETHODIMP_(ULONG) 
CAsaiTable::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
}

/********************************************************************++
 
Routine Description:
 
    Decrements the refcount of the object by one.
 
Arguments:
 
Notes:
 
Return Value:
 
    New refcount.
 
--********************************************************************/
STDMETHODIMP_(ULONG) 
CAsaiTable::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}

//
// ------------------------------------
// ISimpleTableInterceptor:
// ------------------------------------
//

/********************************************************************++
 
Routine Description:
 
    This is the first function to be called when someone tries to get
    a table served by the ASAI interceptor. All initializations and
    schema related work will be done here.
 
Arguments:
 
Notes:
    "namespace" tells us whether we want the cluster-wide view of this
    table or the local-machine view.
 
Return Value:
 
    HRESULT.
 
--********************************************************************/
STDMETHODIMP 
CAsaiTable::Intercept(
	IN LPCWSTR 	i_wszDatabase,
	IN LPCWSTR 	i_wszTable, 
	IN ULONG	i_TableID,
	IN LPVOID	i_QueryData,
	IN LPVOID	i_QueryMeta,
	IN DWORD	i_eQueryFormat,
	IN DWORD	i_fLOS,
	IN IAdvancedTableDispenser* i_pISTDisp,
	IN LPCWSTR	i_wszLocator,
	IN LPVOID	i_pSimpleTable,
	OUT LPVOID*	o_ppvSimpleTable
    )
{
	BOOL        fFoundANonSpecialCell = FALSE;
    ULONG       dwCell = 0;
    ULONG       cCells = 0;                     // Count of cells.                
    LPCWSTR     pwszNamespace = L"Cluster";
    STQueryCell* pQCells = NULL;
	HRESULT     hr = S_OK;

    //
    // Validate the parameters.
    // Set the out parameter to NULL, so that if we ever fail the value is NULL.
    //

    if ( NULL == o_ppvSimpleTable )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    DBG_ASSERT( NULL == *o_ppvSimpleTable && "This should be NULL.  Possible memory leak or just an uninitialized variable.");
    *o_ppvSimpleTable = NULL;

    if ( NULL == i_wszDatabase )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( NULL == i_wszTable )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( NULL == i_pISTDisp )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Can't have any tables below us. This is not a logic interceptor.
    // 
    
    if ( NULL != i_pSimpleTable )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Parse the query. 
    //

    if (0 != i_QueryMeta && NULL != i_QueryData)
    {
		pQCells = (STQueryCell*)i_QueryData;
        cCells = *reinterpret_cast<ULONG*>(i_QueryMeta);

        for ( dwCell = 0; dwCell < cCells; dwCell++)
        {
			if ( !(pQCells[dwCell].iCell & iST_CELL_SPECIAL) )
			{
				fFoundANonSpecialCell = TRUE;
			}
			else  // We are dealing with a special cell.
			{
				if (fFoundANonSpecialCell)
				{
                    //
					// By design, all special cells must preceed all non-special cells.	
                    //
                    hr = E_ST_INVALIDQUERY;
                    goto Cleanup;
				}

				if ( iST_CELL_LOCATION == pQCells[dwCell].iCell )
				{
					if ( NULL == pQCells[dwCell].pData )
                    {
                        hr = E_ST_INVALIDQUERY;
                        goto Cleanup;
                    }

					pwszNamespace = (LPWSTR)(pQCells[dwCell].pData);	
				}
			}				
        }
    }

    // 
    // Get the schema for this table that we would make use of during 
    // PopulateCache or UpdateStore.
    //
    
    hr = GetMeta(i_pISTDisp, i_wszTable);
    if ( FAILED(hr) )
    {
        goto Cleanup;
    }


    //
    // Depending on what the namespace is get the ASAI wiring information, i.e.
    // the ASAI path and ASAI class for this table.
    //
    
    hr = GetAsaiWiring(i_pISTDisp, i_wszTable, pwszNamespace, &m_pwszAsaiPath, &m_pwszAsaiClass);
    if ( FAILED(hr) )
    {
        goto Cleanup;
    }

    DBG_ASSERT(NULL != m_pwszAsaiPath);
    DBG_ASSERT(NULL != m_pwszAsaiClass);

    //
    // Store the table name.
    //

	m_wszTable = new WCHAR[wcslen(i_wszTable)+1];
	if ( m_wszTable == NULL ) 
    {
        hr = E_OUTOFMEMORY;	
        goto Cleanup;
    }
	wcscpy(m_wszTable, i_wszTable);

    //
    //  Get a cache that will store the ASAI data.
    //

    hr = i_pISTDisp->GetMemoryTable(
            i_wszDatabase, 
            i_wszTable, 
            i_TableID, 
            0, 
            0, 
            i_eQueryFormat, 
            i_fLOS, 
            reinterpret_cast<ISimpleTableWrite2 **>(o_ppvSimpleTable));
	if( FAILED(hr) )
    {
        goto Cleanup;
    }

Cleanup:

	return hr;

}

//
// ------------------------------------
// IInterceptorPlugin:
// ------------------------------------
//

/********************************************************************++
 
Routine Description:
 
    This method is used to retrieve data from ASAI and store in the 
    cache.
 
Arguments:
 
    i_pISTW2 - The cache to read the data into.

Notes:
 
Return Value:
 
    HRESULT.
 
--********************************************************************/
STDMETHODIMP 
CAsaiTable::OnPopulateCache(
	OUT ISimpleTableWrite2* o_pISTW2
    )
{
    CPopulateCacheAsaiTraverse cAsaiTraverse;
    IAppCenterObj *pIRoot = NULL; 
	ISimpleTableController* pISTController = NULL;
	HRESULT		hr = S_OK;

    DBG_ASSERT(NULL != o_pISTW2);

    //
    // Get the interface to handle the pre&post states of the cache.
    //

	hr = o_pISTW2->QueryInterface(IID_ISimpleTableController, (LPVOID *)&pISTController);		
    DBG_ASSERT(S_OK == hr);

    //
    // Get the cache state ready for population.
    //

	hr = pISTController->PrePopulateCache(0);
    DBG_ASSERT(S_OK == hr);

    hr = cAsaiTraverse.Init(m_pwszAsaiPath, m_aamColumnMeta, m_cColumns);
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "Init with %s on the ASAITraverse failed [0x%x]\n", m_pwszAsaiPath, hr));
        goto Cleanup;
    }

    hr = cAsaiTraverse.StartTraverse(o_pISTW2);
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "StartTraverse on the ASAITraverse failed [0x%x]\n", hr));
        goto Cleanup;
    }


Cleanup:

    if ( pISTController )
    {
        //
        // Done with populating the cache.
        //

        HRESULT hrTemp = pISTController->PostPopulateCache();
        DBG_ASSERT(S_OK == hrTemp);

    	pISTController->Release();
    }

	return hr;
}

/********************************************************************++
 
Routine Description:
 
    This method will persist the data in the cache into ASAI.
 
Arguments:
    
    i_pISTW2 - The cache to read the data from.

Notes:
 
Return Value:
 
    HRESULT.
 
--********************************************************************/
STDMETHODIMP 
CAsaiTable::OnUpdateStore(
	IN ISimpleTableWrite2* i_pISTW2
    )
{
	HRESULT		hr = S_OK;

	// Complete UpdateStore.
	hr = i_pISTW2->UpdateStore();
	if ( FAILED(hr) ) 
    { 
        goto Cleanup; 
    }

Cleanup:

	return hr;
}

/********************************************************************++
 
Routine Description:
 
    This method will get the ASAI path and ASAI class for the specified
    table.
 
Arguments:
    
    i_pISTW2 - The cache to read the data from.

Notes:
    If the namespace is the local namespace, then we'd need to get the
    local machine name and set it in the ASAI path.
 
Return Value:
 
    HRESULT.
 
--********************************************************************/
HRESULT
CAsaiTable::GetAsaiWiring(
	IN IAdvancedTableDispenser* i_pISTDisp,
    IN LPCWSTR  i_wszTable, 
    IN LPCWSTR  i_pwszNamespace, 
    OUT LPCWSTR *o_ppwszAsaiPath, 
    OUT LPCWSTR *o_ppwszAsaiClass)
{
	ISimpleTableRead2   *pISTAsaiWiring = NULL;
    ULONG               dwWiringRow = 0;
    LPVOID              rgpvKey[2] = { (LPVOID) i_wszTable, (LPVOID) i_pwszNamespace };
    tASAI_METARow       tamRow;
    HRESULT             hr = S_OK;

    //
    // Get the ASAI wiring table.
    // 

    hr = i_pISTDisp->GetTable(  wszDATABASE_ACFIXED, 
                                wszTABLE_ASAI_META, 
                                0,
                                NULL,
                                eST_QUERYFORMAT_CELLS,
                                0,
                                reinterpret_cast<LPVOID*>(&pISTAsaiWiring));
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "GetTable on the ASAI wiring failed [0x%x]\n", hr));
        goto Cleanup;
    }

    //
    // Get the wiring for this table and namespace.
    //

    hr = pISTAsaiWiring->GetRowIndexByIdentity( NULL, 
                                                rgpvKey, 
                                                &dwWiringRow);
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "GetRowIndexByIdentity on the ASAI wiring failed [0x%x]\n", hr));
        goto Cleanup;
    }

    hr = pISTAsaiWiring->GetColumnValues(   dwWiringRow,
                                            cASAI_META_NumberOfColumns,
                                            NULL,
                                            NULL,
                                            reinterpret_cast<LPVOID*>(&tamRow));
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "GetColumnValues on the ASAI wiring table failed [0x%x]\n", hr));
        goto Cleanup;
    }

    *o_ppwszAsaiPath = tamRow.pAsaiPath;
    *o_ppwszAsaiClass = tamRow.pAsaiClass;

    //
    // If the table is requested for the "local" machine, fix up the ASAI path.
    //

Cleanup:

    if ( pISTAsaiWiring )
    {
        pISTAsaiWiring->Release();
    }

    return hr;
}

/********************************************************************++
 
Routine Description:
 
    This method will get meta data from the fixed schema.
 
Arguments:
    
    i_pISTW2 - The cache to read the data from.

Notes:
    If the namespace is the local namespace, then we'd need to get the
    local machine name and set it in the ASAI path.
 
Return Value:
 
    HRESULT.
 
--********************************************************************/
HRESULT
CAsaiTable::GetMeta(
	IN IAdvancedTableDispenser* i_pISTDisp,
    IN LPCWSTR  i_wszTable)
{
	ISimpleTableRead2   *pISTColumnMeta = NULL;
    tCOLUMNMETARow      crColumnMeta = { 0 };
    DWORD               idxColumn = 0;
    HRESULT             hr = S_OK;
    STQueryCell		    aqcellMeta[] =  {   
        { (LPVOID)(i_wszTable), eST_OP_EQUAL, iCOLUMNMETA_Table, DBTYPE_WSTR, static_cast<ULONG>(wcslen(i_wszTable)) }
                                        };
    ULONG               dwCells = sizeof(aqcellMeta)/sizeof(aqcellMeta[0]);

    //
    // Get the ASAI wiring table.
    // 

    hr = i_pISTDisp->GetTable(  wszDATABASE_META, 
                                wszTABLE_COLUMNMETA, 
                                static_cast<LPVOID>(aqcellMeta),
                                &dwCells,
                                eST_QUERYFORMAT_CELLS,
                                0,
                                reinterpret_cast<LPVOID*>(&pISTColumnMeta));
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "GetTable on the COLUMNMETA table failed [0x%x]\n", hr));
        goto Cleanup;
    }

    //
    // How many columns does this table have?
    //

	hr = pISTColumnMeta->GetTableMeta (NULL, NULL, &m_cColumns, NULL);
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "GetTableMeta on the COLUMNMETA table failed [0x%x]\n", hr));
        goto Cleanup;
    }

    DBG_ASSERT(ASAI_MAX_COLUMNS >= m_cColumns);

    //
    // Get the meta for each column.
    //

    for (idxColumn = 0; idxColumn < m_cColumns; idxColumn++)
    {
        hr = pISTColumnMeta->GetColumnValues(   idxColumn, 
                                                cCOLUMNMETA_NumberOfColumns,
                                                NULL,
                                                NULL,
                                                reinterpret_cast<LPVOID*>(&crColumnMeta));
        if ( FAILED(hr) )
        {
            DBGERROR((DBG_CONTEXT, "GetColumnValues on the COLUMNMETA table failed [0x%x]\n", hr));
            goto Cleanup;
        }
    
        //
        // Hold onto data they might be of use. The data we are pointing to is owned by the fixed
        // table, and will always be around. No need to free them.
        //

        m_aamColumnMeta[idxColumn].pwszConfigName = crColumnMeta.pPublicName;
        m_aamColumnMeta[idxColumn].pwszAsaiName = crColumnMeta.pInternalName;

    }


Cleanup:

    if ( pISTColumnMeta )
    {
        pISTColumnMeta->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\asaitable\appcntadm_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for appcntadm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAppCenterObj,0x3D0F4830,0x4F1C,0x48A1,0xA9,0x60,0xC8,0x31,0x4A,0x9B,0xC6,0x44);


MIDL_DEFINE_GUID(IID, IID_IAppCenterCol,0xAD6E90A3,0x646C,0x4E63,0x95,0xA9,0x0F,0x42,0xB4,0x97,0x37,0xA8);


MIDL_DEFINE_GUID(IID, IID_IAppCenterNotify,0x25BDC24E,0xD545,0x4cfb,0xAC,0x40,0x32,0x58,0xC2,0x69,0x98,0x0C);


MIDL_DEFINE_GUID(IID, LIBID_APPCENTERADMLib,0x8A6A6B7F,0x3C46,0x48F6,0xB1,0xC8,0xA7,0x4D,0x55,0x7D,0x6A,0x70);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterObj,0x32D973BD,0xB935,0x4DE8,0xA8,0x81,0x6F,0x1A,0x9B,0x69,0x7E,0xA9);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterCol,0xB36311B9,0xD865,0x4332,0x8D,0x62,0x42,0x7A,0x86,0x75,0xC4,0xA9);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterServer,0x1AEFE812,0xFB0B,0x41f4,0x89,0x2A,0x02,0x8E,0x17,0x68,0x18,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterAdmin,0x200691B9,0xC444,0x4089,0x8C,0x61,0x24,0x76,0x21,0x19,0x6B,0x15);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterSystemApp,0x62A711CF,0x6729,0x4030,0xB4,0x7E,0x98,0x60,0x0F,0x68,0xAE,0x46);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterDefaultReplApp,0xF14FBB0A,0x296D,0x4e2e,0xAD,0xB2,0x04,0x1C,0xC6,0xE0,0x96,0x0D);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterAllSitesApp,0x2E3D9AEB,0x26BD,0x4f33,0x8E,0xC4,0xD6,0x90,0x7F,0x0F,0x15,0x2D);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterAppQueue,0xA5E079DF,0x79A6,0x401f,0xA2,0xDF,0x7B,0x40,0x56,0x6C,0x77,0x04);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for appcntadm.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAppCenterObj,0x3D0F4830,0x4F1C,0x48A1,0xA9,0x60,0xC8,0x31,0x4A,0x9B,0xC6,0x44);


MIDL_DEFINE_GUID(IID, IID_IAppCenterCol,0xAD6E90A3,0x646C,0x4E63,0x95,0xA9,0x0F,0x42,0xB4,0x97,0x37,0xA8);


MIDL_DEFINE_GUID(IID, IID_IAppCenterNotify,0x25BDC24E,0xD545,0x4cfb,0xAC,0x40,0x32,0x58,0xC2,0x69,0x98,0x0C);


MIDL_DEFINE_GUID(IID, LIBID_APPCENTERADMLib,0x8A6A6B7F,0x3C46,0x48F6,0xB1,0xC8,0xA7,0x4D,0x55,0x7D,0x6A,0x70);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterObj,0x32D973BD,0xB935,0x4DE8,0xA8,0x81,0x6F,0x1A,0x9B,0x69,0x7E,0xA9);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterCol,0xB36311B9,0xD865,0x4332,0x8D,0x62,0x42,0x7A,0x86,0x75,0xC4,0xA9);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterServer,0x1AEFE812,0xFB0B,0x41f4,0x89,0x2A,0x02,0x8E,0x17,0x68,0x18,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterAdmin,0x200691B9,0xC444,0x4089,0x8C,0x61,0x24,0x76,0x21,0x19,0x6B,0x15);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterSystemApp,0x62A711CF,0x6729,0x4030,0xB4,0x7E,0x98,0x60,0x0F,0x68,0xAE,0x46);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterDefaultReplApp,0xF14FBB0A,0x296D,0x4e2e,0xAD,0xB2,0x04,0x1C,0xC6,0xE0,0x96,0x0D);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterAllSitesApp,0x2E3D9AEB,0x26BD,0x4f33,0x8E,0xC4,0xD6,0x90,0x7F,0x0F,0x15,0x2D);


MIDL_DEFINE_GUID(CLSID, CLSID_AppCenterAppQueue,0xA5E079DF,0x79A6,0x401f,0xA2,0xDF,0x7B,0x40,0x56,0x6C,0x77,0x04);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\asaitable\traverse.cpp ===
// A helper class that encapsulates the namespace traversal via ASAI.
// 
// Requirements:
//      1. See if we can deal with variants and bstrs more efficiently.
//      2. A call initialed by a query should do minimal number of ASAI calls.
// 

#include "Traverse.h"
#include "coremacros.h"


/********************************************************************++
 
Routine Description:
 
Arguments:
 
Notes:
 
Return Value:
 
--********************************************************************/
HRESULT 
CAsaiTraverse::Init(
    IN LPCWSTR  i_pwszCollection,
    IN ASAIMETA *i_pamMeta,
    IN DWORD    i_cProperties
    )
{
    BSTR        bstrProperty = NULL;
    DWORD       cchPath = 0;
    DWORD       idxProperty = 0;
    DWORD       i = 0;
    HRESULT     hr = S_OK;

    DBG_ASSERT(NULL != i_pwszCollection);
    DBG_ASSERT(0 <= i_cProperties);
    DBG_ASSERT(ASAI_MAX_COLUMNS >= i_cProperties);

    //
    // Prepare the search path array that will be used during the recursive search.
    //

    cchPath = wcslen(i_pwszCollection);
    m_pwszCollection = new WCHAR [cchPath+1];
    if ( NULL == m_pwszCollection )
    {
        hr = E_OUTOFMEMORY;
        DBGERROR((DBG_CONTEXT, "Allocation failed [0x%x]\n", hr));
        goto Cleanup;
    }

    wcscpy(m_pwszCollection, i_pwszCollection);

    m_rgpwszPath[i++] = wcstok(m_pwszCollection, L"\\");
    while (NULL != (m_rgpwszPath[i] = wcstok(NULL, L"\\")))
    {
        i++;

        //
        // Make sure MAX_DEPTH really is the max depth and we don't overflow that array.
        //

        DBG_ASSERT((MAX_DEPTH + 1) > i);
    }

    //
    // Exract the keys, if there are any.
    //

    for ( ; i > 0; i--)
    {
        wcstok(m_rgpwszPath[i-1], L"=");
        m_rgpwszKey[i-1] = wcstok(NULL, L"=");
    }

    //
    // Create the Variant that holds the safearray of property names.
    // @TODO: This is PopulateCache relevant, should not be here.
    // 
 
    VariantInit(&m_varProperties);
    m_varProperties.vt = VT_ARRAY | VT_BSTR;

    m_varProperties.parray = SafeArrayCreateVector(VT_BSTR, 0, i_cProperties);
    if ( NULL == m_varProperties.parray )
    {
        hr = E_OUTOFMEMORY;
        DBGERROR((DBG_CONTEXT, "Allocation failed [0x%x]\n", hr));
        goto Cleanup;
    }

    //
    // Populate the safearray with ASAI property names.
    //

    for ( idxProperty = 0; idxProperty < i_cProperties; idxProperty++ )
    {
        bstrProperty = SysAllocString(i_pamMeta[idxProperty].pwszAsaiName);
        if ( NULL == bstrProperty )
        {
            hr = E_OUTOFMEMORY;
            DBGERROR((DBG_CONTEXT, "SysAllocString failed [0x%x]\n", hr));
            goto Cleanup;
        }

        hr = SafeArrayPutElement (m_varProperties.parray, reinterpret_cast<LONG *>(&idxProperty), bstrProperty);
        SysFreeString (bstrProperty); // free first to avoid leak
        if (FAILED (hr))
        {
            DBGERROR((DBG_CONTEXT, "SafeArrayPutElement failed [0x%x]\n", hr));
            goto Cleanup;
        }
    }

Cleanup:

    return hr;
}


/********************************************************************++
 
Routine Description:
 
Arguments:
 
Notes:
 
Return Value:
 
--********************************************************************/
HRESULT 
CAsaiTraverse::StartTraverse(
	OUT ISimpleTableWrite2* o_pISTW2
    )
{
    IAppCenterObj *pIRoot = NULL; 
    BSTR        bstrAsaiPath = NULL;
    BOOL        fDone = FALSE;
    HRESULT     hr = S_OK;
    //
    // Get the root ASAI object.
    //

    hr = CoCreateInstance(  CLSID_AppCenterAdmin, 
                            NULL,
                            CLSCTX_ALL,
                            IID_IAppCenterObj,
                            (void**)&pIRoot);
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "CoCreateInstance on the ASAI Root object failed [0x%x]\n", hr));
        goto Cleanup;
    }


    hr = Traverse(pIRoot, 0, &fDone, o_pISTW2);
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "Traverse failed [0x%x]\n", hr));
        goto Cleanup;
    }

Cleanup:

    if ( pIRoot )
    {
    	pIRoot->Release();
    }

    return hr;
}

/********************************************************************++
 
Routine Description:
 
Arguments:
 
Notes:
 
Return Value:
 
--********************************************************************/
HRESULT 
CAsaiTraverse::Traverse( 
    IN IAppCenterObj    *i_pParentObj,
    IN DWORD            i_dwDepth,
    IN OUT BOOL         *io_pfDone,
	OUT ISimpleTableWrite2* o_pISTW2
    )
{
    IAppCenterCol *pICol = NULL; 
    IAppCenterObj *pIChildObj = NULL; 
    VARIANT     varIndex;
    BSTR        bstrCollectionName;
    BOOL        fCorrectType = FALSE;
    HRESULT     hr = S_OK; 

    DBG_ASSERT(NULL != i_pParentObj);
    DBG_ASSERT(NULL != m_rgpwszPath[i_dwDepth]);

    bstrCollectionName = SysAllocString(m_rgpwszPath[i_dwDepth]);
    if ( NULL == bstrCollectionName )
    {
        hr = E_OUTOFMEMORY;
        DBGERROR((DBG_CONTEXT, "SysAllocString failed [0x%x]\n", hr));
        goto Cleanup;
    }

    //
    // Get the collection.
    //

    hr = i_pParentObj->GetCollection(bstrCollectionName, NULL, &pICol);
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "GetCollection of collection %s failed : 0x%x\n", m_rgpwszPath[i_dwDepth], hr));
        goto Cleanup;
    }

    //
    // Get the next collection name to traverse. If there is no next collection name,
    // then we found the final collection, i.e. the collection that represents this table.
    // 

    DBG_ASSERT( MAX_DEPTH+1 > i_dwDepth+1 )

    if ( NULL == m_rgpwszPath[i_dwDepth+1] )
    {
        //
        // Found a collection to process.
        //

        hr = ProcessCollection(pICol, o_pISTW2);
        if ( FAILED(hr) )
        {
            DBGERROR((DBG_CONTEXT, "GetCollection of collection %s failed : 0x%x\n", m_rgpwszPath[i_dwDepth], hr));
            goto Cleanup;
        }

    }
    else
    {

        //
        // Keep on traversing.
        //

        //
        // @TODO: use Next(colCount) instead...
        //
        VariantInit(&varIndex);
        varIndex.vt = VT_I4;
        varIndex.iVal = 0;

        while (pICol->get_Item(varIndex, &pIChildObj) == S_OK && !*io_pfDone)
        {
            //
            // Filter the collection, if necessary.
            //

            if ( m_rgpwszKey[i_dwDepth] )
            {
                hr = FilterByType(  pIChildObj, 
                                    m_rgpwszKey[i_dwDepth], 
                                    &fCorrectType);
                if ( FAILED(hr) )
                {
                    DBGERROR((DBG_CONTEXT, "FilterByType failed : 0x%x\n", hr));
                    goto Cleanup;
                }


                if (!fCorrectType)
                {
                    pIChildObj->Release();
                    varIndex.iVal++;
                    continue;
                }
            }

            //
            // Recurse.
            //

            hr = Traverse(  pIChildObj, 
                            i_dwDepth+1, 
                            io_pfDone, 
                            o_pISTW2);
            if ( FAILED(hr) )
            {
                DBGERROR((DBG_CONTEXT, "Traverse failed : 0x%x\n", hr));
                goto Cleanup;
            }

            pIChildObj->Release();
            varIndex.iVal++;
        }
    }

Cleanup:

    if ( pIChildObj )
    {
    	pIChildObj->Release();
    }

    if ( pICol )
    {
    	pICol->Release();
    }

    return hr; 

}

/********************************************************************++
 
Routine Description:
 
Arguments:
 
Notes:
 
Return Value:
 
--********************************************************************/
HRESULT CAsaiTraverse::FilterByType(
    IN IAppCenterObj    *i_pIObj,
    IN LPCWSTR          i_pwszASAIClassName,
    OUT BOOL            *o_pfCorrectType)
//
// Routine Description:
//  This method filter heterogenous collections, such as the Objects 
//  collection on the Root object.
//
// Arguments:
//
// Return Value:
//

{
    VARIANT     varPropValue;
    BSTR        bstrASAIPropName;
    HRESULT     hr = S_OK;
    
    *o_pfCorrectType = FALSE;

    bstrASAIPropName = SysAllocString(L"Class");
    if ( NULL == bstrASAIPropName )
    {
        hr = E_OUTOFMEMORY;
        DBGERROR((DBG_CONTEXT, "SysAllocString failed [0x%x]\n", hr));
        goto Cleanup;
    }

    hr = i_pIObj->get_Value(bstrASAIPropName, &varPropValue);
    if ( FAILED(hr) )
    {
        DBGERRORW((DBG_CONTEXT,L"get_Value of %s failed : 0x%x\n", bstrASAIPropName, hr));
        goto Cleanup;
    }

    if ( 0 == _wcsicmp(varPropValue.bstrVal, i_pwszASAIClassName) )
    {
        *o_pfCorrectType = TRUE;
    }

Cleanup:

    VariantClear(&varPropValue);
    if (bstrASAIPropName)
    {
        SysFreeString(bstrASAIPropName);
    }
    return hr;
}


/********************************************************************++
 
Routine Description:
 
Arguments:
 
Notes:
 
Return Value:
 
--********************************************************************/
HRESULT
CPopulateCacheAsaiTraverse::ProcessCollection(
    IN IAppCenterCol* i_pCol,
	OUT ISimpleTableWrite2* o_pISTW2
    )
{
    VARIANT     *pvarValues = NULL;
    SAFEARRAY   *psaValues = NULL;
    LONG        cObjects = 0; 
    LONG        idxObject = 0;
    DWORD       idxProperty = 0;
    DWORD       dwWriteRow = 0;
    LPVOID      apv[ASAI_MAX_COLUMNS];
    HRESULT     hr = S_OK; 

    //
    // Get the count of objects in this collection.
    //

    hr = i_pCol->get_Count(&cObjects);
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "get_Count() failed on the collection with error [0x%x]\n", hr));
        goto Cleanup;
    }

    //
    // If there aren't any objects in the collection, we are done.
    //
    
    if ( 0 == cObjects )
    {
        goto Cleanup;
    }

    //
    // Get all the properties defined on this table, from all the objects in 
    // collection. 
    // @TODO: Verify that NextEx works with large number of elements: 10000.
    //

    hr = i_pCol->NextEx(cObjects, m_varProperties, &psaValues);
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "NextEx() failed on the collection with error [0x%x]\n", hr));
        goto Cleanup;
    }

    //
    // @TODO: Do more validations on the psaValues.
    //

    DBG_ASSERT(cObjects * m_varProperties.parray->rgsabound->cElements == psaValues->rgsabound->cElements);

    hr = SafeArrayAccessData (psaValues, reinterpret_cast<void **>(&pvarValues));
    if ( FAILED(hr) )
    {
        DBGERROR((DBG_CONTEXT, "SafeArrayAccessData failed with error [0x%x]\n", hr));
        goto Cleanup;
    }
    

    for ( idxObject = 0; idxObject < cObjects; idxObject++ )
    {
        //
        // Add a new row to the cache.
        //
        
        hr = o_pISTW2->AddRowForInsert(&dwWriteRow);
        if ( FAILED(hr) )
        {
            DBGERROR((DBG_CONTEXT, "AddRowForInsert failed with error [0x%x]\n", hr));
            goto Cleanup;
        }

        //
        // Get the property values that need to be set.
        //
            
        for (   idxProperty = 0; 
                idxProperty < m_varProperties.parray->rgsabound->cElements; 
                idxProperty++, pvarValues++ )
        {
            if (pvarValues->vt == VT_BSTR)
            {
                apv[idxProperty] = pvarValues->bstrVal;
            }
            else if (pvarValues->vt == VT_I4)
            {
                apv[idxProperty] = &pvarValues->ulVal;
            }
            else
            {
                apv[idxProperty] = NULL;
                DBGERROR((DBG_CONTEXT, "Not yet implemented"));
            }
        }

        //
        // Set the property values.
        //

        hr = o_pISTW2->SetWriteColumnValues(dwWriteRow, m_varProperties.parray->rgsabound->cElements, NULL, NULL, apv);
        if ( FAILED(hr) )
        {
            DBGERROR((DBG_CONTEXT, "AddRowForInsert failed with error [0x%x]\n", hr));
            goto Cleanup;
        }
    }

Cleanup:

    if ( pvarValues )
    {
        hr = SafeArrayUnaccessData(psaValues);
        if ( FAILED(hr) )
        {
            DBGERROR((DBG_CONTEXT, "SafeArrayUnaccessData failed with error [0x%x]\n", hr));
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\asaitable\asaitable.h ===
/********************************************************************++
 
Copyright (c) 2001 Microsoft Corporation
 
Module Name:
 
    ASAITable.cpp
 
Abstract:
 
    This file contains the implementation of the ASAI interceptor. This
	interceptor is implemented as an InterceptorPlugin, therefore needs
	to implement only three methods: Intercept, OnPopulateCache, and 
	OnUpdateStore.
    
Author:
 
    Murat Ersan (murate)        10-Apr-2001
 
Revision History:
 
--********************************************************************/

#pragma once

#include "catalog.h"
#include "coremacros.h"

struct ASAIMETA
{
    LPCWSTR     pwszConfigName;
    LPCWSTR     pwszAsaiName;
};

#define ASAI_MAX_COLUMNS    20          // No ASAI table has more than this many properties.

/********************************************************************++
 
Class Name:
 
    CAsaiTable
 
Class Description:
 
    The ASAI interceptor.
 
Notes:
     
    All failures of the publc api's will lead to the destruction of the 
    instance which will cleanup any allocated memory.

 
--********************************************************************/
class CAsaiTable:
	public IInterceptorPlugin
{

public:

	CAsaiTable() 
		:   m_wszTable(NULL), 
            m_cRef(0),
            m_pwszAsaiPath(NULL),
	        m_pwszAsaiClass(NULL),
            m_cColumns(0)
	{}

	~CAsaiTable() 
	{
		if (m_wszTable)
		{
			delete [] m_wszTable;
		}
	}

    //
	// IUnknown
    //

	STDMETHOD (QueryInterface)(
        IN REFIID riid, 
        OUT void **ppv
        );

	STDMETHOD_(ULONG,AddRef)();

	STDMETHOD_(ULONG,Release)();

    //
	// ISimpleTableInterceptor:
    //

	STDMETHOD(Intercept)(
	    IN LPCWSTR 	i_wszDatabase,
	    IN LPCWSTR 	i_wszTable, 
	    IN ULONG	i_TableID,
	    IN LPVOID	i_QueryData,
	    IN LPVOID	i_QueryMeta,
	    IN DWORD	i_eQueryFormat,
	    IN DWORD	i_fLOS,
	    IN IAdvancedTableDispenser* i_pISTDisp,
	    IN LPCWSTR	i_wszLocator,
	    IN LPVOID	i_pSimpleTable,
	    OUT LPVOID*	o_ppvSimpleTable
        );

    //
	// IInterceptorPlugin:
    //

	STDMETHOD(OnPopulateCache)(
        OUT ISimpleTableWrite2* o_pISTShell
        );

	STDMETHOD(OnUpdateStore)(
        IN ISimpleTableWrite2* i_pISTShell
        );

private:

    HRESULT
    GetMeta(
	    IN IAdvancedTableDispenser* i_pISTDisp,
        IN LPCWSTR  i_wszTable
        );

    HRESULT
    GetAsaiWiring(
    	IN IAdvancedTableDispenser* i_pISTDisp,
        IN LPCWSTR  i_wszTable, 
        IN LPCWSTR  i_pwszNamespace, 
        OUT LPCWSTR *o_ppwszAsaiPath, 
        OUT LPCWSTR *o_ppwszAsaiClass
        );


private:
	LPWSTR	m_wszTable;
	ULONG   m_cRef;

    LPCWSTR	m_pwszAsaiPath;     // Not allocated, no need to free.
	LPCWSTR	m_pwszAsaiClass;    // Not allocated, no need to free.

    ASAIMETA m_aamColumnMeta[ASAI_MAX_COLUMNS];
    DWORD   m_cColumns;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\complibtable\clbdtdisp.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
// CORDataTable.h: Definition of the CCORDataTable class
//
//////////////////////////////////////////////////////////////////////
#ifndef _CORDATATABLE_H_
#define _CORDATATABLE_H_


//#include <oledb.h>
//#include <activeds.h>
//#include "oledbhlp.h"
#include "catalog.h"
#include "iregnode.h"
#include "utsem.h"

// type definition for the functions we obtain via GetProcAddress
//typedef HRESULT( __stdcall *PFNCoCreateInstance)( REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID);


interface IComponentRecords;
interface ISimpleTableInterceptor;
/////////////////////////////////////////////////////////////////////////////
// CCLBDTDispenser

class CCLBDTDispenser : 
	public ISimpleTableInterceptor
{
public:
	CCLBDTDispenser();
	~CCLBDTDispenser();


public:

	//IUnknown

	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

	//ISimpleDataTable
	STDMETHOD(Intercept)( 
		LPCWSTR					i_wszDatabase,
		LPCWSTR					i_wszTable,
		ULONG					i_TableID,
		LPVOID					i_QueryData,
		LPVOID					i_QueryMeta,
		ULONG					i_QueryType,
		DWORD					i_fTable,
		IAdvancedTableDispenser* i_pISTDisp,
		LPCWSTR					i_wszLocator,
		LPVOID					i_pSimpleTable,
		LPVOID*					o_ppv);

private:

  ULONG       m_cRef;
  IComponentRecords*  m_pICR;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\complibtable\clbdtdisp.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
// CORDataTable.cpp : Implementation of CSdtcorclbApp and DLL registration.

//#include "stdafx.h"

#include "CLBDTDisp.h"
#include <oledb.h>
#include "complib.h"
#include "icmprecsts.h"
#include "metaerrors.h"	//error codes for CLB

//reg schema
#include "comregStructs.h"
#include "comregBlobs.h"


#include "catmeta.h"
#include "simpletablec.h"

#include <tchar.h>
#include "clbread.h"
#include "clbwrite.h"
#include "catmacros.h"
#include "atlbase.h"

////////////////////////////////////////////////////////////////////////////
//
//CMapStringToPtr CCLBDTDispenser::m_mapPathToICR;


CCLBDTDispenser::CCLBDTDispenser()
:m_cRef(0)
{

}

CCLBDTDispenser::~CCLBDTDispenser()
{
	
}

HRESULT STDMETHODCALLTYPE CCLBDTDispenser::Intercept( 
	LPCWSTR					i_wszDatabase,
	LPCWSTR					i_wszTable,
	ULONG					i_TableID,
	LPVOID					i_QueryData,
	LPVOID					i_QueryMeta,
	ULONG					i_QueryType,
	DWORD					i_fTable,
	IAdvancedTableDispenser* i_pISTDisp,
	LPCWSTR					i_wszLocator,
	LPVOID					i_pSimpleTable,
	LPVOID*					o_ppv)
{

	CComPtr<IComponentRecords> pICR;
	CComPtr<ISimpleTableWrite2>pISTWrite;	
	CSimpleTable* pCST = NULL;
	HRESULT hr = S_OK;
	int tableIndex;
	TABLEID tableid;
	int i;
	LPWSTR wszTableIndex = NULL, wszFileName = NULL, wszPound = NULL;
	ULONG nQueryCells;
	COMPLIBSCHEMA complibSchema;
	COMPLIBSCHEMABLOB sSchemaBlob;
	ULONG *psnid = NULL;
	BOOL fFoundANonSpecialCell = FALSE;

    if ( !i_wszLocator )
		return E_INVALIDARG;
	if ( i_pSimpleTable)
		return E_INVALIDARG;

	//Check table flags
    if(fST_LOS_MARSHALLABLE & i_fTable)
	{
		return E_ST_LOSNOTSUPPORTED;
	}


	wszTableIndex = (LPWSTR)i_wszLocator;
	tableIndex = wcstol(wszTableIndex, NULL, 10);
	
	nQueryCells = i_QueryMeta ? *(ULONG*)i_QueryMeta : 0;

	//Get file name and snap shot id from the query cells
	if ( i_QueryData )
	{
		STQueryCell* pQCells = (STQueryCell*)i_QueryData;

		for ( ULONG iSpecial = 0; iSpecial < nQueryCells; iSpecial++ )
		{
			if ( !(pQCells[iSpecial].iCell & iST_CELL_SPECIAL) )
			{
				fFoundANonSpecialCell = TRUE;
			}
			else  // We are dealing with a special cell.
			{
				if (fFoundANonSpecialCell)
				{
					// By design, all special cells must preceed all non-special cells.	
					return (E_ST_INVALIDQUERY);	
				}

				if ( pQCells[iSpecial].iCell == iST_CELL_FILE )
				{
					if ( NULL == pQCells[iSpecial].pData )
						return (E_ST_INVALIDQUERY);	

					wszFileName = (LPWSTR)(pQCells[iSpecial].pData);	
				
				}
				else if ( pQCells[iSpecial].iCell == iST_CELL_SNID )
				{
					if ( NULL == pQCells[iSpecial].pData )
						return (E_ST_INVALIDQUERY);	
				
					psnid = (ULONG*)(pQCells[iSpecial].pData);
					if ( 0 == *psnid )	//snap shot id should always be positive
						return (E_ST_INVALIDSNID);	
				}
			}				
		}				
	}

	//Writing has to go through the complib data table derived from sdtfst except for Cookdown
	// @TODO: Until we make the CSimpleTable class encryption aware, both reads and writes will
	// go through the CSimpleTableC. This will only effect cookdown.
//	if ( fST_LOS_READWRITE & i_fTable )
//	{
	    hr = i_pISTDisp->GetMemoryTable(i_wszDatabase, i_wszTable, i_TableID, 0, 0, i_QueryType, i_fTable, reinterpret_cast<ISimpleTableWrite2 **>(&pISTWrite));
		if(FAILED(hr))return hr;

		CSimpleTableC* pCSTC = new CSimpleTableC( tableIndex, i_fTable );
		if ( NULL == pCSTC )
			return E_OUTOFMEMORY;
		
		hr = pCSTC->Initialize( reinterpret_cast<STQueryCell*>(i_QueryData), nQueryCells, i_pISTDisp, pISTWrite,
								i_wszDatabase, i_wszTable, wszFileName );
		if ( FAILED (hr) ) return hr;
		
		pCSTC->AddRef();
		
		*o_ppv = (LPVOID ) pCSTC;
		return S_OK;
//	}	
	

	//Find the matching schema for this wszDatabase, get the ICR for this file.
	if ( wszFileName )
	{
		hr = _CLBGetSchema( i_wszDatabase, &complibSchema, &sSchemaBlob, NULL );
		if ( FAILED(hr) ) return hr;
		hr = CLBGetReadICR(wszFileName, &pICR, &complibSchema, &sSchemaBlob, psnid );
	}
	else
	{
		hr = _CLBGetSchema( i_wszDatabase, &complibSchema, &sSchemaBlob, &wszFileName );
		if ( FAILED(hr) ) return hr;
		hr = CLBGetReadICR(wszFileName, &pICR, &complibSchema, &sSchemaBlob, psnid );
		delete [] wszFileName;
		wszFileName = NULL;
	}

	
	if ( FAILED (hr) )
		return hr;

	hr = pICR->OpenTable(&complibSchema, tableIndex, &tableid );
	


	if ( FAILED(hr) ) return hr;
	
	pCST = new CSimpleTable ( tableid, pICR, i_fTable );
	if ( pCST == NULL )
		return E_OUTOFMEMORY;

	pCST->AddRef();

	hr = pCST->Initialize ( (STQueryCell*)i_QueryData,nQueryCells, i_pISTDisp, i_wszDatabase, i_wszTable );
	if ( FAILED(hr) ) return hr;

	*o_ppv = (LPVOID ) pCST;

	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\complibtable\cryptohlp.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include "CryptoHlp.h"
#include "catmacros.h"

VOID
IISInitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection)
{
	InitializeCriticalSection(lpCriticalSection);
}


// ==================================================================
// This is a helper function to initialize the crypto storage object.
// This will be used to encrypt and decrypt data.
// The crypto storage object needs a session key that we will store in 
// the clb file.
// The logic is as follows:
//
//		Read the session key from the clb file.
//		If not in clb
//			Initialize the crypto storage with no session key.
//			Generate a session key.
//			Write it to the clb.
//			Done
//		Init the crypto storage with the session key.
//
// ==================================================================
HRESULT GetCryptoStorage(
	IIS_CRYPTO_STORAGE *i_pCryptoStorage,
	LPCWSTR		i_wszCookdownFile,
    DWORD       i_fTable,
	BOOL		i_bUpdateStore)
{
	ISimpleTableDispenser2 *pISTDisp = NULL;
	ISimpleTableWrite2 *pISTSessionKey = NULL;
	PIIS_CRYPTO_BLOB pSessionKeyBlob = NULL;
	STQueryCell	QueryCell[1];
	ULONG		cCell = sizeof(QueryCell)/sizeof(STQueryCell);
	ULONG		iCol = iSESSIONKEY_SessionKey;
	BYTE*		pbSessionKey = NULL;
	ULONG		cbSessionKey = 0;
	ULONG		iWriteRow = 0;
	HRESULT		hr = S_OK;

	hr = IISCryptoInitialize();
    if (FAILED(hr)) 
	{
		TRACE(L"[GetCryptoStorage] IISCryptoInitialize failed with hr = 0x%x.\n", hr);
		return hr;
	}

	//
	// Read the session key from the clb file.
	//

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

	if(FAILED(hr))
	{
        TRACE(L"[GetCryptoStorage]: GetSimpleTableDispenser Failed - error 0x%0x\n", hr);
		return hr;
	}

    QueryCell[0].pData     = (LPVOID)i_wszCookdownFile;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(i_wszCookdownFile)+1)*sizeof(WCHAR);

	hr = pISTDisp->GetTable(wszDATABASE_IIS,
						    wszTABLE_SESSIONKEY,
							(LPVOID)QueryCell,
							(LPVOID)&cCell,
							eST_QUERYFORMAT_CELLS,
							i_fTable,
							(LPVOID *)&pISTSessionKey);

	if(FAILED(hr))
	{
        TRACE(L"[GetCryptoStorage]: ISimpleTableDispenser2::GetTable Failed - error 0x%0x\n", hr);
		goto Cleanup;
	}

	hr = pISTSessionKey->GetColumnValues(0,
		                                1,
										&iCol,
										&cbSessionKey,
										(LPVOID*)&pbSessionKey);
	//
	// If not in clb.
	//
	if(E_ST_NOMOREROWS == hr)
	{
		ASSERT(i_bUpdateStore);

		// Initialize the crypto storage with no session key.
		hr = i_pCryptoStorage->Initialize(
                     TRUE,                          // fUseMachineKeyset
                     CRYPT_NULL
                     );
		if (FAILED(hr))
		{
			TRACE(L"[GetCryptoStorage]: pCryptoStorage->Initialize Failed - error 0x%0x\n", hr);
			return hr;
		}

		// Generate a session key.
		hr = i_pCryptoStorage->GetSessionKeyBlob( &pSessionKeyBlob );
		if (FAILED(hr))
		{
			TRACE(L"[GetCryptoStorage]: pCryptoStorage->GetSessionKeyBlob Failed - error 0x%0x\n", hr);
			goto Cleanup;
		}
		cbSessionKey = IISCryptoGetBlobLength(pSessionKeyBlob);

		// Write it to the clb.
		hr = pISTSessionKey->AddRowForInsert(&iWriteRow);
		if (FAILED(hr))
		{
			TRACE(L"[GetCryptoStorage]: ISimpleTableWrite2::AddRowForInsert Failed - error 0x%0x\n", hr);
			goto Cleanup;
		}

		hr = pISTSessionKey->SetWriteColumnValues(iWriteRow,
													1,
													&iCol,
													&cbSessionKey,
													(LPVOID*)&pSessionKeyBlob);
		if (FAILED(hr))
		{
			TRACE(L"[GetCryptoStorage]: ISimpleTableWrite2::SetWriteColumnValues Failed - error 0x%0x\n", hr);
			goto Cleanup;
		}

		hr = pISTSessionKey->UpdateStore();
		if (FAILED(hr))
		{
			TRACE(L"[GetCryptoStorage]: ISimpleTableWrite2::UpdateStore Failed - error 0x%0x\n", hr);
			goto Cleanup;
		}

		// Done
		hr = S_OK;
		goto Cleanup;
	}
	else if (FAILED(hr))
	{
		TRACE(L"[GetCryptoStorage]: ISimpleTableWrite2::GetColumnValues Failed - error 0x%0x\n", hr);
		goto Cleanup;
	}

	// Init the crypto storage with the session key.
    hr = ::IISCryptoCloneBlobFromRawData(
                   &pSessionKeyBlob,
                   pbSessionKey,
                   cbSessionKey
                   );
	if (FAILED(hr))
	{
        TRACE(L"[GetCryptoStorage]: ::IISCryptoCloneBlobFromRawData Failed - error 0x%0x\n", hr);
		goto Cleanup;
	}

    hr = i_pCryptoStorage->Initialize(
                         pSessionKeyBlob,
                         TRUE,                          // fUseMachineKeyset
                         CRYPT_NULL
                         );
    if (FAILED(hr))
    {
        TRACE(L"[GetCryptoStorage]: pCryptoStorage->Initialize Failed - error 0x%0x\n", hr);
    }

Cleanup:

	if (pSessionKeyBlob)
	{
		::IISCryptoFreeBlob(pSessionKeyBlob);
	}

	if (pISTSessionKey)
	{
		pISTSessionKey->Release();
	}

	if (pISTDisp)
	{
		pISTDisp->Release();
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\complibtable\sdtclb_com.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include <objbase.h>

#include "clbdtdisp.h"
#include "catmacros.h"

static CCLBDTDispenser* g_pDTDisp = NULL;
static UTSemReadWrite g_lock(400);

#include "clbread.h"
extern CMapICR		g_mapWriteICR;
extern CLBREAD_STATE g_CLBReadState;
extern CSNMap g_snapshotMap;
// -----------------------------------------
// sdtclb: Dll*:
// -----------------------------------------

HRESULT SdtClbOnProcessAttach(void)
{
	g_CLBReadState.pISTReadDatabaseMeta = NULL;
	g_CLBReadState.pISTReadColumnMeta = NULL;
	g_CLBReadState.bInitialized = FALSE;
	g_CLBReadState.pAcl = NULL;
	g_CLBReadState.psa = NULL;
	return S_OK;
}



void SdtClbOnProcessDetach(void)
{
		if ( g_pDTDisp )
			g_pDTDisp->Release();

		g_mapWriteICR.ResetMap();
		g_CLBReadState.mapReadICR.ResetMap();
		g_snapshotMap.ResetMap();
		if ( g_CLBReadState.pISTReadDatabaseMeta )
			g_CLBReadState.pISTReadDatabaseMeta->Release();

		if ( g_CLBReadState.pISTReadColumnMeta )
			g_CLBReadState.pISTReadColumnMeta->Release();

		delete g_CLBReadState.pAcl;
}

// ==================================================================
HRESULT GetCLBTableDispenser (REFIID riid, LPVOID* ppv)
{
	HRESULT hr;
	
// Parameter checks:
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if ( g_pDTDisp == NULL )
	{

		//write lock
		UTSemRWMgrWrite lockMgr( &g_lock );

		if ( g_pDTDisp == NULL )
		{

			g_pDTDisp = new CCLBDTDispenser;
			if (NULL == g_pDTDisp)
				return E_OUTOFMEMORY;
			g_pDTDisp->AddRef();
		}
	}
	
// Create the class object:
	return ( g_pDTDisp->QueryInterface (riid, ppv) );

}

// -----------------------------------------
// CCLBDTDispenser: IUnknown and IClassFactory:
// -----------------------------------------

// =======================================================================
STDMETHODIMP CCLBDTDispenser::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_ISimpleTableInterceptor)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}

	if (NULL != *ppv)
	{
		AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CCLBDTDispenser::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

// =======================================================================
STDMETHODIMP_(ULONG) CCLBDTDispenser::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\complibtable\cryptohlp.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#pragma once
#include <windows.h>
#include <stdlib.h>
#include <icrypt.hxx>

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

VOID
IISInitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection);

# ifdef __cplusplus
};
# endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\complibtable\simpletablec.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
//simpletableC.h
//Define the CSimpleTableC class, the complib datatable that uses fast cache
//*****************************************************************************
#pragma once

#include "sdtfst.h"
#include "simpletable.h"
#include <icrypt.hxx>

class CSimpleTableC :   public ISimpleTableWrite2,
                        public ISimpleTableController
{

public:
   
	 CSimpleTableC ( ULONG tableIndex,
                     DWORD fTable);   

    
    ~CSimpleTableC ();
    
   
///////////////////////////////////////////////////////////////////
// IUnknown Interface
//
    virtual HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID riid, PVOID *pp);

    virtual ULONG STDMETHODCALLTYPE AddRef ()
    { return (InterlockedIncrement((long *) &m_cRef)); }

    virtual ULONG STDMETHODCALLTYPE Release ()
    {
        ULONG   cRef;
        if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
            delete this;
        return (cRef);
    }

///////////////////////////////////////////////////////////////////
// ISimpleTableRead2 interface
//

    virtual HRESULT STDMETHODCALLTYPE GetRowIndexByIdentity ( 
            ULONG *i_acb,
            LPVOID *i_apv,
            ULONG* o_piRow);
            
    virtual HRESULT STDMETHODCALLTYPE GetRowIndexBySearch (
            ULONG   i_iStartingRow,
            ULONG   i_cColumns,
            ULONG*  i_aiColumns,
            ULONG*  i_acbSizes,
            LPVOID* i_apvValues,
            ULONG* o_piRow){return E_NOTIMPL;}

    virtual HRESULT STDMETHODCALLTYPE GetColumnValues(
            ULONG i_iRow,
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            ULONG* o_acbSizes, 
            LPVOID* o_apvValues);

    virtual HRESULT STDMETHODCALLTYPE GetTableMeta(
            ULONG* o_pcVersion, 
            DWORD* o_pfTable,
            ULONG* o_pcRows, 
            ULONG* o_pcColumns);

    virtual HRESULT STDMETHODCALLTYPE GetColumnMetas(
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            SimpleColumnMeta* o_aColumnMetas );


///////////////////////////////////////////////////////////////////
// ISimpleTableWrite2 interface
//
    virtual HRESULT STDMETHODCALLTYPE AddRowForDelete (ULONG i_iReadRow);

    virtual HRESULT STDMETHODCALLTYPE AddRowForInsert   (ULONG* o_piWriteRow);
    
    virtual HRESULT STDMETHODCALLTYPE AddRowForUpdate   (ULONG i_iReadRow, ULONG* o_piWriteRow);

    virtual HRESULT STDMETHODCALLTYPE GetWriteColumnValues  (
            ULONG i_iRow,
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            DWORD* o_afStatus, 
            ULONG* o_acbSizes, 
            LPVOID* o_apvValues);

    virtual HRESULT STDMETHODCALLTYPE SetWriteColumnValues  (
            ULONG i_iRow,
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            ULONG* i_acbSizes, 
            LPVOID* i_apvValues);

    virtual HRESULT STDMETHODCALLTYPE GetWriteRowIndexByIdentity(ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);

	virtual HRESULT STDMETHODCALLTYPE GetWriteRowIndexBySearch (
            ULONG   i_iStartingRow,
            ULONG   i_cColumns,
            ULONG*  i_aiColumns,
            ULONG*  i_acbSizes,
            LPVOID* i_apvValues,
            ULONG* o_piRow){return E_NOTIMPL;}

    virtual HRESULT STDMETHODCALLTYPE GetErrorTable (
            DWORD   i_fServiceRequests,
            LPVOID* o_ppvSimpleTable){return E_NOTIMPL;}

    virtual HRESULT STDMETHODCALLTYPE UpdateStore ( void );

///////////////////////////////////////////////////////////////////
// ISimpleTableAdvanced interface
//
    virtual HRESULT STDMETHODCALLTYPE PopulateCache ( void );

    virtual HRESULT STDMETHODCALLTYPE GetDetailedErrorCount(ULONG* o_pcErrs);
    virtual HRESULT STDMETHODCALLTYPE GetDetailedError(ULONG i_iErr, STErr* o_pSTErr);

    ///////////////////////////////////////////////////////////////////            
//ISimpleTableController
public:
    virtual HRESULT STDMETHODCALLTYPE ShapeCache (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes);
    virtual HRESULT STDMETHODCALLTYPE PrePopulateCache  (DWORD i_fControl);
    virtual HRESULT STDMETHODCALLTYPE PostPopulateCache ();
    virtual HRESULT STDMETHODCALLTYPE DiscardPendingWrites ();

    virtual HRESULT STDMETHODCALLTYPE  GetWriteRowAction        (ULONG i_iRow, DWORD* o_peAction);
    virtual HRESULT STDMETHODCALLTYPE  SetWriteRowAction        (ULONG i_iRow, DWORD i_eAction);
    virtual HRESULT STDMETHODCALLTYPE  ChangeWriteColumnStatus  (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus);

    virtual HRESULT STDMETHODCALLTYPE  AddDetailedError (STErr* o_pSTErr);

    virtual HRESULT STDMETHODCALLTYPE  GetMarshallingInterface (IID * o_piid, LPVOID * o_ppItf);

// native methods.
    HRESULT Initialize( STQueryCell* i_aQueryCell, ULONG i_nQueryCells, IAdvancedTableDispenser*	pISTDisp,
						ISimpleTableWrite2* i_pISTWrite, LPCWSTR wszDatabase, LPCWSTR wszTable, LPWSTR wszFileName );

private:
    ULONG       m_cRef;
    
    //Query info
    QUERYHINT   *m_pQryHint;   
    WCHAR        m_szIndexName[MAX_QRYDEX_NAME];
    ULONG       m_cQryColumns;  //column count
    ULONG       *m_rgiColumn;   //ordinals
    DBCOMPAREOP *m_rgfCompare;  //Operators. Always NULL for now.
    LPVOID      *m_rgpbData;    //data
    ULONG       *m_rgcbData;    //sizes
    DBTYPE      *m_rgiType;


    //PK info
    ULONG       m_cPKColumns;
    QUERYHINT   m_PKQryHint;
    ULONG       m_aPKColumns[MAX_PK_COLUMNS];
    DBTYPE      m_aPKTypes[MAX_PK_COLUMNS];

    //Table Meta
    DWORD               m_fTable;                   //Table flag
    ULONG               m_cColumns;                 //Count of columns
    SimpleColumnMeta    *m_pColumnMeta;             //Column meta
	DWORD				*m_pColumnAttrib;			//Column attributes, e.g. Secure.
	BOOL				m_bRequiresEncryption;		//Does this table require encryption.

	LPWSTR              m_wszFileName;              //File name if any
	//Complib schema and blob
	COMPLIBSCHEMA		m_complibSchema;	
	COMPLIBSCHEMABLOB	m_sSchemaBlob;
	

    ULONG       m_tableIndex;

    //Buffers for getting and setting data.
    LPVOID*         m_pData;
    DBTYPE*         m_iType;
    ULONG*          m_cbBuf;
    ULONG*          m_pcbBuf;
    HRESULT*        m_colhr;
    LPVOID*			m_pBlob;

	ISimpleTableWrite2 *m_pISTWrite;
	ISimpleTableController *m_pISTController;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\complibtable\simpletable.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#ifndef _SIMPLETABLE_H_
#define _SIMPLETABLE_H_

#include "objbase.h"
#include "catalog.h"
#include "complib.h"
#include "icmprecsts.h"

// constant definitions.
#define MAX_QRYDEX_NAME     64
#define MAX_PK_COLUMNS      8
#define FAKE_INDEX_BIT     0xF0000000L

class CSimpleTable :    public ISimpleTableWrite2,
                        public ISimpleTableAdvanced 
{

public:
  
    CSimpleTable ( TABLEID tableid, IComponentRecords* pICR,
                   DWORD fTable );   

    
    ~CSimpleTable ();
    
   
///////////////////////////////////////////////////////////////////
// IUnknown Interface
//
    virtual HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID riid, PVOID *pp);

    virtual ULONG STDMETHODCALLTYPE AddRef ()
    { return (InterlockedIncrement((long *) &m_cRef)); }

    virtual ULONG STDMETHODCALLTYPE Release ()
    {
        ULONG   cRef;
        if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
            delete this;
        return (cRef);
    }

///////////////////////////////////////////////////////////////////
// ISimpleTableRead2 interface
//

    virtual HRESULT STDMETHODCALLTYPE GetRowIndexByIdentity ( 
            ULONG *i_acb,
            LPVOID *i_apv,
            ULONG* o_piRow);
            
    virtual HRESULT STDMETHODCALLTYPE GetRowIndexBySearch (
            ULONG   i_iStartingRow,
            ULONG   i_cColumns,
            ULONG*  i_aiColumns,
            ULONG*  i_acbSizes,
            LPVOID* i_apvValues,
            ULONG* o_piRow){return E_NOTIMPL;}

    virtual HRESULT STDMETHODCALLTYPE GetColumnValues(
            ULONG i_iRow,
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            ULONG* o_acbSizes, 
            LPVOID* o_apvValues);

    virtual HRESULT STDMETHODCALLTYPE GetTableMeta(
            ULONG* o_pcVersion, 
            DWORD* o_pfTable,
            ULONG* o_pcRows, 
            ULONG* o_pcColumns);

    virtual HRESULT STDMETHODCALLTYPE GetColumnMetas(
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            SimpleColumnMeta* o_aColumnMetas );

///////////////////////////////////////////////////////////////////
// ISimpleTableWrite2 interface
//
    virtual HRESULT STDMETHODCALLTYPE AddRowForDelete (ULONG i_iReadRow);

    virtual HRESULT STDMETHODCALLTYPE AddRowForInsert   (ULONG* o_piWriteRow);
    
    virtual HRESULT STDMETHODCALLTYPE AddRowForUpdate   (ULONG i_iReadRow, ULONG* o_piWriteRow);

    virtual HRESULT STDMETHODCALLTYPE GetWriteColumnValues  (
            ULONG i_iRow,
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            DWORD* o_afStatus, 
            ULONG* o_acbSizes, 
            LPVOID* o_apvValues);

    virtual HRESULT STDMETHODCALLTYPE SetWriteColumnValues  (
            ULONG i_iRow,
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            ULONG* i_acbSizes, 
            LPVOID* i_apvValues);

    virtual HRESULT STDMETHODCALLTYPE GetWriteRowIndexByIdentity(ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
	virtual HRESULT STDMETHODCALLTYPE GetWriteRowIndexBySearch (
            ULONG   i_iStartingRow,
            ULONG   i_cColumns,
            ULONG*  i_aiColumns,
            ULONG*  i_acbSizes,
            LPVOID* i_apvValues,
            ULONG* o_piRow){return E_NOTIMPL;}
    virtual HRESULT STDMETHODCALLTYPE GetErrorTable (
            DWORD   i_fServiceRequests,
            LPVOID* o_ppvSimpleTable){return E_NOTIMPL;}

    virtual HRESULT STDMETHODCALLTYPE UpdateStore ( void );

///////////////////////////////////////////////////////////////////
// ISimpleTableAdvanced interface
//
    virtual HRESULT STDMETHODCALLTYPE PopulateCache ( void );

    virtual HRESULT STDMETHODCALLTYPE GetDetailedErrorCount(ULONG* o_pcErrs);
    virtual HRESULT STDMETHODCALLTYPE GetDetailedError(ULONG i_iErr, STErr* o_pSTErr);
               

// native methods.
    HRESULT Initialize ( STQueryCell* i_aQueryCell, ULONG i_nQueryCells,IAdvancedTableDispenser* pISTDisp, LPCWSTR wszDatabase, LPCWSTR wszTable);
    inline HRESULT MoveToRowByIndex(ULONG i_iRow, VOID **o_ppRecord)
    {
        if (i_iRow & FAKE_INDEX_BIT)
            return MoveToRowByFakeIndex(i_iRow, o_ppRecord);
        else
            return MoveToRowByRealIndex(i_iRow, o_ppRecord);
   }

    HRESULT MoveToRowByRealIndex(ULONG i_iRow, VOID **o_ppRecord);
    HRESULT MoveToRowByFakeIndex(ULONG i_iRow, VOID **o_ppRecord);  
    HRESULT AddFakeIndex(VOID *i_pRecord, ULONG *o_piFakeIndex);
    HRESULT GetFakeIndex(ULONG i_iFakeIndex, VOID **o_ppRecord);

private:
    //!!!!  make sure pointers are 8 bytes alligned !!!!

    //Row buffer, SetWriteColumn writes into this buffer. 
    DBTYPE      *m_pDBType;
    LPVOID      *m_pColumnData;
    ULONG       *m_pColcb;
    ULONG       *m_pColcbBuf;
    HRESULT     *m_pColumnHr;
    ULONG       *m_pColumnOrdinal;

    //Row Buffer for GetColumnValues
    HRESULT     *m_prowHr;

    // Fake index table
    ULONG       m_cFakeIndex;                           // Number of indices stored.
    ULONG       m_cFakeIndexSize;                       // Max number of indices that can be stored.
    LPVOID      *m_ppvFakeIndex;                        // The fake index array.

    TABLEID     m_tableid;
    IComponentRecords*  m_pICR;

    //Query info
    QUERYHINT   *m_pQryHint;   
    WCHAR        m_szIndexName[MAX_QRYDEX_NAME];
    ULONG       m_cQryColumns;  //column count
    ULONG       m_iRecordCount; //count of records returned 
    ULONG       *m_rgiColumn;   //ordinals
    DBCOMPAREOP *m_rgfCompare;  //Operators. Always NULL for now.
    void        **m_rgpbData;   //data
    ULONG       *m_rgcbData;    //sizes
    DBTYPE      *m_rgiType;

    CRCURSOR    m_curCacheTable;  // this is 24(CStructArray) + 8(pointer) + 4(int) sized sturcture

    // Meta info
    ULONG       m_cColumns;
    SimpleColumnMeta *m_pColumnMeta;
	DWORD			*m_pColumnAttrib;			//Column attributes, e.g. Secure.

    //identity info ( Query + PK ), used by MoveToRowByIdentity
    ULONG       *m_idenColumns;
    DBTYPE      *m_idenType;
    DBCOMPAREOP *m_idenCompare;
    ULONG       *m_idencbData;
    void        **m_idenpbData;

    //PK info
    QUERYHINT   m_PKQryHint;
    ULONG       m_aPKColumns[MAX_PK_COLUMNS];   //1 based column ordinals for PK
    ULONG       m_cPKColumns;

    // variables that are not allignment sensitive
    ULONG       m_cRef;
    DWORD       m_fTable;
    bool        m_bInitialized;
    bool        m_bPopulated;

////////////////////////////////////////////////////////////////////////////
};

//methods from sthelper.cpp
HRESULT _GetColumnMeta(LPCWSTR wszDatabase,
                       LPCWSTR wszTable, 
                       SimpleColumnMeta **pColumnMeta, 
                       ULONG *pcColumns, 
                       ULONG *pcPKColumns, 
                       ULONG aPKColumns[], 
                       DBTYPE aPKTypes[], 
                       QUERYHINT *pPKQryHint,
					   DWORD **ppColumnAttrib,
					   IAdvancedTableDispenser*	pISTDisp);

HRESULT _RetainQuery( LPCWSTR wszTable,STQueryCell aQueryCell[], ULONG cQueryCells, ULONG cPKColumns, SimpleColumnMeta aColumnMeta[],
                      QUERYHINT *pPKQryHint, QUERYHINT **ppQryHint,WCHAR szIndexName[],
                      ULONG *pcQryColumns, ULONG **piColumns, LPVOID **ppbData, ULONG **pcbData, 
                      DBTYPE **piTypes, DBCOMPAREOP **pfCompare );





#endif // _SIMPLETABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\complibtable\simpletable.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//#include "stdafx.h"
#include "simpletable.h"

#include "catmacros.h"
#include "sdtfst.h"
#include "metaerrors.h" //error codes for CLB
// Selective wszDatabase and wszTable definitions:

#include "catmeta.h"



CSimpleTable::CSimpleTable ( TABLEID tableid, IComponentRecords* pICR,
                             DWORD fTable ) 
                           
{
	m_cRef = 0;
    m_tableid = tableid;
    m_fTable = fTable;

    m_pQryHint = NULL;
    m_cQryColumns = 0;
    m_rgiColumn = NULL;
    m_rgfCompare = NULL;
    m_rgpbData = NULL;
    m_rgcbData = NULL;
    m_rgiType = NULL;

    m_bInitialized = FALSE;
    m_bPopulated = FALSE;
    m_pColumnMeta = NULL;
    m_pColumnAttrib = NULL;
    m_cPKColumns = 0;

    m_idenColumns = NULL;
    m_idenType = NULL;
    m_idenCompare = NULL;
    m_idencbData = NULL;
    m_idenpbData = NULL;

    m_pDBType = NULL;
    m_pColumnData = NULL;
    m_pColcb = NULL;
    m_pColcbBuf = NULL;
    m_pColumnHr = NULL;
    m_pColumnOrdinal = NULL;

    m_prowHr = NULL;

    m_cFakeIndex = 0;               
    m_cFakeIndexSize = 0;               
    m_ppvFakeIndex = NULL;  

    ASSERT(pICR != NULL);
                
    m_pICR = pICR;
    m_pICR->AddRef();

}

    
CSimpleTable::~CSimpleTable ()
{
    
    if ( m_bPopulated )
        m_pICR->CloseCursor( &m_curCacheTable );

    if(m_pICR)
    {
        m_pICR->Release();
        m_pICR = NULL;      

    }

    delete [] m_pColumnMeta;
	if (m_pColumnAttrib)
	{
		delete [] m_pColumnAttrib;
	}
    delete [] m_rgfCompare;

    if ( m_pQryHint && m_pQryHint!= &m_PKQryHint )
        delete m_pQryHint;
    
    delete [] m_rgiColumn;
    delete [] m_rgcbData;
    delete [] m_rgiType;

    for ( ULONG i = 0; i < m_cQryColumns; i ++ )
    {
        BYTE* pb = (BYTE*)( m_rgpbData[i] );
        delete [] pb;
    }

    delete [] m_rgpbData;

    delete [] m_idenColumns;
    delete [] m_idenType;
    delete [] m_idenCompare;
    delete [] m_idencbData;
    delete [] m_idenpbData;

    delete [] m_pDBType;
    delete [] m_pColumnData;
    delete [] m_pColcb;
    delete [] m_pColcbBuf;
    delete [] m_pColumnHr;
    delete [] m_pColumnOrdinal;

    delete [] m_prowHr;

    if (NULL != m_ppvFakeIndex) 
    { 
        CoTaskMemFree (m_ppvFakeIndex); 
        m_ppvFakeIndex = NULL; 
    }
}


HRESULT STDMETHODCALLTYPE CSimpleTable::QueryInterface(REFIID riid, PVOID *pp)
{
    if (riid == IID_IUnknown)
    {
        *pp = (PVOID) (IUnknown *) (ISimpleTableRead2 *) this;
    
    }
    else if (riid == IID_ISimpleTableRead2)
    {
        *pp = (PVOID) (ISimpleTableRead2 *) this;
    
    }
    else if (riid == IID_ISimpleTableWrite2)
    {
        *pp = (PVOID) (ISimpleTableWrite2 *) this;      
    }
    else if (riid == IID_ISimpleTableAdvanced)
    {
        *pp = (PVOID) (ISimpleTableAdvanced *) this;        
    }
    else
    {
        return (E_NOINTERFACE);
    }

    AddRef();
    return (S_OK);
}


HRESULT CSimpleTable::Initialize ( STQueryCell* i_aQueryCell, ULONG i_nQueryCells,IAdvancedTableDispenser*	pISTDisp,  LPCWSTR wszDatabase, LPCWSTR wszTable )
{
    HRESULT hr;
    ULONG   i,j, iSpecial;

    hr = _GetColumnMeta(wszDatabase, 
                       wszTable, 
                       &m_pColumnMeta, 
                       &m_cColumns, 
                       &m_cPKColumns, 
                       m_aPKColumns, 
                       NULL, 
                       &m_PKQryHint,
					   &m_pColumnAttrib,
					   pISTDisp);

    if ( FAILED(hr) ) return hr;

    hr = _RetainQuery( wszTable,i_aQueryCell, i_nQueryCells, m_cPKColumns, m_pColumnMeta,
                      &m_PKQryHint, &m_pQryHint,m_szIndexName,
                      &m_cQryColumns, &m_rgiColumn, &m_rgpbData, &m_rgcbData, 
                      &m_rgiType, &m_rgfCompare );

    if ( SUCCEEDED(hr) )    
        m_bInitialized = TRUE;

    return (hr);
}

HRESULT STDMETHODCALLTYPE CSimpleTable::PopulateCache ( void )
{
    HRESULT hr;

    ASSERT(m_pICR != NULL);
    ASSERT(m_bInitialized == TRUE);

    if ( m_bPopulated )
    {  
		m_pICR->CloseCursor( &m_curCacheTable );
    }

    if ( m_fTable & fST_LOS_UNPOPULATED )
    {
        m_iRecordCount = 0;
        hr = S_OK;
        m_fTable &= ~fST_LOS_UNPOPULATED;
        goto _ExitFn;
    }


    hr = m_pICR->QueryByColumns(
                    m_tableid, m_pQryHint, m_cQryColumns,
                    m_rgiColumn, m_rgfCompare, (const void **) m_rgpbData,
                    m_rgcbData, m_rgiType, NULL, 0, &m_curCacheTable, NULL );


    if(FAILED(hr))
        goto _ExitFn;

    m_bPopulated = TRUE;

    hr = m_pICR->GetCount( &m_curCacheTable, &m_iRecordCount);

_ExitFn:

    if ( hr == CLDB_E_RECORD_NOTFOUND )
    {
        m_iRecordCount = 0;
        hr = S_OK;
    }

    return ( hr );
}

HRESULT STDMETHODCALLTYPE CSimpleTable::UpdateStore ( void )
{
    HRESULT hr;

	if (!(m_fTable & fST_LOS_READWRITE)) return E_NOTIMPL;

    if(m_bInitialized)
    {
        hr = m_pICR->Save(NULL);
    }
    else
    {
        hr = E_FAIL;
    }
    return ( hr );
}


HRESULT CSimpleTable::MoveToRowByRealIndex(
        ULONG i_iRow,
        VOID **o_ppRecord)
{
    HRESULT hr;

    if(i_iRow <  m_iRecordCount)
    {
        hr = m_pICR->MoveTo( &m_curCacheTable, i_iRow);
        if ( FAILED(hr) ) return hr;
        int iFetch = 1;
        hr = m_pICR->ReadCursor( &m_curCacheTable, o_ppRecord,&iFetch);
        return ( hr );
    }
    return ( E_ST_NOMOREROWS );
}

HRESULT CSimpleTable::AddFakeIndex(
        VOID *i_pRecord,
        ULONG *o_piFakeIndex)
{
    // @TODO:Lock the fake index array. 
	// Wenjun: Locking is not required since IST doesn't guaruntee to thread safe.
    // Resize the array if there isn't room for one more index.
    if (m_cFakeIndex == m_cFakeIndexSize)
    {
        LPVOID  pTemp;

        // Resize.
        if ((pTemp = CoTaskMemRealloc (m_ppvFakeIndex, (((m_cFakeIndexSize*2)+1) * (sizeof(LPVOID))))) == NULL)
            // @TODO: Unlock.
            return (E_OUTOFMEMORY);

        // Make the new size almost twice as big.
        m_ppvFakeIndex = (LPVOID*)pTemp;
        m_cFakeIndexSize = (m_cFakeIndexSize * 2) + 1;
    }

    // Add the record pointer to the array.
    m_ppvFakeIndex[m_cFakeIndex] = i_pRecord;
    // Set the return fake index (using the FAKE_INDEX_BIT)
    *o_piFakeIndex = m_cFakeIndex | FAKE_INDEX_BIT;
    // Increment the fake index count.
    m_cFakeIndex++;
    
    // @TODO: Unlock the fake index array.

    return S_OK;
}

HRESULT CSimpleTable::MoveToRowByFakeIndex(
        ULONG i_iFakeIndex,
        VOID **o_ppRecord)
{
    HRESULT hr;

    ASSERT(i_iFakeIndex & FAKE_INDEX_BIT);
    // @TODO: Lock the fake index array.

    // Clear the fake bit.
    i_iFakeIndex &= ~FAKE_INDEX_BIT;

    // If the index is valid
    if (i_iFakeIndex < m_cFakeIndex)
    {
        // Set the output record ptr.
        *o_ppRecord = m_ppvFakeIndex[i_iFakeIndex];
        hr = S_OK;
    }
    else
    {
        // Indicate the row doesn't exist.
        hr = E_ST_NOMOREROWS;
    }
    // @TODO:Unlock the fake index array.

    return hr;
}

HRESULT STDMETHODCALLTYPE CSimpleTable::GetRowIndexByIdentity ( 
        ULONG *i_acb,
        LPVOID *i_apv,
        ULONG *o_piRow
        )
{

    int iFetched = 0;
    LPVOID pRecord;
    ULONG i = 0;
    HRESULT hr = S_OK;

//  areturn_on_fail( m_bPopulated, E_UNEXPECTED );

    if ( m_iRecordCount == 0 )
        return ( E_ST_NOMOREROWS );


    if ( !m_idenColumns )
    {
        //Allocate and initialize the query structure, the query cells always go after the 
        //PK info because PK has index hint.

        //Fill out the query info for PK and Query.
        m_idenColumns = new ULONG[m_cQryColumns+m_cPKColumns];
		if ( NULL == m_idenColumns )	return E_OUTOFMEMORY;
        m_idenType = new DBTYPE[m_cQryColumns+m_cPKColumns];
		if ( NULL == m_idenType )	return E_OUTOFMEMORY;
        m_idenCompare = new DBCOMPAREOP[m_cQryColumns+m_cPKColumns];
		if ( NULL == m_idenCompare )	return E_OUTOFMEMORY;	
        m_idencbData = new ULONG[m_cQryColumns+m_cPKColumns];
		if ( NULL == m_idencbData )		return E_OUTOFMEMORY;	
        m_idenpbData = new LPVOID[m_cQryColumns+m_cPKColumns];
		if ( NULL == m_idenpbData )		return E_OUTOFMEMORY;	

        if ( m_cQryColumns > 0 )
        {
            memcpy( (void*)(m_idenColumns+m_cPKColumns), (void*)m_rgiColumn, sizeof(ULONG)*m_cQryColumns ); 
            memcpy( (void*)(m_idenType+m_cPKColumns), (void*)m_rgiType, sizeof(DBTYPE)*m_cQryColumns );
            memcpy( (void*)(m_idenCompare+m_cPKColumns), (void*)m_rgfCompare, sizeof(DBCOMPAREOP)*m_cQryColumns );
            memcpy( (void*)(m_idencbData+m_cPKColumns), m_rgcbData, sizeof(ULONG)*m_cQryColumns );
			memcpy( (void*)(m_idenpbData+m_cPKColumns), m_rgpbData, sizeof(LPVOID)*m_cQryColumns );
        }
            
        for ( i = 0; i < m_cPKColumns; i ++ )
        {
            m_idenColumns[i] = m_aPKColumns[i];
            m_idenType[i] = (DBTYPE)m_pColumnMeta[i].dbType;
            m_idenCompare[i] = DBCOMPAREOPS_EQ; 
            m_idencbData[i] = m_pColumnMeta[i].cbSize;
        }
    }
        
    //Get the PK data into my query structure

    for ( i = 0; i < m_cPKColumns; i ++ )
    {
        m_idenpbData[i] = i_apv[i];

        //If not fixed length, set the column size based on the array passed in
        if ( i_acb && !(m_pColumnMeta[i].fMeta & fCOLUMNMETA_FIXEDLENGTH) )
            m_idencbData[i] = i_acb[i];

    }

        
    hr = m_pICR->QueryByColumns(
                m_tableid, &m_PKQryHint, m_cQryColumns+m_cPKColumns,
                m_idenColumns, m_idenCompare, (const void **) m_idenpbData,
                m_idencbData, m_idenType, &pRecord, 1, NULL, &iFetched );

    if ( hr == CLDB_E_RECORD_NOTFOUND )
         hr = E_ST_NOMOREROWS;

    if (SUCCEEDED(hr))
        hr = AddFakeIndex(pRecord, o_piRow);

    return hr;
}


HRESULT STDMETHODCALLTYPE CSimpleTable::GetColumnValues (
            ULONG i_iRow,
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            ULONG* o_acbSizes, 
            LPVOID* o_apvValues)
{
   
    LPVOID  *ppvValues = NULL;
    ULONG   *pcbSizes = NULL;
    void    *pRecord = NULL;
    HRESULT hr;
	ULONG	i;

    if (i_cColumns == 0)
        return S_OK;

	if (i_cColumns > m_cColumns )
		return E_ST_NOMORECOLUMNS;

    if (FAILED(hr = MoveToRowByIndex(i_iRow, &pRecord)))
        return hr;
        
    if ( !m_prowHr )
    {
        m_prowHr = new HRESULT[m_cColumns];
		if ( NULL == m_prowHr )		return E_OUTOFMEMORY;
    }


    ZeroMemory( m_prowHr, m_cColumns*sizeof( HRESULT ) );
    
    hr = m_pICR->GetColumns( m_tableid,
                             pRecord,
                             COLUMN_ORDINAL_LIST(i_cColumns),
                             NULL,
                             (const void**)o_apvValues,
                             NULL,
                             o_acbSizes,
                             m_prowHr,
                             i_aiColumns
                            );

    if ( FAILED( hr ) )
        return hr;

    for ( i = 0; i < i_cColumns; i ++ )
    {
        if ( FAILED ( m_prowHr[i] ) )
        {
            return  m_prowHr[i];
        }
       
    }

    return S_OK;
        
}


HRESULT STDMETHODCALLTYPE CSimpleTable::AddRowForInsert (ULONG* o_piWriteRow)
{
    LPVOID pRecord;
    HRESULT hr;

    
    hr = m_pICR->NewRecord(m_tableid, &pRecord, 0, 0, 0);

	if (SUCCEEDED(hr))
        hr = AddFakeIndex(pRecord, o_piWriteRow);

	if ( FAILED(hr) )
		return hr;
    
    //Allocate buffer for the new or updated row 
    if ( !m_pDBType )
    {
        m_pDBType = new DBTYPE[ m_cColumns ];
		if ( NULL == m_pDBType )	return E_OUTOFMEMORY;
        m_pColumnData = new LPVOID[ m_cColumns ];
		if ( NULL == m_pColumnData )	return E_OUTOFMEMORY;
        m_pColcb = new ULONG[ m_cColumns ];
		if ( NULL == m_pColcb )		return E_OUTOFMEMORY;
        m_pColcbBuf = new ULONG[ m_cColumns ];
		if ( NULL == m_pColcbBuf )		return E_OUTOFMEMORY;
        m_pColumnHr = new HRESULT[ m_cColumns ];
		if ( NULL == m_pColumnHr )		return E_OUTOFMEMORY;
        m_pColumnOrdinal = new ULONG[ m_cColumns ];
		if ( NULL == m_pColumnOrdinal )		return E_OUTOFMEMORY;
    }

    ZeroMemory( m_pColumnHr, m_cColumns*sizeof( HRESULT ) );

    return ( hr );
}

HRESULT STDMETHODCALLTYPE CSimpleTable::AddRowForDelete (ULONG i_iReadRow)
{

    ULONG rid;
    VOID  *pRecord = NULL;
    HRESULT hr;

    if (FAILED(hr = MoveToRowByIndex(i_iReadRow, &pRecord)))
        return hr;

    hr = m_pICR->GetRIDForRow(m_tableid, pRecord,&rid );
	if ( FAILED(hr) ) return hr;

    hr = m_pICR->DeleteRowByRID(m_tableid, rid );

    return ( hr );
}

HRESULT STDMETHODCALLTYPE CSimpleTable::AddRowForUpdate (ULONG i_iReadRow, ULONG* o_piWriteRow)
{

    //Allocate buffer for the new or updated row 
    if ( !m_pDBType )
    {
		 m_pDBType = new DBTYPE[ m_cColumns ];
		if ( NULL == m_pDBType )	return E_OUTOFMEMORY;
        m_pColumnData = new LPVOID[ m_cColumns ];
		if ( NULL == m_pColumnData )	return E_OUTOFMEMORY;
        m_pColcb = new ULONG[ m_cColumns ];
		if ( NULL == m_pColcb )		return E_OUTOFMEMORY;
        m_pColcbBuf = new ULONG[ m_cColumns ];
		if ( NULL == m_pColcbBuf )		return E_OUTOFMEMORY;
        m_pColumnHr = new HRESULT[ m_cColumns ];
		if ( NULL == m_pColumnHr )		return E_OUTOFMEMORY;
        m_pColumnOrdinal = new ULONG[ m_cColumns ];
		if ( NULL == m_pColumnOrdinal )		return E_OUTOFMEMORY;
	}

    ZeroMemory( m_pColumnHr, m_cColumns*sizeof( HRESULT ) );
    *o_piWriteRow = i_iReadRow;
    return ( S_OK );
}

HRESULT STDMETHODCALLTYPE CSimpleTable::GetWriteColumnValues    (
        ULONG i_iRow,
        ULONG i_cColumns, 
        ULONG* i_aiColumns, 
        DWORD* o_afStatus, 
        ULONG* o_acbSizes, 
        LPVOID* o_apvValues)
{
    return(E_NOTIMPL);
}   

HRESULT STDMETHODCALLTYPE CSimpleTable::SetWriteColumnValues    (
        ULONG i_iRow,
        ULONG i_cColumns, 
        ULONG* i_aiColumns, 
        ULONG* i_acbSizes, 
        LPVOID* i_apvValues)
{
    VOID  *pRecord = NULL;
    HRESULT     hr = S_OK;

    if (FAILED(hr = MoveToRowByIndex(i_iRow, &pRecord)))
        return hr;

    ASSERT( pRecord );

    for ( ULONG i = 0; i < i_cColumns; i++ )
    {
        ULONG iCol;
        ULONG iSource;

        if ( i_aiColumns )
            iCol = i_aiColumns[i];
        else 
            iCol = i;

        // Verify the column ordinal.
        if (iCol >= m_cColumns)
            return E_INVALIDARG;

        iSource = (i_cColumns == 1) ? 0 : iCol;
        m_pColumnOrdinal[i] = iCol+1;
        m_pDBType[i] = (DBTYPE)m_pColumnMeta[iCol].dbType;

        //Set size
        if ( m_pColumnMeta[iCol].dbType == DBTYPE_WSTR)
            m_pColcb[i] = 0xffffffff;
        else if ( i_acbSizes )
            m_pColcb[i] = i_acbSizes[iSource];
        else
            m_pColcb[i] = m_pColumnMeta[iCol].cbSize;

        //Set data
        if ( i_apvValues[iSource] == NULL )
            m_pColumnHr[i] = DBSTATUS_S_ISNULL;
        else
            m_pColumnData[i] = i_apvValues[iSource];
    }
        
    hr = m_pICR->SetColumns( m_tableid,
                             pRecord,
                             COLUMN_ORDINAL_LIST(i_cColumns),
                             m_pDBType,
                             (const void**)m_pColumnData,
                             m_pColcb,
                             m_pColcbBuf,
                             m_pColumnHr,
                             m_pColumnOrdinal
                            );

    return (hr);
}


HRESULT STDMETHODCALLTYPE CSimpleTable::GetTableMeta(
        ULONG* o_pcVersion, 
        DWORD* o_pfTable,                               
        ULONG* o_pcRows, 
        ULONG* o_pcColumns  )
{
    //@todo: get the version info
    if(o_pfTable) 
        *o_pfTable = m_fTable;

    //Only return row count and column count for now
    if ( o_pcRows )
        *o_pcRows = m_iRecordCount;

    if ( o_pcColumns )
        *o_pcColumns = m_cColumns;

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CSimpleTable::GetColumnMetas(
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            SimpleColumnMeta* o_aColumnMetas )
{   

    ULONG iColumn;
    ULONG iTarget;

    if ( i_cColumns > m_cColumns )  
        return  E_ST_NOMORECOLUMNS;
       
    for ( ULONG i = 0; i < i_cColumns; i ++ )
    {
        if(NULL != i_aiColumns)
            iColumn = i_aiColumns[i];
        else
            iColumn = i;

        iTarget = (i_cColumns == 1) ? 0 : iColumn;

        if ( iColumn >= m_cColumns )    
            return  E_ST_NOMORECOLUMNS;

        memcpy( &(o_aColumnMetas[iTarget]), &(m_pColumnMeta[iColumn]), sizeof( SimpleColumnMeta ) );
    }
    
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CSimpleTable::GetWriteRowIndexByIdentity(ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG *o_piRow)
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CSimpleTable::GetDetailedErrorCount(ULONG* o_pcErrs)
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CSimpleTable::GetDetailedError(ULONG i_iErr, STErr* o_pSTErr)
{
    return(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\errortable\errortable.cpp ===
/********************************************************************++
 
Copyright (c) 2001 Microsoft Corporation
 
Module Name:
 
    ErrorTable.cpp
 
Abstract:
 
    Detailed Errors go into a table. This is the implementation of
    that table.
 
Author:
 
    Stephen Rakonza (stephenr)        9-Mar-2001
 
Revision History:
 
--********************************************************************/

#include "Catalog.h"
#include "CatMeta.h"
#include "CatMacros.h"
#ifndef __oaidl_h__
#include "oaidl.h"
#endif
#include "ErrorTable.h"

/********************************************************************++
 
Routine Description:
 
    Intercept member of ISimpleTableInterceptor.  See IST documentation
    for details.
 
Arguments:
 
	i_wszDatabase   - only wszDATABASE_ERRORS is allowed
	i_wszTable      - only wszTABLE_DETAILEDERRORS is allowed
	i_TableID       - no used anymore
	i_QueryData     - no queries are currently acknowledged
	i_QueryMeta     - no queries are currently acknowledged
	i_eQueryFormat  - must be eST_QUERYFORMAT_CELLS
	i_fLOS          - Level of service (currently we don't allow READWRITE)
	i_pISTDisp      - the dispenser used to create this table
	i_wszLocator    - not currently used
	i_pSimpleTable  - this is not a logic interceptor so no table is under us
	o_ppvSimpleTable- we just create a memory table and return it

Notes:
 
    This is the most basic type of table.  It's empty to start with.
    So OnPopulateCache does nothing.  And it is never written to disk.
    So UpdateStore does nothing.  Intercept just create a memory table.
    What could be simpler.
 
Return Value:
 
    HRESULT
 
--********************************************************************/
STDMETHODIMP
ErrorTable::Intercept(
	LPCWSTR 	                i_wszDatabase,
	LPCWSTR 	                i_wszTable, 
	ULONG		                i_TableID,
	LPVOID		                i_QueryData,
	LPVOID		                i_QueryMeta,
	DWORD		                i_eQueryFormat,
	DWORD		                i_fLOS,
	IAdvancedTableDispenser*    i_pISTDisp,
	LPCWSTR		                i_wszLocator,
	LPVOID		                i_pSimpleTable,
	LPVOID*		                o_ppvSimpleTable)
{
	HRESULT		hr = S_OK;

    InterlockedIncrement(&m_IsIntercepted);//We can only be called to Intercept once.

    if(1 != m_IsIntercepted)
    {
        ASSERT(false && "Intercept has already been called.  It can't be called twice.");
        return E_INVALIDARG;
    }

    if(_wcsicmp(i_wszDatabase, wszDATABASE_ERRORS))
    {
        ASSERT(false && "This interceptor only knows how to deal with wszDATABASE_ERRORS.  The wiring must be wrong");
        return E_INVALIDARG;
    }

    if(_wcsicmp(i_wszTable, wszTABLE_DETAILEDERRORS))
    {
        ASSERT(false && "This interceptor only knows how to deal with wszTABLE_DETAILEDERRORS.  The wiring must be wrong");
        return E_INVALIDARG;
    }

    if(0 != i_pSimpleTable)
    {
        ASSERT(false && "Programming Error!  i_pSimpleTable should be NULL.  The Error table is a bottom layer table.");
        return E_INVALIDARG;
    }

    if(0 == i_pISTDisp)
    {
        ASSERT(false && "Programming Error!  The dispenser needs to be passed into ::Intercept");
        return E_INVALIDARG;
    }

    *o_ppvSimpleTable = 0;//init out param

    STQueryCell *   pQueryCell = (STQueryCell*) i_QueryData;    // Query cell array from caller.
    int             nQueryCount = i_QueryMeta ? *reinterpret_cast<ULONG *>(i_QueryMeta) : 0;
    while(nQueryCount--)
    {
        if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//ignore iST_CELL_SPECIAL, any other query is an error
            return E_ST_INVALIDQUERY;
        ++pQueryCell;
    }

    if(i_fLOS & fST_LOS_READWRITE)
    {
        ASSERT(false && "Error tables are not writable at this time");
        return E_ST_LOSNOTSUPPORTED;
    }

    if(eST_QUERYFORMAT_CELLS != i_eQueryFormat)
        return E_ST_QUERYNOTSUPPORTED;//Verify query type.  

    ASSERT(0 == *o_ppvSimpleTable && "This should be NULL.  Possible memory leak or just an uninitialized variable.");

    if(FAILED(hr = i_pISTDisp->GetMemoryTable(  i_wszDatabase,
                                        i_wszTable,
                                        i_TableID,
                                        0,
                                        0,
                                        i_eQueryFormat,
                                        i_fLOS,
                                        reinterpret_cast<ISimpleTableWrite2 **>(&m_spISTWrite))))
            return hr;

    m_spISTController = m_spISTWrite;
    ASSERT(0 != m_spISTController.p);
    if(0 == m_spISTController.p)
        return E_NOINTERFACE;

    *o_ppvSimpleTable = (ISimpleTableWrite2*)(this);
    ((ISimpleTableInterceptor*)this)->AddRef();

    return hr;
}//ErrorTable::Intercept


STDMETHODIMP
ErrorTable::GetGUID(GUID * o_pGUID)
{
    return E_NOTIMPL;
}


STDMETHODIMP
ErrorTable::GetSource(BSTR * o_pBstrSource)
{
    HRESULT     hr;
    LPWSTR      wszSource;        
    ULONG       iColumn = iDETAILEDERRORS_Source;

    if(FAILED(hr = m_spISTWrite->GetColumnValues(0, 1, &iColumn, 0, reinterpret_cast<void **>(&wszSource))))
        return hr;

    CComBSTR bstrSource = wszSource;//Allocation can fail
    if(0 == bstrSource.m_str)
        return E_OUTOFMEMORY;

    *o_pBstrSource = bstrSource.Detach();//this assigns the BSTR and marks the CComBSTR as empty so it doesn't get freed.
    return S_OK;
}


STDMETHODIMP
ErrorTable::GetDescription(BSTR * o_pBstrDescription)
{   //GetDescription gets the first error from the table.  If the table contains more than one error, the caller will need to QI for ISimpleTableRead
    HRESULT     hr;
    LPWSTR      wszDescription;        
    ULONG       iColumn = iDETAILEDERRORS_Description;

    if(FAILED(hr = m_spISTWrite->GetColumnValues(0, 1, &iColumn, 0, reinterpret_cast<void **>(&wszDescription))))
        return hr;

    CComBSTR bstrDescription = wszDescription;//Allocation can fail
    if(0 == bstrDescription.m_str)
        return E_OUTOFMEMORY;

    *o_pBstrDescription = bstrDescription.Detach();//this assigns the BSTR and marks the CComBSTR as empty so it doesn't get freed.
    return S_OK;
}


STDMETHODIMP
ErrorTable::GetHelpFile(BSTR * o_pBstrHelpFile)
{
    return E_NOTIMPL;
}


STDMETHODIMP
ErrorTable::GetHelpContext(DWORD * o_pdwHelpContext)
{
    return E_NOTIMPL;
}


STDMETHODIMP
ErrorTable::QueryInterface(
    REFIID riid,
    void **ppv
)
{
    if (NULL == ppv) 
        return E_INVALIDARG;
    *ppv = NULL;

    if (riid == IID_IUnknown)
    {
        *ppv = (ISimpleTableInterceptor*)(this);
    }
    if (riid == IID_ISimpleTableInterceptor)
    {
        *ppv = (ISimpleTableInterceptor*)(this);
    }
    else if (riid == IID_IErrorInfo)
    {
        *ppv = (IErrorInfo*)(this);
    }
    else if (riid == IID_ISimpleTableRead2)
    {
        *ppv = (ISimpleTableRead2*)(this);
    }
    else if (riid == IID_ISimpleTableWrite2)
    {
        *ppv = (ISimpleTableWrite2*)(this);
    }
    else if (riid == IID_ISimpleTableAdvanced)
    {
        *ppv = (ISimpleTableAdvanced*)(this);
    }
    else if (riid == IID_ISimpleTableController)
    {
        *ppv = (ISimpleTableController*)(this);
    }

    if (NULL != *ppv)
    {
        ((ISimpleTableInterceptor*)this)->AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}//ErrorTable::QueryInterface


STDMETHODIMP_(ULONG)
ErrorTable::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);
}//ErrorTable::AddRef

STDMETHODIMP_(ULONG)
ErrorTable::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
        delete this;

    return cref;
}//ErrorTable::Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\complibtable\simpletablec.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
//simpletableC.cpp
//Implement the CSimpleTableC class, the complib datatable that uses fast cache
//*****************************************************************************
#include "simpletablec.h"
#include "catmacros.h"
#include "atlbase.h"
#include "clbread.h"
#include "clbwrite.h"
#include "metaerrors.h"
#include "..\xmltable\stringroutines.h"

HRESULT GetCryptoStorage(
	IIS_CRYPTO_STORAGE *i_pCryptoStorage,
	LPCWSTR		i_wszCookdownFile,
    DWORD       i_fTable,
	BOOL		i_bUpdateStore);


CSimpleTableC::CSimpleTableC(ULONG tableIndex,DWORD fTable)                             
{
	m_cRef = 0;
    m_tableIndex = tableIndex;
    m_fTable = fTable;
	m_pISTWrite = NULL;
	m_pISTController = NULL;

    m_cPKColumns = 0;
    m_cColumns = 0;

    m_pQryHint    = NULL;
    m_cQryColumns = 0;
    m_rgiColumn  = NULL;
    m_rgfCompare = NULL;
    m_rgpbData   = NULL;
    m_rgcbData   = NULL;
    m_rgiType    = NULL;

    m_pData = NULL;
    m_iType = NULL;
    m_cbBuf = NULL;
    m_pcbBuf = NULL;
    m_colhr = NULL;
    m_pColumnMeta = NULL;
	m_pColumnAttrib = NULL;
    m_pBlob = NULL;

	m_wszFileName = NULL;

}

CSimpleTableC::~CSimpleTableC () 
{
    for ( ULONG i = 0; i < m_cQryColumns; i ++ )
    {
        if ( m_rgpbData[i] )
            delete[] reinterpret_cast<BYTE*>(m_rgpbData[i]);
    }

    if ( m_pQryHint && m_pQryHint!= &m_PKQryHint )
        delete m_pQryHint;
    
    delete[] m_rgiColumn;          
    delete[] m_rgfCompare;
    delete[] m_rgpbData;
    delete[] m_rgcbData;
    delete[] m_rgiType;

    delete[] m_pData;            
    delete[] m_iType;
    delete[] m_cbBuf;
    delete[] m_pcbBuf;
    delete[] m_colhr;
    delete[] m_pColumnMeta;
    delete[] m_pColumnAttrib;
    delete[] m_pBlob;

	delete [] m_wszFileName;
	if	(m_pISTWrite)		m_pISTWrite->Release();
	if	(m_pISTController)	m_pISTController->Release();
}


HRESULT STDMETHODCALLTYPE CSimpleTableC::QueryInterface(REFIID riid, PVOID *pp)
{
    if (riid == IID_IUnknown)
    {
        *pp = (IUnknown *) (ISimpleTableRead2 *) this;
    
    }
    else if (riid == IID_ISimpleTableRead2)
    {
        *pp = (ISimpleTableRead2 *) this;
    
    }
    else if (riid == IID_ISimpleTableWrite2)
    {
        *pp = (ISimpleTableWrite2 *) this;      
    }
    else if (riid == IID_ISimpleTableAdvanced)
    {
        *pp = (ISimpleTableAdvanced *) this;        
    }
    else if (riid == IID_ISimpleTableController)
    {
        *pp = (ISimpleTableController *) this;
    }
    else
    {
        return (E_NOINTERFACE);
    }

    AddRef();
    return (S_OK);
}

HRESULT CSimpleTableC::Initialize( STQueryCell* i_aQueryCell, ULONG i_nQueryCells, IAdvancedTableDispenser* pISTDisp, ISimpleTableWrite2* i_pISTWrite,
								   LPCWSTR wszDatabase, LPCWSTR wszTable, LPWSTR wszFileName)
{
    HRESULT hr = S_OK;
	//Get the complib blob and default file name( if file name is null ).
	if ( wszFileName )
	{
		m_wszFileName = new WCHAR[ wcslen(wszFileName) + 1];
		if ( NULL == m_wszFileName )
			return E_OUTOFMEMORY;
		wcscpy( m_wszFileName, wszFileName );
		hr = _CLBGetSchema( wszDatabase, &m_complibSchema, &m_sSchemaBlob, NULL );
	}
	else
		hr = _CLBGetSchema( wszDatabase, &m_complibSchema, &m_sSchemaBlob, &m_wszFileName );

	if ( FAILED(hr) ) return hr;

	//Get the column meta
    hr = _GetColumnMeta(wszDatabase, 
                       wszTable, 
                       &m_pColumnMeta, 
                       &m_cColumns, 
                       &m_cPKColumns, 
                       m_aPKColumns, 
                       m_aPKTypes, 
                       &m_PKQryHint,
					   &m_pColumnAttrib,
					   pISTDisp);

    if ( FAILED(hr) ) return hr;

	// Figure if this table has any columns that need encryption.
	m_bRequiresEncryption = FALSE;
	for (ULONG i = 0; i < m_cColumns; i++)
	{
		if (m_pColumnAttrib[i] & fCOLUMNMETA_SECURE)
			m_bRequiresEncryption = TRUE;
	}

	// Store the memory table pointer.
	m_pISTWrite = i_pISTWrite;
	m_pISTWrite->AddRef();

	hr = i_pISTWrite->QueryInterface(IID_ISimpleTableController, (LPVOID*)&m_pISTController);
    if ( FAILED(hr) ) return hr;
	//Copy and parse the query cells
    hr = _RetainQuery( wszTable,i_aQueryCell, i_nQueryCells, m_cPKColumns, m_pColumnMeta,
                      &m_PKQryHint, &m_pQryHint,m_szIndexName,
                      &m_cQryColumns, &m_rgiColumn, &m_rgpbData, &m_rgcbData, 
                      &m_rgiType, &m_rgfCompare );

    return hr;


}

HRESULT STDMETHODCALLTYPE CSimpleTableC::PopulateCache ( void )
{
    HRESULT hr;
    CRCURSOR cur;
    ULONG cRecords;
    void*   pRecord = NULL;
    int iFetched;
    ULONG iRow, iCol, j;
    ULONG iWriteRow;
    
    CComPtr<IComponentRecords>  pICR;
    TABLEID tableid;
    IIS_CRYPTO_STORAGE CryptoStorage;
	ULONG cbTemp = 0;
	BYTE *pbTemp = NULL;

    hr = m_pISTController->PrePopulateCache (0);   
    if ( FAILED(hr) ) return hr;

    if ( m_fTable & fST_LOS_UNPOPULATED )
    {
        m_fTable &= ~fST_LOS_UNPOPULATED;
        return m_pISTController->PostPopulateCache();
    }

    //Cookdown is considered as one Tx, reading from the temp file to see the changes 
    //that have been made so far.
    if ( m_fTable & fST_LOS_COOKDOWN )
        hr = CLBGetWriteICR( m_wszFileName, &pICR, &m_complibSchema, &m_sSchemaBlob );
    else
    {
        hr = CLBGetReadICR( m_wszFileName, &pICR, &m_complibSchema, &m_sSchemaBlob );
    
        if ( (m_fTable & fST_LOS_READWRITE) && (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) )
        {
            m_pISTController->PostPopulateCache();
            return S_OK;
        }
    }
    
    if ( FAILED(hr) ) return hr;

    hr = pICR->OpenTable(&m_complibSchema, m_tableIndex, &tableid );
    if ( FAILED(hr) ) return hr;

    hr = pICR->QueryByColumns(
                    tableid, m_pQryHint, m_cQryColumns,
                    m_rgiColumn, m_rgfCompare, (const void **) m_rgpbData,
                    m_rgcbData, m_rgiType, NULL, 0, &cur, NULL );

    if ( FAILED(hr) )
    {
        if ( hr == CLDB_E_RECORD_NOTFOUND )
        {
            cRecords = 0;
            hr = S_OK;
        }
        else
            return hr;
    }
    else
    {
        hr = pICR->GetCount( &cur, &cRecords);
        if ( FAILED(hr) ) return hr;
    }

    if ( cRecords == 0 ) goto ErrExit;

	if (m_bRequiresEncryption)
	{
		hr = GetCryptoStorage(&CryptoStorage, m_wszFileName, m_fTable, FALSE);
		if (FAILED(hr)) 
		{
			TRACE(L"[CSimpleTableC::PopulateCache] GetCryptoStorage failed with hr = 0x%x.\n", hr);
			return hr;
		}
	}

    if ( NULL == m_pData )
    {
        m_pData = new LPVOID[m_cColumns];
        if ( NULL == m_pData ) return E_OUTOFMEMORY;
        m_iType = new DBTYPE[m_cColumns];
        if ( NULL == m_iType ) return E_OUTOFMEMORY;
        m_cbBuf = new ULONG[m_cColumns];
        if ( NULL == m_cbBuf ) return E_OUTOFMEMORY;
        m_pcbBuf = new ULONG[m_cColumns];
        if ( NULL == m_pcbBuf ) return E_OUTOFMEMORY;
        m_colhr = new HRESULT[m_cColumns];
        if ( NULL == m_colhr ) return E_OUTOFMEMORY;
		if (m_bRequiresEncryption)
		{
			m_pBlob = (LPVOID*)new PIIS_CRYPTO_BLOB[m_cColumns];
			if ( NULL == m_pBlob ) return E_OUTOFMEMORY;
			ZeroMemory( m_pBlob, m_cColumns*sizeof(PIIS_CRYPTO_BLOB) );
		}
    }

    memset ( m_colhr, 0, sizeof(HRESULT)*m_cColumns );

    for ( iRow = 0; iRow < cRecords; iRow++ )
    {
        iFetched = 1;

        hr = pICR->ReadCursor( &cur, &pRecord,&iFetched);
        if ( FAILED(hr) ) goto ErrExit;

        hr = m_pISTWrite->AddRowForInsert (&iWriteRow);
        if ( FAILED(hr) ) goto ErrExit;

        hr = pICR->GetColumns ( tableid,             
                                pRecord,             
                                COLUMN_ORDINAL_LIST(m_cColumns),             
                                NULL,             
                                (const void **)m_pData,          
                                NULL,    
                                m_pcbBuf,
                                m_colhr,
                                NULL
                                );

        if ( FAILED(hr) ) goto ErrExit;

        for( iCol = 0; iCol < m_cColumns; iCol ++ )
        {
            if ( FAILED( m_colhr[iCol] ) ) 
            {
                hr = m_colhr[iCol];
                m_pData[iCol] = NULL;   //To avoid confusion during clean up
                break;
            }

            if ( DBSTATUS_S_ISNULL == m_colhr[iCol] )
            {
                m_pcbBuf[iCol] = 0;
                m_pData[iCol] = NULL;
            }
			// Decrypt the data if this is a secure property and not null.
			else if (m_pColumnAttrib[iCol] & fCOLUMNMETA_SECURE)
			{
                m_iType[iCol] = static_cast<DBTYPE>( m_pColumnMeta[iCol].dbType );
				// This code assumes all secure properties are of type DBTYPE_WSTR.
				ASSERT(m_iType[iCol] == DBTYPE_WSTR);

				//
				// This is a secure data object, we'll need to decrypt it
				// before proceeding. 
				
				// But first we must convert the data from its string representation to the binary
				// representation.
				ASSERT(pbTemp == NULL);

				// Calculate how much memory we would need to convert the string representation
				// to thte hex representation. -2 for the trailing \0, divide by four because
				// each byte is represented by two WCHARs which is 4 bytes.
				cbTemp = (m_pcbBuf[iCol] - sizeof(WCHAR)) / (2 * sizeof(WCHAR));
				pbTemp = new BYTE [cbTemp];
				if (pbTemp == NULL)
				{
					hr = E_OUTOFMEMORY;
					break;
				}

				hr = StringToByteArray((WCHAR*)m_pData[iCol], pbTemp);
				ASSERT(hr == S_OK);

				// Note that we must clone the blob before
				// we can actually use it, as the blob data in the line buffer
				// is not DWORD-aligned. (IISCryptoCloneBlobFromRawData() is
				// the only IISCrypto function that can handle unaligned data.)
				hr = ::IISCryptoCloneBlobFromRawData(
								 (PIIS_CRYPTO_BLOB*)&m_pBlob[iCol],
								 pbTemp,
								 cbTemp
								 );

				delete [] pbTemp;
				pbTemp = NULL;

				if (FAILED(hr)) 
				{
			        TRACE(L"[CSimpleTableC::PopulateCache]: IISCryptoCloneBlobFromRawData Failed - error 0x%0x\n", hr);
					break;
				}

				DWORD dummyRegType;
				
				ASSERT(::IISCryptoIsValidBlob((PIIS_CRYPTO_BLOB)m_pBlob[iCol]));
				hr = CryptoStorage.DecryptData(
									   (PVOID *)&m_pData[iCol],
									   &m_pcbBuf[iCol],
									   &dummyRegType,
									   (PIIS_CRYPTO_BLOB)m_pBlob[iCol]
									   );
				if (FAILED(hr)) 
				{
			        TRACE(L"[CSimpleTableC::PopulateCache]: CryptoStorage.DecryptData Failed - error 0x%0x\n", hr);
					break;
				}
			}
        }


        hr = m_pISTWrite->SetWriteColumnValues( iWriteRow, m_cColumns, NULL, 
                                           m_pcbBuf, m_pData );
    
        if ( FAILED(hr) ) break;

		// Free any allocations made for decryption.
		if (m_pBlob)
		{
			for( iCol = 0; iCol < m_cColumns; iCol ++ )
			{
				if (m_pBlob[iCol])
				{
					::IISCryptoFreeBlob((PIIS_CRYPTO_BLOB)m_pBlob[iCol]);
					m_pBlob[iCol] = NULL;
				}
			}
		}
    }

ErrExit:
    //Notify base class that population is over
    m_pISTController->PostPopulateCache();

    pICR->CloseCursor( &cur );

	// Free any allocations made for decryption.
	if (m_pBlob)
	{
		for( iCol = 0; iCol < m_cColumns; iCol ++ )
		{
			if (m_pBlob[iCol])
			{
				::IISCryptoFreeBlob((PIIS_CRYPTO_BLOB)m_pBlob[iCol]);
				m_pBlob[iCol] = NULL;
			}
		}
	}

    return hr;
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::UpdateStore ( void )
{
    HRESULT hr = S_OK;
    CRCURSOR cur;
    ULONG cRecords;
    void*   pRecord = NULL;
    int iFetched;
    ULONG iCol, j;
    ULONG iWriteRow;
    DWORD eAction;
    
    IComponentRecords  *pICR = NULL;
	TABLEID tableid;
    LPVOID  pkData[MAX_PK_COLUMNS];
    ULONG   pkcb[MAX_PK_COLUMNS];
    HANDLE  hWriteLock = NULL;

    ULONG stPKColumns[MAX_PK_COLUMNS];
	STErr stErr;
	BOOL bDetailErr = FALSE;
    IIS_CRYPTO_STORAGE *pCryptoStorage = NULL;
	ULONG cbBlob = 0;
	PIIS_CRYPTO_BLOB pBlob = NULL;

	if (!(m_fTable & fST_LOS_READWRITE)) return E_NOTIMPL;

    for ( iCol = 0; iCol < m_cPKColumns; iCol ++ )
        stPKColumns[iCol] = m_aPKColumns[iCol]-1;

	if ( !(m_fTable & fST_LOS_COOKDOWN) )
    {
        hr = GetWriteLock( NULL, m_wszFileName, &hWriteLock );
        if ( FAILED(hr) ) return hr;
    }

    __try{
    
	if (m_bRequiresEncryption)
	{
		pCryptoStorage = new IIS_CRYPTO_STORAGE;
		if (NULL == pCryptoStorage)
		{
			return E_OUTOFMEMORY;
		}

		hr = GetCryptoStorage(pCryptoStorage, m_wszFileName, m_fTable, TRUE);
		if (FAILED(hr)) 
		{
			TRACE(L"[CSimpleTableC::UpdateStore] GetCryptoStorage failed with hr = 0x%x.\n", hr);
			return hr;
		}
	}

    hr = CLBGetWriteICR( m_wszFileName, &pICR, &m_complibSchema, &m_sSchemaBlob );
    if ( FAILED(hr) ) return hr;

    hr = pICR->OpenTable(&m_complibSchema, m_tableIndex, &tableid );
    if ( FAILED(hr) ) return hr;

//    hr = InternalPreUpdateStore ();
//    if ( FAILED(hr) ) return hr;

    if ( NULL == m_pData )
    {
        m_pData = new LPVOID[m_cColumns];
        if ( NULL == m_pData ) return E_OUTOFMEMORY;
        m_iType = new DBTYPE[m_cColumns];
        if ( NULL == m_iType ) return E_OUTOFMEMORY;
        m_cbBuf = new ULONG[m_cColumns];
        if ( NULL == m_cbBuf ) return E_OUTOFMEMORY;
        m_pcbBuf = new ULONG[m_cColumns];
        if ( NULL == m_pcbBuf ) return E_OUTOFMEMORY;
        m_colhr = new HRESULT[m_cColumns];
        if ( NULL == m_colhr ) return E_OUTOFMEMORY;
		if (m_bRequiresEncryption)
		{
			m_pBlob = (LPVOID*)new PWCHAR[m_cColumns];
			if ( NULL == m_pBlob ) return E_OUTOFMEMORY;
			ZeroMemory( m_pBlob, m_cColumns*sizeof(PIIS_CRYPTO_BLOB) );
		}
    }

    for ( iWriteRow = 0;; iWriteRow++ )
    {
        hr = m_pISTController->GetWriteRowAction( iWriteRow, &eAction );

		if ( FAILED(hr) )
		{
			if ( E_ST_NOMOREROWS == hr )	
				hr = S_OK;

            break;
        }

        if ( eST_ROW_IGNORE == eAction )
            continue;
        
        //For update and delete, find the matching record in the complib first
        if ( eST_ROW_UPDATE == eAction || eST_ROW_DELETE == eAction )
        {
            hr = m_pISTWrite->GetWriteColumnValues( iWriteRow, m_cPKColumns, stPKColumns, NULL, pkcb, pkData );
            if ( FAILED(hr) ) break;

			if(m_cPKColumns > 1)
			{
				for ( iCol = 0; iCol < m_cPKColumns; iCol++ )
				{
					pkData[iCol] = pkData[ stPKColumns[iCol] ];
					pkcb[iCol] = pkcb[ stPKColumns[iCol] ];
				}
			}

            iFetched = 0;

            hr = pICR->QueryByColumns(
                                tableid, &m_PKQryHint, m_cPKColumns,
                                m_aPKColumns, NULL, (const void **) pkData,
                                pkcb, m_aPKTypes, &pRecord, 1, NULL, &iFetched );

            if ( hr == CLDB_E_RECORD_NOTFOUND )
            {
                if ( eST_ROW_UPDATE == eAction )
                {   //trying to update a row that doesn't exist is an error. Log it as detail
					//error and continue, caller should be able to fix it and call UpdateStore again.
                
					stErr.iRow = iWriteRow; 
					stErr.hr = E_ST_ROWDOESNOTEXIST;
					stErr.iColumn = 0;
					hr = m_pISTController->AddDetailedError(&stErr);
					if ( FAILED(hr) ) break;
					bDetailErr = TRUE;
				}									
					
                //trying to delete a row that doesn't exist is NOT an error
				continue;
            }
        }

        //Do insert or update
        if ( eST_ROW_UPDATE == eAction || eST_ROW_INSERT == eAction )
        {
            hr = m_pISTWrite->GetWriteColumnValues( iWriteRow, m_cColumns, NULL, NULL, m_cbBuf, m_pData );
            if ( FAILED(hr) ) break;

            ZeroMemory( m_colhr, m_cColumns*sizeof( HRESULT ) );
            
            for ( iCol = 0; iCol < m_cColumns; iCol ++ )
            { 
                if ( m_pData[iCol] == NULL )
                    m_colhr[iCol] = DBSTATUS_S_ISNULL;  

                m_iType[iCol] = static_cast<DBTYPE>( m_pColumnMeta[iCol].dbType );

				// Encrypt the data if this is a secure property.
				if (m_pColumnAttrib[iCol] & fCOLUMNMETA_SECURE)
				{
					// This code assumes all secure properties are of type DBTYPE_WSTR.
					ASSERT(m_iType[iCol] == DBTYPE_WSTR);
                    //
                    // This is a secure data object, so encrypt it before saving it
                    // to the file.
                    //

                    hr = pCryptoStorage->EncryptData(&pBlob,
                                                     m_pData[iCol],
                                                     m_cbBuf[iCol],
                                                     0);
					if (FAILED(hr))
					{
                        TRACE(L"[UpdateStore] Unable to encrypt data. Failed with hr = 0x%x.\n", hr);
						break;
					}
					
					// Convert the binary data into a string representation. Each byte is represented
					// via two WCHARs.
					cbBlob = IISCryptoGetBlobLength(pBlob);
					m_pBlob[iCol] = new WCHAR [(cbBlob*2)+1];
					if(m_pBlob[iCol] == NULL)
					{
						hr = E_OUTOFMEMORY;
						break;
					}

					ByteArrayToString((PBYTE)pBlob, cbBlob, (WCHAR*)m_pBlob[iCol]);
                    m_pData[iCol] = m_pBlob[iCol];
                    m_cbBuf[iCol] = (cbBlob*2)+1;
				}
				
				if ( m_iType[iCol] == DBTYPE_WSTR )
				{
					m_cbBuf[iCol] = 0xffffffff;
				}
            }

			if (FAILED(hr))
			{
				break;
			}

			if ( eST_ROW_UPDATE == eAction )
			{
				hr = pICR->SetColumns(  tableid,
										pRecord,
										COLUMN_ORDINAL_LIST(m_cColumns),
										m_iType,
										(const void**)m_pData,
										m_cbBuf,
										m_pcbBuf,
										m_colhr,
										NULL
										);
			}
			else
			{   //insert
				hr = pICR->NewRecordAndData(tableid,
											&pRecord,
											NULL,
											0,
											COLUMN_ORDINAL_LIST(m_cColumns),
											m_iType,
											(const void**)m_pData,
											m_cbBuf,
											m_pcbBuf,
											m_colhr,
											NULL
											);
			}

			if (m_pBlob)
			{
				for( iCol = 0; iCol < m_cColumns; iCol ++ )
				{
					if (m_pBlob[iCol])
					{
						delete [] m_pBlob[iCol];
						m_pBlob[iCol] = NULL;
					}
				}
			}

            if ( FAILED(hr) )
            {
				//Primary key or unique index violation. Log it as detail error and continue, 
				//caller should be able to fix it and call UpdateStore again.
                if ( CLDB_E_INDEX_DUPLICATE == hr ) 
				{
					stErr.iRow = iWriteRow; 
					stErr.hr = E_ST_ROWALREADYEXISTS;
					stErr.iColumn = 0;
					hr = m_pISTController->AddDetailedError(&stErr);
					if ( FAILED(hr) ) break;
					bDetailErr = TRUE;
					continue;
				}
				else 
					break;
            }

			//Check for column level error. Log as detail error. 
			for ( iCol = 0; iCol < m_cColumns; iCol ++ )
			{
				if ( FAILED( m_colhr[iCol] ) )
				{	
					stErr.iRow = iWriteRow; 
					if (CLDB_E_NOTNULLABLE == m_colhr[iCol])
					{
						stErr.hr = E_ST_VALUENEEDED;
					}
					else
					{
						stErr.hr = m_colhr[iCol];
					}
					stErr.iColumn = iCol;
					hr = m_pISTController->AddDetailedError(&stErr);
					if ( FAILED(hr) ) break;
					bDetailErr = TRUE;
				}
			}

        }
        else if ( eST_ROW_DELETE == eAction ) //Do delete
        {
            ULONG rid;

            hr = pICR->GetRIDForRow(tableid, pRecord,&rid );
            if ( FAILED(hr) ) break;

            hr = pICR->DeleteRowByRID(tableid, rid );
            if ( FAILED(hr) ) break;
        }
        else
            ASSERT(0);
    }   //for

	if (m_pBlob)
	{
		for( iCol = 0; iCol < m_cColumns; iCol ++ )
		{
			if (m_pBlob[iCol])
			{
				delete [] m_pBlob[iCol];
				m_pBlob[iCol] = NULL;
			}
		}
	}

	// m_pISTController->DiscardPendingWrites (); //comment this out for Bug 5789, this method cleans up write cache and error cache

	if ( SUCCEEDED(hr) && bDetailErr )
		hr = E_ST_DETAILEDERRS;
	else
		m_pISTController->DiscardPendingWrites (); //Fix for Bug 9266


    if ( !(m_fTable & fST_LOS_COOKDOWN) )
    {
        if ( FAILED(hr) )
        {
            pICR->Release();
			pICR = NULL;
            VERIFY (SUCCEEDED(CLBAbortWrite( NULL, m_wszFileName )) );
        }
        else
        {
            pICR->Release();
			pICR = NULL;
            hr = CLBCommitWrite( NULL, m_wszFileName );
        }   
    }

    }   //__try
    __finally
    {
		if (pCryptoStorage)
		{
			delete pCryptoStorage;
		}

		if (pICR)
		{
			pICR->Release();
		}

        if ( !(m_fTable & fST_LOS_COOKDOWN) )
            ReleaseWriteLock( hWriteLock );
    }
        
    return hr;

}

HRESULT STDMETHODCALLTYPE CSimpleTableC::GetRowIndexByIdentity ( 
            ULONG *i_acb,
            LPVOID *i_apv,
            ULONG* o_piRow)
{
    return m_pISTWrite->GetRowIndexByIdentity( i_acb, i_apv, o_piRow);
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::GetColumnValues(ULONG i_iRow,
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            ULONG* o_acbSizes, 
            LPVOID* o_apvValues)
{
    return m_pISTWrite->GetColumnValues( i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::GetTableMeta(
            ULONG* o_pcVersion, 
            DWORD* o_pfTable,
            ULONG* o_pcRows, 
            ULONG* o_pcColumns)
{
    if(NULL != o_pfTable)
    {
        *o_pfTable = m_fTable;
    }
    return m_pISTWrite->GetTableMeta(o_pcVersion,NULL, o_pcRows,o_pcColumns);
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::GetColumnMetas(
            ULONG i_cColumns, 
            ULONG* i_aiColumns,
            SimpleColumnMeta* o_aColumnMetas)
{
    return m_pISTWrite->GetColumnMetas(i_cColumns, i_aiColumns, o_aColumnMetas);
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::AddRowForDelete (ULONG i_iReadRow)
{
    return m_pISTWrite->AddRowForDelete( i_iReadRow );
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::AddRowForInsert (ULONG* o_piWriteRow)
{
    return m_pISTWrite->AddRowForInsert ( o_piWriteRow );
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::AddRowForUpdate (ULONG i_iReadRow, ULONG* o_piWriteRow)
{
    return m_pISTWrite->AddRowForUpdate (i_iReadRow,o_piWriteRow);
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::GetWriteColumnValues   (
            ULONG i_iRow,
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            DWORD* o_afStatus, 
            ULONG* o_acbSizes, 
            LPVOID* o_apvValues)
{
    return m_pISTWrite->GetWriteColumnValues ( i_iRow, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes, o_apvValues);
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::SetWriteColumnValues   (
            ULONG i_iRow,
            ULONG i_cColumns, 
            ULONG* i_aiColumns, 
            ULONG* i_acbSizes, 
            LPVOID* i_apvValues)
{
    return m_pISTWrite->SetWriteColumnValues ( i_iRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues ); 
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::GetWriteRowIndexByIdentity(ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
    return m_pISTWrite->GetWriteRowIndexByIdentity( i_acbSizes, i_apvValues, o_piRow);
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::GetDetailedErrorCount(ULONG* o_pcErrs)
{
    return m_pISTController->GetDetailedErrorCount(o_pcErrs);
}

HRESULT STDMETHODCALLTYPE CSimpleTableC::GetDetailedError(ULONG i_iErr, STErr* o_pSTErr)
{
    return m_pISTController->GetDetailedError( i_iErr, o_pSTErr);
}

// ------------------------------------
// ISimpleTableControl:
// ------------------------------------

// ==================================================================
HRESULT STDMETHODCALLTYPE CSimpleTableC::ShapeCache (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes)
{
    return m_pISTController->ShapeCache (m_fTable, i_cColumns, i_acolmetas, i_apvDefaults, i_acbSizes);
}

// ==================================================================
HRESULT STDMETHODCALLTYPE CSimpleTableC::PrePopulateCache (DWORD i_fControl)
{
    m_pISTController->PrePopulateCache (i_fControl);
    return S_OK;
}

// ==================================================================
HRESULT STDMETHODCALLTYPE CSimpleTableC::PostPopulateCache ()
{
    m_pISTController->PostPopulateCache ();
    return S_OK;
}

// ==================================================================
HRESULT STDMETHODCALLTYPE CSimpleTableC::DiscardPendingWrites ()
{
    m_pISTController->DiscardPendingWrites ();
    return S_OK;
}

// ==================================================================
HRESULT STDMETHODCALLTYPE CSimpleTableC::GetWriteRowAction(ULONG i_iRow, DWORD* o_peAction)
{
    return m_pISTController->GetWriteRowAction(i_iRow, o_peAction);
}

// ==================================================================
HRESULT STDMETHODCALLTYPE CSimpleTableC::SetWriteRowAction(ULONG i_iRow, DWORD i_eAction)
{
    return m_pISTController->SetWriteRowAction(i_iRow, i_eAction);
}

// ==================================================================
HRESULT STDMETHODCALLTYPE CSimpleTableC::ChangeWriteColumnStatus (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus)
{
    return m_pISTController->ChangeWriteColumnStatus (i_iRow, i_iColumn, i_fStatus);
}

// ==================================================================
HRESULT STDMETHODCALLTYPE CSimpleTableC::AddDetailedError (STErr* i_pSTErr)
{
    return m_pISTController->AddDetailedError (i_pSTErr);
}
// ==================================================================
HRESULT STDMETHODCALLTYPE CSimpleTableC::GetMarshallingInterface (IID * o_piid, LPVOID * o_ppItf)
{
    return m_pISTController->GetMarshallingInterface (o_piid, o_ppItf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\complibtable\sthelper.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include "simpletable.h"
#include "catmeta.h"
#include "sdtfst.h"
#include "atlbase.h"
#include "catmacros.h"
#include "clbread.h"


extern HMODULE	g_hModule;

//***********************************************************************************************
//Get the column meta for a table
//***********************************************************************************************

const ULONG g_aMetaColumns[] = { iCOLUMNMETA_Type, iCOLUMNMETA_Size, iCOLUMNMETA_MetaFlags,iCOLUMNMETA_Attributes };


HRESULT _GetColumnMeta(	LPCWSTR wszDatabase, LPCWSTR wszTable, SimpleColumnMeta **pColumnMeta, ULONG *pcColumns, ULONG *pcPKColumns, ULONG aPKColumns[], DBTYPE aPKTypes[], QUERYHINT *pPKQryHint, DWORD **ppColumnAttrib, IAdvancedTableDispenser*	pISTDisp )
{
	CComPtr<ISimpleTableRead2> 	pISTMeta;
	STQueryCell		qcellMeta;
	ULONG			cCells = 1;
	ULONG			i = 0;
	HRESULT			hr;
	
	ASSERT(*ppColumnAttrib == NULL);

	*pColumnMeta = NULL;
	*pcColumns = 0;
	*pcPKColumns = 0;

	qcellMeta.pData		= const_cast<LPWSTR>(wszTable);
	qcellMeta.eOperator = eST_OP_EQUAL;
	qcellMeta.iCell	= iCOLUMNMETA_Table;
	qcellMeta.dbType	= DBTYPE_WSTR;
	qcellMeta.cbSize	= (ULONG)wcslen(wszTable);

	hr = pISTDisp->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, (LPVOID) &qcellMeta, (LPVOID) &cCells, eST_QUERYFORMAT_CELLS, 0, (LPVOID*) &pISTMeta);
	if ( FAILED(hr) ) return hr;

	hr = pISTMeta->GetTableMeta (NULL, NULL, pcColumns, NULL);
	if ( FAILED(hr) ) return hr;



	*pColumnMeta = new SimpleColumnMeta[*pcColumns];
	if ( *pColumnMeta == NULL ) return E_OUTOFMEMORY;

	*ppColumnAttrib = new ULONG[*pcColumns];
	if ( *ppColumnAttrib == NULL ) 
	{
		hr = E_OUTOFMEMORY;
		goto ErrExit;
	}

	// Get Column meta:
	for (i = 0; i < *pcColumns; i++)	
	{
		LPVOID pv[cCOLUMNMETA_NumberOfColumns];

		// Get dbType, cbSize and fMeta:
		hr = pISTMeta->GetColumnValues( i, 4, (ULONG *)g_aMetaColumns, NULL, pv );
		if ( E_ST_NOMOREROWS == hr )
		{
			hr = S_OK;

			if ( *pcColumns != i )
			{
				ASSERT( 0 );
				hr = E_UNEXPECTED;
			}
			
			break;
		}
		else if ( FAILED(hr) )
			goto ErrExit;


        // Multistrings are handled as bytes in the clb.
		if ((fCOLUMNMETA_MULTISTRING & *(DWORD*)(pv[iCOLUMNMETA_MetaFlags])) && 
			(eCOLUMNMETA_String == *(DWORD*)(pv[iCOLUMNMETA_Type])))
		{
			(*pColumnMeta)[i].dbType = eCOLUMNMETA_BYTES;
		}
		else
		{
			(*pColumnMeta)[i].dbType = *(DWORD*)(pv[iCOLUMNMETA_Type]);
		}

		(*pColumnMeta)[i].cbSize = *(DWORD*)(pv[iCOLUMNMETA_Size]);

		(*pColumnMeta)[i].fMeta = *(DWORD*)(pv[iCOLUMNMETA_MetaFlags]);

		if ( (*pColumnMeta)[i].fMeta & fCOLUMNMETA_PRIMARYKEY )
		{
			if ( aPKColumns )
				aPKColumns[*pcPKColumns] = i + 1;
			if ( aPKTypes )
				aPKTypes[*pcPKColumns] = static_cast<DBTYPE>((*pColumnMeta)[i].dbType);
			(*pcPKColumns)++;
			ASSERT( *pcPKColumns <= MAX_PK_COLUMNS );
		}

		(*ppColumnAttrib)[i] = *(DWORD*)(pv[iCOLUMNMETA_Attributes]);
		
		
	}

	//Fill in the PK column hint
	pPKQryHint->iType = QH_COLUMN;
	if ( *pcPKColumns == 1 )
		pPKQryHint->columnid = aPKColumns[0];	
	else if ( *pcPKColumns > 1 )
		pPKQryHint->columnid = QUERYHINT_PK_MULTICOLUMN;


ErrExit:
	if ( FAILED(hr) )
	{
		if (*pColumnMeta )
		{
			delete [] *pColumnMeta;
			*pColumnMeta = NULL;
		}

		if (*ppColumnAttrib )
		{
			delete [] *ppColumnAttrib;
			*ppColumnAttrib = NULL;
		}
	}
	return hr;
}

//***********************************************************************************************
//Get the query hint if there's any. Fill in the query structure. 
//***********************************************************************************************
HRESULT _RetainQuery( LPCWSTR wszTable,STQueryCell aQueryCell[], ULONG cQueryCells, ULONG cPKColumns, SimpleColumnMeta aColumnMeta[],
					  QUERYHINT *pPKQryHint, QUERYHINT **ppQryHint,WCHAR szIndexName[],
					  ULONG *pcQryColumns, ULONG **piColumns, LPVOID **ppbData, ULONG **pcbData, 
					  DBTYPE **piTypes, DBCOMPAREOP **pfCompare )
{
	ULONG	i, j, iSpecial;

	*ppQryHint = NULL;
	
	// Scan the special query cells, assume special cells are always before normal ones
	for ( iSpecial = 0; iSpecial < cQueryCells; iSpecial++ )
	{
		if ( !(aQueryCell[iSpecial].iCell & iST_CELL_SPECIAL) )
			break;

		if ( aQueryCell[iSpecial].iCell == iST_CELL_INDEXHINT )
		{
			LPWSTR pwszDex = (LPWSTR)aQueryCell[iSpecial].pData;

			if ( wcscmp( pwszDex, DEX_MPK ) == 0 )
				*ppQryHint = pPKQryHint;
			else
			{
				*ppQryHint = new QUERYHINT;
				if ( *ppQryHint == NULL )
					return E_OUTOFMEMORY;	

				(*ppQryHint)->iType = QH_INDEX;
				wcscpy( szIndexName, (LPWSTR)aQueryCell[iSpecial].pData );
			 
				(*ppQryHint)->szIndex = szIndexName;
			}
			
		}
	
	}

	*pcQryColumns = cQueryCells - iSpecial;

	//If the query is on PK or single indexed column, I should figure out the query hint myself.
	if ( *ppQryHint == NULL )
	{
		//For single column EQ query, check to see if it's indexed or PK
		if ( *pcQryColumns == 1 )
		{
			if ( aQueryCell[iSpecial].eOperator == eST_OP_EQUAL )
			{
				ULONG iCol = aQueryCell[iSpecial].iCell;

				if( aColumnMeta[iCol].fMeta & fCOLUMNMETA_PRIMARYKEY && cPKColumns == 1 ) 
				{
					*ppQryHint = pPKQryHint;
				}
				else
				{
					//Find the single column index hint in the column meta table
					ULONG icolMeta;	//index into the column meta table
					LPVOID apv[2] = { (LPVOID)wszTable, (LPVOID)&iCol };
					HRESULT hr = (_GetCLBReadState()->pISTReadColumnMeta)->GetRowIndexByIdentity( NULL, apv, &icolMeta );
					if ( FAILED(hr) )
						return hr;

					const ColumnMeta *pColumnMeta = _GetCLBReadState()->pFixedTableHeap->Get_aColumnMeta(icolMeta);
					
					if ( pColumnMeta->iIndexName )
					{		 
						*ppQryHint = new QUERYHINT;
						if ( *ppQryHint == NULL )
							return E_OUTOFMEMORY;	

						(*ppQryHint)->iType = QH_INDEX;
						(*ppQryHint)->szIndex = _GetCLBReadState()->pFixedTableHeap->StringFromIndex(pColumnMeta->iIndexName);
					}
				}
			}

		}
		else if ( (*pcQryColumns == cPKColumns) && aQueryCell &&
				  (aColumnMeta[aQueryCell[iSpecial].iCell].fMeta & fCOLUMNMETA_PRIMARYKEY) )// Check to see if the cells match multi-column PK
		{
			BOOL bIsPK = TRUE;

			for ( i	= iSpecial + 1; i < *pcQryColumns; i ++ )
			{
				if ( aQueryCell[i].iCell <= aQueryCell[i-1].iCell ||
					 !(aColumnMeta[aQueryCell[i].iCell].fMeta & fCOLUMNMETA_PRIMARYKEY) )
				{
					bIsPK = FALSE;
					break;
				}
			}
			
			if ( bIsPK )
				*ppQryHint = pPKQryHint;		
		}
	}

	//Allocate and fill up the arrays for Complib query
	j = 0;
	if ( *pcQryColumns > 0 )
	{
		 *piColumns = new  ULONG[*pcQryColumns];
		 if ( NULL == *piColumns ) return E_OUTOFMEMORY;
		 *ppbData  = new  LPVOID[*pcQryColumns];
		 if ( NULL == *ppbData ) return E_OUTOFMEMORY;
		 memset ( *ppbData, 0, sizeof(LPVOID)*(*pcQryColumns) );
		 *pcbData  = new  ULONG[*pcQryColumns];
		 if ( NULL == *pcbData  ) return E_OUTOFMEMORY;
		 *piTypes   = new  DBTYPE[*pcQryColumns];
		 if ( NULL == *piTypes ) return E_OUTOFMEMORY;
		 *pfCompare = new DBCOMPAREOP[*pcQryColumns];
		 if ( NULL == *pfCompare ) return E_OUTOFMEMORY;

		 for ( i = iSpecial; i < cQueryCells; i++ )
		 {
			int iCol = aQueryCell[i].iCell;

			if ( !(aQueryCell[i].iCell & iST_CELL_SPECIAL) )
			{
				(*piColumns)[j] = iCol + 1;
				if ( aQueryCell[i].cbSize )
					(*pcbData)[j] = aQueryCell[i].cbSize;
				else if ( aColumnMeta[ iCol ].dbType == DBTYPE_WSTR && aQueryCell[i].pData )
					(*pcbData)[j] = ( (int)wcslen( reinterpret_cast<LPWSTR>(aQueryCell[i].pData) )  + 1 )* sizeof(WCHAR);
				else
					(*pcbData)[j] = aColumnMeta[ iCol ].cbSize;


				(*piTypes)[j] = static_cast<USHORT>(aQueryCell[i].dbType);

				switch ( aQueryCell[i].eOperator )
				{
				case eST_OP_EQUAL:
					(*pfCompare)[j] = DBCOMPAREOPS_EQ;
				break;
				case eST_OP_NOTEQUAL:
					(*pfCompare)[j] = DBCOMPAREOPS_NE;
				break;
				default:
					return E_INVALIDARG;
				}

				if ( (*pcbData)[j] > 0 )
				{
					if ( aQueryCell[i].pData )
					{
						(*ppbData)[j] = new BYTE[ (*pcbData)[j] ];	
						if ( NULL == (*ppbData)[j] ) return E_OUTOFMEMORY;
						memcpy( (*ppbData)[j], aQueryCell[i].pData, (*pcbData)[j] );
					}
					else
						(*piTypes)[j] = DBTYPE_NULL;
				}
				else
					(*piTypes)[j] = DBTYPE_NULL;

				// If a column is not nullable, user can't pass a query that has a NULL column value.
				if ((DBTYPE_NULL == (*piTypes)[j]) && (aColumnMeta[iCol].fMeta & fCOLUMNMETA_NOTNULLABLE))
				{
					return (E_ST_INVALIDQUERY);	
				}

				j++;
			}
		}
	}
		
	return S_OK;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\fixedpackedschema.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __FIXEDPACKEDSCHEMA_H__
#define __FIXEDPACKEDSCHEMA_H__

extern ULONG g_aFixedTableHeap[];                                                                                                               
#define g_aTableSchemaHeap (g_aFixedTableHeap + 0x400)

#endif //__FIXEDPACKEDSCHEMA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\fixedpackedschema.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.

#include "windows.h"
#include "FixedPackedSchema.h"
#include "catalog.h"
#ifndef __TABLESCHEMA_H__
    #include "TableSchema.h"
#endif

//The TableSchemaHeap is layed out as follows, the fixed length data comes first
/*
    ULONG           TableSchemaHeapSignature0
    ULONG           TableSchemaHeapSignature1
    ULONG           CountOfTables                       This is interesting only when no query is supplied and we want to walk through every table (this won't be efficient)
    ULONG           TableSchemaRowIndex                 This is the byte offset just beyond the last TableSchema entry.
    ULONG           EndOfHeap                           This is the byte offset just beyond the heap.  All indexes should be less than this
    ULONG           Reserved1
    ULONG           Reserved2
    ULONG           Reserved3
    HashTableHeader TableNameHashHeader                 This is the hash table that map a TableID to its aTableSchema byte offset (from the beginning of TableSchemaHeap)
    HashedIndex     aHashedIndex[507]                   The HashTableHeader contains the modulo (503 is the largest prime number less than the hash table size) for the hash table; but the table can never grow beyond this pre-allocated space.
                                                        This size was chosen so that the entire hash table would fit into the same page in memory.
---------------------------<Page Boundary>---------------------------
    unsigned char   aTableSchema[]                      This is where each Table's TableSchema goes.  FirstTableID (4096) == &aTableSchema[0] - &TableSchemaHeap, LastTableID == &aTableSchema[CountOfTables-1] - &TableSchemaHeap
    ULONG           aTableSchemaRowIndex[CountOfTables] This is used to walk ALL of the tables.  Presumably, someone will get all the CollectionMeta and iterate through all of them

One optimization we could do is to make sure that every table's schema (whose size is <=4096) fits into one page.  In other words, minimize TableSchema crossing a page boundary
*/

#define g_aTableSchemaHeap (g_aFixedTableHeap + 0x400)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedtable\goremacros.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
// Data in the tables
#define gore_aColumnMeta           (m_bExtendedMeta ?      m_pEM->aColumnMeta          : g_aColumnMeta)
#define gore_aDatabaseMeta         (m_bExtendedMeta ?      m_pEM->aDatabaseMeta        : g_aDatabaseMeta)
#define gore_aIndexMeta            (m_bExtendedMeta ?      m_pEM->aIndexMeta           : g_aIndexMeta)
#define gore_aTableMeta            (m_bExtendedMeta ?      m_pEM->aTableMeta           : g_aTableMeta)
#define gore_aTagMeta              (m_bExtendedMeta ?      m_pEM->aTagMeta             : g_aTagMeta)
#define gore_aQueryMeta            (m_bExtendedMeta ?      m_pEM->aQueryMeta           : g_aQueryMeta)
#define gore_aRelationMeta         (m_bExtendedMeta ?      m_pEM->aRelationMeta        : g_aRelationMeta)

// Count of rows in the tables
#define gore_ciColumnMetas         (m_bExtendedMeta ?      *m_pEM->pciColumnMetas        : g_ciColumnMetas)
#define gore_ciDatabaseMetas       (m_bExtendedMeta ?      *m_pEM->pciDatabaseMetas      : g_ciDatabaseMetas)
#define gore_ciIndexMeta           (m_bExtendedMeta ?      *m_pEM->pciIndexMeta          : g_ciIndexMeta)
#define gore_ciTableMetas          (m_bExtendedMeta ?      *m_pEM->pciTableMetas         : g_ciTableMetas)
#define gore_ciTagMeta             (m_bExtendedMeta ?      *m_pEM->pciTagMeta            : g_ciTagMeta)
#define gore_ciQueryMeta           (m_bExtendedMeta ?      *m_pEM->pciQueryMeta          : g_ciQueryMeta)
#define gore_ciRelationMeta        (m_bExtendedMeta ?      *m_pEM->pciRelationMeta       : g_ciRelationMeta)

// Total count of rows in the tables
//#define gore_ciTotalColumnMetas    (m_bExtendedMeta ?      *m_pEM->pciTotalColumnMetas   : g_ciTotalColumnMetas)
//#define gore_ciTotalDatabaseMetas  (m_bExtendedMeta ?      *m_pEM->pciTotalDatabaseMetas : g_ciTotalDatabaseMetas)
//#define gore_ciTotalIndexMeta      (m_bExtendedMeta ?      *m_pEM->pciTotalIndexMeta     : g_ciTotalIndexMeta)
//#define gore_ciTotalTableMetas     (m_bExtendedMeta ?      *m_pEM->pciTotalTableMetas    : g_ciTotalTableMetas)
//#define gore_ciTotalTagMeta        (m_bExtendedMeta ?      *m_pEM->pciTotalTagMeta       : g_ciTotalTagMeta)
//#define gore_ciTotalQueryMeta      (m_bExtendedMeta ?      *m_pEM->pciTotalQueryMeta     : g_ciTotalQueryMeta)
//#define gore_ciTotalRelationMeta   (m_bExtendedMeta ?      *m_pEM->pciTotalRelationMeta  : g_ciTotalRelationMeta)

// Special stuff
#define gore_ulSignature           (m_bExtendedMeta ?      m_pEM->ulSignature          : g_ulSignature)

// Pools and pool sizes
#define gore_aBytes                (m_bExtendedMeta ?      m_pEM->aBytes               : g_aBytes)
//#define gore_ciBytes               (m_bExtendedMeta ?      *m_pEM->pciBytes              : g_ciBytes)
//#define gore_ciTotalBytes          (m_bExtendedMeta ?      *m_pEM->pciTotalBytes         : g_ciTotalBytes)

#define gore_aGuid                 (m_bExtendedMeta ?      m_pEM->aGuid                : g_aGuid)
//#define gore_ciGuid                (m_bExtendedMeta ?      *m_pEM->pciGuid               : g_ciGuid)
//#define gore_ciTotalGuid           (m_bExtendedMeta ?      *m_pEM->pciTotalGuid          : g_ciTotalGuid)

#define gore_aHashedIndex          (m_bExtendedMeta ?      m_pEM->aHashedIndex         : g_aHashedIndex)
//#define gore_ciHashedIndex         (m_bExtendedMeta ?      *m_pEM->pciHashedIndex        : g_ciHashedIndex)
//#define gore_ciTotalHashedIndex    (m_bExtendedMeta ?      *m_pEM->pciTotalHashedIndex   : g_ciTotalHashedIndex)

#define gore_aUI4                  (m_bExtendedMeta ?      m_pEM->aUI4                 : g_aUI4)
//#define gore_ciUI4                 (m_bExtendedMeta ?      *m_pEM->pciUI4                : g_ciUI4)
//#define gore_ciTotalUI4            (m_bExtendedMeta ?      *m_pEM->pciTotalUI4           : g_ciTotalUI4)

#define gore_aULong                (m_bExtendedMeta ?      m_pEM->aULong               : g_aULong)
//#define gore_ciULong               (m_bExtendedMeta ?      *m_pEM->pciULong              : g_ciULong)
//#define gore_ciTotalULong          (m_bExtendedMeta ?      *m_pEM->pciTotalULong         : g_ciTotalULong)

#define gore_aWChar                (m_bExtendedMeta ?      m_pEM->aWChar               : g_aWChar)
//#define gore_ciWChar               (m_bExtendedMeta ?      *m_pEM->pciWChar              : g_ciWChar)
//#define gore_ciTotalWChar          (m_bExtendedMeta ?      *m_pEM->pciTotalWChar         : g_ciTotalWChar)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\errortable\errortable.h ===
/********************************************************************++
 
Copyright (c) 2001 Microsoft Corporation
 
Module Name:
 
    ErrorTable.h
 
Abstract:
 
    Detailed Errors go into a table. This is the implementation of
    that table.
 
Author:
 
    Stephen Rakonza (stephenr)        9-Mar-2001
 
Revision History:
 
--********************************************************************/

#pragma once


class ErrorTable : public ISimpleTableInterceptor
                  ,public ISimpleTableWrite2
                  ,public ISimpleTableController
                  ,public IErrorInfo
{
public:
    ErrorTable () : m_cRef(0), m_IsIntercepted(0){}
    virtual ~ErrorTable () {}

//IUnknown
public:
    STDMETHOD (QueryInterface)          (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)            ();
    STDMETHOD_(ULONG,Release)           ();


    //ISimpleTableInterceptor
    STDMETHOD (Intercept)               (LPCWSTR                    i_wszDatabase,
                                         LPCWSTR                    i_wszTable, 
										 ULONG						i_TableID,
                                         LPVOID                     i_QueryData,
                                         LPVOID                     i_QueryMeta,
                                         DWORD                      i_eQueryFormat,
                                         DWORD                      i_fLOS,
                                         IAdvancedTableDispenser*   i_pISTDisp,
                                         LPCWSTR                    i_wszLocator,
                                         LPVOID                     i_pSimpleTable,
                                         LPVOID*                    o_ppvSimpleTable
                                        );

	// ISimpleTableRead2
    STDMETHOD (GetRowIndexByIdentity)   (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        {   return m_spISTWrite->GetRowIndexByIdentity(i_acbSizes, i_apvValues, o_piRow);    }
    STDMETHOD (GetRowIndexBySearch)     (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        {   return m_spISTWrite->GetRowIndexBySearch(i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);}
	STDMETHOD (GetColumnValues)         (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
                                        {   return m_spISTWrite->GetColumnValues(i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);}
	STDMETHOD (GetTableMeta)            (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG* o_pcRows, ULONG* o_pcColumns )
                                        {   return m_spISTWrite->GetTableMeta(o_pcVersion, o_pfTable, o_pcRows, o_pcColumns);}
	STDMETHOD (GetColumnMetas)	        (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas )
                                        {   return m_spISTWrite->GetColumnMetas(i_cColumns, i_aiColumns, o_aColumnMetas );}

    //ISimpleTableWrite2 : ISimpleTableRead2
	STDMETHOD (AddRowForDelete)		    (ULONG i_iReadRow)
                                        {   return m_spISTWrite->AddRowForDelete(i_iReadRow);}
	STDMETHOD (AddRowForInsert)		    (ULONG* o_piWriteRow)
                                        {   return m_spISTWrite->AddRowForInsert(o_piWriteRow);}
	STDMETHOD (AddRowForUpdate)		    (ULONG i_iReadRow, ULONG* o_piWriteRow)
                                        {   return m_spISTWrite->AddRowForUpdate(i_iReadRow, o_piWriteRow);}
	STDMETHOD (SetWriteColumnValues)    (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues)
                                        {   return m_spISTWrite->SetWriteColumnValues(i_iRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues);}
	STDMETHOD (GetWriteColumnValues)    (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns,  DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
                                        {   return m_spISTWrite->GetWriteColumnValues(i_iRow, i_cColumns, i_aiColumns,  o_afStatus, o_acbSizes, o_apvValues);}
	STDMETHOD (GetWriteRowIndexByIdentity)	(ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        {   return m_spISTWrite->GetWriteRowIndexByIdentity(i_acbSizes, i_apvValues, o_piRow);}
	STDMETHOD (UpdateStore)				()
                                        {   return S_OK;}
	STDMETHOD (GetWriteRowIndexBySearch)(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        {   return m_spISTWrite->GetWriteRowIndexBySearch(i_iStartingRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues, o_piRow);}
	STDMETHOD (GetErrorTable)			(DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable)
                                        {   return m_spISTWrite->GetErrorTable(i_fServiceRequests, o_ppvSimpleTable);}

    //ISimpleTableAdvanced
	STDMETHOD (PopulateCache)			()
                                        {   return S_OK;}
	STDMETHOD (GetDetailedErrorCount)	(ULONG* o_pcErrs)
                                        {   return E_NOTIMPL;}
	STDMETHOD (GetDetailedError)		(ULONG i_iErr, STErr* o_pSTErr)
                                        {   return E_NOTIMPL;}

    //ISimpleTableController : ISimpleTableAdvanced
	STDMETHOD (ShapeCache)				(DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes)
                                        {   return m_spISTController->ShapeCache(i_fTable, i_cColumns, i_acolmetas, i_apvDefaults, i_acbSizes);}
	STDMETHOD (PrePopulateCache)		(DWORD i_fControl)
                                        {   return m_spISTController->PrePopulateCache(i_fControl);}
	STDMETHOD (PostPopulateCache)		()
                                        {   return m_spISTController->PostPopulateCache();}
	STDMETHOD (DiscardPendingWrites)	()
                                        {   return m_spISTController->DiscardPendingWrites();}
	STDMETHOD (GetWriteRowAction)		(ULONG i_iRow, DWORD* o_peAction)
                                        {   return m_spISTController->GetWriteRowAction(i_iRow, o_peAction);}
	STDMETHOD (SetWriteRowAction)		(ULONG i_iRow, DWORD i_eAction)
                                        {   return m_spISTController->SetWriteRowAction(i_iRow, i_eAction);}
	STDMETHOD (ChangeWriteColumnStatus)	(ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus)
                                        {   return m_spISTController->ChangeWriteColumnStatus(i_iRow, i_iColumn, i_fStatus);}
	STDMETHOD (AddDetailedError)		(STErr* o_pSTErr)
                                        {   return m_spISTController->AddDetailedError(o_pSTErr);}
	STDMETHOD (GetMarshallingInterface) (IID * o_piid, LPVOID * o_ppItf)
                                        {   return m_spISTController->GetMarshallingInterface(o_piid, o_ppItf);}

    //IErrorInfo
    STDMETHOD (GetGUID)                 (GUID *         o_pGUID);
    STDMETHOD (GetSource)               (BSTR *         o_pBstrSource);
    STDMETHOD (GetDescription)          (BSTR *         o_pBstrDescription);
    STDMETHOD (GetHelpFile)             (BSTR *         o_pBstrHelpFile);
    STDMETHOD (GetHelpContext)          (DWORD *        o_pdwHelpContext);

private:
    LONG                            m_cRef;
    LONG                            m_IsIntercepted;

    CComPtr<ISimpleTableWrite2>     m_spISTWrite;
    CComQIPtr<ISimpleTableController, &IID_ISimpleTableController> m_spISTController;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\fixedpackedschemainterceptor.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include <objbase.h>
#include "catalog.h"
#ifndef _CATALOGMACROS
    #include "catmacros.h"
#endif
#ifndef __TABLEINFO_H__  
    #include "catmeta.h"
#endif
#include "winwrap.h"
#ifndef __TABLESCHEMA_H__
    #include "TableSchema.h"
#endif 
#ifndef __HASH_H__
    #include "hash.h"
#endif
#include "FixedPackedSchemaInterceptor.h"
#ifndef __FIXEDPACKEDSCHEMA_H__
    #include "FixedPackedSchema.h"
#endif
#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif



//This gets rid of an 'if' inside GetColumnValues.  Since this function is called more than any other, even one 'if' should make a difference,
//especially when it's inside the 'for' loop.
const unsigned long  TFixedPackedSchemaInterceptor::m_aColumnIndex[] = {
        0x00,   0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,   0x09,   0x0a,   0x0b,   0x0c,   0x0d,   0x0e,   0x0f,
        0x10,   0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,   0x19,   0x1a,   0x1b,   0x1c,   0x1d,   0x1e,   0x1f,
        0x20,   0x21,   0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x29,   0x2a,   0x2b,   0x2c,   0x2d,   0x2e,   0x2f
    };

const TableSchema::TableSchemaHeap * TFixedPackedSchemaInterceptor::m_pTableSchemaHeap = reinterpret_cast<const TableSchema::TableSchemaHeap *>(g_aTableSchemaHeap);

HRESULT TFixedPackedSchemaInterceptor::GetTableID(LPCWSTR /*i_wszDatabaseName*/, LPCWSTR i_wszTableName, ULONG &o_TableID)
{
    return GetTableID(i_wszTableName, o_TableID);
}

HRESULT TFixedPackedSchemaInterceptor::GetTableID(LPCWSTR i_wszTableName, ULONG &o_TableID)
{
    o_TableID = TableIDFromTableName(i_wszTableName);//This does the bit manipulation; but we still need to verify that the string matches

    TableSchema::TTableSchema tableschema;
    if(FAILED(tableschema.Init(m_pTableSchemaHeap->Get_TableSchema(o_TableID))))//Get_TableSchema may return NULL, in which case Init should fail gracefully
        return E_ST_INVALIDTABLE;
    return (0==_wcsicmp(tableschema.GetWCharPointerFromIndex(tableschema.GetCollectionMeta()->InternalName), i_wszTableName) ? S_OK : E_ST_INVALIDTABLE);
}

HRESULT TFixedPackedSchemaInterceptor::GetTableName(ULONG i_TableID, LPCWSTR &o_wszTableName)
{
    TableSchema::TTableSchema tableschema;
    if(FAILED(tableschema.Init(m_pTableSchemaHeap->Get_TableSchema(i_TableID))))//If a bogus TableID was passed in Get_TableSchema will return NULL, and Init will fail.
        return E_ST_INVALIDTABLE;
    o_wszTableName      = tableschema.GetWCharPointerFromIndex(tableschema.GetCollectionMeta()->InternalName);
    return S_OK;
}

HRESULT TFixedPackedSchemaInterceptor::GetTableName(ULONG i_TableID, LPCWSTR &o_wszTableName, LPCWSTR &o_wszDatabaseName)
{
    TableSchema::TTableSchema tableschema;
    if(FAILED(tableschema.Init(m_pTableSchemaHeap->Get_TableSchema(i_TableID))))//If a bogus TableID was passed in Get_TableSchema will return NULL, and Init will fail.
        return E_ST_INVALIDTABLE;
    o_wszTableName      = tableschema.GetWCharPointerFromIndex(tableschema.GetCollectionMeta()->InternalName);
    o_wszDatabaseName   = tableschema.GetWCharPointerFromIndex(tableschema.GetCollectionMeta()->Database);
    return S_OK;
}


// ==================================================================
TFixedPackedSchemaInterceptor::TFixedPackedSchemaInterceptor () :
                 m_cColumns(0)
                ,m_cColumnsPlusPrivateColumns(0)
                ,m_ciRows(-1)
                ,m_cRef(0)
                ,m_fIsTable(false)
                ,m_pFixedData(0)
                ,m_pSimpleColumnMeta(0)
                ,m_TableMeta_MetaFlags(0)
                ,m_TableMeta_BaseVersion(0)
                ,m_TableSchemaHeap(*m_pTableSchemaHeap)
                ,m_MetaTable(m_eUnknownMeta)
{
}
// ==================================================================
TFixedPackedSchemaInterceptor::~TFixedPackedSchemaInterceptor ()
{
}


// ------------------------------------
// ISimpleDataTableDispenser:
// ------------------------------------

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::Intercept
(
    LPCWSTR					i_wszDatabase,
    LPCWSTR					i_wszTable, 
    ULONG                   i_TableID,
    LPVOID					i_QueryData,
    LPVOID					i_QueryMeta,
    DWORD					i_eQueryFormat,
	DWORD					i_fTable,
	IAdvancedTableDispenser* i_pISTDisp,
    LPCWSTR					i_wszLocator,
	LPVOID					i_pSimpleTable,
    LPVOID*					o_ppv
)
{
    /*
    The only tables we support are CollectionMeta, PropertyMeta, TagMeta, ServerWiring
    In the future we will also support Fixed tables whose data is contained within the TableSchema block (small fixed tables)

    The types of queries we support:
        CollectionMeta  by TableName
        PropertyMeta    by TableName
        PropertyMeta    by TableName & Index
        TagMeta         by TableName
        TagMeta         by TableName & ColumnIndex
        TagMeta         by TableName, ColumnIndex & InternalName
        ServerWiring       <no query>
        ServerWiring    by TableName
        ServerWiring    by TableName, Order
    */
    STQueryCell           * pQueryCell = (STQueryCell*) i_QueryData;    // Query cell array from caller.
    ULONG                   cQueryCells = 0;
    HRESULT                 hr;

	if (i_pSimpleTable)
		return E_INVALIDARG;
    if (i_QueryMeta)//The count is only valid if i_QueryMeta is not NULL
         cQueryCells= *(ULONG *)i_QueryMeta;

    //We don't support Intercept being called twice
    ASSERT(!m_fIsTable);if(m_fIsTable)return E_UNEXPECTED; // ie: Assert component is posing as class factory / dispenser.

    // Parameter validation:
    //Either i_TableID is non zero OR (i_wszDatabase==wszDATABASE_PACKEDSCHEMA && i_wszTable is NOT NULL)
    if(0==i_TableID)
    {
        if(NULL == i_wszDatabase)                   return E_INVALIDARG;
        if(NULL == i_wszTable)                      return E_INVALIDARG;

        //The only database we support is wszDATABASE_PACKEDSCHEMA (hack, we're handling wszDATABASE_META, TableMeta, ColumnMeta and TagMeta)
        if(0 != StringInsensitiveCompare(i_wszDatabase, wszDATABASE_META) && 
           0 != StringInsensitiveCompare(i_wszDatabase, wszDATABASE_PACKEDSCHEMA))return E_ST_INVALIDTABLE;
    }
    if(NULL == o_ppv)                           return E_INVALIDARG;
    if(eST_QUERYFORMAT_CELLS != i_eQueryFormat) return E_ST_QUERYNOTSUPPORTED;
    if(NULL != i_wszLocator)                    return E_INVALIDARG;
    if((fST_LOS_READWRITE | fST_LOS_MARSHALLABLE | fST_LOS_UNPOPULATED | fST_LOS_REPOPULATE | fST_LOS_MARSHALLABLE) & i_fTable)
                                                return E_ST_LOSNOTSUPPORTED;

    *o_ppv = NULL;

    //The only tables we support are:
    //  wszTABLE_COLLECTION_META    TABLEID_COLLECTION_META
    //  wszTABLE_PROPERTY_META      TABLEID_PROPERTY_META
    //  wszTABLE_TAG_META           TABLEID_TAG_META
    //  wszTABLE_SERVERWIRING_META  TABLEID_SERVERWIRING_META
    if(0 == i_TableID)
        if(FAILED(hr = GetTableID(i_wszTable, i_TableID)))return hr;

    hr = E_ST_INVALIDTABLE;
    switch(i_TableID)
    {
    case TABLEID_TABLEMETA:
    case TABLEID_COLLECTION_META:
        hr = GetCollectionMetaTable     (pQueryCell, cQueryCells);
        break;
    case TABLEID_COLUMNMETA:
    case TABLEID_PROPERTY_META:
        hr = GetPropertyMetaTable       (pQueryCell, cQueryCells);
        break;
    case TABLEID_TAGMETA:
    case TABLEID_TAG_META:
        hr = GetTagMetaTable            (pQueryCell, cQueryCells);
        break;
    case TABLEID_SERVERWIRING_META:
        hr = GetServerWiringMetaTable   (pQueryCell, cQueryCells);
        break;
    default:
        break;
    }
    if(FAILED(hr) && E_ST_NOMOREROWS != hr)//It's perfectly OK to return a table with No rows.
        return hr;

// Supply ISimpleTable* and transition state from class factory / dispenser to data table:
    *o_ppv = (ISimpleTableRead2*) this;
    AddRef ();
    InterlockedIncrement ((LONG*) &m_fIsTable);
    m_fIsTable = true;

    hr = S_OK;
Cleanup:
    return hr;
}


// ------------------------------------
// ISimpleTableRead2:
// ------------------------------------

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetRowIndexByIdentity( ULONG*  i_cb, LPVOID* i_pv, ULONG* o_piRow)
{
    HRESULT hr;
    
    //TagMeta doesn't support this
    if(m_eTagMeta == m_MetaTable)
        return E_NOTIMPL;

    //Also, the other tables don't support this if they were given a query
    if(m_pFixedData)//if turns out that m_pFixedData is only valid when the table was given a query
        return E_NOTIMPL;

    //We're serving up unqueried tables.  The zeroth PK is ALWAYS table name or TableID
    //Also, we don't have DBTYPE_BYTES as a PK so i_cb should always be NULL
    if(NULL != i_cb)        return E_INVALIDARG;
    if(NULL == i_pv)        return E_INVALIDARG;
    if(NULL == i_pv[0])     return E_INVALIDARG;
    if(NULL == o_piRow)     return E_INVALIDARG;

    ULONG TableID = *reinterpret_cast<ULONG *>(i_pv[0]);//WARNING! This assumes that the 0th PK is the TableName BUT users will instead pass &TableID instead.
    if(0 != (0xFF & TableID))//if no table ID was given, then get the TableID from the table name
    {
        if(FAILED(GetTableID(reinterpret_cast<LPCWSTR>(i_pv[0]), TableID)))
            return E_ST_NOMOREROWS;
    }

    switch(m_MetaTable)
    {
    case m_eCollectionMeta:
        *o_piRow = TableID;
        break;
    case m_ePropertyMeta:
    case m_eServerWiringMeta:
        //So the iRow returned has the TableID in the high word and the Order in the low word.
        if(NULL == i_pv[1])
            return E_INVALIDARG;
        *o_piRow = TableID | *reinterpret_cast<ULONG *>(i_pv[1]);
        break;
    default:
        ASSERT(false && "unknown meta table type");
    }

    return S_OK;
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetColumnValues(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
    if(         0 == o_apvValues)return E_INVALIDARG;
    if(i_cColumns <= 0          )return E_INVALIDARG;

    HRESULT hr;
    //Unqueried tables return a Row containing the TableID in the high 24 bits and the Row index for THAT table in the low 8 bits.  This allows
    //the row returned by GetRowIndexByIdentity to be incremented (within the confines of a table), while retaining all information needed to GetColumnValues

    //If we laready have m_pFixedData then we're good to go
    if(m_pFixedData)
    {
        ASSERT(0 == (i_iRow & ~0x3FF));
        return GetColumnValues(m_TableSchema, m_pFixedData, m_ciRows, i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
    }

    TableSchema::TTableSchema TableSchema;//We can't reuse m_TableSchema as that would make this call thread unsafe, so we must declare it on the stack each time.
    const ULONG *pFixedData = 0;
    ULONG  cRows = 0;

    //WARNING!! Very remote chance of a problem.  What if i_iRow is 0x00000100.  Does this mean we have a TableID 0x00000100 and a row index of 0?
    //So what are the chances of a TableID being 0x00000100?  This is the ONLY TableID that is a problem since we only support 503 tables currently.
    //CatUtil bans TableIDs whose upper 21 bits are 0.  This would allow us to grow to 1792 (0x00000700) tables without encountering this problem.
    if(m_MetaTable == m_eCollectionMeta)
    {//The only way this should happen is when the user request CollectionMeta without a query AND wants to iterate through ALL the tables
        if(i_iRow>=m_pTableSchemaHeap->Get_CountOfTables())
            return E_ST_NOMOREROWS;
        VERIFY(SUCCEEDED(TableSchema.Init(reinterpret_cast<const unsigned char *>(m_pTableSchemaHeap) + m_pTableSchemaHeap->Get_aTableSchemaRowIndex()[i_iRow])));//This should NEVER fail, if it does we probably have an error in CatUtil
        pFixedData = reinterpret_cast<const ULONG *>(TableSchema.GetCollectionMeta());
        cRows = 1;
        i_iRow = 0;//remap the request to the 0th row within this table
    }
    else
    {
        ULONG TableID = i_iRow & ~0xFF;
        if(0 == TableID)
            return E_ST_NOMOREROWS;

        i_iRow = i_iRow & 0xFF;//The TableID is in the high 24 bits.  The low 8 bits contains the row within the table.
        if(m_MetaTable == m_eCollectionMeta && 0 != i_iRow)//This makes no sense because, the only way we can have a TableID for CollectionMeta tables, is
            return E_ST_NOMOREROWS;//for the user to call GetRowByIdentity then GetColumnValues.  Well the row returns by GetRowByIdentity will be the TableID
                                   //the user may NOT increment the row index (in this particular case).  The only way for the user to iterate is to set iRow<CountOfTables
                                   //which is handled in the 'if' clause above.

        if(FAILED(TableSchema.Init(m_TableSchemaHeap.Get_TableSchema(TableID))))
            return E_ST_NOMOREROWS;//remap the error to E_ST_NOMOREROWS.  Get_TableSchema will return E_ST_INVALIDTABLE when given a bogus TableID.

        switch(m_MetaTable)
        {
        case m_eServerWiringMeta:
            //This may seem unsafe but if i_iRow >= cRows the pointer will never be accessed (see the private GetColumnValues)
            pFixedData = reinterpret_cast<const ULONG *>(TableSchema.GetServerWiringMeta());
            cRows = TableSchema.GetCollectionMeta()->cServerWiring;
            break;
        case m_eCollectionMeta:
            //This may seem unsafe but if i_iRow >= cRows the pointer will never be accessed (see the private GetColumnValues)
            pFixedData = reinterpret_cast<const ULONG *>(TableSchema.GetCollectionMeta());
            cRows = 1;
            break;
        case m_ePropertyMeta:
            //This may seem unsafe but if i_iRow >= cRows the pointer will never be accessed (see the private GetColumnValues)
            pFixedData = reinterpret_cast<const ULONG *>(TableSchema.GetPropertyMeta(0));
            cRows = TableSchema.GetCollectionMeta()->CountOfProperties;
            break;
        default:
            ASSERT(false && "Hmm!  Only ServerWiring, CollectionMeta dn PropertyMeta can have no query, so how did this happen?");
            return E_FAIL;
        }
    }
    return GetColumnValues(TableSchema, pFixedData, cRows, i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetTableMeta(ULONG *o_pcVersion, DWORD *o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns )
{
	if(NULL != o_pfTable)
	{
		*o_pfTable =  m_TableMeta_MetaFlags;
	}
	if(NULL != o_pcVersion)
	{
		*o_pcVersion = m_TableMeta_BaseVersion;
	}
    if (NULL != o_pcRows)
    {
        if(-1 == m_ciRows)//Some tables have no concept of how many rows they have.  They only know on a TableID by TableID basis
            return E_NOTIMPL;

        *o_pcRows = m_ciRows;
    }
    if (NULL != o_pcColumns)
    {
        *o_pcColumns = m_cColumns;
    }
    return S_OK;
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetColumnMetas (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas)
{
	ULONG iColumn;
	ULONG iTarget;

    if(0 == o_aColumnMetas)
        return E_INVALIDARG;

	if ( i_cColumns > m_cColumns )	
		return  E_ST_NOMORECOLUMNS;

	for ( ULONG i = 0; i < i_cColumns; i ++ )
	{
		if(NULL != i_aiColumns)
			iColumn = i_aiColumns[i];
		else
			iColumn = i;

		iTarget = (i_cColumns == 1) ? 0 : iColumn;

		if ( iColumn >= m_cColumns )	
			return  E_ST_NOMORECOLUMNS;

        memcpy(o_aColumnMetas + iTarget, m_pSimpleColumnMeta + iColumn, sizeof(SimpleColumnMeta));
	}

    return S_OK;
}

// ------------------------------------
// ISimpleTableAdvanced:
// ------------------------------------

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::PopulateCache ()
{
    return S_OK;
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetDetailedErrorCount(ULONG* o_pcErrs)
{
    return E_NOTIMPL;
}

// ==================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::GetDetailedError(ULONG i_iErr, STErr* o_pSTErr)
{
    return E_NOTIMPL;
}


//
//
// Private member functions
//
//
HRESULT TFixedPackedSchemaInterceptor::GetCollectionMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID) const
{
    o_wszTable    = 0;
    o_TableID     = 0;
    //The only query we support for COLLECTION_META is by the table.  BUT there are two ways of specifiying the table: either by
    //TableID or by InternalName.  InternalName is the PK so it is queried by iCell==iCOLLECTION_META_InternalName.  TableID is a
    //an iST_CELL_SPECIAL (just like iST_CELL_FILE), so we check for iCell==iST_CELL_TABLEID also.
    //So walk the list looking for this query
    for(; i_cQueryCells; --i_cQueryCells, ++i_pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        switch(i_pQueryCell->iCell)
        {
        case iCOLLECTION_META_InternalName:
            if( 0                         == o_wszTable       &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_WSTR      &&
                i_pQueryCell->pData       != 0)
                o_wszTable = reinterpret_cast<LPCWSTR>(i_pQueryCell->pData);
            else
                return E_ST_INVALIDQUERY;
            break;
        case iST_CELL_TABLEID:
            if( 0                         == o_TableID        &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_UI4       &&
                i_pQueryCell->pData       != 0)
            {
                o_TableID = *(reinterpret_cast<ULONG *>(i_pQueryCell->pData));
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        default:
            if(0 == (i_pQueryCell->iCell & iST_CELL_SPECIAL))//The above cell is the only non-reserved cell we support
                return E_ST_INVALIDQUERY;                    //and we're supposed to ignore all reserved cell we don't understand
            break;
        }
    }
    if(0 == o_wszTable && 0 == o_TableID)
        return E_ST_INVALIDQUERY;

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetCollectionMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells)
{
    //COLLECTION_META must be supplied a table name
    HRESULT hr;
    ULONG   TableID  = 0;
    LPCWSTR wszTable = 0;
    if(FAILED(hr = GetCollectionMetaQuery(i_pQueryCell, i_cQueryCells, wszTable, TableID)))
        return hr;

    ASSERT(0 != TableID || 0 != wszTable);//No Query (this is invalid)

    if(0 == TableID)//If the TableID wasn't supplied in the query, we need to search for it by TableName
    {
        //So map the table name to an ID
        if(FAILED(hr = GetTableID(wszTable, TableID)))
            return hr;
    }
#ifdef _DEBUG
    else if(wszTable)//If the query included both the TableID AND the Collection Name, then verify that the ID matches the Collection name.
    {
        ULONG TableIDTemp;
        if(FAILED(hr = GetTableID(wszTable, TableIDTemp)))
            return hr;
        ASSERT(TableIDTemp == TableID);
    }
#endif

    //Once we have the TableID it's just a straight forward lookup
    if(FAILED(hr = m_TableSchema.Init(m_TableSchemaHeap.Get_TableSchema(TableID))))
        return hr;
    m_pFixedData                    = reinterpret_cast<const ULONG *>(m_TableSchema.GetCollectionMeta());
    m_ciRows                        = 1;

    m_cColumns                      = kciTableMetaPublicColumns;
    m_cColumnsPlusPrivateColumns    = kciTableMetaPublicColumns;//We don't have to consider the private columns for this table since we don't ever treat it as an array of CollectionMeta
    m_MetaTable                        = m_eCollectionMeta;

    m_pSimpleColumnMeta     = m_pTableSchemaHeap->Get_aSimpleColumnMeta(m_pTableSchemaHeap->eCollectionMeta);
    m_TableMeta_MetaFlags   = fTABLEMETA_INTERNAL | fTABLEMETA_NOLISTENING;
    m_TableMeta_BaseVersion = 0;

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetColumnValues(TableSchema::TTableSchema &i_TableSchema, const ULONG *i_pFixedData, ULONG i_ciRows, ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues) const
{
    ASSERT(i_pFixedData);
// Validate in params
    if(  i_ciRows <= i_iRow     )   return E_ST_NOMOREROWS;
    if(         0 == o_apvValues)   return E_INVALIDARG;
    if(i_cColumns <= 0          )   return E_INVALIDARG;
    if(i_cColumns >  m_cColumns )   return E_INVALIDARG;

    const ULONG   * aColumns    = i_aiColumns ? i_aiColumns : m_aColumnIndex;
    HRESULT         hr          = S_OK;
    ULONG           ipv         = 0;
    ULONG           iColumn     = aColumns[ipv];
    ULONG	        iTarget     = (i_cColumns == 1) ? 0 : iColumn;// If caller needs one column only, he doesn't need to pass a buffer for all the columns.

    // Read data and populate out params
    //The following duplicate code eliminates an 'if' inside the for loop (below).
    {
        if(m_cColumns <= iColumn)// Validate column index
        {
            hr = E_ST_NOMORECOLUMNS;
            goto Cleanup;
        }

        // Read data:
        //So any time we see a WSTR in we treat it as an index into the heap and return the pointer to the item at
        //that index.  Same goes for GUIDs (g_aGuid) and BYTESs (g_aBytes).  In the Bytes array, we expected the first
        //four bytes (cast as a ULONG *) represents the number of bytes.  This is followed by the bytes.
        switch(m_pSimpleColumnMeta[iColumn].dbType)
        {
        case DBTYPE_UI4:
            o_apvValues[iTarget] = const_cast<ULONG *>(i_pFixedData + (m_cColumnsPlusPrivateColumns * i_iRow) + iColumn);
            break;
        case DBTYPE_BYTES:
        case DBTYPE_WSTR:
        case DBTYPE_GUID:
            o_apvValues[iTarget] = const_cast<unsigned char *>(i_TableSchema.GetPointerFromIndex(*(i_pFixedData + (m_cColumnsPlusPrivateColumns * i_iRow) + iColumn)));
            break;
        default:
            ASSERT(false && "Bogus DBTYPE");
            return E_FAIL;
        }
        

        if(o_acbSizes)
        {
            o_acbSizes[iTarget] = 0;//start with 0
            if(NULL != o_apvValues[iTarget])
            {
                switch(m_pSimpleColumnMeta[iColumn].dbType)
                {
                case DBTYPE_UI4:
                    o_acbSizes[iTarget] = sizeof(ULONG);
                    break;
                case DBTYPE_BYTES:
                    o_acbSizes[iTarget] = *(reinterpret_cast<const ULONG *>(o_apvValues[iTarget])-1);
                    break;
                case DBTYPE_WSTR:
                    if(fCOLUMNMETA_FIXEDLENGTH & m_pSimpleColumnMeta[iColumn].fMeta)
                        o_acbSizes[iTarget] = m_pSimpleColumnMeta[iColumn].cbSize;//if a size was specified AND FIXED_LENGTH was specified then return that size specified
                    else //if size was specified and FIXEDLENGTH was NOT then size is just interpretted as Maximum size
                        o_acbSizes[iTarget] = (ULONG)(wcslen ((LPWSTR) o_apvValues[iTarget]) + 1) * sizeof (WCHAR);//just return the string (length +1) in BYTES
                    break;
                case DBTYPE_GUID:
                    o_acbSizes[iTarget] = sizeof(GUID);
                    break;
                }
            }
        }
    }

    // Read data and populate out params
    for(ipv=1; ipv<i_cColumns; ipv++)
    {
//        if(NULL != i_aiColumns)
//            iColumn = i_aiColumns[ipv];
//        else
//            iColumn = ipv;
        iColumn = aColumns[ipv];
		iTarget = iColumn;// If caller needs one column only, he doesn't need to pass a buffer for all the columns.

        if(m_cColumns < iColumn)// Validate column index
        {
            hr = E_ST_NOMORECOLUMNS;
            goto Cleanup;
        }


        // Read data:
        //So any time we see a WSTR in we treat it as an index into the heap and return the pointer to the item at
        //that index.  Same goes for GUIDs (g_aGuid) and BYTESs (g_aBytes).  In the Bytes array, we expected the first
        //four bytes (cast as a ULONG *) represents the number of bytes.  This is followed by the bytes.
        switch(m_pSimpleColumnMeta[iColumn].dbType)
        {
        case DBTYPE_UI4:
            o_apvValues[iTarget] = const_cast<ULONG *>(i_pFixedData + (m_cColumnsPlusPrivateColumns * i_iRow) + iColumn);
            break;
        case DBTYPE_BYTES:
        case DBTYPE_WSTR:
        case DBTYPE_GUID:
            o_apvValues[iTarget] = const_cast<unsigned char *>(i_TableSchema.GetPointerFromIndex(*(i_pFixedData + (m_cColumnsPlusPrivateColumns * i_iRow) + iColumn)));
            break;
        default:
            ASSERT(false && "Bogus DBTYPE");
            return E_FAIL;
        }
        

        if(o_acbSizes)
        {
            o_acbSizes[iTarget] = 0;//start with 0
            if(NULL != o_apvValues[iTarget])
            {
                switch(m_pSimpleColumnMeta[iColumn].dbType)
                {
                case DBTYPE_UI4:
                    o_acbSizes[iTarget] = sizeof(ULONG);
                    break;
                case DBTYPE_BYTES:
                    o_acbSizes[iTarget] = *(reinterpret_cast<const ULONG *>(o_apvValues[iTarget])-1);
                    break;
                case DBTYPE_WSTR:
                    if(fCOLUMNMETA_FIXEDLENGTH & m_pSimpleColumnMeta[iColumn].fMeta)
                        o_acbSizes[iTarget] = m_pSimpleColumnMeta[iColumn].cbSize;//if a size was specified AND FIXED_LENGTH was specified then return that size specified
                    else //if size was specified and FIXEDLENGTH was NOT then size is just interpretted as Maximum size
                        o_acbSizes[iTarget] = (ULONG)(wcslen ((LPWSTR) o_apvValues[iTarget]) + 1) * sizeof (WCHAR);//just return the string (length +1) in BYTES
                    break;
                case DBTYPE_GUID:
                    o_acbSizes[iTarget] = sizeof(GUID);
                    break;
                }
            }
        }
    }

Cleanup:

    if(FAILED(hr))
    {
// Initialize out parameters
        for(ipv=0; ipv<i_cColumns; ipv++)
        {
            o_apvValues[ipv]        = NULL;
            if(NULL != o_acbSizes)
                o_acbSizes[ipv] = 0;
        }
    }

    return hr;
}//GetColumnValues


HRESULT TFixedPackedSchemaInterceptor::GetPropertyMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID, ULONG &o_PropertyIndex) const
{
    o_PropertyIndex = -1;
    o_wszTable      = 0;
    o_TableID       = 0;
    //The only queries we support for PROPERTY_META is by the table or table/property index.  BUT there are two ways of specifiying
    //the table: either by TableID or by InternalName.  InternalName is the PK so it is queried by iCell==iCOLLECTION_META_InternalName.
    //TableID is a an iST_CELL_SPECIAL (just like iST_CELL_FILE), so we check for iCell==iST_CELL_TABLEID also.
    //So walk the list looking for this query
    for(; i_cQueryCells; --i_cQueryCells, ++i_pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        switch(i_pQueryCell->iCell)
        {
        case iPROPERTY_META_Table:
            if( 0                         == o_wszTable       &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_WSTR      &&
                i_pQueryCell->pData       != 0)
            {
                o_wszTable = reinterpret_cast<LPCWSTR>(i_pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        case iPROPERTY_META_Index:
            if( -1                        == o_PropertyIndex  &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_UI4       &&
                i_pQueryCell->pData       != 0)
            {
                o_PropertyIndex = *(reinterpret_cast<ULONG *>(i_pQueryCell->pData));
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        case iST_CELL_TABLEID:
            if( 0                         == o_TableID        &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_UI4       &&
                i_pQueryCell->pData       != 0)
            {
                o_TableID = *(reinterpret_cast<ULONG *>(i_pQueryCell->pData));
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        default:
            if(0 == (i_pQueryCell->iCell & iST_CELL_SPECIAL))//The above cell is the only non-reserved cell we support
                return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
            break;
        }
    }
    if(0 == o_TableID && 0 == o_wszTable && -1 != o_PropertyIndex)
        return E_ST_INVALIDQUERY;//User can't specify a property index without specifying a table also

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetPropertyMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells)
{
    //PROPERTY_META must be supplied a table name or table name/property index
    HRESULT hr;
    ULONG   PropertyIndex   = -1;
    ULONG   TableID         = 0;
    LPCWSTR wszTable        = 0;
    if(FAILED(hr = GetPropertyMetaQuery(i_pQueryCell, i_cQueryCells, wszTable, TableID, PropertyIndex)))
        return hr;

    if(0 == TableID && 0 == wszTable)
    {
        m_pFixedData    = 0;//Does not make sense without a query
        m_ciRows        = -1;//the only way a user can access rows in this table is by Identity first, then the row index can be incremented (within a given table)
        //but ALL columns of ALL tables cannot be iterated.  This would require a mapping which we don't yet build (and we probably shouldn't).
    }
    else
    {
        if(0 == TableID)//If the TableID wasn't supplied in the query, we need to search for it by TableName
        {
            //So map the table name to an ID
            if(FAILED(hr = GetTableID(wszTable, TableID)))
                return hr;
        }
#ifdef _DEBUG
        else if(wszTable)//If the query included both the TableID AND the Collection Name, then verify that the ID matches the Collection name.
        {
            ULONG TableIDTemp;
            if(FAILED(hr = GetTableID(wszTable, TableIDTemp)))
                return hr;
            if(TableIDTemp != TableID)
                return E_ST_INVALIDQUERY;
        }
#endif
        //Once we have the TableID it's just a straight forward lookup
        if(FAILED(hr = m_TableSchema.Init(m_TableSchemaHeap.Get_TableSchema(TableID))))
            return hr;

        //If the user is asking for a column index that doesn't exist, then return error.
        if(PropertyIndex != -1 && PropertyIndex >= m_TableSchema.GetCollectionMeta()->CountOfProperties)
            return E_ST_INVALIDQUERY;

        m_pFixedData                    = reinterpret_cast<const ULONG *>(m_TableSchema.GetPropertyMeta(-1 == PropertyIndex ? 0 : PropertyIndex));
        m_ciRows                        = (-1 == PropertyIndex ? m_TableSchema.GetCollectionMeta()->CountOfProperties : 1);
    }

    m_cColumns                      = kciColumnMetaPublicColumns;
    m_cColumnsPlusPrivateColumns    = m_cColumns + kciColumnMetaPrivateColumns;
    m_MetaTable                        = m_ePropertyMeta;

    m_pSimpleColumnMeta     = m_pTableSchemaHeap->Get_aSimpleColumnMeta(m_pTableSchemaHeap->ePropertyMeta);
    m_TableMeta_MetaFlags   = fTABLEMETA_INTERNAL | fTABLEMETA_NOLISTENING;
    m_TableMeta_BaseVersion = 0;

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetServerWiringMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells) const
{
    //We currently don't support any queries for Server Wiring; so we need to verify that.
    for(; i_cQueryCells; --i_cQueryCells, ++i_pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        if(0 == (i_pQueryCell->iCell & iST_CELL_SPECIAL))//Ignore any iST_CELL_SPECIAL queries but fail if anything else is specified
            return E_ST_INVALIDQUERY;
    }
    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetServerWiringMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells)
{
    //SERVERWIRING_META must NOT be supplied a query (except iST_CELL_SPECIAL cells other than iST_CELL_TABLEID)
    HRESULT hr;

    if(FAILED(hr = GetServerWiringMetaQuery(i_pQueryCell, i_cQueryCells)))
        return hr;

    m_pFixedData                    = 0;//ServerWiring & ClientWiring don't use this.  The pFixedData is figured out at GetColumnValues time
    m_ciRows                        = -1;//ServerWiring & ClientWiring don't use this.  This is figured out at GetColumnValues time on a per table basis.  See GetColumnValues comments for more datails
    m_cColumns                      = kciServerWiringMetaPublicColumns;
    m_cColumnsPlusPrivateColumns    = m_cColumns + kciServerWiringMetaPrivateColumns;
    m_MetaTable                     = m_eServerWiringMeta;

    m_pSimpleColumnMeta     = m_pTableSchemaHeap->Get_aSimpleColumnMeta(m_pTableSchemaHeap->eServerWiringMeta);
    m_TableMeta_MetaFlags   = fTABLEMETA_INTERNAL | fTABLEMETA_NOLISTENING;
    m_TableMeta_BaseVersion = 0;

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetTagMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID, ULONG &o_PropertyIndex) const
{
    o_PropertyIndex = -1;
    o_wszTable      = 0;
    o_TableID       = 0;
    //The only queries we support for TAG_META is by the table or table/property index.  BUT there are two ways of specifiying
    //the table: either by TableID or by InternalName.  InternalName is the PK so it is queried by iCell==iCOLLECTION_META_InternalName.
    //TableID is a an iST_CELL_SPECIAL (just like iST_CELL_FILE), so we check for iCell==iST_CELL_TABLEID also.
    //So walk the list looking for this query
    for(; i_cQueryCells; --i_cQueryCells, ++i_pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        switch(i_pQueryCell->iCell)
        {
        case iTAG_META_Table:
            if( 0                         == o_wszTable       &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_WSTR      &&
                i_pQueryCell->pData       != 0)
            {
                o_wszTable = reinterpret_cast<LPCWSTR>(i_pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        case iTAG_META_ColumnIndex:
            if( -1                        == o_PropertyIndex  &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_UI4       &&
                i_pQueryCell->pData       != 0)
            {
                o_PropertyIndex = *(reinterpret_cast<ULONG *>(i_pQueryCell->pData));
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        case iST_CELL_TABLEID:
            if( 0                         == o_TableID        &&
                i_pQueryCell->eOperator   == eST_OP_EQUAL     &&
                i_pQueryCell->dbType      == DBTYPE_UI4       &&
                i_pQueryCell->pData       != 0)
            {
                o_TableID = *(reinterpret_cast<ULONG *>(i_pQueryCell->pData));
            }
            else
                return E_ST_INVALIDQUERY;
            break;
        default:
            if(0 == (i_pQueryCell->iCell & iST_CELL_SPECIAL))//The above cell is the only non-reserved cell we support
                return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
            break;
        }
    }
    if(0==o_wszTable && 0==o_TableID)//The Query MUST provide a table name OR the TableID
        return E_ST_INVALIDQUERY;

    return S_OK;
}


HRESULT TFixedPackedSchemaInterceptor::GetTagMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells)
{
    //TAG_META must be supplied a table name or table name/property index (NOTE: we don't currently support table name/property index/tag name query)
    HRESULT hr;
    ULONG   PropertyIndex   = -1;
    ULONG   TableID         = 0;
    LPCWSTR wszTable        = 0;
    if(FAILED(hr = GetTagMetaQuery(i_pQueryCell, i_cQueryCells, wszTable, TableID, PropertyIndex)))
        return hr;

    if(0 == TableID)//If the TableID wasn't supplied in the query, we need to search for it by TableName
    {
        //So map the table name to an ID
        if(FAILED(hr = GetTableID(wszTable, TableID)))
            return hr;
    }
#ifdef _DEBUG
    else if(wszTable)//If the query included both the TableID AND the Collection Name, then verify that the ID matches the Collection name.
    {
        ULONG TableIDTemp;
        if(FAILED(hr = GetTableID(wszTable, TableIDTemp)))
            return hr;
        if(TableIDTemp != TableID)
            return E_ST_INVALIDQUERY;
    }
#endif
    //Once we have the TableID it's just a straight forward lookup
    if(FAILED(hr = m_TableSchema.Init(m_TableSchemaHeap.Get_TableSchema(TableID))))
        return hr;

    m_pFixedData                    = reinterpret_cast<const ULONG *>(m_TableSchema.GetTagMeta(PropertyIndex));
    m_ciRows                        = (-1 == PropertyIndex ? m_TableSchema.GetCollectionMeta()->CountOfTags : m_TableSchema.GetPropertyMeta(PropertyIndex)->CountOfTags);
    m_cColumns                      = kciTagMetaPublicColumns;
    m_cColumnsPlusPrivateColumns    = m_cColumns + kciTagMetaPrivateColumns;
    m_MetaTable                        = m_eTagMeta;

    m_pSimpleColumnMeta     = m_pTableSchemaHeap->Get_aSimpleColumnMeta(m_pTableSchemaHeap->eTagMeta);
    m_TableMeta_MetaFlags   = fTABLEMETA_INTERNAL | fTABLEMETA_NOLISTENING;
    m_TableMeta_BaseVersion = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\fixedpackedschemainterceptor.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __FIXEDPACKEDSCHEMAINTERCEPTOR_H__
#define __FIXEDPACKEDSCHEMAINTERCEPTOR_H__

#include "catalog.h"
#ifndef __TABLESCHEMA_H__
    #include "TableSchema.h"
#endif


// ------------------------------------------------------------------
// class TFixedPackedSchemaInterceptor:
// ------------------------------------------------------------------
class TFixedPackedSchemaInterceptor : 
    public ISimpleTableInterceptor,
    public ISimpleTableRead2,
    public ISimpleTableAdvanced
{
public:
    TFixedPackedSchemaInterceptor ();
    ~TFixedPackedSchemaInterceptor ();

// -----------------------------------------
// IUnknown, IClassFactory, ISimpleLogicTableDispenser:
// -----------------------------------------

//IUnknown
public:
    STDMETHOD (QueryInterface)      (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();

//ISimpleDataTableDispenser
public:
    STDMETHOD(Intercept) (
                        LPCWSTR                 i_wszDatabase,
                        LPCWSTR                 i_wszTable, 
                        ULONG                   i_TableID,
                        LPVOID                  i_QueryData,
                        LPVOID                  i_QueryMeta,
                        DWORD                   i_eQueryFormat,
                        DWORD                   i_fTable,
                        IAdvancedTableDispenser* i_pISTDisp,
                        LPCWSTR                 i_wszLocator,
                        LPVOID                  i_pSimpleTable,
                        LPVOID*                 o_ppv
                        );

// -----------------------------------------
// ISimpleTable*:
// -----------------------------------------

//ISimpleTableRead2
public:
    STDMETHOD (GetRowIndexByIdentity)   (ULONG * i_cb, LPVOID * i_pv, ULONG* o_piRow);
    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow){return E_NOTIMPL;}
    STDMETHOD (GetColumnValues)     (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);
    STDMETHOD (GetTableMeta)        (ULONG *o_pcVersion, DWORD * o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns );
    STDMETHOD (GetColumnMetas)      (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas);

//ISimpleTableAdvanced
public:
    STDMETHOD (PopulateCache)           ();
    STDMETHOD (GetDetailedErrorCount)   (ULONG* o_pcErrs);
    STDMETHOD (GetDetailedError)        (ULONG i_iErr, STErr* o_pSTErr);

    static HRESULT GetTableID(LPCWSTR /*i_wszDatabaseName*/, LPCWSTR i_wszTableName, ULONG &o_TableID);
    static HRESULT GetTableID(LPCWSTR i_wszTableName, ULONG &o_TableID);
    static HRESULT GetTableName(ULONG i_TableID, LPCWSTR &o_wszTableName);
    static HRESULT GetTableName(ULONG i_TableID, LPCWSTR &o_wszTableName, LPCWSTR &o_wszDatabaseName);

// -----------------------------------------
// Member variables:
// -----------------------------------------

private:
    //static members first
    static const unsigned long                  m_aColumnIndex[0x30];
    static const TableSchema::TableSchemaHeap * m_pTableSchemaHeap;
    const TableSchema::TableSchemaHeap        & m_TableSchemaHeap;

    enum
    {
        m_eUnknownMeta      = 0,
        m_eServerWiringMeta = 1,
        m_eCollectionMeta   = 3,
        m_ePropertyMeta     = 4,
        m_eTagMeta          = 5
    } m_MetaTable;

    ULONG                           m_cColumns;
    ULONG                           m_cColumnsPlusPrivateColumns;
    ULONG                           m_ciRows;
    ULONG                           m_cRef;
    ULONG                           m_fIsTable;
    const ULONG                 *   m_pFixedData;//This abstracts which PACKED_META table is being served up
    const SimpleColumnMeta      *   m_pSimpleColumnMeta;//There is a minimal amount of ColumnMeta needed for these FixedPackedSchema table.
                                                        //Looking up the CollectionMeta's PropertyMeta will incur an extra page hit.  So
                                                        //the TFixedPackedSchemaInterceptor only relies on SimpleColumnMeta and NOT the full PropertyMeta.
    ULONG                           m_TableMeta_MetaFlags;
    ULONG                           m_TableMeta_BaseVersion;
    TableSchema::TTableSchema       m_TableSchema;

    inline int              StringInsensitiveCompare(LPCWSTR sz1, LPCWSTR sz2) const {return _wcsicmp(sz1, sz2);}
    HRESULT                 GetClientWiringMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells);
    HRESULT                 GetCollectionMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID) const;
    HRESULT                 GetCollectionMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells);
    HRESULT                 GetColumnValues(TableSchema::TTableSchema &i_TableSchema, const ULONG *i_pFixedData, ULONG i_ciRows, ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues) const;
    HRESULT                 GetPropertyMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID, ULONG &o_PropertyIndex) const;
    HRESULT                 GetPropertyMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells);
    HRESULT                 GetServerWiringMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells) const;
    HRESULT                 GetServerWiringMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells);
    HRESULT                 GetTagMetaQuery(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells, LPCWSTR &o_wszTable, ULONG &o_TableID, ULONG &o_PropertyIndex) const;
    HRESULT                 GetTagMetaTable(const STQueryCell *i_pQueryCell, unsigned long i_cQueryCells);
    
};

        
#endif //__FIXEDPACKEDSCHEMAINTERCEPTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\fixedpackedschemainterceptor_com.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include <objbase.h>

#include "catalog.h"
#ifndef _CATALOGMACROS
    #include "catmacros.h"
#endif
#ifndef __TABLESCHEMA_H__
    #include "TableSchema.h"
#endif 
#ifndef __HASH_H__
    #include "hash.h"
#endif
#include "FixedPackedSchemaInterceptor.h"								// TFixedPackedSchemaInterceptor class definition.

// -----------------------------------------
// CSDTFxd: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP TFixedPackedSchemaInterceptor::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (!m_fIsTable) // ie: Component is posing as class factory / dispenser:
	{
		if (riid == IID_ISimpleTableInterceptor)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
	}
	else // ie: Component is currently posing as data table:
	{
		if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableRead2*) this;
		}
		else if (riid == IID_ISimpleTableRead2)
		{
			*ppv = (ISimpleTableRead2*) this;
		}
		else if (riid == IID_ISimpleTableAdvanced)
		{
			*ppv = (ISimpleTableAdvanced*) this;
		}
	}


	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
	
}

// =======================================================================
STDMETHODIMP_(ULONG) TFixedPackedSchemaInterceptor::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

// =======================================================================
STDMETHODIMP_(ULONG) TFixedPackedSchemaInterceptor::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedtable\metamerge.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "metamerge.h"
#include "catmacros.h"
#include "catmeta.h"
#include <objbase.h>

//TODO move XMLUtility.h to a lower inc directory
#include "..\..\core\schemagen\XMLUtility.h"
extern GlobalRowCounts g_coreCounts; 

// Extern functions
STDAPI DllGetSimpleObjectByID (ULONG i_ObjectID, REFIID riid, LPVOID* o_ppv);

// Static initialization
LPWSTR CSDTMetaMerge::m_wszMachineCfgFile = L"machine.cfg";
ExtendedMetaStatus CSDTMetaMerge::m_eExtendedMetaStatus = ExtendedMetaStatusUnknown;

// ==================================================================
CSDTMetaMerge::CSDTMetaMerge () :
      m_cRef                    (0)
    , m_fIsTable                (0)
    , m_bAllQuery               (false)
	, m_pISTFixed               (NULL)
	, m_pISTExtended            (NULL)
    , m_cRowsExt                (0)
    , m_cRowsFixed              (0)
    , m_cRowsToSkip             (0)
{
}

// ==================================================================
CSDTMetaMerge::~CSDTMetaMerge ()
{
    if(m_pISTFixed) m_pISTFixed->Release();
    if(m_pISTExtended) m_pISTExtended->Release();
}


// ------------------------------------
// ISimpleDataTableDispenser:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSDTMetaMerge::Intercept
(
    LPCWSTR					i_wszDatabase,
    LPCWSTR					i_wszTable, 
	ULONG					i_TableID,
    LPVOID					i_QueryData,
    LPVOID					i_QueryMeta,
    DWORD					i_eQueryFormat,
	DWORD					i_fTable,
	IAdvancedTableDispenser* i_pISTDisp,
    LPCWSTR					i_wszLocator,
	LPVOID					i_pSimpleTable,
    LPVOID*					o_ppv
)
{
    STQueryCell           * pQueryCell = (STQueryCell*) i_QueryData;    // Query cell array from caller.
    ULONG                   cQueryCells = 0;
    HRESULT                 hr;
    WCHAR                   wszMachineCfgFullName[MAX_PATH];
    int                     iRes;

    ASSERT(!m_fIsTable);
	if(m_fIsTable) return E_UNEXPECTED; // ie: Assert component is posing as class factory / dispenser.

    ASSERT(i_fTable & fST_LOS_EXTENDEDSCHEMA);
    if(!( i_fTable & fST_LOS_EXTENDEDSCHEMA)) return E_UNEXPECTED;

    if(eST_QUERYFORMAT_CELLS != i_eQueryFormat) return E_ST_QUERYNOTSUPPORTED;

    if (i_QueryMeta)
        cQueryCells= *(ULONG *)i_QueryMeta;

    for(ULONG i = 0; i<cQueryCells; i++)
    {
        if(!(pQueryCell[i].iCell & iST_CELL_SPECIAL)) break;
    }

    m_bAllQuery = (i==cQueryCells);

    if (0 != lstrcmpi(i_wszDatabase, wszDATABASE_META)) return E_ST_INVALIDTABLE;
    //The rest of the parameter validation is done by the underlying tables

    if(m_eExtendedMetaStatus == ExtendedMetaStatusUnknown)
    {   // No lock necessary

        //Get the machine configuration directory
        iRes = ::GetMachineConfigDirectory(WSZ_PRODUCT_NETFRAMEWORKV1, wszMachineCfgFullName, MAX_PATH);
        if (iRes + wcslen(CSDTMetaMerge::m_wszMachineCfgFile) + 1 > MAX_PATH) return E_OUTOFMEMORY;

        //Append machine.cfg to the directory
        wcscat(wszMachineCfgFullName, CSDTMetaMerge::m_wszMachineCfgFile);

        // TODO perf improvment - we shouldn't call GetFileAttributes all the times
        //Try to find the machine.cfg file
        if(-1 == GetFileAttributes(wszMachineCfgFullName))
        {   // if GetFileAttributes fails the file does not exist therefore we have no extended schema
            m_eExtendedMetaStatus = ExtendedMetaStatusNotPresent;
        }
        else
        {
            m_eExtendedMetaStatus = ExtendedMetaStatusPresent;
        }
    }

    if(m_eExtendedMetaStatus == ExtendedMetaStatusNotPresent)
    {   // if we have no machine.cfg no sense trying to look for the extended meta
        return i_pISTDisp->GetTable(i_wszDatabase, i_wszTable, i_QueryData, i_QueryMeta, i_eQueryFormat, (i_fTable & ~fST_LOS_EXTENDEDSCHEMA), o_ppv);
    }

    if(m_bAllQuery)
    {
        // Get both meta tables since we are going to need to do a merge
        hr = i_pISTDisp->GetTable(i_wszDatabase, i_wszTable, i_QueryData, i_QueryMeta, i_eQueryFormat, (i_fTable & ~fST_LOS_EXTENDEDSCHEMA), (LPVOID *)&m_pISTFixed);
        if(FAILED(hr)) return hr;

        hr = CreateExtendedMetaInterceptorAndIntercept( i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, 
                                                i_fTable, i_pISTDisp, i_wszLocator, i_pSimpleTable, (LPVOID *)&m_pISTExtended);
        if(FAILED(hr)) return hr;

        // get the count of rows on each table
        hr = m_pISTExtended->GetTableMeta(NULL, NULL, &m_cRowsExt, NULL);
        if(FAILED(hr)) return hr;
        hr = m_pISTFixed->GetTableMeta(NULL, NULL, &m_cRowsFixed, NULL);
        if(FAILED(hr)) return hr;

        if(0 == lstrcmpi(i_wszTable, wszTABLE_COLUMNMETA)) m_cRowsToSkip = g_coreCounts.cCoreColumns;    
        else if(0 == lstrcmpi(i_wszTable, wszTABLE_DATABASEMETA )) m_cRowsToSkip = g_coreCounts.cCoreDatabases;
        else if(0 == lstrcmpi(i_wszTable, wszTABLE_INDEXMETA    )) m_cRowsToSkip = g_coreCounts.cCoreIndexes;
        else if(0 == lstrcmpi(i_wszTable, wszTABLE_QUERYMETA    )) m_cRowsToSkip = g_coreCounts.cCoreQueries;
        else if(0 == lstrcmpi(i_wszTable, wszTABLE_RELATIONMETA )) m_cRowsToSkip = g_coreCounts.cCoreRelations;
        else if(0 == lstrcmpi(i_wszTable, wszTABLE_TABLEMETA )) m_cRowsToSkip = g_coreCounts.cCoreTables;
        else if(0 == lstrcmpi(i_wszTable, wszTABLE_TAGMETA )) m_cRowsToSkip = g_coreCounts.cCoreTags;
        else return E_ST_INVALIDTABLE;
    }
    else
    {
        ULONG cRows = 0;
        HRESULT hr1;
        // Get the fixed meta table first - if that fails, get the extended one
        hr = i_pISTDisp->GetTable(i_wszDatabase, i_wszTable, i_QueryData, i_QueryMeta, i_eQueryFormat, (i_fTable & ~fST_LOS_EXTENDEDSCHEMA), (LPVOID *)&m_pISTExtended);
        if(hr == S_OK)
        {
            hr1 = m_pISTExtended->GetTableMeta(NULL, NULL, &cRows, NULL);
            if(FAILED(hr1)) return hr1;
        }
        if((hr == E_ST_NOMOREROWS) || (hr == E_ST_INVALIDTABLE) || ((hr == S_OK) && (cRows == 0)))
        {
            hr = CreateExtendedMetaInterceptorAndIntercept( i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, 
                                                i_fTable, i_pISTDisp, i_wszLocator, i_pSimpleTable, (LPVOID *)&m_pISTExtended);
        }
        if(FAILED(hr)) return hr;
    }

// Supply ISimpleTable* and transition state from class factory / dispenser to data table:
    *o_ppv = (ISimpleTableRead2*) this;
    AddRef ();
    InterlockedIncrement ((LONG*) &m_fIsTable);

    hr = S_OK;
Cleanup:
    return hr;
}


// ------------------------------------
// ISimpleTableRead2:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSDTMetaMerge::GetRowIndexByIdentity( ULONG*  i_cb, LPVOID* i_pv, ULONG* o_piRow)
{
    HRESULT hr;

    if(m_bAllQuery)
    {   
        hr = m_pISTFixed->GetRowIndexByIdentity(i_cb, i_pv, o_piRow);
        if (hr == E_ST_NOMOREROWS)
        {
            hr = m_pISTExtended->GetRowIndexByIdentity(i_cb, i_pv, o_piRow);
            if(FAILED(hr)) return hr;

            // be smart about the index we're returning
            if(o_piRow) (*o_piRow) += (m_cRowsFixed - m_cRowsToSkip);
        }
    }
    else
    {
        hr = m_pISTExtended->GetRowIndexByIdentity(i_cb, i_pv, o_piRow);
    }
    return hr;
}

// ==================================================================
STDMETHODIMP CSDTMetaMerge::GetColumnValues(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
    HRESULT hr;
    if(m_bAllQuery)
    {
        if(i_iRow < m_cRowsFixed) // Row must be in the fixed part
            hr = m_pISTFixed->GetColumnValues(i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
        else
            hr = m_pISTExtended->GetColumnValues(i_iRow - m_cRowsFixed + m_cRowsToSkip, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
    }
    else
    {
        hr = m_pISTExtended->GetColumnValues(i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
    }
    return hr;
}
// ==================================================================
STDMETHODIMP CSDTMetaMerge::GetTableMeta(ULONG *o_pcVersion, DWORD *o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns )
{
    HRESULT hr;

    if(m_bAllQuery)
    {
        hr = m_pISTFixed->GetTableMeta(o_pcVersion, o_pfTable, NULL, o_pcColumns);
        if(FAILED(hr)) return hr;

        if(o_pcRows) *o_pcRows = m_cRowsFixed + m_cRowsExt - m_cRowsToSkip;
    }
    else
    {
        hr = m_pISTExtended->GetTableMeta(o_pcVersion, o_pfTable, o_pcRows, o_pcColumns);
    }

    return hr;
}

// ==================================================================
STDMETHODIMP CSDTMetaMerge::GetColumnMetas (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas)
{
    return m_pISTExtended->GetColumnMetas(i_cColumns, i_aiColumns, o_aColumnMetas);
}

// ------------------------------------
// ISimpleTableAdvanced:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSDTMetaMerge::PopulateCache ()
{
    return S_OK;
}

// ==================================================================
STDMETHODIMP CSDTMetaMerge::GetDetailedErrorCount(ULONG* o_pcErrs)
{
    return E_NOTIMPL;
}

// ==================================================================
STDMETHODIMP CSDTMetaMerge::GetDetailedError(ULONG i_iErr, STErr* o_pSTErr)
{
    return E_NOTIMPL;
}

// -----------------------------------------
// IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CSDTMetaMerge::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (!m_fIsTable) // ie: Component is posing as class factory / dispenser:
	{
		if (riid == IID_ISimpleTableInterceptor)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
	}
	else // ie: Component is currently posing as data table:
	{
		if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableRead2*) this;
		}
		else if (riid == IID_ISimpleTableRead2)
		{
			*ppv = (ISimpleTableRead2*) this;
		}
		else if (riid == IID_ISimpleTableAdvanced)
		{
			*ppv = (ISimpleTableAdvanced*) this;
		}
	}


	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
	
}

// =======================================================================
STDMETHODIMP_(ULONG) CSDTMetaMerge::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

// =======================================================================
STDMETHODIMP_(ULONG) CSDTMetaMerge::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}

// ----------------------------------------
// private functions
// ----------------------------------------
HRESULT CSDTMetaMerge::CreateExtendedMetaInterceptorAndIntercept(    LPCWSTR   i_wszDatabase,
                                                  LPCWSTR   i_wszTable,
                                                  ULONG     i_TableID,
                                                  LPVOID    i_QueryData,
                                                  LPVOID    i_QueryMeta,
                                                  DWORD     i_eQueryFormat, 
				                                  DWORD     i_fServiceRequests,
                                                  IAdvancedTableDispenser* i_pISTDisp,
                                                  LPCWSTR	i_wszLocator,
	                                              LPVOID	i_pSimpleTable,
                                                  LPVOID*	o_ppv
                                                )
{
    HRESULT hr;
    CComPtr <ISimpleTableInterceptor>   pISTInterceptor;

    // Get the server wiring table
    hr = DllGetSimpleObjectByID(eSERVERWIRINGMETA_Core_FixedInterceptor, IID_ISimpleTableInterceptor, (LPVOID *)(&pISTInterceptor)); 
    if (FAILED (hr)) return hr;

    return pISTInterceptor->Intercept (i_wszDatabase, i_wszTable, i_TableID, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests, i_pISTDisp, i_wszLocator, i_pSimpleTable, o_ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedschemainterceptor\tableschema.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "windows.h"
#include "catalog.h"
#ifndef __TABLESCHEMA_H__
    #include "TableSchema.h"
#endif


namespace TableSchema
{

const unsigned char * TableSchemaHeap::Get_TableSchema(LPCWSTR TableName) const
{
    const unsigned char *pTableSchema = Get_TableSchema(TableIDFromTableName(TableName));
    const CollectionMeta *pCollectionMeta = reinterpret_cast<const CollectionMeta *>(pTableSchema);
    if(0==pTableSchema || 0!=_wcsicmp(TableName, reinterpret_cast<LPCWSTR>(pTableSchema + pCollectionMeta->iHeap + pCollectionMeta->InternalName)))
        return 0;//the TableID didn't correspond to a valid table OR the table names don't match then fail.
    return pTableSchema;
}

const unsigned char * TableSchemaHeap::Get_TableSchema(ULONG TableID) const
{
    if(0 != (TableID & 0xFF))//TableIDs are 32 bit values whose lower 8 bits are zero.
        return 0;

    const HashedIndex * pHashedIndex = Get_TableNameHashHeader().Get_HashedIndex(TableID);

    for(;pHashedIndex; pHashedIndex = Get_TableNameHashHeader().Get_NextHashedIndex(pHashedIndex))
    {
        if(pHashedIndex->iOffset >= Get_EndOfaTableSchema())//if we're given a bogus TableID, it will result in a pHashedIndex with iOffset==-1 and iNext==-1
            return 0;                                       //if we don't do this check, we'll AV
        const CollectionMeta *pCollectionMeta = reinterpret_cast<const CollectionMeta *>(reinterpret_cast<const unsigned char *>(this) + pHashedIndex->iOffset);
        if(pCollectionMeta->nTableID == TableID)
            return reinterpret_cast<const unsigned char *>(pCollectionMeta);
    }
    return 0;
}

LPCWSTR TableSchemaHeap::Get_TableName(ULONG TableID) const
{
    const unsigned char *  pTableSchema     = Get_TableSchema(TableID);
    if(!pTableSchema)
        return 0;

    const CollectionMeta * pCollectionMeta  = reinterpret_cast<const CollectionMeta *>(pTableSchema);
    return reinterpret_cast<LPCWSTR>(pTableSchema + pCollectionMeta->iHeap + pCollectionMeta->InternalName);//InternalName is a byte offset from the beginning of the pTableSchema's Heap

}

HRESULT TTableSchema::Init(const unsigned char *pTableSchema)
{
    if(0==pTableSchema)
        return E_ST_INVALIDTABLE;

    m_pCollectionMeta   = reinterpret_cast<const CollectionMeta *>(pTableSchema);
    m_pPropertyMeta     = reinterpret_cast<const PropertyMeta *>(pTableSchema + sizeof(CollectionMeta));

    m_pTagMeta          = reinterpret_cast<const TagMeta *>(m_pCollectionMeta->iTagMeta ? pTableSchema + m_pCollectionMeta->iTagMeta : 0);

    ASSERT(0 != m_pCollectionMeta->iServerWiring);
    ASSERT(0 != m_pCollectionMeta->cServerWiring);//There must be at least one
    m_pServerWiring     = reinterpret_cast<const ServerWiringMeta *>(pTableSchema + m_pCollectionMeta->iServerWiring);

    ASSERT(0 != m_pCollectionMeta->iHeap);
    m_pHeap             = pTableSchema + m_pCollectionMeta->iHeap;

    m_pTableDataHeap    = reinterpret_cast<const ULONG *>(m_pCollectionMeta->iFixedTableRows ? pTableSchema + m_pCollectionMeta->iFixedTableRows : 0);
    return S_OK;
}

ULONG TTableSchema::GetPooledHeapPointerSize(const unsigned char *p) const
{
    ASSERT(0 != m_pCollectionMeta);
    if(0==p)
        return 0;

    //Make sure the user doesn't pass some arbitrary pointer.  It MUST be a valid pointer within the heap.
    ASSERT(p > reinterpret_cast<const unsigned char *>(m_pCollectionMeta) + m_pCollectionMeta->iHeap);
    ASSERT(p < reinterpret_cast<const unsigned char *>(m_pCollectionMeta) + m_pCollectionMeta->iHeap + m_pCollectionMeta->cbHeap);
    return (*(reinterpret_cast<const ULONG *>(p) - 1));
}

}//End of namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedtable\sdtfxd_com.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include <objbase.h>

#include "sdtfxd.h"								// SDTFxd class definition.

// -----------------------------------------
// CSDTFxd: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CSDTFxd::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (!m_fIsTable) // ie: Component is posing as class factory / dispenser:
	{
		if (riid == IID_ISimpleTableInterceptor)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
	}
	else // ie: Component is currently posing as data table:
	{
		if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableRead2*) this;
		}
		else if (riid == IID_ISimpleTableRead2)
		{
			*ppv = (ISimpleTableRead2*) this;
		}
		else if (riid == IID_ISimpleTableAdvanced)
		{
			*ppv = (ISimpleTableAdvanced*) this;
		}
	}


	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
	
}

// =======================================================================
STDMETHODIMP_(ULONG) CSDTFxd::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

// =======================================================================
STDMETHODIMP_(ULONG) CSDTFxd::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedtable\metamerge.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __SDTMETAMERGE_H_
#define __SDTMETAMERGE_H_

#include "catalog.h"

// ------------------------------------------------------------------
// enum class that describes the information we have about extended meta
// ------------------------------------------------------------------
enum ExtendedMetaStatus
{
    ExtendedMetaStatusUnknown = 1,
    ExtendedMetaStatusPresent = 2, 
    ExtendedMetaStatusNotPresent = 3
};

// ------------------------------------------------------------------
// class CSDTMetaMerge:
// ------------------------------------------------------------------
class CSDTMetaMerge : 
    public ISimpleTableInterceptor,
    public ISimpleTableRead2,
    public ISimpleTableAdvanced
{
public:
    CSDTMetaMerge ();
    ~CSDTMetaMerge ();

// -----------------------------------------
// IUnknown, IClassFactory, ISimpleLogicTableDispenser:
// -----------------------------------------

//IUnknown
public:
    STDMETHOD (QueryInterface)      (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();

//ISimpleDataTableDispenser
public:
    STDMETHOD(Intercept) (
                        LPCWSTR                 i_wszDatabase,
                        LPCWSTR                 i_wszTable, 
						ULONG					i_TableID,
                        LPVOID                  i_QueryData,
                        LPVOID                  i_QueryMeta,
                        DWORD                   i_eQueryFormat,
                        DWORD                   i_fTable,
                        IAdvancedTableDispenser* i_pISTDisp,
                        LPCWSTR                 i_wszLocator,
                        LPVOID                  i_pSimpleTable,
                        LPVOID*                 o_ppv
                        );

// -----------------------------------------
// ISimpleTable*:
// -----------------------------------------

//ISimpleTableRead2
public:
    STDMETHOD (GetRowIndexByIdentity)   (ULONG * i_cb, LPVOID * i_pv, ULONG* o_piRow);
    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow){return E_NOTIMPL;}
    STDMETHOD (GetColumnValues)     (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);
    STDMETHOD (GetTableMeta)        (ULONG *o_pcVersion, DWORD * o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns );
    STDMETHOD (GetColumnMetas)      (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas);

//ISimpleTableAdvanced
public:
    STDMETHOD (PopulateCache)           ();
    STDMETHOD (GetDetailedErrorCount)   (ULONG* o_pcErrs);
    STDMETHOD (GetDetailedError)        (ULONG i_iErr, STErr* o_pSTErr);

// -----------------------------------------
// Member variables:
// -----------------------------------------

private:
    ULONG                   m_cRef;                 // Interface reference count.
    DWORD                   m_fIsTable;             // Either component is posing as class factory / dispenser or table.
	ISimpleTableRead2 *      m_pISTFixed;            // Pointer to fixed meta IST
	ISimpleTableRead2 *      m_pISTExtended;         // Pointer to extended meta IST

    ULONG                   m_bAllQuery;            // Are we being query-ed for all the rows in a table?
    ULONG                   m_cRowsExt;             // Count of rows in the extended meta table
    ULONG                   m_cRowsFixed;           // Count of rows in the fixed meta table
    ULONG                   m_cRowsToSkip;
    static LPWSTR           m_wszMachineCfgFile;
    static ExtendedMetaStatus m_eExtendedMetaStatus;

    HRESULT CreateExtendedMetaInterceptorAndIntercept(   LPCWSTR   i_wszDatabase,
                                      LPCWSTR   i_wszTable,
                                      ULONG     i_TableID,
                                      LPVOID    i_QueryData,
                                      LPVOID    i_QueryMeta,
                                      DWORD     i_eQueryFormat, 
				                      DWORD     i_fServiceRequests,
                                      IAdvancedTableDispenser* i_pISTDisp,
                                      LPCWSTR	i_wszLocator,
	                                  LPVOID	i_pSimpleTable,
                                      LPVOID*	o_ppv
                                    );

};
        
#endif //__SDTMETAMERGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedtable\sdtfxd_data.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.

// IMPORTANT:   For any schema changes which are incompatible with previous versions:
//              The CURRENT_SCHEMA_VERSION must be incremented as part of the checkin.
//              (Note that this is currently required for all regdb schema changes.)


#include "windows.h"
#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif

extern ULONG g_aFixedTableHeap[]; // from catinproc.cpp

const FixedTableHeap * g_pFixedTableHeap = reinterpret_cast<const FixedTableHeap *>(g_aFixedTableHeap);
const FixedTableHeap * g_pExtendedFixedTableHeap = 0;//This one gets built on the fly as needed.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedtable\sdtfxd_data.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __SDTFXD_DATA_H_
#define __SDTFXD_DATA_H_

#include "catalog.h"
#include "catmeta.h"
#include <objbase.h>

#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif


extern const FixedTableHeap * g_pFixedTableHeap;
extern const FixedTableHeap * g_pExtendedFixedTableHeap;//This one gets built on the fly as needed.

#define g_aColumnMeta   (m_pFixedTableHeap->Get_aColumnMeta())
#define g_aDatabaseMeta (m_pFixedTableHeap->Get_aDatabaseMeta())
#define g_aIndexMeta    (m_pFixedTableHeap->Get_aIndexMeta())
#define g_aTableMeta    (m_pFixedTableHeap->Get_aTableMeta())
#define g_aTagMeta      (m_pFixedTableHeap->Get_aTagMeta())
#define g_aQueryMeta    (m_pFixedTableHeap->Get_aQueryMeta())
#define g_aRelationMeta (m_pFixedTableHeap->Get_aRelationMeta())

#define g_aBytes        (m_pFixedTableHeap->Get_PooledDataHeap())
#define g_aHashedIndex  (m_pFixedTableHeap->Get_HashTableHeap())

#define g_ciColumnMetas     (m_pFixedTableHeap->Get_cColumnMeta())
#define g_ciDatabaseMetas   (m_pFixedTableHeap->Get_cDatabaseMeta())
#define g_ciIndexMeta       (m_pFixedTableHeap->Get_cIndexMeta())
#define g_ciTableMetas      (m_pFixedTableHeap->Get_cTableMeta())
#define g_ciTagMeta         (m_pFixedTableHeap->Get_cTagMeta())
#define g_ciQueryMeta       (m_pFixedTableHeap->Get_cQueryMeta())
#define g_ciRelationMeta    (m_pFixedTableHeap->Get_cRelationMeta())

#define g_aFixedTable       (m_pFixedTableHeap->Get_aULONG())

#endif // __SDTFXD_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedtable\sdtfxd.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include "sdtfxd.h"
#ifndef _CATALOGMACROS
    #include "catmacros.h"
#endif
#ifndef __TABLEINFO_H__  
    #include "catmeta.h"
#endif
#include "svcmsg.h"
#include "winwrap.h"
#ifndef __HASH_H__
    #include "hash.h"
#endif
//TODO move XMLUtility.h to a lower inc directory
#include "..\..\core\schemagen\XMLUtility.h"

#define UI4FromIndex(i)         (*reinterpret_cast<const ULONG *>(m_pFixedTableHeap->Get_PooledData(i)))
#define StringFromIndex(i)      ( const_cast<WCHAR *>(reinterpret_cast<const WCHAR *>(m_pFixedTableHeap->Get_PooledData(i))))
#define GuidPointerFromIndex(i) ( const_cast<GUID *> (reinterpret_cast<const GUID *> (m_pFixedTableHeap->Get_PooledData(i))))
#define BytePointerFromIndex(i) ( const_cast<unsigned char *>(reinterpret_cast<const unsigned char *> (m_pFixedTableHeap->Get_PooledData(i))))
#undef String
#define String(x)           (StringFromIndex(x) ? StringFromIndex(x) : L"(null)")
#define StringBufferLengthFromIndex(i)  (i ? reinterpret_cast<ULONG *>(m_pFixedTableHeap->Get_PooledData(i))[-1] : 0)
void DumpTables();

extern HMODULE g_hModule;             // our dll's module handle
CSemExclusive g_FixupPointersLock; // global lock for loading the static CSDTFxd::m_pFP

//This gets rid of an 'if' inside a loop in GetColumnValues.  Since this function is called more than any other, even one 'if' should make a difference,
//especially when it's inside the 'for' loop.
unsigned long  aColumnIndex[512] = {
        0x00,   0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,   0x09,   0x0a,   0x0b,   0x0c,   0x0d,   0x0e,   0x0f,
        0x10,   0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,   0x19,   0x1a,   0x1b,   0x1c,   0x1d,   0x1e,   0x1f,
        0x20,   0x21,   0x22,   0x23,   0x24,   0x25,   0x26,   0x27,   0x28,   0x29,   0x2a,   0x2b,   0x2c,   0x2d,   0x2e,   0x2f,
        0x30,   0x31,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39,   0x3a,   0x3b,   0x3c,   0x3d,   0x3e,   0x3f,
        0x40,   0x41,   0x42,   0x43,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4a,   0x4b,   0x4c,   0x4d,   0x4e,   0x4f,
        0x50,   0x51,   0x52,   0x53,   0x54,   0x55,   0x56,   0x57,   0x58,   0x59,   0x5a,   0x5b,   0x5c,   0x5d,   0x5e,   0x5f,
        0x60,   0x61,   0x62,   0x63,   0x64,   0x65,   0x66,   0x67,   0x68,   0x69,   0x6a,   0x6b,   0x6c,   0x6d,   0x6e,   0x6f,
        0x70,   0x71,   0x72,   0x73,   0x74,   0x75,   0x76,   0x77,   0x78,   0x79,   0x7a,   0x7b,   0x7c,   0x7d,   0x7e,   0x7f,
        0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,   0x88,   0x89,   0x8a,   0x8b,   0x8c,   0x8d,   0x8e,   0x8f,
        0x90,   0x91,   0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,   0x9a,   0x9b,   0x9c,   0x9d,   0x9e,   0x9f,
        0xa0,   0xa1,   0xa2,   0xa3,   0xa4,   0xa5,   0xa6,   0xa7,   0xa8,   0xa9,   0xaa,   0xab,   0xac,   0xad,   0xae,   0xaf,
        0xb0,   0xb1,   0xb2,   0xb3,   0xb4,   0xb5,   0xb6,   0xb7,   0xb8,   0xb9,   0xba,   0xbb,   0xbc,   0xbd,   0xbe,   0xbf,
        0xc0,   0xc1,   0xc2,   0xc3,   0xc4,   0xc5,   0xc6,   0xc7,   0xc8,   0xc9,   0xca,   0xcb,   0xcc,   0xcd,   0xce,   0xcf,
        0xd0,   0xd1,   0xd2,   0xd3,   0xd4,   0xd5,   0xd6,   0xd7,   0xd8,   0xd9,   0xda,   0xdb,   0xdc,   0xdd,   0xde,   0xdf,
        0xe0,   0xe1,   0xe2,   0xe3,   0xe4,   0xe5,   0xe6,   0xe7,   0xe8,   0xe9,   0xea,   0xeb,   0xec,   0xed,   0xee,   0xef,
        0xf0,   0xf1,   0xf2,   0xf3,   0xf4,   0xf5,   0xf6,   0xf7,   0xf8,   0xf9,   0xfa,   0xfb,   0xfc,   0xfd,   0xfe,   0xff,
       0x100,  0x101,  0x102,  0x103,  0x104,  0x105,  0x106,  0x107,  0x108,  0x109,  0x10a,  0x10b,  0x10c,  0x10d,  0x10e,  0x10f,
       0x110,  0x111,  0x112,  0x113,  0x114,  0x115,  0x116,  0x117,  0x118,  0x119,  0x11a,  0x11b,  0x11c,  0x11d,  0x11e,  0x11f,
       0x120,  0x121,  0x122,  0x123,  0x124,  0x125,  0x126,  0x127,  0x128,  0x129,  0x12a,  0x12b,  0x12c,  0x12d,  0x12e,  0x12f,
       0x130,  0x131,  0x132,  0x133,  0x134,  0x135,  0x136,  0x137,  0x138,  0x139,  0x13a,  0x13b,  0x13c,  0x13d,  0x13e,  0x13f,
       0x140,  0x141,  0x142,  0x143,  0x144,  0x145,  0x146,  0x147,  0x148,  0x149,  0x14a,  0x14b,  0x14c,  0x14d,  0x14e,  0x14f,
       0x150,  0x151,  0x152,  0x153,  0x154,  0x155,  0x156,  0x157,  0x158,  0x159,  0x15a,  0x15b,  0x15c,  0x15d,  0x15e,  0x15f,
       0x160,  0x161,  0x162,  0x163,  0x164,  0x165,  0x166,  0x167,  0x168,  0x169,  0x16a,  0x16b,  0x16c,  0x16d,  0x16e,  0x16f,
       0x170,  0x171,  0x172,  0x173,  0x174,  0x175,  0x176,  0x177,  0x178,  0x179,  0x17a,  0x17b,  0x17c,  0x17d,  0x17e,  0x17f,
       0x180,  0x181,  0x182,  0x183,  0x184,  0x185,  0x186,  0x187,  0x188,  0x189,  0x18a,  0x18b,  0x18c,  0x18d,  0x18e,  0x18f,
       0x190,  0x191,  0x192,  0x193,  0x194,  0x195,  0x196,  0x197,  0x198,  0x199,  0x19a,  0x19b,  0x19c,  0x19d,  0x19e,  0x19f,
       0x1a0,  0x1a1,  0x1a2,  0x1a3,  0x1a4,  0x1a5,  0x1a6,  0x1a7,  0x1a8,  0x1a9,  0x1aa,  0x1ab,  0x1ac,  0x1ad,  0x1ae,  0x1af,
       0x1b0,  0x1b1,  0x1b2,  0x1b3,  0x1b4,  0x1b5,  0x1b6,  0x1b7,  0x1b8,  0x1b9,  0x1ba,  0x1bb,  0x1bc,  0x1bd,  0x1be,  0x1bf,
       0x1c0,  0x1c1,  0x1c2,  0x1c3,  0x1c4,  0x1c5,  0x1c6,  0x1c7,  0x1c8,  0x1c9,  0x1ca,  0x1cb,  0x1cc,  0x1cd,  0x1ce,  0x1cf,
       0x1d0,  0x1d1,  0x1d2,  0x1d3,  0x1d4,  0x1d5,  0x1d6,  0x1d7,  0x1d8,  0x1d9,  0x1da,  0x1db,  0x1dc,  0x1dd,  0x1de,  0x1df,
       0x1e0,  0x1e1,  0x1e2,  0x1e3,  0x1e4,  0x1e5,  0x1e6,  0x1e7,  0x1e8,  0x1e9,  0x1ea,  0x1eb,  0x1ec,  0x1ed,  0x1ee,  0x1ef,
       0x1f0,  0x1f1,  0x1f2,  0x1f3,  0x1f4,  0x1f5,  0x1f6,  0x1f7,  0x1f8,  0x1f9,  0x1fa,  0x1fb,  0x1fc,  0x1fd,  0x1fe,  0x1ff,
    };

// ==================================================================
CSDTFxd::CSDTFxd () :
      m_bDidMeta                (false)
    , m_cColumns                (0)
    , m_cIndexMeta              (0)
    , m_ciRows                  (0)
    , m_cPrimaryKeys            (0)
    , m_cRef                    (0)
    , m_fIsTable                (0)
    , m_iZerothRow              (0)
    , m_pColumnMeta             (0)
    , m_pFixedTable             (0)
    , m_pFixedTableHeap         (g_pFixedTableHeap)//We'll assume the global heap unless the user specifies extended meta
    , m_pFixedTableUnqueried    (0)
    , m_pHashedIndex            (0)
    , m_pHashTableHeader        (0)
    , m_pIndexMeta              (0)
    , m_pTableMeta              (0)
{
}
// ==================================================================
CSDTFxd::~CSDTFxd ()
{
}


// ------------------------------------
// ISimpleDataTableDispenser:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSDTFxd::Intercept
(
    LPCWSTR					i_wszDatabase,
    LPCWSTR					i_wszTable, 
	ULONG					i_TableID,
    LPVOID					i_QueryData,
    LPVOID					i_QueryMeta,
    DWORD					i_eQueryFormat,
	DWORD					i_fTable,
	IAdvancedTableDispenser* i_pISTDisp,
    LPCWSTR					i_wszLocator,
	LPVOID					i_pSimpleTable,
    LPVOID*					o_ppv
)
{
    STQueryCell           * pQueryCell = (STQueryCell*) i_QueryData;    // Query cell array from caller.
    ULONG                   cQueryCells = 0;
    const DatabaseMeta    * aDatabaseMeta;                               // Meta or data did-to-tid map.
    const TableMeta       * aTableMeta;                                  // Tid-to-wire map.
    HRESULT                 hr;
/*
#ifdef _DEBUG

    static bool bWalkFixedTables = false;
    if(bWalkFixedTables)
    {
        DebugBreak();
        DumpTables();
        bWalkFixedTables = false;
    }
#endif
*/
    //There are only a few ways we can be queried
    //If we're given no queries, we just walk the g_aDatabaseMeta table and find the wszDatabase, then walk the TableArray that it points to and find the table.
    //If we ARE given a query, ASSERT that i_wszDatabase is wszDATABASEMETA (wszDATABASE_WIRING doesn't support queries)
    //if wszDATABASE_META then switch on the i_wszTable

	if (i_pSimpleTable)
		return E_INVALIDARG;
    if (i_QueryMeta)
         cQueryCells= *(ULONG *)i_QueryMeta;

    ASSERT(!m_fIsTable);if(m_fIsTable)return E_UNEXPECTED; // ie: Assert component is posing as class factory / dispenser.

// Parameter validation:
    if(NULL == i_wszDatabase)                   return E_INVALIDARG;
    if(NULL == i_wszTable)                      return E_INVALIDARG;
    if(NULL == o_ppv)                           return E_INVALIDARG;
    if(eST_QUERYFORMAT_CELLS != i_eQueryFormat) return E_ST_QUERYNOTSUPPORTED;
    if(NULL != i_wszLocator)                    return E_INVALIDARG;
    if((fST_LOS_READWRITE | fST_LOS_MARSHALLABLE | fST_LOS_UNPOPULATED | fST_LOS_REPOPULATE | fST_LOS_MARSHALLABLE) & i_fTable)
                                                return E_ST_LOSNOTSUPPORTED;
    *o_ppv = NULL;

// Are we using meta from a different dll or not
    if(i_fTable & fST_LOS_EXTENDEDSCHEMA)
    {
        if(g_pExtendedFixedTableHeap == NULL)
        {
            CLock mylock(g_FixupPointersLock); //Take a lock before we fill in m_pEM

            if(g_pExtendedFixedTableHeap == NULL)
            {
                // fill in m_pEM with meta from the files listed in machine.cfg
                hr = GetPointersToHeapMetaStructures(i_pISTDisp);
                if (FAILED (hr)) return hr;
            }
        }
        m_pFixedTableHeap = g_pExtendedFixedTableHeap;
    }
    else if(cQueryCells>0)
    {
        for(ULONG i=0; i<cQueryCells && 0!=(pQueryCell[i].iCell & iST_CELL_SPECIAL);++i)
            if(pQueryCell[i].iCell == iST_CELL_FILE || pQueryCell[i].iCell == iST_CELL_SCHEMAFILE)
            {
                if(SUCCEEDED(m_FixedTableHeapFile.Load(reinterpret_cast<LPCWSTR>(pQueryCell[i].pData))) && m_FixedTableHeapFile.Size()>4096)
                {
                    m_pFixedTableHeap = reinterpret_cast<const class FixedTableHeap *>(m_FixedTableHeapFile.Mapping());
                    if(!m_pFixedTableHeap->IsValid())
                    {
                        LOG_ERROR(Interceptor, (E_FAIL, ID_CAT_CAT, IDS_COMCAT_MBSCHEMA_BIN_INVALID,
                                            reinterpret_cast<LPCWSTR>(pQueryCell[i].pData)));
                        m_pFixedTableHeap=g_pFixedTableHeap;
                    }
                }
                else
                {
                    //Quietly ignore the fact that the bin file doesn't exist and use the g_pFixedTableHeap within the DLL.
                }
            }
    }

// Determine table type:
    if(0 == StringInsensitiveCompare(i_wszDatabase, wszDATABASE_META))
    {
        hr = E_ST_INVALIDTABLE;
        switch(i_wszTable[0])
        {
        case L'c':
        case L'C':
            if(0 == lstrcmpi(i_wszTable, wszTABLE_COLUMNMETA))         hr = GetColumnMetaTable(  pQueryCell, cQueryCells);
            break;
            //TRACE(TEXT("Error! ColumnMeta should come from the fixed packed interceptor!\n"));
            //ASSERT(false && "Error! ColumnMeta should come from the fixed packed interceptor!");
            //break;
        case L'd':
        case L'D':
            if(0 == lstrcmpi(i_wszTable, wszTABLE_DATABASEMETA ))      hr = GetDatabaseMetaTable(  pQueryCell, cQueryCells);
            break;
        case L'i':
        case L'I':
            if(0 == lstrcmpi(i_wszTable, wszTABLE_INDEXMETA    ))      hr = GetIndexMetaTable(     pQueryCell, cQueryCells);
            break;
        case L'q':
        case L'Q':
            if(0 == lstrcmpi(i_wszTable, wszTABLE_QUERYMETA    ))      hr = GetQueryMetaTable(     pQueryCell, cQueryCells);
            break;
        case L'r':
        case L'R':
            if(0 == lstrcmpi(i_wszTable, wszTABLE_RELATIONMETA ))      hr = GetRelationMetaTable(  pQueryCell, cQueryCells);
            break;
        case L't':
        case L'T':
            // Only extesible schema comes from here - the rest comes from the fixed pachked interceptor
            if(0 == lstrcmpi(i_wszTable, wszTABLE_TABLEMETA ))         hr = GetTableMetaTable(     pQueryCell, cQueryCells);
            else if(0 == lstrcmpi(i_wszTable, wszTABLE_TAGMETA ))      hr = GetTagMetaTable(       pQueryCell, cQueryCells);
            else
            {   
                ASSERT(false && L"What table is this?  We should only be called for TableMeta or TagMeta for extensible schema!!");
                return E_ST_INVALIDTABLE;
            }
            break;
        default:
            break;
        }
        if(FAILED(hr) && E_ST_NOMOREROWS != hr)
            return hr;

        //Now see if there's any special indexing
        if(FAILED(hr = GetIndexMeta(pQueryCell, cQueryCells)))return hr;
    }
    else
    {
        //Fixed Tables that are not Meta tables are not allowed to be queried
        for(ULONG i=0; i<cQueryCells;++i)
            if(0 == (pQueryCell[i].iCell & iST_CELL_SPECIAL))
                return E_ST_INVALIDQUERY;
      

        //FixedTables
        unsigned long cTables =0;
		unsigned long iRow;

        //Walk the Fixed Databases (it's an overloaded use of the DatabaseMeta structure)
        m_pTableMeta = NULL;
        for(iRow = 0; iRow < m_pFixedTableHeap->Get_cDatabaseMeta(); iRow++)
            if (0 == StringInsensitiveCompare(i_wszDatabase, StringFromIndex(m_pFixedTableHeap->Get_aDatabaseMeta(iRow)->InternalName)))
            {
                m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(m_pFixedTableHeap->Get_aDatabaseMeta(iRow)->iTableMeta);
                cTables         = UI4FromIndex(m_pFixedTableHeap->Get_aDatabaseMeta(iRow)->CountOfTables);
                break;
            }

        if(NULL == m_pTableMeta)//If the Database is not found then error
            return E_INVALIDARG;

        for (iRow = 0; iRow < cTables; iRow++, m_pTableMeta++)//Walk the Tables in that Database
            if (0 == StringInsensitiveCompare(i_wszTable, StringFromIndex(m_pTableMeta->InternalName)))
                break;

        if(iRow == cTables)               //if we walked the entire list without finding a matching tid,
            return E_ST_INVALIDTABLE;   //return Tid not recognized

        if(static_cast<long>(m_pTableMeta->iFixedTable) <= 0)//If the database and table are found but the iFixedTable member is <= 0 then no table to dispense
            return E_ST_INVALIDTABLE;

        m_pFixedTable       = m_pFixedTableHeap->Get_aULONG(m_pTableMeta->iFixedTable); //iFixedTable is an index into ULONG pool
        m_pFixedTableUnqueried = m_pFixedTable;//we don't support queries on fixed tables other than Meta tables
        m_pColumnMeta       = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);
        m_pHashedIndex      = m_pTableMeta->iHashTableHeader ? m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader + 1) : 0;
        m_pHashTableHeader  = m_pTableMeta->iHashTableHeader ? m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader) : 0;
        m_ciRows = m_pTableMeta->ciRows;
        ASSERT(0 != m_ciRows);//We don't have any Fixed tables that are empty so ASSERT that.
        m_cColumnsPlusPrivate = UI4FromIndex(m_pTableMeta->CountOfColumns);
    }
    m_cColumns              = UI4FromIndex(m_pTableMeta->CountOfColumns);

    //We do this up front, it will save us time in the long run
    for(unsigned long iColumn=0; iColumn<m_cColumns; ++iColumn)
    {
        if(UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags) & fCOLUMNMETA_PRIMARYKEY)
            m_cPrimaryKeys++;
    }

// Supply ISimpleTable* and transition state from class factory / dispenser to data table:
    *o_ppv = (ISimpleTableRead2*) this;
    AddRef ();
    InterlockedIncrement ((LONG*) &m_fIsTable);

    hr = S_OK;
Cleanup:
    return hr;
}


// ------------------------------------
// ISimpleTableRead2:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSDTFxd::GetRowIndexByIdentity( ULONG*  i_cb, LPVOID* i_pv, ULONG* o_piRow)
{
    if(0 != i_cb    )return E_INVALIDARG;
    if(0 == o_piRow )return E_INVALIDARG;
    if(0 == i_pv    )return E_INVALIDARG;
    if(0 == m_ciRows)return E_ST_NOMOREROWS;

    if(m_pHashedIndex && 1!=m_ciRows)//If the table has a hash table, then use it.
    {
        ULONG       iColumn, iPK, RowHash=0;
		for(iColumn = 0, iPK = 0; iPK < m_cPrimaryKeys; iColumn++)
		{
			if (fCOLUMNMETA_PRIMARYKEY & UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags))
			{
                if(0 == i_pv[iPK])
                    return E_INVALIDARG;//NULL PK is invalid

                switch(UI4FromIndex(m_pColumnMeta[iColumn].Type))
                {
                case DBTYPE_GUID:
                    RowHash = Hash( *reinterpret_cast<GUID *>(i_pv[iPK]), RowHash );break;
                case DBTYPE_WSTR:
                    RowHash = Hash( reinterpret_cast<LPCWSTR>(i_pv[iPK]), RowHash );break;
                case DBTYPE_UI4:
                    RowHash = Hash( *reinterpret_cast<ULONG *>(i_pv[iPK]), RowHash );break;
                case DBTYPE_BYTES:
                    ASSERT (0 != i_cb);
                    RowHash = Hash( reinterpret_cast<unsigned char *>(i_pv[iPK]), i_cb[iPK], RowHash );break;
                default:
                    ASSERT (false && "We don't support PKs of type DBTYPE_BYTES yet.");//@@@
                    return E_UNEXPECTED;
                }
                ++iPK;
            }
        }

        const HashedIndex * pHashedIndex = &m_pHashedIndex[RowHash % m_pHashTableHeader->Modulo];
        if(-1 == pHashedIndex->iOffset)//If the hash slot is empty then bail.
            return E_ST_NOMOREROWS;

        //After we get the HashedIndex we need to verify that it really matches.  Also if there is more than one, then walk the list.
        bool bMatch=false;                                 //-1 iNext value indicated the end of the list
        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {
    		for(iColumn = 0, iPK = 0; iPK < m_cPrimaryKeys; iColumn++)
            {
			    if(fCOLUMNMETA_PRIMARYKEY & UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags))
			    {
				    bMatch = false;
                    unsigned long index = *(reinterpret_cast<const DWORD*>(m_pFixedTableUnqueried) + (m_cColumnsPlusPrivate * pHashedIndex->iOffset) + iColumn);
				    switch(UI4FromIndex(m_pColumnMeta[iColumn].Type))
				    {
					    case DBTYPE_GUID:
						    bMatch = (0 == memcmp (GuidPointerFromIndex(index), i_pv[iPK], sizeof (GUID)));
    					    break;
					    case DBTYPE_WSTR:
                            if(IsStringFromPool(reinterpret_cast<LPWSTR>(i_pv[iPK])))//If the i_pv is a pointer from our pool, then just compare the pointers
                                bMatch = (StringFromIndex(index) == reinterpret_cast<LPWSTR>(i_pv[iPK]));
                            else
                                bMatch = (0 == StringInsensitiveCompare(StringFromIndex(index), reinterpret_cast<LPWSTR>(i_pv[iPK])));
    					    break;
					    case DBTYPE_UI4:
						    bMatch = (UI4FromIndex(index) == *(ULONG*)(i_pv[iPK]));
    					    break;
					    default:
						    ASSERT (0); // ie: Remaining types not currently supported as primary keys.
    					    return E_UNEXPECTED;
				    }
				    iPK++;
				    if(!bMatch)
					    break;
			    }
            }
            if(bMatch)
                break;
            if(-1 == pHashedIndex->iNext)
                break;
        }
        if(!bMatch)
            return E_ST_NOMOREROWS;

        if(pHashedIndex->iOffset < m_iZerothRow)
            return E_ST_NOMOREROWS;
        if(pHashedIndex->iOffset >= (m_iZerothRow + m_ciRows))
            return E_ST_NOMOREROWS;

        *o_piRow = pHashedIndex->iOffset - m_iZerothRow;
        return S_OK;
    }
    else//Currently there is only one Fixed Table that does not have a hash table (RelationMeta).  As soon as we get a hash table for it we can eliminate the else.
    {
        ULONG       iColumn, iRow, iPK;
        BOOL        fMatch;

        for (iRow = 0, fMatch = FALSE; iRow < m_ciRows; iRow++)
	    {
		    for (iColumn = 0, iPK = 0; iColumn < m_cColumns; iColumn++)
		    {
			    if (fCOLUMNMETA_PRIMARYKEY & UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags))
			    {
				    fMatch = FALSE;
                    unsigned long index = *(reinterpret_cast<const DWORD *>(m_pFixedTable) + (m_cColumnsPlusPrivate * iRow) + iColumn);
                    if(0 == i_pv[iPK])
                        return E_INVALIDARG;//NULL PK is invalid
				    switch (UI4FromIndex(m_pColumnMeta[iColumn].Type))
				    {
					    case DBTYPE_GUID:
						    if (0 == memcmp (GuidPointerFromIndex(index), i_pv[iPK], sizeof (GUID)))
						    {
							    fMatch = TRUE;
							    break;
						    }
					    break;
					    case DBTYPE_WSTR:
						    if (0 == StringInsensitiveCompare(StringFromIndex(index), reinterpret_cast<LPWSTR>(i_pv[iPK])))
						    {
							    fMatch = TRUE;
							    break;
						    }
					    break;
					    case DBTYPE_UI4:
						    if (UI4FromIndex(index) == *(ULONG*)(i_pv[iPK]))
						    {
							    fMatch = TRUE;
							    break;
						    }
					    break;
					    default:
						    ASSERT (0); // ie: Remaining types not currently supported as primary keys.
					    return E_UNEXPECTED;
				    }
				    iPK++;
				    if (!fMatch)
				    {
					    break;
				    }
			    }
		    }
		    if (fMatch)
		    {
			    break;
		    }
	    }
        if (fMatch)
        {
            *o_piRow = iRow;
            return S_OK;
        }
        else
        {
            return E_ST_NOMOREROWS;
        }
    }
}

STDMETHODIMP CSDTFxd::GetRowIndexBySearch(ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
    if(i_cColumns==0 && i_cColumns>=m_cColumns)return E_INVALIDARG;
    if(0 == o_piRow )return E_INVALIDARG;
    if(0 == m_ciRows)return E_ST_NOMOREROWS;

    ULONG * aColumns    = i_aiColumns ? i_aiColumns : aColumnIndex;

    bool bUsingIndexMetaHashTable = false;
    //If the query indicated a Unique index AND the rest of the parameters indicate that the search is by that index, then we can use the hash
    if(m_pIndexMeta && i_cColumns==m_cIndexMeta)//associated with this index
    {
        ULONG i;
        for(i=0;i<i_cColumns;++i)
        {
            if(i_aiColumns[i] != UI4FromIndex(m_pIndexMeta[i].ColumnIndex))
                break;
        }
        if(m_cIndexMeta == i)//If all of the column indexes match up with the IndexMeta.ColumnIndex
        {                    //then we're OK to use the hash table
            bUsingIndexMetaHashTable = true;
        }
    }

    if(bUsingIndexMetaHashTable)
    {
        ULONG       i, RowHash=0;
		for(i = 0; i< i_cColumns; i++)
		{
            ULONG iTarget = (i_cColumns==1) ? 0 : aColumns[i]; 

            if(0 == i_apvValues[iTarget])
                continue;//NULL is handle as nothing hashed


            switch(UI4FromIndex(m_pColumnMeta[aColumns[i]].Type))
            {
            case DBTYPE_GUID:
                RowHash = Hash( *reinterpret_cast<GUID *>(i_apvValues[iTarget]), RowHash );break;
            case DBTYPE_WSTR:
                RowHash = Hash( reinterpret_cast<LPCWSTR>(i_apvValues[iTarget]), RowHash );break;
            case DBTYPE_UI4:
                RowHash = Hash( *reinterpret_cast<ULONG *>(i_apvValues[iTarget]), RowHash );break;
            case DBTYPE_BYTES:
                if(0 != i_acbSizes)
                    return E_INVALIDARG;
                RowHash = Hash( reinterpret_cast<unsigned char *>(i_apvValues[iTarget]), i_acbSizes[iTarget], RowHash );break;
            default:
                ASSERT(false && L"Bogus type!");
                return E_FAIL;
            }
        }

        const HashedIndex     * pHashedIndex0th     = m_pFixedTableHeap->Get_HashedIndex(m_pIndexMeta->iHashTable+1);
        const HashTableHeader * pHashTableHeader    = m_pFixedTableHeap->Get_HashHeader(m_pIndexMeta->iHashTable);
        const HashedIndex     * pHashedIndex        = pHashedIndex0th + (RowHash % pHashTableHeader->Modulo);
        if(-1 == pHashedIndex->iOffset)//If the hash slot is empty then bail.
            return E_ST_NOMOREROWS;

        //After we get the HashedIndex we need to verify that it really matches.  Also if there is more than one, then walk the list.
        bool bMatch=false;                                 //-1 iNext value indicated the end of the list
        for(;;)
        {
            if((pHashedIndex->iOffset - m_iZerothRow)>=i_iStartingRow)//if the hash table points to a row that is less than the StartinRow (the first row the caller wishes to be considered), then go to the next.
			{
				for(ULONG i = 0; i< i_cColumns; i++)
				{
					unsigned long index = *(reinterpret_cast<const DWORD*>(m_pFixedTableUnqueried) + (m_cColumnsPlusPrivate * pHashedIndex->iOffset) + aColumns[i]);
					ULONG iTarget = (i_cColumns==1) ? 0 : aColumns[i]; 

					if(0 == i_apvValues[iTarget] && 0==index)
					{
						bMatch=true;
					}
					else
					{
						switch(UI4FromIndex(m_pColumnMeta[aColumns[i]].Type))
						{
							case DBTYPE_GUID:
								bMatch = (0 == memcmp (GuidPointerFromIndex(index), i_apvValues[iTarget], sizeof (GUID)));
    							break;
							case DBTYPE_WSTR:
								if(IsStringFromPool(reinterpret_cast<LPWSTR>(i_apvValues[iTarget])))//If the i_apv is a pointer from our pool, then just compare the pointers
									bMatch = (StringFromIndex(index) == reinterpret_cast<LPWSTR>(i_apvValues[iTarget]));
								else
									bMatch = (0 == StringInsensitiveCompare(StringFromIndex(index), reinterpret_cast<LPWSTR>(i_apvValues[iTarget])));
    							break;
							case DBTYPE_UI4:
								bMatch = (UI4FromIndex(index) == *(ULONG*)(i_apvValues[iTarget]));
    							break;
							case DBTYPE_BYTES:
								{
									ASSERT(0 != i_acbSizes);//This should have laready been checked above
									ULONG cbSize= reinterpret_cast<ULONG *>(BytePointerFromIndex(index))[-1];
									bMatch = (cbSize==i_acbSizes[iTarget] && 0 == memcmp(BytePointerFromIndex(index), i_apvValues[iTarget], cbSize));
								}
								break;
							default:
								ASSERT(false && L"Bogus type!");
								return E_FAIL;
						}
					}
					if(!bMatch)
						break;
				}
			}
            if(bMatch)//break if we found a match
				break;
					  
			if(-1 == pHashedIndex->iNext)
                break;//break if were at the end

			pHashedIndex = &pHashedIndex0th[pHashedIndex->iNext];
        }
        if(!bMatch)
            return E_ST_NOMOREROWS;

        if(pHashedIndex->iOffset < m_iZerothRow+i_iStartingRow)
            return E_ST_NOMOREROWS;
        if(pHashedIndex->iOffset >= (m_iZerothRow + m_ciRows))
            return E_ST_NOMOREROWS;

        *o_piRow = pHashedIndex->iOffset - m_iZerothRow;
    }
    else//If we can't use our IndexMeta hash table then we'll have to do a linear search
    {
        ULONG       i, iRow;
        bool        bMatch=false;

        for (iRow = i_iStartingRow; iRow < m_ciRows; iRow++)
	    {
		    for (i = 0; i < i_cColumns; i++)
		    {
				bMatch = false;
                unsigned long index = *(reinterpret_cast<const DWORD *>(m_pFixedTable) + (m_cColumnsPlusPrivate * iRow) + aColumns[i]);

                ULONG iTarget = (i_cColumns==1) ? 0 : aColumns[i]; 

                if(0 == i_apvValues[iTarget] && 0==index)
                {
                    bMatch = true;
                }
                else
                {
				    switch (UI4FromIndex(m_pColumnMeta[aColumns[i]].Type))
				    {
					    case DBTYPE_GUID:
						    bMatch = (0 == memcmp (GuidPointerFromIndex(index), i_apvValues[iTarget], sizeof (GUID)));
                            break;
					    break;
					    case DBTYPE_WSTR:
                            if(IsStringFromPool(reinterpret_cast<LPWSTR>(i_apvValues[iTarget])))//If the i_apv is a pointer from our pool, then just compare the pointers
                                bMatch = (StringFromIndex(index) == reinterpret_cast<LPWSTR>(i_apvValues[iTarget]));
                            else
                                bMatch = (0 == StringInsensitiveCompare(StringFromIndex(index), reinterpret_cast<LPWSTR>(i_apvValues[iTarget])));
						    break;
					    break;
					    case DBTYPE_UI4:
						    bMatch = (UI4FromIndex(index) == *(ULONG*)(i_apvValues[iTarget]));
                            break;
					    break;
					    case DBTYPE_BYTES:
                            {
                                if(0 != i_acbSizes)
                                    return E_INVALIDARG;
                                ULONG cbSize= reinterpret_cast<ULONG *>(BytePointerFromIndex(index))[-1];
                                bMatch = (cbSize==i_acbSizes[iTarget] && 0 == memcmp(BytePointerFromIndex(index), i_apvValues[iTarget], cbSize));
                            }
                            break;
					    default:
						    ASSERT (0); // ie: Remaining types not currently supported as primary keys.
					    return E_UNEXPECTED;
				    }
                }
				if(!bMatch)
				    break;
		    }
            if(bMatch)
                break;
	    }
        if(bMatch)
            *o_piRow = iRow;
        else
            return E_ST_NOMOREROWS;
    }
    return S_OK;
}

// ==================================================================
STDMETHODIMP CSDTFxd::GetColumnValues(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
// Validate in params
    if(  m_ciRows <= i_iRow     )return E_ST_NOMOREROWS;
    if(         0 == o_apvValues)return E_INVALIDARG;
    if(i_cColumns <= 0          )return E_INVALIDARG;
    if(i_cColumns >  m_cColumns)return E_ST_NOMORECOLUMNS;

    ULONG   ipv;
    ULONG   iColumn;
    ULONG	iTarget;
    HRESULT hr          = S_OK;
    ULONG * aColumns    = i_aiColumns ? i_aiColumns : aColumnIndex;

// Read data and populate out params
    ipv=0;
    //The following duplicate code eliminates an 'if' inside the for loop (below).
    {
        iColumn = aColumns[ipv];

	// If caller needs one column only, he doesn't need to pass a buffer for all the columns.
		iTarget = (i_cColumns == 1) ? 0 : iColumn;

    // Validate column index
        if(m_cColumns <= iColumn)
        {
            hr = E_ST_NOMORECOLUMNS;
            goto Cleanup;
        }


    // Read data:
        unsigned long index = *(reinterpret_cast<const DWORD *>(m_pFixedTable) + (m_cColumnsPlusPrivate * i_iRow) + iColumn);
        if(0 == index)
            o_apvValues[iTarget] = 0;
        else
        {
            ASSERT(UI4FromIndex(m_pColumnMeta[iColumn].Type) <= DBTYPE_DBTIMESTAMP);
            o_apvValues[iTarget] = BytePointerFromIndex(index);
        }


    // Optionally read size if the pvValue is not NULL
        if(NULL != o_acbSizes)
        {
            o_acbSizes[iTarget] = 0;//start with 0
            if(NULL != o_apvValues[iTarget])
            {
                switch (UI4FromIndex(m_pColumnMeta[iColumn].Type))
                {
                case DBTYPE_WSTR:
                    if(fCOLUMNMETA_FIXEDLENGTH & UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags))
                        o_acbSizes[iTarget] = UI4FromIndex(m_pColumnMeta[iColumn].Size);//if a size was specified AND FIXED_LENGTH was specified then return that size specified
                    else //if size was specified and FIXEDLENGTH was NOT then size is just interpretted as Maximum size
                        o_acbSizes[iTarget] = (ULONG)(wcslen ((LPWSTR) o_apvValues[iTarget]) + 1) * sizeof (WCHAR);//just return the string (length +1) in BYTES
                    break;
                case DBTYPE_BYTES:
                    o_acbSizes[iTarget] = reinterpret_cast<const ULONG *>(o_apvValues[iTarget])[-1];
                    break;
                default:
                    o_acbSizes[iTarget] = UI4FromIndex(m_pColumnMeta[iColumn].Size);
                    break;
                }
            }
        }
    }

// Read data and populate out params
    for(ipv=1; ipv<i_cColumns; ipv++)
    {
//        if(NULL != i_aiColumns)
//            iColumn = i_aiColumns[ipv];
//        else
//            iColumn = ipv;
        iColumn = aColumns[ipv];

	// If caller needs one column only, he doesn't need to pass a buffer for all the columns.
		iTarget = iColumn;

    // Validate column index
        if(m_cColumns < iColumn)
        {
            hr = E_ST_NOMORECOLUMNS;
            goto Cleanup;
        }


    // Read data:
        unsigned long index = *(reinterpret_cast<const DWORD *>(m_pFixedTable) + (m_cColumnsPlusPrivate * i_iRow) + iColumn);
        if(0 == index)
            o_apvValues[iTarget] = 0;
        else
        {
            ASSERT(UI4FromIndex(m_pColumnMeta[iColumn].Type) <= DBTYPE_DBTIMESTAMP);
            o_apvValues[iTarget] = BytePointerFromIndex(index);
        }


    // Optionally read size if the pvValue is not NULL
        if(NULL != o_acbSizes)
        {
            o_acbSizes[iTarget] = 0;//start with 0
            if(NULL != o_apvValues[iTarget])
            {
                switch (UI4FromIndex(m_pColumnMeta[iColumn].Type))
                {
                case DBTYPE_WSTR:
                    if(fCOLUMNMETA_FIXEDLENGTH & UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags))
                        o_acbSizes[iTarget] = UI4FromIndex(m_pColumnMeta[iColumn].Size);//if a size was specified AND FIXED_LENGTH was specified then return that size specified
                    else //if size was specified and FIXEDLENGTH was NOT then size is just interpretted as Maximum size
                        o_acbSizes[iTarget] = (ULONG)(wcslen ((LPWSTR) o_apvValues[iTarget]) + 1) * sizeof (WCHAR);//just return the string (length +1) in BYTES
                    break;
                case DBTYPE_BYTES:
                    o_acbSizes[iTarget] = reinterpret_cast<const ULONG *>(BytePointerFromIndex(index))[-1];
                    break;
                default:
                    o_acbSizes[iTarget] = UI4FromIndex(m_pColumnMeta[iColumn].Size);
                    break;
                }
            }
        }
    }

Cleanup:

    if(FAILED(hr))
    {
// Initialize out parameters
        for(ipv=0; ipv<i_cColumns; ipv++)
        {
            o_apvValues[ipv]        = NULL;
            if(NULL != o_acbSizes)
            {
                o_acbSizes[ipv] = 0;
            }
        }
    }

    return hr;
}
// ==================================================================
STDMETHODIMP CSDTFxd::GetTableMeta(ULONG *o_pcVersion, DWORD *o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns )
{
	if(NULL != o_pfTable)
	{
		*o_pfTable = 0;
	}
	if(NULL != o_pcVersion)
	{
		*o_pcVersion = UI4FromIndex(m_pTableMeta->BaseVersion);
	}

    
    if (NULL != o_pcRows)
    {
        *o_pcRows = m_ciRows;
    }
    if (NULL != o_pcColumns)
    {
        *o_pcColumns = m_cColumns;
    }
    return S_OK;
}

// ==================================================================
STDMETHODIMP CSDTFxd::GetColumnMetas (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas)
{
	ULONG iColumn;
	ULONG iTarget;

    if(0 == o_aColumnMetas)
        return E_INVALIDARG;

	if ( i_cColumns > m_cColumns )	
		return  E_ST_NOMORECOLUMNS;

	for ( ULONG i = 0; i < i_cColumns; i ++ )
	{
		if(NULL != i_aiColumns)
			iColumn = i_aiColumns[i];
		else
			iColumn = i;

		iTarget = (i_cColumns == 1) ? 0 : iColumn;

		if ( iColumn >= m_cColumns )	
			return  E_ST_NOMORECOLUMNS;

        o_aColumnMetas[iTarget].dbType   = UI4FromIndex(m_pColumnMeta[iColumn].Type);
        o_aColumnMetas[iTarget].cbSize   = UI4FromIndex(m_pColumnMeta[iColumn].Size);
        o_aColumnMetas[iTarget].fMeta    = UI4FromIndex(m_pColumnMeta[iColumn].MetaFlags);
	}

    return S_OK;
}

// ------------------------------------
// ISimpleTableAdvanced:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSDTFxd::PopulateCache ()
{
    return S_OK;
}

// ==================================================================
STDMETHODIMP CSDTFxd::GetDetailedErrorCount(ULONG* o_pcErrs)
{
    return E_NOTIMPL;
}

// ==================================================================
STDMETHODIMP CSDTFxd::GetDetailedError(ULONG i_iErr, STErr* o_pSTErr)
{
    return E_NOTIMPL;
}


//
//
// Private member functions
//
//
HRESULT CSDTFxd::GetColumnMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, unsigned long &iOrder) const
{
    wszTable    = 0;
    iOrder      = -1;
    //The only queries supported is tid equals or iOrder equals
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {
        if(pQueryCell->iCell     == iCOLUMNMETA_Table)
        {
            if(0 == wszTable && pQueryCell->eOperator == eST_OP_EQUAL        &&
                                pQueryCell->dbType    == DBTYPE_WSTR         &&
//                                pQueryCell->cbSize    != 0                   &&
                                pQueryCell->pData     != 0)
                wszTable = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            else//The iCell is iDATABASEMETA_iGuidDid, but some other part of the query is bogus
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell     == iCOLUMNMETA_Index)
        {
            if(-1 == iOrder &&  pQueryCell->eOperator == eST_OP_EQUAL        &&
                                pQueryCell->dbType    == DBTYPE_UI4          &&
//                                pQueryCell->cbSize    == sizeof(ULONG)       &&
                                pQueryCell->pData     != 0)
                iOrder = *reinterpret_cast<ULONG *>(pQueryCell->pData);
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand

        //ignore query cells we don't know about
    }
    if(!wszTable && (-1 != iOrder))
        return E_ST_INVALIDQUERY;
    return S_OK;
}


HRESULT CSDTFxd::GetColumnMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_COLUMNMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aColumnMeta();
    m_cColumnsPlusPrivate   = kciColumnMetaColumns;


    HRESULT hr;
    LPCWSTR wszTable=0;
    ULONG   iOrder  =-1;

    if(FAILED(hr = GetColumnMetaQuery(pQueryCell, cQueryCells, wszTable, iOrder)))
        return hr;

    const ColumnMeta * pColumnMeta = m_pFixedTableHeap->Get_aColumnMeta();
    if(0 == wszTable)//if a tid wasn't provided as part of the query then we're done
    {
        m_ciRows        = m_pFixedTableHeap->Get_cColumnMeta();
        m_iZerothRow    = 0;
    }
    else
    {
        //We're looking up the TableMeta for this table (the table that we're finding the ColumnMeta for) because it already has the pointer to the ColumnMeta AND the count
        const TableMeta       * pTableMetaForTheTableMeta = m_pFixedTableHeap->Get_aTableMeta(m_pFixedTableHeap->FindTableMetaRow(wszTABLE_TABLEMETA));
        const HashedIndex     * pBaseHashedIndex = m_pFixedTableHeap->Get_HashedIndex(pTableMetaForTheTableMeta->iHashTableHeader + 1);
        const HashTableHeader * pHashTableHeader = reinterpret_cast<const HashTableHeader *>(pBaseHashedIndex-1);
        ULONG RowHash = Hash(wszTable, 0) % pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex     = &pBaseHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)//if no row matches this hash then return an empty table
        {
            m_pFixedTable   = 0;
            m_ciRows        = 0;
            m_iZerothRow    = 0;
            return S_OK;
        }

        const TableMeta * pTableMeta;
        //After we get the HashedIndex we need to verify that it really matches.  Also if there is more than one, then walk the list. -1 iNext value indicated the end of the list
        for(; ; pHashedIndex = &pBaseHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pTableMeta = m_pFixedTableHeap->Get_aTableMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTableMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }
        if(-1 == iOrder)
        {
            pColumnMeta     = m_pFixedTableHeap->Get_aColumnMeta(pTableMeta->iColumnMeta);
            m_ciRows        = UI4FromIndex(pTableMeta->CountOfColumns);
            m_iZerothRow    = pTableMeta->iColumnMeta;
        }
        else
        {
            if(iOrder >= UI4FromIndex(pTableMeta->CountOfColumns))//can't ask for a row that doesn't exist
                return E_ST_INVALIDQUERY;

            pColumnMeta     = m_pFixedTableHeap->Get_aColumnMeta(pTableMeta->iColumnMeta + iOrder);
            m_ciRows        = 1;
            m_iZerothRow    = pTableMeta->iColumnMeta + iOrder;
        }
    }
    m_pFixedTable   = const_cast<ColumnMeta *>(pColumnMeta);
    return S_OK;
}


HRESULT CSDTFxd::GetDatabaseMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszDatabase) const
{
    wszDatabase = 0;
    //The only query supported is 'did equals' (or iCell==0, dbType==GUID etc)
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        if(pQueryCell->iCell     == iDATABASEMETA_InternalName)
        {
            if(0 == wszDatabase &&  pQueryCell->eOperator == eST_OP_EQUAL        &&
                                    pQueryCell->dbType    == DBTYPE_WSTR         &&
//                                    pQueryCell->cbSize    != 0                   &&
//                                    pQueryCell->cbSize    <= 16                  && //@@@ 16 should be replaced by a define
                                    pQueryCell->pData     != 0)
                wszDatabase = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            else//The iCell is iDATABASEMETA_iGuidDid, but some other part of the query is bogus
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    return S_OK;
}


HRESULT CSDTFxd::GetDatabaseMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{   //Now enforce the query (the only one supported is 'did equals' (or iCell==0, dbType==GUID etc)
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_DATABASEMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    ASSERT(0 != m_pTableMeta->iHashTableHeader);
    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aDatabaseMeta();
    m_cColumnsPlusPrivate   = kciDatabaseMetaColumns;

    HRESULT hr;
    LPCWSTR wszDatabase=0;

    if(FAILED(hr = GetDatabaseMetaQuery(pQueryCell, cQueryCells, wszDatabase)))
        return hr;

    const DatabaseMeta *    pDatabaseMeta = m_pFixedTableHeap->Get_aDatabaseMeta();
    if(0 == wszDatabase)
    {
        m_ciRows        = m_pFixedTableHeap->Get_cDatabaseMeta();
        m_iZerothRow    = 0;
    }
    else
    {
        ULONG           RowHash = Hash(wszDatabase, 0) % m_pHashTableHeader->Modulo;
        const HashedIndex   * pHashedIndex = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])//Walk the hash links 'til we find a match
        {   
            pDatabaseMeta = m_pFixedTableHeap->Get_aDatabaseMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszDatabase, StringFromIndex(pDatabaseMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_ciRows        = 1;//if we found a match then the size of the table is 1
        m_iZerothRow    = pHashedIndex->iOffset;
    }//0 == wszDatabase
    m_pFixedTable   = const_cast<DatabaseMeta *>(pDatabaseMeta);//The 0th element is reserved as NULL
    return S_OK;
}


HRESULT CSDTFxd::GetIndexMeta(const STQueryCell *pQueryCell, unsigned long cQueryCells)
{
    LPCWSTR wszIndexName=0;
    for(; 0!=cQueryCells; --cQueryCells, ++pQueryCell)
    {
        if(pQueryCell->iCell == iST_CELL_INDEXHINT)
        {
            if(0 == wszIndexName &&  pQueryCell->eOperator == eST_OP_EQUAL    &&
                                     pQueryCell->dbType    == DBTYPE_WSTR     &&
//                                   pQueryCell->cbSize    != 0               &&
                                     pQueryCell->pData     != 0)
            {
                wszIndexName = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
        }
    }
    if(0 == wszIndexName)//if there was no IndexName specified, then bail
        return S_OK;

    //Find the first index that matches the IndexName
    const IndexMeta * pIndexMeta = m_pFixedTableHeap->Get_aIndexMeta() + m_pTableMeta->iIndexMeta;
    for(ULONG iIndexMeta=0; iIndexMeta<m_pTableMeta->cIndexMeta; ++iIndexMeta, ++pIndexMeta)
    {
        ASSERT(pIndexMeta->Table == m_pTableMeta->InternalName);

        if(0 == StringInsensitiveCompare(StringFromIndex(pIndexMeta->InternalName), wszIndexName))
        {
            if(0 == m_cIndexMeta)//Keep around a pointer to the first IndexMeta row.
                m_pIndexMeta = pIndexMeta;

            ++m_cIndexMeta;//For every IndexMeta that matches the index name, bump the count
        }
        else if(m_cIndexMeta>0)
            break;
    }
    if(0 == m_cIndexMeta)//The user specified an IndexName that does not exist.
        return E_ST_INVALIDQUERY;

    return S_OK;
}


HRESULT CSDTFxd::GetIndexMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, LPCWSTR &InternalName, unsigned long &iColumnOrder) const
{
    wszTable        = 0;
    InternalName    = 0;
    iColumnOrder    = -1;

    unsigned long fSpecifiedQueries=0;//must be 0, 1, 3 or 7

    //There are three queries we support for TagMeta, by TableID, TableID & iOrder, TableID iOrder & InternalName
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {
        if(pQueryCell->iCell == iINDEXMETA_Table)
        {
            if(0 == wszTable && pQueryCell->eOperator == eST_OP_EQUAL    &&
                                pQueryCell->dbType    == DBTYPE_WSTR     &&
//                                pQueryCell->cbSize    != 0               &&
                                pQueryCell->pData     != 0)
            {
                wszTable = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 1;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iINDEXMETA_InternalName)
        {
            if(0 == InternalName && pQueryCell->eOperator == eST_OP_EQUAL   &&
                                    pQueryCell->dbType    == DBTYPE_WSTR    &&
//                                    pQueryCell->cbSize    != 0              &&
                                    pQueryCell->pData     != 0)
            {
                InternalName = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 2;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iINDEXMETA_ColumnIndex)
        {
            if(-1 == iColumnOrder &&  pQueryCell->eOperator == eST_OP_EQUAL   &&
                                pQueryCell->dbType    == DBTYPE_UI4     &&
//                                pQueryCell->cbSize    == sizeof(ULONG)  &&
                                pQueryCell->pData     != 0)
            {
                iColumnOrder = *reinterpret_cast<ULONG *>(pQueryCell->pData);
                fSpecifiedQueries |= 4;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    switch(fSpecifiedQueries)
    {
    case 0:     //Legal value so fall through to the break
    case 1:     //Legal value so fall through to the break
    case 3:     //Legal value so fall through to the break
    case 7:     break;//Legal value
    default:    return E_ST_INVALIDQUERY;//anything else is an invalid query
    }
    return S_OK;
}


HRESULT CSDTFxd::GetIndexMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_INDEXMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    ASSERT(0 != m_pTableMeta->iHashTableHeader);
    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aIndexMeta();
    m_cColumnsPlusPrivate   = kciIndexMetaColumns;


    HRESULT hr;
    LPCWSTR wszTable    = 0;
    ULONG   ColumnIndex = -1;
    LPCWSTR InternalName= 0;

    if(FAILED(hr = GetIndexMetaQuery(pQueryCell, cQueryCells, wszTable, InternalName, ColumnIndex)))
        return hr;

    const IndexMeta *pIndexMeta = m_pFixedTableHeap->Get_aIndexMeta();//Start with the whole table.
    if(0 == wszTable)
    {   //No query, return the whole table
        m_ciRows        = m_pFixedTableHeap->Get_cIndexMeta();
        m_iZerothRow    = 0;
    }
    else if(0 == InternalName)
    {   //TableName only query
        ULONG                   RowHash         = Hash(wszTable, 0) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pIndexMeta      = m_pFixedTableHeap->Get_aIndexMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pIndexMeta->Table)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cIndexMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pIndexMeta[m_ciRows].Table)); ++m_ciRows);
    }
    else if(-1 == ColumnIndex)
    {   //TableName and InternalName but NO ColumnIndex
        ULONG                   RowHash         = Hash(InternalName, Hash(wszTable, 0)) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pIndexMeta      = m_pFixedTableHeap->Get_aIndexMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pIndexMeta->Table)) && 0 == StringInsensitiveCompare(InternalName, StringFromIndex(pIndexMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cIndexMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pIndexMeta[m_ciRows].Table))
                         && 0 == StringInsensitiveCompare(InternalName, StringFromIndex(pIndexMeta[m_ciRows].InternalName)); ++m_ciRows);
    }
    else
    {   //All three PrimaryKey were specified in the query
        ULONG                   RowHash         = Hash(ColumnIndex, Hash(InternalName, Hash(wszTable, 0))) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pIndexMeta      = m_pFixedTableHeap->Get_aIndexMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pIndexMeta->Table)) && UI4FromIndex(pIndexMeta->ColumnIndex)==ColumnIndex && 0 == StringInsensitiveCompare(InternalName, StringFromIndex(pIndexMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }
        m_ciRows        = 1;//When all PK are queried for, the only result is 1 row
        m_iZerothRow    = pHashedIndex->iOffset;
    }
    m_pFixedTable   = const_cast<IndexMeta *>(pIndexMeta);
    return S_OK;
}


HRESULT CSDTFxd::GetQueryMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, LPCWSTR &wszInternalName, LPCWSTR &wszCellName) const
{
    wszTable        = 0;
    wszInternalName = 0;
    wszCellName     = 0;

    unsigned long fSpecifiedQueries=0;//must be 0, 1, 3 or 7

    //The only two queries we support for QueryMeta are, iCell==iQUERYMETA_Table && iCell==iQUERYMETA_InternalName
    //So walk the list looking for one of those two queries
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        if(pQueryCell->iCell == iQUERYMETA_Table)
        {
            if(0 == wszTable &&     pQueryCell->eOperator == eST_OP_EQUAL    &&
                                    pQueryCell->dbType    == DBTYPE_WSTR     &&
//@@@ work around bug in dispenser                                    pQueryCell->cbSize    != 0               &&
                                    pQueryCell->pData     != 0)
            {
                wszTable = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 1;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iQUERYMETA_InternalName)
        {
            if(0 == wszInternalName &&  pQueryCell->eOperator == eST_OP_EQUAL    &&
                                        pQueryCell->dbType    == DBTYPE_WSTR     &&
//@@@ work around bug in dispenser                                pQueryCell->cbSize    != 0               &&
                                        pQueryCell->pData     != 0)
            {
                wszInternalName = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 2;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iQUERYMETA_CellName)
        {
            if(0 == wszCellName &&      pQueryCell->eOperator == eST_OP_EQUAL    &&
                                        pQueryCell->dbType    == DBTYPE_WSTR     &&
//@@@ work around bug in dispenser                                pQueryCell->cbSize    != 0               &&
                                        pQueryCell->pData     != 0)
            {
                wszCellName = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 4;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    switch(fSpecifiedQueries)
    {
    case 0:     //Legal value so fall through to the break
    case 1:     //Legal value so fall through to the break
    case 3:     //Legal value so fall through to the break
    case 7:     break;//Legal value
    default:    return E_ST_INVALIDQUERY;//anything else is an invalid query
    }

    return S_OK;
}


HRESULT CSDTFxd::GetQueryMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_QUERYMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    ASSERT(0 != m_pTableMeta->iHashTableHeader);
    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aQueryMeta();
    m_cColumnsPlusPrivate   = kciQueryMetaColumns;

    HRESULT hr;
    LPCWSTR wszTable        = 0;
    LPCWSTR wszInternalName = 0;
    LPCWSTR wszCellName     = 0;

    if(FAILED(hr = GetQueryMetaQuery(pQueryCell, cQueryCells, wszTable, wszInternalName, wszCellName)))
        return hr;

    const QueryMeta *pQueryMeta = m_pFixedTableHeap->Get_aQueryMeta();//Start with the whole table.
    if(0 == wszTable)
    {   //No query, return the whole table
        m_ciRows        = m_pFixedTableHeap->Get_cQueryMeta();
        m_iZerothRow    = 0;
    }
    else if(0 == wszInternalName)
    {   //Query is by TableName only
        ULONG                   RowHash         = Hash(wszTable, 0) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pQueryMeta      = m_pFixedTableHeap->Get_aQueryMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta->Table)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cQueryMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta[m_ciRows].Table)); ++m_ciRows);
    }
    else if(0 == wszCellName)
    {   //Query is by TableName and InternalName
        ULONG                   RowHash         = Hash( wszInternalName, Hash(wszTable, 0)) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pQueryMeta      = m_pFixedTableHeap->Get_aQueryMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta->Table)) && 0 == StringInsensitiveCompare(wszInternalName, StringFromIndex(pQueryMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;        
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cQueryMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta[m_ciRows].Table)) &&
                         0 == StringInsensitiveCompare(wszInternalName, StringFromIndex(pQueryMeta[m_ciRows].InternalName)); ++m_ciRows);
    }
    else
    {   //Query is by all three PrimaryKeys
        ULONG                   RowHash         = Hash(wszCellName, Hash( wszInternalName, Hash(wszTable, 0))) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pQueryMeta      = m_pFixedTableHeap->Get_aQueryMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta->Table)) && 0 == StringInsensitiveCompare(wszInternalName, StringFromIndex(pQueryMeta->InternalName))
                            && 0 == StringInsensitiveCompare(wszCellName, StringFromIndex(pQueryMeta->CellName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cQueryMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pQueryMeta[m_ciRows].Table)) &&
                         0 == StringInsensitiveCompare(wszInternalName, StringFromIndex(pQueryMeta->InternalName))
                         && 0 == StringInsensitiveCompare(wszCellName, StringFromIndex(pQueryMeta->CellName)); ++m_ciRows);
    }
    m_pFixedTable = const_cast<QueryMeta *>(pQueryMeta);
    return S_OK;
}


HRESULT CSDTFxd::GetRelationMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTablePrimary, LPCWSTR &wszTableForeign) const
{
    wszTablePrimary = 0;
    wszTableForeign    = 0;

    //@@@ To Do: we need to support queries by either Primary or Foreign table.  This means we'll want the table sorted by each (a copy of the table).
    //@@@ For now the only query we'll support is by BOTH Primary and Foreign Tables

    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        if(pQueryCell->iCell == iRELATIONMETA_PrimaryTable)
        {
            if(0 == wszTablePrimary &&  pQueryCell->eOperator == eST_OP_EQUAL    &&
                                        pQueryCell->dbType    == DBTYPE_WSTR     &&
//@@@ work around bug in dispenser                                    pQueryCell->cbSize    != 0               &&
                                        pQueryCell->pData     != 0)
            {
                wszTablePrimary = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iRELATIONMETA_ForeignTable)
        {
            if(0 == wszTableForeign &&  pQueryCell->eOperator == eST_OP_EQUAL    &&
                                        pQueryCell->dbType    == DBTYPE_WSTR     &&
//@@@ work around bug in dispenser                                pQueryCell->cbSize    != 0               &&
                                        pQueryCell->pData     != 0)
            {
                wszTableForeign = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    if((wszTablePrimary && !wszTableForeign) || (!wszTablePrimary && wszTableForeign))//@@@ For now both or neither should be specified.
        return E_ST_INVALIDQUERY;

    return S_OK;
}


//@@@ To Do: Need to support querying by either primary key not just both!
HRESULT CSDTFxd::GetRelationMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_RELATIONMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta        = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta       = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    m_pHashedIndex          = 0;
    m_pHashTableHeader      = 0;
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aRelationMeta();
    m_cColumnsPlusPrivate   = kciRelationMetaColumns;

    HRESULT hr;
    LPCWSTR wszTablePrimary = 0;
    LPCWSTR wszTableForeign = 0;

    if(FAILED(hr = GetRelationMetaQuery(pQueryCell, cQueryCells, wszTablePrimary, wszTableForeign)))
        return hr;

    if(0 == wszTablePrimary && 0 == wszTableForeign)
    {
        m_pFixedTable   = m_pFixedTableHeap->Get_aRelationMeta();
        m_ciRows        = m_pFixedTableHeap->Get_cRelationMeta();
        return S_OK;
    }
    const RelationMeta *pRelationMeta = m_pFixedTableHeap->Get_aRelationMeta();
    for(unsigned long iRelationMeta=0; iRelationMeta<m_pFixedTableHeap->Get_cRelationMeta(); ++iRelationMeta, ++pRelationMeta)
    {
        if(0 == StringInsensitiveCompare(StringFromIndex(pRelationMeta->PrimaryTable), wszTablePrimary) &&
           0 == StringInsensitiveCompare(StringFromIndex(pRelationMeta->ForeignTable), wszTableForeign))
        {
            m_pFixedTable   = const_cast<RelationMeta *>(pRelationMeta);
            m_ciRows        = 1;//These are both of the PKs so there can only be one match.
            break;
        }
    }
    return S_OK;
}


HRESULT CSDTFxd::GetTableMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszDatabase, LPCWSTR &wszTable) const
{
    wszDatabase = 0;
    wszTable    = 0;
    //The only two queries we support for TableMeta are, iCell==iTABLEMETA_iGuidDid && iCell==iTABLEMETA_iGuidTid
    //So walk the list looking for one of those two queries
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {   //Walk the Query cells looking for one that matches the following criteria
        if(pQueryCell->iCell == iTABLEMETA_Database)
        {
            if(0 == wszDatabase &&  pQueryCell->eOperator == eST_OP_EQUAL    &&
                                    pQueryCell->dbType    == DBTYPE_WSTR     &&
//                                    pQueryCell->cbSize    != 0               &&
//                                    pQueryCell->cbSize    <= 16              && //@@@ the 16 should be replaced by a define
                                    pQueryCell->pData     != 0)
            {
                wszDatabase = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iTABLEMETA_InternalName)
        {
            if(0 == wszTable && pQueryCell->eOperator == eST_OP_EQUAL    &&
                                pQueryCell->dbType    == DBTYPE_WSTR     &&
//                                pQueryCell->cbSize    != 0               &&
                                pQueryCell->pData     != 0)
            {
                wszTable = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    if(wszDatabase)
    {
        if(wszTable)//We support query by Database or TableName but NOT both.
        {
            TRACE(TEXT("Warning! Users should NOT query TableMeta by both DatabaseName AND TableName.  It is redundant.  Just query by iTABLEMETA_InternalName.\n"));
            return S_OK;//E_ST_INVALIDQUERY;
        }
    }
    return S_OK;
}


HRESULT CSDTFxd::GetTableMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_TABLEMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    ASSERT(0 != m_pTableMeta->iHashTableHeader);
    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aTableMeta();
    m_cColumnsPlusPrivate   = kciTableMetaColumns;

    HRESULT hr;
    LPCWSTR wszDatabase =0;
    LPCWSTR wszTable    =0;

    if(FAILED(hr = GetTableMetaQuery(pQueryCell, cQueryCells, wszDatabase, wszTable)))
        return hr;

    const TableMeta *    pTableMeta = m_pFixedTableHeap->Get_aTableMeta();
    //TableMeta has a special case.  Even though Database name is NOT aPK, we allow querying by it.
    if(0 != wszDatabase && 0 == wszTable)//So if we're querying by Database only
    {
        const TableMeta       * pTableMetaForDatabaseMeta = m_pFixedTableHeap->Get_aTableMeta(m_pFixedTableHeap->FindTableMetaRow(wszTABLE_DATABASEMETA));
        const HashedIndex     * pHashedIndex     = m_pFixedTableHeap->Get_HashedIndex(pTableMetaForDatabaseMeta->iHashTableHeader + 1);
        const HashedIndex     * _pHashedIndex    = pHashedIndex;
        const HashTableHeader * pHashTableHeader = m_pFixedTableHeap->Get_HashHeader(pTableMetaForDatabaseMeta->iHashTableHeader);
        ULONG RowHash = Hash(wszDatabase, 0) % pHashTableHeader->Modulo;

        pHashedIndex += RowHash;

        if(-1 == pHashedIndex->iOffset)//if no row matches this hash then return an empty table
        {
            m_pFixedTable   = 0;
            m_ciRows        = 0;
            m_iZerothRow    = 0;
            return S_OK;
        }

        const DatabaseMeta * pDatabaseMeta;
        //After we get the HashedIndex we need to verify that it really matches.  Also if there is more than one, then walk the list. -1 iNext value indicated the end of the list
        for(;; pHashedIndex = &_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pDatabaseMeta = m_pFixedTableHeap->Get_aDatabaseMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszDatabase, StringFromIndex(pDatabaseMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        pTableMeta      = m_pFixedTableHeap->Get_aTableMeta(pDatabaseMeta->iTableMeta);
        m_ciRows        = UI4FromIndex(pDatabaseMeta->CountOfTables);
        m_iZerothRow    = pDatabaseMeta->iTableMeta;
    }
    else if(0 == wszTable)//Nither Database NOR Table name supplied
    {
        m_ciRows        = m_pFixedTableHeap->Get_cTableMeta();
        m_iZerothRow    = 0;
    }
    else
    {   //Query by Table's InternalName
        ULONG               RowHash = Hash(wszTable, 0) % m_pHashTableHeader->Modulo;
        const HashedIndex * pHashedIndex = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])//Walk the hash links 'til we find a match
        {   
            pTableMeta = m_pFixedTableHeap->Get_aTableMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTableMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_ciRows        = 1;//if we found a match then the size of the table is 1
        m_iZerothRow    = pHashedIndex->iOffset;
    }
    m_pFixedTable   = const_cast<TableMeta *>(pTableMeta);
    return S_OK;
}


HRESULT CSDTFxd::GetTagMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, unsigned long &iOrder, LPCWSTR &InternalName) const
{
    wszTable    = 0;
    iOrder      = -1;
    InternalName= 0;

    unsigned long fSpecifiedQueries=0;//must be 0, 1, 3 or 7

    //There are three queries we support for TagMeta, by TableID, TableID & iOrder, TableID iOrder & InternalName
    for(; cQueryCells; --cQueryCells, ++pQueryCell)
    {
        if(pQueryCell->iCell == iTAGMETA_Table)
        {
            if(0 == wszTable && pQueryCell->eOperator == eST_OP_EQUAL    &&
                                pQueryCell->dbType    == DBTYPE_WSTR     &&
//                                pQueryCell->cbSize    != 0               &&
                                pQueryCell->pData     != 0)
            {
                wszTable = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 1;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iTAGMETA_ColumnIndex)
        {
            if(-1 == iOrder &&  pQueryCell->eOperator == eST_OP_EQUAL   &&
                                pQueryCell->dbType    == DBTYPE_UI4     &&
//                                pQueryCell->cbSize    == sizeof(ULONG)  &&
                                pQueryCell->pData     != 0)
            {
                iOrder = *reinterpret_cast<ULONG *>(pQueryCell->pData);
                fSpecifiedQueries |= 2;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(pQueryCell->iCell == iTAGMETA_InternalName)
        {
            if(0 == InternalName && pQueryCell->eOperator == eST_OP_EQUAL   &&
                                    pQueryCell->dbType    == DBTYPE_WSTR    &&
//                                    pQueryCell->cbSize    != 0              &&
                                    pQueryCell->pData     != 0)
            {
                InternalName = reinterpret_cast<LPCWSTR>(pQueryCell->pData);
                fSpecifiedQueries |= 4;
            }
            else
                return E_ST_INVALIDQUERY;
        }
        else if(0 == (pQueryCell->iCell & iST_CELL_SPECIAL))//The above cells are the only non-reserved cells we support
            return E_ST_INVALIDQUERY;                       //and we're supposed to ignore all reserved cell we don't understand
    }
    switch(fSpecifiedQueries)
    {
    case 0:     //Legal value so fall through to the break
    case 1:     //Legal value so fall through to the break
    case 3:     //Legal value so fall through to the break
    case 7:     break;//Legal value
    default:    return E_ST_INVALIDQUERY;//anything else is an invalid query
    }
    return S_OK;
}


HRESULT CSDTFxd::GetTagMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells)
{
    ULONG iTableMetaRow = m_pFixedTableHeap->FindTableMetaRow(wszTABLE_TAGMETA);
    ASSERT(-1 != iTableMetaRow);
    m_pTableMeta    = m_pFixedTableHeap->Get_aTableMeta(iTableMetaRow);
    m_pColumnMeta   = m_pFixedTableHeap->Get_aColumnMeta(m_pTableMeta->iColumnMeta);

    ASSERT(0 != m_pTableMeta->iHashTableHeader);
    m_pHashedIndex          = m_pFixedTableHeap->Get_HashedIndex(m_pTableMeta->iHashTableHeader+1);
    m_pHashTableHeader      = m_pFixedTableHeap->Get_HashHeader(m_pTableMeta->iHashTableHeader);
    m_pFixedTableUnqueried  = m_pFixedTableHeap->Get_aTagMeta();
    m_cColumnsPlusPrivate   = kciTagMetaColumns;


    HRESULT hr;
    LPCWSTR wszTable        =0;
    ULONG   ColumnIndex    =-1;
    LPCWSTR InternalName    =0;

    if(cQueryCells && FAILED(hr = GetTagMetaQuery(pQueryCell, cQueryCells, wszTable, ColumnIndex, InternalName)))
        return hr;

    const TagMeta *pTagMeta = m_pFixedTableHeap->Get_aTagMeta();//Start with the whole table.
    if(0 == wszTable)
    {   //No query
        m_ciRows        = m_pFixedTableHeap->Get_cTagMeta();
        m_iZerothRow    = 0;
    }
    else if(-1 == ColumnIndex)
    {   //query by Table only
        ULONG                   RowHash         = Hash(wszTable, 0) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pTagMeta      = m_pFixedTableHeap->Get_aTagMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTagMeta->Table)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cTagMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTagMeta[m_ciRows].Table)); ++m_ciRows);
    }
    else if(0 == InternalName)
    {   //Query by TableName and ColumnIndex
        ULONG                   RowHash         = Hash(ColumnIndex, Hash(wszTable, 0)) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pTagMeta      = m_pFixedTableHeap->Get_aTagMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTagMeta->Table)) && ColumnIndex == UI4FromIndex(pTagMeta->ColumnIndex))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_iZerothRow    = pHashedIndex->iOffset;
        for(m_ciRows = 0; (m_iZerothRow + m_ciRows) < m_pFixedTableHeap->Get_cTagMeta() && 0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTagMeta[m_ciRows].Table))
                         && ColumnIndex == UI4FromIndex(pTagMeta[m_ciRows].ColumnIndex); ++m_ciRows);
    }
    else
    {   //Query by all three PrimaryKeys
        ULONG                   RowHash         = Hash(InternalName, Hash(ColumnIndex, Hash(wszTable, 0))) % m_pHashTableHeader->Modulo;
        const HashedIndex     * pHashedIndex    = &m_pHashedIndex[RowHash];

        if(-1 == pHashedIndex->iOffset)return E_ST_NOMOREROWS;

        for(;; pHashedIndex = &m_pHashedIndex[pHashedIndex->iNext])
        {   //Walk the hash links 'til we find a match
            pTagMeta      = m_pFixedTableHeap->Get_aTagMeta(pHashedIndex->iOffset);
			if(0 == StringInsensitiveCompare(wszTable, StringFromIndex(pTagMeta->Table)) && ColumnIndex == UI4FromIndex(pTagMeta->ColumnIndex)
                            && 0 == StringInsensitiveCompare(InternalName, StringFromIndex(pTagMeta->InternalName)))
                break;
            if(-1 == pHashedIndex->iNext)
                return E_ST_NOMOREROWS;
        }

        m_ciRows        = 1;
        m_iZerothRow    = pHashedIndex->iOffset;
    }
    m_pFixedTable = const_cast<TagMeta *>(pTagMeta);
    return S_OK;
}

const LPWSTR CSDTFxd::wszCoreMetaFile = L"catmeta.xml";
const LPWSTR CSDTFxd::wszMachineCfgFile = L"machine.cfg";

HRESULT CSDTFxd::GetPointersToHeapMetaStructures(ISimpleTableDispenser2 * pISTDisp)
{
    HRESULT hr; // we're being optimistic
    static  TFixedTableHeapBuilder *pExtendedFixedTableHeap=0;

    CComPtr<ISimpleTableRead2 >pISTFiles;
    WCHAR wszMachineCfgFullName[MAX_PATH];
    WCHAR wszCatmetaFullName[MAX_PATH];
    LPWSTR wszFilename;
    STQueryCell qc;
    ULONG iRes, i, cRows;
    ULONG one = 1;

    //Get the machine configuration directory
    iRes = ::GetMachineConfigDirectory(WSZ_PRODUCT_NETFRAMEWORKV1, wszMachineCfgFullName, MAX_PATH);
    if (iRes + wcslen(CSDTFxd::wszMachineCfgFile) + 1 > MAX_PATH) return E_OUTOFMEMORY;

    //Append machine.cfg to the directory
    wcscat(wszMachineCfgFullName, CSDTFxd::wszMachineCfgFile);

    // Prepare the query cell
	qc.pData = wszMachineCfgFullName;
	qc.eOperator = eST_OP_EQUAL;
	qc.iCell = iST_CELL_FILE;
	qc.dbType = DBTYPE_WSTR;
	qc.cbSize = (ULONG)wcslen(wszMachineCfgFullName);

    // Get the SchemaFile table
    hr = pISTDisp->GetTable(wszDATABASE_CONFIGSYS, wszTABLE_SchemaFiles, (LPVOID)&qc, (LPVOID) &one, eST_QUERYFORMAT_CELLS, fST_LOS_NONE, (LPVOID *)&pISTFiles);
    if (hr == E_ST_INVALIDTABLE) 
    {
        //BUGBUG - this should not be the code for file not found - however, this is what the XML interceptor returns if it doesnt find the file
        return E_ST_INVALIDEXTENDEDMETA;
    }
    if(FAILED(hr)) return hr;

    hr = pISTFiles->GetTableMeta(NULL, NULL, &cRows, NULL);
    if(FAILED(hr)) return hr;

    //When dealing with objects from CatUtil code, everything must be wrapped in a try catch and the only type of exception throw is TException
    try 
    {
        TSmartPointerArray<TXmlFile> aXMLFiles = new TXmlFile[cRows+1]; //the +1 is for catmeta.xml which we always read
        if(0 == aXMLFiles.m_p)
            return E_OUTOFMEMORY;

        // Prepend the directory of catalog.sll to wszCoreMetaFile
        GetModuleFileName(g_hModule, wszCatmetaFullName, MAX_PATH);
        *(wcsrchr(wszCatmetaFullName, L'\\')+1) = 0x00; // get rid of catalog.dll
        wcscat(wszCatmetaFullName, CSDTFxd::wszCoreMetaFile);//tack on the filename to the current dir path.

        // Parse catmeta.xml
        aXMLFiles[0].SetAlternateErrorReporting();
        aXMLFiles[0].Parse(wszCatmetaFullName, true);//Parse and validate
        if(!aXMLFiles[0].IsSchemaEqualTo(TComCatMetaXmlFile::m_szComCatMetaSchema))
        {
             TRACE(L"Error! %s is not a valid %s.  Schema version mismatch", wszCatmetaFullName, TComCatMetaXmlFile::m_szComCatMetaSchema );
             ASSERT(false && "Schema version mismatch");
        }

		int iNrValidFiles = 0; // how many files do actually exist

        // iterate the list of files and parse them
        for(i = 0; i<cRows; i++)
        {
            hr = pISTFiles->GetColumnValues(i, 1, &one, NULL, (LPVOID*) &wszFilename); // read column 1, which happens to be the filename
            if(FAILED(hr)) return hr;
    
			// verify that the file exists. If not, we skip the file, and
			// continue with the next file
			if (GetFileAttributes (wszFilename) == -1)
			{
				//Log an error to the event log
				LOG_ERROR(Win32, (STG_E_FILENOTFOUND, ID_CAT_CAT,IDS_COMCAT_FILE_NOT_FOUND, wszFilename));
				continue;
			}
		   
			iNrValidFiles++;

            aXMLFiles[iNrValidFiles].SetAlternateErrorReporting();
            aXMLFiles[iNrValidFiles].Parse(wszFilename, true);//Parse and validate
            if(!aXMLFiles[iNrValidFiles].IsSchemaEqualTo(TComCatMetaXmlFile::m_szComCatMetaSchema))
            {
                TRACE(L"Error! %s is not a valid %s.  Schema version mismatch", wszFilename, TComCatMetaXmlFile::m_szComCatMetaSchema );
                 ASSERT(false && "Schema version mismatch");
            }
        }

        // Create the fixup structures out of the list of parsed XML files
        TDebugOutput  so;
        TComCatMetaXmlFile meta = TComCatMetaXmlFile(aXMLFiles, iNrValidFiles+1, so);
        TMetaInferrence().Compile(meta, so);
        THashedPKIndexes().Compile(meta, so);
        THashedUniqueIndexes().Compile(meta, so);

        ASSERT(0 == pExtendedFixedTableHeap);

        pExtendedFixedTableHeap = new TFixedTableHeapBuilder();
        if(0 == pExtendedFixedTableHeap)
            return E_OUTOFMEMORY;
        pExtendedFixedTableHeap->Compile(meta, so);
        g_pExtendedFixedTableHeap = reinterpret_cast<const FixedTableHeap *>(pExtendedFixedTableHeap->m_FixedTableHeap.GetHeapPointer());
        ASSERT(0 != g_pExtendedFixedTableHeap);
    }
    catch(TException e)
    {
        hr = E_ST_INVALIDEXTENDEDMETA;
    }

    return hr;
}


/*
void DumpMetaTables()
{
    #define output OutputDebugString
    #define pciColumnMetas      &g_ciColumnMetas
    #define pciDatabaseMetas    &g_ciDatabaseMetas
    #define pciGuid             &g_ciGuid     
    #define pciIndexMeta        &g_ciIndexMeta
    #define pciQueryMeta        &g_ciQueryMeta
    #define pciRelationMeta     &g_ciRelationMeta
    #define pciTableMetas       &g_ciTableMetas
    #define pciTagMeta          &g_ciTagMeta  
    #define pciWChar            &g_ciWChar    

    #define aColumnMeta         g_aColumnMeta  
    #define aDatabaseMeta       g_aDatabaseMeta
    #define aGuid               g_aGuid
    #define aIndexMeta          g_aIndexMeta    
    #define aQueryMeta          g_aQueryMeta    
    #define aRelationMeta       g_aRelationMeta
    #define aTableMeta          g_aTableMeta
    #define aTagMeta            g_aTagMeta      
    #define aWChar              g_aWChar

    #define szBuffer szBuf
    WCHAR szBuf[2048];

    wsprintf(szBuf, L"\nDatabaseMeta\n");output(szBuf);
    wsprintf(szBuf, L"{%40s, %40s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s}\n", L"InternalName", L"PublicName", L"BaseVersion", L"ExtendedVersion",
                    L"CountOfTables", L"iSchemaBlob", L"cbSchemaBlob", L"iNameHeapBlob", L"cbNameHeapBlob", L"iTableMeta", L"iGuidDid");
    output(szBuf);
    for(unsigned int iDatabaseMeta=1; iDatabaseMeta<*pciDatabaseMetas; iDatabaseMeta++)
    {
        wsprintf(szBuf, L"{%40s, %40s,      0x%08X,      0x%08X,      0x%08X, %15d, %15d, %15d, %15d, %15d, %15d}\n", 
                        String(aDatabaseMeta[iDatabaseMeta].InternalName   )   ,//Index into aWChar
                        String(aDatabaseMeta[iDatabaseMeta].PublicName     )   ,//Index into aWChar
                        UI4FromIndex(aDatabaseMeta[iDatabaseMeta].BaseVersion       )   ,//
                        UI4FromIndex(aDatabaseMeta[iDatabaseMeta].ExtendedVersion   )   ,//
                        UI4FromIndex(aDatabaseMeta[iDatabaseMeta].CountOfTables     )   ,//Count of tables in database
                        aDatabaseMeta[iDatabaseMeta].iSchemaBlob                        ,//Index into aBytes
                        aDatabaseMeta[iDatabaseMeta].cbSchemaBlob                       ,//Count of Bytes of the SchemaBlob
                        aDatabaseMeta[iDatabaseMeta].iNameHeapBlob                      ,//Index into aBytes
                        aDatabaseMeta[iDatabaseMeta].cbNameHeapBlob                     ,//Count of Bytes of the SchemaBlob
                        aDatabaseMeta[iDatabaseMeta].iTableMeta                         ,//Index into aTableMeta
                        aDatabaseMeta[iDatabaseMeta].iGuidDid                           );//Index to aGuid where the guid is the Database InternalName cast as a GUID and padded with 0x00s.
        output(szBuf);Sleep(10);
    }
    wsprintf(szBuf, L"\nTableMeta\n");output(szBuf);
    wsprintf(szBuf, L"{%40s, %40s, %40s, %40s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %15s}\n", L"Database", L"InternalName",
                    L"PublicName", L"PublicRowName", L"BaseVersion", L"ExtendedVersion", L"NameColumn", L"NavColumn", L"CountOfColumns", L"MetaFlags",
                    L"SchemaGenFlags", L"ciRows", L"iColumnMeta", L"iFixedTable", L"cPrivateColumns", L"cIndexMeta", L"iIndexMeta");
    output(szBuf);
    for(unsigned int iTableMeta=1; iTableMeta<*pciTableMetas; iTableMeta++)
    {
        wsprintf(szBuf, L"{%40s, %40s, %40s, %40s,      0x%08X,      0x%08X,      0x%08X,      0x%08X,      0x%08X,      0x%08X,      0x%08X, %15d, %15d, %15d, %15d, %15d, %15d}\n", 
                        String(aTableMeta[iTableMeta].Database             )   ,//Index into aWChar
                        String(aTableMeta[iTableMeta].InternalName         )   ,//Index into aWChar
                        String(aTableMeta[iTableMeta].PublicName           )   ,//Index into aWChar
                        String(aTableMeta[iTableMeta].PublicRowName        )   ,//Index into aWChar
                        UI4FromIndex(aTableMeta[iTableMeta].BaseVersion             )   ,//
                        UI4FromIndex(aTableMeta[iTableMeta].ExtendedVersion         )   ,//
                        UI4FromIndex(aTableMeta[iTableMeta].NameColumn              )   ,//iOrder of the NameColumn
                        UI4FromIndex(aTableMeta[iTableMeta].NavColumn               )   ,//iOrder of the NavColumn
                        UI4FromIndex(aTableMeta[iTableMeta].CountOfColumns          )   ,//Count of Columns
                        UI4FromIndex(aTableMeta[iTableMeta].MetaFlags               )   ,//TableMetaFlags are defined in CatInpro.meta
                        UI4FromIndex(aTableMeta[iTableMeta].SchemaGeneratorFlags    )   ,//SchemaGenFlags are defined in CatInpro.meta
                        aTableMeta[iTableMeta].ciRows                                   ,//Count of Rows in the Fixed Table (which if the fixed table is meta, this is also the number of columns in the table that the meta describes).
                        aTableMeta[iTableMeta].iColumnMeta                              ,//Index into aColumnMeta
                        aTableMeta[iTableMeta].iFixedTable                              ,//Index into g_aFixedTable
                        aTableMeta[iTableMeta].cPrivateColumns                          ,//This is the munber of private columns (private + ciColumns = totalColumns), this is needed for fixed table pointer arithmetic
                        aTableMeta[iTableMeta].cIndexMeta                               ,//The number of IndexMeta entries in this table
                        aTableMeta[iTableMeta].iIndexMeta                               );//Index into aIndexMeta
        output(szBuf);Sleep(10);
    }
    wsprintf(szBuf, L"\nColumnMeta\n");output(szBuf);
    wsprintf(szBuf, L"{%40s, %15s, %40s, %40s, %15s, %15s, %15s, %15s, %15s, %15s, %15s, %40s, %15s, %15s}\n", L"Table", L"Index", L"InternalName", L"PublicName",
                    L"Type", L"Size", L"MetaFlags", L"DefaultValue", L"FlagMask", L"StartingNumber", L"EndingNumber", L"CharacterSet", L"ciTagMeta", L"iTagMeta");
    output(szBuf);
    for(unsigned int iColumnMeta=1; iColumnMeta<*pciColumnMetas; iColumnMeta++)
    {
        wsprintf(szBuf, L"{%40s,      0x%08X, %40s, %40s,      0x%08X,      0x%08X,      0x%08X, %15s,      0x%08X,      0x%08X,      0x%08X, %40s, %15d, %15d}\n", 
                        String(aColumnMeta[iColumnMeta].Table           )  ,//Index into aWChar
	                    UI4FromIndex(aColumnMeta[iColumnMeta].Index              )  ,//Index into UI4 pool, Column Index
                        String(aColumnMeta[iColumnMeta].InternalName    )  ,//Index into aWChar
                        String(aColumnMeta[iColumnMeta].PublicName      )  ,//Index into aWChar
	                    UI4FromIndex(aColumnMeta[iColumnMeta].Type               )  ,//These are a subset of DBTYPEs defined in oledb.h (exact subset is defined in CatInpro.schema)
	                    UI4FromIndex(aColumnMeta[iColumnMeta].Size               )  ,//
	                    UI4FromIndex(aColumnMeta[iColumnMeta].MetaFlags          )  ,//ColumnMetaFlags defined in CatInpro.meta
                        aColumnMeta[iColumnMeta].DefaultValue ? L"<Bytes>" : L"<Null>",
                        UI4FromIndex(aColumnMeta[iColumnMeta].FlagMask           )  ,//Only valid for flags
                        UI4FromIndex(aColumnMeta[iColumnMeta].StartingNumber     )  ,//Only valid for UI4s
                        UI4FromIndex(aColumnMeta[iColumnMeta].EndingNumber       )  ,//Only valid for UI4s
                        aColumnMeta[iColumnMeta].CharacterSet ? String(aColumnMeta[iColumnMeta].CharacterSet) : L"<Null>",//Index into aWChar - Only valid for WSTRs
                        aColumnMeta[iColumnMeta].ciTagMeta                          ,//Count of Tags - Only valid for UI4s
                        aColumnMeta[iColumnMeta].iTagMeta                           );//Index into aTagMeta - Only valid for UI4s
        output(szBuf);Sleep(10);
    }
    wsprintf(szBuf, L"\nTagMeta\n");output(szBuf);
    wsprintf(szBuf, L"{%40s, %15s, %40s, %40s, %15s}\n", L"Table", L"ColumnIndex", L"InternalName", L"PublicName", L"Value");
    output(szBuf);
    for(unsigned int iTagMeta=1; iTagMeta<*pciTagMeta; iTagMeta++)
    {
        wsprintf(szBuf, L"{%40s,      0x%08X, %40s, %40s,      0x%08X}\n", 
	                    String (aTagMeta[iTagMeta].Table           ),
	                    UI4FromIndex    (aTagMeta[iTagMeta].ColumnIndex     ),
	                    String (aTagMeta[iTagMeta].InternalName    ),
                        String (aTagMeta[iTagMeta].PublicName      ),        
                        UI4FromIndex    (aTagMeta[iTagMeta].Value           ));
        output(szBuf);Sleep(10);
    }
    wsprintf(szBuf, L"\nIndexMeta\n");output(szBuf);
    wsprintf(szBuf, L"{%40s, %40s, %15s, %40s, %40s, %15s}\n", L"Table", L"PublicName", L"ColumnIndex", L"InternalName", L"ColumnInternalName", L"MetaFlags");
    output(szBuf);
    for(unsigned int iIndexMeta=1; iIndexMeta<*pciIndexMeta; iIndexMeta++)
    {
        wsprintf(szBuf, L"{%40s, %40s,      0x%08X, %40s, %40s,      0x%08X}\n", 
	                    String (aIndexMeta[iIndexMeta].Table               ),
                        String (aIndexMeta[iIndexMeta].PublicName          ),
	                    UI4FromIndex    (aIndexMeta[iIndexMeta].ColumnIndex         ),
	                    String (aIndexMeta[iIndexMeta].InternalName        ),        
	                    String (aIndexMeta[iIndexMeta].ColumnInternalName  ),
                        UI4FromIndex    (aIndexMeta[iIndexMeta].MetaFlags           ));
        output(szBuf);Sleep(10);
    }
    wsprintf(szBuf, L"\nQueryMeta\n");output(szBuf);
    wsprintf(szBuf, L"{%40s, %40s, %40s, %15s, %40s, %15s, %15s}\n", L"Table", L"InternalName", L"PublicName" ,L"Index" ,L"CellName" ,L"Operator" ,L"MetaFlags");
    output(szBuf);
    for(unsigned int iQueryMeta=1; iQueryMeta<*pciQueryMeta; iQueryMeta++)
    {
        wsprintf(szBuf, L"{%40s, %40s, %40s,      0x%08X, %40s,      0x%08X,      0x%08X}\n", 
                        String (aQueryMeta[iQueryMeta].Table       ),
                        String (aQueryMeta[iQueryMeta].InternalName),
                        String (aQueryMeta[iQueryMeta].PublicName  ),
                        UI4FromIndex    (aQueryMeta[iQueryMeta].Index       ),
                        String (aQueryMeta[iQueryMeta].CellName    ),
                        UI4FromIndex    (aQueryMeta[iQueryMeta].Operator    ),
                        UI4FromIndex    (aQueryMeta[iQueryMeta].MetaFlags   ));
        output(szBuf);Sleep(10);
    }
    wsprintf(szBuf, L"\nRelationMeta\n");output(szBuf);
    wsprintf(szBuf, L"{%40s, %20s, %40s, %20s, %15s}\n", L"PrimaryTable", L"PrimaryColumns", L"ForeignTable", L"ForeignColumns", L"MetaFlags");
    output(szBuf);
    for(unsigned int iRelationMeta=1; iRelationMeta<*pciRelationMeta; iRelationMeta++)
    {
        wsprintf(szBuf, L"{%40s, %20s, %40s, %20s,      0x%08X}\n", 
                        String(aRelationMeta[iRelationMeta].PrimaryTable   ),
                                        L"<bytes>"                               ,
                        String(aRelationMeta[iRelationMeta].ForeignTable   ),
                                        L"<bytes>"                               ,
                        UI4FromIndex(aRelationMeta[iRelationMeta].MetaFlags         ));
        output(szBuf);Sleep(10);
    }
    wsprintf(szBuf, L"\nString Pool\n");output(szBuf);
    unsigned int iWChar=4;
    while(iWChar < *pciWChar)
    {
        wsprintf(szBuf, L"%4d\t%s\n", iWChar, String(iWChar));
        iWChar += StringBufferLengthFromIndex(iWChar)+2;
        output(szBuf);Sleep(10);
    }
    wsprintf(szBuf, L"\nGuid Pool\n");output(szBuf);
    LPWSTR pszGuid=0;
    for(unsigned int iGuid=1; iGuid < *pciGuid; iGuid++)
    {
        StringFromCLSID(aGuid[iGuid], &pszGuid);
        wsprintf(szBuf, L"%4d\t%s\n", iGuid, pszGuid);
        CoTaskMemFree(pszGuid);pszGuid=0;
        output(szBuf);Sleep(10);
    }
}

void DumpFixedTables()
{
    #define ciTableMeta     g_ciTableMetas
    #define aColumnMeta     g_aColumnMeta
    #define aHashedIndex    g_aHashedIndex
    #define aTableMeta      g_aTableMeta
    #define aULong          g_aULong
    #define aGuid           g_aGuid
    #define output          OutputDebugString

    const TableMeta *pTableMeta = aTableMeta;
    WCHAR szBuf[2048];
    for(unsigned long iTableMeta=0; iTableMeta< ciTableMeta; ++iTableMeta, ++pTableMeta)
    {
        if(static_cast<long>(pTableMeta->iFixedTable) > 0)
        {
            const ULONG *pLong= &aULong[pTableMeta->iFixedTable];
            const ColumnMeta *pColumnMeta = &aColumnMeta[pTableMeta->iColumnMeta];

            wsprintf(szBuf, L"Fixed Table --------- %s ---------\n", String(pTableMeta->PublicName));
            output(szBuf);

            output(L"\t{");
            for(unsigned long iColumn=0;iColumn<UI4FromIndex(pTableMeta->CountOfColumns); ++iColumn, ++pColumnMeta)
            {
                wsprintf(szBuf, L"%50s", String(pColumnMeta->InternalName));output(szBuf);
                if(iColumn != UI4FromIndex(pTableMeta->CountOfColumns)-1)
                    output(L" , ");
            }
            output(L"}\n");

            for(unsigned long iRow=0; iRow<pTableMeta->ciRows; ++iRow)
            {
                pColumnMeta = &aColumnMeta[pTableMeta->iColumnMeta];
                ULONG RowHash = 0;

                output(L"\t{");
                for(unsigned long iColumn=0;iColumn<UI4FromIndex(pTableMeta->CountOfColumns); ++iColumn, ++pColumnMeta)
                {
                    if(0 == (UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_NOTPERSISTABLE))
                    {
                        if(0 == pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn])
                        {
                            wsprintf(szBuf, L"%50s", L"<Null>");
                            output(szBuf);
                        }
                        else
                        {
                            switch(UI4FromIndex(pColumnMeta->Type))
                            {
                            case DBTYPE_GUID:
                                {
                                    const GUID *pGuid = &aGuid[pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn]];

                                    LPOLESTR szGuid;
                                    StringFromCLSID(*pGuid, &szGuid);
                                    wsprintf(szBuf, L"%50s", szGuid);
                                    output(szBuf);
                                    CoTaskMemFree(szGuid);
                                    if(UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY)
                                        RowHash = Hash(*pGuid, RowHash);
                                }
                                break;
                            case DBTYPE_WSTR:
                                {
                                    wsprintf(szBuf, L"%50s", String(pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn]));
                                    output(szBuf);
                                    if(UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY)
                                        RowHash = Hash(String(pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn]), RowHash);
                                }
                                break;
                            case DBTYPE_UI4:
                                wsprintf(szBuf, L"%39s 0x%08X", L"", UI4FromIndex(pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn]));
                                output(szBuf);
                                if(UI4FromIndex(pColumnMeta->MetaFlags) & fCOLUMNMETA_PRIMARYKEY)
                                    RowHash = Hash(UI4FromIndex(pLong[iRow*UI4FromIndex(pTableMeta->CountOfColumns) + iColumn]), RowHash);
                                break;
                            case DBTYPE_BYTES:
                                wsprintf(szBuf, L"%50s", L" <Bytes>  ");
                                output(szBuf);
                                break;
                            default:
                                ASSERT(false && "Something's wrong, we should never get a type other than the four basic types");
                            }
                        }
                    }
                    else
                    {
                        output(L"    ");
                    }
                    if(iColumn != UI4FromIndex(pTableMeta->CountOfColumns)-1)
                        output(L" , ");
                }
                wsprintf(szBuf, L"} Hash= 0x%08x, Modulo= 0x%08x, RowHash= 0x%08x\n", RowHash, aHashedIndex[pTableMeta->iHashTableHeader].iNext, RowHash % aHashedIndex[pTableMeta->iHashTableHeader].iNext);
                output(szBuf);
                Sleep(25);
            }
            wsprintf(szBuf, L"end Table   --------- %s ---------\n\n", String(pTableMeta->PublicName));
            output(szBuf);
        }
    }
}

void DumpTables()
{
    DumpMetaTables();
    DumpFixedTables();
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\fixedtable\sdtfxd.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __SDTFXD_H_
#define __SDTFXD_H_

#include "catalog.h"
#include "sdtfxd_data.h"
#include "utsem.h"
#ifndef __TFILEMAPPING_H__
    #include "TFileMapping.h"
#endif


// ------------------------------------------------------------------
// class CSDTFxd:
// ------------------------------------------------------------------
class CSDTFxd : 
    public ISimpleTableInterceptor,
    public ISimpleTableRead2,
    public ISimpleTableAdvanced
{
public:
    CSDTFxd ();
    ~CSDTFxd ();

// -----------------------------------------
// IUnknown, IClassFactory, ISimpleLogicTableDispenser:
// -----------------------------------------

//IUnknown
public:
    STDMETHOD (QueryInterface)      (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();

//ISimpleDataTableDispenser
public:
    STDMETHOD(Intercept) (
                        LPCWSTR                 i_wszDatabase,
                        LPCWSTR                 i_wszTable, 
						ULONG					i_TableID,
                        LPVOID                  i_QueryData,
                        LPVOID                  i_QueryMeta,
                        DWORD                   i_eQueryFormat,
                        DWORD                   i_fTable,
                        IAdvancedTableDispenser* i_pISTDisp,
                        LPCWSTR                 i_wszLocator,
                        LPVOID                  i_pSimpleTable,
                        LPVOID*                 o_ppv
                        );

// -----------------------------------------
// ISimpleTable*:
// -----------------------------------------

//ISimpleTableRead2
public:
    STDMETHOD (GetRowIndexByIdentity)   (ULONG * i_cb, LPVOID * i_pv, ULONG* o_piRow);
    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetColumnValues)     (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);
    STDMETHOD (GetTableMeta)        (ULONG *o_pcVersion, DWORD * o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns );
    STDMETHOD (GetColumnMetas)      (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas);

//ISimpleTableAdvanced
public:
    STDMETHOD (PopulateCache)           ();
    STDMETHOD (GetDetailedErrorCount)   (ULONG* o_pcErrs);
    STDMETHOD (GetDetailedError)        (ULONG i_iErr, STErr* o_pSTErr);

// -----------------------------------------
// Member variables:
// -----------------------------------------

private:
    bool                    m_bDidMeta;
    unsigned long           m_cColumns;             // This duplicate to m_pTableMeta->CountOfColumns eliminate a bunch of UI4FromIndexs
    unsigned long           m_cColumnsPlusPrivate;  // Since this information is needed all over the place, we have this to eliminate an 'add'.
    unsigned long           m_cIndexMeta;
    unsigned long           m_ciRows;
    ULONG                   m_cPrimaryKeys;         // This is the number of promary keys there are in the table.
    ULONG                   m_cRef;                 // Interface reference count.
    DWORD                   m_fIsTable;             // Either component is posing as class factory / dispenser or table.
    ULONG                   m_iZerothRow;           // When a query is executed, the consumer's 0th row, is m_iZerothRow.  All Rows must be between 0 & m_ciRows
    const ColumnMeta      * m_pColumnMeta;          // Pointer to the ColumnMeta
    const void            * m_pFixedTableUnqueried; // We need to keep this around since, hash indexes refer to the row from the beginning of the table.
    const void            * m_pFixedTable;
    const HashedIndex     * m_pHashedIndex;
    const HashTableHeader * m_pHashTableHeader;
    const IndexMeta       * m_pIndexMeta;           // Pointer to the first IndexMeta row for this table & index named in the query.
    const TableMeta       * m_pTableMeta;           // Pointer to the TableMeta, part of this meta is the pointer to the actual data (if exists as FIXED table).
    TFileMapping            m_FixedTableHeapFile;   // If the Meta comes from a file, this object maps a view of the file.

    const FixedTableHeap  * m_pFixedTableHeap;      // This can either be a pointer to g_pFixedTableHeap or one that we generate for extensible schema
    static const LPWSTR     wszCoreMetaFile;        // hardcoded name of the file that contains the meta for the meta
    static const LPWSTR     wszMachineCfgFile;

    HRESULT                 GetPointersToHeapMetaStructures(ISimpleTableDispenser2 * pISTDisp);
    HRESULT                 GetColumnMetaQuery(  const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, unsigned long &iOrder) const;
    HRESULT                 GetColumnMetaTable(  STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetDatabaseMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszDatabase) const;
    HRESULT                 GetDatabaseMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetIndexMeta(        const STQueryCell *pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetIndexMetaQuery(   const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, LPCWSTR &InternalName, unsigned long &iOrder) const;
    HRESULT                 GetIndexMetaTable(   STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetQueryMetaQuery(   const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, LPCWSTR &wszInternalName, LPCWSTR &wszCellName) const;
    HRESULT                 GetQueryMetaTable(   STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetRelationMetaQuery(const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTablePrimary, LPCWSTR &TableForeign) const;
    HRESULT                 GetRelationMetaTable(STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetTableMetaQuery(   const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszDatabase, LPCWSTR &wszTable) const;
    HRESULT                 GetTableMetaTable(   STQueryCell * pQueryCell, unsigned long cQueryCells);
    HRESULT                 GetTagMetaQuery(     const STQueryCell *pQueryCell, unsigned long cQueryCells, LPCWSTR &wszTable, unsigned long &iOrder, LPCWSTR &PublicName) const;
    HRESULT                 GetTagMetaTable(     STQueryCell * pQueryCell, unsigned long cQueryCells);
    inline int              StringInsensitiveCompare(LPCWSTR sz1, LPCWSTR sz2) const
                            {
                                if(sz1 == sz2 || 0 == wcscmp(sz1, sz2))//try case sensitive compare first
                                    return 0;
                                return _wcsicmp(sz1, sz2);
                            }
    inline int              StringCompare(LPCWSTR sz1, LPCWSTR sz2) const
                            {
                                if(sz1 == sz2)
                                    return 0;
                                if(*sz1 != *sz2)//check the first character before calling wcscmp
                                    return -1;
                                return wcscmp(sz1, sz2);
                            }
    inline bool             IsStringFromPool(LPCWSTR sz) const
    {
        return (reinterpret_cast<const unsigned char *>(sz) > m_pFixedTableHeap->Get_PooledDataHeap() && reinterpret_cast<const unsigned char *>(sz) < m_pFixedTableHeap->Get_PooledDataHeap()+m_pFixedTableHeap->Get_cbPooledHeap());
    }

};
        
#endif //__SDTFXD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\memorytable\sltshp.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#include "sltshp.h"
#define USE_NONCRTNEW
#define USE_ADMINASSERT
#include "comacros.h"
#include "catmeta.h"

// ==================================================================
CSLTShapeless::CSLTShapeless ()
	: m_cRef (0)
	, m_fIsDataTable (0)
	, m_fTable (0)
{
}
// ==================================================================
CSLTShapeless::~CSLTShapeless () {}

// ------------------------------------
// ISimpleLogicTableDispenser:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSLTShapeless::Intercept
(
	LPCWSTR					i_wszDatabase,
	LPCWSTR 				i_wszTable, 
	ULONG					i_TableID,
	LPVOID					i_QueryData,
	LPVOID					i_QueryMeta,
	DWORD					i_eQueryFormat,
	DWORD					i_fTable,
	IAdvancedTableDispenser* i_pISTDisp,
	LPCWSTR					i_wszLocator,
	LPVOID					i_pv,
	LPVOID*					o_ppv
)
{
	SimpleColumnMeta	columnmeta;
	HRESULT				hr;

	areturn_on_fail (!m_fIsDataTable, E_UNEXPECTED); // ie: Assert component is posing as class factory / dispenser.
	areturn_on_fail (NULL != o_ppv, E_INVALIDARG);
	if(i_wszLocator)
		return E_INVALIDARG;
	*o_ppv = NULL;

// As a shapeless cache none of these parameters are supported:
	areturn_on_fail (NULL == i_QueryData, E_INVALIDARG);
	areturn_on_fail (NULL == i_QueryMeta, E_INVALIDARG);
	areturn_on_fail (NULL == i_pv, E_INVALIDARG);

// Remember what little is necessary:
	m_fTable = i_fTable;

// Leave the cache shapeless

// Supply ISimpleTable* and transition state from class factory / dispenser to data table:
	*o_ppv = (ISimpleTableWrite2*) this;
	((ISimpleTableWrite2*) this)->AddRef ();
	InterlockedIncrement ((LONG*) &m_fIsDataTable);

	return S_OK;
}


// ------------------------------------
// ISimpleTableRead2:
// ------------------------------------
// ==================================================================
STDMETHODIMP CSLTShapeless::GetRowIndexByIdentity( ULONG*  i_cb, LPVOID* i_pv, ULONG* o_piRow)
{
    return InternalMoveToRowByIdentity(i_cb, i_pv, o_piRow);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::GetColumnValues(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
    return InternalGetColumnValues(i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::GetTableMeta(ULONG * o_pcVersion, DWORD * o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns)
{
	// Todo:  In the old GetTableMeta, we didn't support pfTable or the Query stuff, for the new GetTableMeta if
	//		  we want to support pcVersion or pfTable, we need to implement it.
	areturn_on_fail (NULL == o_pcVersion, E_INVALIDARG);
	areturn_on_fail (NULL == o_pfTable, E_INVALIDARG);

	return InternalGetTableMeta(o_pcVersion, o_pcRows, o_pcColumns);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::GetColumnMetas (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas)
{
	return InternalGetColumnMetas(i_cColumns, i_aiColumns, o_aColumnMetas);
}

// ------------------------------------
// ISimpleTableWrite2:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSLTShapeless::UpdateStore()
{
    HRESULT hr = S_OK;
	
	if (!(m_fTable & fST_LOS_READWRITE)) return E_NOTIMPL;
	hr = InternalPreUpdateStore ();
    if (!SUCCEEDED(hr))
        return hr;
	InternalPostUpdateStore ();
	return hr;
}

// ==================================================================
STDMETHODIMP CSLTShapeless::AddRowForInsert(ULONG* o_piWriteRow)
{
	return InternalAddRowForInsert(o_piWriteRow);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::AddRowForUpdate(ULONG i_iReadRow, ULONG* o_piWriteRow)
{
	return InternalAddRowForUpdate(i_iReadRow, o_piWriteRow);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::AddRowForDelete(ULONG i_iReadRow)
{
	return InternalAddRowForDelete(i_iReadRow);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::GetWriteColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
{
	return InternalGetWriteColumnValues(i_iRow, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes, o_apvValues);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::SetWriteColumnValues(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* i_apvValues)
{
	return InternalSetWriteColumnValues(i_iRow, i_cColumns, i_aiColumns, o_acbSizes, i_apvValues);
}


// ------------------------------------
// ISimpleTableControl:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSLTShapeless::ShapeCache (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes)
{
	return InternalSimpleInitialize (m_fTable, i_cColumns, i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::PrePopulateCache (DWORD i_fControl)
{
	InternalPrePopulateCache (i_fControl);
	return S_OK;
}

// ==================================================================
STDMETHODIMP CSLTShapeless::PostPopulateCache ()
{
	InternalPostPopulateCache ();
	return S_OK;
}

// ==================================================================
STDMETHODIMP CSLTShapeless::DiscardPendingWrites ()
{
	InternalPostUpdateStore ();
	return S_OK;
}

// ==================================================================
STDMETHODIMP CSLTShapeless::GetWriteRowAction(ULONG i_iRow, DWORD* o_peAction)
{
	return InternalGetWriteRowAction(i_iRow, o_peAction);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::SetWriteRowAction(ULONG i_iRow, DWORD i_eAction)
{
	return InternalSetWriteRowAction(i_iRow, i_eAction);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::ChangeWriteColumnStatus (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus)
{
	return InternalChangeWriteColumnStatus (i_iRow, i_iColumn, i_fStatus);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::AddDetailedError (STErr* i_pSTErr)
{
	return InternalAddDetailedError (i_pSTErr);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::GetMarshallingInterface (IID * o_piid, LPVOID * o_ppItf)
{
	// parameter validation
	areturn_on_fail(NULL != o_piid, E_INVALIDARG);
	areturn_on_fail(NULL != o_ppItf, E_INVALIDARG);

	if(fST_LOS_MARSHALLABLE & m_fTable)
	{ // ie: we are a marshallable table
		*o_piid = IID_ISimpleTableMarshall;
		*o_ppItf = (ISimpleTableMarshall *)this;
		((ISimpleTableMarshall *) *o_ppItf)->AddRef();
		return S_OK;
	}
	else
	{// ie: we are NOT a marshallable table
		return E_NOTIMPL;
	}
}
// ------------------------------------
// ISimpleTableAdvanced
// ------------------------------------
// ==================================================================
STDMETHODIMP CSLTShapeless::GetWriteRowIndexByIdentity( ULONG*  i_cbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
    return InternalMoveToWriteRowByIdentity(i_cbSizes, i_apvValues, o_piRow);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::GetDetailedErrorCount (ULONG* o_pcErrs)
{
	return InternalGetDetailedErrorCount (o_pcErrs);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::GetDetailedError (ULONG i_iErr, STErr* o_pSTErr)
{
	return InternalGetDetailedError (i_iErr, o_pSTErr);
}

// ==================================================================
STDMETHODIMP CSLTShapeless::PopulateCache ()
{
	InternalPrePopulateCache ();
	InternalPostPopulateCache ();
    return S_OK;
}

// ------------------------------------
// ISimpleTableMarshal:
// ------------------------------------

// ==================================================================
STDMETHODIMP CSLTShapeless::SupplyMarshallable (DWORD i_fReadNotWrite,
		char **	o_ppv1,	ULONG *	o_pcb1,	char **	o_ppv2, ULONG *	o_pcb2, char **	o_ppv3,
		ULONG *	o_pcb3, char **	o_ppv4, ULONG *	o_pcb4, char **	o_ppv5,	ULONG *	o_pcb5)
{
	return	InternalSupplyMarshallable (i_fReadNotWrite,
		o_ppv1,	o_pcb1, o_ppv2, o_pcb2, o_ppv3,
		o_pcb3,	o_ppv4, o_pcb4, o_ppv5,	o_pcb5);
}

STDMETHODIMP CSLTShapeless::ConsumeMarshallable (DWORD i_fReadNotWrite,
		char * i_pv1, ULONG i_cb1,	char * i_pv2, ULONG i_cb2,	char * i_pv3, 
		ULONG i_cb3, char * i_pv4, ULONG i_cb4,	char * i_pv5, ULONG i_cb5)
{
	return InternalConsumeMarshallable (i_fReadNotWrite,
		i_pv1, i_cb1, i_pv2, i_cb2,	i_pv3, 
		i_cb3, i_pv4, i_cb4, i_pv5, i_cb5);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\memorytable\sltshp.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#ifndef __SLTSHP_H_
#define __SLTSHP_H_

#include "catalog.h"
#include "sdtfst.h"

// ------------------------------------------------------------------
// class CSLTShapeless:
// ------------------------------------------------------------------
class CSLTShapeless : 
	protected CMemoryTable,
	public ISimpleTableInterceptor,
	public ISimpleTableWrite2,
	public ISimpleTableController,
	public ISimpleTableMarshall	
{
public:
	CSLTShapeless ();
	~CSLTShapeless ();

// -----------------------------------------
// IUnknown, IClassFactory, ISimpleLogicTableDispenser:
// -----------------------------------------

//IUnknown
public:
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

//ISimpleLogicTableDispenser
public:
	STDMETHOD(Intercept) (
						LPCWSTR					i_wszDatabase,
						LPCWSTR 				i_wszTable, 
						ULONG					i_TableID,
						LPVOID					i_QueryData,
						LPVOID					i_QueryMeta,
						DWORD					i_eQueryFormat,
						DWORD					i_fTable,
						IAdvancedTableDispenser* i_pISTDisp,
						LPCWSTR					i_wszLocator,
						LPVOID					i_pv,
						LPVOID*					o_ppv
						);

// -----------------------------------------
// ISimpleTable*:
// -----------------------------------------

//ISimpleTableRead2
public:

	STDMETHOD (GetRowIndexByIdentity)	(ULONG * i_cb, LPVOID * i_pv, ULONG* o_piRow);

    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow){return E_NOTIMPL;}

	STDMETHOD (GetColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);

	STDMETHOD (GetTableMeta) (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG *o_pcRows, ULONG* o_pcColumns);

	STDMETHOD (GetColumnMetas)		(ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas);
//ISimpleTableWrite2
public:
	STDMETHOD (AddRowForDelete)			(ULONG i_iReadRow);

	STDMETHOD (AddRowForInsert)	(ULONG* o_piWriteRow);
	STDMETHOD (AddRowForUpdate)	(ULONG i_iReadRow, ULONG* o_piWriteRow);

	STDMETHOD (GetWriteColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues);
	STDMETHOD (SetWriteColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* i_apvValues);

	STDMETHOD (GetWriteRowIndexByIdentity)	(ULONG * i_cbSizes, LPVOID * i_apvValues, ULONG* o_piRow);
	STDMETHOD (UpdateStore)				();
	
//ISimpleTableController
public:
	STDMETHOD (ShapeCache)				(DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes);
	STDMETHOD (PrePopulateCache)		(DWORD i_fControl);
	STDMETHOD (PostPopulateCache)		();
	STDMETHOD (DiscardPendingWrites)	();

	STDMETHOD (GetWriteRowAction)		(ULONG i_iRow, DWORD* o_peAction);
	STDMETHOD (SetWriteRowAction)		(ULONG i_iRow, DWORD i_eAction);
	STDMETHOD (ChangeWriteColumnStatus)	(ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus);

	STDMETHOD (AddDetailedError)		(STErr* o_pSTErr);

	STDMETHOD (GetMarshallingInterface) (IID * o_piid, LPVOID * o_ppItf);

//ISimpleTableAdvanced
public:
	STDMETHOD (PopulateCache)		();
	STDMETHOD (GetDetailedErrorCount)	(ULONG* o_pcErrs);
	STDMETHOD (GetDetailedError)		(ULONG i_iErr, STErr* o_pSTErr);

//ISimpleTableMarshall
public:
	STDMETHOD (SupplyMarshallable) (DWORD i_fReadNotWrite,
		char **	o_ppv1,	ULONG *	o_pcb1,	char **	o_ppv2, ULONG *	o_pcb2, char **	o_ppv3,
		ULONG *	o_pcb3, char **	o_ppv4, ULONG *	o_pcb4, char **	o_ppv5,	ULONG *	o_pcb5);

	STDMETHOD (ConsumeMarshallable) (DWORD i_fReadNotWrite,
		char * i_pv1, ULONG i_cb1,	char * i_pv2, ULONG i_cb2,	char * i_pv3, 
		ULONG i_cb3, char * i_pv4, ULONG i_cb4,	char * i_pv5, ULONG i_cb5);

// -----------------------------------------
// Member variables:
// -----------------------------------------

protected:
	ULONG				m_cRef;						// Interface reference count.
	DWORD				m_fIsDataTable;				// Either component is posing as class factory / dispenser or data table.
	DWORD				m_fTable;					// Table flags.
};
		
#endif //__SLTSHP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\memorytable\sltshp_com.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#include <objbase.h>
#include "sltshp.h"

// -----------------------------------------
// CSLTShapeless: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CSLTShapeless::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (!m_fIsDataTable) // ie: Component is posing as class factory / dispenser:
	{
		if (riid == IID_ISimpleTableInterceptor)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableInterceptor*) this;
		}
	}
	else // ie: Component is currently posing as data table:
	{
		if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableRead2)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableWrite2)
		{
			*ppv = (ISimpleTableWrite2*) this;
		}
		else if (riid == IID_ISimpleTableController)
		{
			*ppv = (ISimpleTableController*) this;
		}
		else if (riid == IID_ISimpleTableAdvanced)
		{
			*ppv = (ISimpleTableAdvanced*) this;
		}
		else if (riid == IID_ISimpleTableMarshall && (fST_LOS_MARSHALLABLE & m_fTable))
		{
			*ppv = (ISimpleTableMarshall*) this;
		}

	}
	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CSLTShapeless::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

// =======================================================================
STDMETHODIMP_(ULONG) CSLTShapeless::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\interceptor\mergecoordinator.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    mergecoordinator.h

$Header: $
	
Abstract:
	Merge Coordinator Definition

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __MERGECOORDINATOR_H__
#define __MERGECOORDINATOR_H__

#pragma once

#include <atlbase.h>
#include "catalog.h"
#include "catmacros.h"

// forward declaration
class CSTConfigStoreWrap;

/**************************************************************************++
Class Name:
    CMergeCoordinator

Class Description:
    The Merge Coodinator handles the merging of configuration stores. It invokes
	the correct tranformer and merger depending on the selector cell and the table
	information, and it will coordinate the merging and updates to the updateable store

Constraints:
	None
--*************************************************************************/
class CMergeCoordinator: public ISimpleTableWrite2, public ISimpleTableAdvanced
{
public:
	CMergeCoordinator ();
	~CMergeCoordinator ();

	//IUnknown
    STDMETHOD (QueryInterface)      (REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();
    
	HRESULT Initialize (LPCWSTR                 i_wszDatabase,
                        LPCWSTR                 i_wszTable, 
                        ULONG                   i_TableID,
                        LPVOID                  i_QueryData,
                        LPVOID                  i_QueryMeta,
                        DWORD                   i_eQueryFormat,
                        DWORD                   i_fLOS,
                        IAdvancedTableDispenser* i_pISTDisp,
                        LPVOID*                 o_ppv
                        );
	//ISimpleTableRead2
    STDMETHOD (GetRowIndexByIdentity)   (ULONG * i_cb, LPVOID * i_pv, ULONG* o_piRow);
    STDMETHOD (GetRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetColumnValues)     (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues);
    STDMETHOD (GetTableMeta)        (ULONG *o_pcVersion, DWORD * o_pfTable, ULONG * o_pcRows, ULONG * o_pcColumns );
    STDMETHOD (GetColumnMetas)      (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas);

	//ISimpleTableAdvanced
    STDMETHOD (PopulateCache)           ();
    STDMETHOD (GetDetailedErrorCount)   (ULONG* o_pcErrs);
    STDMETHOD (GetDetailedError)        (ULONG i_iErr, STErr* o_pSTErr);
	
	//ISimpleTableWrite2
	STDMETHOD (AddRowForDelete)			(ULONG i_iReadRow);
	STDMETHOD (AddRowForInsert)	(ULONG* o_piWriteRow);
	STDMETHOD (AddRowForUpdate)	(ULONG i_iReadRow, ULONG* o_piWriteRow);
	STDMETHOD (GetWriteColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues);
	STDMETHOD (SetWriteColumnValues)	(ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* i_apvValues);
	STDMETHOD (GetWriteRowIndexByIdentity)	(ULONG * i_cbSizes, LPVOID * i_apvValues, ULONG* o_piRow);
	STDMETHOD (GetWriteRowIndexBySearch) (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetErrorTable)           (DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable);
	STDMETHOD (UpdateStore)				();

private:
	HRESULT GetTransformerString ();
	HRESULT GetTransformer ();
	HRESULT GetConfigStores ();
	HRESULT GetMerger ();
	HRESULT GetPKInfo ();
	HRESULT CopyTable (ISimpleTableRead2 *i_pRead, ISimpleTableWrite2 *io_pWrite);
	bool IsValidSelector (LPCWSTR wszSelector) const;

	HRESULT InsertRow (LPVOID *i_pValues);
	HRESULT UpdateRow (LPVOID *i_pValues);
	HRESULT DeleteRow (LPVOID *i_pValues);
	HRESULT HandleUpdateableStoreErrors ();

	// merger creation routines
	HRESULT CreateLocalDllMerger (ULONG i_iMergerID);
	HRESULT CreateForeignDllMerger (ULONG i_iMergerID, const WCHAR * i_wszDLLName);

	long m_cRef;  // reference count
	CComPtr<IAdvancedTableDispenser> m_spSTDisp;
	CComPtr<ISimpleTableWrite2>      m_spMemTable;
	CComPtr<ISimpleTableWrite2>      m_spUpdateStore;
	CComPtr<ISimpleTableTransform>   m_spTransformer;
	CComPtr<ISimpleTableMerge>		 m_spMerger;

	CSTConfigStoreWrap *			 m_aConfigStores;	// configuration store array
	ULONG							 m_cNrRealStores;   // number of config stores
	ULONG							 m_cNrPossibleStores; // number of possible config stores

	ULONG						     m_cNrColumns;      // number of columns for the merged table
	ULONG *							 m_aPKColumns;      // array with indexes of PK columns
	LPVOID *						 m_aPKValues;       // array that holds values for PK columns (perf optimization)

	ULONG							 m_cNrPKColumns;    // number of primary key columns

	LPWSTR							 m_wszProtocol;     // protocol
	LPWSTR							 m_wszSelector;		// selector string without protocol

	LPWSTR					         m_wszDatabase;		// database name
    LPWSTR			                 m_wszTable;		// table name
    ULONG			                 m_TableID;			// table id
	
	ULONG                            m_cNrQueryCells;    // number of query cells
	STQueryCell *                    m_aQueryData;      // query cell data
	ULONG							 m_iSelectorCell;    // index of selector query cell

    DWORD							 m_eQueryFormat;	// query format
    DWORD			                 m_fLOS;			// Level of service
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\interceptor\mc_factory.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    mc_factory.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "mergecoordinator.h"
#include "catmeta.h"

#include "listappend.h"
#include "propertyoverride.h"
#include "listmerge.h"


// Pointer to DllGetSimpleObject kind of functions
typedef HRESULT( __stdcall *PFNDllGetSimpleObjectByID)( ULONG, REFIID, LPVOID);



//=================================================================================
// Function: CMergeCoordinator::GetMerger
//
// Synopsis: This function retrieves creates a merger by looking into the wiring. We
//           once again go look into the serverwiring table to find the rows for this
//           table. Because there is only one merge interceptor allowed for each table,
//           we keep searching until we find this interceptor. Note that we ALWAYS should
//           find a match, else we wouldn't end up here in the first place.
//
// Return Value: 
//=================================================================================
HRESULT 
CMergeCoordinator::GetMerger ()
{
	CComPtr<ISimpleTableWrite2> spISTWiring;
	HRESULT hr = m_spSTDisp->GetTable (wszDATABASE_PACKEDSCHEMA, wszTABLE_SERVERWIRING_META,
		                                 0, 0, eST_QUERYFORMAT_CELLS, fST_LOS_CONFIGWORK, 
										 (LPVOID *)(&spISTWiring));	
	if (FAILED (hr)) 
	{
		TRACE(L"Unable to get Wiring Table");
		return hr;
	}

	// Search by primary key. PK of SERVERWIRING_META is TableID, order. We use the TableID
	// that we got passed in from the merge interceptor, and we start at the zero'th column

	ULONG iRow;
	ULONG *pk[2];
	ULONG zero = 0;
	pk[0] = &m_TableID;
	pk[1] = &zero;

	hr = spISTWiring->GetRowIndexByIdentity (0, (void **) pk, &iRow);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get wiring information for table %ld", m_TableID);
		return hr;
	}

	// we found the starting row. Lets loop until we find the merge interceptor. 
	// TODO(marcelv) Shouldn't the merge interceptor always be the first row, i.e. we
	// don't need the for loop, because the first one is always the merge interceptor row
	tSERVERWIRINGMETARow SWColumns;
	for(ULONG iOrder = iRow;;++iOrder)
	{
		hr = spISTWiring->GetColumnValues(iOrder, cSERVERWIRING_META_NumberOfColumns, 0, 0, (LPVOID *)&SWColumns);
		if (FAILED (hr))
		{
			ASSERT (false);
			return hr;
		}

		if (*SWColumns.pInterceptor == eSERVERWIRINGMETA_Core_MergeInterceptor)
		{
			// we found the merge interceptor. Lets use the merger information
			// to create the merger.
			break;
		}
	}

	// When we get here, we found the merge interceptor. Handle it. When we have a DLL
	// name, the merger is defined in a separate DLL. If the DLL is empty, it means that
	// one of the mergers in the current DLL is used.

	if (SWColumns.pMergerDLLName == 0)
	{
		hr = CreateLocalDllMerger (*SWColumns.pMerger);
	}
	else
	{
		hr = CreateForeignDllMerger (*SWColumns.pMerger, (WCHAR *) SWColumns.pMergerDLLName);
	}

	if (FAILED (hr))
	{
		TRACE (L"Creation of merger failed");
		return hr;
	}

	hr = m_spMerger->Initialize (m_cNrColumns, m_cNrPKColumns, m_aPKColumns);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of merger failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CMergeCoordinator::CreateLocalDllMerger
//
// Synopsis: This function creates all the mergers that are defined in catalog.dll. Any
//           mergers that are defined in their own DLL are created via the CreateDLLMerger
//           function
//
// Arguments: [iMergerID] - ID of merger that we are looking for
//            
// Return Value: E_ST_INVALIDWIRING in case an illegal merger is specified.
//				 S_OK else
//=================================================================================
HRESULT
CMergeCoordinator::CreateLocalDllMerger (ULONG i_iMergerID)
{ 
	ISimpleTableMerge *p = 0;
	switch (i_iMergerID)
	{
		case eSERVERWIRINGMETA_ListAppend:
			p = new CListAppend ();
			break;
		case eSERVERWIRINGMETA_PropertyOverride:
 			p = new CPropertyOverride ();
			break;
		case eSERVERWIRINGMETA_ListMerge:
			p = new CListMerge ();
			break;
		default:
			return E_ST_INVALIDWIRING;
			break;
	}

	if (p == 0)
	{
		return E_OUTOFMEMORY;
	}

	return p->QueryInterface (IID_ISimpleTableMerge, (void **) &m_spMerger );
}

//=================================================================================
// Function: CMergeCoordinator::CreateForeignDllMerger
//
// Synopsis: Creates a merger that is defined in an external DLL. We look for the 
//           function DllGetSimpleObjectByID in the wszDLLName. If we find this function,
//           we invoke it with the merged ID and merger interfaces as parameter. When
//           everything succeeds, we'll get a merger interface back.
//
// Arguments: [iMergerID] - ID of the merger we're looking for
//            [wszDllName] - Name of the DLL in which the merger is defined
//            
//=================================================================================
HRESULT
CMergeCoordinator::CreateForeignDllMerger (ULONG i_iMergerID, LPCWSTR i_wszDllName)
{
	ASSERT (i_wszDllName != 0);

	PFNDllGetSimpleObjectByID pfnDllGetSimpleObjectByID;

	// Load the library 
	HINSTANCE handle = LoadLibrary (i_wszDllName);
	if(0 == handle)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// get the address of DllGetSimpleObject procedure
	pfnDllGetSimpleObjectByID = (PFNDllGetSimpleObjectByID) ::GetProcAddress (handle, "DllGetSimpleObjectByID");
	if(0 == pfnDllGetSimpleObjectByID)
	{
		FreeLibrary(handle);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return (*pfnDllGetSimpleObjectByID)(i_iMergerID, IID_ISimpleTableMerge, &m_spMerger );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\interceptor\mergeinterceptor.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    mergeinterceptor.cpp

$Header: $

Abstract:
	Implements the merge interceptor

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "mergeinterceptor.h"
#include "mergecoordinator.h"

//=================================================================================
// Function: CMergeInterceptor::CMergeInterceptor
//
// Synopsis: Default Constructor. Doesn't do anything
//=================================================================================
CMergeInterceptor::CMergeInterceptor()
{
}

//=================================================================================
// Function: CMergeInterceptor::~CMergeInterceptor
//
// Synopsis: Default Destructor. Doesn't do anything
//=================================================================================
CMergeInterceptor::~CMergeInterceptor ()
{
}

//=================================================================================
// Function: CMergeInterceptor::AddRef
//
// Synopsis: Because the Merge Interceptor is implemented as a singleton, the function
//           always returns 1.
//
// Return Value: 1
//=================================================================================
ULONG
CMergeInterceptor::AddRef ()
{
	return 1;
}

//=================================================================================
// Function: CMergeInterceptor::Release
//
// Synopsis: Because the Merge Interceptor is a singleton, it always returns 1
//
// Return Value: 1
//=================================================================================
ULONG
CMergeInterceptor::Release () 
{
	return 1;
}

//=================================================================================
// Function: CMergeInterceptor::QueryInterface
//
// Synopsis: Default Query interface implementation
//
// Arguments: [riid] - interface id that is requested
//            [ppv] - pointer will be returned here
//            
// Return Value: E_INVALIDARG when null pointer is passed in
//				 E_NOINTERFACE when we don't support the requested interface
//				 S_OK else
//=================================================================================
STDMETHODIMP 
CMergeInterceptor::QueryInterface (REFIID riid, void **ppv)
{
	if (0 == ppv) 
	{
		return E_INVALIDARG;
	}

	*ppv = 0;

	if (riid == IID_ISimpleTableInterceptor || riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}
	else
	{
		return E_NOINTERFACE;
	}

	ASSERT (*ppv != 0);

	((ISimpleTableInterceptor*)this)->AddRef ();

	return S_OK;
}

//=================================================================================
// Function: CMergeInterceptor::Intercept
//
// Synopsis: The function checks if one of the query cells is of type iST_CELL_SELECTOR.
//           If this is the case, the function creates a new merge coordinator, and 
//           forwards the work to the merge coordinator. When no cell of query type
//			 iST_CELL_SELECTOR is found, the function returns E_ST_OMITDISPENSER to 
//           indicate that the merge interceptor couldn't do anything usefull. This
//           means that the dispenser will continue trying with the other 'First'
//           interceptors
//
// Arguments: [i_wszDatabase] - database name
//            [i_wszTable] - table name	
//            [i_TableID] - table id
//            [i_QueryData] - query data
//            [i_QueryMeta] - query meta	
//            [i_eQueryFormat] - query format, must be eST_QUERYFORMAT_CELLS
//            [i_fLOS] - LOS
//            [i_pISTDisp] - pointer to dispenser 
//            [i_wszLocator] - Locator?
//            [i_pSimpleTable] - pointer to simple table. Must always be 0.
//            [o_ppvSTWrite2] - pointer to write interface will be returned in here
//            
// Return Value: E_ST_OMITDISPENSER	- The merge interceptor didn't find a selector cell
//                                    and therefore cannot handle the request.
//				 E_OUTOFMEMORY		- Cannot allocate memory for the merge coordinator
//				 S_OK				- everything ok
//=================================================================================
STDMETHODIMP
CMergeInterceptor::Intercept (LPCWSTR i_wszDatabase, 
							  LPCWSTR i_wszTable,
							  ULONG i_TableID,
							  LPVOID i_QueryData,
							  LPVOID i_QueryMeta,
							  DWORD i_eQueryFormat,
							  DWORD i_fLOS,
							  IAdvancedTableDispenser *i_pISTDisp,
							  LPCWSTR i_wszLocator,
							  LPVOID i_pSimpleTable,
							  LPVOID *o_ppvSTWrite2)
{
	// search for query cell of type iST_CELL_SELECTOR. If this query cell is
	// not found we cannot continue
	ASSERT (i_wszDatabase != 0);
	ASSERT (i_wszTable != 0);
	ASSERT (i_pISTDisp != 0);
	ASSERT (i_pSimpleTable == 0); // We are a first interceptor, so we shouldn't have any table here
	ASSERT (o_ppvSTWrite2 != 0);

	// initialize out parameter
	*o_ppvSTWrite2  = 0;

	// we only support query cells for the moment
	if (i_eQueryFormat !=  eST_QUERYFORMAT_CELLS)
	{
		return E_ST_INVALIDQUERY;
	}

	STQueryCell *pQueryCell = static_cast<STQueryCell *>(i_QueryData );
	
	// Number of query cells is only relevant when we have querydata
	ULONG ulNrCells = 0;
	if (pQueryCell != 0)
	{
		ulNrCells = *static_cast<ULONG *>(i_QueryMeta);
	}

	bool bFound = false;
	// walk through all the query cells and find a transformer
	for (ULONG idx=0; idx < ulNrCells; ++idx)
	{
		// the special cells are always specified before the non-special cells
		// this means that as soon as we find a non-special cells, we can stop
		// searching, because a selector cell is defined as a special cell
		if (!(pQueryCell[idx].iCell & iST_CELL_SPECIAL))
		{
			break;
		}
		else if (pQueryCell[idx].iCell == iST_CELL_SELECTOR)
		{
			bFound = true;
			break;
		}
	}

	if (!bFound)
	{
		TRACE (L"Merge Interceptor invoked for (%s, %s) without Selector string. Omitting Dispenser", i_wszDatabase, i_wszTable);
		return E_ST_OMITDISPENSER;
	}

	// we found a transformer string. Lets invoke the merge coordinator and delegate
	// the work to it. The Merge Coordinator is a COM object that can act as both an
	// interceptor and a ISTWrite interface. Because of that we cannot use delete to
	// get rid of it, but we have to use proper referencing counting techniques. The
	// AddRef and Release below are necessary to enforce this, and cannot be optimized
	// away

	CMergeCoordinator *pMergeCoordinator = new CMergeCoordinator;
	if (pMergeCoordinator == 0)
	{
		return E_OUTOFMEMORY;
	}
	pMergeCoordinator->AddRef ();

	HRESULT	hr = pMergeCoordinator->Initialize( i_wszDatabase, 
												i_wszTable,
												i_TableID,
												i_QueryData,
												i_QueryMeta,
												i_eQueryFormat,
												i_fLOS,
												i_pISTDisp,
												o_ppvSTWrite2);

	// release the merge coordinator. We need to call release to delete the merge coordinator in case
	// Initialize failed.
	pMergeCoordinator->Release ();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\interceptor\mergecoordinator.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    mergecoordinator.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "mergecoordinator.h"
#include "catmeta.h"
#include "smartpointer.h"
#include "stconfigstorewrap.h"

#include "transformerfactory.h"

//=================================================================================
// Function: CMergeCoordinator::CMergeCoordinator
//
// Synopsis: Constructor
//=================================================================================
CMergeCoordinator::CMergeCoordinator()
{
	m_cRef				= 0;
	m_wszSelector		= 0;
	m_wszProtocol		= 0;
	m_wszDatabase		= 0;
	m_wszTable			= 0;
	m_TableID			= 0;
	m_cNrColumns		= 0;
	m_fLOS				= 0;
	m_aConfigStores		= 0;
	m_cNrRealStores		= 0;
	m_cNrPossibleStores	= 0;
	m_aPKColumns		= 0;
	m_aPKValues			= 0;
	m_cNrPKColumns		= 0;
	m_cNrQueryCells		= 0;
	m_aQueryData		= 0;
	m_eQueryFormat		= 0;
	m_iSelectorCell		= 0;
}

//=================================================================================
// Function: CMergeCoordinator::~CMergeCoordinator
//
// Synopsis: Destructor
//=================================================================================
CMergeCoordinator::~CMergeCoordinator ()
{
	delete [] m_wszSelector;
	m_wszSelector = 0;

	delete [] m_wszProtocol;
	m_wszProtocol = 0;

	delete [] m_wszDatabase;
	m_wszDatabase = 0;

	delete [] m_wszTable;
	m_wszTable = 0;

	delete [] m_aConfigStores;
	m_aConfigStores = 0;

	delete [] m_aPKColumns;
	m_aPKColumns = 0;

	delete [] m_aPKValues;
	m_aPKValues = 0;

	delete [] m_aQueryData;
	m_aQueryData = 0;
}

//=================================================================================
// Function: CMergeCoordinator::AddRef
//
// Synopsis: Default AddRef implementation
//=================================================================================
ULONG
CMergeCoordinator::AddRef ()
{
	return InterlockedIncrement((LONG*) &m_cRef);
}

//=================================================================================
// Function: CMergeCoordinator::Release
//
// Synopsis: Default Release implementation
//=================================================================================
ULONG
CMergeCoordinator::Release () 
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}

//=================================================================================
// Function: CMergeCoordinator::QueryInterface
//
// Synopsis: Default QI implementation
//
// Arguments: [riid] - interface id
//            [ppv] - pointer to interface in case interface is supported
//            
// Return Value: E_NOINTERFACE if interface not supported, S_OK else
//=================================================================================
STDMETHODIMP 
CMergeCoordinator::QueryInterface (REFIID riid, void **ppv)
{
	if (0 == ppv) 
	{
		return E_INVALIDARG;
	}

	*ppv = 0;

	if (riid == IID_ISimpleTableWrite2 )
	{
		*ppv = (ISimpleTableWrite2*) this;
	}
	else if (riid == IID_ISimpleTableRead2 )
	{
		*ppv = (ISimpleTableRead2 *) this;
	}
	else if (riid == IID_ISimpleTableAdvanced )
	{
		*ppv = (ISimpleTableAdvanced *) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableWrite2 *) this;
	}
	else
	{
		return E_NOINTERFACE;
	}

	((ISimpleTableWrite2*)this)->AddRef ();

	return S_OK;
}


//=================================================================================
// Function: CMergeCoordinator::Initialize
//
// Synopsis: Initializes the merge coordinator:
//           1) Create the merge coordinator cache
//           2) Get column meta information (nr columns, pk information)
//           3) Get the transformer, and retrieve the configuration stores from it
//           4) Create the merger and initialize it
//           5) Return pointer to itself as ISimpleTableWrite2
//
// Arguments: [i_wszDatabase] - Database name
//            [i_wszTable] - Table name	
//            [i_TableID] - Table ID (calculated by the interceptor code)
//            [i_QueryData] - Query data information
//            [i_QueryMeta] - query meta information (nr of query cells in iQueryData)
//            [i_eQueryFormat] - eST_FORMAT_QUERYCELLS is the only thing we support
//            [i_fLOS] - Level of Service
//            [i_pISTDisp] - pointer to the dispenser, so we can call back into the dispenser
//            [o_ppv] - Assign the merge coordinator pointer to this when everything succeeds
//            
// Return Value: 
//=================================================================================
HRESULT
CMergeCoordinator::Initialize (LPCWSTR i_wszDatabase, 
							   LPCWSTR i_wszTable,
							   ULONG i_TableID,
							   LPVOID i_QueryData,
							   LPVOID i_QueryMeta,
							   DWORD i_eQueryFormat,
							   DWORD i_fLOS,
							   IAdvancedTableDispenser *i_pISTDisp,
							   LPVOID *o_ppv)
{
	HRESULT hr = S_OK;

	ASSERT (i_wszDatabase != 0);
	ASSERT (i_wszTable != 0);
	ASSERT (i_pISTDisp != 0);
	ASSERT (i_eQueryFormat == eST_QUERYFORMAT_CELLS);
	ASSERT (i_QueryData != 0);
	ASSERT (i_QueryMeta != 0);
	ASSERT (i_pISTDisp != 0);
	ASSERT (o_ppv != 0);

	*o_ppv		= 0;
	m_spSTDisp	= i_pISTDisp;
	m_TableID	= i_TableID;
	m_fLOS		= i_fLOS;

	m_wszDatabase = new WCHAR[wcslen(i_wszDatabase) + 1];
	if (m_wszDatabase == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszDatabase, i_wszDatabase);

	m_wszTable = new WCHAR[wcslen(i_wszTable) + 1];
	if (m_wszTable == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszTable, i_wszTable);

	// copy the query cells. We need the in PopulateCache to forward to the interceptors
	m_cNrQueryCells = *static_cast<ULONG *>(i_QueryMeta);
	ASSERT (m_cNrQueryCells > 0); // need to be at least one, because of transformer string

	m_aQueryData   = new STQueryCell[m_cNrQueryCells];
	if (m_aQueryData == 0)
	{
		return E_OUTOFMEMORY;
	}
	memcpy (m_aQueryData, i_QueryData, m_cNrQueryCells * sizeof (STQueryCell));

	hr = GetConfigStores ();
	if (FAILED (hr))
	{
		TRACE(L"Unable to get configuration store information in merge coordinator");
		return hr;
	}

	// special case: when we have only one configuration store, we immediately forward the
	// query to that configuration store. This means that the merge interceptor goes out
	// of existance as soon as this function returns.
	if (m_cNrRealStores == 1 && m_cNrPossibleStores == 1)
	{
		ULONG cTotalCells = m_cNrQueryCells + m_aConfigStores[0].cNrQueryCells - 1;
		TSmartPointerArray<STQueryCell> aQueryData = new STQueryCell [cTotalCells]; 
		if (aQueryData == 0)
		{
			return E_OUTOFMEMORY;
		}
		memcpy (aQueryData.m_p, m_aQueryData, sizeof (STQueryCell) * m_iSelectorCell);
		memcpy (aQueryData.m_p + m_iSelectorCell, m_aConfigStores[0].aQueryCells, m_aConfigStores[0].cNrQueryCells * sizeof (STQueryCell));
		memcpy (aQueryData.m_p + m_iSelectorCell + m_aConfigStores[0].cNrQueryCells, m_aQueryData + m_iSelectorCell + 1, (m_cNrQueryCells - m_iSelectorCell - 1) * sizeof (STQueryCell));

		// we need to pass the fST_LOS_REPOPULATE and fST_LOS_UNPOPULATED flags to
		// avoid populating the table twice. The reason is that GetTable calls
		// Populate cache. However, when the merge interceptor returns, the o_ppv pointer
		// points to the single table. The Dispenser calls populatecache again. To avoid
		// this from happening we use the fST_LOS_UNPOPULATED flag to indicate that the
		// first populate cache shouldn't populate the cache. The F_ST_LOS_REPOPULATE flag
		// indicates that the second populate will be successful.
		return m_spSTDisp->GetTable (i_wszDatabase, i_wszTable, 
									(void *) aQueryData, (void *) &cTotalCells,
									eST_QUERYFORMAT_CELLS, 
									m_fLOS | fST_LOS_REPOPULATE | fST_LOS_UNPOPULATED, 
									o_ppv);
	}
	
	// we use a memory table for the internal cache of the merge coordinator
	hr = i_pISTDisp->GetMemoryTable (m_wszDatabase, m_wszTable, m_TableID, 
									 0, 0, eST_QUERYFORMAT_CELLS, m_fLOS, &m_spMemTable );
	if (FAILED(hr))
	{
		TRACE (L"Unable to retrieve memory table in Merge Coordinator");
		return hr;
	}

	hr = GetPKInfo ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Primary key information for table %s", i_wszTable);
		return hr;
	}

	hr = GetMerger ();
	if (FAILED (hr))
	{
		TRACE(L"Unable to retrieve merger in merge coordinator");
		return hr;
	}

	*o_ppv = (ISimpleTableWrite2 *) this;
	AddRef();

	return hr;
}

//=================================================================================
// Function: CMergeCoordinator::GetPKInfo
//
// Synopsis: Gets the primary key information for the current table. We need to find
//           out which columns form the primary key, so that we can do quick searches
//           on primary key values. This function gets called during initialize, and we
//           cache the primary key column values, so that we do not have to recalculate
//           this information all the time.
//
// Return Value: 
//=================================================================================
HRESULT 
CMergeCoordinator::GetPKInfo ()
{
	HRESULT hr = GetTableMeta (0,0,0, &m_cNrColumns);
	if (FAILED (hr))
	{
		TRACE (L"Unable to retrieve Table Meta for table %s", m_wszTable);
		return hr;
	}

	ASSERT (m_cNrColumns > 0);

	TSmartPointerArray<SimpleColumnMeta> saColumnMeta = new SimpleColumnMeta[m_cNrColumns];
	if (saColumnMeta == 0)
	{
		return E_OUTOFMEMORY;
	}

	// Assume that all columns are part of the PK. We reserve a little bit more memory,
	// however, this migh not be a big problem.

	TSmartPointerArray<ULONG> saPKColumns = new ULONG[m_cNrColumns];
	if (saPKColumns == 0)
	{
		return E_OUTOFMEMORY;
	}

	// find out what the primary key columns are
	hr = GetColumnMetas (m_cNrColumns, 0, saColumnMeta);
	if (FAILED (hr))
	{
		TRACE (L"Unable to retrieve column meta for table %s", m_wszTable );
		return hr;
	}

	ASSERT (m_cNrPKColumns == 0);

	for (ULONG idx = 0; idx < m_cNrColumns; ++idx)
	{
		if (saColumnMeta[idx].fMeta & fCOLUMNMETA_PRIMARYKEY)
		{
			saPKColumns[m_cNrPKColumns] = idx;
			m_cNrPKColumns++;
		}
	}

	// Is this a valid assumption. In the future, when PK's are not needed anymore, this
	// won't work.
	ASSERT (m_cNrPKColumns > 0);

	m_aPKColumns = new ULONG [m_cNrPKColumns ];
	if (m_aPKColumns == 0)
	{
		return E_OUTOFMEMORY;
	}

	memcpy (m_aPKColumns, saPKColumns, m_cNrPKColumns * sizeof (ULONG));

	m_aPKValues = new LPVOID [m_cNrPKColumns];
	if (m_aPKValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	return hr;
}

//=================================================================================
// Function: CMergeCoordinator::GetTableMeta
//
// Synopsis: Get Table meta information
//
// Arguments: [o_pcVersion] - not supported
//            [o_pfTable] - not supported
//            [o_pcRows] - Number of rows in merged table
//            [o_pcColumns] - Number of columns
//            
// Return Value: 
//=================================================================================
STDMETHODIMP
CMergeCoordinator::GetTableMeta (ULONG *o_pcVersion, DWORD *o_pfTable, ULONG *o_pcRows,
								 ULONG *o_pcColumns)
{
	return m_spMemTable->GetTableMeta (o_pcVersion, o_pfTable, o_pcRows, o_pcColumns);
}

//=================================================================================
// Function: CMergeCoordinator::GetColumnMetas
//
// Synopsis: Get Column Meta information
//
// Arguments: [i_cColumns] - number of columns for which you want information
//            [i_aiColumns] - array with column indexes for which we want information
//            [o_aColumnMetas] - array that will contain column meta information when 
//								 function returns
//            
// Return Value: 
//=================================================================================
STDMETHODIMP
CMergeCoordinator::GetColumnMetas (ULONG i_cColumns, ULONG *i_aiColumns, 
								   SimpleColumnMeta *o_aColumnMetas)
{
	return m_spMemTable->GetColumnMetas (i_cColumns, i_aiColumns, o_aColumnMetas);
}

//=================================================================================
// Function: CMergeCoordinator::GetColumnValues
//
// Synopsis: Get Column values for a particular row in the merge cache
//
// Arguments: [i_iRow] - row that we're interested in
//            [i_cColumns] - Number of columns that we are interested in
//            [i_aiColumns] - array with column indexes for columns we want info
//            [o_acbSizes] - sizes of columns for which we want info
//            [o_apvValues] - values of the columns
//            
// Return Value: 
//=================================================================================
STDMETHODIMP
CMergeCoordinator::GetColumnValues (ULONG i_iRow, ULONG i_cColumns, ULONG *i_aiColumns,
									 ULONG *o_acbSizes, LPVOID* o_apvValues)
{
	return m_spMemTable->GetColumnValues (i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
}

//=================================================================================
// Function: CMergeCoordinator::GetRowIndexByIdentity
//
// Synopsis: Get a row by primary key
//
// Arguments: [i_cb] - always null
//            [i_pv] - primary key column values
//            [o_piRow] - index of row that 
//            
// Return Value: E_ST_NOMOREROWS, row was not found, S_OK, row was found, everything else
//               indicates an error
//=================================================================================
STDMETHODIMP
CMergeCoordinator::GetRowIndexByIdentity (ULONG *i_cb, LPVOID *i_pv, ULONG *o_piRow)
{
	return m_spMemTable->GetRowIndexByIdentity (i_cb, i_pv, o_piRow);
}

//=================================================================================
// Function: CMergeCoordinator::GetRowIndexBySearch
//
// Synopsis: ?
//
// Arguments: [i_iStartingRow] - 
//            [i_cColumns] - 
//            [i_aiColumns] - 
//            [i_acbSizes] - 
//            [i_apvValues] - 
//            [o_piRow] - 
//            
// Return Value: 
//=================================================================================
STDMETHODIMP
CMergeCoordinator::GetRowIndexBySearch (ULONG i_iStartingRow, ULONG i_cColumns,
										ULONG *i_aiColumns, ULONG * i_acbSizes,
										LPVOID *i_apvValues, ULONG *o_piRow)
{
	return m_spMemTable->GetRowIndexBySearch (i_iStartingRow, i_cColumns, i_aiColumns,
											  i_acbSizes, i_apvValues, o_piRow);
}

//=================================================================================
// Function: CMergeCoordinator::AddRowForDelete
//
// Synopsis: Add a row for deletion to the write cache
//
// Arguments: [i_iReadRow] - index of readrow in read cache that we want to delete
//=================================================================================
STDMETHODIMP
CMergeCoordinator::AddRowForDelete (ULONG i_iReadRow)
{
	// we don't support writing into merged views for the moment

	return E_ST_LOSNOTSUPPORTED;

	//return m_spMemTable->AddRowForDelete (i_iReadRow);
}

//=================================================================================
// Function: CMergeCoordinator::AddRowForInsert
//
// Synopsis: Insert a new row in the write cache
//
// Arguments: [o_piWriteRow] - index of the write row
//            
// Return Value: S_OK, everything ok, non-S_OK else
//=================================================================================
STDMETHODIMP
CMergeCoordinator::AddRowForInsert (ULONG *o_piWriteRow)
{	
	// we don't support writing into merged views for the moment

	return E_ST_LOSNOTSUPPORTED;
	
	//return m_spMemTable->AddRowForInsert (o_piWriteRow);
}

//=================================================================================
// Function: CMergeCoordinator::AddRowForUpdate
//
// Synopsis: Add read row to write cache, and mark the row for update
//
// Arguments: [i_iReadRow] - index of read row in read cache
//            [o_piWriteRow] - index of write row in write cache
//            
// Return Value: S_OK, everything ok, error else
//=================================================================================
STDMETHODIMP
CMergeCoordinator::AddRowForUpdate (ULONG i_iReadRow, ULONG *o_piWriteRow)
{
	// we don't support writing into merged views for the moment
	return E_ST_LOSNOTSUPPORTED;

	//return m_spMemTable->AddRowForUpdate (i_iReadRow, o_piWriteRow);
}

//=================================================================================
// Function: CMergeCoordinator::UpdateStore
//
// Synopsis: Updates the mergecoordinator cache and the updateable store cache. It
//           walks through all the row in the merge coordinator caches, and for each
//           row, it will do an insert/delete/update in the updateable store cache, 
//           depending on the flag for that particular row. After all rows are processed,
//           UpdateStore is called fo rthe updateable cache. When everything succeeds, we
//           will update the cache of the merge coordinator as well.
//
// Return Value: S_OK, everything ok, error else
//=================================================================================
STDMETHODIMP
CMergeCoordinator::UpdateStore ()
{
	HRESULT hr = S_OK;

	// spMemtable exposes the controller interface as well. Use that to get more advanced
	// information about the write cache
	CComPtr<ISimpleTableController> spController;
	hr = m_spMemTable->QueryInterface (IID_ISimpleTableController, (void **) &spController);
	if (FAILED (hr))
	{
		TRACE (L"QI for IID_ISimpleTableController failed for merge coordinator cache");
		return hr;
	}

	TSmartPointerArray<LPVOID> spValues = new LPVOID[m_cNrColumns];
	if (spValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	// walk through all the rows in the write cache, and do the correct thing (update/delete/insert)
	// depending on the row action flag
	for (ULONG iRow=0;; ++iRow)
	{
		hr = m_spMemTable->GetWriteColumnValues (iRow, m_cNrColumns, 0, 0, 0, spValues);
		if (hr == E_ST_NOMOREROWS)
		{
			hr = S_OK;
			break;
		}
		if (FAILED (hr))
		{
			TRACE (L"Error during GetWriteColumnValues of merge coordinator cache");
			return hr;
		}

		DWORD eAction;
		hr  = spController->GetWriteRowAction (iRow, &eAction);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get writeRowAction for row %ld in merge cache", iRow);
			return hr;
		}

		switch (eAction)
		{
		case eST_ROW_INSERT:
			hr = InsertRow (spValues);
			break;
		case eST_ROW_UPDATE:
			hr = UpdateRow (spValues);
			break;
		case eST_ROW_DELETE:
			hr = DeleteRow (spValues);
			break;
		case eST_ROW_IGNORE:
			// do nothing, simply continue
			break;
		default:
			ASSERT (false);
			break;
		}

		if (FAILED (hr))
		{
			TRACE (L"Unable to update updatable store for row %d", iRow);
			return hr;
		}
	}

	// We've populated the write cache of the updateable store. Lets sync the stuff.

	hr = m_spUpdateStore->UpdateStore ();
	if (hr == E_ST_DETAILEDERRS)
	{
		hr = HandleUpdateableStoreErrors ();
		return hr;
	}
	if (FAILED (hr))
	{
		TRACE (L"UpdateStore for updateable store failed in Merge Coordinator");
		return hr;
	}

	hr = m_spMemTable->UpdateStore ();
	if (FAILED (hr))
	{
		TRACE (L"Updatestore of Merge Coordinator cache failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CMergeCoordinator::GetWriteColumnValues
//
// Synopsis: Get Column values for a row in the write cache
//
// Arguments: [i_iRow] - row in write cache we're interested in
//            [i_cColumns] - nr of columns for which we want the values
//            [i_aiColumns] - array with column indexes
//            [o_afStatus] - status of the columns
//            [o_acbSizes] - sizes of the columns
//            [o_apvValues] - values of the columns
//=================================================================================
STDMETHODIMP
CMergeCoordinator::GetWriteColumnValues (ULONG i_iRow, ULONG i_cColumns,
										 ULONG *i_aiColumns, DWORD *o_afStatus,
										 ULONG *o_acbSizes, LPVOID *o_apvValues)
{
	return m_spMemTable->GetWriteColumnValues (i_iRow, i_cColumns, i_aiColumns,
											  o_afStatus, o_acbSizes, o_apvValues);
}

//=================================================================================
// Function: CMergeCoordinator::SetWriteColumnValues
//
// Synopsis: Sets the values of a row in the write cache
//
// Arguments: [i_iRow] - index of row in write cache that we want to update
//            [i_cColumns] - number of columns that we want to set value for
//            [i_aiColumns] - array with column indexes
//            [o_acbSizes] - array with column sizes
//            [i_apvValues] - array with column values
//            
// Return Value: 
//=================================================================================
STDMETHODIMP
CMergeCoordinator::SetWriteColumnValues (ULONG i_iRow, ULONG i_cColumns,
										 ULONG *i_aiColumns, ULONG *i_acbSizes,
										 LPVOID *i_apvValues)
{
	return m_spMemTable->SetWriteColumnValues (i_iRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues);
}

//=================================================================================
// Function: CMergeCoordinator::GetWriteRowIndexByIdentity
//
// Synopsis: Get row from write cache by primary key
//
// Arguments: [i_cbSizes] - always null 
//            [i_apvValues] - primary key column values
//            [o_piRow] - index of row in write cache that has this primary key
//            
// Return Value: E_ST_NOMOREROWS, nothing found, S_OK, element found, other hr, error
//=================================================================================
STDMETHODIMP
CMergeCoordinator::GetWriteRowIndexByIdentity (ULONG *i_cbSizes, LPVOID *i_apvValues,
											   ULONG *o_piRow)
{
	return m_spMemTable->GetWriteRowIndexByIdentity (i_cbSizes, i_apvValues, o_piRow);
}

//=================================================================================
// Function: CMergeCoordinator::GetWriteRowIndexBySearch
//
// Synopsis: ?
//
// Arguments: [i_iStartingRow] - 
//            [i_cColumns] - 
//            [i_aiColumns] - 
//            [i_acbSizes] - 
//            [i_apvValues] - 
//            [o_piRow] - 
//            
// Return Value: 
//=================================================================================
STDMETHODIMP
CMergeCoordinator::GetWriteRowIndexBySearch (ULONG i_iStartingRow, ULONG i_cColumns,
											 ULONG *i_aiColumns, ULONG * i_acbSizes,
											 LPVOID *i_apvValues, ULONG *o_piRow)
{
	return m_spMemTable->GetWriteRowIndexBySearch (i_iStartingRow, i_cColumns, i_aiColumns,
									  			   i_acbSizes, i_apvValues, o_piRow);
}

STDMETHODIMP
CMergeCoordinator::GetErrorTable
(
    DWORD   i_fServiceRequests,
    LPVOID* o_ppvSimpleTable
)
{
    return m_spMemTable->GetErrorTable(i_fServiceRequests, o_ppvSimpleTable);
}

//=================================================================================
// Function: CMergeCoordinator::PopulateCache
//
// Synopsis: This function retrieves the information from all configuration stores, and
//           instructs the merger to do the merging. It keeps the last configuration store
//           as updateable store.
//
// Return Value: 
//=================================================================================
STDMETHODIMP
CMergeCoordinator::PopulateCache ()
{
	ASSERT (m_cNrRealStores > 0);

	CComQIPtr<ISimpleTableController, &IID_ISimpleTableController> spISTController = m_spMemTable;
	HRESULT hr = spISTController->PrePopulateCache (0);
	if (FAILED (hr))
	{
		TRACE (L"Prepopulate cache for merge coordinator cache failed");
		return hr;
	}

	STMergeContext mergeContext;
	mergeContext.fAllowOverride = true;

	// loop through all configuration stores, and get the information
	for (ULONG idx = 0; idx < m_cNrRealStores; ++idx)
	{
		CComPtr<ISimpleTableRead2> spRead;
		ULONG cTotalCells = m_cNrQueryCells + m_aConfigStores[idx].cNrQueryCells - 1;
		TSmartPointerArray<STQueryCell> aQueryData = new STQueryCell [cTotalCells]; 
		if (aQueryData == 0)
		{
			return E_OUTOFMEMORY;
		}
		memcpy (aQueryData.m_p, m_aQueryData, sizeof (STQueryCell) * m_iSelectorCell);
		memcpy (aQueryData.m_p + m_iSelectorCell, m_aConfigStores[idx].aQueryCells, m_aConfigStores[idx].cNrQueryCells * sizeof (STQueryCell));
		memcpy (aQueryData.m_p + m_iSelectorCell + m_aConfigStores[idx].cNrQueryCells, m_aQueryData + m_iSelectorCell + 1, (m_cNrQueryCells - m_iSelectorCell - 1) * sizeof (STQueryCell));

		hr = m_spSTDisp->GetTable (	m_wszDatabase, 
									m_wszTable, 
									(void *) aQueryData,
									(void *) &cTotalCells,
									eST_QUERYFORMAT_CELLS,
									m_fLOS,
								    (void **)&spRead);
		if (FAILED (hr))
		{
			TRACE (L"GetTable failed for configuration store in merge coordinator");
			return hr;
		}

		// when we reach here the first time, the cache is empty. Instead of invoking the
		// merger, and doing a lot of work there, we simply copy the information from the
		// table to the cache. This is done in CopyTable.
		if (idx == 0)
		{
			hr = CopyTable (spRead, m_spMemTable);
			if (FAILED (hr))
			{
				TRACE (L"CopyTable failed in merge coordinator");
				return hr;
			}
		}
		else
		{	
			hr = m_spMerger->Merge (spRead, m_spMemTable, &mergeContext );
			if (FAILED (hr))
			{
				TRACE (L"Merge failed in merge coordinator");
				return hr;
			}
		}

		// and set the override property. This will ensure that the next merge checks if overrides
		// are allowed or not. Do this only when fAllowOverride is still true.

		if (mergeContext.fAllowOverride)
		{
			mergeContext.fAllowOverride = m_aConfigStores[idx].fAllowOverride;
		}

		// keep the last interceptor for updates.
		if (idx == m_cNrRealStores - 1)
		{
			hr = spRead->QueryInterface (IID_ISimpleTableWrite2, (void **)&m_spUpdateStore);
			if (FAILED (hr))
			{
				TRACE(L"Unable to get interface pointer to updateable store");
				return hr;
			}
		}
	}

	// PostPopulateCache converts the read rows into write rows.
	hr = spISTController->PostPopulateCache ();
	if (FAILED (hr))
	{
		TRACE(L"PostPopulateCache failed for merge coordinator cache");
		return hr;
	}

	return hr;
}

STDMETHODIMP
CMergeCoordinator::GetDetailedErrorCount (ULONG *o_pcErrs)
{
	CComQIPtr<ISimpleTableAdvanced, &IID_ISimpleTableAdvanced> spISTAdvanced = m_spMemTable;	
	return spISTAdvanced->GetDetailedErrorCount (o_pcErrs);
}

STDMETHODIMP
CMergeCoordinator::GetDetailedError (ULONG i_iErr, STErr *o_pSTErr)
{
	CComQIPtr<ISimpleTableAdvanced, &IID_ISimpleTableAdvanced> spISTAdvanced = m_spMemTable;	
	return spISTAdvanced->GetDetailedError (i_iErr, o_pSTErr);
}

//=================================================================================
// Function: CMergeCoordinator::GetTransformerString
//
// Synopsis: Get the transformer string, and extract the protocol and selector. The
//           protocol and selecor are stored in object variables.
//            
// Return Value: E_ST_INVALIDSELECTOR		Invalid selector specified
//               E_ST_MULTIPLESELECTOR	    Multiple selectors specified
//               S_OK						Everything ok
//=================================================================================
HRESULT 
CMergeCoordinator::GetTransformerString ()
{
	// the caller must assure that there is at least a selector string in the query meta
	ASSERT (m_cNrQueryCells != 0);
	ASSERT (m_aQueryData != 0);

	// ensure that local that we are not initialized yet
	ASSERT (m_wszProtocol == 0);
	ASSERT (m_wszSelector == 0);
	ASSERT (m_iSelectorCell == 0);

	static LPCWSTR wszProtocolSeperator = L"://";
	bool bFound = false;
	// walk through all the query cells and find a transformer. If more than one transformer
	// is found, we return an error message
	for (ULONG idx=0; idx < m_cNrQueryCells; ++idx)
	{
		if (m_aQueryData[idx].iCell == iST_CELL_SELECTOR)
		{
			if (bFound)
			{
				// multiple transformer strings found. Give up
				TRACE (L"Multiple Selector strings found in query cells");
				return E_ST_MULTIPLESELECTOR;
			}

			LPWSTR wszSelector = (LPWSTR) m_aQueryData[idx].pData;
			LPWSTR wszProtocolStart = wcsstr(wszSelector, wszProtocolSeperator);
			if ((wszProtocolStart == 0) || (wszProtocolStart == wszSelector))
			{
				TRACE (L"Invalid selector string: %s. No protocol found\n", wszSelector);
				return E_ST_INVALIDSELECTOR;
			}

			size_t iProtocolLen = wszProtocolStart - wszSelector;
			ASSERT (iProtocolLen > 0);
			m_wszProtocol = new WCHAR[iProtocolLen + 1];
			if (m_wszProtocol == 0)
			{
				return E_OUTOFMEMORY;
			}
			wcsncpy (m_wszProtocol, wszSelector, iProtocolLen);
			m_wszProtocol[iProtocolLen] = L'\0';
			
			SIZE_T iSelectorLen = wcslen (wszProtocolStart) - wcslen (wszProtocolSeperator );
			m_wszSelector = new WCHAR[iSelectorLen + 1];
			if (m_wszSelector == 0)
			{
				return E_OUTOFMEMORY;
			}

			wcscpy (m_wszSelector, wszProtocolStart + wcslen (wszProtocolSeperator ));

			if (!IsValidSelector (m_wszSelector))
			{
				TRACE (L"Selector is invalid: %s", wszSelector);
				return E_ST_INVALIDSELECTOR;
			}
			
			bFound = true;

			// and set the selector cell so that we know which one to replace when we
			// call gettable on the individual stores
			m_iSelectorCell = idx;
		}
	}

	// we always find a selector, else the caller shouldn't call this function in the
	// first place
	ASSERT (bFound);

	return S_OK;
}

//=================================================================================
// Function: CMergeCoordinator::GetConfigStores
//
// Synopsis: This function uses the transformerstring passed into the query cells
//           to find the correct transformer. After the transformer is created, it
//           will call Intialize and GetConfigStores on it to get the configuration 
//           stores.
//
// Return Value: S_OK if everything ok, error else
//=================================================================================
HRESULT
CMergeCoordinator::GetConfigStores ()
{
	HRESULT hr = GetTransformerString ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to get transformerstring from selector");
		return hr;
	}

	hr = GetTransformer ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to retrieve correct transformer in selector");
		return hr;
	}

	hr = m_spTransformer->Initialize (m_spSTDisp, m_wszProtocol, m_wszSelector, &m_cNrRealStores, &m_cNrPossibleStores);
	if (FAILED (hr))
	{
		TRACE (L"Transformer initialization failed");
		return hr;
	}

	ASSERT (m_cNrPossibleStores >= m_cNrRealStores);

	// when we have 0 stores, we do not have to do anything
	if (m_cNrRealStores == 0)
	{
		TRACE (L"Transformer did not find any configuration stores");
		return E_ST_NOCONFIGSTORES;
	}
	
	m_aConfigStores = new CSTConfigStoreWrap[m_cNrRealStores];
	if (m_aConfigStores == 0)
	{
		return E_OUTOFMEMORY;
	}

	hr = m_spTransformer->GetRealConfigStores (m_cNrRealStores, m_aConfigStores);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get configuration stores from transformer");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CMergeCoordinator::InsertRow
//
// Synopsis: Insert a row in the updateable store
//
// Arguments: [i_pValues] - values for the row to be inserted
//            
// Return Value: 
//=================================================================================
HRESULT
CMergeCoordinator::InsertRow (LPVOID *i_pValues)
{
	ASSERT (i_pValues != 0);
	HRESULT hr = S_OK;

	ULONG iWriteRow;
	hr = m_spUpdateStore->AddRowForInsert (&iWriteRow);
	if (FAILED (hr))
	{
		TRACE(L"Insert into updateable store failed");
		return hr;
	}

	hr = m_spUpdateStore->SetWriteColumnValues (iWriteRow, m_cNrColumns, 0, 0, i_pValues);
	if (FAILED (hr))
	{
		TRACE(L"SetWriteColumnValues failed during insert into updateable store");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CMergeCoordinator::UpdateRow
//
// Synopsis: This function tries to update a row in the updateable store. First, the
//           function checks if the row already exists in the updateable store. If it
//           exists is does an update. When the row does not exist, it must have come
//           from another store, meaning that the function will do an insert instead.
//
// Arguments: [i_pValues] - Values of the row that will be updated
//            
// Return Value: 
//=================================================================================
HRESULT
CMergeCoordinator::UpdateRow (LPVOID *i_pValues)
{
	ASSERT (i_pValues != 0);
	HRESULT hr = S_OK;

	ASSERT (i_pValues != 0);

	memset (m_aPKValues, 0x00, m_cNrPKColumns * sizeof (LPVOID));

	for (ULONG idx = 0; idx < m_cNrPKColumns; ++idx)
	{
		m_aPKValues[idx] = i_pValues[m_aPKColumns[idx]];
	}
	
	ULONG iReadRow;
	ULONG iWriteRow;

	hr = m_spUpdateStore->GetRowIndexByIdentity (0, m_aPKValues, &iReadRow);
	if (hr == E_ST_NOMOREROWS)
	{
		// new row, lets insert
		return InsertRow (i_pValues);
	}

	if (FAILED (hr))
	{
		TRACE (L"GetRowIndexByIdentity failed during update of updateable store");
		return hr;
	}

	hr = m_spUpdateStore->AddRowForUpdate (iReadRow, &iWriteRow);
	if (FAILED (hr))
	{
		TRACE (L"AddRowForUpdate failed for updateable store");
		return hr;
	}

	hr = m_spUpdateStore->SetWriteColumnValues (iWriteRow, m_cNrColumns, 0, 0, i_pValues);
	if (FAILED (hr))
	{
		TRACE (L"SetWriteColumnValues failed for updateable store");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CMergeCoordinator::DeleteRow
//
// Synopsis: Deletes a row from the updateable cache. First, the function checks if
//           the row existed in this store. This is needed, because it is possible that
//           the row came from another config store. If the row is found in the updataeble
//           store, the row is deleted. If it is not found, we simple ignore the deletion.
//
// Arguments: [i_pValues] - Values of the row that is going to be deleted
//            
// Return Value: 
//=================================================================================
HRESULT
CMergeCoordinator::DeleteRow (LPVOID *i_pValues)
{
	ASSERT (i_pValues != 0);

	memset (m_aPKValues, 0x00, sizeof (LPVOID) * m_cNrPKColumns);

	for (ULONG idx = 0; idx < m_cNrPKColumns; ++idx)
	{
		m_aPKValues[idx] = i_pValues[m_aPKColumns[idx]];
	}
	
	ULONG iReadRow;

	HRESULT	hr = m_spUpdateStore->GetRowIndexByIdentity (0, m_aPKValues, &iReadRow);
	if (hr == E_ST_NOMOREROWS)
	{
		// row does not exist, so nothing to delete
		return S_OK;
	}

	if (FAILED (hr))
	{
		TRACE (L"GetRowIndexByIdentity failed in deleting row in updateable store");
		return hr;
	}

	hr = m_spUpdateStore->AddRowForDelete (iReadRow);
	if (FAILED (hr))
	{
		TRACE (L"Unable to delete row %d in updateable store", iReadRow);
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CMergeCoordinator::CopyTable
//
// Synopsis: Copy the information from the table pointed to by i_pRead to io_pWrite.
//
// Arguments: [i_pRead] - Table to get information from
//            [io_pWrite] - Table to copy information to
//=================================================================================
HRESULT
CMergeCoordinator::CopyTable (ISimpleTableRead2 *i_pRead, ISimpleTableWrite2 *io_pWrite)
{
	ASSERT (i_pRead  != 0);
	ASSERT (io_pWrite != 0);
	ASSERT (m_cNrColumns != 0);

	// simply copy the information from pRead to pWrite
	HRESULT hr = S_OK;

	TSmartPointerArray<LPVOID> apvValues = new LPVOID[m_cNrColumns];
	if (apvValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	for (ULONG iRow = 0; ;++iRow)
	{
		hr = i_pRead->GetColumnValues(iRow, m_cNrColumns, 0, 0, apvValues);
		if (hr == E_ST_NOMOREROWS)
		{
			hr = S_OK;
			break;
		}

		ULONG iWriteRow;
		hr = io_pWrite->AddRowForInsert (&iWriteRow);
		if (FAILED (hr))
		{
			TRACE (L"Unable to insert new row in MC Cache during FastMerge");
			return hr;
		}

		hr = io_pWrite->SetWriteColumnValues (iWriteRow, m_cNrColumns, 0, 0, apvValues );
		if (FAILED(hr))
		{
			TRACE (L"SetWriteColumnValues failed during FastMerge");
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CMergeCoordinator::HandleUpdateableStoreErrors
//
// Synopsis: Move the detailed errors from the updateable cache to the Merge Coordinator
//			 cache, so that when the client asks for the detailed errors, they can be
//           exposed to the client via the Merge Coordinator
//=================================================================================
HRESULT
CMergeCoordinator::HandleUpdateableStoreErrors ()
{
	// need to fill up the detailed errors in memory cache
	CComQIPtr<ISimpleTableController, &IID_ISimpleTableController> spISTController = m_spMemTable;	

	CComPtr<ISimpleTableAdvanced> spISTUpdateAdvanced;

	HRESULT hr = m_spUpdateStore->QueryInterface (IID_ISimpleTableAdvanced, (void 